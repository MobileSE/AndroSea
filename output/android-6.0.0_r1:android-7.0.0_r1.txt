Find a silently evolved API code:android.net.Uri.checkFileUriExposed:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * If this is a {@code file://} Uri, it will be reported to
 * {@link StrictMode}.
 *
 * @hide
 */

Body of Frist Method:
{
    if ("file".equals(getScheme())) {
        StrictMode.onFileUriExposed(location);
    }
}
Body of Second Method:
{
    if ("file".equals(getScheme()) && !getPath().startsWith("/system/")) {
        StrictMode.onFileUriExposed(this, location);
    }
}
------------------------
Find a silently evolved API code:android.content.res.TypedArray.getDimensionPixelSize:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve a dimensional unit attribute at <var>index</var> for use
 * as a size in raw pixels.  This is the same as
 * {@link #getDimension}, except the returned value is converted to
 * integer pixels for use as a size.  A size conversion involves
 * rounding the base value, and ensuring that a non-zero base value
 * is at least one pixel in size.
 * <p>
 * This method will throw an exception if the attribute is defined but is
 * not a dimension.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute dimension value multiplied by the appropriate
 * metric and truncated to integer pixels, or defValue if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not a dimension.
 *
 * @see #getDimension
 * @see #getDimensionPixelOffset
 */

Body of Frist Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimensionPixelSize(data[index + AssetManager.STYLE_DATA], mMetrics);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index * AssetManager.STYLE_NUM_ENTRIES, value);
        throw new UnsupportedOperationException("Failed to resolve attribute at index " + index + ": " + value);
    }
    throw new UnsupportedOperationException("Can't convert to dimension: type=0x" + Integer.toHexString(type));
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    final int attrIndex = index;
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimensionPixelSize(data[index + AssetManager.STYLE_DATA], mMetrics);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index, value);
        throw new UnsupportedOperationException("Failed to resolve attribute at index " + attrIndex + ": " + value);
    }
    throw new UnsupportedOperationException("Can't convert value at index " + attrIndex + " to dimension: type=0x" + Integer.toHexString(type));
}
------------------------
Find a silently evolved API code:android.net.LocalSocketImpl.shutdownOutput:COMMENT
Method Modifier: protected   
Comment:/**
 * Shuts down the output side of the socket.
 *
 * @throws IOException
 */

Body of Frist Method:
{
    if (fd == null) {
        throw new IOException("socket not created");
    }
    shutdown(fd, false);
}
Body of Second Method:
{
    if (fd == null) {
        throw new IOException("socket not created");
    }
    try {
        Os.shutdown(fd, OsConstants.SHUT_WR);
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
}
------------------------
Find a silently evolved API code:android.app.ActivityManager.getPackageImportance:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Return the importance of a given package name, based on the processes that are
 * currently running.  The return value is one of the importance constants defined
 * in {@link RunningAppProcessInfo}, giving you the highest importance of all the
 * processes that this package has code running inside of.  If there are no processes
 * running its code, {@link RunningAppProcessInfo#IMPORTANCE_GONE} is returned.
 * @hide
 */

Body of Frist Method:
{
    try {
        int procState = ActivityManagerNative.getDefault().getPackageProcessState(packageName, mContext.getOpPackageName());
        return RunningAppProcessInfo.procStateToImportance(procState);
    } catch (RemoteException e) {
        return RunningAppProcessInfo.IMPORTANCE_GONE;
    }
}
Body of Second Method:
{
    try {
        int procState = ActivityManagerNative.getDefault().getPackageProcessState(packageName, mContext.getOpPackageName());
        return RunningAppProcessInfo.procStateToImportance(procState);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiEnterpriseConfig.resetCaCertificate:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    mCaCert = null;
}
Body of Second Method:
{
    mCaCerts = null;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothAdapter.getState:COMMENT
Method Modifier: public      
Comment:/**
 * Get the current state of the local Bluetooth adapter.
 * <p>Possible return values are
 * {@link #STATE_OFF},
 * {@link #STATE_TURNING_ON},
 * {@link #STATE_ON},
 * {@link #STATE_TURNING_OFF}.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}
 *
 * @return current state of Bluetooth adapter
 */

Body of Frist Method:
{
    try {
        synchronized (mManagerCallback) {
            if (mService != null) {
                int state = mService.getState();
                if (VDBG)
                    Log.d(TAG, "" + hashCode() + ": getState(). Returning " + state);
                // consider all internal states as OFF
                if (state == BluetoothAdapter.STATE_BLE_ON || state == BluetoothAdapter.STATE_BLE_TURNING_ON || state == BluetoothAdapter.STATE_BLE_TURNING_OFF) {
                    if (VDBG)
                        Log.d(TAG, "Consider internal state as OFF");
                    state = BluetoothAdapter.STATE_OFF;
                }
                return state;
            }
        // TODO(BT) there might be a small gap during STATE_TURNING_ON that
        // mService is null, handle that case
        }
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return STATE_OFF;
}
Body of Second Method:
{
    int state = BluetoothAdapter.STATE_OFF;
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            state = mService.getState();
        }
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    // Consider all internal states as OFF
    if (state == BluetoothAdapter.STATE_BLE_ON || state == BluetoothAdapter.STATE_BLE_TURNING_ON || state == BluetoothAdapter.STATE_BLE_TURNING_OFF) {
        if (VDBG)
            Log.d(TAG, "Consider internal state as OFF");
        state = BluetoothAdapter.STATE_OFF;
    }
    if (VDBG)
        Log.d(TAG, "" + hashCode() + ": getState(). Returning " + state);
    return state;
}
------------------------
Find a silently evolved API code:android.media.ImageUtils.imageCopy:COMMENT
Method Modifier: public      static      
Comment:/**
 * <p>
 * Copy source image data to destination Image.
 * </p>
 * <p>
 * Only support the copy between two non-{@link ImageFormat#PRIVATE PRIVATE} format
 * images with same properties (format, size, etc.). The data from the
 * source image will be copied to the byteBuffers from the destination Image
 * starting from position zero, and the destination image will be rewound to
 * zero after copy is done.
 * </p>
 *
 * @param src The source image to be copied from.
 * @param dst The destination image to be copied to.
 * @throws IllegalArgumentException If the source and destination images
 * have different format, or one of the images is not copyable.
 */

Body of Frist Method:
{
    if (src == null || dst == null) {
        throw new IllegalArgumentException("Images should be non-null");
    }
    if (src.getFormat() != dst.getFormat()) {
        throw new IllegalArgumentException("Src and dst images should have the same format");
    }
    if (src.getFormat() == ImageFormat.PRIVATE || dst.getFormat() == ImageFormat.PRIVATE) {
        throw new IllegalArgumentException("PRIVATE format images are not copyable");
    }
    if (!(dst.getOwner() instanceof ImageWriter)) {
        throw new IllegalArgumentException("Destination image is not from ImageWriter. Only" + " the images from ImageWriter are writable");
    }
    Size srcSize = new Size(src.getWidth(), src.getHeight());
    Size dstSize = new Size(dst.getWidth(), dst.getHeight());
    if (!srcSize.equals(dstSize)) {
        throw new IllegalArgumentException("source image size " + srcSize + " is different" + " with " + "destination image size " + dstSize);
    }
    Plane[] srcPlanes = src.getPlanes();
    Plane[] dstPlanes = dst.getPlanes();
    ByteBuffer srcBuffer = null;
    ByteBuffer dstBuffer = null;
    for (int i = 0; i < srcPlanes.length; i++) {
        int srcRowStride = srcPlanes[i].getRowStride();
        int dstRowStride = dstPlanes[i].getRowStride();
        srcBuffer = srcPlanes[i].getBuffer();
        dstBuffer = dstPlanes[i].getBuffer();
        if (!(srcBuffer.isDirect() && dstBuffer.isDirect())) {
            throw new IllegalArgumentException("Source and destination ByteBuffers must be" + " direct byteBuffer!");
        }
        if (srcPlanes[i].getPixelStride() != dstPlanes[i].getPixelStride()) {
            throw new IllegalArgumentException("Source plane image pixel stride " + srcPlanes[i].getPixelStride() + " must be same as destination image pixel stride " + dstPlanes[i].getPixelStride());
        }
        int srcPos = srcBuffer.position();
        srcBuffer.rewind();
        dstBuffer.rewind();
        if (srcRowStride == dstRowStride) {
            // Fast path, just copy the content if the byteBuffer all together.
            dstBuffer.put(srcBuffer);
        } else {
            // Source and destination images may have different alignment requirements,
            // therefore may have different strides. Copy row by row for such case.
            int srcOffset = srcBuffer.position();
            int dstOffset = dstBuffer.position();
            Size effectivePlaneSize = getEffectivePlaneSizeForImage(src, i);
            int srcByteCount = effectivePlaneSize.getWidth() * srcPlanes[i].getPixelStride();
            for (int row = 0; row < effectivePlaneSize.getHeight(); row++) {
                if (row == effectivePlaneSize.getHeight() - 1) {
                    // Special case for NV21 backed YUV420_888: need handle the last row
                    // carefully to avoid memory corruption. Check if we have enough bytes to
                    // copy.
                    int remainingBytes = srcBuffer.remaining() - srcOffset;
                    if (srcByteCount > remainingBytes) {
                        srcByteCount = remainingBytes;
                    }
                }
                directByteBufferCopy(srcBuffer, srcOffset, dstBuffer, dstOffset, srcByteCount);
                srcOffset += srcRowStride;
                dstOffset += dstRowStride;
            }
        }
        srcBuffer.position(srcPos);
        dstBuffer.rewind();
    }
}
Body of Second Method:
{
    if (src == null || dst == null) {
        throw new IllegalArgumentException("Images should be non-null");
    }
    if (src.getFormat() != dst.getFormat()) {
        throw new IllegalArgumentException("Src and dst images should have the same format");
    }
    if (src.getFormat() == ImageFormat.PRIVATE || dst.getFormat() == ImageFormat.PRIVATE) {
        throw new IllegalArgumentException("PRIVATE format images are not copyable");
    }
    if (src.getFormat() == ImageFormat.RAW_PRIVATE) {
        throw new IllegalArgumentException("Copy of RAW_OPAQUE format has not been implemented");
    }
    if (!(dst.getOwner() instanceof ImageWriter)) {
        throw new IllegalArgumentException("Destination image is not from ImageWriter. Only" + " the images from ImageWriter are writable");
    }
    Size srcSize = new Size(src.getWidth(), src.getHeight());
    Size dstSize = new Size(dst.getWidth(), dst.getHeight());
    if (!srcSize.equals(dstSize)) {
        throw new IllegalArgumentException("source image size " + srcSize + " is different" + " with " + "destination image size " + dstSize);
    }
    Plane[] srcPlanes = src.getPlanes();
    Plane[] dstPlanes = dst.getPlanes();
    ByteBuffer srcBuffer = null;
    ByteBuffer dstBuffer = null;
    for (int i = 0; i < srcPlanes.length; i++) {
        int srcRowStride = srcPlanes[i].getRowStride();
        int dstRowStride = dstPlanes[i].getRowStride();
        srcBuffer = srcPlanes[i].getBuffer();
        dstBuffer = dstPlanes[i].getBuffer();
        if (!(srcBuffer.isDirect() && dstBuffer.isDirect())) {
            throw new IllegalArgumentException("Source and destination ByteBuffers must be" + " direct byteBuffer!");
        }
        if (srcPlanes[i].getPixelStride() != dstPlanes[i].getPixelStride()) {
            throw new IllegalArgumentException("Source plane image pixel stride " + srcPlanes[i].getPixelStride() + " must be same as destination image pixel stride " + dstPlanes[i].getPixelStride());
        }
        int srcPos = srcBuffer.position();
        srcBuffer.rewind();
        dstBuffer.rewind();
        if (srcRowStride == dstRowStride) {
            // Fast path, just copy the content if the byteBuffer all together.
            dstBuffer.put(srcBuffer);
        } else {
            // Source and destination images may have different alignment requirements,
            // therefore may have different strides. Copy row by row for such case.
            int srcOffset = srcBuffer.position();
            int dstOffset = dstBuffer.position();
            Size effectivePlaneSize = getEffectivePlaneSizeForImage(src, i);
            int srcByteCount = effectivePlaneSize.getWidth() * srcPlanes[i].getPixelStride();
            for (int row = 0; row < effectivePlaneSize.getHeight(); row++) {
                if (row == effectivePlaneSize.getHeight() - 1) {
                    // Special case for NV21 backed YUV420_888: need handle the last row
                    // carefully to avoid memory corruption. Check if we have enough bytes to
                    // copy.
                    int remainingBytes = srcBuffer.remaining() - srcOffset;
                    if (srcByteCount > remainingBytes) {
                        srcByteCount = remainingBytes;
                    }
                }
                directByteBufferCopy(srcBuffer, srcOffset, dstBuffer, dstOffset, srcByteCount);
                srcOffset += srcRowStride;
                dstOffset += dstRowStride;
            }
        }
        srcBuffer.position(srcPos);
        dstBuffer.rewind();
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiManager.getTxPacketCount:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Return TX packet counter, for CTS test of WiFi watchdog.
 * @param listener is the interface to receive result
 *
 * @hide for CTS test only
 */

Body of Frist Method:
{
    validateChannel();
    sAsyncChannel.sendMessage(RSSI_PKTCNT_FETCH, 0, putListener(listener));
}
Body of Second Method:
{
    getChannel().sendMessage(RSSI_PKTCNT_FETCH, 0, putListener(listener));
}
------------------------
Find a silently evolved API code:android.app.ActivityManager.getPackageScreenCompatMode:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    try {
        return ActivityManagerNative.getDefault().getPackageScreenCompatMode(packageName);
    } catch (RemoteException e) {
        // System dead, we will be dead too soon!
        return 0;
    }
}
Body of Second Method:
{
    try {
        return ActivityManagerNative.getDefault().getPackageScreenCompatMode(packageName);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.media.tv.TvTrackInfo.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Used to package this object into a {@link Parcel}.
 *
 * @param dest The {@link Parcel} to be written.
 * @param flags The flags used for parceling.
 */

Body of Frist Method:
{
    dest.writeInt(mType);
    dest.writeString(mId);
    dest.writeString(mLanguage);
    dest.writeString(mDescription != null ? mDescription.toString() : null);
    dest.writeInt(mAudioChannelCount);
    dest.writeInt(mAudioSampleRate);
    dest.writeInt(mVideoWidth);
    dest.writeInt(mVideoHeight);
    dest.writeFloat(mVideoFrameRate);
    dest.writeFloat(mVideoPixelAspectRatio);
    dest.writeBundle(mExtra);
}
Body of Second Method:
{
    dest.writeInt(mType);
    dest.writeString(mId);
    dest.writeString(mLanguage);
    dest.writeString(mDescription != null ? mDescription.toString() : null);
    dest.writeInt(mAudioChannelCount);
    dest.writeInt(mAudioSampleRate);
    dest.writeInt(mVideoWidth);
    dest.writeInt(mVideoHeight);
    dest.writeFloat(mVideoFrameRate);
    dest.writeFloat(mVideoPixelAspectRatio);
    dest.writeByte(mVideoActiveFormatDescription);
    dest.writeBundle(mExtra);
}
------------------------
Find a silently evolved API code:android.graphics.drawable.RippleDrawable.tryBackgroundEnter:COMMENT
Method Modifier: private     
Comment:/**
 * Creates an active hotspot at the specified location.
 */

Body of Frist Method:
{
    if (mBackground == null) {
        mBackground = new RippleBackground(this, mHotspotBounds);
    }
    mBackground.setup(mState.mMaxRadius, mDensity);
    mBackground.enter(focused);
}
Body of Second Method:
{
    if (mBackground == null) {
        final boolean isBounded = isBounded();
        mBackground = new RippleBackground(this, mHotspotBounds, isBounded, mForceSoftware);
    }
    mBackground.setup(mState.mMaxRadius, mDensity);
    mBackground.enter(focused);
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiManager.addOrUpdateNetwork:COMMENT
Method Modifier: private     
Comment:/**
 * Internal method for doing the RPC that creates a new network description
 * or updates an existing one.
 *
 * @param config The possibly sparse object containing the variables that
 * are to set or updated in the network description.
 * @return the ID of the network on success, {@code -1} on failure.
 */

Body of Frist Method:
{
    try {
        return mService.addOrUpdateNetwork(config);
    } catch (RemoteException e) {
        return -1;
    }
}
Body of Second Method:
{
    try {
        return mService.addOrUpdateNetwork(config);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.os.BatteryManager.isCharging:COMMENT
Method Modifier: public      
Comment:/**
 * Return true if the battery is currently considered to be charging.  This means that
 * the device is plugged in and is supplying sufficient power that the battery level is
 * going up (or the battery is fully charged).  Changes in this state are matched by
 * broadcasts of {@link #ACTION_CHARGING} and {@link #ACTION_DISCHARGING}.
 */

Body of Frist Method:
{
    try {
        return mBatteryStats.isCharging();
    } catch (RemoteException e) {
        return true;
    }
}
Body of Second Method:
{
    try {
        return mBatteryStats.isCharging();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.os.Looper.loop:COMMENT
Method Modifier: public      static      
Comment:/**
 * Run the message queue in this thread. Be sure to call
 * {@link #quit()} to end the loop.
 */

Body of Frist Method:
{
    final Looper me = myLooper();
    if (me == null) {
        throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread.");
    }
    final MessageQueue queue = me.mQueue;
    // Make sure the identity of this thread is that of the local process,
    // and keep track of what that identity token actually is.
    Binder.clearCallingIdentity();
    final long ident = Binder.clearCallingIdentity();
    for (; ; ) {
        // might block
        Message msg = queue.next();
        if (msg == null) {
            // No message indicates that the message queue is quitting.
            return;
        }
        // This must be in a local variable, in case a UI event sets the logger
        Printer logging = me.mLogging;
        if (logging != null) {
            logging.println(">>>>> Dispatching to " + msg.target + " " + msg.callback + ": " + msg.what);
        }
        msg.target.dispatchMessage(msg);
        if (logging != null) {
            logging.println("<<<<< Finished to " + msg.target + " " + msg.callback);
        }
        // Make sure that during the course of dispatching the
        // identity of the thread wasn't corrupted.
        final long newIdent = Binder.clearCallingIdentity();
        if (ident != newIdent) {
            Log.wtf(TAG, "Thread identity changed from 0x" + Long.toHexString(ident) + " to 0x" + Long.toHexString(newIdent) + " while dispatching to " + msg.target.getClass().getName() + " " + msg.callback + " what=" + msg.what);
        }
        msg.recycleUnchecked();
    }
}
Body of Second Method:
{
    final Looper me = myLooper();
    if (me == null) {
        throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread.");
    }
    final MessageQueue queue = me.mQueue;
    // Make sure the identity of this thread is that of the local process,
    // and keep track of what that identity token actually is.
    Binder.clearCallingIdentity();
    final long ident = Binder.clearCallingIdentity();
    for (; ; ) {
        // might block
        Message msg = queue.next();
        if (msg == null) {
            // No message indicates that the message queue is quitting.
            return;
        }
        // This must be in a local variable, in case a UI event sets the logger
        final Printer logging = me.mLogging;
        if (logging != null) {
            logging.println(">>>>> Dispatching to " + msg.target + " " + msg.callback + ": " + msg.what);
        }
        final long traceTag = me.mTraceTag;
        if (traceTag != 0) {
            Trace.traceBegin(traceTag, msg.target.getTraceName(msg));
        }
        try {
            msg.target.dispatchMessage(msg);
        } finally {
            if (traceTag != 0) {
                Trace.traceEnd(traceTag);
            }
        }
        if (logging != null) {
            logging.println("<<<<< Finished to " + msg.target + " " + msg.callback);
        }
        // Make sure that during the course of dispatching the
        // identity of the thread wasn't corrupted.
        final long newIdent = Binder.clearCallingIdentity();
        if (ident != newIdent) {
            Log.wtf(TAG, "Thread identity changed from 0x" + Long.toHexString(ident) + " to 0x" + Long.toHexString(newIdent) + " while dispatching to " + msg.target.getClass().getName() + " " + msg.callback + " what=" + msg.what);
        }
        msg.recycleUnchecked();
    }
}
------------------------
Find a silently evolved API code:android.net.ConnectivityManager.getNetworkCapabilities:COMMENT
Method Modifier: public      
Comment:/**
 * Get the {@link android.net.NetworkCapabilities} for the given {@link Network}.  This
 * will return {@code null} if the network is unknown.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
 *
 * @param network The {@link Network} object identifying the network in question.
 * @return The {@link android.net.NetworkCapabilities} for the network, or {@code null}.
 */

Body of Frist Method:
{
    try {
        return mService.getNetworkCapabilities(network);
    } catch (RemoteException e) {
        return null;
    }
}
Body of Second Method:
{
    try {
        return mService.getNetworkCapabilities(network);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.net.NetworkScoreManager.setActiveScorer:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Set the active scorer to a new package and clear existing scores.
 *
 * <p>Should never be called directly without obtaining user consent. This can be done by using
 * the {@link #ACTION_CHANGE_ACTIVE} broadcast, or using a custom configuration activity.
 *
 * @return true if the operation succeeded, or false if the new package is not a valid scorer.
 * @throws SecurityException if the caller does not hold the
 * {@link android.Manifest.permission#SCORE_NETWORKS} permission.
 * @hide
 */

Body of Frist Method:
{
    try {
        return mService.setActiveScorer(packageName);
    } catch (RemoteException e) {
        return false;
    }
}
Body of Second Method:
{
    try {
        return mService.setActiveScorer(packageName);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.media.AudioFormat.Builder.setEncoding:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the data encoding format.
 * @param encoding one of {@link AudioFormat#ENCODING_DEFAULT},
 * {@link AudioFormat#ENCODING_PCM_8BIT},
 * {@link AudioFormat#ENCODING_PCM_16BIT},
 * {@link AudioFormat#ENCODING_PCM_FLOAT},
 * {@link AudioFormat#ENCODING_AC3},
 * {@link AudioFormat#ENCODING_E_AC3}.
 * {@link AudioFormat#ENCODING_DTS},
 * {@link AudioFormat#ENCODING_DTS_HD}.
 * @return the same Builder instance.
 * @throws java.lang.IllegalArgumentException
 */

Body of Frist Method:
{
    switch(encoding) {
        case ENCODING_DEFAULT:
            mEncoding = ENCODING_PCM_16BIT;
            break;
        case ENCODING_PCM_8BIT:
        case ENCODING_PCM_16BIT:
        case ENCODING_PCM_FLOAT:
        case ENCODING_AC3:
        case ENCODING_E_AC3:
        case ENCODING_DTS:
        case ENCODING_DTS_HD:
            mEncoding = encoding;
            break;
        case ENCODING_INVALID:
        default:
            throw new IllegalArgumentException("Invalid encoding " + encoding);
    }
    mPropertySetMask |= AUDIO_FORMAT_HAS_PROPERTY_ENCODING;
    return this;
}
Body of Second Method:
{
    switch(encoding) {
        case ENCODING_DEFAULT:
            mEncoding = ENCODING_PCM_16BIT;
            break;
        case ENCODING_PCM_8BIT:
        case ENCODING_PCM_16BIT:
        case ENCODING_PCM_FLOAT:
        case ENCODING_AC3:
        case ENCODING_E_AC3:
        case ENCODING_DTS:
        case ENCODING_DTS_HD:
        case ENCODING_IEC61937:
            mEncoding = encoding;
            break;
        case ENCODING_INVALID:
        default:
            throw new IllegalArgumentException("Invalid encoding " + encoding);
    }
    mPropertySetMask |= AUDIO_FORMAT_HAS_PROPERTY_ENCODING;
    return this;
}
------------------------
Find a silently evolved API code:android.media.ImageWriter.abortImage:COMMENT
Method Modifier: private     
Comment:/**
 * <p>
 * Abort the Images that were dequeued from this ImageWriter, and return
 * them to this writer for reuse.
 * </p>
 * <p>
 * This method is used for the cases where the application dequeued the
 * Image, may have filled the data, but does not want the downstream
 * component to consume it. The Image will be returned to this ImageWriter
 * for reuse after this call, and the ImageWriter will immediately have an
 * Image available to be dequeued. This aborted Image will be invisible to
 * the downstream consumer, as if nothing happened.
 * </p>
 *
 * @param image The Image to be aborted.
 * @see #dequeueInputImage()
 * @see Image#close()
 */

Body of Frist Method:
{
    if (image == null) {
        throw new IllegalArgumentException("image shouldn't be null");
    }
    if (!mDequeuedImages.contains(image)) {
        throw new IllegalStateException("It is illegal to abort some image that is not" + " dequeued yet");
    }
    WriterSurfaceImage wi = (WriterSurfaceImage) image;
    if (!wi.mIsImageValid) {
        throw new IllegalStateException("Image is invalid");
    }
    /**
     * We only need abort Images that are owned and dequeued by ImageWriter.
     * For attached Images, no need to abort, as there are only two cases:
     * attached + queued successfully, and attach failed. Neither of the
     * cases need abort.
     */
    cancelImage(mNativeContext, image);
    mDequeuedImages.remove(image);
    wi.clearSurfacePlanes();
    wi.mIsImageValid = false;
}
Body of Second Method:
{
    if (image == null) {
        throw new IllegalArgumentException("image shouldn't be null");
    }
    if (!mDequeuedImages.contains(image)) {
        throw new IllegalStateException("It is illegal to abort some image that is not" + " dequeued yet");
    }
    WriterSurfaceImage wi = (WriterSurfaceImage) image;
    if (!wi.mIsImageValid) {
        return;
    }
    /**
     * We only need abort Images that are owned and dequeued by ImageWriter.
     * For attached Images, no need to abort, as there are only two cases:
     * attached + queued successfully, and attach failed. Neither of the
     * cases need abort.
     */
    cancelImage(mNativeContext, image);
    mDequeuedImages.remove(image);
    wi.clearSurfacePlanes();
    wi.mIsImageValid = false;
}
------------------------
Find a silently evolved API code:android.inputmethodservice.InputMethodService.InputMethodImpl.showSoftInput:COMMENT
Method Modifier: public      
Comment:/**
 * Handle a request by the system to show the soft input area.
 */

Body of Frist Method:
{
    if (DEBUG)
        Log.v(TAG, "showSoftInput()");
    boolean wasVis = isInputViewShown();
    mShowInputFlags = 0;
    if (onShowInputRequested(flags, false)) {
        try {
            showWindow(true);
        } catch (BadTokenException e) {
            if (DEBUG)
                Log.v(TAG, "BadTokenException: IME is done.");
            mWindowVisible = false;
            mWindowAdded = false;
        }
    }
    clearInsetOfPreviousIme();
    // If user uses hard keyboard, IME button should always be shown.
    boolean showing = isInputViewShown();
    mImm.setImeWindowStatus(mToken, IME_ACTIVE | (showing ? IME_VISIBLE : 0), mBackDisposition);
    if (resultReceiver != null) {
        resultReceiver.send(wasVis != isInputViewShown() ? InputMethodManager.RESULT_SHOWN : (wasVis ? InputMethodManager.RESULT_UNCHANGED_SHOWN : InputMethodManager.RESULT_UNCHANGED_HIDDEN), null);
    }
}
Body of Second Method:
{
    if (DEBUG)
        Log.v(TAG, "showSoftInput()");
    boolean wasVis = isInputViewShown();
    if (dispatchOnShowInputRequested(flags, false)) {
        try {
            showWindow(true);
        } catch (BadTokenException e) {
        // We have ignored BadTokenException here since Jelly Bean MR-2 (API Level 18).
        // We could ignore BadTokenException in InputMethodService#showWindow() instead,
        // but it may break assumptions for those who override #showWindow() that we can
        // detect errors in #showWindow() by checking BadTokenException.
        // TODO: Investigate its feasibility.  Update JavaDoc of #showWindow() of
        // whether it's OK to override #showWindow() or not.
        }
    }
    clearInsetOfPreviousIme();
    // If user uses hard keyboard, IME button should always be shown.
    boolean showing = isInputViewShown();
    mImm.setImeWindowStatus(mToken, IME_ACTIVE | (showing ? IME_VISIBLE : 0), mBackDisposition);
    if (resultReceiver != null) {
        resultReceiver.send(wasVis != isInputViewShown() ? InputMethodManager.RESULT_SHOWN : (wasVis ? InputMethodManager.RESULT_UNCHANGED_SHOWN : InputMethodManager.RESULT_UNCHANGED_HIDDEN), null);
    }
}
------------------------
Find a silently evolved API code:android.print.PrinterInfo.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Creates a new {@link PrinterInfo}.
 *
 * @return A new {@link PrinterInfo}.
 */

Body of Frist Method:
{
    return mPrototype;
}
Body of Second Method:
{
    return new PrinterInfo(mPrinterId, mName, mStatus, mIconResourceId, mHasCustomPrinterIcon, mDescription, mInfoIntent, mCapabilities, mCustomPrinterIconGen);
}
------------------------
Find a silently evolved API code:android.widget.ProgressBar.startAnimation:COMMENT
Method Modifier: default     
Comment:/**
 * <p>Start the indeterminate progress animation.</p>
 */

Body of Frist Method:
{
    if (getVisibility() != VISIBLE) {
        return;
    }
    if (mIndeterminateDrawable instanceof Animatable) {
        mShouldStartAnimationDrawable = true;
        mHasAnimation = false;
    } else {
        mHasAnimation = true;
        if (mInterpolator == null) {
            mInterpolator = new LinearInterpolator();
        }
        if (mTransformation == null) {
            mTransformation = new Transformation();
        } else {
            mTransformation.clear();
        }
        if (mAnimation == null) {
            mAnimation = new AlphaAnimation(0.0f, 1.0f);
        } else {
            mAnimation.reset();
        }
        mAnimation.setRepeatMode(mBehavior);
        mAnimation.setRepeatCount(Animation.INFINITE);
        mAnimation.setDuration(mDuration);
        mAnimation.setInterpolator(mInterpolator);
        mAnimation.setStartTime(Animation.START_ON_FIRST_FRAME);
    }
    postInvalidate();
}
Body of Second Method:
{
    if (getVisibility() != VISIBLE || getWindowVisibility() != VISIBLE) {
        return;
    }
    if (mIndeterminateDrawable instanceof Animatable) {
        mShouldStartAnimationDrawable = true;
        mHasAnimation = false;
    } else {
        mHasAnimation = true;
        if (mInterpolator == null) {
            mInterpolator = new LinearInterpolator();
        }
        if (mTransformation == null) {
            mTransformation = new Transformation();
        } else {
            mTransformation.clear();
        }
        if (mAnimation == null) {
            mAnimation = new AlphaAnimation(0.0f, 1.0f);
        } else {
            mAnimation.reset();
        }
        mAnimation.setRepeatMode(mBehavior);
        mAnimation.setRepeatCount(Animation.INFINITE);
        mAnimation.setDuration(mDuration);
        mAnimation.setInterpolator(mInterpolator);
        mAnimation.setStartTime(Animation.START_ON_FIRST_FRAME);
    }
    postInvalidate();
}
------------------------
Find a silently evolved API code:android.media.AudioManager.setBluetoothA2dpDeviceConnectionState:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Indicate A2DP source or sink connection state change.
 * @param device Bluetooth device connected/disconnected
 * @param state  new connection state (BluetoothProfile.STATE_xxx)
 * @param profile profile for the A2DP device
 * (either {@link android.bluetooth.BluetoothProfile.A2DP} or
 * {@link android.bluetooth.BluetoothProfile.A2DP_SINK})
 * @return a delay in ms that the caller should wait before broadcasting
 * BluetoothA2dp.ACTION_CONNECTION_STATE_CHANGED intent.
 * {@hide}
 */

Body of Frist Method:
{
    IAudioService service = getService();
    int delay = 0;
    try {
        delay = service.setBluetoothA2dpDeviceConnectionState(device, state, profile);
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in setBluetoothA2dpDeviceConnectionState " + e);
    }
    return delay;
}
Body of Second Method:
{
    IAudioService service = getService();
    int delay = 0;
    try {
        delay = service.setBluetoothA2dpDeviceConnectionState(device, state, profile);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
    return delay;
}
------------------------
Find a silently evolved API code:android.telephony.SignalStrength.copyFrom:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    mGsmSignalStrength = s.mGsmSignalStrength;
    mGsmBitErrorRate = s.mGsmBitErrorRate;
    mCdmaDbm = s.mCdmaDbm;
    mCdmaEcio = s.mCdmaEcio;
    mEvdoDbm = s.mEvdoDbm;
    mEvdoEcio = s.mEvdoEcio;
    mEvdoSnr = s.mEvdoSnr;
    mLteSignalStrength = s.mLteSignalStrength;
    mLteRsrp = s.mLteRsrp;
    mLteRsrq = s.mLteRsrq;
    mLteRssnr = s.mLteRssnr;
    mLteCqi = s.mLteCqi;
    isGsm = s.isGsm;
}
Body of Second Method:
{
    mGsmSignalStrength = s.mGsmSignalStrength;
    mGsmBitErrorRate = s.mGsmBitErrorRate;
    mCdmaDbm = s.mCdmaDbm;
    mCdmaEcio = s.mCdmaEcio;
    mEvdoDbm = s.mEvdoDbm;
    mEvdoEcio = s.mEvdoEcio;
    mEvdoSnr = s.mEvdoSnr;
    mLteSignalStrength = s.mLteSignalStrength;
    mLteRsrp = s.mLteRsrp;
    mLteRsrq = s.mLteRsrq;
    mLteRssnr = s.mLteRssnr;
    mLteCqi = s.mLteCqi;
    mTdScdmaRscp = s.mTdScdmaRscp;
    isGsm = s.isGsm;
}
------------------------
Find a silently evolved API code:android.accounts.AccountManager.getAccountsForPackage:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 * For use by internal activities. Returns the list of accounts that the calling package
 * is authorized to use, particularly for shared accounts.
 * @param packageName package name of the calling app.
 * @param uid the uid of the calling app.
 * @return the accounts that are available to this package and user.
 */

Body of Frist Method:
{
    try {
        return mService.getAccountsForPackage(packageName, uid, mContext.getOpPackageName());
    } catch (RemoteException re) {
        // won't ever happen
        throw new RuntimeException(re);
    }
}
Body of Second Method:
{
    try {
        return mService.getAccountsForPackage(packageName, uid, mContext.getOpPackageName());
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.os.Bundle.readFromParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Reads the Parcel contents into this Bundle, typically in order for
 * it to be passed through an IBinder connection.
 * @param parcel The parcel to overwrite this bundle from.
 */

Body of Frist Method:
{
    super.readFromParcelInner(parcel);
    mHasFds = mParcelledData.hasFileDescriptors();
    mFdsKnown = true;
}
Body of Second Method:
{
    super.readFromParcelInner(parcel);
    mFlags = FLAG_HAS_FDS_KNOWN | FLAG_ALLOW_FDS;
    if (mParcelledData.hasFileDescriptors()) {
        mFlags |= FLAG_HAS_FDS;
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiManager.getWpsNfcConfigurationToken:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Creates a configuration token describing the network referenced by {@code netId}
 * of MIME type application/vnd.wfa.wsc. Can be used to configure WiFi networks via NFC.
 *
 * @return hex-string encoded configuration token
 * @hide
 */

Body of Frist Method:
{
    try {
        return mService.getWpsNfcConfigurationToken(netId);
    } catch (RemoteException e) {
        return null;
    }
}
Body of Second Method:
{
    try {
        return mService.getWpsNfcConfigurationToken(netId);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.hardware.usb.UsbManager.setUsbDataUnlocked:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets whether USB data (for example, MTP exposed pictures) should be made available
 * on the USB connection when in device mode. Unlocking usb data should only be done with
 * user involvement, since exposing pictures or other data could leak sensitive
 * user information.
 *
 * {@hide}
 */

Body of Frist Method:
{
    try {
        mService.setUsbDataUnlocked(unlocked);
    } catch (RemoteException e) {
        Log.e(TAG, "RemoteException in setUsbDataUnlocked", e);
    }
}
Body of Second Method:
{
    try {
        mService.setUsbDataUnlocked(unlocked);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.inputmethodservice.InputMethodService.onExtractedDeleteText:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    InputConnection conn = getCurrentInputConnection();
    if (conn != null) {
        conn.setSelection(start, start);
        conn.deleteSurroundingText(0, end - start);
    }
}
Body of Second Method:
{
    InputConnection conn = getCurrentInputConnection();
    if (conn != null) {
        conn.finishComposingText();
        conn.setSelection(start, start);
        conn.deleteSurroundingText(0, end - start);
    }
}
------------------------
Find a silently evolved API code:android.widget.Editor.SelectionModifierCursorController.isDragAcceleratorActive:COMMENT
Method Modifier: public      
Comment:/**
 * @return true if the user is selecting text using the drag accelerator.
 */

Body of Frist Method:
{
    return mDragAcceleratorActive;
}
Body of Second Method:
{
    return mDragAcceleratorMode != DRAG_ACCELERATOR_MODE_INACTIVE;
}
------------------------
Find a silently evolved API code:android.app.ActivityManager.forceStopPackageAsUser:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Have the system perform a force stop of everything associated with
 * the given application package.  All processes that share its uid
 * will be killed, all services it has running stopped, all activities
 * removed, etc.  In addition, a {@link Intent#ACTION_PACKAGE_RESTARTED}
 * broadcast will be sent, so that any of its registered alarms can
 * be stopped, notifications removed, etc.
 *
 * <p>You must hold the permission
 * {@link android.Manifest.permission#FORCE_STOP_PACKAGES} to be able to
 * call this method.
 *
 * @param packageName The name of the package to be stopped.
 * @param userId The user for which the running package is to be stopped.
 *
 * @hide This is not available to third party applications due to
 * it allowing them to break other applications by stopping their
 * services, removing their alarms, etc.
 */

Body of Frist Method:
{
    try {
        ActivityManagerNative.getDefault().forceStopPackage(packageName, userId);
    } catch (RemoteException e) {
    }
}
Body of Second Method:
{
    try {
        ActivityManagerNative.getDefault().forceStopPackage(packageName, userId);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.net.NetworkStats.groupedByIface:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Return total statistics grouped by {@link #iface}; doesn't mutate the
 * original structure.
 */

Body of Frist Method:
{
    final NetworkStats stats = new NetworkStats(elapsedRealtime, 10);
    final Entry entry = new Entry();
    entry.uid = UID_ALL;
    entry.set = SET_ALL;
    entry.tag = TAG_NONE;
    entry.operations = 0L;
    for (int i = 0; i < size; i++) {
        // skip specific tags, since already counted in TAG_NONE
        if (tag[i] != TAG_NONE)
            continue;
        entry.iface = iface[i];
        entry.rxBytes = rxBytes[i];
        entry.rxPackets = rxPackets[i];
        entry.txBytes = txBytes[i];
        entry.txPackets = txPackets[i];
        stats.combineValues(entry);
    }
    return stats;
}
Body of Second Method:
{
    final NetworkStats stats = new NetworkStats(elapsedRealtime, 10);
    final Entry entry = new Entry();
    entry.uid = UID_ALL;
    entry.set = SET_ALL;
    entry.tag = TAG_NONE;
    entry.roaming = ROAMING_ALL;
    entry.operations = 0L;
    for (int i = 0; i < size; i++) {
        // skip specific tags, since already counted in TAG_NONE
        if (tag[i] != TAG_NONE)
            continue;
        entry.iface = iface[i];
        entry.rxBytes = rxBytes[i];
        entry.rxPackets = rxPackets[i];
        entry.txBytes = txBytes[i];
        entry.txPackets = txPackets[i];
        stats.combineValues(entry);
    }
    return stats;
}
------------------------
Find a silently evolved API code:android.net.ConnectivityManager.getProxyForNetwork:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Retrieve the global HTTP proxy, or if no global HTTP proxy is set, a
 * network-specific HTTP proxy.  If {@code network} is null, the
 * network-specific proxy returned is the proxy of the default active
 * network.
 *
 * @return {@link ProxyInfo} for the current global HTTP proxy, or if no
 * global HTTP proxy is set, {@code ProxyInfo} for {@code network},
 * or when {@code network} is {@code null},
 * the {@code ProxyInfo} for the default active network.  Returns
 * {@code null} when no proxy applies or the caller doesn't have
 * permission to use {@code network}.
 * @hide
 */

Body of Frist Method:
{
    try {
        return mService.getProxyForNetwork(network);
    } catch (RemoteException e) {
        return null;
    }
}
Body of Second Method:
{
    try {
        return mService.getProxyForNetwork(network);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.RttManager.RttCapabilities.writeToParcel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Implement the Parcelable interface {@hide}
 */

Body of Frist Method:
{
    dest.writeInt(oneSidedRttSupported ? 1 : 0);
    dest.writeInt(twoSided11McRttSupported ? 1 : 0);
    dest.writeInt(lciSupported ? 1 : 0);
    dest.writeInt(lcrSupported ? 1 : 0);
    dest.writeInt(preambleSupported);
    dest.writeInt(bwSupported);
}
Body of Second Method:
{
    dest.writeInt(oneSidedRttSupported ? 1 : 0);
    dest.writeInt(twoSided11McRttSupported ? 1 : 0);
    dest.writeInt(lciSupported ? 1 : 0);
    dest.writeInt(lcrSupported ? 1 : 0);
    dest.writeInt(preambleSupported);
    dest.writeInt(bwSupported);
    dest.writeInt(responderSupported ? 1 : 0);
    dest.writeInt(secureRttSupported ? 1 : 0);
    dest.writeInt(mcVersion);
}
------------------------
Find a silently evolved API code:android.app.usage.NetworkStatsManager.querySummaryForUser:COMMENT
Method Modifier: public      
Comment:/**
 * Query network usage statistics summaries. Result is summarised data usage for all uids
 * belonging to calling user. Result is a single Bucket aggregated over time, state and uid.
 * This means the bucket's start and end timestamp are going to be the same as the 'startTime'
 * and 'endTime' parameters, state is going to be {@link NetworkStats.Bucket#STATE_ALL} and uid
 * {@link NetworkStats.Bucket#UID_ALL}.
 *
 * @param networkType As defined in {@link ConnectivityManager}, e.g.
 * {@link ConnectivityManager#TYPE_MOBILE}, {@link ConnectivityManager#TYPE_WIFI}
 * etc.
 * @param subscriberId If applicable, the subscriber id of the network interface.
 * @param startTime Start of period. Defined in terms of "Unix time", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param endTime End of period. Defined in terms of "Unix time", see
 * {@link java.lang.System#currentTimeMillis}.
 * @return Bucket object or null if permissions are insufficient or error happened during
 * statistics collection.
 */

Body of Frist Method:
{
    NetworkTemplate template = createTemplate(networkType, subscriberId);
    if (template == null) {
        return null;
    }
    NetworkStats stats;
    stats = new NetworkStats(mContext, template, startTime, endTime);
    stats.startSummaryEnumeration();
    stats.close();
    return stats.getSummaryAggregate();
}
Body of Second Method:
{
    NetworkTemplate template;
    try {
        template = createTemplate(networkType, subscriberId);
    } catch (IllegalArgumentException e) {
        if (DBG)
            Log.e(TAG, "Cannot create template", e);
        return null;
    }
    NetworkStats stats;
    stats = new NetworkStats(mContext, template, startTime, endTime);
    stats.startSummaryEnumeration();
    stats.close();
    return stats.getSummaryAggregate();
}
------------------------
Find a silently evolved API code:android.widget.ImageView.onPopulateAccessibilityEventInternal:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    super.onPopulateAccessibilityEventInternal(event);
    CharSequence contentDescription = getContentDescription();
    if (!TextUtils.isEmpty(contentDescription)) {
        event.getText().add(contentDescription);
    }
}
Body of Second Method:
{
    super.onPopulateAccessibilityEventInternal(event);
    final CharSequence contentDescription = getContentDescription();
    if (!TextUtils.isEmpty(contentDescription)) {
        event.getText().add(contentDescription);
    }
}
------------------------
Find a silently evolved API code:android.accounts.AccountManager.hasFeatures:COMMENT
Method Modifier: public      
Comment:/**
 * Finds out whether a particular account has all the specified features.
 * Account features are authenticator-specific string tokens identifying
 * boolean account properties.  For example, features are used to tell
 * whether Google accounts have a particular service (such as Google
 * Calendar or Google Talk) enabled.  The feature names and their meanings
 * are published somewhere associated with the authenticator in question.
 *
 * <p>This method may be called from any thread, but the returned
 * {@link AccountManagerFuture} must not be used on the main thread.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#GET_ACCOUNTS} or be a signature
 * match with the AbstractAccountAuthenticator that manages the account.
 *
 * @param account The {@link Account} to test
 * @param features An array of the account features to check
 * @param callback Callback to invoke when the request completes,
 * null for no callback
 * @param handler {@link Handler} identifying the callback thread,
 * null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to a Boolean,
 * true if the account exists and has all of the specified features.
 */

Body of Frist Method:
{
    if (account == null)
        throw new IllegalArgumentException("account is null");
    if (features == null)
        throw new IllegalArgumentException("features is null");
    return new Future2Task<Boolean>(handler, callback) {

        public void doWork() throws RemoteException {
            mService.hasFeatures(mResponse, account, features, mContext.getOpPackageName());
        }

        public Boolean bundleToResult(Bundle bundle) throws AuthenticatorException {
            if (!bundle.containsKey(KEY_BOOLEAN_RESULT)) {
                throw new AuthenticatorException("no result in response");
            }
            return bundle.getBoolean(KEY_BOOLEAN_RESULT);
        }
    }.start();
}
Body of Second Method:
{
    if (account == null)
        throw new IllegalArgumentException("account is null");
    if (features == null)
        throw new IllegalArgumentException("features is null");
    return new Future2Task<Boolean>(handler, callback) {

        @Override
        public void doWork() throws RemoteException {
            mService.hasFeatures(mResponse, account, features, mContext.getOpPackageName());
        }

        @Override
        public Boolean bundleToResult(Bundle bundle) throws AuthenticatorException {
            if (!bundle.containsKey(KEY_BOOLEAN_RESULT)) {
                throw new AuthenticatorException("no result in response");
            }
            return bundle.getBoolean(KEY_BOOLEAN_RESULT);
        }
    }.start();
}
------------------------
Find a silently evolved API code:android.os.PowerManager.isPowerSaveMode:COMMENT
Method Modifier: public      
Comment:/**
 * Returns true if the device is currently in power save mode.  When in this mode,
 * applications should reduce their functionality in order to conserve battery as
 * much as possible.  You can monitor for changes to this state with
 * {@link #ACTION_POWER_SAVE_MODE_CHANGED}.
 *
 * @return Returns true if currently in low power mode, else false.
 */

Body of Frist Method:
{
    try {
        return mService.isPowerSaveMode();
    } catch (RemoteException e) {
        return false;
    }
}
Body of Second Method:
{
    try {
        return mService.isPowerSaveMode();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.media.ImageUtils.getNumPlanesForFormat:COMMENT
Method Modifier: public      static      
Comment:/**
 * Only a subset of the formats defined in
 * {@link android.graphics.ImageFormat ImageFormat} and
 * {@link android.graphics.PixelFormat PixelFormat} are supported by
 * ImageReader. When reading RGB data from a surface, the formats defined in
 * {@link android.graphics.PixelFormat PixelFormat} can be used; when
 * reading YUV, JPEG or raw sensor data (for example, from the camera or video
 * decoder), formats from {@link android.graphics.ImageFormat ImageFormat}
 * are used.
 */

Body of Frist Method:
{
    switch(format) {
        case ImageFormat.YV12:
        case ImageFormat.YUV_420_888:
        case ImageFormat.NV21:
            return 3;
        case ImageFormat.NV16:
            return 2;
        case PixelFormat.RGB_565:
        case PixelFormat.RGBA_8888:
        case PixelFormat.RGBX_8888:
        case PixelFormat.RGB_888:
        case ImageFormat.JPEG:
        case ImageFormat.YUY2:
        case ImageFormat.Y8:
        case ImageFormat.Y16:
        case ImageFormat.RAW_SENSOR:
        case ImageFormat.RAW10:
            return 1;
        case ImageFormat.PRIVATE:
            return 0;
        default:
            throw new UnsupportedOperationException(String.format("Invalid format specified %d", format));
    }
}
Body of Second Method:
{
    switch(format) {
        case ImageFormat.YV12:
        case ImageFormat.YUV_420_888:
        case ImageFormat.NV21:
            return 3;
        case ImageFormat.NV16:
            return 2;
        case PixelFormat.RGB_565:
        case PixelFormat.RGBA_8888:
        case PixelFormat.RGBX_8888:
        case PixelFormat.RGB_888:
        case ImageFormat.JPEG:
        case ImageFormat.YUY2:
        case ImageFormat.Y8:
        case ImageFormat.Y16:
        case ImageFormat.RAW_SENSOR:
        case ImageFormat.RAW_PRIVATE:
        case ImageFormat.RAW10:
        case ImageFormat.RAW12:
        case ImageFormat.DEPTH16:
        case ImageFormat.DEPTH_POINT_CLOUD:
            return 1;
        case ImageFormat.PRIVATE:
            return 0;
        default:
            throw new UnsupportedOperationException(String.format("Invalid format specified %d", format));
    }
}
------------------------
Find a silently evolved API code:android.accounts.AccountManager.getAuthenticatorTypesAsUser:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 * Lists the currently registered authenticators for a given user id.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>The caller has to be in the same user or have the permission
 * {@link android.Manifest.permission#INTERACT_ACROSS_USERS_FULL}.
 *
 * @return An array of {@link AuthenticatorDescription} for every
 * authenticator known to the AccountManager service.  Empty (never
 * null) if no authenticators are known.
 */

Body of Frist Method:
{
    try {
        return mService.getAuthenticatorTypes(userId);
    } catch (RemoteException e) {
        // will never happen
        throw new RuntimeException(e);
    }
}
Body of Second Method:
{
    try {
        return mService.getAuthenticatorTypes(userId);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.text.SpannableStringBuilder.clearSpans:COMMENT
Method Modifier: public      
Comment:// Documentation from interface

Body of Frist Method:
{
    for (int i = mSpanCount - 1; i >= 0; i--) {
        Object what = mSpans[i];
        int ostart = mSpanStarts[i];
        int oend = mSpanEnds[i];
        if (ostart > mGapStart)
            ostart -= mGapLength;
        if (oend > mGapStart)
            oend -= mGapLength;
        mSpanCount = i;
        mSpans[i] = null;
        sendSpanRemoved(what, ostart, oend);
    }
    if (mIndexOfSpan != null) {
        mIndexOfSpan.clear();
    }
}
Body of Second Method:
{
    for (int i = mSpanCount - 1; i >= 0; i--) {
        Object what = mSpans[i];
        int ostart = mSpanStarts[i];
        int oend = mSpanEnds[i];
        if (ostart > mGapStart)
            ostart -= mGapLength;
        if (oend > mGapStart)
            oend -= mGapLength;
        mSpanCount = i;
        mSpans[i] = null;
        sendSpanRemoved(what, ostart, oend);
    }
    if (mIndexOfSpan != null) {
        mIndexOfSpan.clear();
    }
    mSpanInsertCount = 0;
}
------------------------
Find a silently evolved API code:android.app.SearchManager.getGlobalSearchActivity:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the name of the global search activity.
 */

Body of Frist Method:
{
    try {
        return mService.getGlobalSearchActivity();
    } catch (RemoteException ex) {
        Log.e(TAG, "getGlobalSearchActivity() failed: " + ex);
        return null;
    }
}
Body of Second Method:
{
    try {
        return mService.getGlobalSearchActivity();
    } catch (RemoteException ex) {
        throw ex.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.net.LinkProperties.compareProvisioning:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Compare the provisioning states of two LinkProperties instances.
 *
 * @hide
 */

Body of Frist Method:
{
    if (before.isProvisioned() && after.isProvisioned()) {
        // TODO: Remove this special case altogether.
        if (before.isIPv4Provisioned() && !after.isIPv4Provisioned()) {
            return ProvisioningChange.LOST_PROVISIONING;
        }
        return ProvisioningChange.STILL_PROVISIONED;
    } else if (before.isProvisioned() && !after.isProvisioned()) {
        return ProvisioningChange.LOST_PROVISIONING;
    } else if (!before.isProvisioned() && after.isProvisioned()) {
        return ProvisioningChange.GAINED_PROVISIONING;
    } else {
        // !before.isProvisioned() && !after.isProvisioned()
        return ProvisioningChange.STILL_NOT_PROVISIONED;
    }
}
Body of Second Method:
{
    if (before.isProvisioned() && after.isProvisioned()) {
        // previously dualstack network is deemed a lost of provisioning.
        if ((before.isIPv4Provisioned() && !after.isIPv4Provisioned()) || (before.isIPv6Provisioned() && !after.isIPv6Provisioned())) {
            return ProvisioningChange.LOST_PROVISIONING;
        }
        return ProvisioningChange.STILL_PROVISIONED;
    } else if (before.isProvisioned() && !after.isProvisioned()) {
        return ProvisioningChange.LOST_PROVISIONING;
    } else if (!before.isProvisioned() && after.isProvisioned()) {
        return ProvisioningChange.GAINED_PROVISIONING;
    } else {
        // !before.isProvisioned() && !after.isProvisioned()
        return ProvisioningChange.STILL_NOT_PROVISIONED;
    }
}
------------------------
Find a silently evolved API code:android.hardware.usb.UsbManager.getPortStatus:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Gets the status of the specified USB port.
 *
 * @param port The port to query.
 * @return The status of the specified USB port, or null if unknown.
 *
 * @hide
 */

Body of Frist Method:
{
    Preconditions.checkNotNull(port, "port must not be null");
    try {
        return mService.getPortStatus(port.getId());
    } catch (RemoteException e) {
        Log.e(TAG, "RemoteException in getPortStatus", e);
    }
    return null;
}
Body of Second Method:
{
    Preconditions.checkNotNull(port, "port must not be null");
    try {
        return mService.getPortStatus(port.getId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.net.ConnectivityManager.getTetherableUsbRegexs:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the list of regular expressions that define any tetherable
 * USB network interfaces.  If USB tethering is not supported by the
 * device, this list should be empty.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
 *
 * @return an array of 0 or more regular expression Strings defining
 * what interfaces are considered tetherable usb interfaces.
 *
 * {@hide}
 */

Body of Frist Method:
{
    try {
        return mService.getTetherableUsbRegexs();
    } catch (RemoteException e) {
        return new String[0];
    }
}
Body of Second Method:
{
    try {
        return mService.getTetherableUsbRegexs();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.app.trust.TrustManager.registerTrustListener:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Registers a listener for trust events.
 *
 * Requires the {@link android.Manifest.permission#TRUST_LISTENER} permission.
 */

Body of Frist Method:
{
    try {
        ITrustListener.Stub iTrustListener = new ITrustListener.Stub() {

            @Override
            public void onTrustChanged(boolean enabled, int userId, int flags) {
                Message m = mHandler.obtainMessage(MSG_TRUST_CHANGED, (enabled ? 1 : 0), userId, trustListener);
                if (flags != 0) {
                    m.getData().putInt(DATA_FLAGS, flags);
                }
                m.sendToTarget();
            }

            @Override
            public void onTrustManagedChanged(boolean managed, int userId) {
                mHandler.obtainMessage(MSG_TRUST_MANAGED_CHANGED, (managed ? 1 : 0), userId, trustListener).sendToTarget();
            }
        };
        mService.registerTrustListener(iTrustListener);
        mTrustListeners.put(trustListener, iTrustListener);
    } catch (RemoteException e) {
        onError(e);
    }
}
Body of Second Method:
{
    try {
        ITrustListener.Stub iTrustListener = new ITrustListener.Stub() {

            @Override
            public void onTrustChanged(boolean enabled, int userId, int flags) {
                Message m = mHandler.obtainMessage(MSG_TRUST_CHANGED, (enabled ? 1 : 0), userId, trustListener);
                if (flags != 0) {
                    m.getData().putInt(DATA_FLAGS, flags);
                }
                m.sendToTarget();
            }

            @Override
            public void onTrustManagedChanged(boolean managed, int userId) {
                mHandler.obtainMessage(MSG_TRUST_MANAGED_CHANGED, (managed ? 1 : 0), userId, trustListener).sendToTarget();
            }
        };
        mService.registerTrustListener(iTrustListener);
        mTrustListeners.put(trustListener, iTrustListener);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.os.Bundle.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Writes the Bundle contents to a Parcel, typically in order for
 * it to be passed through an IBinder connection.
 * @param parcel The parcel to copy this bundle to.
 */

Body of Frist Method:
{
    final boolean oldAllowFds = parcel.pushAllowFds(mAllowFds);
    try {
        super.writeToParcelInner(parcel, flags);
    } finally {
        parcel.restoreAllowFds(oldAllowFds);
    }
}
Body of Second Method:
{
    final boolean oldAllowFds = parcel.pushAllowFds((mFlags & FLAG_ALLOW_FDS) != 0);
    try {
        super.writeToParcelInner(parcel, flags);
    } finally {
        parcel.restoreAllowFds(oldAllowFds);
    }
}
------------------------
Find a silently evolved API code:android.os.DropBoxManager.isTagEnabled:COMMENT
Method Modifier: public      
Comment:/**
 * Checks any blacklists (set in system settings) to see whether a certain
 * tag is allowed.  Entries with disabled tags will be dropped immediately,
 * so you can save the work of actually constructing and sending the data.
 *
 * @param tag that would be used in {@link #addText} or {@link #addFile}
 * @return whether events with that tag would be accepted
 */

Body of Frist Method:
{
    try {
        return mService.isTagEnabled(tag);
    } catch (RemoteException e) {
        return false;
    }
}
Body of Second Method:
{
    try {
        return mService.isTagEnabled(tag);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.accounts.AccountManager.updateAppPermission:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Change whether or not an app (identified by its uid) is allowed to retrieve an authToken
 * for an account.
 * <p>
 * This is only meant to be used by system activities and is not in the SDK.
 * @param account The account whose permissions are being modified
 * @param authTokenType The type of token whose permissions are being modified
 * @param uid The uid that identifies the app which is being granted or revoked permission.
 * @param value true is permission is being granted, false for revoked
 * @hide
 */

Body of Frist Method:
{
    try {
        mService.updateAppPermission(account, authTokenType, uid, value);
    } catch (RemoteException e) {
        // won't ever happen
        throw new RuntimeException(e);
    }
}
Body of Second Method:
{
    try {
        mService.updateAppPermission(account, authTokenType, uid, value);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.media.AudioManager.getStreamMaxVolume:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the maximum volume index for a particular stream.
 *
 * @param streamType The stream type whose maximum volume index is returned.
 * @return The maximum valid volume index for the stream.
 * @see #getStreamVolume(int)
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        return service.getStreamMaxVolume(streamType);
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in getStreamMaxVolume", e);
        return 0;
    }
}
Body of Second Method:
{
    IAudioService service = getService();
    try {
        return service.getStreamMaxVolume(streamType);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.accounts.AccountManager.invalidateAuthToken:COMMENT
Method Modifier: public      
Comment:/**
 * Removes an auth token from the AccountManager's cache.  Does nothing if
 * the auth token is not currently in the cache.  Applications must call this
 * method when the auth token is found to have expired or otherwise become
 * invalid for authenticating requests.  The AccountManager does not validate
 * or expire cached auth tokens otherwise.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * MANAGE_ACCOUNTS or USE_CREDENTIALS permission is needed for those
 * platforms. See docs for this function in API level 22.
 *
 * @param accountType The account type of the auth token to invalidate, must not be null
 * @param authToken The auth token to invalidate, may be null
 */

Body of Frist Method:
{
    if (accountType == null)
        throw new IllegalArgumentException("accountType is null");
    try {
        if (authToken != null) {
            mService.invalidateAuthToken(accountType, authToken);
        }
    } catch (RemoteException e) {
        // won't ever happen
        throw new RuntimeException(e);
    }
}
Body of Second Method:
{
    if (accountType == null)
        throw new IllegalArgumentException("accountType is null");
    try {
        if (authToken != null) {
            mService.invalidateAuthToken(accountType, authToken);
        }
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.net.TrafficStats.incrementOperationCount:COMMENT
Method Modifier: public      static      
Comment:/**
 * Increment count of network operations performed under the given
 * accounting tag. This can be used to derive bytes-per-operation.
 *
 * @param tag Accounting tag used in {@link #setThreadStatsTag(int)}.
 * @param operationCount Number of operations to increment count by.
 */

Body of Frist Method:
{
    final int uid = android.os.Process.myUid();
    try {
        getStatsService().incrementOperationCount(uid, tag, operationCount);
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}
Body of Second Method:
{
    final int uid = android.os.Process.myUid();
    try {
        getStatsService().incrementOperationCount(uid, tag, operationCount);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.hardware.camera2.DngCreator.setOrientation:COMMENT
Method Modifier: public      
Comment:/**
 * Set the orientation value to write.
 *
 * <p>
 * This will be written as the TIFF "Orientation" tag {@code (0x0112)}.
 * Calling this will override any prior settings for this tag.
 * </p>
 *
 * @param orientation the orientation value to set, one of:
 * <ul>
 * <li>{@link android.media.ExifInterface#ORIENTATION_NORMAL}</li>
 * <li>{@link android.media.ExifInterface#ORIENTATION_FLIP_HORIZONTAL}</li>
 * <li>{@link android.media.ExifInterface#ORIENTATION_ROTATE_180}</li>
 * <li>{@link android.media.ExifInterface#ORIENTATION_FLIP_VERTICAL}</li>
 * <li>{@link android.media.ExifInterface#ORIENTATION_TRANSPOSE}</li>
 * <li>{@link android.media.ExifInterface#ORIENTATION_ROTATE_90}</li>
 * <li>{@link android.media.ExifInterface#ORIENTATION_TRANSVERSE}</li>
 * <li>{@link android.media.ExifInterface#ORIENTATION_ROTATE_270}</li>
 * </ul>
 * @return this {@link #DngCreator} object.
 */

Body of Frist Method:
{
    if (orientation < ExifInterface.ORIENTATION_UNDEFINED || orientation > ExifInterface.ORIENTATION_ROTATE_270) {
        throw new IllegalArgumentException("Orientation " + orientation + " is not a valid EXIF orientation value");
    }
    nativeSetOrientation(orientation);
    return this;
}
Body of Second Method:
{
    if (orientation < ExifInterface.ORIENTATION_UNDEFINED || orientation > ExifInterface.ORIENTATION_ROTATE_270) {
        throw new IllegalArgumentException("Orientation " + orientation + " is not a valid EXIF orientation value");
    }
    // "Unknown" orientation; other values map directly
    if (orientation == ExifInterface.ORIENTATION_UNDEFINED) {
        orientation = TAG_ORIENTATION_UNKNOWN;
    }
    nativeSetOrientation(orientation);
    return this;
}
------------------------
Find a silently evolved API code:android.location.Location.makeComplete:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Helper to fill incomplete fields.
 *
 * <p>Used to assist in backwards compatibility with
 * Location objects received from applications.
 *
 * @see #isComplete
 * @hide
 */

Body of Frist Method:
{
    if (mProvider == null)
        mProvider = "?";
    if (!mHasAccuracy) {
        mHasAccuracy = true;
        mAccuracy = 100.0f;
    }
    if (mTime == 0)
        mTime = System.currentTimeMillis();
    if (mElapsedRealtimeNanos == 0)
        mElapsedRealtimeNanos = SystemClock.elapsedRealtimeNanos();
}
Body of Second Method:
{
    if (mProvider == null)
        mProvider = "?";
    if (!hasAccuracy()) {
        mFieldsMask |= HAS_ACCURACY_MASK;
        mAccuracy = 100.0f;
    }
    if (mTime == 0)
        mTime = System.currentTimeMillis();
    if (mElapsedRealtimeNanos == 0)
        mElapsedRealtimeNanos = SystemClock.elapsedRealtimeNanos();
}
------------------------
Find a silently evolved API code:android.graphics.drawable.LayerDrawable.setLayerInset:COMMENT
Method Modifier: public      
Comment:/**
 * Specifies the insets in pixels for the drawable at the specified index.
 *
 * @param index the index of the drawable to adjust
 * @param l number of pixels to add to the left bound
 * @param t number of pixels to add to the top bound
 * @param r number of pixels to subtract from the right bound
 * @param b number of pixels to subtract from the bottom bound
 *
 * @attr ref android.R.styleable#LayerDrawableItem_left
 * @attr ref android.R.styleable#LayerDrawableItem_top
 * @attr ref android.R.styleable#LayerDrawableItem_right
 * @attr ref android.R.styleable#LayerDrawableItem_bottom
 */

Body of Frist Method:
{
    setLayerInsetInternal(index, l, t, r, b, UNDEFINED_INSET, UNDEFINED_INSET);
}
Body of Second Method:
{
    setLayerInsetInternal(index, l, t, r, b, INSET_UNDEFINED, INSET_UNDEFINED);
}
------------------------
Find a silently evolved API code:android.os.StrictMode.parsePolicyFromMessage:COMMENT
Method Modifier: private     static      
Comment:/**
 * Parses the BlockGuard policy mask out from the Exception's
 * getMessage() String value.  Kinda gross, but least
 * invasive.  :/
 *
 * Input is of the following forms:
 * "policy=137 violation=64"
 * "policy=137 violation=64 msg=Arbitrary text"
 *
 * Returns 0 on failure, which is a valid policy, but not a
 * valid policy during a violation (else there must've been
 * some policy in effect to violate).
 */

Body of Frist Method:
{
    if (message == null || !message.startsWith("policy=")) {
        return 0;
    }
    int spaceIndex = message.indexOf(' ');
    if (spaceIndex == -1) {
        return 0;
    }
    String policyString = message.substring(7, spaceIndex);
    try {
        return Integer.valueOf(policyString).intValue();
    } catch (NumberFormatException e) {
        return 0;
    }
}
Body of Second Method:
{
    if (message == null || !message.startsWith("policy=")) {
        return 0;
    }
    int spaceIndex = message.indexOf(' ');
    if (spaceIndex == -1) {
        return 0;
    }
    String policyString = message.substring(7, spaceIndex);
    try {
        return Integer.parseInt(policyString);
    } catch (NumberFormatException e) {
        return 0;
    }
}
------------------------
Find a silently evolved API code:android.graphics.drawable.BitmapDrawable.updateLocalState:COMMENT
Method Modifier: private     
Comment:/**
 * Initializes local dynamic properties from state. This should be called
 * after significant state changes, e.g. from the One True Constructor and
 * after inflating or applying a theme.
 */

Body of Frist Method:
{
    if (res != null) {
        final int densityDpi = res.getDisplayMetrics().densityDpi;
        mTargetDensity = densityDpi == 0 ? DisplayMetrics.DENSITY_DEFAULT : densityDpi;
    } else {
        mTargetDensity = mBitmapState.mTargetDensity;
    }
    mTintFilter = updateTintFilter(mTintFilter, mBitmapState.mTint, mBitmapState.mTintMode);
    computeBitmapSize();
}
Body of Second Method:
{
    mTargetDensity = resolveDensity(res, mBitmapState.mTargetDensity);
    mTintFilter = updateTintFilter(mTintFilter, mBitmapState.mTint, mBitmapState.mTintMode);
    computeBitmapSize();
}
------------------------
Find a silently evolved API code:android.content.res.BridgeTypedArray.getTextArray:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the CharSequence[] for the attribute at <var>index</var>.
 * This gets the resource ID of the selected attribute, and uses
 * {@link Resources#getTextArray Resources.getTextArray} of the owning
 * Resources object to retrieve its String[].
 *
 * @param index Index of attribute to retrieve.
 *
 * @return CharSequence[] for the attribute, or null if not defined.
 */

Body of Frist Method:
{
    String value = getString(index);
    if (value != null) {
        return new CharSequence[] { value };
    }
    return null;
}
Body of Second Method:
{
    if (!hasValue(index)) {
        return null;
    }
    ResourceValue resVal = mResourceData[index];
    if (resVal instanceof ArrayResourceValue) {
        ArrayResourceValue array = (ArrayResourceValue) resVal;
        int count = array.getElementCount();
        return count >= 0 ? Resources_Delegate.fillValues(mBridgeResources, array, new CharSequence[count]) : null;
    }
    int id = getResourceId(index, 0);
    String resIdMessage = id > 0 ? " (resource id 0x" + Integer.toHexString(id) + ')' : "";
    throw new NotFoundException(String.format("%1$s in %2$s%3$s is not a valid array resource.", resVal.getValue(), mNames[index], resIdMessage));
}
------------------------
Find a silently evolved API code:android.net.ConnectivityManager.removeDefaultNetworkActiveListener:COMMENT
Method Modifier: public      
Comment:/**
 * Remove network active listener previously registered with
 * {@link #addDefaultNetworkActiveListener}.
 *
 * @param l Previously registered listener.
 */

Body of Frist Method:
{
    INetworkActivityListener rl = mNetworkActivityListeners.get(l);
    if (rl == null) {
        throw new IllegalArgumentException("Listener not registered: " + l);
    }
    try {
        getNetworkManagementService().unregisterNetworkActivityListener(rl);
    } catch (RemoteException e) {
    }
}
Body of Second Method:
{
    INetworkActivityListener rl = mNetworkActivityListeners.get(l);
    if (rl == null) {
        throw new IllegalArgumentException("Listener not registered: " + l);
    }
    try {
        getNetworkManagementService().unregisterNetworkActivityListener(rl);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.view.DragEvent.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Creates a {@link android.os.Parcel} object from this DragEvent object.
 * @param dest A {@link android.os.Parcel} object in which to put the DragEvent object.
 * @param flags Flags to store in the Parcel.
 */

Body of Frist Method:
{
    dest.writeInt(mAction);
    dest.writeFloat(mX);
    dest.writeFloat(mY);
    dest.writeInt(mDragResult ? 1 : 0);
    if (mClipData == null) {
        dest.writeInt(0);
    } else {
        dest.writeInt(1);
        mClipData.writeToParcel(dest, flags);
    }
    if (mClipDescription == null) {
        dest.writeInt(0);
    } else {
        dest.writeInt(1);
        mClipDescription.writeToParcel(dest, flags);
    }
}
Body of Second Method:
{
    dest.writeInt(mAction);
    dest.writeFloat(mX);
    dest.writeFloat(mY);
    dest.writeInt(mDragResult ? 1 : 0);
    if (mClipData == null) {
        dest.writeInt(0);
    } else {
        dest.writeInt(1);
        mClipData.writeToParcel(dest, flags);
    }
    if (mClipDescription == null) {
        dest.writeInt(0);
    } else {
        dest.writeInt(1);
        mClipDescription.writeToParcel(dest, flags);
    }
    if (mDragAndDropPermissions == null) {
        dest.writeInt(0);
    } else {
        dest.writeInt(1);
        dest.writeStrongBinder(mDragAndDropPermissions.asBinder());
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiScanner.stopTrackingWifiChange:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * stop tracking changes in wifi environment
 * @param listener object that was provided to report events on {@link
 * #stopTrackingWifiChange}
 */

Body of Frist Method:
{
    validateChannel();
    sAsyncChannel.sendMessage(CMD_STOP_TRACKING_CHANGE, 0, removeListener(listener));
}
Body of Second Method:
{
    int key = removeListener(listener);
    if (key == INVALID_KEY)
        return;
    validateChannel();
    mAsyncChannel.sendMessage(CMD_STOP_TRACKING_CHANGE, 0, key);
}
------------------------
Find a silently evolved API code:android.app.WallpaperManager.clearWallpaperOffsets:COMMENT
Method Modifier: public      
Comment:/**
 * Clear the offsets previously associated with this window through
 * {@link #setWallpaperOffsets(IBinder, float, float)}.  This reverts
 * the window to its default state, where it does not cause the wallpaper
 * to scroll from whatever its last offsets were.
 *
 * @param windowToken The window who these offsets should be associated
 * with, as returned by {@link android.view.View#getWindowToken()
 * View.getWindowToken()}.
 */

Body of Frist Method:
{
    try {
        WindowManagerGlobal.getWindowSession().setWallpaperPosition(windowToken, -1, -1, -1, -1);
    } catch (RemoteException e) {
    // Ignore.
    }
}
Body of Second Method:
{
    try {
        WindowManagerGlobal.getWindowSession().setWallpaperPosition(windowToken, -1, -1, -1, -1);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.net.nsd.NsdManager.setEnabled:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Internal use only @hide
 */

Body of Frist Method:
{
    try {
        mService.setEnabled(enabled);
    } catch (RemoteException e) {
    }
}
Body of Second Method:
{
    try {
        mService.setEnabled(enabled);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.net.LocalSocketImpl.SocketOutputStream.flush:COMMENT
Method Modifier: public      
Comment:/**
 * Wait until the data in sending queue is emptied. A polling version
 * for flush implementation.
 * @throws IOException
 * if an i/o error occurs.
 */

Body of Frist Method:
{
    FileDescriptor myFd = fd;
    if (myFd == null)
        throw new IOException("socket closed");
    while (pending_native(myFd) > 0) {
        try {
            Thread.sleep(10);
        } catch (InterruptedException ie) {
            return;
        }
    }
}
Body of Second Method:
{
    FileDescriptor myFd = fd;
    if (myFd == null)
        throw new IOException("socket closed");
    // Loop until the output buffer is empty.
    MutableInt pending = new MutableInt(0);
    while (true) {
        try {
            // See linux/net/unix/af_unix.c
            Os.ioctlInt(myFd, OsConstants.TIOCOUTQ, pending);
        } catch (ErrnoException e) {
            throw e.rethrowAsIOException();
        }
        if (pending.value <= 0) {
            // The output buffer is empty.
            break;
        }
        try {
            Thread.sleep(10);
        } catch (InterruptedException ie) {
            break;
        }
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiManager.MulticastLock.acquire:COMMENT
Method Modifier: public      
Comment:/**
 * Locks Wifi Multicast on until {@link #release} is called.
 *
 * If this MulticastLock is reference-counted each call to
 * {@code acquire} will increment the reference count, and the
 * wifi interface will receive multicast packets as long as the
 * reference count is above zero.
 *
 * If this MulticastLock is not reference-counted, the first call to
 * {@code acquire} will turn on the multicast packets, but subsequent
 * calls will be ignored.  Only one call to {@link #release} will
 * be required, regardless of the number of times that {@code acquire}
 * is called.
 *
 * Note that other applications may also lock Wifi Multicast on.
 * Only they can relinquish their lock.
 *
 * Also note that applications cannot leave Multicast locked on.
 * When an app exits or crashes, any Multicast locks will be released.
 */

Body of Frist Method:
{
    synchronized (mBinder) {
        if (mRefCounted ? (++mRefCount == 1) : (!mHeld)) {
            try {
                mService.acquireMulticastLock(mBinder, mTag);
                synchronized (WifiManager.this) {
                    if (mActiveLockCount >= MAX_ACTIVE_LOCKS) {
                        mService.releaseMulticastLock();
                        throw new UnsupportedOperationException("Exceeded maximum number of wifi locks");
                    }
                    mActiveLockCount++;
                }
            } catch (RemoteException ignore) {
            }
            mHeld = true;
        }
    }
}
Body of Second Method:
{
    synchronized (mBinder) {
        if (mRefCounted ? (++mRefCount == 1) : (!mHeld)) {
            try {
                mService.acquireMulticastLock(mBinder, mTag);
                synchronized (WifiManager.this) {
                    if (mActiveLockCount >= MAX_ACTIVE_LOCKS) {
                        mService.releaseMulticastLock();
                        throw new UnsupportedOperationException("Exceeded maximum number of wifi locks");
                    }
                    mActiveLockCount++;
                }
            } catch (RemoteException e) {
                throw e.rethrowFromSystemServer();
            }
            mHeld = true;
        }
    }
}
------------------------
Find a silently evolved API code:android.media.AudioFormat.isEncodingLinearPcm:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    switch(audioFormat) {
        case ENCODING_PCM_8BIT:
        case ENCODING_PCM_16BIT:
        case ENCODING_PCM_FLOAT:
        case ENCODING_DEFAULT:
            return true;
        case ENCODING_AC3:
        case ENCODING_E_AC3:
        case ENCODING_DTS:
        case ENCODING_DTS_HD:
        case ENCODING_MP3:
        case ENCODING_AAC_LC:
        case ENCODING_AAC_HE_V1:
        case ENCODING_AAC_HE_V2:
            return false;
        case ENCODING_INVALID:
        default:
            throw new IllegalArgumentException("Bad audio format " + audioFormat);
    }
}
Body of Second Method:
{
    switch(audioFormat) {
        case ENCODING_PCM_8BIT:
        case ENCODING_PCM_16BIT:
        case ENCODING_PCM_FLOAT:
        case ENCODING_DEFAULT:
            return true;
        case ENCODING_AC3:
        case ENCODING_E_AC3:
        case ENCODING_DTS:
        case ENCODING_DTS_HD:
        case ENCODING_MP3:
        case ENCODING_AAC_LC:
        case ENCODING_AAC_HE_V1:
        case ENCODING_AAC_HE_V2:
        case // wrapped in PCM but compressed
        ENCODING_IEC61937:
            return false;
        case ENCODING_INVALID:
        default:
            throw new IllegalArgumentException("Bad audio format " + audioFormat);
    }
}
------------------------
Find a silently evolved API code:android.location.Location.hasAltitude:COMMENT
Method Modifier: public      
Comment:/**
 * True if this location has an altitude.
 */

Body of Frist Method:
{
    return mHasAltitude;
}
Body of Second Method:
{
    return (mFieldsMask & HAS_ALTITUDE_MASK) != 0;
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiManager.forget:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Delete the network in the supplicant config.
 *
 * This function is used instead of a sequence of removeNetwork()
 * and saveConfiguration().
 *
 * @param config the set of variables that describe the configuration,
 * contained in a {@link WifiConfiguration} object.
 * @param listener for callbacks on success or failure. Can be null.
 * @throws IllegalStateException if the WifiManager instance needs to be
 * initialized again
 * @hide
 */

Body of Frist Method:
{
    if (netId < 0)
        throw new IllegalArgumentException("Network id cannot be negative");
    validateChannel();
    sAsyncChannel.sendMessage(FORGET_NETWORK, netId, putListener(listener));
}
Body of Second Method:
{
    if (netId < 0)
        throw new IllegalArgumentException("Network id cannot be negative");
    getChannel().sendMessage(FORGET_NETWORK, netId, putListener(listener));
}
------------------------
Find a silently evolved API code:android.inputmethodservice.InputMethodService.clearInsetOfPreviousIme:COMMENT
Method Modifier: private     
Comment:/**
 * Reset the inset occupied the previous IME when and only when
 * {@link #mShouldClearInsetOfPreviousIme} is {@code true}.
 */

Body of Frist Method:
{
    if (DEBUG)
        Log.v(TAG, "clearInsetOfPreviousIme() " + " mShouldClearInsetOfPreviousIme=" + mShouldClearInsetOfPreviousIme);
    if (!mShouldClearInsetOfPreviousIme || mWindow == null)
        return;
    try {
        // We do not call onWindowShown() and onWindowHidden() so as not to make the IME author
        // confused.
        // TODO: Find out a better way which has less side-effect.
        mWindow.show();
        mWindow.hide();
    } catch (WindowManager.BadTokenException e) {
        if (DEBUG)
            Log.v(TAG, "clearInsetOfPreviousIme: BadTokenException: IME is done.");
        mWindowVisible = false;
        mWindowAdded = false;
    }
    mShouldClearInsetOfPreviousIme = false;
}
Body of Second Method:
{
    if (DEBUG)
        Log.v(TAG, "clearInsetOfPreviousIme() " + " mShouldClearInsetOfPreviousIme=" + mShouldClearInsetOfPreviousIme);
    if (!mShouldClearInsetOfPreviousIme)
        return;
    mImm.clearLastInputMethodWindowForTransition(mToken);
    mShouldClearInsetOfPreviousIme = false;
}
------------------------
Find a silently evolved API code:android.net.ConnectivityManager.getNetworkInfo:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * Returns connection status information about a particular
 * network type.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
 *
 * @param networkType integer specifying which networkType in
 * which you're interested.
 * @return a {@link NetworkInfo} object for the requested
 * network type or {@code null} if the type is not
 * supported by the device.
 *
 * @deprecated This method does not support multiple connected networks
 * of the same type. Use {@link #getAllNetworks} and
 * {@link #getNetworkInfo(android.net.Network)} instead.
 */

Body of Frist Method:
{
    try {
        return mService.getNetworkInfo(networkType);
    } catch (RemoteException e) {
        return null;
    }
}
Body of Second Method:
{
    try {
        return mService.getNetworkInfo(networkType);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiManager.setWifiEnabled:COMMENT
Method Modifier: public      
Comment:/**
 * Enable or disable Wi-Fi.
 * @param enabled {@code true} to enable, {@code false} to disable.
 * @return {@code true} if the operation succeeds (or if the existing state
 * is the same as the requested state).
 */

Body of Frist Method:
{
    try {
        return mService.setWifiEnabled(enabled);
    } catch (RemoteException e) {
        return false;
    }
}
Body of Second Method:
{
    try {
        return mService.setWifiEnabled(enabled);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.media.AudioManager.isStreamMute:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the current mute state for a particular stream.
 *
 * @param streamType The stream to get mute state for.
 * @return The mute state for the given stream.
 * @see #adjustStreamVolume(int, int, int)
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        return service.isStreamMute(streamType);
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in isStreamMute", e);
        return false;
    }
}
Body of Second Method:
{
    IAudioService service = getService();
    try {
        return service.isStreamMute(streamType);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiManager.disable:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Disable network
 *
 * @param netId is the network Id
 * @param listener for callbacks on success or failure. Can be null.
 * @throws IllegalStateException if the WifiManager instance needs to be
 * initialized again
 * @hide
 */

Body of Frist Method:
{
    if (netId < 0)
        throw new IllegalArgumentException("Network id cannot be negative");
    validateChannel();
    sAsyncChannel.sendMessage(DISABLE_NETWORK, netId, putListener(listener));
}
Body of Second Method:
{
    if (netId < 0)
        throw new IllegalArgumentException("Network id cannot be negative");
    getChannel().sendMessage(DISABLE_NETWORK, netId, putListener(listener));
}
------------------------
Find a silently evolved API code:android.text.TextUtils.isDigitsOnly:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns whether the given CharSequence contains only digits.
 */

Body of Frist Method:
{
    final int len = str.length();
    for (int i = 0; i < len; i++) {
        if (!Character.isDigit(str.charAt(i))) {
            return false;
        }
    }
    return true;
}
Body of Second Method:
{
    final int len = str.length();
    for (int cp, i = 0; i < len; i += Character.charCount(cp)) {
        cp = Character.codePointAt(str, i);
        if (!Character.isDigit(cp)) {
            return false;
        }
    }
    return true;
}
------------------------
Find a silently evolved API code:android.hardware.usb.UsbManager.getDeviceList:COMMENT
Method Modifier: public      
Comment:/**
 * Returns a HashMap containing all USB devices currently attached.
 * USB device name is the key for the returned HashMap.
 * The result will be empty if no devices are attached, or if
 * USB host mode is inactive or unsupported.
 *
 * @return HashMap containing all connected USB devices.
 */

Body of Frist Method:
{
    Bundle bundle = new Bundle();
    try {
        mService.getDeviceList(bundle);
        HashMap<String, UsbDevice> result = new HashMap<String, UsbDevice>();
        for (String name : bundle.keySet()) {
            result.put(name, (UsbDevice) bundle.get(name));
        }
        return result;
    } catch (RemoteException e) {
        Log.e(TAG, "RemoteException in getDeviceList", e);
        return null;
    }
}
Body of Second Method:
{
    Bundle bundle = new Bundle();
    try {
        mService.getDeviceList(bundle);
        HashMap<String, UsbDevice> result = new HashMap<String, UsbDevice>();
        for (String name : bundle.keySet()) {
            result.put(name, (UsbDevice) bundle.get(name));
        }
        return result;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.view.ScaleGestureDetector.onTouchEvent:COMMENT
Method Modifier: public      
Comment:/**
 * Accepts MotionEvents and dispatches events to a {@link OnScaleGestureListener}
 * when appropriate.
 *
 * <p>Applications should pass a complete and consistent event stream to this method.
 * A complete and consistent event stream involves all MotionEvents from the initial
 * ACTION_DOWN to the final ACTION_UP or ACTION_CANCEL.</p>
 *
 * @param event The event to process
 * @return true if the event was processed and the detector wants to receive the
 * rest of the MotionEvents in this event stream.
 */

Body of Frist Method:
{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(event, 0);
    }
    mCurrTime = event.getEventTime();
    final int action = event.getActionMasked();
    // Forward the event to check for double tap gesture
    if (mQuickScaleEnabled) {
        mGestureDetector.onTouchEvent(event);
    }
    final int count = event.getPointerCount();
    final boolean isStylusButtonDown = (event.getButtonState() & MotionEvent.BUTTON_STYLUS_PRIMARY) != 0;
    final boolean anchoredScaleCancelled = mAnchoredScaleMode == ANCHORED_SCALE_MODE_STYLUS && !isStylusButtonDown;
    final boolean streamComplete = action == MotionEvent.ACTION_UP || action == MotionEvent.ACTION_CANCEL || anchoredScaleCancelled;
    if (action == MotionEvent.ACTION_DOWN || streamComplete) {
        // This means the app probably didn't give us all the events. Shame on it.
        if (mInProgress) {
            mListener.onScaleEnd(this);
            mInProgress = false;
            mInitialSpan = 0;
            mAnchoredScaleMode = ANCHORED_SCALE_MODE_NONE;
        } else if (inAnchoredScaleMode() && streamComplete) {
            mInProgress = false;
            mInitialSpan = 0;
            mAnchoredScaleMode = ANCHORED_SCALE_MODE_NONE;
        }
        if (streamComplete) {
            clearTouchHistory();
            return true;
        }
    }
    if (!mInProgress && mStylusScaleEnabled && !inAnchoredScaleMode() && !streamComplete && isStylusButtonDown) {
        // Start of a button scale gesture
        mAnchoredScaleStartX = event.getX();
        mAnchoredScaleStartY = event.getY();
        mAnchoredScaleMode = ANCHORED_SCALE_MODE_STYLUS;
        mInitialSpan = 0;
    }
    final boolean configChanged = action == MotionEvent.ACTION_DOWN || action == MotionEvent.ACTION_POINTER_UP || action == MotionEvent.ACTION_POINTER_DOWN || anchoredScaleCancelled;
    final boolean pointerUp = action == MotionEvent.ACTION_POINTER_UP;
    final int skipIndex = pointerUp ? event.getActionIndex() : -1;
    // Determine focal point
    float sumX = 0, sumY = 0;
    final int div = pointerUp ? count - 1 : count;
    final float focusX;
    final float focusY;
    if (inAnchoredScaleMode()) {
        // In anchored scale mode, the focal pt is always where the double tap
        // or button down gesture started
        focusX = mAnchoredScaleStartX;
        focusY = mAnchoredScaleStartY;
        if (event.getY() < focusY) {
            mEventBeforeOrAboveStartingGestureEvent = true;
        } else {
            mEventBeforeOrAboveStartingGestureEvent = false;
        }
    } else {
        for (int i = 0; i < count; i++) {
            if (skipIndex == i)
                continue;
            sumX += event.getX(i);
            sumY += event.getY(i);
        }
        focusX = sumX / div;
        focusY = sumY / div;
    }
    addTouchHistory(event);
    // Determine average deviation from focal point
    float devSumX = 0, devSumY = 0;
    for (int i = 0; i < count; i++) {
        if (skipIndex == i)
            continue;
        // Convert the resulting diameter into a radius.
        final float touchSize = mTouchHistoryLastAccepted / 2;
        devSumX += Math.abs(event.getX(i) - focusX) + touchSize;
        devSumY += Math.abs(event.getY(i) - focusY) + touchSize;
    }
    final float devX = devSumX / div;
    final float devY = devSumY / div;
    // Span is the average distance between touch points through the focal point;
    // i.e. the diameter of the circle with a radius of the average deviation from
    // the focal point.
    final float spanX = devX * 2;
    final float spanY = devY * 2;
    final float span;
    if (inAnchoredScaleMode()) {
        span = spanY;
    } else {
        span = (float) Math.hypot(spanX, spanY);
    }
    // Dispatch begin/end events as needed.
    // If the configuration changes, notify the app to reset its current state by beginning
    // a fresh scale event stream.
    final boolean wasInProgress = mInProgress;
    mFocusX = focusX;
    mFocusY = focusY;
    if (!inAnchoredScaleMode() && mInProgress && (span < mMinSpan || configChanged)) {
        mListener.onScaleEnd(this);
        mInProgress = false;
        mInitialSpan = span;
    }
    if (configChanged) {
        mPrevSpanX = mCurrSpanX = spanX;
        mPrevSpanY = mCurrSpanY = spanY;
        mInitialSpan = mPrevSpan = mCurrSpan = span;
    }
    final int minSpan = inAnchoredScaleMode() ? mSpanSlop : mMinSpan;
    if (!mInProgress && span >= minSpan && (wasInProgress || Math.abs(span - mInitialSpan) > mSpanSlop)) {
        mPrevSpanX = mCurrSpanX = spanX;
        mPrevSpanY = mCurrSpanY = spanY;
        mPrevSpan = mCurrSpan = span;
        mPrevTime = mCurrTime;
        mInProgress = mListener.onScaleBegin(this);
    }
    // Handle motion; focal point and span/scale factor are changing.
    if (action == MotionEvent.ACTION_MOVE) {
        mCurrSpanX = spanX;
        mCurrSpanY = spanY;
        mCurrSpan = span;
        boolean updatePrev = true;
        if (mInProgress) {
            updatePrev = mListener.onScale(this);
        }
        if (updatePrev) {
            mPrevSpanX = mCurrSpanX;
            mPrevSpanY = mCurrSpanY;
            mPrevSpan = mCurrSpan;
            mPrevTime = mCurrTime;
        }
    }
    return true;
}
Body of Second Method:
{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(event, 0);
    }
    mCurrTime = event.getEventTime();
    final int action = event.getActionMasked();
    // Forward the event to check for double tap gesture
    if (mQuickScaleEnabled) {
        mGestureDetector.onTouchEvent(event);
    }
    final int count = event.getPointerCount();
    final boolean isStylusButtonDown = (event.getButtonState() & MotionEvent.BUTTON_STYLUS_PRIMARY) != 0;
    final boolean anchoredScaleCancelled = mAnchoredScaleMode == ANCHORED_SCALE_MODE_STYLUS && !isStylusButtonDown;
    final boolean streamComplete = action == MotionEvent.ACTION_UP || action == MotionEvent.ACTION_CANCEL || anchoredScaleCancelled;
    if (action == MotionEvent.ACTION_DOWN || streamComplete) {
        // This means the app probably didn't give us all the events. Shame on it.
        if (mInProgress) {
            mListener.onScaleEnd(this);
            mInProgress = false;
            mInitialSpan = 0;
            mAnchoredScaleMode = ANCHORED_SCALE_MODE_NONE;
        } else if (inAnchoredScaleMode() && streamComplete) {
            mInProgress = false;
            mInitialSpan = 0;
            mAnchoredScaleMode = ANCHORED_SCALE_MODE_NONE;
        }
        if (streamComplete) {
            return true;
        }
    }
    if (!mInProgress && mStylusScaleEnabled && !inAnchoredScaleMode() && !streamComplete && isStylusButtonDown) {
        // Start of a button scale gesture
        mAnchoredScaleStartX = event.getX();
        mAnchoredScaleStartY = event.getY();
        mAnchoredScaleMode = ANCHORED_SCALE_MODE_STYLUS;
        mInitialSpan = 0;
    }
    final boolean configChanged = action == MotionEvent.ACTION_DOWN || action == MotionEvent.ACTION_POINTER_UP || action == MotionEvent.ACTION_POINTER_DOWN || anchoredScaleCancelled;
    final boolean pointerUp = action == MotionEvent.ACTION_POINTER_UP;
    final int skipIndex = pointerUp ? event.getActionIndex() : -1;
    // Determine focal point
    float sumX = 0, sumY = 0;
    final int div = pointerUp ? count - 1 : count;
    final float focusX;
    final float focusY;
    if (inAnchoredScaleMode()) {
        // In anchored scale mode, the focal pt is always where the double tap
        // or button down gesture started
        focusX = mAnchoredScaleStartX;
        focusY = mAnchoredScaleStartY;
        if (event.getY() < focusY) {
            mEventBeforeOrAboveStartingGestureEvent = true;
        } else {
            mEventBeforeOrAboveStartingGestureEvent = false;
        }
    } else {
        for (int i = 0; i < count; i++) {
            if (skipIndex == i)
                continue;
            sumX += event.getX(i);
            sumY += event.getY(i);
        }
        focusX = sumX / div;
        focusY = sumY / div;
    }
    // Determine average deviation from focal point
    float devSumX = 0, devSumY = 0;
    for (int i = 0; i < count; i++) {
        if (skipIndex == i)
            continue;
        // Convert the resulting diameter into a radius.
        devSumX += Math.abs(event.getX(i) - focusX);
        devSumY += Math.abs(event.getY(i) - focusY);
    }
    final float devX = devSumX / div;
    final float devY = devSumY / div;
    // Span is the average distance between touch points through the focal point;
    // i.e. the diameter of the circle with a radius of the average deviation from
    // the focal point.
    final float spanX = devX * 2;
    final float spanY = devY * 2;
    final float span;
    if (inAnchoredScaleMode()) {
        span = spanY;
    } else {
        span = (float) Math.hypot(spanX, spanY);
    }
    // Dispatch begin/end events as needed.
    // If the configuration changes, notify the app to reset its current state by beginning
    // a fresh scale event stream.
    final boolean wasInProgress = mInProgress;
    mFocusX = focusX;
    mFocusY = focusY;
    if (!inAnchoredScaleMode() && mInProgress && (span < mMinSpan || configChanged)) {
        mListener.onScaleEnd(this);
        mInProgress = false;
        mInitialSpan = span;
    }
    if (configChanged) {
        mPrevSpanX = mCurrSpanX = spanX;
        mPrevSpanY = mCurrSpanY = spanY;
        mInitialSpan = mPrevSpan = mCurrSpan = span;
    }
    final int minSpan = inAnchoredScaleMode() ? mSpanSlop : mMinSpan;
    if (!mInProgress && span >= minSpan && (wasInProgress || Math.abs(span - mInitialSpan) > mSpanSlop)) {
        mPrevSpanX = mCurrSpanX = spanX;
        mPrevSpanY = mCurrSpanY = spanY;
        mPrevSpan = mCurrSpan = span;
        mPrevTime = mCurrTime;
        mInProgress = mListener.onScaleBegin(this);
    }
    // Handle motion; focal point and span/scale factor are changing.
    if (action == MotionEvent.ACTION_MOVE) {
        mCurrSpanX = spanX;
        mCurrSpanY = spanY;
        mCurrSpan = span;
        boolean updatePrev = true;
        if (mInProgress) {
            updatePrev = mListener.onScale(this);
        }
        if (updatePrev) {
            mPrevSpanX = mCurrSpanX;
            mPrevSpanY = mCurrSpanY;
            mPrevSpan = mCurrSpan;
            mPrevTime = mCurrTime;
        }
    }
    return true;
}
------------------------
Find a silently evolved API code:android.media.AudioManager.requestAudioFocusForCall:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 * Used internally by telephony package to request audio focus. Will cause the focus request
 * to be associated with the "voice communication" identifier only used in AudioService
 * to identify this use case.
 * @param streamType use STREAM_RING for focus requests when ringing, VOICE_CALL for
 * the establishment of the call
 * @param durationHint the type of focus request. AUDIOFOCUS_GAIN_TRANSIENT is recommended so
 * media applications resume after a call
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        service.requestAudioFocus(new AudioAttributes.Builder().setInternalLegacyStreamType(streamType).build(), durationHint, mICallBack, null, AudioSystem.IN_VOICE_COMM_FOCUS_ID, getContext().getOpPackageName(), AUDIOFOCUS_FLAG_LOCK, null);
    } catch (RemoteException e) {
        Log.e(TAG, "Can't call requestAudioFocusForCall() on AudioService:", e);
    }
}
Body of Second Method:
{
    IAudioService service = getService();
    try {
        service.requestAudioFocus(new AudioAttributes.Builder().setInternalLegacyStreamType(streamType).build(), durationHint, mICallBack, null, AudioSystem.IN_VOICE_COMM_FOCUS_ID, getContext().getOpPackageName(), AUDIOFOCUS_FLAG_LOCK, null);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.app.ActivityManager.getRunningTasks:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * Return a list of the tasks that are currently running, with
 * the most recent being first and older ones after in order.  Note that
 * "running" does not mean any of the task's code is currently loaded or
 * activity -- the task may have been frozen by the system, so that it
 * can be restarted in its previous state when next brought to the
 * foreground.
 *
 * <p><b>Note: this method is only intended for debugging and presenting
 * task management user interfaces</b>.  This should never be used for
 * core logic in an application, such as deciding between different
 * behaviors based on the information found here.  Such uses are
 * <em>not</em> supported, and will likely break in the future.  For
 * example, if multiple applications can be actively running at the
 * same time, assumptions made about the meaning of the data here for
 * purposes of control flow will be incorrect.</p>
 *
 * @deprecated As of {@link android.os.Build.VERSION_CODES#LOLLIPOP}, this method
 * is no longer available to third party
 * applications: the introduction of document-centric recents means
 * it can leak person information to the caller.  For backwards compatibility,
 * it will still retu rn a small subset of its data: at least the caller's
 * own tasks, and possibly some other tasks
 * such as home that are known to not be sensitive.
 *
 * @param maxNum The maximum number of entries to return in the list.  The
 * actual number returned may be smaller, depending on how many tasks the
 * user has started.
 *
 * @return Returns a list of RunningTaskInfo records describing each of
 * the running tasks.
 */

Body of Frist Method:
{
    try {
        return ActivityManagerNative.getDefault().getTasks(maxNum, 0);
    } catch (RemoteException e) {
        // System dead, we will be dead too soon!
        return null;
    }
}
Body of Second Method:
{
    try {
        return ActivityManagerNative.getDefault().getTasks(maxNum, 0);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.app.UiModeManager.disableCarMode:COMMENT
Method Modifier: public      
Comment:/**
 * Turn off special mode if currently in car mode.
 * @param flags May be 0 or {@link #DISABLE_CAR_MODE_GO_HOME}.
 */

Body of Frist Method:
{
    if (mService != null) {
        try {
            mService.disableCarMode(flags);
        } catch (RemoteException e) {
            Log.e(TAG, "disableCarMode: RemoteException", e);
        }
    }
}
Body of Second Method:
{
    if (mService != null) {
        try {
            mService.disableCarMode(flags);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}
------------------------
Find a silently evolved API code:android.hardware.ConsumerIrManager.hasIrEmitter:COMMENT
Method Modifier: public      
Comment:/**
 * Check whether the device has an infrared emitter.
 *
 * @return true if the device has an infrared emitter, else false.
 */

Body of Frist Method:
{
    if (mService == null) {
        Log.w(TAG, "no consumer ir service.");
        return false;
    }
    try {
        return mService.hasIrEmitter();
    } catch (RemoteException e) {
    }
    return false;
}
Body of Second Method:
{
    if (mService == null) {
        Log.w(TAG, "no consumer ir service.");
        return false;
    }
    try {
        return mService.hasIrEmitter();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiConfiguration.writeToParcel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Implement the Parcelable interface {@hide}
 */

Body of Frist Method:
{
    dest.writeInt(networkId);
    dest.writeInt(status);
    dest.writeInt(disableReason);
    dest.writeString(SSID);
    dest.writeString(BSSID);
    dest.writeInt(apBand);
    dest.writeInt(apChannel);
    dest.writeString(autoJoinBSSID);
    dest.writeString(FQDN);
    dest.writeString(providerFriendlyName);
    dest.writeInt(roamingConsortiumIds.length);
    for (long roamingConsortiumId : roamingConsortiumIds) {
        dest.writeLong(roamingConsortiumId);
    }
    dest.writeString(preSharedKey);
    for (String wepKey : wepKeys) {
        dest.writeString(wepKey);
    }
    dest.writeInt(wepTxKeyIndex);
    dest.writeInt(priority);
    dest.writeInt(hiddenSSID ? 1 : 0);
    dest.writeInt(requirePMF ? 1 : 0);
    dest.writeString(updateIdentifier);
    writeBitSet(dest, allowedKeyManagement);
    writeBitSet(dest, allowedProtocols);
    writeBitSet(dest, allowedAuthAlgorithms);
    writeBitSet(dest, allowedPairwiseCiphers);
    writeBitSet(dest, allowedGroupCiphers);
    dest.writeParcelable(enterpriseConfig, flags);
    dest.writeParcelable(mIpConfiguration, flags);
    dest.writeString(dhcpServer);
    dest.writeString(defaultGwMacAddress);
    dest.writeInt(autoJoinStatus);
    dest.writeInt(selfAdded ? 1 : 0);
    dest.writeInt(didSelfAdd ? 1 : 0);
    dest.writeInt(validatedInternetAccess ? 1 : 0);
    dest.writeInt(ephemeral ? 1 : 0);
    dest.writeInt(creatorUid);
    dest.writeInt(lastConnectUid);
    dest.writeInt(lastUpdateUid);
    dest.writeString(creatorName);
    dest.writeString(lastUpdateName);
    dest.writeLong(blackListTimestamp);
    dest.writeLong(lastConnectionFailure);
    dest.writeLong(lastRoamingFailure);
    dest.writeInt(lastRoamingFailureReason);
    dest.writeLong(roamingFailureBlackListTimeMilli);
    dest.writeInt(numConnectionFailures);
    dest.writeInt(numIpConfigFailures);
    dest.writeInt(numAuthFailures);
    dest.writeInt(numScorerOverride);
    dest.writeInt(numScorerOverrideAndSwitchedNetwork);
    dest.writeInt(numAssociation);
    dest.writeInt(numUserTriggeredWifiDisableLowRSSI);
    dest.writeInt(numUserTriggeredWifiDisableBadRSSI);
    dest.writeInt(numUserTriggeredWifiDisableNotHighRSSI);
    dest.writeInt(numTicksAtLowRSSI);
    dest.writeInt(numTicksAtBadRSSI);
    dest.writeInt(numTicksAtNotHighRSSI);
    dest.writeInt(numUserTriggeredJoinAttempts);
    dest.writeInt(autoJoinUseAggressiveJoinAttemptThreshold);
    dest.writeInt(autoJoinBailedDueToLowRssi ? 1 : 0);
    dest.writeInt(userApproved);
    dest.writeInt(numNoInternetAccessReports);
    dest.writeInt(noInternetAccessExpected ? 1 : 0);
}
Body of Second Method:
{
    dest.writeInt(networkId);
    dest.writeInt(status);
    mNetworkSelectionStatus.writeToParcel(dest);
    dest.writeString(SSID);
    dest.writeString(BSSID);
    dest.writeInt(apBand);
    dest.writeInt(apChannel);
    dest.writeString(FQDN);
    dest.writeString(providerFriendlyName);
    dest.writeInt(roamingConsortiumIds.length);
    for (long roamingConsortiumId : roamingConsortiumIds) {
        dest.writeLong(roamingConsortiumId);
    }
    dest.writeString(preSharedKey);
    for (String wepKey : wepKeys) {
        dest.writeString(wepKey);
    }
    dest.writeInt(wepTxKeyIndex);
    dest.writeInt(priority);
    dest.writeInt(hiddenSSID ? 1 : 0);
    dest.writeInt(requirePMF ? 1 : 0);
    dest.writeString(updateIdentifier);
    writeBitSet(dest, allowedKeyManagement);
    writeBitSet(dest, allowedProtocols);
    writeBitSet(dest, allowedAuthAlgorithms);
    writeBitSet(dest, allowedPairwiseCiphers);
    writeBitSet(dest, allowedGroupCiphers);
    dest.writeParcelable(enterpriseConfig, flags);
    dest.writeParcelable(mIpConfiguration, flags);
    dest.writeString(dhcpServer);
    dest.writeString(defaultGwMacAddress);
    dest.writeInt(selfAdded ? 1 : 0);
    dest.writeInt(didSelfAdd ? 1 : 0);
    dest.writeInt(validatedInternetAccess ? 1 : 0);
    dest.writeInt(ephemeral ? 1 : 0);
    dest.writeInt(meteredHint ? 1 : 0);
    dest.writeInt(useExternalScores ? 1 : 0);
    dest.writeInt(creatorUid);
    dest.writeInt(lastConnectUid);
    dest.writeInt(lastUpdateUid);
    dest.writeString(creatorName);
    dest.writeString(lastUpdateName);
    dest.writeLong(lastConnectionFailure);
    dest.writeLong(lastRoamingFailure);
    dest.writeInt(lastRoamingFailureReason);
    dest.writeLong(roamingFailureBlackListTimeMilli);
    dest.writeInt(numScorerOverride);
    dest.writeInt(numScorerOverrideAndSwitchedNetwork);
    dest.writeInt(numAssociation);
    dest.writeInt(numUserTriggeredWifiDisableLowRSSI);
    dest.writeInt(numUserTriggeredWifiDisableBadRSSI);
    dest.writeInt(numUserTriggeredWifiDisableNotHighRSSI);
    dest.writeInt(numTicksAtLowRSSI);
    dest.writeInt(numTicksAtBadRSSI);
    dest.writeInt(numTicksAtNotHighRSSI);
    dest.writeInt(numUserTriggeredJoinAttempts);
    dest.writeInt(userApproved);
    dest.writeInt(numNoInternetAccessReports);
    dest.writeInt(noInternetAccessExpected ? 1 : 0);
    dest.writeInt(shared ? 1 : 0);
    dest.writeString(mPasspointManagementObjectTree);
}
------------------------
Find a silently evolved API code:android.app.ActivityManager.clearWatchHeapLimit:COMMENT
Method Modifier: public      
Comment:/**
 * Clear a heap watch limit previously set by {@link #setWatchHeapLimit(long)}.
 */

Body of Frist Method:
{
    try {
        ActivityManagerNative.getDefault().setDumpHeapDebugLimit(null, 0, 0, null);
    } catch (RemoteException e) {
    }
}
Body of Second Method:
{
    try {
        ActivityManagerNative.getDefault().setDumpHeapDebugLimit(null, 0, 0, null);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.appwidget.AppWidgetManager.getAppWidgetOptions:COMMENT
Method Modifier: public      
Comment:/**
 * Get the extras associated with a given widget instance.
 * <p>
 * The extras can be used to embed additional information about this widget to be accessed
 * by the associated widget's AppWidgetProvider.
 *
 * @see #updateAppWidgetOptions(int, Bundle)
 *
 * @param appWidgetId The AppWidget instances for which to set the RemoteViews.
 * @return The options associated with the given widget instance.
 */

Body of Frist Method:
{
    if (mService == null) {
        return Bundle.EMPTY;
    }
    try {
        return mService.getAppWidgetOptions(mPackageName, appWidgetId);
    } catch (RemoteException e) {
        throw new RuntimeException("system server dead?", e);
    }
}
Body of Second Method:
{
    if (mService == null) {
        return Bundle.EMPTY;
    }
    try {
        return mService.getAppWidgetOptions(mPackageName, appWidgetId);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiEnterpriseConfig.getKeyId:COMMENT
<android.net.wifi.WifiEnterpriseConfig: String getKeyId(WifiEnterpriseConfig)>
default     hidden      ->public      hidden      
Method Modifier: public      default     hidden      
Method Modifier: No          Yes         Yes         
Method Updated:  Yes         No          Yes         
Comment:/**
 * See {@link WifiConfiguration#getKeyIdForCredentials} @hide
 */

Body of Frist Method:
{
    String eap = mFields.get(EAP_KEY);
    String phase2 = mFields.get(PHASE2_KEY);
    // If either eap or phase2 are not initialized, use current config details
    if (TextUtils.isEmpty((eap))) {
        eap = current.mFields.get(EAP_KEY);
    }
    if (TextUtils.isEmpty(phase2)) {
        phase2 = current.mFields.get(PHASE2_KEY);
    }
    return eap + "_" + phase2;
}
Body of Second Method:
{
    // If EAP method is not initialized, use current config details
    if (mEapMethod == Eap.NONE) {
        return (current != null) ? current.getKeyId(null) : EMPTY_VALUE;
    }
    if (!isEapMethodValid()) {
        return EMPTY_VALUE;
    }
    return Eap.strings[mEapMethod] + "_" + Phase2.strings[mPhase2Method];
}
------------------------
Find a silently evolved API code:android.media.ImageReader.close:COMMENT
Method Modifier: public      
Comment:/**
 * Free up all the resources associated with this ImageReader.
 *
 * <p>
 * After calling this method, this ImageReader can not be used. Calling
 * any methods on this ImageReader and Images previously provided by
 * {@link #acquireNextImage} or {@link #acquireLatestImage}
 * will result in an {@link IllegalStateException}, and attempting to read from
 * {@link ByteBuffer ByteBuffers} returned by an earlier
 * {@link Image.Plane#getBuffer Plane#getBuffer} call will
 * have undefined behavior.
 * </p>
 */

Body of Frist Method:
{
    setOnImageAvailableListener(null, null);
    if (mSurface != null)
        mSurface.release();
    nativeClose();
    if (mEstimatedNativeAllocBytes > 0) {
        VMRuntime.getRuntime().registerNativeFree(mEstimatedNativeAllocBytes);
        mEstimatedNativeAllocBytes = 0;
    }
}
Body of Second Method:
{
    setOnImageAvailableListener(null, null);
    if (mSurface != null)
        mSurface.release();
    /**
     * Close all outstanding acquired images before closing the ImageReader. It is a good
     * practice to close all the images as soon as it is not used to reduce system instantaneous
     * memory pressure. CopyOnWrite list will use a copy of current list content. For the images
     * being closed by other thread (e.g., GC thread), doubling the close call is harmless. For
     * the image being acquired by other threads, mCloseLock is used to synchronize close and
     * acquire operations.
     */
    synchronized (mCloseLock) {
        mIsReaderValid = false;
        for (Image image : mAcquiredImages) {
            image.close();
        }
        mAcquiredImages.clear();
        nativeClose();
    }
    if (mEstimatedNativeAllocBytes > 0) {
        VMRuntime.getRuntime().registerNativeFree(mEstimatedNativeAllocBytes);
        mEstimatedNativeAllocBytes = 0;
    }
}
------------------------
Find a silently evolved API code:android.view.inputmethod.EditorInfo.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Used to package this object into a {@link Parcel}.
 *
 * @param dest The {@link Parcel} to be written.
 * @param flags The flags used for parceling.
 */

Body of Frist Method:
{
    dest.writeInt(inputType);
    dest.writeInt(imeOptions);
    dest.writeString(privateImeOptions);
    TextUtils.writeToParcel(actionLabel, dest, flags);
    dest.writeInt(actionId);
    dest.writeInt(initialSelStart);
    dest.writeInt(initialSelEnd);
    dest.writeInt(initialCapsMode);
    TextUtils.writeToParcel(hintText, dest, flags);
    TextUtils.writeToParcel(label, dest, flags);
    dest.writeString(packageName);
    dest.writeInt(fieldId);
    dest.writeString(fieldName);
    dest.writeBundle(extras);
}
Body of Second Method:
{
    dest.writeInt(inputType);
    dest.writeInt(imeOptions);
    dest.writeString(privateImeOptions);
    TextUtils.writeToParcel(actionLabel, dest, flags);
    dest.writeInt(actionId);
    dest.writeInt(initialSelStart);
    dest.writeInt(initialSelEnd);
    dest.writeInt(initialCapsMode);
    TextUtils.writeToParcel(hintText, dest, flags);
    TextUtils.writeToParcel(label, dest, flags);
    dest.writeString(packageName);
    dest.writeInt(fieldId);
    dest.writeString(fieldName);
    dest.writeBundle(extras);
    if (hintLocales != null) {
        hintLocales.writeToParcel(dest, flags);
    } else {
        LocaleList.getEmptyLocaleList().writeToParcel(dest, flags);
    }
}
------------------------
Find a silently evolved API code:android.content.pm.LauncherApps.isActivityEnabled:COMMENT
Method Modifier: public      
Comment:/**
 * Checks if the activity exists and it enabled for a profile.
 *
 * @param component The activity to check.
 * @param user The UserHandle of the profile.
 *
 * @return true if the activity exists and is enabled.
 */

Body of Frist Method:
{
    try {
        return mService.isActivityEnabled(component, user);
    } catch (RemoteException re) {
        throw new RuntimeException("Failed to call LauncherAppsService");
    }
}
Body of Second Method:
{
    try {
        return mService.isActivityEnabled(component, user);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.app.BackStackRecord.configureTransitions:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Configures custom transitions for a specific fragment container.
 *
 * @param containerId The container ID of the fragments to configure the transition for.
 * @param state The Transition State keeping track of the executing transitions.
 * @param firstOutFragments The list of first fragments to be removed, keyed on the
 * container ID.
 * @param lastInFragments The list of last fragments to be added, keyed on the
 * container ID.
 * @param isBack true if this is popping the back stack or false if this is a
 * forward operation.
 */

Body of Frist Method:
{
    ViewGroup sceneRoot = (ViewGroup) mManager.mContainer.onFindViewById(containerId);
    if (sceneRoot != null) {
        Fragment inFragment = lastInFragments.get(containerId);
        Fragment outFragment = firstOutFragments.get(containerId);
        Transition enterTransition = getEnterTransition(inFragment, isBack);
        TransitionSet sharedElementTransition = getSharedElementTransition(inFragment, outFragment, isBack);
        Transition exitTransition = getExitTransition(outFragment, isBack);
        if (enterTransition == null && sharedElementTransition == null && exitTransition == null) {
            // no transitions!
            return;
        }
        if (enterTransition != null) {
            enterTransition.addTarget(state.nonExistentView);
        }
        ArrayMap<String, View> namedViews = null;
        ArrayList<View> sharedElementTargets = new ArrayList<View>();
        if (sharedElementTransition != null) {
            namedViews = remapSharedElements(state, outFragment, isBack);
            setSharedElementTargets(sharedElementTransition, state.nonExistentView, namedViews, sharedElementTargets);
            // Notify the start of the transition.
            SharedElementCallback callback = isBack ? outFragment.mEnterTransitionCallback : inFragment.mEnterTransitionCallback;
            ArrayList<String> names = new ArrayList<String>(namedViews.keySet());
            ArrayList<View> views = new ArrayList<View>(namedViews.values());
            callback.onSharedElementStart(names, views, null);
        }
        ArrayList<View> exitingViews = captureExitingViews(exitTransition, outFragment, namedViews, state.nonExistentView);
        if (exitingViews == null || exitingViews.isEmpty()) {
            exitTransition = null;
        }
        // Set the epicenter of the exit transition
        if (mSharedElementTargetNames != null && namedViews != null) {
            View epicenterView = namedViews.get(mSharedElementTargetNames.get(0));
            if (epicenterView != null) {
                if (exitTransition != null) {
                    setEpicenter(exitTransition, epicenterView);
                }
                if (sharedElementTransition != null) {
                    setEpicenter(sharedElementTransition, epicenterView);
                }
            }
        }
        Transition transition = mergeTransitions(enterTransition, exitTransition, sharedElementTransition, inFragment, isBack);
        if (transition != null) {
            ArrayList<View> hiddenFragments = new ArrayList<View>();
            ArrayList<View> enteringViews = addTransitionTargets(state, enterTransition, sharedElementTransition, transition, sceneRoot, inFragment, outFragment, hiddenFragments, isBack, sharedElementTargets);
            transition.setNameOverrides(state.nameOverrides);
            // We want to exclude hidden views later, so we need a non-null list in the
            // transition now.
            transition.excludeTarget(state.nonExistentView, true);
            // Now exclude all currently hidden fragments.
            excludeHiddenFragments(hiddenFragments, containerId, transition);
            TransitionManager.beginDelayedTransition(sceneRoot, transition);
            // Remove the view targeting after the transition starts
            removeTargetedViewsFromTransitions(sceneRoot, state.nonExistentView, enterTransition, enteringViews, exitTransition, exitingViews, sharedElementTransition, sharedElementTargets, transition, hiddenFragments);
        }
    }
}
Body of Second Method:
{
    ViewGroup sceneRoot = (ViewGroup) mManager.mContainer.onFindViewById(containerId);
    if (sceneRoot != null) {
        Fragment inFragment = lastInFragments.get(containerId);
        Fragment outFragment = firstOutFragments.get(containerId);
        Transition enterTransition = getEnterTransition(inFragment, isBack);
        TransitionSet sharedElementTransition = getSharedElementTransition(inFragment, outFragment, isBack);
        Transition exitTransition = getExitTransition(outFragment, isBack);
        if (enterTransition == null && sharedElementTransition == null && exitTransition == null) {
            // no transitions!
            return;
        }
        if (enterTransition != null) {
            enterTransition.addTarget(state.nonExistentView);
        }
        ArrayMap<String, View> namedViews = null;
        ArrayList<View> sharedElementTargets = new ArrayList<View>();
        if (sharedElementTransition != null) {
            namedViews = remapSharedElements(state, outFragment, isBack);
            setSharedElementTargets(sharedElementTransition, state.nonExistentView, namedViews, sharedElementTargets);
            // Notify the start of the transition.
            SharedElementCallback callback = isBack ? outFragment.mEnterTransitionCallback : inFragment.mEnterTransitionCallback;
            ArrayList<String> names = new ArrayList<String>(namedViews.keySet());
            ArrayList<View> views = new ArrayList<View>(namedViews.values());
            callback.onSharedElementStart(names, views, null);
        }
        ArrayList<View> exitingViews = captureExitingViews(exitTransition, outFragment, namedViews, state.nonExistentView);
        if (exitingViews == null || exitingViews.isEmpty()) {
            exitTransition = null;
        }
        excludeViews(enterTransition, exitTransition, exitingViews, true);
        excludeViews(enterTransition, sharedElementTransition, sharedElementTargets, true);
        excludeViews(exitTransition, sharedElementTransition, sharedElementTargets, true);
        // Set the epicenter of the exit transition
        if (mSharedElementTargetNames != null && namedViews != null) {
            View epicenterView = namedViews.get(mSharedElementTargetNames.get(0));
            if (epicenterView != null) {
                if (exitTransition != null) {
                    setEpicenter(exitTransition, epicenterView);
                }
                if (sharedElementTransition != null) {
                    setEpicenter(sharedElementTransition, epicenterView);
                }
            }
        }
        Transition transition = mergeTransitions(enterTransition, exitTransition, sharedElementTransition, inFragment, isBack);
        if (transition != null) {
            ArrayList<View> hiddenFragments = new ArrayList<View>();
            ArrayList<View> enteringViews = addTransitionTargets(state, enterTransition, sharedElementTransition, exitTransition, transition, sceneRoot, inFragment, outFragment, hiddenFragments, isBack, sharedElementTargets);
            transition.setNameOverrides(state.nameOverrides);
            // We want to exclude hidden views later, so we need a non-null list in the
            // transition now.
            transition.excludeTarget(state.nonExistentView, true);
            // Now exclude all currently hidden fragments.
            excludeHiddenFragments(hiddenFragments, containerId, transition);
            TransitionManager.beginDelayedTransition(sceneRoot, transition);
            // Remove the view targeting after the transition starts
            removeTargetedViewsFromTransitions(sceneRoot, state.nonExistentView, enterTransition, enteringViews, exitTransition, exitingViews, sharedElementTransition, sharedElementTargets, transition, hiddenFragments);
        }
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiLinkLayerStats.writeToParcel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Implement the Parcelable interface {@hide}
 */

Body of Frist Method:
{
    dest.writeString(SSID);
    dest.writeString(BSSID);
    dest.writeInt(on_time);
    dest.writeInt(tx_time);
    dest.writeInt(rx_time);
    dest.writeInt(on_time_scan);
}
Body of Second Method:
{
    dest.writeString(SSID);
    dest.writeString(BSSID);
    dest.writeInt(on_time);
    dest.writeInt(tx_time);
    dest.writeIntArray(tx_time_per_level);
    dest.writeInt(rx_time);
    dest.writeInt(on_time_scan);
}
------------------------
Find a silently evolved API code:android.media.MediaActionSound.play:COMMENT
Method Modifier: public      
Comment:/**
 * <p>Play one of the predefined platform sounds for media actions.</p>
 *
 * <p>Use this method to play a platform-specific sound for various media
 * actions. The sound playback is done asynchronously, with the same
 * behavior and content as the sounds played by
 * {@link android.hardware.Camera#takePicture Camera.takePicture},
 * {@link android.media.MediaRecorder#start MediaRecorder.start}, and
 * {@link android.media.MediaRecorder#stop MediaRecorder.stop}.</p>
 *
 * <p>With the {@link android.hardware.camera2 camera2} API, this method can be used to play
 * standard camera operation sounds with the appropriate system behavior for such sounds.</p>
 *
 * <p>With the older {@link android.hardware.Camera} API, using this method makes it easy to
 * match the default device sounds when recording or capturing data through the preview
 * callbacks, or when implementing custom camera-like features in your application.</p>
 *
 * <p>If the sound has not been loaded by {@link #load} before calling play,
 * play will load the sound at the cost of some additional latency before
 * sound playback begins. </p>
 *
 * @param soundName The type of sound to play, selected from
 * SHUTTER_CLICK, FOCUS_COMPLETE, START_VIDEO_RECORDING, or
 * STOP_VIDEO_RECORDING.
 * @see android.hardware.Camera#takePicture
 * @see android.media.MediaRecorder
 * @see #SHUTTER_CLICK
 * @see #FOCUS_COMPLETE
 * @see #START_VIDEO_RECORDING
 * @see #STOP_VIDEO_RECORDING
 */

Body of Frist Method:
{
    if (soundName < 0 || soundName >= SOUND_FILES.length) {
        throw new RuntimeException("Unknown sound requested: " + soundName);
    }
    if (mSoundIds[soundName] == SOUND_NOT_LOADED) {
        mSoundIdToPlay = mSoundPool.load(SOUND_FILES[soundName], 1);
        mSoundIds[soundName] = mSoundIdToPlay;
    } else {
        mSoundPool.play(mSoundIds[soundName], 1.0f, 1.0f, 0, 0, 1.0f);
    }
}
Body of Second Method:
{
    if (soundName < 0 || soundName >= SOUND_FILES.length) {
        throw new RuntimeException("Unknown sound requested: " + soundName);
    }
    SoundState sound = mSounds[soundName];
    synchronized (sound) {
        switch(sound.state) {
            case STATE_NOT_LOADED:
                loadSound(sound);
                if (loadSound(sound) <= 0) {
                    Log.e(TAG, "play() error loading sound: " + soundName);
                    break;
                }
            case STATE_LOADING:
                sound.state = STATE_LOADING_PLAY_REQUESTED;
                break;
            case STATE_LOADED:
                mSoundPool.play(sound.id, 1.0f, 1.0f, 0, 0, 1.0f);
                break;
            default:
                Log.e(TAG, "play() called in wrong state: " + sound.state + " for sound: " + soundName);
                break;
        }
    }
}
------------------------
Find a silently evolved API code:android.net.ConnectivityManager.factoryReset:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Resets all connectivity manager settings back to factory defaults.
 * @hide
 */

Body of Frist Method:
{
    try {
        mService.factoryReset();
    } catch (RemoteException e) {
    }
}
Body of Second Method:
{
    try {
        mService.factoryReset();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothAdapter.getUuids:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the UUIDs supported by the local Bluetooth adapter.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}
 *
 * @return the UUIDs supported by the local Bluetooth Adapter.
 * @hide
 */

Body of Frist Method:
{
    if (getState() != STATE_ON)
        return null;
    try {
        synchronized (mManagerCallback) {
            if (mService != null)
                return mService.getUuids();
        }
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return null;
}
Body of Second Method:
{
    if (getState() != STATE_ON)
        return null;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.getUuids();
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return null;
}
------------------------
Find a silently evolved API code:android.app.Activity.setTaskDescription:COMMENT
Method Modifier: public      
Comment:/**
 * Sets information describing the task with this activity for presentation inside the Recents
 * System UI. When {@link ActivityManager#getRecentTasks} is called, the activities of each task
 * are traversed in order from the topmost activity to the bottommost. The traversal continues
 * for each property until a suitable value is found. For each task the taskDescription will be
 * returned in {@link android.app.ActivityManager.TaskDescription}.
 *
 * @see ActivityManager#getRecentTasks
 * @see android.app.ActivityManager.TaskDescription
 *
 * @param taskDescription The TaskDescription properties that describe the task with this activity
 */

Body of Frist Method:
{
    ActivityManager.TaskDescription td;
    // Scale the icon down to something reasonable if it is provided
    if (taskDescription.getIconFilename() == null && taskDescription.getIcon() != null) {
        final int size = ActivityManager.getLauncherLargeIconSizeInner(this);
        final Bitmap icon = Bitmap.createScaledBitmap(taskDescription.getIcon(), size, size, true);
        td = new ActivityManager.TaskDescription(taskDescription.getLabel(), icon, taskDescription.getPrimaryColor());
    } else {
        td = taskDescription;
    }
    try {
        ActivityManagerNative.getDefault().setTaskDescription(mToken, td);
    } catch (RemoteException e) {
    }
}
Body of Second Method:
{
    if (mTaskDescription != taskDescription) {
        mTaskDescription.copyFrom(taskDescription);
        // Scale the icon down to something reasonable if it is provided
        if (taskDescription.getIconFilename() == null && taskDescription.getIcon() != null) {
            final int size = ActivityManager.getLauncherLargeIconSizeInner(this);
            final Bitmap icon = Bitmap.createScaledBitmap(taskDescription.getIcon(), size, size, true);
            mTaskDescription.setIcon(icon);
        }
    }
    try {
        ActivityManagerNative.getDefault().setTaskDescription(mToken, mTaskDescription);
    } catch (RemoteException e) {
    }
}
------------------------
Find a silently evolved API code:android.os.Bundle.putAll:COMMENT
Method Modifier: public      
Comment:/**
 * Inserts all mappings from the given Bundle into this Bundle.
 *
 * @param bundle a Bundle
 */

Body of Frist Method:
{
    unparcel();
    bundle.unparcel();
    mMap.putAll(bundle.mMap);
    // fd state is now known if and only if both bundles already knew
    mHasFds |= bundle.mHasFds;
    mFdsKnown = mFdsKnown && bundle.mFdsKnown;
}
Body of Second Method:
{
    unparcel();
    bundle.unparcel();
    mMap.putAll(bundle.mMap);
    // FD state is now known if and only if both bundles already knew
    if ((bundle.mFlags & FLAG_HAS_FDS) != 0) {
        mFlags |= FLAG_HAS_FDS;
    }
    if ((bundle.mFlags & FLAG_HAS_FDS_KNOWN) == 0) {
        mFlags &= ~FLAG_HAS_FDS_KNOWN;
    }
}
------------------------
Find a silently evolved API code:android.media.AudioManager.abandonAudioFocusForCall:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 * Used internally by telephony package to abandon audio focus, typically after a call or
 * when ringing ends and the call is rejected or not answered.
 * Should match one or more calls to {@link #requestAudioFocusForCall(int, int)}.
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        service.abandonAudioFocus(null, AudioSystem.IN_VOICE_COMM_FOCUS_ID, null);
    } catch (RemoteException e) {
        Log.e(TAG, "Can't call abandonAudioFocusForCall() on AudioService:", e);
    }
}
Body of Second Method:
{
    IAudioService service = getService();
    try {
        service.abandonAudioFocus(null, AudioSystem.IN_VOICE_COMM_FOCUS_ID, null);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.mtp.MtpObjectInfo.getImagePixWidth:COMMENT
Method Modifier: public      final       
Comment:/**
 * Returns the width of the MTP object in pixels
 * Will be zero for non-image objects
 *
 * @return the image width
 */

Body of Frist Method:
{
    return mImagePixWidth;
}
Body of Second Method:
{
    Preconditions.checkState(mImagePixWidth >= 0);
    return mImagePixWidth;
}
------------------------
Find a silently evolved API code:android.renderscript.Sampler.MIRRORED_REPEAT_LINEAR:COMMENT
Method Modifier: public      static      
Comment:/**
 * Retrieve a sampler with min and mag set to linear and wrap modes set to
 * mirrored repeat.
 *
 * @param rs Context to which the sampler will belong.
 *
 * @return Sampler
 */

Body of Frist Method:
{
    if (rs.mSampler_MIRRORED_REPEAT_LINEAR == null) {
        Builder b = new Builder(rs);
        b.setMinification(Value.LINEAR);
        b.setMagnification(Value.LINEAR);
        b.setWrapS(Value.MIRRORED_REPEAT);
        b.setWrapT(Value.MIRRORED_REPEAT);
        rs.mSampler_MIRRORED_REPEAT_LINEAR = b.create();
    }
    return rs.mSampler_MIRRORED_REPEAT_LINEAR;
}
Body of Second Method:
{
    if (rs.mSampler_MIRRORED_REPEAT_LINEAR == null) {
        synchronized (rs) {
            if (rs.mSampler_MIRRORED_REPEAT_LINEAR == null) {
                Builder b = new Builder(rs);
                b.setMinification(Value.LINEAR);
                b.setMagnification(Value.LINEAR);
                b.setWrapS(Value.MIRRORED_REPEAT);
                b.setWrapT(Value.MIRRORED_REPEAT);
                rs.mSampler_MIRRORED_REPEAT_LINEAR = b.create();
            }
        }
    }
    return rs.mSampler_MIRRORED_REPEAT_LINEAR;
}
------------------------
Find a silently evolved API code:android.graphics.Bitmap.setHasAlpha:COMMENT
Method Modifier: public      
Comment:/**
 * Tell the bitmap if all of the pixels are known to be opaque (false)
 * or if some of the pixels may contain non-opaque alpha values (true).
 * Note, for some configs (e.g. RGB_565) this call is ignored, since it
 * does not support per-pixel alpha values.
 *
 * This is meant as a drawing hint, as in some cases a bitmap that is known
 * to be opaque can take a faster drawing case than one that may have
 * non-opaque per-pixel alpha values.
 */

Body of Frist Method:
{
    checkRecycled("setHasAlpha called on a recycled bitmap");
    nativeSetHasAlpha(mFinalizer.mNativeBitmap, hasAlpha, mRequestPremultiplied);
}
Body of Second Method:
{
    checkRecycled("setHasAlpha called on a recycled bitmap");
    nativeSetHasAlpha(mNativePtr, hasAlpha, mRequestPremultiplied);
}
------------------------
Find a silently evolved API code:android.net.ConnectivityManager.getMobileProvisioningUrl:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the mobile provisioning url.
 * {@hide}
 */

Body of Frist Method:
{
    try {
        return mService.getMobileProvisioningUrl();
    } catch (RemoteException e) {
    }
    return null;
}
Body of Second Method:
{
    try {
        return mService.getMobileProvisioningUrl();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.net.ConnectivityManager.getAllNetworks:COMMENT
Method Modifier: public      
Comment:/**
 * Returns an array of all {@link Network} currently tracked by the
 * framework.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
 *
 * @return an array of {@link Network} objects.
 */

Body of Frist Method:
{
    try {
        return mService.getAllNetworks();
    } catch (RemoteException e) {
        return null;
    }
}
Body of Second Method:
{
    try {
        return mService.getAllNetworks();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.content.pm.LauncherApps.getActivityList:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieves a list of launchable activities that match {@link Intent#ACTION_MAIN} and
 * {@link Intent#CATEGORY_LAUNCHER}, for a specified user.
 *
 * @param packageName The specific package to query. If null, it checks all installed packages
 * in the profile.
 * @param user The UserHandle of the profile.
 * @return List of launchable activities. Can be an empty list but will not be null.
 */

Body of Frist Method:
{
    List<ResolveInfo> activities = null;
    try {
        activities = mService.getLauncherActivities(packageName, user);
    } catch (RemoteException re) {
        throw new RuntimeException("Failed to call LauncherAppsService");
    }
    if (activities == null) {
        return Collections.EMPTY_LIST;
    }
    ArrayList<LauncherActivityInfo> lais = new ArrayList<LauncherActivityInfo>();
    final int count = activities.size();
    for (int i = 0; i < count; i++) {
        ResolveInfo ri = activities.get(i);
        long firstInstallTime = 0;
        try {
            firstInstallTime = mPm.getPackageInfo(ri.activityInfo.packageName, PackageManager.GET_UNINSTALLED_PACKAGES).firstInstallTime;
        } catch (NameNotFoundException nnfe) {
        // Sorry, can't find package
        }
        LauncherActivityInfo lai = new LauncherActivityInfo(mContext, ri, user, firstInstallTime);
        if (DEBUG) {
            Log.v(TAG, "Returning activity for profile " + user + " : " + lai.getComponentName());
        }
        lais.add(lai);
    }
    return lais;
}
Body of Second Method:
{
    ParceledListSlice<ResolveInfo> activities = null;
    try {
        activities = mService.getLauncherActivities(packageName, user);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
    if (activities == null) {
        return Collections.EMPTY_LIST;
    }
    ArrayList<LauncherActivityInfo> lais = new ArrayList<LauncherActivityInfo>();
    for (ResolveInfo ri : activities.getList()) {
        LauncherActivityInfo lai = new LauncherActivityInfo(mContext, ri.activityInfo, user);
        if (DEBUG) {
            Log.v(TAG, "Returning activity for profile " + user + " : " + lai.getComponentName());
        }
        lais.add(lai);
    }
    return lais;
}
------------------------
Find a silently evolved API code:android.content.ClipboardManager.getPrimaryClipDescription:COMMENT
Method Modifier: public      
Comment:/**
 * Returns a description of the current primary clip on the clipboard
 * but not a copy of its data.
 */

Body of Frist Method:
{
    try {
        return getService().getPrimaryClipDescription(mContext.getOpPackageName());
    } catch (RemoteException e) {
        return null;
    }
}
Body of Second Method:
{
    try {
        return getService().getPrimaryClipDescription(mContext.getOpPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.app.SearchManager.getWebSearchActivity:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Gets the name of the web search activity.
 *
 * @return The name of the default activity for web searches. This activity
 * can be used to get web search suggestions. Returns {@code null} if
 * there is no default web search activity.
 *
 * @hide
 */

Body of Frist Method:
{
    try {
        return mService.getWebSearchActivity();
    } catch (RemoteException ex) {
        Log.e(TAG, "getWebSearchActivity() failed: " + ex);
        return null;
    }
}
Body of Second Method:
{
    try {
        return mService.getWebSearchActivity();
    } catch (RemoteException ex) {
        throw ex.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.app.ActivityManager.handleIncomingUser:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 * Helper for dealing with incoming user arguments to system service calls.
 * Takes care of checking permissions and converting USER_CURRENT to the
 * actual current user.
 *
 * @param callingPid The pid of the incoming call, as per Binder.getCallingPid().
 * @param callingUid The uid of the incoming call, as per Binder.getCallingUid().
 * @param userId The user id argument supplied by the caller -- this is the user
 * they want to run as.
 * @param allowAll If true, we will allow USER_ALL.  This means you must be prepared
 * to get a USER_ALL returned and deal with it correctly.  If false,
 * an exception will be thrown if USER_ALL is supplied.
 * @param requireFull If true, the caller must hold
 * {@link android.Manifest.permission#INTERACT_ACROSS_USERS_FULL} to be able to run as a
 * different user than their current process; otherwise they must hold
 * {@link android.Manifest.permission#INTERACT_ACROSS_USERS}.
 * @param name Optional textual name of the incoming call; only for generating error messages.
 * @param callerPackage Optional package name of caller; only for error messages.
 *
 * @return Returns the user ID that the call should run as.  Will always be a concrete
 * user number, unless <var>allowAll</var> is true in which case it could also be
 * USER_ALL.
 */

Body of Frist Method:
{
    if (UserHandle.getUserId(callingUid) == userId) {
        return userId;
    }
    try {
        return ActivityManagerNative.getDefault().handleIncomingUser(callingPid, callingUid, userId, allowAll, requireFull, name, callerPackage);
    } catch (RemoteException e) {
        throw new SecurityException("Failed calling activity manager", e);
    }
}
Body of Second Method:
{
    if (UserHandle.getUserId(callingUid) == userId) {
        return userId;
    }
    try {
        return ActivityManagerNative.getDefault().handleIncomingUser(callingPid, callingUid, userId, allowAll, requireFull, name, callerPackage);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.app.ActivityManager.getProcessesInErrorState:COMMENT
Method Modifier: public      
Comment:/**
 * Returns a list of any processes that are currently in an error condition.  The result
 * will be null if all processes are running properly at this time.
 *
 * @return Returns a list of ProcessErrorStateInfo records, or null if there are no
 * current error conditions (it will not return an empty list).  This list ordering is not
 * specified.
 */

Body of Frist Method:
{
    try {
        return ActivityManagerNative.getDefault().getProcessesInErrorState();
    } catch (RemoteException e) {
        return null;
    }
}
Body of Second Method:
{
    try {
        return ActivityManagerNative.getDefault().getProcessesInErrorState();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.media.ImageReader.releaseImage:COMMENT
Method Modifier: private     
Comment:/**
 * <p>Return the frame to the ImageReader for reuse.</p>
 */

Body of Frist Method:
{
    if (!(i instanceof SurfaceImage)) {
        throw new IllegalArgumentException("This image was not produced by an ImageReader");
    }
    SurfaceImage si = (SurfaceImage) i;
    if (si.getReader() != this) {
        throw new IllegalArgumentException("This image was not produced by this ImageReader");
    }
    si.clearSurfacePlanes();
    nativeReleaseImage(i);
    si.mIsImageValid = false;
}
Body of Second Method:
{
    if (!(i instanceof SurfaceImage)) {
        throw new IllegalArgumentException("This image was not produced by an ImageReader");
    }
    SurfaceImage si = (SurfaceImage) i;
    if (si.mIsImageValid == false) {
        return;
    }
    if (si.getReader() != this || !mAcquiredImages.contains(i)) {
        throw new IllegalArgumentException("This image was not produced by this ImageReader");
    }
    si.clearSurfacePlanes();
    nativeReleaseImage(i);
    si.mIsImageValid = false;
    mAcquiredImages.remove(i);
}
------------------------
Find a silently evolved API code:android.net.wifi.ScanResult.writeToParcel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Implement the Parcelable interface {@hide}
 */

Body of Frist Method:
{
    if (wifiSsid != null) {
        dest.writeInt(1);
        wifiSsid.writeToParcel(dest, flags);
    } else {
        dest.writeInt(0);
    }
    dest.writeString(SSID);
    dest.writeString(BSSID);
    dest.writeString(capabilities);
    dest.writeInt(level);
    dest.writeInt(frequency);
    dest.writeLong(timestamp);
    dest.writeInt(distanceCm);
    dest.writeInt(distanceSdCm);
    dest.writeInt(channelWidth);
    dest.writeInt(centerFreq0);
    dest.writeInt(centerFreq1);
    dest.writeLong(seen);
    dest.writeInt(autoJoinStatus);
    dest.writeInt(untrusted ? 1 : 0);
    dest.writeInt(numConnection);
    dest.writeInt(numUsage);
    dest.writeInt(numIpConfigFailures);
    dest.writeInt(isAutoJoinCandidate);
    dest.writeString((venueName != null) ? venueName.toString() : "");
    dest.writeString((operatorFriendlyName != null) ? operatorFriendlyName.toString() : "");
    dest.writeLong(this.flags);
    if (informationElements != null) {
        dest.writeInt(informationElements.length);
        for (int i = 0; i < informationElements.length; i++) {
            dest.writeInt(informationElements[i].id);
            dest.writeInt(informationElements[i].bytes.length);
            dest.writeByteArray(informationElements[i].bytes);
        }
    } else {
        dest.writeInt(0);
    }
}
Body of Second Method:
{
    if (wifiSsid != null) {
        dest.writeInt(1);
        wifiSsid.writeToParcel(dest, flags);
    } else {
        dest.writeInt(0);
    }
    dest.writeString(SSID);
    dest.writeString(BSSID);
    dest.writeLong(hessid);
    dest.writeInt(anqpDomainId);
    dest.writeString(capabilities);
    dest.writeInt(level);
    dest.writeInt(frequency);
    dest.writeLong(timestamp);
    dest.writeInt(distanceCm);
    dest.writeInt(distanceSdCm);
    dest.writeInt(channelWidth);
    dest.writeInt(centerFreq0);
    dest.writeInt(centerFreq1);
    dest.writeLong(seen);
    dest.writeInt(untrusted ? 1 : 0);
    dest.writeInt(numConnection);
    dest.writeInt(numUsage);
    dest.writeInt(numIpConfigFailures);
    dest.writeInt(isAutoJoinCandidate);
    dest.writeString((venueName != null) ? venueName.toString() : "");
    dest.writeString((operatorFriendlyName != null) ? operatorFriendlyName.toString() : "");
    dest.writeLong(this.flags);
    if (informationElements != null) {
        dest.writeInt(informationElements.length);
        for (int i = 0; i < informationElements.length; i++) {
            dest.writeInt(informationElements[i].id);
            dest.writeInt(informationElements[i].bytes.length);
            dest.writeByteArray(informationElements[i].bytes);
        }
    } else {
        dest.writeInt(0);
    }
    if (anqpLines != null) {
        dest.writeInt(anqpLines.size());
        for (int i = 0; i < anqpLines.size(); i++) {
            dest.writeString(anqpLines.get(i));
        }
    } else {
        dest.writeInt(0);
    }
    if (anqpElements != null) {
        dest.writeInt(anqpElements.length);
        for (AnqpInformationElement element : anqpElements) {
            dest.writeInt(element.getVendorId());
            dest.writeInt(element.getElementId());
            dest.writeInt(element.getPayload().length);
            dest.writeByteArray(element.getPayload());
        }
    } else {
        dest.writeInt(0);
    }
}
------------------------
Find a silently evolved API code:android.app.WallpaperManager.getDesiredMinimumWidth:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the desired minimum width for the wallpaper. Callers of
 * {@link #setBitmap(android.graphics.Bitmap)} or
 * {@link #setStream(java.io.InputStream)} should check this value
 * beforehand to make sure the supplied wallpaper respects the desired
 * minimum width.
 *
 * If the returned value is <= 0, the caller should use the width of
 * the default display instead.
 *
 * @return The desired minimum width for the wallpaper. This value should
 * be honored by applications that set the wallpaper but it is not
 * mandatory.
 */

Body of Frist Method:
{
    if (sGlobals.mService == null) {
        Log.w(TAG, "WallpaperService not running");
        return 0;
    }
    try {
        return sGlobals.mService.getWidthHint();
    } catch (RemoteException e) {
        // Shouldn't happen!
        return 0;
    }
}
Body of Second Method:
{
    if (sGlobals.mService == null) {
        Log.w(TAG, "WallpaperService not running");
        throw new RuntimeException(new DeadSystemException());
    }
    try {
        return sGlobals.mService.getWidthHint();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.net.ConnectivityManager.getMobileDataEnabled:COMMENT
Method Modifier: public      hidden      deprecated  
Comment:/**
 * @hide
 * @deprecated Talk to TelephonyManager directly
 */

Body of Frist Method:
{
    IBinder b = ServiceManager.getService(Context.TELEPHONY_SERVICE);
    if (b != null) {
        try {
            ITelephony it = ITelephony.Stub.asInterface(b);
            int subId = SubscriptionManager.getDefaultDataSubId();
            Log.d("ConnectivityManager", "getMobileDataEnabled()+ subId=" + subId);
            boolean retVal = it.getDataEnabled(subId);
            Log.d("ConnectivityManager", "getMobileDataEnabled()- subId=" + subId + " retVal=" + retVal);
            return retVal;
        } catch (RemoteException e) {
        }
    }
    Log.d("ConnectivityManager", "getMobileDataEnabled()- remote exception retVal=false");
    return false;
}
Body of Second Method:
{
    IBinder b = ServiceManager.getService(Context.TELEPHONY_SERVICE);
    if (b != null) {
        try {
            ITelephony it = ITelephony.Stub.asInterface(b);
            int subId = SubscriptionManager.getDefaultDataSubscriptionId();
            Log.d("ConnectivityManager", "getMobileDataEnabled()+ subId=" + subId);
            boolean retVal = it.getDataEnabled(subId);
            Log.d("ConnectivityManager", "getMobileDataEnabled()- subId=" + subId + " retVal=" + retVal);
            return retVal;
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    Log.d("ConnectivityManager", "getMobileDataEnabled()- remote exception retVal=false");
    return false;
}
------------------------
Find a silently evolved API code:android.media.AudioManager.isStreamAffectedByRingerMode:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Only useful for volume controllers.
 * @hide
 */

Body of Frist Method:
{
    try {
        return getService().isStreamAffectedByRingerMode(streamType);
    } catch (RemoteException e) {
        Log.w(TAG, "Error calling isStreamAffectedByRingerMode", e);
        return false;
    }
}
Body of Second Method:
{
    try {
        return getService().isStreamAffectedByRingerMode(streamType);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.content.res.TypedArray.recycle:COMMENT
Method Modifier: public      
Comment:/**
 * Recycles the TypedArray, to be re-used by a later caller. After calling
 * this function you must not ever touch the typed array again.
 *
 * @throws RuntimeException if the TypedArray has already been recycled.
 */

Body of Frist Method:
{
    if (mRecycled) {
        throw new RuntimeException(toString() + " recycled twice!");
    }
    mRecycled = true;
    // These may have been set by the client.
    mXml = null;
    mTheme = null;
    mResources.mTypedArrayPool.release(this);
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException(toString() + " recycled twice!");
    }
    mRecycled = true;
    // These may have been set by the client.
    mXml = null;
    mTheme = null;
    mAssets = null;
    mResources.mTypedArrayPool.release(this);
}
------------------------
Find a silently evolved API code:android.content.ContentProvider.validateIncomingUri:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    String auth = uri.getAuthority();
    int userId = getUserIdFromAuthority(auth, UserHandle.USER_CURRENT);
    if (userId != UserHandle.USER_CURRENT && userId != mContext.getUserId()) {
        throw new SecurityException("trying to query a ContentProvider in user " + mContext.getUserId() + " with a uri belonging to user " + userId);
    }
    if (!matchesOurAuthorities(getAuthorityWithoutUserId(auth))) {
        String message = "The authority of the uri " + uri + " does not match the one of the " + "contentProvider: ";
        if (mAuthority != null) {
            message += mAuthority;
        } else {
            message += mAuthorities;
        }
        throw new SecurityException(message);
    }
}
Body of Second Method:
{
    String auth = uri.getAuthority();
    int userId = getUserIdFromAuthority(auth, UserHandle.USER_CURRENT);
    if (userId != UserHandle.USER_CURRENT && userId != mContext.getUserId()) {
        throw new SecurityException("trying to query a ContentProvider in user " + mContext.getUserId() + " with a uri belonging to user " + userId);
    }
    if (!matchesOurAuthorities(getAuthorityWithoutUserId(auth))) {
        String message = "The authority of the uri " + uri + " does not match the one of the " + "contentProvider: ";
        if (mAuthority != null) {
            message += mAuthority;
        } else {
            message += Arrays.toString(mAuthorities);
        }
        throw new SecurityException(message);
    }
}
------------------------
Find a silently evolved API code:android.os.PowerManager.isScreenBrightnessBoosted:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns whether the screen brightness is currently boosted to maximum, caused by a call
 * to {@link #boostScreenBrightness(long)}.
 * @return {@code True} if the screen brightness is currently boosted. {@code False} otherwise.
 *
 * @hide
 */

Body of Frist Method:
{
    try {
        return mService.isScreenBrightnessBoosted();
    } catch (RemoteException e) {
        return false;
    }
}
Body of Second Method:
{
    try {
        return mService.isScreenBrightnessBoosted();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.os.DropBoxManager.addData:COMMENT
Method Modifier: public      
Comment:/**
 * Stores binary data, which may be ignored or discarded as with {@link #addText}.
 *
 * @param tag describing the type of entry being stored
 * @param data value to store
 * @param flags describing the data
 */

Body of Frist Method:
{
    if (data == null)
        throw new NullPointerException("data == null");
    try {
        mService.add(new Entry(tag, 0, data, flags));
    } catch (RemoteException e) {
    }
}
Body of Second Method:
{
    if (data == null)
        throw new NullPointerException("data == null");
    try {
        mService.add(new Entry(tag, 0, data, flags));
    } catch (RemoteException e) {
        if (e instanceof TransactionTooLargeException && mContext.getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.N) {
            Log.e(TAG, "App sent too much data, so it was ignored", e);
            return;
        }
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.content.BroadcastReceiver.peekService:COMMENT
Method Modifier: public      
Comment:/**
 * Provide a binder to an already-running service.  This method is synchronous
 * and will not start the target service if it is not present, so it is safe
 * to call from {@link #onReceive}.
 *
 * @param myContext The Context that had been passed to {@link #onReceive(Context, Intent)}
 * @param service The Intent indicating the service you wish to use.  See {@link
 * Context#startService(Intent)} for more information.
 */

Body of Frist Method:
{
    IActivityManager am = ActivityManagerNative.getDefault();
    IBinder binder = null;
    try {
        service.prepareToLeaveProcess();
        binder = am.peekService(service, service.resolveTypeIfNeeded(myContext.getContentResolver()), myContext.getOpPackageName());
    } catch (RemoteException e) {
    }
    return binder;
}
Body of Second Method:
{
    IActivityManager am = ActivityManagerNative.getDefault();
    IBinder binder = null;
    try {
        service.prepareToLeaveProcess(myContext);
        binder = am.peekService(service, service.resolveTypeIfNeeded(myContext.getContentResolver()), myContext.getOpPackageName());
    } catch (RemoteException e) {
    }
    return binder;
}
------------------------
Find a silently evolved API code:android.telephony.TelephonyManager.getSimOperatorNumeric:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns the MCC+MNC (mobile country code + mobile network code) of the
 * provider of the SIM. 5 or 6 decimal digits.
 * <p>
 * Availability: SIM state must be {@link #SIM_STATE_READY}
 *
 * @see #getSimState
 * @hide
 */

Body of Frist Method:
{
    int subId = SubscriptionManager.getDefaultDataSubId();
    if (!SubscriptionManager.isUsableSubIdValue(subId)) {
        subId = SubscriptionManager.getDefaultSmsSubId();
        if (!SubscriptionManager.isUsableSubIdValue(subId)) {
            subId = SubscriptionManager.getDefaultVoiceSubId();
            if (!SubscriptionManager.isUsableSubIdValue(subId)) {
                subId = SubscriptionManager.getDefaultSubId();
            }
        }
    }
    return getSimOperatorNumericForSubscription(subId);
}
Body of Second Method:
{
    int subId = SubscriptionManager.getDefaultDataSubscriptionId();
    if (!SubscriptionManager.isUsableSubIdValue(subId)) {
        subId = SubscriptionManager.getDefaultSmsSubscriptionId();
        if (!SubscriptionManager.isUsableSubIdValue(subId)) {
            subId = SubscriptionManager.getDefaultVoiceSubscriptionId();
            if (!SubscriptionManager.isUsableSubIdValue(subId)) {
                subId = SubscriptionManager.getDefaultSubscriptionId();
            }
        }
    }
    return getSimOperatorNumeric(subId);
}
------------------------
Find a silently evolved API code:android.app.backup.BlobBackupHelper.writeBackupState:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * New overall state record
 */

Body of Frist Method:
{
    try {
        FileOutputStream fos = new FileOutputStream(stateFile.getFileDescriptor());
        // We explicitly don't close 'out' because we must not close the backing fd.
        // The FileOutputStream will not close it implicitly.
        @SuppressWarnings("resource") DataOutputStream out = new DataOutputStream(fos);
        out.writeInt(mCurrentBlobVersion);
        final int N = (state != null) ? state.size() : 0;
        out.writeInt(N);
        for (int i = 0; i < N; i++) {
            out.writeUTF(state.keyAt(i));
            out.writeLong(state.valueAt(i).longValue());
        }
    } catch (IOException e) {
        Log.e(TAG, "Unable to write updated state", e);
    }
}
Body of Second Method:
{
    try {
        FileOutputStream fos = new FileOutputStream(stateFile.getFileDescriptor());
        // We explicitly don't close 'out' because we must not close the backing fd.
        // The FileOutputStream will not close it implicitly.
        @SuppressWarnings("resource") DataOutputStream out = new DataOutputStream(fos);
        out.writeInt(mCurrentBlobVersion);
        final int N = (state != null) ? state.size() : 0;
        out.writeInt(N);
        for (int i = 0; i < N; i++) {
            final String key = state.keyAt(i);
            final long checksum = state.valueAt(i).longValue();
            if (DEBUG) {
                Log.i(TAG, "  writing key " + key + " checksum = " + checksum);
            }
            out.writeUTF(key);
            out.writeLong(checksum);
        }
    } catch (IOException e) {
        Log.e(TAG, "Unable to write updated state", e);
    }
}
------------------------
Find a silently evolved API code:android.renderscript.Allocation.destroy:COMMENT
Method Modifier: public      
Comment:/**
 * For USAGE_IO_OUTPUT, destroy() implies setSurface(null).
 */

Body of Frist Method:
{
    if ((mUsage & USAGE_IO_OUTPUT) != 0) {
        setSurface(null);
    }
    super.destroy();
}
Body of Second Method:
{
    if ((mUsage & USAGE_IO_OUTPUT) != 0) {
        setSurface(null);
    }
    if (mType != null && mOwningType) {
        mType.destroy();
    }
    super.destroy();
}
------------------------
Find a silently evolved API code:android.widget.AbsSeekBar.drawThumb:COMMENT
Method Modifier: default     
Comment:/**
 * Draw the thumb.
 */

Body of Frist Method:
{
    if (mThumb != null) {
        canvas.save();
        // Translate the padding. For the x, we need to allow the thumb to
        // draw in its extra space
        canvas.translate(mPaddingLeft - mThumbOffset, mPaddingTop);
        mThumb.draw(canvas);
        canvas.restore();
    }
}
Body of Second Method:
{
    if (mThumb != null) {
        final int saveCount = canvas.save();
        // Translate the padding. For the x, we need to allow the thumb to
        // draw in its extra space
        canvas.translate(mPaddingLeft - mThumbOffset, mPaddingTop);
        mThumb.draw(canvas);
        canvas.restoreToCount(saveCount);
    }
}
------------------------
Find a silently evolved API code:android.media.AudioManager.setMode:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the audio mode.
 * <p>
 * The audio mode encompasses audio routing AND the behavior of
 * the telephony layer. Therefore this method should only be used by applications that
 * replace the platform-wide management of audio settings or the main telephony application.
 * In particular, the {@link #MODE_IN_CALL} mode should only be used by the telephony
 * application when it places a phone call, as it will cause signals from the radio layer
 * to feed the platform mixer.
 *
 * @param mode  the requested audio mode ({@link #MODE_NORMAL}, {@link #MODE_RINGTONE},
 * {@link #MODE_IN_CALL} or {@link #MODE_IN_COMMUNICATION}).
 * Informs the HAL about the current audio state so that
 * it can route the audio appropriately.
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        service.setMode(mode, mICallBack, mApplicationContext.getOpPackageName());
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in setMode", e);
    }
}
Body of Second Method:
{
    IAudioService service = getService();
    try {
        service.setMode(mode, mICallBack, mApplicationContext.getOpPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.hardware.camera2.marshal.MarshalRegistry.getMarshaler:COMMENT
Method Modifier: public      static      
Comment:/**
 * Lookup a marshaler between {@code T} and {@code nativeType}.
 *
 * <p>Marshalers are looked up in the order they were registered; earlier registered
 * marshal queriers get priority.</p>
 *
 * @param typeToken The compile-time type reference for {@code T}
 * @param nativeType The native type, e.g. {@link CameraMetadataNative#TYPE_BYTE TYPE_BYTE}
 * @return marshaler a non-{@code null} marshaler that supports marshaling the type combo
 *
 * @throws UnsupportedOperationException If no marshaler matching the args could be found
 */

Body of Frist Method:
{
    // TODO: can avoid making a new token each time by code-genning
    // the list of type tokens and native types from the keys (at the call sites)
    MarshalToken<T> marshalToken = new MarshalToken<T>(typeToken, nativeType);
    /*
         * Marshalers are instantiated lazily once they are looked up; successive lookups
         * will not instantiate new marshalers.
         */
    Marshaler<T> marshaler = (Marshaler<T>) sMarshalerMap.get(marshalToken);
    if (sRegisteredMarshalQueryables.size() == 0) {
        throw new AssertionError("No available query marshalers registered");
    }
    if (marshaler == null) {
        // Query each marshaler to see if they support the native/managed type combination
        for (MarshalQueryable<?> potentialMarshaler : sRegisteredMarshalQueryables) {
            MarshalQueryable<T> castedPotential = (MarshalQueryable<T>) potentialMarshaler;
            if (castedPotential.isTypeMappingSupported(typeToken, nativeType)) {
                marshaler = castedPotential.createMarshaler(typeToken, nativeType);
                break;
            }
        }
        if (marshaler == null) {
            throw new UnsupportedOperationException("Could not find marshaler that matches the requested " + "combination of type reference " + typeToken + " and native type " + MarshalHelpers.toStringNativeType(nativeType));
        }
        // Only put when no cached version exists to avoid +0.5ms lookup per call.
        sMarshalerMap.put(marshalToken, marshaler);
    }
    return marshaler;
}
Body of Second Method:
{
    synchronized (sMarshalLock) {
        // TODO: can avoid making a new token each time by code-genning
        // the list of type tokens and native types from the keys (at the call sites)
        MarshalToken<T> marshalToken = new MarshalToken<T>(typeToken, nativeType);
        /*
             * Marshalers are instantiated lazily once they are looked up; successive lookups
             * will not instantiate new marshalers.
             */
        Marshaler<T> marshaler = (Marshaler<T>) sMarshalerMap.get(marshalToken);
        if (marshaler == null) {
            if (sRegisteredMarshalQueryables.size() == 0) {
                throw new AssertionError("No available query marshalers registered");
            }
            // Query each marshaler to see if they support the native/managed type combination
            for (MarshalQueryable<?> potentialMarshaler : sRegisteredMarshalQueryables) {
                MarshalQueryable<T> castedPotential = (MarshalQueryable<T>) potentialMarshaler;
                if (castedPotential.isTypeMappingSupported(typeToken, nativeType)) {
                    marshaler = castedPotential.createMarshaler(typeToken, nativeType);
                    break;
                }
            }
            if (marshaler == null) {
                throw new UnsupportedOperationException("Could not find marshaler that matches the requested " + "combination of type reference " + typeToken + " and native type " + MarshalHelpers.toStringNativeType(nativeType));
            }
            // Only put when no cached version exists to avoid +0.5ms lookup per call.
            sMarshalerMap.put(marshalToken, marshaler);
        }
        return marshaler;
    }
}
------------------------
Find a silently evolved API code:android.app.WallpaperManager.hasResourceWallpaper:COMMENT
Method Modifier: public      
Comment:/**
 * Return whether any users are currently set to use the wallpaper
 * with the given resource ID.  That is, their wallpaper has been
 * set through {@link #setResource(int)} with the same resource id.
 */

Body of Frist Method:
{
    if (sGlobals.mService == null) {
        Log.w(TAG, "WallpaperService not running");
        return false;
    }
    try {
        Resources resources = mContext.getResources();
        String name = "res:" + resources.getResourceName(resid);
        return sGlobals.mService.hasNamedWallpaper(name);
    } catch (RemoteException e) {
        return false;
    }
}
Body of Second Method:
{
    if (sGlobals.mService == null) {
        Log.w(TAG, "WallpaperService not running");
        throw new RuntimeException(new DeadSystemException());
    }
    try {
        Resources resources = mContext.getResources();
        String name = "res:" + resources.getResourceName(resid);
        return sGlobals.mService.hasNamedWallpaper(name);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.app.backup.FullBackup.BackupScheme.getTokenForXmlDomain:COMMENT
Method Modifier: private     
Comment:/**
 * Map xml specified domain (human-readable, what clients put in their manifest's xml) to
 * BackupAgent internal data token.
 * @return null if the xml domain was invalid.
 */

Body of Frist Method:
{
    if ("root".equals(xmlDomain)) {
        return FullBackup.ROOT_TREE_TOKEN;
    } else if ("file".equals(xmlDomain)) {
        return FullBackup.DATA_TREE_TOKEN;
    } else if ("database".equals(xmlDomain)) {
        return FullBackup.DATABASE_TREE_TOKEN;
    } else if ("sharedpref".equals(xmlDomain)) {
        return FullBackup.SHAREDPREFS_TREE_TOKEN;
    } else if ("external".equals(xmlDomain)) {
        return FullBackup.MANAGED_EXTERNAL_TREE_TOKEN;
    } else {
        return null;
    }
}
Body of Second Method:
{
    if ("root".equals(xmlDomain)) {
        return FullBackup.ROOT_TREE_TOKEN;
    } else if ("file".equals(xmlDomain)) {
        return FullBackup.FILES_TREE_TOKEN;
    } else if ("database".equals(xmlDomain)) {
        return FullBackup.DATABASE_TREE_TOKEN;
    } else if ("sharedpref".equals(xmlDomain)) {
        return FullBackup.SHAREDPREFS_TREE_TOKEN;
    } else if ("device_root".equals(xmlDomain)) {
        return FullBackup.DEVICE_ROOT_TREE_TOKEN;
    } else if ("device_file".equals(xmlDomain)) {
        return FullBackup.DEVICE_FILES_TREE_TOKEN;
    } else if ("device_database".equals(xmlDomain)) {
        return FullBackup.DEVICE_DATABASE_TREE_TOKEN;
    } else if ("device_sharedpref".equals(xmlDomain)) {
        return FullBackup.DEVICE_SHAREDPREFS_TREE_TOKEN;
    } else if ("external".equals(xmlDomain)) {
        return FullBackup.MANAGED_EXTERNAL_TREE_TOKEN;
    } else {
        return null;
    }
}
------------------------
Find a silently evolved API code:android.telephony.ServiceState.rilRadioTechnologyToString:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Convert radio technology to String
 *
 * @param radioTechnology
 * @return String representation of the RAT
 *
 * @hide
 */

Body of Frist Method:
{
    String rtString;
    switch(rt) {
        case RIL_RADIO_TECHNOLOGY_UNKNOWN:
            rtString = "Unknown";
            break;
        case RIL_RADIO_TECHNOLOGY_GPRS:
            rtString = "GPRS";
            break;
        case RIL_RADIO_TECHNOLOGY_EDGE:
            rtString = "EDGE";
            break;
        case RIL_RADIO_TECHNOLOGY_UMTS:
            rtString = "UMTS";
            break;
        case RIL_RADIO_TECHNOLOGY_IS95A:
            rtString = "CDMA-IS95A";
            break;
        case RIL_RADIO_TECHNOLOGY_IS95B:
            rtString = "CDMA-IS95B";
            break;
        case RIL_RADIO_TECHNOLOGY_1xRTT:
            rtString = "1xRTT";
            break;
        case RIL_RADIO_TECHNOLOGY_EVDO_0:
            rtString = "EvDo-rev.0";
            break;
        case RIL_RADIO_TECHNOLOGY_EVDO_A:
            rtString = "EvDo-rev.A";
            break;
        case RIL_RADIO_TECHNOLOGY_HSDPA:
            rtString = "HSDPA";
            break;
        case RIL_RADIO_TECHNOLOGY_HSUPA:
            rtString = "HSUPA";
            break;
        case RIL_RADIO_TECHNOLOGY_HSPA:
            rtString = "HSPA";
            break;
        case RIL_RADIO_TECHNOLOGY_EVDO_B:
            rtString = "EvDo-rev.B";
            break;
        case RIL_RADIO_TECHNOLOGY_EHRPD:
            rtString = "eHRPD";
            break;
        case RIL_RADIO_TECHNOLOGY_LTE:
            rtString = "LTE";
            break;
        case RIL_RADIO_TECHNOLOGY_HSPAP:
            rtString = "HSPAP";
            break;
        case RIL_RADIO_TECHNOLOGY_GSM:
            rtString = "GSM";
            break;
        case RIL_RADIO_TECHNOLOGY_IWLAN:
            rtString = "IWLAN";
            break;
        default:
            rtString = "Unexpected";
            Rlog.w(LOG_TAG, "Unexpected radioTechnology=" + rt);
            break;
    }
    return rtString;
}
Body of Second Method:
{
    String rtString;
    switch(rt) {
        case RIL_RADIO_TECHNOLOGY_UNKNOWN:
            rtString = "Unknown";
            break;
        case RIL_RADIO_TECHNOLOGY_GPRS:
            rtString = "GPRS";
            break;
        case RIL_RADIO_TECHNOLOGY_EDGE:
            rtString = "EDGE";
            break;
        case RIL_RADIO_TECHNOLOGY_UMTS:
            rtString = "UMTS";
            break;
        case RIL_RADIO_TECHNOLOGY_IS95A:
            rtString = "CDMA-IS95A";
            break;
        case RIL_RADIO_TECHNOLOGY_IS95B:
            rtString = "CDMA-IS95B";
            break;
        case RIL_RADIO_TECHNOLOGY_1xRTT:
            rtString = "1xRTT";
            break;
        case RIL_RADIO_TECHNOLOGY_EVDO_0:
            rtString = "EvDo-rev.0";
            break;
        case RIL_RADIO_TECHNOLOGY_EVDO_A:
            rtString = "EvDo-rev.A";
            break;
        case RIL_RADIO_TECHNOLOGY_HSDPA:
            rtString = "HSDPA";
            break;
        case RIL_RADIO_TECHNOLOGY_HSUPA:
            rtString = "HSUPA";
            break;
        case RIL_RADIO_TECHNOLOGY_HSPA:
            rtString = "HSPA";
            break;
        case RIL_RADIO_TECHNOLOGY_EVDO_B:
            rtString = "EvDo-rev.B";
            break;
        case RIL_RADIO_TECHNOLOGY_EHRPD:
            rtString = "eHRPD";
            break;
        case RIL_RADIO_TECHNOLOGY_LTE:
            rtString = "LTE";
            break;
        case RIL_RADIO_TECHNOLOGY_HSPAP:
            rtString = "HSPAP";
            break;
        case RIL_RADIO_TECHNOLOGY_GSM:
            rtString = "GSM";
            break;
        case RIL_RADIO_TECHNOLOGY_IWLAN:
            rtString = "IWLAN";
            break;
        case RIL_RADIO_TECHNOLOGY_TD_SCDMA:
            rtString = "TD-SCDMA";
            break;
        default:
            rtString = "Unexpected";
            Rlog.w(LOG_TAG, "Unexpected radioTechnology=" + rt);
            break;
    }
    return rtString;
}
------------------------
Find a silently evolved API code:android.app.ActivityManager.getRunningAppProcesses:COMMENT
Method Modifier: public      
Comment:/**
 * Returns a list of application processes that are running on the device.
 *
 * <p><b>Note: this method is only intended for debugging or building
 * a user-facing process management UI.</b></p>
 *
 * @return Returns a list of RunningAppProcessInfo records, or null if there are no
 * running processes (it will not return an empty list).  This list ordering is not
 * specified.
 */

Body of Frist Method:
{
    try {
        return ActivityManagerNative.getDefault().getRunningAppProcesses();
    } catch (RemoteException e) {
        return null;
    }
}
Body of Second Method:
{
    try {
        return ActivityManagerNative.getDefault().getRunningAppProcesses();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.accounts.AccountManager.setUserData:COMMENT
Method Modifier: public      
Comment:/**
 * Sets one userdata key for an account.  Intended by use for the
 * authenticator to stash state for itself, not directly by applications.
 * The meaning of the keys and values is up to the authenticator.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>This method requires the caller to have a signature match with the
 * authenticator that manages the specified account.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * AUTHENTICATE_ACCOUNTS permission and same UID as account's authenticator
 * is needed for those platforms. See docs for this function in API level 22.
 *
 * @param account Account whose user data is to be set. Must not be {@code null}.
 * @param key String user data key to set.  Must not be null
 * @param value String value to set, {@code null} to clear this user data key
 */

Body of Frist Method:
{
    if (account == null)
        throw new IllegalArgumentException("account is null");
    if (key == null)
        throw new IllegalArgumentException("key is null");
    try {
        mService.setUserData(account, key, value);
    } catch (RemoteException e) {
        // Will happen if there is not signature match.
        throw new RuntimeException(e);
    }
}
Body of Second Method:
{
    if (account == null)
        throw new IllegalArgumentException("account is null");
    if (key == null)
        throw new IllegalArgumentException("key is null");
    try {
        mService.setUserData(account, key, value);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.media.AudioManager.getVibrateSetting:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * Returns whether the user's vibrate setting for a vibrate type.
 * <p>
 * This shouldn't be needed by most clients that want to vibrate, instead
 * see {@link #shouldVibrate(int)}.
 *
 * @param vibrateType The type of vibrate. One of
 * {@link #VIBRATE_TYPE_NOTIFICATION} or
 * {@link #VIBRATE_TYPE_RINGER}.
 * @return The vibrate setting, one of {@link #VIBRATE_SETTING_ON},
 * {@link #VIBRATE_SETTING_OFF}, or
 * {@link #VIBRATE_SETTING_ONLY_SILENT}.
 * @see #setVibrateSetting(int, int)
 * @see #shouldVibrate(int)
 * @deprecated Applications should maintain their own vibrate policy based on
 * current ringer mode that can be queried via {@link #getRingerMode()}.
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        return service.getVibrateSetting(vibrateType);
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in getVibrateSetting", e);
        return VIBRATE_SETTING_OFF;
    }
}
Body of Second Method:
{
    IAudioService service = getService();
    try {
        return service.getVibrateSetting(vibrateType);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.renderscript.Sampler.WRAP_NEAREST:COMMENT
Method Modifier: public      static      
Comment:/**
 * Retrieve a sampler with min and mag set to nearest and wrap modes set to
 * wrap.
 *
 * @param rs Context to which the sampler will belong.
 *
 * @return Sampler
 */

Body of Frist Method:
{
    if (rs.mSampler_WRAP_NEAREST == null) {
        Builder b = new Builder(rs);
        b.setMinification(Value.NEAREST);
        b.setMagnification(Value.NEAREST);
        b.setWrapS(Value.WRAP);
        b.setWrapT(Value.WRAP);
        rs.mSampler_WRAP_NEAREST = b.create();
    }
    return rs.mSampler_WRAP_NEAREST;
}
Body of Second Method:
{
    if (rs.mSampler_WRAP_NEAREST == null) {
        synchronized (rs) {
            if (rs.mSampler_WRAP_NEAREST == null) {
                Builder b = new Builder(rs);
                b.setMinification(Value.NEAREST);
                b.setMagnification(Value.NEAREST);
                b.setWrapS(Value.WRAP);
                b.setWrapT(Value.WRAP);
                rs.mSampler_WRAP_NEAREST = b.create();
            }
        }
    }
    return rs.mSampler_WRAP_NEAREST;
}
------------------------
Find a silently evolved API code:android.media.AudioFormat.isValidEncoding:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    switch(audioFormat) {
        case ENCODING_PCM_8BIT:
        case ENCODING_PCM_16BIT:
        case ENCODING_PCM_FLOAT:
        case ENCODING_AC3:
        case ENCODING_E_AC3:
        case ENCODING_DTS:
        case ENCODING_DTS_HD:
        case ENCODING_MP3:
        case ENCODING_AAC_LC:
        case ENCODING_AAC_HE_V1:
        case ENCODING_AAC_HE_V2:
            return true;
        default:
            return false;
    }
}
Body of Second Method:
{
    switch(audioFormat) {
        case ENCODING_PCM_8BIT:
        case ENCODING_PCM_16BIT:
        case ENCODING_PCM_FLOAT:
        case ENCODING_AC3:
        case ENCODING_E_AC3:
        case ENCODING_DTS:
        case ENCODING_DTS_HD:
        case ENCODING_MP3:
        case ENCODING_AAC_LC:
        case ENCODING_AAC_HE_V1:
        case ENCODING_AAC_HE_V2:
        case ENCODING_IEC61937:
            return true;
        default:
            return false;
    }
}
------------------------
Find a silently evolved API code:android.os.PowerManager.setPowerSaveMode:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Set the current power save mode.
 *
 * @return True if the set was allowed.
 *
 * @see #isPowerSaveMode()
 *
 * @hide
 */

Body of Frist Method:
{
    try {
        return mService.setPowerSaveMode(mode);
    } catch (RemoteException e) {
        return false;
    }
}
Body of Second Method:
{
    try {
        return mService.setPowerSaveMode(mode);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.media.AudioManager.setVibrateSetting:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * Sets the setting for when the vibrate type should vibrate.
 * <p>
 * This method should only be used by applications that replace the platform-wide
 * management of audio settings or the main telephony application.
 *
 * @param vibrateType The type of vibrate. One of
 * {@link #VIBRATE_TYPE_NOTIFICATION} or
 * {@link #VIBRATE_TYPE_RINGER}.
 * @param vibrateSetting The vibrate setting, one of
 * {@link #VIBRATE_SETTING_ON},
 * {@link #VIBRATE_SETTING_OFF}, or
 * {@link #VIBRATE_SETTING_ONLY_SILENT}.
 * @see #getVibrateSetting(int)
 * @see #shouldVibrate(int)
 * @deprecated Applications should maintain their own vibrate policy based on
 * current ringer mode that can be queried via {@link #getRingerMode()}.
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        service.setVibrateSetting(vibrateType, vibrateSetting);
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in setVibrateSetting", e);
    }
}
Body of Second Method:
{
    IAudioService service = getService();
    try {
        service.setVibrateSetting(vibrateType, vibrateSetting);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.graphics.drawable.RippleDrawable.tryRippleEnter:COMMENT
Method Modifier: private     
Comment:/**
 * Attempts to start an enter animation for the active hotspot. Fails if
 * there are too many animating ripples.
 */

Body of Frist Method:
{
    if (mExitingRipplesCount >= MAX_RIPPLES) {
        // or there is a bug that's preventing ripples from being removed.
        return;
    }
    if (mRipple == null) {
        final float x;
        final float y;
        if (mHasPending) {
            mHasPending = false;
            x = mPendingX;
            y = mPendingY;
        } else {
            x = mHotspotBounds.exactCenterX();
            y = mHotspotBounds.exactCenterY();
        }
        final boolean isBounded = isBounded();
        mRipple = new RippleForeground(this, mHotspotBounds, x, y, isBounded);
    }
    mRipple.setup(mState.mMaxRadius, mDensity);
    mRipple.enter(false);
}
Body of Second Method:
{
    if (mExitingRipplesCount >= MAX_RIPPLES) {
        // or there is a bug that's preventing ripples from being removed.
        return;
    }
    if (mRipple == null) {
        final float x;
        final float y;
        if (mHasPending) {
            mHasPending = false;
            x = mPendingX;
            y = mPendingY;
        } else {
            x = mHotspotBounds.exactCenterX();
            y = mHotspotBounds.exactCenterY();
        }
        final boolean isBounded = isBounded();
        mRipple = new RippleForeground(this, mHotspotBounds, x, y, isBounded, mForceSoftware);
    }
    mRipple.setup(mState.mMaxRadius, mDensity);
    mRipple.enter(false);
}
------------------------
Find a silently evolved API code:android.hardware.camera2.legacy.SurfaceTextureRenderer.drawIntoSurfaces:COMMENT
Method Modifier: public      
Comment:/**
 * Draw the current buffer in the {@link SurfaceTexture} returned from
 * {@link #getSurfaceTexture()} into the set of target {@link Surface}s
 * in the next request from the given {@link CaptureCollector}, or drop
 * the frame if none is available.
 *
 * <p>
 * Any {@link Surface}s targeted must be a subset of the {@link Surface}s
 * set in the last {@link #configureSurfaces(java.util.Collection)} call.
 * </p>
 *
 * @param targetCollector the surfaces to draw to.
 */

Body of Frist Method:
{
    if ((mSurfaces == null || mSurfaces.size() == 0) && (mConversionSurfaces == null || mConversionSurfaces.size() == 0)) {
        return;
    }
    boolean doTiming = targetCollector.hasPendingPreviewCaptures();
    checkGlError("before updateTexImage");
    if (doTiming) {
        beginGlTiming();
    }
    mSurfaceTexture.updateTexImage();
    long timestamp = mSurfaceTexture.getTimestamp();
    Pair<RequestHolder, Long> captureHolder = targetCollector.previewCaptured(timestamp);
    // No preview request queued, drop frame.
    if (captureHolder == null) {
        if (DEBUG) {
            Log.d(TAG, "Dropping preview frame.");
        }
        if (doTiming) {
            endGlTiming();
        }
        return;
    }
    RequestHolder request = captureHolder.first;
    Collection<Surface> targetSurfaces = request.getHolderTargets();
    if (doTiming) {
        addGlTimestamp(timestamp);
    }
    List<Long> targetSurfaceIds = LegacyCameraDevice.getSurfaceIds(targetSurfaces);
    for (EGLSurfaceHolder holder : mSurfaces) {
        if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)) {
            try {
                LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height);
                makeCurrent(holder.eglSurface);
                LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second);
                drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing == CameraCharacteristics.LENS_FACING_FRONT) ? FLIP_TYPE_HORIZONTAL : FLIP_TYPE_NONE);
                swapBuffers(holder.eglSurface);
            } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
                Log.w(TAG, "Surface abandoned, dropping frame. ", e);
            }
        }
    }
    for (EGLSurfaceHolder holder : mConversionSurfaces) {
        if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)) {
            makeCurrent(holder.eglSurface);
            // glReadPixels reads from the bottom of the buffer, so add an extra vertical flip
            drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing == CameraCharacteristics.LENS_FACING_FRONT) ? FLIP_TYPE_BOTH : FLIP_TYPE_VERTICAL);
            mPBufferPixels.clear();
            GLES20.glReadPixels(/*x*/
            0, /*y*/
            0, holder.width, holder.height, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, mPBufferPixels);
            checkGlError("glReadPixels");
            try {
                int format = LegacyCameraDevice.detectSurfaceType(holder.surface);
                LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height);
                LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second);
                LegacyCameraDevice.produceFrame(holder.surface, mPBufferPixels.array(), holder.width, holder.height, format);
            } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
                Log.w(TAG, "Surface abandoned, dropping frame. ", e);
            }
        }
    }
    targetCollector.previewProduced();
    if (doTiming) {
        endGlTiming();
    }
}
Body of Second Method:
{
    if ((mSurfaces == null || mSurfaces.size() == 0) && (mConversionSurfaces == null || mConversionSurfaces.size() == 0)) {
        return;
    }
    boolean doTiming = targetCollector.hasPendingPreviewCaptures();
    checkGlError("before updateTexImage");
    if (doTiming) {
        beginGlTiming();
    }
    mSurfaceTexture.updateTexImage();
    long timestamp = mSurfaceTexture.getTimestamp();
    Pair<RequestHolder, Long> captureHolder = targetCollector.previewCaptured(timestamp);
    // No preview request queued, drop frame.
    if (captureHolder == null) {
        if (DEBUG) {
            Log.d(TAG, "Dropping preview frame.");
        }
        if (doTiming) {
            endGlTiming();
        }
        return;
    }
    RequestHolder request = captureHolder.first;
    Collection<Surface> targetSurfaces = request.getHolderTargets();
    if (doTiming) {
        addGlTimestamp(timestamp);
    }
    List<Long> targetSurfaceIds = new ArrayList();
    try {
        targetSurfaceIds = LegacyCameraDevice.getSurfaceIds(targetSurfaces);
    } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
        Log.w(TAG, "Surface abandoned, dropping frame. ", e);
        request.setOutputAbandoned();
    }
    for (EGLSurfaceHolder holder : mSurfaces) {
        if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)) {
            try {
                LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height);
                makeCurrent(holder.eglSurface);
                LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second);
                drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing == CameraCharacteristics.LENS_FACING_FRONT) ? FLIP_TYPE_HORIZONTAL : FLIP_TYPE_NONE);
                swapBuffers(holder.eglSurface);
            } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
                Log.w(TAG, "Surface abandoned, dropping frame. ", e);
                request.setOutputAbandoned();
            }
        }
    }
    for (EGLSurfaceHolder holder : mConversionSurfaces) {
        if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)) {
            makeCurrent(holder.eglSurface);
            // glReadPixels reads from the bottom of the buffer, so add an extra vertical flip
            drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing == CameraCharacteristics.LENS_FACING_FRONT) ? FLIP_TYPE_BOTH : FLIP_TYPE_VERTICAL);
            mPBufferPixels.clear();
            GLES20.glReadPixels(/*x*/
            0, /*y*/
            0, holder.width, holder.height, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, mPBufferPixels);
            checkGlError("glReadPixels");
            try {
                int format = LegacyCameraDevice.detectSurfaceType(holder.surface);
                LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height);
                LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second);
                LegacyCameraDevice.produceFrame(holder.surface, mPBufferPixels.array(), holder.width, holder.height, format);
            } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
                Log.w(TAG, "Surface abandoned, dropping frame. ", e);
                request.setOutputAbandoned();
            }
        }
    }
    targetCollector.previewProduced();
    if (doTiming) {
        endGlTiming();
    }
}
------------------------
Find a silently evolved API code:android.app.ActivityManager.checkUidPermission:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    try {
        return AppGlobals.getPackageManager().checkUidPermission(permission, uid);
    } catch (RemoteException e) {
        // Should never happen, but if it does... deny!
        Slog.e(TAG, "PackageManager is dead?!?", e);
    }
    return PackageManager.PERMISSION_DENIED;
}
Body of Second Method:
{
    try {
        return AppGlobals.getPackageManager().checkUidPermission(permission, uid);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.content.ContentResolver.openAssetFileDescriptor:COMMENT
Method Modifier: public      final       
Comment:/**
 * Open a raw file descriptor to access data under a URI.  This
 * interacts with the underlying {@link ContentProvider#openAssetFile}
 * method of the provider associated with the given URI, to retrieve any file stored there.
 *
 * <h5>Accepts the following URI schemes:</h5>
 * <ul>
 * <li>content ({@link #SCHEME_CONTENT})</li>
 * <li>android.resource ({@link #SCHEME_ANDROID_RESOURCE})</li>
 * <li>file ({@link #SCHEME_FILE})</li>
 * </ul>
 * <h5>The android.resource ({@link #SCHEME_ANDROID_RESOURCE}) Scheme</h5>
 * <p>
 * A Uri object can be used to reference a resource in an APK file.  The
 * Uri should be one of the following formats:
 * <ul>
 * <li><code>android.resource://package_name/id_number</code><br/>
 * <code>package_name</code> is your package name as listed in your AndroidManifest.xml.
 * For example <code>com.example.myapp</code><br/>
 * <code>id_number</code> is the int form of the ID.<br/>
 * The easiest way to construct this form is
 * <pre>Uri uri = Uri.parse("android.resource://com.example.myapp/" + R.raw.my_resource");</pre>
 * </li>
 * <li><code>android.resource://package_name/type/name</code><br/>
 * <code>package_name</code> is your package name as listed in your AndroidManifest.xml.
 * For example <code>com.example.myapp</code><br/>
 * <code>type</code> is the string form of the resource type.  For example, <code>raw</code>
 * or <code>drawable</code>.
 * <code>name</code> is the string form of the resource name.  That is, whatever the file
 * name was in your res directory, without the type extension.
 * The easiest way to construct this form is
 * <pre>Uri uri = Uri.parse("android.resource://com.example.myapp/raw/my_resource");</pre>
 * </li>
 * </ul>
 *
 * <p>Note that if this function is called for read-only input (mode is "r")
 * on a content: URI, it will instead call {@link #openTypedAssetFileDescriptor}
 * for you with a MIME type of "*&#47;*".  This allows such callers to benefit
 * from any built-in data conversion that a provider implements.
 *
 * @param uri The desired URI to open.
 * @param mode The file mode to use, as per {@link ContentProvider#openAssetFile
 * ContentProvider.openAssetFile}.
 * @param cancellationSignal A signal to cancel the operation in progress, or null if
 * none. If the operation is canceled, then
 * {@link OperationCanceledException} will be thrown.
 * @return Returns a new ParcelFileDescriptor pointing to the file.  You
 * own this descriptor and are responsible for closing it when done.
 * @throws FileNotFoundException Throws FileNotFoundException of no
 * file exists under the URI or the mode is invalid.
 */

Body of Frist Method:
{
    Preconditions.checkNotNull(uri, "uri");
    Preconditions.checkNotNull(mode, "mode");
    String scheme = uri.getScheme();
    if (SCHEME_ANDROID_RESOURCE.equals(scheme)) {
        if (!"r".equals(mode)) {
            throw new FileNotFoundException("Can't write resources: " + uri);
        }
        OpenResourceIdResult r = getResourceId(uri);
        try {
            return r.r.openRawResourceFd(r.id);
        } catch (Resources.NotFoundException ex) {
            throw new FileNotFoundException("Resource does not exist: " + uri);
        }
    } else if (SCHEME_FILE.equals(scheme)) {
        ParcelFileDescriptor pfd = ParcelFileDescriptor.open(new File(uri.getPath()), ParcelFileDescriptor.parseMode(mode));
        return new AssetFileDescriptor(pfd, 0, -1);
    } else {
        if ("r".equals(mode)) {
            return openTypedAssetFileDescriptor(uri, "*/*", null, cancellationSignal);
        } else {
            IContentProvider unstableProvider = acquireUnstableProvider(uri);
            if (unstableProvider == null) {
                throw new FileNotFoundException("No content provider: " + uri);
            }
            IContentProvider stableProvider = null;
            AssetFileDescriptor fd = null;
            try {
                ICancellationSignal remoteCancellationSignal = null;
                if (cancellationSignal != null) {
                    cancellationSignal.throwIfCanceled();
                    remoteCancellationSignal = unstableProvider.createCancellationSignal();
                    cancellationSignal.setRemote(remoteCancellationSignal);
                }
                try {
                    fd = unstableProvider.openAssetFile(mPackageName, uri, mode, remoteCancellationSignal);
                    if (fd == null) {
                        // The provider will be released by the finally{} clause
                        return null;
                    }
                } catch (DeadObjectException e) {
                    // The remote process has died...  but we only hold an unstable
                    // reference though, so we might recover!!!  Let's try!!!!
                    // This is exciting!!1!!1!!!!1
                    unstableProviderDied(unstableProvider);
                    stableProvider = acquireProvider(uri);
                    if (stableProvider == null) {
                        throw new FileNotFoundException("No content provider: " + uri);
                    }
                    fd = stableProvider.openAssetFile(mPackageName, uri, mode, remoteCancellationSignal);
                    if (fd == null) {
                        // The provider will be released by the finally{} clause
                        return null;
                    }
                }
                if (stableProvider == null) {
                    stableProvider = acquireProvider(uri);
                }
                releaseUnstableProvider(unstableProvider);
                ParcelFileDescriptor pfd = new ParcelFileDescriptorInner(fd.getParcelFileDescriptor(), stableProvider);
                // Success!  Don't release the provider when exiting, let
                // ParcelFileDescriptorInner do that when it is closed.
                stableProvider = null;
                return new AssetFileDescriptor(pfd, fd.getStartOffset(), fd.getDeclaredLength());
            } catch (RemoteException e) {
                // Whatever, whatever, we'll go away.
                throw new FileNotFoundException("Failed opening content provider: " + uri);
            } catch (FileNotFoundException e) {
                throw e;
            } finally {
                if (cancellationSignal != null) {
                    cancellationSignal.setRemote(null);
                }
                if (stableProvider != null) {
                    releaseProvider(stableProvider);
                }
                if (unstableProvider != null) {
                    releaseUnstableProvider(unstableProvider);
                }
            }
        }
    }
}
Body of Second Method:
{
    Preconditions.checkNotNull(uri, "uri");
    Preconditions.checkNotNull(mode, "mode");
    String scheme = uri.getScheme();
    if (SCHEME_ANDROID_RESOURCE.equals(scheme)) {
        if (!"r".equals(mode)) {
            throw new FileNotFoundException("Can't write resources: " + uri);
        }
        OpenResourceIdResult r = getResourceId(uri);
        try {
            return r.r.openRawResourceFd(r.id);
        } catch (Resources.NotFoundException ex) {
            throw new FileNotFoundException("Resource does not exist: " + uri);
        }
    } else if (SCHEME_FILE.equals(scheme)) {
        ParcelFileDescriptor pfd = ParcelFileDescriptor.open(new File(uri.getPath()), ParcelFileDescriptor.parseMode(mode));
        return new AssetFileDescriptor(pfd, 0, -1);
    } else {
        if ("r".equals(mode)) {
            return openTypedAssetFileDescriptor(uri, "*/*", null, cancellationSignal);
        } else {
            IContentProvider unstableProvider = acquireUnstableProvider(uri);
            if (unstableProvider == null) {
                throw new FileNotFoundException("No content provider: " + uri);
            }
            IContentProvider stableProvider = null;
            AssetFileDescriptor fd = null;
            try {
                ICancellationSignal remoteCancellationSignal = null;
                if (cancellationSignal != null) {
                    cancellationSignal.throwIfCanceled();
                    remoteCancellationSignal = unstableProvider.createCancellationSignal();
                    cancellationSignal.setRemote(remoteCancellationSignal);
                }
                try {
                    fd = unstableProvider.openAssetFile(mPackageName, uri, mode, remoteCancellationSignal);
                    if (fd == null) {
                        // The provider will be released by the finally{} clause
                        return null;
                    }
                } catch (DeadObjectException e) {
                    // The remote process has died...  but we only hold an unstable
                    // reference though, so we might recover!!!  Let's try!!!!
                    // This is exciting!!1!!1!!!!1
                    unstableProviderDied(unstableProvider);
                    stableProvider = acquireProvider(uri);
                    if (stableProvider == null) {
                        throw new FileNotFoundException("No content provider: " + uri);
                    }
                    fd = stableProvider.openAssetFile(mPackageName, uri, mode, remoteCancellationSignal);
                    if (fd == null) {
                        // The provider will be released by the finally{} clause
                        return null;
                    }
                }
                if (stableProvider == null) {
                    stableProvider = acquireProvider(uri);
                }
                releaseUnstableProvider(unstableProvider);
                unstableProvider = null;
                ParcelFileDescriptor pfd = new ParcelFileDescriptorInner(fd.getParcelFileDescriptor(), stableProvider);
                // Success!  Don't release the provider when exiting, let
                // ParcelFileDescriptorInner do that when it is closed.
                stableProvider = null;
                return new AssetFileDescriptor(pfd, fd.getStartOffset(), fd.getDeclaredLength());
            } catch (RemoteException e) {
                // Whatever, whatever, we'll go away.
                throw new FileNotFoundException("Failed opening content provider: " + uri);
            } catch (FileNotFoundException e) {
                throw e;
            } finally {
                if (cancellationSignal != null) {
                    cancellationSignal.setRemote(null);
                }
                if (stableProvider != null) {
                    releaseProvider(stableProvider);
                }
                if (unstableProvider != null) {
                    releaseUnstableProvider(unstableProvider);
                }
            }
        }
    }
}
------------------------
Find a silently evolved API code:android.text.Hyphenator.init:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Load hyphenation patterns at initialization time. We want to have patterns
 * for all locales loaded and ready to use so we don't have to do any file IO
 * on the UI thread when drawing text in different locales.
 *
 * @hide
 */

Body of Frist Method:
{
    sMap.put(null, null);
    // TODO: replace this with a discovery-based method that looks into /system/usr/hyphen-data
    String[] availableLanguages = { "en-US", "eu", "hu", "hy", "nb", "nn", "sa", "und-Ethi" };
    for (int i = 0; i < availableLanguages.length; i++) {
        String languageTag = availableLanguages[i];
        Hyphenator h = loadHyphenator(languageTag);
        if (h != null) {
            sMap.put(Locale.forLanguageTag(languageTag), h);
        }
    }
    for (int i = 0; i < LOCALE_FALLBACK_DATA.length; i++) {
        String language = LOCALE_FALLBACK_DATA[i][0];
        String fallback = LOCALE_FALLBACK_DATA[i][1];
        sMap.put(Locale.forLanguageTag(language), sMap.get(Locale.forLanguageTag(fallback)));
    }
}
Body of Second Method:
{
    sMap.put(null, null);
    // TODO: replace this with a discovery-based method that looks into /system/usr/hyphen-data
    String[] availableLanguages = { "as", "bn", "cy", "da", "de-1901", "de-1996", "de-CH-1901", "en-GB", "en-US", "es", "et", "eu", "fr", "ga", "gu", "hi", "hr", "hu", "hy", "kn", "ml", "mn-Cyrl", "mr", "nb", "nn", "or", "pa", "pt", "sl", "ta", "te", "tk", "und-Ethi" };
    for (int i = 0; i < availableLanguages.length; i++) {
        String languageTag = availableLanguages[i];
        Hyphenator h = loadHyphenator(languageTag);
        if (h != null) {
            sMap.put(Locale.forLanguageTag(languageTag), h);
        }
    }
    for (int i = 0; i < LOCALE_FALLBACK_DATA.length; i++) {
        String language = LOCALE_FALLBACK_DATA[i][0];
        String fallback = LOCALE_FALLBACK_DATA[i][1];
        sMap.put(Locale.forLanguageTag(language), sMap.get(Locale.forLanguageTag(fallback)));
    }
}
------------------------
Find a silently evolved API code:android.telephony.TelephonyManager.setRoamingOverride:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Override the roaming preference for the current ICCID.
 *
 * Using this call, the carrier app (see #hasCarrierPrivileges) can override
 * the platform's notion of a network operator being considered roaming or not.
 * The change only affects the ICCID that was active when this call was made.
 *
 * If null is passed as any of the input, the corresponding value is deleted.
 *
 * <p>Requires that the caller have carrier privilege. See #hasCarrierPrivileges.
 *
 * @param gsmRoamingList - List of MCCMNCs to be considered roaming for 3GPP RATs.
 * @param gsmNonRoamingList - List of MCCMNCs to be considered not roaming for 3GPP RATs.
 * @param cdmaRoamingList - List of SIDs to be considered roaming for 3GPP2 RATs.
 * @param cdmaNonRoamingList - List of SIDs to be considered not roaming for 3GPP2 RATs.
 * @return true if the operation was executed correctly.
 *
 * @hide
 */

Body of Frist Method:
{
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            return telephony.setRoamingOverride(gsmRoamingList, gsmNonRoamingList, cdmaRoamingList, cdmaNonRoamingList);
    } catch (RemoteException ex) {
        Rlog.e(TAG, "setRoamingOverride RemoteException", ex);
    } catch (NullPointerException ex) {
        Rlog.e(TAG, "setRoamingOverride NPE", ex);
    }
    return false;
}
Body of Second Method:
{
    return setRoamingOverride(getSubId(), gsmRoamingList, gsmNonRoamingList, cdmaRoamingList, cdmaNonRoamingList);
}
------------------------
Find a silently evolved API code:android.hardware.SerialManager.openSerialPort:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Opens and returns the {@link android.hardware.SerialPort} with the given name.
 * The speed of the serial port must be one of:
 * 50, 75, 110, 134, 150, 200, 300, 600, 1200, 1800, 2400, 4800, 9600,
 * 19200, 38400, 57600, 115200, 230400, 460800, 500000, 576000, 921600, 1000000, 1152000,
 * 1500000, 2000000, 2500000, 3000000, 3500000 or 4000000
 *
 * @param name of the serial port
 * @param speed at which to open the serial port
 * @return the serial port
 */

Body of Frist Method:
{
    try {
        ParcelFileDescriptor pfd = mService.openSerialPort(name);
        if (pfd != null) {
            SerialPort port = new SerialPort(name);
            port.open(pfd, speed);
            return port;
        } else {
            throw new IOException("Could not open serial port " + name);
        }
    } catch (RemoteException e) {
        Log.e(TAG, "exception in UsbManager.openDevice", e);
    }
    return null;
}
Body of Second Method:
{
    try {
        ParcelFileDescriptor pfd = mService.openSerialPort(name);
        if (pfd != null) {
            SerialPort port = new SerialPort(name);
            port.open(pfd, speed);
            return port;
        } else {
            throw new IOException("Could not open serial port " + name);
        }
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.app.trust.TrustManager.reportUnlockAttempt:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Reports that user {@param userId} has tried to unlock the device.
 *
 * @param successful if true, the unlock attempt was successful.
 *
 * Requires the {@link android.Manifest.permission#ACCESS_KEYGUARD_SECURE_STORAGE} permission.
 */

Body of Frist Method:
{
    try {
        mService.reportUnlockAttempt(successful, userId);
    } catch (RemoteException e) {
        onError(e);
    }
}
Body of Second Method:
{
    try {
        mService.reportUnlockAttempt(successful, userId);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.accounts.AccountManager.notifyAccountAuthenticated:COMMENT
Method Modifier: public      
Comment:/**
 * Notifies the system that the account has just been authenticated. This
 * information may be used by other applications to verify the account. This
 * should be called only when the user has entered correct credentials for
 * the account.
 * <p>
 * It is not safe to call this method from the main thread. As such, call it
 * from another thread.
 * <p>This method requires the caller to have a signature match with the
 * authenticator that owns the specified account.
 *
 * @param account The {@link Account} to be updated.
 * @return boolean {@code true} if the authentication of the account has been successfully
 * acknowledged. Otherwise {@code false}.
 */

Body of Frist Method:
{
    if (account == null)
        throw new IllegalArgumentException("account is null");
    try {
        return mService.accountAuthenticated(account);
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}
Body of Second Method:
{
    if (account == null)
        throw new IllegalArgumentException("account is null");
    try {
        return mService.accountAuthenticated(account);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.media.AudioManager.getRingerMode:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the current ringtone mode.
 *
 * @return The current ringtone mode, one of {@link #RINGER_MODE_NORMAL},
 * {@link #RINGER_MODE_SILENT}, or {@link #RINGER_MODE_VIBRATE}.
 * @see #setRingerMode(int)
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        return service.getRingerModeExternal();
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in getRingerMode", e);
        return RINGER_MODE_NORMAL;
    }
}
Body of Second Method:
{
    IAudioService service = getService();
    try {
        return service.getRingerModeExternal();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.app.ActivityManager.getRunningExternalApplications:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns a list of application processes installed on external media
 * that are running on the device.
 *
 * <p><b>Note: this method is only intended for debugging or building
 * a user-facing process management UI.</b></p>
 *
 * @return Returns a list of ApplicationInfo records, or null if none
 * This list ordering is not specified.
 * @hide
 */

Body of Frist Method:
{
    try {
        return ActivityManagerNative.getDefault().getRunningExternalApplications();
    } catch (RemoteException e) {
        return null;
    }
}
Body of Second Method:
{
    try {
        return ActivityManagerNative.getDefault().getRunningExternalApplications();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.telephony.CellSignalStrengthGsm.setDefaultValues:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    mSignalStrength = Integer.MAX_VALUE;
    mBitErrorRate = Integer.MAX_VALUE;
}
Body of Second Method:
{
    mSignalStrength = Integer.MAX_VALUE;
    mBitErrorRate = Integer.MAX_VALUE;
    mTimingAdvance = Integer.MAX_VALUE;
}
------------------------
Find a silently evolved API code:android.location.Location.set:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the contents of the location to the values from the given location.
 */

Body of Frist Method:
{
    mProvider = l.mProvider;
    mTime = l.mTime;
    mElapsedRealtimeNanos = l.mElapsedRealtimeNanos;
    mLatitude = l.mLatitude;
    mLongitude = l.mLongitude;
    mHasAltitude = l.mHasAltitude;
    mAltitude = l.mAltitude;
    mHasSpeed = l.mHasSpeed;
    mSpeed = l.mSpeed;
    mHasBearing = l.mHasBearing;
    mBearing = l.mBearing;
    mHasAccuracy = l.mHasAccuracy;
    mAccuracy = l.mAccuracy;
    mExtras = (l.mExtras == null) ? null : new Bundle(l.mExtras);
    mIsFromMockProvider = l.mIsFromMockProvider;
}
Body of Second Method:
{
    mProvider = l.mProvider;
    mTime = l.mTime;
    mElapsedRealtimeNanos = l.mElapsedRealtimeNanos;
    mFieldsMask = l.mFieldsMask;
    mLatitude = l.mLatitude;
    mLongitude = l.mLongitude;
    mAltitude = l.mAltitude;
    mSpeed = l.mSpeed;
    mBearing = l.mBearing;
    mAccuracy = l.mAccuracy;
    mExtras = (l.mExtras == null) ? null : new Bundle(l.mExtras);
}
------------------------
Find a silently evolved API code:android.net.ConnectivityManager.addDefaultNetworkActiveListener:COMMENT
Method Modifier: public      
Comment:/**
 * Start listening to reports when the system's default data network is active, meaning it is
 * a good time to perform network traffic.  Use {@link #isDefaultNetworkActive()}
 * to determine the current state of the system's default network after registering the
 * listener.
 * <p>
 * If the process default network has been set with
 * {@link ConnectivityManager#bindProcessToNetwork} this function will not
 * reflect the process's default, but the system default.
 *
 * @param l The listener to be told when the network is active.
 */

Body of Frist Method:
{
    INetworkActivityListener rl = new INetworkActivityListener.Stub() {

        @Override
        public void onNetworkActive() throws RemoteException {
            l.onNetworkActive();
        }
    };
    try {
        getNetworkManagementService().registerNetworkActivityListener(rl);
        mNetworkActivityListeners.put(l, rl);
    } catch (RemoteException e) {
    }
}
Body of Second Method:
{
    INetworkActivityListener rl = new INetworkActivityListener.Stub() {

        @Override
        public void onNetworkActive() throws RemoteException {
            l.onNetworkActive();
        }
    };
    try {
        getNetworkManagementService().registerNetworkActivityListener(rl);
        mNetworkActivityListeners.put(l, rl);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.app.BackStackRecord.removeTargetedViewsFromTransitions:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * After the transition has started, remove all targets that we added to the transitions
 * so that the transitions are left in a clean state.
 */

Body of Frist Method:
{
    if (overallTransition != null) {
        sceneRoot.getViewTreeObserver().addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {

            @Override
            public boolean onPreDraw() {
                sceneRoot.getViewTreeObserver().removeOnPreDrawListener(this);
                if (enterTransition != null) {
                    removeTargets(enterTransition, enteringViews);
                }
                if (exitTransition != null) {
                    removeTargets(exitTransition, exitingViews);
                }
                if (sharedElementTransition != null) {
                    removeTargets(sharedElementTransition, sharedElementTargets);
                }
                int numViews = hiddenViews.size();
                for (int i = 0; i < numViews; i++) {
                    overallTransition.excludeTarget(hiddenViews.get(i), false);
                }
                overallTransition.excludeTarget(nonExistingView, false);
                return true;
            }
        });
    }
}
Body of Second Method:
{
    if (overallTransition != null) {
        sceneRoot.getViewTreeObserver().addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {

            @Override
            public boolean onPreDraw() {
                sceneRoot.getViewTreeObserver().removeOnPreDrawListener(this);
                if (enterTransition != null) {
                    removeTargets(enterTransition, enteringViews);
                    excludeViews(enterTransition, exitTransition, exitingViews, false);
                    excludeViews(enterTransition, sharedElementTransition, sharedElementTargets, false);
                }
                if (exitTransition != null) {
                    removeTargets(exitTransition, exitingViews);
                    excludeViews(exitTransition, enterTransition, enteringViews, false);
                    excludeViews(exitTransition, sharedElementTransition, sharedElementTargets, false);
                }
                if (sharedElementTransition != null) {
                    removeTargets(sharedElementTransition, sharedElementTargets);
                }
                int numViews = hiddenViews.size();
                for (int i = 0; i < numViews; i++) {
                    overallTransition.excludeTarget(hiddenViews.get(i), false);
                }
                overallTransition.excludeTarget(nonExistingView, false);
                return true;
            }
        });
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.p2p.WifiP2pManager.getP2pStateMachineMessenger:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get a reference to P2pStateMachine handler. This is used to establish
 * a priveleged AsyncChannel communication with WifiP2pService.
 *
 * @return Messenger pointing to the WifiP2pService handler
 * @hide
 */

Body of Frist Method:
{
    try {
        return mService.getP2pStateMachineMessenger();
    } catch (RemoteException e) {
        return null;
    }
}
Body of Second Method:
{
    try {
        return mService.getP2pStateMachineMessenger();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.content.res.AssetManager.addAssetPath:COMMENT
Method Modifier: public      final       hidden      
Comment:/**
 * Add an additional set of assets to the asset manager.  This can be
 * either a directory or ZIP file.  Not for use by applications.  Returns
 * the cookie of the added asset, or 0 on failure.
 * {@hide}
 */

Body of Frist Method:
{
    synchronized (this) {
        int res = addAssetPathNative(path);
        makeStringBlocks(mStringBlocks);
        return res;
    }
}
Body of Second Method:
{
    return addAssetPathInternal(path, false);
}
------------------------
Find a silently evolved API code:android.telephony.SignalStrength.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * {@link Parcelable#writeToParcel}
 */

Body of Frist Method:
{
    out.writeInt(mGsmSignalStrength);
    out.writeInt(mGsmBitErrorRate);
    out.writeInt(mCdmaDbm);
    out.writeInt(mCdmaEcio);
    out.writeInt(mEvdoDbm);
    out.writeInt(mEvdoEcio);
    out.writeInt(mEvdoSnr);
    out.writeInt(mLteSignalStrength);
    out.writeInt(mLteRsrp);
    out.writeInt(mLteRsrq);
    out.writeInt(mLteRssnr);
    out.writeInt(mLteCqi);
    out.writeInt(isGsm ? 1 : 0);
}
Body of Second Method:
{
    out.writeInt(mGsmSignalStrength);
    out.writeInt(mGsmBitErrorRate);
    out.writeInt(mCdmaDbm);
    out.writeInt(mCdmaEcio);
    out.writeInt(mEvdoDbm);
    out.writeInt(mEvdoEcio);
    out.writeInt(mEvdoSnr);
    out.writeInt(mLteSignalStrength);
    out.writeInt(mLteRsrp);
    out.writeInt(mLteRsrq);
    out.writeInt(mLteRssnr);
    out.writeInt(mLteCqi);
    out.writeInt(mTdScdmaRscp);
    out.writeInt(isGsm ? 1 : 0);
}
------------------------
Find a silently evolved API code:android.renderscript.Allocation.createSized:COMMENT
Method Modifier: public      static      
Comment:/**
 * Creates an Allocation with a specified number of given elements
 *
 * @param rs Context to which the Allocation will belong.
 * @param e Element to use in the Allocation
 * @param count the number of Elements in the Allocation
 * @param usage bit field specifying how the Allocation is
 * utilized
 *
 * @return allocation
 */

Body of Frist Method:
{
    try {
        Trace.traceBegin(RenderScript.TRACE_TAG, "createSized");
        rs.validate();
        Type.Builder b = new Type.Builder(rs, e);
        b.setX(count);
        Type t = b.create();
        long id = rs.nAllocationCreateTyped(t.getID(rs), MipmapControl.MIPMAP_NONE.mID, usage, 0);
        if (id == 0) {
            throw new RSRuntimeException("Allocation creation failed.");
        }
        return new Allocation(id, rs, t, usage);
    } finally {
        Trace.traceEnd(RenderScript.TRACE_TAG);
    }
}
Body of Second Method:
{
    try {
        Trace.traceBegin(RenderScript.TRACE_TAG, "createSized");
        rs.validate();
        Type.Builder b = new Type.Builder(rs, e);
        b.setX(count);
        Type t = b.create();
        long id = rs.nAllocationCreateTyped(t.getID(rs), MipmapControl.MIPMAP_NONE.mID, usage, 0);
        if (id == 0) {
            throw new RSRuntimeException("Allocation creation failed.");
        }
        return new Allocation(id, rs, t, true, usage, MipmapControl.MIPMAP_NONE);
    } finally {
        Trace.traceEnd(RenderScript.TRACE_TAG);
    }
}
------------------------
Find a silently evolved API code:android.widget.TextView.setCompoundDrawablesRelative:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the Drawables (if any) to appear to the start of, above, to the end
 * of, and below the text. Use {@code null} if you do not want a Drawable
 * there. The Drawables must already have had {@link Drawable#setBounds}
 * called.
 * <p>
 * Calling this method will overwrite any Drawables previously set using
 * {@link #setCompoundDrawables} or related methods.
 *
 * @attr ref android.R.styleable#TextView_drawableStart
 * @attr ref android.R.styleable#TextView_drawableTop
 * @attr ref android.R.styleable#TextView_drawableEnd
 * @attr ref android.R.styleable#TextView_drawableBottom
 */

Body of Frist Method:
{
    Drawables dr = mDrawables;
    // We're switching to relative, discard absolute.
    if (dr != null) {
        if (dr.mShowing[Drawables.LEFT] != null) {
            dr.mShowing[Drawables.LEFT].setCallback(null);
        }
        dr.mShowing[Drawables.LEFT] = dr.mDrawableLeftInitial = null;
        if (dr.mShowing[Drawables.RIGHT] != null) {
            dr.mShowing[Drawables.RIGHT].setCallback(null);
        }
        dr.mShowing[Drawables.RIGHT] = dr.mDrawableRightInitial = null;
        dr.mDrawableSizeLeft = dr.mDrawableHeightLeft = 0;
        dr.mDrawableSizeRight = dr.mDrawableHeightRight = 0;
    }
    final boolean drawables = start != null || top != null || end != null || bottom != null;
    if (!drawables) {
        // Clearing drawables...  can we free the data structure?
        if (dr != null) {
            if (dr.mDrawablePadding == 0) {
                mDrawables = null;
            } else {
                // out all of the fields in the existing structure.
                if (dr.mDrawableStart != null)
                    dr.mDrawableStart.setCallback(null);
                dr.mDrawableStart = null;
                if (dr.mShowing[Drawables.TOP] != null) {
                    dr.mShowing[Drawables.TOP].setCallback(null);
                }
                dr.mShowing[Drawables.TOP] = null;
                if (dr.mDrawableEnd != null) {
                    dr.mDrawableEnd.setCallback(null);
                }
                dr.mDrawableEnd = null;
                if (dr.mShowing[Drawables.BOTTOM] != null) {
                    dr.mShowing[Drawables.BOTTOM].setCallback(null);
                }
                dr.mShowing[Drawables.BOTTOM] = null;
                dr.mDrawableSizeStart = dr.mDrawableHeightStart = 0;
                dr.mDrawableSizeEnd = dr.mDrawableHeightEnd = 0;
                dr.mDrawableSizeTop = dr.mDrawableWidthTop = 0;
                dr.mDrawableSizeBottom = dr.mDrawableWidthBottom = 0;
            }
        }
    } else {
        if (dr == null) {
            mDrawables = dr = new Drawables(getContext());
        }
        mDrawables.mOverride = true;
        if (dr.mDrawableStart != start && dr.mDrawableStart != null) {
            dr.mDrawableStart.setCallback(null);
        }
        dr.mDrawableStart = start;
        if (dr.mShowing[Drawables.TOP] != top && dr.mShowing[Drawables.TOP] != null) {
            dr.mShowing[Drawables.TOP].setCallback(null);
        }
        dr.mShowing[Drawables.TOP] = top;
        if (dr.mDrawableEnd != end && dr.mDrawableEnd != null) {
            dr.mDrawableEnd.setCallback(null);
        }
        dr.mDrawableEnd = end;
        if (dr.mShowing[Drawables.BOTTOM] != bottom && dr.mShowing[Drawables.BOTTOM] != null) {
            dr.mShowing[Drawables.BOTTOM].setCallback(null);
        }
        dr.mShowing[Drawables.BOTTOM] = bottom;
        final Rect compoundRect = dr.mCompoundRect;
        int[] state;
        state = getDrawableState();
        if (start != null) {
            start.setState(state);
            start.copyBounds(compoundRect);
            start.setCallback(this);
            dr.mDrawableSizeStart = compoundRect.width();
            dr.mDrawableHeightStart = compoundRect.height();
        } else {
            dr.mDrawableSizeStart = dr.mDrawableHeightStart = 0;
        }
        if (end != null) {
            end.setState(state);
            end.copyBounds(compoundRect);
            end.setCallback(this);
            dr.mDrawableSizeEnd = compoundRect.width();
            dr.mDrawableHeightEnd = compoundRect.height();
        } else {
            dr.mDrawableSizeEnd = dr.mDrawableHeightEnd = 0;
        }
        if (top != null) {
            top.setState(state);
            top.copyBounds(compoundRect);
            top.setCallback(this);
            dr.mDrawableSizeTop = compoundRect.height();
            dr.mDrawableWidthTop = compoundRect.width();
        } else {
            dr.mDrawableSizeTop = dr.mDrawableWidthTop = 0;
        }
        if (bottom != null) {
            bottom.setState(state);
            bottom.copyBounds(compoundRect);
            bottom.setCallback(this);
            dr.mDrawableSizeBottom = compoundRect.height();
            dr.mDrawableWidthBottom = compoundRect.width();
        } else {
            dr.mDrawableSizeBottom = dr.mDrawableWidthBottom = 0;
        }
    }
    resetResolvedDrawables();
    resolveDrawables();
    invalidate();
    requestLayout();
}
Body of Second Method:
{
    Drawables dr = mDrawables;
    // We're switching to relative, discard absolute.
    if (dr != null) {
        if (dr.mShowing[Drawables.LEFT] != null) {
            dr.mShowing[Drawables.LEFT].setCallback(null);
        }
        dr.mShowing[Drawables.LEFT] = dr.mDrawableLeftInitial = null;
        if (dr.mShowing[Drawables.RIGHT] != null) {
            dr.mShowing[Drawables.RIGHT].setCallback(null);
        }
        dr.mShowing[Drawables.RIGHT] = dr.mDrawableRightInitial = null;
        dr.mDrawableSizeLeft = dr.mDrawableHeightLeft = 0;
        dr.mDrawableSizeRight = dr.mDrawableHeightRight = 0;
    }
    final boolean drawables = start != null || top != null || end != null || bottom != null;
    if (!drawables) {
        // Clearing drawables...  can we free the data structure?
        if (dr != null) {
            if (!dr.hasMetadata()) {
                mDrawables = null;
            } else {
                // out all of the fields in the existing structure.
                if (dr.mDrawableStart != null)
                    dr.mDrawableStart.setCallback(null);
                dr.mDrawableStart = null;
                if (dr.mShowing[Drawables.TOP] != null) {
                    dr.mShowing[Drawables.TOP].setCallback(null);
                }
                dr.mShowing[Drawables.TOP] = null;
                if (dr.mDrawableEnd != null) {
                    dr.mDrawableEnd.setCallback(null);
                }
                dr.mDrawableEnd = null;
                if (dr.mShowing[Drawables.BOTTOM] != null) {
                    dr.mShowing[Drawables.BOTTOM].setCallback(null);
                }
                dr.mShowing[Drawables.BOTTOM] = null;
                dr.mDrawableSizeStart = dr.mDrawableHeightStart = 0;
                dr.mDrawableSizeEnd = dr.mDrawableHeightEnd = 0;
                dr.mDrawableSizeTop = dr.mDrawableWidthTop = 0;
                dr.mDrawableSizeBottom = dr.mDrawableWidthBottom = 0;
            }
        }
    } else {
        if (dr == null) {
            mDrawables = dr = new Drawables(getContext());
        }
        mDrawables.mOverride = true;
        if (dr.mDrawableStart != start && dr.mDrawableStart != null) {
            dr.mDrawableStart.setCallback(null);
        }
        dr.mDrawableStart = start;
        if (dr.mShowing[Drawables.TOP] != top && dr.mShowing[Drawables.TOP] != null) {
            dr.mShowing[Drawables.TOP].setCallback(null);
        }
        dr.mShowing[Drawables.TOP] = top;
        if (dr.mDrawableEnd != end && dr.mDrawableEnd != null) {
            dr.mDrawableEnd.setCallback(null);
        }
        dr.mDrawableEnd = end;
        if (dr.mShowing[Drawables.BOTTOM] != bottom && dr.mShowing[Drawables.BOTTOM] != null) {
            dr.mShowing[Drawables.BOTTOM].setCallback(null);
        }
        dr.mShowing[Drawables.BOTTOM] = bottom;
        final Rect compoundRect = dr.mCompoundRect;
        int[] state;
        state = getDrawableState();
        if (start != null) {
            start.setState(state);
            start.copyBounds(compoundRect);
            start.setCallback(this);
            dr.mDrawableSizeStart = compoundRect.width();
            dr.mDrawableHeightStart = compoundRect.height();
        } else {
            dr.mDrawableSizeStart = dr.mDrawableHeightStart = 0;
        }
        if (end != null) {
            end.setState(state);
            end.copyBounds(compoundRect);
            end.setCallback(this);
            dr.mDrawableSizeEnd = compoundRect.width();
            dr.mDrawableHeightEnd = compoundRect.height();
        } else {
            dr.mDrawableSizeEnd = dr.mDrawableHeightEnd = 0;
        }
        if (top != null) {
            top.setState(state);
            top.copyBounds(compoundRect);
            top.setCallback(this);
            dr.mDrawableSizeTop = compoundRect.height();
            dr.mDrawableWidthTop = compoundRect.width();
        } else {
            dr.mDrawableSizeTop = dr.mDrawableWidthTop = 0;
        }
        if (bottom != null) {
            bottom.setState(state);
            bottom.copyBounds(compoundRect);
            bottom.setCallback(this);
            dr.mDrawableSizeBottom = compoundRect.height();
            dr.mDrawableWidthBottom = compoundRect.width();
        } else {
            dr.mDrawableSizeBottom = dr.mDrawableWidthBottom = 0;
        }
    }
    resetResolvedDrawables();
    resolveDrawables();
    invalidate();
    requestLayout();
}
------------------------
Find a silently evolved API code:android.app.ActivityManager.isUserAMonkey:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns "true" if the user interface is currently being messed with
 * by a monkey.
 */

Body of Frist Method:
{
    try {
        return ActivityManagerNative.getDefault().isUserAMonkey();
    } catch (RemoteException e) {
    }
    return false;
}
Body of Second Method:
{
    try {
        return ActivityManagerNative.getDefault().isUserAMonkey();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.media.midi.MidiManager.createDeviceServer:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    try {
        MidiDeviceServer server = new MidiDeviceServer(mService, inputPortReceivers, numOutputPorts, callback);
        MidiDeviceInfo deviceInfo = mService.registerDeviceServer(server.getBinderInterface(), inputPortReceivers.length, numOutputPorts, inputPortNames, outputPortNames, properties, type);
        if (deviceInfo == null) {
            Log.e(TAG, "registerVirtualDevice failed");
            return null;
        }
        return server;
    } catch (RemoteException e) {
        Log.e(TAG, "RemoteException in createVirtualDevice");
        return null;
    }
}
Body of Second Method:
{
    try {
        MidiDeviceServer server = new MidiDeviceServer(mService, inputPortReceivers, numOutputPorts, callback);
        MidiDeviceInfo deviceInfo = mService.registerDeviceServer(server.getBinderInterface(), inputPortReceivers.length, numOutputPorts, inputPortNames, outputPortNames, properties, type);
        if (deviceInfo == null) {
            Log.e(TAG, "registerVirtualDevice failed");
            return null;
        }
        return server;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.app.backup.BlobBackupHelper.readOldState:COMMENT
Method Modifier: private     hidden      
Comment:/*
     * State on-disk format:
     * [Int]    : overall blob version number
     * [Int=N] : number of keys represented in the state blob
     * N* :
     *     [String] key
     *     [Long]   blob checksum, calculated after compression
     */

Body of Frist Method:
{
    final ArrayMap<String, Long> state = new ArrayMap<String, Long>();
    FileInputStream fis = new FileInputStream(oldStateFd.getFileDescriptor());
    BufferedInputStream bis = new BufferedInputStream(fis);
    DataInputStream in = new DataInputStream(bis);
    try {
        int version = in.readInt();
        if (version <= mCurrentBlobVersion) {
            final int numKeys = in.readInt();
            for (int i = 0; i < numKeys; i++) {
                String key = in.readUTF();
                long checksum = in.readLong();
                state.put(key, checksum);
            }
        } else {
            Log.w(TAG, "Prior state from unrecognized version " + version);
        }
    } catch (EOFException e) {
        // Empty file is expected on first backup,  so carry on. If the state
        // is truncated we just treat it the same way.
        state.clear();
    } catch (Exception e) {
        Log.e(TAG, "Error examining prior backup state " + e.getMessage());
        state.clear();
    }
    return state;
}
Body of Second Method:
{
    final ArrayMap<String, Long> state = new ArrayMap<String, Long>();
    FileInputStream fis = new FileInputStream(oldStateFd.getFileDescriptor());
    DataInputStream in = new DataInputStream(fis);
    try {
        int version = in.readInt();
        if (version <= mCurrentBlobVersion) {
            final int numKeys = in.readInt();
            if (DEBUG) {
                Log.i(TAG, "  " + numKeys + " keys in state record");
            }
            for (int i = 0; i < numKeys; i++) {
                String key = in.readUTF();
                long checksum = in.readLong();
                if (DEBUG) {
                    Log.i(TAG, "  key '" + key + "' checksum is " + checksum);
                }
                state.put(key, checksum);
            }
        } else {
            Log.w(TAG, "Prior state from unrecognized version " + version);
        }
    } catch (EOFException e) {
        // is truncated we just treat it the same way.
        if (DEBUG) {
            Log.i(TAG, "Hit EOF reading prior state");
        }
        state.clear();
    } catch (Exception e) {
        Log.e(TAG, "Error examining prior backup state " + e.getMessage());
        state.clear();
    }
    return state;
}
------------------------
Find a silently evolved API code:android.graphics.Bitmap.copyPixelsToBuffer:COMMENT
Method Modifier: public      
Comment:/**
 * <p>Copy the bitmap's pixels into the specified buffer (allocated by the
 * caller). An exception is thrown if the buffer is not large enough to
 * hold all of the pixels (taking into account the number of bytes per
 * pixel) or if the Buffer subclass is not one of the support types
 * (ByteBuffer, ShortBuffer, IntBuffer).</p>
 * <p>The content of the bitmap is copied into the buffer as-is. This means
 * that if this bitmap stores its pixels pre-multiplied
 * (see {@link #isPremultiplied()}, the values in the buffer will also be
 * pre-multiplied.</p>
 * <p>After this method returns, the current position of the buffer is
 * updated: the position is incremented by the number of elements written
 * in the buffer.</p>
 */

Body of Frist Method:
{
    int elements = dst.remaining();
    int shift;
    if (dst instanceof ByteBuffer) {
        shift = 0;
    } else if (dst instanceof ShortBuffer) {
        shift = 1;
    } else if (dst instanceof IntBuffer) {
        shift = 2;
    } else {
        throw new RuntimeException("unsupported Buffer subclass");
    }
    long bufferSize = (long) elements << shift;
    long pixelSize = getByteCount();
    if (bufferSize < pixelSize) {
        throw new RuntimeException("Buffer not large enough for pixels");
    }
    nativeCopyPixelsToBuffer(mFinalizer.mNativeBitmap, dst);
    // now update the buffer's position
    int position = dst.position();
    position += pixelSize >> shift;
    dst.position(position);
}
Body of Second Method:
{
    int elements = dst.remaining();
    int shift;
    if (dst instanceof ByteBuffer) {
        shift = 0;
    } else if (dst instanceof ShortBuffer) {
        shift = 1;
    } else if (dst instanceof IntBuffer) {
        shift = 2;
    } else {
        throw new RuntimeException("unsupported Buffer subclass");
    }
    long bufferSize = (long) elements << shift;
    long pixelSize = getByteCount();
    if (bufferSize < pixelSize) {
        throw new RuntimeException("Buffer not large enough for pixels");
    }
    nativeCopyPixelsToBuffer(mNativePtr, dst);
    // now update the buffer's position
    int position = dst.position();
    position += pixelSize >> shift;
    dst.position(position);
}
------------------------
Find a silently evolved API code:android.app.AlarmManager.setTimeZone:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the system's persistent default time zone. This is the time zone for all apps, even
 * after a reboot. Use {@link java.util.TimeZone#setDefault} if you just want to change the
 * time zone within your app, and even then prefer to pass an explicit
 * {@link java.util.TimeZone} to APIs that require it rather than changing the time zone for
 * all threads.
 *
 * <p> On android M and above, it is an error to pass in a non-Olson timezone to this
 * function. Note that this is a bad idea on all Android releases because POSIX and
 * the {@code TimeZone} class have opposite interpretations of {@code '+'} and {@code '-'}
 * in the same non-Olson ID.
 *
 * @param timeZone one of the Olson ids from the list returned by
 * {@link java.util.TimeZone#getAvailableIDs}
 */

Body of Frist Method:
{
    if (TextUtils.isEmpty(timeZone)) {
        return;
    }
    // Reject this timezone if it isn't an Olson zone we recognize.
    if (mTargetSdkVersion >= Build.VERSION_CODES.M) {
        boolean hasTimeZone = false;
        try {
            hasTimeZone = ZoneInfoDB.getInstance().hasTimeZone(timeZone);
        } catch (IOException ignored) {
        }
        if (!hasTimeZone) {
            throw new IllegalArgumentException("Timezone: " + timeZone + " is not an Olson ID");
        }
    }
    try {
        mService.setTimeZone(timeZone);
    } catch (RemoteException ex) {
    }
}
Body of Second Method:
{
    if (TextUtils.isEmpty(timeZone)) {
        return;
    }
    // Reject this timezone if it isn't an Olson zone we recognize.
    if (mTargetSdkVersion >= Build.VERSION_CODES.M) {
        boolean hasTimeZone = false;
        try {
            hasTimeZone = ZoneInfoDB.getInstance().hasTimeZone(timeZone);
        } catch (IOException ignored) {
        }
        if (!hasTimeZone) {
            throw new IllegalArgumentException("Timezone: " + timeZone + " is not an Olson ID");
        }
    }
    try {
        mService.setTimeZone(timeZone);
    } catch (RemoteException ex) {
        throw ex.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.content.pm.LauncherApps.resolveActivity:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the activity info for a given intent and user handle, if it resolves. Otherwise it
 * returns null.
 *
 * @param intent The intent to find a match for.
 * @param user The profile to look in for a match.
 * @return An activity info object if there is a match.
 */

Body of Frist Method:
{
    try {
        ResolveInfo ri = mService.resolveActivity(intent, user);
        if (ri != null) {
            long firstInstallTime = 0;
            try {
                firstInstallTime = mPm.getPackageInfo(ri.activityInfo.packageName, PackageManager.GET_UNINSTALLED_PACKAGES).firstInstallTime;
            } catch (NameNotFoundException nnfe) {
            // Sorry, can't find package
            }
            LauncherActivityInfo info = new LauncherActivityInfo(mContext, ri, user, firstInstallTime);
            return info;
        }
    } catch (RemoteException re) {
        throw new RuntimeException("Failed to call LauncherAppsService");
    }
    return null;
}
Body of Second Method:
{
    try {
        ActivityInfo ai = mService.resolveActivity(intent.getComponent(), user);
        if (ai != null) {
            LauncherActivityInfo info = new LauncherActivityInfo(mContext, ai, user);
            return info;
        }
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
    return null;
}
------------------------
Find a silently evolved API code:android.animation.ValueAnimator.setDuration:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the length of the animation. The default duration is 300 milliseconds.
 *
 * @param duration The length of the animation, in milliseconds. This value cannot
 * be negative.
 * @return ValueAnimator The object called with setDuration(). This return
 * value makes it easier to compose statements together that construct and then set the
 * duration, as in <code>ValueAnimator.ofInt(0, 10).setDuration(500).start()</code>.
 */

Body of Frist Method:
{
    if (duration < 0) {
        throw new IllegalArgumentException("Animators cannot have negative duration: " + duration);
    }
    mUnscaledDuration = duration;
    updateScaledDuration();
    return this;
}
Body of Second Method:
{
    if (duration < 0) {
        throw new IllegalArgumentException("Animators cannot have negative duration: " + duration);
    }
    mDuration = duration;
    return this;
}
------------------------
Find a silently evolved API code:android.telephony.TelephonyManager.hasCarrierPrivileges:COMMENT
Method Modifier: public      
Comment:/**
 * Has the calling application been granted carrier privileges by the carrier.
 *
 * If any of the packages in the calling UID has carrier privileges, the
 * call will return true. This access is granted by the owner of the UICC
 * card and does not depend on the registered carrier.
 *
 * @return true if the app has carrier privileges.
 */

Body of Frist Method:
{
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            return telephony.getCarrierPrivilegeStatus() == CARRIER_PRIVILEGE_STATUS_HAS_ACCESS;
    } catch (RemoteException ex) {
        Rlog.e(TAG, "hasCarrierPrivileges RemoteException", ex);
    } catch (NullPointerException ex) {
        Rlog.e(TAG, "hasCarrierPrivileges NPE", ex);
    }
    return false;
}
Body of Second Method:
{
    return hasCarrierPrivileges(getSubId());
}
------------------------
Find a silently evolved API code:android.telephony.SubscriptionManager.getResourcesForSubId:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Returns the resources associated with Subscription.
 * @param context Context object
 * @param subId Subscription Id of Subscription who's resources are required
 * @return Resources associated with Subscription.
 * @hide
 */

Body of Frist Method:
{
    final SubscriptionInfo subInfo = SubscriptionManager.from(context).getActiveSubscriptionInfo(subId);
    Configuration config = context.getResources().getConfiguration();
    Configuration newConfig = new Configuration();
    newConfig.setTo(config);
    if (subInfo != null) {
        newConfig.mcc = subInfo.getMcc();
        newConfig.mnc = subInfo.getMnc();
    }
    DisplayMetrics metrics = context.getResources().getDisplayMetrics();
    DisplayMetrics newMetrics = new DisplayMetrics();
    newMetrics.setTo(metrics);
    return new Resources(context.getResources().getAssets(), newMetrics, newConfig);
}
Body of Second Method:
{
    final SubscriptionInfo subInfo = SubscriptionManager.from(context).getActiveSubscriptionInfo(subId);
    Configuration config = context.getResources().getConfiguration();
    Configuration newConfig = new Configuration();
    newConfig.setTo(config);
    if (subInfo != null) {
        newConfig.mcc = subInfo.getMcc();
        newConfig.mnc = subInfo.getMnc();
        if (newConfig.mnc == 0)
            newConfig.mnc = Configuration.MNC_ZERO;
    }
    DisplayMetrics metrics = context.getResources().getDisplayMetrics();
    DisplayMetrics newMetrics = new DisplayMetrics();
    newMetrics.setTo(metrics);
    return new Resources(context.getResources().getAssets(), newMetrics, newConfig);
}
------------------------
Find a silently evolved API code:android.net.ConnectivityManager.getDefaultNetworkCapabilitiesForUser:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns an array of {@link android.net.NetworkCapabilities} objects, representing
 * the Networks that applications run by the given user will use by default.
 * @hide
 */

Body of Frist Method:
{
    try {
        return mService.getDefaultNetworkCapabilitiesForUser(userId);
    } catch (RemoteException e) {
        return null;
    }
}
Body of Second Method:
{
    try {
        return mService.getDefaultNetworkCapabilitiesForUser(userId);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.text.format.Formatter.formatBytes:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * {@hide}
 */

Body of Frist Method:
{
    float result = sizeBytes;
    int suffix = com.android.internal.R.string.byteShort;
    long mult = 1;
    if (result > 900) {
        suffix = com.android.internal.R.string.kilobyteShort;
        mult = TrafficStats.KB_IN_BYTES;
        result = result / 1024;
    }
    if (result > 900) {
        suffix = com.android.internal.R.string.megabyteShort;
        mult = TrafficStats.MB_IN_BYTES;
        result = result / 1024;
    }
    if (result > 900) {
        suffix = com.android.internal.R.string.gigabyteShort;
        mult = TrafficStats.GB_IN_BYTES;
        result = result / 1024;
    }
    if (result > 900) {
        suffix = com.android.internal.R.string.terabyteShort;
        mult = TrafficStats.TB_IN_BYTES;
        result = result / 1024;
    }
    if (result > 900) {
        suffix = com.android.internal.R.string.petabyteShort;
        mult = TrafficStats.PB_IN_BYTES;
        result = result / 1024;
    }
    // Note we calculate the rounded long by ourselves, but still let String.format()
    // compute the rounded value. String.format("%f", 0.1) might not return "0.1" due to
    // floating point errors.
    final int roundFactor;
    final String roundFormat;
    if (result < 1) {
        roundFactor = 100;
        roundFormat = "%.2f";
    } else if (result < 10) {
        if ((flags & FLAG_SHORTER) != 0) {
            roundFactor = 10;
            roundFormat = "%.1f";
        } else {
            roundFactor = 100;
            roundFormat = "%.2f";
        }
    } else if (result < 100) {
        if ((flags & FLAG_SHORTER) != 0) {
            roundFactor = 1;
            roundFormat = "%.0f";
        } else {
            roundFactor = 100;
            roundFormat = "%.2f";
        }
    } else {
        roundFactor = 1;
        roundFormat = "%.0f";
    }
    final String roundedString = String.format(roundFormat, result);
    // Note this might overflow if result >= Long.MAX_VALUE / 100, but that's like 80PB so
    // it's okay (for now)...
    final long roundedBytes = (flags & FLAG_CALCULATE_ROUNDED) == 0 ? 0 : (((long) Math.round(result * roundFactor)) * mult / roundFactor);
    final String units = res.getString(suffix);
    return new BytesResult(roundedString, units, roundedBytes);
}
Body of Second Method:
{
    final boolean isNegative = (sizeBytes < 0);
    float result = isNegative ? -sizeBytes : sizeBytes;
    int suffix = com.android.internal.R.string.byteShort;
    long mult = 1;
    if (result > 900) {
        suffix = com.android.internal.R.string.kilobyteShort;
        mult = TrafficStats.KB_IN_BYTES;
        result = result / 1024;
    }
    if (result > 900) {
        suffix = com.android.internal.R.string.megabyteShort;
        mult = TrafficStats.MB_IN_BYTES;
        result = result / 1024;
    }
    if (result > 900) {
        suffix = com.android.internal.R.string.gigabyteShort;
        mult = TrafficStats.GB_IN_BYTES;
        result = result / 1024;
    }
    if (result > 900) {
        suffix = com.android.internal.R.string.terabyteShort;
        mult = TrafficStats.TB_IN_BYTES;
        result = result / 1024;
    }
    if (result > 900) {
        suffix = com.android.internal.R.string.petabyteShort;
        mult = TrafficStats.PB_IN_BYTES;
        result = result / 1024;
    }
    // Note we calculate the rounded long by ourselves, but still let String.format()
    // compute the rounded value. String.format("%f", 0.1) might not return "0.1" due to
    // floating point errors.
    final int roundFactor;
    final String roundFormat;
    if (mult == 1 || result >= 100) {
        roundFactor = 1;
        roundFormat = "%.0f";
    } else if (result < 1) {
        roundFactor = 100;
        roundFormat = "%.2f";
    } else if (result < 10) {
        if ((flags & FLAG_SHORTER) != 0) {
            roundFactor = 10;
            roundFormat = "%.1f";
        } else {
            roundFactor = 100;
            roundFormat = "%.2f";
        }
    } else {
        // 10 <= result < 100
        if ((flags & FLAG_SHORTER) != 0) {
            roundFactor = 1;
            roundFormat = "%.0f";
        } else {
            roundFactor = 100;
            roundFormat = "%.2f";
        }
    }
    if (isNegative) {
        result = -result;
    }
    final String roundedString = String.format(roundFormat, result);
    // Note this might overflow if abs(result) >= Long.MAX_VALUE / 100, but that's like 80PB so
    // it's okay (for now)...
    final long roundedBytes = (flags & FLAG_CALCULATE_ROUNDED) == 0 ? 0 : (((long) Math.round(result * roundFactor)) * mult / roundFactor);
    final String units = res.getString(suffix);
    return new BytesResult(roundedString, units, roundedBytes);
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiManager.getPrivilegedConfiguredNetworks:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    try {
        return mService.getPrivilegedConfiguredNetworks();
    } catch (RemoteException e) {
        return null;
    }
}
Body of Second Method:
{
    try {
        return mService.getPrivilegedConfiguredNetworks();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.telephony.SubscriptionManager.allDefaultsSelected:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (!isValidSubscriptionId(getDefaultDataSubId())) {
        return false;
    }
    if (!isValidSubscriptionId(getDefaultSmsSubId())) {
        return false;
    }
    if (!isValidSubscriptionId(getDefaultVoiceSubId())) {
        return false;
    }
    return true;
}
Body of Second Method:
{
    if (!isValidSubscriptionId(getDefaultDataSubscriptionId())) {
        return false;
    }
    if (!isValidSubscriptionId(getDefaultSmsSubscriptionId())) {
        return false;
    }
    if (!isValidSubscriptionId(getDefaultVoiceSubscriptionId())) {
        return false;
    }
    return true;
}
------------------------
Find a silently evolved API code:android.app.ActivityManager.switchUser:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @param userid the user's id. Zero indicates the default user.
 * @hide
 */

Body of Frist Method:
{
    try {
        return ActivityManagerNative.getDefault().switchUser(userid);
    } catch (RemoteException e) {
        return false;
    }
}
Body of Second Method:
{
    try {
        return ActivityManagerNative.getDefault().switchUser(userid);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.animation.ValueAnimator.setCurrentFraction:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the position of the animation to the specified fraction. This fraction should
 * be between 0 and the total fraction of the animation, including any repetition. That is,
 * a fraction of 0 will position the animation at the beginning, a value of 1 at the end,
 * and a value of 2 at the end of a reversing animator that repeats once. If
 * the animation has not yet been started, then it will not advance forward after it is
 * set to this fraction; it will simply set the fraction to this value and perform any
 * appropriate actions based on that fraction. If the animation is already running, then
 * setCurrentFraction() will set the current fraction to this value and continue
 * playing from that point. {@link Animator.AnimatorListener} events are not called
 * due to changing the fraction; those events are only processed while the animation
 * is running.
 *
 * @param fraction The fraction to which the animation is advanced or rewound. Values
 * outside the range of 0 to the maximum fraction for the animator will be clamped to
 * the correct range.
 */

Body of Frist Method:
{
    initAnimation();
    if (fraction < 0) {
        fraction = 0;
    }
    int iteration = (int) fraction;
    if (fraction == 1) {
        iteration -= 1;
    } else if (fraction > 1) {
        if (iteration < (mRepeatCount + 1) || mRepeatCount == INFINITE) {
            if (mRepeatMode == REVERSE) {
                mPlayingBackwards = (iteration % 2) != 0;
            }
            fraction = fraction % 1f;
        } else {
            fraction = 1;
            iteration -= 1;
        }
    } else {
        mPlayingBackwards = mReversing;
    }
    mCurrentIteration = iteration;
    long seekTime = (long) (mDuration * fraction);
    long currentTime = AnimationUtils.currentAnimationTimeMillis();
    mStartTime = currentTime - seekTime;
    // do not allow start time to be compensated for jank
    mStartTimeCommitted = true;
    if (mPlayingState != RUNNING) {
        mSeekFraction = fraction;
        mPlayingState = SEEKED;
    }
    if (mPlayingBackwards) {
        fraction = 1f - fraction;
    }
    animateValue(fraction);
}
Body of Second Method:
{
    initAnimation();
    fraction = clampFraction(fraction);
    long seekTime = (long) (getScaledDuration() * fraction);
    long currentTime = AnimationUtils.currentAnimationTimeMillis();
    mStartTime = currentTime - seekTime;
    // do not allow start time to be compensated for jank
    mStartTimeCommitted = true;
    if (!isPulsingInternal()) {
        // If the animation loop hasn't started, the startTime will be adjusted in the first
        // frame based on seek fraction.
        mSeekFraction = fraction;
    }
    mOverallFraction = fraction;
    final float currentIterationFraction = getCurrentIterationFraction(fraction);
    animateValue(currentIterationFraction);
}
------------------------
Find a silently evolved API code:android.net.ConnectivityManager.isDefaultNetworkActive:COMMENT
Method Modifier: public      
Comment:/**
 * Return whether the data network is currently active.  An active network means that
 * it is currently in a high power state for performing data transmission.  On some
 * types of networks, it may be expensive to move and stay in such a state, so it is
 * more power efficient to batch network traffic together when the radio is already in
 * this state.  This method tells you whether right now is currently a good time to
 * initiate network traffic, as the network is already active.
 */

Body of Frist Method:
{
    try {
        return getNetworkManagementService().isNetworkActive();
    } catch (RemoteException e) {
    }
    return false;
}
Body of Second Method:
{
    try {
        return getNetworkManagementService().isNetworkActive();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.app.Fragment.setRetainInstance:COMMENT
Method Modifier: public      
Comment:/**
 * Control whether a fragment instance is retained across Activity
 * re-creation (such as from a configuration change).  This can only
 * be used with fragments not in the back stack.  If set, the fragment
 * lifecycle will be slightly different when an activity is recreated:
 * <ul>
 * <li> {@link #onDestroy()} will not be called (but {@link #onDetach()} still
 * will be, because the fragment is being detached from its current activity).
 * <li> {@link #onCreate(Bundle)} will not be called since the fragment
 * is not being re-created.
 * <li> {@link #onAttach(Activity)} and {@link #onActivityCreated(Bundle)} <b>will</b>
 * still be called.
 * </ul>
 */

Body of Frist Method:
{
    if (retain && mParentFragment != null) {
        throw new IllegalStateException("Can't retain fragements that are nested in other fragments");
    }
    mRetainInstance = retain;
}
Body of Second Method:
{
    mRetainInstance = retain;
}
------------------------
Find a silently evolved API code:android.widget.TextView.setElegantTextHeight:COMMENT
Method Modifier: public      
Comment:/**
 * Set the TextView's elegant height metrics flag. This setting selects font
 * variants that have not been compacted to fit Latin-based vertical
 * metrics, and also increases top and bottom bounds to provide more space.
 *
 * @param elegant set the paint's elegant metrics flag.
 *
 * @attr ref android.R.styleable#TextView_elegantTextHeight
 */

Body of Frist Method:
{
    mTextPaint.setElegantTextHeight(elegant);
}
Body of Second Method:
{
    if (elegant != mTextPaint.isElegantTextHeight()) {
        mTextPaint.setElegantTextHeight(elegant);
        if (mLayout != null) {
            nullLayouts();
            requestLayout();
            invalidate();
        }
    }
}
------------------------
Find a silently evolved API code:android.net.ConnectivityManager.checkMobileProvisioning:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Check mobile provisioning.
 *
 * @param suggestedTimeOutMs, timeout in milliseconds
 *
 * @return time out that will be used, maybe less that suggestedTimeOutMs
 * -1 if an error.
 *
 * {@hide}
 */

Body of Frist Method:
{
    int timeOutMs = -1;
    try {
        timeOutMs = mService.checkMobileProvisioning(suggestedTimeOutMs);
    } catch (RemoteException e) {
    }
    return timeOutMs;
}
Body of Second Method:
{
    int timeOutMs = -1;
    try {
        timeOutMs = mService.checkMobileProvisioning(suggestedTimeOutMs);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
    return timeOutMs;
}
------------------------
Find a silently evolved API code:android.media.AudioManager.loadSoundEffects:COMMENT
Method Modifier: public      
Comment:/**
 * Load Sound effects.
 * This method must be called when sound effects are enabled.
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        service.loadSoundEffects();
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in loadSoundEffects" + e);
    }
}
Body of Second Method:
{
    IAudioService service = getService();
    try {
        service.loadSoundEffects();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.os.Bundle.hasFileDescriptors:COMMENT
Method Modifier: public      
Comment:/**
 * Reports whether the bundle contains any parcelled file descriptors.
 */

Body of Frist Method:
{
    if (!mFdsKnown) {
        // keep going until we find one or run out of data
        boolean fdFound = false;
        if (mParcelledData != null) {
            if (mParcelledData.hasFileDescriptors()) {
                fdFound = true;
            }
        } else {
            // It's been unparcelled, so we need to walk the map
            for (int i = mMap.size() - 1; i >= 0; i--) {
                Object obj = mMap.valueAt(i);
                if (obj instanceof Parcelable) {
                    if ((((Parcelable) obj).describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0) {
                        fdFound = true;
                        break;
                    }
                } else if (obj instanceof Parcelable[]) {
                    Parcelable[] array = (Parcelable[]) obj;
                    for (int n = array.length - 1; n >= 0; n--) {
                        Parcelable p = array[n];
                        if (p != null && ((p.describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0)) {
                            fdFound = true;
                            break;
                        }
                    }
                } else if (obj instanceof SparseArray) {
                    SparseArray<? extends Parcelable> array = (SparseArray<? extends Parcelable>) obj;
                    for (int n = array.size() - 1; n >= 0; n--) {
                        Parcelable p = array.valueAt(n);
                        if (p != null && (p.describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0) {
                            fdFound = true;
                            break;
                        }
                    }
                } else if (obj instanceof ArrayList) {
                    ArrayList array = (ArrayList) obj;
                    // Parcelables; only look inside for Parcelables
                    if (!array.isEmpty() && (array.get(0) instanceof Parcelable)) {
                        for (int n = array.size() - 1; n >= 0; n--) {
                            Parcelable p = (Parcelable) array.get(n);
                            if (p != null && ((p.describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0)) {
                                fdFound = true;
                                break;
                            }
                        }
                    }
                }
            }
        }
        mHasFds = fdFound;
        mFdsKnown = true;
    }
    return mHasFds;
}
Body of Second Method:
{
    if ((mFlags & FLAG_HAS_FDS_KNOWN) == 0) {
        // keep going until we find one or run out of data
        boolean fdFound = false;
        if (mParcelledData != null) {
            if (mParcelledData.hasFileDescriptors()) {
                fdFound = true;
            }
        } else {
            // It's been unparcelled, so we need to walk the map
            for (int i = mMap.size() - 1; i >= 0; i--) {
                Object obj = mMap.valueAt(i);
                if (obj instanceof Parcelable) {
                    if ((((Parcelable) obj).describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0) {
                        fdFound = true;
                        break;
                    }
                } else if (obj instanceof Parcelable[]) {
                    Parcelable[] array = (Parcelable[]) obj;
                    for (int n = array.length - 1; n >= 0; n--) {
                        Parcelable p = array[n];
                        if (p != null && ((p.describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0)) {
                            fdFound = true;
                            break;
                        }
                    }
                } else if (obj instanceof SparseArray) {
                    SparseArray<? extends Parcelable> array = (SparseArray<? extends Parcelable>) obj;
                    for (int n = array.size() - 1; n >= 0; n--) {
                        Parcelable p = array.valueAt(n);
                        if (p != null && (p.describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0) {
                            fdFound = true;
                            break;
                        }
                    }
                } else if (obj instanceof ArrayList) {
                    ArrayList array = (ArrayList) obj;
                    // Parcelables; only look inside for Parcelables
                    if (!array.isEmpty() && (array.get(0) instanceof Parcelable)) {
                        for (int n = array.size() - 1; n >= 0; n--) {
                            Parcelable p = (Parcelable) array.get(n);
                            if (p != null && ((p.describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0)) {
                                fdFound = true;
                                break;
                            }
                        }
                    }
                }
            }
        }
        if (fdFound) {
            mFlags |= FLAG_HAS_FDS;
        } else {
            mFlags &= ~FLAG_HAS_FDS;
        }
        mFlags |= FLAG_HAS_FDS_KNOWN;
    }
    return (mFlags & FLAG_HAS_FDS) != 0;
}
------------------------
Find a silently evolved API code:android.media.AudioManager.startBluetoothScoVirtualCall:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 * Start bluetooth SCO audio connection in virtual call mode.
 * <p>Requires Permission:
 * {@link android.Manifest.permission#MODIFY_AUDIO_SETTINGS}.
 * <p>Similar to {@link #startBluetoothSco()} with explicit selection of virtual call mode.
 * Telephony and communication applications (VoIP, Video Chat) should preferably select
 * virtual call mode.
 * Applications using voice input for search or commands should first try raw audio connection
 * with {@link #startBluetoothSco()} and fall back to startBluetoothScoVirtualCall() in case of
 * failure.
 * @see #startBluetoothSco()
 * @see #stopBluetoothSco()
 * @see #ACTION_SCO_AUDIO_STATE_UPDATED
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        service.startBluetoothScoVirtualCall(mICallBack);
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in startBluetoothScoVirtualCall", e);
    }
}
Body of Second Method:
{
    IAudioService service = getService();
    try {
        service.startBluetoothScoVirtualCall(mICallBack);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiManager.getEnableAutoJoinWhenAssociated:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get setting for Framework layer autojoin enable status
 * @hide
 */

Body of Frist Method:
{
    try {
        return mService.getEnableAutoJoinWhenAssociated();
    } catch (RemoteException e) {
        return false;
    }
}
Body of Second Method:
{
    try {
        return mService.getEnableAutoJoinWhenAssociated();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.app.admin.DeviceAdminInfo.getPackageName:COMMENT
Method Modifier: public      
Comment:/**
 * Return the .apk package that implements this device admin.
 */

Body of Frist Method:
{
    return mReceiver.activityInfo.packageName;
}
Body of Second Method:
{
    return mActivityInfo.packageName;
}
------------------------
Find a silently evolved API code:android.accounts.AccountManager.peekAuthToken:COMMENT
Method Modifier: public      
Comment:/**
 * Gets an auth token from the AccountManager's cache.  If no auth
 * token is cached for this account, null will be returned -- a new
 * auth token will not be generated, and the server will not be contacted.
 * Intended for use by the authenticator, not directly by applications.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>This method requires the caller to have a signature match with the
 * authenticator that manages the specified account.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * AUTHENTICATE_ACCOUNTS permission and same UID as account's authenticator
 * is needed for those platforms. See docs for this function in API level 22.
 *
 * @param account The account for which an auth token is to be fetched. Cannot be {@code null}.
 * @param authTokenType The type of auth token to fetch. Cannot be {@code null}.
 * @return The cached auth token for this account and type, or null if
 * no auth token is cached or the account does not exist.
 * @see #getAuthToken
 */

Body of Frist Method:
{
    if (account == null)
        throw new IllegalArgumentException("account is null");
    if (authTokenType == null)
        throw new IllegalArgumentException("authTokenType is null");
    try {
        return mService.peekAuthToken(account, authTokenType);
    } catch (RemoteException e) {
        // won't ever happen
        throw new RuntimeException(e);
    }
}
Body of Second Method:
{
    if (account == null)
        throw new IllegalArgumentException("account is null");
    if (authTokenType == null)
        throw new IllegalArgumentException("authTokenType is null");
    try {
        return mService.peekAuthToken(account, authTokenType);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.app.ActivityManager.getLockTaskModeState:COMMENT
Method Modifier: public      
Comment:/**
 * Return the current state of task locking. The three possible outcomes
 * are {@link #LOCK_TASK_MODE_NONE}, {@link #LOCK_TASK_MODE_LOCKED}
 * and {@link #LOCK_TASK_MODE_PINNED}.
 *
 * @see Activity#startLockTask()
 */

Body of Frist Method:
{
    try {
        return ActivityManagerNative.getDefault().getLockTaskModeState();
    } catch (RemoteException e) {
        return ActivityManager.LOCK_TASK_MODE_NONE;
    }
}
Body of Second Method:
{
    try {
        return ActivityManagerNative.getDefault().getLockTaskModeState();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.provider.DocumentsProvider.call:COMMENT
Method Modifier: public      
Comment:/**
 * Implementation is provided by the parent class. Can be overridden to
 * provide additional functionality, but subclasses <em>must</em> always
 * call the superclass. If the superclass returns {@code null}, the subclass
 * may implement custom behavior.
 */

Body of Frist Method:
{
    if (!method.startsWith("android:")) {
        // Ignore non-platform methods
        return super.call(method, arg, extras);
    }
    final Context context = getContext();
    final Uri documentUri = extras.getParcelable(DocumentsContract.EXTRA_URI);
    final String authority = documentUri.getAuthority();
    final String documentId = DocumentsContract.getDocumentId(documentUri);
    if (!mAuthority.equals(authority)) {
        throw new SecurityException("Requested authority " + authority + " doesn't match provider " + mAuthority);
    }
    enforceTree(documentUri);
    final Bundle out = new Bundle();
    try {
        if (METHOD_CREATE_DOCUMENT.equals(method)) {
            enforceWritePermissionInner(documentUri, getCallingPackage(), null);
            final String mimeType = extras.getString(Document.COLUMN_MIME_TYPE);
            final String displayName = extras.getString(Document.COLUMN_DISPLAY_NAME);
            final String newDocumentId = createDocument(documentId, mimeType, displayName);
            // No need to issue new grants here, since caller either has
            // manage permission or a prefix grant. We might generate a
            // tree style URI if that's how they called us.
            final Uri newDocumentUri = buildDocumentUriMaybeUsingTree(documentUri, newDocumentId);
            out.putParcelable(DocumentsContract.EXTRA_URI, newDocumentUri);
        } else if (METHOD_RENAME_DOCUMENT.equals(method)) {
            enforceWritePermissionInner(documentUri, getCallingPackage(), null);
            final String displayName = extras.getString(Document.COLUMN_DISPLAY_NAME);
            final String newDocumentId = renameDocument(documentId, displayName);
            if (newDocumentId != null) {
                final Uri newDocumentUri = buildDocumentUriMaybeUsingTree(documentUri, newDocumentId);
                // narrow grant for the newly renamed document.
                if (!isTreeUri(newDocumentUri)) {
                    final int modeFlags = getCallingOrSelfUriPermissionModeFlags(context, documentUri);
                    context.grantUriPermission(getCallingPackage(), newDocumentUri, modeFlags);
                }
                out.putParcelable(DocumentsContract.EXTRA_URI, newDocumentUri);
                // Original document no longer exists, clean up any grants
                revokeDocumentPermission(documentId);
            }
        } else if (METHOD_DELETE_DOCUMENT.equals(method)) {
            enforceWritePermissionInner(documentUri, getCallingPackage(), null);
            deleteDocument(documentId);
            // Document no longer exists, clean up any grants
            revokeDocumentPermission(documentId);
        } else {
            throw new UnsupportedOperationException("Method not supported " + method);
        }
    } catch (FileNotFoundException e) {
        throw new IllegalStateException("Failed call " + method, e);
    }
    return out;
}
Body of Second Method:
{
    if (!method.startsWith("android:")) {
        // Ignore non-platform methods
        return super.call(method, arg, extras);
    }
    try {
        return callUnchecked(method, arg, extras);
    } catch (FileNotFoundException e) {
        throw new IllegalStateException("Failed call " + method, e);
    }
}
------------------------
Find a silently evolved API code:android.os.Bundle.putParcelableArrayList:COMMENT
Method Modifier: public      
Comment:/**
 * Inserts a List of Parcelable values into the mapping of this Bundle,
 * replacing any existing value for the given key.  Either key or value may
 * be null.
 *
 * @param key a String, or null
 * @param value an ArrayList of Parcelable objects, or null
 */

Body of Frist Method:
{
    unparcel();
    mMap.put(key, value);
    mFdsKnown = false;
}
Body of Second Method:
{
    unparcel();
    mMap.put(key, value);
    mFlags &= ~FLAG_HAS_FDS_KNOWN;
}
------------------------
Find a silently evolved API code:android.app.WallpaperManager.peekDrawable:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the current system wallpaper; if there is no wallpaper set,
 * a null pointer is returned. This is returned as an
 * abstract Drawable that you can install in a View to display whatever
 * wallpaper the user has currently set.
 *
 * @return Returns a Drawable object that will draw the wallpaper or a
 * null pointer if these is none.
 */

Body of Frist Method:
{
    Bitmap bm = sGlobals.peekWallpaperBitmap(mContext, false);
    if (bm != null) {
        Drawable dr = new BitmapDrawable(mContext.getResources(), bm);
        dr.setDither(false);
        return dr;
    }
    return null;
}
Body of Second Method:
{
    Bitmap bm = sGlobals.peekWallpaperBitmap(mContext, false, FLAG_SYSTEM);
    if (bm != null) {
        Drawable dr = new BitmapDrawable(mContext.getResources(), bm);
        dr.setDither(false);
        return dr;
    }
    return null;
}
------------------------
Find a silently evolved API code:android.os.PowerManager.WakeLock.setWorkSource:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the work source associated with the wake lock.
 * <p>
 * The work source is used to determine on behalf of which application
 * the wake lock is being held.  This is useful in the case where a
 * service is performing work on behalf of an application so that the
 * cost of that work can be accounted to the application.
 * </p>
 *
 * @param ws The work source, or null if none.
 */

Body of Frist Method:
{
    synchronized (mToken) {
        if (ws != null && ws.size() == 0) {
            ws = null;
        }
        final boolean changed;
        if (ws == null) {
            changed = mWorkSource != null;
            mWorkSource = null;
        } else if (mWorkSource == null) {
            changed = true;
            mWorkSource = new WorkSource(ws);
        } else {
            changed = mWorkSource.diff(ws);
            if (changed) {
                mWorkSource.set(ws);
            }
        }
        if (changed && mHeld) {
            try {
                mService.updateWakeLockWorkSource(mToken, mWorkSource, mHistoryTag);
            } catch (RemoteException e) {
            }
        }
    }
}
Body of Second Method:
{
    synchronized (mToken) {
        if (ws != null && ws.size() == 0) {
            ws = null;
        }
        final boolean changed;
        if (ws == null) {
            changed = mWorkSource != null;
            mWorkSource = null;
        } else if (mWorkSource == null) {
            changed = true;
            mWorkSource = new WorkSource(ws);
        } else {
            changed = mWorkSource.diff(ws);
            if (changed) {
                mWorkSource.set(ws);
            }
        }
        if (changed && mHeld) {
            try {
                mService.updateWakeLockWorkSource(mToken, mWorkSource, mHistoryTag);
            } catch (RemoteException e) {
                throw e.rethrowFromSystemServer();
            }
        }
    }
}
------------------------
Find a silently evolved API code:android.widget.TextView.setAccessibilitySelection:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (getAccessibilitySelectionStart() == start && getAccessibilitySelectionEnd() == end) {
        return;
    }
    // controllers interact with how selection behaves.
    if (mEditor != null) {
        mEditor.hideCursorAndSpanControllers();
        mEditor.stopTextActionMode();
    }
    CharSequence text = getIterableTextForAccessibility();
    if (Math.min(start, end) >= 0 && Math.max(start, end) <= text.length()) {
        Selection.setSelection((Spannable) text, start, end);
    } else {
        Selection.removeSelection((Spannable) text);
    }
}
Body of Second Method:
{
    if (getAccessibilitySelectionStart() == start && getAccessibilitySelectionEnd() == end) {
        return;
    }
    CharSequence text = getIterableTextForAccessibility();
    if (Math.min(start, end) >= 0 && Math.max(start, end) <= text.length()) {
        Selection.setSelection((Spannable) text, start, end);
    } else {
        Selection.removeSelection((Spannable) text);
    }
    // controllers interact with how selection behaves.
    if (mEditor != null) {
        mEditor.hideCursorAndSpanControllers();
        mEditor.stopTextActionMode();
    }
}
------------------------
Find a silently evolved API code:android.media.AudioManager.isValidRingerMode:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Checks valid ringer mode values.
 *
 * @return true if the ringer mode indicated is valid, false otherwise.
 *
 * @see #setRingerMode(int)
 * @hide
 */

Body of Frist Method:
{
    if (ringerMode < 0 || ringerMode > RINGER_MODE_MAX) {
        return false;
    }
    IAudioService service = getService();
    try {
        return service.isValidRingerMode(ringerMode);
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in isValidRingerMode", e);
        return false;
    }
}
Body of Second Method:
{
    if (ringerMode < 0 || ringerMode > RINGER_MODE_MAX) {
        return false;
    }
    IAudioService service = getService();
    try {
        return service.isValidRingerMode(ringerMode);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.app.BackStackRecord.calculateBackFragments:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Finds the first removed fragment and last added fragments when popping the back stack.
 * If none of the fragments have transitions, then both lists will be empty.
 *
 * @param firstOutFragments The list of first fragments to be removed, keyed on the
 * container ID. This list will be modified by the method.
 * @param lastInFragments The list of last fragments to be added, keyed on the
 * container ID. This list will be modified by the method.
 */

Body of Frist Method:
{
    if (!mManager.mContainer.onHasView()) {
        // nothing to see, so no transitions
        return;
    }
    Op op = mHead;
    while (op != null) {
        switch(op.cmd) {
            case OP_ADD:
                setFirstOut(firstOutFragments, op.fragment);
                break;
            case OP_REPLACE:
                if (op.removed != null) {
                    for (int i = op.removed.size() - 1; i >= 0; i--) {
                        setLastIn(lastInFragments, op.removed.get(i));
                    }
                }
                setFirstOut(firstOutFragments, op.fragment);
                break;
            case OP_REMOVE:
                setLastIn(lastInFragments, op.fragment);
                break;
            case OP_HIDE:
                setLastIn(lastInFragments, op.fragment);
                break;
            case OP_SHOW:
                setFirstOut(firstOutFragments, op.fragment);
                break;
            case OP_DETACH:
                setLastIn(lastInFragments, op.fragment);
                break;
            case OP_ATTACH:
                setFirstOut(firstOutFragments, op.fragment);
                break;
        }
        op = op.next;
    }
}
Body of Second Method:
{
    if (!mManager.mContainer.onHasView()) {
        // nothing to see, so no transitions
        return;
    }
    Op op = mTail;
    while (op != null) {
        switch(op.cmd) {
            case OP_ADD:
                setFirstOut(firstOutFragments, lastInFragments, op.fragment);
                break;
            case OP_REPLACE:
                if (op.removed != null) {
                    for (int i = op.removed.size() - 1; i >= 0; i--) {
                        setLastIn(firstOutFragments, lastInFragments, op.removed.get(i));
                    }
                }
                setFirstOut(firstOutFragments, lastInFragments, op.fragment);
                break;
            case OP_REMOVE:
                setLastIn(firstOutFragments, lastInFragments, op.fragment);
                break;
            case OP_HIDE:
                setLastIn(firstOutFragments, lastInFragments, op.fragment);
                break;
            case OP_SHOW:
                setFirstOut(firstOutFragments, lastInFragments, op.fragment);
                break;
            case OP_DETACH:
                setLastIn(firstOutFragments, lastInFragments, op.fragment);
                break;
            case OP_ATTACH:
                setFirstOut(firstOutFragments, lastInFragments, op.fragment);
                break;
        }
        op = op.prev;
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothAdapter.startDiscovery:COMMENT
Method Modifier: public      
Comment:/**
 * Start the remote device discovery process.
 * <p>The discovery process usually involves an inquiry scan of about 12
 * seconds, followed by a page scan of each new device to retrieve its
 * Bluetooth name.
 * <p>This is an asynchronous call, it will return immediately. Register
 * for {@link #ACTION_DISCOVERY_STARTED} and {@link
 * #ACTION_DISCOVERY_FINISHED} intents to determine exactly when the
 * discovery starts and completes. Register for {@link
 * BluetoothDevice#ACTION_FOUND} to be notified as remote Bluetooth devices
 * are found.
 * <p>Device discovery is a heavyweight procedure. New connections to
 * remote Bluetooth devices should not be attempted while discovery is in
 * progress, and existing connections will experience limited bandwidth
 * and high latency. Use {@link #cancelDiscovery()} to cancel an ongoing
 * discovery. Discovery is not managed by the Activity,
 * but is run as a system service, so an application should always call
 * {@link BluetoothAdapter#cancelDiscovery()} even if it
 * did not directly request a discovery, just to be sure.
 * <p>Device discovery will only find remote devices that are currently
 * <i>discoverable</i> (inquiry scan enabled). Many Bluetooth devices are
 * not discoverable by default, and need to be entered into a special mode.
 * <p>If Bluetooth state is not {@link #STATE_ON}, this API
 * will return false. After turning on Bluetooth,
 * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}
 * to get the updated value.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}.
 *
 * @return true on success, false on error
 */

Body of Frist Method:
{
    if (getState() != STATE_ON)
        return false;
    try {
        synchronized (mManagerCallback) {
            if (mService != null)
                return mService.startDiscovery();
        }
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
Body of Second Method:
{
    if (getState() != STATE_ON)
        return false;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.startDiscovery();
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}
------------------------
Find a silently evolved API code:android.os.SystemClock_Delegate.uptimeMillis:COMMENT
Method Modifier: default     static      
Comment:/**
 * Returns milliseconds since boot, not counting time spent in deep sleep.
 * <b>Note:</b> This value may get reset occasionally (before it would
 * otherwise wrap around).
 *
 * @return milliseconds of non-sleep uptime since boot.
 */

Body of Frist Method:
{
    return System.currentTimeMillis() - sBootTime;
}
Body of Second Method:
{
    return System_Delegate.currentTimeMillis() - System_Delegate.bootTimeMillis();
}
------------------------
Find a silently evolved API code:android.util.Pair.equals:COMMENT
Method Modifier: public      
Comment:/**
 * Checks the two objects for equality by delegating to their respective
 * {@link Object#equals(Object)} methods.
 *
 * @param o the {@link Pair} to which this one is to be checked for equality
 * @return true if the underlying objects of the Pair are both considered
 * equal
 */

Body of Frist Method:
{
    if (!(o instanceof Pair)) {
        return false;
    }
    Pair<?, ?> p = (Pair<?, ?>) o;
    return Objects.equal(p.first, first) && Objects.equal(p.second, second);
}
Body of Second Method:
{
    if (!(o instanceof Pair)) {
        return false;
    }
    Pair<?, ?> p = (Pair<?, ?>) o;
    return Objects.equals(p.first, first) && Objects.equals(p.second, second);
}
------------------------
Find a silently evolved API code:android.service.persistentdata.PersistentDataBlockManager.read:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns the data block stored on the persistent partition.
 */

Body of Frist Method:
{
    try {
        return sService.read();
    } catch (RemoteException e) {
        onError("reading data");
        return null;
    }
}
Body of Second Method:
{
    try {
        return sService.read();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.app.WallpaperManager.getDesiredMinimumHeight:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the desired minimum height for the wallpaper. Callers of
 * {@link #setBitmap(android.graphics.Bitmap)} or
 * {@link #setStream(java.io.InputStream)} should check this value
 * beforehand to make sure the supplied wallpaper respects the desired
 * minimum height.
 *
 * If the returned value is <= 0, the caller should use the height of
 * the default display instead.
 *
 * @return The desired minimum height for the wallpaper. This value should
 * be honored by applications that set the wallpaper but it is not
 * mandatory.
 */

Body of Frist Method:
{
    if (sGlobals.mService == null) {
        Log.w(TAG, "WallpaperService not running");
        return 0;
    }
    try {
        return sGlobals.mService.getHeightHint();
    } catch (RemoteException e) {
        // Shouldn't happen!
        return 0;
    }
}
Body of Second Method:
{
    if (sGlobals.mService == null) {
        Log.w(TAG, "WallpaperService not running");
        throw new RuntimeException(new DeadSystemException());
    }
    try {
        return sGlobals.mService.getHeightHint();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.app.Activity.recreate:COMMENT
Method Modifier: public      
Comment:/**
 * Cause this Activity to be recreated with a new instance.  This results
 * in essentially the same flow as when the Activity is created due to
 * a configuration change -- the current instance will go through its
 * lifecycle to {@link #onDestroy} and a new instance then created after it.
 */

Body of Frist Method:
{
    if (mParent != null) {
        throw new IllegalStateException("Can only be called on top-level activity");
    }
    if (Looper.myLooper() != mMainThread.getLooper()) {
        throw new IllegalStateException("Must be called from main thread");
    }
    mMainThread.requestRelaunchActivity(mToken, null, null, 0, false, null, null, false);
}
Body of Second Method:
{
    if (mParent != null) {
        throw new IllegalStateException("Can only be called on top-level activity");
    }
    if (Looper.myLooper() != mMainThread.getLooper()) {
        throw new IllegalStateException("Must be called from main thread");
    }
    mMainThread.requestRelaunchActivity(mToken, null, null, 0, false, null, null, false, false);
}
------------------------
Find a silently evolved API code:android.widget.TextView.onPreDraw:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (mLayout == null) {
        assumeLayout();
    }
    if (mMovement != null) {
        /* This code also provides auto-scrolling when a cursor is moved using a
             * CursorController (insertion point or selection limits).
             * For selection, ensure start or end is visible depending on controller's state.
             */
        int curs = getSelectionEnd();
        // Do not create the controller if it is not already created.
        if (mEditor != null && mEditor.mSelectionModifierCursorController != null && mEditor.mSelectionModifierCursorController.isSelectionStartDragged()) {
            curs = getSelectionStart();
        }
        /*
             * TODO: This should really only keep the end in view if
             * it already was before the text changed.  I'm not sure
             * of a good way to tell from here if it was.
             */
        if (curs < 0 && (mGravity & Gravity.VERTICAL_GRAVITY_MASK) == Gravity.BOTTOM) {
            curs = mText.length();
        }
        if (curs >= 0) {
            bringPointIntoView(curs);
        }
    } else {
        bringTextIntoView();
    }
    // a screen rotation) since layout is not yet initialized at that point.
    if (mEditor != null && mEditor.mCreatedWithASelection) {
        if (mEditor.extractedTextModeWillBeStarted()) {
            mEditor.checkFieldAndSelectCurrentWord();
        } else {
            mEditor.startSelectionActionMode();
        }
        mEditor.mCreatedWithASelection = false;
    }
    // not be set. Do the test here instead.
    if (isInExtractedMode() && hasSelection() && mEditor != null && mEditor.mTextActionMode == null && isShown() && hasWindowFocus()) {
        mEditor.startSelectionActionMode();
    }
    unregisterForPreDraw();
    return true;
}
Body of Second Method:
{
    if (mLayout == null) {
        assumeLayout();
    }
    if (mMovement != null) {
        /* This code also provides auto-scrolling when a cursor is moved using a
             * CursorController (insertion point or selection limits).
             * For selection, ensure start or end is visible depending on controller's state.
             */
        int curs = getSelectionEnd();
        // Do not create the controller if it is not already created.
        if (mEditor != null && mEditor.mSelectionModifierCursorController != null && mEditor.mSelectionModifierCursorController.isSelectionStartDragged()) {
            curs = getSelectionStart();
        }
        /*
             * TODO: This should really only keep the end in view if
             * it already was before the text changed.  I'm not sure
             * of a good way to tell from here if it was.
             */
        if (curs < 0 && (mGravity & Gravity.VERTICAL_GRAVITY_MASK) == Gravity.BOTTOM) {
            curs = mText.length();
        }
        if (curs >= 0) {
            bringPointIntoView(curs);
        }
    } else {
        bringTextIntoView();
    }
    // a screen rotation) since layout is not yet initialized at that point.
    if (mEditor != null && mEditor.mCreatedWithASelection) {
        mEditor.refreshTextActionMode();
        mEditor.mCreatedWithASelection = false;
    }
    unregisterForPreDraw();
    return true;
}
------------------------
Find a silently evolved API code:android.hardware.SerialManager.getSerialPorts:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns a string array containing the names of available serial ports
 *
 * @return names of available serial ports
 */

Body of Frist Method:
{
    try {
        return mService.getSerialPorts();
    } catch (RemoteException e) {
        Log.e(TAG, "RemoteException in getSerialPorts", e);
        return null;
    }
}
Body of Second Method:
{
    try {
        return mService.getSerialPorts();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.os.DropBoxManager.getNextEntry:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the next entry from the drop box <em>after</em> the specified time.
 * Requires <code>android.permission.READ_LOGS</code>.  You must always call
 * {@link Entry#close()} on the return value!
 *
 * @param tag of entry to look for, null for all tags
 * @param msec time of the last entry seen
 * @return the next entry, or null if there are no more entries
 */

Body of Frist Method:
{
    try {
        return mService.getNextEntry(tag, msec);
    } catch (RemoteException e) {
        return null;
    }
}
Body of Second Method:
{
    try {
        return mService.getNextEntry(tag, msec);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.graphics.Bitmap.eraseColor:COMMENT
Method Modifier: public      
Comment:/**
 * Fills the bitmap's pixels with the specified {@link Color}.
 *
 * @throws IllegalStateException if the bitmap is not mutable.
 */

Body of Frist Method:
{
    checkRecycled("Can't erase a recycled bitmap");
    if (!isMutable()) {
        throw new IllegalStateException("cannot erase immutable bitmaps");
    }
    nativeErase(mFinalizer.mNativeBitmap, c);
}
Body of Second Method:
{
    checkRecycled("Can't erase a recycled bitmap");
    if (!isMutable()) {
        throw new IllegalStateException("cannot erase immutable bitmaps");
    }
    nativeErase(mNativePtr, c);
}
------------------------
Find a silently evolved API code:android.accounts.AccountManager.confirmCredentialsAsUser:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 * Same as {@link #confirmCredentials(Account, Bundle, Activity, AccountManagerCallback, Handler)}
 * but for the specified user.
 */

Body of Frist Method:
{
    if (account == null)
        throw new IllegalArgumentException("account is null");
    final int userId = userHandle.getIdentifier();
    return new AmsTask(activity, handler, callback) {

        public void doWork() throws RemoteException {
            mService.confirmCredentialsAsUser(mResponse, account, options, activity != null, userId);
        }
    }.start();
}
Body of Second Method:
{
    if (account == null)
        throw new IllegalArgumentException("account is null");
    final int userId = userHandle.getIdentifier();
    return new AmsTask(activity, handler, callback) {

        @Override
        public void doWork() throws RemoteException {
            mService.confirmCredentialsAsUser(mResponse, account, options, activity != null, userId);
        }
    }.start();
}
------------------------
Find a silently evolved API code:android.app.Activity.getReferrer:COMMENT
Method Modifier: public      
Comment:/**
 * Return information about who launched this activity.  If the launching Intent
 * contains an {@link android.content.Intent#EXTRA_REFERRER Intent.EXTRA_REFERRER},
 * that will be returned as-is; otherwise, if known, an
 * {@link Intent#URI_ANDROID_APP_SCHEME android-app:} referrer URI containing the
 * package name that started the Intent will be returned.  This may return null if no
 * referrer can be identified -- it is neither explicitly specified, nor is it known which
 * application package was involved.
 *
 * <p>If called while inside the handling of {@link #onNewIntent}, this function will
 * return the referrer that submitted that new intent to the activity.  Otherwise, it
 * always returns the referrer of the original Intent.</p>
 *
 * <p>Note that this is <em>not</em> a security feature -- you can not trust the
 * referrer information, applications can spoof it.</p>
 */

Body of Frist Method:
{
    Intent intent = getIntent();
    Uri referrer = intent.getParcelableExtra(Intent.EXTRA_REFERRER);
    if (referrer != null) {
        return referrer;
    }
    String referrerName = intent.getStringExtra(Intent.EXTRA_REFERRER_NAME);
    if (referrerName != null) {
        return Uri.parse(referrerName);
    }
    if (mReferrer != null) {
        return new Uri.Builder().scheme("android-app").authority(mReferrer).build();
    }
    return null;
}
Body of Second Method:
{
    Intent intent = getIntent();
    try {
        Uri referrer = intent.getParcelableExtra(Intent.EXTRA_REFERRER);
        if (referrer != null) {
            return referrer;
        }
        String referrerName = intent.getStringExtra(Intent.EXTRA_REFERRER_NAME);
        if (referrerName != null) {
            return Uri.parse(referrerName);
        }
    } catch (BadParcelableException e) {
        Log.w(TAG, "Cannot read referrer from intent;" + " intent extras contain unknown custom Parcelable objects");
    }
    if (mReferrer != null) {
        return new Uri.Builder().scheme("android-app").authority(mReferrer).build();
    }
    return null;
}
------------------------
Find a silently evolved API code:android.app.ActivityManager.AppTask.setExcludeFromRecents:COMMENT
Method Modifier: public      
Comment:/**
 * Modify the {@link Intent#FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS} flag in the root
 * Intent of this AppTask.
 *
 * @param exclude If true, {@link Intent#FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS} will
 * be set; otherwise, it will be cleared.
 */

Body of Frist Method:
{
    try {
        mAppTaskImpl.setExcludeFromRecents(exclude);
    } catch (RemoteException e) {
        Slog.e(TAG, "Invalid AppTask", e);
    }
}
Body of Second Method:
{
    try {
        mAppTaskImpl.setExcludeFromRecents(exclude);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.widget.ListPopupWindow.show:COMMENT
Method Modifier: public      
Comment:/**
 * Show the popup list. If the list is already showing, this method
 * will recalculate the popup's size and position.
 */

Body of Frist Method:
{
    int height = buildDropDown();
    final boolean noInputMethod = isInputMethodNotNeeded();
    mPopup.setAllowScrollingAnchorParent(!noInputMethod);
    mPopup.setWindowLayoutType(mDropDownWindowLayoutType);
    if (mPopup.isShowing()) {
        final int widthSpec;
        if (mDropDownWidth == ViewGroup.LayoutParams.MATCH_PARENT) {
            // The call to PopupWindow's update method below can accept -1 for any
            // value you do not want to update.
            widthSpec = -1;
        } else if (mDropDownWidth == ViewGroup.LayoutParams.WRAP_CONTENT) {
            widthSpec = getAnchorView().getWidth();
        } else {
            widthSpec = mDropDownWidth;
        }
        final int heightSpec;
        if (mDropDownHeight == ViewGroup.LayoutParams.MATCH_PARENT) {
            // The call to PopupWindow's update method below can accept -1 for any
            // value you do not want to update.
            heightSpec = noInputMethod ? height : ViewGroup.LayoutParams.MATCH_PARENT;
            if (noInputMethod) {
                mPopup.setWidth(mDropDownWidth == ViewGroup.LayoutParams.MATCH_PARENT ? ViewGroup.LayoutParams.MATCH_PARENT : 0);
                mPopup.setHeight(0);
            } else {
                mPopup.setWidth(mDropDownWidth == ViewGroup.LayoutParams.MATCH_PARENT ? ViewGroup.LayoutParams.MATCH_PARENT : 0);
                mPopup.setHeight(ViewGroup.LayoutParams.MATCH_PARENT);
            }
        } else if (mDropDownHeight == ViewGroup.LayoutParams.WRAP_CONTENT) {
            heightSpec = height;
        } else {
            heightSpec = mDropDownHeight;
        }
        mPopup.setOutsideTouchable(!mForceIgnoreOutsideTouch && !mDropDownAlwaysVisible);
        mPopup.update(getAnchorView(), mDropDownHorizontalOffset, mDropDownVerticalOffset, (widthSpec < 0) ? -1 : widthSpec, (heightSpec < 0) ? -1 : heightSpec);
    } else {
        final int widthSpec;
        if (mDropDownWidth == ViewGroup.LayoutParams.MATCH_PARENT) {
            widthSpec = ViewGroup.LayoutParams.MATCH_PARENT;
        } else {
            if (mDropDownWidth == ViewGroup.LayoutParams.WRAP_CONTENT) {
                widthSpec = getAnchorView().getWidth();
            } else {
                widthSpec = mDropDownWidth;
            }
        }
        final int heightSpec;
        if (mDropDownHeight == ViewGroup.LayoutParams.MATCH_PARENT) {
            heightSpec = ViewGroup.LayoutParams.MATCH_PARENT;
        } else {
            if (mDropDownHeight == ViewGroup.LayoutParams.WRAP_CONTENT) {
                heightSpec = height;
            } else {
                heightSpec = mDropDownHeight;
            }
        }
        mPopup.setWidth(widthSpec);
        mPopup.setHeight(heightSpec);
        mPopup.setClipToScreenEnabled(true);
        // use outside touchable to dismiss drop down when touching outside of it, so
        // only set this if the dropdown is not always visible
        mPopup.setOutsideTouchable(!mForceIgnoreOutsideTouch && !mDropDownAlwaysVisible);
        mPopup.setTouchInterceptor(mTouchInterceptor);
        mPopup.showAsDropDown(getAnchorView(), mDropDownHorizontalOffset, mDropDownVerticalOffset, mDropDownGravity);
        mDropDownList.setSelection(ListView.INVALID_POSITION);
        if (!mModal || mDropDownList.isInTouchMode()) {
            clearListSelection();
        }
        if (!mModal) {
            mHandler.post(mHideSelector);
        }
    }
}
Body of Second Method:
{
    int height = buildDropDown();
    final boolean noInputMethod = isInputMethodNotNeeded();
    mPopup.setAllowScrollingAnchorParent(!noInputMethod);
    mPopup.setWindowLayoutType(mDropDownWindowLayoutType);
    if (mPopup.isShowing()) {
        final int widthSpec;
        if (mDropDownWidth == ViewGroup.LayoutParams.MATCH_PARENT) {
            // The call to PopupWindow's update method below can accept -1 for any
            // value you do not want to update.
            widthSpec = -1;
        } else if (mDropDownWidth == ViewGroup.LayoutParams.WRAP_CONTENT) {
            widthSpec = getAnchorView().getWidth();
        } else {
            widthSpec = mDropDownWidth;
        }
        final int heightSpec;
        if (mDropDownHeight == ViewGroup.LayoutParams.MATCH_PARENT) {
            // The call to PopupWindow's update method below can accept -1 for any
            // value you do not want to update.
            heightSpec = noInputMethod ? height : ViewGroup.LayoutParams.MATCH_PARENT;
            if (noInputMethod) {
                mPopup.setWidth(mDropDownWidth == ViewGroup.LayoutParams.MATCH_PARENT ? ViewGroup.LayoutParams.MATCH_PARENT : 0);
                mPopup.setHeight(0);
            } else {
                mPopup.setWidth(mDropDownWidth == ViewGroup.LayoutParams.MATCH_PARENT ? ViewGroup.LayoutParams.MATCH_PARENT : 0);
                mPopup.setHeight(ViewGroup.LayoutParams.MATCH_PARENT);
            }
        } else if (mDropDownHeight == ViewGroup.LayoutParams.WRAP_CONTENT) {
            heightSpec = height;
        } else {
            heightSpec = mDropDownHeight;
        }
        mPopup.setOutsideTouchable(!mForceIgnoreOutsideTouch && !mDropDownAlwaysVisible);
        mPopup.update(getAnchorView(), mDropDownHorizontalOffset, mDropDownVerticalOffset, (widthSpec < 0) ? -1 : widthSpec, (heightSpec < 0) ? -1 : heightSpec);
    } else {
        final int widthSpec;
        if (mDropDownWidth == ViewGroup.LayoutParams.MATCH_PARENT) {
            widthSpec = ViewGroup.LayoutParams.MATCH_PARENT;
        } else {
            if (mDropDownWidth == ViewGroup.LayoutParams.WRAP_CONTENT) {
                widthSpec = getAnchorView().getWidth();
            } else {
                widthSpec = mDropDownWidth;
            }
        }
        final int heightSpec;
        if (mDropDownHeight == ViewGroup.LayoutParams.MATCH_PARENT) {
            heightSpec = ViewGroup.LayoutParams.MATCH_PARENT;
        } else {
            if (mDropDownHeight == ViewGroup.LayoutParams.WRAP_CONTENT) {
                heightSpec = height;
            } else {
                heightSpec = mDropDownHeight;
            }
        }
        mPopup.setWidth(widthSpec);
        mPopup.setHeight(heightSpec);
        mPopup.setClipToScreenEnabled(true);
        // use outside touchable to dismiss drop down when touching outside of it, so
        // only set this if the dropdown is not always visible
        mPopup.setOutsideTouchable(!mForceIgnoreOutsideTouch && !mDropDownAlwaysVisible);
        mPopup.setTouchInterceptor(mTouchInterceptor);
        mPopup.setEpicenterBounds(mEpicenterBounds);
        mPopup.showAsDropDown(getAnchorView(), mDropDownHorizontalOffset, mDropDownVerticalOffset, mDropDownGravity);
        mDropDownList.setSelection(ListView.INVALID_POSITION);
        if (!mModal || mDropDownList.isInTouchMode()) {
            clearListSelection();
        }
        if (!mModal) {
            mHandler.post(mHideSelector);
        }
    }
}
------------------------
Find a silently evolved API code:android.mtp.MtpObjectInfo.getThumbPixHeight:COMMENT
Method Modifier: public      final       
Comment:/**
 * Returns the height of the MTP object's thumbnail in pixels
 * Will be zero for objects with no thumbnail
 *
 * @return the thumbnail height
 */

Body of Frist Method:
{
    return mThumbPixHeight;
}
Body of Second Method:
{
    Preconditions.checkState(mThumbPixHeight >= 0);
    return mThumbPixHeight;
}
------------------------
Find a silently evolved API code:android.renderscript.Allocation.ioReceive:COMMENT
Method Modifier: public      
Comment:/**
 * Receive the latest input into the Allocation. This operation
 * is only valid if {@link #USAGE_IO_INPUT} is set on the Allocation.
 */

Body of Frist Method:
{
    try {
        Trace.traceBegin(RenderScript.TRACE_TAG, "ioReceive");
        if ((mUsage & USAGE_IO_INPUT) == 0) {
            throw new RSIllegalArgumentException("Can only receive if IO_INPUT usage specified.");
        }
        mRS.validate();
        mRS.nAllocationIoReceive(getID(mRS));
    } finally {
        Trace.traceEnd(RenderScript.TRACE_TAG);
    }
}
Body of Second Method:
{
    try {
        Trace.traceBegin(RenderScript.TRACE_TAG, "ioReceive");
        if ((mUsage & USAGE_IO_INPUT) == 0) {
            throw new RSIllegalArgumentException("Can only receive if IO_INPUT usage specified.");
        }
        mRS.validate();
        mTimeStamp = mRS.nAllocationIoReceive(getID(mRS));
    } finally {
        Trace.traceEnd(RenderScript.TRACE_TAG);
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiEnterpriseConfig.setCaCertificate:COMMENT
Method Modifier: public      
Comment:/**
 * Specify a X.509 certificate that identifies the server.
 *
 * <p>A default name is automatically assigned to the certificate and used
 * with this configuration. The framework takes care of installing the
 * certificate when the config is saved and removing the certificate when
 * the config is removed.
 *
 * @param cert X.509 CA certificate
 * @throws IllegalArgumentException if not a CA certificate
 */

Body of Frist Method:
{
    if (cert != null) {
        if (cert.getBasicConstraints() >= 0) {
            mCaCert = cert;
        } else {
            throw new IllegalArgumentException("Not a CA certificate");
        }
    } else {
        mCaCert = null;
    }
}
Body of Second Method:
{
    if (cert != null) {
        if (cert.getBasicConstraints() >= 0) {
            mCaCerts = new X509Certificate[] { cert };
        } else {
            throw new IllegalArgumentException("Not a CA certificate");
        }
    } else {
        mCaCerts = null;
    }
}
------------------------
Find a silently evolved API code:android.app.Instrumentation.finish:COMMENT
Method Modifier: public      
Comment:/**
 * Terminate instrumentation of the application.  This will cause the
 * application process to exit, removing this instrumentation from the next
 * time the application is started.
 *
 * @param resultCode Overall success/failure of instrumentation.
 * @param results Any results to send back to the code that started the
 * instrumentation.
 */

Body of Frist Method:
{
    if (mAutomaticPerformanceSnapshots) {
        endPerformanceSnapshot();
    }
    if (mPerfMetrics != null) {
        if (results == null) {
            results = new Bundle();
        }
        results.putAll(mPerfMetrics);
    }
    if (mUiAutomation != null) {
        mUiAutomation.disconnect();
        mUiAutomation = null;
    }
    mThread.finishInstrumentation(resultCode, results);
}
Body of Second Method:
{
    if (mAutomaticPerformanceSnapshots) {
        endPerformanceSnapshot();
    }
    if (mPerfMetrics != null) {
        if (results == null) {
            results = new Bundle();
        }
        results.putAll(mPerfMetrics);
    }
    if ((mUiAutomation != null) && !mUiAutomation.isDestroyed()) {
        mUiAutomation.disconnect();
        mUiAutomation = null;
    }
    mThread.finishInstrumentation(resultCode, results);
}
------------------------
Find a silently evolved API code:android.app.StatusBarManager.collapsePanels:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Collapse the notifications and settings panels.
 */

Body of Frist Method:
{
    try {
        final IStatusBarService svc = getService();
        if (svc != null) {
            svc.collapsePanels();
        }
    } catch (RemoteException ex) {
        // system process is dead anyway.
        throw new RuntimeException(ex);
    }
}
Body of Second Method:
{
    try {
        final IStatusBarService svc = getService();
        if (svc != null) {
            svc.collapsePanels();
        }
    } catch (RemoteException ex) {
        throw ex.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.os.StrictMode.conditionallyCheckInstanceCounts:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    VmPolicy policy = getVmPolicy();
    if (policy.classInstanceLimit.size() == 0) {
        return;
    }
    System.gc();
    System.runFinalization();
    System.gc();
    // Note: classInstanceLimit is immutable, so this is lock-free
    for (Map.Entry<Class, Integer> entry : policy.classInstanceLimit.entrySet()) {
        Class klass = entry.getKey();
        int limit = entry.getValue();
        long instances = VMDebug.countInstancesOfClass(klass, false);
        if (instances <= limit) {
            continue;
        }
        Throwable tr = new InstanceCountViolation(klass, instances, limit);
        onVmPolicyViolation(tr.getMessage(), tr);
    }
}
Body of Second Method:
{
    VmPolicy policy = getVmPolicy();
    int policySize = policy.classInstanceLimit.size();
    if (policySize == 0) {
        return;
    }
    System.gc();
    System.runFinalization();
    System.gc();
    // Note: classInstanceLimit is immutable, so this is lock-free
    // Create the classes array.
    Class[] classes = policy.classInstanceLimit.keySet().toArray(new Class[policySize]);
    long[] instanceCounts = VMDebug.countInstancesOfClasses(classes, false);
    for (int i = 0; i < classes.length; ++i) {
        Class klass = classes[i];
        int limit = policy.classInstanceLimit.get(klass);
        long instances = instanceCounts[i];
        if (instances > limit) {
            Throwable tr = new InstanceCountViolation(klass, instances, limit);
            onVmPolicyViolation(tr.getMessage(), tr);
        }
    }
}
------------------------
Find a silently evolved API code:android.os.PowerManager.isWakeLockLevelSupported:COMMENT
Method Modifier: public      
Comment:/**
 * Returns true if the specified wake lock level is supported.
 *
 * @param level The wake lock level to check.
 * @return True if the specified wake lock level is supported.
 */

Body of Frist Method:
{
    try {
        return mService.isWakeLockLevelSupported(level);
    } catch (RemoteException e) {
        return false;
    }
}
Body of Second Method:
{
    try {
        return mService.isWakeLockLevelSupported(level);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiManager.isDualBandSupported:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Check if the chipset supports dual frequency band (2.4 GHz and 5 GHz)
 * @return {@code true} if supported, {@code false} otherwise.
 * @hide
 */

Body of Frist Method:
{
    try {
        return mService.isDualBandSupported();
    } catch (RemoteException e) {
        return false;
    }
}
Body of Second Method:
{
    try {
        return mService.isDualBandSupported();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.graphics.Bitmap.compress:COMMENT
Method Modifier: public      
Comment:/**
 * Write a compressed version of the bitmap to the specified outputstream.
 * If this returns true, the bitmap can be reconstructed by passing a
 * corresponding inputstream to BitmapFactory.decodeStream(). Note: not
 * all Formats support all bitmap configs directly, so it is possible that
 * the returned bitmap from BitmapFactory could be in a different bitdepth,
 * and/or may have lost per-pixel alpha (e.g. JPEG only supports opaque
 * pixels).
 *
 * @param format   The format of the compressed image
 * @param quality  Hint to the compressor, 0-100. 0 meaning compress for
 * small size, 100 meaning compress for max quality. Some
 * formats, like PNG which is lossless, will ignore the
 * quality setting
 * @param stream   The outputstream to write the compressed data.
 * @return true if successfully compressed to the specified stream.
 */

Body of Frist Method:
{
    checkRecycled("Can't compress a recycled bitmap");
    // do explicit check before calling the native method
    if (stream == null) {
        throw new NullPointerException();
    }
    if (quality < 0 || quality > 100) {
        throw new IllegalArgumentException("quality must be 0..100");
    }
    Trace.traceBegin(Trace.TRACE_TAG_RESOURCES, "Bitmap.compress");
    boolean result = nativeCompress(mFinalizer.mNativeBitmap, format.nativeInt, quality, stream, new byte[WORKING_COMPRESS_STORAGE]);
    Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
    return result;
}
Body of Second Method:
{
    checkRecycled("Can't compress a recycled bitmap");
    // do explicit check before calling the native method
    if (stream == null) {
        throw new NullPointerException();
    }
    if (quality < 0 || quality > 100) {
        throw new IllegalArgumentException("quality must be 0..100");
    }
    Trace.traceBegin(Trace.TRACE_TAG_RESOURCES, "Bitmap.compress");
    boolean result = nativeCompress(mNativePtr, format.nativeInt, quality, stream, new byte[WORKING_COMPRESS_STORAGE]);
    Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
    return result;
}
------------------------
Find a silently evolved API code:android.hardware.usb.UsbManager.requestPermission:COMMENT
Method Modifier: public      
Comment:/**
 * Requests temporary permission for the given package to access the accessory.
 * This may result in a system dialog being displayed to the user
 * if permission had not already been granted.
 * Success or failure is returned via the {@link android.app.PendingIntent} pi.
 * If successful, this grants the caller permission to access the accessory only
 * until the device is disconnected.
 *
 * The following extras will be added to pi:
 * <ul>
 * <li> {@link #EXTRA_ACCESSORY} containing the accessory passed into this call
 * <li> {@link #EXTRA_PERMISSION_GRANTED} containing boolean indicating whether
 * permission was granted by the user
 * </ul>
 *
 * @param accessory to request permissions for
 * @param pi PendingIntent for returning result
 */

Body of Frist Method:
{
    try {
        mService.requestAccessoryPermission(accessory, mContext.getPackageName(), pi);
    } catch (RemoteException e) {
        Log.e(TAG, "RemoteException in requestPermission", e);
    }
}
Body of Second Method:
{
    try {
        mService.requestAccessoryPermission(accessory, mContext.getPackageName(), pi);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.hardware.location.ActivityRecognitionHardware.onActivityChanged:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Called by the Activity-Recognition HAL.
 */

Body of Frist Method:
{
    if (events == null || events.length == 0) {
        Log.d(TAG, "No events to broadcast for onActivityChanged.");
        return;
    }
    int eventsLength = events.length;
    ActivityRecognitionEvent[] activityRecognitionEventArray = new ActivityRecognitionEvent[eventsLength];
    for (int i = 0; i < eventsLength; ++i) {
        Event event = events[i];
        String activityName = getActivityName(event.activity);
        activityRecognitionEventArray[i] = new ActivityRecognitionEvent(activityName, event.type, event.timestamp);
    }
    ActivityChangedEvent activityChangedEvent = new ActivityChangedEvent(activityRecognitionEventArray);
    int size = mSinks.beginBroadcast();
    for (int i = 0; i < size; ++i) {
        IActivityRecognitionHardwareSink sink = mSinks.getBroadcastItem(i);
        try {
            sink.onActivityChanged(activityChangedEvent);
        } catch (RemoteException e) {
            Log.e(TAG, "Error delivering activity changed event.", e);
        }
    }
    mSinks.finishBroadcast();
}
Body of Second Method:
{
    if (events == null || events.length == 0) {
        if (DEBUG)
            Log.d(TAG, "No events to broadcast for onActivityChanged.");
        return;
    }
    int eventsLength = events.length;
    ActivityRecognitionEvent[] activityRecognitionEventArray = new ActivityRecognitionEvent[eventsLength];
    for (int i = 0; i < eventsLength; ++i) {
        Event event = events[i];
        String activityName = getActivityName(event.activity);
        activityRecognitionEventArray[i] = new ActivityRecognitionEvent(activityName, event.type, event.timestamp);
    }
    ActivityChangedEvent activityChangedEvent = new ActivityChangedEvent(activityRecognitionEventArray);
    int size = mSinks.beginBroadcast();
    for (int i = 0; i < size; ++i) {
        IActivityRecognitionHardwareSink sink = mSinks.getBroadcastItem(i);
        try {
            sink.onActivityChanged(activityChangedEvent);
        } catch (RemoteException e) {
            Log.e(TAG, "Error delivering activity changed event.", e);
        }
    }
    mSinks.finishBroadcast();
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothAdapter.getBondedDevices:COMMENT
Method Modifier: public      
Comment:/**
 * Return the set of {@link BluetoothDevice} objects that are bonded
 * (paired) to the local adapter.
 * <p>If Bluetooth state is not {@link #STATE_ON}, this API
 * will return an empty set. After turning on Bluetooth,
 * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}
 * to get the updated value.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}.
 *
 * @return unmodifiable set of {@link BluetoothDevice}, or null on error
 */

Body of Frist Method:
{
    if (getState() != STATE_ON) {
        return toDeviceSet(new BluetoothDevice[0]);
    }
    try {
        synchronized (mManagerCallback) {
            if (mService != null)
                return toDeviceSet(mService.getBondedDevices());
        }
        return toDeviceSet(new BluetoothDevice[0]);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return null;
}
Body of Second Method:
{
    if (getState() != STATE_ON) {
        return toDeviceSet(new BluetoothDevice[0]);
    }
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return toDeviceSet(mService.getBondedDevices());
        return toDeviceSet(new BluetoothDevice[0]);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return null;
}
------------------------
Find a silently evolved API code:android.media.AudioAttributes.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Combines all of the attributes that have been set and return a new
 * {@link AudioAttributes} object.
 * @return a new {@link AudioAttributes} object
 */

Body of Frist Method:
{
    AudioAttributes aa = new AudioAttributes();
    aa.mContentType = mContentType;
    aa.mUsage = mUsage;
    aa.mSource = mSource;
    aa.mFlags = mFlags;
    aa.mTags = (HashSet<String>) mTags.clone();
    aa.mFormattedTags = TextUtils.join(";", mTags);
    return aa;
}
Body of Second Method:
{
    AudioAttributes aa = new AudioAttributes();
    aa.mContentType = mContentType;
    aa.mUsage = mUsage;
    aa.mSource = mSource;
    aa.mFlags = mFlags;
    aa.mTags = (HashSet<String>) mTags.clone();
    aa.mFormattedTags = TextUtils.join(";", mTags);
    if (mBundle != null) {
        aa.mBundle = new Bundle(mBundle);
    }
    return aa;
}
------------------------
Find a silently evolved API code:android.app.trust.TrustManager.reportKeyguardShowingChanged:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Reports that the visibility of the keyguard has changed.
 *
 * Requires the {@link android.Manifest.permission#ACCESS_KEYGUARD_SECURE_STORAGE} permission.
 */

Body of Frist Method:
{
    try {
        mService.reportKeyguardShowingChanged();
    } catch (RemoteException e) {
        onError(e);
    }
}
Body of Second Method:
{
    try {
        mService.reportKeyguardShowingChanged();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.os.Bundle.putParcelableArray:COMMENT
Method Modifier: public      
Comment:/**
 * Inserts an array of Parcelable values into the mapping of this Bundle,
 * replacing any existing value for the given key.  Either key or value may
 * be null.
 *
 * @param key a String, or null
 * @param value an array of Parcelable objects, or null
 */

Body of Frist Method:
{
    unparcel();
    mMap.put(key, value);
    mFdsKnown = false;
}
Body of Second Method:
{
    unparcel();
    mMap.put(key, value);
    mFlags &= ~FLAG_HAS_FDS_KNOWN;
}
------------------------
Find a silently evolved API code:android.accounts.AccountManager.getAuthTokenLabel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the user-friendly label associated with an authenticator's auth token.
 * @param accountType the type of the authenticator. must not be null.
 * @param authTokenType the token type. must not be null.
 * @param callback callback to invoke when the result is available. may be null.
 * @param handler the handler on which to invoke the callback, or null for the main thread
 * @return a future containing the label string
 * @hide
 */

Body of Frist Method:
{
    if (accountType == null)
        throw new IllegalArgumentException("accountType is null");
    if (authTokenType == null)
        throw new IllegalArgumentException("authTokenType is null");
    return new Future2Task<String>(handler, callback) {

        public void doWork() throws RemoteException {
            mService.getAuthTokenLabel(mResponse, accountType, authTokenType);
        }

        @Override
        public String bundleToResult(Bundle bundle) throws AuthenticatorException {
            if (!bundle.containsKey(KEY_AUTH_TOKEN_LABEL)) {
                throw new AuthenticatorException("no result in response");
            }
            return bundle.getString(KEY_AUTH_TOKEN_LABEL);
        }
    }.start();
}
Body of Second Method:
{
    if (accountType == null)
        throw new IllegalArgumentException("accountType is null");
    if (authTokenType == null)
        throw new IllegalArgumentException("authTokenType is null");
    return new Future2Task<String>(handler, callback) {

        @Override
        public void doWork() throws RemoteException {
            mService.getAuthTokenLabel(mResponse, accountType, authTokenType);
        }

        @Override
        public String bundleToResult(Bundle bundle) throws AuthenticatorException {
            if (!bundle.containsKey(KEY_AUTH_TOKEN_LABEL)) {
                throw new AuthenticatorException("no result in response");
            }
            return bundle.getString(KEY_AUTH_TOKEN_LABEL);
        }
    }.start();
}
------------------------
Find a silently evolved API code:android.provider.ContactsInternal.maybeStartManagedQuickContact:COMMENT
Method Modifier: private     static      hidden      
Comment:/**
 * If the URI in {@code intent} is of a corp contact, launch quick contact on the managed
 * profile.
 *
 * @return the URI in {@code intent} is of a corp contact thus launched on the managed profile.
 */

Body of Frist Method:
{
    final Uri uri = originalIntent.getData();
    // Decompose into an ID and a lookup key.
    final List<String> pathSegments = uri.getPathSegments();
    final long contactId = ContentUris.parseId(uri);
    final String lookupKey = pathSegments.get(2);
    // See if it has a corp lookupkey.
    if (TextUtils.isEmpty(lookupKey) || !lookupKey.startsWith(ContactsContract.Contacts.ENTERPRISE_CONTACT_LOOKUP_PREFIX)) {
        // It's not a corp lookup key.
        return false;
    }
    // Launch Quick Contact on the managed profile, if the policy allows.
    final DevicePolicyManager dpm = context.getSystemService(DevicePolicyManager.class);
    final String actualLookupKey = lookupKey.substring(ContactsContract.Contacts.ENTERPRISE_CONTACT_LOOKUP_PREFIX.length());
    final long actualContactId = (contactId - ContactsContract.Contacts.ENTERPRISE_CONTACT_ID_BASE);
    dpm.startManagedQuickContact(actualLookupKey, actualContactId, originalIntent);
    return true;
}
Body of Second Method:
{
    final Uri uri = originalIntent.getData();
    // Decompose into an ID and a lookup key.
    final List<String> pathSegments = uri.getPathSegments();
    final boolean isContactIdIgnored = pathSegments.size() < 4;
    final long contactId = isContactIdIgnored ? // contact id will be ignored
    ContactsContract.Contacts.ENTERPRISE_CONTACT_ID_BASE : ContentUris.parseId(uri);
    final String lookupKey = pathSegments.get(2);
    final String directoryIdStr = uri.getQueryParameter(ContactsContract.DIRECTORY_PARAM_KEY);
    final long directoryId = (directoryIdStr == null) ? ContactsContract.Directory.ENTERPRISE_DIRECTORY_ID_BASE : Long.parseLong(directoryIdStr);
    // See if it has a corp lookupkey.
    if (TextUtils.isEmpty(lookupKey) || !lookupKey.startsWith(ContactsContract.Contacts.ENTERPRISE_CONTACT_LOOKUP_PREFIX)) {
        // It's not a corp lookup key.
        return false;
    }
    if (!ContactsContract.Contacts.isEnterpriseContactId(contactId)) {
        throw new IllegalArgumentException("Invalid enterprise contact id: " + contactId);
    }
    if (!ContactsContract.Directory.isEnterpriseDirectoryId(directoryId)) {
        throw new IllegalArgumentException("Invalid enterprise directory id: " + directoryId);
    }
    // Launch Quick Contact on the managed profile, if the policy allows.
    final DevicePolicyManager dpm = context.getSystemService(DevicePolicyManager.class);
    final String actualLookupKey = lookupKey.substring(ContactsContract.Contacts.ENTERPRISE_CONTACT_LOOKUP_PREFIX.length());
    final long actualContactId = (contactId - ContactsContract.Contacts.ENTERPRISE_CONTACT_ID_BASE);
    final long actualDirectoryId = (directoryId - ContactsContract.Directory.ENTERPRISE_DIRECTORY_ID_BASE);
    dpm.startManagedQuickContact(actualLookupKey, actualContactId, isContactIdIgnored, actualDirectoryId, originalIntent);
    return true;
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiManager.getFrequencyBand:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the operational frequency band.
 * @return One of
 * {@link #WIFI_FREQUENCY_BAND_AUTO},
 * {@link #WIFI_FREQUENCY_BAND_5GHZ},
 * {@link #WIFI_FREQUENCY_BAND_2GHZ} or
 * {@code -1} on failure.
 * @hide
 */

Body of Frist Method:
{
    try {
        return mService.getFrequencyBand();
    } catch (RemoteException e) {
        return -1;
    }
}
Body of Second Method:
{
    try {
        return mService.getFrequencyBand();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.security.NetworkSecurityPolicy.setCleartextTrafficPermitted:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets whether cleartext network traffic is permitted for this process.
 *
 * <p>This method is used by the platform early on in the application's initialization to set
 * the policy.
 *
 * @hide
 */

Body of Frist Method:
{
    libcore.net.NetworkSecurityPolicy.setCleartextTrafficPermitted(permitted);
}
Body of Second Method:
{
    FrameworkNetworkSecurityPolicy policy = new FrameworkNetworkSecurityPolicy(permitted);
    libcore.net.NetworkSecurityPolicy.setInstance(policy);
}
------------------------
Find a silently evolved API code:android.media.midi.MidiManager.openDevice:COMMENT
Method Modifier: public      
Comment:/**
 * Opens a MIDI device for reading and writing.
 *
 * @param deviceInfo a {@link android.media.midi.MidiDeviceInfo} to open
 * @param listener a {@link MidiManager.OnDeviceOpenedListener} to be called
 * to receive the result
 * @param handler the {@link android.os.Handler Handler} that will be used for delivering
 * the result. If handler is null, then the thread used for the
 * listener is unspecified.
 */

Body of Frist Method:
{
    final MidiDeviceInfo deviceInfoF = deviceInfo;
    final OnDeviceOpenedListener listenerF = listener;
    final Handler handlerF = handler;
    IMidiDeviceOpenCallback callback = new IMidiDeviceOpenCallback.Stub() {

        @Override
        public void onDeviceOpened(IMidiDeviceServer server, IBinder deviceToken) {
            MidiDevice device;
            if (server != null) {
                device = new MidiDevice(deviceInfoF, server, mService, mToken, deviceToken);
            } else {
                device = null;
            }
            sendOpenDeviceResponse(device, listenerF, handlerF);
        }
    };
    try {
        mService.openDevice(mToken, deviceInfo, callback);
    } catch (RemoteException e) {
        Log.e(TAG, "RemoteException in openDevice");
    }
}
Body of Second Method:
{
    final MidiDeviceInfo deviceInfoF = deviceInfo;
    final OnDeviceOpenedListener listenerF = listener;
    final Handler handlerF = handler;
    IMidiDeviceOpenCallback callback = new IMidiDeviceOpenCallback.Stub() {

        @Override
        public void onDeviceOpened(IMidiDeviceServer server, IBinder deviceToken) {
            MidiDevice device;
            if (server != null) {
                device = new MidiDevice(deviceInfoF, server, mService, mToken, deviceToken);
            } else {
                device = null;
            }
            sendOpenDeviceResponse(device, listenerF, handlerF);
        }
    };
    try {
        mService.openDevice(mToken, deviceInfo, callback);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.widget.RelativeLayout.LayoutParams.getRules:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Retrieves a complete list of all supported rules, where the index is the rule
 * verb, and the element value is the value specified, or "false" if it was never
 * set. If there are relative rules defined (*_START / *_END), they will be resolved
 * depending on the layout direction.
 *
 * @param layoutDirection the direction of the layout.
 * Should be either {@link View#LAYOUT_DIRECTION_LTR}
 * or {@link View#LAYOUT_DIRECTION_RTL}
 * @return the supported rules
 * @see #addRule(int, int)
 *
 * @hide
 */

Body of Frist Method:
{
    if (hasRelativeRules() && (mRulesChanged || layoutDirection != getLayoutDirection())) {
        resolveRules(layoutDirection);
        if (layoutDirection != getLayoutDirection()) {
            setLayoutDirection(layoutDirection);
        }
    }
    return mRules;
}
Body of Second Method:
{
    resolveLayoutDirection(layoutDirection);
    return mRules;
}
------------------------
Find a silently evolved API code:android.app.AlarmManager.setTime:COMMENT
Method Modifier: public      
Comment:/**
 * Set the system wall clock time.
 * Requires the permission android.permission.SET_TIME.
 *
 * @param millis time in milliseconds since the Epoch
 */

Body of Frist Method:
{
    try {
        mService.setTime(millis);
    } catch (RemoteException ex) {
    }
}
Body of Second Method:
{
    try {
        mService.setTime(millis);
    } catch (RemoteException ex) {
        throw ex.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.app.LoaderManagerImpl.restartLoader:COMMENT
Method Modifier: public      
Comment:/**
 * Call to re-create the Loader associated with a particular ID.  If there
 * is currently a Loader associated with this ID, it will be
 * canceled/stopped/destroyed as appropriate.  A new Loader with the given
 * arguments will be created and its data delivered to you once available.
 *
 * <p>This function does some throttling of Loaders.  If too many Loaders
 * have been created for the given ID but not yet generated their data,
 * new calls to this function will create and return a new Loader but not
 * actually start it until some previous loaders have completed.
 *
 * <p>After calling this function, any previous Loaders associated with
 * this ID will be considered invalid, and you will receive no further
 * data updates from them.
 *
 * @param id A unique (to this LoaderManager instance) identifier under
 * which to manage the new Loader.
 * @param args Optional arguments that will be propagated to
 * {@link LoaderCallbacks#onCreateLoader(int, Bundle) LoaderCallbacks.onCreateLoader()}.
 * @param callback Interface implementing management of this Loader.  Required.
 * Its onCreateLoader() method will be called while inside of the function to
 * instantiate the Loader object.
 */

Body of Frist Method:
{
    if (mCreatingLoader) {
        throw new IllegalStateException("Called while creating a loader");
    }
    LoaderInfo info = mLoaders.get(id);
    if (DEBUG)
        Log.v(TAG, "restartLoader in " + this + ": args=" + args);
    if (info != null) {
        LoaderInfo inactive = mInactiveLoaders.get(id);
        if (inactive != null) {
            if (info.mHaveData) {
                // that now.
                if (DEBUG)
                    Log.v(TAG, "  Removing last inactive loader: " + info);
                inactive.mDeliveredData = false;
                inactive.destroy();
                info.mLoader.abandon();
                mInactiveLoaders.put(id, info);
            } else {
                // waiting for!  What to do, what to do...
                if (!info.mStarted) {
                    // thank-you-ma'am.
                    if (DEBUG)
                        Log.v(TAG, "  Current loader is stopped; replacing");
                    mLoaders.put(id, null);
                    info.destroy();
                } else {
                    // finishes or is canceled.
                    if (DEBUG)
                        Log.v(TAG, "  Current loader is running; attempting to cancel");
                    info.cancel();
                    if (info.mPendingLoader != null) {
                        if (DEBUG)
                            Log.v(TAG, "  Removing pending loader: " + info.mPendingLoader);
                        info.mPendingLoader.destroy();
                        info.mPendingLoader = null;
                    }
                    if (DEBUG)
                        Log.v(TAG, "  Enqueuing as new pending loader");
                    info.mPendingLoader = createLoader(id, args, (LoaderManager.LoaderCallbacks<Object>) callback);
                    return (Loader<D>) info.mPendingLoader.mLoader;
                }
            }
        } else {
            // it when the new one completes.
            if (DEBUG)
                Log.v(TAG, "  Making last loader inactive: " + info);
            info.mLoader.abandon();
            mInactiveLoaders.put(id, info);
        }
    }
    info = createAndInstallLoader(id, args, (LoaderManager.LoaderCallbacks<Object>) callback);
    return (Loader<D>) info.mLoader;
}
Body of Second Method:
{
    if (mCreatingLoader) {
        throw new IllegalStateException("Called while creating a loader");
    }
    LoaderInfo info = mLoaders.get(id);
    if (DEBUG)
        Log.v(TAG, "restartLoader in " + this + ": args=" + args);
    if (info != null) {
        LoaderInfo inactive = mInactiveLoaders.get(id);
        if (inactive != null) {
            if (info.mHaveData) {
                // that now.
                if (DEBUG)
                    Log.v(TAG, "  Removing last inactive loader: " + info);
                inactive.mDeliveredData = false;
                inactive.destroy();
                info.mLoader.abandon();
                mInactiveLoaders.put(id, info);
            } else {
                // running and we have more work to do.
                if (!info.cancel()) {
                    // LoaderInfo will be created below.
                    if (DEBUG)
                        Log.v(TAG, "  Current loader is stopped; replacing");
                    mLoaders.put(id, null);
                    info.destroy();
                } else {
                    // finishes.
                    if (DEBUG)
                        Log.v(TAG, "  Current loader is running; configuring pending loader");
                    if (info.mPendingLoader != null) {
                        if (DEBUG)
                            Log.v(TAG, "  Removing pending loader: " + info.mPendingLoader);
                        info.mPendingLoader.destroy();
                        info.mPendingLoader = null;
                    }
                    if (DEBUG)
                        Log.v(TAG, "  Enqueuing as new pending loader");
                    info.mPendingLoader = createLoader(id, args, (LoaderManager.LoaderCallbacks<Object>) callback);
                    return (Loader<D>) info.mPendingLoader.mLoader;
                }
            }
        } else {
            // it when the new one completes.
            if (DEBUG)
                Log.v(TAG, "  Making last loader inactive: " + info);
            info.mLoader.abandon();
            mInactiveLoaders.put(id, info);
        }
    }
    info = createAndInstallLoader(id, args, (LoaderManager.LoaderCallbacks<Object>) callback);
    return (Loader<D>) info.mLoader;
}
------------------------
Find a silently evolved API code:android.app.ActivityManager.getMyMemoryState:COMMENT
Method Modifier: public      static      
Comment:/**
 * Return global memory state information for the calling process.  This
 * does not fill in all fields of the {@link RunningAppProcessInfo}.  The
 * only fields that will be filled in are
 * {@link RunningAppProcessInfo#pid},
 * {@link RunningAppProcessInfo#uid},
 * {@link RunningAppProcessInfo#lastTrimLevel},
 * {@link RunningAppProcessInfo#importance},
 * {@link RunningAppProcessInfo#lru}, and
 * {@link RunningAppProcessInfo#importanceReasonCode}.
 */

Body of Frist Method:
{
    try {
        ActivityManagerNative.getDefault().getMyMemoryState(outState);
    } catch (RemoteException e) {
    }
}
Body of Second Method:
{
    try {
        ActivityManagerNative.getDefault().getMyMemoryState(outState);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.app.ActivityOptions.toBundle:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the created options as a Bundle, which can be passed to
 * {@link android.content.Context#startActivity(android.content.Intent, android.os.Bundle)
 * Context.startActivity(Intent, Bundle)} and related methods.
 * Note that the returned Bundle is still owned by the ActivityOptions
 * object; you must not modify it, but can supply it to the startActivity
 * methods that take an options Bundle.
 */

Body of Frist Method:
{
    if (mAnimationType == ANIM_DEFAULT) {
        return null;
    }
    Bundle b = new Bundle();
    if (mPackageName != null) {
        b.putString(KEY_PACKAGE_NAME, mPackageName);
    }
    b.putInt(KEY_ANIM_TYPE, mAnimationType);
    if (mUsageTimeReport != null) {
        b.putParcelable(KEY_USAGE_TIME_REPORT, mUsageTimeReport);
    }
    switch(mAnimationType) {
        case ANIM_CUSTOM:
            b.putInt(KEY_ANIM_ENTER_RES_ID, mCustomEnterResId);
            b.putInt(KEY_ANIM_EXIT_RES_ID, mCustomExitResId);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_CUSTOM_IN_PLACE:
            b.putInt(KEY_ANIM_IN_PLACE_RES_ID, mCustomInPlaceResId);
            break;
        case ANIM_SCALE_UP:
        case ANIM_CLIP_REVEAL:
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            break;
        case ANIM_THUMBNAIL_SCALE_UP:
        case ANIM_THUMBNAIL_SCALE_DOWN:
        case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
        case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
            b.putParcelable(KEY_ANIM_THUMBNAIL, mThumbnail);
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_SCENE_TRANSITION:
            if (mTransitionReceiver != null) {
                b.putParcelable(KEY_TRANSITION_COMPLETE_LISTENER, mTransitionReceiver);
            }
            b.putBoolean(KEY_TRANSITION_IS_RETURNING, mIsReturning);
            b.putStringArrayList(KEY_TRANSITION_SHARED_ELEMENTS, mSharedElementNames);
            b.putParcelable(KEY_RESULT_DATA, mResultData);
            b.putInt(KEY_RESULT_CODE, mResultCode);
            b.putInt(KEY_EXIT_COORDINATOR_INDEX, mExitCoordinatorIndex);
            break;
    }
    return b;
}
Body of Second Method:
{
    if (mAnimationType == ANIM_DEFAULT) {
        return null;
    }
    Bundle b = new Bundle();
    if (mPackageName != null) {
        b.putString(KEY_PACKAGE_NAME, mPackageName);
    }
    if (mLaunchBounds != null) {
        b.putParcelable(KEY_LAUNCH_BOUNDS, mLaunchBounds);
    }
    b.putInt(KEY_ANIM_TYPE, mAnimationType);
    if (mUsageTimeReport != null) {
        b.putParcelable(KEY_USAGE_TIME_REPORT, mUsageTimeReport);
    }
    switch(mAnimationType) {
        case ANIM_CUSTOM:
            b.putInt(KEY_ANIM_ENTER_RES_ID, mCustomEnterResId);
            b.putInt(KEY_ANIM_EXIT_RES_ID, mCustomExitResId);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_CUSTOM_IN_PLACE:
            b.putInt(KEY_ANIM_IN_PLACE_RES_ID, mCustomInPlaceResId);
            break;
        case ANIM_SCALE_UP:
        case ANIM_CLIP_REVEAL:
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            break;
        case ANIM_THUMBNAIL_SCALE_UP:
        case ANIM_THUMBNAIL_SCALE_DOWN:
        case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
        case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
            b.putParcelable(KEY_ANIM_THUMBNAIL, mThumbnail);
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_SCENE_TRANSITION:
            if (mTransitionReceiver != null) {
                b.putParcelable(KEY_TRANSITION_COMPLETE_LISTENER, mTransitionReceiver);
            }
            b.putBoolean(KEY_TRANSITION_IS_RETURNING, mIsReturning);
            b.putStringArrayList(KEY_TRANSITION_SHARED_ELEMENTS, mSharedElementNames);
            b.putParcelable(KEY_RESULT_DATA, mResultData);
            b.putInt(KEY_RESULT_CODE, mResultCode);
            b.putInt(KEY_EXIT_COORDINATOR_INDEX, mExitCoordinatorIndex);
            break;
    }
    b.putInt(KEY_LAUNCH_STACK_ID, mLaunchStackId);
    b.putInt(KEY_LAUNCH_TASK_ID, mLaunchTaskId);
    b.putBoolean(KEY_TASK_OVERLAY, mTaskOverlay);
    b.putInt(KEY_DOCK_CREATE_MODE, mDockCreateMode);
    if (mAnimSpecs != null) {
        b.putParcelableArray(KEY_ANIM_SPECS, mAnimSpecs);
    }
    if (mAnimationFinishedListener != null) {
        b.putBinder(KEY_ANIMATION_FINISHED_LISTENER, mAnimationFinishedListener.asBinder());
    }
    return b;
}
------------------------
Find a silently evolved API code:android.media.AudioManager.isStreamAffectedByMute:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Only useful for volume controllers.
 * @hide
 */

Body of Frist Method:
{
    try {
        return getService().isStreamAffectedByMute(streamType);
    } catch (RemoteException e) {
        Log.w(TAG, "Error calling isStreamAffectedByMute", e);
        return false;
    }
}
Body of Second Method:
{
    try {
        return getService().isStreamAffectedByMute(streamType);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.widget.SimpleMonthView.setMonthParams:COMMENT
Method Modifier: default     
Comment:/**
 * Sets all the parameters for displaying this week.
 * <p>
 * Parameters have a default value and will only update if a new value is
 * included, except for focus month, which will always default to no focus
 * month if no value is passed in. The only required parameter is the week
 * start.
 *
 * @param selectedDay the selected day of the month, or -1 for no selection
 * @param month the month
 * @param year the year
 * @param weekStart which day the week should start on, valid values are
 * {@link Calendar#SUNDAY} through {@link Calendar#SATURDAY}
 * @param enabledDayStart the first enabled day
 * @param enabledDayEnd the last enabled day
 */

Body of Frist Method:
{
    mActivatedDay = selectedDay;
    if (isValidMonth(month)) {
        mMonth = month;
    }
    mYear = year;
    mCalendar.set(Calendar.MONTH, mMonth);
    mCalendar.set(Calendar.YEAR, mYear);
    mCalendar.set(Calendar.DAY_OF_MONTH, 1);
    mDayOfWeekStart = mCalendar.get(Calendar.DAY_OF_WEEK);
    if (isValidDayOfWeek(weekStart)) {
        mWeekStart = weekStart;
    } else {
        mWeekStart = mCalendar.getFirstDayOfWeek();
    }
    // Figure out what day today is.
    final Calendar today = Calendar.getInstance();
    mToday = -1;
    mDaysInMonth = getDaysInMonth(mMonth, mYear);
    for (int i = 0; i < mDaysInMonth; i++) {
        final int day = i + 1;
        if (sameDay(day, today)) {
            mToday = day;
        }
    }
    mEnabledDayStart = MathUtils.constrain(enabledDayStart, 1, mDaysInMonth);
    mEnabledDayEnd = MathUtils.constrain(enabledDayEnd, mEnabledDayStart, mDaysInMonth);
    // Invalidate the old title.
    mTitle = null;
    // Invalidate cached accessibility information.
    mTouchHelper.invalidateRoot();
}
Body of Second Method:
{
    mActivatedDay = selectedDay;
    if (isValidMonth(month)) {
        mMonth = month;
    }
    mYear = year;
    mCalendar.set(Calendar.MONTH, mMonth);
    mCalendar.set(Calendar.YEAR, mYear);
    mCalendar.set(Calendar.DAY_OF_MONTH, 1);
    mDayOfWeekStart = mCalendar.get(Calendar.DAY_OF_WEEK);
    if (isValidDayOfWeek(weekStart)) {
        mWeekStart = weekStart;
    } else {
        mWeekStart = mCalendar.getFirstDayOfWeek();
    }
    // Figure out what day today is.
    final Calendar today = Calendar.getInstance();
    mToday = -1;
    mDaysInMonth = getDaysInMonth(mMonth, mYear);
    for (int i = 0; i < mDaysInMonth; i++) {
        final int day = i + 1;
        if (sameDay(day, today)) {
            mToday = day;
        }
    }
    mEnabledDayStart = MathUtils.constrain(enabledDayStart, 1, mDaysInMonth);
    mEnabledDayEnd = MathUtils.constrain(enabledDayEnd, mEnabledDayStart, mDaysInMonth);
    updateMonthYearLabel();
    updateDayOfWeekLabels();
    // Invalidate cached accessibility information.
    mTouchHelper.invalidateRoot();
    invalidate();
}
------------------------
Find a silently evolved API code:android.media.AudioManager.getMode:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the current audio mode.
 *
 * @return      the current audio mode ({@link #MODE_NORMAL}, {@link #MODE_RINGTONE},
 * {@link #MODE_IN_CALL} or {@link #MODE_IN_COMMUNICATION}).
 * Returns the current current audio state from the HAL.
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        return service.getMode();
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in getMode", e);
        return MODE_INVALID;
    }
}
Body of Second Method:
{
    IAudioService service = getService();
    try {
        return service.getMode();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.app.ActivityManager.getTaskThumbnail:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    try {
        return ActivityManagerNative.getDefault().getTaskThumbnail(id);
    } catch (RemoteException e) {
        // System dead, we will be dead too soon!
        return null;
    }
}
Body of Second Method:
{
    try {
        return ActivityManagerNative.getDefault().getTaskThumbnail(id);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.app.trust.TrustManager.reportEnabledTrustAgentsChanged:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Reports that the list of enabled trust agents changed for user {@param userId}.
 *
 * Requires the {@link android.Manifest.permission#ACCESS_KEYGUARD_SECURE_STORAGE} permission.
 */

Body of Frist Method:
{
    try {
        mService.reportEnabledTrustAgentsChanged(userId);
    } catch (RemoteException e) {
        onError(e);
    }
}
Body of Second Method:
{
    try {
        mService.reportEnabledTrustAgentsChanged(userId);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothAdapter.getProfileProxy:COMMENT
Method Modifier: public      
Comment:/**
 * Get the profile proxy object associated with the profile.
 *
 * <p>Profile can be one of {@link BluetoothProfile#HEALTH}, {@link BluetoothProfile#HEADSET},
 * {@link BluetoothProfile#A2DP}, {@link BluetoothProfile#GATT}, or
 * {@link BluetoothProfile#GATT_SERVER}. Clients must implement
 * {@link BluetoothProfile.ServiceListener} to get notified of
 * the connection status and to get the proxy object.
 *
 * @param context Context of the application
 * @param listener The service Listener for connection callbacks.
 * @param profile The Bluetooth profile; either {@link BluetoothProfile#HEALTH},
 * {@link BluetoothProfile#HEADSET}, {@link BluetoothProfile#A2DP}.
 * {@link BluetoothProfile#GATT} or {@link BluetoothProfile#GATT_SERVER}.
 * @return true on success, false on error
 */

Body of Frist Method:
{
    if (context == null || listener == null)
        return false;
    if (profile == BluetoothProfile.HEADSET) {
        BluetoothHeadset headset = new BluetoothHeadset(context, listener);
        return true;
    } else if (profile == BluetoothProfile.A2DP) {
        BluetoothA2dp a2dp = new BluetoothA2dp(context, listener);
        return true;
    } else if (profile == BluetoothProfile.A2DP_SINK) {
        BluetoothA2dpSink a2dpSink = new BluetoothA2dpSink(context, listener);
        return true;
    } else if (profile == BluetoothProfile.AVRCP_CONTROLLER) {
        BluetoothAvrcpController avrcp = new BluetoothAvrcpController(context, listener);
        return true;
    } else if (profile == BluetoothProfile.INPUT_DEVICE) {
        BluetoothInputDevice iDev = new BluetoothInputDevice(context, listener);
        return true;
    } else if (profile == BluetoothProfile.PAN) {
        BluetoothPan pan = new BluetoothPan(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEALTH) {
        BluetoothHealth health = new BluetoothHealth(context, listener);
        return true;
    } else if (profile == BluetoothProfile.MAP) {
        BluetoothMap map = new BluetoothMap(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEADSET_CLIENT) {
        BluetoothHeadsetClient headsetClient = new BluetoothHeadsetClient(context, listener);
        return true;
    } else if (profile == BluetoothProfile.SAP) {
        BluetoothSap sap = new BluetoothSap(context, listener);
        return true;
    } else {
        return false;
    }
}
Body of Second Method:
{
    if (context == null || listener == null)
        return false;
    if (profile == BluetoothProfile.HEADSET) {
        BluetoothHeadset headset = new BluetoothHeadset(context, listener);
        return true;
    } else if (profile == BluetoothProfile.A2DP) {
        BluetoothA2dp a2dp = new BluetoothA2dp(context, listener);
        return true;
    } else if (profile == BluetoothProfile.A2DP_SINK) {
        BluetoothA2dpSink a2dpSink = new BluetoothA2dpSink(context, listener);
        return true;
    } else if (profile == BluetoothProfile.AVRCP_CONTROLLER) {
        BluetoothAvrcpController avrcp = new BluetoothAvrcpController(context, listener);
        return true;
    } else if (profile == BluetoothProfile.INPUT_DEVICE) {
        BluetoothInputDevice iDev = new BluetoothInputDevice(context, listener);
        return true;
    } else if (profile == BluetoothProfile.PAN) {
        BluetoothPan pan = new BluetoothPan(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEALTH) {
        BluetoothHealth health = new BluetoothHealth(context, listener);
        return true;
    } else if (profile == BluetoothProfile.MAP) {
        BluetoothMap map = new BluetoothMap(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEADSET_CLIENT) {
        BluetoothHeadsetClient headsetClient = new BluetoothHeadsetClient(context, listener);
        return true;
    } else if (profile == BluetoothProfile.SAP) {
        BluetoothSap sap = new BluetoothSap(context, listener);
        return true;
    } else if (profile == BluetoothProfile.PBAP_CLIENT) {
        BluetoothPbapClient pbapClient = new BluetoothPbapClient(context, listener);
        return true;
    } else {
        return false;
    }
}
------------------------
Find a silently evolved API code:android.os.Bundle.clear:COMMENT
Method Modifier: public      
Comment:/**
 * Removes all elements from the mapping of this Bundle.
 */

Body of Frist Method:
{
    super.clear();
    mHasFds = false;
    mFdsKnown = true;
}
Body of Second Method:
{
    super.clear();
    mFlags = FLAG_HAS_FDS_KNOWN | FLAG_ALLOW_FDS;
}
------------------------
Find a silently evolved API code:android.accounts.AccountManager.getAccounts:COMMENT
Method Modifier: public      
Comment:/**
 * Lists all accounts of any type registered on the device.
 * Equivalent to getAccountsByType(null).
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>Clients of this method that have not been granted the
 * {@link android.Manifest.permission#GET_ACCOUNTS} permission,
 * will only see those accounts managed by AbstractAccountAuthenticators whose
 * signature matches the client.
 *
 * @return An array of {@link Account}, one for each account.  Empty
 * (never null) if no accounts have been added.
 */

Body of Frist Method:
{
    try {
        return mService.getAccounts(null, mContext.getOpPackageName());
    } catch (RemoteException e) {
        // won't ever happen
        throw new RuntimeException(e);
    }
}
Body of Second Method:
{
    try {
        return mService.getAccounts(null, mContext.getOpPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.media.AudioManager.avrcpSupportsAbsoluteVolume:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 * Notifies AudioService that it is connected to an A2DP device that supports absolute volume,
 * so that AudioService can send volume change events to the A2DP device, rather than handling
 * them.
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        service.avrcpSupportsAbsoluteVolume(address, support);
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in avrcpSupportsAbsoluteVolume", e);
    }
}
Body of Second Method:
{
    IAudioService service = getService();
    try {
        service.avrcpSupportsAbsoluteVolume(address, support);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.app.admin.DeviceAdminInfo.loadLabel:COMMENT
Method Modifier: public      
Comment:/**
 * Load the user-displayed label for this device admin.
 *
 * @param pm Supply a PackageManager used to load the device admin's
 * resources.
 */

Body of Frist Method:
{
    return mReceiver.loadLabel(pm);
}
Body of Second Method:
{
    return mActivityInfo.loadLabel(pm);
}
------------------------
Find a silently evolved API code:android.net.SntpClient.readTimeStamp:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Reads the NTP time stamp at the given offset in the buffer and returns
 * it as a system time (milliseconds since January 1, 1970).
 */

Body of Frist Method:
{
    long seconds = read32(buffer, offset);
    long fraction = read32(buffer, offset + 4);
    return ((seconds - OFFSET_1900_TO_1970) * 1000) + ((fraction * 1000L) / 0x100000000L);
}
Body of Second Method:
{
    long seconds = read32(buffer, offset);
    long fraction = read32(buffer, offset + 4);
    // Special case: zero means zero.
    if (seconds == 0 && fraction == 0) {
        return 0;
    }
    return ((seconds - OFFSET_1900_TO_1970) * 1000) + ((fraction * 1000L) / 0x100000000L);
}
------------------------
Find a silently evolved API code:android.media.tv.TvTrackInfo.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Creates a {@link TvTrackInfo} instance with the specified fields.
 *
 * @return The new {@link TvTrackInfo} instance
 */

Body of Frist Method:
{
    return new TvTrackInfo(mType, mId, mLanguage, mDescription, mAudioChannelCount, mAudioSampleRate, mVideoWidth, mVideoHeight, mVideoFrameRate, mVideoPixelAspectRatio, mExtra);
}
Body of Second Method:
{
    return new TvTrackInfo(mType, mId, mLanguage, mDescription, mAudioChannelCount, mAudioSampleRate, mVideoWidth, mVideoHeight, mVideoFrameRate, mVideoPixelAspectRatio, mVideoActiveFormatDescription, mExtra);
}
------------------------
Find a silently evolved API code:android.text.style.SuggestionSpan.writeToParcelInternal:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    dest.writeStringArray(mSuggestions);
    dest.writeInt(mFlags);
    dest.writeString(mLocaleString);
    dest.writeString(mNotificationTargetClassName);
    dest.writeString(mNotificationTargetPackageName);
    dest.writeInt(mHashCode);
    dest.writeInt(mEasyCorrectUnderlineColor);
    dest.writeFloat(mEasyCorrectUnderlineThickness);
    dest.writeInt(mMisspelledUnderlineColor);
    dest.writeFloat(mMisspelledUnderlineThickness);
    dest.writeInt(mAutoCorrectionUnderlineColor);
    dest.writeFloat(mAutoCorrectionUnderlineThickness);
}
Body of Second Method:
{
    dest.writeStringArray(mSuggestions);
    dest.writeInt(mFlags);
    dest.writeString(mLocaleStringForCompatibility);
    dest.writeString(mLanguageTag);
    dest.writeString(mNotificationTargetClassName);
    dest.writeString(mNotificationTargetPackageName);
    dest.writeInt(mHashCode);
    dest.writeInt(mEasyCorrectUnderlineColor);
    dest.writeFloat(mEasyCorrectUnderlineThickness);
    dest.writeInt(mMisspelledUnderlineColor);
    dest.writeFloat(mMisspelledUnderlineThickness);
    dest.writeInt(mAutoCorrectionUnderlineColor);
    dest.writeFloat(mAutoCorrectionUnderlineThickness);
}
------------------------
Find a silently evolved API code:android.text.TextUtils.getLayoutDirectionFromLocale:COMMENT
Method Modifier: public      static      
Comment:/**
 * Return the layout direction for a given Locale
 *
 * @param locale the Locale for which we want the layout direction. Can be null.
 * @return the layout direction. This may be one of:
 * {@link android.view.View#LAYOUT_DIRECTION_LTR} or
 * {@link android.view.View#LAYOUT_DIRECTION_RTL}.
 *
 * Be careful: this code will need to be updated when vertical scripts will be supported
 */

Body of Frist Method:
{
    if (locale != null && !locale.equals(Locale.ROOT)) {
        final String scriptSubtag = ICU.addLikelySubtags(locale).getScript();
        if (scriptSubtag == null)
            return getLayoutDirectionFromFirstChar(locale);
        if (scriptSubtag.equalsIgnoreCase(ARAB_SCRIPT_SUBTAG) || scriptSubtag.equalsIgnoreCase(HEBR_SCRIPT_SUBTAG)) {
            return View.LAYOUT_DIRECTION_RTL;
        }
    }
    // If forcing into RTL layout mode, return RTL as default, else LTR
    return SystemProperties.getBoolean(Settings.Global.DEVELOPMENT_FORCE_RTL, false) ? View.LAYOUT_DIRECTION_RTL : View.LAYOUT_DIRECTION_LTR;
}
Body of Second Method:
{
    return ((locale != null && !locale.equals(Locale.ROOT) && ULocale.forLocale(locale).isRightToLeft()) || // If forcing into RTL layout mode, return RTL as default
    SystemProperties.getBoolean(Settings.Global.DEVELOPMENT_FORCE_RTL, false)) ? View.LAYOUT_DIRECTION_RTL : View.LAYOUT_DIRECTION_LTR;
}
------------------------
Find a silently evolved API code:android.app.ActivityManager.isInHomeStack:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    try {
        return ActivityManagerNative.getDefault().isInHomeStack(taskId);
    } catch (RemoteException e) {
        // System dead, we will be dead too soon!
        return false;
    }
}
Body of Second Method:
{
    try {
        return ActivityManagerNative.getDefault().isInHomeStack(taskId);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.graphics.drawable.NinePatchDrawable.updateLocalState:COMMENT
Method Modifier: private     
Comment:/**
 * Initializes local dynamic properties from state.
 */

Body of Frist Method:
{
    final NinePatchState state = mNinePatchState;
    if (res != null) {
        final int densityDpi = res.getDisplayMetrics().densityDpi;
        mTargetDensity = densityDpi == 0 ? DisplayMetrics.DENSITY_DEFAULT : densityDpi;
    } else {
        mTargetDensity = state.mTargetDensity;
    }
    // If we can, avoid calling any methods that initialize Paint.
    if (state.mDither != DEFAULT_DITHER) {
        setDither(state.mDither);
    }
    // Make a local copy of the padding.
    if (state.mPadding != null) {
        mPadding = new Rect(state.mPadding);
    }
    mTintFilter = updateTintFilter(mTintFilter, state.mTint, state.mTintMode);
    setNinePatch(state.mNinePatch);
}
Body of Second Method:
{
    final NinePatchState state = mNinePatchState;
    // If we can, avoid calling any methods that initialize Paint.
    if (state.mDither != DEFAULT_DITHER) {
        setDither(state.mDither);
    }
    // available).
    if (res == null && state.mNinePatch != null) {
        mTargetDensity = state.mNinePatch.getDensity();
    } else {
        mTargetDensity = Drawable.resolveDensity(res, mTargetDensity);
    }
    mTintFilter = updateTintFilter(mTintFilter, state.mTint, state.mTintMode);
    computeBitmapSize();
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiEnterpriseConfig.getEapMethod:COMMENT
Method Modifier: public      
Comment:/**
 * Get the eap method.
 * @return eap method configured
 */

Body of Frist Method:
{
    String eapMethod = mFields.get(EAP_KEY);
    return getStringIndex(Eap.strings, eapMethod, Eap.NONE);
}
Body of Second Method:
{
    return mEapMethod;
}
------------------------
Find a silently evolved API code:android.graphics.Canvas.setHighContrastText:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
}
Body of Second Method:
{
    native_setHighContrastText(mNativeCanvasWrapper, highContrastText);
}
------------------------
Find a silently evolved API code:android.net.ConnectivityManager.getTetherableBluetoothRegexs:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the list of regular expressions that define any tetherable
 * Bluetooth network interfaces.  If Bluetooth tethering is not supported by the
 * device, this list should be empty.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
 *
 * @return an array of 0 or more regular expression Strings defining
 * what interfaces are considered tetherable bluetooth interfaces.
 *
 * {@hide}
 */

Body of Frist Method:
{
    try {
        return mService.getTetherableBluetoothRegexs();
    } catch (RemoteException e) {
        return new String[0];
    }
}
Body of Second Method:
{
    try {
        return mService.getTetherableBluetoothRegexs();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.net.ConnectivityManager.getLastTetherError:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get a more detailed error code after a Tethering or Untethering
 * request asynchronously failed.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
 *
 * @param iface The name of the interface of interest
 * @return error The error code of the last error tethering or untethering the named
 * interface
 *
 * {@hide}
 */

Body of Frist Method:
{
    try {
        return mService.getLastTetherError(iface);
    } catch (RemoteException e) {
        return TETHER_ERROR_SERVICE_UNAVAIL;
    }
}
Body of Second Method:
{
    try {
        return mService.getLastTetherError(iface);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiManager.getAllowScansWithTraffic:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get setting for allowing Scans when traffic is ongoing.
 * @hide
 */

Body of Frist Method:
{
    try {
        return mService.getAllowScansWithTraffic();
    } catch (RemoteException e) {
        return 0;
    }
}
Body of Second Method:
{
    try {
        return mService.getAllowScansWithTraffic();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.telephony.TelephonyManager.getPhoneType:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * This function returns the type of the phone, depending
 * on the network mode.
 *
 * @param networkMode
 * @return Phone Type
 *
 * @hide
 */

Body of Frist Method:
{
    switch(networkMode) {
        case RILConstants.NETWORK_MODE_CDMA:
        case RILConstants.NETWORK_MODE_CDMA_NO_EVDO:
        case RILConstants.NETWORK_MODE_EVDO_NO_CDMA:
            return PhoneConstants.PHONE_TYPE_CDMA;
        case RILConstants.NETWORK_MODE_WCDMA_PREF:
        case RILConstants.NETWORK_MODE_GSM_ONLY:
        case RILConstants.NETWORK_MODE_WCDMA_ONLY:
        case RILConstants.NETWORK_MODE_GSM_UMTS:
        case RILConstants.NETWORK_MODE_LTE_GSM_WCDMA:
        case RILConstants.NETWORK_MODE_LTE_WCDMA:
        case RILConstants.NETWORK_MODE_LTE_CDMA_EVDO_GSM_WCDMA:
            return PhoneConstants.PHONE_TYPE_GSM;
        // Use CDMA Phone for the global mode including CDMA
        case RILConstants.NETWORK_MODE_GLOBAL:
        case RILConstants.NETWORK_MODE_LTE_CDMA_EVDO:
            return PhoneConstants.PHONE_TYPE_CDMA;
        case RILConstants.NETWORK_MODE_LTE_ONLY:
            if (getLteOnCdmaModeStatic() == PhoneConstants.LTE_ON_CDMA_TRUE) {
                return PhoneConstants.PHONE_TYPE_CDMA;
            } else {
                return PhoneConstants.PHONE_TYPE_GSM;
            }
        default:
            return PhoneConstants.PHONE_TYPE_GSM;
    }
}
Body of Second Method:
{
    switch(networkMode) {
        case RILConstants.NETWORK_MODE_CDMA:
        case RILConstants.NETWORK_MODE_CDMA_NO_EVDO:
        case RILConstants.NETWORK_MODE_EVDO_NO_CDMA:
            return PhoneConstants.PHONE_TYPE_CDMA;
        case RILConstants.NETWORK_MODE_WCDMA_PREF:
        case RILConstants.NETWORK_MODE_GSM_ONLY:
        case RILConstants.NETWORK_MODE_WCDMA_ONLY:
        case RILConstants.NETWORK_MODE_GSM_UMTS:
        case RILConstants.NETWORK_MODE_LTE_GSM_WCDMA:
        case RILConstants.NETWORK_MODE_LTE_WCDMA:
        case RILConstants.NETWORK_MODE_LTE_CDMA_EVDO_GSM_WCDMA:
        case RILConstants.NETWORK_MODE_TDSCDMA_ONLY:
        case RILConstants.NETWORK_MODE_TDSCDMA_WCDMA:
        case RILConstants.NETWORK_MODE_LTE_TDSCDMA:
        case RILConstants.NETWORK_MODE_TDSCDMA_GSM:
        case RILConstants.NETWORK_MODE_LTE_TDSCDMA_GSM:
        case RILConstants.NETWORK_MODE_TDSCDMA_GSM_WCDMA:
        case RILConstants.NETWORK_MODE_LTE_TDSCDMA_WCDMA:
        case RILConstants.NETWORK_MODE_LTE_TDSCDMA_GSM_WCDMA:
        case RILConstants.NETWORK_MODE_LTE_TDSCDMA_CDMA_EVDO_GSM_WCDMA:
            return PhoneConstants.PHONE_TYPE_GSM;
        // Use CDMA Phone for the global mode including CDMA
        case RILConstants.NETWORK_MODE_GLOBAL:
        case RILConstants.NETWORK_MODE_LTE_CDMA_EVDO:
        case RILConstants.NETWORK_MODE_TDSCDMA_CDMA_EVDO_GSM_WCDMA:
            return PhoneConstants.PHONE_TYPE_CDMA;
        case RILConstants.NETWORK_MODE_LTE_ONLY:
            if (getLteOnCdmaModeStatic() == PhoneConstants.LTE_ON_CDMA_TRUE) {
                return PhoneConstants.PHONE_TYPE_CDMA;
            } else {
                return PhoneConstants.PHONE_TYPE_GSM;
            }
        default:
            return PhoneConstants.PHONE_TYPE_GSM;
    }
}
------------------------
Find a silently evolved API code:android.nfc.NfcActivityManager.createBeamShareData:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Callback from NFC service, usually on binder thread
 */

Body of Frist Method:
{
    NfcAdapter.CreateNdefMessageCallback ndefCallback;
    NfcAdapter.CreateBeamUrisCallback urisCallback;
    NdefMessage message;
    Activity activity;
    Uri[] uris;
    int flags;
    NfcEvent event = new NfcEvent(mAdapter, peerLlcpVersion);
    synchronized (NfcActivityManager.this) {
        NfcActivityState state = findResumedActivityState();
        if (state == null)
            return null;
        ndefCallback = state.ndefMessageCallback;
        urisCallback = state.uriCallback;
        message = state.ndefMessage;
        uris = state.uris;
        flags = state.flags;
        activity = state.activity;
    }
    // Make callbacks without lock
    if (ndefCallback != null) {
        message = ndefCallback.createNdefMessage(event);
    }
    if (urisCallback != null) {
        uris = urisCallback.createBeamUris(event);
        if (uris != null) {
            ArrayList<Uri> validUris = new ArrayList<Uri>();
            for (Uri uri : uris) {
                if (uri == null) {
                    Log.e(TAG, "Uri not allowed to be null.");
                    continue;
                }
                String scheme = uri.getScheme();
                if (scheme == null || (!scheme.equalsIgnoreCase("file") && !scheme.equalsIgnoreCase("content"))) {
                    Log.e(TAG, "Uri needs to have " + "either scheme file or scheme content");
                    continue;
                }
                uri = ContentProvider.maybeAddUserId(uri, UserHandle.myUserId());
                validUris.add(uri);
            }
            uris = validUris.toArray(new Uri[validUris.size()]);
        }
    }
    if (uris != null && uris.length > 0) {
        for (Uri uri : uris) {
            // Grant the NFC process permission to read these URIs
            activity.grantUriPermission("com.android.nfc", uri, Intent.FLAG_GRANT_READ_URI_PERMISSION);
        }
    }
    return new BeamShareData(message, uris, new UserHandle(UserHandle.myUserId()), flags);
}
Body of Second Method:
{
    NfcAdapter.CreateNdefMessageCallback ndefCallback;
    NfcAdapter.CreateBeamUrisCallback urisCallback;
    NdefMessage message;
    Activity activity;
    Uri[] uris;
    int flags;
    NfcEvent event = new NfcEvent(mAdapter, peerLlcpVersion);
    synchronized (NfcActivityManager.this) {
        NfcActivityState state = findResumedActivityState();
        if (state == null)
            return null;
        ndefCallback = state.ndefMessageCallback;
        urisCallback = state.uriCallback;
        message = state.ndefMessage;
        uris = state.uris;
        flags = state.flags;
        activity = state.activity;
    }
    final long ident = Binder.clearCallingIdentity();
    try {
        // Make callbacks without lock
        if (ndefCallback != null) {
            message = ndefCallback.createNdefMessage(event);
        }
        if (urisCallback != null) {
            uris = urisCallback.createBeamUris(event);
            if (uris != null) {
                ArrayList<Uri> validUris = new ArrayList<Uri>();
                for (Uri uri : uris) {
                    if (uri == null) {
                        Log.e(TAG, "Uri not allowed to be null.");
                        continue;
                    }
                    String scheme = uri.getScheme();
                    if (scheme == null || (!scheme.equalsIgnoreCase("file") && !scheme.equalsIgnoreCase("content"))) {
                        Log.e(TAG, "Uri needs to have " + "either scheme file or scheme content");
                        continue;
                    }
                    uri = ContentProvider.maybeAddUserId(uri, UserHandle.myUserId());
                    validUris.add(uri);
                }
                uris = validUris.toArray(new Uri[validUris.size()]);
            }
        }
        if (uris != null && uris.length > 0) {
            for (Uri uri : uris) {
                // Grant the NFC process permission to read these URIs
                activity.grantUriPermission("com.android.nfc", uri, Intent.FLAG_GRANT_READ_URI_PERMISSION);
            }
        }
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
    return new BeamShareData(message, uris, new UserHandle(UserHandle.myUserId()), flags);
}
------------------------
Find a silently evolved API code:android.mtp.MtpObjectInfo.getThumbPixWidth:COMMENT
Method Modifier: public      final       
Comment:/**
 * Returns the width of the MTP object's thumbnail in pixels
 * Will be zero for objects with no thumbnail
 *
 * @return the thumbnail width
 */

Body of Frist Method:
{
    return mThumbPixWidth;
}
Body of Second Method:
{
    Preconditions.checkState(mThumbPixWidth >= 0);
    return mThumbPixWidth;
}
------------------------
Find a silently evolved API code:android.view.inputmethod.CursorAnchorInfo.Builder.setMatrix:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the matrix that transforms local coordinates into screen coordinates.
 * @param matrix transformation matrix from local coordinates into screen coordinates. null
 * is interpreted as an identity matrix.
 */

Body of Frist Method:
{
    mMatrix.set(matrix != null ? matrix : Matrix.IDENTITY_MATRIX);
    mMatrixInitialized = true;
    return this;
}
Body of Second Method:
{
    if (mMatrixValues == null) {
        mMatrixValues = new float[9];
    }
    (matrix != null ? matrix : Matrix.IDENTITY_MATRIX).getValues(mMatrixValues);
    mMatrixInitialized = true;
    return this;
}
------------------------
Find a silently evolved API code:android.service.voice.VoiceInteractionSession.startVoiceActivity:COMMENT
Method Modifier: public      
Comment:/**
 * Ask that a new activity be started for voice interaction.  This will create a
 * new dedicated task in the activity manager for this voice interaction session;
 * this means that {@link Intent#FLAG_ACTIVITY_NEW_TASK Intent.FLAG_ACTIVITY_NEW_TASK}
 * will be set for you to make it a new task.
 *
 * <p>The newly started activity will be displayed to the user in a special way, as
 * a layer under the voice interaction UI.</p>
 *
 * <p>As the voice activity runs, it can retrieve a {@link android.app.VoiceInteractor}
 * through which it can perform voice interactions through your session.  These requests
 * for voice interactions will appear as callbacks on {@link #onGetSupportedCommands},
 * {@link #onRequestConfirmation}, {@link #onRequestPickOption},
 * {@link #onRequestCompleteVoice}, {@link #onRequestAbortVoice},
 * or {@link #onRequestCommand}
 *
 * <p>You will receive a call to {@link #onTaskStarted} when the task starts up
 * and {@link #onTaskFinished} when the last activity has finished.
 *
 * @param intent The Intent to start this voice interaction.  The given Intent will
 * always have {@link Intent#CATEGORY_VOICE Intent.CATEGORY_VOICE} added to it, since
 * this is part of a voice interaction.
 */

Body of Frist Method:
{
    if (mToken == null) {
        throw new IllegalStateException("Can't call before onCreate()");
    }
    try {
        intent.migrateExtraStreamToClipData();
        intent.prepareToLeaveProcess();
        int res = mSystemService.startVoiceActivity(mToken, intent, intent.resolveType(mContext.getContentResolver()));
        Instrumentation.checkStartActivityResult(res, intent);
    } catch (RemoteException e) {
    }
}
Body of Second Method:
{
    if (mToken == null) {
        throw new IllegalStateException("Can't call before onCreate()");
    }
    try {
        intent.migrateExtraStreamToClipData();
        intent.prepareToLeaveProcess(mContext);
        int res = mSystemService.startVoiceActivity(mToken, intent, intent.resolveType(mContext.getContentResolver()));
        Instrumentation.checkStartActivityResult(res, intent);
    } catch (RemoteException e) {
    }
}
------------------------
Find a silently evolved API code:android.content.IntentSender.sendIntent:COMMENT
Method Modifier: public      
Comment:/**
 * Perform the operation associated with this IntentSender, allowing the
 * caller to specify information about the Intent to use and be notified
 * when the send has completed.
 *
 * @param context The Context of the caller.  This may be null if
 * <var>intent</var> is also null.
 * @param code Result code to supply back to the IntentSender's target.
 * @param intent Additional Intent data.  See {@link Intent#fillIn
 * Intent.fillIn()} for information on how this is applied to the
 * original Intent.  Use null to not modify the original Intent.
 * @param onFinished The object to call back on when the send has
 * completed, or null for no callback.
 * @param handler Handler identifying the thread on which the callback
 * should happen.  If null, the callback will happen from the thread
 * pool of the process.
 * @param requiredPermission Name of permission that a recipient of the PendingIntent
 * is required to hold.  This is only valid for broadcast intents, and
 * corresponds to the permission argument in
 * {@link Context#sendBroadcast(Intent, String) Context.sendOrderedBroadcast(Intent, String)}.
 * If null, no permission is required.
 *
 * @throws SendIntentException Throws CanceledIntentException if the IntentSender
 * is no longer allowing more intents to be sent through it.
 */

Body of Frist Method:
{
    try {
        String resolvedType = intent != null ? intent.resolveTypeIfNeeded(context.getContentResolver()) : null;
        int res = mTarget.send(code, intent, resolvedType, onFinished != null ? new FinishedDispatcher(this, onFinished, handler) : null, requiredPermission, null);
        if (res < 0) {
            throw new SendIntentException();
        }
    } catch (RemoteException e) {
        throw new SendIntentException();
    }
}
Body of Second Method:
{
    try {
        String resolvedType = intent != null ? intent.resolveTypeIfNeeded(context.getContentResolver()) : null;
        int res = ActivityManagerNative.getDefault().sendIntentSender(mTarget, code, intent, resolvedType, onFinished != null ? new FinishedDispatcher(this, onFinished, handler) : null, requiredPermission, null);
        if (res < 0) {
            throw new SendIntentException();
        }
    } catch (RemoteException e) {
        throw new SendIntentException();
    }
}
------------------------
Find a silently evolved API code:android.app.Activity.onDestroy:COMMENT
Method Modifier: protected   
Comment:/**
 * Perform any final cleanup before an activity is destroyed.  This can
 * happen either because the activity is finishing (someone called
 * {@link #finish} on it, or because the system is temporarily destroying
 * this instance of the activity to save space.  You can distinguish
 * between these two scenarios with the {@link #isFinishing} method.
 *
 * <p><em>Note: do not count on this method being called as a place for
 * saving data! For example, if an activity is editing data in a content
 * provider, those edits should be committed in either {@link #onPause} or
 * {@link #onSaveInstanceState}, not here.</em> This method is usually implemented to
 * free resources like threads that are associated with an activity, so
 * that a destroyed activity does not leave such things around while the
 * rest of its application is still running.  There are situations where
 * the system will simply kill the activity's hosting process without
 * calling this method (or any others) in it, so it should not be used to
 * do things that are intended to remain around after the process goes
 * away.
 *
 * <p><em>Derived classes must call through to the super class's
 * implementation of this method.  If they do not, an exception will be
 * thrown.</em></p>
 *
 * @see #onPause
 * @see #onStop
 * @see #finish
 * @see #isFinishing
 */

Body of Frist Method:
{
    if (DEBUG_LIFECYCLE)
        Slog.v(TAG, "onDestroy " + this);
    mCalled = true;
    // dismiss any dialogs we are managing.
    if (mManagedDialogs != null) {
        final int numDialogs = mManagedDialogs.size();
        for (int i = 0; i < numDialogs; i++) {
            final ManagedDialog md = mManagedDialogs.valueAt(i);
            if (md.mDialog.isShowing()) {
                md.mDialog.dismiss();
            }
        }
        mManagedDialogs = null;
    }
    // close any cursors we are managing.
    synchronized (mManagedCursors) {
        int numCursors = mManagedCursors.size();
        for (int i = 0; i < numCursors; i++) {
            ManagedCursor c = mManagedCursors.get(i);
            if (c != null) {
                c.mCursor.close();
            }
        }
        mManagedCursors.clear();
    }
    // Close any open search dialog
    if (mSearchManager != null) {
        mSearchManager.stopSearch();
    }
    getApplication().dispatchActivityDestroyed(this);
}
Body of Second Method:
{
    if (DEBUG_LIFECYCLE)
        Slog.v(TAG, "onDestroy " + this);
    mCalled = true;
    // dismiss any dialogs we are managing.
    if (mManagedDialogs != null) {
        final int numDialogs = mManagedDialogs.size();
        for (int i = 0; i < numDialogs; i++) {
            final ManagedDialog md = mManagedDialogs.valueAt(i);
            if (md.mDialog.isShowing()) {
                md.mDialog.dismiss();
            }
        }
        mManagedDialogs = null;
    }
    // close any cursors we are managing.
    synchronized (mManagedCursors) {
        int numCursors = mManagedCursors.size();
        for (int i = 0; i < numCursors; i++) {
            ManagedCursor c = mManagedCursors.get(i);
            if (c != null) {
                c.mCursor.close();
            }
        }
        mManagedCursors.clear();
    }
    // Close any open search dialog
    if (mSearchManager != null) {
        mSearchManager.stopSearch();
    }
    if (mActionBar != null) {
        mActionBar.onDestroy();
    }
    getApplication().dispatchActivityDestroyed(this);
}
------------------------
Find a silently evolved API code:android.telephony.CellIdentityWcdma.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Implement the Parcelable interface
 */

Body of Frist Method:
{
    if (DBG)
        log("writeToParcel(Parcel, int): " + toString());
    dest.writeInt(mMcc);
    dest.writeInt(mMnc);
    dest.writeInt(mLac);
    dest.writeInt(mCid);
    dest.writeInt(mPsc);
}
Body of Second Method:
{
    if (DBG)
        log("writeToParcel(Parcel, int): " + toString());
    dest.writeInt(mMcc);
    dest.writeInt(mMnc);
    dest.writeInt(mLac);
    dest.writeInt(mCid);
    dest.writeInt(mPsc);
    dest.writeInt(mUarfcn);
}
------------------------
Find a silently evolved API code:android.view.SurfaceView.updateWindow:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (!mHaveFrame) {
        return;
    }
    ViewRootImpl viewRoot = getViewRootImpl();
    if (viewRoot != null) {
        mTranslator = viewRoot.mTranslator;
    }
    if (mTranslator != null) {
        mSurface.setCompatibilityTranslator(mTranslator);
    }
    int myWidth = mRequestedWidth;
    if (myWidth <= 0)
        myWidth = getWidth();
    int myHeight = mRequestedHeight;
    if (myHeight <= 0)
        myHeight = getHeight();
    getLocationInWindow(mLocation);
    final boolean creating = mWindow == null;
    final boolean formatChanged = mFormat != mRequestedFormat;
    final boolean sizeChanged = mWidth != myWidth || mHeight != myHeight;
    final boolean visibleChanged = mVisible != mRequestedVisible;
    if (force || creating || formatChanged || sizeChanged || visibleChanged || mLeft != mLocation[0] || mTop != mLocation[1] || mUpdateWindowNeeded || mReportDrawNeeded || redrawNeeded) {
        if (DEBUG)
            Log.i(TAG, "Changes: creating=" + creating + " format=" + formatChanged + " size=" + sizeChanged + " visible=" + visibleChanged + " left=" + (mLeft != mLocation[0]) + " top=" + (mTop != mLocation[1]));
        try {
            final boolean visible = mVisible = mRequestedVisible;
            mLeft = mLocation[0];
            mTop = mLocation[1];
            mWidth = myWidth;
            mHeight = myHeight;
            mFormat = mRequestedFormat;
            // Scaling/Translate window's layout here because mLayout is not used elsewhere.
            // Places the window relative
            mLayout.x = mLeft;
            mLayout.y = mTop;
            mLayout.width = getWidth();
            mLayout.height = getHeight();
            if (mTranslator != null) {
                mTranslator.translateLayoutParamsInAppWindowToScreen(mLayout);
            }
            mLayout.format = mRequestedFormat;
            mLayout.flags |= WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_SCALED | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;
            if (!getContext().getResources().getCompatibilityInfo().supportsScreen()) {
                mLayout.privateFlags |= WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;
            }
            mLayout.privateFlags |= WindowManager.LayoutParams.PRIVATE_FLAG_NO_MOVE_ANIMATION;
            if (mWindow == null) {
                Display display = getDisplay();
                mWindow = new MyWindow(this);
                mLayout.type = mWindowType;
                mLayout.gravity = Gravity.START | Gravity.TOP;
                mSession.addToDisplayWithoutInputChannel(mWindow, mWindow.mSeq, mLayout, mVisible ? VISIBLE : GONE, display.getDisplayId(), mContentInsets, mStableInsets);
            }
            boolean realSizeChanged;
            boolean reportDrawNeeded;
            int relayoutResult;
            mSurfaceLock.lock();
            try {
                mUpdateWindowNeeded = false;
                reportDrawNeeded = mReportDrawNeeded;
                mReportDrawNeeded = false;
                mDrawingStopped = !visible;
                if (DEBUG)
                    Log.i(TAG, "Cur surface: " + mSurface);
                relayoutResult = mSession.relayout(mWindow, mWindow.mSeq, mLayout, mWidth, mHeight, visible ? VISIBLE : GONE, WindowManagerGlobal.RELAYOUT_DEFER_SURFACE_DESTROY, mWinFrame, mOverscanInsets, mContentInsets, mVisibleInsets, mStableInsets, mOutsets, mConfiguration, mNewSurface);
                if ((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0) {
                    reportDrawNeeded = true;
                }
                if (DEBUG)
                    Log.i(TAG, "New surface: " + mNewSurface + ", vis=" + visible + ", frame=" + mWinFrame);
                mSurfaceFrame.left = 0;
                mSurfaceFrame.top = 0;
                if (mTranslator == null) {
                    mSurfaceFrame.right = mWinFrame.width();
                    mSurfaceFrame.bottom = mWinFrame.height();
                } else {
                    float appInvertedScale = mTranslator.applicationInvertedScale;
                    mSurfaceFrame.right = (int) (mWinFrame.width() * appInvertedScale + 0.5f);
                    mSurfaceFrame.bottom = (int) (mWinFrame.height() * appInvertedScale + 0.5f);
                }
                final int surfaceWidth = mSurfaceFrame.right;
                final int surfaceHeight = mSurfaceFrame.bottom;
                realSizeChanged = mLastSurfaceWidth != surfaceWidth || mLastSurfaceHeight != surfaceHeight;
                mLastSurfaceWidth = surfaceWidth;
                mLastSurfaceHeight = surfaceHeight;
            } finally {
                mSurfaceLock.unlock();
            }
            try {
                redrawNeeded |= creating | reportDrawNeeded;
                SurfaceHolder.Callback[] callbacks = null;
                final boolean surfaceChanged = (relayoutResult & WindowManagerGlobal.RELAYOUT_RES_SURFACE_CHANGED) != 0;
                if (mSurfaceCreated && (surfaceChanged || (!visible && visibleChanged))) {
                    mSurfaceCreated = false;
                    if (mSurface.isValid()) {
                        if (DEBUG)
                            Log.i(TAG, "visibleChanged -- surfaceDestroyed");
                        callbacks = getSurfaceCallbacks();
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceDestroyed(mSurfaceHolder);
                        }
                    }
                }
                mSurface.transferFrom(mNewSurface);
                if (visible && mSurface.isValid()) {
                    if (!mSurfaceCreated && (surfaceChanged || visibleChanged)) {
                        mSurfaceCreated = true;
                        mIsCreating = true;
                        if (DEBUG)
                            Log.i(TAG, "visibleChanged -- surfaceCreated");
                        if (callbacks == null) {
                            callbacks = getSurfaceCallbacks();
                        }
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceCreated(mSurfaceHolder);
                        }
                    }
                    if (creating || formatChanged || sizeChanged || visibleChanged || realSizeChanged) {
                        if (DEBUG)
                            Log.i(TAG, "surfaceChanged -- format=" + mFormat + " w=" + myWidth + " h=" + myHeight);
                        if (callbacks == null) {
                            callbacks = getSurfaceCallbacks();
                        }
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceChanged(mSurfaceHolder, mFormat, myWidth, myHeight);
                        }
                    }
                    if (redrawNeeded) {
                        if (DEBUG)
                            Log.i(TAG, "surfaceRedrawNeeded");
                        if (callbacks == null) {
                            callbacks = getSurfaceCallbacks();
                        }
                        for (SurfaceHolder.Callback c : callbacks) {
                            if (c instanceof SurfaceHolder.Callback2) {
                                ((SurfaceHolder.Callback2) c).surfaceRedrawNeeded(mSurfaceHolder);
                            }
                        }
                    }
                }
            } finally {
                mIsCreating = false;
                if (redrawNeeded) {
                    if (DEBUG)
                        Log.i(TAG, "finishedDrawing");
                    mSession.finishDrawing(mWindow);
                }
                mSession.performDeferredDestroy(mWindow);
            }
        } catch (RemoteException ex) {
        }
        if (DEBUG)
            Log.v(TAG, "Layout: x=" + mLayout.x + " y=" + mLayout.y + " w=" + mLayout.width + " h=" + mLayout.height + ", frame=" + mSurfaceFrame);
    }
}
Body of Second Method:
{
    if (!mHaveFrame) {
        return;
    }
    ViewRootImpl viewRoot = getViewRootImpl();
    if (viewRoot != null) {
        mTranslator = viewRoot.mTranslator;
    }
    if (mTranslator != null) {
        mSurface.setCompatibilityTranslator(mTranslator);
    }
    int myWidth = mRequestedWidth;
    if (myWidth <= 0)
        myWidth = getWidth();
    int myHeight = mRequestedHeight;
    if (myHeight <= 0)
        myHeight = getHeight();
    final boolean creating = mWindow == null;
    final boolean formatChanged = mFormat != mRequestedFormat;
    final boolean sizeChanged = mWindowSpaceWidth != myWidth || mWindowSpaceHeight != myHeight;
    final boolean visibleChanged = mVisible != mRequestedVisible;
    final boolean layoutSizeChanged = getWidth() != mLayout.width || getHeight() != mLayout.height;
    if (force || creating || formatChanged || sizeChanged || visibleChanged || mUpdateWindowNeeded || mReportDrawNeeded || redrawNeeded) {
        getLocationInWindow(mLocation);
        if (DEBUG)
            Log.i(TAG, System.identityHashCode(this) + " " + "Changes: creating=" + creating + " format=" + formatChanged + " size=" + sizeChanged + " visible=" + visibleChanged + " left=" + (mWindowSpaceLeft != mLocation[0]) + " top=" + (mWindowSpaceTop != mLocation[1]));
        try {
            final boolean visible = mVisible = mRequestedVisible;
            mWindowSpaceLeft = mLocation[0];
            mWindowSpaceTop = mLocation[1];
            mWindowSpaceWidth = myWidth;
            mWindowSpaceHeight = myHeight;
            mFormat = mRequestedFormat;
            // Scaling/Translate window's layout here because mLayout is not used elsewhere.
            // Places the window relative
            mLayout.x = mWindowSpaceLeft;
            mLayout.y = mWindowSpaceTop;
            mLayout.width = getWidth();
            mLayout.height = getHeight();
            if (mTranslator != null) {
                mTranslator.translateLayoutParamsInAppWindowToScreen(mLayout);
            }
            mLayout.format = mRequestedFormat;
            mLayout.flags |= WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_SCALED | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;
            if (!creating && !force && !mUpdateWindowNeeded && !sizeChanged) {
                mLayout.privateFlags |= WindowManager.LayoutParams.PRIVATE_FLAG_PRESERVE_GEOMETRY;
            } else {
                mLayout.privateFlags &= ~WindowManager.LayoutParams.PRIVATE_FLAG_PRESERVE_GEOMETRY;
            }
            if (!getContext().getResources().getCompatibilityInfo().supportsScreen()) {
                mLayout.privateFlags |= WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;
            }
            mLayout.privateFlags |= WindowManager.LayoutParams.PRIVATE_FLAG_NO_MOVE_ANIMATION | WindowManager.LayoutParams.PRIVATE_FLAG_LAYOUT_CHILD_WINDOW_IN_PARENT_FRAME;
            if (mWindow == null) {
                Display display = getDisplay();
                mWindow = new MyWindow(this);
                mLayout.type = mWindowType;
                mLayout.gravity = Gravity.START | Gravity.TOP;
                mSession.addToDisplayWithoutInputChannel(mWindow, mWindow.mSeq, mLayout, mVisible ? VISIBLE : GONE, display.getDisplayId(), mContentInsets, mStableInsets);
            }
            boolean realSizeChanged;
            boolean reportDrawNeeded;
            int relayoutResult;
            mSurfaceLock.lock();
            try {
                mUpdateWindowNeeded = false;
                reportDrawNeeded = mReportDrawNeeded;
                mReportDrawNeeded = false;
                mDrawingStopped = !visible;
                if (DEBUG)
                    Log.i(TAG, System.identityHashCode(this) + " " + "Cur surface: " + mSurface);
                relayoutResult = mSession.relayout(mWindow, mWindow.mSeq, mLayout, mWindowSpaceWidth, mWindowSpaceHeight, visible ? VISIBLE : GONE, WindowManagerGlobal.RELAYOUT_DEFER_SURFACE_DESTROY, mWinFrame, mOverscanInsets, mContentInsets, mVisibleInsets, mStableInsets, mOutsets, mBackdropFrame, mConfiguration, mNewSurface);
                if ((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0) {
                    reportDrawNeeded = true;
                }
                if (DEBUG)
                    Log.i(TAG, System.identityHashCode(this) + " " + "New surface: " + mNewSurface + ", vis=" + visible + ", frame=" + mWinFrame);
                mSurfaceFrame.left = 0;
                mSurfaceFrame.top = 0;
                if (mTranslator == null) {
                    mSurfaceFrame.right = mWinFrame.width();
                    mSurfaceFrame.bottom = mWinFrame.height();
                } else {
                    float appInvertedScale = mTranslator.applicationInvertedScale;
                    mSurfaceFrame.right = (int) (mWinFrame.width() * appInvertedScale + 0.5f);
                    mSurfaceFrame.bottom = (int) (mWinFrame.height() * appInvertedScale + 0.5f);
                }
                final int surfaceWidth = mSurfaceFrame.right;
                final int surfaceHeight = mSurfaceFrame.bottom;
                realSizeChanged = mLastSurfaceWidth != surfaceWidth || mLastSurfaceHeight != surfaceHeight;
                mLastSurfaceWidth = surfaceWidth;
                mLastSurfaceHeight = surfaceHeight;
            } finally {
                mSurfaceLock.unlock();
            }
            try {
                redrawNeeded |= creating | reportDrawNeeded;
                SurfaceHolder.Callback[] callbacks = null;
                final boolean surfaceChanged = (relayoutResult & WindowManagerGlobal.RELAYOUT_RES_SURFACE_CHANGED) != 0;
                if (mSurfaceCreated && (surfaceChanged || (!visible && visibleChanged))) {
                    mSurfaceCreated = false;
                    if (mSurface.isValid()) {
                        if (DEBUG)
                            Log.i(TAG, System.identityHashCode(this) + " " + "visibleChanged -- surfaceDestroyed");
                        callbacks = getSurfaceCallbacks();
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceDestroyed(mSurfaceHolder);
                        }
                    }
                }
                mSurface.transferFrom(mNewSurface);
                if (visible && mSurface.isValid()) {
                    if (!mSurfaceCreated && (surfaceChanged || visibleChanged)) {
                        mSurfaceCreated = true;
                        mIsCreating = true;
                        if (DEBUG)
                            Log.i(TAG, System.identityHashCode(this) + " " + "visibleChanged -- surfaceCreated");
                        if (callbacks == null) {
                            callbacks = getSurfaceCallbacks();
                        }
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceCreated(mSurfaceHolder);
                        }
                    }
                    if (creating || formatChanged || sizeChanged || visibleChanged || realSizeChanged) {
                        if (DEBUG)
                            Log.i(TAG, System.identityHashCode(this) + " " + "surfaceChanged -- format=" + mFormat + " w=" + myWidth + " h=" + myHeight);
                        if (callbacks == null) {
                            callbacks = getSurfaceCallbacks();
                        }
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceChanged(mSurfaceHolder, mFormat, myWidth, myHeight);
                        }
                    }
                    if (redrawNeeded) {
                        if (DEBUG)
                            Log.i(TAG, System.identityHashCode(this) + " " + "surfaceRedrawNeeded");
                        if (callbacks == null) {
                            callbacks = getSurfaceCallbacks();
                        }
                        for (SurfaceHolder.Callback c : callbacks) {
                            if (c instanceof SurfaceHolder.Callback2) {
                                ((SurfaceHolder.Callback2) c).surfaceRedrawNeeded(mSurfaceHolder);
                            }
                        }
                    }
                }
            } finally {
                mIsCreating = false;
                if (redrawNeeded) {
                    if (DEBUG)
                        Log.i(TAG, System.identityHashCode(this) + " " + "finishedDrawing");
                    mSession.finishDrawing(mWindow);
                }
                mSession.performDeferredDestroy(mWindow);
            }
        } catch (RemoteException ex) {
            Log.e(TAG, "Exception from relayout", ex);
        }
        if (DEBUG)
            Log.v(TAG, "Layout: x=" + mLayout.x + " y=" + mLayout.y + " w=" + mLayout.width + " h=" + mLayout.height + ", frame=" + mSurfaceFrame);
    } else {
        // Calculate the window position in case RT loses the window
        // and we need to fallback to a UI-thread driven position update
        getLocationInWindow(mLocation);
        final boolean positionChanged = mWindowSpaceLeft != mLocation[0] || mWindowSpaceTop != mLocation[1];
        if (positionChanged || layoutSizeChanged) {
            // Only the position has changed
            mWindowSpaceLeft = mLocation[0];
            mWindowSpaceTop = mLocation[1];
            // For our size changed check, we keep mLayout.width and mLayout.height
            // in view local space.
            mLocation[0] = mLayout.width = getWidth();
            mLocation[1] = mLayout.height = getHeight();
            transformFromViewToWindowSpace(mLocation);
            mWinFrame.set(mWindowSpaceLeft, mWindowSpaceTop, mLocation[0], mLocation[1]);
            if (mTranslator != null) {
                mTranslator.translateRectInAppWindowToScreen(mWinFrame);
            }
            if (!isHardwareAccelerated() || !mRtHandlingPositionUpdates) {
                try {
                    if (DEBUG)
                        Log.d(TAG, String.format("%d updateWindowPosition UI, " + "postion = [%d, %d, %d, %d]", System.identityHashCode(this), mWinFrame.left, mWinFrame.top, mWinFrame.right, mWinFrame.bottom));
                    mSession.repositionChild(mWindow, mWinFrame.left, mWinFrame.top, mWinFrame.right, mWinFrame.bottom, -1, mWinFrame);
                } catch (RemoteException ex) {
                    Log.e(TAG, "Exception from relayout", ex);
                }
            }
        }
    }
}
------------------------
Find a silently evolved API code:android.app.WallpaperManager.getBitmap:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Like {@link #getDrawable()} but returns a Bitmap.
 *
 * @hide
 */

Body of Frist Method:
{
    return sGlobals.peekWallpaperBitmap(mContext, true);
}
Body of Second Method:
{
    return getBitmapAsUser(mContext.getUserId());
}
------------------------
Find a silently evolved API code:android.print.PrinterInfo.Builder.setCapabilities:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the printer capabilities.
 *
 * @param capabilities The capabilities.
 * @return This builder.
 */

Body of Frist Method:
{
    mPrototype.mCapabilities = capabilities;
    return this;
}
Body of Second Method:
{
    mCapabilities = capabilities;
    return this;
}
------------------------
Find a silently evolved API code:android.telephony.SignalStrength.validateInput:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Validate the individual signal strength fields as per the range
 * specified in ril.h
 * Set to invalid any field that is not in the valid range
 * Cdma, evdo, lte rsrp & rsrq values are sign converted
 * when received from ril interface
 *
 * @return
 * Valid values for all signalstrength fields
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("Signal before validate=" + this);
    // TS 27.007 8.5
    mGsmSignalStrength = mGsmSignalStrength >= 0 ? mGsmSignalStrength : 99;
    // BER no change;
    mCdmaDbm = mCdmaDbm > 0 ? -mCdmaDbm : -120;
    mCdmaEcio = (mCdmaEcio > 0) ? -mCdmaEcio : -160;
    mEvdoDbm = (mEvdoDbm > 0) ? -mEvdoDbm : -120;
    mEvdoEcio = (mEvdoEcio >= 0) ? -mEvdoEcio : -1;
    mEvdoSnr = ((mEvdoSnr > 0) && (mEvdoSnr <= 8)) ? mEvdoSnr : -1;
    // TS 36.214 Physical Layer Section 5.1.3, TS 36.331 RRC
    mLteSignalStrength = (mLteSignalStrength >= 0) ? mLteSignalStrength : 99;
    mLteRsrp = ((mLteRsrp >= 44) && (mLteRsrp <= 140)) ? -mLteRsrp : SignalStrength.INVALID;
    mLteRsrq = ((mLteRsrq >= 3) && (mLteRsrq <= 20)) ? -mLteRsrq : SignalStrength.INVALID;
    mLteRssnr = ((mLteRssnr >= -200) && (mLteRssnr <= 300)) ? mLteRssnr : SignalStrength.INVALID;
    // Cqi no change
    if (DBG)
        log("Signal after validate=" + this);
}
Body of Second Method:
{
    if (DBG)
        log("Signal before validate=" + this);
    // TS 27.007 8.5
    mGsmSignalStrength = mGsmSignalStrength >= 0 ? mGsmSignalStrength : 99;
    // BER no change;
    mCdmaDbm = mCdmaDbm > 0 ? -mCdmaDbm : -120;
    mCdmaEcio = (mCdmaEcio > 0) ? -mCdmaEcio : -160;
    mEvdoDbm = (mEvdoDbm > 0) ? -mEvdoDbm : -120;
    mEvdoEcio = (mEvdoEcio >= 0) ? -mEvdoEcio : -1;
    mEvdoSnr = ((mEvdoSnr > 0) && (mEvdoSnr <= 8)) ? mEvdoSnr : -1;
    // TS 36.214 Physical Layer Section 5.1.3, TS 36.331 RRC
    mLteSignalStrength = (mLteSignalStrength >= 0) ? mLteSignalStrength : 99;
    mLteRsrp = ((mLteRsrp >= 44) && (mLteRsrp <= 140)) ? -mLteRsrp : SignalStrength.INVALID;
    mLteRsrq = ((mLteRsrq >= 3) && (mLteRsrq <= 20)) ? -mLteRsrq : SignalStrength.INVALID;
    mLteRssnr = ((mLteRssnr >= -200) && (mLteRssnr <= 300)) ? mLteRssnr : SignalStrength.INVALID;
    mTdScdmaRscp = ((mTdScdmaRscp >= 25) && (mTdScdmaRscp <= 120)) ? -mTdScdmaRscp : SignalStrength.INVALID;
    // Cqi no change
    if (DBG)
        log("Signal after validate=" + this);
}
------------------------
Find a silently evolved API code:android.graphics.Outline.setOval:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the outline to the oval defined by input rect.
 */

Body of Frist Method:
{
    if (left >= right || top >= bottom) {
        setEmpty();
        return;
    }
    if ((bottom - top) == (right - left)) {
        // represent circle as round rect, for efficiency, and to enable clipping
        setRoundRect(left, top, right, bottom, (bottom - top) / 2.0f);
        return;
    }
    if (mPath == null)
        mPath = new Path();
    mPath.reset();
    mPath.addOval(left, top, right, bottom, Path.Direction.CW);
    mRect = null;
}
Body of Second Method:
{
    if (left >= right || top >= bottom) {
        setEmpty();
        return;
    }
    if ((bottom - top) == (right - left)) {
        // represent circle as round rect, for efficiency, and to enable clipping
        setRoundRect(left, top, right, bottom, (bottom - top) / 2.0f);
        return;
    }
    mMode = MODE_CONVEX_PATH;
    mPath.rewind();
    mPath.addOval(left, top, right, bottom, Path.Direction.CW);
    mRect.setEmpty();
    mRadius = RADIUS_UNDEFINED;
}
------------------------
Find a silently evolved API code:android.print.PrinterInfo.Builder.setName:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the <strong>localized</strong> printer name which
 * is shown to the user
 *
 * @param name The name.
 * @return This builder.
 */

Body of Frist Method:
{
    mPrototype.mName = name;
    return this;
}
Body of Second Method:
{
    mName = checkName(name);
    return this;
}
------------------------
Find a silently evolved API code:android.telephony.TelephonyManager.getDefaultSubscription:COMMENT
Method Modifier: private     static      
Comment:/**
 * Returns Default subscription.
 */

Body of Frist Method:
{
    return SubscriptionManager.getDefaultSubId();
}
Body of Second Method:
{
    return SubscriptionManager.getDefaultSubscriptionId();
}
------------------------
Find a silently evolved API code:android.renderscript.Element.I8:COMMENT
Method Modifier: public      static      
Comment:/**
 * Utility function for returning an Element containing a single SIGNED_8.
 *
 * @param rs Context to which the element will belong.
 *
 * @return Element
 */

Body of Frist Method:
{
    if (rs.mElement_I8 == null) {
        rs.mElement_I8 = createUser(rs, DataType.SIGNED_8);
    }
    return rs.mElement_I8;
}
Body of Second Method:
{
    if (rs.mElement_I8 == null) {
        synchronized (rs) {
            if (rs.mElement_I8 == null) {
                rs.mElement_I8 = createUser(rs, DataType.SIGNED_8);
            }
        }
    }
    return rs.mElement_I8;
}
------------------------
Find a silently evolved API code:android.graphics.Bitmap.getPixel:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the {@link Color} at the specified location. Throws an exception
 * if x or y are out of bounds (negative or >= to the width or height
 * respectively). The returned color is a non-premultiplied ARGB value.
 *
 * @param x    The x coordinate (0...width-1) of the pixel to return
 * @param y    The y coordinate (0...height-1) of the pixel to return
 * @return     The argb {@link Color} at the specified coordinate
 * @throws IllegalArgumentException if x, y exceed the bitmap's bounds
 */

Body of Frist Method:
{
    checkRecycled("Can't call getPixel() on a recycled bitmap");
    checkPixelAccess(x, y);
    return nativeGetPixel(mFinalizer.mNativeBitmap, x, y);
}
Body of Second Method:
{
    checkRecycled("Can't call getPixel() on a recycled bitmap");
    checkPixelAccess(x, y);
    return nativeGetPixel(mNativePtr, x, y);
}
------------------------
Find a silently evolved API code:android.media.AudioManager.stopBluetoothSco:COMMENT
Method Modifier: public      
Comment:// Also used for connections started with {@link #startBluetoothScoVirtualCall()}

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        service.stopBluetoothSco(mICallBack);
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in stopBluetoothSco", e);
    }
}
Body of Second Method:
{
    IAudioService service = getService();
    try {
        service.stopBluetoothSco(mICallBack);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.media.AudioManager.isBluetoothA2dpOn:COMMENT
Method Modifier: public      
Comment:/**
 * Checks whether A2DP audio routing to the Bluetooth headset is on or off.
 *
 * @return true if A2DP audio is being routed to/from Bluetooth headset;
 * false if otherwise
 */

Body of Frist Method:
{
    if (AudioSystem.getDeviceConnectionState(DEVICE_OUT_BLUETOOTH_A2DP, "") == AudioSystem.DEVICE_STATE_UNAVAILABLE) {
        return false;
    } else {
        return true;
    }
}
Body of Second Method:
{
    if (AudioSystem.getDeviceConnectionState(DEVICE_OUT_BLUETOOTH_A2DP, "") == AudioSystem.DEVICE_STATE_AVAILABLE) {
        return true;
    } else if (AudioSystem.getDeviceConnectionState(DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES, "") == AudioSystem.DEVICE_STATE_AVAILABLE) {
        return true;
    } else if (AudioSystem.getDeviceConnectionState(DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER, "") == AudioSystem.DEVICE_STATE_AVAILABLE) {
        return true;
    }
    return false;
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiManager.factoryReset:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Resets all wifi manager settings back to factory defaults.
 *
 * @hide
 */

Body of Frist Method:
{
    try {
        mService.factoryReset();
    } catch (RemoteException e) {
    }
}
Body of Second Method:
{
    try {
        mService.factoryReset();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.text.TextUtils.isGraphic:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns whether the given CharSequence contains any printable characters.
 */

Body of Frist Method:
{
    final int len = str.length();
    for (int i = 0; i < len; i++) {
        int gc = Character.getType(str.charAt(i));
        if (gc != Character.CONTROL && gc != Character.FORMAT && gc != Character.SURROGATE && gc != Character.UNASSIGNED && gc != Character.LINE_SEPARATOR && gc != Character.PARAGRAPH_SEPARATOR && gc != Character.SPACE_SEPARATOR) {
            return true;
        }
    }
    return false;
}
Body of Second Method:
{
    final int len = str.length();
    for (int cp, i = 0; i < len; i += Character.charCount(cp)) {
        cp = Character.codePointAt(str, i);
        int gc = Character.getType(cp);
        if (gc != Character.CONTROL && gc != Character.FORMAT && gc != Character.SURROGATE && gc != Character.UNASSIGNED && gc != Character.LINE_SEPARATOR && gc != Character.PARAGRAPH_SEPARATOR && gc != Character.SPACE_SEPARATOR) {
            return true;
        }
    }
    return false;
}
------------------------
Find a silently evolved API code:android.app.backup.WallpaperBackupHelper.restoreEntity:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Restore one absolute file entity from the restore stream.  If we're restoring the
 * magic wallpaper file, take specific action to determine whether it is suitable for
 * the current device.
 */

Body of Frist Method:
{
    final String key = data.getKey();
    if (isKeyInList(key, mKeys)) {
        if (key.equals(WALLPAPER_IMAGE_KEY)) {
            // restore the file to the stage for inspection
            File f = new File(STAGE_FILE);
            if (writeFile(f, data)) {
                // Preflight the restored image's dimensions without loading it
                BitmapFactory.Options options = new BitmapFactory.Options();
                options.inJustDecodeBounds = true;
                BitmapFactory.decodeFile(STAGE_FILE, options);
                if (DEBUG)
                    Slog.d(TAG, "Restoring wallpaper image w=" + options.outWidth + " h=" + options.outHeight);
                if (REJECT_OUTSIZED_RESTORE) {
                    // We accept any wallpaper that is at least as wide as our preference
                    // (i.e. wide enough to fill the screen), and is within a comfortable
                    // factor of the target height, to avoid significant clipping/scaling/
                    // letterboxing.  At this point we know that mDesiredMinWidth is the
                    // smallest dimension, regardless of current orientation, so we can
                    // safely require that the candidate's width and height both exceed
                    // that hard minimum.
                    final double heightRatio = mDesiredMinHeight / options.outHeight;
                    if (options.outWidth < mDesiredMinWidth || options.outHeight < mDesiredMinWidth || heightRatio >= MAX_HEIGHT_RATIO || heightRatio <= MIN_HEIGHT_RATIO) {
                        // Not wide enough for the screen, or too short/tall to be a good fit
                        // for the height of the screen, broken image file, or the system's
                        // desires for wallpaper size are in a bad state.  Probably one of the
                        // first two.
                        Slog.i(TAG, "Restored image dimensions (w=" + options.outWidth + ", h=" + options.outHeight + ") too far off target (tw=" + mDesiredMinWidth + ", th=" + mDesiredMinHeight + "); falling back to default wallpaper.");
                        f.delete();
                        return;
                    }
                }
                // We passed the acceptable-dimensions test (if any), so we're going to
                // use the restored image.
                // TODO: spin a service to copy the restored image to sd/usb storage,
                // since it does not exist anywhere other than the private wallpaper
                // file.
                Slog.d(TAG, "Applying restored wallpaper image.");
                f.renameTo(new File(WALLPAPER_IMAGE));
            }
        } else if (key.equals(WALLPAPER_INFO_KEY)) {
            // XML file containing wallpaper info
            File f = new File(WALLPAPER_INFO);
            writeFile(f, data);
        }
    }
}
Body of Second Method:
{
    final String key = data.getKey();
    if (isKeyInList(key, mKeys)) {
        if (key.equals(WALLPAPER_IMAGE_KEY)) {
            // restore the file to the stage for inspection
            File f = new File(STAGE_FILE);
            if (writeFile(f, data)) {
                // Preflight the restored image's dimensions without loading it
                BitmapFactory.Options options = new BitmapFactory.Options();
                options.inJustDecodeBounds = true;
                BitmapFactory.decodeFile(STAGE_FILE, options);
                if (DEBUG)
                    Slog.d(TAG, "Restoring wallpaper image w=" + options.outWidth + " h=" + options.outHeight);
                if (REJECT_OUTSIZED_RESTORE) {
                    // We accept any wallpaper that is at least as wide as our preference
                    // (i.e. wide enough to fill the screen), and is within a comfortable
                    // factor of the target height, to avoid significant clipping/scaling/
                    // letterboxing.  At this point we know that mDesiredMinWidth is the
                    // smallest dimension, regardless of current orientation, so we can
                    // safely require that the candidate's width and height both exceed
                    // that hard minimum.
                    final double heightRatio = mDesiredMinHeight / options.outHeight;
                    if (options.outWidth < mDesiredMinWidth || options.outHeight < mDesiredMinWidth || heightRatio >= MAX_HEIGHT_RATIO || heightRatio <= MIN_HEIGHT_RATIO) {
                        // Not wide enough for the screen, or too short/tall to be a good fit
                        // for the height of the screen, broken image file, or the system's
                        // desires for wallpaper size are in a bad state.  Probably one of the
                        // first two.
                        Slog.i(TAG, "Restored image dimensions (w=" + options.outWidth + ", h=" + options.outHeight + ") too far off target (tw=" + mDesiredMinWidth + ", th=" + mDesiredMinHeight + "); falling back to default wallpaper.");
                        f.delete();
                        return;
                    }
                }
            // We passed the acceptable-dimensions test (if any), so we're going to
            // use the restored image.  That comes last, when we are done restoring
            // both the pixels and the metadata.
            }
        } else if (key.equals(WALLPAPER_INFO_KEY)) {
            // XML file containing wallpaper info
            File f = new File(WALLPAPER_INFO);
            writeFile(f, data);
        }
    }
}
------------------------
Find a silently evolved API code:android.media.MediaActionSound.load:COMMENT
Method Modifier: public      
Comment:/**
 * Preload a predefined platform sound to minimize latency when the sound is
 * played later by {@link #play}.
 * @param soundName The type of sound to preload, selected from
 * SHUTTER_CLICK, FOCUS_COMPLETE, START_VIDEO_RECORDING, or
 * STOP_VIDEO_RECORDING.
 * @see #play
 * @see #SHUTTER_CLICK
 * @see #FOCUS_COMPLETE
 * @see #START_VIDEO_RECORDING
 * @see #STOP_VIDEO_RECORDING
 */

Body of Frist Method:
{
    if (soundName < 0 || soundName >= SOUND_FILES.length) {
        throw new RuntimeException("Unknown sound requested: " + soundName);
    }
    if (mSoundIds[soundName] == SOUND_NOT_LOADED) {
        mSoundIds[soundName] = mSoundPool.load(SOUND_FILES[soundName], 1);
    }
}
Body of Second Method:
{
    if (soundName < 0 || soundName >= SOUND_FILES.length) {
        throw new RuntimeException("Unknown sound requested: " + soundName);
    }
    SoundState sound = mSounds[soundName];
    synchronized (sound) {
        switch(sound.state) {
            case STATE_NOT_LOADED:
                if (loadSound(sound) <= 0) {
                    Log.e(TAG, "load() error loading sound: " + soundName);
                }
                break;
            default:
                Log.e(TAG, "load() called in wrong state: " + sound + " for sound: " + soundName);
                break;
        }
    }
}
------------------------
Find a silently evolved API code:android.media.AudioManager.setWiredDeviceConnectionState:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Indicate wired accessory connection state change.
 * @param device type of device connected/disconnected (AudioManager.DEVICE_OUT_xxx)
 * @param state  new connection state: 1 connected, 0 disconnected
 * @param name   device name
 * {@hide}
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        service.setWiredDeviceConnectionState(type, state, address, name, mApplicationContext.getOpPackageName());
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in setWiredDeviceConnectionState " + e);
    }
}
Body of Second Method:
{
    IAudioService service = getService();
    try {
        service.setWiredDeviceConnectionState(type, state, address, name, mApplicationContext.getOpPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.media.MediaDrm.getCryptoSession:COMMENT
Method Modifier: public      
Comment:/**
 * Obtain a CryptoSession object which can be used to encrypt, decrypt,
 * sign and verify messages or data using the session keys established
 * for the session using methods {@link #getKeyRequest} and
 * {@link #provideKeyResponse} using a session key server.
 *
 * @param sessionId the session ID for the session containing keys
 * to be used for encrypt, decrypt, sign and/or verify
 * @param cipherAlgorithm the algorithm to use for encryption and
 * decryption ciphers. The algorithm string conforms to JCA Standard
 * Names for Cipher Transforms and is case insensitive.  For example
 * "AES/CBC/NoPadding".
 * @param macAlgorithm the algorithm to use for sign and verify
 * The algorithm string conforms to JCA Standard Names for Mac
 * Algorithms and is case insensitive.  For example "HmacSHA256".
 * <p>
 * The list of supported algorithms for a DRM engine plugin can be obtained
 * using the method {@link #getPropertyString} with the property name
 * "algorithms".
 */

Body of Frist Method:
{
    return new CryptoSession(this, sessionId, cipherAlgorithm, macAlgorithm);
}
Body of Second Method:
{
    return new CryptoSession(sessionId, cipherAlgorithm, macAlgorithm);
}
------------------------
Find a silently evolved API code:android.app.AlarmManager.setExactAndAllowWhileIdle:COMMENT
Method Modifier: public      
Comment:/**
 * Like {@link #setExact(int, long, PendingIntent)}, but this alarm will be allowed to execute
 * even when the system is in low-power idle modes.  If you don't need exact scheduling of
 * the alarm but still need to execute while idle, consider using
 * {@link #setAndAllowWhileIdle}.  This type of alarm must <b>only</b>
 * be used for situations where it is actually required that the alarm go off while in
 * idle -- a reasonable example would be for a calendar notification that should make a
 * sound so the user is aware of it.  When the alarm is dispatched, the app will also be
 * added to the system's temporary whitelist for approximately 10 seconds to allow that
 * application to acquire further wake locks in which to complete its work.</p>
 *
 * <p>These alarms can significantly impact the power use
 * of the device when idle (and thus cause significant battery blame to the app scheduling
 * them), so they should be used with care.  To reduce abuse, there are restrictions on how
 * frequently these alarms will go off for a particular application.
 * Under normal system operation, it will not dispatch these
 * alarms more than about every minute (at which point every such pending alarm is
 * dispatched); when in low-power idle modes this duration may be significantly longer,
 * such as 15 minutes.</p>
 *
 * <p>Unlike other alarms, the system is free to reschedule this type of alarm to happen
 * out of order with any other alarms, even those from the same app.  This will clearly happen
 * when the device is idle (since this alarm can go off while idle, when any other alarms
 * from the app will be held until later), but may also happen even when not idle.
 * Note that the OS will allow itself more flexibility for scheduling these alarms than
 * regular exact alarms, since the application has opted into this behavior.  When the
 * device is idle it may take even more liberties with scheduling in order to optimize
 * for battery life.</p>
 *
 * @param type One of {@link #ELAPSED_REALTIME}, {@link #ELAPSED_REALTIME_WAKEUP},
 * {@link #RTC}, or {@link #RTC_WAKEUP}.
 * @param triggerAtMillis time in milliseconds that the alarm should go
 * off, using the appropriate clock (depending on the alarm type).
 * @param operation Action to perform when the alarm goes off;
 * typically comes from {@link PendingIntent#getBroadcast
 * IntentSender.getBroadcast()}.
 *
 * @see #set
 * @see #setRepeating
 * @see #setWindow
 * @see #cancel
 * @see android.content.Context#sendBroadcast
 * @see android.content.Context#registerReceiver
 * @see android.content.Intent#filterEquals
 * @see #ELAPSED_REALTIME
 * @see #ELAPSED_REALTIME_WAKEUP
 * @see #RTC
 * @see #RTC_WAKEUP
 */

Body of Frist Method:
{
    setImpl(type, triggerAtMillis, WINDOW_EXACT, 0, FLAG_ALLOW_WHILE_IDLE, operation, null, null);
}
Body of Second Method:
{
    setImpl(type, triggerAtMillis, WINDOW_EXACT, 0, FLAG_ALLOW_WHILE_IDLE, operation, null, null, null, null, null);
}
------------------------
Find a silently evolved API code:android.renderscript.Element.U8:COMMENT
Method Modifier: public      static      
Comment:/**
 * Utility function for returning an Element containing a single UNSIGNED_8.
 *
 * @param rs Context to which the element will belong.
 *
 * @return Element
 */

Body of Frist Method:
{
    if (rs.mElement_U8 == null) {
        rs.mElement_U8 = createUser(rs, DataType.UNSIGNED_8);
    }
    return rs.mElement_U8;
}
Body of Second Method:
{
    if (rs.mElement_U8 == null) {
        synchronized (rs) {
            if (rs.mElement_U8 == null) {
                rs.mElement_U8 = createUser(rs, DataType.UNSIGNED_8);
            }
        }
    }
    return rs.mElement_U8;
}
------------------------
Find a silently evolved API code:android.service.persistentdata.PersistentDataBlockManager.getMaximumDataBlockSize:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Retrieves the maximum size allowed for a data block.
 *
 * Returns -1 on error.
 */

Body of Frist Method:
{
    try {
        return sService.getMaximumDataBlockSize();
    } catch (RemoteException e) {
        onError("getting maximum data block size");
        return -1;
    }
}
Body of Second Method:
{
    try {
        return sService.getMaximumDataBlockSize();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.os.PowerManager.setBacklightBrightness:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets the brightness of the backlights (screen, keyboard, button).
 * <p>
 * Requires the {@link android.Manifest.permission#DEVICE_POWER} permission.
 * </p>
 *
 * @param brightness The brightness value from 0 to 255.
 *
 * @hide Requires signature permission.
 */

Body of Frist Method:
{
    try {
        mService.setTemporaryScreenBrightnessSettingOverride(brightness);
    } catch (RemoteException e) {
    }
}
Body of Second Method:
{
    try {
        mService.setTemporaryScreenBrightnessSettingOverride(brightness);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothAdapter.notifyUserAction:COMMENT
Method Modifier: private     
Comment:/**
 * Performs action based on user action to turn BT ON
 * or OFF if BT is in BLE_ON state
 */

Body of Frist Method:
{
    if (mService == null) {
        Log.e(TAG, "mService is null");
        return;
    }
    try {
        if (enable) {
            // NA:TODO implementation pending
            mService.onLeServiceUp();
        } else {
            // NA:TODO implementation pending
            mService.onBrEdrDown();
        }
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
}
Body of Second Method:
{
    try {
        mServiceLock.readLock().lock();
        if (mService == null) {
            Log.e(TAG, "mService is null");
            return;
        }
        if (enable) {
            // NA:TODO implementation pending
            mService.onLeServiceUp();
        } else {
            // NA:TODO implementation pending
            mService.onBrEdrDown();
        }
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
}
------------------------
Find a silently evolved API code:android.content.pm.LauncherApps.startAppDetailsActivity:COMMENT
Method Modifier: public      
Comment:/**
 * Starts the settings activity to show the application details for a
 * package in the specified profile.
 *
 * @param component The ComponentName of the package to launch settings for.
 * @param user The UserHandle of the profile
 * @param sourceBounds The Rect containing the source bounds of the clicked icon
 * @param opts Options to pass to startActivity
 */

Body of Frist Method:
{
    try {
        mService.showAppDetailsAsUser(component, sourceBounds, opts, user);
    } catch (RemoteException re) {
    // Oops!
    }
}
Body of Second Method:
{
    try {
        mService.showAppDetailsAsUser(component, sourceBounds, opts, user);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.net.ConnectivityManager.reportBadNetwork:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * Report a problem network to the framework.  This provides a hint to the system
 * that there might be connectivity problems on this network and may cause
 * the framework to re-evaluate network connectivity and/or switch to another
 * network.
 *
 * @param network The {@link Network} the application was attempting to use
 * or {@code null} to indicate the current default network.
 * @deprecated Use {@link #reportNetworkConnectivity} which allows reporting both
 * working and non-working connectivity.
 */

Body of Frist Method:
{
    try {
        // One of these will be ignored because it matches system's current state.
        // The other will trigger the necessary reevaluation.
        mService.reportNetworkConnectivity(network, true);
        mService.reportNetworkConnectivity(network, false);
    } catch (RemoteException e) {
    }
}
Body of Second Method:
{
    try {
        // One of these will be ignored because it matches system's current state.
        // The other will trigger the necessary reevaluation.
        mService.reportNetworkConnectivity(network, true);
        mService.reportNetworkConnectivity(network, false);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.net.ConnectivityManager.enforceTetherChangePermission:COMMENT
Method Modifier: public      static      final       hidden      
Comment:/**
 * {@hide
 */

Body of Frist Method:
{
    if (context.getResources().getStringArray(com.android.internal.R.array.config_mobile_hotspot_provision_app).length == 2) {
        // Have a provisioning app - must only let system apps (which check this app)
        // turn on tethering
        context.enforceCallingOrSelfPermission(android.Manifest.permission.CONNECTIVITY_INTERNAL, "ConnectivityService");
    } else {
        int uid = Binder.getCallingUid();
        Settings.checkAndNoteChangeNetworkStateOperation(context, uid, Settings.getPackageNameForUid(context, uid), true);
    }
}
Body of Second Method:
{
    if (context.getResources().getStringArray(com.android.internal.R.array.config_mobile_hotspot_provision_app).length == 2) {
        // Have a provisioning app - must only let system apps (which check this app)
        // turn on tethering
        context.enforceCallingOrSelfPermission(android.Manifest.permission.TETHER_PRIVILEGED, "ConnectivityService");
    } else {
        int uid = Binder.getCallingUid();
        Settings.checkAndNoteWriteSettingsOperation(context, uid, Settings.getPackageNameForUid(context, uid), true);
    }
}
------------------------
Find a silently evolved API code:android.os.PowerManager.isIgnoringBatteryOptimizations:COMMENT
Method Modifier: public      
Comment:/**
 * Return whether the given application package name is on the device's power whitelist.
 * Apps can be placed on the whitelist through the settings UI invoked by
 * {@link android.provider.Settings#ACTION_IGNORE_BATTERY_OPTIMIZATION_SETTINGS}.
 */

Body of Frist Method:
{
    synchronized (this) {
        if (mIDeviceIdleController == null) {
            mIDeviceIdleController = IDeviceIdleController.Stub.asInterface(ServiceManager.getService(Context.DEVICE_IDLE_CONTROLLER));
        }
    }
    try {
        return mIDeviceIdleController.isPowerSaveWhitelistApp(packageName);
    } catch (RemoteException e) {
        return false;
    }
}
Body of Second Method:
{
    synchronized (this) {
        if (mIDeviceIdleController == null) {
            mIDeviceIdleController = IDeviceIdleController.Stub.asInterface(ServiceManager.getService(Context.DEVICE_IDLE_CONTROLLER));
        }
    }
    try {
        return mIDeviceIdleController.isPowerSaveWhitelistApp(packageName);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.app.ActivityManager.getDeviceConfigurationInfo:COMMENT
Method Modifier: public      
Comment:/**
 * Get the device configuration attributes.
 */

Body of Frist Method:
{
    try {
        return ActivityManagerNative.getDefault().getDeviceConfigurationInfo();
    } catch (RemoteException e) {
    }
    return null;
}
Body of Second Method:
{
    try {
        return ActivityManagerNative.getDefault().getDeviceConfigurationInfo();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.os.Process.myUserHandle:COMMENT
<android.os.Process: UserHandle myUserHandle()>
public      static      final       ->public      static      
Method Modifier: public      static      final       
Method Modifier: Yes         Yes         Yes         
Method Updated:  Yes         Yes         No          
Comment:/**
 * Returns this process's user handle.  This is the
 * user the process is running under.  It is distinct from
 * {@link #myUid()} in that a particular user will have multiple
 * distinct apps running under it each with their own uid.
 */

Body of Frist Method:
{
    return new UserHandle(UserHandle.getUserId(myUid()));
}
Body of Second Method:
{
    return UserHandle.of(UserHandle.getUserId(myUid()));
}
------------------------
Find a silently evolved API code:android.app.Activity.startIntentSenderForResult:COMMENT
Method Modifier: public      
Comment:/**
 * Like {@link #startActivityForResult(Intent, int)}, but allowing you
 * to use a IntentSender to describe the activity to be started.  If
 * the IntentSender is for an activity, that activity will be started
 * as if you had called the regular {@link #startActivityForResult(Intent, int)}
 * here; otherwise, its associated action will be executed (such as
 * sending a broadcast) as if you had called
 * {@link IntentSender#sendIntent IntentSender.sendIntent} on it.
 *
 * @param intent The IntentSender to launch.
 * @param requestCode If >= 0, this code will be returned in
 * onActivityResult() when the activity exits.
 * @param fillInIntent If non-null, this will be provided as the
 * intent parameter to {@link IntentSender#sendIntent}.
 * @param flagsMask Intent flags in the original IntentSender that you
 * would like to change.
 * @param flagsValues Desired values for any bits set in
 * <var>flagsMask</var>
 * @param extraFlags Always set to 0.
 * @param options Additional options for how the Activity should be started.
 * See {@link android.content.Context#startActivity(Intent, Bundle)
 * Context.startActivity(Intent, Bundle)} for more details.  If options
 * have also been supplied by the IntentSender, options given here will
 * override any that conflict with those given by the IntentSender.
 */

Body of Frist Method:
{
    if (mParent == null) {
        startIntentSenderForResultInner(intent, requestCode, fillInIntent, flagsMask, flagsValues, this, options);
    } else if (options != null) {
        mParent.startIntentSenderFromChild(this, intent, requestCode, fillInIntent, flagsMask, flagsValues, extraFlags, options);
    } else {
        // Note we want to go through this call for compatibility with
        // existing applications that may have overridden the method.
        mParent.startIntentSenderFromChild(this, intent, requestCode, fillInIntent, flagsMask, flagsValues, extraFlags);
    }
}
Body of Second Method:
{
    if (mParent == null) {
        startIntentSenderForResultInner(intent, mEmbeddedID, requestCode, fillInIntent, flagsMask, flagsValues, options);
    } else if (options != null) {
        mParent.startIntentSenderFromChild(this, intent, requestCode, fillInIntent, flagsMask, flagsValues, extraFlags, options);
    } else {
        // Note we want to go through this call for compatibility with
        // existing applications that may have overridden the method.
        mParent.startIntentSenderFromChild(this, intent, requestCode, fillInIntent, flagsMask, flagsValues, extraFlags);
    }
}
------------------------
Find a silently evolved API code:android.widget.TextView.append:COMMENT
Method Modifier: public      
Comment:/**
 * Convenience method: Append the specified text slice to the TextView's
 * display buffer, upgrading it to BufferType.EDITABLE if it was
 * not already editable.
 */

Body of Frist Method:
{
    if (!(mText instanceof Editable)) {
        setText(mText, BufferType.EDITABLE);
    }
    ((Editable) mText).append(text, start, end);
}
Body of Second Method:
{
    if (!(mText instanceof Editable)) {
        setText(mText, BufferType.EDITABLE);
    }
    ((Editable) mText).append(text, start, end);
    if (mAutoLinkMask != 0) {
        boolean linksWereAdded = Linkify.addLinks((Spannable) mText, mAutoLinkMask);
        // would prevent an arbitrary cursor displacement.
        if (linksWereAdded && mLinksClickable && !textCanBeSelected()) {
            setMovementMethod(LinkMovementMethod.getInstance());
        }
    }
}
------------------------
Find a silently evolved API code:android.net.ConnectivityManager.setProvisioningNotificationVisible:COMMENT
Method Modifier: public      hidden      deprecated  
Comment:/**
 * Set sign in error notification to visible or in visible
 *
 * @param visible
 * @param networkType
 *
 * {@hide}
 * @deprecated Doesn't properly deal with multiple connected networks of the same type.
 */

Body of Frist Method:
{
    try {
        mService.setProvisioningNotificationVisible(visible, networkType, action);
    } catch (RemoteException e) {
    }
}
Body of Second Method:
{
    try {
        mService.setProvisioningNotificationVisible(visible, networkType, action);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.graphics.Bitmap.copyPixelsFromBuffer:COMMENT
Method Modifier: public      
Comment:/**
 * <p>Copy the pixels from the buffer, beginning at the current position,
 * overwriting the bitmap's pixels. The data in the buffer is not changed
 * in any way (unlike setPixels(), which converts from unpremultipled 32bit
 * to whatever the bitmap's native format is.</p>
 * <p>After this method returns, the current position of the buffer is
 * updated: the position is incremented by the number of elements read from
 * the buffer. If you need to read the bitmap from the buffer again you must
 * first rewind the buffer.</p>
 */

Body of Frist Method:
{
    checkRecycled("copyPixelsFromBuffer called on recycled bitmap");
    int elements = src.remaining();
    int shift;
    if (src instanceof ByteBuffer) {
        shift = 0;
    } else if (src instanceof ShortBuffer) {
        shift = 1;
    } else if (src instanceof IntBuffer) {
        shift = 2;
    } else {
        throw new RuntimeException("unsupported Buffer subclass");
    }
    long bufferBytes = (long) elements << shift;
    long bitmapBytes = getByteCount();
    if (bufferBytes < bitmapBytes) {
        throw new RuntimeException("Buffer not large enough for pixels");
    }
    nativeCopyPixelsFromBuffer(mFinalizer.mNativeBitmap, src);
    // now update the buffer's position
    int position = src.position();
    position += bitmapBytes >> shift;
    src.position(position);
}
Body of Second Method:
{
    checkRecycled("copyPixelsFromBuffer called on recycled bitmap");
    int elements = src.remaining();
    int shift;
    if (src instanceof ByteBuffer) {
        shift = 0;
    } else if (src instanceof ShortBuffer) {
        shift = 1;
    } else if (src instanceof IntBuffer) {
        shift = 2;
    } else {
        throw new RuntimeException("unsupported Buffer subclass");
    }
    long bufferBytes = (long) elements << shift;
    long bitmapBytes = getByteCount();
    if (bufferBytes < bitmapBytes) {
        throw new RuntimeException("Buffer not large enough for pixels");
    }
    nativeCopyPixelsFromBuffer(mNativePtr, src);
    // now update the buffer's position
    int position = src.position();
    position += bitmapBytes >> shift;
    src.position(position);
}
------------------------
Find a silently evolved API code:android.widget.LinearLayout.measureVertical:COMMENT
Method Modifier: default     
Comment:/**
 * Measures the children when the orientation of this LinearLayout is set
 * to {@link #VERTICAL}.
 *
 * @param widthMeasureSpec Horizontal space requirements as imposed by the parent.
 * @param heightMeasureSpec Vertical space requirements as imposed by the parent.
 *
 * @see #getOrientation()
 * @see #setOrientation(int)
 * @see #onMeasure(int, int)
 */

Body of Frist Method:
{
    mTotalLength = 0;
    int maxWidth = 0;
    int childState = 0;
    int alternativeMaxWidth = 0;
    int weightedMaxWidth = 0;
    boolean allFillParent = true;
    float totalWeight = 0;
    final int count = getVirtualChildCount();
    final int widthMode = MeasureSpec.getMode(widthMeasureSpec);
    final int heightMode = MeasureSpec.getMode(heightMeasureSpec);
    boolean matchWidth = false;
    boolean skippedMeasure = false;
    final int baselineChildIndex = mBaselineAlignedChildIndex;
    final boolean useLargestChild = mUseLargestChild;
    int largestChildHeight = Integer.MIN_VALUE;
    // See how tall everyone is. Also remember max width.
    for (int i = 0; i < count; ++i) {
        final View child = getVirtualChildAt(i);
        if (child == null) {
            mTotalLength += measureNullChild(i);
            continue;
        }
        if (child.getVisibility() == View.GONE) {
            i += getChildrenSkipCount(child, i);
            continue;
        }
        if (hasDividerBeforeChildAt(i)) {
            mTotalLength += mDividerHeight;
        }
        LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
        totalWeight += lp.weight;
        if (heightMode == MeasureSpec.EXACTLY && lp.height == 0 && lp.weight > 0) {
            // Optimization: don't bother measuring children who are going to use
            // leftover space. These views will get measured again down below if
            // there is any leftover space.
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin);
            skippedMeasure = true;
        } else {
            int oldHeight = Integer.MIN_VALUE;
            if (lp.height == 0 && lp.weight > 0) {
                // heightMode is either UNSPECIFIED or AT_MOST, and this
                // child wanted to stretch to fill available space.
                // Translate that to WRAP_CONTENT so that it does not end up
                // with a height of 0
                oldHeight = 0;
                lp.height = LayoutParams.WRAP_CONTENT;
            }
            // Determine how big this child would like to be. If this or
            // previous children have given a weight, then we allow it to
            // use all available space (and we will shrink things later
            // if needed).
            measureChildBeforeLayout(child, i, widthMeasureSpec, 0, heightMeasureSpec, totalWeight == 0 ? mTotalLength : 0);
            if (oldHeight != Integer.MIN_VALUE) {
                lp.height = oldHeight;
            }
            final int childHeight = child.getMeasuredHeight();
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
            if (useLargestChild) {
                largestChildHeight = Math.max(childHeight, largestChildHeight);
            }
        }
        /**
         * If applicable, compute the additional offset to the child's baseline
         * we'll need later when asked {@link #getBaseline}.
         */
        if ((baselineChildIndex >= 0) && (baselineChildIndex == i + 1)) {
            mBaselineChildTop = mTotalLength;
        }
        // weight.  fail fast to aid the developer.
        if (i < baselineChildIndex && lp.weight > 0) {
            throw new RuntimeException("A child of LinearLayout with index " + "less than mBaselineAlignedChildIndex has weight > 0, which " + "won't work.  Either remove the weight, or don't set " + "mBaselineAlignedChildIndex.");
        }
        boolean matchWidthLocally = false;
        if (widthMode != MeasureSpec.EXACTLY && lp.width == LayoutParams.MATCH_PARENT) {
            // The width of the linear layout will scale, and at least one
            // child said it wanted to match our width. Set a flag
            // indicating that we need to remeasure at least that view when
            // we know our width.
            matchWidth = true;
            matchWidthLocally = true;
        }
        final int margin = lp.leftMargin + lp.rightMargin;
        final int measuredWidth = child.getMeasuredWidth() + margin;
        maxWidth = Math.max(maxWidth, measuredWidth);
        childState = combineMeasuredStates(childState, child.getMeasuredState());
        allFillParent = allFillParent && lp.width == LayoutParams.MATCH_PARENT;
        if (lp.weight > 0) {
            /*
                 * Widths of weighted Views are bogus if we end up
                 * remeasuring, so keep them separate.
                 */
            weightedMaxWidth = Math.max(weightedMaxWidth, matchWidthLocally ? margin : measuredWidth);
        } else {
            alternativeMaxWidth = Math.max(alternativeMaxWidth, matchWidthLocally ? margin : measuredWidth);
        }
        i += getChildrenSkipCount(child, i);
    }
    if (mTotalLength > 0 && hasDividerBeforeChildAt(count)) {
        mTotalLength += mDividerHeight;
    }
    if (useLargestChild && (heightMode == MeasureSpec.AT_MOST || heightMode == MeasureSpec.UNSPECIFIED)) {
        mTotalLength = 0;
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child == null) {
                mTotalLength += measureNullChild(i);
                continue;
            }
            if (child.getVisibility() == GONE) {
                i += getChildrenSkipCount(child, i);
                continue;
            }
            final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
            // Account for negative margins
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + largestChildHeight + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
        }
    }
    // Add in our padding
    mTotalLength += mPaddingTop + mPaddingBottom;
    int heightSize = mTotalLength;
    // Check against our minimum height
    heightSize = Math.max(heightSize, getSuggestedMinimumHeight());
    // Reconcile our calculated size with the heightMeasureSpec
    int heightSizeAndState = resolveSizeAndState(heightSize, heightMeasureSpec, 0);
    heightSize = heightSizeAndState & MEASURED_SIZE_MASK;
    // Either expand children with weight to take up available space or
    // shrink them if they extend beyond our current bounds. If we skipped
    // measurement on any children, we need to measure them now.
    int delta = heightSize - mTotalLength;
    if (skippedMeasure || delta != 0 && totalWeight > 0.0f) {
        float weightSum = mWeightSum > 0.0f ? mWeightSum : totalWeight;
        mTotalLength = 0;
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child.getVisibility() == View.GONE) {
                continue;
            }
            LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
            float childExtra = lp.weight;
            if (childExtra > 0) {
                // Child said it could absorb extra space -- give him his share
                int share = (int) (childExtra * delta / weightSum);
                weightSum -= childExtra;
                delta -= share;
                final int childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin, lp.width);
                // child has been previously measured
                if ((lp.height != 0) || (heightMode != MeasureSpec.EXACTLY)) {
                    // child was measured once already above...
                    // base new measurement on stored values
                    int childHeight = child.getMeasuredHeight() + share;
                    if (childHeight < 0) {
                        childHeight = 0;
                    }
                    child.measure(childWidthMeasureSpec, MeasureSpec.makeMeasureSpec(childHeight, MeasureSpec.EXACTLY));
                } else {
                    // child was skipped in the loop above.
                    // Measure for this first time here
                    child.measure(childWidthMeasureSpec, MeasureSpec.makeMeasureSpec(share > 0 ? share : 0, MeasureSpec.EXACTLY));
                }
                // Child may now not fit in vertical dimension.
                childState = combineMeasuredStates(childState, child.getMeasuredState() & (MEASURED_STATE_MASK >> MEASURED_HEIGHT_STATE_SHIFT));
            }
            final int margin = lp.leftMargin + lp.rightMargin;
            final int measuredWidth = child.getMeasuredWidth() + margin;
            maxWidth = Math.max(maxWidth, measuredWidth);
            boolean matchWidthLocally = widthMode != MeasureSpec.EXACTLY && lp.width == LayoutParams.MATCH_PARENT;
            alternativeMaxWidth = Math.max(alternativeMaxWidth, matchWidthLocally ? margin : measuredWidth);
            allFillParent = allFillParent && lp.width == LayoutParams.MATCH_PARENT;
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
        }
        // Add in our padding
        mTotalLength += mPaddingTop + mPaddingBottom;
    // TODO: Should we recompute the heightSpec based on the new total length?
    } else {
        alternativeMaxWidth = Math.max(alternativeMaxWidth, weightedMaxWidth);
        // Children will have already been measured once.
        if (useLargestChild && heightMode != MeasureSpec.EXACTLY) {
            for (int i = 0; i < count; i++) {
                final View child = getVirtualChildAt(i);
                if (child == null || child.getVisibility() == View.GONE) {
                    continue;
                }
                final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
                float childExtra = lp.weight;
                if (childExtra > 0) {
                    child.measure(MeasureSpec.makeMeasureSpec(child.getMeasuredWidth(), MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(largestChildHeight, MeasureSpec.EXACTLY));
                }
            }
        }
    }
    if (!allFillParent && widthMode != MeasureSpec.EXACTLY) {
        maxWidth = alternativeMaxWidth;
    }
    maxWidth += mPaddingLeft + mPaddingRight;
    // Check against our minimum width
    maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());
    setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState), heightSizeAndState);
    if (matchWidth) {
        forceUniformWidth(count, heightMeasureSpec);
    }
}
Body of Second Method:
{
    mTotalLength = 0;
    int maxWidth = 0;
    int childState = 0;
    int alternativeMaxWidth = 0;
    int weightedMaxWidth = 0;
    boolean allFillParent = true;
    float totalWeight = 0;
    final int count = getVirtualChildCount();
    final int widthMode = MeasureSpec.getMode(widthMeasureSpec);
    final int heightMode = MeasureSpec.getMode(heightMeasureSpec);
    boolean matchWidth = false;
    boolean skippedMeasure = false;
    final int baselineChildIndex = mBaselineAlignedChildIndex;
    final boolean useLargestChild = mUseLargestChild;
    int largestChildHeight = Integer.MIN_VALUE;
    int consumedExcessSpace = 0;
    // See how tall everyone is. Also remember max width.
    for (int i = 0; i < count; ++i) {
        final View child = getVirtualChildAt(i);
        if (child == null) {
            mTotalLength += measureNullChild(i);
            continue;
        }
        if (child.getVisibility() == View.GONE) {
            i += getChildrenSkipCount(child, i);
            continue;
        }
        if (hasDividerBeforeChildAt(i)) {
            mTotalLength += mDividerHeight;
        }
        final LayoutParams lp = (LayoutParams) child.getLayoutParams();
        totalWeight += lp.weight;
        final boolean useExcessSpace = lp.height == 0 && lp.weight > 0;
        if (heightMode == MeasureSpec.EXACTLY && useExcessSpace) {
            // Optimization: don't bother measuring children who are only
            // laid out using excess space. These views will get measured
            // later if we have space to distribute.
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin);
            skippedMeasure = true;
        } else {
            if (useExcessSpace) {
                // The heightMode is either UNSPECIFIED or AT_MOST, and
                // this child is only laid out using excess space. Measure
                // using WRAP_CONTENT so that we can find out the view's
                // optimal height. We'll restore the original height of 0
                // after measurement.
                lp.height = LayoutParams.WRAP_CONTENT;
            }
            // Determine how big this child would like to be. If this or
            // previous children have given a weight, then we allow it to
            // use all available space (and we will shrink things later
            // if needed).
            final int usedHeight = totalWeight == 0 ? mTotalLength : 0;
            measureChildBeforeLayout(child, i, widthMeasureSpec, 0, heightMeasureSpec, usedHeight);
            final int childHeight = child.getMeasuredHeight();
            if (useExcessSpace) {
                // Restore the original height and record how much space
                // we've allocated to excess-only children so that we can
                // match the behavior of EXACTLY measurement.
                lp.height = 0;
                consumedExcessSpace += childHeight;
            }
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
            if (useLargestChild) {
                largestChildHeight = Math.max(childHeight, largestChildHeight);
            }
        }
        /**
         * If applicable, compute the additional offset to the child's baseline
         * we'll need later when asked {@link #getBaseline}.
         */
        if ((baselineChildIndex >= 0) && (baselineChildIndex == i + 1)) {
            mBaselineChildTop = mTotalLength;
        }
        // weight.  fail fast to aid the developer.
        if (i < baselineChildIndex && lp.weight > 0) {
            throw new RuntimeException("A child of LinearLayout with index " + "less than mBaselineAlignedChildIndex has weight > 0, which " + "won't work.  Either remove the weight, or don't set " + "mBaselineAlignedChildIndex.");
        }
        boolean matchWidthLocally = false;
        if (widthMode != MeasureSpec.EXACTLY && lp.width == LayoutParams.MATCH_PARENT) {
            // The width of the linear layout will scale, and at least one
            // child said it wanted to match our width. Set a flag
            // indicating that we need to remeasure at least that view when
            // we know our width.
            matchWidth = true;
            matchWidthLocally = true;
        }
        final int margin = lp.leftMargin + lp.rightMargin;
        final int measuredWidth = child.getMeasuredWidth() + margin;
        maxWidth = Math.max(maxWidth, measuredWidth);
        childState = combineMeasuredStates(childState, child.getMeasuredState());
        allFillParent = allFillParent && lp.width == LayoutParams.MATCH_PARENT;
        if (lp.weight > 0) {
            /*
                 * Widths of weighted Views are bogus if we end up
                 * remeasuring, so keep them separate.
                 */
            weightedMaxWidth = Math.max(weightedMaxWidth, matchWidthLocally ? margin : measuredWidth);
        } else {
            alternativeMaxWidth = Math.max(alternativeMaxWidth, matchWidthLocally ? margin : measuredWidth);
        }
        i += getChildrenSkipCount(child, i);
    }
    if (mTotalLength > 0 && hasDividerBeforeChildAt(count)) {
        mTotalLength += mDividerHeight;
    }
    if (useLargestChild && (heightMode == MeasureSpec.AT_MOST || heightMode == MeasureSpec.UNSPECIFIED)) {
        mTotalLength = 0;
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child == null) {
                mTotalLength += measureNullChild(i);
                continue;
            }
            if (child.getVisibility() == GONE) {
                i += getChildrenSkipCount(child, i);
                continue;
            }
            final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
            // Account for negative margins
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + largestChildHeight + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
        }
    }
    // Add in our padding
    mTotalLength += mPaddingTop + mPaddingBottom;
    int heightSize = mTotalLength;
    // Check against our minimum height
    heightSize = Math.max(heightSize, getSuggestedMinimumHeight());
    // Reconcile our calculated size with the heightMeasureSpec
    int heightSizeAndState = resolveSizeAndState(heightSize, heightMeasureSpec, 0);
    heightSize = heightSizeAndState & MEASURED_SIZE_MASK;
    // Either expand children with weight to take up available space or
    // shrink them if they extend beyond our current bounds. If we skipped
    // measurement on any children, we need to measure them now.
    int remainingExcess = heightSize - mTotalLength + (mAllowInconsistentMeasurement ? 0 : consumedExcessSpace);
    if (skippedMeasure || remainingExcess != 0 && totalWeight > 0.0f) {
        float remainingWeightSum = mWeightSum > 0.0f ? mWeightSum : totalWeight;
        mTotalLength = 0;
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child == null || child.getVisibility() == View.GONE) {
                continue;
            }
            final LayoutParams lp = (LayoutParams) child.getLayoutParams();
            final float childWeight = lp.weight;
            if (childWeight > 0) {
                final int share = (int) (childWeight * remainingExcess / remainingWeightSum);
                remainingExcess -= share;
                remainingWeightSum -= childWeight;
                final int childHeight;
                if (mUseLargestChild && heightMode != MeasureSpec.EXACTLY) {
                    childHeight = largestChildHeight;
                } else if (lp.height == 0 && (!mAllowInconsistentMeasurement || heightMode == MeasureSpec.EXACTLY)) {
                    // This child needs to be laid out from scratch using
                    // only its share of excess space.
                    childHeight = share;
                } else {
                    // This child had some intrinsic height to which we
                    // need to add its share of excess space.
                    childHeight = child.getMeasuredHeight() + share;
                }
                final int childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(Math.max(0, childHeight), MeasureSpec.EXACTLY);
                final int childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin, lp.width);
                child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
                // Child may now not fit in vertical dimension.
                childState = combineMeasuredStates(childState, child.getMeasuredState() & (MEASURED_STATE_MASK >> MEASURED_HEIGHT_STATE_SHIFT));
            }
            final int margin = lp.leftMargin + lp.rightMargin;
            final int measuredWidth = child.getMeasuredWidth() + margin;
            maxWidth = Math.max(maxWidth, measuredWidth);
            boolean matchWidthLocally = widthMode != MeasureSpec.EXACTLY && lp.width == LayoutParams.MATCH_PARENT;
            alternativeMaxWidth = Math.max(alternativeMaxWidth, matchWidthLocally ? margin : measuredWidth);
            allFillParent = allFillParent && lp.width == LayoutParams.MATCH_PARENT;
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
        }
        // Add in our padding
        mTotalLength += mPaddingTop + mPaddingBottom;
    // TODO: Should we recompute the heightSpec based on the new total length?
    } else {
        alternativeMaxWidth = Math.max(alternativeMaxWidth, weightedMaxWidth);
        // Children will have already been measured once.
        if (useLargestChild && heightMode != MeasureSpec.EXACTLY) {
            for (int i = 0; i < count; i++) {
                final View child = getVirtualChildAt(i);
                if (child == null || child.getVisibility() == View.GONE) {
                    continue;
                }
                final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
                float childExtra = lp.weight;
                if (childExtra > 0) {
                    child.measure(MeasureSpec.makeMeasureSpec(child.getMeasuredWidth(), MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(largestChildHeight, MeasureSpec.EXACTLY));
                }
            }
        }
    }
    if (!allFillParent && widthMode != MeasureSpec.EXACTLY) {
        maxWidth = alternativeMaxWidth;
    }
    maxWidth += mPaddingLeft + mPaddingRight;
    // Check against our minimum width
    maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());
    setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState), heightSizeAndState);
    if (matchWidth) {
        forceUniformWidth(count, heightMeasureSpec);
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothAdapter.isOffloadedScanBatchingSupported:COMMENT
Method Modifier: public      
Comment:/**
 * Return true if offloaded scan batching is supported
 *
 * @return true if chipset supports on-chip scan batching
 */

Body of Frist Method:
{
    if (!getLeAccess())
        return false;
    try {
        return mService.isOffloadedScanBatchingSupported();
    } catch (RemoteException e) {
        Log.e(TAG, "failed to get isOffloadedScanBatchingSupported, error: ", e);
    }
    return false;
}
Body of Second Method:
{
    if (!getLeAccess())
        return false;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.isOffloadedScanBatchingSupported();
    } catch (RemoteException e) {
        Log.e(TAG, "failed to get isOffloadedScanBatchingSupported, error: ", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}
------------------------
Find a silently evolved API code:android.mtp.MtpObjectInfo.getThumbCompressedSize:COMMENT
Method Modifier: public      final       
Comment:/**
 * Returns the size of the MTP object's thumbnail
 * Will be zero for objects with no thumbnail
 *
 * @return the thumbnail size
 */

Body of Frist Method:
{
    return mThumbCompressedSize;
}
Body of Second Method:
{
    Preconditions.checkState(mThumbCompressedSize >= 0);
    return mThumbCompressedSize;
}
------------------------
Find a silently evolved API code:android.renderscript.Sampler.CLAMP_NEAREST:COMMENT
Method Modifier: public      static      
Comment:/**
 * Retrieve a sampler with min and mag set to nearest and wrap modes set to
 * clamp.
 *
 * @param rs Context to which the sampler will belong.
 *
 * @return Sampler
 */

Body of Frist Method:
{
    if (rs.mSampler_CLAMP_NEAREST == null) {
        Builder b = new Builder(rs);
        b.setMinification(Value.NEAREST);
        b.setMagnification(Value.NEAREST);
        b.setWrapS(Value.CLAMP);
        b.setWrapT(Value.CLAMP);
        rs.mSampler_CLAMP_NEAREST = b.create();
    }
    return rs.mSampler_CLAMP_NEAREST;
}
Body of Second Method:
{
    if (rs.mSampler_CLAMP_NEAREST == null) {
        synchronized (rs) {
            if (rs.mSampler_CLAMP_NEAREST == null) {
                Builder b = new Builder(rs);
                b.setMinification(Value.NEAREST);
                b.setMagnification(Value.NEAREST);
                b.setWrapS(Value.CLAMP);
                b.setWrapT(Value.CLAMP);
                rs.mSampler_CLAMP_NEAREST = b.create();
            }
        }
    }
    return rs.mSampler_CLAMP_NEAREST;
}
------------------------
Find a silently evolved API code:android.app.SearchManager.launchAssist:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Starts the assistant.
 *
 * @param args the args to pass to the assistant
 *
 * @hide
 */

Body of Frist Method:
{
    try {
        if (mService == null) {
            return;
        }
        mService.launchAssist(args);
    } catch (RemoteException re) {
        Log.e(TAG, "launchAssist() failed: " + re);
    }
}
Body of Second Method:
{
    try {
        if (mService == null) {
            return;
        }
        mService.launchAssist(args);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.hardware.fingerprint.FingerprintManager.preEnroll:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Requests a pre-enrollment auth token to tie enrollment to the confirmation of
 * existing device credentials (e.g. pin/pattern/password).
 * @hide
 */

Body of Frist Method:
{
    long result = 0;
    if (mService != null)
        try {
            result = mService.preEnroll(mToken);
        } catch (RemoteException e) {
            Log.w(TAG, "Remote exception in enroll: ", e);
        }
    return result;
}
Body of Second Method:
{
    long result = 0;
    if (mService != null)
        try {
            result = mService.preEnroll(mToken);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    return result;
}
------------------------
Find a silently evolved API code:android.media.AudioFormat.isPublicEncoding:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    switch(audioFormat) {
        case ENCODING_PCM_8BIT:
        case ENCODING_PCM_16BIT:
        case ENCODING_PCM_FLOAT:
        case ENCODING_AC3:
        case ENCODING_E_AC3:
        case ENCODING_DTS:
        case ENCODING_DTS_HD:
            return true;
        default:
            return false;
    }
}
Body of Second Method:
{
    switch(audioFormat) {
        case ENCODING_PCM_8BIT:
        case ENCODING_PCM_16BIT:
        case ENCODING_PCM_FLOAT:
        case ENCODING_AC3:
        case ENCODING_E_AC3:
        case ENCODING_DTS:
        case ENCODING_DTS_HD:
        case ENCODING_IEC61937:
            return true;
        default:
            return false;
    }
}
------------------------
Find a silently evolved API code:android.hardware.camera2.params.StreamConfigurationMap.getPublicFormatCount:COMMENT
Method Modifier: private     
Comment:/**
 * Count the number of publicly-visible output formats
 */

Body of Frist Method:
{
    SparseIntArray formatsMap = getFormatsMap(output);
    int size = formatsMap.size();
    if (formatsMap.indexOfKey(HAL_PIXEL_FORMAT_RAW_OPAQUE) >= 0) {
        size -= 1;
    }
    if (output) {
        size += mDepthOutputFormats.size();
    }
    return size;
}
Body of Second Method:
{
    SparseIntArray formatsMap = getFormatsMap(output);
    int size = formatsMap.size();
    if (output) {
        size += mDepthOutputFormats.size();
    }
    return size;
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiScanner.stopTrackingBssids:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * remove tracking of interesting access points
 * @param listener same object provided in {@link #startTrackingBssids}
 */

Body of Frist Method:
{
    validateChannel();
    sAsyncChannel.sendMessage(CMD_RESET_HOTLIST, 0, removeListener(listener));
}
Body of Second Method:
{
    Preconditions.checkNotNull(listener, "listener cannot be null");
    int key = removeListener(listener);
    if (key == INVALID_KEY)
        return;
    validateChannel();
    mAsyncChannel.sendMessage(CMD_RESET_HOTLIST, 0, key);
}
------------------------
Find a silently evolved API code:android.telephony.SignalStrength.setFromNotifierBundle:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Set SignalStrength based on intent notifier map
 *
 * @param m intent notifier map
 * @hide
 */

Body of Frist Method:
{
    mGsmSignalStrength = m.getInt("GsmSignalStrength");
    mGsmBitErrorRate = m.getInt("GsmBitErrorRate");
    mCdmaDbm = m.getInt("CdmaDbm");
    mCdmaEcio = m.getInt("CdmaEcio");
    mEvdoDbm = m.getInt("EvdoDbm");
    mEvdoEcio = m.getInt("EvdoEcio");
    mEvdoSnr = m.getInt("EvdoSnr");
    mLteSignalStrength = m.getInt("LteSignalStrength");
    mLteRsrp = m.getInt("LteRsrp");
    mLteRsrq = m.getInt("LteRsrq");
    mLteRssnr = m.getInt("LteRssnr");
    mLteCqi = m.getInt("LteCqi");
    isGsm = m.getBoolean("isGsm");
}
Body of Second Method:
{
    mGsmSignalStrength = m.getInt("GsmSignalStrength");
    mGsmBitErrorRate = m.getInt("GsmBitErrorRate");
    mCdmaDbm = m.getInt("CdmaDbm");
    mCdmaEcio = m.getInt("CdmaEcio");
    mEvdoDbm = m.getInt("EvdoDbm");
    mEvdoEcio = m.getInt("EvdoEcio");
    mEvdoSnr = m.getInt("EvdoSnr");
    mLteSignalStrength = m.getInt("LteSignalStrength");
    mLteRsrp = m.getInt("LteRsrp");
    mLteRsrq = m.getInt("LteRsrq");
    mLteRssnr = m.getInt("LteRssnr");
    mLteCqi = m.getInt("LteCqi");
    mTdScdmaRscp = m.getInt("TdScdma");
    isGsm = m.getBoolean("isGsm");
}
------------------------
Find a silently evolved API code:android.app.ActivityManager.getProcessMemoryInfo:COMMENT
Method Modifier: public      
Comment:/**
 * Return information about the memory usage of one or more processes.
 *
 * <p><b>Note: this method is only intended for debugging or building
 * a user-facing process management UI.</b></p>
 *
 * @param pids The pids of the processes whose memory usage is to be
 * retrieved.
 * @return Returns an array of memory information, one for each
 * requested pid.
 */

Body of Frist Method:
{
    try {
        return ActivityManagerNative.getDefault().getProcessMemoryInfo(pids);
    } catch (RemoteException e) {
        return null;
    }
}
Body of Second Method:
{
    try {
        return ActivityManagerNative.getDefault().getProcessMemoryInfo(pids);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.os.PowerManager.goToSleep:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Forces the device to go to sleep.
 * <p>
 * Overrides all the wake locks that are held.
 * This is what happens when the power key is pressed to turn off the screen.
 * </p><p>
 * Requires the {@link android.Manifest.permission#DEVICE_POWER} permission.
 * </p>
 *
 * @param time The time when the request to go to sleep was issued, in the
 * {@link SystemClock#uptimeMillis()} time base.  This timestamp is used to correctly
 * order the go to sleep request with other power management functions.  It should be set
 * to the timestamp of the input event that caused the request to go to sleep.
 * @param reason The reason the device is going to sleep.
 * @param flags Optional flags to apply when going to sleep.
 *
 * @see #userActivity
 * @see #wakeUp
 *
 * @hide Requires signature permission.
 */

Body of Frist Method:
{
    try {
        mService.goToSleep(time, reason, flags);
    } catch (RemoteException e) {
    }
}
Body of Second Method:
{
    try {
        mService.goToSleep(time, reason, flags);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.printservice.PrintService.getActivePrintJobs:COMMENT
Method Modifier: public      final       
Comment:/**
 * Gets the active print jobs for the printers managed by this service.
 * Active print jobs are ones that are not in a final state, i.e. whose
 * state is queued or started.
 *
 * @return The active print jobs.
 *
 * @see PrintJob#isQueued() PrintJob.isQueued()
 * @see PrintJob#isStarted() PrintJob.isStarted()
 */

Body of Frist Method:
{
    throwIfNotCalledOnMainThread();
    if (mClient == null) {
        return Collections.emptyList();
    }
    try {
        List<PrintJob> printJobs = null;
        List<PrintJobInfo> printJobInfos = mClient.getPrintJobInfos();
        if (printJobInfos != null) {
            final int printJobInfoCount = printJobInfos.size();
            printJobs = new ArrayList<PrintJob>(printJobInfoCount);
            for (int i = 0; i < printJobInfoCount; i++) {
                printJobs.add(new PrintJob(printJobInfos.get(i), mClient));
            }
        }
        if (printJobs != null) {
            return printJobs;
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, "Error calling getPrintJobs()", re);
    }
    return Collections.emptyList();
}
Body of Second Method:
{
    throwIfNotCalledOnMainThread();
    if (mClient == null) {
        return Collections.emptyList();
    }
    try {
        List<PrintJob> printJobs = null;
        List<PrintJobInfo> printJobInfos = mClient.getPrintJobInfos();
        if (printJobInfos != null) {
            final int printJobInfoCount = printJobInfos.size();
            printJobs = new ArrayList<PrintJob>(printJobInfoCount);
            for (int i = 0; i < printJobInfoCount; i++) {
                printJobs.add(new PrintJob(this, printJobInfos.get(i), mClient));
            }
        }
        if (printJobs != null) {
            return printJobs;
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, "Error calling getPrintJobs()", re);
    }
    return Collections.emptyList();
}
------------------------
Find a silently evolved API code:android.os.StrictMode.parseViolationFromMessage:COMMENT
Method Modifier: private     static      
Comment:/**
 * Like parsePolicyFromMessage(), but returns the violation.
 */

Body of Frist Method:
{
    if (message == null) {
        return 0;
    }
    int violationIndex = message.indexOf("violation=");
    if (violationIndex == -1) {
        return 0;
    }
    int numberStartIndex = violationIndex + "violation=".length();
    int numberEndIndex = message.indexOf(' ', numberStartIndex);
    if (numberEndIndex == -1) {
        numberEndIndex = message.length();
    }
    String violationString = message.substring(numberStartIndex, numberEndIndex);
    try {
        return Integer.valueOf(violationString).intValue();
    } catch (NumberFormatException e) {
        return 0;
    }
}
Body of Second Method:
{
    if (message == null) {
        return 0;
    }
    int violationIndex = message.indexOf("violation=");
    if (violationIndex == -1) {
        return 0;
    }
    int numberStartIndex = violationIndex + "violation=".length();
    int numberEndIndex = message.indexOf(' ', numberStartIndex);
    if (numberEndIndex == -1) {
        numberEndIndex = message.length();
    }
    String violationString = message.substring(numberStartIndex, numberEndIndex);
    try {
        return Integer.parseInt(violationString);
    } catch (NumberFormatException e) {
        return 0;
    }
}
------------------------
Find a silently evolved API code:android.location.Location.distanceBetween:COMMENT
Method Modifier: public      static      
Comment:/**
 * Computes the approximate distance in meters between two
 * locations, and optionally the initial and final bearings of the
 * shortest path between them.  Distance and bearing are defined using the
 * WGS84 ellipsoid.
 *
 * <p> The computed distance is stored in results[0].  If results has length
 * 2 or greater, the initial bearing is stored in results[1]. If results has
 * length 3 or greater, the final bearing is stored in results[2].
 *
 * @param startLatitude the starting latitude
 * @param startLongitude the starting longitude
 * @param endLatitude the ending latitude
 * @param endLongitude the ending longitude
 * @param results an array of floats to hold the results
 *
 * @throws IllegalArgumentException if results is null or has length < 1
 */

Body of Frist Method:
{
    if (results == null || results.length < 1) {
        throw new IllegalArgumentException("results is null or has length < 1");
    }
    computeDistanceAndBearing(startLatitude, startLongitude, endLatitude, endLongitude, results);
}
Body of Second Method:
{
    if (results == null || results.length < 1) {
        throw new IllegalArgumentException("results is null or has length < 1");
    }
    BearingDistanceCache cache = sBearingDistanceCache.get();
    computeDistanceAndBearing(startLatitude, startLongitude, endLatitude, endLongitude, cache);
    results[0] = cache.mDistance;
    if (results.length > 1) {
        results[1] = cache.mInitialBearing;
        if (results.length > 2) {
            results[2] = cache.mFinalBearing;
        }
    }
}
------------------------
Find a silently evolved API code:android.accounts.AccountManager.addAccountAsUser:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @see #addAccount(String, String, String[], Bundle, Activity, AccountManagerCallback, Handler)
 * @hide
 */

Body of Frist Method:
{
    if (accountType == null)
        throw new IllegalArgumentException("accountType is null");
    if (userHandle == null)
        throw new IllegalArgumentException("userHandle is null");
    final Bundle optionsIn = new Bundle();
    if (addAccountOptions != null) {
        optionsIn.putAll(addAccountOptions);
    }
    optionsIn.putString(KEY_ANDROID_PACKAGE_NAME, mContext.getPackageName());
    return new AmsTask(activity, handler, callback) {

        public void doWork() throws RemoteException {
            mService.addAccountAsUser(mResponse, accountType, authTokenType, requiredFeatures, activity != null, optionsIn, userHandle.getIdentifier());
        }
    }.start();
}
Body of Second Method:
{
    if (accountType == null)
        throw new IllegalArgumentException("accountType is null");
    if (userHandle == null)
        throw new IllegalArgumentException("userHandle is null");
    final Bundle optionsIn = new Bundle();
    if (addAccountOptions != null) {
        optionsIn.putAll(addAccountOptions);
    }
    optionsIn.putString(KEY_ANDROID_PACKAGE_NAME, mContext.getPackageName());
    return new AmsTask(activity, handler, callback) {

        @Override
        public void doWork() throws RemoteException {
            mService.addAccountAsUser(mResponse, accountType, authTokenType, requiredFeatures, activity != null, optionsIn, userHandle.getIdentifier());
        }
    }.start();
}
------------------------
Find a silently evolved API code:android.app.assist.AssistContent.setDefaultIntent:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 * Called by {@link android.app.ActivityThread} to set the default Intent based on
 * {@link android.app.Activity#getIntent Activity.getIntent}.
 *
 * <p>Automatically populates {@link #mUri} if that Intent is an {@link Intent#ACTION_VIEW}
 * of a web (http or https scheme) URI.</p>
 */

Body of Frist Method:
{
    mIntent = intent;
    setWebUri(null);
    if (intent != null && Intent.ACTION_VIEW.equals(intent.getAction())) {
        Uri uri = intent.getData();
        if (uri != null) {
            if ("http".equals(uri.getScheme()) || "https".equals(uri.getScheme())) {
                setWebUri(uri);
            }
        }
    }
}
Body of Second Method:
{
    mIntent = intent;
    mIsAppProvidedIntent = false;
    mIsAppProvidedWebUri = false;
    mUri = null;
    if (intent != null && Intent.ACTION_VIEW.equals(intent.getAction())) {
        Uri uri = intent.getData();
        if (uri != null) {
            if ("http".equals(uri.getScheme()) || "https".equals(uri.getScheme())) {
                mUri = uri;
            }
        }
    }
}
------------------------
Find a silently evolved API code:android.view.accessibility.AccessibilityWindowInfo.clear:COMMENT
Method Modifier: private     
Comment:/**
 * Clears the internal state.
 */

Body of Frist Method:
{
    mType = UNDEFINED;
    mLayer = UNDEFINED;
    mBooleanProperties = 0;
    mId = UNDEFINED;
    mParentId = UNDEFINED;
    mBoundsInScreen.setEmpty();
    if (mChildIds != null) {
        mChildIds.clear();
    }
    mConnectionId = UNDEFINED;
}
Body of Second Method:
{
    mType = UNDEFINED;
    mLayer = UNDEFINED;
    mBooleanProperties = 0;
    mId = UNDEFINED;
    mParentId = UNDEFINED;
    mBoundsInScreen.setEmpty();
    if (mChildIds != null) {
        mChildIds.clear();
    }
    mConnectionId = UNDEFINED;
    mAnchorId = UNDEFINED;
    mTitle = null;
}
------------------------
Find a silently evolved API code:android.content.PeriodicSync.syncExtrasEquals:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Periodic sync extra comparison function.
 * {@hide}
 */

Body of Frist Method:
{
    if (b1.size() != b2.size()) {
        return false;
    }
    if (b1.isEmpty()) {
        return true;
    }
    for (String key : b1.keySet()) {
        if (!b2.containsKey(key)) {
            return false;
        }
        if (!b1.get(key).equals(b2.get(key))) {
            return false;
        }
    }
    return true;
}
Body of Second Method:
{
    if (b1.size() != b2.size()) {
        return false;
    }
    if (b1.isEmpty()) {
        return true;
    }
    for (String key : b1.keySet()) {
        if (!b2.containsKey(key)) {
            return false;
        }
        // are allowed in the bundle.
        if (!Objects.equals(b1.get(key), b2.get(key))) {
            return false;
        }
    }
    return true;
}
------------------------
Find a silently evolved API code:android.net.ConnectivityManager.getTetheringErroredIfaces:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the set of interface names which attempted to tether but
 * failed.  Re-attempting to tether may cause them to reset to the Tethered
 * state.  Alternatively, causing the interface to be destroyed and recreated
 * may cause them to reset to the available state.
 * {@link ConnectivityManager#getLastTetherError} can be used to get more
 * information on the cause of the errors.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
 *
 * @return an array of 0 or more String indicating the interface names
 * which failed to tether.
 *
 * {@hide}
 */

Body of Frist Method:
{
    try {
        return mService.getTetheringErroredIfaces();
    } catch (RemoteException e) {
        return new String[0];
    }
}
Body of Second Method:
{
    try {
        return mService.getTetheringErroredIfaces();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.media.audiopolicy.AudioMix.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Combines all of the settings and return a new {@link AudioMix} object.
 * @return a new {@link AudioMix} object
 * @throws IllegalArgumentException if no {@link AudioMixingRule} has been set.
 */

Body of Frist Method:
{
    if (mRule == null) {
        throw new IllegalArgumentException("Illegal null AudioMixingRule");
    }
    if (mRouteFlags == 0) {
        // no route flags set, use default
        mRouteFlags = ROUTE_FLAG_RENDER;
    }
    if (mFormat == null) {
        int rate = AudioSystem.getPrimaryOutputSamplingRate();
        if (rate <= 0) {
            rate = 44100;
        }
        mFormat = new AudioFormat.Builder().setSampleRate(rate).build();
    }
    return new AudioMix(mRule, mFormat, mRouteFlags, mCallbackFlags);
}
Body of Second Method:
{
    if (mRule == null) {
        throw new IllegalArgumentException("Illegal null AudioMixingRule");
    }
    if (mRouteFlags == 0) {
        // no route flags set, use default as described in Builder.setRouteFlags(int)
        mRouteFlags = ROUTE_FLAG_LOOP_BACK;
    }
    // can't do loop back AND render at same time in this implementation
    if (mRouteFlags == (ROUTE_FLAG_RENDER | ROUTE_FLAG_LOOP_BACK)) {
        throw new IllegalArgumentException("Unsupported route behavior combination 0x" + Integer.toHexString(mRouteFlags));
    }
    if (mFormat == null) {
        // FIXME Can we eliminate this?  Will AudioMix work with an unspecified sample rate?
        int rate = AudioSystem.getPrimaryOutputSamplingRate();
        if (rate <= 0) {
            rate = 44100;
        }
        mFormat = new AudioFormat.Builder().setSampleRate(rate).build();
    }
    if ((mDeviceSystemType != AudioSystem.DEVICE_NONE) && (mDeviceSystemType != AudioSystem.DEVICE_OUT_REMOTE_SUBMIX) && (mDeviceSystemType != AudioSystem.DEVICE_IN_REMOTE_SUBMIX)) {
        if ((mRouteFlags & ROUTE_FLAG_RENDER) == 0) {
            throw new IllegalArgumentException("Can't have audio device without flag ROUTE_FLAG_RENDER");
        }
        if (mRule.getTargetMixType() != AudioMix.MIX_TYPE_PLAYERS) {
            throw new IllegalArgumentException("Unsupported device on non-playback mix");
        }
    } else {
        if ((mRouteFlags & ROUTE_FLAG_RENDER) == ROUTE_FLAG_RENDER) {
            throw new IllegalArgumentException("Can't have flag ROUTE_FLAG_RENDER without an audio device");
        }
        if ((mRouteFlags & ROUTE_FLAG_SUPPORTED) == ROUTE_FLAG_LOOP_BACK) {
            if (mRule.getTargetMixType() == MIX_TYPE_PLAYERS) {
                mDeviceSystemType = AudioSystem.DEVICE_OUT_REMOTE_SUBMIX;
            } else if (mRule.getTargetMixType() == MIX_TYPE_RECORDERS) {
                mDeviceSystemType = AudioSystem.DEVICE_IN_REMOTE_SUBMIX;
            } else {
                throw new IllegalArgumentException("Unknown mixing rule type");
            }
        }
    }
    return new AudioMix(mRule, mFormat, mRouteFlags, mCallbackFlags, mDeviceSystemType, mDeviceAddress);
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiScanner.stopScan:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * stops an ongoing single shot scan; only useful after {@link #startScan} if onResults()
 * hasn't been called on the listener, ignored otherwise
 * @param listener
 */

Body of Frist Method:
{
    validateChannel();
    sAsyncChannel.sendMessage(CMD_STOP_SINGLE_SCAN, 0, removeListener(listener));
}
Body of Second Method:
{
    Preconditions.checkNotNull(listener, "listener cannot be null");
    int key = removeListener(listener);
    if (key == INVALID_KEY)
        return;
    validateChannel();
    mAsyncChannel.sendMessage(CMD_STOP_SINGLE_SCAN, 0, key);
}
------------------------
Find a silently evolved API code:android.provider.VoicemailContract.Status.setStatus:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * A helper method to set the status of a voicemail source.
 *
 * @param context The context from the package calling the method. This will be the source.
 * @param accountHandle The handle for the account the source is associated with.
 * @param configurationState See {@link Status#CONFIGURATION_STATE}
 * @param dataChannelState See {@link Status#DATA_CHANNEL_STATE}
 * @param notificationChannelState See {@link Status#NOTIFICATION_CHANNEL_STATE}
 *
 * @hide
 */

Body of Frist Method:
{
    ContentResolver contentResolver = context.getContentResolver();
    Uri statusUri = buildSourceUri(context.getPackageName());
    ContentValues values = new ContentValues();
    values.put(Status.PHONE_ACCOUNT_COMPONENT_NAME, accountHandle.getComponentName().flattenToString());
    values.put(Status.PHONE_ACCOUNT_ID, accountHandle.getId());
    values.put(Status.CONFIGURATION_STATE, configurationState);
    values.put(Status.DATA_CHANNEL_STATE, dataChannelState);
    values.put(Status.NOTIFICATION_CHANNEL_STATE, notificationChannelState);
    if (isStatusPresent(contentResolver, statusUri)) {
        contentResolver.update(statusUri, values, null, null);
    } else {
        contentResolver.insert(statusUri, values);
    }
}
Body of Second Method:
{
    ContentValues values = new ContentValues();
    values.put(Status.PHONE_ACCOUNT_COMPONENT_NAME, accountHandle.getComponentName().flattenToString());
    values.put(Status.PHONE_ACCOUNT_ID, accountHandle.getId());
    if (configurationState != CONFIGURATION_STATE_IGNORE) {
        values.put(Status.CONFIGURATION_STATE, configurationState);
    }
    if (dataChannelState != DATA_CHANNEL_STATE_IGNORE) {
        values.put(Status.DATA_CHANNEL_STATE, dataChannelState);
    }
    if (notificationChannelState != NOTIFICATION_CHANNEL_STATE_IGNORE) {
        values.put(Status.NOTIFICATION_CHANNEL_STATE, notificationChannelState);
    }
    ContentResolver contentResolver = context.getContentResolver();
    Uri statusUri = buildSourceUri(context.getPackageName());
    contentResolver.insert(statusUri, values);
}
------------------------
Find a silently evolved API code:android.hardware.usb.UsbManager.setPortRoles:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets the desired role combination of the port.
 * <p>
 * The supported role combinations depend on what is connected to the port and may be
 * determined by consulting
 * {@link UsbPortStatus#isRoleCombinationSupported UsbPortStatus.isRoleCombinationSupported}.
 * </p><p>
 * Note: This function is asynchronous and may fail silently without applying
 * the requested changes.  If this function does cause a status change to occur then
 * a {@link #ACTION_USB_PORT_CHANGED} broadcast will be sent.
 * </p>
 *
 * @param powerRole The desired power role: {@link UsbPort#POWER_ROLE_SOURCE}
 * or {@link UsbPort#POWER_ROLE_SINK}, or 0 if no power role.
 * @param dataRole The desired data role: {@link UsbPort#DATA_ROLE_HOST}
 * or {@link UsbPort#DATA_ROLE_DEVICE}, or 0 if no data role.
 *
 * @hide
 */

Body of Frist Method:
{
    Preconditions.checkNotNull(port, "port must not be null");
    UsbPort.checkRoles(powerRole, dataRole);
    try {
        mService.setPortRoles(port.getId(), powerRole, dataRole);
    } catch (RemoteException e) {
        Log.e(TAG, "RemoteException in setPortRole", e);
    }
}
Body of Second Method:
{
    Preconditions.checkNotNull(port, "port must not be null");
    UsbPort.checkRoles(powerRole, dataRole);
    try {
        mService.setPortRoles(port.getId(), powerRole, dataRole);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.app.WallpaperManager.getCropAndSetWallpaperIntent:COMMENT
Method Modifier: public      
Comment:/**
 * Gets an Intent that will launch an activity that crops the given
 * image and sets the device's wallpaper. If there is a default HOME activity
 * that supports cropping wallpapers, it will be preferred as the default.
 * Use this method instead of directly creating a {@link #ACTION_CROP_AND_SET_WALLPAPER}
 * intent.
 *
 * @param imageUri The image URI that will be set in the intent. The must be a content
 * URI and its provider must resolve its type to "image/*"
 *
 * @throws IllegalArgumentException if the URI is not a content URI or its MIME type is
 * not "image/*"
 */

Body of Frist Method:
{
    if (imageUri == null) {
        throw new IllegalArgumentException("Image URI must not be null");
    }
    if (!ContentResolver.SCHEME_CONTENT.equals(imageUri.getScheme())) {
        throw new IllegalArgumentException("Image URI must be of the " + ContentResolver.SCHEME_CONTENT + " scheme type");
    }
    final PackageManager packageManager = mContext.getPackageManager();
    Intent cropAndSetWallpaperIntent = new Intent(ACTION_CROP_AND_SET_WALLPAPER, imageUri);
    cropAndSetWallpaperIntent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
    // Find out if the default HOME activity supports CROP_AND_SET_WALLPAPER
    Intent homeIntent = new Intent(Intent.ACTION_MAIN).addCategory(Intent.CATEGORY_HOME);
    ResolveInfo resolvedHome = packageManager.resolveActivity(homeIntent, PackageManager.MATCH_DEFAULT_ONLY);
    if (resolvedHome != null) {
        cropAndSetWallpaperIntent.setPackage(resolvedHome.activityInfo.packageName);
        List<ResolveInfo> cropAppList = packageManager.queryIntentActivities(cropAndSetWallpaperIntent, 0);
        if (cropAppList.size() > 0) {
            return cropAndSetWallpaperIntent;
        }
    }
    // fallback crop activity
    cropAndSetWallpaperIntent.setPackage("com.android.wallpapercropper");
    List<ResolveInfo> cropAppList = packageManager.queryIntentActivities(cropAndSetWallpaperIntent, 0);
    if (cropAppList.size() > 0) {
        return cropAndSetWallpaperIntent;
    }
    // cropper doesn't exist, return null
    throw new IllegalArgumentException("Cannot use passed URI to set wallpaper; " + "check that the type returned by ContentProvider matches image/*");
}
Body of Second Method:
{
    if (imageUri == null) {
        throw new IllegalArgumentException("Image URI must not be null");
    }
    if (!ContentResolver.SCHEME_CONTENT.equals(imageUri.getScheme())) {
        throw new IllegalArgumentException("Image URI must be of the " + ContentResolver.SCHEME_CONTENT + " scheme type");
    }
    final PackageManager packageManager = mContext.getPackageManager();
    Intent cropAndSetWallpaperIntent = new Intent(ACTION_CROP_AND_SET_WALLPAPER, imageUri);
    cropAndSetWallpaperIntent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
    // Find out if the default HOME activity supports CROP_AND_SET_WALLPAPER
    Intent homeIntent = new Intent(Intent.ACTION_MAIN).addCategory(Intent.CATEGORY_HOME);
    ResolveInfo resolvedHome = packageManager.resolveActivity(homeIntent, PackageManager.MATCH_DEFAULT_ONLY);
    if (resolvedHome != null) {
        cropAndSetWallpaperIntent.setPackage(resolvedHome.activityInfo.packageName);
        List<ResolveInfo> cropAppList = packageManager.queryIntentActivities(cropAndSetWallpaperIntent, 0);
        if (cropAppList.size() > 0) {
            return cropAndSetWallpaperIntent;
        }
    }
    // fallback crop activity
    final String cropperPackage = mContext.getString(com.android.internal.R.string.config_wallpaperCropperPackage);
    cropAndSetWallpaperIntent.setPackage(cropperPackage);
    List<ResolveInfo> cropAppList = packageManager.queryIntentActivities(cropAndSetWallpaperIntent, 0);
    if (cropAppList.size() > 0) {
        return cropAndSetWallpaperIntent;
    }
    // cropper doesn't exist, return null
    throw new IllegalArgumentException("Cannot use passed URI to set wallpaper; " + "check that the type returned by ContentProvider matches image/*");
}
------------------------
Find a silently evolved API code:android.accounts.AccountManager.setPassword:COMMENT
Method Modifier: public      
Comment:/**
 * Sets or forgets a saved password. This modifies the local copy of the
 * password used to automatically authenticate the user; it does not change
 * the user's account password on the server. Intended for use by the
 * authenticator, not directly by applications.
 * <p>Calling this method does not update the last authenticated timestamp,
 * referred by {@link #KEY_LAST_AUTHENTICATED_TIME}. To update it, call
 * {@link #notifyAccountAuthenticated(Account)} after getting success.
 * <p>It is safe to call this method from the main thread.
 * <p>This method requires the caller to have a signature match with the
 * authenticator that manages the specified account.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * AUTHENTICATE_ACCOUNTS permission and same UID as account's authenticator
 * is needed for those platforms. See docs for this function in API level 22.
 *
 * @param account The account whose password is to be set. Cannot be
 * {@code null}.
 * @param password The password to set, null to clear the password
 */

Body of Frist Method:
{
    if (account == null)
        throw new IllegalArgumentException("account is null");
    try {
        mService.setPassword(account, password);
    } catch (RemoteException e) {
        // won't ever happen
        throw new RuntimeException(e);
    }
}
Body of Second Method:
{
    if (account == null)
        throw new IllegalArgumentException("account is null");
    try {
        mService.setPassword(account, password);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.net.NetworkTemplate.matchesMobile:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Check if mobile network with matching IMSI.
 */

Body of Frist Method:
{
    if (ident.mType == TYPE_WIMAX) {
        // TODO: consider matching against WiMAX subscriber identity
        return true;
    } else {
        final boolean matchesType = (sForceAllNetworkTypes || contains(DATA_USAGE_NETWORK_TYPES, ident.mType));
        return matchesType && ArrayUtils.contains(mMatchSubscriberIds, ident.mSubscriberId);
    }
}
Body of Second Method:
{
    if (ident.mType == TYPE_WIMAX) {
        // TODO: consider matching against WiMAX subscriber identity
        return true;
    } else {
        return (sForceAllNetworkTypes || (ident.mType == TYPE_MOBILE && ident.mMetered)) && !ArrayUtils.isEmpty(mMatchSubscriberIds) && ArrayUtils.contains(mMatchSubscriberIds, ident.mSubscriberId);
    }
}
------------------------
Find a silently evolved API code:android.net.NetworkScoreManager.disableScoring:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Turn off network scoring.
 *
 * <p>May only be called by the current scorer app, or the system.
 *
 * @throws SecurityException if the caller is neither the active scorer nor the system.
 */

Body of Frist Method:
{
    try {
        mService.disableScoring();
    } catch (RemoteException e) {
    }
}
Body of Second Method:
{
    try {
        mService.disableScoring();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.telephony.SignalStrength.makeSignalStrengthFromRilParcel:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Make a SignalStrength object from the given parcel as passed up by
 * the ril which does not have isGsm. isGsm will be changed by ServiceStateTracker
 * so the default is a don't care.
 *
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("Size of signalstrength parcel:" + in.dataSize());
    SignalStrength ss = new SignalStrength();
    ss.mGsmSignalStrength = in.readInt();
    ss.mGsmBitErrorRate = in.readInt();
    ss.mCdmaDbm = in.readInt();
    ss.mCdmaEcio = in.readInt();
    ss.mEvdoDbm = in.readInt();
    ss.mEvdoEcio = in.readInt();
    ss.mEvdoSnr = in.readInt();
    ss.mLteSignalStrength = in.readInt();
    ss.mLteRsrp = in.readInt();
    ss.mLteRsrq = in.readInt();
    ss.mLteRssnr = in.readInt();
    ss.mLteCqi = in.readInt();
    return ss;
}
Body of Second Method:
{
    if (DBG)
        log("Size of signalstrength parcel:" + in.dataSize());
    SignalStrength ss = new SignalStrength();
    ss.mGsmSignalStrength = in.readInt();
    ss.mGsmBitErrorRate = in.readInt();
    ss.mCdmaDbm = in.readInt();
    ss.mCdmaEcio = in.readInt();
    ss.mEvdoDbm = in.readInt();
    ss.mEvdoEcio = in.readInt();
    ss.mEvdoSnr = in.readInt();
    ss.mLteSignalStrength = in.readInt();
    ss.mLteRsrp = in.readInt();
    ss.mLteRsrq = in.readInt();
    ss.mLteRssnr = in.readInt();
    ss.mLteCqi = in.readInt();
    ss.mTdScdmaRscp = in.readInt();
    return ss;
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiEnterpriseConfig.setEapMethod:COMMENT
Method Modifier: public      
Comment:/**
 * Set the EAP authentication method.
 * @param  eapMethod is one {@link Eap#PEAP}, {@link Eap#TLS}, {@link Eap#TTLS} or
 * {@link Eap#PWD}
 * @throws IllegalArgumentException on an invalid eap method
 */

Body of Frist Method:
{
    switch(eapMethod) {
        /**
         * Valid methods
         */
        case Eap.TLS:
            setPhase2Method(Phase2.NONE);
        /* fall through */
        case Eap.PEAP:
        case Eap.PWD:
        case Eap.TTLS:
        case Eap.SIM:
        case Eap.AKA:
        case Eap.AKA_PRIME:
            mFields.put(EAP_KEY, Eap.strings[eapMethod]);
            mFields.put(OPP_KEY_CACHING, "1");
            break;
        default:
            throw new IllegalArgumentException("Unknown EAP method");
    }
}
Body of Second Method:
{
    switch(eapMethod) {
        /**
         * Valid methods
         */
        case Eap.TLS:
        case Eap.UNAUTH_TLS:
            setPhase2Method(Phase2.NONE);
        /* fall through */
        case Eap.PEAP:
        case Eap.PWD:
        case Eap.TTLS:
        case Eap.SIM:
        case Eap.AKA:
        case Eap.AKA_PRIME:
            mEapMethod = eapMethod;
            mFields.put(OPP_KEY_CACHING, "1");
            break;
        default:
            throw new IllegalArgumentException("Unknown EAP method");
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothAdapter.setDiscoverableTimeout:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (getState() != STATE_ON)
        return;
    try {
        synchronized (mManagerCallback) {
            if (mService != null)
                mService.setDiscoverableTimeout(timeout);
        }
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
}
Body of Second Method:
{
    if (getState() != STATE_ON)
        return;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            mService.setDiscoverableTimeout(timeout);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiManager.getVerboseLoggingLevel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the WiFi verbose logging level.This is used by settings
 * to decide what to show within the picker.
 * @hide
 */

Body of Frist Method:
{
    try {
        return mService.getVerboseLoggingLevel();
    } catch (RemoteException e) {
        return 0;
    }
}
Body of Second Method:
{
    try {
        return mService.getVerboseLoggingLevel();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.appwidget.AppWidgetManager.bindRemoteViewsService:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Binds the RemoteViewsService for a given appWidgetId and intent.
 *
 * The appWidgetId specified must already be bound to the calling AppWidgetHost via
 * {@link android.appwidget.AppWidgetManager#bindAppWidgetId AppWidgetManager.bindAppWidgetId()}.
 *
 * @param packageName   The package from which the binding is requested.
 * @param appWidgetId   The AppWidget instance for which to bind the RemoteViewsService.
 * @param intent        The intent of the service which will be providing the data to the
 * RemoteViewsAdapter.
 * @param connection    The callback interface to be notified when a connection is made or lost.
 * @hide
 */

Body of Frist Method:
{
    if (mService == null) {
        return;
    }
    try {
        mService.bindRemoteViewsService(packageName, appWidgetId, intent, connection);
    } catch (RemoteException e) {
        throw new RuntimeException("system server dead?", e);
    }
}
Body of Second Method:
{
    if (mService == null) {
        return;
    }
    try {
        mService.bindRemoteViewsService(packageName, appWidgetId, intent, connection);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.os.Process.startViaZygote:COMMENT
Method Modifier: private     static      
Comment:/**
 * Starts a new process via the zygote mechanism.
 *
 * @param processClass Class name whose static main() to run
 * @param niceName 'nice' process name to appear in ps
 * @param uid a POSIX uid that the new process should setuid() to
 * @param gid a POSIX gid that the new process shuold setgid() to
 * @param gids null-ok; a list of supplementary group IDs that the
 * new process should setgroup() to.
 * @param debugFlags Additional flags.
 * @param targetSdkVersion The target SDK version for the app.
 * @param seInfo null-ok SELinux information for the new process.
 * @param abi the ABI the process should use.
 * @param instructionSet null-ok the instruction set to use.
 * @param appDataDir null-ok the data directory of the app.
 * @param extraArgs Additional arguments to supply to the zygote process.
 * @return An object that describes the result of the attempt to start the process.
 * @throws ZygoteStartFailedEx if process start failed for any reason
 */

Body of Frist Method:
{
    synchronized (Process.class) {
        ArrayList<String> argsForZygote = new ArrayList<String>();
        // --runtime-args, --setuid=, --setgid=,
        // and --setgroups= must go first
        argsForZygote.add("--runtime-args");
        argsForZygote.add("--setuid=" + uid);
        argsForZygote.add("--setgid=" + gid);
        if ((debugFlags & Zygote.DEBUG_ENABLE_JNI_LOGGING) != 0) {
            argsForZygote.add("--enable-jni-logging");
        }
        if ((debugFlags & Zygote.DEBUG_ENABLE_SAFEMODE) != 0) {
            argsForZygote.add("--enable-safemode");
        }
        if ((debugFlags & Zygote.DEBUG_ENABLE_DEBUGGER) != 0) {
            argsForZygote.add("--enable-debugger");
        }
        if ((debugFlags & Zygote.DEBUG_ENABLE_CHECKJNI) != 0) {
            argsForZygote.add("--enable-checkjni");
        }
        if ((debugFlags & Zygote.DEBUG_ENABLE_JIT) != 0) {
            argsForZygote.add("--enable-jit");
        }
        if ((debugFlags & Zygote.DEBUG_GENERATE_DEBUG_INFO) != 0) {
            argsForZygote.add("--generate-debug-info");
        }
        if ((debugFlags & Zygote.DEBUG_ENABLE_ASSERT) != 0) {
            argsForZygote.add("--enable-assert");
        }
        if (mountExternal == Zygote.MOUNT_EXTERNAL_DEFAULT) {
            argsForZygote.add("--mount-external-default");
        } else if (mountExternal == Zygote.MOUNT_EXTERNAL_READ) {
            argsForZygote.add("--mount-external-read");
        } else if (mountExternal == Zygote.MOUNT_EXTERNAL_WRITE) {
            argsForZygote.add("--mount-external-write");
        }
        argsForZygote.add("--target-sdk-version=" + targetSdkVersion);
        // --setgroups is a comma-separated list
        if (gids != null && gids.length > 0) {
            StringBuilder sb = new StringBuilder();
            sb.append("--setgroups=");
            int sz = gids.length;
            for (int i = 0; i < sz; i++) {
                if (i != 0) {
                    sb.append(',');
                }
                sb.append(gids[i]);
            }
            argsForZygote.add(sb.toString());
        }
        if (niceName != null) {
            argsForZygote.add("--nice-name=" + niceName);
        }
        if (seInfo != null) {
            argsForZygote.add("--seinfo=" + seInfo);
        }
        if (instructionSet != null) {
            argsForZygote.add("--instruction-set=" + instructionSet);
        }
        if (appDataDir != null) {
            argsForZygote.add("--app-data-dir=" + appDataDir);
        }
        argsForZygote.add(processClass);
        if (extraArgs != null) {
            for (String arg : extraArgs) {
                argsForZygote.add(arg);
            }
        }
        return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);
    }
}
Body of Second Method:
{
    synchronized (Process.class) {
        ArrayList<String> argsForZygote = new ArrayList<String>();
        // --runtime-args, --setuid=, --setgid=,
        // and --setgroups= must go first
        argsForZygote.add("--runtime-args");
        argsForZygote.add("--setuid=" + uid);
        argsForZygote.add("--setgid=" + gid);
        if ((debugFlags & Zygote.DEBUG_ENABLE_JNI_LOGGING) != 0) {
            argsForZygote.add("--enable-jni-logging");
        }
        if ((debugFlags & Zygote.DEBUG_ENABLE_SAFEMODE) != 0) {
            argsForZygote.add("--enable-safemode");
        }
        if ((debugFlags & Zygote.DEBUG_ENABLE_DEBUGGER) != 0) {
            argsForZygote.add("--enable-debugger");
        }
        if ((debugFlags & Zygote.DEBUG_ENABLE_CHECKJNI) != 0) {
            argsForZygote.add("--enable-checkjni");
        }
        if ((debugFlags & Zygote.DEBUG_GENERATE_DEBUG_INFO) != 0) {
            argsForZygote.add("--generate-debug-info");
        }
        if ((debugFlags & Zygote.DEBUG_ALWAYS_JIT) != 0) {
            argsForZygote.add("--always-jit");
        }
        if ((debugFlags & Zygote.DEBUG_NATIVE_DEBUGGABLE) != 0) {
            argsForZygote.add("--native-debuggable");
        }
        if ((debugFlags & Zygote.DEBUG_ENABLE_ASSERT) != 0) {
            argsForZygote.add("--enable-assert");
        }
        if (mountExternal == Zygote.MOUNT_EXTERNAL_DEFAULT) {
            argsForZygote.add("--mount-external-default");
        } else if (mountExternal == Zygote.MOUNT_EXTERNAL_READ) {
            argsForZygote.add("--mount-external-read");
        } else if (mountExternal == Zygote.MOUNT_EXTERNAL_WRITE) {
            argsForZygote.add("--mount-external-write");
        }
        argsForZygote.add("--target-sdk-version=" + targetSdkVersion);
        // --setgroups is a comma-separated list
        if (gids != null && gids.length > 0) {
            StringBuilder sb = new StringBuilder();
            sb.append("--setgroups=");
            int sz = gids.length;
            for (int i = 0; i < sz; i++) {
                if (i != 0) {
                    sb.append(',');
                }
                sb.append(gids[i]);
            }
            argsForZygote.add(sb.toString());
        }
        if (niceName != null) {
            argsForZygote.add("--nice-name=" + niceName);
        }
        if (seInfo != null) {
            argsForZygote.add("--seinfo=" + seInfo);
        }
        if (instructionSet != null) {
            argsForZygote.add("--instruction-set=" + instructionSet);
        }
        if (appDataDir != null) {
            argsForZygote.add("--app-data-dir=" + appDataDir);
        }
        argsForZygote.add(processClass);
        if (extraArgs != null) {
            for (String arg : extraArgs) {
                argsForZygote.add(arg);
            }
        }
        return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);
    }
}
------------------------
Find a silently evolved API code:android.graphics.Path_Delegate.cubicTo:COMMENT
<android.graphics.Path_Delegate: void cubicTo(float,float,float,float,float,float)>
private     ->public      
Method Modifier: public      private     
Method Modifier: No          Yes         
Method Updated:  Yes         No          
Comment:/**
 * Add a cubic bezier from the last point, approaching control points
 * (x1,y1) and (x2,y2), and ending at (x3,y3). If no moveTo() call has been
 * made for this contour, the first point is automatically set to (0,0).
 *
 * @param x1 The x-coordinate of the 1st control point on a cubic curve
 * @param y1 The y-coordinate of the 1st control point on a cubic curve
 * @param x2 The x-coordinate of the 2nd control point on a cubic curve
 * @param y2 The y-coordinate of the 2nd control point on a cubic curve
 * @param x3 The x-coordinate of the end point on a cubic curve
 * @param y3 The y-coordinate of the end point on a cubic curve
 */

Body of Frist Method:
{
    mPath.curveTo(x1, y1, x2, y2, mLastX = x3, mLastY = y3);
}
Body of Second Method:
{
    if (!hasPoints()) {
        mPath.moveTo(0, 0);
    }
    mPath.curveTo(x1, y1, x2, y2, mLastX = x3, mLastY = y3);
}
------------------------
Find a silently evolved API code:android.webkit.WebViewFragment.onCreateView:COMMENT
Method Modifier: public      
Comment:/**
 * Called to instantiate the view. Creates and returns the WebView.
 */

Body of Frist Method:
{
    if (mWebView != null) {
        mWebView.destroy();
    }
    mWebView = new WebView(getActivity());
    mIsWebViewAvailable = true;
    return mWebView;
}
Body of Second Method:
{
    if (mWebView != null) {
        mWebView.destroy();
    }
    mWebView = new WebView(getContext());
    mIsWebViewAvailable = true;
    return mWebView;
}
------------------------
Find a silently evolved API code:android.app.Activity.finish:COMMENT
Method Modifier: public      
Comment:/**
 * Call this when your activity is done and should be closed.  The
 * ActivityResult is propagated back to whoever launched you via
 * onActivityResult().
 */

Body of Frist Method:
{
    finish(false);
}
Body of Second Method:
{
    finish(DONT_FINISH_TASK_WITH_ACTIVITY);
}
------------------------
Find a silently evolved API code:android.location.Location.removeAltitude:COMMENT
Method Modifier: public      
Comment:/**
 * Remove the altitude from this location.
 *
 * <p>Following this call {@link #hasAltitude} will return false,
 * and {@link #getAltitude} will return 0.0.
 */

Body of Frist Method:
{
    mAltitude = 0.0f;
    mHasAltitude = false;
}
Body of Second Method:
{
    mAltitude = 0.0f;
    mFieldsMask &= ~HAS_ALTITUDE_MASK;
}
------------------------
Find a silently evolved API code:android.app.Service.startForeground:COMMENT
Method Modifier: public      final       
Comment:/**
 * Make this service run in the foreground, supplying the ongoing
 * notification to be shown to the user while in this state.
 * By default services are background, meaning that if the system needs to
 * kill them to reclaim more memory (such as to display a large page in a
 * web browser), they can be killed without too much harm.  You can set this
 * flag if killing your service would be disruptive to the user, such as
 * if your service is performing background music playback, so the user
 * would notice if their music stopped playing.
 *
 * <p>If you need your application to run on platform versions prior to API
 * level 5, you can use the following model to call the the older setForeground()
 * or this modern method as appropriate:
 *
 * {@sample development/samples/ApiDemos/src/com/example/android/apis/app/ForegroundService.java
 * foreground_compatibility}
 *
 * @param id The identifier for this notification as per
 * {@link NotificationManager#notify(int, Notification)
 * NotificationManager.notify(int, Notification)}; must not be 0.
 * @param notification The Notification to be displayed.
 *
 * @see #stopForeground(boolean)
 */

Body of Frist Method:
{
    try {
        mActivityManager.setServiceForeground(new ComponentName(this, mClassName), mToken, id, notification, true);
    } catch (RemoteException ex) {
    }
}
Body of Second Method:
{
    try {
        mActivityManager.setServiceForeground(new ComponentName(this, mClassName), mToken, id, notification, 0);
    } catch (RemoteException ex) {
    }
}
------------------------
Find a silently evolved API code:android.widget.TimePicker.setHour:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the currently selected hour using 24-hour time.
 *
 * @param hour the hour to set, in the range (0-23)
 * @see #getHour()
 */

Body of Frist Method:
{
    mDelegate.setCurrentHour(hour);
}
Body of Second Method:
{
    mDelegate.setHour(hour);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothAdapter.configHciSnoopLog:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * enable or disable Bluetooth HCI snoop log.
 *
 * <p>Requires the {@link android.Manifest.permission#BLUETOOTH_ADMIN}
 * permission
 *
 * @return true to indicate configure HCI log successfully, or false on
 * immediate error
 * @hide
 */

Body of Frist Method:
{
    try {
        synchronized (mManagerCallback) {
            if (mService != null)
                return mService.configHciSnoopLog(enable);
        }
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
Body of Second Method:
{
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.configHciSnoopLog(enable);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}
------------------------
Find a silently evolved API code:android.app.StatusBarManager.disable:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Disable some features in the status bar.  Pass the bitwise-or of the DISABLE_* flags.
 * To re-enable everything, pass {@link #DISABLE_NONE}.
 */

Body of Frist Method:
{
    try {
        final IStatusBarService svc = getService();
        if (svc != null) {
            svc.disable(what, mToken, mContext.getPackageName());
        }
    } catch (RemoteException ex) {
        // system process is dead anyway.
        throw new RuntimeException(ex);
    }
}
Body of Second Method:
{
    try {
        final IStatusBarService svc = getService();
        if (svc != null) {
            svc.disable(what, mToken, mContext.getPackageName());
        }
    } catch (RemoteException ex) {
        throw ex.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.telephony.TelephonyManager.isNetworkRoaming:COMMENT
Method Modifier: public      
Comment:/**
 * Returns true if the device is considered roaming on the current
 * network, for GSM purposes.
 * <p>
 * Availability: Only when user registered to a network.
 */

Body of Frist Method:
{
    return isNetworkRoaming(getDefaultSubscription());
}
Body of Second Method:
{
    return isNetworkRoaming(getSubId());
}
------------------------
Find a silently evolved API code:android.app.ActivityManager.getRunningServiceControlPanel:COMMENT
Method Modifier: public      
Comment:/**
 * Returns a PendingIntent you can start to show a control panel for the
 * given running service.  If the service does not have a control panel,
 * null is returned.
 */

Body of Frist Method:
{
    try {
        return ActivityManagerNative.getDefault().getRunningServiceControlPanel(service);
    } catch (RemoteException e) {
        // System dead, we will be dead too soon!
        return null;
    }
}
Body of Second Method:
{
    try {
        return ActivityManagerNative.getDefault().getRunningServiceControlPanel(service);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.graphics.Bitmap.getPixels:COMMENT
Method Modifier: public      
Comment:/**
 * Returns in pixels[] a copy of the data in the bitmap. Each value is
 * a packed int representing a {@link Color}. The stride parameter allows
 * the caller to allow for gaps in the returned pixels array between
 * rows. For normal packed results, just pass width for the stride value.
 * The returned colors are non-premultiplied ARGB values.
 *
 * @param pixels   The array to receive the bitmap's colors
 * @param offset   The first index to write into pixels[]
 * @param stride   The number of entries in pixels[] to skip between
 * rows (must be >= bitmap's width). Can be negative.
 * @param x        The x coordinate of the first pixel to read from
 * the bitmap
 * @param y        The y coordinate of the first pixel to read from
 * the bitmap
 * @param width    The number of pixels to read from each row
 * @param height   The number of rows to read
 *
 * @throws IllegalArgumentException if x, y, width, height exceed the
 * bounds of the bitmap, or if abs(stride) < width.
 * @throws ArrayIndexOutOfBoundsException if the pixels array is too small
 * to receive the specified number of pixels.
 */

Body of Frist Method:
{
    checkRecycled("Can't call getPixels() on a recycled bitmap");
    if (width == 0 || height == 0) {
        // nothing to do
        return;
    }
    checkPixelsAccess(x, y, width, height, offset, stride, pixels);
    nativeGetPixels(mFinalizer.mNativeBitmap, pixels, offset, stride, x, y, width, height);
}
Body of Second Method:
{
    checkRecycled("Can't call getPixels() on a recycled bitmap");
    if (width == 0 || height == 0) {
        // nothing to do
        return;
    }
    checkPixelsAccess(x, y, width, height, offset, stride, pixels);
    nativeGetPixels(mNativePtr, pixels, offset, stride, x, y, width, height);
}
------------------------
Find a silently evolved API code:android.security.Credentials.convertFromPem:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Convert objects from PEM format, which is used for
 * CA_CERTIFICATE and USER_CERTIFICATE entries.
 */

Body of Frist Method:
{
    ByteArrayInputStream bai = new ByteArrayInputStream(bytes);
    Reader reader = new InputStreamReader(bai, StandardCharsets.US_ASCII);
    PemReader pr = new PemReader(reader);
    CertificateFactory cf = CertificateFactory.getInstance("X509");
    List<X509Certificate> result = new ArrayList<X509Certificate>();
    PemObject o;
    while ((o = pr.readPemObject()) != null) {
        if (o.getType().equals("CERTIFICATE")) {
            Certificate c = cf.generateCertificate(new ByteArrayInputStream(o.getContent()));
            result.add((X509Certificate) c);
        } else {
            throw new IllegalArgumentException("Unknown type " + o.getType());
        }
    }
    pr.close();
    return result;
}
Body of Second Method:
{
    ByteArrayInputStream bai = new ByteArrayInputStream(bytes);
    Reader reader = new InputStreamReader(bai, StandardCharsets.US_ASCII);
    PemReader pr = new PemReader(reader);
    try {
        CertificateFactory cf = CertificateFactory.getInstance("X509");
        List<X509Certificate> result = new ArrayList<X509Certificate>();
        PemObject o;
        while ((o = pr.readPemObject()) != null) {
            if (o.getType().equals("CERTIFICATE")) {
                Certificate c = cf.generateCertificate(new ByteArrayInputStream(o.getContent()));
                result.add((X509Certificate) c);
            } else {
                throw new IllegalArgumentException("Unknown type " + o.getType());
            }
        }
        return result;
    } finally {
        pr.close();
    }
}
------------------------
Find a silently evolved API code:android.telecom.Log.pii:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Redact personally identifiable information for production users.
 * If we are running in verbose mode, return the original string, otherwise
 * return a SHA-1 hash of the input string.
 */

Body of Frist Method:
{
    if (pii == null || VERBOSE) {
        return String.valueOf(pii);
    }
    return "[" + secureHash(String.valueOf(pii).getBytes()) + "]";
}
Body of Second Method:
{
    if (pii == null || VERBOSE) {
        return String.valueOf(pii);
    }
    if (pii instanceof Uri) {
        return piiUri((Uri) pii);
    }
    return "[" + secureHash(String.valueOf(pii).getBytes()) + "]";
}
------------------------
Find a silently evolved API code:android.telephony.CellSignalStrengthGsm.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Implement the Parcelable interface
 */

Body of Frist Method:
{
    if (DBG)
        log("writeToParcel(Parcel, int): " + toString());
    dest.writeInt(mSignalStrength);
    dest.writeInt(mBitErrorRate);
}
Body of Second Method:
{
    if (DBG)
        log("writeToParcel(Parcel, int): " + toString());
    dest.writeInt(mSignalStrength);
    dest.writeInt(mBitErrorRate);
    dest.writeInt(mTimingAdvance);
}
------------------------
Find a silently evolved API code:android.widget.TimePickerSpinnerDelegate.setDividerText:COMMENT
Method Modifier: private     
Comment:/**
 * The time separator is defined in the Unicode CLDR and cannot be supposed to be ":".
 *
 * See http://unicode.org/cldr/trac/browser/trunk/common/main
 *
 * We pass the correct "skeleton" depending on 12 or 24 hours view and then extract the
 * separator as the character which is just after the hour marker in the returned pattern.
 */

Body of Frist Method:
{
    final String skeleton = (mIs24HourView) ? "Hm" : "hm";
    final String bestDateTimePattern = DateFormat.getBestDateTimePattern(mCurrentLocale, skeleton);
    final String separatorText;
    int hourIndex = bestDateTimePattern.lastIndexOf('H');
    if (hourIndex == -1) {
        hourIndex = bestDateTimePattern.lastIndexOf('h');
    }
    if (hourIndex == -1) {
        // Default case
        separatorText = ":";
    } else {
        int minuteIndex = bestDateTimePattern.indexOf('m', hourIndex + 1);
        if (minuteIndex == -1) {
            separatorText = Character.toString(bestDateTimePattern.charAt(hourIndex + 1));
        } else {
            separatorText = bestDateTimePattern.substring(hourIndex + 1, minuteIndex);
        }
    }
    mDivider.setText(separatorText);
}
Body of Second Method:
{
    final String skeleton = (mIs24HourView) ? "Hm" : "hm";
    final String bestDateTimePattern = DateFormat.getBestDateTimePattern(mLocale, skeleton);
    final String separatorText;
    int hourIndex = bestDateTimePattern.lastIndexOf('H');
    if (hourIndex == -1) {
        hourIndex = bestDateTimePattern.lastIndexOf('h');
    }
    if (hourIndex == -1) {
        // Default case
        separatorText = ":";
    } else {
        int minuteIndex = bestDateTimePattern.indexOf('m', hourIndex + 1);
        if (minuteIndex == -1) {
            separatorText = Character.toString(bestDateTimePattern.charAt(hourIndex + 1));
        } else {
            separatorText = bestDateTimePattern.substring(hourIndex + 1, minuteIndex);
        }
    }
    mDivider.setText(separatorText);
}
------------------------
Find a silently evolved API code:android.location.Location.hasAccuracy:COMMENT
Method Modifier: public      
Comment:/**
 * True if this location has an accuracy.
 *
 * <p>All locations generated by the {@link LocationManager} have an
 * accuracy.
 */

Body of Frist Method:
{
    return mHasAccuracy;
}
Body of Second Method:
{
    return (mFieldsMask & HAS_ACCURACY_MASK) != 0;
}
------------------------
Find a silently evolved API code:android.media.AudioManager.forceVolumeControlStream:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * forces the stream controlled by hard volume keys
 * specifying streamType == -1 releases control to the
 * logic.
 *
 * @hide
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        service.forceVolumeControlStream(streamType, mICallBack);
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in forceVolumeControlStream", e);
    }
}
Body of Second Method:
{
    IAudioService service = getService();
    try {
        service.forceVolumeControlStream(streamType, mICallBack);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.hardware.usb.UsbManager.openAccessory:COMMENT
Method Modifier: public      
Comment:/**
 * Opens a file descriptor for reading and writing data to the USB accessory.
 *
 * @param accessory the USB accessory to open
 * @return file descriptor, or null if the accessor could not be opened.
 */

Body of Frist Method:
{
    try {
        return mService.openAccessory(accessory);
    } catch (RemoteException e) {
        Log.e(TAG, "RemoteException in openAccessory", e);
        return null;
    }
}
Body of Second Method:
{
    try {
        return mService.openAccessory(accessory);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.app.UiModeManager.enableCarMode:COMMENT
Method Modifier: public      
Comment:/**
 * Force device into car mode, like it had been placed in the car dock.
 * This will cause the device to switch to the car home UI as part of
 * the mode switch.
 * @param flags Must be 0.
 */

Body of Frist Method:
{
    if (mService != null) {
        try {
            mService.enableCarMode(flags);
        } catch (RemoteException e) {
            Log.e(TAG, "disableCarMode: RemoteException", e);
        }
    }
}
Body of Second Method:
{
    if (mService != null) {
        try {
            mService.enableCarMode(flags);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}
------------------------
Find a silently evolved API code:android.app.SearchManager.getSearchableInfo:COMMENT
Method Modifier: public      
Comment:/**
 * Gets information about a searchable activity.
 *
 * @param componentName The activity to get searchable information for.
 * @return Searchable information, or <code>null</code> if the activity does not
 * exist, or is not searchable.
 */

Body of Frist Method:
{
    try {
        return mService.getSearchableInfo(componentName);
    } catch (RemoteException ex) {
        Log.e(TAG, "getSearchableInfo() failed: " + ex);
        return null;
    }
}
Body of Second Method:
{
    try {
        return mService.getSearchableInfo(componentName);
    } catch (RemoteException ex) {
        throw ex.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.telephony.SubscriptionManager.getSimStateForSlotIdx:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Returns a constant indicating the state of sim for the slot idx.
 *
 * @param slotIdx
 *
 * {@See TelephonyManager#SIM_STATE_UNKNOWN}
 * {@See TelephonyManager#SIM_STATE_ABSENT}
 * {@See TelephonyManager#SIM_STATE_PIN_REQUIRED}
 * {@See TelephonyManager#SIM_STATE_PUK_REQUIRED}
 * {@See TelephonyManager#SIM_STATE_NETWORK_LOCKED}
 * {@See TelephonyManager#SIM_STATE_READY}
 * {@See TelephonyManager#SIM_STATE_NOT_READY}
 * {@See TelephonyManager#SIM_STATE_PERM_DISABLED}
 * {@See TelephonyManager#SIM_STATE_CARD_IO_ERROR}
 *
 * {@hide}
 */

Body of Frist Method:
{
    int simState = TelephonyManager.SIM_STATE_UNKNOWN;
    try {
        ISub iSub = ISub.Stub.asInterface(ServiceManager.getService("isub"));
        if (iSub != null) {
            simState = iSub.getSimStateForSlotIdx(slotIdx);
        }
    } catch (RemoteException ex) {
    }
    logd("getSimStateForSubscriber: simState=" + simState + " slotIdx=" + slotIdx);
    return simState;
}
Body of Second Method:
{
    int simState = TelephonyManager.SIM_STATE_UNKNOWN;
    try {
        ISub iSub = ISub.Stub.asInterface(ServiceManager.getService("isub"));
        if (iSub != null) {
            simState = iSub.getSimStateForSlotIdx(slotIdx);
        }
    } catch (RemoteException ex) {
    }
    return simState;
}
------------------------
Find a silently evolved API code:android.widget.RelativeLayout.LayoutParams.resolveRules:COMMENT
Method Modifier: private     
Comment:// only the "left"/"right" rules at the end.

Body of Frist Method:
{
    final boolean isLayoutRtl = (layoutDirection == View.LAYOUT_DIRECTION_RTL);
    // Reset to initial state
    System.arraycopy(mInitialRules, LEFT_OF, mRules, LEFT_OF, VERB_COUNT);
    // Apply rules depending on direction and if we are in RTL compatibility mode
    if (mIsRtlCompatibilityMode) {
        if (mRules[ALIGN_START] != 0) {
            if (mRules[ALIGN_LEFT] == 0) {
                // "left" rule is not defined but "start" rule is: use the "start" rule as
                // the "left" rule
                mRules[ALIGN_LEFT] = mRules[ALIGN_START];
            }
            mRules[ALIGN_START] = 0;
        }
        if (mRules[ALIGN_END] != 0) {
            if (mRules[ALIGN_RIGHT] == 0) {
                // "right" rule is not defined but "end" rule is: use the "end" rule as the
                // "right" rule
                mRules[ALIGN_RIGHT] = mRules[ALIGN_END];
            }
            mRules[ALIGN_END] = 0;
        }
        if (mRules[START_OF] != 0) {
            if (mRules[LEFT_OF] == 0) {
                // "left" rule is not defined but "start" rule is: use the "start" rule as
                // the "left" rule
                mRules[LEFT_OF] = mRules[START_OF];
            }
            mRules[START_OF] = 0;
        }
        if (mRules[END_OF] != 0) {
            if (mRules[RIGHT_OF] == 0) {
                // "right" rule is not defined but "end" rule is: use the "end" rule as the
                // "right" rule
                mRules[RIGHT_OF] = mRules[END_OF];
            }
            mRules[END_OF] = 0;
        }
        if (mRules[ALIGN_PARENT_START] != 0) {
            if (mRules[ALIGN_PARENT_LEFT] == 0) {
                // "left" rule is not defined but "start" rule is: use the "start" rule as
                // the "left" rule
                mRules[ALIGN_PARENT_LEFT] = mRules[ALIGN_PARENT_START];
            }
            mRules[ALIGN_PARENT_START] = 0;
        }
        if (mRules[ALIGN_PARENT_END] != 0) {
            if (mRules[ALIGN_PARENT_RIGHT] == 0) {
                // "right" rule is not defined but "end" rule is: use the "end" rule as the
                // "right" rule
                mRules[ALIGN_PARENT_RIGHT] = mRules[ALIGN_PARENT_END];
            }
            mRules[ALIGN_PARENT_END] = 0;
        }
    } else {
        // JB MR1+ case
        if ((mRules[ALIGN_START] != 0 || mRules[ALIGN_END] != 0) && (mRules[ALIGN_LEFT] != 0 || mRules[ALIGN_RIGHT] != 0)) {
            // "start"/"end" rules take precedence over "left"/"right" rules
            mRules[ALIGN_LEFT] = 0;
            mRules[ALIGN_RIGHT] = 0;
        }
        if (mRules[ALIGN_START] != 0) {
            // "start" rule resolved to "left" or "right" depending on the direction
            mRules[isLayoutRtl ? ALIGN_RIGHT : ALIGN_LEFT] = mRules[ALIGN_START];
            mRules[ALIGN_START] = 0;
        }
        if (mRules[ALIGN_END] != 0) {
            // "end" rule resolved to "left" or "right" depending on the direction
            mRules[isLayoutRtl ? ALIGN_LEFT : ALIGN_RIGHT] = mRules[ALIGN_END];
            mRules[ALIGN_END] = 0;
        }
        if ((mRules[START_OF] != 0 || mRules[END_OF] != 0) && (mRules[LEFT_OF] != 0 || mRules[RIGHT_OF] != 0)) {
            // "start"/"end" rules take precedence over "left"/"right" rules
            mRules[LEFT_OF] = 0;
            mRules[RIGHT_OF] = 0;
        }
        if (mRules[START_OF] != 0) {
            // "start" rule resolved to "left" or "right" depending on the direction
            mRules[isLayoutRtl ? RIGHT_OF : LEFT_OF] = mRules[START_OF];
            mRules[START_OF] = 0;
        }
        if (mRules[END_OF] != 0) {
            // "end" rule resolved to "left" or "right" depending on the direction
            mRules[isLayoutRtl ? LEFT_OF : RIGHT_OF] = mRules[END_OF];
            mRules[END_OF] = 0;
        }
        if ((mRules[ALIGN_PARENT_START] != 0 || mRules[ALIGN_PARENT_END] != 0) && (mRules[ALIGN_PARENT_LEFT] != 0 || mRules[ALIGN_PARENT_RIGHT] != 0)) {
            // "start"/"end" rules take precedence over "left"/"right" rules
            mRules[ALIGN_PARENT_LEFT] = 0;
            mRules[ALIGN_PARENT_RIGHT] = 0;
        }
        if (mRules[ALIGN_PARENT_START] != 0) {
            // "start" rule resolved to "left" or "right" depending on the direction
            mRules[isLayoutRtl ? ALIGN_PARENT_RIGHT : ALIGN_PARENT_LEFT] = mRules[ALIGN_PARENT_START];
            mRules[ALIGN_PARENT_START] = 0;
        }
        if (mRules[ALIGN_PARENT_END] != 0) {
            // "end" rule resolved to "left" or "right" depending on the direction
            mRules[isLayoutRtl ? ALIGN_PARENT_LEFT : ALIGN_PARENT_RIGHT] = mRules[ALIGN_PARENT_END];
            mRules[ALIGN_PARENT_END] = 0;
        }
    }
    mRulesChanged = false;
}
Body of Second Method:
{
    final boolean isLayoutRtl = (layoutDirection == View.LAYOUT_DIRECTION_RTL);
    // Reset to initial state
    System.arraycopy(mInitialRules, LEFT_OF, mRules, LEFT_OF, VERB_COUNT);
    // Apply rules depending on direction and if we are in RTL compatibility mode
    if (mIsRtlCompatibilityMode) {
        if (mRules[ALIGN_START] != 0) {
            if (mRules[ALIGN_LEFT] == 0) {
                // "left" rule is not defined but "start" rule is: use the "start" rule as
                // the "left" rule
                mRules[ALIGN_LEFT] = mRules[ALIGN_START];
            }
            mRules[ALIGN_START] = 0;
        }
        if (mRules[ALIGN_END] != 0) {
            if (mRules[ALIGN_RIGHT] == 0) {
                // "right" rule is not defined but "end" rule is: use the "end" rule as the
                // "right" rule
                mRules[ALIGN_RIGHT] = mRules[ALIGN_END];
            }
            mRules[ALIGN_END] = 0;
        }
        if (mRules[START_OF] != 0) {
            if (mRules[LEFT_OF] == 0) {
                // "left" rule is not defined but "start" rule is: use the "start" rule as
                // the "left" rule
                mRules[LEFT_OF] = mRules[START_OF];
            }
            mRules[START_OF] = 0;
        }
        if (mRules[END_OF] != 0) {
            if (mRules[RIGHT_OF] == 0) {
                // "right" rule is not defined but "end" rule is: use the "end" rule as the
                // "right" rule
                mRules[RIGHT_OF] = mRules[END_OF];
            }
            mRules[END_OF] = 0;
        }
        if (mRules[ALIGN_PARENT_START] != 0) {
            if (mRules[ALIGN_PARENT_LEFT] == 0) {
                // "left" rule is not defined but "start" rule is: use the "start" rule as
                // the "left" rule
                mRules[ALIGN_PARENT_LEFT] = mRules[ALIGN_PARENT_START];
            }
            mRules[ALIGN_PARENT_START] = 0;
        }
        if (mRules[ALIGN_PARENT_END] != 0) {
            if (mRules[ALIGN_PARENT_RIGHT] == 0) {
                // "right" rule is not defined but "end" rule is: use the "end" rule as the
                // "right" rule
                mRules[ALIGN_PARENT_RIGHT] = mRules[ALIGN_PARENT_END];
            }
            mRules[ALIGN_PARENT_END] = 0;
        }
    } else {
        // JB MR1+ case
        if ((mRules[ALIGN_START] != 0 || mRules[ALIGN_END] != 0) && (mRules[ALIGN_LEFT] != 0 || mRules[ALIGN_RIGHT] != 0)) {
            // "start"/"end" rules take precedence over "left"/"right" rules
            mRules[ALIGN_LEFT] = 0;
            mRules[ALIGN_RIGHT] = 0;
        }
        if (mRules[ALIGN_START] != 0) {
            // "start" rule resolved to "left" or "right" depending on the direction
            mRules[isLayoutRtl ? ALIGN_RIGHT : ALIGN_LEFT] = mRules[ALIGN_START];
            mRules[ALIGN_START] = 0;
        }
        if (mRules[ALIGN_END] != 0) {
            // "end" rule resolved to "left" or "right" depending on the direction
            mRules[isLayoutRtl ? ALIGN_LEFT : ALIGN_RIGHT] = mRules[ALIGN_END];
            mRules[ALIGN_END] = 0;
        }
        if ((mRules[START_OF] != 0 || mRules[END_OF] != 0) && (mRules[LEFT_OF] != 0 || mRules[RIGHT_OF] != 0)) {
            // "start"/"end" rules take precedence over "left"/"right" rules
            mRules[LEFT_OF] = 0;
            mRules[RIGHT_OF] = 0;
        }
        if (mRules[START_OF] != 0) {
            // "start" rule resolved to "left" or "right" depending on the direction
            mRules[isLayoutRtl ? RIGHT_OF : LEFT_OF] = mRules[START_OF];
            mRules[START_OF] = 0;
        }
        if (mRules[END_OF] != 0) {
            // "end" rule resolved to "left" or "right" depending on the direction
            mRules[isLayoutRtl ? LEFT_OF : RIGHT_OF] = mRules[END_OF];
            mRules[END_OF] = 0;
        }
        if ((mRules[ALIGN_PARENT_START] != 0 || mRules[ALIGN_PARENT_END] != 0) && (mRules[ALIGN_PARENT_LEFT] != 0 || mRules[ALIGN_PARENT_RIGHT] != 0)) {
            // "start"/"end" rules take precedence over "left"/"right" rules
            mRules[ALIGN_PARENT_LEFT] = 0;
            mRules[ALIGN_PARENT_RIGHT] = 0;
        }
        if (mRules[ALIGN_PARENT_START] != 0) {
            // "start" rule resolved to "left" or "right" depending on the direction
            mRules[isLayoutRtl ? ALIGN_PARENT_RIGHT : ALIGN_PARENT_LEFT] = mRules[ALIGN_PARENT_START];
            mRules[ALIGN_PARENT_START] = 0;
        }
        if (mRules[ALIGN_PARENT_END] != 0) {
            // "end" rule resolved to "left" or "right" depending on the direction
            mRules[isLayoutRtl ? ALIGN_PARENT_LEFT : ALIGN_PARENT_RIGHT] = mRules[ALIGN_PARENT_END];
            mRules[ALIGN_PARENT_END] = 0;
        }
    }
    mRulesChanged = false;
    mNeedsLayoutResolution = false;
}
------------------------
Find a silently evolved API code:android.accounts.AccountManager.getAccountsByTypeForPackage:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the accounts visible to the specified package, in an environment where some apps
 * are not authorized to view all accounts. This method can only be called by system apps.
 * @param type The type of accounts to return, null to retrieve all accounts
 * @param packageName The package name of the app for which the accounts are to be returned
 * @return An array of {@link Account}, one per matching account.  Empty
 * (never null) if no accounts of the specified type have been added.
 */

Body of Frist Method:
{
    try {
        return mService.getAccountsByTypeForPackage(type, packageName, mContext.getOpPackageName());
    } catch (RemoteException re) {
        // won't ever happen
        throw new RuntimeException(re);
    }
}
Body of Second Method:
{
    try {
        return mService.getAccountsByTypeForPackage(type, packageName, mContext.getOpPackageName());
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiScanner.startScan:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * starts a single scan and reports results asynchronously
 * @param settings specifies various parameters for the scan; for more information look at
 * {@link ScanSettings}
 * @param listener specifies the object to report events to. This object is also treated as a
 * key for this scan, and must also be specified to cancel the scan. Multiple
 * scans should also not share this object.
 */

Body of Frist Method:
{
    validateChannel();
    sAsyncChannel.sendMessage(CMD_START_SINGLE_SCAN, 0, putListener(listener), settings);
}
Body of Second Method:
{
    startScan(settings, listener, null);
}
------------------------
Find a silently evolved API code:android.telephony.SignalStrength.toString:COMMENT
Method Modifier: public      
Comment:/**
 * @return string representation.
 */

Body of Frist Method:
{
    return ("SignalStrength:" + " " + mGsmSignalStrength + " " + mGsmBitErrorRate + " " + mCdmaDbm + " " + mCdmaEcio + " " + mEvdoDbm + " " + mEvdoEcio + " " + mEvdoSnr + " " + mLteSignalStrength + " " + mLteRsrp + " " + mLteRsrq + " " + mLteRssnr + " " + mLteCqi + " " + (isGsm ? "gsm|lte" : "cdma"));
}
Body of Second Method:
{
    return ("SignalStrength:" + " " + mGsmSignalStrength + " " + mGsmBitErrorRate + " " + mCdmaDbm + " " + mCdmaEcio + " " + mEvdoDbm + " " + mEvdoEcio + " " + mEvdoSnr + " " + mLteSignalStrength + " " + mLteRsrp + " " + mLteRsrq + " " + mLteRssnr + " " + mLteCqi + " " + mTdScdmaRscp + " " + (isGsm ? "gsm|lte" : "cdma"));
}
------------------------
Find a silently evolved API code:android.app.ActivityOptions.update:COMMENT
Method Modifier: public      
Comment:/**
 * Update the current values in this ActivityOptions from those supplied
 * in <var>otherOptions</var>.  Any values
 * defined in <var>otherOptions</var> replace those in the base options.
 */

Body of Frist Method:
{
    if (otherOptions.mPackageName != null) {
        mPackageName = otherOptions.mPackageName;
    }
    mUsageTimeReport = otherOptions.mUsageTimeReport;
    mTransitionReceiver = null;
    mSharedElementNames = null;
    mIsReturning = false;
    mResultData = null;
    mResultCode = 0;
    mExitCoordinatorIndex = 0;
    mAnimationType = otherOptions.mAnimationType;
    switch(otherOptions.mAnimationType) {
        case ANIM_CUSTOM:
            mCustomEnterResId = otherOptions.mCustomEnterResId;
            mCustomExitResId = otherOptions.mCustomExitResId;
            mThumbnail = null;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = otherOptions.mAnimationStartedListener;
            break;
        case ANIM_CUSTOM_IN_PLACE:
            mCustomInPlaceResId = otherOptions.mCustomInPlaceResId;
            break;
        case ANIM_SCALE_UP:
            mStartX = otherOptions.mStartX;
            mStartY = otherOptions.mStartY;
            mWidth = otherOptions.mWidth;
            mHeight = otherOptions.mHeight;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = null;
            break;
        case ANIM_THUMBNAIL_SCALE_UP:
        case ANIM_THUMBNAIL_SCALE_DOWN:
        case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
        case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
            mThumbnail = otherOptions.mThumbnail;
            mStartX = otherOptions.mStartX;
            mStartY = otherOptions.mStartY;
            mWidth = otherOptions.mWidth;
            mHeight = otherOptions.mHeight;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = otherOptions.mAnimationStartedListener;
            break;
        case ANIM_SCENE_TRANSITION:
            mTransitionReceiver = otherOptions.mTransitionReceiver;
            mSharedElementNames = otherOptions.mSharedElementNames;
            mIsReturning = otherOptions.mIsReturning;
            mThumbnail = null;
            mAnimationStartedListener = null;
            mResultData = otherOptions.mResultData;
            mResultCode = otherOptions.mResultCode;
            mExitCoordinatorIndex = otherOptions.mExitCoordinatorIndex;
            break;
    }
}
Body of Second Method:
{
    if (otherOptions.mPackageName != null) {
        mPackageName = otherOptions.mPackageName;
    }
    mUsageTimeReport = otherOptions.mUsageTimeReport;
    mTransitionReceiver = null;
    mSharedElementNames = null;
    mIsReturning = false;
    mResultData = null;
    mResultCode = 0;
    mExitCoordinatorIndex = 0;
    mAnimationType = otherOptions.mAnimationType;
    switch(otherOptions.mAnimationType) {
        case ANIM_CUSTOM:
            mCustomEnterResId = otherOptions.mCustomEnterResId;
            mCustomExitResId = otherOptions.mCustomExitResId;
            mThumbnail = null;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = otherOptions.mAnimationStartedListener;
            break;
        case ANIM_CUSTOM_IN_PLACE:
            mCustomInPlaceResId = otherOptions.mCustomInPlaceResId;
            break;
        case ANIM_SCALE_UP:
            mStartX = otherOptions.mStartX;
            mStartY = otherOptions.mStartY;
            mWidth = otherOptions.mWidth;
            mHeight = otherOptions.mHeight;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = null;
            break;
        case ANIM_THUMBNAIL_SCALE_UP:
        case ANIM_THUMBNAIL_SCALE_DOWN:
        case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
        case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
            mThumbnail = otherOptions.mThumbnail;
            mStartX = otherOptions.mStartX;
            mStartY = otherOptions.mStartY;
            mWidth = otherOptions.mWidth;
            mHeight = otherOptions.mHeight;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = otherOptions.mAnimationStartedListener;
            break;
        case ANIM_SCENE_TRANSITION:
            mTransitionReceiver = otherOptions.mTransitionReceiver;
            mSharedElementNames = otherOptions.mSharedElementNames;
            mIsReturning = otherOptions.mIsReturning;
            mThumbnail = null;
            mAnimationStartedListener = null;
            mResultData = otherOptions.mResultData;
            mResultCode = otherOptions.mResultCode;
            mExitCoordinatorIndex = otherOptions.mExitCoordinatorIndex;
            break;
    }
    mAnimSpecs = otherOptions.mAnimSpecs;
    mAnimationFinishedListener = otherOptions.mAnimationFinishedListener;
}
------------------------
Find a silently evolved API code:android.hardware.usb.UsbManager.getPorts:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns a list of physical USB ports on the device.
 * <p>
 * This list is guaranteed to contain all dual-role USB Type C ports but it might
 * be missing other ports depending on whether the kernel USB drivers have been
 * updated to publish all of the device's ports through the new "dual_role_usb"
 * device class (which supports all types of ports despite its name).
 * </p>
 *
 * @return The list of USB ports, or null if none.
 *
 * @hide
 */

Body of Frist Method:
{
    try {
        return mService.getPorts();
    } catch (RemoteException e) {
        Log.e(TAG, "RemoteException in getPorts", e);
    }
    return null;
}
Body of Second Method:
{
    try {
        return mService.getPorts();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.content.res.TypedArray.getColor:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the color value for the attribute at <var>index</var>.  If
 * the attribute references a color resource holding a complex
 * {@link android.content.res.ColorStateList}, then the default color from
 * the set is returned.
 * <p>
 * This method will throw an exception if the attribute is defined but is
 * not an integer color or color state list.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute color value, or defValue if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not an integer color or color state list.
 */

Body of Frist Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + AssetManager.STYLE_DATA];
    } else if (type == TypedValue.TYPE_STRING) {
        final TypedValue value = mValue;
        if (getValueAt(index, value)) {
            final ColorStateList csl = mResources.loadColorStateList(value, value.resourceId, mTheme);
            return csl.getDefaultColor();
        }
        return defValue;
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index * AssetManager.STYLE_NUM_ENTRIES, value);
        throw new UnsupportedOperationException("Failed to resolve attribute at index " + index + ": " + value);
    }
    throw new UnsupportedOperationException("Can't convert to color: type=0x" + Integer.toHexString(type));
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    final int attrIndex = index;
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + AssetManager.STYLE_DATA];
    } else if (type == TypedValue.TYPE_STRING) {
        final TypedValue value = mValue;
        if (getValueAt(index, value)) {
            final ColorStateList csl = mResources.loadColorStateList(value, value.resourceId, mTheme);
            return csl.getDefaultColor();
        }
        return defValue;
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index, value);
        throw new UnsupportedOperationException("Failed to resolve attribute at index " + attrIndex + ": " + value);
    }
    throw new UnsupportedOperationException("Can't convert value at index " + attrIndex + " to color: type=0x" + Integer.toHexString(type));
}
------------------------
Find a silently evolved API code:android.content.ClipboardManager.getPrimaryClip:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the current primary clip on the clipboard.
 */

Body of Frist Method:
{
    try {
        return getService().getPrimaryClip(mContext.getOpPackageName());
    } catch (RemoteException e) {
        return null;
    }
}
Body of Second Method:
{
    try {
        return getService().getPrimaryClip(mContext.getOpPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiManager.isMulticastEnabled:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Check multicast filter status.
 *
 * @return true if multicast packets are allowed.
 *
 * @hide pending API council approval
 */

Body of Frist Method:
{
    try {
        return mService.isMulticastEnabled();
    } catch (RemoteException e) {
        return false;
    }
}
Body of Second Method:
{
    try {
        return mService.isMulticastEnabled();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.widget.SimpleMonthView.setFirstDayOfWeek:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the first day of the week.
 *
 * @param weekStart which day the week should start on, valid values are
 * {@link Calendar#SUNDAY} through {@link Calendar#SATURDAY}
 */

Body of Frist Method:
{
    if (isValidDayOfWeek(weekStart)) {
        mWeekStart = weekStart;
    } else {
        mWeekStart = mCalendar.getFirstDayOfWeek();
    }
    // Invalidate cached accessibility information.
    mTouchHelper.invalidateRoot();
    invalidate();
}
Body of Second Method:
{
    if (isValidDayOfWeek(weekStart)) {
        mWeekStart = weekStart;
    } else {
        mWeekStart = mCalendar.getFirstDayOfWeek();
    }
    updateDayOfWeekLabels();
    // Invalidate cached accessibility information.
    mTouchHelper.invalidateRoot();
    invalidate();
}
------------------------
Find a silently evolved API code:android.hardware.usb.UsbManager.getAccessoryList:COMMENT
Method Modifier: public      
Comment:/**
 * Returns a list of currently attached USB accessories.
 * (in the current implementation there can be at most one)
 *
 * @return list of USB accessories, or null if none are attached.
 */

Body of Frist Method:
{
    try {
        UsbAccessory accessory = mService.getCurrentAccessory();
        if (accessory == null) {
            return null;
        } else {
            return new UsbAccessory[] { accessory };
        }
    } catch (RemoteException e) {
        Log.e(TAG, "RemoteException in getAccessoryList", e);
        return null;
    }
}
Body of Second Method:
{
    try {
        UsbAccessory accessory = mService.getCurrentAccessory();
        if (accessory == null) {
            return null;
        } else {
            return new UsbAccessory[] { accessory };
        }
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.hardware.camera2.legacy.RequestHolder.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Build a new {@link RequestHolder} using with parameters generated from this
 * {@link Builder}.
 *
 * @param frameNumber the {@code framenumber} to generate in the {@link RequestHolder}.
 * @return a {@link RequestHolder} constructed with the {@link Builder}'s parameters.
 */

Body of Frist Method:
{
    return new RequestHolder(mRequestId, mSubsequenceId, mRequest, mRepeating, frameNumber, mNumJpegTargets, mNumPreviewTargets);
}
Body of Second Method:
{
    return new RequestHolder(mRequestId, mSubsequenceId, mRequest, mRepeating, frameNumber, mNumJpegTargets, mNumPreviewTargets, mJpegSurfaceIds);
}
------------------------
Find a silently evolved API code:android.app.WallpaperManager.setDisplayPadding:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Specify extra padding that the wallpaper should have outside of the display.
 * That is, the given padding supplies additional pixels the wallpaper should extend
 * outside of the display itself.
 * @param padding The number of pixels the wallpaper should extend beyond the display,
 * on its left, top, right, and bottom sides.
 * @hide
 */

Body of Frist Method:
{
    try {
        if (sGlobals.mService == null) {
            Log.w(TAG, "WallpaperService not running");
        } else {
            sGlobals.mService.setDisplayPadding(padding, mContext.getOpPackageName());
        }
    } catch (RemoteException e) {
    // Ignore
    }
}
Body of Second Method:
{
    try {
        if (sGlobals.mService == null) {
            Log.w(TAG, "WallpaperService not running");
            throw new RuntimeException(new DeadSystemException());
        } else {
            sGlobals.mService.setDisplayPadding(padding, mContext.getOpPackageName());
        }
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiManager.getCurrentNetwork:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get Network object of current wifi network
 * @return Get Network object of current wifi network
 * @hide
 */

Body of Frist Method:
{
    try {
        return mService.getCurrentNetwork();
    } catch (RemoteException e) {
        return null;
    }
}
Body of Second Method:
{
    try {
        return mService.getCurrentNetwork();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.content.pm.LauncherApps.unregisterCallback:COMMENT
Method Modifier: public      
Comment:/**
 * Unregisters a callback that was previously registered.
 *
 * @param callback The callback to unregister.
 * @see #registerCallback(Callback)
 */

Body of Frist Method:
{
    synchronized (this) {
        removeCallbackLocked(callback);
        if (mCallbacks.size() == 0) {
            try {
                mService.removeOnAppsChangedListener(mAppsChangedListener);
            } catch (RemoteException re) {
            }
        }
    }
}
Body of Second Method:
{
    synchronized (this) {
        removeCallbackLocked(callback);
        if (mCallbacks.size() == 0) {
            try {
                mService.removeOnAppsChangedListener(mAppsChangedListener);
            } catch (RemoteException re) {
                throw re.rethrowFromSystemServer();
            }
        }
    }
}
------------------------
Find a silently evolved API code:android.app.admin.DeviceAdminInfo.getReceiverName:COMMENT
Method Modifier: public      
Comment:/**
 * Return the class name of the receiver component that implements
 * this device admin.
 */

Body of Frist Method:
{
    return mReceiver.activityInfo.name;
}
Body of Second Method:
{
    return mActivityInfo.name;
}
------------------------
Find a silently evolved API code:android.app.ActivityManager.getPackageAskScreenCompat:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    try {
        return ActivityManagerNative.getDefault().getPackageAskScreenCompat(packageName);
    } catch (RemoteException e) {
        // System dead, we will be dead too soon!
        return false;
    }
}
Body of Second Method:
{
    try {
        return ActivityManagerNative.getDefault().getPackageAskScreenCompat(packageName);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.view.RenderNode.end:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Ends the recording for this display list. A display list cannot be
 * replayed if recording is not finished. Calling this method marks
 * the display list valid and {@link #isValid()} will return true.
 *
 * @see #start(int, int)
 * @see #isValid()
 */

Body of Frist Method:
{
    canvas.onPostDraw();
    long renderNodeData = canvas.finishRecording();
    nSetDisplayListData(mNativeRenderNode, renderNodeData);
    canvas.recycle();
    mValid = true;
}
Body of Second Method:
{
    long displayList = canvas.finishRecording();
    nSetDisplayList(mNativeRenderNode, displayList);
    canvas.recycle();
    mValid = true;
}
------------------------
Find a silently evolved API code:android.app.admin.DeviceAdminInfo.loadDescription:COMMENT
Method Modifier: public      
Comment:/**
 * Load user-visible description associated with this device admin.
 *
 * @param pm Supply a PackageManager used to load the device admin's
 * resources.
 */

Body of Frist Method:
{
    if (mReceiver.activityInfo.descriptionRes != 0) {
        String packageName = mReceiver.resolvePackageName;
        ApplicationInfo applicationInfo = null;
        if (packageName == null) {
            packageName = mReceiver.activityInfo.packageName;
            applicationInfo = mReceiver.activityInfo.applicationInfo;
        }
        return pm.getText(packageName, mReceiver.activityInfo.descriptionRes, applicationInfo);
    }
    throw new NotFoundException();
}
Body of Second Method:
{
    if (mActivityInfo.descriptionRes != 0) {
        return pm.getText(mActivityInfo.packageName, mActivityInfo.descriptionRes, mActivityInfo.applicationInfo);
    }
    throw new NotFoundException();
}
------------------------
Find a silently evolved API code:android.view.inputmethod.CursorAnchorInfo.Builder.reset:COMMENT
Method Modifier: public      
Comment:/**
 * Resets the internal state so that this instance can be reused to build another
 * instance of {@link CursorAnchorInfo}.
 */

Body of Frist Method:
{
    mSelectionStart = -1;
    mSelectionEnd = -1;
    mComposingTextStart = -1;
    mComposingText = null;
    mInsertionMarkerFlags = 0;
    mInsertionMarkerHorizontal = Float.NaN;
    mInsertionMarkerTop = Float.NaN;
    mInsertionMarkerBaseline = Float.NaN;
    mInsertionMarkerBottom = Float.NaN;
    mMatrix.set(Matrix.IDENTITY_MATRIX);
    mMatrixInitialized = false;
    if (mCharacterBoundsArrayBuilder != null) {
        mCharacterBoundsArrayBuilder.reset();
    }
}
Body of Second Method:
{
    mSelectionStart = -1;
    mSelectionEnd = -1;
    mComposingTextStart = -1;
    mComposingText = null;
    mInsertionMarkerFlags = 0;
    mInsertionMarkerHorizontal = Float.NaN;
    mInsertionMarkerTop = Float.NaN;
    mInsertionMarkerBaseline = Float.NaN;
    mInsertionMarkerBottom = Float.NaN;
    mMatrixInitialized = false;
    if (mCharacterBoundsArrayBuilder != null) {
        mCharacterBoundsArrayBuilder.reset();
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiManager.disableEphemeralNetwork:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Disable ephemeral Network
 *
 * @param SSID, in the format of WifiConfiguration's SSID.
 * @hide
 */

Body of Frist Method:
{
    if (SSID == null)
        throw new IllegalArgumentException("SSID cannot be null");
    try {
        mService.disableEphemeralNetwork(SSID);
    } catch (RemoteException e) {
    }
}
Body of Second Method:
{
    if (SSID == null)
        throw new IllegalArgumentException("SSID cannot be null");
    try {
        mService.disableEphemeralNetwork(SSID);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiManager.disableNetwork:COMMENT
Method Modifier: public      
Comment:/**
 * Disable a configured network. The specified network will not be
 * a candidate for associating. This may result in the asynchronous
 * delivery of state change events.
 * @param netId the ID of the network as returned by {@link #addNetwork}.
 * @return {@code true} if the operation succeeded
 */

Body of Frist Method:
{
    try {
        return mService.disableNetwork(netId);
    } catch (RemoteException e) {
        return false;
    }
}
Body of Second Method:
{
    try {
        return mService.disableNetwork(netId);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.location.Location.hasBearing:COMMENT
Method Modifier: public      
Comment:/**
 * True if this location has a bearing.
 */

Body of Frist Method:
{
    return mHasBearing;
}
Body of Second Method:
{
    return (mFieldsMask & HAS_BEARING_MASK) != 0;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothAdapter.getLeState:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the current state of the local Bluetooth adapter
 * <p>This returns current internal state of Adapter including LE ON/OFF
 *
 * <p>Possible return values are
 * {@link #STATE_OFF},
 * {@link #STATE_BLE_TURNING_ON},
 * {@link #STATE_BLE_ON},
 * {@link #STATE_TURNING_ON},
 * {@link #STATE_ON},
 * {@link #STATE_TURNING_OFF},
 * {@link #STATE_BLE_TURNING_OFF}.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}
 *
 * @return current state of Bluetooth adapter
 * @hide
 */

Body of Frist Method:
{
    try {
        synchronized (mManagerCallback) {
            if (mService != null) {
                int state = mService.getState();
                if (VDBG)
                    Log.d(TAG, "getLeState() returning " + state);
                return state;
            }
        }
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return BluetoothAdapter.STATE_OFF;
}
Body of Second Method:
{
    int state = BluetoothAdapter.STATE_OFF;
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            state = mService.getState();
        }
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    if (VDBG)
        Log.d(TAG, "getLeState() returning " + state);
    return state;
}
------------------------
Find a silently evolved API code:android.net.ConnectivityManager.registerNetworkAgent:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 * Register a NetworkAgent with ConnectivityService.
 * @return NetID corresponding to NetworkAgent.
 */

Body of Frist Method:
{
    try {
        return mService.registerNetworkAgent(messenger, ni, lp, nc, score, misc);
    } catch (RemoteException e) {
        return NETID_UNSET;
    }
}
Body of Second Method:
{
    try {
        return mService.registerNetworkAgent(messenger, ni, lp, nc, score, misc);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.hardware.usb.UsbManager.isFunctionEnabled:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns true if the specified USB function is currently enabled when in device mode.
 * <p>
 * USB functions represent interfaces which are published to the host to access
 * services offered by the device.
 * </p>
 *
 * @param function name of the USB function
 * @return true if the USB function is enabled
 *
 * {@hide}
 */

Body of Frist Method:
{
    try {
        return mService.isFunctionEnabled(function);
    } catch (RemoteException e) {
        Log.e(TAG, "RemoteException in setCurrentFunction", e);
        return false;
    }
}
Body of Second Method:
{
    try {
        return mService.isFunctionEnabled(function);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.telephony.TelephonyManager.iccTransmitApduBasicChannel:COMMENT
Method Modifier: public      
Comment:/**
 * Transmit an APDU to the ICC card over the basic channel.
 *
 * Input parameters equivalent to TS 27.007 AT+CSIM command.
 *
 * <p>Requires Permission:
 * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE}
 * Or the calling app has carrier privileges. @see #hasCarrierPrivileges
 *
 * @param cla Class of the APDU command.
 * @param instruction Instruction of the APDU command.
 * @param p1 P1 value of the APDU command.
 * @param p2 P2 value of the APDU command.
 * @param p3 P3 value of the APDU command. If p3 is negative a 4 byte APDU
 * is sent to the SIM.
 * @param data Data to be sent with the APDU.
 * @return The APDU response from the ICC card with the status appended at
 * the end.
 */

Body of Frist Method:
{
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            return telephony.iccTransmitApduBasicChannel(cla, instruction, p1, p2, p3, data);
    } catch (RemoteException ex) {
    } catch (NullPointerException ex) {
    }
    return "";
}
Body of Second Method:
{
    return iccTransmitApduBasicChannel(getSubId(), cla, instruction, p1, p2, p3, data);
}
------------------------
Find a silently evolved API code:android.widget.TextView.setExtractedText:COMMENT
Method Modifier: public      
Comment:/**
 * Apply to this text view the given extracted text, as previously
 * returned by {@link #extractText(ExtractedTextRequest, ExtractedText)}.
 */

Body of Frist Method:
{
    Editable content = getEditableText();
    if (text.text != null) {
        if (content == null) {
            setText(text.text, TextView.BufferType.EDITABLE);
        } else {
            int start = 0;
            int end = content.length();
            if (text.partialStartOffset >= 0) {
                final int N = content.length();
                start = text.partialStartOffset;
                if (start > N)
                    start = N;
                end = text.partialEndOffset;
                if (end > N)
                    end = N;
            }
            removeParcelableSpans(content, start, end);
            if (TextUtils.equals(content.subSequence(start, end), text.text)) {
                if (text.text instanceof Spanned) {
                    // OK to copy spans only.
                    TextUtils.copySpansFrom((Spanned) text.text, start, end, Object.class, content, start);
                }
            } else {
                content.replace(start, end, text.text);
            }
        }
    }
    // Now set the selection position...  make sure it is in range, to
    // avoid crashes.  If this is a partial update, it is possible that
    // the underlying text may have changed, causing us problems here.
    // Also we just don't want to trust clients to do the right thing.
    Spannable sp = (Spannable) getText();
    final int N = sp.length();
    int start = text.selectionStart;
    if (start < 0)
        start = 0;
    else if (start > N)
        start = N;
    int end = text.selectionEnd;
    if (end < 0)
        end = 0;
    else if (end > N)
        end = N;
    Selection.setSelection(sp, start, end);
    // Finally, update the selection mode.
    if ((text.flags & ExtractedText.FLAG_SELECTING) != 0) {
        MetaKeyKeyListener.startSelecting(this, sp);
    } else {
        MetaKeyKeyListener.stopSelecting(this, sp);
    }
}
Body of Second Method:
{
    Editable content = getEditableText();
    if (text.text != null) {
        if (content == null) {
            setText(text.text, TextView.BufferType.EDITABLE);
        } else {
            int start = 0;
            int end = content.length();
            if (text.partialStartOffset >= 0) {
                final int N = content.length();
                start = text.partialStartOffset;
                if (start > N)
                    start = N;
                end = text.partialEndOffset;
                if (end > N)
                    end = N;
            }
            removeParcelableSpans(content, start, end);
            if (TextUtils.equals(content.subSequence(start, end), text.text)) {
                if (text.text instanceof Spanned) {
                    // OK to copy spans only.
                    TextUtils.copySpansFrom((Spanned) text.text, 0, end - start, Object.class, content, start);
                }
            } else {
                content.replace(start, end, text.text);
            }
        }
    }
    // Now set the selection position...  make sure it is in range, to
    // avoid crashes.  If this is a partial update, it is possible that
    // the underlying text may have changed, causing us problems here.
    // Also we just don't want to trust clients to do the right thing.
    Spannable sp = (Spannable) getText();
    final int N = sp.length();
    int start = text.selectionStart;
    if (start < 0)
        start = 0;
    else if (start > N)
        start = N;
    int end = text.selectionEnd;
    if (end < 0)
        end = 0;
    else if (end > N)
        end = N;
    Selection.setSelection(sp, start, end);
    // Finally, update the selection mode.
    if ((text.flags & ExtractedText.FLAG_SELECTING) != 0) {
        MetaKeyKeyListener.startSelecting(this, sp);
    } else {
        MetaKeyKeyListener.stopSelecting(this, sp);
    }
}
------------------------
Find a silently evolved API code:android.widget.SimpleMonthView.initPaints:COMMENT
Method Modifier: private     
Comment:/**
 * Sets up the text and style properties for painting.
 */

Body of Frist Method:
{
    final String monthTypeface = res.getString(R.string.date_picker_month_typeface);
    final String dayOfWeekTypeface = res.getString(R.string.date_picker_day_of_week_typeface);
    final String dayTypeface = res.getString(R.string.date_picker_day_typeface);
    final int monthTextSize = res.getDimensionPixelSize(R.dimen.date_picker_month_text_size);
    final int dayOfWeekTextSize = res.getDimensionPixelSize(R.dimen.date_picker_day_of_week_text_size);
    final int dayTextSize = res.getDimensionPixelSize(R.dimen.date_picker_day_text_size);
    mMonthPaint.setAntiAlias(true);
    mMonthPaint.setTextSize(monthTextSize);
    mMonthPaint.setTypeface(Typeface.create(monthTypeface, 0));
    mMonthPaint.setTextAlign(Align.CENTER);
    mMonthPaint.setStyle(Style.FILL);
    mDayOfWeekPaint.setAntiAlias(true);
    mDayOfWeekPaint.setTextSize(dayOfWeekTextSize);
    mDayOfWeekPaint.setTypeface(Typeface.create(dayOfWeekTypeface, 0));
    mDayOfWeekPaint.setTextAlign(Align.CENTER);
    mDayOfWeekPaint.setStyle(Style.FILL);
    mDaySelectorPaint.setAntiAlias(true);
    mDaySelectorPaint.setStyle(Style.FILL);
    mDayHighlightPaint.setAntiAlias(true);
    mDayHighlightPaint.setStyle(Style.FILL);
    mDayPaint.setAntiAlias(true);
    mDayPaint.setTextSize(dayTextSize);
    mDayPaint.setTypeface(Typeface.create(dayTypeface, 0));
    mDayPaint.setTextAlign(Align.CENTER);
    mDayPaint.setStyle(Style.FILL);
}
Body of Second Method:
{
    final String monthTypeface = res.getString(R.string.date_picker_month_typeface);
    final String dayOfWeekTypeface = res.getString(R.string.date_picker_day_of_week_typeface);
    final String dayTypeface = res.getString(R.string.date_picker_day_typeface);
    final int monthTextSize = res.getDimensionPixelSize(R.dimen.date_picker_month_text_size);
    final int dayOfWeekTextSize = res.getDimensionPixelSize(R.dimen.date_picker_day_of_week_text_size);
    final int dayTextSize = res.getDimensionPixelSize(R.dimen.date_picker_day_text_size);
    mMonthPaint.setAntiAlias(true);
    mMonthPaint.setTextSize(monthTextSize);
    mMonthPaint.setTypeface(Typeface.create(monthTypeface, 0));
    mMonthPaint.setTextAlign(Align.CENTER);
    mMonthPaint.setStyle(Style.FILL);
    mDayOfWeekPaint.setAntiAlias(true);
    mDayOfWeekPaint.setTextSize(dayOfWeekTextSize);
    mDayOfWeekPaint.setTypeface(Typeface.create(dayOfWeekTypeface, 0));
    mDayOfWeekPaint.setTextAlign(Align.CENTER);
    mDayOfWeekPaint.setStyle(Style.FILL);
    mDaySelectorPaint.setAntiAlias(true);
    mDaySelectorPaint.setStyle(Style.FILL);
    mDayHighlightPaint.setAntiAlias(true);
    mDayHighlightPaint.setStyle(Style.FILL);
    mDayHighlightSelectorPaint.setAntiAlias(true);
    mDayHighlightSelectorPaint.setStyle(Style.FILL);
    mDayPaint.setAntiAlias(true);
    mDayPaint.setTextSize(dayTextSize);
    mDayPaint.setTypeface(Typeface.create(dayTypeface, 0));
    mDayPaint.setTextAlign(Align.CENTER);
    mDayPaint.setStyle(Style.FILL);
}
------------------------
Find a silently evolved API code:android.graphics.Path_Delegate.rQuadTo:COMMENT
<android.graphics.Path_Delegate: void rQuadTo(float,float,float,float)>
private     ->public      
Method Modifier: public      private     
Method Modifier: No          Yes         
Method Updated:  Yes         No          
Comment:/**
 * Same as quadTo, but the coordinates are considered relative to the last
 * point on this contour. If there is no previous point, then a moveTo(0,0)
 * is inserted automatically.
 *
 * @param dx1 The amount to add to the x-coordinate of the last point on
 * this contour, for the control point of a quadratic curve
 * @param dy1 The amount to add to the y-coordinate of the last point on
 * this contour, for the control point of a quadratic curve
 * @param dx2 The amount to add to the x-coordinate of the last point on
 * this contour, for the end point of a quadratic curve
 * @param dy2 The amount to add to the y-coordinate of the last point on
 * this contour, for the end point of a quadratic curve
 */

Body of Frist Method:
{
    if (isEmpty()) {
        mPath.moveTo(mLastX = 0, mLastY = 0);
    }
    dx1 += mLastX;
    dy1 += mLastY;
    dx2 += mLastX;
    dy2 += mLastY;
    mPath.quadTo(dx1, dy1, mLastX = dx2, mLastY = dy2);
}
Body of Second Method:
{
    if (!hasPoints()) {
        mPath.moveTo(mLastX = 0, mLastY = 0);
    }
    dx1 += mLastX;
    dy1 += mLastY;
    dx2 += mLastX;
    dy2 += mLastY;
    mPath.quadTo(dx1, dy1, mLastX = dx2, mLastY = dy2);
}
------------------------
Find a silently evolved API code:android.accounts.AccountManager.setAuthToken:COMMENT
Method Modifier: public      
Comment:/**
 * Adds an auth token to the AccountManager cache for an account.
 * If the account does not exist then this call has no effect.
 * Replaces any previous auth token for this account and auth token type.
 * Intended for use by the authenticator, not directly by applications.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>This method requires the caller to have a signature match with the
 * authenticator that manages the specified account.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * AUTHENTICATE_ACCOUNTS permission and same UID as account's authenticator
 * is needed for those platforms. See docs for this function in API level 22.
 *
 * @param account The account to set an auth token for
 * @param authTokenType The type of the auth token, see {#getAuthToken}
 * @param authToken The auth token to add to the cache
 */

Body of Frist Method:
{
    if (account == null)
        throw new IllegalArgumentException("account is null");
    if (authTokenType == null)
        throw new IllegalArgumentException("authTokenType is null");
    try {
        mService.setAuthToken(account, authTokenType, authToken);
    } catch (RemoteException e) {
        // won't ever happen
        throw new RuntimeException(e);
    }
}
Body of Second Method:
{
    if (account == null)
        throw new IllegalArgumentException("account is null");
    if (authTokenType == null)
        throw new IllegalArgumentException("authTokenType is null");
    try {
        mService.setAuthToken(account, authTokenType, authToken);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiManager.setAllowScansWithTraffic:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Set setting for allowing Scans when traffic is ongoing.
 * @hide
 */

Body of Frist Method:
{
    try {
        mService.setAllowScansWithTraffic(enabled);
    } catch (RemoteException e) {
    }
}
Body of Second Method:
{
    try {
        mService.setAllowScansWithTraffic(enabled);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.graphics.Path_Delegate.rCubicTo:COMMENT
<android.graphics.Path_Delegate: void rCubicTo(float,float,float,float,float,float)>
private     ->public      
Method Modifier: public      private     
Method Modifier: No          Yes         
Method Updated:  Yes         No          
Comment:/**
 * Same as cubicTo, but the coordinates are considered relative to the
 * current point on this contour. If there is no previous point, then a
 * moveTo(0,0) is inserted automatically.
 */

Body of Frist Method:
{
    if (isEmpty()) {
        mPath.moveTo(mLastX = 0, mLastY = 0);
    }
    dx1 += mLastX;
    dy1 += mLastY;
    dx2 += mLastX;
    dy2 += mLastY;
    dx3 += mLastX;
    dy3 += mLastY;
    mPath.curveTo(dx1, dy1, dx2, dy2, mLastX = dx3, mLastY = dy3);
}
Body of Second Method:
{
    if (!hasPoints()) {
        mPath.moveTo(mLastX = 0, mLastY = 0);
    }
    dx1 += mLastX;
    dy1 += mLastY;
    dx2 += mLastX;
    dy2 += mLastY;
    dx3 += mLastX;
    dy3 += mLastY;
    mPath.curveTo(dx1, dy1, dx2, dy2, mLastX = dx3, mLastY = dy3);
}
------------------------
Find a silently evolved API code:android.content.SyncRequest.Builder.setDisallowMetered:COMMENT
Method Modifier: public      
Comment:/**
 * Will throw an <code>IllegalArgumentException</code> if called and
 * {@link #setIgnoreSettings(boolean ignoreSettings)} has already been called.
 * @param disallow true to allow this transfer on metered networks. Default false.
 */

Body of Frist Method:
{
    if (mIgnoreSettings && disallow) {
        throw new IllegalArgumentException("setDisallowMetered(true) after having" + "specified that settings are ignored.");
    }
    mDisallowMetered = disallow;
    return this;
}
Body of Second Method:
{
    if (mIgnoreSettings && disallow) {
        throw new IllegalArgumentException("setDisallowMetered(true) after having" + " specified that settings are ignored.");
    }
    mDisallowMetered = disallow;
    return this;
}
------------------------
Find a silently evolved API code:android.content.res.TypedArray.getDimension:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve a dimensional unit attribute at <var>index</var>. Unit
 * conversions are based on the current {@link DisplayMetrics}
 * associated with the resources this {@link TypedArray} object
 * came from.
 * <p>
 * This method will throw an exception if the attribute is defined but is
 * not a dimension.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute dimension value multiplied by the appropriate
 * metric, or defValue if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not an integer.
 *
 * @see #getDimensionPixelOffset
 * @see #getDimensionPixelSize
 */

Body of Frist Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimension(data[index + AssetManager.STYLE_DATA], mMetrics);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index * AssetManager.STYLE_NUM_ENTRIES, value);
        throw new UnsupportedOperationException("Failed to resolve attribute at index " + index + ": " + value);
    }
    throw new UnsupportedOperationException("Can't convert to dimension: type=0x" + Integer.toHexString(type));
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    final int attrIndex = index;
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimension(data[index + AssetManager.STYLE_DATA], mMetrics);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index, value);
        throw new UnsupportedOperationException("Failed to resolve attribute at index " + attrIndex + ": " + value);
    }
    throw new UnsupportedOperationException("Can't convert value at index " + attrIndex + " to dimension: type=0x" + Integer.toHexString(type));
}
------------------------
Find a silently evolved API code:android.telecom.PhoneAccount.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Creates an instance of a {@link PhoneAccount} based on the current builder settings.
 *
 * @return The {@link PhoneAccount}.
 */

Body of Frist Method:
{
    // If no supported URI schemes were defined, assume "tel" is supported.
    if (mSupportedUriSchemes.isEmpty()) {
        addSupportedUriScheme(SCHEME_TEL);
    }
    return new PhoneAccount(mAccountHandle, mAddress, mSubscriptionAddress, mCapabilities, mIcon, mHighlightColor, mLabel, mShortDescription, mSupportedUriSchemes, mIsEnabled);
}
Body of Second Method:
{
    // If no supported URI schemes were defined, assume "tel" is supported.
    if (mSupportedUriSchemes.isEmpty()) {
        addSupportedUriScheme(SCHEME_TEL);
    }
    return new PhoneAccount(mAccountHandle, mAddress, mSubscriptionAddress, mCapabilities, mIcon, mHighlightColor, mLabel, mShortDescription, mSupportedUriSchemes, mExtras, mIsEnabled);
}
------------------------
Find a silently evolved API code:android.graphics.drawable.Icon.convertToAshmem:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Puts the memory used by this instance into Ashmem memory, if possible.
 * @hide
 */

Body of Frist Method:
{
    if (mType == TYPE_BITMAP && getBitmap().isMutable()) {
        setBitmap(getBitmap().createAshmemBitmap());
    }
}
Body of Second Method:
{
    if (mType == TYPE_BITMAP && getBitmap().isMutable() && getBitmap().getAllocationByteCount() >= MIN_ASHMEM_ICON_SIZE) {
        setBitmap(getBitmap().createAshmemBitmap());
    }
}
------------------------
Find a silently evolved API code:android.media.RemoteControlClient.setOnGetPlaybackPositionListener:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * Sets the listener to be called whenever the media current playback position is needed.
 * Queries will be received in the same thread as the one in which RemoteControlClient
 * was created.
 * @param l the listener to be called to retrieve the playback position
 */

Body of Frist Method:
{
    synchronized (mCacheLock) {
        mPositionProvider = l;
        if ((mPositionProvider != null) && (mEventHandler != null) && playbackPositionShouldMove(mPlaybackState)) {
            // playback position is already moving, but now we have a position provider,
            // so schedule a drift check right now
            mEventHandler.sendMessageDelayed(mEventHandler.obtainMessage(MSG_POSITION_DRIFT_CHECK), 0);
        }
    }
}
Body of Second Method:
{
    synchronized (mCacheLock) {
        mPositionProvider = l;
    }
}
------------------------
Find a silently evolved API code:android.graphics.Outline.set:COMMENT
Method Modifier: public      
Comment:/**
 * Replace the contents of this Outline with the contents of src.
 *
 * @param src Source outline to copy from.
 */

Body of Frist Method:
{
    if (src.mPath != null) {
        if (mPath == null) {
            mPath = new Path();
        }
        mPath.set(src.mPath);
        mRect = null;
    }
    if (src.mRect != null) {
        if (mRect == null) {
            mRect = new Rect();
        }
        mRect.set(src.mRect);
    }
    mRadius = src.mRadius;
    mAlpha = src.mAlpha;
}
Body of Second Method:
{
    mMode = src.mMode;
    mPath.set(src.mPath);
    mRect.set(src.mRect);
    mRadius = src.mRadius;
    mAlpha = src.mAlpha;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothDevice.cancelBondProcess:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Cancel an in-progress bonding request started with {@link #createBond}.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}.
 *
 * @return true on success, false on error
 * @hide
 */

Body of Frist Method:
{
    if (sService == null) {
        Log.e(TAG, "BT not enabled. Cannot cancel Remote Device bond");
        return false;
    }
    try {
        return sService.cancelBondProcess(this);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
Body of Second Method:
{
    if (sService == null) {
        Log.e(TAG, "BT not enabled. Cannot cancel Remote Device bond");
        return false;
    }
    try {
        Log.i(TAG, "cancelBondProcess() for device " + getAddress() + " called by pid: " + Process.myPid() + " tid: " + Process.myTid());
        return sService.cancelBondProcess(this);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
------------------------
Find a silently evolved API code:android.media.midi.MidiDevice.openInputPort:COMMENT
Method Modifier: public      
Comment:/**
 * Called to open a {@link MidiInputPort} for the specified port number.
 *
 * An input port can only be used by one sender at a time.
 * Opening an input port will fail if another application has already opened it for use.
 * A {@link MidiDeviceStatus} can be used to determine if an input port is already open.
 *
 * @param portNumber the number of the input port to open
 * @return the {@link MidiInputPort} if the open is successful,
 * or null in case of failure.
 */

Body of Frist Method:
{
    try {
        IBinder token = new Binder();
        ParcelFileDescriptor pfd = mDeviceServer.openInputPort(token, portNumber);
        if (pfd == null) {
            return null;
        }
        return new MidiInputPort(mDeviceServer, token, pfd, portNumber);
    } catch (RemoteException e) {
        Log.e(TAG, "RemoteException in openInputPort");
        return null;
    }
}
Body of Second Method:
{
    if (mIsDeviceClosed) {
        return null;
    }
    try {
        IBinder token = new Binder();
        ParcelFileDescriptor pfd = mDeviceServer.openInputPort(token, portNumber);
        if (pfd == null) {
            return null;
        }
        return new MidiInputPort(mDeviceServer, token, pfd, portNumber);
    } catch (RemoteException e) {
        Log.e(TAG, "RemoteException in openInputPort");
        return null;
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiManager.getMatchingWifiConfig:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns a WifiConfiguration matching this ScanResult
 * @param scanResult scanResult that represents the BSSID
 * @return {@link WifiConfiguration} that matches this BSSID or null
 * @hide
 */

Body of Frist Method:
{
    try {
        return mService.getMatchingWifiConfig(scanResult);
    } catch (RemoteException e) {
        return null;
    }
}
Body of Second Method:
{
    try {
        return mService.getMatchingWifiConfig(scanResult);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiManager.setFrequencyBand:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Set the operational frequency band.
 * @param band  One of
 * {@link #WIFI_FREQUENCY_BAND_AUTO},
 * {@link #WIFI_FREQUENCY_BAND_5GHZ},
 * {@link #WIFI_FREQUENCY_BAND_2GHZ},
 * @param persist {@code true} if this needs to be remembered
 * @hide
 */

Body of Frist Method:
{
    try {
        mService.setFrequencyBand(band, persist);
    } catch (RemoteException e) {
    }
}
Body of Second Method:
{
    try {
        mService.setFrequencyBand(band, persist);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.appwidget.AppWidgetManager.partiallyUpdateAppWidget:COMMENT
Method Modifier: public      
Comment:/**
 * Perform an incremental update or command on the widget(s) specified by appWidgetIds.
 * <p>
 * This update  differs from {@link #updateAppWidget(int[], RemoteViews)} in that the
 * RemoteViews object which is passed is understood to be an incomplete representation of the
 * widget, and hence does not replace the cached representation of the widget. As of API
 * level 17, the new properties set within the views objects will be appended to the cached
 * representation of the widget, and hence will persist.
 *
 * Use with {@link RemoteViews#showNext(int)}, {@link RemoteViews#showPrevious(int)},
 * {@link RemoteViews#setScrollPosition(int, int)} and similar commands.
 *
 * <p>
 * It is okay to call this method both inside an {@link #ACTION_APPWIDGET_UPDATE} broadcast,
 * and outside of the handler.
 * This method will only work when called from the uid that owns the AppWidget provider.
 *
 * <p>
 * This method will be ignored if a widget has not received a full update via
 * {@link #updateAppWidget(int[], RemoteViews)}.
 *
 * @param appWidgetIds     The AppWidget instances for which to set the RemoteViews.
 * @param views            The RemoteViews object containing the incremental update / command.
 */

Body of Frist Method:
{
    if (mService == null) {
        return;
    }
    try {
        mService.partiallyUpdateAppWidgetIds(mPackageName, appWidgetIds, views);
    } catch (RemoteException e) {
        throw new RuntimeException("system server dead?", e);
    }
}
Body of Second Method:
{
    if (mService == null) {
        return;
    }
    try {
        mService.partiallyUpdateAppWidgetIds(mPackageName, appWidgetIds, views);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.app.Activity.navigateUpTo:COMMENT
Method Modifier: public      
Comment:/**
 * Navigate from this activity to the activity specified by upIntent, finishing this activity
 * in the process. If the activity indicated by upIntent already exists in the task's history,
 * this activity and all others before the indicated activity in the history stack will be
 * finished.
 *
 * <p>If the indicated activity does not appear in the history stack, this will finish
 * each activity in this task until the root activity of the task is reached, resulting in
 * an "in-app home" behavior. This can be useful in apps with a complex navigation hierarchy
 * when an activity may be reached by a path not passing through a canonical parent
 * activity.</p>
 *
 * <p>This method should be used when performing up navigation from within the same task
 * as the destination. If up navigation should cross tasks in some cases, see
 * {@link #shouldUpRecreateTask(Intent)}.</p>
 *
 * @param upIntent An intent representing the target destination for up navigation
 *
 * @return true if up navigation successfully reached the activity indicated by upIntent and
 * upIntent was delivered to it. false if an instance of the indicated activity could
 * not be found and this activity was simply finished normally.
 */

Body of Frist Method:
{
    if (mParent == null) {
        ComponentName destInfo = upIntent.getComponent();
        if (destInfo == null) {
            destInfo = upIntent.resolveActivity(getPackageManager());
            if (destInfo == null) {
                return false;
            }
            upIntent = new Intent(upIntent);
            upIntent.setComponent(destInfo);
        }
        int resultCode;
        Intent resultData;
        synchronized (this) {
            resultCode = mResultCode;
            resultData = mResultData;
        }
        if (resultData != null) {
            resultData.prepareToLeaveProcess();
        }
        try {
            upIntent.prepareToLeaveProcess();
            return ActivityManagerNative.getDefault().navigateUpTo(mToken, upIntent, resultCode, resultData);
        } catch (RemoteException e) {
            return false;
        }
    } else {
        return mParent.navigateUpToFromChild(this, upIntent);
    }
}
Body of Second Method:
{
    if (mParent == null) {
        ComponentName destInfo = upIntent.getComponent();
        if (destInfo == null) {
            destInfo = upIntent.resolveActivity(getPackageManager());
            if (destInfo == null) {
                return false;
            }
            upIntent = new Intent(upIntent);
            upIntent.setComponent(destInfo);
        }
        int resultCode;
        Intent resultData;
        synchronized (this) {
            resultCode = mResultCode;
            resultData = mResultData;
        }
        if (resultData != null) {
            resultData.prepareToLeaveProcess(this);
        }
        try {
            upIntent.prepareToLeaveProcess(this);
            return ActivityManagerNative.getDefault().navigateUpTo(mToken, upIntent, resultCode, resultData);
        } catch (RemoteException e) {
            return false;
        }
    } else {
        return mParent.navigateUpToFromChild(this, upIntent);
    }
}
------------------------
Find a silently evolved API code:android.net.ConnectivityManager.getTetheredIfaces:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the set of tethered interfaces.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
 *
 * @return an array of 0 or more String of currently tethered interface names.
 *
 * {@hide}
 */

Body of Frist Method:
{
    try {
        return mService.getTetheredIfaces();
    } catch (RemoteException e) {
        return new String[0];
    }
}
Body of Second Method:
{
    try {
        return mService.getTetheredIfaces();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.location.Location.isComplete:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Return true if this Location object is complete.
 *
 * <p>A location object is currently considered complete if it has
 * a valid provider, accuracy, wall-clock time and elapsed real-time.
 *
 * <p>All locations supplied by the {@link LocationManager} to
 * applications must be complete.
 *
 * @see #makeComplete
 * @hide
 */

Body of Frist Method:
{
    if (mProvider == null)
        return false;
    if (!mHasAccuracy)
        return false;
    if (mTime == 0)
        return false;
    if (mElapsedRealtimeNanos == 0)
        return false;
    return true;
}
Body of Second Method:
{
    if (mProvider == null)
        return false;
    if (!hasAccuracy())
        return false;
    if (mTime == 0)
        return false;
    if (mElapsedRealtimeNanos == 0)
        return false;
    return true;
}
------------------------
Find a silently evolved API code:android.net.NetworkScoreManager.requestScores:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Request scoring for networks.
 *
 * <p>Note that this is just a helper method to assemble the broadcast, and will run in the
 * calling process.
 *
 * @return true if the broadcast was sent, or false if there is no active scorer.
 * @throws SecurityException if the caller does not hold the
 * {@link android.Manifest.permission#BROADCAST_NETWORK_PRIVILEGED} permission.
 * @hide
 */

Body of Frist Method:
{
    String activeScorer = getActiveScorerPackage();
    if (activeScorer == null) {
        return false;
    }
    Intent intent = new Intent(ACTION_SCORE_NETWORKS);
    intent.setPackage(activeScorer);
    intent.setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    intent.putExtra(EXTRA_NETWORKS_TO_SCORE, networks);
    // A scorer should never become active if its package doesn't hold SCORE_NETWORKS, but
    // ensure the package still holds it to be extra safe.
    mContext.sendBroadcastAsUser(intent, UserHandle.OWNER, Manifest.permission.SCORE_NETWORKS);
    return true;
}
Body of Second Method:
{
    String activeScorer = getActiveScorerPackage();
    if (activeScorer == null) {
        return false;
    }
    Intent intent = new Intent(ACTION_SCORE_NETWORKS);
    intent.setPackage(activeScorer);
    intent.setFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    intent.putExtra(EXTRA_NETWORKS_TO_SCORE, networks);
    // A scorer should never become active if its package doesn't hold SCORE_NETWORKS, but
    // ensure the package still holds it to be extra safe.
    // TODO: http://b/23422763
    mContext.sendBroadcastAsUser(intent, UserHandle.SYSTEM, Manifest.permission.SCORE_NETWORKS);
    return true;
}
------------------------
Find a silently evolved API code:android.graphics.Outline.setEmpty:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the outline to be empty.
 *
 * @see #isEmpty()
 */

Body of Frist Method:
{
    mPath = null;
    mRect = null;
    mRadius = 0;
}
Body of Second Method:
{
    mMode = MODE_EMPTY;
    mPath.rewind();
    mRect.setEmpty();
    mRadius = RADIUS_UNDEFINED;
}
------------------------
Find a silently evolved API code:android.app.usage.UsageStats.add:COMMENT
Method Modifier: public      
Comment:/**
 * Add the statistics from the right {@link UsageStats} to the left. The package name for
 * both {@link UsageStats} objects must be the same.
 * @param right The {@link UsageStats} object to merge into this one.
 * @throws java.lang.IllegalArgumentException if the package names of the two
 * {@link UsageStats} objects are different.
 */

Body of Frist Method:
{
    if (!mPackageName.equals(right.mPackageName)) {
        throw new IllegalArgumentException("Can't merge UsageStats for package '" + mPackageName + "' with UsageStats for package '" + right.mPackageName + "'.");
    }
    if (right.mEndTimeStamp > mEndTimeStamp) {
        mLastEvent = right.mLastEvent;
        mEndTimeStamp = right.mEndTimeStamp;
        mLastTimeUsed = right.mLastTimeUsed;
        mBeginIdleTime = right.mBeginIdleTime;
        mLastTimeSystemUsed = right.mLastTimeSystemUsed;
    }
    mBeginTimeStamp = Math.min(mBeginTimeStamp, right.mBeginTimeStamp);
    mTotalTimeInForeground += right.mTotalTimeInForeground;
    mLaunchCount += right.mLaunchCount;
}
Body of Second Method:
{
    if (!mPackageName.equals(right.mPackageName)) {
        throw new IllegalArgumentException("Can't merge UsageStats for package '" + mPackageName + "' with UsageStats for package '" + right.mPackageName + "'.");
    }
    if (right.mBeginTimeStamp > mBeginTimeStamp) {
        // The incoming UsageStat begins after this one, so use its last time used fields
        // as the source of truth.
        // We use the mBeginTimeStamp due to a bug where UsageStats files can overlap with
        // regards to their mEndTimeStamp.
        mLastEvent = right.mLastEvent;
        mLastTimeUsed = right.mLastTimeUsed;
    }
    mBeginTimeStamp = Math.min(mBeginTimeStamp, right.mBeginTimeStamp);
    mEndTimeStamp = Math.max(mEndTimeStamp, right.mEndTimeStamp);
    mTotalTimeInForeground += right.mTotalTimeInForeground;
    mLaunchCount += right.mLaunchCount;
}
------------------------
Find a silently evolved API code:android.content.ClipData.newUri:COMMENT
Method Modifier: public      static      
Comment:/**
 * Create a new ClipData holding a URI.  If the URI is a content: URI,
 * this will query the content provider for the MIME type of its data and
 * use that as the MIME type.  Otherwise, it will use the MIME type
 * {@link ClipDescription#MIMETYPE_TEXT_URILIST}.
 *
 * @param resolver ContentResolver used to get information about the URI.
 * @param label User-visible label for the clip data.
 * @param uri The URI in the clip.
 * @return Returns a new ClipData containing the specified data.
 */

Body of Frist Method:
{
    Item item = new Item(uri);
    String[] mimeTypes = null;
    if ("content".equals(uri.getScheme())) {
        String realType = resolver.getType(uri);
        mimeTypes = resolver.getStreamTypes(uri, "*/*");
        if (mimeTypes == null) {
            if (realType != null) {
                mimeTypes = new String[] { realType, ClipDescription.MIMETYPE_TEXT_URILIST };
            }
        } else {
            String[] tmp = new String[mimeTypes.length + (realType != null ? 2 : 1)];
            int i = 0;
            if (realType != null) {
                tmp[0] = realType;
                i++;
            }
            System.arraycopy(mimeTypes, 0, tmp, i, mimeTypes.length);
            tmp[i + mimeTypes.length] = ClipDescription.MIMETYPE_TEXT_URILIST;
            mimeTypes = tmp;
        }
    }
    if (mimeTypes == null) {
        mimeTypes = MIMETYPES_TEXT_URILIST;
    }
    return new ClipData(label, mimeTypes, item);
}
Body of Second Method:
{
    Item item = new Item(uri);
    String[] mimeTypes = null;
    if ("content".equals(uri.getScheme())) {
        String realType = resolver.getType(uri);
        mimeTypes = resolver.getStreamTypes(uri, "*/*");
        if (realType != null) {
            if (mimeTypes == null) {
                mimeTypes = new String[] { realType };
            } else {
                String[] tmp = new String[mimeTypes.length + 1];
                tmp[0] = realType;
                System.arraycopy(mimeTypes, 0, tmp, 1, mimeTypes.length);
                mimeTypes = tmp;
            }
        }
    }
    if (mimeTypes == null) {
        mimeTypes = MIMETYPES_TEXT_URILIST;
    }
    return new ClipData(label, mimeTypes, item);
}
------------------------
Find a silently evolved API code:android.graphics.Bitmap.sameAs:COMMENT
Method Modifier: public      
Comment:/**
 * Given another bitmap, return true if it has the same dimensions, config,
 * and pixel data as this bitmap. If any of those differ, return false.
 * If other is null, return false.
 */

Body of Frist Method:
{
    checkRecycled("Can't call sameAs on a recycled bitmap!");
    if (this == other)
        return true;
    if (other == null)
        return false;
    if (other.isRecycled()) {
        throw new IllegalArgumentException("Can't compare to a recycled bitmap!");
    }
    return nativeSameAs(mFinalizer.mNativeBitmap, other.mFinalizer.mNativeBitmap);
}
Body of Second Method:
{
    checkRecycled("Can't call sameAs on a recycled bitmap!");
    if (this == other)
        return true;
    if (other == null)
        return false;
    if (other.isRecycled()) {
        throw new IllegalArgumentException("Can't compare to a recycled bitmap!");
    }
    return nativeSameAs(mNativePtr, other.mNativePtr);
}
------------------------
Find a silently evolved API code:android.widget.LinearLayout.layoutHorizontal:COMMENT
Method Modifier: default     
Comment:/**
 * Position the children during a layout pass if the orientation of this
 * LinearLayout is set to {@link #HORIZONTAL}.
 *
 * @see #getOrientation()
 * @see #setOrientation(int)
 * @see #onLayout(boolean, int, int, int, int)
 * @param left
 * @param top
 * @param right
 * @param bottom
 */

Body of Frist Method:
{
    final boolean isLayoutRtl = isLayoutRtl();
    final int paddingTop = mPaddingTop;
    int childTop;
    int childLeft;
    // Where bottom of child should go
    final int height = bottom - top;
    int childBottom = height - mPaddingBottom;
    // Space available for child
    int childSpace = height - paddingTop - mPaddingBottom;
    final int count = getVirtualChildCount();
    final int majorGravity = mGravity & Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK;
    final int minorGravity = mGravity & Gravity.VERTICAL_GRAVITY_MASK;
    final boolean baselineAligned = mBaselineAligned;
    final int[] maxAscent = mMaxAscent;
    final int[] maxDescent = mMaxDescent;
    final int layoutDirection = getLayoutDirection();
    switch(Gravity.getAbsoluteGravity(majorGravity, layoutDirection)) {
        case Gravity.RIGHT:
            // mTotalLength contains the padding already
            childLeft = mPaddingLeft + right - left - mTotalLength;
            break;
        case Gravity.CENTER_HORIZONTAL:
            // mTotalLength contains the padding already
            childLeft = mPaddingLeft + (right - left - mTotalLength) / 2;
            break;
        case Gravity.LEFT:
        default:
            childLeft = mPaddingLeft;
            break;
    }
    int start = 0;
    int dir = 1;
    // In case of RTL, start drawing from the last child.
    if (isLayoutRtl) {
        start = count - 1;
        dir = -1;
    }
    for (int i = 0; i < count; i++) {
        int childIndex = start + dir * i;
        final View child = getVirtualChildAt(childIndex);
        if (child == null) {
            childLeft += measureNullChild(childIndex);
        } else if (child.getVisibility() != GONE) {
            final int childWidth = child.getMeasuredWidth();
            final int childHeight = child.getMeasuredHeight();
            int childBaseline = -1;
            final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
            if (baselineAligned && lp.height != LayoutParams.MATCH_PARENT) {
                childBaseline = child.getBaseline();
            }
            int gravity = lp.gravity;
            if (gravity < 0) {
                gravity = minorGravity;
            }
            switch(gravity & Gravity.VERTICAL_GRAVITY_MASK) {
                case Gravity.TOP:
                    childTop = paddingTop + lp.topMargin;
                    if (childBaseline != -1) {
                        childTop += maxAscent[INDEX_TOP] - childBaseline;
                    }
                    break;
                case Gravity.CENTER_VERTICAL:
                    // Removed support for baseline alignment when layout_gravity or
                    // gravity == center_vertical. See bug #1038483.
                    // Keep the code around if we need to re-enable this feature
                    // if (childBaseline != -1) {
                    // // Align baselines vertically only if the child is smaller than us
                    // if (childSpace - childHeight > 0) {
                    // childTop = paddingTop + (childSpace / 2) - childBaseline;
                    // } else {
                    // childTop = paddingTop + (childSpace - childHeight) / 2;
                    // }
                    // } else {
                    childTop = paddingTop + ((childSpace - childHeight) / 2) + lp.topMargin - lp.bottomMargin;
                    break;
                case Gravity.BOTTOM:
                    childTop = childBottom - childHeight - lp.bottomMargin;
                    if (childBaseline != -1) {
                        int descent = child.getMeasuredHeight() - childBaseline;
                        childTop -= (maxDescent[INDEX_BOTTOM] - descent);
                    }
                    break;
                default:
                    childTop = paddingTop;
                    break;
            }
            if (hasDividerBeforeChildAt(childIndex)) {
                childLeft += mDividerWidth;
            }
            childLeft += lp.leftMargin;
            setChildFrame(child, childLeft + getLocationOffset(child), childTop, childWidth, childHeight);
            childLeft += childWidth + lp.rightMargin + getNextLocationOffset(child);
            i += getChildrenSkipCount(child, childIndex);
        }
    }
}
Body of Second Method:
{
    final boolean isLayoutRtl = isLayoutRtl();
    final int paddingTop = mPaddingTop;
    int childTop;
    int childLeft;
    // Where bottom of child should go
    final int height = bottom - top;
    int childBottom = height - mPaddingBottom;
    // Space available for child
    int childSpace = height - paddingTop - mPaddingBottom;
    final int count = getVirtualChildCount();
    final int majorGravity = mGravity & Gravity.RELATIVE_HORIZONTAL_GRAVITY_MASK;
    final int minorGravity = mGravity & Gravity.VERTICAL_GRAVITY_MASK;
    final boolean baselineAligned = mBaselineAligned;
    final int[] maxAscent = mMaxAscent;
    final int[] maxDescent = mMaxDescent;
    final int layoutDirection = getLayoutDirection();
    switch(Gravity.getAbsoluteGravity(majorGravity, layoutDirection)) {
        case Gravity.RIGHT:
            // mTotalLength contains the padding already
            childLeft = mPaddingLeft + right - left - mTotalLength;
            break;
        case Gravity.CENTER_HORIZONTAL:
            // mTotalLength contains the padding already
            childLeft = mPaddingLeft + (right - left - mTotalLength) / 2;
            break;
        case Gravity.LEFT:
        default:
            childLeft = mPaddingLeft;
            break;
    }
    int start = 0;
    int dir = 1;
    // In case of RTL, start drawing from the last child.
    if (isLayoutRtl) {
        start = count - 1;
        dir = -1;
    }
    for (int i = 0; i < count; i++) {
        final int childIndex = start + dir * i;
        final View child = getVirtualChildAt(childIndex);
        if (child == null) {
            childLeft += measureNullChild(childIndex);
        } else if (child.getVisibility() != GONE) {
            final int childWidth = child.getMeasuredWidth();
            final int childHeight = child.getMeasuredHeight();
            int childBaseline = -1;
            final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
            if (baselineAligned && lp.height != LayoutParams.MATCH_PARENT) {
                childBaseline = child.getBaseline();
            }
            int gravity = lp.gravity;
            if (gravity < 0) {
                gravity = minorGravity;
            }
            switch(gravity & Gravity.VERTICAL_GRAVITY_MASK) {
                case Gravity.TOP:
                    childTop = paddingTop + lp.topMargin;
                    if (childBaseline != -1) {
                        childTop += maxAscent[INDEX_TOP] - childBaseline;
                    }
                    break;
                case Gravity.CENTER_VERTICAL:
                    // Removed support for baseline alignment when layout_gravity or
                    // gravity == center_vertical. See bug #1038483.
                    // Keep the code around if we need to re-enable this feature
                    // if (childBaseline != -1) {
                    // // Align baselines vertically only if the child is smaller than us
                    // if (childSpace - childHeight > 0) {
                    // childTop = paddingTop + (childSpace / 2) - childBaseline;
                    // } else {
                    // childTop = paddingTop + (childSpace - childHeight) / 2;
                    // }
                    // } else {
                    childTop = paddingTop + ((childSpace - childHeight) / 2) + lp.topMargin - lp.bottomMargin;
                    break;
                case Gravity.BOTTOM:
                    childTop = childBottom - childHeight - lp.bottomMargin;
                    if (childBaseline != -1) {
                        int descent = child.getMeasuredHeight() - childBaseline;
                        childTop -= (maxDescent[INDEX_BOTTOM] - descent);
                    }
                    break;
                default:
                    childTop = paddingTop;
                    break;
            }
            if (hasDividerBeforeChildAt(childIndex)) {
                childLeft += mDividerWidth;
            }
            childLeft += lp.leftMargin;
            setChildFrame(child, childLeft + getLocationOffset(child), childTop, childWidth, childHeight);
            childLeft += childWidth + lp.rightMargin + getNextLocationOffset(child);
            i += getChildrenSkipCount(child, childIndex);
        }
    }
}
------------------------
Find a silently evolved API code:android.app.SearchManager.getSearchablesInGlobalSearch:COMMENT
Method Modifier: public      
Comment:/**
 * Returns a list of the searchable activities that can be included in global search.
 *
 * @return a list containing searchable information for all searchable activities
 * that have the <code>android:includeInGlobalSearch</code> attribute set
 * in their searchable meta-data.
 */

Body of Frist Method:
{
    try {
        return mService.getSearchablesInGlobalSearch();
    } catch (RemoteException e) {
        Log.e(TAG, "getSearchablesInGlobalSearch() failed: " + e);
        return null;
    }
}
Body of Second Method:
{
    try {
        return mService.getSearchablesInGlobalSearch();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.accounts.AccountManager.removeAccountExplicitly:COMMENT
Method Modifier: public      
Comment:/**
 * Removes an account directly. Normally used by authenticators, not
 * directly by applications. Does not delete the account from the server.
 * The authenticator may have its own policies preventing account deletion,
 * in which case the account will not be deleted.
 * <p>
 * It is safe to call this method from the main thread.
 * <p>This method requires the caller to have a signature match with the
 * authenticator that manages the specified account.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * AUTHENTICATE_ACCOUNTS permission and same UID as account's authenticator
 * is needed for those platforms. See docs for this function in API level 22.
 *
 * @param account The {@link Account} to delete.
 * @return True if the account was successfully deleted, false if the
 * account did not exist, the account is null, or another error
 * occurs.
 */

Body of Frist Method:
{
    if (account == null)
        throw new IllegalArgumentException("account is null");
    try {
        return mService.removeAccountExplicitly(account);
    } catch (RemoteException e) {
        // May happen if the caller doesn't match the signature of the authenticator.
        throw new RuntimeException(e);
    }
}
Body of Second Method:
{
    if (account == null)
        throw new IllegalArgumentException("account is null");
    try {
        return mService.removeAccountExplicitly(account);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.provider.DocumentsContract.isDocumentUri:COMMENT
Method Modifier: public      static      
Comment:/**
 * Test if the given URI represents a {@link Document} backed by a
 * {@link DocumentsProvider}.
 *
 * @see #buildDocumentUri(String, String)
 * @see #buildDocumentUriUsingTree(Uri, String)
 */

Body of Frist Method:
{
    final List<String> paths = uri.getPathSegments();
    if (paths.size() == 2 && PATH_DOCUMENT.equals(paths.get(0))) {
        return isDocumentsProvider(context, uri.getAuthority());
    }
    if (paths.size() == 4 && PATH_TREE.equals(paths.get(0)) && PATH_DOCUMENT.equals(paths.get(2))) {
        return isDocumentsProvider(context, uri.getAuthority());
    }
    return false;
}
Body of Second Method:
{
    if (isContentUri(uri) && isDocumentsProvider(context, uri.getAuthority())) {
        final List<String> paths = uri.getPathSegments();
        if (paths.size() == 2) {
            return PATH_DOCUMENT.equals(paths.get(0));
        } else if (paths.size() == 4) {
            return PATH_TREE.equals(paths.get(0)) && PATH_DOCUMENT.equals(paths.get(2));
        }
    }
    return false;
}
------------------------
Find a silently evolved API code:android.app.StatusBarManager.expandNotificationsPanel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Expand the notifications panel.
 */

Body of Frist Method:
{
    try {
        final IStatusBarService svc = getService();
        if (svc != null) {
            svc.expandNotificationsPanel();
        }
    } catch (RemoteException ex) {
        // system process is dead anyway.
        throw new RuntimeException(ex);
    }
}
Body of Second Method:
{
    try {
        final IStatusBarService svc = getService();
        if (svc != null) {
            svc.expandNotificationsPanel();
        }
    } catch (RemoteException ex) {
        throw ex.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiManager.saveConfiguration:COMMENT
Method Modifier: public      
Comment:/**
 * Tell the supplicant to persist the current list of configured networks.
 * <p>
 * Note: It is possible for this method to change the network IDs of
 * existing networks. You should assume the network IDs can be different
 * after calling this method.
 *
 * @return {@code true} if the operation succeeded
 */

Body of Frist Method:
{
    try {
        return mService.saveConfiguration();
    } catch (RemoteException e) {
        return false;
    }
}
Body of Second Method:
{
    try {
        return mService.saveConfiguration();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.media.AudioFormat.getBytesPerSample:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    switch(audioFormat) {
        case ENCODING_PCM_8BIT:
            return 1;
        case ENCODING_PCM_16BIT:
        case ENCODING_DEFAULT:
            return 2;
        case ENCODING_PCM_FLOAT:
            return 4;
        case ENCODING_INVALID:
        default:
            throw new IllegalArgumentException("Bad audio format " + audioFormat);
    }
}
Body of Second Method:
{
    switch(audioFormat) {
        case ENCODING_PCM_8BIT:
            return 1;
        case ENCODING_PCM_16BIT:
        case ENCODING_IEC61937:
        case ENCODING_DEFAULT:
            return 2;
        case ENCODING_PCM_FLOAT:
            return 4;
        case ENCODING_INVALID:
        default:
            throw new IllegalArgumentException("Bad audio format " + audioFormat);
    }
}
------------------------
Find a silently evolved API code:android.mtp.MtpObjectInfo.getSequenceNumber:COMMENT
Method Modifier: public      final       
Comment:/**
 * Returns the sequence number for the MTP object
 * This field is typically not used for MTP devices,
 * but is sometimes used to define a sequence of photos
 * on PTP cameras.
 *
 * @return the object's sequence number
 */

Body of Frist Method:
{
    return mSequenceNumber;
}
Body of Second Method:
{
    Preconditions.checkState(mSequenceNumber >= 0);
    return mSequenceNumber;
}
------------------------
Find a silently evolved API code:android.hardware.display.DisplayManagerGlobal.getDisplayInfo:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get information about a particular logical display.
 *
 * @param displayId The logical display id.
 * @return Information about the specified display, or null if it does not exist.
 * This object belongs to an internal cache and should be treated as if it were immutable.
 */

Body of Frist Method:
{
    try {
        synchronized (mLock) {
            DisplayInfo info;
            if (USE_CACHE) {
                info = mDisplayInfoCache.get(displayId);
                if (info != null) {
                    return info;
                }
            }
            info = mDm.getDisplayInfo(displayId);
            if (info == null) {
                return null;
            }
            if (USE_CACHE) {
                mDisplayInfoCache.put(displayId, info);
            }
            registerCallbackIfNeededLocked();
            if (DEBUG) {
                Log.d(TAG, "getDisplayInfo: displayId=" + displayId + ", info=" + info);
            }
            return info;
        }
    } catch (RemoteException ex) {
        Log.e(TAG, "Could not get display information from display manager.", ex);
        return null;
    }
}
Body of Second Method:
{
    try {
        synchronized (mLock) {
            DisplayInfo info;
            if (USE_CACHE) {
                info = mDisplayInfoCache.get(displayId);
                if (info != null) {
                    return info;
                }
            }
            info = mDm.getDisplayInfo(displayId);
            if (info == null) {
                return null;
            }
            if (USE_CACHE) {
                mDisplayInfoCache.put(displayId, info);
            }
            registerCallbackIfNeededLocked();
            if (DEBUG) {
                Log.d(TAG, "getDisplayInfo: displayId=" + displayId + ", info=" + info);
            }
            return info;
        }
    } catch (RemoteException ex) {
        throw ex.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.media.AudioFormat.Builder.setSampleRate:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the sample rate.
 * @param sampleRate the sample rate expressed in Hz
 * @return the same Builder instance.
 * @throws java.lang.IllegalArgumentException
 */

Body of Frist Method:
{
    if ((sampleRate <= 0) || (sampleRate > 192000)) {
        throw new IllegalArgumentException("Invalid sample rate " + sampleRate);
    }
    mSampleRate = sampleRate;
    mPropertySetMask |= AUDIO_FORMAT_HAS_PROPERTY_SAMPLE_RATE;
    return this;
}
Body of Second Method:
{
    // native implementation or platform capabilities.
    if (((sampleRate < SAMPLE_RATE_HZ_MIN) || (sampleRate > SAMPLE_RATE_HZ_MAX)) && sampleRate != SAMPLE_RATE_UNSPECIFIED) {
        throw new IllegalArgumentException("Invalid sample rate " + sampleRate);
    }
    mSampleRate = sampleRate;
    mPropertySetMask |= AUDIO_FORMAT_HAS_PROPERTY_SAMPLE_RATE;
    return this;
}
------------------------
Find a silently evolved API code:android.widget.TimePicker.setMinute:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the currently selected minute..
 *
 * @param minute the minute to set, in the range (0-59)
 * @see #getMinute()
 */

Body of Frist Method:
{
    mDelegate.setCurrentMinute(minute);
}
Body of Second Method:
{
    mDelegate.setMinute(minute);
}
------------------------
Find a silently evolved API code:android.animation.ValueAnimator.setCurrentPlayTime:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the position of the animation to the specified point in time. This time should
 * be between 0 and the total duration of the animation, including any repetition. If
 * the animation has not yet been started, then it will not advance forward after it is
 * set to this time; it will simply set the time to this value and perform any appropriate
 * actions based on that time. If the animation is already running, then setCurrentPlayTime()
 * will set the current playing time to this value and continue playing from that point.
 *
 * @param playTime The time, in milliseconds, to which the animation is advanced or rewound.
 */

Body of Frist Method:
{
    float fraction = mUnscaledDuration > 0 ? (float) playTime / mUnscaledDuration : 1;
    setCurrentFraction(fraction);
}
Body of Second Method:
{
    float fraction = mDuration > 0 ? (float) playTime / mDuration : 1;
    setCurrentFraction(fraction);
}
------------------------
Find a silently evolved API code:android.app.EnterTransitionCoordinator.cancelEnter:COMMENT
Method Modifier: public      
Comment:/**
 * Cancels the enter transition.
 * @return True if the enter transition is still pending capturing the target state. If so,
 * any transition started on the decor will do nothing.
 */

Body of Frist Method:
{
    setGhostVisibility(View.INVISIBLE);
    mHasStopped = true;
    mIsCanceled = true;
    mResultReceiver = null;
    if (mBackgroundAnimator != null) {
        mBackgroundAnimator.cancel();
        mBackgroundAnimator = null;
    }
    mActivity = null;
    clearState();
    return super.cancelPendingTransitions();
}
Body of Second Method:
{
    setGhostVisibility(View.INVISIBLE);
    mHasStopped = true;
    mIsCanceled = true;
    clearState();
    return super.cancelPendingTransitions();
}
------------------------
Find a silently evolved API code:android.view.LayoutInflater.createView:COMMENT
Method Modifier: public      final       
Comment:/**
 * Low-level function for instantiating a view by name. This attempts to
 * instantiate a view class of the given <var>name</var> found in this
 * LayoutInflater's ClassLoader.
 *
 * <p>
 * There are two things that can happen in an error case: either the
 * exception describing the error will be thrown, or a null will be
 * returned. You must deal with both possibilities -- the former will happen
 * the first time createView() is called for a class of a particular name,
 * the latter every time there-after for that class name.
 *
 * @param name The full name of the class to be instantiated.
 * @param attrs The XML attributes supplied for this instance.
 *
 * @return View The newly instantiated view, or null.
 */

Body of Frist Method:
{
    Constructor<? extends View> constructor = sConstructorMap.get(name);
    Class<? extends View> clazz = null;
    try {
        Trace.traceBegin(Trace.TRACE_TAG_VIEW, name);
        if (constructor == null) {
            // Class not found in the cache, see if it's real, and try to add it
            clazz = mContext.getClassLoader().loadClass(prefix != null ? (prefix + name) : name).asSubclass(View.class);
            if (mFilter != null && clazz != null) {
                boolean allowed = mFilter.onLoadClass(clazz);
                if (!allowed) {
                    failNotAllowed(name, prefix, attrs);
                }
            }
            constructor = clazz.getConstructor(mConstructorSignature);
            constructor.setAccessible(true);
            sConstructorMap.put(name, constructor);
        } else {
            // If we have a filter, apply it to cached constructor
            if (mFilter != null) {
                // Have we seen this name before?
                Boolean allowedState = mFilterMap.get(name);
                if (allowedState == null) {
                    // New class -- remember whether it is allowed
                    clazz = mContext.getClassLoader().loadClass(prefix != null ? (prefix + name) : name).asSubclass(View.class);
                    boolean allowed = clazz != null && mFilter.onLoadClass(clazz);
                    mFilterMap.put(name, allowed);
                    if (!allowed) {
                        failNotAllowed(name, prefix, attrs);
                    }
                } else if (allowedState.equals(Boolean.FALSE)) {
                    failNotAllowed(name, prefix, attrs);
                }
            }
        }
        Object[] args = mConstructorArgs;
        args[1] = attrs;
        final View view = constructor.newInstance(args);
        if (view instanceof ViewStub) {
            // Use the same context when inflating ViewStub later.
            final ViewStub viewStub = (ViewStub) view;
            viewStub.setLayoutInflater(cloneInContext((Context) args[0]));
        }
        return view;
    } catch (NoSuchMethodException e) {
        InflateException ie = new InflateException(attrs.getPositionDescription() + ": Error inflating class " + (prefix != null ? (prefix + name) : name));
        ie.initCause(e);
        throw ie;
    } catch (ClassCastException e) {
        // If loaded class is not a View subclass
        InflateException ie = new InflateException(attrs.getPositionDescription() + ": Class is not a View " + (prefix != null ? (prefix + name) : name));
        ie.initCause(e);
        throw ie;
    } catch (ClassNotFoundException e) {
        // If loadClass fails, we should propagate the exception.
        throw e;
    } catch (Exception e) {
        InflateException ie = new InflateException(attrs.getPositionDescription() + ": Error inflating class " + (clazz == null ? "<unknown>" : clazz.getName()));
        ie.initCause(e);
        throw ie;
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_VIEW);
    }
}
Body of Second Method:
{
    Constructor<? extends View> constructor = sConstructorMap.get(name);
    if (constructor != null && !verifyClassLoader(constructor)) {
        constructor = null;
        sConstructorMap.remove(name);
    }
    Class<? extends View> clazz = null;
    try {
        Trace.traceBegin(Trace.TRACE_TAG_VIEW, name);
        if (constructor == null) {
            // Class not found in the cache, see if it's real, and try to add it
            clazz = mContext.getClassLoader().loadClass(prefix != null ? (prefix + name) : name).asSubclass(View.class);
            if (mFilter != null && clazz != null) {
                boolean allowed = mFilter.onLoadClass(clazz);
                if (!allowed) {
                    failNotAllowed(name, prefix, attrs);
                }
            }
            constructor = clazz.getConstructor(mConstructorSignature);
            constructor.setAccessible(true);
            sConstructorMap.put(name, constructor);
        } else {
            // If we have a filter, apply it to cached constructor
            if (mFilter != null) {
                // Have we seen this name before?
                Boolean allowedState = mFilterMap.get(name);
                if (allowedState == null) {
                    // New class -- remember whether it is allowed
                    clazz = mContext.getClassLoader().loadClass(prefix != null ? (prefix + name) : name).asSubclass(View.class);
                    boolean allowed = clazz != null && mFilter.onLoadClass(clazz);
                    mFilterMap.put(name, allowed);
                    if (!allowed) {
                        failNotAllowed(name, prefix, attrs);
                    }
                } else if (allowedState.equals(Boolean.FALSE)) {
                    failNotAllowed(name, prefix, attrs);
                }
            }
        }
        Object[] args = mConstructorArgs;
        args[1] = attrs;
        final View view = constructor.newInstance(args);
        if (view instanceof ViewStub) {
            // Use the same context when inflating ViewStub later.
            final ViewStub viewStub = (ViewStub) view;
            viewStub.setLayoutInflater(cloneInContext((Context) args[0]));
        }
        return view;
    } catch (NoSuchMethodException e) {
        final InflateException ie = new InflateException(attrs.getPositionDescription() + ": Error inflating class " + (prefix != null ? (prefix + name) : name), e);
        ie.setStackTrace(EMPTY_STACK_TRACE);
        throw ie;
    } catch (ClassCastException e) {
        // If loaded class is not a View subclass
        final InflateException ie = new InflateException(attrs.getPositionDescription() + ": Class is not a View " + (prefix != null ? (prefix + name) : name), e);
        ie.setStackTrace(EMPTY_STACK_TRACE);
        throw ie;
    } catch (ClassNotFoundException e) {
        // If loadClass fails, we should propagate the exception.
        throw e;
    } catch (Exception e) {
        final InflateException ie = new InflateException(attrs.getPositionDescription() + ": Error inflating class " + (clazz == null ? "<unknown>" : clazz.getName()), e);
        ie.setStackTrace(EMPTY_STACK_TRACE);
        throw ie;
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_VIEW);
    }
}
------------------------
Find a silently evolved API code:android.app.ActivityManager.checkComponentPermission:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    // Root, system server get to do everything.
    final int appId = UserHandle.getAppId(uid);
    if (appId == Process.ROOT_UID || appId == Process.SYSTEM_UID) {
        return PackageManager.PERMISSION_GRANTED;
    }
    // Isolated processes don't get any permissions.
    if (UserHandle.isIsolated(uid)) {
        return PackageManager.PERMISSION_DENIED;
    }
    // blanket access to it regardless of the permissions it requires.
    if (owningUid >= 0 && UserHandle.isSameApp(uid, owningUid)) {
        return PackageManager.PERMISSION_GRANTED;
    }
    // If the target is not exported, then nobody else can get to it.
    if (!exported) {
        /*
            RuntimeException here = new RuntimeException("here");
            here.fillInStackTrace();
            Slog.w(TAG, "Permission denied: checkComponentPermission() owningUid=" + owningUid,
                    here);
            */
        return PackageManager.PERMISSION_DENIED;
    }
    if (permission == null) {
        return PackageManager.PERMISSION_GRANTED;
    }
    try {
        return AppGlobals.getPackageManager().checkUidPermission(permission, uid);
    } catch (RemoteException e) {
        // Should never happen, but if it does... deny!
        Slog.e(TAG, "PackageManager is dead?!?", e);
    }
    return PackageManager.PERMISSION_DENIED;
}
Body of Second Method:
{
    // Root, system server get to do everything.
    final int appId = UserHandle.getAppId(uid);
    if (appId == Process.ROOT_UID || appId == Process.SYSTEM_UID) {
        return PackageManager.PERMISSION_GRANTED;
    }
    // Isolated processes don't get any permissions.
    if (UserHandle.isIsolated(uid)) {
        return PackageManager.PERMISSION_DENIED;
    }
    // blanket access to it regardless of the permissions it requires.
    if (owningUid >= 0 && UserHandle.isSameApp(uid, owningUid)) {
        return PackageManager.PERMISSION_GRANTED;
    }
    // If the target is not exported, then nobody else can get to it.
    if (!exported) {
        /*
            RuntimeException here = new RuntimeException("here");
            here.fillInStackTrace();
            Slog.w(TAG, "Permission denied: checkComponentPermission() owningUid=" + owningUid,
                    here);
            */
        return PackageManager.PERMISSION_DENIED;
    }
    if (permission == null) {
        return PackageManager.PERMISSION_GRANTED;
    }
    try {
        return AppGlobals.getPackageManager().checkUidPermission(permission, uid);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.graphics.ImageFormat.isPublicFormat:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Determine whether or not this is a public-visible {@code format}.
 *
 * <p>In particular, {@code @hide} formats will return {@code false}.</p>
 *
 * <p>Any other formats (including UNKNOWN) will return {@code false}.</p>
 *
 * @param format an integer format
 * @return a boolean
 *
 * @hide
 */

Body of Frist Method:
{
    switch(format) {
        case RGB_565:
        case NV16:
        case YUY2:
        case YV12:
        case JPEG:
        case NV21:
        case YUV_420_888:
        case YUV_422_888:
        case YUV_444_888:
        case FLEX_RGB_888:
        case FLEX_RGBA_8888:
        case RAW_SENSOR:
        case RAW10:
        case RAW12:
        case DEPTH16:
        case DEPTH_POINT_CLOUD:
        case PRIVATE:
            return true;
    }
    return false;
}
Body of Second Method:
{
    switch(format) {
        case RGB_565:
        case NV16:
        case YUY2:
        case YV12:
        case JPEG:
        case NV21:
        case YUV_420_888:
        case YUV_422_888:
        case YUV_444_888:
        case FLEX_RGB_888:
        case FLEX_RGBA_8888:
        case RAW_SENSOR:
        case RAW_PRIVATE:
        case RAW10:
        case RAW12:
        case DEPTH16:
        case DEPTH_POINT_CLOUD:
        case PRIVATE:
            return true;
    }
    return false;
}
------------------------
Find a silently evolved API code:android.view.textservice.SpellCheckerSubtype.getDisplayName:COMMENT
Method Modifier: public      
Comment:/**
 * @param context Context will be used for getting Locale and PackageManager.
 * @param packageName The package name of the spell checker
 * @param appInfo The application info of the spell checker
 * @return a display name for this subtype. The string resource of the label (mSubtypeNameResId)
 * can have only one %s in it. If there is, the %s part will be replaced with the locale's
 * display name by the formatter. If there is not, this method simply returns the string
 * specified by mSubtypeNameResId. If mSubtypeNameResId is not specified (== 0), it's up to the
 * framework to generate an appropriate display name.
 */

Body of Frist Method:
{
    final Locale locale = constructLocaleFromString(mSubtypeLocale);
    final String localeStr = locale != null ? locale.getDisplayName() : mSubtypeLocale;
    if (mSubtypeNameResId == 0) {
        return localeStr;
    }
    final CharSequence subtypeName = context.getPackageManager().getText(packageName, mSubtypeNameResId, appInfo);
    if (!TextUtils.isEmpty(subtypeName)) {
        return String.format(subtypeName.toString(), localeStr);
    } else {
        return localeStr;
    }
}
Body of Second Method:
{
    final Locale locale = getLocaleObject();
    final String localeStr = locale != null ? locale.getDisplayName() : mSubtypeLocale;
    if (mSubtypeNameResId == 0) {
        return localeStr;
    }
    final CharSequence subtypeName = context.getPackageManager().getText(packageName, mSubtypeNameResId, appInfo);
    if (!TextUtils.isEmpty(subtypeName)) {
        return String.format(subtypeName.toString(), localeStr);
    } else {
        return localeStr;
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothGatt.setCharacteristicNotification:COMMENT
Method Modifier: public      
Comment:/**
 * Enable or disable notifications/indications for a given characteristic.
 *
 * <p>Once notifications are enabled for a characteristic, a
 * {@link BluetoothGattCallback#onCharacteristicChanged} callback will be
 * triggered if the remote device indicates that the given characteristic
 * has changed.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param characteristic The characteristic for which to enable notifications
 * @param enable Set to true to enable notifications/indications
 * @return true, if the requested notification status was set successfully
 */

Body of Frist Method:
{
    if (DBG)
        Log.d(TAG, "setCharacteristicNotification() - uuid: " + characteristic.getUuid() + " enable: " + enable);
    if (mService == null || mClientIf == 0)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    try {
        mService.registerForNotification(mClientIf, device.getAddress(), service.getType(), service.getInstanceId(), new ParcelUuid(service.getUuid()), characteristic.getInstanceId(), new ParcelUuid(characteristic.getUuid()), enable);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        return false;
    }
    return true;
}
Body of Second Method:
{
    if (DBG)
        Log.d(TAG, "setCharacteristicNotification() - uuid: " + characteristic.getUuid() + " enable: " + enable);
    if (mService == null || mClientIf == 0)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    try {
        mService.registerForNotification(mClientIf, device.getAddress(), characteristic.getInstanceId(), enable);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        return false;
    }
    return true;
}
------------------------
Find a silently evolved API code:android.media.midi.MidiManager.openBluetoothDevice:COMMENT
Method Modifier: public      
Comment:/**
 * Opens a Bluetooth MIDI device for reading and writing.
 *
 * @param bluetoothDevice a {@link android.bluetooth.BluetoothDevice} to open as a MIDI device
 * @param listener a {@link MidiManager.OnDeviceOpenedListener} to be called to receive the
 * result
 * @param handler the {@link android.os.Handler Handler} that will be used for delivering
 * the result. If handler is null, then the thread used for the
 * listener is unspecified.
 */

Body of Frist Method:
{
    final OnDeviceOpenedListener listenerF = listener;
    final Handler handlerF = handler;
    IMidiDeviceOpenCallback callback = new IMidiDeviceOpenCallback.Stub() {

        @Override
        public void onDeviceOpened(IMidiDeviceServer server, IBinder deviceToken) {
            MidiDevice device = null;
            if (server != null) {
                try {
                    // fetch MidiDeviceInfo from the server
                    MidiDeviceInfo deviceInfo = server.getDeviceInfo();
                    device = new MidiDevice(deviceInfo, server, mService, mToken, deviceToken);
                    sendOpenDeviceResponse(device, listenerF, handlerF);
                } catch (RemoteException e) {
                    Log.e(TAG, "remote exception in getDeviceInfo()");
                }
            }
            sendOpenDeviceResponse(device, listenerF, handlerF);
        }
    };
    try {
        mService.openBluetoothDevice(mToken, bluetoothDevice, callback);
    } catch (RemoteException e) {
        Log.e(TAG, "RemoteException in openDevice");
    }
}
Body of Second Method:
{
    final OnDeviceOpenedListener listenerF = listener;
    final Handler handlerF = handler;
    IMidiDeviceOpenCallback callback = new IMidiDeviceOpenCallback.Stub() {

        @Override
        public void onDeviceOpened(IMidiDeviceServer server, IBinder deviceToken) {
            MidiDevice device = null;
            if (server != null) {
                try {
                    // fetch MidiDeviceInfo from the server
                    MidiDeviceInfo deviceInfo = server.getDeviceInfo();
                    device = new MidiDevice(deviceInfo, server, mService, mToken, deviceToken);
                } catch (RemoteException e) {
                    Log.e(TAG, "remote exception in getDeviceInfo()");
                }
            }
            sendOpenDeviceResponse(device, listenerF, handlerF);
        }
    };
    try {
        mService.openBluetoothDevice(mToken, bluetoothDevice, callback);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.hardware.Sensor.setType:COMMENT
Method Modifier: private     
Comment:/**
 * Sets the Type associated with the sensor.
 * NOTE: to be used only by native bindings in SensorManager.
 *
 * This allows interned static strings to be used across all representations of the Sensor. If
 * a sensor type is not referenced here, it will still be interned by the native SensorManager.
 *
 * @return {@code true} if the StringType was successfully set, {@code false} otherwise.
 */

Body of Frist Method:
{
    mType = value;
    switch(mType) {
        case TYPE_ACCELEROMETER:
            mStringType = STRING_TYPE_ACCELEROMETER;
            return true;
        case TYPE_AMBIENT_TEMPERATURE:
            mStringType = STRING_TYPE_AMBIENT_TEMPERATURE;
            return true;
        case TYPE_GAME_ROTATION_VECTOR:
            mStringType = STRING_TYPE_GAME_ROTATION_VECTOR;
            return true;
        case TYPE_GEOMAGNETIC_ROTATION_VECTOR:
            mStringType = STRING_TYPE_GEOMAGNETIC_ROTATION_VECTOR;
            return true;
        case TYPE_GLANCE_GESTURE:
            mStringType = STRING_TYPE_GLANCE_GESTURE;
            return true;
        case TYPE_GRAVITY:
            mStringType = STRING_TYPE_GRAVITY;
            return true;
        case TYPE_GYROSCOPE:
            mStringType = STRING_TYPE_GYROSCOPE;
            return true;
        case TYPE_GYROSCOPE_UNCALIBRATED:
            mStringType = STRING_TYPE_GYROSCOPE_UNCALIBRATED;
            return true;
        case TYPE_HEART_RATE:
            mStringType = STRING_TYPE_HEART_RATE;
            return true;
        case TYPE_LIGHT:
            mStringType = STRING_TYPE_LIGHT;
            return true;
        case TYPE_LINEAR_ACCELERATION:
            mStringType = STRING_TYPE_LINEAR_ACCELERATION;
            return true;
        case TYPE_MAGNETIC_FIELD:
            mStringType = STRING_TYPE_MAGNETIC_FIELD;
            return true;
        case TYPE_MAGNETIC_FIELD_UNCALIBRATED:
            mStringType = STRING_TYPE_MAGNETIC_FIELD_UNCALIBRATED;
            return true;
        case TYPE_PICK_UP_GESTURE:
            mStringType = STRING_TYPE_PICK_UP_GESTURE;
            return true;
        case TYPE_PRESSURE:
            mStringType = STRING_TYPE_PRESSURE;
            return true;
        case TYPE_PROXIMITY:
            mStringType = STRING_TYPE_PROXIMITY;
            return true;
        case TYPE_RELATIVE_HUMIDITY:
            mStringType = STRING_TYPE_RELATIVE_HUMIDITY;
            return true;
        case TYPE_ROTATION_VECTOR:
            mStringType = STRING_TYPE_ROTATION_VECTOR;
            return true;
        case TYPE_SIGNIFICANT_MOTION:
            mStringType = STRING_TYPE_SIGNIFICANT_MOTION;
            return true;
        case TYPE_STEP_COUNTER:
            mStringType = STRING_TYPE_STEP_COUNTER;
            return true;
        case TYPE_STEP_DETECTOR:
            mStringType = STRING_TYPE_STEP_DETECTOR;
            return true;
        case TYPE_TILT_DETECTOR:
            mStringType = SENSOR_STRING_TYPE_TILT_DETECTOR;
            return true;
        case TYPE_WAKE_GESTURE:
            mStringType = STRING_TYPE_WAKE_GESTURE;
            return true;
        case TYPE_ORIENTATION:
            mStringType = STRING_TYPE_ORIENTATION;
            return true;
        case TYPE_TEMPERATURE:
            mStringType = STRING_TYPE_TEMPERATURE;
            return true;
        default:
            return false;
    }
}
Body of Second Method:
{
    mType = value;
    switch(mType) {
        case TYPE_ACCELEROMETER:
            mStringType = STRING_TYPE_ACCELEROMETER;
            return true;
        case TYPE_AMBIENT_TEMPERATURE:
            mStringType = STRING_TYPE_AMBIENT_TEMPERATURE;
            return true;
        case TYPE_GAME_ROTATION_VECTOR:
            mStringType = STRING_TYPE_GAME_ROTATION_VECTOR;
            return true;
        case TYPE_GEOMAGNETIC_ROTATION_VECTOR:
            mStringType = STRING_TYPE_GEOMAGNETIC_ROTATION_VECTOR;
            return true;
        case TYPE_GLANCE_GESTURE:
            mStringType = STRING_TYPE_GLANCE_GESTURE;
            return true;
        case TYPE_GRAVITY:
            mStringType = STRING_TYPE_GRAVITY;
            return true;
        case TYPE_GYROSCOPE:
            mStringType = STRING_TYPE_GYROSCOPE;
            return true;
        case TYPE_GYROSCOPE_UNCALIBRATED:
            mStringType = STRING_TYPE_GYROSCOPE_UNCALIBRATED;
            return true;
        case TYPE_HEART_RATE:
            mStringType = STRING_TYPE_HEART_RATE;
            return true;
        case TYPE_LIGHT:
            mStringType = STRING_TYPE_LIGHT;
            return true;
        case TYPE_LINEAR_ACCELERATION:
            mStringType = STRING_TYPE_LINEAR_ACCELERATION;
            return true;
        case TYPE_MAGNETIC_FIELD:
            mStringType = STRING_TYPE_MAGNETIC_FIELD;
            return true;
        case TYPE_MAGNETIC_FIELD_UNCALIBRATED:
            mStringType = STRING_TYPE_MAGNETIC_FIELD_UNCALIBRATED;
            return true;
        case TYPE_PICK_UP_GESTURE:
            mStringType = STRING_TYPE_PICK_UP_GESTURE;
            return true;
        case TYPE_PRESSURE:
            mStringType = STRING_TYPE_PRESSURE;
            return true;
        case TYPE_PROXIMITY:
            mStringType = STRING_TYPE_PROXIMITY;
            return true;
        case TYPE_RELATIVE_HUMIDITY:
            mStringType = STRING_TYPE_RELATIVE_HUMIDITY;
            return true;
        case TYPE_ROTATION_VECTOR:
            mStringType = STRING_TYPE_ROTATION_VECTOR;
            return true;
        case TYPE_SIGNIFICANT_MOTION:
            mStringType = STRING_TYPE_SIGNIFICANT_MOTION;
            return true;
        case TYPE_STEP_COUNTER:
            mStringType = STRING_TYPE_STEP_COUNTER;
            return true;
        case TYPE_STEP_DETECTOR:
            mStringType = STRING_TYPE_STEP_DETECTOR;
            return true;
        case TYPE_TILT_DETECTOR:
            mStringType = SENSOR_STRING_TYPE_TILT_DETECTOR;
            return true;
        case TYPE_WAKE_GESTURE:
            mStringType = STRING_TYPE_WAKE_GESTURE;
            return true;
        case TYPE_ORIENTATION:
            mStringType = STRING_TYPE_ORIENTATION;
            return true;
        case TYPE_TEMPERATURE:
            mStringType = STRING_TYPE_TEMPERATURE;
            return true;
        case TYPE_DEVICE_ORIENTATION:
            mStringType = STRING_TYPE_DEVICE_ORIENTATION;
            return true;
        case TYPE_DYNAMIC_SENSOR_META:
            mStringType = STRING_TYPE_DYNAMIC_SENSOR_META;
            return true;
        default:
            return false;
    }
}
------------------------
Find a silently evolved API code:android.media.ImageWriter.close:COMMENT
Method Modifier: public      
Comment:/**
 * Free up all the resources associated with this ImageWriter.
 * <p>
 * After calling this method, this ImageWriter cannot be used. Calling any
 * methods on this ImageWriter and Images previously provided by
 * {@link #dequeueInputImage()} will result in an
 * {@link IllegalStateException}, and attempting to write into
 * {@link ByteBuffer ByteBuffers} returned by an earlier
 * {@link Image.Plane#getBuffer Plane#getBuffer} call will have undefined
 * behavior.
 * </p>
 */

Body of Frist Method:
{
    setOnImageReleasedListener(null, null);
    for (Image image : mDequeuedImages) {
        image.close();
    }
    mDequeuedImages.clear();
    nativeClose(mNativeContext);
    mNativeContext = 0;
}
Body of Second Method:
{
    setOnImageReleasedListener(null, null);
    for (Image image : mDequeuedImages) {
        image.close();
    }
    mDequeuedImages.clear();
    nativeClose(mNativeContext);
    mNativeContext = 0;
    if (mEstimatedNativeAllocBytes > 0) {
        VMRuntime.getRuntime().registerNativeFree(mEstimatedNativeAllocBytes);
        mEstimatedNativeAllocBytes = 0;
    }
}
------------------------
Find a silently evolved API code:android.accounts.AccountManager.getUserData:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the user data named by "key" associated with the account.
 * This is intended for authenticators and related code to store
 * arbitrary metadata along with accounts.  The meaning of the keys
 * and values is up to the authenticator for the account.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>This method requires the caller to have a signature match with the
 * authenticator that owns the specified account.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * AUTHENTICATE_ACCOUNTS permission is needed for those platforms. See docs
 * for this function in API level 22.
 *
 * @param account The account to query for user data
 * @return The user data, null if the account or key doesn't exist
 */

Body of Frist Method:
{
    if (account == null)
        throw new IllegalArgumentException("account is null");
    if (key == null)
        throw new IllegalArgumentException("key is null");
    try {
        return mService.getUserData(account, key);
    } catch (RemoteException e) {
        // won't ever happen
        throw new RuntimeException(e);
    }
}
Body of Second Method:
{
    if (account == null)
        throw new IllegalArgumentException("account is null");
    if (key == null)
        throw new IllegalArgumentException("key is null");
    try {
        return mService.getUserData(account, key);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.graphics.Bitmap.createAshmemBitmap:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Creates a new immutable bitmap backed by ashmem which can efficiently
 * be passed between processes.
 *
 * @hide
 */

Body of Frist Method:
{
    checkRecycled("Can't copy a recycled bitmap");
    Bitmap b = nativeCopyAshmem(mFinalizer.mNativeBitmap);
    if (b != null) {
        b.setPremultiplied(mRequestPremultiplied);
        b.mDensity = mDensity;
    }
    return b;
}
Body of Second Method:
{
    checkRecycled("Can't copy a recycled bitmap");
    Bitmap b = nativeCopyAshmem(mNativePtr);
    if (b != null) {
        b.setPremultiplied(mRequestPremultiplied);
        b.mDensity = mDensity;
    }
    return b;
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiScanner.stopBackgroundScan:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * stop an ongoing wifi scan
 * @param listener specifies which scan to cancel; must be same object as passed in {@link
 * #startBackgroundScan}
 */

Body of Frist Method:
{
    validateChannel();
    sAsyncChannel.sendMessage(CMD_STOP_BACKGROUND_SCAN, 0, removeListener(listener));
}
Body of Second Method:
{
    Preconditions.checkNotNull(listener, "listener cannot be null");
    int key = removeListener(listener);
    if (key == INVALID_KEY)
        return;
    validateChannel();
    mAsyncChannel.sendMessage(CMD_STOP_BACKGROUND_SCAN, 0, key);
}
------------------------
Find a silently evolved API code:android.widget.Toast.setDuration:COMMENT
Method Modifier: public      
Comment:/**
 * Set how long to show the view for.
 * @see #LENGTH_SHORT
 * @see #LENGTH_LONG
 */

Body of Frist Method:
{
    mDuration = duration;
}
Body of Second Method:
{
    mDuration = duration;
    mTN.mDuration = duration;
}
------------------------
Find a silently evolved API code:android.graphics.Bitmap.setHasMipMap:COMMENT
Method Modifier: public      final       
Comment:/**
 * Set a hint for the renderer responsible for drawing this bitmap
 * indicating that it should attempt to use mipmaps when this bitmap
 * is drawn scaled down.
 *
 * If you know that you are going to draw this bitmap at less than
 * 50% of its original size, you may be able to obtain a higher
 * quality by turning this property on.
 *
 * Note that if the renderer respects this hint it might have to
 * allocate extra memory to hold the mipmap levels for this bitmap.
 *
 * This property is only a suggestion that can be ignored by the
 * renderer. It is not guaranteed to have any effect.
 *
 * @param hasMipMap indicates whether the renderer should attempt
 * to use mipmaps
 *
 * @see #hasMipMap()
 */

Body of Frist Method:
{
    checkRecycled("setHasMipMap called on a recycled bitmap");
    nativeSetHasMipMap(mFinalizer.mNativeBitmap, hasMipMap);
}
Body of Second Method:
{
    checkRecycled("setHasMipMap called on a recycled bitmap");
    nativeSetHasMipMap(mNativePtr, hasMipMap);
}
------------------------
Find a silently evolved API code:android.appwidget.AppWidgetHostView.updateAppWidget:COMMENT
Method Modifier: public      
Comment:/**
 * Process a set of {@link RemoteViews} coming in as an update from the
 * AppWidget provider. Will animate into these new views as needed
 */

Body of Frist Method:
{
    if (LOGD)
        Log.d(TAG, "updateAppWidget called mOld=" + mOld);
    boolean recycled = false;
    View content = null;
    Exception exception = null;
    // Capture the old view into a bitmap so we can do the crossfade.
    if (CROSSFADE) {
        if (mFadeStartTime < 0) {
            if (mView != null) {
                final int width = mView.getWidth();
                final int height = mView.getHeight();
                try {
                    mOld = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
                } catch (OutOfMemoryError e) {
                    // we just won't do the fade
                    mOld = null;
                }
                if (mOld != null) {
                // mView.drawIntoBitmap(mOld);
                }
            }
        }
    }
    if (remoteViews == null) {
        if (mViewMode == VIEW_MODE_DEFAULT) {
            // We've already done this -- nothing to do.
            return;
        }
        content = getDefaultView();
        mLayoutId = -1;
        mViewMode = VIEW_MODE_DEFAULT;
    } else {
        // Prepare a local reference to the remote Context so we're ready to
        // inflate any requested LayoutParams.
        mRemoteContext = getRemoteContext();
        int layoutId = remoteViews.getLayoutId();
        // layout matches, try recycling it
        if (content == null && layoutId == mLayoutId) {
            try {
                remoteViews.reapply(mContext, mView, mOnClickHandler);
                content = mView;
                recycled = true;
                if (LOGD)
                    Log.d(TAG, "was able to recycled existing layout");
            } catch (RuntimeException e) {
                exception = e;
            }
        }
        // Try normal RemoteView inflation
        if (content == null) {
            try {
                content = remoteViews.apply(mContext, this, mOnClickHandler);
                if (LOGD)
                    Log.d(TAG, "had to inflate new layout");
            } catch (RuntimeException e) {
                exception = e;
            }
        }
        mLayoutId = layoutId;
        mViewMode = VIEW_MODE_CONTENT;
    }
    if (content == null) {
        if (mViewMode == VIEW_MODE_ERROR) {
            // We've already done this -- nothing to do.
            return;
        }
        Log.w(TAG, "updateAppWidget couldn't find any view, using error view", exception);
        content = getErrorView();
        mViewMode = VIEW_MODE_ERROR;
    }
    if (!recycled) {
        prepareView(content);
        addView(content);
    }
    if (mView != content) {
        removeView(mView);
        mView = content;
    }
    if (CROSSFADE) {
        if (mFadeStartTime < 0) {
            // if there is already an animation in progress, don't do anything --
            // the new view will pop in on top of the old one during the cross fade,
            // and that looks okay.
            mFadeStartTime = SystemClock.uptimeMillis();
            invalidate();
        }
    }
}
Body of Second Method:
{
    applyRemoteViews(remoteViews);
}
------------------------
Find a silently evolved API code:android.location.Location.reset:COMMENT
Method Modifier: public      
Comment:/**
 * Clears the contents of the location.
 */

Body of Frist Method:
{
    mProvider = null;
    mTime = 0;
    mElapsedRealtimeNanos = 0;
    mLatitude = 0;
    mLongitude = 0;
    mHasAltitude = false;
    mAltitude = 0;
    mHasSpeed = false;
    mSpeed = 0;
    mHasBearing = false;
    mBearing = 0;
    mHasAccuracy = false;
    mAccuracy = 0;
    mExtras = null;
    mIsFromMockProvider = false;
}
Body of Second Method:
{
    mProvider = null;
    mTime = 0;
    mElapsedRealtimeNanos = 0;
    mFieldsMask = 0;
    mLatitude = 0;
    mLongitude = 0;
    mAltitude = 0;
    mSpeed = 0;
    mBearing = 0;
    mAccuracy = 0;
    mExtras = null;
}
------------------------
Find a silently evolved API code:android.os.PowerManager.reboot:COMMENT
Method Modifier: public      
Comment:/**
 * Reboot the device.  Will not return if the reboot is successful.
 * <p>
 * Requires the {@link android.Manifest.permission#REBOOT} permission.
 * </p>
 *
 * @param reason code to pass to the kernel (e.g., "recovery") to
 * request special boot modes, or null.
 */

Body of Frist Method:
{
    try {
        mService.reboot(false, reason, true);
    } catch (RemoteException e) {
    }
}
Body of Second Method:
{
    try {
        mService.reboot(false, reason, true);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.inputmethodservice.InputMethodService.onUpdateExtractingViews:COMMENT
Method Modifier: public      
Comment:/**
 * Called when the fullscreen-mode extracting editor info has changed,
 * to update the state of its UI such as the action buttons shown.
 * You do not need to deal with this if you are using the standard
 * full screen extract UI.  If replacing it, you will need to re-implement
 * this to put the appropriate action button in your own UI and handle it,
 * and perform any other changes.
 *
 * <p>The standard implementation turns on or off its accessory area
 * depending on whether there is an action button, and hides or shows
 * the entire extract area depending on whether it makes sense for the
 * current editor.  In particular, a {@link InputType#TYPE_NULL} or
 * {@link InputType#TYPE_TEXT_VARIATION_FILTER} input type will turn off the
 * extract area since there is no text to be shown.
 */

Body of Frist Method:
{
    if (!isExtractViewShown()) {
        return;
    }
    if (mExtractAccessories == null) {
        return;
    }
    final boolean hasAction = ei.actionLabel != null || ((ei.imeOptions & EditorInfo.IME_MASK_ACTION) != EditorInfo.IME_ACTION_NONE && (ei.imeOptions & EditorInfo.IME_FLAG_NO_ACCESSORY_ACTION) == 0 && ei.inputType != InputType.TYPE_NULL);
    if (hasAction) {
        mExtractAccessories.setVisibility(View.VISIBLE);
        if (mExtractAction != null) {
            if (ei.actionLabel != null) {
                mExtractAction.setText(ei.actionLabel);
            } else {
                mExtractAction.setText(getTextForImeAction(ei.imeOptions));
            }
            mExtractAction.setOnClickListener(mActionClickListener);
        }
    } else {
        mExtractAccessories.setVisibility(View.GONE);
        if (mExtractAction != null) {
            mExtractAction.setOnClickListener(null);
        }
    }
}
Body of Second Method:
{
    if (!isExtractViewShown()) {
        return;
    }
    if (mExtractAccessories == null) {
        return;
    }
    final boolean hasAction = ei.actionLabel != null || ((ei.imeOptions & EditorInfo.IME_MASK_ACTION) != EditorInfo.IME_ACTION_NONE && (ei.imeOptions & EditorInfo.IME_FLAG_NO_ACCESSORY_ACTION) == 0 && ei.inputType != InputType.TYPE_NULL);
    if (hasAction) {
        mExtractAccessories.setVisibility(View.VISIBLE);
        if (mExtractAction != null) {
            if (mExtractAction instanceof ImageButton) {
                ((ImageButton) mExtractAction).setImageResource(getIconForImeAction(ei.imeOptions));
                if (ei.actionLabel != null) {
                    mExtractAction.setContentDescription(ei.actionLabel);
                } else {
                    mExtractAction.setContentDescription(getTextForImeAction(ei.imeOptions));
                }
            } else {
                if (ei.actionLabel != null) {
                    ((TextView) mExtractAction).setText(ei.actionLabel);
                } else {
                    ((TextView) mExtractAction).setText(getTextForImeAction(ei.imeOptions));
                }
            }
            mExtractAction.setOnClickListener(mActionClickListener);
        }
    } else {
        mExtractAccessories.setVisibility(View.GONE);
        if (mExtractAction != null) {
            mExtractAction.setOnClickListener(null);
        }
    }
}
------------------------
Find a silently evolved API code:android.accounts.AccountManager.getSharedAccounts:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 * @param user
 * @return
 */

Body of Frist Method:
{
    try {
        return mService.getSharedAccountsAsUser(user.getIdentifier());
    } catch (RemoteException re) {
        // won't ever happen
        throw new RuntimeException(re);
    }
}
Body of Second Method:
{
    try {
        return mService.getSharedAccountsAsUser(user.getIdentifier());
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.telephony.TelephonyManager.getDefaultPhone:COMMENT
Method Modifier: private     static      
Comment:/**
 * Returns Default phone.
 */

Body of Frist Method:
{
    return SubscriptionManager.getPhoneId(SubscriptionManager.getDefaultSubId());
}
Body of Second Method:
{
    return SubscriptionManager.getPhoneId(SubscriptionManager.getDefaultSubscriptionId());
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiScanner.startTrackingBssids:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * set interesting access points to find
 * @param bssidInfos access points of interest
 * @param apLostThreshold number of scans needed to indicate that AP is lost
 * @param listener object provided to report events on; this object must be unique and must
 * also be provided on {@link #stopTrackingBssids}
 */

Body of Frist Method:
{
    validateChannel();
    HotlistSettings settings = new HotlistSettings();
    settings.bssidInfos = bssidInfos;
    sAsyncChannel.sendMessage(CMD_SET_HOTLIST, 0, putListener(listener), settings);
}
Body of Second Method:
{
    Preconditions.checkNotNull(listener, "listener cannot be null");
    int key = addListener(listener);
    if (key == INVALID_KEY)
        return;
    validateChannel();
    HotlistSettings settings = new HotlistSettings();
    settings.bssidInfos = bssidInfos;
    settings.apLostThreshold = apLostThreshold;
    mAsyncChannel.sendMessage(CMD_SET_HOTLIST, 0, key, settings);
}
------------------------
Find a silently evolved API code:android.widget.ProgressBar.setProgressDrawable:COMMENT
Method Modifier: public      
Comment:/**
 * Define the drawable used to draw the progress bar in progress mode.
 *
 * @param d the new drawable
 * @see #getProgressDrawable()
 * @see #setIndeterminate(boolean)
 */

Body of Frist Method:
{
    if (mProgressDrawable != d) {
        if (mProgressDrawable != null) {
            mProgressDrawable.setCallback(null);
            unscheduleDrawable(mProgressDrawable);
        }
        mProgressDrawable = d;
        if (d != null) {
            d.setCallback(this);
            d.setLayoutDirection(getLayoutDirection());
            if (d.isStateful()) {
                d.setState(getDrawableState());
            }
            // Make sure the ProgressBar is always tall enough
            int drawableHeight = d.getMinimumHeight();
            if (mMaxHeight < drawableHeight) {
                mMaxHeight = drawableHeight;
                requestLayout();
            }
            applyProgressTints();
        }
        if (!mIndeterminate) {
            mCurrentDrawable = d;
            postInvalidate();
        }
        updateDrawableBounds(getWidth(), getHeight());
        updateDrawableState();
        doRefreshProgress(R.id.progress, mProgress, false, false);
        doRefreshProgress(R.id.secondaryProgress, mSecondaryProgress, false, false);
    }
}
Body of Second Method:
{
    if (mProgressDrawable != d) {
        if (mProgressDrawable != null) {
            mProgressDrawable.setCallback(null);
            unscheduleDrawable(mProgressDrawable);
        }
        mProgressDrawable = d;
        if (d != null) {
            d.setCallback(this);
            d.setLayoutDirection(getLayoutDirection());
            if (d.isStateful()) {
                d.setState(getDrawableState());
            }
            // Make sure the ProgressBar is always tall enough
            int drawableHeight = d.getMinimumHeight();
            if (mMaxHeight < drawableHeight) {
                mMaxHeight = drawableHeight;
                requestLayout();
            }
            applyProgressTints();
        }
        if (!mIndeterminate) {
            swapCurrentDrawable(d);
            postInvalidate();
        }
        updateDrawableBounds(getWidth(), getHeight());
        updateDrawableState();
        doRefreshProgress(R.id.progress, mProgress, false, false, false);
        doRefreshProgress(R.id.secondaryProgress, mSecondaryProgress, false, false, false);
    }
}
------------------------
Find a silently evolved API code:android.app.AlarmManager.setInexactRepeating:COMMENT
Method Modifier: public      
Comment:/**
 * Schedule a repeating alarm that has inexact trigger time requirements;
 * for example, an alarm that repeats every hour, but not necessarily at
 * the top of every hour.  These alarms are more power-efficient than
 * the strict recurrences traditionally supplied by {@link #setRepeating}, since the
 * system can adjust alarms' delivery times to cause them to fire simultaneously,
 * avoiding waking the device from sleep more than necessary.
 *
 * <p>Your alarm's first trigger will not be before the requested time,
 * but it might not occur for almost a full interval after that time.  In
 * addition, while the overall period of the repeating alarm will be as
 * requested, the time between any two successive firings of the alarm
 * may vary.  If your application demands very low jitter, use
 * one-shot alarms with an appropriate window instead; see {@link
 * #setWindow(int, long, long, PendingIntent)} and
 * {@link #setExact(int, long, PendingIntent)}.
 *
 * <p class="note">
 * As of API 19, all repeating alarms are inexact.  Because this method has
 * been available since API 3, your application can safely call it and be
 * assured that it will get similar behavior on both current and older versions
 * of Android.
 *
 * @param type One of {@link #ELAPSED_REALTIME}, {@link #ELAPSED_REALTIME_WAKEUP},
 * {@link #RTC}, or {@link #RTC_WAKEUP}.
 * @param triggerAtMillis time in milliseconds that the alarm should first
 * go off, using the appropriate clock (depending on the alarm type).  This
 * is inexact: the alarm will not fire before this time, but there may be a
 * delay of almost an entire alarm interval before the first invocation of
 * the alarm.
 * @param intervalMillis interval in milliseconds between subsequent repeats
 * of the alarm.  Prior to API 19, if this is one of INTERVAL_FIFTEEN_MINUTES,
 * INTERVAL_HALF_HOUR, INTERVAL_HOUR, INTERVAL_HALF_DAY, or INTERVAL_DAY
 * then the alarm will be phase-aligned with other alarms to reduce the
 * number of wakeups.  Otherwise, the alarm will be set as though the
 * application had called {@link #setRepeating}.  As of API 19, all repeating
 * alarms will be inexact and subject to batching with other alarms regardless
 * of their stated repeat interval.
 * @param operation Action to perform when the alarm goes off;
 * typically comes from {@link PendingIntent#getBroadcast
 * IntentSender.getBroadcast()}.
 *
 * @see android.os.Handler
 * @see #set
 * @see #cancel
 * @see android.content.Context#sendBroadcast
 * @see android.content.Context#registerReceiver
 * @see android.content.Intent#filterEquals
 * @see #ELAPSED_REALTIME
 * @see #ELAPSED_REALTIME_WAKEUP
 * @see #RTC
 * @see #RTC_WAKEUP
 * @see #INTERVAL_FIFTEEN_MINUTES
 * @see #INTERVAL_HALF_HOUR
 * @see #INTERVAL_HOUR
 * @see #INTERVAL_HALF_DAY
 * @see #INTERVAL_DAY
 */

Body of Frist Method:
{
    setImpl(type, triggerAtMillis, WINDOW_HEURISTIC, intervalMillis, 0, operation, null, null);
}
Body of Second Method:
{
    setImpl(type, triggerAtMillis, WINDOW_HEURISTIC, intervalMillis, 0, operation, null, null, null, null, null);
}
------------------------
Find a silently evolved API code:android.text.Layout.drawText:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    int previousLineBottom = getLineTop(firstLine);
    int previousLineEnd = getLineStart(firstLine);
    ParagraphStyle[] spans = NO_PARA_SPANS;
    int spanEnd = 0;
    TextPaint paint = mPaint;
    CharSequence buf = mText;
    Alignment paraAlign = mAlignment;
    TabStops tabStops = null;
    boolean tabStopsIsInitialized = false;
    TextLine tl = TextLine.obtain();
    // The baseline is the top of the following line minus the current line's descent.
    for (int lineNum = firstLine; lineNum <= lastLine; lineNum++) {
        int start = previousLineEnd;
        previousLineEnd = getLineStart(lineNum + 1);
        int end = getLineVisibleEnd(lineNum, start, previousLineEnd);
        int ltop = previousLineBottom;
        int lbottom = getLineTop(lineNum + 1);
        previousLineBottom = lbottom;
        int lbaseline = lbottom - getLineDescent(lineNum);
        int dir = getParagraphDirection(lineNum);
        int left = 0;
        int right = mWidth;
        if (mSpannedText) {
            Spanned sp = (Spanned) buf;
            int textLength = buf.length();
            boolean isFirstParaLine = (start == 0 || buf.charAt(start - 1) == '\n');
            // our problem.
            if (start >= spanEnd && (lineNum == firstLine || isFirstParaLine)) {
                spanEnd = sp.nextSpanTransition(start, textLength, ParagraphStyle.class);
                spans = getParagraphSpans(sp, start, spanEnd, ParagraphStyle.class);
                paraAlign = mAlignment;
                for (int n = spans.length - 1; n >= 0; n--) {
                    if (spans[n] instanceof AlignmentSpan) {
                        paraAlign = ((AlignmentSpan) spans[n]).getAlignment();
                        break;
                    }
                }
                tabStopsIsInitialized = false;
            }
            // Draw all leading margin spans.  Adjust left or right according
            // to the paragraph direction of the line.
            final int length = spans.length;
            boolean useFirstLineMargin = isFirstParaLine;
            for (int n = 0; n < length; n++) {
                if (spans[n] instanceof LeadingMarginSpan2) {
                    int count = ((LeadingMarginSpan2) spans[n]).getLeadingMarginLineCount();
                    int startLine = getLineForOffset(sp.getSpanStart(spans[n]));
                    // the count that is greatest
                    if (lineNum < startLine + count) {
                        useFirstLineMargin = true;
                        break;
                    }
                }
            }
            for (int n = 0; n < length; n++) {
                if (spans[n] instanceof LeadingMarginSpan) {
                    LeadingMarginSpan margin = (LeadingMarginSpan) spans[n];
                    if (dir == DIR_RIGHT_TO_LEFT) {
                        margin.drawLeadingMargin(canvas, paint, right, dir, ltop, lbaseline, lbottom, buf, start, end, isFirstParaLine, this);
                        right -= margin.getLeadingMargin(useFirstLineMargin);
                    } else {
                        margin.drawLeadingMargin(canvas, paint, left, dir, ltop, lbaseline, lbottom, buf, start, end, isFirstParaLine, this);
                        left += margin.getLeadingMargin(useFirstLineMargin);
                    }
                }
            }
        }
        boolean hasTabOrEmoji = getLineContainsTab(lineNum);
        // Can't tell if we have tabs for sure, currently
        if (hasTabOrEmoji && !tabStopsIsInitialized) {
            if (tabStops == null) {
                tabStops = new TabStops(TAB_INCREMENT, spans);
            } else {
                tabStops.reset(TAB_INCREMENT, spans);
            }
            tabStopsIsInitialized = true;
        }
        // Determine whether the line aligns to normal, opposite, or center.
        Alignment align = paraAlign;
        if (align == Alignment.ALIGN_LEFT) {
            align = (dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_NORMAL : Alignment.ALIGN_OPPOSITE;
        } else if (align == Alignment.ALIGN_RIGHT) {
            align = (dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_OPPOSITE : Alignment.ALIGN_NORMAL;
        }
        int x;
        if (align == Alignment.ALIGN_NORMAL) {
            if (dir == DIR_LEFT_TO_RIGHT) {
                x = left + getIndentAdjust(lineNum, Alignment.ALIGN_LEFT);
            } else {
                x = right + getIndentAdjust(lineNum, Alignment.ALIGN_RIGHT);
            }
        } else {
            int max = (int) getLineExtent(lineNum, tabStops, false);
            if (align == Alignment.ALIGN_OPPOSITE) {
                if (dir == DIR_LEFT_TO_RIGHT) {
                    x = right - max + getIndentAdjust(lineNum, Alignment.ALIGN_RIGHT);
                } else {
                    x = left - max + getIndentAdjust(lineNum, Alignment.ALIGN_LEFT);
                }
            } else {
                // Alignment.ALIGN_CENTER
                max = max & ~1;
                x = ((right + left - max) >> 1) + getIndentAdjust(lineNum, Alignment.ALIGN_CENTER);
            }
        }
        paint.setHyphenEdit(getHyphen(lineNum));
        Directions directions = getLineDirections(lineNum);
        if (directions == DIRS_ALL_LEFT_TO_RIGHT && !mSpannedText && !hasTabOrEmoji) {
            // XXX: assumes there's nothing additional to be done
            canvas.drawText(buf, start, end, x, lbaseline, paint);
        } else {
            tl.set(paint, buf, start, end, dir, directions, hasTabOrEmoji, tabStops);
            tl.draw(canvas, x, ltop, lbaseline, lbottom);
        }
        paint.setHyphenEdit(0);
    }
    TextLine.recycle(tl);
}
Body of Second Method:
{
    int previousLineBottom = getLineTop(firstLine);
    int previousLineEnd = getLineStart(firstLine);
    ParagraphStyle[] spans = NO_PARA_SPANS;
    int spanEnd = 0;
    TextPaint paint = mPaint;
    CharSequence buf = mText;
    Alignment paraAlign = mAlignment;
    TabStops tabStops = null;
    boolean tabStopsIsInitialized = false;
    TextLine tl = TextLine.obtain();
    // The baseline is the top of the following line minus the current line's descent.
    for (int lineNum = firstLine; lineNum <= lastLine; lineNum++) {
        int start = previousLineEnd;
        previousLineEnd = getLineStart(lineNum + 1);
        int end = getLineVisibleEnd(lineNum, start, previousLineEnd);
        int ltop = previousLineBottom;
        int lbottom = getLineTop(lineNum + 1);
        previousLineBottom = lbottom;
        int lbaseline = lbottom - getLineDescent(lineNum);
        int dir = getParagraphDirection(lineNum);
        int left = 0;
        int right = mWidth;
        if (mSpannedText) {
            Spanned sp = (Spanned) buf;
            int textLength = buf.length();
            boolean isFirstParaLine = (start == 0 || buf.charAt(start - 1) == '\n');
            // our problem.
            if (start >= spanEnd && (lineNum == firstLine || isFirstParaLine)) {
                spanEnd = sp.nextSpanTransition(start, textLength, ParagraphStyle.class);
                spans = getParagraphSpans(sp, start, spanEnd, ParagraphStyle.class);
                paraAlign = mAlignment;
                for (int n = spans.length - 1; n >= 0; n--) {
                    if (spans[n] instanceof AlignmentSpan) {
                        paraAlign = ((AlignmentSpan) spans[n]).getAlignment();
                        break;
                    }
                }
                tabStopsIsInitialized = false;
            }
            // Draw all leading margin spans.  Adjust left or right according
            // to the paragraph direction of the line.
            final int length = spans.length;
            boolean useFirstLineMargin = isFirstParaLine;
            for (int n = 0; n < length; n++) {
                if (spans[n] instanceof LeadingMarginSpan2) {
                    int count = ((LeadingMarginSpan2) spans[n]).getLeadingMarginLineCount();
                    int startLine = getLineForOffset(sp.getSpanStart(spans[n]));
                    // the count that is greatest
                    if (lineNum < startLine + count) {
                        useFirstLineMargin = true;
                        break;
                    }
                }
            }
            for (int n = 0; n < length; n++) {
                if (spans[n] instanceof LeadingMarginSpan) {
                    LeadingMarginSpan margin = (LeadingMarginSpan) spans[n];
                    if (dir == DIR_RIGHT_TO_LEFT) {
                        margin.drawLeadingMargin(canvas, paint, right, dir, ltop, lbaseline, lbottom, buf, start, end, isFirstParaLine, this);
                        right -= margin.getLeadingMargin(useFirstLineMargin);
                    } else {
                        margin.drawLeadingMargin(canvas, paint, left, dir, ltop, lbaseline, lbottom, buf, start, end, isFirstParaLine, this);
                        left += margin.getLeadingMargin(useFirstLineMargin);
                    }
                }
            }
        }
        boolean hasTab = getLineContainsTab(lineNum);
        // Can't tell if we have tabs for sure, currently
        if (hasTab && !tabStopsIsInitialized) {
            if (tabStops == null) {
                tabStops = new TabStops(TAB_INCREMENT, spans);
            } else {
                tabStops.reset(TAB_INCREMENT, spans);
            }
            tabStopsIsInitialized = true;
        }
        // Determine whether the line aligns to normal, opposite, or center.
        Alignment align = paraAlign;
        if (align == Alignment.ALIGN_LEFT) {
            align = (dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_NORMAL : Alignment.ALIGN_OPPOSITE;
        } else if (align == Alignment.ALIGN_RIGHT) {
            align = (dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_OPPOSITE : Alignment.ALIGN_NORMAL;
        }
        int x;
        if (align == Alignment.ALIGN_NORMAL) {
            if (dir == DIR_LEFT_TO_RIGHT) {
                x = left + getIndentAdjust(lineNum, Alignment.ALIGN_LEFT);
            } else {
                x = right + getIndentAdjust(lineNum, Alignment.ALIGN_RIGHT);
            }
        } else {
            int max = (int) getLineExtent(lineNum, tabStops, false);
            if (align == Alignment.ALIGN_OPPOSITE) {
                if (dir == DIR_LEFT_TO_RIGHT) {
                    x = right - max + getIndentAdjust(lineNum, Alignment.ALIGN_RIGHT);
                } else {
                    x = left - max + getIndentAdjust(lineNum, Alignment.ALIGN_LEFT);
                }
            } else {
                // Alignment.ALIGN_CENTER
                max = max & ~1;
                x = ((right + left - max) >> 1) + getIndentAdjust(lineNum, Alignment.ALIGN_CENTER);
            }
        }
        paint.setHyphenEdit(getHyphen(lineNum));
        Directions directions = getLineDirections(lineNum);
        if (directions == DIRS_ALL_LEFT_TO_RIGHT && !mSpannedText && !hasTab) {
            // XXX: assumes there's nothing additional to be done
            canvas.drawText(buf, start, end, x, lbaseline, paint);
        } else {
            tl.set(paint, buf, start, end, dir, directions, hasTab, tabStops);
            tl.draw(canvas, x, ltop, lbaseline, lbottom);
        }
        paint.setHyphenEdit(0);
    }
    TextLine.recycle(tl);
}
------------------------
Find a silently evolved API code:android.nfc.NfcAdapter.hasNfcFeature:COMMENT
Method Modifier: private     static      
Comment:/**
 * Helper to check if this device has FEATURE_NFC, but without using
 * a context.
 * Equivalent to
 * context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_NFC)
 */

Body of Frist Method:
{
    IPackageManager pm = ActivityThread.getPackageManager();
    if (pm == null) {
        Log.e(TAG, "Cannot get package manager, assuming no NFC feature");
        return false;
    }
    try {
        return pm.hasSystemFeature(PackageManager.FEATURE_NFC);
    } catch (RemoteException e) {
        Log.e(TAG, "Package manager query failed, assuming no NFC feature", e);
        return false;
    }
}
Body of Second Method:
{
    IPackageManager pm = ActivityThread.getPackageManager();
    if (pm == null) {
        Log.e(TAG, "Cannot get package manager, assuming no NFC feature");
        return false;
    }
    try {
        return pm.hasSystemFeature(PackageManager.FEATURE_NFC, 0);
    } catch (RemoteException e) {
        Log.e(TAG, "Package manager query failed, assuming no NFC feature", e);
        return false;
    }
}
------------------------
Find a silently evolved API code:android.view.RenderNode.start:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Starts recording a display list for the render node. All
 * operations performed on the returned canvas are recorded and
 * stored in this display list.
 *
 * Calling this method will mark the render node invalid until
 * {@link #end(DisplayListCanvas)} is called.
 * Only valid render nodes can be replayed.
 *
 * @param width The width of the recording viewport
 * @param height The height of the recording viewport
 *
 * @return A canvas to record drawing operations.
 *
 * @see #end(DisplayListCanvas)
 * @see #isValid()
 */

Body of Frist Method:
{
    DisplayListCanvas canvas = DisplayListCanvas.obtain(this);
    canvas.setViewport(width, height);
    // The dirty rect should always be null for a display list
    canvas.onPreDraw(null);
    return canvas;
}
Body of Second Method:
{
    return DisplayListCanvas.obtain(this, width, height);
}
------------------------
Find a silently evolved API code:android.media.MediaCodecList.getGlobalSettings:COMMENT
Method Modifier: default     static      final       
Comment:/* package private */

Body of Frist Method:
{
    return sGlobalSettings;
}
Body of Second Method:
{
    synchronized (sInitLock) {
        if (sGlobalSettings == null) {
            sGlobalSettings = native_getGlobalSettings();
        }
    }
    return sGlobalSettings;
}
------------------------
Find a silently evolved API code:android.widget.AdapterViewFlipper.showPrevious:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    // we should we should make sure to reset the timer
    if (mRunning) {
        mHandler.removeMessages(FLIP_MSG);
        Message msg = mHandler.obtainMessage(FLIP_MSG);
        mHandler.sendMessageDelayed(msg, mFlipInterval);
    }
    super.showPrevious();
}
Body of Second Method:
{
    // we should we should make sure to reset the timer
    if (mRunning) {
        removeCallbacks(mFlipRunnable);
        postDelayed(mFlipRunnable, mFlipInterval);
    }
    super.showPrevious();
}
------------------------
Find a silently evolved API code:android.accounts.AccountManager.removeSharedAccount:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 * Removes the shared account.
 * @param account the account to remove
 * @param user the user to remove the account from
 * @return
 */

Body of Frist Method:
{
    try {
        boolean val = mService.removeSharedAccountAsUser(account, user.getIdentifier());
        return val;
    } catch (RemoteException re) {
        // won't ever happen
        throw new RuntimeException(re);
    }
}
Body of Second Method:
{
    try {
        boolean val = mService.removeSharedAccountAsUser(account, user.getIdentifier());
        return val;
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.graphics.Bitmap.copy:COMMENT
Method Modifier: public      
Comment:/**
 * Tries to make a new bitmap based on the dimensions of this bitmap,
 * setting the new bitmap's config to the one specified, and then copying
 * this bitmap's pixels into the new bitmap. If the conversion is not
 * supported, or the allocator fails, then this returns NULL.  The returned
 * bitmap initially has the same density as the original.
 *
 * @param config    The desired config for the resulting bitmap
 * @param isMutable True if the resulting bitmap should be mutable (i.e.
 * its pixels can be modified)
 * @return the new bitmap, or null if the copy could not be made.
 */

Body of Frist Method:
{
    checkRecycled("Can't copy a recycled bitmap");
    Bitmap b = nativeCopy(mFinalizer.mNativeBitmap, config.nativeInt, isMutable);
    if (b != null) {
        b.setPremultiplied(mRequestPremultiplied);
        b.mDensity = mDensity;
    }
    return b;
}
Body of Second Method:
{
    checkRecycled("Can't copy a recycled bitmap");
    Bitmap b = nativeCopy(mNativePtr, config.nativeInt, isMutable);
    if (b != null) {
        b.setPremultiplied(mRequestPremultiplied);
        b.mDensity = mDensity;
    }
    return b;
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiEnterpriseConfig.setPhase2Method:COMMENT
Method Modifier: public      
Comment:/**
 * Set Phase 2 authentication method. Sets the inner authentication method to be used in
 * phase 2 after setting up a secure channel
 * @param phase2Method is the inner authentication method and can be one of {@link Phase2#NONE},
 * {@link Phase2#PAP}, {@link Phase2#MSCHAP}, {@link Phase2#MSCHAPV2},
 * {@link Phase2#GTC}
 * @throws IllegalArgumentException on an invalid phase2 method
 */

Body of Frist Method:
{
    switch(phase2Method) {
        case Phase2.NONE:
            mFields.put(PHASE2_KEY, EMPTY_VALUE);
            break;
        /**
         * Valid methods
         */
        case Phase2.PAP:
        case Phase2.MSCHAP:
        case Phase2.MSCHAPV2:
        case Phase2.GTC:
            mFields.put(PHASE2_KEY, convertToQuotedString(Phase2.PREFIX + Phase2.strings[phase2Method]));
            break;
        default:
            throw new IllegalArgumentException("Unknown Phase 2 method");
    }
}
Body of Second Method:
{
    switch(phase2Method) {
        case Phase2.NONE:
        case Phase2.PAP:
        case Phase2.MSCHAP:
        case Phase2.MSCHAPV2:
        case Phase2.GTC:
            mPhase2Method = phase2Method;
            break;
        default:
            throw new IllegalArgumentException("Unknown Phase 2 method");
    }
}
------------------------
Find a silently evolved API code:android.app.ActivityManager.startLockTaskMode:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    try {
        ActivityManagerNative.getDefault().startLockTaskMode(taskId);
    } catch (RemoteException e) {
    }
}
Body of Second Method:
{
    try {
        ActivityManagerNative.getDefault().startLockTaskMode(taskId);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.graphics.Outline.setConvexPath:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the Constructs an Outline from a
 * {@link android.graphics.Path#isConvex() convex path}.
 */

Body of Frist Method:
{
    if (convexPath.isEmpty()) {
        setEmpty();
        return;
    }
    if (!convexPath.isConvex()) {
        throw new IllegalArgumentException("path must be convex");
    }
    if (mPath == null)
        mPath = new Path();
    mPath.set(convexPath);
    mRect = null;
    mRadius = -1.0f;
}
Body of Second Method:
{
    if (convexPath.isEmpty()) {
        setEmpty();
        return;
    }
    if (!convexPath.isConvex()) {
        throw new IllegalArgumentException("path must be convex");
    }
    mMode = MODE_CONVEX_PATH;
    mPath.set(convexPath);
    mRect.setEmpty();
    mRadius = RADIUS_UNDEFINED;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothGatt.writeDescriptor:COMMENT
Method Modifier: public      
Comment:/**
 * Write the value of a given descriptor to the associated remote device.
 *
 * <p>A {@link BluetoothGattCallback#onDescriptorWrite} callback is
 * triggered to report the result of the write operation.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param descriptor Descriptor to write to the associated remote device
 * @return true, if the write operation was initiated successfully
 */

Body of Frist Method:
{
    if (VDBG)
        Log.d(TAG, "writeDescriptor() - uuid: " + descriptor.getUuid());
    if (mService == null || mClientIf == 0 || descriptor.getValue() == null)
        return false;
    BluetoothGattCharacteristic characteristic = descriptor.getCharacteristic();
    if (characteristic == null)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusy) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.writeDescriptor(mClientIf, device.getAddress(), service.getType(), service.getInstanceId(), new ParcelUuid(service.getUuid()), characteristic.getInstanceId(), new ParcelUuid(characteristic.getUuid()), descriptor.getInstanceId(), new ParcelUuid(descriptor.getUuid()), characteristic.getWriteType(), AUTHENTICATION_NONE, descriptor.getValue());
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}
Body of Second Method:
{
    if (VDBG)
        Log.d(TAG, "writeDescriptor() - uuid: " + descriptor.getUuid());
    if (mService == null || mClientIf == 0 || descriptor.getValue() == null)
        return false;
    BluetoothGattCharacteristic characteristic = descriptor.getCharacteristic();
    if (characteristic == null)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusy) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.writeDescriptor(mClientIf, device.getAddress(), descriptor.getInstanceId(), BluetoothGattCharacteristic.WRITE_TYPE_DEFAULT, AUTHENTICATION_NONE, descriptor.getValue());
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}
------------------------
Find a silently evolved API code:android.media.RemoteController.sendMediaKeyEvent:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * Send a simulated key event for a media button to be received by the current client.
 * To simulate a key press, you must first send a KeyEvent built with
 * a {@link KeyEvent#ACTION_DOWN} action, then another event with the {@link KeyEvent#ACTION_UP}
 * action.
 * <p>The key event will be sent to the registered receiver
 * (see {@link AudioManager#registerMediaButtonEventReceiver(PendingIntent)}) whose associated
 * {@link RemoteControlClient}'s metadata and playback state is published (there may be
 * none under some circumstances).
 * @param keyEvent a {@link KeyEvent} instance whose key code is one of
 * {@link KeyEvent#KEYCODE_MUTE},
 * {@link KeyEvent#KEYCODE_HEADSETHOOK},
 * {@link KeyEvent#KEYCODE_MEDIA_PLAY},
 * {@link KeyEvent#KEYCODE_MEDIA_PAUSE},
 * {@link KeyEvent#KEYCODE_MEDIA_PLAY_PAUSE},
 * {@link KeyEvent#KEYCODE_MEDIA_STOP},
 * {@link KeyEvent#KEYCODE_MEDIA_NEXT},
 * {@link KeyEvent#KEYCODE_MEDIA_PREVIOUS},
 * {@link KeyEvent#KEYCODE_MEDIA_REWIND},
 * {@link KeyEvent#KEYCODE_MEDIA_RECORD},
 * {@link KeyEvent#KEYCODE_MEDIA_FAST_FORWARD},
 * {@link KeyEvent#KEYCODE_MEDIA_CLOSE},
 * {@link KeyEvent#KEYCODE_MEDIA_EJECT},
 * or {@link KeyEvent#KEYCODE_MEDIA_AUDIO_TRACK}.
 * @return true if the event was successfully sent, false otherwise.
 * @throws IllegalArgumentException
 */

Body of Frist Method:
{
    if (!KeyEvent.isMediaKey(keyEvent.getKeyCode())) {
        throw new IllegalArgumentException("not a media key event");
    }
    if (USE_SESSIONS) {
        synchronized (mInfoLock) {
            if (mCurrentSession != null) {
                return mCurrentSession.dispatchMediaButtonEvent(keyEvent);
            }
            return false;
        }
    } else {
        final PendingIntent pi;
        synchronized (mInfoLock) {
            if (!mIsRegistered) {
                Log.e(TAG, "Cannot use sendMediaKeyEvent() from an unregistered RemoteController");
                return false;
            }
            if (!mEnabled) {
                Log.e(TAG, "Cannot use sendMediaKeyEvent() from a disabled RemoteController");
                return false;
            }
            pi = mClientPendingIntentCurrent;
        }
        if (pi != null) {
            Intent intent = new Intent(Intent.ACTION_MEDIA_BUTTON);
            intent.putExtra(Intent.EXTRA_KEY_EVENT, keyEvent);
            try {
                pi.send(mContext, 0, intent);
            } catch (CanceledException e) {
                Log.e(TAG, "Error sending intent for media button down: ", e);
                return false;
            }
        } else {
            Log.i(TAG, "No-op when sending key click, no receiver right now");
            return false;
        }
    }
    return true;
}
Body of Second Method:
{
    if (!KeyEvent.isMediaKey(keyEvent.getKeyCode())) {
        throw new IllegalArgumentException("not a media key event");
    }
    synchronized (mInfoLock) {
        if (mCurrentSession != null) {
            return mCurrentSession.dispatchMediaButtonEvent(keyEvent);
        }
        return false;
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiScanner.getScanResults:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * reports currently available scan results on appropriate listeners
 * @return true if all scan results were reported correctly
 */

Body of Frist Method:
{
    validateChannel();
    Message reply = sAsyncChannel.sendMessageSynchronously(CMD_GET_SCAN_RESULTS, 0);
    return reply.what == CMD_OP_SUCCEEDED;
}
Body of Second Method:
{
    validateChannel();
    Message reply = mAsyncChannel.sendMessageSynchronously(CMD_GET_SCAN_RESULTS, 0);
    return reply.what == CMD_OP_SUCCEEDED;
}
------------------------
Find a silently evolved API code:android.telephony.TelephonyManager.getVoiceMailAlphaTag:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieves the alphabetic identifier associated with the voice
 * mail number.
 * <p>
 * Requires Permission:
 * {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}
 */

Body of Frist Method:
{
    return getVoiceMailAlphaTag(getDefaultSubscription());
}
Body of Second Method:
{
    return getVoiceMailAlphaTag(getSubId());
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiActivityEnergyInfo.isValid:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @return if the record is valid
 */

Body of Frist Method:
{
    return ((mControllerTxTimeMs != 0) || (mControllerRxTimeMs != 0) || (mControllerIdleTimeMs != 0));
}
Body of Second Method:
{
    return ((mControllerTxTimeMs >= 0) && (mControllerRxTimeMs >= 0) && (mControllerIdleTimeMs >= 0));
}
------------------------
Find a silently evolved API code:android.mtp.MtpObjectInfo.getImagePixDepth:COMMENT
Method Modifier: public      final       
Comment:/**
 * Returns the depth of the MTP object in bits per pixel
 * Will be zero for non-image objects
 *
 * @return the image depth
 */

Body of Frist Method:
{
    return mImagePixDepth;
}
Body of Second Method:
{
    Preconditions.checkState(mImagePixDepth >= 0);
    return mImagePixDepth;
}
------------------------
Find a silently evolved API code:android.accounts.AccountManager.updateCredentials:COMMENT
Method Modifier: public      
Comment:/**
 * Asks the user to enter a new password for an account, updating the
 * saved credentials for the account.  Normally this happens automatically
 * when the server rejects credentials during an auth token fetch, but this
 * can be invoked directly to ensure we have the correct credentials stored.
 *
 * <p>This method may be called from any thread, but the returned
 * {@link AccountManagerFuture} must not be used on the main thread.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * MANAGE_ACCOUNTS permission is needed for those platforms. See docs for
 * this function in API level 22.
 *
 * @param account The account to update credentials for
 * @param authTokenType The credentials entered must allow an auth token
 * of this type to be created (but no actual auth token is returned);
 * may be null
 * @param options Authenticator-specific options for the request;
 * may be null or empty
 * @param activity The {@link Activity} context to use for launching a new
 * authenticator-defined sub-Activity to prompt the user to enter a
 * password; used only to call startActivity(); if null, the prompt
 * will not be launched directly, but the necessary {@link Intent}
 * will be returned to the caller instead
 * @param callback Callback to invoke when the request completes,
 * null for no callback
 * @param handler {@link Handler} identifying the callback thread,
 * null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to a Bundle
 * with these fields if an activity was supplied and the account
 * credentials were successfully updated:
 * <ul>
 * <li> {@link #KEY_ACCOUNT_NAME} - the name of the account
 * <li> {@link #KEY_ACCOUNT_TYPE} - the type of the account
 * </ul>
 *
 * If no activity was specified, the returned Bundle contains
 * {@link #KEY_INTENT} with the {@link Intent} needed to launch the
 * password prompt. If an error occurred,
 * {@link AccountManagerFuture#getResult()} throws:
 * <ul>
 * <li> {@link AuthenticatorException} if the authenticator failed to respond
 * <li> {@link OperationCanceledException} if the operation was canceled for
 * any reason, including the user canceling the password prompt
 * <li> {@link IOException} if the authenticator experienced an I/O problem
 * verifying the password, usually because of network trouble
 * </ul>
 */

Body of Frist Method:
{
    if (account == null)
        throw new IllegalArgumentException("account is null");
    return new AmsTask(activity, handler, callback) {

        public void doWork() throws RemoteException {
            mService.updateCredentials(mResponse, account, authTokenType, activity != null, options);
        }
    }.start();
}
Body of Second Method:
{
    if (account == null)
        throw new IllegalArgumentException("account is null");
    return new AmsTask(activity, handler, callback) {

        @Override
        public void doWork() throws RemoteException {
            mService.updateCredentials(mResponse, account, authTokenType, activity != null, options);
        }
    }.start();
}
------------------------
Find a silently evolved API code:android.widget.ListPopupWindow.createDragToOpenListener:COMMENT
Method Modifier: public      
Comment:/**
 * Returns an {@link OnTouchListener} that can be added to the source view
 * to implement drag-to-open behavior. Generally, the source view should be
 * the same view that was passed to {@link #setAnchorView}.
 * <p>
 * When the listener is set on a view, touching that view and dragging
 * outside of its bounds will open the popup window. Lifting will select the
 * currently touched list item.
 * <p>
 * Example usage:
 * <pre>
 * ListPopupWindow myPopup = new ListPopupWindow(context);
 * myPopup.setAnchor(myAnchor);
 * OnTouchListener dragListener = myPopup.createDragToOpenListener(myAnchor);
 * myAnchor.setOnTouchListener(dragListener);
 * </pre>
 *
 * @param src the view on which the resulting listener will be set
 * @return a touch listener that controls drag-to-open behavior
 */

Body of Frist Method:
{
    return new ForwardingListener(src) {

        @Override
        public ListPopupWindow getPopup() {
            return ListPopupWindow.this;
        }
    };
}
Body of Second Method:
{
    return new ForwardingListener(src) {

        @Override
        public ShowableListMenu getPopup() {
            return ListPopupWindow.this;
        }
    };
}
------------------------
Find a silently evolved API code:android.net.ConnectivityManager.unregisterNetworkFactory:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * {@hide}
 */

Body of Frist Method:
{
    try {
        mService.unregisterNetworkFactory(messenger);
    } catch (RemoteException e) {
    }
}
Body of Second Method:
{
    try {
        mService.unregisterNetworkFactory(messenger);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.text.BoringLayout.init:COMMENT
Method Modifier: default     
Comment:/* package */

Body of Frist Method:
{
    int spacing;
    if (source instanceof String && align == Layout.Alignment.ALIGN_NORMAL) {
        mDirect = source.toString();
    } else {
        mDirect = null;
    }
    mPaint = paint;
    if (includepad) {
        spacing = metrics.bottom - metrics.top;
    } else {
        spacing = metrics.descent - metrics.ascent;
    }
    mBottom = spacing;
    if (includepad) {
        mDesc = spacing + metrics.top;
    } else {
        mDesc = spacing + metrics.ascent;
    }
    if (trustWidth) {
        mMax = metrics.width;
    } else {
        /*
             * If we have ellipsized, we have to actually calculate the
             * width because the width that was passed in was for the
             * full text, not the ellipsized form.
             */
        TextLine line = TextLine.obtain();
        line.set(paint, source, 0, source.length(), Layout.DIR_LEFT_TO_RIGHT, Layout.DIRS_ALL_LEFT_TO_RIGHT, false, null);
        mMax = (int) Math.ceil(line.metrics(null));
        TextLine.recycle(line);
    }
    if (includepad) {
        mTopPadding = metrics.top - metrics.ascent;
        mBottomPadding = metrics.bottom - metrics.descent;
    }
}
Body of Second Method:
{
    int spacing;
    if (source instanceof String && align == Layout.Alignment.ALIGN_NORMAL) {
        mDirect = source.toString();
    } else {
        mDirect = null;
    }
    mPaint = paint;
    if (includepad) {
        spacing = metrics.bottom - metrics.top;
        mDesc = metrics.bottom;
    } else {
        spacing = metrics.descent - metrics.ascent;
        mDesc = metrics.descent;
    }
    mBottom = spacing;
    if (trustWidth) {
        mMax = metrics.width;
    } else {
        /*
             * If we have ellipsized, we have to actually calculate the
             * width because the width that was passed in was for the
             * full text, not the ellipsized form.
             */
        TextLine line = TextLine.obtain();
        line.set(paint, source, 0, source.length(), Layout.DIR_LEFT_TO_RIGHT, Layout.DIRS_ALL_LEFT_TO_RIGHT, false, null);
        mMax = (int) Math.ceil(line.metrics(null));
        TextLine.recycle(line);
    }
    if (includepad) {
        mTopPadding = metrics.top - metrics.ascent;
        mBottomPadding = metrics.bottom - metrics.descent;
    }
}
------------------------
Find a silently evolved API code:android.media.ImageUtils.getEstimatedNativeAllocBytes:COMMENT
Method Modifier: public      static      
Comment:/**
 * Return the estimated native allocation size in bytes based on width, height, format,
 * and number of images.
 *
 * <p>This is a very rough estimation and should only be used for native allocation
 * registration in VM so it can be accounted for during GC.</p>
 *
 * @param width The width of the images.
 * @param height The height of the images.
 * @param format The format of the images.
 * @param numImages The number of the images.
 */

Body of Frist Method:
{
    double estimatedBytePerPixel;
    switch(format) {
        // 10x compression from RGB_888
        case ImageFormat.JPEG:
        case ImageFormat.DEPTH_POINT_CLOUD:
            estimatedBytePerPixel = 0.3;
            break;
        case ImageFormat.Y8:
            estimatedBytePerPixel = 1.0;
            break;
        case ImageFormat.RAW10:
            estimatedBytePerPixel = 1.25;
            break;
        case ImageFormat.YV12:
        case ImageFormat.YUV_420_888:
        case ImageFormat.NV21:
        case // A really rough estimate because the real size is unknown.
        ImageFormat.PRIVATE:
            estimatedBytePerPixel = 1.5;
            break;
        case ImageFormat.NV16:
        case PixelFormat.RGB_565:
        case ImageFormat.YUY2:
        case ImageFormat.Y16:
        case ImageFormat.RAW_SENSOR:
        case ImageFormat.DEPTH16:
            estimatedBytePerPixel = 2.0;
            break;
        case PixelFormat.RGB_888:
            estimatedBytePerPixel = 3.0;
            break;
        case PixelFormat.RGBA_8888:
        case PixelFormat.RGBX_8888:
            estimatedBytePerPixel = 4.0;
            break;
        default:
            throw new UnsupportedOperationException(String.format("Invalid format specified %d", format));
    }
    return (int) (width * height * estimatedBytePerPixel * numImages);
}
Body of Second Method:
{
    double estimatedBytePerPixel;
    switch(format) {
        // 10x compression from RGB_888
        case ImageFormat.JPEG:
        case ImageFormat.DEPTH_POINT_CLOUD:
            estimatedBytePerPixel = 0.3;
            break;
        case ImageFormat.Y8:
            estimatedBytePerPixel = 1.0;
            break;
        case ImageFormat.RAW10:
            estimatedBytePerPixel = 1.25;
            break;
        case ImageFormat.YV12:
        case ImageFormat.YUV_420_888:
        case ImageFormat.NV21:
        case ImageFormat.RAW12:
        case // A rough estimate because the real size is unknown.
        ImageFormat.PRIVATE:
            estimatedBytePerPixel = 1.5;
            break;
        case ImageFormat.NV16:
        case PixelFormat.RGB_565:
        case ImageFormat.YUY2:
        case ImageFormat.Y16:
        case ImageFormat.RAW_SENSOR:
        // round estimate, real size is unknown
        case ImageFormat.RAW_PRIVATE:
        case ImageFormat.DEPTH16:
            estimatedBytePerPixel = 2.0;
            break;
        case PixelFormat.RGB_888:
            estimatedBytePerPixel = 3.0;
            break;
        case PixelFormat.RGBA_8888:
        case PixelFormat.RGBX_8888:
            estimatedBytePerPixel = 4.0;
            break;
        default:
            throw new UnsupportedOperationException(String.format("Invalid format specified %d", format));
    }
    return (int) (width * height * estimatedBytePerPixel * numImages);
}
------------------------
Find a silently evolved API code:android.app.ActivityManager.getCurrentUser:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Gets the userId of the current foreground user. Requires system permissions.
 * @hide
 */

Body of Frist Method:
{
    UserInfo ui;
    try {
        ui = ActivityManagerNative.getDefault().getCurrentUser();
        return ui != null ? ui.id : 0;
    } catch (RemoteException e) {
        return 0;
    }
}
Body of Second Method:
{
    UserInfo ui;
    try {
        ui = ActivityManagerNative.getDefault().getCurrentUser();
        return ui != null ? ui.id : 0;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.accounts.AccountManager.getPassword:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the saved password associated with the account.
 * This is intended for authenticators and related code; applications
 * should get an auth token instead.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>This method requires the caller to have a signature match with the
 * authenticator that owns the specified account.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * AUTHENTICATE_ACCOUNTS permission is needed for those platforms. See docs for
 * this function in API level 22.
 *
 * @param account The account to query for a password. Must not be {@code null}.
 * @return The account's password, null if none or if the account doesn't exist
 */

Body of Frist Method:
{
    if (account == null)
        throw new IllegalArgumentException("account is null");
    try {
        return mService.getPassword(account);
    } catch (RemoteException e) {
        // won't ever happen
        throw new RuntimeException(e);
    }
}
Body of Second Method:
{
    if (account == null)
        throw new IllegalArgumentException("account is null");
    try {
        return mService.getPassword(account);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.hardware.fingerprint.FingerprintManager.postEnroll:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Finishes enrollment and cancels the current auth token.
 * @hide
 */

Body of Frist Method:
{
    int result = 0;
    if (mService != null)
        try {
            result = mService.postEnroll(mToken);
        } catch (RemoteException e) {
            Log.w(TAG, "Remote exception in post enroll: ", e);
        }
    return result;
}
Body of Second Method:
{
    int result = 0;
    if (mService != null)
        try {
            result = mService.postEnroll(mToken);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    return result;
}
------------------------
Find a silently evolved API code:android.net.nsd.NsdServiceInfo.getTxtRecord:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    int txtRecordSize = getTxtRecordSize();
    if (txtRecordSize == 0) {
        return null;
    }
    byte[] txtRecord = new byte[txtRecordSize];
    int ptr = 0;
    for (Map.Entry<String, byte[]> entry : mTxtRecord.entrySet()) {
        String key = entry.getKey();
        byte[] value = entry.getValue();
        // One byte to record the length of this key/value pair.
        txtRecord[ptr++] = (byte) (key.length() + (value == null ? 0 : value.length) + 1);
        // The key, in US-ASCII.
        // Note: use the StandardCharsets const here because it doesn't raise exceptions and we
        // already know the key is ASCII at this point.
        System.arraycopy(key.getBytes(StandardCharsets.US_ASCII), 0, txtRecord, ptr, key.length());
        ptr += key.length();
        // US-ASCII '=' character.
        txtRecord[ptr++] = (byte) '=';
        // The value, as any raw bytes.
        if (value != null) {
            System.arraycopy(value, 0, txtRecord, ptr, value.length);
            ptr += value.length;
        }
    }
    return txtRecord;
}
Body of Second Method:
{
    int txtRecordSize = getTxtRecordSize();
    if (txtRecordSize == 0) {
        return new byte[] {};
    }
    byte[] txtRecord = new byte[txtRecordSize];
    int ptr = 0;
    for (Map.Entry<String, byte[]> entry : mTxtRecord.entrySet()) {
        String key = entry.getKey();
        byte[] value = entry.getValue();
        // One byte to record the length of this key/value pair.
        txtRecord[ptr++] = (byte) (key.length() + (value == null ? 0 : value.length) + 1);
        // The key, in US-ASCII.
        // Note: use the StandardCharsets const here because it doesn't raise exceptions and we
        // already know the key is ASCII at this point.
        System.arraycopy(key.getBytes(StandardCharsets.US_ASCII), 0, txtRecord, ptr, key.length());
        ptr += key.length();
        // US-ASCII '=' character.
        txtRecord[ptr++] = (byte) '=';
        // The value, as any raw bytes.
        if (value != null) {
            System.arraycopy(value, 0, txtRecord, ptr, value.length);
            ptr += value.length;
        }
    }
    return txtRecord;
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiManager.enableAggressiveHandover:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Set wifi Aggressive Handover. Called from developer settings.
 * @hide
 */

Body of Frist Method:
{
    try {
        mService.enableAggressiveHandover(enabled);
    } catch (RemoteException e) {
    }
}
Body of Second Method:
{
    try {
        mService.enableAggressiveHandover(enabled);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.os.DropBoxManager.addText:COMMENT
Method Modifier: public      
Comment:/**
 * Stores human-readable text.  The data may be discarded eventually (or even
 * immediately) if space is limited, or ignored entirely if the tag has been
 * blocked (see {@link #isTagEnabled}).
 *
 * @param tag describing the type of entry being stored
 * @param data value to store
 */

Body of Frist Method:
{
    try {
        mService.add(new Entry(tag, 0, data));
    } catch (RemoteException e) {
    }
}
Body of Second Method:
{
    try {
        mService.add(new Entry(tag, 0, data));
    } catch (RemoteException e) {
        if (e instanceof TransactionTooLargeException && mContext.getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.N) {
            Log.e(TAG, "App sent too much data, so it was ignored", e);
            return;
        }
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.app.UiModeManager.getCurrentModeType:COMMENT
Method Modifier: public      
Comment:/**
 * Return the current running mode type.  May be one of
 * {@link Configuration#UI_MODE_TYPE_NORMAL Configuration.UI_MODE_TYPE_NORMAL},
 * {@link Configuration#UI_MODE_TYPE_DESK Configuration.UI_MODE_TYPE_DESK},
 * {@link Configuration#UI_MODE_TYPE_CAR Configuration.UI_MODE_TYPE_CAR},
 * {@link Configuration#UI_MODE_TYPE_TELEVISION Configuration.UI_MODE_TYPE_TELEVISION},
 * {@link Configuration#UI_MODE_TYPE_APPLIANCE Configuration.UI_MODE_TYPE_APPLIANCE}, or
 * {@link Configuration#UI_MODE_TYPE_WATCH Configuration.UI_MODE_TYPE_WATCH}.
 */

Body of Frist Method:
{
    if (mService != null) {
        try {
            return mService.getCurrentModeType();
        } catch (RemoteException e) {
            Log.e(TAG, "getCurrentModeType: RemoteException", e);
        }
    }
    return Configuration.UI_MODE_TYPE_NORMAL;
}
Body of Second Method:
{
    if (mService != null) {
        try {
            return mService.getCurrentModeType();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    return Configuration.UI_MODE_TYPE_NORMAL;
}
------------------------
Find a silently evolved API code:android.widget.Editor.selectCurrentWord:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Adjusts selection to the word under last touch offset. Return true if the operation was
 * successfully performed.
 */

Body of Frist Method:
{
    if (!mTextView.canSelectText()) {
        return false;
    }
    if (mTextView.hasPasswordTransformationMethod()) {
        // is however useful to delete or paste to replace the entire content.
        return mTextView.selectAllText();
    }
    int inputType = mTextView.getInputType();
    int klass = inputType & InputType.TYPE_MASK_CLASS;
    int variation = inputType & InputType.TYPE_MASK_VARIATION;
    // Specific text field types: select the entire text for these
    if (klass == InputType.TYPE_CLASS_NUMBER || klass == InputType.TYPE_CLASS_PHONE || klass == InputType.TYPE_CLASS_DATETIME || variation == InputType.TYPE_TEXT_VARIATION_URI || variation == InputType.TYPE_TEXT_VARIATION_EMAIL_ADDRESS || variation == InputType.TYPE_TEXT_VARIATION_WEB_EMAIL_ADDRESS || variation == InputType.TYPE_TEXT_VARIATION_FILTER) {
        return mTextView.selectAllText();
    }
    long lastTouchOffsets = getLastTouchOffsets();
    final int minOffset = TextUtils.unpackRangeStartFromLong(lastTouchOffsets);
    final int maxOffset = TextUtils.unpackRangeEndFromLong(lastTouchOffsets);
    // Safety check in case standard touch event handling has been bypassed
    if (minOffset < 0 || minOffset >= mTextView.getText().length())
        return false;
    if (maxOffset < 0 || maxOffset >= mTextView.getText().length())
        return false;
    int selectionStart, selectionEnd;
    // If a URLSpan (web address, email, phone...) is found at that position, select it.
    URLSpan[] urlSpans = ((Spanned) mTextView.getText()).getSpans(minOffset, maxOffset, URLSpan.class);
    if (urlSpans.length >= 1) {
        URLSpan urlSpan = urlSpans[0];
        selectionStart = ((Spanned) mTextView.getText()).getSpanStart(urlSpan);
        selectionEnd = ((Spanned) mTextView.getText()).getSpanEnd(urlSpan);
    } else {
        // FIXME - We should check if there's a LocaleSpan in the text, this may be
        // something we should try handling or checking for.
        final WordIterator wordIterator = getWordIterator();
        wordIterator.setCharSequence(mTextView.getText(), minOffset, maxOffset);
        selectionStart = wordIterator.getBeginning(minOffset);
        selectionEnd = wordIterator.getEnd(maxOffset);
        if (selectionStart == BreakIterator.DONE || selectionEnd == BreakIterator.DONE || selectionStart == selectionEnd) {
            // Possible when the word iterator does not properly handle the text's language
            long range = getCharClusterRange(minOffset);
            selectionStart = TextUtils.unpackRangeStartFromLong(range);
            selectionEnd = TextUtils.unpackRangeEndFromLong(range);
        }
    }
    Selection.setSelection((Spannable) mTextView.getText(), selectionStart, selectionEnd);
    return selectionEnd > selectionStart;
}
Body of Second Method:
{
    if (!mTextView.canSelectText()) {
        return false;
    }
    if (needsToSelectAllToSelectWordOrParagraph()) {
        return mTextView.selectAllText();
    }
    long lastTouchOffsets = getLastTouchOffsets();
    final int minOffset = TextUtils.unpackRangeStartFromLong(lastTouchOffsets);
    final int maxOffset = TextUtils.unpackRangeEndFromLong(lastTouchOffsets);
    // Safety check in case standard touch event handling has been bypassed
    if (minOffset < 0 || minOffset > mTextView.getText().length())
        return false;
    if (maxOffset < 0 || maxOffset > mTextView.getText().length())
        return false;
    int selectionStart, selectionEnd;
    // If a URLSpan (web address, email, phone...) is found at that position, select it.
    URLSpan[] urlSpans = ((Spanned) mTextView.getText()).getSpans(minOffset, maxOffset, URLSpan.class);
    if (urlSpans.length >= 1) {
        URLSpan urlSpan = urlSpans[0];
        selectionStart = ((Spanned) mTextView.getText()).getSpanStart(urlSpan);
        selectionEnd = ((Spanned) mTextView.getText()).getSpanEnd(urlSpan);
    } else {
        // FIXME - We should check if there's a LocaleSpan in the text, this may be
        // something we should try handling or checking for.
        final WordIterator wordIterator = getWordIterator();
        wordIterator.setCharSequence(mTextView.getText(), minOffset, maxOffset);
        selectionStart = wordIterator.getBeginning(minOffset);
        selectionEnd = wordIterator.getEnd(maxOffset);
        if (selectionStart == BreakIterator.DONE || selectionEnd == BreakIterator.DONE || selectionStart == selectionEnd) {
            // Possible when the word iterator does not properly handle the text's language
            long range = getCharClusterRange(minOffset);
            selectionStart = TextUtils.unpackRangeStartFromLong(range);
            selectionEnd = TextUtils.unpackRangeEndFromLong(range);
        }
    }
    Selection.setSelection((Spannable) mTextView.getText(), selectionStart, selectionEnd);
    return selectionEnd > selectionStart;
}
------------------------
Find a silently evolved API code:android.app.Activity.onResume:COMMENT
Method Modifier: protected   
Comment:/**
 * Called after {@link #onRestoreInstanceState}, {@link #onRestart}, or
 * {@link #onPause}, for your activity to start interacting with the user.
 * This is a good place to begin animations, open exclusive-access devices
 * (such as the camera), etc.
 *
 * <p>Keep in mind that onResume is not the best indicator that your activity
 * is visible to the user; a system window such as the keyguard may be in
 * front.  Use {@link #onWindowFocusChanged} to know for certain that your
 * activity is visible to the user (for example, to resume a game).
 *
 * <p><em>Derived classes must call through to the super class's
 * implementation of this method.  If they do not, an exception will be
 * thrown.</em></p>
 *
 * @see #onRestoreInstanceState
 * @see #onRestart
 * @see #onPostResume
 * @see #onPause
 */

Body of Frist Method:
{
    if (DEBUG_LIFECYCLE)
        Slog.v(TAG, "onResume " + this);
    getApplication().dispatchActivityResumed(this);
    mActivityTransitionState.onResume();
    mCalled = true;
}
Body of Second Method:
{
    if (DEBUG_LIFECYCLE)
        Slog.v(TAG, "onResume " + this);
    getApplication().dispatchActivityResumed(this);
    mActivityTransitionState.onResume(this, isTopOfTask());
    mCalled = true;
}
------------------------
Find a silently evolved API code:android.widget.LinearLayout.measureHorizontal:COMMENT
Method Modifier: default     
Comment:/**
 * Measures the children when the orientation of this LinearLayout is set
 * to {@link #HORIZONTAL}.
 *
 * @param widthMeasureSpec Horizontal space requirements as imposed by the parent.
 * @param heightMeasureSpec Vertical space requirements as imposed by the parent.
 *
 * @see #getOrientation()
 * @see #setOrientation(int)
 * @see #onMeasure(int, int)
 */

Body of Frist Method:
{
    mTotalLength = 0;
    int maxHeight = 0;
    int childState = 0;
    int alternativeMaxHeight = 0;
    int weightedMaxHeight = 0;
    boolean allFillParent = true;
    float totalWeight = 0;
    final int count = getVirtualChildCount();
    final int widthMode = MeasureSpec.getMode(widthMeasureSpec);
    final int heightMode = MeasureSpec.getMode(heightMeasureSpec);
    boolean matchHeight = false;
    boolean skippedMeasure = false;
    if (mMaxAscent == null || mMaxDescent == null) {
        mMaxAscent = new int[VERTICAL_GRAVITY_COUNT];
        mMaxDescent = new int[VERTICAL_GRAVITY_COUNT];
    }
    final int[] maxAscent = mMaxAscent;
    final int[] maxDescent = mMaxDescent;
    maxAscent[0] = maxAscent[1] = maxAscent[2] = maxAscent[3] = -1;
    maxDescent[0] = maxDescent[1] = maxDescent[2] = maxDescent[3] = -1;
    final boolean baselineAligned = mBaselineAligned;
    final boolean useLargestChild = mUseLargestChild;
    final boolean isExactly = widthMode == MeasureSpec.EXACTLY;
    int largestChildWidth = Integer.MIN_VALUE;
    // See how wide everyone is. Also remember max height.
    for (int i = 0; i < count; ++i) {
        final View child = getVirtualChildAt(i);
        if (child == null) {
            mTotalLength += measureNullChild(i);
            continue;
        }
        if (child.getVisibility() == GONE) {
            i += getChildrenSkipCount(child, i);
            continue;
        }
        if (hasDividerBeforeChildAt(i)) {
            mTotalLength += mDividerWidth;
        }
        final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
        totalWeight += lp.weight;
        if (widthMode == MeasureSpec.EXACTLY && lp.width == 0 && lp.weight > 0) {
            // there is any leftover space.
            if (isExactly) {
                mTotalLength += lp.leftMargin + lp.rightMargin;
            } else {
                final int totalLength = mTotalLength;
                mTotalLength = Math.max(totalLength, totalLength + lp.leftMargin + lp.rightMargin);
            }
            // later (and re-measure).
            if (baselineAligned) {
                final int freeWidthSpec = MeasureSpec.makeSafeMeasureSpec(MeasureSpec.getSize(widthMeasureSpec), MeasureSpec.UNSPECIFIED);
                final int freeHeightSpec = MeasureSpec.makeSafeMeasureSpec(MeasureSpec.getSize(heightMeasureSpec), MeasureSpec.UNSPECIFIED);
                child.measure(freeWidthSpec, freeHeightSpec);
            } else {
                skippedMeasure = true;
            }
        } else {
            int oldWidth = Integer.MIN_VALUE;
            if (lp.width == 0 && lp.weight > 0) {
                // widthMode is either UNSPECIFIED or AT_MOST, and this
                // child
                // wanted to stretch to fill available space. Translate that to
                // WRAP_CONTENT so that it does not end up with a width of 0
                oldWidth = 0;
                lp.width = LayoutParams.WRAP_CONTENT;
            }
            // Determine how big this child would like to be. If this or
            // previous children have given a weight, then we allow it to
            // use all available space (and we will shrink things later
            // if needed).
            measureChildBeforeLayout(child, i, widthMeasureSpec, totalWeight == 0 ? mTotalLength : 0, heightMeasureSpec, 0);
            if (oldWidth != Integer.MIN_VALUE) {
                lp.width = oldWidth;
            }
            final int childWidth = child.getMeasuredWidth();
            if (isExactly) {
                mTotalLength += childWidth + lp.leftMargin + lp.rightMargin + getNextLocationOffset(child);
            } else {
                final int totalLength = mTotalLength;
                mTotalLength = Math.max(totalLength, totalLength + childWidth + lp.leftMargin + lp.rightMargin + getNextLocationOffset(child));
            }
            if (useLargestChild) {
                largestChildWidth = Math.max(childWidth, largestChildWidth);
            }
        }
        boolean matchHeightLocally = false;
        if (heightMode != MeasureSpec.EXACTLY && lp.height == LayoutParams.MATCH_PARENT) {
            // The height of the linear layout will scale, and at least one
            // child said it wanted to match our height. Set a flag indicating that
            // we need to remeasure at least that view when we know our height.
            matchHeight = true;
            matchHeightLocally = true;
        }
        final int margin = lp.topMargin + lp.bottomMargin;
        final int childHeight = child.getMeasuredHeight() + margin;
        childState = combineMeasuredStates(childState, child.getMeasuredState());
        if (baselineAligned) {
            final int childBaseline = child.getBaseline();
            if (childBaseline != -1) {
                // Translates the child's vertical gravity into an index
                // in the range 0..VERTICAL_GRAVITY_COUNT
                final int gravity = (lp.gravity < 0 ? mGravity : lp.gravity) & Gravity.VERTICAL_GRAVITY_MASK;
                final int index = ((gravity >> Gravity.AXIS_Y_SHIFT) & ~Gravity.AXIS_SPECIFIED) >> 1;
                maxAscent[index] = Math.max(maxAscent[index], childBaseline);
                maxDescent[index] = Math.max(maxDescent[index], childHeight - childBaseline);
            }
        }
        maxHeight = Math.max(maxHeight, childHeight);
        allFillParent = allFillParent && lp.height == LayoutParams.MATCH_PARENT;
        if (lp.weight > 0) {
            /*
                 * Heights of weighted Views are bogus if we end up
                 * remeasuring, so keep them separate.
                 */
            weightedMaxHeight = Math.max(weightedMaxHeight, matchHeightLocally ? margin : childHeight);
        } else {
            alternativeMaxHeight = Math.max(alternativeMaxHeight, matchHeightLocally ? margin : childHeight);
        }
        i += getChildrenSkipCount(child, i);
    }
    if (mTotalLength > 0 && hasDividerBeforeChildAt(count)) {
        mTotalLength += mDividerWidth;
    }
    // the most common case
    if (maxAscent[INDEX_TOP] != -1 || maxAscent[INDEX_CENTER_VERTICAL] != -1 || maxAscent[INDEX_BOTTOM] != -1 || maxAscent[INDEX_FILL] != -1) {
        final int ascent = Math.max(maxAscent[INDEX_FILL], Math.max(maxAscent[INDEX_CENTER_VERTICAL], Math.max(maxAscent[INDEX_TOP], maxAscent[INDEX_BOTTOM])));
        final int descent = Math.max(maxDescent[INDEX_FILL], Math.max(maxDescent[INDEX_CENTER_VERTICAL], Math.max(maxDescent[INDEX_TOP], maxDescent[INDEX_BOTTOM])));
        maxHeight = Math.max(maxHeight, ascent + descent);
    }
    if (useLargestChild && (widthMode == MeasureSpec.AT_MOST || widthMode == MeasureSpec.UNSPECIFIED)) {
        mTotalLength = 0;
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child == null) {
                mTotalLength += measureNullChild(i);
                continue;
            }
            if (child.getVisibility() == GONE) {
                i += getChildrenSkipCount(child, i);
                continue;
            }
            final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
            if (isExactly) {
                mTotalLength += largestChildWidth + lp.leftMargin + lp.rightMargin + getNextLocationOffset(child);
            } else {
                final int totalLength = mTotalLength;
                mTotalLength = Math.max(totalLength, totalLength + largestChildWidth + lp.leftMargin + lp.rightMargin + getNextLocationOffset(child));
            }
        }
    }
    // Add in our padding
    mTotalLength += mPaddingLeft + mPaddingRight;
    int widthSize = mTotalLength;
    // Check against our minimum width
    widthSize = Math.max(widthSize, getSuggestedMinimumWidth());
    // Reconcile our calculated size with the widthMeasureSpec
    int widthSizeAndState = resolveSizeAndState(widthSize, widthMeasureSpec, 0);
    widthSize = widthSizeAndState & MEASURED_SIZE_MASK;
    // Either expand children with weight to take up available space or
    // shrink them if they extend beyond our current bounds. If we skipped
    // measurement on any children, we need to measure them now.
    int delta = widthSize - mTotalLength;
    if (skippedMeasure || delta != 0 && totalWeight > 0.0f) {
        float weightSum = mWeightSum > 0.0f ? mWeightSum : totalWeight;
        maxAscent[0] = maxAscent[1] = maxAscent[2] = maxAscent[3] = -1;
        maxDescent[0] = maxDescent[1] = maxDescent[2] = maxDescent[3] = -1;
        maxHeight = -1;
        mTotalLength = 0;
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child == null || child.getVisibility() == View.GONE) {
                continue;
            }
            final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
            float childExtra = lp.weight;
            if (childExtra > 0) {
                // Child said it could absorb extra space -- give him his share
                int share = (int) (childExtra * delta / weightSum);
                weightSum -= childExtra;
                delta -= share;
                final int childHeightMeasureSpec = getChildMeasureSpec(heightMeasureSpec, mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin, lp.height);
                // child has been previously measured
                if ((lp.width != 0) || (widthMode != MeasureSpec.EXACTLY)) {
                    // child was measured once already above ... base new measurement
                    // on stored values
                    int childWidth = child.getMeasuredWidth() + share;
                    if (childWidth < 0) {
                        childWidth = 0;
                    }
                    child.measure(MeasureSpec.makeMeasureSpec(childWidth, MeasureSpec.EXACTLY), childHeightMeasureSpec);
                } else {
                    // child was skipped in the loop above. Measure for this first time here
                    child.measure(MeasureSpec.makeMeasureSpec(share > 0 ? share : 0, MeasureSpec.EXACTLY), childHeightMeasureSpec);
                }
                // Child may now not fit in horizontal dimension.
                childState = combineMeasuredStates(childState, child.getMeasuredState() & MEASURED_STATE_MASK);
            }
            if (isExactly) {
                mTotalLength += child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin + getNextLocationOffset(child);
            } else {
                final int totalLength = mTotalLength;
                mTotalLength = Math.max(totalLength, totalLength + child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin + getNextLocationOffset(child));
            }
            boolean matchHeightLocally = heightMode != MeasureSpec.EXACTLY && lp.height == LayoutParams.MATCH_PARENT;
            final int margin = lp.topMargin + lp.bottomMargin;
            int childHeight = child.getMeasuredHeight() + margin;
            maxHeight = Math.max(maxHeight, childHeight);
            alternativeMaxHeight = Math.max(alternativeMaxHeight, matchHeightLocally ? margin : childHeight);
            allFillParent = allFillParent && lp.height == LayoutParams.MATCH_PARENT;
            if (baselineAligned) {
                final int childBaseline = child.getBaseline();
                if (childBaseline != -1) {
                    // Translates the child's vertical gravity into an index in the range 0..2
                    final int gravity = (lp.gravity < 0 ? mGravity : lp.gravity) & Gravity.VERTICAL_GRAVITY_MASK;
                    final int index = ((gravity >> Gravity.AXIS_Y_SHIFT) & ~Gravity.AXIS_SPECIFIED) >> 1;
                    maxAscent[index] = Math.max(maxAscent[index], childBaseline);
                    maxDescent[index] = Math.max(maxDescent[index], childHeight - childBaseline);
                }
            }
        }
        // Add in our padding
        mTotalLength += mPaddingLeft + mPaddingRight;
        // the most common case
        if (maxAscent[INDEX_TOP] != -1 || maxAscent[INDEX_CENTER_VERTICAL] != -1 || maxAscent[INDEX_BOTTOM] != -1 || maxAscent[INDEX_FILL] != -1) {
            final int ascent = Math.max(maxAscent[INDEX_FILL], Math.max(maxAscent[INDEX_CENTER_VERTICAL], Math.max(maxAscent[INDEX_TOP], maxAscent[INDEX_BOTTOM])));
            final int descent = Math.max(maxDescent[INDEX_FILL], Math.max(maxDescent[INDEX_CENTER_VERTICAL], Math.max(maxDescent[INDEX_TOP], maxDescent[INDEX_BOTTOM])));
            maxHeight = Math.max(maxHeight, ascent + descent);
        }
    } else {
        alternativeMaxHeight = Math.max(alternativeMaxHeight, weightedMaxHeight);
        // Children will have already been measured once.
        if (useLargestChild && widthMode != MeasureSpec.EXACTLY) {
            for (int i = 0; i < count; i++) {
                final View child = getVirtualChildAt(i);
                if (child == null || child.getVisibility() == View.GONE) {
                    continue;
                }
                final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
                float childExtra = lp.weight;
                if (childExtra > 0) {
                    child.measure(MeasureSpec.makeMeasureSpec(largestChildWidth, MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(child.getMeasuredHeight(), MeasureSpec.EXACTLY));
                }
            }
        }
    }
    if (!allFillParent && heightMode != MeasureSpec.EXACTLY) {
        maxHeight = alternativeMaxHeight;
    }
    maxHeight += mPaddingTop + mPaddingBottom;
    // Check against our minimum height
    maxHeight = Math.max(maxHeight, getSuggestedMinimumHeight());
    setMeasuredDimension(widthSizeAndState | (childState & MEASURED_STATE_MASK), resolveSizeAndState(maxHeight, heightMeasureSpec, (childState << MEASURED_HEIGHT_STATE_SHIFT)));
    if (matchHeight) {
        forceUniformHeight(count, widthMeasureSpec);
    }
}
Body of Second Method:
{
    mTotalLength = 0;
    int maxHeight = 0;
    int childState = 0;
    int alternativeMaxHeight = 0;
    int weightedMaxHeight = 0;
    boolean allFillParent = true;
    float totalWeight = 0;
    final int count = getVirtualChildCount();
    final int widthMode = MeasureSpec.getMode(widthMeasureSpec);
    final int heightMode = MeasureSpec.getMode(heightMeasureSpec);
    boolean matchHeight = false;
    boolean skippedMeasure = false;
    if (mMaxAscent == null || mMaxDescent == null) {
        mMaxAscent = new int[VERTICAL_GRAVITY_COUNT];
        mMaxDescent = new int[VERTICAL_GRAVITY_COUNT];
    }
    final int[] maxAscent = mMaxAscent;
    final int[] maxDescent = mMaxDescent;
    maxAscent[0] = maxAscent[1] = maxAscent[2] = maxAscent[3] = -1;
    maxDescent[0] = maxDescent[1] = maxDescent[2] = maxDescent[3] = -1;
    final boolean baselineAligned = mBaselineAligned;
    final boolean useLargestChild = mUseLargestChild;
    final boolean isExactly = widthMode == MeasureSpec.EXACTLY;
    int largestChildWidth = Integer.MIN_VALUE;
    int usedExcessSpace = 0;
    // See how wide everyone is. Also remember max height.
    for (int i = 0; i < count; ++i) {
        final View child = getVirtualChildAt(i);
        if (child == null) {
            mTotalLength += measureNullChild(i);
            continue;
        }
        if (child.getVisibility() == GONE) {
            i += getChildrenSkipCount(child, i);
            continue;
        }
        if (hasDividerBeforeChildAt(i)) {
            mTotalLength += mDividerWidth;
        }
        final LayoutParams lp = (LayoutParams) child.getLayoutParams();
        totalWeight += lp.weight;
        final boolean useExcessSpace = lp.width == 0 && lp.weight > 0;
        if (widthMode == MeasureSpec.EXACTLY && useExcessSpace) {
            // later if we have space to distribute.
            if (isExactly) {
                mTotalLength += lp.leftMargin + lp.rightMargin;
            } else {
                final int totalLength = mTotalLength;
                mTotalLength = Math.max(totalLength, totalLength + lp.leftMargin + lp.rightMargin);
            }
            // later (and re-measure).
            if (baselineAligned) {
                final int freeWidthSpec = MeasureSpec.makeSafeMeasureSpec(MeasureSpec.getSize(widthMeasureSpec), MeasureSpec.UNSPECIFIED);
                final int freeHeightSpec = MeasureSpec.makeSafeMeasureSpec(MeasureSpec.getSize(heightMeasureSpec), MeasureSpec.UNSPECIFIED);
                child.measure(freeWidthSpec, freeHeightSpec);
            } else {
                skippedMeasure = true;
            }
        } else {
            if (useExcessSpace) {
                // The widthMode is either UNSPECIFIED or AT_MOST, and
                // this child is only laid out using excess space. Measure
                // using WRAP_CONTENT so that we can find out the view's
                // optimal width. We'll restore the original width of 0
                // after measurement.
                lp.width = LayoutParams.WRAP_CONTENT;
            }
            // Determine how big this child would like to be. If this or
            // previous children have given a weight, then we allow it to
            // use all available space (and we will shrink things later
            // if needed).
            final int usedWidth = totalWeight == 0 ? mTotalLength : 0;
            measureChildBeforeLayout(child, i, widthMeasureSpec, usedWidth, heightMeasureSpec, 0);
            final int childWidth = child.getMeasuredWidth();
            if (useExcessSpace) {
                // Restore the original width and record how much space
                // we've allocated to excess-only children so that we can
                // match the behavior of EXACTLY measurement.
                lp.width = 0;
                usedExcessSpace += childWidth;
            }
            if (isExactly) {
                mTotalLength += childWidth + lp.leftMargin + lp.rightMargin + getNextLocationOffset(child);
            } else {
                final int totalLength = mTotalLength;
                mTotalLength = Math.max(totalLength, totalLength + childWidth + lp.leftMargin + lp.rightMargin + getNextLocationOffset(child));
            }
            if (useLargestChild) {
                largestChildWidth = Math.max(childWidth, largestChildWidth);
            }
        }
        boolean matchHeightLocally = false;
        if (heightMode != MeasureSpec.EXACTLY && lp.height == LayoutParams.MATCH_PARENT) {
            // The height of the linear layout will scale, and at least one
            // child said it wanted to match our height. Set a flag indicating that
            // we need to remeasure at least that view when we know our height.
            matchHeight = true;
            matchHeightLocally = true;
        }
        final int margin = lp.topMargin + lp.bottomMargin;
        final int childHeight = child.getMeasuredHeight() + margin;
        childState = combineMeasuredStates(childState, child.getMeasuredState());
        if (baselineAligned) {
            final int childBaseline = child.getBaseline();
            if (childBaseline != -1) {
                // Translates the child's vertical gravity into an index
                // in the range 0..VERTICAL_GRAVITY_COUNT
                final int gravity = (lp.gravity < 0 ? mGravity : lp.gravity) & Gravity.VERTICAL_GRAVITY_MASK;
                final int index = ((gravity >> Gravity.AXIS_Y_SHIFT) & ~Gravity.AXIS_SPECIFIED) >> 1;
                maxAscent[index] = Math.max(maxAscent[index], childBaseline);
                maxDescent[index] = Math.max(maxDescent[index], childHeight - childBaseline);
            }
        }
        maxHeight = Math.max(maxHeight, childHeight);
        allFillParent = allFillParent && lp.height == LayoutParams.MATCH_PARENT;
        if (lp.weight > 0) {
            /*
                 * Heights of weighted Views are bogus if we end up
                 * remeasuring, so keep them separate.
                 */
            weightedMaxHeight = Math.max(weightedMaxHeight, matchHeightLocally ? margin : childHeight);
        } else {
            alternativeMaxHeight = Math.max(alternativeMaxHeight, matchHeightLocally ? margin : childHeight);
        }
        i += getChildrenSkipCount(child, i);
    }
    if (mTotalLength > 0 && hasDividerBeforeChildAt(count)) {
        mTotalLength += mDividerWidth;
    }
    // the most common case
    if (maxAscent[INDEX_TOP] != -1 || maxAscent[INDEX_CENTER_VERTICAL] != -1 || maxAscent[INDEX_BOTTOM] != -1 || maxAscent[INDEX_FILL] != -1) {
        final int ascent = Math.max(maxAscent[INDEX_FILL], Math.max(maxAscent[INDEX_CENTER_VERTICAL], Math.max(maxAscent[INDEX_TOP], maxAscent[INDEX_BOTTOM])));
        final int descent = Math.max(maxDescent[INDEX_FILL], Math.max(maxDescent[INDEX_CENTER_VERTICAL], Math.max(maxDescent[INDEX_TOP], maxDescent[INDEX_BOTTOM])));
        maxHeight = Math.max(maxHeight, ascent + descent);
    }
    if (useLargestChild && (widthMode == MeasureSpec.AT_MOST || widthMode == MeasureSpec.UNSPECIFIED)) {
        mTotalLength = 0;
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child == null) {
                mTotalLength += measureNullChild(i);
                continue;
            }
            if (child.getVisibility() == GONE) {
                i += getChildrenSkipCount(child, i);
                continue;
            }
            final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
            if (isExactly) {
                mTotalLength += largestChildWidth + lp.leftMargin + lp.rightMargin + getNextLocationOffset(child);
            } else {
                final int totalLength = mTotalLength;
                mTotalLength = Math.max(totalLength, totalLength + largestChildWidth + lp.leftMargin + lp.rightMargin + getNextLocationOffset(child));
            }
        }
    }
    // Add in our padding
    mTotalLength += mPaddingLeft + mPaddingRight;
    int widthSize = mTotalLength;
    // Check against our minimum width
    widthSize = Math.max(widthSize, getSuggestedMinimumWidth());
    // Reconcile our calculated size with the widthMeasureSpec
    int widthSizeAndState = resolveSizeAndState(widthSize, widthMeasureSpec, 0);
    widthSize = widthSizeAndState & MEASURED_SIZE_MASK;
    // Either expand children with weight to take up available space or
    // shrink them if they extend beyond our current bounds. If we skipped
    // measurement on any children, we need to measure them now.
    int remainingExcess = widthSize - mTotalLength + (mAllowInconsistentMeasurement ? 0 : usedExcessSpace);
    if (skippedMeasure || remainingExcess != 0 && totalWeight > 0.0f) {
        float remainingWeightSum = mWeightSum > 0.0f ? mWeightSum : totalWeight;
        maxAscent[0] = maxAscent[1] = maxAscent[2] = maxAscent[3] = -1;
        maxDescent[0] = maxDescent[1] = maxDescent[2] = maxDescent[3] = -1;
        maxHeight = -1;
        mTotalLength = 0;
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child == null || child.getVisibility() == View.GONE) {
                continue;
            }
            final LayoutParams lp = (LayoutParams) child.getLayoutParams();
            final float childWeight = lp.weight;
            if (childWeight > 0) {
                final int share = (int) (childWeight * remainingExcess / remainingWeightSum);
                remainingExcess -= share;
                remainingWeightSum -= childWeight;
                final int childWidth;
                if (mUseLargestChild && widthMode != MeasureSpec.EXACTLY) {
                    childWidth = largestChildWidth;
                } else if (lp.width == 0 && (!mAllowInconsistentMeasurement || widthMode == MeasureSpec.EXACTLY)) {
                    // This child needs to be laid out from scratch using
                    // only its share of excess space.
                    childWidth = share;
                } else {
                    // This child had some intrinsic width to which we
                    // need to add its share of excess space.
                    childWidth = child.getMeasuredWidth() + share;
                }
                final int childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(Math.max(0, childWidth), MeasureSpec.EXACTLY);
                final int childHeightMeasureSpec = getChildMeasureSpec(heightMeasureSpec, mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin, lp.height);
                child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
                // Child may now not fit in horizontal dimension.
                childState = combineMeasuredStates(childState, child.getMeasuredState() & MEASURED_STATE_MASK);
            }
            if (isExactly) {
                mTotalLength += child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin + getNextLocationOffset(child);
            } else {
                final int totalLength = mTotalLength;
                mTotalLength = Math.max(totalLength, totalLength + child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin + getNextLocationOffset(child));
            }
            boolean matchHeightLocally = heightMode != MeasureSpec.EXACTLY && lp.height == LayoutParams.MATCH_PARENT;
            final int margin = lp.topMargin + lp.bottomMargin;
            int childHeight = child.getMeasuredHeight() + margin;
            maxHeight = Math.max(maxHeight, childHeight);
            alternativeMaxHeight = Math.max(alternativeMaxHeight, matchHeightLocally ? margin : childHeight);
            allFillParent = allFillParent && lp.height == LayoutParams.MATCH_PARENT;
            if (baselineAligned) {
                final int childBaseline = child.getBaseline();
                if (childBaseline != -1) {
                    // Translates the child's vertical gravity into an index in the range 0..2
                    final int gravity = (lp.gravity < 0 ? mGravity : lp.gravity) & Gravity.VERTICAL_GRAVITY_MASK;
                    final int index = ((gravity >> Gravity.AXIS_Y_SHIFT) & ~Gravity.AXIS_SPECIFIED) >> 1;
                    maxAscent[index] = Math.max(maxAscent[index], childBaseline);
                    maxDescent[index] = Math.max(maxDescent[index], childHeight - childBaseline);
                }
            }
        }
        // Add in our padding
        mTotalLength += mPaddingLeft + mPaddingRight;
        // the most common case
        if (maxAscent[INDEX_TOP] != -1 || maxAscent[INDEX_CENTER_VERTICAL] != -1 || maxAscent[INDEX_BOTTOM] != -1 || maxAscent[INDEX_FILL] != -1) {
            final int ascent = Math.max(maxAscent[INDEX_FILL], Math.max(maxAscent[INDEX_CENTER_VERTICAL], Math.max(maxAscent[INDEX_TOP], maxAscent[INDEX_BOTTOM])));
            final int descent = Math.max(maxDescent[INDEX_FILL], Math.max(maxDescent[INDEX_CENTER_VERTICAL], Math.max(maxDescent[INDEX_TOP], maxDescent[INDEX_BOTTOM])));
            maxHeight = Math.max(maxHeight, ascent + descent);
        }
    } else {
        alternativeMaxHeight = Math.max(alternativeMaxHeight, weightedMaxHeight);
        // Children will have already been measured once.
        if (useLargestChild && widthMode != MeasureSpec.EXACTLY) {
            for (int i = 0; i < count; i++) {
                final View child = getVirtualChildAt(i);
                if (child == null || child.getVisibility() == View.GONE) {
                    continue;
                }
                final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
                float childExtra = lp.weight;
                if (childExtra > 0) {
                    child.measure(MeasureSpec.makeMeasureSpec(largestChildWidth, MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(child.getMeasuredHeight(), MeasureSpec.EXACTLY));
                }
            }
        }
    }
    if (!allFillParent && heightMode != MeasureSpec.EXACTLY) {
        maxHeight = alternativeMaxHeight;
    }
    maxHeight += mPaddingTop + mPaddingBottom;
    // Check against our minimum height
    maxHeight = Math.max(maxHeight, getSuggestedMinimumHeight());
    setMeasuredDimension(widthSizeAndState | (childState & MEASURED_STATE_MASK), resolveSizeAndState(maxHeight, heightMeasureSpec, (childState << MEASURED_HEIGHT_STATE_SHIFT)));
    if (matchHeight) {
        forceUniformHeight(count, widthMeasureSpec);
    }
}
------------------------
Find a silently evolved API code:android.nfc.cardemulation.CardEmulation.getInstance:COMMENT
Method Modifier: public      static      
Comment:/**
 * Helper to get an instance of this class.
 *
 * @param adapter A reference to an NfcAdapter object.
 * @return
 */

Body of Frist Method:
{
    if (adapter == null)
        throw new NullPointerException("NfcAdapter is null");
    Context context = adapter.getContext();
    if (context == null) {
        Log.e(TAG, "NfcAdapter context is null.");
        throw new UnsupportedOperationException();
    }
    if (!sIsInitialized) {
        IPackageManager pm = ActivityThread.getPackageManager();
        if (pm == null) {
            Log.e(TAG, "Cannot get PackageManager");
            throw new UnsupportedOperationException();
        }
        try {
            if (!pm.hasSystemFeature(PackageManager.FEATURE_NFC_HOST_CARD_EMULATION)) {
                Log.e(TAG, "This device does not support card emulation");
                throw new UnsupportedOperationException();
            }
        } catch (RemoteException e) {
            Log.e(TAG, "PackageManager query failed.");
            throw new UnsupportedOperationException();
        }
        sIsInitialized = true;
    }
    CardEmulation manager = sCardEmus.get(context);
    if (manager == null) {
        // Get card emu service
        INfcCardEmulation service = adapter.getCardEmulationService();
        if (service == null) {
            Log.e(TAG, "This device does not implement the INfcCardEmulation interface.");
            throw new UnsupportedOperationException();
        }
        manager = new CardEmulation(context, service);
        sCardEmus.put(context, manager);
    }
    return manager;
}
Body of Second Method:
{
    if (adapter == null)
        throw new NullPointerException("NfcAdapter is null");
    Context context = adapter.getContext();
    if (context == null) {
        Log.e(TAG, "NfcAdapter context is null.");
        throw new UnsupportedOperationException();
    }
    if (!sIsInitialized) {
        IPackageManager pm = ActivityThread.getPackageManager();
        if (pm == null) {
            Log.e(TAG, "Cannot get PackageManager");
            throw new UnsupportedOperationException();
        }
        try {
            if (!pm.hasSystemFeature(PackageManager.FEATURE_NFC_HOST_CARD_EMULATION, 0)) {
                Log.e(TAG, "This device does not support card emulation");
                throw new UnsupportedOperationException();
            }
        } catch (RemoteException e) {
            Log.e(TAG, "PackageManager query failed.");
            throw new UnsupportedOperationException();
        }
        sIsInitialized = true;
    }
    CardEmulation manager = sCardEmus.get(context);
    if (manager == null) {
        // Get card emu service
        INfcCardEmulation service = adapter.getCardEmulationService();
        if (service == null) {
            Log.e(TAG, "This device does not implement the INfcCardEmulation interface.");
            throw new UnsupportedOperationException();
        }
        manager = new CardEmulation(context, service);
        sCardEmus.put(context, manager);
    }
    return manager;
}
------------------------
Find a silently evolved API code:android.net.SntpClient.writeTimeStamp:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Writes system time (milliseconds since January 1, 1970) as an NTP time stamp
 * at the given offset in the buffer.
 */

Body of Frist Method:
{
    long seconds = time / 1000L;
    long milliseconds = time - seconds * 1000L;
    seconds += OFFSET_1900_TO_1970;
    // write seconds in big endian format
    buffer[offset++] = (byte) (seconds >> 24);
    buffer[offset++] = (byte) (seconds >> 16);
    buffer[offset++] = (byte) (seconds >> 8);
    buffer[offset++] = (byte) (seconds >> 0);
    long fraction = milliseconds * 0x100000000L / 1000L;
    // write fraction in big endian format
    buffer[offset++] = (byte) (fraction >> 24);
    buffer[offset++] = (byte) (fraction >> 16);
    buffer[offset++] = (byte) (fraction >> 8);
    // low order bits should be random data
    buffer[offset++] = (byte) (Math.random() * 255.0);
}
Body of Second Method:
{
    // Special case: zero means zero.
    if (time == 0) {
        Arrays.fill(buffer, offset, offset + 8, (byte) 0x00);
        return;
    }
    long seconds = time / 1000L;
    long milliseconds = time - seconds * 1000L;
    seconds += OFFSET_1900_TO_1970;
    // write seconds in big endian format
    buffer[offset++] = (byte) (seconds >> 24);
    buffer[offset++] = (byte) (seconds >> 16);
    buffer[offset++] = (byte) (seconds >> 8);
    buffer[offset++] = (byte) (seconds >> 0);
    long fraction = milliseconds * 0x100000000L / 1000L;
    // write fraction in big endian format
    buffer[offset++] = (byte) (fraction >> 24);
    buffer[offset++] = (byte) (fraction >> 16);
    buffer[offset++] = (byte) (fraction >> 8);
    // low order bits should be random data
    buffer[offset++] = (byte) (Math.random() * 255.0);
}
------------------------
Find a silently evolved API code:android.location.Location.setBearing:COMMENT
Method Modifier: public      
Comment:/**
 * Set the bearing, in degrees.
 *
 * <p>Bearing is the horizontal direction of travel of this device,
 * and is not related to the device orientation.
 *
 * <p>The input will be wrapped into the range (0.0, 360.0].
 */

Body of Frist Method:
{
    while (bearing < 0.0f) {
        bearing += 360.0f;
    }
    while (bearing >= 360.0f) {
        bearing -= 360.0f;
    }
    mBearing = bearing;
    mHasBearing = true;
}
Body of Second Method:
{
    while (bearing < 0.0f) {
        bearing += 360.0f;
    }
    while (bearing >= 360.0f) {
        bearing -= 360.0f;
    }
    mBearing = bearing;
    mFieldsMask |= HAS_BEARING_MASK;
}
------------------------
Find a silently evolved API code:android.graphics.drawable.LayerDrawable.updateStateFromTypedArray:COMMENT
Method Modifier: private     
Comment:/**
 * Initializes the constant state from the values in the typed array.
 */

Body of Frist Method:
{
    final LayerState state = mLayerState;
    // Account for any configuration changes.
    state.mChangingConfigurations |= a.getChangingConfigurations();
    // Extract the theme attributes, if any.
    state.mThemeAttrs = a.extractThemeAttrs();
    final int N = a.getIndexCount();
    for (int i = 0; i < N; i++) {
        int attr = a.getIndex(i);
        switch(attr) {
            case R.styleable.LayerDrawable_opacity:
                state.mOpacityOverride = a.getInt(attr, state.mOpacityOverride);
                break;
            case R.styleable.LayerDrawable_paddingTop:
                state.mPaddingTop = a.getDimensionPixelOffset(attr, state.mPaddingTop);
                break;
            case R.styleable.LayerDrawable_paddingBottom:
                state.mPaddingBottom = a.getDimensionPixelOffset(attr, state.mPaddingBottom);
                break;
            case R.styleable.LayerDrawable_paddingLeft:
                state.mPaddingLeft = a.getDimensionPixelOffset(attr, state.mPaddingLeft);
                break;
            case R.styleable.LayerDrawable_paddingRight:
                state.mPaddingRight = a.getDimensionPixelOffset(attr, state.mPaddingRight);
                break;
            case R.styleable.LayerDrawable_paddingStart:
                state.mPaddingStart = a.getDimensionPixelOffset(attr, state.mPaddingStart);
                break;
            case R.styleable.LayerDrawable_paddingEnd:
                state.mPaddingEnd = a.getDimensionPixelOffset(attr, state.mPaddingEnd);
                break;
            case R.styleable.LayerDrawable_autoMirrored:
                state.mAutoMirrored = a.getBoolean(attr, state.mAutoMirrored);
                break;
            case R.styleable.LayerDrawable_paddingMode:
                state.mPaddingMode = a.getInteger(attr, state.mPaddingMode);
                break;
        }
    }
}
Body of Second Method:
{
    final LayerState state = mLayerState;
    // Account for any configuration changes.
    state.mChangingConfigurations |= a.getChangingConfigurations();
    // Extract the theme attributes, if any.
    state.mThemeAttrs = a.extractThemeAttrs();
    final int N = a.getIndexCount();
    for (int i = 0; i < N; i++) {
        final int attr = a.getIndex(i);
        switch(attr) {
            case R.styleable.LayerDrawable_opacity:
                state.mOpacityOverride = a.getInt(attr, state.mOpacityOverride);
                break;
            case R.styleable.LayerDrawable_paddingTop:
                state.mPaddingTop = a.getDimensionPixelOffset(attr, state.mPaddingTop);
                break;
            case R.styleable.LayerDrawable_paddingBottom:
                state.mPaddingBottom = a.getDimensionPixelOffset(attr, state.mPaddingBottom);
                break;
            case R.styleable.LayerDrawable_paddingLeft:
                state.mPaddingLeft = a.getDimensionPixelOffset(attr, state.mPaddingLeft);
                break;
            case R.styleable.LayerDrawable_paddingRight:
                state.mPaddingRight = a.getDimensionPixelOffset(attr, state.mPaddingRight);
                break;
            case R.styleable.LayerDrawable_paddingStart:
                state.mPaddingStart = a.getDimensionPixelOffset(attr, state.mPaddingStart);
                break;
            case R.styleable.LayerDrawable_paddingEnd:
                state.mPaddingEnd = a.getDimensionPixelOffset(attr, state.mPaddingEnd);
                break;
            case R.styleable.LayerDrawable_autoMirrored:
                state.mAutoMirrored = a.getBoolean(attr, state.mAutoMirrored);
                break;
            case R.styleable.LayerDrawable_paddingMode:
                state.mPaddingMode = a.getInteger(attr, state.mPaddingMode);
                break;
        }
    }
}
------------------------
Find a silently evolved API code:android.accounts.AccountManager.clearPassword:COMMENT
Method Modifier: public      
Comment:/**
 * Forgets a saved password.  This erases the local copy of the password;
 * it does not change the user's account password on the server.
 * Has the same effect as setPassword(account, null) but requires fewer
 * permissions, and may be used by applications or management interfaces
 * to "sign out" from an account.
 *
 * <p>This method only successfully clear the account's password when the
 * caller has the same signature as the authenticator that owns the
 * specified account. Otherwise, this method will silently fail.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * MANAGE_ACCOUNTS permission is needed for those platforms. See docs for
 * this function in API level 22.
 *
 * @param account The account whose password to clear
 */

Body of Frist Method:
{
    if (account == null)
        throw new IllegalArgumentException("account is null");
    try {
        mService.clearPassword(account);
    } catch (RemoteException e) {
        // won't ever happen
        throw new RuntimeException(e);
    }
}
Body of Second Method:
{
    if (account == null)
        throw new IllegalArgumentException("account is null");
    try {
        mService.clearPassword(account);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.widget.TextView.onPopulateAccessibilityEventInternal:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    super.onPopulateAccessibilityEventInternal(event);
    final boolean isPassword = hasPasswordTransformationMethod();
    if (!isPassword || shouldSpeakPasswordsForAccessibility()) {
        final CharSequence text = getTextForAccessibility();
        if (!TextUtils.isEmpty(text)) {
            event.getText().add(text);
        }
    }
}
Body of Second Method:
{
    super.onPopulateAccessibilityEventInternal(event);
    final CharSequence text = getTextForAccessibility();
    if (!TextUtils.isEmpty(text)) {
        event.getText().add(text);
    }
}
------------------------
Find a silently evolved API code:android.view.inputmethod.BaseInputConnection.commitText:COMMENT
Method Modifier: public      
Comment:/**
 * Default implementation replaces any existing composing text with
 * the given text.  In addition, only if dummy mode, a key event is
 * sent for the new text and the current editable buffer cleared.
 */

Body of Frist Method:
{
    if (DEBUG)
        Log.v(TAG, "commitText " + text);
    replaceText(text, newCursorPosition, false);
    mIMM.notifyUserAction();
    sendCurrentText();
    return true;
}
Body of Second Method:
{
    if (DEBUG)
        Log.v(TAG, "commitText " + text);
    replaceText(text, newCursorPosition, false);
    sendCurrentText();
    return true;
}
------------------------
Find a silently evolved API code:android.telephony.SignalStrength.getAsuLevel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the signal level as an asu value between 0..31, 99 is unknown
 *
 * @hide
 */

Body of Frist Method:
{
    int asuLevel;
    if (isGsm) {
        if (getLteLevel() == SIGNAL_STRENGTH_NONE_OR_UNKNOWN) {
            asuLevel = getGsmAsuLevel();
        } else {
            asuLevel = getLteAsuLevel();
        }
    } else {
        int cdmaAsuLevel = getCdmaAsuLevel();
        int evdoAsuLevel = getEvdoAsuLevel();
        if (evdoAsuLevel == 0) {
            /* We don't know evdo use, cdma */
            asuLevel = cdmaAsuLevel;
        } else if (cdmaAsuLevel == 0) {
            /* We don't know cdma use, evdo */
            asuLevel = evdoAsuLevel;
        } else {
            /* We know both, use the lowest level */
            asuLevel = cdmaAsuLevel < evdoAsuLevel ? cdmaAsuLevel : evdoAsuLevel;
        }
    }
    if (DBG)
        log("getAsuLevel=" + asuLevel);
    return asuLevel;
}
Body of Second Method:
{
    int asuLevel = 0;
    if (isGsm) {
        if (getLteLevel() == SIGNAL_STRENGTH_NONE_OR_UNKNOWN) {
            if (getTdScdmaLevel() == SIGNAL_STRENGTH_NONE_OR_UNKNOWN) {
                asuLevel = getGsmAsuLevel();
            } else {
                asuLevel = getTdScdmaAsuLevel();
            }
        } else {
            asuLevel = getLteAsuLevel();
        }
    } else {
        int cdmaAsuLevel = getCdmaAsuLevel();
        int evdoAsuLevel = getEvdoAsuLevel();
        if (evdoAsuLevel == 0) {
            /* We don't know evdo use, cdma */
            asuLevel = cdmaAsuLevel;
        } else if (cdmaAsuLevel == 0) {
            /* We don't know cdma use, evdo */
            asuLevel = evdoAsuLevel;
        } else {
            /* We know both, use the lowest level */
            asuLevel = cdmaAsuLevel < evdoAsuLevel ? cdmaAsuLevel : evdoAsuLevel;
        }
    }
    if (DBG)
        log("getAsuLevel=" + asuLevel);
    return asuLevel;
}
------------------------
Find a silently evolved API code:android.app.ActivityManager.getMaxRecentTasksStatic:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Return the maximum number of recents entries that we will maintain and show.
 * @hide
 */

Body of Frist Method:
{
    if (gMaxRecentTasks < 0) {
        return gMaxRecentTasks = isLowRamDeviceStatic() ? 50 : 100;
    }
    return gMaxRecentTasks;
}
Body of Second Method:
{
    if (gMaxRecentTasks < 0) {
        return gMaxRecentTasks = isLowRamDeviceStatic() ? 36 : 48;
    }
    return gMaxRecentTasks;
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiManager.isScanAlwaysAvailable:COMMENT
Method Modifier: public      
Comment:/**
 * Check if scanning is always available.
 *
 * If this return {@code true}, apps can issue {@link #startScan} and fetch scan results
 * even when Wi-Fi is turned off.
 *
 * To change this setting, see {@link #ACTION_REQUEST_SCAN_ALWAYS_AVAILABLE}.
 */

Body of Frist Method:
{
    try {
        return mService.isScanAlwaysAvailable();
    } catch (RemoteException e) {
        return false;
    }
}
Body of Second Method:
{
    try {
        return mService.isScanAlwaysAvailable();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.renderscript.Sampler.MIRRORED_REPEAT_LINEAR_MIP_LINEAR:COMMENT
Method Modifier: public      static      
Comment:/**
 * Retrieve a sampler with min and mag set to linear and wrap modes set to
 * mirrored repeat.
 *
 * @param rs Context to which the sampler will belong.
 *
 * @return Sampler
 */

Body of Frist Method:
{
    if (rs.mSampler_MIRRORED_REPEAT_LINEAR_MIP_LINEAR == null) {
        Builder b = new Builder(rs);
        b.setMinification(Value.LINEAR_MIP_LINEAR);
        b.setMagnification(Value.LINEAR);
        b.setWrapS(Value.MIRRORED_REPEAT);
        b.setWrapT(Value.MIRRORED_REPEAT);
        rs.mSampler_MIRRORED_REPEAT_LINEAR_MIP_LINEAR = b.create();
    }
    return rs.mSampler_MIRRORED_REPEAT_LINEAR_MIP_LINEAR;
}
Body of Second Method:
{
    if (rs.mSampler_MIRRORED_REPEAT_LINEAR_MIP_LINEAR == null) {
        synchronized (rs) {
            if (rs.mSampler_MIRRORED_REPEAT_LINEAR_MIP_LINEAR == null) {
                Builder b = new Builder(rs);
                b.setMinification(Value.LINEAR_MIP_LINEAR);
                b.setMagnification(Value.LINEAR);
                b.setWrapS(Value.MIRRORED_REPEAT);
                b.setWrapT(Value.MIRRORED_REPEAT);
                rs.mSampler_MIRRORED_REPEAT_LINEAR_MIP_LINEAR = b.create();
            }
        }
    }
    return rs.mSampler_MIRRORED_REPEAT_LINEAR_MIP_LINEAR;
}
------------------------
Find a silently evolved API code:android.widget.ProgressBar.setIndeterminateDrawable:COMMENT
Method Modifier: public      
Comment:/**
 * Define the drawable used to draw the progress bar in indeterminate mode.
 *
 * @param d the new drawable
 * @see #getIndeterminateDrawable()
 * @see #setIndeterminate(boolean)
 */

Body of Frist Method:
{
    if (mIndeterminateDrawable != d) {
        if (mIndeterminateDrawable != null) {
            mIndeterminateDrawable.setCallback(null);
            unscheduleDrawable(mIndeterminateDrawable);
        }
        mIndeterminateDrawable = d;
        if (d != null) {
            d.setCallback(this);
            d.setLayoutDirection(getLayoutDirection());
            if (d.isStateful()) {
                d.setState(getDrawableState());
            }
            applyIndeterminateTint();
        }
        if (mIndeterminate) {
            mCurrentDrawable = d;
            postInvalidate();
        }
    }
}
Body of Second Method:
{
    if (mIndeterminateDrawable != d) {
        if (mIndeterminateDrawable != null) {
            mIndeterminateDrawable.setCallback(null);
            unscheduleDrawable(mIndeterminateDrawable);
        }
        mIndeterminateDrawable = d;
        if (d != null) {
            d.setCallback(this);
            d.setLayoutDirection(getLayoutDirection());
            if (d.isStateful()) {
                d.setState(getDrawableState());
            }
            applyIndeterminateTint();
        }
        if (mIndeterminate) {
            swapCurrentDrawable(d);
            postInvalidate();
        }
    }
}
------------------------
Find a silently evolved API code:android.app.ActivityManager.setPackageScreenCompatMode:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    try {
        ActivityManagerNative.getDefault().setPackageScreenCompatMode(packageName, mode);
    } catch (RemoteException e) {
    // System dead, we will be dead too soon!
    }
}
Body of Second Method:
{
    try {
        ActivityManagerNative.getDefault().setPackageScreenCompatMode(packageName, mode);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.telephony.SubscriptionManager.getDefaultSmsPhoneId:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return getPhoneId(getDefaultSmsSubId());
}
Body of Second Method:
{
    return getPhoneId(getDefaultSmsSubscriptionId());
}
------------------------
Find a silently evolved API code:android.app.DownloadManager.markRowDeleted:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Marks the specified download as 'to be deleted'. This is done when a completed download
 * is to be removed but the row was stored without enough info to delete the corresponding
 * metadata from Mediaprovider database. Actual cleanup of this row is done in DownloadService.
 *
 * @param ids the IDs of the downloads to be marked 'deleted'
 * @return the number of downloads actually updated
 * @hide
 */

Body of Frist Method:
{
    if (ids == null || ids.length == 0) {
        // called with nothing to remove!
        throw new IllegalArgumentException("input param 'ids' can't be null");
    }
    ContentValues values = new ContentValues();
    values.put(Downloads.Impl.COLUMN_DELETED, 1);
    // this will eliminate a full database scan in the download service.
    if (ids.length == 1) {
        return mResolver.update(ContentUris.withAppendedId(mBaseUri, ids[0]), values, null, null);
    }
    return mResolver.update(mBaseUri, values, getWhereClauseForIds(ids), getWhereArgsForIds(ids));
}
Body of Second Method:
{
    if (ids == null || ids.length == 0) {
        // called with nothing to remove!
        throw new IllegalArgumentException("input param 'ids' can't be null");
    }
    return mResolver.delete(mBaseUri, getWhereClauseForIds(ids), getWhereArgsForIds(ids));
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiScanner.ScanData.writeToParcel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Implement the Parcelable interface {@hide}
 */

Body of Frist Method:
{
    if (mResults != null) {
        dest.writeInt(mId);
        dest.writeInt(mFlags);
        dest.writeInt(mResults.length);
        for (int i = 0; i < mResults.length; i++) {
            ScanResult result = mResults[i];
            result.writeToParcel(dest, flags);
        }
    } else {
        dest.writeInt(0);
    }
}
Body of Second Method:
{
    if (mResults != null) {
        dest.writeInt(mId);
        dest.writeInt(mFlags);
        dest.writeInt(mBucketsScanned);
        dest.writeInt(mResults.length);
        for (int i = 0; i < mResults.length; i++) {
            ScanResult result = mResults[i];
            result.writeToParcel(dest, flags);
        }
    } else {
        dest.writeInt(0);
    }
}
------------------------
Find a silently evolved API code:android.widget.TextView.setCompoundDrawables:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the Drawables (if any) to appear to the left of, above, to the
 * right of, and below the text. Use {@code null} if you do not want a
 * Drawable there. The Drawables must already have had
 * {@link Drawable#setBounds} called.
 * <p>
 * Calling this method will overwrite any Drawables previously set using
 * {@link #setCompoundDrawablesRelative} or related methods.
 *
 * @attr ref android.R.styleable#TextView_drawableLeft
 * @attr ref android.R.styleable#TextView_drawableTop
 * @attr ref android.R.styleable#TextView_drawableRight
 * @attr ref android.R.styleable#TextView_drawableBottom
 */

Body of Frist Method:
{
    Drawables dr = mDrawables;
    // We're switching to absolute, discard relative.
    if (dr != null) {
        if (dr.mDrawableStart != null)
            dr.mDrawableStart.setCallback(null);
        dr.mDrawableStart = null;
        if (dr.mDrawableEnd != null)
            dr.mDrawableEnd.setCallback(null);
        dr.mDrawableEnd = null;
        dr.mDrawableSizeStart = dr.mDrawableHeightStart = 0;
        dr.mDrawableSizeEnd = dr.mDrawableHeightEnd = 0;
    }
    final boolean drawables = left != null || top != null || right != null || bottom != null;
    if (!drawables) {
        // Clearing drawables...  can we free the data structure?
        if (dr != null) {
            if (dr.mDrawablePadding == 0) {
                mDrawables = null;
            } else {
                // out all of the fields in the existing structure.
                for (int i = dr.mShowing.length - 1; i >= 0; i--) {
                    if (dr.mShowing[i] != null) {
                        dr.mShowing[i].setCallback(null);
                    }
                    dr.mShowing[i] = null;
                }
                dr.mDrawableSizeLeft = dr.mDrawableHeightLeft = 0;
                dr.mDrawableSizeRight = dr.mDrawableHeightRight = 0;
                dr.mDrawableSizeTop = dr.mDrawableWidthTop = 0;
                dr.mDrawableSizeBottom = dr.mDrawableWidthBottom = 0;
            }
        }
    } else {
        if (dr == null) {
            mDrawables = dr = new Drawables(getContext());
        }
        mDrawables.mOverride = false;
        if (dr.mShowing[Drawables.LEFT] != left && dr.mShowing[Drawables.LEFT] != null) {
            dr.mShowing[Drawables.LEFT].setCallback(null);
        }
        dr.mShowing[Drawables.LEFT] = left;
        if (dr.mShowing[Drawables.TOP] != top && dr.mShowing[Drawables.TOP] != null) {
            dr.mShowing[Drawables.TOP].setCallback(null);
        }
        dr.mShowing[Drawables.TOP] = top;
        if (dr.mShowing[Drawables.RIGHT] != right && dr.mShowing[Drawables.RIGHT] != null) {
            dr.mShowing[Drawables.RIGHT].setCallback(null);
        }
        dr.mShowing[Drawables.RIGHT] = right;
        if (dr.mShowing[Drawables.BOTTOM] != bottom && dr.mShowing[Drawables.BOTTOM] != null) {
            dr.mShowing[Drawables.BOTTOM].setCallback(null);
        }
        dr.mShowing[Drawables.BOTTOM] = bottom;
        final Rect compoundRect = dr.mCompoundRect;
        int[] state;
        state = getDrawableState();
        if (left != null) {
            left.setState(state);
            left.copyBounds(compoundRect);
            left.setCallback(this);
            dr.mDrawableSizeLeft = compoundRect.width();
            dr.mDrawableHeightLeft = compoundRect.height();
        } else {
            dr.mDrawableSizeLeft = dr.mDrawableHeightLeft = 0;
        }
        if (right != null) {
            right.setState(state);
            right.copyBounds(compoundRect);
            right.setCallback(this);
            dr.mDrawableSizeRight = compoundRect.width();
            dr.mDrawableHeightRight = compoundRect.height();
        } else {
            dr.mDrawableSizeRight = dr.mDrawableHeightRight = 0;
        }
        if (top != null) {
            top.setState(state);
            top.copyBounds(compoundRect);
            top.setCallback(this);
            dr.mDrawableSizeTop = compoundRect.height();
            dr.mDrawableWidthTop = compoundRect.width();
        } else {
            dr.mDrawableSizeTop = dr.mDrawableWidthTop = 0;
        }
        if (bottom != null) {
            bottom.setState(state);
            bottom.copyBounds(compoundRect);
            bottom.setCallback(this);
            dr.mDrawableSizeBottom = compoundRect.height();
            dr.mDrawableWidthBottom = compoundRect.width();
        } else {
            dr.mDrawableSizeBottom = dr.mDrawableWidthBottom = 0;
        }
    }
    // Save initial left/right drawables
    if (dr != null) {
        dr.mDrawableLeftInitial = left;
        dr.mDrawableRightInitial = right;
    }
    resetResolvedDrawables();
    resolveDrawables();
    applyCompoundDrawableTint();
    invalidate();
    requestLayout();
}
Body of Second Method:
{
    Drawables dr = mDrawables;
    // We're switching to absolute, discard relative.
    if (dr != null) {
        if (dr.mDrawableStart != null)
            dr.mDrawableStart.setCallback(null);
        dr.mDrawableStart = null;
        if (dr.mDrawableEnd != null)
            dr.mDrawableEnd.setCallback(null);
        dr.mDrawableEnd = null;
        dr.mDrawableSizeStart = dr.mDrawableHeightStart = 0;
        dr.mDrawableSizeEnd = dr.mDrawableHeightEnd = 0;
    }
    final boolean drawables = left != null || top != null || right != null || bottom != null;
    if (!drawables) {
        // Clearing drawables...  can we free the data structure?
        if (dr != null) {
            if (!dr.hasMetadata()) {
                mDrawables = null;
            } else {
                // out all of the fields in the existing structure.
                for (int i = dr.mShowing.length - 1; i >= 0; i--) {
                    if (dr.mShowing[i] != null) {
                        dr.mShowing[i].setCallback(null);
                    }
                    dr.mShowing[i] = null;
                }
                dr.mDrawableSizeLeft = dr.mDrawableHeightLeft = 0;
                dr.mDrawableSizeRight = dr.mDrawableHeightRight = 0;
                dr.mDrawableSizeTop = dr.mDrawableWidthTop = 0;
                dr.mDrawableSizeBottom = dr.mDrawableWidthBottom = 0;
            }
        }
    } else {
        if (dr == null) {
            mDrawables = dr = new Drawables(getContext());
        }
        mDrawables.mOverride = false;
        if (dr.mShowing[Drawables.LEFT] != left && dr.mShowing[Drawables.LEFT] != null) {
            dr.mShowing[Drawables.LEFT].setCallback(null);
        }
        dr.mShowing[Drawables.LEFT] = left;
        if (dr.mShowing[Drawables.TOP] != top && dr.mShowing[Drawables.TOP] != null) {
            dr.mShowing[Drawables.TOP].setCallback(null);
        }
        dr.mShowing[Drawables.TOP] = top;
        if (dr.mShowing[Drawables.RIGHT] != right && dr.mShowing[Drawables.RIGHT] != null) {
            dr.mShowing[Drawables.RIGHT].setCallback(null);
        }
        dr.mShowing[Drawables.RIGHT] = right;
        if (dr.mShowing[Drawables.BOTTOM] != bottom && dr.mShowing[Drawables.BOTTOM] != null) {
            dr.mShowing[Drawables.BOTTOM].setCallback(null);
        }
        dr.mShowing[Drawables.BOTTOM] = bottom;
        final Rect compoundRect = dr.mCompoundRect;
        int[] state;
        state = getDrawableState();
        if (left != null) {
            left.setState(state);
            left.copyBounds(compoundRect);
            left.setCallback(this);
            dr.mDrawableSizeLeft = compoundRect.width();
            dr.mDrawableHeightLeft = compoundRect.height();
        } else {
            dr.mDrawableSizeLeft = dr.mDrawableHeightLeft = 0;
        }
        if (right != null) {
            right.setState(state);
            right.copyBounds(compoundRect);
            right.setCallback(this);
            dr.mDrawableSizeRight = compoundRect.width();
            dr.mDrawableHeightRight = compoundRect.height();
        } else {
            dr.mDrawableSizeRight = dr.mDrawableHeightRight = 0;
        }
        if (top != null) {
            top.setState(state);
            top.copyBounds(compoundRect);
            top.setCallback(this);
            dr.mDrawableSizeTop = compoundRect.height();
            dr.mDrawableWidthTop = compoundRect.width();
        } else {
            dr.mDrawableSizeTop = dr.mDrawableWidthTop = 0;
        }
        if (bottom != null) {
            bottom.setState(state);
            bottom.copyBounds(compoundRect);
            bottom.setCallback(this);
            dr.mDrawableSizeBottom = compoundRect.height();
            dr.mDrawableWidthBottom = compoundRect.width();
        } else {
            dr.mDrawableSizeBottom = dr.mDrawableWidthBottom = 0;
        }
    }
    // Save initial left/right drawables
    if (dr != null) {
        dr.mDrawableLeftInitial = left;
        dr.mDrawableRightInitial = right;
    }
    resetResolvedDrawables();
    resolveDrawables();
    applyCompoundDrawableTint();
    invalidate();
    requestLayout();
}
------------------------
Find a silently evolved API code:android.os.Bundle.putSparseParcelableArray:COMMENT
Method Modifier: public      
Comment:/**
 * Inserts a SparceArray of Parcelable values into the mapping of this
 * Bundle, replacing any existing value for the given key.  Either key
 * or value may be null.
 *
 * @param key a String, or null
 * @param value a SparseArray of Parcelable objects, or null
 */

Body of Frist Method:
{
    unparcel();
    mMap.put(key, value);
    mFdsKnown = false;
}
Body of Second Method:
{
    unparcel();
    mMap.put(key, value);
    mFlags &= ~FLAG_HAS_FDS_KNOWN;
}
------------------------
Find a silently evolved API code:android.app.Fragment.initState:COMMENT
Method Modifier: default     
Comment:/**
 * Called by the fragment manager once this fragment has been removed,
 * so that we don't have any left-over state if the application decides
 * to re-use the instance.  This only clears state that the framework
 * internally manages, not things the application sets.
 */

Body of Frist Method:
{
    mIndex = -1;
    mWho = null;
    mAdded = false;
    mRemoving = false;
    mResumed = false;
    mFromLayout = false;
    mInLayout = false;
    mRestored = false;
    mBackStackNesting = 0;
    mFragmentManager = null;
    mChildFragmentManager = null;
    mHost = null;
    mFragmentId = 0;
    mContainerId = 0;
    mTag = null;
    mHidden = false;
    mDetached = false;
    mRetaining = false;
    mLoaderManager = null;
    mLoadersStarted = false;
    mCheckedForLoaderManager = false;
}
Body of Second Method:
{
    mIndex = -1;
    mWho = null;
    mAdded = false;
    mRemoving = false;
    mFromLayout = false;
    mInLayout = false;
    mRestored = false;
    mBackStackNesting = 0;
    mFragmentManager = null;
    mChildFragmentManager = null;
    mHost = null;
    mFragmentId = 0;
    mContainerId = 0;
    mTag = null;
    mHidden = false;
    mDetached = false;
    mRetaining = false;
    mLoaderManager = null;
    mLoadersStarted = false;
    mCheckedForLoaderManager = false;
}
------------------------
Find a silently evolved API code:android.app.SearchManager.getGlobalSearchActivities:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns a list of installed apps that handle the global search
 * intent.
 *
 * @hide
 */

Body of Frist Method:
{
    try {
        return mService.getGlobalSearchActivities();
    } catch (RemoteException ex) {
        Log.e(TAG, "getGlobalSearchActivities() failed: " + ex);
        return null;
    }
}
Body of Second Method:
{
    try {
        return mService.getGlobalSearchActivities();
    } catch (RemoteException ex) {
        throw ex.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.hardware.camera2.params.StreamConfigurationMap.getPublicFormats:COMMENT
Method Modifier: private     
Comment:/**
 * Get the list of publically visible output formats; does not include IMPL_DEFINED
 */

Body of Frist Method:
{
    int[] formats = new int[getPublicFormatCount(output)];
    int i = 0;
    SparseIntArray map = getFormatsMap(output);
    for (int j = 0; j < map.size(); j++) {
        int format = map.keyAt(j);
        if (format != HAL_PIXEL_FORMAT_RAW_OPAQUE) {
            formats[i++] = imageFormatToPublic(format);
        }
    }
    if (output) {
        for (int j = 0; j < mDepthOutputFormats.size(); j++) {
            formats[i++] = depthFormatToPublic(mDepthOutputFormats.keyAt(j));
        }
    }
    if (formats.length != i) {
        throw new AssertionError("Too few formats " + i + ", expected " + formats.length);
    }
    return formats;
}
Body of Second Method:
{
    int[] formats = new int[getPublicFormatCount(output)];
    int i = 0;
    SparseIntArray map = getFormatsMap(output);
    for (int j = 0; j < map.size(); j++) {
        int format = map.keyAt(j);
        formats[i++] = imageFormatToPublic(format);
    }
    if (output) {
        for (int j = 0; j < mDepthOutputFormats.size(); j++) {
            formats[i++] = depthFormatToPublic(mDepthOutputFormats.keyAt(j));
        }
    }
    if (formats.length != i) {
        throw new AssertionError("Too few formats " + i + ", expected " + formats.length);
    }
    return formats;
}
------------------------
Find a silently evolved API code:android.net.ConnectivityManager.getAllNetworkInfo:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * Returns connection status information about all network
 * types supported by the device.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
 *
 * @return an array of {@link NetworkInfo} objects.  Check each
 * {@link NetworkInfo#getType} for which type each applies.
 *
 * @deprecated This method does not support multiple connected networks
 * of the same type. Use {@link #getAllNetworks} and
 * {@link #getNetworkInfo(android.net.Network)} instead.
 */

Body of Frist Method:
{
    try {
        return mService.getAllNetworkInfo();
    } catch (RemoteException e) {
        return null;
    }
}
Body of Second Method:
{
    try {
        return mService.getAllNetworkInfo();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.transition.Fade.createAnimation:COMMENT
Method Modifier: private     
Comment:/**
 * Utility method to handle creating and running the Animator.
 */

Body of Frist Method:
{
    if (startAlpha == endAlpha) {
        return null;
    }
    view.setTransitionAlpha(startAlpha);
    final ObjectAnimator anim = ObjectAnimator.ofFloat(view, "transitionAlpha", endAlpha);
    if (DBG) {
        Log.d(LOG_TAG, "Created animator " + anim);
    }
    final FadeAnimatorListener listener = new FadeAnimatorListener(view);
    anim.addListener(listener);
    anim.addPauseListener(listener);
    addListener(new TransitionListenerAdapter() {

        @Override
        public void onTransitionEnd(Transition transition) {
            view.setTransitionAlpha(1);
        }
    });
    return anim;
}
Body of Second Method:
{
    if (startAlpha == endAlpha) {
        return null;
    }
    view.setTransitionAlpha(startAlpha);
    final ObjectAnimator anim = ObjectAnimator.ofFloat(view, "transitionAlpha", endAlpha);
    if (DBG) {
        Log.d(LOG_TAG, "Created animator " + anim);
    }
    final FadeAnimatorListener listener = new FadeAnimatorListener(view);
    anim.addListener(listener);
    addListener(new TransitionListenerAdapter() {

        @Override
        public void onTransitionEnd(Transition transition) {
            view.setTransitionAlpha(1);
        }
    });
    return anim;
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiManager.getCountryCode:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * get the country code.
 * @return the country code in ISO 3166 format.
 *
 * @hide
 */

Body of Frist Method:
{
    try {
        String country = mService.getCountryCode();
        return (country);
    } catch (RemoteException e) {
        return null;
    }
}
Body of Second Method:
{
    try {
        String country = mService.getCountryCode();
        return country;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.widget.LinearLayout.allViewsAreGoneBefore:COMMENT
Method Modifier: private     
Comment:/**
 * Checks whether all (virtual) child views before the given index are gone.
 */

Body of Frist Method:
{
    for (int i = childIndex - 1; i >= 0; i--) {
        View child = getVirtualChildAt(i);
        if (child != null && child.getVisibility() != GONE) {
            return false;
        }
    }
    return true;
}
Body of Second Method:
{
    for (int i = childIndex - 1; i >= 0; i--) {
        final View child = getVirtualChildAt(i);
        if (child != null && child.getVisibility() != GONE) {
            return false;
        }
    }
    return true;
}
------------------------
Find a silently evolved API code:android.renderscript.Sampler.CLAMP_LINEAR_MIP_LINEAR:COMMENT
Method Modifier: public      static      
Comment:/**
 * Retrieve a sampler with mag set to linear, min linear mipmap linear, and
 * wrap modes set to clamp.
 *
 * @param rs Context to which the sampler will belong.
 *
 * @return Sampler
 */

Body of Frist Method:
{
    if (rs.mSampler_CLAMP_LINEAR_MIP_LINEAR == null) {
        Builder b = new Builder(rs);
        b.setMinification(Value.LINEAR_MIP_LINEAR);
        b.setMagnification(Value.LINEAR);
        b.setWrapS(Value.CLAMP);
        b.setWrapT(Value.CLAMP);
        rs.mSampler_CLAMP_LINEAR_MIP_LINEAR = b.create();
    }
    return rs.mSampler_CLAMP_LINEAR_MIP_LINEAR;
}
Body of Second Method:
{
    if (rs.mSampler_CLAMP_LINEAR_MIP_LINEAR == null) {
        synchronized (rs) {
            if (rs.mSampler_CLAMP_LINEAR_MIP_LINEAR == null) {
                Builder b = new Builder(rs);
                b.setMinification(Value.LINEAR_MIP_LINEAR);
                b.setMagnification(Value.LINEAR);
                b.setWrapS(Value.CLAMP);
                b.setWrapT(Value.CLAMP);
                rs.mSampler_CLAMP_LINEAR_MIP_LINEAR = b.create();
            }
        }
    }
    return rs.mSampler_CLAMP_LINEAR_MIP_LINEAR;
}
------------------------
Find a silently evolved API code:android.net.dhcp.DhcpAckPacket.finishPacket:COMMENT
Method Modifier: default     
Comment:/**
 * Adds the optional parameters to the client-generated ACK packet.
 */

Body of Frist Method:
{
    addTlv(buffer, DHCP_MESSAGE_TYPE, DHCP_MESSAGE_TYPE_ACK);
    addTlv(buffer, DHCP_SERVER_IDENTIFIER, mServerIdentifier);
    addTlv(buffer, DHCP_LEASE_TIME, mLeaseTime);
    // the client should renew at 1/2 the lease-expiry interval
    if (mLeaseTime != null) {
        addTlv(buffer, DHCP_RENEWAL_TIME, Integer.valueOf(mLeaseTime.intValue() / 2));
    }
    addTlv(buffer, DHCP_SUBNET_MASK, mSubnetMask);
    addTlv(buffer, DHCP_ROUTER, mGateway);
    addTlv(buffer, DHCP_DOMAIN_NAME, mDomainName);
    addTlv(buffer, DHCP_BROADCAST_ADDRESS, mBroadcastAddress);
    addTlv(buffer, DHCP_DNS_SERVER, mDnsServers);
    addTlvEnd(buffer);
}
Body of Second Method:
{
    addTlv(buffer, DHCP_MESSAGE_TYPE, DHCP_MESSAGE_TYPE_ACK);
    addTlv(buffer, DHCP_SERVER_IDENTIFIER, mServerIdentifier);
    addTlv(buffer, DHCP_LEASE_TIME, mLeaseTime);
    // the client should renew at 1/2 the lease-expiry interval
    if (mLeaseTime != null) {
        addTlv(buffer, DHCP_RENEWAL_TIME, Integer.valueOf(mLeaseTime.intValue() / 2));
    }
    addTlv(buffer, DHCP_SUBNET_MASK, mSubnetMask);
    addTlv(buffer, DHCP_ROUTER, mGateways);
    addTlv(buffer, DHCP_DOMAIN_NAME, mDomainName);
    addTlv(buffer, DHCP_BROADCAST_ADDRESS, mBroadcastAddress);
    addTlv(buffer, DHCP_DNS_SERVER, mDnsServers);
    addTlvEnd(buffer);
}
------------------------
Find a silently evolved API code:android.app.backup.FullBackup.BackupScheme.getDirectoryForCriteriaDomain:COMMENT
Method Modifier: private     
Comment:/**
 * @param domain parsed from xml. Not sanitised before calling this function so may be null.
 * @return The directory relevant to the domain specified.
 */

Body of Frist Method:
{
    if (TextUtils.isEmpty(domain)) {
        return null;
    }
    if ("file".equals(domain)) {
        return FILES_DIR;
    } else if ("database".equals(domain)) {
        return DATABASE_DIR;
    } else if ("root".equals(domain)) {
        return ROOT_DIR;
    } else if ("sharedpref".equals(domain)) {
        return SHAREDPREF_DIR;
    } else if ("external".equals(domain)) {
        return EXTERNAL_DIR;
    } else {
        return null;
    }
}
Body of Second Method:
{
    if (TextUtils.isEmpty(domain)) {
        return null;
    }
    if ("file".equals(domain)) {
        return FILES_DIR;
    } else if ("database".equals(domain)) {
        return DATABASE_DIR;
    } else if ("root".equals(domain)) {
        return ROOT_DIR;
    } else if ("sharedpref".equals(domain)) {
        return SHAREDPREF_DIR;
    } else if ("device_file".equals(domain)) {
        return DEVICE_FILES_DIR;
    } else if ("device_database".equals(domain)) {
        return DEVICE_DATABASE_DIR;
    } else if ("device_root".equals(domain)) {
        return DEVICE_ROOT_DIR;
    } else if ("device_sharedpref".equals(domain)) {
        return DEVICE_SHAREDPREF_DIR;
    } else if ("external".equals(domain)) {
        return EXTERNAL_DIR;
    } else {
        return null;
    }
}
------------------------
Find a silently evolved API code:android.widget.SearchView.SearchAutoComplete.onWindowFocusChanged:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * We override this method to be sure and show the soft keyboard if
 * appropriate when the TextView has focus.
 */

Body of Frist Method:
{
    super.onWindowFocusChanged(hasWindowFocus);
    if (hasWindowFocus && mSearchView.hasFocus() && getVisibility() == VISIBLE) {
        InputMethodManager inputManager = (InputMethodManager) getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
        inputManager.showSoftInput(this, 0);
        // the ime is in front of the dropdown.
        if (isLandscapeMode(getContext())) {
            ensureImeVisible(true);
        }
    }
}
Body of Second Method:
{
    super.onWindowFocusChanged(hasWindowFocus);
    if (hasWindowFocus && mSearchView.hasFocus() && getVisibility() == VISIBLE) {
        InputMethodManager inputManager = getContext().getSystemService(InputMethodManager.class);
        inputManager.showSoftInput(this, 0);
        // the ime is in front of the dropdown.
        if (isLandscapeMode(getContext())) {
            ensureImeVisible(true);
        }
    }
}
------------------------
Find a silently evolved API code:android.telephony.CellSignalStrengthGsm.initialize:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Initialize all the values
 *
 * @param ss SignalStrength as ASU value
 * @param ber is Bit Error Rate
 *
 * @hide
 */

Body of Frist Method:
{
    mSignalStrength = ss;
    mBitErrorRate = ber;
}
Body of Second Method:
{
    mSignalStrength = ss;
    mBitErrorRate = ber;
    mTimingAdvance = Integer.MAX_VALUE;
}
------------------------
Find a silently evolved API code:android.telephony.CellSignalStrengthLte.getAsuLevel:COMMENT
Method Modifier: public      
Comment:/**
 * Get the LTE signal level as an asu value between 0..97, 99 is unknown
 * Asu is calculated based on 3GPP RSRP. Refer to 3GPP 27.007 (Ver 10.3.0) Sec 8.69
 */

Body of Frist Method:
{
    int lteAsuLevel = 99;
    int lteDbm = getDbm();
    if (lteDbm <= -140)
        lteAsuLevel = 0;
    else if (lteDbm >= -43)
        lteAsuLevel = 97;
    else
        lteAsuLevel = lteDbm + 140;
    if (DBG)
        log("Lte Asu level: " + lteAsuLevel);
    return lteAsuLevel;
}
Body of Second Method:
{
    int lteAsuLevel = 99;
    int lteDbm = getDbm();
    if (lteDbm == Integer.MAX_VALUE)
        lteAsuLevel = 99;
    else if (lteDbm <= -140)
        lteAsuLevel = 0;
    else if (lteDbm >= -43)
        lteAsuLevel = 97;
    else
        lteAsuLevel = lteDbm + 140;
    if (DBG)
        log("Lte Asu level: " + lteAsuLevel);
    return lteAsuLevel;
}
------------------------
Find a silently evolved API code:android.app.trust.TrustManager.unregisterTrustListener:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Unregisters a listener for trust events.
 *
 * Requires the {@link android.Manifest.permission#TRUST_LISTENER} permission.
 */

Body of Frist Method:
{
    ITrustListener iTrustListener = mTrustListeners.remove(trustListener);
    if (iTrustListener != null) {
        try {
            mService.unregisterTrustListener(iTrustListener);
        } catch (RemoteException e) {
            onError(e);
        }
    }
}
Body of Second Method:
{
    ITrustListener iTrustListener = mTrustListeners.remove(trustListener);
    if (iTrustListener != null) {
        try {
            mService.unregisterTrustListener(iTrustListener);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothAdapter.closeProfileProxy:COMMENT
Method Modifier: public      
Comment:/**
 * Close the connection of the profile proxy to the Service.
 *
 * <p> Clients should call this when they are no longer using
 * the proxy obtained from {@link #getProfileProxy}.
 * Profile can be one of  {@link BluetoothProfile#HEALTH}, {@link BluetoothProfile#HEADSET} or
 * {@link BluetoothProfile#A2DP}
 *
 * @param profile
 * @param proxy Profile proxy object
 */

Body of Frist Method:
{
    if (proxy == null)
        return;
    switch(profile) {
        case BluetoothProfile.HEADSET:
            BluetoothHeadset headset = (BluetoothHeadset) proxy;
            headset.close();
            break;
        case BluetoothProfile.A2DP:
            BluetoothA2dp a2dp = (BluetoothA2dp) proxy;
            a2dp.close();
            break;
        case BluetoothProfile.A2DP_SINK:
            BluetoothA2dpSink a2dpSink = (BluetoothA2dpSink) proxy;
            a2dpSink.close();
            break;
        case BluetoothProfile.AVRCP_CONTROLLER:
            BluetoothAvrcpController avrcp = (BluetoothAvrcpController) proxy;
            avrcp.close();
            break;
        case BluetoothProfile.INPUT_DEVICE:
            BluetoothInputDevice iDev = (BluetoothInputDevice) proxy;
            iDev.close();
            break;
        case BluetoothProfile.PAN:
            BluetoothPan pan = (BluetoothPan) proxy;
            pan.close();
            break;
        case BluetoothProfile.HEALTH:
            BluetoothHealth health = (BluetoothHealth) proxy;
            health.close();
            break;
        case BluetoothProfile.GATT:
            BluetoothGatt gatt = (BluetoothGatt) proxy;
            gatt.close();
            break;
        case BluetoothProfile.GATT_SERVER:
            BluetoothGattServer gattServer = (BluetoothGattServer) proxy;
            gattServer.close();
            break;
        case BluetoothProfile.MAP:
            BluetoothMap map = (BluetoothMap) proxy;
            map.close();
            break;
        case BluetoothProfile.HEADSET_CLIENT:
            BluetoothHeadsetClient headsetClient = (BluetoothHeadsetClient) proxy;
            headsetClient.close();
            break;
        case BluetoothProfile.SAP:
            BluetoothSap sap = (BluetoothSap) proxy;
            sap.close();
            break;
    }
}
Body of Second Method:
{
    if (proxy == null)
        return;
    switch(profile) {
        case BluetoothProfile.HEADSET:
            BluetoothHeadset headset = (BluetoothHeadset) proxy;
            headset.close();
            break;
        case BluetoothProfile.A2DP:
            BluetoothA2dp a2dp = (BluetoothA2dp) proxy;
            a2dp.close();
            break;
        case BluetoothProfile.A2DP_SINK:
            BluetoothA2dpSink a2dpSink = (BluetoothA2dpSink) proxy;
            a2dpSink.close();
            break;
        case BluetoothProfile.AVRCP_CONTROLLER:
            BluetoothAvrcpController avrcp = (BluetoothAvrcpController) proxy;
            avrcp.close();
            break;
        case BluetoothProfile.INPUT_DEVICE:
            BluetoothInputDevice iDev = (BluetoothInputDevice) proxy;
            iDev.close();
            break;
        case BluetoothProfile.PAN:
            BluetoothPan pan = (BluetoothPan) proxy;
            pan.close();
            break;
        case BluetoothProfile.HEALTH:
            BluetoothHealth health = (BluetoothHealth) proxy;
            health.close();
            break;
        case BluetoothProfile.GATT:
            BluetoothGatt gatt = (BluetoothGatt) proxy;
            gatt.close();
            break;
        case BluetoothProfile.GATT_SERVER:
            BluetoothGattServer gattServer = (BluetoothGattServer) proxy;
            gattServer.close();
            break;
        case BluetoothProfile.MAP:
            BluetoothMap map = (BluetoothMap) proxy;
            map.close();
            break;
        case BluetoothProfile.HEADSET_CLIENT:
            BluetoothHeadsetClient headsetClient = (BluetoothHeadsetClient) proxy;
            headsetClient.close();
            break;
        case BluetoothProfile.SAP:
            BluetoothSap sap = (BluetoothSap) proxy;
            sap.close();
            break;
        case BluetoothProfile.PBAP_CLIENT:
            BluetoothPbapClient pbapClient = (BluetoothPbapClient) proxy;
            pbapClient.close();
            break;
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.RttManager.ParcelableRttResults.writeToParcel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Implement the Parcelable interface {@hide}
 */

Body of Frist Method:
{
    if (mResults != null) {
        dest.writeInt(mResults.length);
        for (RttResult result : mResults) {
            dest.writeString(result.bssid);
            dest.writeInt(result.burstNumber);
            dest.writeInt(result.measurementFrameNumber);
            dest.writeInt(result.successMeasurementFrameNumber);
            dest.writeInt(result.frameNumberPerBurstPeer);
            dest.writeInt(result.status);
            dest.writeInt(result.measurementType);
            dest.writeInt(result.retryAfterDuration);
            dest.writeLong(result.ts);
            dest.writeInt(result.rssi);
            dest.writeInt(result.rssiSpread);
            dest.writeInt(result.txRate);
            dest.writeLong(result.rtt);
            dest.writeLong(result.rttStandardDeviation);
            dest.writeLong(result.rttSpread);
            dest.writeInt(result.distance);
            dest.writeInt(result.distanceStandardDeviation);
            dest.writeInt(result.distanceSpread);
            dest.writeInt(result.burstDuration);
            dest.writeInt(result.negotiatedBurstNum);
            dest.writeByte(result.LCI.id);
            if (result.LCI.id != (byte) 0xFF) {
                dest.writeByte((byte) result.LCI.data.length);
                dest.writeByteArray(result.LCI.data);
            }
            dest.writeByte(result.LCR.id);
            if (result.LCR.id != (byte) 0xFF) {
                dest.writeInt((byte) result.LCR.data.length);
                dest.writeByte(result.LCR.id);
            }
        }
    } else {
        dest.writeInt(0);
    }
}
Body of Second Method:
{
    if (mResults != null) {
        dest.writeInt(mResults.length);
        for (RttResult result : mResults) {
            dest.writeString(result.bssid);
            dest.writeInt(result.burstNumber);
            dest.writeInt(result.measurementFrameNumber);
            dest.writeInt(result.successMeasurementFrameNumber);
            dest.writeInt(result.frameNumberPerBurstPeer);
            dest.writeInt(result.status);
            dest.writeInt(result.measurementType);
            dest.writeInt(result.retryAfterDuration);
            dest.writeLong(result.ts);
            dest.writeInt(result.rssi);
            dest.writeInt(result.rssiSpread);
            dest.writeInt(result.txRate);
            dest.writeLong(result.rtt);
            dest.writeLong(result.rttStandardDeviation);
            dest.writeLong(result.rttSpread);
            dest.writeInt(result.distance);
            dest.writeInt(result.distanceStandardDeviation);
            dest.writeInt(result.distanceSpread);
            dest.writeInt(result.burstDuration);
            dest.writeInt(result.negotiatedBurstNum);
            dest.writeByte(result.LCI.id);
            if (result.LCI.id != (byte) 0xFF) {
                dest.writeByte((byte) result.LCI.data.length);
                dest.writeByteArray(result.LCI.data);
            }
            dest.writeByte(result.LCR.id);
            if (result.LCR.id != (byte) 0xFF) {
                dest.writeInt((byte) result.LCR.data.length);
                dest.writeByte(result.LCR.id);
            }
            dest.writeByte(result.secure ? (byte) 1 : 0);
        }
    } else {
        dest.writeInt(0);
    }
}
------------------------
Find a silently evolved API code:android.location.Location.bearingTo:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the approximate initial bearing in degrees East of true
 * North when traveling along the shortest path between this
 * location and the given location.  The shortest path is defined
 * using the WGS84 ellipsoid.  Locations that are (nearly)
 * antipodal may produce meaningless results.
 *
 * @param dest the destination location
 * @return the initial bearing in degrees
 */

Body of Frist Method:
{
    synchronized (mResults) {
        // See if we already have the result
        if (mLatitude != mLat1 || mLongitude != mLon1 || dest.mLatitude != mLat2 || dest.mLongitude != mLon2) {
            computeDistanceAndBearing(mLatitude, mLongitude, dest.mLatitude, dest.mLongitude, mResults);
            mLat1 = mLatitude;
            mLon1 = mLongitude;
            mLat2 = dest.mLatitude;
            mLon2 = dest.mLongitude;
            mDistance = mResults[0];
            mInitialBearing = mResults[1];
        }
        return mInitialBearing;
    }
}
Body of Second Method:
{
    BearingDistanceCache cache = sBearingDistanceCache.get();
    // See if we already have the result
    if (mLatitude != cache.mLat1 || mLongitude != cache.mLon1 || dest.mLatitude != cache.mLat2 || dest.mLongitude != cache.mLon2) {
        computeDistanceAndBearing(mLatitude, mLongitude, dest.mLatitude, dest.mLongitude, cache);
    }
    return cache.mInitialBearing;
}
------------------------
Find a silently evolved API code:android.media.AudioManager.isMasterMute:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * get master mute state.
 *
 * @hide
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        return service.isMasterMute();
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in isMasterMute", e);
        return false;
    }
}
Body of Second Method:
{
    IAudioService service = getService();
    try {
        return service.isMasterMute();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.inputmethodservice.InputMethodService.dump:COMMENT
Method Modifier: protected   
Comment:/**
 * Performs a dump of the InputMethodService's internal state.  Override
 * to add your own information to the dump.
 */

Body of Frist Method:
{
    final Printer p = new PrintWriterPrinter(fout);
    p.println("Input method service state for " + this + ":");
    p.println("  mWindowCreated=" + mWindowCreated + " mWindowAdded=" + mWindowAdded);
    p.println("  mWindowVisible=" + mWindowVisible + " mWindowWasVisible=" + mWindowWasVisible + " mInShowWindow=" + mInShowWindow);
    p.println("  Configuration=" + getResources().getConfiguration());
    p.println("  mToken=" + mToken);
    p.println("  mInputBinding=" + mInputBinding);
    p.println("  mInputConnection=" + mInputConnection);
    p.println("  mStartedInputConnection=" + mStartedInputConnection);
    p.println("  mInputStarted=" + mInputStarted + " mInputViewStarted=" + mInputViewStarted + " mCandidatesViewStarted=" + mCandidatesViewStarted);
    if (mInputEditorInfo != null) {
        p.println("  mInputEditorInfo:");
        mInputEditorInfo.dump(p, "    ");
    } else {
        p.println("  mInputEditorInfo: null");
    }
    p.println("  mShowInputRequested=" + mShowInputRequested + " mLastShowInputRequested=" + mLastShowInputRequested + " mShowInputForced=" + mShowInputForced + " mShowInputFlags=0x" + Integer.toHexString(mShowInputFlags));
    p.println("  mCandidatesVisibility=" + mCandidatesVisibility + " mFullscreenApplied=" + mFullscreenApplied + " mIsFullscreen=" + mIsFullscreen + " mExtractViewHidden=" + mExtractViewHidden);
    if (mExtractedText != null) {
        p.println("  mExtractedText:");
        p.println("    text=" + mExtractedText.text.length() + " chars" + " startOffset=" + mExtractedText.startOffset);
        p.println("    selectionStart=" + mExtractedText.selectionStart + " selectionEnd=" + mExtractedText.selectionEnd + " flags=0x" + Integer.toHexString(mExtractedText.flags));
    } else {
        p.println("  mExtractedText: null");
    }
    p.println("  mExtractedToken=" + mExtractedToken);
    p.println("  mIsInputViewShown=" + mIsInputViewShown + " mStatusIcon=" + mStatusIcon);
    p.println("Last computed insets:");
    p.println("  contentTopInsets=" + mTmpInsets.contentTopInsets + " visibleTopInsets=" + mTmpInsets.visibleTopInsets + " touchableInsets=" + mTmpInsets.touchableInsets + " touchableRegion=" + mTmpInsets.touchableRegion);
    p.println(" mShouldClearInsetOfPreviousIme=" + mShouldClearInsetOfPreviousIme);
}
Body of Second Method:
{
    final Printer p = new PrintWriterPrinter(fout);
    p.println("Input method service state for " + this + ":");
    p.println("  mWindowCreated=" + mWindowCreated + " mWindowAdded=" + mWindowAdded);
    p.println("  mWindowVisible=" + mWindowVisible + " mWindowWasVisible=" + mWindowWasVisible + " mInShowWindow=" + mInShowWindow);
    p.println("  Configuration=" + getResources().getConfiguration());
    p.println("  mToken=" + mToken);
    p.println("  mInputBinding=" + mInputBinding);
    p.println("  mInputConnection=" + mInputConnection);
    p.println("  mStartedInputConnection=" + mStartedInputConnection);
    p.println("  mInputStarted=" + mInputStarted + " mInputViewStarted=" + mInputViewStarted + " mCandidatesViewStarted=" + mCandidatesViewStarted);
    if (mInputEditorInfo != null) {
        p.println("  mInputEditorInfo:");
        mInputEditorInfo.dump(p, "    ");
    } else {
        p.println("  mInputEditorInfo: null");
    }
    p.println("  mShowInputRequested=" + mShowInputRequested + " mLastShowInputRequested=" + mLastShowInputRequested + " mShowInputFlags=0x" + Integer.toHexString(mShowInputFlags));
    p.println("  mCandidatesVisibility=" + mCandidatesVisibility + " mFullscreenApplied=" + mFullscreenApplied + " mIsFullscreen=" + mIsFullscreen + " mExtractViewHidden=" + mExtractViewHidden);
    if (mExtractedText != null) {
        p.println("  mExtractedText:");
        p.println("    text=" + mExtractedText.text.length() + " chars" + " startOffset=" + mExtractedText.startOffset);
        p.println("    selectionStart=" + mExtractedText.selectionStart + " selectionEnd=" + mExtractedText.selectionEnd + " flags=0x" + Integer.toHexString(mExtractedText.flags));
    } else {
        p.println("  mExtractedText: null");
    }
    p.println("  mExtractedToken=" + mExtractedToken);
    p.println("  mIsInputViewShown=" + mIsInputViewShown + " mStatusIcon=" + mStatusIcon);
    p.println("Last computed insets:");
    p.println("  contentTopInsets=" + mTmpInsets.contentTopInsets + " visibleTopInsets=" + mTmpInsets.visibleTopInsets + " touchableInsets=" + mTmpInsets.touchableInsets + " touchableRegion=" + mTmpInsets.touchableRegion);
    p.println(" mShouldClearInsetOfPreviousIme=" + mShouldClearInsetOfPreviousIme);
    p.println(" mSettingsObserver=" + mSettingsObserver);
}
------------------------
Find a silently evolved API code:android.app.ActivityManager.AppTask.moveToFront:COMMENT
Method Modifier: public      
Comment:/**
 * Bring this task to the foreground.  If it contains activities, they will be
 * brought to the foreground with it and their instances re-created if needed.
 * If it doesn't contain activities, the root activity of the task will be
 * re-launched.
 */

Body of Frist Method:
{
    try {
        mAppTaskImpl.moveToFront();
    } catch (RemoteException e) {
        Slog.e(TAG, "Invalid AppTask", e);
    }
}
Body of Second Method:
{
    try {
        mAppTaskImpl.moveToFront();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.telephony.CellSignalStrengthCdma.getAsuLevel:COMMENT
Method Modifier: public      
Comment:/**
 * Get the signal level as an asu value between 0..97, 99 is unknown
 */

Body of Frist Method:
{
    final int cdmaDbm = getCdmaDbm();
    final int cdmaEcio = getCdmaEcio();
    int cdmaAsuLevel;
    int ecioAsuLevel;
    if (cdmaDbm >= -75)
        cdmaAsuLevel = 16;
    else if (cdmaDbm >= -82)
        cdmaAsuLevel = 8;
    else if (cdmaDbm >= -90)
        cdmaAsuLevel = 4;
    else if (cdmaDbm >= -95)
        cdmaAsuLevel = 2;
    else if (cdmaDbm >= -100)
        cdmaAsuLevel = 1;
    else
        cdmaAsuLevel = 99;
    // Ec/Io are in dB*10
    if (cdmaEcio >= -90)
        ecioAsuLevel = 16;
    else if (cdmaEcio >= -100)
        ecioAsuLevel = 8;
    else if (cdmaEcio >= -115)
        ecioAsuLevel = 4;
    else if (cdmaEcio >= -130)
        ecioAsuLevel = 2;
    else if (cdmaEcio >= -150)
        ecioAsuLevel = 1;
    else
        ecioAsuLevel = 99;
    int level = (cdmaAsuLevel < ecioAsuLevel) ? cdmaAsuLevel : ecioAsuLevel;
    if (DBG)
        log("getAsuLevel=" + level);
    return level;
}
Body of Second Method:
{
    final int cdmaDbm = getCdmaDbm();
    final int cdmaEcio = getCdmaEcio();
    int cdmaAsuLevel;
    int ecioAsuLevel;
    if (cdmaDbm == Integer.MAX_VALUE)
        cdmaAsuLevel = 99;
    else if (cdmaDbm >= -75)
        cdmaAsuLevel = 16;
    else if (cdmaDbm >= -82)
        cdmaAsuLevel = 8;
    else if (cdmaDbm >= -90)
        cdmaAsuLevel = 4;
    else if (cdmaDbm >= -95)
        cdmaAsuLevel = 2;
    else if (cdmaDbm >= -100)
        cdmaAsuLevel = 1;
    else
        cdmaAsuLevel = 99;
    // Ec/Io are in dB*10
    if (cdmaEcio == Integer.MAX_VALUE)
        ecioAsuLevel = 99;
    else if (cdmaEcio >= -90)
        ecioAsuLevel = 16;
    else if (cdmaEcio >= -100)
        ecioAsuLevel = 8;
    else if (cdmaEcio >= -115)
        ecioAsuLevel = 4;
    else if (cdmaEcio >= -130)
        ecioAsuLevel = 2;
    else if (cdmaEcio >= -150)
        ecioAsuLevel = 1;
    else
        ecioAsuLevel = 99;
    int level = (cdmaAsuLevel < ecioAsuLevel) ? cdmaAsuLevel : ecioAsuLevel;
    if (DBG)
        log("getAsuLevel=" + level);
    return level;
}
------------------------
Find a silently evolved API code:android.app.ActivityManager.killUid:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Kills the specified UID.
 * @param uid The UID to kill.
 * @param reason The reason for the kill.
 *
 * @hide
 */

Body of Frist Method:
{
    try {
        ActivityManagerNative.getDefault().killUid(UserHandle.getAppId(uid), UserHandle.getUserId(uid), reason);
    } catch (RemoteException e) {
        Log.e(TAG, "Couldn't kill uid:" + uid, e);
    }
}
Body of Second Method:
{
    try {
        ActivityManagerNative.getDefault().killUid(UserHandle.getAppId(uid), UserHandle.getUserId(uid), reason);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.media.AudioManager.setBluetoothScoOn:COMMENT
Method Modifier: public      
Comment:/**
 * Request use of Bluetooth SCO headset for communications.
 * <p>
 * This method should only be used by applications that replace the platform-wide
 * management of audio settings or the main telephony application.
 *
 * @param on set <var>true</var> to use bluetooth SCO for communications;
 * <var>false</var> to not use bluetooth SCO for communications
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        service.setBluetoothScoOn(on);
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in setBluetoothScoOn", e);
    }
}
Body of Second Method:
{
    IAudioService service = getService();
    try {
        service.setBluetoothScoOn(on);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.hardware.fingerprint.FingerprintManager.getAuthenticatorId:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Retrieves the authenticator token for binding keys to the lifecycle
 * of the current set of fingerprints. Used only by internal clients.
 *
 * @hide
 */

Body of Frist Method:
{
    if (mService != null) {
        try {
            return mService.getAuthenticatorId(mContext.getOpPackageName());
        } catch (RemoteException e) {
            Log.v(TAG, "Remote exception in getAuthenticatorId(): ", e);
        }
    } else {
        Log.w(TAG, "getAuthenticatorId(): Service not connected!");
    }
    return 0;
}
Body of Second Method:
{
    if (mService != null) {
        try {
            return mService.getAuthenticatorId(mContext.getOpPackageName());
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    } else {
        Log.w(TAG, "getAuthenticatorId(): Service not connected!");
    }
    return 0;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothDevice.createBond:COMMENT
Method Modifier: public      
Comment:/**
 * Start the bonding (pairing) process with the remote device.
 * <p>This is an asynchronous call, it will return immediately. Register
 * for {@link #ACTION_BOND_STATE_CHANGED} intents to be notified when
 * the bonding process completes, and its result.
 * <p>Android system services will handle the necessary user interactions
 * to confirm and complete the bonding process.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}.
 *
 * @return false on immediate error, true if bonding will begin
 */

Body of Frist Method:
{
    if (sService == null) {
        Log.e(TAG, "BT not enabled. Cannot create bond to Remote Device");
        return false;
    }
    try {
        return sService.createBond(this, TRANSPORT_AUTO);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
Body of Second Method:
{
    if (sService == null) {
        Log.e(TAG, "BT not enabled. Cannot create bond to Remote Device");
        return false;
    }
    try {
        Log.i(TAG, "createBond() for device " + getAddress() + " called by pid: " + Process.myPid() + " tid: " + Process.myTid());
        return sService.createBond(this, TRANSPORT_AUTO);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
------------------------
Find a silently evolved API code:android.graphics.Canvas.drawPath:COMMENT
Method Modifier: public      
Comment:/**
 * Draw the specified path using the specified paint. The path will be
 * filled or framed based on the Style in the paint.
 *
 * @param path  The path to be drawn
 * @param paint The paint used to draw the path
 */

Body of Frist Method:
{
    native_drawPath(mNativeCanvasWrapper, path.ni(), paint.getNativeInstance());
}
Body of Second Method:
{
    if (path.isSimplePath && path.rects != null) {
        native_drawRegion(mNativeCanvasWrapper, path.rects.mNativeRegion, paint.getNativeInstance());
    } else {
        native_drawPath(mNativeCanvasWrapper, path.ni(), paint.getNativeInstance());
    }
}
------------------------
Find a silently evolved API code:android.location.Location.removeAccuracy:COMMENT
Method Modifier: public      
Comment:/**
 * Remove the accuracy from this location.
 *
 * <p>Following this call {@link #hasAccuracy} will return false, and
 * {@link #getAccuracy} will return 0.0.
 */

Body of Frist Method:
{
    mAccuracy = 0.0f;
    mHasAccuracy = false;
}
Body of Second Method:
{
    mAccuracy = 0.0f;
    mFieldsMask &= ~HAS_ACCURACY_MASK;
}
------------------------
Find a silently evolved API code:android.content.Loader.rollbackContentChanged:COMMENT
Method Modifier: public      
Comment:/**
 * Report that you have abandoned the processing of a content change that
 * was returned by {@link #takeContentChanged()} and would like to rollback
 * to the state where there is again a pending content change.  This is
 * to handle the case where a data load due to a content change has been
 * canceled before its data was delivered back to the loader.
 */

Body of Frist Method:
{
    if (mProcessingChange) {
        mContentChanged = true;
    }
}
Body of Second Method:
{
    if (mProcessingChange) {
        onContentChanged();
    }
}
------------------------
Find a silently evolved API code:android.os.UserHandle.getUserId:COMMENT
<android.os.UserHandle: int getUserId(int)>
public      static      final       hidden      ->public      static      hidden      
Method Modifier: public      static      final       hidden      
Method Modifier: Yes         Yes         Yes         Yes         
Method Updated:  Yes         Yes         No          Yes         
Comment:/**
 * Returns the user id for a given uid.
 * @hide
 */

Body of Frist Method:
{
    if (MU_ENABLED) {
        return uid / PER_USER_RANGE;
    } else {
        return 0;
    }
}
Body of Second Method:
{
    if (MU_ENABLED) {
        return uid / PER_USER_RANGE;
    } else {
        return UserHandle.USER_SYSTEM;
    }
}
------------------------
Find a silently evolved API code:android.graphics.drawable.RippleDrawable.updateStateFromTypedArray:COMMENT
Method Modifier: private     
Comment:/**
 * Initializes the constant state from the values in the typed array.
 */

Body of Frist Method:
{
    final RippleState state = mState;
    // Account for any configuration changes.
    state.mChangingConfigurations |= a.getChangingConfigurations();
    // Extract the theme attributes, if any.
    state.mTouchThemeAttrs = a.extractThemeAttrs();
    final ColorStateList color = a.getColorStateList(R.styleable.RippleDrawable_color);
    if (color != null) {
        mState.mColor = color;
    }
    mState.mMaxRadius = a.getDimensionPixelSize(R.styleable.RippleDrawable_radius, mState.mMaxRadius);
    verifyRequiredAttributes(a);
}
Body of Second Method:
{
    final RippleState state = mState;
    // Account for any configuration changes.
    state.mChangingConfigurations |= a.getChangingConfigurations();
    // Extract the theme attributes, if any.
    state.mTouchThemeAttrs = a.extractThemeAttrs();
    final ColorStateList color = a.getColorStateList(R.styleable.RippleDrawable_color);
    if (color != null) {
        mState.mColor = color;
    }
    mState.mMaxRadius = a.getDimensionPixelSize(R.styleable.RippleDrawable_radius, mState.mMaxRadius);
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiManager.WifiLock.acquire:COMMENT
Method Modifier: public      
Comment:/**
 * Locks the Wi-Fi radio on until {@link #release} is called.
 *
 * If this WifiLock is reference-counted, each call to {@code acquire} will increment the
 * reference count, and the radio will remain locked as long as the reference count is
 * above zero.
 *
 * If this WifiLock is not reference-counted, the first call to {@code acquire} will lock
 * the radio, but subsequent calls will be ignored.  Only one call to {@link #release}
 * will be required, regardless of the number of times that {@code acquire} is called.
 */

Body of Frist Method:
{
    synchronized (mBinder) {
        if (mRefCounted ? (++mRefCount == 1) : (!mHeld)) {
            try {
                mService.acquireWifiLock(mBinder, mLockType, mTag, mWorkSource);
                synchronized (WifiManager.this) {
                    if (mActiveLockCount >= MAX_ACTIVE_LOCKS) {
                        mService.releaseWifiLock(mBinder);
                        throw new UnsupportedOperationException("Exceeded maximum number of wifi locks");
                    }
                    mActiveLockCount++;
                }
            } catch (RemoteException ignore) {
            }
            mHeld = true;
        }
    }
}
Body of Second Method:
{
    synchronized (mBinder) {
        if (mRefCounted ? (++mRefCount == 1) : (!mHeld)) {
            try {
                mService.acquireWifiLock(mBinder, mLockType, mTag, mWorkSource);
                synchronized (WifiManager.this) {
                    if (mActiveLockCount >= MAX_ACTIVE_LOCKS) {
                        mService.releaseWifiLock(mBinder);
                        throw new UnsupportedOperationException("Exceeded maximum number of wifi locks");
                    }
                    mActiveLockCount++;
                }
            } catch (RemoteException e) {
                throw e.rethrowFromSystemServer();
            }
            mHeld = true;
        }
    }
}
------------------------
Find a silently evolved API code:android.transition.Visibility.onAppear:COMMENT
Method Modifier: public      
Comment:/**
 * The default implementation of this method calls
 * {@link #onAppear(ViewGroup, View, TransitionValues, TransitionValues)}.
 * Subclasses should override this method or
 * {@link #onAppear(ViewGroup, View, TransitionValues, TransitionValues)}.
 * if they need to create an Animator when targets appear.
 * The method should only be called by the Visibility class; it is
 * not intended to be called from external classes.
 *
 * @param sceneRoot The root of the transition hierarchy
 * @param startValues The target values in the start scene
 * @param startVisibility The target visibility in the start scene
 * @param endValues The target values in the end scene
 * @param endVisibility The target visibility in the end scene
 * @return An Animator to be started at the appropriate time in the
 * overall transition for this scene change. A null value means no animation
 * should be run.
 */

Body of Frist Method:
{
    if ((mMode & MODE_IN) != MODE_IN || endValues == null) {
        return null;
    }
    if (startValues == null) {
        VisibilityInfo parentVisibilityInfo = null;
        View endParent = (View) endValues.view.getParent();
        TransitionValues startParentValues = getMatchedTransitionValues(endParent, false);
        TransitionValues endParentValues = getTransitionValues(endParent, false);
        parentVisibilityInfo = getVisibilityChangeInfo(startParentValues, endParentValues);
        if (parentVisibilityInfo.visibilityChange) {
            return null;
        }
    }
    final boolean isForcedVisibility = mForcedStartVisibility != -1 || mForcedEndVisibility != -1;
    if (isForcedVisibility) {
        // Make sure that we reverse the effect of onDisappear's setTransitionAlpha(0)
        endValues.view.setTransitionAlpha(1);
    }
    return onAppear(sceneRoot, endValues.view, startValues, endValues);
}
Body of Second Method:
{
    if ((mMode & MODE_IN) != MODE_IN || endValues == null) {
        return null;
    }
    if (startValues == null) {
        VisibilityInfo parentVisibilityInfo = null;
        View endParent = (View) endValues.view.getParent();
        TransitionValues startParentValues = getMatchedTransitionValues(endParent, false);
        TransitionValues endParentValues = getTransitionValues(endParent, false);
        parentVisibilityInfo = getVisibilityChangeInfo(startParentValues, endParentValues);
        if (parentVisibilityInfo.visibilityChange) {
            return null;
        }
    }
    return onAppear(sceneRoot, endValues.view, startValues, endValues);
}
------------------------
Find a silently evolved API code:android.view.TextureView.draw:COMMENT
Method Modifier: public      final       
Comment:/**
 * Subclasses of TextureView cannot do their own rendering
 * with the {@link Canvas} object.
 *
 * @param canvas The Canvas to which the View is rendered.
 */

Body of Frist Method:
{
    // NOTE: Maintain this carefully (see View.java)
    mPrivateFlags = (mPrivateFlags & ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;
    applyUpdate();
    applyTransformMatrix();
}
Body of Second Method:
{
    // NOTE: Maintain this carefully (see View#draw)
    mPrivateFlags = (mPrivateFlags & ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;
    if (canvas.isHardwareAccelerated()) {
        DisplayListCanvas displayListCanvas = (DisplayListCanvas) canvas;
        HardwareLayer layer = getHardwareLayer();
        if (layer != null) {
            applyUpdate();
            applyTransformMatrix();
            // ensure layer paint is up to date
            mLayer.setLayerPaint(mLayerPaint);
            displayListCanvas.drawHardwareLayer(layer);
        }
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiManager.save:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Save the given network in the supplicant config. If the network already
 * exists, the configuration is updated. A new network is enabled
 * by default.
 *
 * For a new network, this function is used instead of a
 * sequence of addNetwork(), enableNetwork() and saveConfiguration().
 *
 * For an existing network, it accomplishes the task of updateNetwork()
 * and saveConfiguration()
 *
 * @param config the set of variables that describe the configuration,
 * contained in a {@link WifiConfiguration} object.
 * @param listener for callbacks on success or failure. Can be null.
 * @throws IllegalStateException if the WifiManager instance needs to be
 * initialized again
 * @hide
 */

Body of Frist Method:
{
    if (config == null)
        throw new IllegalArgumentException("config cannot be null");
    validateChannel();
    sAsyncChannel.sendMessage(SAVE_NETWORK, 0, putListener(listener), config);
}
Body of Second Method:
{
    if (config == null)
        throw new IllegalArgumentException("config cannot be null");
    getChannel().sendMessage(SAVE_NETWORK, 0, putListener(listener), config);
}
------------------------
Find a silently evolved API code:android.os.Bundle.putParcelable:COMMENT
Method Modifier: public      
Comment:/**
 * Inserts a Parcelable value into the mapping of this Bundle, replacing
 * any existing value for the given key.  Either key or value may be null.
 *
 * @param key a String, or null
 * @param value a Parcelable object, or null
 */

Body of Frist Method:
{
    unparcel();
    mMap.put(key, value);
    mFdsKnown = false;
}
Body of Second Method:
{
    unparcel();
    mMap.put(key, value);
    mFlags &= ~FLAG_HAS_FDS_KNOWN;
}
------------------------
Find a silently evolved API code:android.media.ImageReader.acquireNextSurfaceImage:COMMENT
Method Modifier: private     
Comment:/**
 * Attempts to acquire the next image from the underlying native implementation.
 *
 * <p>
 * Note that unexpected failures will throw at the JNI level.
 * </p>
 *
 * @param si A blank SurfaceImage.
 * @return One of the {@code ACQUIRE_*} codes that determine success or failure.
 *
 * @see #ACQUIRE_MAX_IMAGES
 * @see #ACQUIRE_NO_BUFS
 * @see #ACQUIRE_SUCCESS
 */

Body of Frist Method:
{
    int status = nativeImageSetup(si);
    switch(status) {
        case ACQUIRE_SUCCESS:
            si.createSurfacePlanes();
            si.mIsImageValid = true;
        case ACQUIRE_NO_BUFS:
        case ACQUIRE_MAX_IMAGES:
            break;
        default:
            throw new AssertionError("Unknown nativeImageSetup return code " + status);
    }
    return status;
}
Body of Second Method:
{
    synchronized (mCloseLock) {
        // A null image will eventually be returned if ImageReader is already closed.
        int status = ACQUIRE_NO_BUFS;
        if (mIsReaderValid) {
            status = nativeImageSetup(si);
        }
        switch(status) {
            case ACQUIRE_SUCCESS:
                si.mIsImageValid = true;
            case ACQUIRE_NO_BUFS:
            case ACQUIRE_MAX_IMAGES:
                break;
            default:
                throw new AssertionError("Unknown nativeImageSetup return code " + status);
        }
        // for such case.
        if (status == ACQUIRE_SUCCESS) {
            mAcquiredImages.add(si);
        }
        return status;
    }
}
------------------------
Find a silently evolved API code:android.view.SurfaceControl.PhysicalDisplayInfo.toString:COMMENT
Method Modifier: public      
Comment:// For debugging purposes

Body of Frist Method:
{
    return "PhysicalDisplayInfo{" + width + " x " + height + ", " + refreshRate + " fps, " + "density " + density + ", " + xDpi + " x " + yDpi + " dpi, secure " + secure + ", appVsyncOffset " + appVsyncOffsetNanos + ", bufferDeadline " + presentationDeadlineNanos + "}";
}
Body of Second Method:
{
    return "PhysicalDisplayInfo{" + width + " x " + height + ", " + refreshRate + " fps, " + "density " + density + ", " + xDpi + " x " + yDpi + " dpi, secure " + secure + ", appVsyncOffset " + appVsyncOffsetNanos + ", bufferDeadline " + presentationDeadlineNanos + ", colorTransform " + colorTransform + "}";
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothAdapter.getConnectionState:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the current connection state of the local Bluetooth adapter.
 * This can be used to check whether the local Bluetooth adapter is connected
 * to any profile of any other remote Bluetooth Device.
 *
 * <p> Use this function along with {@link #ACTION_CONNECTION_STATE_CHANGED}
 * intent to get the connection state of the adapter.
 *
 * @return One of {@link #STATE_CONNECTED}, {@link #STATE_DISCONNECTED},
 * {@link #STATE_CONNECTING} or {@link #STATE_DISCONNECTED}
 *
 * @hide
 */

Body of Frist Method:
{
    if (getState() != STATE_ON)
        return BluetoothAdapter.STATE_DISCONNECTED;
    try {
        synchronized (mManagerCallback) {
            if (mService != null)
                return mService.getAdapterConnectionState();
        }
    } catch (RemoteException e) {
        Log.e(TAG, "getConnectionState:", e);
    }
    return BluetoothAdapter.STATE_DISCONNECTED;
}
Body of Second Method:
{
    if (getState() != STATE_ON)
        return BluetoothAdapter.STATE_DISCONNECTED;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.getAdapterConnectionState();
    } catch (RemoteException e) {
        Log.e(TAG, "getConnectionState:", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return BluetoothAdapter.STATE_DISCONNECTED;
}
------------------------
Find a silently evolved API code:android.text.BidiFormatter.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * @return A BidiFormatter with the specified options.
 */

Body of Frist Method:
{
    if (mFlags == DEFAULT_FLAGS && mTextDirectionHeuristic == DEFAULT_TEXT_DIRECTION_HEURISTIC) {
        return getDefaultInstanceFromContext(mIsRtlContext);
    }
    return new BidiFormatter(mIsRtlContext, mFlags, mTextDirectionHeuristic);
}
Body of Second Method:
{
    if (mFlags == DEFAULT_FLAGS && mTextDirectionHeuristic == DEFAULT_TEXT_DIRECTION_HEURISTIC) {
        return BidiFormatter.getDefaultInstanceFromContext(mIsRtlContext);
    }
    return new BidiFormatter(mIsRtlContext, mFlags, mTextDirectionHeuristic);
}
------------------------
Find a silently evolved API code:android.widget.ProgressBar.setSecondaryProgress:COMMENT
Method Modifier: public      
Comment:/**
 * <p>
 * Set the current secondary progress to the specified value. Does not do
 * anything if the progress bar is in indeterminate mode.
 * </p>
 *
 * @param secondaryProgress the new secondary progress, between 0 and {@link #getMax()}
 * @see #setIndeterminate(boolean)
 * @see #isIndeterminate()
 * @see #getSecondaryProgress()
 * @see #incrementSecondaryProgressBy(int)
 */

Body of Frist Method:
{
    if (mIndeterminate) {
        return;
    }
    if (secondaryProgress < 0) {
        secondaryProgress = 0;
    }
    if (secondaryProgress > mMax) {
        secondaryProgress = mMax;
    }
    if (secondaryProgress != mSecondaryProgress) {
        mSecondaryProgress = secondaryProgress;
        refreshProgress(R.id.secondaryProgress, mSecondaryProgress, false);
    }
}
Body of Second Method:
{
    if (mIndeterminate) {
        return;
    }
    if (secondaryProgress < 0) {
        secondaryProgress = 0;
    }
    if (secondaryProgress > mMax) {
        secondaryProgress = mMax;
    }
    if (secondaryProgress != mSecondaryProgress) {
        mSecondaryProgress = secondaryProgress;
        refreshProgress(R.id.secondaryProgress, mSecondaryProgress, false, false);
    }
}
------------------------
Find a silently evolved API code:android.app.Fragment.dump:COMMENT
Method Modifier: public      
Comment:/**
 * Print the Fragments's state into the given stream.
 *
 * @param prefix Text to print at the front of each line.
 * @param fd The raw file descriptor that the dump is being sent to.
 * @param writer The PrintWriter to which you should dump your state.  This will be
 * closed for you after you return.
 * @param args additional arguments to the dump request.
 */

Body of Frist Method:
{
    writer.print(prefix);
    writer.print("mFragmentId=#");
    writer.print(Integer.toHexString(mFragmentId));
    writer.print(" mContainerId=#");
    writer.print(Integer.toHexString(mContainerId));
    writer.print(" mTag=");
    writer.println(mTag);
    writer.print(prefix);
    writer.print("mState=");
    writer.print(mState);
    writer.print(" mIndex=");
    writer.print(mIndex);
    writer.print(" mWho=");
    writer.print(mWho);
    writer.print(" mBackStackNesting=");
    writer.println(mBackStackNesting);
    writer.print(prefix);
    writer.print("mAdded=");
    writer.print(mAdded);
    writer.print(" mRemoving=");
    writer.print(mRemoving);
    writer.print(" mResumed=");
    writer.print(mResumed);
    writer.print(" mFromLayout=");
    writer.print(mFromLayout);
    writer.print(" mInLayout=");
    writer.println(mInLayout);
    writer.print(prefix);
    writer.print("mHidden=");
    writer.print(mHidden);
    writer.print(" mDetached=");
    writer.print(mDetached);
    writer.print(" mMenuVisible=");
    writer.print(mMenuVisible);
    writer.print(" mHasMenu=");
    writer.println(mHasMenu);
    writer.print(prefix);
    writer.print("mRetainInstance=");
    writer.print(mRetainInstance);
    writer.print(" mRetaining=");
    writer.print(mRetaining);
    writer.print(" mUserVisibleHint=");
    writer.println(mUserVisibleHint);
    if (mFragmentManager != null) {
        writer.print(prefix);
        writer.print("mFragmentManager=");
        writer.println(mFragmentManager);
    }
    if (mHost != null) {
        writer.print(prefix);
        writer.print("mHost=");
        writer.println(mHost);
    }
    if (mParentFragment != null) {
        writer.print(prefix);
        writer.print("mParentFragment=");
        writer.println(mParentFragment);
    }
    if (mArguments != null) {
        writer.print(prefix);
        writer.print("mArguments=");
        writer.println(mArguments);
    }
    if (mSavedFragmentState != null) {
        writer.print(prefix);
        writer.print("mSavedFragmentState=");
        writer.println(mSavedFragmentState);
    }
    if (mSavedViewState != null) {
        writer.print(prefix);
        writer.print("mSavedViewState=");
        writer.println(mSavedViewState);
    }
    if (mTarget != null) {
        writer.print(prefix);
        writer.print("mTarget=");
        writer.print(mTarget);
        writer.print(" mTargetRequestCode=");
        writer.println(mTargetRequestCode);
    }
    if (mNextAnim != 0) {
        writer.print(prefix);
        writer.print("mNextAnim=");
        writer.println(mNextAnim);
    }
    if (mContainer != null) {
        writer.print(prefix);
        writer.print("mContainer=");
        writer.println(mContainer);
    }
    if (mView != null) {
        writer.print(prefix);
        writer.print("mView=");
        writer.println(mView);
    }
    if (mAnimatingAway != null) {
        writer.print(prefix);
        writer.print("mAnimatingAway=");
        writer.println(mAnimatingAway);
        writer.print(prefix);
        writer.print("mStateAfterAnimating=");
        writer.println(mStateAfterAnimating);
    }
    if (mLoaderManager != null) {
        writer.print(prefix);
        writer.println("Loader Manager:");
        mLoaderManager.dump(prefix + "  ", fd, writer, args);
    }
    if (mChildFragmentManager != null) {
        writer.print(prefix);
        writer.println("Child " + mChildFragmentManager + ":");
        mChildFragmentManager.dump(prefix + "  ", fd, writer, args);
    }
}
Body of Second Method:
{
    writer.print(prefix);
    writer.print("mFragmentId=#");
    writer.print(Integer.toHexString(mFragmentId));
    writer.print(" mContainerId=#");
    writer.print(Integer.toHexString(mContainerId));
    writer.print(" mTag=");
    writer.println(mTag);
    writer.print(prefix);
    writer.print("mState=");
    writer.print(mState);
    writer.print(" mIndex=");
    writer.print(mIndex);
    writer.print(" mWho=");
    writer.print(mWho);
    writer.print(" mBackStackNesting=");
    writer.println(mBackStackNesting);
    writer.print(prefix);
    writer.print("mAdded=");
    writer.print(mAdded);
    writer.print(" mRemoving=");
    writer.print(mRemoving);
    writer.print(" mFromLayout=");
    writer.print(mFromLayout);
    writer.print(" mInLayout=");
    writer.println(mInLayout);
    writer.print(prefix);
    writer.print("mHidden=");
    writer.print(mHidden);
    writer.print(" mDetached=");
    writer.print(mDetached);
    writer.print(" mMenuVisible=");
    writer.print(mMenuVisible);
    writer.print(" mHasMenu=");
    writer.println(mHasMenu);
    writer.print(prefix);
    writer.print("mRetainInstance=");
    writer.print(mRetainInstance);
    writer.print(" mRetaining=");
    writer.print(mRetaining);
    writer.print(" mUserVisibleHint=");
    writer.println(mUserVisibleHint);
    if (mFragmentManager != null) {
        writer.print(prefix);
        writer.print("mFragmentManager=");
        writer.println(mFragmentManager);
    }
    if (mHost != null) {
        writer.print(prefix);
        writer.print("mHost=");
        writer.println(mHost);
    }
    if (mParentFragment != null) {
        writer.print(prefix);
        writer.print("mParentFragment=");
        writer.println(mParentFragment);
    }
    if (mArguments != null) {
        writer.print(prefix);
        writer.print("mArguments=");
        writer.println(mArguments);
    }
    if (mSavedFragmentState != null) {
        writer.print(prefix);
        writer.print("mSavedFragmentState=");
        writer.println(mSavedFragmentState);
    }
    if (mSavedViewState != null) {
        writer.print(prefix);
        writer.print("mSavedViewState=");
        writer.println(mSavedViewState);
    }
    if (mTarget != null) {
        writer.print(prefix);
        writer.print("mTarget=");
        writer.print(mTarget);
        writer.print(" mTargetRequestCode=");
        writer.println(mTargetRequestCode);
    }
    if (mNextAnim != 0) {
        writer.print(prefix);
        writer.print("mNextAnim=");
        writer.println(mNextAnim);
    }
    if (mContainer != null) {
        writer.print(prefix);
        writer.print("mContainer=");
        writer.println(mContainer);
    }
    if (mView != null) {
        writer.print(prefix);
        writer.print("mView=");
        writer.println(mView);
    }
    if (mAnimatingAway != null) {
        writer.print(prefix);
        writer.print("mAnimatingAway=");
        writer.println(mAnimatingAway);
        writer.print(prefix);
        writer.print("mStateAfterAnimating=");
        writer.println(mStateAfterAnimating);
    }
    if (mLoaderManager != null) {
        writer.print(prefix);
        writer.println("Loader Manager:");
        mLoaderManager.dump(prefix + "  ", fd, writer, args);
    }
    if (mChildFragmentManager != null) {
        writer.print(prefix);
        writer.println("Child " + mChildFragmentManager + ":");
        mChildFragmentManager.dump(prefix + "  ", fd, writer, args);
    }
}
------------------------
Find a silently evolved API code:android.location.Location.isFromMockProvider:COMMENT
Method Modifier: public      
Comment:/**
 * Returns true if the Location came from a mock provider.
 *
 * @return true if this Location came from a mock provider, false otherwise
 */

Body of Frist Method:
{
    return mIsFromMockProvider;
}
Body of Second Method:
{
    return (mFieldsMask & HAS_MOCK_PROVIDER_MASK) != 0;
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiManager.cancelWps:COMMENT
Method Modifier: public      
Comment:/**
 * Cancel any ongoing Wi-fi Protected Setup
 *
 * @param listener for callbacks on success or failure. Can be null.
 * @throws IllegalStateException if the WifiManager instance needs to be
 * initialized again
 */

Body of Frist Method:
{
    validateChannel();
    sAsyncChannel.sendMessage(CANCEL_WPS, 0, putListener(listener));
}
Body of Second Method:
{
    getChannel().sendMessage(CANCEL_WPS, 0, putListener(listener));
}
------------------------
Find a silently evolved API code:android.nfc.NfcAdapter.getNfcAdapter:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Returns the NfcAdapter for application context,
 * or throws if NFC is not available.
 * @hide
 */

Body of Frist Method:
{
    if (!sIsInitialized) {
        /* is this device meant to have NFC */
        if (!hasNfcFeature()) {
            Log.v(TAG, "this device does not have NFC support");
            throw new UnsupportedOperationException();
        }
        sService = getServiceInterface();
        if (sService == null) {
            Log.e(TAG, "could not retrieve NFC service");
            throw new UnsupportedOperationException();
        }
        try {
            sTagService = sService.getNfcTagInterface();
        } catch (RemoteException e) {
            Log.e(TAG, "could not retrieve NFC Tag service");
            throw new UnsupportedOperationException();
        }
        try {
            sCardEmulationService = sService.getNfcCardEmulationInterface();
        } catch (RemoteException e) {
            Log.e(TAG, "could not retrieve card emulation service");
            throw new UnsupportedOperationException();
        }
        sIsInitialized = true;
    }
    if (context == null) {
        if (sNullContextNfcAdapter == null) {
            sNullContextNfcAdapter = new NfcAdapter(null);
        }
        return sNullContextNfcAdapter;
    }
    NfcAdapter adapter = sNfcAdapters.get(context);
    if (adapter == null) {
        adapter = new NfcAdapter(context);
        sNfcAdapters.put(context, adapter);
    }
    return adapter;
}
Body of Second Method:
{
    if (!sIsInitialized) {
        /* is this device meant to have NFC */
        if (!hasNfcFeature()) {
            Log.v(TAG, "this device does not have NFC support");
            throw new UnsupportedOperationException();
        }
        sService = getServiceInterface();
        if (sService == null) {
            Log.e(TAG, "could not retrieve NFC service");
            throw new UnsupportedOperationException();
        }
        try {
            sTagService = sService.getNfcTagInterface();
        } catch (RemoteException e) {
            Log.e(TAG, "could not retrieve NFC Tag service");
            throw new UnsupportedOperationException();
        }
        try {
            sCardEmulationService = sService.getNfcCardEmulationInterface();
        } catch (RemoteException e) {
            Log.e(TAG, "could not retrieve card emulation service");
            throw new UnsupportedOperationException();
        }
        try {
            sNfcFCardEmulationService = sService.getNfcFCardEmulationInterface();
        } catch (RemoteException e) {
            Log.e(TAG, "could not retrieve NFC-F card emulation service");
            throw new UnsupportedOperationException();
        }
        sIsInitialized = true;
    }
    if (context == null) {
        if (sNullContextNfcAdapter == null) {
            sNullContextNfcAdapter = new NfcAdapter(null);
        }
        return sNullContextNfcAdapter;
    }
    NfcAdapter adapter = sNfcAdapters.get(context);
    if (adapter == null) {
        adapter = new NfcAdapter(context);
        sNfcAdapters.put(context, adapter);
    }
    return adapter;
}
------------------------
Find a silently evolved API code:android.hardware.usb.UsbManager.addFunction:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if ("none".equals(functions)) {
        return function;
    }
    if (!containsFunction(functions, function)) {
        if (functions.length() > 0) {
            functions += ",";
        }
        functions += function;
    }
    return functions;
}
Body of Second Method:
{
    if (USB_FUNCTION_NONE.equals(functions)) {
        return function;
    }
    if (!containsFunction(functions, function)) {
        if (functions.length() > 0) {
            functions += ",";
        }
        functions += function;
    }
    return functions;
}
------------------------
Find a silently evolved API code:android.net.nsd.NsdManager.getMessenger:COMMENT
Method Modifier: private     
Comment:/**
 * Get a reference to NetworkService handler. This is used to establish
 * an AsyncChannel communication with the service
 *
 * @return Messenger pointing to the NetworkService handler
 */

Body of Frist Method:
{
    try {
        return mService.getMessenger();
    } catch (RemoteException e) {
        return null;
    }
}
Body of Second Method:
{
    try {
        return mService.getMessenger();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.os.SystemClock_Delegate.elapsedRealtime:COMMENT
Method Modifier: default     static      
Comment:/**
 * Returns milliseconds since boot, including time spent in sleep.
 *
 * @return elapsed milliseconds since boot.
 */

Body of Frist Method:
{
    return System.currentTimeMillis() - sBootTime;
}
Body of Second Method:
{
    return System_Delegate.currentTimeMillis() - System_Delegate.bootTimeMillis();
}
------------------------
Find a silently evolved API code:android.graphics.Outline.canClip:COMMENT
Method Modifier: public      
Comment:/**
 * Returns whether the outline can be used to clip a View.
 * <p>
 * Currently, only Outlines that can be represented as a rectangle, circle,
 * or round rect support clipping.
 *
 * @see {@link android.view.View#setClipToOutline(boolean)}
 */

Body of Frist Method:
{
    return !isEmpty() && mRect != null;
}
Body of Second Method:
{
    return mMode != MODE_CONVEX_PATH;
}
------------------------
Find a silently evolved API code:android.graphics.drawable.NinePatchDrawable.getOpticalInsets:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (needsMirroring()) {
        return Insets.of(mOpticalInsets.right, mOpticalInsets.top, mOpticalInsets.left, mOpticalInsets.bottom);
    } else {
        return mOpticalInsets;
    }
}
Body of Second Method:
{
    final Insets opticalInsets = mOpticalInsets;
    if (needsMirroring()) {
        return Insets.of(opticalInsets.right, opticalInsets.top, opticalInsets.left, opticalInsets.bottom);
    } else {
        return opticalInsets;
    }
}
------------------------
Find a silently evolved API code:android.telephony.CellIdentityGsm.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Implement the Parcelable interface
 */

Body of Frist Method:
{
    if (DBG)
        log("writeToParcel(Parcel, int): " + toString());
    dest.writeInt(mMcc);
    dest.writeInt(mMnc);
    dest.writeInt(mLac);
    dest.writeInt(mCid);
}
Body of Second Method:
{
    if (DBG)
        log("writeToParcel(Parcel, int): " + toString());
    dest.writeInt(mMcc);
    dest.writeInt(mMnc);
    dest.writeInt(mLac);
    dest.writeInt(mCid);
    dest.writeInt(mArfcn);
    dest.writeInt(mBsic);
}
------------------------
Find a silently evolved API code:android.view.inputmethod.EditorInfo.dump:COMMENT
Method Modifier: public      
Comment:/**
 * Write debug output of this object.
 */

Body of Frist Method:
{
    pw.println(prefix + "inputType=0x" + Integer.toHexString(inputType) + " imeOptions=0x" + Integer.toHexString(imeOptions) + " privateImeOptions=" + privateImeOptions);
    pw.println(prefix + "actionLabel=" + actionLabel + " actionId=" + actionId);
    pw.println(prefix + "initialSelStart=" + initialSelStart + " initialSelEnd=" + initialSelEnd + " initialCapsMode=0x" + Integer.toHexString(initialCapsMode));
    pw.println(prefix + "hintText=" + hintText + " label=" + label);
    pw.println(prefix + "packageName=" + packageName + " fieldId=" + fieldId + " fieldName=" + fieldName);
    pw.println(prefix + "extras=" + extras);
}
Body of Second Method:
{
    pw.println(prefix + "inputType=0x" + Integer.toHexString(inputType) + " imeOptions=0x" + Integer.toHexString(imeOptions) + " privateImeOptions=" + privateImeOptions);
    pw.println(prefix + "actionLabel=" + actionLabel + " actionId=" + actionId);
    pw.println(prefix + "initialSelStart=" + initialSelStart + " initialSelEnd=" + initialSelEnd + " initialCapsMode=0x" + Integer.toHexString(initialCapsMode));
    pw.println(prefix + "hintText=" + hintText + " label=" + label);
    pw.println(prefix + "packageName=" + packageName + " fieldId=" + fieldId + " fieldName=" + fieldName);
    pw.println(prefix + "extras=" + extras);
    pw.println(prefix + "hintLocales=" + hintLocales);
}
------------------------
Find a silently evolved API code:android.media.AudioManager.startBluetoothSco:COMMENT
Method Modifier: public      
Comment:/**
 * Start bluetooth SCO audio connection.
 * <p>Requires Permission:
 * {@link android.Manifest.permission#MODIFY_AUDIO_SETTINGS}.
 * <p>This method can be used by applications wanting to send and received audio
 * to/from a bluetooth SCO headset while the phone is not in call.
 * <p>As the SCO connection establishment can take several seconds,
 * applications should not rely on the connection to be available when the method
 * returns but instead register to receive the intent {@link #ACTION_SCO_AUDIO_STATE_UPDATED}
 * and wait for the state to be {@link #SCO_AUDIO_STATE_CONNECTED}.
 * <p>As the ACTION_SCO_AUDIO_STATE_UPDATED intent is sticky, the application can check the SCO
 * audio state before calling startBluetoothSco() by reading the intent returned by the receiver
 * registration. If the state is already CONNECTED, no state change will be received via the
 * intent after calling startBluetoothSco(). It is however useful to call startBluetoothSco()
 * so that the connection stays active in case the current initiator stops the connection.
 * <p>Unless the connection is already active as described above, the state will always
 * transition from DISCONNECTED to CONNECTING and then either to CONNECTED if the connection
 * succeeds or back to DISCONNECTED if the connection fails (e.g no headset is connected).
 * <p>When finished with the SCO connection or if the establishment fails, the application must
 * call {@link #stopBluetoothSco()} to clear the request and turn down the bluetooth connection.
 * <p>Even if a SCO connection is established, the following restrictions apply on audio
 * output streams so that they can be routed to SCO headset:
 * <ul>
 * <li> the stream type must be {@link #STREAM_VOICE_CALL} </li>
 * <li> the format must be mono </li>
 * <li> the sampling must be 16kHz or 8kHz </li>
 * </ul>
 * <p>The following restrictions apply on input streams:
 * <ul>
 * <li> the format must be mono </li>
 * <li> the sampling must be 8kHz </li>
 * </ul>
 * <p>Note that the phone application always has the priority on the usage of the SCO
 * connection for telephony. If this method is called while the phone is in call
 * it will be ignored. Similarly, if a call is received or sent while an application
 * is using the SCO connection, the connection will be lost for the application and NOT
 * returned automatically when the call ends.
 * <p>NOTE: up to and including API version
 * {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1}, this method initiates a virtual
 * voice call to the bluetooth headset.
 * After API version {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2} only a raw SCO audio
 * connection is established.
 * @see #stopBluetoothSco()
 * @see #ACTION_SCO_AUDIO_STATE_UPDATED
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        service.startBluetoothSco(mICallBack, getContext().getApplicationInfo().targetSdkVersion);
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in startBluetoothSco", e);
    }
}
Body of Second Method:
{
    IAudioService service = getService();
    try {
        service.startBluetoothSco(mICallBack, getContext().getApplicationInfo().targetSdkVersion);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.text.style.LocaleSpan.writeToParcelInternal:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    dest.writeString(mLocale.getLanguage());
    dest.writeString(mLocale.getCountry());
    dest.writeString(mLocale.getVariant());
}
Body of Second Method:
{
    mLocales.writeToParcel(dest, flags);
}
------------------------
Find a silently evolved API code:android.net.NetworkStats.groupedByUid:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Return total statistics grouped by {@link #uid}; doesn't mutate the
 * original structure.
 */

Body of Frist Method:
{
    final NetworkStats stats = new NetworkStats(elapsedRealtime, 10);
    final Entry entry = new Entry();
    entry.iface = IFACE_ALL;
    entry.set = SET_ALL;
    entry.tag = TAG_NONE;
    for (int i = 0; i < size; i++) {
        // skip specific tags, since already counted in TAG_NONE
        if (tag[i] != TAG_NONE)
            continue;
        entry.uid = uid[i];
        entry.rxBytes = rxBytes[i];
        entry.rxPackets = rxPackets[i];
        entry.txBytes = txBytes[i];
        entry.txPackets = txPackets[i];
        entry.operations = operations[i];
        stats.combineValues(entry);
    }
    return stats;
}
Body of Second Method:
{
    final NetworkStats stats = new NetworkStats(elapsedRealtime, 10);
    final Entry entry = new Entry();
    entry.iface = IFACE_ALL;
    entry.set = SET_ALL;
    entry.tag = TAG_NONE;
    entry.roaming = ROAMING_ALL;
    for (int i = 0; i < size; i++) {
        // skip specific tags, since already counted in TAG_NONE
        if (tag[i] != TAG_NONE)
            continue;
        entry.uid = uid[i];
        entry.rxBytes = rxBytes[i];
        entry.rxPackets = rxPackets[i];
        entry.txBytes = txBytes[i];
        entry.txPackets = txPackets[i];
        entry.operations = operations[i];
        stats.combineValues(entry);
    }
    return stats;
}
------------------------
Find a silently evolved API code:android.accounts.AccountManager.addAccount:COMMENT
Method Modifier: public      
Comment:/**
 * Asks the user to add an account of a specified type.  The authenticator
 * for this account type processes this request with the appropriate user
 * interface.  If the user does elect to create a new account, the account
 * name is returned.
 *
 * <p>This method may be called from any thread, but the returned
 * {@link AccountManagerFuture} must not be used on the main thread.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * MANAGE_ACCOUNTS permission is needed for those platforms. See docs for
 * this function in API level 22.
 *
 * @param accountType The type of account to add; must not be null
 * @param authTokenType The type of auth token (see {@link #getAuthToken})
 * this account will need to be able to generate, null for none
 * @param requiredFeatures The features (see {@link #hasFeatures}) this
 * account must have, null for none
 * @param addAccountOptions Authenticator-specific options for the request,
 * may be null or empty
 * @param activity The {@link Activity} context to use for launching a new
 * authenticator-defined sub-Activity to prompt the user to create an
 * account; used only to call startActivity(); if null, the prompt
 * will not be launched directly, but the necessary {@link Intent}
 * will be returned to the caller instead
 * @param callback Callback to invoke when the request completes,
 * null for no callback
 * @param handler {@link Handler} identifying the callback thread,
 * null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to a Bundle with
 * these fields if activity was specified and an account was created:
 * <ul>
 * <li> {@link #KEY_ACCOUNT_NAME} - the name of the account created
 * <li> {@link #KEY_ACCOUNT_TYPE} - the type of the account
 * </ul>
 *
 * If no activity was specified, the returned Bundle contains only
 * {@link #KEY_INTENT} with the {@link Intent} needed to launch the
 * actual account creation process.  If an error occurred,
 * {@link AccountManagerFuture#getResult()} throws:
 * <ul>
 * <li> {@link AuthenticatorException} if no authenticator was registered for
 * this account type or the authenticator failed to respond
 * <li> {@link OperationCanceledException} if the operation was canceled for
 * any reason, including the user canceling the creation process or adding accounts
 * (of this type) has been disabled by policy
 * <li> {@link IOException} if the authenticator experienced an I/O problem
 * creating a new account, usually because of network trouble
 * </ul>
 */

Body of Frist Method:
{
    if (accountType == null)
        throw new IllegalArgumentException("accountType is null");
    final Bundle optionsIn = new Bundle();
    if (addAccountOptions != null) {
        optionsIn.putAll(addAccountOptions);
    }
    optionsIn.putString(KEY_ANDROID_PACKAGE_NAME, mContext.getPackageName());
    return new AmsTask(activity, handler, callback) {

        public void doWork() throws RemoteException {
            mService.addAccount(mResponse, accountType, authTokenType, requiredFeatures, activity != null, optionsIn);
        }
    }.start();
}
Body of Second Method:
{
    if (accountType == null)
        throw new IllegalArgumentException("accountType is null");
    final Bundle optionsIn = new Bundle();
    if (addAccountOptions != null) {
        optionsIn.putAll(addAccountOptions);
    }
    optionsIn.putString(KEY_ANDROID_PACKAGE_NAME, mContext.getPackageName());
    return new AmsTask(activity, handler, callback) {

        @Override
        public void doWork() throws RemoteException {
            mService.addAccount(mResponse, accountType, authTokenType, requiredFeatures, activity != null, optionsIn);
        }
    }.start();
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothAdapter.enable:COMMENT
Method Modifier: public      
Comment:/**
 * Turn on the local Bluetooth adapter&mdash;do not use without explicit
 * user action to turn on Bluetooth.
 * <p>This powers on the underlying Bluetooth hardware, and starts all
 * Bluetooth system services.
 * <p class="caution"><strong>Bluetooth should never be enabled without
 * direct user consent</strong>. If you want to turn on Bluetooth in order
 * to create a wireless connection, you should use the {@link
 * #ACTION_REQUEST_ENABLE} Intent, which will raise a dialog that requests
 * user permission to turn on Bluetooth. The {@link #enable()} method is
 * provided only for applications that include a user interface for changing
 * system settings, such as a "power manager" app.</p>
 * <p>This is an asynchronous call: it will return immediately, and
 * clients should listen for {@link #ACTION_STATE_CHANGED}
 * to be notified of subsequent adapter state changes. If this call returns
 * true, then the adapter state will immediately transition from {@link
 * #STATE_OFF} to {@link #STATE_TURNING_ON}, and some time
 * later transition to either {@link #STATE_OFF} or {@link
 * #STATE_ON}. If this call returns false then there was an
 * immediate problem that will prevent the adapter from being turned on -
 * such as Airplane mode, or the adapter is already turned on.
 * <p>Requires the {@link android.Manifest.permission#BLUETOOTH_ADMIN}
 * permission
 *
 * @return true to indicate adapter startup has begun, or false on
 * immediate error
 */

Body of Frist Method:
{
    int state = STATE_OFF;
    if (isEnabled() == true) {
        if (DBG)
            Log.d(TAG, "enable(): BT is already enabled..!");
        return true;
    }
    // Use service interface to get the exact state
    if (mService != null) {
        try {
            state = mService.getState();
        } catch (RemoteException e) {
            Log.e(TAG, "", e);
        }
    }
    if (state == BluetoothAdapter.STATE_BLE_ON) {
        Log.e(TAG, "BT is in BLE_ON State");
        notifyUserAction(true);
        return true;
    }
    try {
        return mManagerService.enable();
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
Body of Second Method:
{
    if (isEnabled() == true) {
        if (DBG)
            Log.d(TAG, "enable(): BT is already enabled..!");
        return true;
    }
    try {
        return mManagerService.enable();
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
------------------------
Find a silently evolved API code:android.graphics.Bitmap.getConfig:COMMENT
Method Modifier: public      final       
Comment:/**
 * If the bitmap's internal config is in one of the public formats, return
 * that config, otherwise return null.
 */

Body of Frist Method:
{
    if (mRecycled) {
        Log.w(TAG, "Called getConfig() on a recycle()'d bitmap! This is undefined behavior!");
    }
    return Config.nativeToConfig(nativeConfig(mFinalizer.mNativeBitmap));
}
Body of Second Method:
{
    if (mRecycled) {
        Log.w(TAG, "Called getConfig() on a recycle()'d bitmap! This is undefined behavior!");
    }
    return Config.nativeToConfig(nativeConfig(mNativePtr));
}
------------------------
Find a silently evolved API code:android.widget.AbsSeekBar.performAccessibilityActionInternal:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (super.performAccessibilityActionInternal(action, arguments)) {
        return true;
    }
    if (!isEnabled()) {
        return false;
    }
    if (action == AccessibilityNodeInfo.ACTION_SCROLL_FORWARD || action == AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD) {
        int increment = Math.max(1, Math.round((float) getMax() / 5));
        if (action == AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD) {
            increment = -increment;
        }
        // Let progress bar handle clamping values.
        if (setProgress(getProgress() + increment, true)) {
            onKeyChange();
            return true;
        }
        return false;
    }
    return false;
}
Body of Second Method:
{
    if (super.performAccessibilityActionInternal(action, arguments)) {
        return true;
    }
    if (!isEnabled()) {
        return false;
    }
    switch(action) {
        case R.id.accessibilityActionSetProgress:
            {
                if (!canUserSetProgress()) {
                    return false;
                }
                if (arguments == null || !arguments.containsKey(AccessibilityNodeInfo.ACTION_ARGUMENT_PROGRESS_VALUE)) {
                    return false;
                }
                float value = arguments.getFloat(AccessibilityNodeInfo.ACTION_ARGUMENT_PROGRESS_VALUE);
                return setProgressInternal((int) value, true, true);
            }
        case AccessibilityNodeInfo.ACTION_SCROLL_FORWARD:
        case AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD:
            {
                if (!canUserSetProgress()) {
                    return false;
                }
                int increment = Math.max(1, Math.round((float) getMax() / 20));
                if (action == AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD) {
                    increment = -increment;
                }
                // Let progress bar handle clamping values.
                if (setProgressInternal(getProgress() + increment, true, true)) {
                    onKeyChange();
                    return true;
                }
                return false;
            }
    }
    return false;
}
------------------------
Find a silently evolved API code:android.graphics.Bitmap.recycle:COMMENT
Method Modifier: public      
Comment:/**
 * Free the native object associated with this bitmap, and clear the
 * reference to the pixel data. This will not free the pixel data synchronously;
 * it simply allows it to be garbage collected if there are no other references.
 * The bitmap is marked as "dead", meaning it will throw an exception if
 * getPixels() or setPixels() is called, and will draw nothing. This operation
 * cannot be reversed, so it should only be called if you are sure there are no
 * further uses for the bitmap. This is an advanced call, and normally need
 * not be called, since the normal GC process will free up this memory when
 * there are no more references to this bitmap.
 */

Body of Frist Method:
{
    if (!mRecycled && mFinalizer.mNativeBitmap != 0) {
        if (nativeRecycle(mFinalizer.mNativeBitmap)) {
            // return value indicates whether native pixel object was actually recycled.
            // false indicates that it is still in use at the native level and these
            // objects should not be collected now. They will be collected later when the
            // Bitmap itself is collected.
            mBuffer = null;
            mNinePatchChunk = null;
        }
        mRecycled = true;
    }
}
Body of Second Method:
{
    if (!mRecycled && mNativePtr != 0) {
        if (nativeRecycle(mNativePtr)) {
            // return value indicates whether native pixel object was actually recycled.
            // false indicates that it is still in use at the native level and these
            // objects should not be collected now. They will be collected later when the
            // Bitmap itself is collected.
            mBuffer = null;
            mNinePatchChunk = null;
        }
        mRecycled = true;
    }
}
------------------------
Find a silently evolved API code:android.app.Instrumentation.execStartActivitiesAsUser:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Like {@link #execStartActivity(Context, IBinder, IBinder, Activity, Intent, int, Bundle)},
 * but accepts an array of activities to be started.  Note that active
 * {@link ActivityMonitor} objects only match against the first activity in
 * the array.
 *
 * {@hide}
 */

Body of Frist Method:
{
    IApplicationThread whoThread = (IApplicationThread) contextThread;
    if (mActivityMonitors != null) {
        synchronized (mSync) {
            final int N = mActivityMonitors.size();
            for (int i = 0; i < N; i++) {
                final ActivityMonitor am = mActivityMonitors.get(i);
                if (am.match(who, null, intents[0])) {
                    am.mHits++;
                    if (am.isBlocking()) {
                        return;
                    }
                    break;
                }
            }
        }
    }
    try {
        String[] resolvedTypes = new String[intents.length];
        for (int i = 0; i < intents.length; i++) {
            intents[i].migrateExtraStreamToClipData();
            intents[i].prepareToLeaveProcess();
            resolvedTypes[i] = intents[i].resolveTypeIfNeeded(who.getContentResolver());
        }
        int result = ActivityManagerNative.getDefault().startActivities(whoThread, who.getBasePackageName(), intents, resolvedTypes, token, options, userId);
        checkStartActivityResult(result, intents[0]);
    } catch (RemoteException e) {
        throw new RuntimeException("Failure from system", e);
    }
}
Body of Second Method:
{
    IApplicationThread whoThread = (IApplicationThread) contextThread;
    if (mActivityMonitors != null) {
        synchronized (mSync) {
            final int N = mActivityMonitors.size();
            for (int i = 0; i < N; i++) {
                final ActivityMonitor am = mActivityMonitors.get(i);
                if (am.match(who, null, intents[0])) {
                    am.mHits++;
                    if (am.isBlocking()) {
                        return;
                    }
                    break;
                }
            }
        }
    }
    try {
        String[] resolvedTypes = new String[intents.length];
        for (int i = 0; i < intents.length; i++) {
            intents[i].migrateExtraStreamToClipData();
            intents[i].prepareToLeaveProcess(who);
            resolvedTypes[i] = intents[i].resolveTypeIfNeeded(who.getContentResolver());
        }
        int result = ActivityManagerNative.getDefault().startActivities(whoThread, who.getBasePackageName(), intents, resolvedTypes, token, options, userId);
        checkStartActivityResult(result, intents[0]);
    } catch (RemoteException e) {
        throw new RuntimeException("Failure from system", e);
    }
}
------------------------
Find a silently evolved API code:android.util.ArraySet.indexOf:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the index of a value in the set.
 *
 * @param key The value to search for.
 * @return Returns the index of the value if it exists, else a negative integer.
 */

Body of Frist Method:
{
    return key == null ? indexOfNull() : indexOf(key, key.hashCode());
}
Body of Second Method:
{
    return key == null ? indexOfNull() : indexOf(key, mIdentityHashCode ? System.identityHashCode(key) : key.hashCode());
}
------------------------
Find a silently evolved API code:android.accounts.AccountManager.getAuthenticatorTypes:COMMENT
Method Modifier: public      
Comment:/**
 * Lists the currently registered authenticators.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>No permission is required to call this method.
 *
 * @return An array of {@link AuthenticatorDescription} for every
 * authenticator known to the AccountManager service.  Empty (never
 * null) if no authenticators are known.
 */

Body of Frist Method:
{
    try {
        return mService.getAuthenticatorTypes(UserHandle.getCallingUserId());
    } catch (RemoteException e) {
        // will never happen
        throw new RuntimeException(e);
    }
}
Body of Second Method:
{
    try {
        return mService.getAuthenticatorTypes(UserHandle.getCallingUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.view.HardwareLayer.setLayerPaint:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Update the paint used when drawing this layer.
 *
 * @param paint The paint used when the layer is drawn into the destination canvas.
 * @see View#setLayerPaint(android.graphics.Paint)
 */

Body of Frist Method:
{
    nSetLayerPaint(mFinalizer.get(), paint.getNativeInstance());
    mRenderer.pushLayerUpdate(this);
}
Body of Second Method:
{
    nSetLayerPaint(mFinalizer.get(), paint != null ? paint.getNativeInstance() : 0);
    mRenderer.pushLayerUpdate(this);
}
------------------------
Find a silently evolved API code:android.net.ConnectivityManager.isActiveNetworkMetered:COMMENT
Method Modifier: public      
Comment:/**
 * Returns if the currently active data network is metered. A network is
 * classified as metered when the user is sensitive to heavy data usage on
 * that connection due to monetary costs, data limitations or
 * battery/performance issues. You should check this before doing large
 * data transfers, and warn the user or delay the operation until another
 * network is available.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
 *
 * @return {@code true} if large transfers should be avoided, otherwise
 * {@code false}.
 */

Body of Frist Method:
{
    try {
        return mService.isActiveNetworkMetered();
    } catch (RemoteException e) {
        return false;
    }
}
Body of Second Method:
{
    try {
        return mService.isActiveNetworkMetered();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.widget.TimePicker.getCurrentHour:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * @return the current hour in the range (0-23)
 * @deprecated Use {@link #getHour()}
 */

Body of Frist Method:
{
    return mDelegate.getCurrentHour();
}
Body of Second Method:
{
    return mDelegate.getHour();
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiManager.setCountryCode:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Set the country code.
 * @param countryCode country code in ISO 3166 format.
 * @param persist {@code true} if this needs to be remembered
 *
 * @hide
 */

Body of Frist Method:
{
    try {
        mService.setCountryCode(country, persist);
    } catch (RemoteException e) {
    }
}
Body of Second Method:
{
    try {
        mService.setCountryCode(country, persist);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.net.ConnectivityManager.setAirplaneMode:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Set the value for enabling/disabling airplane mode
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#CONNECTIVITY_INTERNAL}.
 *
 * @param enable whether to enable airplane mode or not
 *
 * @hide
 */

Body of Frist Method:
{
    try {
        mService.setAirplaneMode(enable);
    } catch (RemoteException e) {
    }
}
Body of Second Method:
{
    try {
        mService.setAirplaneMode(enable);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.media.ThumbnailUtils.createImageThumbnail:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * This method first examines if the thumbnail embedded in EXIF is bigger than our target
 * size. If not, then it'll create a thumbnail from original image. Due to efficiency
 * consideration, we want to let MediaThumbRequest avoid calling this method twice for
 * both kinds, so it only requests for MICRO_KIND and set saveImage to true.
 *
 * This method always returns a "square thumbnail" for MICRO_KIND thumbnail.
 *
 * @param filePath the path of image file
 * @param kind could be MINI_KIND or MICRO_KIND
 * @return Bitmap, or null on failures
 *
 * @hide This method is only used by media framework and media provider internally.
 */

Body of Frist Method:
{
    boolean wantMini = (kind == Images.Thumbnails.MINI_KIND);
    int targetSize = wantMini ? TARGET_SIZE_MINI_THUMBNAIL : TARGET_SIZE_MICRO_THUMBNAIL;
    int maxPixels = wantMini ? MAX_NUM_PIXELS_THUMBNAIL : MAX_NUM_PIXELS_MICRO_THUMBNAIL;
    SizedThumbnailBitmap sizedThumbnailBitmap = new SizedThumbnailBitmap();
    Bitmap bitmap = null;
    MediaFileType fileType = MediaFile.getFileType(filePath);
    if (fileType != null && fileType.fileType == MediaFile.FILE_TYPE_JPEG) {
        createThumbnailFromEXIF(filePath, targetSize, maxPixels, sizedThumbnailBitmap);
        bitmap = sizedThumbnailBitmap.mBitmap;
    }
    if (bitmap == null) {
        FileInputStream stream = null;
        try {
            stream = new FileInputStream(filePath);
            FileDescriptor fd = stream.getFD();
            BitmapFactory.Options options = new BitmapFactory.Options();
            options.inSampleSize = 1;
            options.inJustDecodeBounds = true;
            BitmapFactory.decodeFileDescriptor(fd, null, options);
            if (options.mCancel || options.outWidth == -1 || options.outHeight == -1) {
                return null;
            }
            options.inSampleSize = computeSampleSize(options, targetSize, maxPixels);
            options.inJustDecodeBounds = false;
            options.inDither = false;
            options.inPreferredConfig = Bitmap.Config.ARGB_8888;
            bitmap = BitmapFactory.decodeFileDescriptor(fd, null, options);
        } catch (IOException ex) {
            Log.e(TAG, "", ex);
        } catch (OutOfMemoryError oom) {
            Log.e(TAG, "Unable to decode file " + filePath + ". OutOfMemoryError.", oom);
        } finally {
            try {
                if (stream != null) {
                    stream.close();
                }
            } catch (IOException ex) {
                Log.e(TAG, "", ex);
            }
        }
    }
    if (kind == Images.Thumbnails.MICRO_KIND) {
        // now we make it a "square thumbnail" for MICRO_KIND thumbnail
        bitmap = extractThumbnail(bitmap, TARGET_SIZE_MICRO_THUMBNAIL, TARGET_SIZE_MICRO_THUMBNAIL, OPTIONS_RECYCLE_INPUT);
    }
    return bitmap;
}
Body of Second Method:
{
    boolean wantMini = (kind == Images.Thumbnails.MINI_KIND);
    int targetSize = wantMini ? TARGET_SIZE_MINI_THUMBNAIL : TARGET_SIZE_MICRO_THUMBNAIL;
    int maxPixels = wantMini ? MAX_NUM_PIXELS_THUMBNAIL : MAX_NUM_PIXELS_MICRO_THUMBNAIL;
    SizedThumbnailBitmap sizedThumbnailBitmap = new SizedThumbnailBitmap();
    Bitmap bitmap = null;
    MediaFileType fileType = MediaFile.getFileType(filePath);
    if (fileType != null && (fileType.fileType == MediaFile.FILE_TYPE_JPEG || MediaFile.isRawImageFileType(fileType.fileType))) {
        createThumbnailFromEXIF(filePath, targetSize, maxPixels, sizedThumbnailBitmap);
        bitmap = sizedThumbnailBitmap.mBitmap;
    }
    if (bitmap == null) {
        FileInputStream stream = null;
        try {
            stream = new FileInputStream(filePath);
            FileDescriptor fd = stream.getFD();
            BitmapFactory.Options options = new BitmapFactory.Options();
            options.inSampleSize = 1;
            options.inJustDecodeBounds = true;
            BitmapFactory.decodeFileDescriptor(fd, null, options);
            if (options.mCancel || options.outWidth == -1 || options.outHeight == -1) {
                return null;
            }
            options.inSampleSize = computeSampleSize(options, targetSize, maxPixels);
            options.inJustDecodeBounds = false;
            options.inDither = false;
            options.inPreferredConfig = Bitmap.Config.ARGB_8888;
            bitmap = BitmapFactory.decodeFileDescriptor(fd, null, options);
        } catch (IOException ex) {
            Log.e(TAG, "", ex);
        } catch (OutOfMemoryError oom) {
            Log.e(TAG, "Unable to decode file " + filePath + ". OutOfMemoryError.", oom);
        } finally {
            try {
                if (stream != null) {
                    stream.close();
                }
            } catch (IOException ex) {
                Log.e(TAG, "", ex);
            }
        }
    }
    if (kind == Images.Thumbnails.MICRO_KIND) {
        // now we make it a "square thumbnail" for MICRO_KIND thumbnail
        bitmap = extractThumbnail(bitmap, TARGET_SIZE_MICRO_THUMBNAIL, TARGET_SIZE_MICRO_THUMBNAIL, OPTIONS_RECYCLE_INPUT);
    }
    return bitmap;
}
------------------------
Find a silently evolved API code:android.media.AudioManager.getStreamVolume:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the current volume index for a particular stream.
 *
 * @param streamType The stream type whose volume index is returned.
 * @return The current volume index for the stream.
 * @see #getStreamMaxVolume(int)
 * @see #setStreamVolume(int, int, int)
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        return service.getStreamVolume(streamType);
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in getStreamVolume", e);
        return 0;
    }
}
Body of Second Method:
{
    IAudioService service = getService();
    try {
        return service.getStreamVolume(streamType);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.media.AudioManager.isAudioFocusExclusive:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 * Checks whether the current audio focus is exclusive.
 * @return true if the top of the audio focus stack requested focus
 * with {@link #AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE}
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        return service.getCurrentAudioFocus() == AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE;
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in isAudioFocusExclusive()", e);
        return false;
    }
}
Body of Second Method:
{
    IAudioService service = getService();
    try {
        return service.getCurrentAudioFocus() == AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.graphics.drawable.LayerDrawable.inflateLayers:COMMENT
Method Modifier: private     
Comment:/**
 * Inflates child layers using the specified parser.
 */

Body of Frist Method:
{
    final LayerState state = mLayerState;
    final int innerDepth = parser.getDepth() + 1;
    int type;
    int depth;
    while ((type = parser.next()) != XmlPullParser.END_DOCUMENT && ((depth = parser.getDepth()) >= innerDepth || type != XmlPullParser.END_TAG)) {
        if (type != XmlPullParser.START_TAG) {
            continue;
        }
        if (depth > innerDepth || !parser.getName().equals("item")) {
            continue;
        }
        final ChildDrawable layer = new ChildDrawable();
        final TypedArray a = obtainAttributes(r, theme, attrs, R.styleable.LayerDrawableItem);
        updateLayerFromTypedArray(layer, a);
        a.recycle();
        // element.
        if (layer.mDrawable == null && (layer.mThemeAttrs == null || layer.mThemeAttrs[R.styleable.LayerDrawableItem_drawable] == 0)) {
            while ((type = parser.next()) == XmlPullParser.TEXT) {
            }
            if (type != XmlPullParser.START_TAG) {
                throw new XmlPullParserException(parser.getPositionDescription() + ": <item> tag requires a 'drawable' attribute or " + "child tag defining a drawable");
            }
            layer.mDrawable = Drawable.createFromXmlInner(r, parser, attrs, theme);
        }
        if (layer.mDrawable != null) {
            state.mChildrenChangingConfigurations |= layer.mDrawable.getChangingConfigurations();
            layer.mDrawable.setCallback(this);
        }
        addLayer(layer);
    }
}
Body of Second Method:
{
    final LayerState state = mLayerState;
    final int innerDepth = parser.getDepth() + 1;
    int type;
    int depth;
    while ((type = parser.next()) != XmlPullParser.END_DOCUMENT && ((depth = parser.getDepth()) >= innerDepth || type != XmlPullParser.END_TAG)) {
        if (type != XmlPullParser.START_TAG) {
            continue;
        }
        if (depth > innerDepth || !parser.getName().equals("item")) {
            continue;
        }
        final ChildDrawable layer = new ChildDrawable(state.mDensity);
        final TypedArray a = obtainAttributes(r, theme, attrs, R.styleable.LayerDrawableItem);
        updateLayerFromTypedArray(layer, a);
        a.recycle();
        // element.
        if (layer.mDrawable == null && (layer.mThemeAttrs == null || layer.mThemeAttrs[R.styleable.LayerDrawableItem_drawable] == 0)) {
            while ((type = parser.next()) == XmlPullParser.TEXT) {
            }
            if (type != XmlPullParser.START_TAG) {
                throw new XmlPullParserException(parser.getPositionDescription() + ": <item> tag requires a 'drawable' attribute or " + "child tag defining a drawable");
            }
            layer.mDrawable = Drawable.createFromXmlInner(r, parser, attrs, theme);
        }
        if (layer.mDrawable != null) {
            state.mChildrenChangingConfigurations |= layer.mDrawable.getChangingConfigurations();
            layer.mDrawable.setCallback(this);
        }
        addLayer(layer);
    }
}
------------------------
Find a silently evolved API code:android.graphics.Path_Delegate.lineTo:COMMENT
<android.graphics.Path_Delegate: void lineTo(float,float)>
private     ->public      
Method Modifier: public      private     
Method Modifier: No          Yes         
Method Updated:  Yes         No          
Comment:/**
 * Add a line from the last point to the specified point (x,y).
 * If no moveTo() call has been made for this contour, the first point is
 * automatically set to (0,0).
 *
 * @param x The x-coordinate of the end of a line
 * @param y The y-coordinate of the end of a line
 */

Body of Frist Method:
{
    if (isEmpty()) {
        mPath.moveTo(mLastX = 0, mLastY = 0);
    }
    mPath.lineTo(mLastX = x, mLastY = y);
}
Body of Second Method:
{
    if (!hasPoints()) {
        mPath.moveTo(mLastX = 0, mLastY = 0);
    }
    mPath.lineTo(mLastX = x, mLastY = y);
}
------------------------
Find a silently evolved API code:android.media.AudioManager.getRingtonePlayer:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * {@hide}
 */

Body of Frist Method:
{
    try {
        return getService().getRingtonePlayer();
    } catch (RemoteException e) {
        return null;
    }
}
Body of Second Method:
{
    try {
        return getService().getRingtonePlayer();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.media.midi.MidiManager.getDevices:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the list of all connected MIDI devices.
 *
 * @return an array of all MIDI devices
 */

Body of Frist Method:
{
    try {
        return mService.getDevices();
    } catch (RemoteException e) {
        Log.e(TAG, "RemoteException in getDevices");
        return new MidiDeviceInfo[0];
    }
}
Body of Second Method:
{
    try {
        return mService.getDevices();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.os.PowerManager.nap:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Forces the device to start napping.
 * <p>
 * If the device is currently awake, starts dreaming, otherwise does nothing.
 * When the dream ends or if the dream cannot be started, the device will
 * either wake up or go to sleep depending on whether there has been recent
 * user activity.
 * </p><p>
 * Requires the {@link android.Manifest.permission#DEVICE_POWER} permission.
 * </p>
 *
 * @param time The time when the request to nap was issued, in the
 * {@link SystemClock#uptimeMillis()} time base.  This timestamp is used to correctly
 * order the nap request with other power management functions.  It should be set
 * to the timestamp of the input event that caused the request to nap.
 *
 * @see #wakeUp
 * @see #goToSleep
 *
 * @hide Requires signature permission.
 */

Body of Frist Method:
{
    try {
        mService.nap(time);
    } catch (RemoteException e) {
    }
}
Body of Second Method:
{
    try {
        mService.nap(time);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiManager.enableNetwork:COMMENT
Method Modifier: public      
Comment:/**
 * Allow a previously configured network to be associated with. If
 * <code>disableOthers</code> is true, then all other configured
 * networks are disabled, and an attempt to connect to the selected
 * network is initiated. This may result in the asynchronous delivery
 * of state change events.
 * <p>
 * <b>Note:</b> If an application's target SDK version is
 * {@link android.os.Build.VERSION_CODES#LOLLIPOP} or newer, network
 * communication may not use Wi-Fi even if Wi-Fi is connected; traffic may
 * instead be sent through another network, such as cellular data,
 * Bluetooth tethering, or Ethernet. For example, traffic will never use a
 * Wi-Fi network that does not provide Internet access (e.g. a wireless
 * printer), if another network that does offer Internet access (e.g.
 * cellular data) is available. Applications that need to ensure that their
 * network traffic uses Wi-Fi should use APIs such as
 * {@link Network#bindSocket(java.net.Socket)},
 * {@link Network#openConnection(java.net.URL)}, or
 * {@link ConnectivityManager#bindProcessToNetwork} to do so.
 *
 * @param netId the ID of the network in the list of configured networks
 * @param disableOthers if true, disable all other networks. The way to
 * select a particular network to connect to is specify {@code true}
 * for this parameter.
 * @return {@code true} if the operation succeeded
 */

Body of Frist Method:
{
    final boolean pin = disableOthers && mTargetSdkVersion < Build.VERSION_CODES.LOLLIPOP;
    if (pin) {
        registerPinningNetworkCallback();
    }
    boolean success;
    try {
        success = mService.enableNetwork(netId, disableOthers);
    } catch (RemoteException e) {
        success = false;
    }
    if (pin && !success) {
        unregisterPinningNetworkCallback();
    }
    return success;
}
Body of Second Method:
{
    final boolean pin = disableOthers && mTargetSdkVersion < Build.VERSION_CODES.LOLLIPOP;
    if (pin) {
        NetworkRequest request = new NetworkRequest.Builder().clearCapabilities().addTransportType(NetworkCapabilities.TRANSPORT_WIFI).build();
        NetworkPinner.pin(mContext, request);
    }
    boolean success;
    try {
        success = mService.enableNetwork(netId, disableOthers);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
    if (pin && !success) {
        NetworkPinner.unpin();
    }
    return success;
}
------------------------
Find a silently evolved API code:android.app.WallpaperManager.forgetLoadedWallpaper:COMMENT
Method Modifier: public      
Comment:/**
 * Remove all internal references to the last loaded wallpaper.  Useful
 * for apps that want to reduce memory usage when they only temporarily
 * need to have the wallpaper.  After calling, the next request for the
 * wallpaper will require reloading it again from disk.
 */

Body of Frist Method:
{
    if (isWallpaperSupported()) {
        sGlobals.forgetLoadedWallpaper();
    }
}
Body of Second Method:
{
    sGlobals.forgetLoadedWallpaper();
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiManager.startWps:COMMENT
Method Modifier: public      
Comment:/**
 * Start Wi-fi Protected Setup
 *
 * @param config WPS configuration (does not support {@link WpsInfo#LABEL})
 * @param listener for callbacks on success or failure. Can be null.
 * @throws IllegalStateException if the WifiManager instance needs to be
 * initialized again
 */

Body of Frist Method:
{
    if (config == null)
        throw new IllegalArgumentException("config cannot be null");
    validateChannel();
    sAsyncChannel.sendMessage(START_WPS, 0, putListener(listener), config);
}
Body of Second Method:
{
    if (config == null)
        throw new IllegalArgumentException("config cannot be null");
    getChannel().sendMessage(START_WPS, 0, putListener(listener), config);
}
------------------------
Find a silently evolved API code:android.net.NetworkTemplate.matches:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Test if given {@link NetworkIdentity} matches this template.
 */

Body of Frist Method:
{
    switch(mMatchRule) {
        case MATCH_MOBILE_ALL:
            return matchesMobile(ident);
        case MATCH_MOBILE_3G_LOWER:
            return matchesMobile3gLower(ident);
        case MATCH_MOBILE_4G:
            return matchesMobile4g(ident);
        case MATCH_WIFI:
            return matchesWifi(ident);
        case MATCH_ETHERNET:
            return matchesEthernet(ident);
        case MATCH_MOBILE_WILDCARD:
            return matchesMobileWildcard(ident);
        case MATCH_WIFI_WILDCARD:
            return matchesWifiWildcard(ident);
        case MATCH_BLUETOOTH:
            return matchesBluetooth(ident);
        default:
            throw new IllegalArgumentException("unknown network template");
    }
}
Body of Second Method:
{
    switch(mMatchRule) {
        case MATCH_MOBILE_ALL:
            return matchesMobile(ident);
        case MATCH_MOBILE_3G_LOWER:
            return matchesMobile3gLower(ident);
        case MATCH_MOBILE_4G:
            return matchesMobile4g(ident);
        case MATCH_WIFI:
            return matchesWifi(ident);
        case MATCH_ETHERNET:
            return matchesEthernet(ident);
        case MATCH_MOBILE_WILDCARD:
            return matchesMobileWildcard(ident);
        case MATCH_WIFI_WILDCARD:
            return matchesWifiWildcard(ident);
        case MATCH_BLUETOOTH:
            return matchesBluetooth(ident);
        case MATCH_PROXY:
            return matchesProxy(ident);
        default:
            throw new IllegalArgumentException("unknown network template");
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiManager.WifiLock.release:COMMENT
Method Modifier: public      
Comment:/**
 * Unlocks the Wi-Fi radio, allowing it to turn off when the device is idle.
 *
 * If this WifiLock is reference-counted, each call to {@code release} will decrement the
 * reference count, and the radio will be unlocked only when the reference count reaches
 * zero.  If the reference count goes below zero (that is, if {@code release} is called
 * a greater number of times than {@link #acquire}), an exception is thrown.
 *
 * If this WifiLock is not reference-counted, the first call to {@code release} (after
 * the radio was locked using {@link #acquire}) will unlock the radio, and subsequent
 * calls will be ignored.
 */

Body of Frist Method:
{
    synchronized (mBinder) {
        if (mRefCounted ? (--mRefCount == 0) : (mHeld)) {
            try {
                mService.releaseWifiLock(mBinder);
                synchronized (WifiManager.this) {
                    mActiveLockCount--;
                }
            } catch (RemoteException ignore) {
            }
            mHeld = false;
        }
        if (mRefCount < 0) {
            throw new RuntimeException("WifiLock under-locked " + mTag);
        }
    }
}
Body of Second Method:
{
    synchronized (mBinder) {
        if (mRefCounted ? (--mRefCount == 0) : (mHeld)) {
            try {
                mService.releaseWifiLock(mBinder);
                synchronized (WifiManager.this) {
                    mActiveLockCount--;
                }
            } catch (RemoteException e) {
                throw e.rethrowFromSystemServer();
            }
            mHeld = false;
        }
        if (mRefCount < 0) {
            throw new RuntimeException("WifiLock under-locked " + mTag);
        }
    }
}
------------------------
Find a silently evolved API code:android.hardware.ConsumerIrManager.transmit:COMMENT
Method Modifier: public      
Comment:/**
 * Transmit an infrared pattern
 * <p>
 * This method is synchronous; when it returns the pattern has
 * been transmitted. Only patterns shorter than 2 seconds will
 * be transmitted.
 * </p>
 *
 * @param carrierFrequency The IR carrier frequency in Hertz.
 * @param pattern The alternating on/off pattern in microseconds to transmit.
 */

Body of Frist Method:
{
    if (mService == null) {
        Log.w(TAG, "failed to transmit; no consumer ir service.");
        return;
    }
    try {
        mService.transmit(mPackageName, carrierFrequency, pattern);
    } catch (RemoteException e) {
        Log.w(TAG, "failed to transmit.", e);
    }
}
Body of Second Method:
{
    if (mService == null) {
        Log.w(TAG, "failed to transmit; no consumer ir service.");
        return;
    }
    try {
        mService.transmit(mPackageName, carrierFrequency, pattern);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.app.WallpaperManager.peekFastDrawable:COMMENT
Method Modifier: public      
Comment:/**
 * Like {@link #getFastDrawable()}, but if there is no wallpaper set,
 * a null pointer is returned.
 *
 * @return Returns an optimized Drawable object that will draw the
 * wallpaper or a null pointer if these is none.
 */

Body of Frist Method:
{
    Bitmap bm = sGlobals.peekWallpaperBitmap(mContext, false);
    if (bm != null) {
        return new FastBitmapDrawable(bm);
    }
    return null;
}
Body of Second Method:
{
    Bitmap bm = sGlobals.peekWallpaperBitmap(mContext, false, FLAG_SYSTEM);
    if (bm != null) {
        return new FastBitmapDrawable(bm);
    }
    return null;
}
------------------------
Find a silently evolved API code:android.app.WallpaperManager.sendWallpaperCommand:COMMENT
Method Modifier: public      
Comment:/**
 * Send an arbitrary command to the current active wallpaper.
 *
 * @param windowToken The window who these offsets should be associated
 * with, as returned by {@link android.view.View#getWindowToken()
 * View.getWindowToken()}.
 * @param action Name of the command to perform.  This must be a scoped
 * name to avoid collisions, such as "com.mycompany.wallpaper.DOIT".
 * @param x Arbitrary integer argument based on command.
 * @param y Arbitrary integer argument based on command.
 * @param z Arbitrary integer argument based on command.
 * @param extras Optional additional information for the command, or null.
 */

Body of Frist Method:
{
    try {
        // Log.v(TAG, "Sending new wallpaper offsets from app...");
        WindowManagerGlobal.getWindowSession().sendWallpaperCommand(windowToken, action, x, y, z, extras, false);
    // Log.v(TAG, "...app returning after sending offsets!");
    } catch (RemoteException e) {
    // Ignore.
    }
}
Body of Second Method:
{
    try {
        // Log.v(TAG, "Sending new wallpaper offsets from app...");
        WindowManagerGlobal.getWindowSession().sendWallpaperCommand(windowToken, action, x, y, z, extras, false);
    // Log.v(TAG, "...app returning after sending offsets!");
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.graphics.drawable.NinePatchDrawable.updateStateFromTypedArray:COMMENT
Method Modifier: private     
Comment:/**
 * Updates the constant state from the values in the typed array.
 */

Body of Frist Method:
{
    final Resources r = a.getResources();
    final NinePatchState state = mNinePatchState;
    // Account for any configuration changes.
    state.mChangingConfigurations |= a.getChangingConfigurations();
    // Extract the theme attributes, if any.
    state.mThemeAttrs = a.extractThemeAttrs();
    state.mDither = a.getBoolean(R.styleable.NinePatchDrawable_dither, state.mDither);
    final int srcResId = a.getResourceId(R.styleable.NinePatchDrawable_src, 0);
    if (srcResId != 0) {
        final BitmapFactory.Options options = new BitmapFactory.Options();
        options.inDither = !state.mDither;
        options.inScreenDensity = r.getDisplayMetrics().noncompatDensityDpi;
        final Rect padding = new Rect();
        final Rect opticalInsets = new Rect();
        Bitmap bitmap = null;
        try {
            final TypedValue value = new TypedValue();
            final InputStream is = r.openRawResource(srcResId, value);
            bitmap = BitmapFactory.decodeResourceStream(r, value, is, padding, options);
            is.close();
        } catch (IOException e) {
        // Ignore
        }
        if (bitmap == null) {
            throw new XmlPullParserException(a.getPositionDescription() + ": <nine-patch> requires a valid src attribute");
        } else if (bitmap.getNinePatchChunk() == null) {
            throw new XmlPullParserException(a.getPositionDescription() + ": <nine-patch> requires a valid 9-patch source image");
        }
        bitmap.getOpticalInsets(opticalInsets);
        state.mNinePatch = new NinePatch(bitmap, bitmap.getNinePatchChunk());
        state.mPadding = padding;
        state.mOpticalInsets = Insets.of(opticalInsets);
    }
    state.mAutoMirrored = a.getBoolean(R.styleable.NinePatchDrawable_autoMirrored, state.mAutoMirrored);
    state.mBaseAlpha = a.getFloat(R.styleable.NinePatchDrawable_alpha, state.mBaseAlpha);
    final int tintMode = a.getInt(R.styleable.NinePatchDrawable_tintMode, -1);
    if (tintMode != -1) {
        state.mTintMode = Drawable.parseTintMode(tintMode, Mode.SRC_IN);
    }
    final ColorStateList tint = a.getColorStateList(R.styleable.NinePatchDrawable_tint);
    if (tint != null) {
        state.mTint = tint;
    }
    final int densityDpi = r.getDisplayMetrics().densityDpi;
    state.mTargetDensity = densityDpi == 0 ? DisplayMetrics.DENSITY_DEFAULT : densityDpi;
}
Body of Second Method:
{
    final Resources r = a.getResources();
    final NinePatchState state = mNinePatchState;
    // Account for any configuration changes.
    state.mChangingConfigurations |= a.getChangingConfigurations();
    // Extract the theme attributes, if any.
    state.mThemeAttrs = a.extractThemeAttrs();
    state.mDither = a.getBoolean(R.styleable.NinePatchDrawable_dither, state.mDither);
    final int srcResId = a.getResourceId(R.styleable.NinePatchDrawable_src, 0);
    if (srcResId != 0) {
        final BitmapFactory.Options options = new BitmapFactory.Options();
        options.inDither = !state.mDither;
        options.inScreenDensity = r.getDisplayMetrics().noncompatDensityDpi;
        final Rect padding = new Rect();
        final Rect opticalInsets = new Rect();
        Bitmap bitmap = null;
        try {
            final TypedValue value = new TypedValue();
            final InputStream is = r.openRawResource(srcResId, value);
            bitmap = BitmapFactory.decodeResourceStream(r, value, is, padding, options);
            is.close();
        } catch (IOException e) {
        // Ignore
        }
        if (bitmap == null) {
            throw new XmlPullParserException(a.getPositionDescription() + ": <nine-patch> requires a valid src attribute");
        } else if (bitmap.getNinePatchChunk() == null) {
            throw new XmlPullParserException(a.getPositionDescription() + ": <nine-patch> requires a valid 9-patch source image");
        }
        bitmap.getOpticalInsets(opticalInsets);
        state.mNinePatch = new NinePatch(bitmap, bitmap.getNinePatchChunk());
        state.mPadding = padding;
        state.mOpticalInsets = Insets.of(opticalInsets);
    }
    state.mAutoMirrored = a.getBoolean(R.styleable.NinePatchDrawable_autoMirrored, state.mAutoMirrored);
    state.mBaseAlpha = a.getFloat(R.styleable.NinePatchDrawable_alpha, state.mBaseAlpha);
    final int tintMode = a.getInt(R.styleable.NinePatchDrawable_tintMode, -1);
    if (tintMode != -1) {
        state.mTintMode = Drawable.parseTintMode(tintMode, Mode.SRC_IN);
    }
    final ColorStateList tint = a.getColorStateList(R.styleable.NinePatchDrawable_tint);
    if (tint != null) {
        state.mTint = tint;
    }
}
------------------------
Find a silently evolved API code:android.hardware.display.DisplayManagerGlobal.getDisplayIds:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Gets all currently valid logical display ids.
 *
 * @return An array containing all display ids.
 */

Body of Frist Method:
{
    try {
        synchronized (mLock) {
            if (USE_CACHE) {
                if (mDisplayIdCache != null) {
                    return mDisplayIdCache;
                }
            }
            int[] displayIds = mDm.getDisplayIds();
            if (USE_CACHE) {
                mDisplayIdCache = displayIds;
            }
            registerCallbackIfNeededLocked();
            return displayIds;
        }
    } catch (RemoteException ex) {
        Log.e(TAG, "Could not get display ids from display manager.", ex);
        return new int[] { Display.DEFAULT_DISPLAY };
    }
}
Body of Second Method:
{
    try {
        synchronized (mLock) {
            if (USE_CACHE) {
                if (mDisplayIdCache != null) {
                    return mDisplayIdCache;
                }
            }
            int[] displayIds = mDm.getDisplayIds();
            if (USE_CACHE) {
                mDisplayIdCache = displayIds;
            }
            registerCallbackIfNeededLocked();
            return displayIds;
        }
    } catch (RemoteException ex) {
        throw ex.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.telephony.SignalStrength.fillInNotifierBundle:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Set intent notifier Bundle based on SignalStrength
 *
 * @param m intent notifier Bundle
 * @hide
 */

Body of Frist Method:
{
    m.putInt("GsmSignalStrength", mGsmSignalStrength);
    m.putInt("GsmBitErrorRate", mGsmBitErrorRate);
    m.putInt("CdmaDbm", mCdmaDbm);
    m.putInt("CdmaEcio", mCdmaEcio);
    m.putInt("EvdoDbm", mEvdoDbm);
    m.putInt("EvdoEcio", mEvdoEcio);
    m.putInt("EvdoSnr", mEvdoSnr);
    m.putInt("LteSignalStrength", mLteSignalStrength);
    m.putInt("LteRsrp", mLteRsrp);
    m.putInt("LteRsrq", mLteRsrq);
    m.putInt("LteRssnr", mLteRssnr);
    m.putInt("LteCqi", mLteCqi);
    m.putBoolean("isGsm", Boolean.valueOf(isGsm));
}
Body of Second Method:
{
    m.putInt("GsmSignalStrength", mGsmSignalStrength);
    m.putInt("GsmBitErrorRate", mGsmBitErrorRate);
    m.putInt("CdmaDbm", mCdmaDbm);
    m.putInt("CdmaEcio", mCdmaEcio);
    m.putInt("EvdoDbm", mEvdoDbm);
    m.putInt("EvdoEcio", mEvdoEcio);
    m.putInt("EvdoSnr", mEvdoSnr);
    m.putInt("LteSignalStrength", mLteSignalStrength);
    m.putInt("LteRsrp", mLteRsrp);
    m.putInt("LteRsrq", mLteRsrq);
    m.putInt("LteRssnr", mLteRssnr);
    m.putInt("LteCqi", mLteCqi);
    m.putInt("TdScdma", mTdScdmaRscp);
    m.putBoolean("isGsm", Boolean.valueOf(isGsm));
}
------------------------
Find a silently evolved API code:android.hardware.usb.UsbManager.removeFunction:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    String[] split = functions.split(",");
    for (int i = 0; i < split.length; i++) {
        if (function.equals(split[i])) {
            split[i] = null;
        }
    }
    if (split.length == 1 && split[0] == null) {
        return "none";
    }
    StringBuilder builder = new StringBuilder();
    for (int i = 0; i < split.length; i++) {
        String s = split[i];
        if (s != null) {
            if (builder.length() > 0) {
                builder.append(",");
            }
            builder.append(s);
        }
    }
    return builder.toString();
}
Body of Second Method:
{
    String[] split = functions.split(",");
    for (int i = 0; i < split.length; i++) {
        if (function.equals(split[i])) {
            split[i] = null;
        }
    }
    if (split.length == 1 && split[0] == null) {
        return USB_FUNCTION_NONE;
    }
    StringBuilder builder = new StringBuilder();
    for (int i = 0; i < split.length; i++) {
        String s = split[i];
        if (s != null) {
            if (builder.length() > 0) {
                builder.append(",");
            }
            builder.append(s);
        }
    }
    return builder.toString();
}
------------------------
Find a silently evolved API code:android.net.ConnectivityManager.setAcceptUnvalidated:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Informs the system whether it should switch to {@code network} regardless of whether it is
 * validated or not. If {@code accept} is true, and the network was explicitly selected by the
 * user (e.g., by selecting a Wi-Fi network in the Settings app), then the network will become
 * the system default network regardless of any other network that's currently connected. If
 * {@code always} is true, then the choice is remembered, so that the next time the user
 * connects to this network, the system will switch to it.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#CONNECTIVITY_INTERNAL}
 *
 * @param network The network to accept.
 * @param accept Whether to accept the network even if unvalidated.
 * @param always Whether to remember this choice in the future.
 *
 * @hide
 */

Body of Frist Method:
{
    try {
        mService.setAcceptUnvalidated(network, accept, always);
    } catch (RemoteException e) {
    }
}
Body of Second Method:
{
    try {
        mService.setAcceptUnvalidated(network, accept, always);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.app.AlarmManager.setAlarmClock:COMMENT
Method Modifier: public      
Comment:/**
 * Schedule an alarm that represents an alarm clock.
 *
 * The system may choose to display information about this alarm to the user.
 *
 * <p>
 * This method is like {@link #setExact(int, long, PendingIntent)}, but implies
 * {@link #RTC_WAKEUP}.
 *
 * @param info
 * @param operation Action to perform when the alarm goes off;
 * typically comes from {@link PendingIntent#getBroadcast
 * IntentSender.getBroadcast()}.
 *
 * @see #set
 * @see #setRepeating
 * @see #setWindow
 * @see #setExact
 * @see #cancel
 * @see #getNextAlarmClock()
 * @see android.content.Context#sendBroadcast
 * @see android.content.Context#registerReceiver
 * @see android.content.Intent#filterEquals
 */

Body of Frist Method:
{
    setImpl(RTC_WAKEUP, info.getTriggerTime(), WINDOW_EXACT, 0, 0, operation, null, info);
}
Body of Second Method:
{
    setImpl(RTC_WAKEUP, info.getTriggerTime(), WINDOW_EXACT, 0, 0, operation, null, null, null, null, info);
}
------------------------
Find a silently evolved API code:android.media.MediaDrm.CryptoSession.sign:COMMENT
Method Modifier: public      
Comment:/**
 * Sign data using the CryptoSessions's mac algorithm.
 *
 * @param keyid specifies which key to use
 * @param message the data for which a signature is to be computed
 */

Body of Frist Method:
{
    return signNative(mDrm, mSessionId, keyid, message);
}
Body of Second Method:
{
    return signNative(MediaDrm.this, mSessionId, keyid, message);
}
------------------------
Find a silently evolved API code:android.service.persistentdata.PersistentDataBlockManager.getDataBlockSize:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Retrieves the size of the block currently written to the persistent partition.
 *
 * Return -1 on error.
 */

Body of Frist Method:
{
    try {
        return sService.getDataBlockSize();
    } catch (RemoteException e) {
        onError("getting data block size");
        return -1;
    }
}
Body of Second Method:
{
    try {
        return sService.getDataBlockSize();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.animation.ValueAnimator.getStartDelay:COMMENT
Method Modifier: public      
Comment:/**
 * The amount of time, in milliseconds, to delay starting the animation after
 * {@link #start()} is called.
 *
 * @return the number of milliseconds to delay running the animation
 */

Body of Frist Method:
{
    return mUnscaledStartDelay;
}
Body of Second Method:
{
    return mStartDelay;
}
------------------------
Find a silently evolved API code:android.hardware.camera2.marshal.MarshalRegistry.registerMarshalQueryable:COMMENT
Method Modifier: public      static      
Comment:/**
 * Register a marshal queryable for the managed type {@code T}.
 *
 * <p>Multiple marshal queryables for the same managed type {@code T} may be registered;
 * this is desirable if they support different native types (e.g. marshaler 1 supports
 * {@code Integer <-> TYPE_INT32}, marshaler 2 supports {@code Integer <-> TYPE_BYTE}.</p>
 *
 * @param queryable a non-{@code null} marshal queryable that supports marshaling {@code T}
 */

Body of Frist Method:
{
    sRegisteredMarshalQueryables.add(queryable);
}
Body of Second Method:
{
    synchronized (sMarshalLock) {
        sRegisteredMarshalQueryables.add(queryable);
    }
}
------------------------
Find a silently evolved API code:android.media.midi.MidiManager.unregisterDeviceCallback:COMMENT
Method Modifier: public      
Comment:/**
 * Unregisters a {@link DeviceCallback}.
 *
 * @param callback a {@link DeviceCallback} to unregister
 */

Body of Frist Method:
{
    DeviceListener deviceListener = mDeviceListeners.remove(callback);
    if (deviceListener != null) {
        try {
            mService.unregisterListener(mToken, deviceListener);
        } catch (RemoteException e) {
            Log.e(TAG, "RemoteException in unregisterDeviceListener");
        }
    }
}
Body of Second Method:
{
    DeviceListener deviceListener = mDeviceListeners.remove(callback);
    if (deviceListener != null) {
        try {
            mService.unregisterListener(mToken, deviceListener);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}
------------------------
Find a silently evolved API code:android.net.ConnectivityManager.isTetheringSupported:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Check if the device allows for tethering.  It may be disabled via
 * {@code ro.tether.denied} system property, Settings.TETHER_SUPPORTED or
 * due to device configuration.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
 *
 * @return a boolean - {@code true} indicating Tethering is supported.
 *
 * {@hide}
 */

Body of Frist Method:
{
    try {
        return mService.isTetheringSupported();
    } catch (RemoteException e) {
        return false;
    }
}
Body of Second Method:
{
    try {
        return mService.isTetheringSupported();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.security.keystore.KeyProtection.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Builds an instance of {@link KeyProtection}.
 *
 * @throws IllegalArgumentException if a required field is missing
 */

Body of Frist Method:
{
    return new KeyProtection(mKeyValidityStart, mKeyValidityForOriginationEnd, mKeyValidityForConsumptionEnd, mPurposes, mEncryptionPaddings, mSignaturePaddings, mDigests, mBlockModes, mRandomizedEncryptionRequired, mUserAuthenticationRequired, mUserAuthenticationValidityDurationSeconds);
}
Body of Second Method:
{
    return new KeyProtection(mKeyValidityStart, mKeyValidityForOriginationEnd, mKeyValidityForConsumptionEnd, mPurposes, mEncryptionPaddings, mSignaturePaddings, mDigests, mBlockModes, mRandomizedEncryptionRequired, mUserAuthenticationRequired, mUserAuthenticationValidityDurationSeconds, mUserAuthenticationValidWhileOnBody, mInvalidatedByBiometricEnrollment);
}
------------------------
Find a silently evolved API code:android.view.RenderNode.setOutline:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets the outline, defining the shape that casts a shadow, and the path to
 * be clipped if setClipToOutline is set.
 *
 * Deep copies the data into native to simplify reference ownership.
 */

Body of Frist Method:
{
    if (outline == null) {
        return nSetOutlineNone(mNativeRenderNode);
    } else if (outline.isEmpty()) {
        return nSetOutlineEmpty(mNativeRenderNode);
    } else if (outline.mRect != null) {
        return nSetOutlineRoundRect(mNativeRenderNode, outline.mRect.left, outline.mRect.top, outline.mRect.right, outline.mRect.bottom, outline.mRadius, outline.mAlpha);
    } else if (outline.mPath != null) {
        return nSetOutlineConvexPath(mNativeRenderNode, outline.mPath.mNativePath, outline.mAlpha);
    }
    throw new IllegalArgumentException("Unrecognized outline?");
}
Body of Second Method:
{
    if (outline == null) {
        return nSetOutlineNone(mNativeRenderNode);
    }
    switch(outline.mMode) {
        case Outline.MODE_EMPTY:
            return nSetOutlineEmpty(mNativeRenderNode);
        case Outline.MODE_ROUND_RECT:
            return nSetOutlineRoundRect(mNativeRenderNode, outline.mRect.left, outline.mRect.top, outline.mRect.right, outline.mRect.bottom, outline.mRadius, outline.mAlpha);
        case Outline.MODE_CONVEX_PATH:
            return nSetOutlineConvexPath(mNativeRenderNode, outline.mPath.mNativePath, outline.mAlpha);
    }
    throw new IllegalArgumentException("Unrecognized outline?");
}
------------------------
Find a silently evolved API code:android.telephony.CarrierConfigManager.updateConfigForPhoneId:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Request the carrier config loader to update the cofig for phoneId.
 * <p>
 * Depending on simState, the config may be cleared or loaded from config app. This is only used
 * by SubscriptionInfoUpdater.
 * </p>
 *
 * @hide
 */

Body of Frist Method:
{
    try {
        getICarrierConfigLoader().updateConfigForPhoneId(phoneId, simState);
    } catch (RemoteException ex) {
        Rlog.e(TAG, "Error updating config for phoneId=" + phoneId + ": " + ex.toString());
    } catch (NullPointerException ex) {
        Rlog.e(TAG, "Error updating config for phoneId=" + phoneId + ": " + ex.toString());
    }
}
Body of Second Method:
{
    try {
        ICarrierConfigLoader loader = getICarrierConfigLoader();
        if (loader == null) {
            Rlog.w(TAG, "Error updating config for phoneId=" + phoneId + " ICarrierConfigLoader is null");
            return;
        }
        loader.updateConfigForPhoneId(phoneId, simState);
    } catch (RemoteException ex) {
        Rlog.e(TAG, "Error updating config for phoneId=" + phoneId + ": " + ex.toString());
    }
}
------------------------
Find a silently evolved API code:android.widget.TimePickerClockDelegate.onTimeChanged:COMMENT
Method Modifier: private     
Comment:/**
 * Propagate the time change
 */

Body of Frist Method:
{
    mDelegator.sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_SELECTED);
    if (mOnTimeChangedListener != null) {
        mOnTimeChangedListener.onTimeChanged(mDelegator, getCurrentHour(), getCurrentMinute());
    }
}
Body of Second Method:
{
    mDelegator.sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_SELECTED);
    if (mOnTimeChangedListener != null) {
        mOnTimeChangedListener.onTimeChanged(mDelegator, getHour(), getMinute());
    }
}
------------------------
Find a silently evolved API code:android.webkit.WebViewDelegate.invokeDrawGlFunctor:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Invokes the draw GL functor. If waitForCompletion is false the functor
 * may be invoked asynchronously.
 *
 * @param nativeDrawGLFunctor the pointer to the native functor that implements
 * system/core/include/utils/Functor.h
 */

Body of Frist Method:
{
    ViewRootImpl viewRootImpl = containerView.getViewRootImpl();
    viewRootImpl.invokeFunctor(nativeDrawGLFunctor, waitForCompletion);
}
Body of Second Method:
{
    ViewRootImpl.invokeFunctor(nativeDrawGLFunctor, waitForCompletion);
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiManager.setTdlsEnabledWithMacAddress:COMMENT
Method Modifier: public      
Comment:/**
 * Similar to {@link #setTdlsEnabled(InetAddress, boolean) }, except
 * this version allows you to specify remote endpoint with a MAC address.
 * @param remoteMacAddress MAC address of the remote endpoint such as 00:00:0c:9f:f2:ab
 * @param enable true = setup and false = tear down TDLS
 */

Body of Frist Method:
{
    try {
        mService.enableTdlsWithMacAddress(remoteMacAddress, enable);
    } catch (RemoteException e) {
    // Just ignore the exception
    }
}
Body of Second Method:
{
    try {
        mService.enableTdlsWithMacAddress(remoteMacAddress, enable);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.widget.TextView.onActivityResult:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (requestCode == PROCESS_TEXT_REQUEST_CODE) {
        if (resultCode == Activity.RESULT_OK && data != null) {
            CharSequence result = data.getCharSequenceExtra(Intent.EXTRA_PROCESS_TEXT);
            if (result != null) {
                if (isTextEditable()) {
                    replaceSelectionWithText(result);
                } else {
                    if (result.length() > 0) {
                        Toast.makeText(getContext(), String.valueOf(result), Toast.LENGTH_LONG).show();
                    }
                }
            }
        }
        if (mEditor.hasSelectionController()) {
            mEditor.startSelectionActionMode();
        }
    }
}
Body of Second Method:
{
    if (requestCode == PROCESS_TEXT_REQUEST_CODE) {
        if (resultCode == Activity.RESULT_OK && data != null) {
            CharSequence result = data.getCharSequenceExtra(Intent.EXTRA_PROCESS_TEXT);
            if (result != null) {
                if (isTextEditable()) {
                    replaceSelectionWithText(result);
                    if (mEditor != null) {
                        mEditor.refreshTextActionMode();
                    }
                } else {
                    if (result.length() > 0) {
                        Toast.makeText(getContext(), String.valueOf(result), Toast.LENGTH_LONG).show();
                    }
                }
            }
        } else if (mText instanceof Spannable) {
            // Reset the selection.
            Selection.setSelection((Spannable) mText, getSelectionEnd());
        }
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothAdapter.isOffloadedFilteringSupported:COMMENT
Method Modifier: public      
Comment:/**
 * Return true if offloaded filters are supported
 *
 * @return true if chipset supports on-chip filtering
 */

Body of Frist Method:
{
    if (!getLeAccess())
        return false;
    try {
        return mService.isOffloadedFilteringSupported();
    } catch (RemoteException e) {
        Log.e(TAG, "failed to get isOffloadedFilteringSupported, error: ", e);
    }
    return false;
}
Body of Second Method:
{
    if (!getLeAccess())
        return false;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.isOffloadedFilteringSupported();
    } catch (RemoteException e) {
        Log.e(TAG, "failed to get isOffloadedFilteringSupported, error: ", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}
------------------------
Find a silently evolved API code:android.app.admin.DeviceAdminInfo.loadIcon:COMMENT
Method Modifier: public      
Comment:/**
 * Load the user-displayed icon for this device admin.
 *
 * @param pm Supply a PackageManager used to load the device admin's
 * resources.
 */

Body of Frist Method:
{
    return mReceiver.loadIcon(pm);
}
Body of Second Method:
{
    return mActivityInfo.loadIcon(pm);
}
------------------------
Find a silently evolved API code:android.telephony.TelephonyManager.getDefaultSim:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * {@hide}
 */

Body of Frist Method:
{
    return SubscriptionManager.getSlotId(SubscriptionManager.getDefaultSubId());
}
Body of Second Method:
{
    return SubscriptionManager.getSlotId(SubscriptionManager.getDefaultSubscriptionId());
}
------------------------
Find a silently evolved API code:android.net.http.X509TrustManagerExtensions.checkServerTrusted:COMMENT
Method Modifier: public      
Comment:/**
 * Verifies the given certificate chain.
 *
 * <p>See {@link X509TrustManager#checkServerTrusted(X509Certificate[], String)} for a
 * description of the chain and authType parameters. The final parameter, host, should be the
 * hostname of the server.</p>
 *
 * @throws CertificateException if the chain does not verify correctly.
 * @return the properly ordered chain used for verification as a list of X509Certificates.
 */

Body of Frist Method:
{
    return mDelegate.checkServerTrusted(chain, authType, host);
}
Body of Second Method:
{
    if (mDelegate != null) {
        return mDelegate.checkServerTrusted(chain, authType, host);
    } else {
        try {
            return (List<X509Certificate>) mCheckServerTrusted.invoke(mTrustManager, chain, authType, host);
        } catch (IllegalAccessException e) {
            throw new CertificateException("Failed to call checkServerTrusted", e);
        } catch (InvocationTargetException e) {
            if (e.getCause() instanceof CertificateException) {
                throw (CertificateException) e.getCause();
            }
            if (e.getCause() instanceof RuntimeException) {
                throw (RuntimeException) e.getCause();
            }
            throw new CertificateException("checkServerTrusted failed", e.getCause());
        }
    }
}
------------------------
Find a silently evolved API code:android.net.dhcp.DhcpOfferPacket.finishPacket:COMMENT
Method Modifier: default     
Comment:/**
 * Adds the optional parameters to the server-generated OFFER packet.
 */

Body of Frist Method:
{
    addTlv(buffer, DHCP_MESSAGE_TYPE, DHCP_MESSAGE_TYPE_OFFER);
    addTlv(buffer, DHCP_SERVER_IDENTIFIER, mServerIdentifier);
    addTlv(buffer, DHCP_LEASE_TIME, mLeaseTime);
    // the client should renew at 1/2 the lease-expiry interval
    if (mLeaseTime != null) {
        addTlv(buffer, DHCP_RENEWAL_TIME, Integer.valueOf(mLeaseTime.intValue() / 2));
    }
    addTlv(buffer, DHCP_SUBNET_MASK, mSubnetMask);
    addTlv(buffer, DHCP_ROUTER, mGateway);
    addTlv(buffer, DHCP_DOMAIN_NAME, mDomainName);
    addTlv(buffer, DHCP_BROADCAST_ADDRESS, mBroadcastAddress);
    addTlv(buffer, DHCP_DNS_SERVER, mDnsServers);
    addTlvEnd(buffer);
}
Body of Second Method:
{
    addTlv(buffer, DHCP_MESSAGE_TYPE, DHCP_MESSAGE_TYPE_OFFER);
    addTlv(buffer, DHCP_SERVER_IDENTIFIER, mServerIdentifier);
    addTlv(buffer, DHCP_LEASE_TIME, mLeaseTime);
    // the client should renew at 1/2 the lease-expiry interval
    if (mLeaseTime != null) {
        addTlv(buffer, DHCP_RENEWAL_TIME, Integer.valueOf(mLeaseTime.intValue() / 2));
    }
    addTlv(buffer, DHCP_SUBNET_MASK, mSubnetMask);
    addTlv(buffer, DHCP_ROUTER, mGateways);
    addTlv(buffer, DHCP_DOMAIN_NAME, mDomainName);
    addTlv(buffer, DHCP_BROADCAST_ADDRESS, mBroadcastAddress);
    addTlv(buffer, DHCP_DNS_SERVER, mDnsServers);
    addTlvEnd(buffer);
}
------------------------
Find a silently evolved API code:android.animation.ValueAnimator.getDuration:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the length of the animation. The default duration is 300 milliseconds.
 *
 * @return The length of the animation, in milliseconds.
 */

Body of Frist Method:
{
    return mUnscaledDuration;
}
Body of Second Method:
{
    return mDuration;
}
------------------------
Find a silently evolved API code:android.accounts.AccountManager.getAccountsByTypeAndFeatures:COMMENT
Method Modifier: public      
Comment:/**
 * Lists all accounts of a type which have certain features.  The account
 * type identifies the authenticator (see {@link #getAccountsByType}).
 * Account features are authenticator-specific string tokens identifying
 * boolean account properties (see {@link #hasFeatures}).
 *
 * <p>Unlike {@link #getAccountsByType}, this method calls the authenticator,
 * which may contact the server or do other work to check account features,
 * so the method returns an {@link AccountManagerFuture}.
 *
 * <p>This method may be called from any thread, but the returned
 * {@link AccountManagerFuture} must not be used on the main thread.
 *
 * <p>Clients of this method that have not been granted the
 * {@link android.Manifest.permission#GET_ACCOUNTS} permission,
 * will only see those accounts managed by AbstractAccountAuthenticators whose
 * signature matches the client.
 *
 * @param type The type of accounts to return, must not be null
 * @param features An array of the account features to require,
 * may be null or empty
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * GET_ACCOUNTS permission is needed for those platforms, irrespective of uid
 * or signature match. See docs for this function in API level 22.
 *
 * @param callback Callback to invoke when the request completes,
 * null for no callback
 * @param handler {@link Handler} identifying the callback thread,
 * null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to an array of
 * {@link Account}, one per account of the specified type which
 * matches the requested features.
 */

Body of Frist Method:
{
    if (type == null)
        throw new IllegalArgumentException("type is null");
    return new Future2Task<Account[]>(handler, callback) {

        public void doWork() throws RemoteException {
            mService.getAccountsByFeatures(mResponse, type, features, mContext.getOpPackageName());
        }

        public Account[] bundleToResult(Bundle bundle) throws AuthenticatorException {
            if (!bundle.containsKey(KEY_ACCOUNTS)) {
                throw new AuthenticatorException("no result in response");
            }
            final Parcelable[] parcelables = bundle.getParcelableArray(KEY_ACCOUNTS);
            Account[] descs = new Account[parcelables.length];
            for (int i = 0; i < parcelables.length; i++) {
                descs[i] = (Account) parcelables[i];
            }
            return descs;
        }
    }.start();
}
Body of Second Method:
{
    if (type == null)
        throw new IllegalArgumentException("type is null");
    return new Future2Task<Account[]>(handler, callback) {

        @Override
        public void doWork() throws RemoteException {
            mService.getAccountsByFeatures(mResponse, type, features, mContext.getOpPackageName());
        }

        @Override
        public Account[] bundleToResult(Bundle bundle) throws AuthenticatorException {
            if (!bundle.containsKey(KEY_ACCOUNTS)) {
                throw new AuthenticatorException("no result in response");
            }
            final Parcelable[] parcelables = bundle.getParcelableArray(KEY_ACCOUNTS);
            Account[] descs = new Account[parcelables.length];
            for (int i = 0; i < parcelables.length; i++) {
                descs[i] = (Account) parcelables[i];
            }
            return descs;
        }
    }.start();
}
------------------------
Find a silently evolved API code:android.telephony.TelephonyManager.getCdmaMdn:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return getCdmaMdn(getDefaultSubscription());
}
Body of Second Method:
{
    return getCdmaMdn(getSubId());
}
------------------------
Find a silently evolved API code:android.webkit.WebViewDelegate.canInvokeDrawGlFunctor:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns true if the draw GL functor can be invoked (see {@link #invokeDrawGlFunctor})
 * and false otherwise.
 */

Body of Frist Method:
{
    ViewRootImpl viewRootImpl = containerView.getViewRootImpl();
    // viewRootImpl can be null during teardown when window is leaked.
    return viewRootImpl != null;
}
Body of Second Method:
{
    return true;
}
------------------------
Find a silently evolved API code:android.telephony.TelephonyManager.setDataEnabled:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    setDataEnabled(SubscriptionManager.getDefaultDataSubId(), enable);
}
Body of Second Method:
{
    setDataEnabled(SubscriptionManager.getDefaultDataSubscriptionId(), enable);
}
------------------------
Find a silently evolved API code:android.graphics.Outline.offset:COMMENT
Method Modifier: public      
Comment:/**
 * Offsets the Outline by (dx,dy)
 */

Body of Frist Method:
{
    if (mRect != null) {
        mRect.offset(dx, dy);
    } else if (mPath != null) {
        mPath.offset(dx, dy);
    }
}
Body of Second Method:
{
    if (mMode == MODE_ROUND_RECT) {
        mRect.offset(dx, dy);
    } else if (mMode == MODE_CONVEX_PATH) {
        mPath.offset(dx, dy);
    }
}
------------------------
Find a silently evolved API code:android.ddm.DdmHandleHello.handleHELO:COMMENT
Method Modifier: private     
Comment:/*
     * Handle introductory packet. This is called during JNI_CreateJavaVM
     * before frameworks native methods are registered, so be careful not
     * to call any APIs that depend on frameworks native code.
     */

Body of Frist Method:
{
    if (false)
        return createFailChunk(123, "This is a test");
    /*
         * Process the request.
         */
    ByteBuffer in = wrapChunk(request);
    int serverProtoVers = in.getInt();
    if (false)
        Log.v("ddm-hello", "Server version is " + serverProtoVers);
    /*
         * Create a response.
         */
    String vmName = System.getProperty("java.vm.name", "?");
    String vmVersion = System.getProperty("java.vm.version", "?");
    String vmIdent = vmName + " v" + vmVersion;
    // String appName = android.app.ActivityThread.currentPackageName();
    // if (appName == null)
    // appName = "unknown";
    String appName = DdmHandleAppName.getAppName();
    VMRuntime vmRuntime = VMRuntime.getRuntime();
    String instructionSetDescription = vmRuntime.is64Bit() ? "64-bit" : "32-bit";
    String vmInstructionSet = vmRuntime.vmInstructionSet();
    if (vmInstructionSet != null && vmInstructionSet.length() > 0) {
        instructionSetDescription += " (" + vmInstructionSet + ")";
    }
    String vmFlags = "CheckJNI=" + (vmRuntime.isCheckJniEnabled() ? "true" : "false");
    ByteBuffer out = ByteBuffer.allocate(28 + vmIdent.length() * 2 + appName.length() * 2 + instructionSetDescription.length() * 2 + vmFlags.length() * 2);
    out.order(ChunkHandler.CHUNK_ORDER);
    out.putInt(DdmServer.CLIENT_PROTOCOL_VERSION);
    out.putInt(android.os.Process.myPid());
    out.putInt(vmIdent.length());
    out.putInt(appName.length());
    putString(out, vmIdent);
    putString(out, appName);
    out.putInt(UserHandle.myUserId());
    out.putInt(instructionSetDescription.length());
    putString(out, instructionSetDescription);
    out.putInt(vmFlags.length());
    putString(out, vmFlags);
    Chunk reply = new Chunk(CHUNK_HELO, out);
    /*
         * Take the opportunity to inform DDMS if we are waiting for a
         * debugger to attach.
         */
    if (Debug.waitingForDebugger())
        sendWAIT(0);
    return reply;
}
Body of Second Method:
{
    if (false)
        return createFailChunk(123, "This is a test");
    /*
         * Process the request.
         */
    ByteBuffer in = wrapChunk(request);
    int serverProtoVers = in.getInt();
    if (false)
        Log.v("ddm-hello", "Server version is " + serverProtoVers);
    /*
         * Create a response.
         */
    String vmName = System.getProperty("java.vm.name", "?");
    String vmVersion = System.getProperty("java.vm.version", "?");
    String vmIdent = vmName + " v" + vmVersion;
    // String appName = android.app.ActivityThread.currentPackageName();
    // if (appName == null)
    // appName = "unknown";
    String appName = DdmHandleAppName.getAppName();
    VMRuntime vmRuntime = VMRuntime.getRuntime();
    String instructionSetDescription = vmRuntime.is64Bit() ? "64-bit" : "32-bit";
    String vmInstructionSet = vmRuntime.vmInstructionSet();
    if (vmInstructionSet != null && vmInstructionSet.length() > 0) {
        instructionSetDescription += " (" + vmInstructionSet + ")";
    }
    String vmFlags = "CheckJNI=" + (vmRuntime.isCheckJniEnabled() ? "true" : "false");
    boolean isNativeDebuggable = vmRuntime.isNativeDebuggable();
    ByteBuffer out = ByteBuffer.allocate(28 + vmIdent.length() * 2 + appName.length() * 2 + instructionSetDescription.length() * 2 + vmFlags.length() * 2 + 1);
    out.order(ChunkHandler.CHUNK_ORDER);
    out.putInt(DdmServer.CLIENT_PROTOCOL_VERSION);
    out.putInt(android.os.Process.myPid());
    out.putInt(vmIdent.length());
    out.putInt(appName.length());
    putString(out, vmIdent);
    putString(out, appName);
    out.putInt(UserHandle.myUserId());
    out.putInt(instructionSetDescription.length());
    putString(out, instructionSetDescription);
    out.putInt(vmFlags.length());
    putString(out, vmFlags);
    out.put((byte) (isNativeDebuggable ? 1 : 0));
    Chunk reply = new Chunk(CHUNK_HELO, out);
    /*
         * Take the opportunity to inform DDMS if we are waiting for a
         * debugger to attach.
         */
    if (Debug.waitingForDebugger())
        sendWAIT(0);
    return reply;
}
------------------------
Find a silently evolved API code:android.view.SurfaceControl.closeTransaction:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * end a transaction
 */

Body of Frist Method:
{
    nativeCloseTransaction();
}
Body of Second Method:
{
    nativeCloseTransaction(false);
}
------------------------
Find a silently evolved API code:android.media.audiopolicy.AudioMix.getRegistration:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return mRegistrationId;
}
Body of Second Method:
{
    return mDeviceAddress;
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiManager.getWifiState:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the Wi-Fi enabled state.
 * @return One of {@link #WIFI_STATE_DISABLED},
 * {@link #WIFI_STATE_DISABLING}, {@link #WIFI_STATE_ENABLED},
 * {@link #WIFI_STATE_ENABLING}, {@link #WIFI_STATE_UNKNOWN}
 * @see #isWifiEnabled()
 */

Body of Frist Method:
{
    try {
        return mService.getWifiEnabledState();
    } catch (RemoteException e) {
        return WIFI_STATE_UNKNOWN;
    }
}
Body of Second Method:
{
    try {
        return mService.getWifiEnabledState();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiManager.getConfigFile:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns the file in which IP and proxy configuration data is stored
 * @hide
 */

Body of Frist Method:
{
    try {
        return mService.getConfigFile();
    } catch (RemoteException e) {
        return null;
    }
}
Body of Second Method:
{
    try {
        return mService.getConfigFile();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.net.NetworkStats.getValues:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Return specific stats entry.
 */

Body of Frist Method:
{
    final Entry entry = recycle != null ? recycle : new Entry();
    entry.iface = iface[i];
    entry.uid = uid[i];
    entry.set = set[i];
    entry.tag = tag[i];
    entry.rxBytes = rxBytes[i];
    entry.rxPackets = rxPackets[i];
    entry.txBytes = txBytes[i];
    entry.txPackets = txPackets[i];
    entry.operations = operations[i];
    return entry;
}
Body of Second Method:
{
    final Entry entry = recycle != null ? recycle : new Entry();
    entry.iface = iface[i];
    entry.uid = uid[i];
    entry.set = set[i];
    entry.tag = tag[i];
    entry.roaming = roaming[i];
    entry.rxBytes = rxBytes[i];
    entry.rxPackets = rxPackets[i];
    entry.txBytes = txBytes[i];
    entry.txPackets = txPackets[i];
    entry.operations = operations[i];
    return entry;
}
------------------------
Find a silently evolved API code:android.media.AudioManager.setHdmiSystemAudioSupported:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Set Hdmi Cec system audio mode.
 *
 * @param on whether to be on system audio mode
 * @return output device type. 0 (DEVICE_NONE) if failed to set device.
 * @hide
 */

Body of Frist Method:
{
    try {
        return getService().setHdmiSystemAudioSupported(on);
    } catch (RemoteException e) {
        Log.w(TAG, "Error setting system audio mode", e);
        return AudioSystem.DEVICE_NONE;
    }
}
Body of Second Method:
{
    try {
        return getService().setHdmiSystemAudioSupported(on);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.widget.AdapterViewFlipper.showNext:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    // we should we should make sure to reset the timer
    if (mRunning) {
        mHandler.removeMessages(FLIP_MSG);
        Message msg = mHandler.obtainMessage(FLIP_MSG);
        mHandler.sendMessageDelayed(msg, mFlipInterval);
    }
    super.showNext();
}
Body of Second Method:
{
    // we should we should make sure to reset the timer
    if (mRunning) {
        removeCallbacks(mFlipRunnable);
        postDelayed(mFlipRunnable, mFlipInterval);
    }
    super.showNext();
}
------------------------
Find a silently evolved API code:android.location.Location.setIsFromMockProvider:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Flag this Location as having come from a mock provider or not.
 *
 * @param isFromMockProvider true if this Location came from a mock provider, false otherwise
 * @hide
 */

Body of Frist Method:
{
    mIsFromMockProvider = isFromMockProvider;
}
Body of Second Method:
{
    if (isFromMockProvider) {
        mFieldsMask |= HAS_MOCK_PROVIDER_MASK;
    } else {
        mFieldsMask &= ~HAS_MOCK_PROVIDER_MASK;
    }
}
------------------------
Find a silently evolved API code:android.security.keystore.KeyGenParameterSpec.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Builds an instance of {@code KeyGenParameterSpec}.
 */

Body of Frist Method:
{
    return new KeyGenParameterSpec(mKeystoreAlias, mKeySize, mSpec, mCertificateSubject, mCertificateSerialNumber, mCertificateNotBefore, mCertificateNotAfter, mKeyValidityStart, mKeyValidityForOriginationEnd, mKeyValidityForConsumptionEnd, mPurposes, mDigests, mEncryptionPaddings, mSignaturePaddings, mBlockModes, mRandomizedEncryptionRequired, mUserAuthenticationRequired, mUserAuthenticationValidityDurationSeconds);
}
Body of Second Method:
{
    return new KeyGenParameterSpec(mKeystoreAlias, mUid, mKeySize, mSpec, mCertificateSubject, mCertificateSerialNumber, mCertificateNotBefore, mCertificateNotAfter, mKeyValidityStart, mKeyValidityForOriginationEnd, mKeyValidityForConsumptionEnd, mPurposes, mDigests, mEncryptionPaddings, mSignaturePaddings, mBlockModes, mRandomizedEncryptionRequired, mUserAuthenticationRequired, mUserAuthenticationValidityDurationSeconds, mAttestationChallenge, mUniqueIdIncluded, mUserAuthenticationValidWhileOnBody, mInvalidatedByBiometricEnrollment);
}
------------------------
Find a silently evolved API code:android.app.AlarmManager.setRepeating:COMMENT
Method Modifier: public      
Comment:/**
 * Schedule a repeating alarm.  <b>Note: for timing operations (ticks,
 * timeouts, etc) it is easier and much more efficient to use
 * {@link android.os.Handler}.</b>  If there is already an alarm scheduled
 * for the same IntentSender, it will first be canceled.
 *
 * <p>Like {@link #set}, except you can also supply a period at which
 * the alarm will automatically repeat.  This alarm continues
 * repeating until explicitly removed with {@link #cancel}.  If the stated
 * trigger time is in the past, the alarm will be triggered immediately, with an
 * alarm count depending on how far in the past the trigger time is relative
 * to the repeat interval.
 *
 * <p>If an alarm is delayed (by system sleep, for example, for non
 * _WAKEUP alarm types), a skipped repeat will be delivered as soon as
 * possible.  After that, future alarms will be delivered according to the
 * original schedule; they do not drift over time.  For example, if you have
 * set a recurring alarm for the top of every hour but the phone was asleep
 * from 7:45 until 8:45, an alarm will be sent as soon as the phone awakens,
 * then the next alarm will be sent at 9:00.
 *
 * <p>If your application wants to allow the delivery times to drift in
 * order to guarantee that at least a certain time interval always elapses
 * between alarms, then the approach to take is to use one-time alarms,
 * scheduling the next one yourself when handling each alarm delivery.
 *
 * <p class="note">
 * <b>Note:</b> as of API 19, all repeating alarms are inexact.  If your
 * application needs precise delivery times then it must use one-time
 * exact alarms, rescheduling each time as described above. Legacy applications
 * whose {@code targetSdkVersion} is earlier than API 19 will continue to have all
 * of their alarms, including repeating alarms, treated as exact.
 *
 * @param type One of {@link #ELAPSED_REALTIME}, {@link #ELAPSED_REALTIME_WAKEUP},
 * {@link #RTC}, or {@link #RTC_WAKEUP}.
 * @param triggerAtMillis time in milliseconds that the alarm should first
 * go off, using the appropriate clock (depending on the alarm type).
 * @param intervalMillis interval in milliseconds between subsequent repeats
 * of the alarm.
 * @param operation Action to perform when the alarm goes off;
 * typically comes from {@link PendingIntent#getBroadcast
 * IntentSender.getBroadcast()}.
 *
 * @see android.os.Handler
 * @see #set
 * @see #setExact
 * @see #setWindow
 * @see #cancel
 * @see android.content.Context#sendBroadcast
 * @see android.content.Context#registerReceiver
 * @see android.content.Intent#filterEquals
 * @see #ELAPSED_REALTIME
 * @see #ELAPSED_REALTIME_WAKEUP
 * @see #RTC
 * @see #RTC_WAKEUP
 */

Body of Frist Method:
{
    setImpl(type, triggerAtMillis, legacyExactLength(), intervalMillis, 0, operation, null, null);
}
Body of Second Method:
{
    setImpl(type, triggerAtMillis, legacyExactLength(), intervalMillis, 0, operation, null, null, null, null, null);
}
------------------------
Find a silently evolved API code:android.app.AlarmManager.setExact:COMMENT
Method Modifier: public      
Comment:/**
 * Schedule an alarm to be delivered precisely at the stated time.
 *
 * <p>
 * This method is like {@link #set(int, long, PendingIntent)}, but does not permit
 * the OS to adjust the delivery time.  The alarm will be delivered as nearly as
 * possible to the requested trigger time.
 *
 * <p>
 * <b>Note:</b> only alarms for which there is a strong demand for exact-time
 * delivery (such as an alarm clock ringing at the requested time) should be
 * scheduled as exact.  Applications are strongly discouraged from using exact
 * alarms unnecessarily as they reduce the OS's ability to minimize battery use.
 *
 * @param type One of {@link #ELAPSED_REALTIME}, {@link #ELAPSED_REALTIME_WAKEUP},
 * {@link #RTC}, or {@link #RTC_WAKEUP}.
 * @param triggerAtMillis time in milliseconds that the alarm should go
 * off, using the appropriate clock (depending on the alarm type).
 * @param operation Action to perform when the alarm goes off;
 * typically comes from {@link PendingIntent#getBroadcast
 * IntentSender.getBroadcast()}.
 *
 * @see #set
 * @see #setRepeating
 * @see #setWindow
 * @see #cancel
 * @see android.content.Context#sendBroadcast
 * @see android.content.Context#registerReceiver
 * @see android.content.Intent#filterEquals
 * @see #ELAPSED_REALTIME
 * @see #ELAPSED_REALTIME_WAKEUP
 * @see #RTC
 * @see #RTC_WAKEUP
 */

Body of Frist Method:
{
    setImpl(type, triggerAtMillis, WINDOW_EXACT, 0, 0, operation, null, null);
}
Body of Second Method:
{
    setImpl(type, triggerAtMillis, WINDOW_EXACT, 0, 0, operation, null, null, null, null, null);
}
------------------------
Find a silently evolved API code:android.appwidget.AppWidgetManager.getAppWidgetInfo:COMMENT
Method Modifier: public      
Comment:/**
 * Get the available info about the AppWidget.
 *
 * @return A appWidgetId.  If the appWidgetId has not been bound to a provider yet, or
 * you don't have access to that appWidgetId, null is returned.
 */

Body of Frist Method:
{
    if (mService == null) {
        return null;
    }
    try {
        AppWidgetProviderInfo info = mService.getAppWidgetInfo(mPackageName, appWidgetId);
        if (info != null) {
            // Converting complex to dp.
            convertSizesToPixels(info);
        }
        return info;
    } catch (RemoteException e) {
        throw new RuntimeException("system server dead?", e);
    }
}
Body of Second Method:
{
    if (mService == null) {
        return null;
    }
    try {
        AppWidgetProviderInfo info = mService.getAppWidgetInfo(mPackageName, appWidgetId);
        if (info != null) {
            // Converting complex to dp.
            convertSizesToPixels(info);
        }
        return info;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.content.res.TypedArray.getNonConfigurationString:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Retrieves the string value for the attribute at <var>index</var> that is
 * not allowed to change with the given configurations.
 *
 * @param index Index of attribute to retrieve.
 * @param allowedChangingConfigs Bit mask of configurations from
 * {@link Configuration}.NATIVE_CONFIG_* that are allowed to change.
 *
 * @return String holding string data. Any styling information is removed.
 * Returns {@code null} if the attribute is not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @hide
 */

Body of Frist Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if ((data[index + AssetManager.STYLE_CHANGING_CONFIGURATIONS] & ~allowedChangingConfigs) != 0) {
        return null;
    }
    if (type == TypedValue.TYPE_NULL) {
        return null;
    } else if (type == TypedValue.TYPE_STRING) {
        return loadStringValueAt(index).toString();
    }
    final TypedValue v = mValue;
    if (getValueAt(index, v)) {
        final CharSequence cs = v.coerceToString();
        return cs != null ? cs.toString() : null;
    }
    // We already checked for TYPE_NULL. This should never happen.
    throw new RuntimeException("getNonConfigurationString of bad type: 0x" + Integer.toHexString(type));
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    @Config final int changingConfigs = ActivityInfo.activityInfoConfigNativeToJava(data[index + AssetManager.STYLE_CHANGING_CONFIGURATIONS]);
    if ((changingConfigs & ~allowedChangingConfigs) != 0) {
        return null;
    }
    if (type == TypedValue.TYPE_NULL) {
        return null;
    } else if (type == TypedValue.TYPE_STRING) {
        return loadStringValueAt(index).toString();
    }
    final TypedValue v = mValue;
    if (getValueAt(index, v)) {
        final CharSequence cs = v.coerceToString();
        return cs != null ? cs.toString() : null;
    }
    // We already checked for TYPE_NULL. This should never happen.
    throw new RuntimeException("getNonConfigurationString of bad type: 0x" + Integer.toHexString(type));
}
------------------------
Find a silently evolved API code:android.webkit.WebViewDelegate.addWebViewAssetPath:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Adds the WebView asset path to {@link android.content.res.AssetManager}.
 */

Body of Frist Method:
{
    context.getAssets().addAssetPath(WebViewFactory.getLoadedPackageInfo().applicationInfo.sourceDir);
}
Body of Second Method:
{
    final String newAssetPath = WebViewFactory.getLoadedPackageInfo().applicationInfo.sourceDir;
    final ApplicationInfo appInfo = context.getApplicationInfo();
    final String[] libs = appInfo.sharedLibraryFiles;
    if (!ArrayUtils.contains(libs, newAssetPath)) {
        // Build the new library asset path list.
        final int newLibAssetsCount = 1 + (libs != null ? libs.length : 0);
        final String[] newLibAssets = new String[newLibAssetsCount];
        if (libs != null) {
            System.arraycopy(libs, 0, newLibAssets, 0, libs.length);
        }
        newLibAssets[newLibAssetsCount - 1] = newAssetPath;
        // Update the ApplicationInfo object with the new list.
        // We know this will persist and future Resources created via ResourcesManager
        // will include the shared library because this ApplicationInfo comes from the
        // underlying LoadedApk in ContextImpl, which does not change during the life of the
        // application.
        appInfo.sharedLibraryFiles = newLibAssets;
        // Update existing Resources with the WebView library.
        ResourcesManager.getInstance().appendLibAssetForMainAssetPath(appInfo.getBaseResourcePath(), newAssetPath);
    }
}
------------------------
Find a silently evolved API code:android.telephony.TelephonyManager.iccExchangeSimIO:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the response APDU for a command APDU sent through SIM_IO.
 *
 * <p>Requires Permission:
 * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE}
 * Or the calling app has carrier privileges. @see #hasCarrierPrivileges
 *
 * @param fileID
 * @param command
 * @param p1 P1 value of the APDU command.
 * @param p2 P2 value of the APDU command.
 * @param p3 P3 value of the APDU command.
 * @param filePath
 * @return The APDU response.
 */

Body of Frist Method:
{
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            return telephony.iccExchangeSimIO(fileID, command, p1, p2, p3, filePath);
    } catch (RemoteException ex) {
    } catch (NullPointerException ex) {
    }
    return null;
}
Body of Second Method:
{
    return iccExchangeSimIO(getSubId(), fileID, command, p1, p2, p3, filePath);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothDevice.removeBond:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Remove bond (pairing) with the remote device.
 * <p>Delete the link key associated with the remote device, and
 * immediately terminate connections to that device that require
 * authentication and encryption.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}.
 *
 * @return true on success, false on error
 * @hide
 */

Body of Frist Method:
{
    if (sService == null) {
        Log.e(TAG, "BT not enabled. Cannot remove Remote Device bond");
        return false;
    }
    try {
        return sService.removeBond(this);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
Body of Second Method:
{
    if (sService == null) {
        Log.e(TAG, "BT not enabled. Cannot remove Remote Device bond");
        return false;
    }
    try {
        Log.i(TAG, "removeBond() for device " + getAddress() + " called by pid: " + Process.myPid() + " tid: " + Process.myTid());
        return sService.removeBond(this);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiInfo.getSSID:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the service set identifier (SSID) of the current 802.11 network.
 * If the SSID can be decoded as UTF-8, it will be returned surrounded by double
 * quotation marks. Otherwise, it is returned as a string of hex digits. The
 * SSID may be &lt;unknown ssid&gt; if there is no network currently connected.
 * @return the SSID
 */

Body of Frist Method:
{
    if (mWifiSsid != null) {
        String unicode = mWifiSsid.toString();
        if (!TextUtils.isEmpty(unicode)) {
            return "\"" + unicode + "\"";
        } else {
            return mWifiSsid.getHexString();
        }
    }
    return WifiSsid.NONE;
}
Body of Second Method:
{
    if (mWifiSsid != null) {
        String unicode = mWifiSsid.toString();
        if (!TextUtils.isEmpty(unicode)) {
            return "\"" + unicode + "\"";
        } else {
            String hex = mWifiSsid.getHexString();
            return (hex != null) ? hex : WifiSsid.NONE;
        }
    }
    return WifiSsid.NONE;
}
------------------------
Find a silently evolved API code:android.widget.TimePicker.getMinute:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the currently selected minute.
 *
 * @return the currently selected minute, in the range (0-59)
 * @see #setMinute(int)
 */

Body of Frist Method:
{
    return mDelegate.getCurrentMinute();
}
Body of Second Method:
{
    return mDelegate.getMinute();
}
------------------------
Find a silently evolved API code:android.media.AudioManager.getUiSoundsStreamType:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the stream type whose volume is driving the UI sounds volume.
 * UI sounds are screen lock/unlock, camera shutter, key clicks...
 * It is assumed that this stream type is also tied to ringer mode changes.
 * @hide
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        return service.getUiSoundsStreamType();
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in getUiSoundsStreamType", e);
        return STREAM_RING;
    }
}
Body of Second Method:
{
    IAudioService service = getService();
    try {
        return service.getUiSoundsStreamType();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.content.ContentResolver.call:COMMENT
Method Modifier: public      final       
Comment:/**
 * Call a provider-defined method.  This can be used to implement
 * read or write interfaces which are cheaper than using a Cursor and/or
 * do not fit into the traditional table model.
 *
 * @param method provider-defined method name to call.  Opaque to
 * framework, but must be non-null.
 * @param arg provider-defined String argument.  May be null.
 * @param extras provider-defined Bundle argument.  May be null.
 * @return a result Bundle, possibly null.  Will be null if the ContentProvider
 * does not implement call.
 * @throws NullPointerException if uri or method is null
 * @throws IllegalArgumentException if uri is not known
 */

Body of Frist Method:
{
    Preconditions.checkNotNull(uri, "uri");
    Preconditions.checkNotNull(method, "method");
    IContentProvider provider = acquireProvider(uri);
    if (provider == null) {
        throw new IllegalArgumentException("Unknown URI " + uri);
    }
    try {
        return provider.call(mPackageName, method, arg, extras);
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } finally {
        releaseProvider(provider);
    }
}
Body of Second Method:
{
    Preconditions.checkNotNull(uri, "uri");
    Preconditions.checkNotNull(method, "method");
    IContentProvider provider = acquireProvider(uri);
    if (provider == null) {
        throw new IllegalArgumentException("Unknown URI " + uri);
    }
    try {
        final Bundle res = provider.call(mPackageName, method, arg, extras);
        Bundle.setDefusable(res, true);
        return res;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } finally {
        releaseProvider(provider);
    }
}
------------------------
Find a silently evolved API code:android.animation.PropertyValuesHolder.setupValue:COMMENT
Method Modifier: private     
Comment:/**
 * Utility function to set the value stored in a particular Keyframe. The value used is
 * whatever the value is for the property name specified in the keyframe on the target object.
 *
 * @param target The target object from which the current value should be extracted.
 * @param kf The keyframe which holds the property name and value.
 */

Body of Frist Method:
{
    if (mProperty != null) {
        Object value = convertBack(mProperty.get(target));
        kf.setValue(value);
    }
    try {
        if (mGetter == null) {
            Class targetClass = target.getClass();
            setupGetter(targetClass);
            if (mGetter == null) {
                // Already logged the error - just return to avoid NPE
                return;
            }
        }
        Object value = convertBack(mGetter.invoke(target));
        kf.setValue(value);
    } catch (InvocationTargetException e) {
        Log.e("PropertyValuesHolder", e.toString());
    } catch (IllegalAccessException e) {
        Log.e("PropertyValuesHolder", e.toString());
    }
}
Body of Second Method:
{
    if (mProperty != null) {
        Object value = convertBack(mProperty.get(target));
        kf.setValue(value);
    } else {
        try {
            if (mGetter == null) {
                Class targetClass = target.getClass();
                setupGetter(targetClass);
                if (mGetter == null) {
                    // Already logged the error - just return to avoid NPE
                    return;
                }
            }
            Object value = convertBack(mGetter.invoke(target));
            kf.setValue(value);
        } catch (InvocationTargetException e) {
            Log.e("PropertyValuesHolder", e.toString());
        } catch (IllegalAccessException e) {
            Log.e("PropertyValuesHolder", e.toString());
        }
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothAdapter.cancelDiscovery:COMMENT
Method Modifier: public      
Comment:/**
 * Cancel the current device discovery process.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}.
 * <p>Because discovery is a heavyweight procedure for the Bluetooth
 * adapter, this method should always be called before attempting to connect
 * to a remote device with {@link
 * android.bluetooth.BluetoothSocket#connect()}. Discovery is not managed by
 * the  Activity, but is run as a system service, so an application should
 * always call cancel discovery even if it did not directly request a
 * discovery, just to be sure.
 * <p>If Bluetooth state is not {@link #STATE_ON}, this API
 * will return false. After turning on Bluetooth,
 * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}
 * to get the updated value.
 *
 * @return true on success, false on error
 */

Body of Frist Method:
{
    if (getState() != STATE_ON)
        return false;
    try {
        synchronized (mManagerCallback) {
            if (mService != null)
                return mService.cancelDiscovery();
        }
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
Body of Second Method:
{
    if (getState() != STATE_ON)
        return false;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.cancelDiscovery();
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}
------------------------
Find a silently evolved API code:android.preference.PreferenceManager.getSharedPreferences:COMMENT
Method Modifier: public      
Comment:/**
 * Gets a SharedPreferences instance that preferences managed by this will
 * use.
 *
 * @return A SharedPreferences instance pointing to the file that contains
 * the values of preferences that are managed by this.
 */

Body of Frist Method:
{
    if (mSharedPreferences == null) {
        mSharedPreferences = mContext.getSharedPreferences(mSharedPreferencesName, mSharedPreferencesMode);
    }
    return mSharedPreferences;
}
Body of Second Method:
{
    if (mSharedPreferences == null) {
        final Context storageContext;
        switch(mStorage) {
            case STORAGE_DEVICE_PROTECTED:
                storageContext = mContext.createDeviceProtectedStorageContext();
                break;
            case STORAGE_CREDENTIAL_PROTECTED:
                storageContext = mContext.createCredentialProtectedStorageContext();
                break;
            default:
                storageContext = mContext;
                break;
        }
        mSharedPreferences = storageContext.getSharedPreferences(mSharedPreferencesName, mSharedPreferencesMode);
    }
    return mSharedPreferences;
}
------------------------
Find a silently evolved API code:android.net.ConnectivityManager.getTetherableIfaces:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the set of tetherable, available interfaces.  This list is limited by
 * device configuration and current interface existence.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
 *
 * @return an array of 0 or more Strings of tetherable interface names.
 *
 * {@hide}
 */

Body of Frist Method:
{
    try {
        return mService.getTetherableIfaces();
    } catch (RemoteException e) {
        return new String[0];
    }
}
Body of Second Method:
{
    try {
        return mService.getTetherableIfaces();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.p2p.WifiP2pManager.getMessenger:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get a reference to WifiP2pService handler. This is used to establish
 * an AsyncChannel communication with WifiService
 *
 * @return Messenger pointing to the WifiP2pService handler
 * @hide
 */

Body of Frist Method:
{
    try {
        return mService.getMessenger();
    } catch (RemoteException e) {
        return null;
    }
}
Body of Second Method:
{
    try {
        return mService.getMessenger();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiManager.startScan:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    try {
        mService.startScan(null, workSource);
        return true;
    } catch (RemoteException e) {
        return false;
    }
}
Body of Second Method:
{
    try {
        mService.startScan(null, workSource);
        return true;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.graphics.Bitmap.getRowBytes:COMMENT
Method Modifier: public      final       
Comment:/**
 * Return the number of bytes between rows in the bitmap's pixels. Note that
 * this refers to the pixels as stored natively by the bitmap. If you call
 * getPixels() or setPixels(), then the pixels are uniformly treated as
 * 32bit values, packed according to the Color class.
 *
 * <p>As of {@link android.os.Build.VERSION_CODES#KITKAT}, this method
 * should not be used to calculate the memory usage of the bitmap. Instead,
 * see {@link #getAllocationByteCount()}.
 *
 * @return number of bytes between rows of the native bitmap pixels.
 */

Body of Frist Method:
{
    if (mRecycled) {
        Log.w(TAG, "Called getRowBytes() on a recycle()'d bitmap! This is undefined behavior!");
    }
    return nativeRowBytes(mFinalizer.mNativeBitmap);
}
Body of Second Method:
{
    if (mRecycled) {
        Log.w(TAG, "Called getRowBytes() on a recycle()'d bitmap! This is undefined behavior!");
    }
    return nativeRowBytes(mNativePtr);
}
------------------------
Find a silently evolved API code:android.widget.TimePicker.getHour:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the currently selected hour using 24-hour time.
 *
 * @return the currently selected hour, in the range (0-23)
 * @see #setHour(int)
 */

Body of Frist Method:
{
    return mDelegate.getCurrentHour();
}
Body of Second Method:
{
    return mDelegate.getHour();
}
------------------------
Find a silently evolved API code:android.net.ConnectivityManager.reportNetworkConnectivity:COMMENT
Method Modifier: public      
Comment:/**
 * Report to the framework whether a network has working connectivity.
 * This provides a hint to the system that a particular network is providing
 * working connectivity or not.  In response the framework may re-evaluate
 * the network's connectivity and might take further action thereafter.
 *
 * @param network The {@link Network} the application was attempting to use
 * or {@code null} to indicate the current default network.
 * @param hasConnectivity {@code true} if the application was able to successfully access the
 * Internet using {@code network} or {@code false} if not.
 */

Body of Frist Method:
{
    try {
        mService.reportNetworkConnectivity(network, hasConnectivity);
    } catch (RemoteException e) {
    }
}
Body of Second Method:
{
    try {
        mService.reportNetworkConnectivity(network, hasConnectivity);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.text.TextUtils.join:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns a string containing the tokens joined by delimiters.
 * @param tokens an array objects to be joined. Strings will be formed from
 * the objects by calling object.toString().
 */

Body of Frist Method:
{
    StringBuilder sb = new StringBuilder();
    boolean firstTime = true;
    for (Object token : tokens) {
        if (firstTime) {
            firstTime = false;
        } else {
            sb.append(delimiter);
        }
        sb.append(token);
    }
    return sb.toString();
}
Body of Second Method:
{
    StringBuilder sb = new StringBuilder();
    Iterator<?> it = tokens.iterator();
    if (it.hasNext()) {
        sb.append(it.next());
        while (it.hasNext()) {
            sb.append(delimiter);
            sb.append(it.next());
        }
    }
    return sb.toString();
}
------------------------
Find a silently evolved API code:android.os.Debug.MemoryInfo.getTotalPss:COMMENT
Method Modifier: public      
Comment:/**
 * Return total PSS memory usage in kB.
 */

Body of Frist Method:
{
    return dalvikPss + nativePss + otherPss;
}
Body of Second Method:
{
    return dalvikPss + nativePss + otherPss + getTotalSwappedOutPss();
}
------------------------
Find a silently evolved API code:android.app.WallpaperManager.getDrawable:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the current system wallpaper; if
 * no wallpaper is set, the system built-in static wallpaper is returned.
 * This is returned as an
 * abstract Drawable that you can install in a View to display whatever
 * wallpaper the user has currently set.
 *
 * @return Returns a Drawable object that will draw the wallpaper.
 */

Body of Frist Method:
{
    Bitmap bm = sGlobals.peekWallpaperBitmap(mContext, true);
    if (bm != null) {
        Drawable dr = new BitmapDrawable(mContext.getResources(), bm);
        dr.setDither(false);
        return dr;
    }
    return null;
}
Body of Second Method:
{
    Bitmap bm = sGlobals.peekWallpaperBitmap(mContext, true, FLAG_SYSTEM);
    if (bm != null) {
        Drawable dr = new BitmapDrawable(mContext.getResources(), bm);
        dr.setDither(false);
        return dr;
    }
    return null;
}
------------------------
Find a silently evolved API code:android.animation.ValueAnimator.reverse:COMMENT
Method Modifier: public      
Comment:/**
 * Plays the ValueAnimator in reverse. If the animation is already running,
 * it will stop itself and play backwards from the point reached when reverse was called.
 * If the animation is not currently running, then it will start from the end and
 * play backwards. This behavior is only set for the current animation; future playing
 * of the animation will use the default behavior of playing forward.
 */

Body of Frist Method:
{
    mPlayingBackwards = !mPlayingBackwards;
    if (mPlayingState == RUNNING) {
        long currentTime = AnimationUtils.currentAnimationTimeMillis();
        long currentPlayTime = currentTime - mStartTime;
        long timeLeft = mDuration - currentPlayTime;
        mStartTime = currentTime - timeLeft;
        // do not allow start time to be compensated for jank
        mStartTimeCommitted = true;
        mReversing = !mReversing;
    } else if (mStarted) {
        end();
    } else {
        start(true);
    }
}
Body of Second Method:
{
    if (isPulsingInternal()) {
        long currentTime = AnimationUtils.currentAnimationTimeMillis();
        long currentPlayTime = currentTime - mStartTime;
        long timeLeft = getScaledDuration() - currentPlayTime;
        mStartTime = currentTime - timeLeft;
        // do not allow start time to be compensated for jank
        mStartTimeCommitted = true;
        mReversing = !mReversing;
    } else if (mStarted) {
        mReversing = !mReversing;
        end();
    } else {
        start(true);
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothGatt.writeCharacteristic:COMMENT
Method Modifier: public      
Comment:/**
 * Writes a given characteristic and its values to the associated remote device.
 *
 * <p>Once the write operation has been completed, the
 * {@link BluetoothGattCallback#onCharacteristicWrite} callback is invoked,
 * reporting the result of the operation.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param characteristic Characteristic to write on the remote device
 * @return true, if the write operation was initiated successfully
 */

Body of Frist Method:
{
    if ((characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_WRITE) == 0 && (characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE) == 0)
        return false;
    if (VDBG)
        Log.d(TAG, "writeCharacteristic() - uuid: " + characteristic.getUuid());
    if (mService == null || mClientIf == 0 || characteristic.getValue() == null)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusy) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.writeCharacteristic(mClientIf, device.getAddress(), service.getType(), service.getInstanceId(), new ParcelUuid(service.getUuid()), characteristic.getInstanceId(), new ParcelUuid(characteristic.getUuid()), characteristic.getWriteType(), AUTHENTICATION_NONE, characteristic.getValue());
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}
Body of Second Method:
{
    if ((characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_WRITE) == 0 && (characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE) == 0)
        return false;
    if (VDBG)
        Log.d(TAG, "writeCharacteristic() - uuid: " + characteristic.getUuid());
    if (mService == null || mClientIf == 0 || characteristic.getValue() == null)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusy) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.writeCharacteristic(mClientIf, device.getAddress(), characteristic.getInstanceId(), characteristic.getWriteType(), AUTHENTICATION_NONE, characteristic.getValue());
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}
------------------------
Find a silently evolved API code:android.net.ConnectivityManager.setGlobalProxy:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Set a network-independent global http proxy.  This is not normally what you want
 * for typical HTTP proxies - they are general network dependent.  However if you're
 * doing something unusual like general internal filtering this may be useful.  On
 * a private network where the proxy is not accessible, you may break HTTP using this.
 * <p>This method requires the caller to hold the permission
 * android.Manifest.permission#CONNECTIVITY_INTERNAL.
 *
 * @param p A {@link ProxyInfo} object defining the new global
 * HTTP proxy.  A {@code null} value will clear the global HTTP proxy.
 * @hide
 */

Body of Frist Method:
{
    try {
        mService.setGlobalProxy(p);
    } catch (RemoteException e) {
    }
}
Body of Second Method:
{
    try {
        mService.setGlobalProxy(p);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.service.persistentdata.PersistentDataBlockManager.getOemUnlockEnabled:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns whether or not "OEM unlock" is enabled or disabled on this device.
 */

Body of Frist Method:
{
    try {
        return sService.getOemUnlockEnabled();
    } catch (RemoteException e) {
        onError("getting OEM unlock enabled bit");
        return false;
    }
}
Body of Second Method:
{
    try {
        return sService.getOemUnlockEnabled();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.graphics.Bitmap.hasAlpha:COMMENT
Method Modifier: public      final       
Comment:/**
 * Returns true if the bitmap's config supports per-pixel alpha, and
 * if the pixels may contain non-opaque alpha values. For some configs,
 * this is always false (e.g. RGB_565), since they do not support per-pixel
 * alpha. However, for configs that do, the bitmap may be flagged to be
 * known that all of its pixels are opaque. In this case hasAlpha() will
 * also return false. If a config such as ARGB_8888 is not so flagged,
 * it will return true by default.
 */

Body of Frist Method:
{
    if (mRecycled) {
        Log.w(TAG, "Called hasAlpha() on a recycle()'d bitmap! This is undefined behavior!");
    }
    return nativeHasAlpha(mFinalizer.mNativeBitmap);
}
Body of Second Method:
{
    if (mRecycled) {
        Log.w(TAG, "Called hasAlpha() on a recycle()'d bitmap! This is undefined behavior!");
    }
    return nativeHasAlpha(mNativePtr);
}
------------------------
Find a silently evolved API code:android.renderscript.Element.BOOLEAN:COMMENT
Method Modifier: public      static      
Comment:/**
 * Utility function for returning an Element containing a single Boolean.
 *
 * @param rs Context to which the element will belong.
 *
 * @return Element
 */

Body of Frist Method:
{
    if (rs.mElement_BOOLEAN == null) {
        rs.mElement_BOOLEAN = createUser(rs, DataType.BOOLEAN);
    }
    return rs.mElement_BOOLEAN;
}
Body of Second Method:
{
    if (rs.mElement_BOOLEAN == null) {
        synchronized (rs) {
            if (rs.mElement_BOOLEAN == null) {
                rs.mElement_BOOLEAN = createUser(rs, DataType.BOOLEAN);
            }
        }
    }
    return rs.mElement_BOOLEAN;
}
------------------------
Find a silently evolved API code:android.view.KeyEvent.isConfirmKey:COMMENT
Method Modifier: public      static      final       hidden      
Comment:/**
 * Whether key will, by default, trigger a click on the focused view.
 * @hide
 */

Body of Frist Method:
{
    switch(keyCode) {
        case KeyEvent.KEYCODE_DPAD_CENTER:
        case KeyEvent.KEYCODE_ENTER:
            return true;
        default:
            return false;
    }
}
Body of Second Method:
{
    switch(keyCode) {
        case KeyEvent.KEYCODE_DPAD_CENTER:
        case KeyEvent.KEYCODE_ENTER:
        case KeyEvent.KEYCODE_SPACE:
        case KeyEvent.KEYCODE_NUMPAD_ENTER:
            return true;
        default:
            return false;
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiManager.buildWifiConfig:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Builds a WifiConfiguration from Hotspot 2.0 MIME file.
 * @return AP details in WifiConfiguration
 *
 * @hide Dont open yet
 */

Body of Frist Method:
{
    try {
        return mService.buildWifiConfig(uriString, mimeType, data);
    } catch (RemoteException e) {
        Log.w(TAG, "Caught RemoteException trying to build wifi config: " + e);
        return null;
    }
}
Body of Second Method:
{
    try {
        return mService.buildWifiConfig(uriString, mimeType, data);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.app.ActivityManager.getRunningServices:COMMENT
Method Modifier: public      
Comment:/**
 * Return a list of the services that are currently running.
 *
 * <p><b>Note: this method is only intended for debugging or implementing
 * service management type user interfaces.</b></p>
 *
 * @param maxNum The maximum number of entries to return in the list.  The
 * actual number returned may be smaller, depending on how many services
 * are running.
 *
 * @return Returns a list of RunningServiceInfo records describing each of
 * the running tasks.
 */

Body of Frist Method:
{
    try {
        return ActivityManagerNative.getDefault().getServices(maxNum, 0);
    } catch (RemoteException e) {
        // System dead, we will be dead too soon!
        return null;
    }
}
Body of Second Method:
{
    try {
        return ActivityManagerNative.getDefault().getServices(maxNum, 0);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.telephony.CellSignalStrengthCdma.getCdmaLevel:COMMENT
Method Modifier: public      
Comment:/**
 * Get cdma as level 0..4
 */

Body of Frist Method:
{
    final int cdmaDbm = getCdmaDbm();
    final int cdmaEcio = getCdmaEcio();
    int levelDbm;
    int levelEcio;
    if (cdmaDbm >= -75)
        levelDbm = SIGNAL_STRENGTH_GREAT;
    else if (cdmaDbm >= -85)
        levelDbm = SIGNAL_STRENGTH_GOOD;
    else if (cdmaDbm >= -95)
        levelDbm = SIGNAL_STRENGTH_MODERATE;
    else if (cdmaDbm >= -100)
        levelDbm = SIGNAL_STRENGTH_POOR;
    else
        levelDbm = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    // Ec/Io are in dB*10
    if (cdmaEcio >= -90)
        levelEcio = SIGNAL_STRENGTH_GREAT;
    else if (cdmaEcio >= -110)
        levelEcio = SIGNAL_STRENGTH_GOOD;
    else if (cdmaEcio >= -130)
        levelEcio = SIGNAL_STRENGTH_MODERATE;
    else if (cdmaEcio >= -150)
        levelEcio = SIGNAL_STRENGTH_POOR;
    else
        levelEcio = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    int level = (levelDbm < levelEcio) ? levelDbm : levelEcio;
    if (DBG)
        log("getCdmaLevel=" + level);
    return level;
}
Body of Second Method:
{
    final int cdmaDbm = getCdmaDbm();
    final int cdmaEcio = getCdmaEcio();
    int levelDbm;
    int levelEcio;
    if (cdmaDbm == Integer.MAX_VALUE)
        levelDbm = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    else if (cdmaDbm >= -75)
        levelDbm = SIGNAL_STRENGTH_GREAT;
    else if (cdmaDbm >= -85)
        levelDbm = SIGNAL_STRENGTH_GOOD;
    else if (cdmaDbm >= -95)
        levelDbm = SIGNAL_STRENGTH_MODERATE;
    else if (cdmaDbm >= -100)
        levelDbm = SIGNAL_STRENGTH_POOR;
    else
        levelDbm = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    // Ec/Io are in dB*10
    if (cdmaEcio == Integer.MAX_VALUE)
        levelEcio = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    else if (cdmaEcio >= -90)
        levelEcio = SIGNAL_STRENGTH_GREAT;
    else if (cdmaEcio >= -110)
        levelEcio = SIGNAL_STRENGTH_GOOD;
    else if (cdmaEcio >= -130)
        levelEcio = SIGNAL_STRENGTH_MODERATE;
    else if (cdmaEcio >= -150)
        levelEcio = SIGNAL_STRENGTH_POOR;
    else
        levelEcio = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    int level = (levelDbm < levelEcio) ? levelDbm : levelEcio;
    if (DBG)
        log("getCdmaLevel=" + level);
    return level;
}
------------------------
Find a silently evolved API code:android.content.pm.LauncherApps.isPackageEnabled:COMMENT
Method Modifier: public      
Comment:/**
 * Checks if the package is installed and enabled for a profile.
 *
 * @param packageName The package to check.
 * @param user The UserHandle of the profile.
 *
 * @return true if the package exists and is enabled.
 */

Body of Frist Method:
{
    try {
        return mService.isPackageEnabled(packageName, user);
    } catch (RemoteException re) {
        throw new RuntimeException("Failed to call LauncherAppsService");
    }
}
Body of Second Method:
{
    try {
        return mService.isPackageEnabled(packageName, user);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.telephony.DisconnectCause.toString:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Returns descriptive string for the specified disconnect cause.
 */

Body of Frist Method:
{
    switch(cause) {
        case NOT_DISCONNECTED:
            return "NOT_DISCONNECTED";
        case INCOMING_MISSED:
            return "INCOMING_MISSED";
        case NORMAL:
            return "NORMAL";
        case LOCAL:
            return "LOCAL";
        case BUSY:
            return "BUSY";
        case CONGESTION:
            return "CONGESTION";
        case INVALID_NUMBER:
            return "INVALID_NUMBER";
        case NUMBER_UNREACHABLE:
            return "NUMBER_UNREACHABLE";
        case SERVER_UNREACHABLE:
            return "SERVER_UNREACHABLE";
        case INVALID_CREDENTIALS:
            return "INVALID_CREDENTIALS";
        case OUT_OF_NETWORK:
            return "OUT_OF_NETWORK";
        case SERVER_ERROR:
            return "SERVER_ERROR";
        case TIMED_OUT:
            return "TIMED_OUT";
        case LOST_SIGNAL:
            return "LOST_SIGNAL";
        case LIMIT_EXCEEDED:
            return "LIMIT_EXCEEDED";
        case INCOMING_REJECTED:
            return "INCOMING_REJECTED";
        case POWER_OFF:
            return "POWER_OFF";
        case OUT_OF_SERVICE:
            return "OUT_OF_SERVICE";
        case ICC_ERROR:
            return "ICC_ERROR";
        case CALL_BARRED:
            return "CALL_BARRED";
        case FDN_BLOCKED:
            return "FDN_BLOCKED";
        case CS_RESTRICTED:
            return "CS_RESTRICTED";
        case CS_RESTRICTED_NORMAL:
            return "CS_RESTRICTED_NORMAL";
        case CS_RESTRICTED_EMERGENCY:
            return "CS_RESTRICTED_EMERGENCY";
        case UNOBTAINABLE_NUMBER:
            return "UNOBTAINABLE_NUMBER";
        case CDMA_LOCKED_UNTIL_POWER_CYCLE:
            return "CDMA_LOCKED_UNTIL_POWER_CYCLE";
        case CDMA_DROP:
            return "CDMA_DROP";
        case CDMA_INTERCEPT:
            return "CDMA_INTERCEPT";
        case CDMA_REORDER:
            return "CDMA_REORDER";
        case CDMA_SO_REJECT:
            return "CDMA_SO_REJECT";
        case CDMA_RETRY_ORDER:
            return "CDMA_RETRY_ORDER";
        case CDMA_ACCESS_FAILURE:
            return "CDMA_ACCESS_FAILURE";
        case CDMA_PREEMPTED:
            return "CDMA_PREEMPTED";
        case CDMA_NOT_EMERGENCY:
            return "CDMA_NOT_EMERGENCY";
        case CDMA_ACCESS_BLOCKED:
            return "CDMA_ACCESS_BLOCKED";
        case EMERGENCY_ONLY:
            return "EMERGENCY_ONLY";
        case NO_PHONE_NUMBER_SUPPLIED:
            return "NO_PHONE_NUMBER_SUPPLIED";
        case DIALED_MMI:
            return "DIALED_MMI";
        case VOICEMAIL_NUMBER_MISSING:
            return "VOICEMAIL_NUMBER_MISSING";
        case CDMA_CALL_LOST:
            return "CDMA_CALL_LOST";
        case EXITED_ECM:
            return "EXITED_ECM";
        case DIAL_MODIFIED_TO_USSD:
            return "DIAL_MODIFIED_TO_USSD";
        case DIAL_MODIFIED_TO_SS:
            return "DIAL_MODIFIED_TO_SS";
        case DIAL_MODIFIED_TO_DIAL:
            return "DIAL_MODIFIED_TO_DIAL";
        case ERROR_UNSPECIFIED:
            return "ERROR_UNSPECIFIED";
        case OUTGOING_FAILURE:
            return "OUTGOING_FAILURE";
        case OUTGOING_CANCELED:
            return "OUTGOING_CANCELED";
        case IMS_MERGED_SUCCESSFULLY:
            return "IMS_MERGED_SUCCESSFULLY";
        case CDMA_ALREADY_ACTIVATED:
            return "CDMA_ALREADY_ACTIVATED";
        default:
            return "INVALID: " + cause;
    }
}
Body of Second Method:
{
    switch(cause) {
        case NOT_DISCONNECTED:
            return "NOT_DISCONNECTED";
        case INCOMING_MISSED:
            return "INCOMING_MISSED";
        case NORMAL:
            return "NORMAL";
        case LOCAL:
            return "LOCAL";
        case BUSY:
            return "BUSY";
        case CONGESTION:
            return "CONGESTION";
        case INVALID_NUMBER:
            return "INVALID_NUMBER";
        case NUMBER_UNREACHABLE:
            return "NUMBER_UNREACHABLE";
        case SERVER_UNREACHABLE:
            return "SERVER_UNREACHABLE";
        case INVALID_CREDENTIALS:
            return "INVALID_CREDENTIALS";
        case OUT_OF_NETWORK:
            return "OUT_OF_NETWORK";
        case SERVER_ERROR:
            return "SERVER_ERROR";
        case TIMED_OUT:
            return "TIMED_OUT";
        case LOST_SIGNAL:
            return "LOST_SIGNAL";
        case LIMIT_EXCEEDED:
            return "LIMIT_EXCEEDED";
        case INCOMING_REJECTED:
            return "INCOMING_REJECTED";
        case POWER_OFF:
            return "POWER_OFF";
        case OUT_OF_SERVICE:
            return "OUT_OF_SERVICE";
        case ICC_ERROR:
            return "ICC_ERROR";
        case CALL_BARRED:
            return "CALL_BARRED";
        case FDN_BLOCKED:
            return "FDN_BLOCKED";
        case CS_RESTRICTED:
            return "CS_RESTRICTED";
        case CS_RESTRICTED_NORMAL:
            return "CS_RESTRICTED_NORMAL";
        case CS_RESTRICTED_EMERGENCY:
            return "CS_RESTRICTED_EMERGENCY";
        case UNOBTAINABLE_NUMBER:
            return "UNOBTAINABLE_NUMBER";
        case CDMA_LOCKED_UNTIL_POWER_CYCLE:
            return "CDMA_LOCKED_UNTIL_POWER_CYCLE";
        case CDMA_DROP:
            return "CDMA_DROP";
        case CDMA_INTERCEPT:
            return "CDMA_INTERCEPT";
        case CDMA_REORDER:
            return "CDMA_REORDER";
        case CDMA_SO_REJECT:
            return "CDMA_SO_REJECT";
        case CDMA_RETRY_ORDER:
            return "CDMA_RETRY_ORDER";
        case CDMA_ACCESS_FAILURE:
            return "CDMA_ACCESS_FAILURE";
        case CDMA_PREEMPTED:
            return "CDMA_PREEMPTED";
        case CDMA_NOT_EMERGENCY:
            return "CDMA_NOT_EMERGENCY";
        case CDMA_ACCESS_BLOCKED:
            return "CDMA_ACCESS_BLOCKED";
        case EMERGENCY_ONLY:
            return "EMERGENCY_ONLY";
        case NO_PHONE_NUMBER_SUPPLIED:
            return "NO_PHONE_NUMBER_SUPPLIED";
        case DIALED_MMI:
            return "DIALED_MMI";
        case VOICEMAIL_NUMBER_MISSING:
            return "VOICEMAIL_NUMBER_MISSING";
        case CDMA_CALL_LOST:
            return "CDMA_CALL_LOST";
        case EXITED_ECM:
            return "EXITED_ECM";
        case DIAL_MODIFIED_TO_USSD:
            return "DIAL_MODIFIED_TO_USSD";
        case DIAL_MODIFIED_TO_SS:
            return "DIAL_MODIFIED_TO_SS";
        case DIAL_MODIFIED_TO_DIAL:
            return "DIAL_MODIFIED_TO_DIAL";
        case ERROR_UNSPECIFIED:
            return "ERROR_UNSPECIFIED";
        case OUTGOING_FAILURE:
            return "OUTGOING_FAILURE";
        case OUTGOING_CANCELED:
            return "OUTGOING_CANCELED";
        case IMS_MERGED_SUCCESSFULLY:
            return "IMS_MERGED_SUCCESSFULLY";
        case CDMA_ALREADY_ACTIVATED:
            return "CDMA_ALREADY_ACTIVATED";
        case VIDEO_CALL_NOT_ALLOWED_WHILE_TTY_ENABLED:
            return "VIDEO_CALL_NOT_ALLOWED_WHILE_TTY_ENABLED";
        default:
            return "INVALID: " + cause;
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothGatt.readCharacteristic:COMMENT
Method Modifier: public      
Comment:/**
 * Reads the requested characteristic from the associated remote device.
 *
 * <p>This is an asynchronous operation. The result of the read operation
 * is reported by the {@link BluetoothGattCallback#onCharacteristicRead}
 * callback.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param characteristic Characteristic to read from the remote device
 * @return true, if the read operation was initiated successfully
 */

Body of Frist Method:
{
    if ((characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_READ) == 0)
        return false;
    if (VDBG)
        Log.d(TAG, "readCharacteristic() - uuid: " + characteristic.getUuid());
    if (mService == null || mClientIf == 0)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusy) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.readCharacteristic(mClientIf, device.getAddress(), service.getType(), service.getInstanceId(), new ParcelUuid(service.getUuid()), characteristic.getInstanceId(), new ParcelUuid(characteristic.getUuid()), AUTHENTICATION_NONE);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}
Body of Second Method:
{
    if ((characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_READ) == 0)
        return false;
    if (VDBG)
        Log.d(TAG, "readCharacteristic() - uuid: " + characteristic.getUuid());
    if (mService == null || mClientIf == 0)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusy) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.readCharacteristic(mClientIf, device.getAddress(), characteristic.getInstanceId(), AUTHENTICATION_NONE);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}
------------------------
Find a silently evolved API code:android.media.AudioManager.getStreamMinVolume:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns the minimum volume index for a particular stream.
 *
 * @param streamType The stream type whose minimum volume index is returned.
 * @return The minimum valid volume index for the stream.
 * @see #getStreamVolume(int)
 * @hide
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        return service.getStreamMinVolume(streamType);
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in getStreamMinVolume", e);
        return 0;
    }
}
Body of Second Method:
{
    IAudioService service = getService();
    try {
        return service.getStreamMinVolume(streamType);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.util.Log.d:COMMENT
Method Modifier: public      static      
Comment:/**
 * Send a {@link #DEBUG} log message and log the exception.
 * @param tag Used to identify the source of a log message.  It usually identifies
 * the class or activity where the log call occurs.
 * @param msg The message you would like logged.
 * @param tr An exception to log
 */

Body of Frist Method:
{
    return println_native(LOG_ID_MAIN, DEBUG, tag, msg + '\n' + getStackTraceString(tr));
}
Body of Second Method:
{
    return printlns(LOG_ID_MAIN, DEBUG, tag, msg, tr);
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiManager.getControllerActivityEnergyInfo:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Return the record of {@link WifiActivityEnergyInfo} object that
 * has the activity and energy info. This can be used to ascertain what
 * the controller has been up to, since the last sample.
 * @param updateType Type of info, cached vs refreshed.
 *
 * @return a record with {@link WifiActivityEnergyInfo} or null if
 * report is unavailable or unsupported
 * @hide
 */

Body of Frist Method:
{
    if (mService == null)
        return null;
    try {
        WifiActivityEnergyInfo record;
        if (!isEnhancedPowerReportingSupported()) {
            return null;
        }
        synchronized (this) {
            record = mService.reportActivityInfo();
            if (record != null && record.isValid()) {
                return record;
            } else {
                return null;
            }
        }
    } catch (RemoteException e) {
        Log.e(TAG, "getControllerActivityEnergyInfo: " + e);
    }
    return null;
}
Body of Second Method:
{
    if (mService == null)
        return null;
    try {
        synchronized (this) {
            return mService.reportActivityInfo();
        }
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiScanner.ScanSettings.writeToParcel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Implement the Parcelable interface {@hide}
 */

Body of Frist Method:
{
    dest.writeInt(band);
    dest.writeInt(periodInMs);
    dest.writeInt(reportEvents);
    dest.writeInt(numBssidsPerScan);
    dest.writeInt(maxScansToCache);
    if (channels != null) {
        dest.writeInt(channels.length);
        for (int i = 0; i < channels.length; i++) {
            dest.writeInt(channels[i].frequency);
            dest.writeInt(channels[i].dwellTimeMS);
            dest.writeInt(channels[i].passive ? 1 : 0);
        }
    } else {
        dest.writeInt(0);
    }
}
Body of Second Method:
{
    dest.writeInt(band);
    dest.writeInt(periodInMs);
    dest.writeInt(reportEvents);
    dest.writeInt(numBssidsPerScan);
    dest.writeInt(maxScansToCache);
    dest.writeInt(maxPeriodInMs);
    dest.writeInt(stepCount);
    dest.writeInt(isPnoScan ? 1 : 0);
    if (channels != null) {
        dest.writeInt(channels.length);
        for (int i = 0; i < channels.length; i++) {
            dest.writeInt(channels[i].frequency);
            dest.writeInt(channels[i].dwellTimeMS);
            dest.writeInt(channels[i].passive ? 1 : 0);
        }
    } else {
        dest.writeInt(0);
    }
    dest.writeIntArray(hiddenNetworkIds);
}
------------------------
Find a silently evolved API code:android.app.AlarmManager.getNextWakeFromIdleTime:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    try {
        return mService.getNextWakeFromIdleTime();
    } catch (RemoteException ex) {
        return Long.MAX_VALUE;
    }
}
Body of Second Method:
{
    try {
        return mService.getNextWakeFromIdleTime();
    } catch (RemoteException ex) {
        throw ex.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.util.Log.w:COMMENT
Method Modifier: public      static      
Comment:/*
     * Send a {@link #WARN} log message and log the exception.
     * @param tag Used to identify the source of a log message.  It usually identifies
     *        the class or activity where the log call occurs.
     * @param tr An exception to log
     */

Body of Frist Method:
{
    return println_native(LOG_ID_MAIN, WARN, tag, getStackTraceString(tr));
}
Body of Second Method:
{
    return printlns(LOG_ID_MAIN, WARN, tag, "", tr);
}
------------------------
Find a silently evolved API code:android.telephony.SubscriptionManager.getDefaultDataPhoneId:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return getPhoneId(getDefaultDataSubId());
}
Body of Second Method:
{
    return getPhoneId(getDefaultDataSubscriptionId());
}
------------------------
Find a silently evolved API code:android.graphics.Path.set:COMMENT
Method Modifier: public      
Comment:/**
 * Replace the contents of this with the contents of src.
 */

Body of Frist Method:
{
    if (this != src) {
        isSimplePath = src.isSimplePath;
        native_set(mNativePath, src.mNativePath);
    }
}
Body of Second Method:
{
    if (this == src) {
        return;
    }
    isSimplePath = src.isSimplePath;
    native_set(mNativePath, src.mNativePath);
    if (!isSimplePath) {
        return;
    }
    if (rects != null && src.rects != null) {
        rects.set(src.rects);
    } else if (rects != null && src.rects == null) {
        rects.setEmpty();
    } else if (src.rects != null) {
        rects = new Region(src.rects);
    }
}
------------------------
Find a silently evolved API code:android.net.ConnectivityManager.getActiveNetworkInfo:COMMENT
Method Modifier: public      
Comment:/**
 * Returns details about the currently active default data network. When
 * connected, this network is the default route for outgoing connections.
 * You should always check {@link NetworkInfo#isConnected()} before initiating
 * network traffic. This may return {@code null} when there is no default
 * network.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
 *
 * @return a {@link NetworkInfo} object for the current default network
 * or {@code null} if no default network is currently active
 */

Body of Frist Method:
{
    try {
        return mService.getActiveNetworkInfo();
    } catch (RemoteException e) {
        return null;
    }
}
Body of Second Method:
{
    try {
        return mService.getActiveNetworkInfo();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.media.AudioManager.adjustStreamVolume:COMMENT
Method Modifier: public      
Comment:/**
 * Adjusts the volume of a particular stream by one step in a direction.
 * <p>
 * This method should only be used by applications that replace the platform-wide
 * management of audio settings or the main telephony application.
 *
 * @param streamType The stream type to adjust. One of {@link #STREAM_VOICE_CALL},
 * {@link #STREAM_SYSTEM}, {@link #STREAM_RING}, {@link #STREAM_MUSIC} or
 * {@link #STREAM_ALARM}
 * @param direction The direction to adjust the volume. One of
 * {@link #ADJUST_LOWER}, {@link #ADJUST_RAISE}, or
 * {@link #ADJUST_SAME}.
 * @param flags One or more flags.
 * @see #adjustVolume(int, int)
 * @see #setStreamVolume(int, int, int)
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        service.adjustStreamVolume(streamType, direction, flags, getContext().getOpPackageName());
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in adjustStreamVolume", e);
    }
}
Body of Second Method:
{
    IAudioService service = getService();
    try {
        service.adjustStreamVolume(streamType, direction, flags, getContext().getOpPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.security.keystore.KeyStoreCryptoOperationUtils.getInvalidKeyExceptionForInit:COMMENT
Method Modifier: default     static      hidden      
Comment:/**
 * Returns the {@link InvalidKeyException} to be thrown by the {@code init} method of
 * the crypto operation in response to {@code KeyStore.begin} operation or {@code null} if
 * the {@code init} method should succeed.
 */

Body of Frist Method:
{
    if (beginOpResultCode == KeyStore.NO_ERROR) {
        return null;
    }
    // An error occured. However, some errors should not lead to init throwing an exception.
    // See below.
    InvalidKeyException e = keyStore.getInvalidKeyException(key.getAlias(), beginOpResultCode);
    switch(beginOpResultCode) {
        case KeyStore.OP_AUTH_NEEDED:
            // the key is permanently invalidated (KeyPermanentlyInvalidatedException).
            if (e instanceof UserNotAuthenticatedException) {
                return null;
            }
            break;
    }
    return e;
}
Body of Second Method:
{
    if (beginOpResultCode == KeyStore.NO_ERROR) {
        return null;
    }
    // An error occured. However, some errors should not lead to init throwing an exception.
    // See below.
    InvalidKeyException e = keyStore.getInvalidKeyException(key.getAlias(), key.getUid(), beginOpResultCode);
    switch(beginOpResultCode) {
        case KeyStore.OP_AUTH_NEEDED:
            // the key is permanently invalidated (KeyPermanentlyInvalidatedException).
            if (e instanceof UserNotAuthenticatedException) {
                return null;
            }
            break;
    }
    return e;
}
------------------------
Find a silently evolved API code:android.telephony.SignalStrength.equals:COMMENT
Method Modifier: public      
Comment:/**
 * @return true if the signal strengths are the same
 */

Body of Frist Method:
{
    SignalStrength s;
    try {
        s = (SignalStrength) o;
    } catch (ClassCastException ex) {
        return false;
    }
    if (o == null) {
        return false;
    }
    return (mGsmSignalStrength == s.mGsmSignalStrength && mGsmBitErrorRate == s.mGsmBitErrorRate && mCdmaDbm == s.mCdmaDbm && mCdmaEcio == s.mCdmaEcio && mEvdoDbm == s.mEvdoDbm && mEvdoEcio == s.mEvdoEcio && mEvdoSnr == s.mEvdoSnr && mLteSignalStrength == s.mLteSignalStrength && mLteRsrp == s.mLteRsrp && mLteRsrq == s.mLteRsrq && mLteRssnr == s.mLteRssnr && mLteCqi == s.mLteCqi && isGsm == s.isGsm);
}
Body of Second Method:
{
    SignalStrength s;
    try {
        s = (SignalStrength) o;
    } catch (ClassCastException ex) {
        return false;
    }
    if (o == null) {
        return false;
    }
    return (mGsmSignalStrength == s.mGsmSignalStrength && mGsmBitErrorRate == s.mGsmBitErrorRate && mCdmaDbm == s.mCdmaDbm && mCdmaEcio == s.mCdmaEcio && mEvdoDbm == s.mEvdoDbm && mEvdoEcio == s.mEvdoEcio && mEvdoSnr == s.mEvdoSnr && mLteSignalStrength == s.mLteSignalStrength && mLteRsrp == s.mLteRsrp && mLteRsrq == s.mLteRsrq && mLteRssnr == s.mLteRssnr && mLteCqi == s.mLteCqi && mTdScdmaRscp == s.mTdScdmaRscp && isGsm == s.isGsm);
}
------------------------
Find a silently evolved API code:android.graphics.Bitmap.hasMipMap:COMMENT
Method Modifier: public      final       
Comment:/**
 * Indicates whether the renderer responsible for drawing this
 * bitmap should attempt to use mipmaps when this bitmap is drawn
 * scaled down.
 *
 * If you know that you are going to draw this bitmap at less than
 * 50% of its original size, you may be able to obtain a higher
 * quality
 *
 * This property is only a suggestion that can be ignored by the
 * renderer. It is not guaranteed to have any effect.
 *
 * @return true if the renderer should attempt to use mipmaps,
 * false otherwise
 *
 * @see #setHasMipMap(boolean)
 */

Body of Frist Method:
{
    if (mRecycled) {
        Log.w(TAG, "Called hasMipMap() on a recycle()'d bitmap! This is undefined behavior!");
    }
    return nativeHasMipMap(mFinalizer.mNativeBitmap);
}
Body of Second Method:
{
    if (mRecycled) {
        Log.w(TAG, "Called hasMipMap() on a recycle()'d bitmap! This is undefined behavior!");
    }
    return nativeHasMipMap(mNativePtr);
}
------------------------
Find a silently evolved API code:android.inputmethodservice.InputMethodService.onConfigurationChanged:COMMENT
Method Modifier: public      
Comment:/**
 * Take care of handling configuration changes.  Subclasses of
 * InputMethodService generally don't need to deal directly with
 * this on their own; the standard implementation here takes care of
 * regenerating the input method UI as a result of the configuration
 * change, so you can rely on your {@link #onCreateInputView} and
 * other methods being called as appropriate due to a configuration change.
 *
 * <p>When a configuration change does happen,
 * {@link #onInitializeInterface()} is guaranteed to be called the next
 * time prior to any of the other input or UI creation callbacks.  The
 * following will be called immediately depending if appropriate for current
 * state: {@link #onStartInput} if input is active, and
 * {@link #onCreateInputView} and {@link #onStartInputView} and related
 * appropriate functions if the UI is displayed.
 */

Body of Frist Method:
{
    super.onConfigurationChanged(newConfig);
    boolean visible = mWindowVisible;
    int showFlags = mShowInputFlags;
    boolean showingInput = mShowInputRequested;
    CompletionInfo[] completions = mCurCompletions;
    initViews();
    mInputViewStarted = false;
    mCandidatesViewStarted = false;
    if (mInputStarted) {
        doStartInput(getCurrentInputConnection(), getCurrentInputEditorInfo(), true);
    }
    if (visible) {
        if (showingInput) {
            // If we were last showing the soft keyboard, try to do so again.
            if (onShowInputRequested(showFlags, true)) {
                showWindow(true);
                if (completions != null) {
                    mCurCompletions = completions;
                    onDisplayCompletions(completions);
                }
            } else {
                doHideWindow();
            }
        } else if (mCandidatesVisibility == View.VISIBLE) {
            // If the candidates are currently visible, make sure the
            // window is shown for them.
            showWindow(false);
        } else {
            // Otherwise hide the window.
            doHideWindow();
        }
        // If user uses hard keyboard, IME button should always be shown.
        boolean showing = onEvaluateInputViewShown();
        mImm.setImeWindowStatus(mToken, IME_ACTIVE | (showing ? IME_VISIBLE : 0), mBackDisposition);
    }
}
Body of Second Method:
{
    super.onConfigurationChanged(newConfig);
    resetStateForNewConfiguration();
}
------------------------
Find a silently evolved API code:android.widget.ListPopupWindow.buildDropDown:COMMENT
Method Modifier: private     
Comment:/**
 * <p>Builds the popup window's content and returns the height the popup
 * should have. Returns -1 when the content already exists.</p>
 *
 * @return the content's height or -1 if content already exists
 */

Body of Frist Method:
{
    ViewGroup dropDownView;
    int otherHeights = 0;
    if (mDropDownList == null) {
        Context context = mContext;
        /**
         * This Runnable exists for the sole purpose of checking if the view layout has got
         * completed and if so call showDropDown to display the drop down. This is used to show
         * the drop down as soon as possible after user opens up the search dialog, without
         * waiting for the normal UI pipeline to do it's job which is slower than this method.
         */
        mShowDropDownRunnable = new Runnable() {

            public void run() {
                // View layout should be all done before displaying the drop down.
                View view = getAnchorView();
                if (view != null && view.getWindowToken() != null) {
                    show();
                }
            }
        };
        mDropDownList = new DropDownListView(context, !mModal);
        if (mDropDownListHighlight != null) {
            mDropDownList.setSelector(mDropDownListHighlight);
        }
        mDropDownList.setAdapter(mAdapter);
        mDropDownList.setOnItemClickListener(mItemClickListener);
        mDropDownList.setFocusable(true);
        mDropDownList.setFocusableInTouchMode(true);
        mDropDownList.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {

            public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {
                if (position != -1) {
                    DropDownListView dropDownList = mDropDownList;
                    if (dropDownList != null) {
                        dropDownList.mListSelectionHidden = false;
                    }
                }
            }

            public void onNothingSelected(AdapterView<?> parent) {
            }
        });
        mDropDownList.setOnScrollListener(mScrollListener);
        if (mItemSelectedListener != null) {
            mDropDownList.setOnItemSelectedListener(mItemSelectedListener);
        }
        dropDownView = mDropDownList;
        View hintView = mPromptView;
        if (hintView != null) {
            // if a hint has been specified, we accomodate more space for it and
            // add a text view in the drop down menu, at the bottom of the list
            LinearLayout hintContainer = new LinearLayout(context);
            hintContainer.setOrientation(LinearLayout.VERTICAL);
            LinearLayout.LayoutParams hintParams = new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, 0, 1.0f);
            switch(mPromptPosition) {
                case POSITION_PROMPT_BELOW:
                    hintContainer.addView(dropDownView, hintParams);
                    hintContainer.addView(hintView);
                    break;
                case POSITION_PROMPT_ABOVE:
                    hintContainer.addView(hintView);
                    hintContainer.addView(dropDownView, hintParams);
                    break;
                default:
                    Log.e(TAG, "Invalid hint position " + mPromptPosition);
                    break;
            }
            // Measure the hint's height to find how much more vertical
            // space we need to add to the drop down's height.
            final int widthSize;
            final int widthMode;
            if (mDropDownWidth >= 0) {
                widthMode = MeasureSpec.AT_MOST;
                widthSize = mDropDownWidth;
            } else {
                widthMode = MeasureSpec.UNSPECIFIED;
                widthSize = 0;
            }
            final int widthSpec = MeasureSpec.makeMeasureSpec(widthSize, widthMode);
            final int heightSpec = MeasureSpec.UNSPECIFIED;
            hintView.measure(widthSpec, heightSpec);
            hintParams = (LinearLayout.LayoutParams) hintView.getLayoutParams();
            otherHeights = hintView.getMeasuredHeight() + hintParams.topMargin + hintParams.bottomMargin;
            dropDownView = hintContainer;
        }
        mPopup.setContentView(dropDownView);
    } else {
        dropDownView = (ViewGroup) mPopup.getContentView();
        final View view = mPromptView;
        if (view != null) {
            LinearLayout.LayoutParams hintParams = (LinearLayout.LayoutParams) view.getLayoutParams();
            otherHeights = view.getMeasuredHeight() + hintParams.topMargin + hintParams.bottomMargin;
        }
    }
    // getMaxAvailableHeight() subtracts the padding, so we put it back
    // to get the available height for the whole window
    int padding = 0;
    Drawable background = mPopup.getBackground();
    if (background != null) {
        background.getPadding(mTempRect);
        padding = mTempRect.top + mTempRect.bottom;
        // background so that content will line up.
        if (!mDropDownVerticalOffsetSet) {
            mDropDownVerticalOffset = -mTempRect.top;
        }
    } else {
        mTempRect.setEmpty();
    }
    // Max height available on the screen for a popup.
    boolean ignoreBottomDecorations = mPopup.getInputMethodMode() == PopupWindow.INPUT_METHOD_NOT_NEEDED;
    final int maxHeight = mPopup.getMaxAvailableHeight(getAnchorView(), mDropDownVerticalOffset, ignoreBottomDecorations);
    if (mDropDownAlwaysVisible || mDropDownHeight == ViewGroup.LayoutParams.MATCH_PARENT) {
        return maxHeight + padding;
    }
    final int childWidthSpec;
    switch(mDropDownWidth) {
        case ViewGroup.LayoutParams.WRAP_CONTENT:
            childWidthSpec = MeasureSpec.makeMeasureSpec(mContext.getResources().getDisplayMetrics().widthPixels - (mTempRect.left + mTempRect.right), MeasureSpec.AT_MOST);
            break;
        case ViewGroup.LayoutParams.MATCH_PARENT:
            childWidthSpec = MeasureSpec.makeMeasureSpec(mContext.getResources().getDisplayMetrics().widthPixels - (mTempRect.left + mTempRect.right), MeasureSpec.EXACTLY);
            break;
        default:
            childWidthSpec = MeasureSpec.makeMeasureSpec(mDropDownWidth, MeasureSpec.EXACTLY);
            break;
    }
    final int listContent = mDropDownList.measureHeightOfChildren(childWidthSpec, 0, ListView.NO_POSITION, maxHeight - otherHeights, -1);
    // the popup if it is not needed
    if (listContent > 0)
        otherHeights += padding;
    return listContent + otherHeights;
}
Body of Second Method:
{
    ViewGroup dropDownView;
    int otherHeights = 0;
    if (mDropDownList == null) {
        Context context = mContext;
        /**
         * This Runnable exists for the sole purpose of checking if the view layout has got
         * completed and if so call showDropDown to display the drop down. This is used to show
         * the drop down as soon as possible after user opens up the search dialog, without
         * waiting for the normal UI pipeline to do it's job which is slower than this method.
         */
        mShowDropDownRunnable = new Runnable() {

            public void run() {
                // View layout should be all done before displaying the drop down.
                View view = getAnchorView();
                if (view != null && view.getWindowToken() != null) {
                    show();
                }
            }
        };
        mDropDownList = createDropDownListView(context, !mModal);
        if (mDropDownListHighlight != null) {
            mDropDownList.setSelector(mDropDownListHighlight);
        }
        mDropDownList.setAdapter(mAdapter);
        mDropDownList.setOnItemClickListener(mItemClickListener);
        mDropDownList.setFocusable(true);
        mDropDownList.setFocusableInTouchMode(true);
        mDropDownList.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {

            public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {
                if (position != -1) {
                    DropDownListView dropDownList = mDropDownList;
                    if (dropDownList != null) {
                        dropDownList.setListSelectionHidden(false);
                    }
                }
            }

            public void onNothingSelected(AdapterView<?> parent) {
            }
        });
        mDropDownList.setOnScrollListener(mScrollListener);
        if (mItemSelectedListener != null) {
            mDropDownList.setOnItemSelectedListener(mItemSelectedListener);
        }
        dropDownView = mDropDownList;
        View hintView = mPromptView;
        if (hintView != null) {
            // if a hint has been specified, we accomodate more space for it and
            // add a text view in the drop down menu, at the bottom of the list
            LinearLayout hintContainer = new LinearLayout(context);
            hintContainer.setOrientation(LinearLayout.VERTICAL);
            LinearLayout.LayoutParams hintParams = new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, 0, 1.0f);
            switch(mPromptPosition) {
                case POSITION_PROMPT_BELOW:
                    hintContainer.addView(dropDownView, hintParams);
                    hintContainer.addView(hintView);
                    break;
                case POSITION_PROMPT_ABOVE:
                    hintContainer.addView(hintView);
                    hintContainer.addView(dropDownView, hintParams);
                    break;
                default:
                    Log.e(TAG, "Invalid hint position " + mPromptPosition);
                    break;
            }
            // Measure the hint's height to find how much more vertical
            // space we need to add to the drop down's height.
            final int widthSize;
            final int widthMode;
            if (mDropDownWidth >= 0) {
                widthMode = MeasureSpec.AT_MOST;
                widthSize = mDropDownWidth;
            } else {
                widthMode = MeasureSpec.UNSPECIFIED;
                widthSize = 0;
            }
            final int widthSpec = MeasureSpec.makeMeasureSpec(widthSize, widthMode);
            final int heightSpec = MeasureSpec.UNSPECIFIED;
            hintView.measure(widthSpec, heightSpec);
            hintParams = (LinearLayout.LayoutParams) hintView.getLayoutParams();
            otherHeights = hintView.getMeasuredHeight() + hintParams.topMargin + hintParams.bottomMargin;
            dropDownView = hintContainer;
        }
        mPopup.setContentView(dropDownView);
    } else {
        final View view = mPromptView;
        if (view != null) {
            LinearLayout.LayoutParams hintParams = (LinearLayout.LayoutParams) view.getLayoutParams();
            otherHeights = view.getMeasuredHeight() + hintParams.topMargin + hintParams.bottomMargin;
        }
    }
    // getMaxAvailableHeight() subtracts the padding, so we put it back
    // to get the available height for the whole window.
    final int padding;
    final Drawable background = mPopup.getBackground();
    if (background != null) {
        background.getPadding(mTempRect);
        padding = mTempRect.top + mTempRect.bottom;
        // the window background so that content will line up.
        if (!mDropDownVerticalOffsetSet) {
            mDropDownVerticalOffset = -mTempRect.top;
        }
    } else {
        mTempRect.setEmpty();
        padding = 0;
    }
    // Max height available on the screen for a popup.
    final boolean ignoreBottomDecorations = mPopup.getInputMethodMode() == PopupWindow.INPUT_METHOD_NOT_NEEDED;
    final int maxHeight = mPopup.getMaxAvailableHeight(getAnchorView(), mDropDownVerticalOffset, ignoreBottomDecorations);
    if (mDropDownAlwaysVisible || mDropDownHeight == ViewGroup.LayoutParams.MATCH_PARENT) {
        return maxHeight + padding;
    }
    final int childWidthSpec;
    switch(mDropDownWidth) {
        case ViewGroup.LayoutParams.WRAP_CONTENT:
            childWidthSpec = MeasureSpec.makeMeasureSpec(mContext.getResources().getDisplayMetrics().widthPixels - (mTempRect.left + mTempRect.right), MeasureSpec.AT_MOST);
            break;
        case ViewGroup.LayoutParams.MATCH_PARENT:
            childWidthSpec = MeasureSpec.makeMeasureSpec(mContext.getResources().getDisplayMetrics().widthPixels - (mTempRect.left + mTempRect.right), MeasureSpec.EXACTLY);
            break;
        default:
            childWidthSpec = MeasureSpec.makeMeasureSpec(mDropDownWidth, MeasureSpec.EXACTLY);
            break;
    }
    // Add padding only if the list has items in it, that way we don't show
    // the popup if it is not needed.
    final int listContent = mDropDownList.measureHeightOfChildren(childWidthSpec, 0, DropDownListView.NO_POSITION, maxHeight - otherHeights, -1);
    if (listContent > 0) {
        final int listPadding = mDropDownList.getPaddingTop() + mDropDownList.getPaddingBottom();
        otherHeights += padding + listPadding;
    }
    return listContent + otherHeights;
}
------------------------
Find a silently evolved API code:android.view.inputmethod.BaseInputConnection.sendKeyEvent:COMMENT
Method Modifier: public      
Comment:/**
 * Provides standard implementation for sending a key event to the window
 * attached to the input connection's view.
 */

Body of Frist Method:
{
    synchronized (mIMM.mH) {
        ViewRootImpl viewRootImpl = mTargetView != null ? mTargetView.getViewRootImpl() : null;
        if (viewRootImpl == null) {
            if (mIMM.mServedView != null) {
                viewRootImpl = mIMM.mServedView.getViewRootImpl();
            }
        }
        if (viewRootImpl != null) {
            viewRootImpl.dispatchKeyFromIme(event);
        }
    }
    mIMM.notifyUserAction();
    return false;
}
Body of Second Method:
{
    mIMM.dispatchKeyEventFromInputMethod(mTargetView, event);
    return false;
}
------------------------
Find a silently evolved API code:android.accessibilityservice.AccessibilityServiceInfo.capabilityToString:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns the string representation of a capability. For example,
 * {@link #CAPABILITY_CAN_RETRIEVE_WINDOW_CONTENT} is represented
 * by the string CAPABILITY_CAN_RETRIEVE_WINDOW_CONTENT.
 *
 * @param capability The capability.
 * @return The string representation.
 */

Body of Frist Method:
{
    switch(capability) {
        case CAPABILITY_CAN_RETRIEVE_WINDOW_CONTENT:
            return "CAPABILITY_CAN_RETRIEVE_WINDOW_CONTENT";
        case CAPABILITY_CAN_REQUEST_TOUCH_EXPLORATION:
            return "CAPABILITY_CAN_REQUEST_TOUCH_EXPLORATION";
        case CAPABILITY_CAN_REQUEST_ENHANCED_WEB_ACCESSIBILITY:
            return "CAPABILITY_CAN_REQUEST_ENHANCED_WEB_ACCESSIBILITY";
        case CAPABILITY_CAN_REQUEST_FILTER_KEY_EVENTS:
            return "CAPABILITY_CAN_FILTER_KEY_EVENTS";
        default:
            return "UNKNOWN";
    }
}
Body of Second Method:
{
    switch(capability) {
        case CAPABILITY_CAN_RETRIEVE_WINDOW_CONTENT:
            return "CAPABILITY_CAN_RETRIEVE_WINDOW_CONTENT";
        case CAPABILITY_CAN_REQUEST_TOUCH_EXPLORATION:
            return "CAPABILITY_CAN_REQUEST_TOUCH_EXPLORATION";
        case CAPABILITY_CAN_REQUEST_ENHANCED_WEB_ACCESSIBILITY:
            return "CAPABILITY_CAN_REQUEST_ENHANCED_WEB_ACCESSIBILITY";
        case CAPABILITY_CAN_REQUEST_FILTER_KEY_EVENTS:
            return "CAPABILITY_CAN_FILTER_KEY_EVENTS";
        case CAPABILITY_CAN_CONTROL_MAGNIFICATION:
            return "CAPABILITY_CAN_CONTROL_MAGNIFICATION";
        case CAPABILITY_CAN_PERFORM_GESTURES:
            return "CAPABILITY_CAN_PERFORM_GESTURES";
        default:
            return "UNKNOWN";
    }
}
------------------------
Find a silently evolved API code:android.widget.AutoCompleteTextView.setCompletionHint:COMMENT
Method Modifier: public      
Comment:/**
 * <p>Sets the optional hint text that is displayed at the bottom of the
 * the matching list.  This can be used as a cue to the user on how to
 * best use the list, or to provide extra information.</p>
 *
 * @param hint the text to be displayed to the user
 *
 * @see #getCompletionHint()
 *
 * @attr ref android.R.styleable#AutoCompleteTextView_completionHint
 */

Body of Frist Method:
{
    mHintText = hint;
    if (hint != null) {
        if (mHintView == null) {
            final TextView hintView = (TextView) LayoutInflater.from(getContext()).inflate(mHintResource, null).findViewById(com.android.internal.R.id.text1);
            hintView.setText(mHintText);
            mHintView = hintView;
            mPopup.setPromptView(hintView);
        } else {
            mHintView.setText(hint);
        }
    } else {
        mPopup.setPromptView(null);
        mHintView = null;
    }
}
Body of Second Method:
{
    mHintText = hint;
    if (hint != null) {
        if (mHintView == null) {
            final TextView hintView = (TextView) LayoutInflater.from(mPopupContext).inflate(mHintResource, null).findViewById(R.id.text1);
            hintView.setText(mHintText);
            mHintView = hintView;
            mPopup.setPromptView(hintView);
        } else {
            mHintView.setText(hint);
        }
    } else {
        mPopup.setPromptView(null);
        mHintView = null;
    }
}
------------------------
Find a silently evolved API code:android.graphics.Bitmap.setPixel:COMMENT
Method Modifier: public      
Comment:/**
 * <p>Write the specified {@link Color} into the bitmap (assuming it is
 * mutable) at the x,y coordinate. The color must be a
 * non-premultiplied ARGB value.</p>
 *
 * @param x     The x coordinate of the pixel to replace (0...width-1)
 * @param y     The y coordinate of the pixel to replace (0...height-1)
 * @param color The ARGB color to write into the bitmap
 *
 * @throws IllegalStateException if the bitmap is not mutable
 * @throws IllegalArgumentException if x, y are outside of the bitmap's
 * bounds.
 */

Body of Frist Method:
{
    checkRecycled("Can't call setPixel() on a recycled bitmap");
    if (!isMutable()) {
        throw new IllegalStateException();
    }
    checkPixelAccess(x, y);
    nativeSetPixel(mFinalizer.mNativeBitmap, x, y, color);
}
Body of Second Method:
{
    checkRecycled("Can't call setPixel() on a recycled bitmap");
    if (!isMutable()) {
        throw new IllegalStateException();
    }
    checkPixelAccess(x, y);
    nativeSetPixel(mNativePtr, x, y, color);
}
------------------------
Find a silently evolved API code:android.appwidget.AppWidgetHostView.setAppWidget:COMMENT
Method Modifier: public      
Comment:/**
 * Set the AppWidget that will be displayed by this view. This method also adds default padding
 * to widgets, as described in {@link #getDefaultPaddingForWidget(Context, ComponentName, Rect)}
 * and can be overridden in order to add custom padding.
 */

Body of Frist Method:
{
    mAppWidgetId = appWidgetId;
    mInfo = info;
    // a widget, eg. for some widgets in safe mode.
    if (info != null) {
        // We add padding to the AppWidgetHostView if necessary
        Rect padding = getDefaultPaddingForWidget(mContext, info.provider, null);
        setPadding(padding.left, padding.top, padding.right, padding.bottom);
        setContentDescription(info.label);
    }
}
Body of Second Method:
{
    mAppWidgetId = appWidgetId;
    mInfo = info;
    // a widget, eg. for some widgets in safe mode.
    if (info != null) {
        // We add padding to the AppWidgetHostView if necessary
        Rect padding = getDefaultPaddingForWidget(mContext, info.provider, null);
        setPadding(padding.left, padding.top, padding.right, padding.bottom);
        updateContentDescription(info);
    }
}
------------------------
Find a silently evolved API code:android.widget.LinearLayout.getLastNonGoneChild:COMMENT
Method Modifier: private     
Comment:/**
 * Finds the last child that is not gone. The last child will be used as the reference for
 * where the end divider should be drawn.
 */

Body of Frist Method:
{
    for (int i = getVirtualChildCount() - 1; i >= 0; i--) {
        View child = getVirtualChildAt(i);
        if (child != null && child.getVisibility() != GONE) {
            return child;
        }
    }
    return null;
}
Body of Second Method:
{
    for (int i = getVirtualChildCount() - 1; i >= 0; i--) {
        final View child = getVirtualChildAt(i);
        if (child != null && child.getVisibility() != GONE) {
            return child;
        }
    }
    return null;
}
------------------------
Find a silently evolved API code:android.app.admin.DeviceAdminInfo.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Used to package this object into a {@link Parcel}.
 *
 * @param dest The {@link Parcel} to be written.
 * @param flags The flags used for parceling.
 */

Body of Frist Method:
{
    mReceiver.writeToParcel(dest, flags);
    dest.writeInt(mUsesPolicies);
}
Body of Second Method:
{
    mActivityInfo.writeToParcel(dest, flags);
    dest.writeInt(mUsesPolicies);
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiManager.initializeMulticastFiltering:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Initialize the multicast filtering to 'on'
 * @hide no intent to publish
 */

Body of Frist Method:
{
    try {
        mService.initializeMulticastFiltering();
        return true;
    } catch (RemoteException e) {
        return false;
    }
}
Body of Second Method:
{
    try {
        mService.initializeMulticastFiltering();
        return true;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.os.SystemClock_Delegate.currentThreadTimeMillis:COMMENT
Method Modifier: default     static      
Comment:/**
 * Returns milliseconds running in the current thread.
 *
 * @return elapsed milliseconds in the thread
 */

Body of Frist Method:
{
    return System.currentTimeMillis();
}
Body of Second Method:
{
    return System_Delegate.currentTimeMillis();
}
------------------------
Find a silently evolved API code:android.media.midi.MidiDevice.openOutputPort:COMMENT
Method Modifier: public      
Comment:/**
 * Called to open a {@link MidiOutputPort} for the specified port number.
 *
 * An output port may be opened by multiple applications.
 *
 * @param portNumber the number of the output port to open
 * @return the {@link MidiOutputPort} if the open is successful,
 * or null in case of failure.
 */

Body of Frist Method:
{
    try {
        IBinder token = new Binder();
        ParcelFileDescriptor pfd = mDeviceServer.openOutputPort(token, portNumber);
        if (pfd == null) {
            return null;
        }
        return new MidiOutputPort(mDeviceServer, token, pfd, portNumber);
    } catch (RemoteException e) {
        Log.e(TAG, "RemoteException in openOutputPort");
        return null;
    }
}
Body of Second Method:
{
    if (mIsDeviceClosed) {
        return null;
    }
    try {
        IBinder token = new Binder();
        ParcelFileDescriptor pfd = mDeviceServer.openOutputPort(token, portNumber);
        if (pfd == null) {
            return null;
        }
        return new MidiOutputPort(mDeviceServer, token, pfd, portNumber);
    } catch (RemoteException e) {
        Log.e(TAG, "RemoteException in openOutputPort");
        return null;
    }
}
------------------------
Find a silently evolved API code:android.telephony.TelephonyManager.getCdmaMin:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return getCdmaMin(getDefaultSubscription());
}
Body of Second Method:
{
    return getCdmaMin(getSubId());
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiSsid.getHexString:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    String out = "0x";
    byte[] ssidbytes = getOctets();
    for (int i = 0; i < octets.size(); i++) {
        out += String.format(Locale.US, "%02x", ssidbytes[i]);
    }
    return out;
}
Body of Second Method:
{
    String out = "0x";
    byte[] ssidbytes = getOctets();
    for (int i = 0; i < octets.size(); i++) {
        out += String.format(Locale.US, "%02x", ssidbytes[i]);
    }
    return (octets.size() > 0) ? out : null;
}
------------------------
Find a silently evolved API code:android.widget.TextView.onResolveDrawables:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    // No need to resolve twice
    if (mLastLayoutDirection == layoutDirection) {
        return;
    }
    mLastLayoutDirection = layoutDirection;
    // Resolve drawables
    if (mDrawables != null) {
        mDrawables.resolveWithLayoutDirection(layoutDirection);
    }
}
Body of Second Method:
{
    // No need to resolve twice
    if (mLastLayoutDirection == layoutDirection) {
        return;
    }
    mLastLayoutDirection = layoutDirection;
    // Resolve drawables
    if (mDrawables != null) {
        if (mDrawables.resolveWithLayoutDirection(layoutDirection)) {
            prepareDrawableForDisplay(mDrawables.mShowing[Drawables.LEFT]);
            prepareDrawableForDisplay(mDrawables.mShowing[Drawables.RIGHT]);
            applyCompoundDrawableTint();
        }
    }
}
------------------------
Find a silently evolved API code:android.telephony.CellSignalStrengthGsm.toString:COMMENT
Method Modifier: public      
Comment:/**
 * @return string representation.
 */

Body of Frist Method:
{
    return "CellSignalStrengthGsm:" + " ss=" + mSignalStrength + " ber=" + mBitErrorRate;
}
Body of Second Method:
{
    return "CellSignalStrengthGsm:" + " ss=" + mSignalStrength + " ber=" + mBitErrorRate + " mTa=" + mTimingAdvance;
}
------------------------
Find a silently evolved API code:android.nfc.NfcAdapter.attemptDeadServiceRecovery:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * NFC service dead - attempt best effort recovery
 * @hide
 */

Body of Frist Method:
{
    Log.e(TAG, "NFC service dead - attempting to recover", e);
    INfcAdapter service = getServiceInterface();
    if (service == null) {
        Log.e(TAG, "could not retrieve NFC service during service recovery");
        // this recovery path again later
        return;
    }
    // assigning to sService is not thread-safe, but this is best-effort code
    // and on a well-behaved system should never happen
    sService = service;
    try {
        sTagService = service.getNfcTagInterface();
    } catch (RemoteException ee) {
        Log.e(TAG, "could not retrieve NFC tag service during service recovery");
        // this recovery path again later
        return;
    }
    try {
        sCardEmulationService = service.getNfcCardEmulationInterface();
    } catch (RemoteException ee) {
        Log.e(TAG, "could not retrieve NFC card emulation service during service recovery");
    }
    return;
}
Body of Second Method:
{
    Log.e(TAG, "NFC service dead - attempting to recover", e);
    INfcAdapter service = getServiceInterface();
    if (service == null) {
        Log.e(TAG, "could not retrieve NFC service during service recovery");
        // this recovery path again later
        return;
    }
    // assigning to sService is not thread-safe, but this is best-effort code
    // and on a well-behaved system should never happen
    sService = service;
    try {
        sTagService = service.getNfcTagInterface();
    } catch (RemoteException ee) {
        Log.e(TAG, "could not retrieve NFC tag service during service recovery");
        // this recovery path again later
        return;
    }
    try {
        sCardEmulationService = service.getNfcCardEmulationInterface();
    } catch (RemoteException ee) {
        Log.e(TAG, "could not retrieve NFC card emulation service during service recovery");
    }
    try {
        sNfcFCardEmulationService = service.getNfcFCardEmulationInterface();
    } catch (RemoteException ee) {
        Log.e(TAG, "could not retrieve NFC-F card emulation service during service recovery");
    }
    return;
}
------------------------
Find a silently evolved API code:android.app.SearchManager.getAssistIntent:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Gets an intent for launching installed assistant activity, or null if not available.
 * @return The assist intent.
 *
 * @hide
 */

Body of Frist Method:
{
    try {
        Intent intent = new Intent(Intent.ACTION_ASSIST);
        if (inclContext) {
            IActivityManager am = ActivityManagerNative.getDefault();
            Bundle extras = am.getAssistContextExtras(ActivityManager.ASSIST_CONTEXT_BASIC);
            if (extras != null) {
                intent.replaceExtras(extras);
            }
        }
        return intent;
    } catch (RemoteException re) {
        Log.e(TAG, "getAssistIntent() failed: " + re);
        return null;
    }
}
Body of Second Method:
{
    try {
        Intent intent = new Intent(Intent.ACTION_ASSIST);
        if (inclContext) {
            IActivityManager am = ActivityManagerNative.getDefault();
            Bundle extras = am.getAssistContextExtras(ActivityManager.ASSIST_CONTEXT_BASIC);
            if (extras != null) {
                intent.replaceExtras(extras);
            }
        }
        return intent;
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.app.ActivityManager.getFrontActivityScreenCompatMode:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    try {
        return ActivityManagerNative.getDefault().getFrontActivityScreenCompatMode();
    } catch (RemoteException e) {
        // System dead, we will be dead too soon!
        return 0;
    }
}
Body of Second Method:
{
    try {
        return ActivityManagerNative.getDefault().getFrontActivityScreenCompatMode();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.telephony.TelephonyManager.getCdmaEriIconIndex:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns the CDMA ERI icon index to display
 *
 * <p>
 * Requires Permission:
 * {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}
 * @hide
 */

Body of Frist Method:
{
    return getCdmaEriIconIndex(getDefaultSubscription());
}
Body of Second Method:
{
    return getCdmaEriIconIndex(getSubId());
}
------------------------
Find a silently evolved API code:android.media.AudioManager.unloadSoundEffects:COMMENT
Method Modifier: public      
Comment:/**
 * Unload Sound effects.
 * This method can be called to free some memory when
 * sound effects are disabled.
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        service.unloadSoundEffects();
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in unloadSoundEffects" + e);
    }
}
Body of Second Method:
{
    IAudioService service = getService();
    try {
        service.unloadSoundEffects();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.app.SearchManager.launchLegacyAssist:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Starts the legacy assistant (i.e. the {@link Intent#ACTION_ASSIST}).
 *
 * @param args the args to pass to the assistant
 *
 * @hide
 */

Body of Frist Method:
{
    try {
        if (mService == null) {
            return false;
        }
        return mService.launchLegacyAssist(hint, userHandle, args);
    } catch (RemoteException re) {
        Log.e(TAG, "launchAssist() failed: " + re);
        return false;
    }
}
Body of Second Method:
{
    try {
        if (mService == null) {
            return false;
        }
        return mService.launchLegacyAssist(hint, userHandle, args);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.appwidget.AppWidgetManager.getAppWidgetIds:COMMENT
Method Modifier: public      
Comment:/**
 * Get the list of appWidgetIds that have been bound to the given AppWidget
 * provider.
 *
 * @param provider The {@link android.content.BroadcastReceiver} that is the
 * AppWidget provider to find appWidgetIds for.
 */

Body of Frist Method:
{
    if (mService == null) {
        return new int[0];
    }
    try {
        return mService.getAppWidgetIds(provider);
    } catch (RemoteException e) {
        throw new RuntimeException("system server dead?", e);
    }
}
Body of Second Method:
{
    if (mService == null) {
        return new int[0];
    }
    try {
        return mService.getAppWidgetIds(provider);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.media.MediaRecorder.getAudioSourceMax:COMMENT
Method Modifier: public      static      final       
Comment:/**
 * Gets the maximum value for audio sources.
 * @see android.media.MediaRecorder.AudioSource
 */

Body of Frist Method:
{
    return AudioSource.REMOTE_SUBMIX;
}
Body of Second Method:
{
    return AudioSource.UNPROCESSED;
}
------------------------
Find a silently evolved API code:android.app.StatusBarManager.disable2:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Disable additional status bar features. Pass the bitwise-or of the DISABLE2_* flags.
 * To re-enable everything, pass {@link #DISABLE_NONE}.
 *
 * Warning: Only pass DISABLE2_* flags into this function, do not use DISABLE_* flags.
 */

Body of Frist Method:
{
    try {
        final IStatusBarService svc = getService();
        if (svc != null) {
            svc.disable2(what, mToken, mContext.getPackageName());
        }
    } catch (RemoteException ex) {
        // system process is dead anyway.
        throw new RuntimeException(ex);
    }
}
Body of Second Method:
{
    try {
        final IStatusBarService svc = getService();
        if (svc != null) {
            svc.disable2(what, mToken, mContext.getPackageName());
        }
    } catch (RemoteException ex) {
        throw ex.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.service.persistentdata.PersistentDataBlockManager.write:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Writes {@code data} to the persistent partition. Previously written data
 * will be overwritten. This data will persist across factory resets.
 *
 * Returns the number of bytes written or -1 on error. If the block is too big
 * to fit on the partition, returns -MAX_BLOCK_SIZE.
 *
 * @param data the data to write
 */

Body of Frist Method:
{
    try {
        return sService.write(data);
    } catch (RemoteException e) {
        onError("writing data");
        return -1;
    }
}
Body of Second Method:
{
    try {
        return sService.write(data);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.text.StaticLayout.generate:COMMENT
Method Modifier: default     
Comment:/* package */

Body of Frist Method:
{
    CharSequence source = b.mText;
    int bufStart = b.mStart;
    int bufEnd = b.mEnd;
    TextPaint paint = b.mPaint;
    int outerWidth = b.mWidth;
    TextDirectionHeuristic textDir = b.mTextDir;
    float spacingmult = b.mSpacingMult;
    float spacingadd = b.mSpacingAdd;
    float ellipsizedWidth = b.mEllipsizedWidth;
    TextUtils.TruncateAt ellipsize = b.mEllipsize;
    // TODO: move to builder to avoid allocation costs
    LineBreaks lineBreaks = new LineBreaks();
    // store span end locations
    int[] spanEndCache = new int[4];
    // store fontMetrics per span range
    // must be a multiple of 4 (and > 0) (store top, bottom, ascent, and descent per range)
    int[] fmCache = new int[4 * 4];
    // TODO: also respect LocaleSpan within the text
    b.setLocale(paint.getTextLocale());
    mLineCount = 0;
    int v = 0;
    boolean needMultiply = (spacingmult != 1 || spacingadd != 0);
    Paint.FontMetricsInt fm = b.mFontMetricsInt;
    int[] chooseHtv = null;
    MeasuredText measured = b.mMeasuredText;
    Spanned spanned = null;
    if (source instanceof Spanned)
        spanned = (Spanned) source;
    int paraEnd;
    for (int paraStart = bufStart; paraStart <= bufEnd; paraStart = paraEnd) {
        paraEnd = TextUtils.indexOf(source, CHAR_NEW_LINE, paraStart, bufEnd);
        if (paraEnd < 0)
            paraEnd = bufEnd;
        else
            paraEnd++;
        int firstWidthLineCount = 1;
        int firstWidth = outerWidth;
        int restWidth = outerWidth;
        LineHeightSpan[] chooseHt = null;
        if (spanned != null) {
            LeadingMarginSpan[] sp = getParagraphSpans(spanned, paraStart, paraEnd, LeadingMarginSpan.class);
            for (int i = 0; i < sp.length; i++) {
                LeadingMarginSpan lms = sp[i];
                firstWidth -= sp[i].getLeadingMargin(true);
                restWidth -= sp[i].getLeadingMargin(false);
                // leading margin spans, not just this particular one
                if (lms instanceof LeadingMarginSpan2) {
                    LeadingMarginSpan2 lms2 = (LeadingMarginSpan2) lms;
                    firstWidthLineCount = Math.max(firstWidthLineCount, lms2.getLeadingMarginLineCount());
                }
            }
            chooseHt = getParagraphSpans(spanned, paraStart, paraEnd, LineHeightSpan.class);
            if (chooseHt.length != 0) {
                if (chooseHtv == null || chooseHtv.length < chooseHt.length) {
                    chooseHtv = ArrayUtils.newUnpaddedIntArray(chooseHt.length);
                }
                for (int i = 0; i < chooseHt.length; i++) {
                    int o = spanned.getSpanStart(chooseHt[i]);
                    if (o < paraStart) {
                        // starts in this layout, before the
                        // current paragraph
                        chooseHtv[i] = getLineTop(getLineForOffset(o));
                    } else {
                        // starts in this paragraph
                        chooseHtv[i] = v;
                    }
                }
            }
        }
        measured.setPara(source, paraStart, paraEnd, textDir, b);
        char[] chs = measured.mChars;
        float[] widths = measured.mWidths;
        byte[] chdirs = measured.mLevels;
        int dir = measured.mDir;
        boolean easy = measured.mEasy;
        // tab stop locations
        int[] variableTabStops = null;
        if (spanned != null) {
            TabStopSpan[] spans = getParagraphSpans(spanned, paraStart, paraEnd, TabStopSpan.class);
            if (spans.length > 0) {
                int[] stops = new int[spans.length];
                for (int i = 0; i < spans.length; i++) {
                    stops[i] = spans[i].getTabStop();
                }
                Arrays.sort(stops, 0, stops.length);
                variableTabStops = stops;
            }
        }
        nSetupParagraph(b.mNativePtr, chs, paraEnd - paraStart, firstWidth, firstWidthLineCount, restWidth, variableTabStops, TAB_INCREMENT, b.mBreakStrategy, b.mHyphenationFrequency);
        if (mLeftIndents != null || mRightIndents != null) {
            // TODO(raph) performance: it would be better to do this once per layout rather
            // than once per paragraph, but that would require a change to the native
            // interface.
            int leftLen = mLeftIndents == null ? 0 : mLeftIndents.length;
            int rightLen = mRightIndents == null ? 0 : mRightIndents.length;
            int indentsLen = Math.max(1, Math.min(leftLen, rightLen) - mLineCount);
            int[] indents = new int[indentsLen];
            for (int i = 0; i < indentsLen; i++) {
                int leftMargin = mLeftIndents == null ? 0 : mLeftIndents[Math.min(i + mLineCount, leftLen - 1)];
                int rightMargin = mRightIndents == null ? 0 : mRightIndents[Math.min(i + mLineCount, rightLen - 1)];
                indents[i] = leftMargin + rightMargin;
            }
            nSetIndents(b.mNativePtr, indents);
        }
        // measurement has to be done before performing line breaking
        // but we don't want to recompute fontmetrics or span ranges the
        // second time, so we cache those and then use those stored values
        int fmCacheCount = 0;
        int spanEndCacheCount = 0;
        for (int spanStart = paraStart, spanEnd; spanStart < paraEnd; spanStart = spanEnd) {
            if (fmCacheCount * 4 >= fmCache.length) {
                int[] grow = new int[fmCacheCount * 4 * 2];
                System.arraycopy(fmCache, 0, grow, 0, fmCacheCount * 4);
                fmCache = grow;
            }
            if (spanEndCacheCount >= spanEndCache.length) {
                int[] grow = new int[spanEndCacheCount * 2];
                System.arraycopy(spanEndCache, 0, grow, 0, spanEndCacheCount);
                spanEndCache = grow;
            }
            if (spanned == null) {
                spanEnd = paraEnd;
                int spanLen = spanEnd - spanStart;
                measured.addStyleRun(paint, spanLen, fm);
            } else {
                spanEnd = spanned.nextSpanTransition(spanStart, paraEnd, MetricAffectingSpan.class);
                int spanLen = spanEnd - spanStart;
                MetricAffectingSpan[] spans = spanned.getSpans(spanStart, spanEnd, MetricAffectingSpan.class);
                spans = TextUtils.removeEmptySpans(spans, spanned, MetricAffectingSpan.class);
                measured.addStyleRun(paint, spans, spanLen, fm);
            }
            // the order of storage here (top, bottom, ascent, descent) has to match the code below
            // where these values are retrieved
            fmCache[fmCacheCount * 4 + 0] = fm.top;
            fmCache[fmCacheCount * 4 + 1] = fm.bottom;
            fmCache[fmCacheCount * 4 + 2] = fm.ascent;
            fmCache[fmCacheCount * 4 + 3] = fm.descent;
            fmCacheCount++;
            spanEndCache[spanEndCacheCount] = spanEnd;
            spanEndCacheCount++;
        }
        nGetWidths(b.mNativePtr, widths);
        int breakCount = nComputeLineBreaks(b.mNativePtr, lineBreaks, lineBreaks.breaks, lineBreaks.widths, lineBreaks.flags, lineBreaks.breaks.length);
        int[] breaks = lineBreaks.breaks;
        float[] lineWidths = lineBreaks.widths;
        int[] flags = lineBreaks.flags;
        final int remainingLineCount = mMaximumVisibleLineCount - mLineCount;
        final boolean ellipsisMayBeApplied = ellipsize != null && (ellipsize == TextUtils.TruncateAt.END || (mMaximumVisibleLineCount == 1 && ellipsize != TextUtils.TruncateAt.MARQUEE));
        if (remainingLineCount > 0 && remainingLineCount < breakCount && ellipsisMayBeApplied) {
            // Treat the last line and overflowed lines as a single line.
            breaks[remainingLineCount - 1] = breaks[breakCount - 1];
            // Calculate width and flag.
            float width = 0;
            int flag = 0;
            for (int i = remainingLineCount - 1; i < breakCount; i++) {
                width += lineWidths[i];
                flag |= flags[i] & TAB_MASK;
            }
            lineWidths[remainingLineCount - 1] = width;
            flags[remainingLineCount - 1] = flag;
            breakCount = remainingLineCount;
        }
        // here is the offset of the starting character of the line we are currently measuring
        int here = paraStart;
        int fmTop = 0, fmBottom = 0, fmAscent = 0, fmDescent = 0;
        int fmCacheIndex = 0;
        int spanEndCacheIndex = 0;
        int breakIndex = 0;
        for (int spanStart = paraStart, spanEnd; spanStart < paraEnd; spanStart = spanEnd) {
            // retrieve end of span
            spanEnd = spanEndCache[spanEndCacheIndex++];
            // retrieve cached metrics, order matches above
            fm.top = fmCache[fmCacheIndex * 4 + 0];
            fm.bottom = fmCache[fmCacheIndex * 4 + 1];
            fm.ascent = fmCache[fmCacheIndex * 4 + 2];
            fm.descent = fmCache[fmCacheIndex * 4 + 3];
            fmCacheIndex++;
            if (fm.top < fmTop) {
                fmTop = fm.top;
            }
            if (fm.ascent < fmAscent) {
                fmAscent = fm.ascent;
            }
            if (fm.descent > fmDescent) {
                fmDescent = fm.descent;
            }
            if (fm.bottom > fmBottom) {
                fmBottom = fm.bottom;
            }
            // skip breaks ending before current span range
            while (breakIndex < breakCount && paraStart + breaks[breakIndex] < spanStart) {
                breakIndex++;
            }
            while (breakIndex < breakCount && paraStart + breaks[breakIndex] <= spanEnd) {
                int endPos = paraStart + breaks[breakIndex];
                boolean moreChars = (endPos < bufEnd);
                v = out(source, here, endPos, fmAscent, fmDescent, fmTop, fmBottom, v, spacingmult, spacingadd, chooseHt, chooseHtv, fm, flags[breakIndex], needMultiply, chdirs, dir, easy, bufEnd, includepad, trackpad, chs, widths, paraStart, ellipsize, ellipsizedWidth, lineWidths[breakIndex], paint, moreChars);
                if (endPos < spanEnd) {
                    // preserve metrics for current span
                    fmTop = fm.top;
                    fmBottom = fm.bottom;
                    fmAscent = fm.ascent;
                    fmDescent = fm.descent;
                } else {
                    fmTop = fmBottom = fmAscent = fmDescent = 0;
                }
                here = endPos;
                breakIndex++;
                if (mLineCount >= mMaximumVisibleLineCount) {
                    return;
                }
            }
        }
        if (paraEnd == bufEnd)
            break;
    }
    if ((bufEnd == bufStart || source.charAt(bufEnd - 1) == CHAR_NEW_LINE) && mLineCount < mMaximumVisibleLineCount) {
        // Log.e("text", "output last " + bufEnd);
        measured.setPara(source, bufEnd, bufEnd, textDir, b);
        paint.getFontMetricsInt(fm);
        v = out(source, bufEnd, bufEnd, fm.ascent, fm.descent, fm.top, fm.bottom, v, spacingmult, spacingadd, null, null, fm, 0, needMultiply, measured.mLevels, measured.mDir, measured.mEasy, bufEnd, includepad, trackpad, null, null, bufStart, ellipsize, ellipsizedWidth, 0, paint, false);
    }
}
Body of Second Method:
{
    CharSequence source = b.mText;
    int bufStart = b.mStart;
    int bufEnd = b.mEnd;
    TextPaint paint = b.mPaint;
    int outerWidth = b.mWidth;
    TextDirectionHeuristic textDir = b.mTextDir;
    float spacingmult = b.mSpacingMult;
    float spacingadd = b.mSpacingAdd;
    float ellipsizedWidth = b.mEllipsizedWidth;
    TextUtils.TruncateAt ellipsize = b.mEllipsize;
    // TODO: move to builder to avoid allocation costs
    LineBreaks lineBreaks = new LineBreaks();
    // store span end locations
    int[] spanEndCache = new int[4];
    // store fontMetrics per span range
    // must be a multiple of 4 (and > 0) (store top, bottom, ascent, and descent per range)
    int[] fmCache = new int[4 * 4];
    // TODO: also respect LocaleSpan within the text
    b.setLocale(paint.getTextLocale());
    mLineCount = 0;
    int v = 0;
    boolean needMultiply = (spacingmult != 1 || spacingadd != 0);
    Paint.FontMetricsInt fm = b.mFontMetricsInt;
    int[] chooseHtv = null;
    MeasuredText measured = b.mMeasuredText;
    Spanned spanned = null;
    if (source instanceof Spanned)
        spanned = (Spanned) source;
    int paraEnd;
    for (int paraStart = bufStart; paraStart <= bufEnd; paraStart = paraEnd) {
        paraEnd = TextUtils.indexOf(source, CHAR_NEW_LINE, paraStart, bufEnd);
        if (paraEnd < 0)
            paraEnd = bufEnd;
        else
            paraEnd++;
        int firstWidthLineCount = 1;
        int firstWidth = outerWidth;
        int restWidth = outerWidth;
        LineHeightSpan[] chooseHt = null;
        if (spanned != null) {
            LeadingMarginSpan[] sp = getParagraphSpans(spanned, paraStart, paraEnd, LeadingMarginSpan.class);
            for (int i = 0; i < sp.length; i++) {
                LeadingMarginSpan lms = sp[i];
                firstWidth -= sp[i].getLeadingMargin(true);
                restWidth -= sp[i].getLeadingMargin(false);
                // leading margin spans, not just this particular one
                if (lms instanceof LeadingMarginSpan2) {
                    LeadingMarginSpan2 lms2 = (LeadingMarginSpan2) lms;
                    firstWidthLineCount = Math.max(firstWidthLineCount, lms2.getLeadingMarginLineCount());
                }
            }
            chooseHt = getParagraphSpans(spanned, paraStart, paraEnd, LineHeightSpan.class);
            if (chooseHt.length == 0) {
                // So that out() would not assume it has any contents
                chooseHt = null;
            } else {
                if (chooseHtv == null || chooseHtv.length < chooseHt.length) {
                    chooseHtv = ArrayUtils.newUnpaddedIntArray(chooseHt.length);
                }
                for (int i = 0; i < chooseHt.length; i++) {
                    int o = spanned.getSpanStart(chooseHt[i]);
                    if (o < paraStart) {
                        // starts in this layout, before the
                        // current paragraph
                        chooseHtv[i] = getLineTop(getLineForOffset(o));
                    } else {
                        // starts in this paragraph
                        chooseHtv[i] = v;
                    }
                }
            }
        }
        measured.setPara(source, paraStart, paraEnd, textDir, b);
        char[] chs = measured.mChars;
        float[] widths = measured.mWidths;
        byte[] chdirs = measured.mLevels;
        int dir = measured.mDir;
        boolean easy = measured.mEasy;
        // tab stop locations
        int[] variableTabStops = null;
        if (spanned != null) {
            TabStopSpan[] spans = getParagraphSpans(spanned, paraStart, paraEnd, TabStopSpan.class);
            if (spans.length > 0) {
                int[] stops = new int[spans.length];
                for (int i = 0; i < spans.length; i++) {
                    stops[i] = spans[i].getTabStop();
                }
                Arrays.sort(stops, 0, stops.length);
                variableTabStops = stops;
            }
        }
        nSetupParagraph(b.mNativePtr, chs, paraEnd - paraStart, firstWidth, firstWidthLineCount, restWidth, variableTabStops, TAB_INCREMENT, b.mBreakStrategy, b.mHyphenationFrequency);
        if (mLeftIndents != null || mRightIndents != null) {
            // TODO(raph) performance: it would be better to do this once per layout rather
            // than once per paragraph, but that would require a change to the native
            // interface.
            int leftLen = mLeftIndents == null ? 0 : mLeftIndents.length;
            int rightLen = mRightIndents == null ? 0 : mRightIndents.length;
            int indentsLen = Math.max(1, Math.max(leftLen, rightLen) - mLineCount);
            int[] indents = new int[indentsLen];
            for (int i = 0; i < indentsLen; i++) {
                int leftMargin = mLeftIndents == null ? 0 : mLeftIndents[Math.min(i + mLineCount, leftLen - 1)];
                int rightMargin = mRightIndents == null ? 0 : mRightIndents[Math.min(i + mLineCount, rightLen - 1)];
                indents[i] = leftMargin + rightMargin;
            }
            nSetIndents(b.mNativePtr, indents);
        }
        // measurement has to be done before performing line breaking
        // but we don't want to recompute fontmetrics or span ranges the
        // second time, so we cache those and then use those stored values
        int fmCacheCount = 0;
        int spanEndCacheCount = 0;
        for (int spanStart = paraStart, spanEnd; spanStart < paraEnd; spanStart = spanEnd) {
            if (fmCacheCount * 4 >= fmCache.length) {
                int[] grow = new int[fmCacheCount * 4 * 2];
                System.arraycopy(fmCache, 0, grow, 0, fmCacheCount * 4);
                fmCache = grow;
            }
            if (spanEndCacheCount >= spanEndCache.length) {
                int[] grow = new int[spanEndCacheCount * 2];
                System.arraycopy(spanEndCache, 0, grow, 0, spanEndCacheCount);
                spanEndCache = grow;
            }
            if (spanned == null) {
                spanEnd = paraEnd;
                int spanLen = spanEnd - spanStart;
                measured.addStyleRun(paint, spanLen, fm);
            } else {
                spanEnd = spanned.nextSpanTransition(spanStart, paraEnd, MetricAffectingSpan.class);
                int spanLen = spanEnd - spanStart;
                MetricAffectingSpan[] spans = spanned.getSpans(spanStart, spanEnd, MetricAffectingSpan.class);
                spans = TextUtils.removeEmptySpans(spans, spanned, MetricAffectingSpan.class);
                measured.addStyleRun(paint, spans, spanLen, fm);
            }
            // the order of storage here (top, bottom, ascent, descent) has to match the code below
            // where these values are retrieved
            fmCache[fmCacheCount * 4 + 0] = fm.top;
            fmCache[fmCacheCount * 4 + 1] = fm.bottom;
            fmCache[fmCacheCount * 4 + 2] = fm.ascent;
            fmCache[fmCacheCount * 4 + 3] = fm.descent;
            fmCacheCount++;
            spanEndCache[spanEndCacheCount] = spanEnd;
            spanEndCacheCount++;
        }
        nGetWidths(b.mNativePtr, widths);
        int breakCount = nComputeLineBreaks(b.mNativePtr, lineBreaks, lineBreaks.breaks, lineBreaks.widths, lineBreaks.flags, lineBreaks.breaks.length);
        int[] breaks = lineBreaks.breaks;
        float[] lineWidths = lineBreaks.widths;
        int[] flags = lineBreaks.flags;
        final int remainingLineCount = mMaximumVisibleLineCount - mLineCount;
        final boolean ellipsisMayBeApplied = ellipsize != null && (ellipsize == TextUtils.TruncateAt.END || (mMaximumVisibleLineCount == 1 && ellipsize != TextUtils.TruncateAt.MARQUEE));
        if (remainingLineCount > 0 && remainingLineCount < breakCount && ellipsisMayBeApplied) {
            // Calculate width and flag.
            float width = 0;
            int flag = 0;
            for (int i = remainingLineCount - 1; i < breakCount; i++) {
                if (i == breakCount - 1) {
                    width += lineWidths[i];
                } else {
                    for (int j = (i == 0 ? 0 : breaks[i - 1]); j < breaks[i]; j++) {
                        width += widths[j];
                    }
                }
                flag |= flags[i] & TAB_MASK;
            }
            // Treat the last line and overflowed lines as a single line.
            breaks[remainingLineCount - 1] = breaks[breakCount - 1];
            lineWidths[remainingLineCount - 1] = width;
            flags[remainingLineCount - 1] = flag;
            breakCount = remainingLineCount;
        }
        // here is the offset of the starting character of the line we are currently measuring
        int here = paraStart;
        int fmTop = 0, fmBottom = 0, fmAscent = 0, fmDescent = 0;
        int fmCacheIndex = 0;
        int spanEndCacheIndex = 0;
        int breakIndex = 0;
        for (int spanStart = paraStart, spanEnd; spanStart < paraEnd; spanStart = spanEnd) {
            // retrieve end of span
            spanEnd = spanEndCache[spanEndCacheIndex++];
            // retrieve cached metrics, order matches above
            fm.top = fmCache[fmCacheIndex * 4 + 0];
            fm.bottom = fmCache[fmCacheIndex * 4 + 1];
            fm.ascent = fmCache[fmCacheIndex * 4 + 2];
            fm.descent = fmCache[fmCacheIndex * 4 + 3];
            fmCacheIndex++;
            if (fm.top < fmTop) {
                fmTop = fm.top;
            }
            if (fm.ascent < fmAscent) {
                fmAscent = fm.ascent;
            }
            if (fm.descent > fmDescent) {
                fmDescent = fm.descent;
            }
            if (fm.bottom > fmBottom) {
                fmBottom = fm.bottom;
            }
            // skip breaks ending before current span range
            while (breakIndex < breakCount && paraStart + breaks[breakIndex] < spanStart) {
                breakIndex++;
            }
            while (breakIndex < breakCount && paraStart + breaks[breakIndex] <= spanEnd) {
                int endPos = paraStart + breaks[breakIndex];
                boolean moreChars = (endPos < bufEnd);
                v = out(source, here, endPos, fmAscent, fmDescent, fmTop, fmBottom, v, spacingmult, spacingadd, chooseHt, chooseHtv, fm, flags[breakIndex], needMultiply, chdirs, dir, easy, bufEnd, includepad, trackpad, chs, widths, paraStart, ellipsize, ellipsizedWidth, lineWidths[breakIndex], paint, moreChars);
                if (endPos < spanEnd) {
                    // preserve metrics for current span
                    fmTop = fm.top;
                    fmBottom = fm.bottom;
                    fmAscent = fm.ascent;
                    fmDescent = fm.descent;
                } else {
                    fmTop = fmBottom = fmAscent = fmDescent = 0;
                }
                here = endPos;
                breakIndex++;
                if (mLineCount >= mMaximumVisibleLineCount) {
                    return;
                }
            }
        }
        if (paraEnd == bufEnd)
            break;
    }
    if ((bufEnd == bufStart || source.charAt(bufEnd - 1) == CHAR_NEW_LINE) && mLineCount < mMaximumVisibleLineCount) {
        // Log.e("text", "output last " + bufEnd);
        measured.setPara(source, bufEnd, bufEnd, textDir, b);
        paint.getFontMetricsInt(fm);
        v = out(source, bufEnd, bufEnd, fm.ascent, fm.descent, fm.top, fm.bottom, v, spacingmult, spacingadd, null, null, fm, 0, needMultiply, measured.mLevels, measured.mDir, measured.mEasy, bufEnd, includepad, trackpad, null, null, bufStart, ellipsize, ellipsizedWidth, 0, paint, false);
    }
}
------------------------
Find a silently evolved API code:android.app.admin.DeviceAdminReceiver.onReceive:COMMENT
Method Modifier: public      
Comment:/**
 * Intercept standard device administrator broadcasts.  Implementations
 * should not override this method; it is better to implement the
 * convenience callbacks for each action.
 */

Body of Frist Method:
{
    String action = intent.getAction();
    if (ACTION_PASSWORD_CHANGED.equals(action)) {
        onPasswordChanged(context, intent);
    } else if (ACTION_PASSWORD_FAILED.equals(action)) {
        onPasswordFailed(context, intent);
    } else if (ACTION_PASSWORD_SUCCEEDED.equals(action)) {
        onPasswordSucceeded(context, intent);
    } else if (ACTION_DEVICE_ADMIN_ENABLED.equals(action)) {
        onEnabled(context, intent);
    } else if (ACTION_DEVICE_ADMIN_DISABLE_REQUESTED.equals(action)) {
        CharSequence res = onDisableRequested(context, intent);
        if (res != null) {
            Bundle extras = getResultExtras(true);
            extras.putCharSequence(EXTRA_DISABLE_WARNING, res);
        }
    } else if (ACTION_DEVICE_ADMIN_DISABLED.equals(action)) {
        onDisabled(context, intent);
    } else if (ACTION_PASSWORD_EXPIRING.equals(action)) {
        onPasswordExpiring(context, intent);
    } else if (ACTION_PROFILE_PROVISIONING_COMPLETE.equals(action)) {
        onProfileProvisioningComplete(context, intent);
    } else if (ACTION_CHOOSE_PRIVATE_KEY_ALIAS.equals(action)) {
        int uid = intent.getIntExtra(EXTRA_CHOOSE_PRIVATE_KEY_SENDER_UID, -1);
        Uri uri = intent.getParcelableExtra(EXTRA_CHOOSE_PRIVATE_KEY_URI);
        String alias = intent.getStringExtra(EXTRA_CHOOSE_PRIVATE_KEY_ALIAS);
        String chosenAlias = onChoosePrivateKeyAlias(context, intent, uid, uri, alias);
        setResultData(chosenAlias);
    } else if (ACTION_LOCK_TASK_ENTERING.equals(action)) {
        String pkg = intent.getStringExtra(EXTRA_LOCK_TASK_PACKAGE);
        onLockTaskModeEntering(context, intent, pkg);
    } else if (ACTION_LOCK_TASK_EXITING.equals(action)) {
        onLockTaskModeExiting(context, intent);
    } else if (ACTION_READY_FOR_USER_INITIALIZATION.equals(action)) {
        onReadyForUserInitialization(context, intent);
    } else if (ACTION_NOTIFY_PENDING_SYSTEM_UPDATE.equals(action)) {
        long receivedTime = intent.getLongExtra(EXTRA_SYSTEM_UPDATE_RECEIVED_TIME, -1);
        onSystemUpdatePending(context, intent, receivedTime);
    }
}
Body of Second Method:
{
    String action = intent.getAction();
    if (ACTION_PASSWORD_CHANGED.equals(action)) {
        onPasswordChanged(context, intent);
    } else if (ACTION_PASSWORD_FAILED.equals(action)) {
        onPasswordFailed(context, intent);
    } else if (ACTION_PASSWORD_SUCCEEDED.equals(action)) {
        onPasswordSucceeded(context, intent);
    } else if (ACTION_DEVICE_ADMIN_ENABLED.equals(action)) {
        onEnabled(context, intent);
    } else if (ACTION_DEVICE_ADMIN_DISABLE_REQUESTED.equals(action)) {
        CharSequence res = onDisableRequested(context, intent);
        if (res != null) {
            Bundle extras = getResultExtras(true);
            extras.putCharSequence(EXTRA_DISABLE_WARNING, res);
        }
    } else if (ACTION_DEVICE_ADMIN_DISABLED.equals(action)) {
        onDisabled(context, intent);
    } else if (ACTION_PASSWORD_EXPIRING.equals(action)) {
        onPasswordExpiring(context, intent);
    } else if (ACTION_PROFILE_PROVISIONING_COMPLETE.equals(action)) {
        onProfileProvisioningComplete(context, intent);
    } else if (ACTION_CHOOSE_PRIVATE_KEY_ALIAS.equals(action)) {
        int uid = intent.getIntExtra(EXTRA_CHOOSE_PRIVATE_KEY_SENDER_UID, -1);
        Uri uri = intent.getParcelableExtra(EXTRA_CHOOSE_PRIVATE_KEY_URI);
        String alias = intent.getStringExtra(EXTRA_CHOOSE_PRIVATE_KEY_ALIAS);
        String chosenAlias = onChoosePrivateKeyAlias(context, intent, uid, uri, alias);
        setResultData(chosenAlias);
    } else if (ACTION_LOCK_TASK_ENTERING.equals(action)) {
        String pkg = intent.getStringExtra(EXTRA_LOCK_TASK_PACKAGE);
        onLockTaskModeEntering(context, intent, pkg);
    } else if (ACTION_LOCK_TASK_EXITING.equals(action)) {
        onLockTaskModeExiting(context, intent);
    } else if (ACTION_NOTIFY_PENDING_SYSTEM_UPDATE.equals(action)) {
        long receivedTime = intent.getLongExtra(EXTRA_SYSTEM_UPDATE_RECEIVED_TIME, -1);
        onSystemUpdatePending(context, intent, receivedTime);
    } else if (ACTION_BUGREPORT_SHARING_DECLINED.equals(action)) {
        onBugreportSharingDeclined(context, intent);
    } else if (ACTION_BUGREPORT_SHARE.equals(action)) {
        String bugreportFileHash = intent.getStringExtra(EXTRA_BUGREPORT_HASH);
        onBugreportShared(context, intent, bugreportFileHash);
    } else if (ACTION_BUGREPORT_FAILED.equals(action)) {
        int failureCode = intent.getIntExtra(EXTRA_BUGREPORT_FAILURE_REASON, BUGREPORT_FAILURE_FAILED_COMPLETING);
        onBugreportFailed(context, intent, failureCode);
    } else if (ACTION_SECURITY_LOGS_AVAILABLE.equals(action)) {
        onSecurityLogsAvailable(context, intent);
    }
}
------------------------
Find a silently evolved API code:android.app.ActivityManager.setFrontActivityScreenCompatMode:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    try {
        ActivityManagerNative.getDefault().setFrontActivityScreenCompatMode(mode);
    } catch (RemoteException e) {
    // System dead, we will be dead too soon!
    }
}
Body of Second Method:
{
    try {
        ActivityManagerNative.getDefault().setFrontActivityScreenCompatMode(mode);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.net.LinkProperties.hasIPv4AddressOnInterface:COMMENT
Method Modifier: private     
Comment:/**
 * Returns true if this link or any of its stacked interfaces has an IPv4 address.
 *
 * @return {@code true} if there is an IPv4 address, {@code false} otherwise.
 */

Body of Frist Method:
{
    return (mIfaceName.equals(iface) && hasIPv4Address()) || (iface != null && mStackedLinks.containsKey(iface) && mStackedLinks.get(iface).hasIPv4Address());
}
Body of Second Method:
{
    // mIfaceName can be null.
    return (Objects.equals(iface, mIfaceName) && hasIPv4Address()) || (iface != null && mStackedLinks.containsKey(iface) && mStackedLinks.get(iface).hasIPv4Address());
}
------------------------
Find a silently evolved API code:android.animation.AnimatorInflater.setupAnimatorForPath:COMMENT
Method Modifier: private     static      
Comment:/**
 * Setup the Animator to achieve path morphing.
 *
 * @param anim The target Animator which will be updated.
 * @param arrayAnimator TypedArray for the ValueAnimator.
 * @return the PathDataEvaluator.
 */

Body of Frist Method:
{
    TypeEvaluator evaluator = null;
    String fromString = arrayAnimator.getString(R.styleable.Animator_valueFrom);
    String toString = arrayAnimator.getString(R.styleable.Animator_valueTo);
    PathParser.PathDataNode[] nodesFrom = PathParser.createNodesFromPathData(fromString);
    PathParser.PathDataNode[] nodesTo = PathParser.createNodesFromPathData(toString);
    if (nodesFrom != null) {
        if (nodesTo != null) {
            anim.setObjectValues(nodesFrom, nodesTo);
            if (!PathParser.canMorph(nodesFrom, nodesTo)) {
                throw new InflateException(arrayAnimator.getPositionDescription() + " Can't morph from " + fromString + " to " + toString);
            }
        } else {
            anim.setObjectValues((Object) nodesFrom);
        }
        evaluator = new PathDataEvaluator(PathParser.deepCopyNodes(nodesFrom));
    } else if (nodesTo != null) {
        anim.setObjectValues((Object) nodesTo);
        evaluator = new PathDataEvaluator(PathParser.deepCopyNodes(nodesTo));
    }
    if (DBG_ANIMATOR_INFLATER && evaluator != null) {
        Log.v(TAG, "create a new PathDataEvaluator here");
    }
    return evaluator;
}
Body of Second Method:
{
    TypeEvaluator evaluator = null;
    String fromString = arrayAnimator.getString(R.styleable.Animator_valueFrom);
    String toString = arrayAnimator.getString(R.styleable.Animator_valueTo);
    PathParser.PathData pathDataFrom = fromString == null ? null : new PathParser.PathData(fromString);
    PathParser.PathData pathDataTo = toString == null ? null : new PathParser.PathData(toString);
    if (pathDataFrom != null) {
        if (pathDataTo != null) {
            anim.setObjectValues(pathDataFrom, pathDataTo);
            if (!PathParser.canMorph(pathDataFrom, pathDataTo)) {
                throw new InflateException(arrayAnimator.getPositionDescription() + " Can't morph from " + fromString + " to " + toString);
            }
        } else {
            anim.setObjectValues((Object) pathDataFrom);
        }
        evaluator = new PathDataEvaluator();
    } else if (pathDataTo != null) {
        anim.setObjectValues((Object) pathDataTo);
        evaluator = new PathDataEvaluator();
    }
    if (DBG_ANIMATOR_INFLATER && evaluator != null) {
        Log.v(TAG, "create a new PathDataEvaluator here");
    }
    return evaluator;
}
------------------------
Find a silently evolved API code:android.media.AudioFormat.Builder.setChannelMask:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the channel position mask.
 * The channel position mask specifies the association between audio samples in a frame
 * with named endpoint channels. The samples in the frame correspond to the
 * named set bits in the channel position mask, in ascending bit order.
 * See {@link #setChannelIndexMask(int)} to specify channels
 * based on endpoint numbered channels. This <a href="#channelPositionMask>description of
 * channel position masks</a> covers the concept in more details.
 * @param channelMask describes the configuration of the audio channels.
 * <p> For output, the channelMask can be an OR-ed combination of
 * channel position masks, e.g.
 * {@link AudioFormat#CHANNEL_OUT_FRONT_LEFT},
 * {@link AudioFormat#CHANNEL_OUT_FRONT_RIGHT},
 * {@link AudioFormat#CHANNEL_OUT_FRONT_CENTER},
 * {@link AudioFormat#CHANNEL_OUT_LOW_FREQUENCY}
 * {@link AudioFormat#CHANNEL_OUT_BACK_LEFT},
 * {@link AudioFormat#CHANNEL_OUT_BACK_RIGHT},
 * {@link AudioFormat#CHANNEL_OUT_BACK_CENTER},
 * {@link AudioFormat#CHANNEL_OUT_SIDE_LEFT},
 * {@link AudioFormat#CHANNEL_OUT_SIDE_RIGHT}.
 * <p> For a valid {@link AudioTrack} channel position mask,
 * the following conditions apply:
 * <br> (1) at most eight channel positions may be used;
 * <br> (2) right/left pairs should be matched.
 * <p> For input or {@link AudioRecord}, the mask should be
 * {@link AudioFormat#CHANNEL_IN_MONO} or
 * {@link AudioFormat#CHANNEL_IN_STEREO}.  {@link AudioFormat#CHANNEL_IN_MONO} is
 * guaranteed to work on all devices.
 * @return the same <code>Builder</code> instance.
 * @throws IllegalArgumentException if the channel mask is invalid or
 * if both channel index mask and channel position mask
 * are specified but do not have the same channel count.
 */

Body of Frist Method:
{
    if (channelMask == 0) {
        throw new IllegalArgumentException("Invalid zero channel mask");
    } else if (/* channelMask != 0 && */
    mChannelIndexMask != 0 && Integer.bitCount(channelMask) != Integer.bitCount(mChannelIndexMask)) {
        throw new IllegalArgumentException("Mismatched channel count for mask " + Integer.toHexString(channelMask).toUpperCase());
    }
    mChannelMask = channelMask;
    mPropertySetMask |= AUDIO_FORMAT_HAS_PROPERTY_CHANNEL_MASK;
    return this;
}
Body of Second Method:
{
    if (channelMask == CHANNEL_INVALID) {
        throw new IllegalArgumentException("Invalid zero channel mask");
    } else if (/* channelMask != 0 && */
    mChannelIndexMask != 0 && Integer.bitCount(channelMask) != Integer.bitCount(mChannelIndexMask)) {
        throw new IllegalArgumentException("Mismatched channel count for mask " + Integer.toHexString(channelMask).toUpperCase());
    }
    mChannelMask = channelMask;
    mPropertySetMask |= AUDIO_FORMAT_HAS_PROPERTY_CHANNEL_MASK;
    return this;
}
------------------------
Find a silently evolved API code:android.telecom.VideoCallImpl.sendSessionModifyRequest:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sends a session modification request to the video provider.
 * <p>
 * The {@link InCallService} will create the {@code requestProfile} based on the current
 * video state (i.e. {@link Call.Details#getVideoState()}).  It is, however, possible that the
 * video state maintained by the {@link InCallService} could get out of sync with what is known
 * by the {@link android.telecom.Connection.VideoProvider}.  To remove ambiguity, the
 * {@link VideoCallImpl} passes along the pre-modify video profile to the {@code VideoProvider}
 * to ensure it has full context of the requested change.
 *
 * @param requestProfile The requested video profile.
 */

Body of Frist Method:
{
    try {
        VideoProfile originalProfile = new VideoProfile(mCall.getDetails().getVideoState(), mVideoQuality);
        mVideoProvider.sendSessionModifyRequest(originalProfile, requestProfile);
    } catch (RemoteException e) {
    }
}
Body of Second Method:
{
    try {
        VideoProfile originalProfile = new VideoProfile(mVideoState, mVideoQuality);
        mVideoProvider.sendSessionModifyRequest(originalProfile, requestProfile);
    } catch (RemoteException e) {
    }
}
------------------------
Find a silently evolved API code:android.media.AudioManager.getLastAudibleStreamVolume:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get last audible volume before stream was muted.
 *
 * @hide
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        return service.getLastAudibleStreamVolume(streamType);
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in getLastAudibleStreamVolume", e);
        return 0;
    }
}
Body of Second Method:
{
    IAudioService service = getService();
    try {
        return service.getLastAudibleStreamVolume(streamType);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.os.PowerManager.boostScreenBrightness:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Boosts the brightness of the screen to maximum for a predetermined
 * period of time.  This is used to make the screen more readable in bright
 * daylight for a short duration.
 * <p>
 * Requires the {@link android.Manifest.permission#DEVICE_POWER} permission.
 * </p>
 *
 * @param time The time when the request to boost was issued, in the
 * {@link SystemClock#uptimeMillis()} time base.  This timestamp is used to correctly
 * order the boost request with other power management functions.  It should be set
 * to the timestamp of the input event that caused the request to boost.
 *
 * @hide Requires signature permission.
 */

Body of Frist Method:
{
    try {
        mService.boostScreenBrightness(time);
    } catch (RemoteException e) {
    }
}
Body of Second Method:
{
    try {
        mService.boostScreenBrightness(time);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.appwidget.AppWidgetManager.updateAppWidgetOptions:COMMENT
Method Modifier: public      
Comment:/**
 * Update the extras for a given widget instance.
 * <p>
 * The extras can be used to embed additional information about this widget to be accessed
 * by the associated widget's AppWidgetProvider.
 *
 * @see #getAppWidgetOptions(int)
 *
 * @param appWidgetId The AppWidget instances for which to set the RemoteViews.
 * @param options The options to associate with this widget
 */

Body of Frist Method:
{
    if (mService == null) {
        return;
    }
    try {
        mService.updateAppWidgetOptions(mPackageName, appWidgetId, options);
    } catch (RemoteException e) {
        throw new RuntimeException("system server dead?", e);
    }
}
Body of Second Method:
{
    if (mService == null) {
        return;
    }
    try {
        mService.updateAppWidgetOptions(mPackageName, appWidgetId, options);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.media.RemoteController.setSynchronizationMode:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * Set the playback position synchronization mode.
 * Must be called on a registered RemoteController.
 * @param sync {@link #POSITION_SYNCHRONIZATION_NONE} or {@link #POSITION_SYNCHRONIZATION_CHECK}
 * @return true if the synchronization mode was successfully set.
 * @throws IllegalArgumentException
 */

Body of Frist Method:
{
    if ((sync != POSITION_SYNCHRONIZATION_NONE) && (sync != POSITION_SYNCHRONIZATION_CHECK)) {
        throw new IllegalArgumentException("Unknown synchronization mode " + sync);
    }
    if (!mIsRegistered) {
        Log.e(TAG, "Cannot set synchronization mode on an unregistered RemoteController");
        return false;
    }
    mAudioManager.remoteControlDisplayWantsPlaybackPositionSync(mRcd, POSITION_SYNCHRONIZATION_CHECK == sync);
    return true;
}
Body of Second Method:
{
    if ((sync != POSITION_SYNCHRONIZATION_NONE) && (sync != POSITION_SYNCHRONIZATION_CHECK)) {
        throw new IllegalArgumentException("Unknown synchronization mode " + sync);
    }
    if (!mIsRegistered) {
        Log.e(TAG, "Cannot set synchronization mode on an unregistered RemoteController");
        return false;
    }
    // deprecated, no-op
    return true;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothAdapter.isEnabled:COMMENT
Method Modifier: public      
Comment:/**
 * Return true if Bluetooth is currently enabled and ready for use.
 * <p>Equivalent to:
 * <code>getBluetoothState() == STATE_ON</code>
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}
 *
 * @return true if the local adapter is turned on
 */

Body of Frist Method:
{
    try {
        synchronized (mManagerCallback) {
            if (mService != null)
                return mService.isEnabled();
        }
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
Body of Second Method:
{
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.isEnabled();
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}
------------------------
Find a silently evolved API code:android.app.ActivityManager.stopLockTaskMode:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    try {
        ActivityManagerNative.getDefault().stopLockTaskMode();
    } catch (RemoteException e) {
    }
}
Body of Second Method:
{
    try {
        ActivityManagerNative.getDefault().stopLockTaskMode();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.app.Fragment.isResumed:COMMENT
Method Modifier: public      final       
Comment:/**
 * Return true if the fragment is in the resumed state.  This is true
 * for the duration of {@link #onResume()} and {@link #onPause()} as well.
 */

Body of Frist Method:
{
    return mResumed;
}
Body of Second Method:
{
    return mState >= RESUMED;
}
------------------------
Find a silently evolved API code:android.media.MediaActionSound.release:COMMENT
Method Modifier: public      
Comment:/**
 * Free up all audio resources used by this MediaActionSound instance. Do
 * not call any other methods on a MediaActionSound instance after calling
 * release().
 */

Body of Frist Method:
{
    if (mSoundPool != null) {
        mSoundPool.release();
        mSoundPool = null;
    }
}
Body of Second Method:
{
    if (mSoundPool != null) {
        for (SoundState sound : mSounds) {
            synchronized (sound) {
                sound.state = STATE_NOT_LOADED;
                sound.id = 0;
            }
        }
        mSoundPool.release();
        mSoundPool = null;
    }
}
------------------------
Find a silently evolved API code:android.app.WallpaperManager.getFastDrawable:COMMENT
Method Modifier: public      
Comment:/**
 * Like {@link #getDrawable()}, but the returned Drawable has a number
 * of limitations to reduce its overhead as much as possible. It will
 * never scale the wallpaper (only centering it if the requested bounds
 * do match the bitmap bounds, which should not be typical), doesn't
 * allow setting an alpha, color filter, or other attributes, etc.  The
 * bounds of the returned drawable will be initialized to the same bounds
 * as the wallpaper, so normally you will not need to touch it.  The
 * drawable also assumes that it will be used in a context running in
 * the same density as the screen (not in density compatibility mode).
 *
 * @return Returns a Drawable object that will draw the wallpaper.
 */

Body of Frist Method:
{
    Bitmap bm = sGlobals.peekWallpaperBitmap(mContext, true);
    if (bm != null) {
        return new FastBitmapDrawable(bm);
    }
    return null;
}
Body of Second Method:
{
    Bitmap bm = sGlobals.peekWallpaperBitmap(mContext, true, FLAG_SYSTEM);
    if (bm != null) {
        return new FastBitmapDrawable(bm);
    }
    return null;
}
------------------------
Find a silently evolved API code:android.hardware.usb.UsbManager.setCurrentFunction:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets the current USB function when in device mode.
 * <p>
 * USB functions represent interfaces which are published to the host to access
 * services offered by the device.
 * </p><p>
 * This method is intended to select among primary USB functions.  The system may
 * automatically activate additional functions such as {@link #USB_FUNCTION_ADB}
 * or {@link #USB_FUNCTION_ACCESSORY} based on other settings and states.
 * </p><p>
 * The allowed values are: {@link #USB_FUNCTION_NONE}, {@link #USB_FUNCTION_AUDIO_SOURCE},
 * {@link #USB_FUNCTION_MIDI}, {@link #USB_FUNCTION_MTP}, {@link #USB_FUNCTION_PTP},
 * or {@link #USB_FUNCTION_RNDIS}.
 * </p><p>
 * Note: This function is asynchronous and may fail silently without applying
 * the requested changes.
 * </p>
 *
 * @param function name of the USB function, or null to restore the default function
 *
 * {@hide}
 */

Body of Frist Method:
{
    try {
        mService.setCurrentFunction(function);
    } catch (RemoteException e) {
        Log.e(TAG, "RemoteException in setCurrentFunction", e);
    }
}
Body of Second Method:
{
    try {
        mService.setCurrentFunction(function);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.location.Location.setAltitude:COMMENT
Method Modifier: public      
Comment:/**
 * Set the altitude, in meters above the WGS 84 reference ellipsoid.
 *
 * <p>Following this call {@link #hasAltitude} will return true.
 */

Body of Frist Method:
{
    mAltitude = altitude;
    mHasAltitude = true;
}
Body of Second Method:
{
    mAltitude = altitude;
    mFieldsMask |= HAS_ALTITUDE_MASK;
}
------------------------
Find a silently evolved API code:android.os.BatteryManager.queryProperty:COMMENT
Method Modifier: private     
Comment:/**
 * Query a battery property from the batteryproperties service.
 *
 * Returns the requested value, or Long.MIN_VALUE if property not
 * supported on this system or on other error.
 */

Body of Frist Method:
{
    long ret;
    if (mBatteryPropertiesRegistrar == null) {
        return Long.MIN_VALUE;
    }
    try {
        BatteryProperty prop = new BatteryProperty();
        if (mBatteryPropertiesRegistrar.getProperty(id, prop) == 0)
            ret = prop.getLong();
        else
            ret = Long.MIN_VALUE;
    } catch (RemoteException e) {
        ret = Long.MIN_VALUE;
    }
    return ret;
}
Body of Second Method:
{
    long ret;
    if (mBatteryPropertiesRegistrar == null) {
        return Long.MIN_VALUE;
    }
    try {
        BatteryProperty prop = new BatteryProperty();
        if (mBatteryPropertiesRegistrar.getProperty(id, prop) == 0)
            ret = prop.getLong();
        else
            ret = Long.MIN_VALUE;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
    return ret;
}
------------------------
Find a silently evolved API code:android.telephony.ServiceState.setDataRegState:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    mDataRegState = state;
    if (DBG)
        Rlog.d(LOG_TAG, "[ServiceState] setDataRegState=" + mDataRegState);
}
Body of Second Method:
{
    mDataRegState = state;
    if (VDBG)
        Rlog.d(LOG_TAG, "[ServiceState] setDataRegState=" + mDataRegState);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothClass.doesClassMatch:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Check class bits for possible bluetooth profile support.
 * This is a simple heuristic that tries to guess if a device with the
 * given class bits might support specified profile. It is not accurate for all
 * devices. It tries to err on the side of false positives.
 * @param profile The profile to be checked
 * @return True if this device might support specified profile.
 * @hide
 */

Body of Frist Method:
{
    if (profile == PROFILE_A2DP) {
        if (hasService(Service.RENDER)) {
            return true;
        }
        // match on some other class bits.
        switch(getDeviceClass()) {
            case Device.AUDIO_VIDEO_HIFI_AUDIO:
            case Device.AUDIO_VIDEO_HEADPHONES:
            case Device.AUDIO_VIDEO_LOUDSPEAKER:
            case Device.AUDIO_VIDEO_CAR_AUDIO:
                return true;
            default:
                return false;
        }
    } else if (profile == PROFILE_HEADSET) {
        // pretty good signal
        if (hasService(Service.RENDER)) {
            return true;
        }
        // Just in case they forgot the render service class
        switch(getDeviceClass()) {
            case Device.AUDIO_VIDEO_HANDSFREE:
            case Device.AUDIO_VIDEO_WEARABLE_HEADSET:
            case Device.AUDIO_VIDEO_CAR_AUDIO:
                return true;
            default:
                return false;
        }
    } else if (profile == PROFILE_OPP) {
        if (hasService(Service.OBJECT_TRANSFER)) {
            return true;
        }
        switch(getDeviceClass()) {
            case Device.COMPUTER_UNCATEGORIZED:
            case Device.COMPUTER_DESKTOP:
            case Device.COMPUTER_SERVER:
            case Device.COMPUTER_LAPTOP:
            case Device.COMPUTER_HANDHELD_PC_PDA:
            case Device.COMPUTER_PALM_SIZE_PC_PDA:
            case Device.COMPUTER_WEARABLE:
            case Device.PHONE_UNCATEGORIZED:
            case Device.PHONE_CELLULAR:
            case Device.PHONE_CORDLESS:
            case Device.PHONE_SMART:
            case Device.PHONE_MODEM_OR_GATEWAY:
            case Device.PHONE_ISDN:
                return true;
            default:
                return false;
        }
    } else if (profile == PROFILE_HID) {
        return (getDeviceClass() & Device.Major.PERIPHERAL) == Device.Major.PERIPHERAL;
    } else if (profile == PROFILE_PANU || profile == PROFILE_NAP) {
        // No good way to distinguish between the two, based on class bits.
        if (hasService(Service.NETWORKING)) {
            return true;
        }
        return (getDeviceClass() & Device.Major.NETWORKING) == Device.Major.NETWORKING;
    } else {
        return false;
    }
}
Body of Second Method:
{
    if (profile == PROFILE_A2DP) {
        if (hasService(Service.RENDER)) {
            return true;
        }
        // match on some other class bits.
        switch(getDeviceClass()) {
            case Device.AUDIO_VIDEO_HIFI_AUDIO:
            case Device.AUDIO_VIDEO_HEADPHONES:
            case Device.AUDIO_VIDEO_LOUDSPEAKER:
            case Device.AUDIO_VIDEO_CAR_AUDIO:
                return true;
            default:
                return false;
        }
    } else if (profile == PROFILE_A2DP_SINK) {
        if (hasService(Service.CAPTURE)) {
            return true;
        }
        // match on some other class bits.
        switch(getDeviceClass()) {
            case Device.AUDIO_VIDEO_HIFI_AUDIO:
            case Device.AUDIO_VIDEO_SET_TOP_BOX:
            case Device.AUDIO_VIDEO_VCR:
                return true;
            default:
                return false;
        }
    } else if (profile == PROFILE_HEADSET) {
        // pretty good signal
        if (hasService(Service.RENDER)) {
            return true;
        }
        // Just in case they forgot the render service class
        switch(getDeviceClass()) {
            case Device.AUDIO_VIDEO_HANDSFREE:
            case Device.AUDIO_VIDEO_WEARABLE_HEADSET:
            case Device.AUDIO_VIDEO_CAR_AUDIO:
                return true;
            default:
                return false;
        }
    } else if (profile == PROFILE_OPP) {
        if (hasService(Service.OBJECT_TRANSFER)) {
            return true;
        }
        switch(getDeviceClass()) {
            case Device.COMPUTER_UNCATEGORIZED:
            case Device.COMPUTER_DESKTOP:
            case Device.COMPUTER_SERVER:
            case Device.COMPUTER_LAPTOP:
            case Device.COMPUTER_HANDHELD_PC_PDA:
            case Device.COMPUTER_PALM_SIZE_PC_PDA:
            case Device.COMPUTER_WEARABLE:
            case Device.PHONE_UNCATEGORIZED:
            case Device.PHONE_CELLULAR:
            case Device.PHONE_CORDLESS:
            case Device.PHONE_SMART:
            case Device.PHONE_MODEM_OR_GATEWAY:
            case Device.PHONE_ISDN:
                return true;
            default:
                return false;
        }
    } else if (profile == PROFILE_HID) {
        return (getDeviceClass() & Device.Major.PERIPHERAL) == Device.Major.PERIPHERAL;
    } else if (profile == PROFILE_PANU || profile == PROFILE_NAP) {
        // No good way to distinguish between the two, based on class bits.
        if (hasService(Service.NETWORKING)) {
            return true;
        }
        return (getDeviceClass() & Device.Major.NETWORKING) == Device.Major.NETWORKING;
    } else {
        return false;
    }
}
------------------------
Find a silently evolved API code:android.telephony.TelephonyManager.iccCloseLogicalChannel:COMMENT
Method Modifier: public      
Comment:/**
 * Closes a previously opened logical channel to the ICC card.
 *
 * Input parameters equivalent to TS 27.007 AT+CCHC command.
 *
 * <p>Requires Permission:
 * {@link android.Manifest.permission#MODIFY_PHONE_STATE MODIFY_PHONE_STATE}
 * Or the calling app has carrier privileges. @see #hasCarrierPrivileges
 *
 * @param channel is the channel id to be closed as retruned by a successful
 * iccOpenLogicalChannel.
 * @return true if the channel was closed successfully.
 */

Body of Frist Method:
{
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            return telephony.iccCloseLogicalChannel(channel);
    } catch (RemoteException ex) {
    } catch (NullPointerException ex) {
    }
    return false;
}
Body of Second Method:
{
    return iccCloseLogicalChannel(getSubId(), channel);
}
------------------------
Find a silently evolved API code:android.widget.ProgressBar.setMax:COMMENT
Method Modifier: public      
Comment:/**
 * <p>Set the range of the progress bar to 0...<tt>max</tt>.</p>
 *
 * @param max the upper range of this progress bar
 *
 * @see #getMax()
 * @see #setProgress(int)
 * @see #setSecondaryProgress(int)
 */

Body of Frist Method:
{
    if (max < 0) {
        max = 0;
    }
    if (max != mMax) {
        mMax = max;
        postInvalidate();
        if (mProgress > max) {
            mProgress = max;
        }
        refreshProgress(R.id.progress, mProgress, false);
    }
}
Body of Second Method:
{
    if (max < 0) {
        max = 0;
    }
    if (max != mMax) {
        mMax = max;
        postInvalidate();
        if (mProgress > max) {
            mProgress = max;
        }
        refreshProgress(R.id.progress, mProgress, false, false);
    }
}
------------------------
Find a silently evolved API code:android.telephony.CellSignalStrengthCdma.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Implement the Parcelable interface
 */

Body of Frist Method:
{
    if (DBG)
        log("writeToParcel(Parcel, int): " + toString());
    // Need to multiply CdmaDbm, CdmaEcio, EvdoDbm and EvdoEcio by -1
    // to ensure consistency when reading values written here
    dest.writeInt(mCdmaDbm * -1);
    dest.writeInt(mCdmaEcio * -1);
    dest.writeInt(mEvdoDbm * -1);
    dest.writeInt(mEvdoEcio * -1);
    dest.writeInt(mEvdoSnr);
}
Body of Second Method:
{
    if (DBG)
        log("writeToParcel(Parcel, int): " + toString());
    // Need to multiply CdmaDbm, CdmaEcio, EvdoDbm and EvdoEcio by -1
    // to ensure consistency when reading values written here
    // unless the value is invalid
    dest.writeInt(mCdmaDbm * (mCdmaDbm != Integer.MAX_VALUE ? -1 : 1));
    dest.writeInt(mCdmaEcio * (mCdmaEcio != Integer.MAX_VALUE ? -1 : 1));
    dest.writeInt(mEvdoDbm * (mEvdoDbm != Integer.MAX_VALUE ? -1 : 1));
    dest.writeInt(mEvdoEcio * (mEvdoEcio != Integer.MAX_VALUE ? -1 : 1));
    dest.writeInt(mEvdoSnr);
}
------------------------
Find a silently evolved API code:android.media.AudioManager.shouldVibrate:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * Returns whether a particular type should vibrate according to user
 * settings and the current ringer mode.
 * <p>
 * This shouldn't be needed by most clients that use notifications to
 * vibrate. The notification manager will not vibrate if the policy doesn't
 * allow it, so the client should always set a vibrate pattern and let the
 * notification manager control whether or not to actually vibrate.
 *
 * @param vibrateType The type of vibrate. One of
 * {@link #VIBRATE_TYPE_NOTIFICATION} or
 * {@link #VIBRATE_TYPE_RINGER}.
 * @return Whether the type should vibrate at the instant this method is
 * called.
 * @see #setVibrateSetting(int, int)
 * @see #getVibrateSetting(int)
 * @deprecated Applications should maintain their own vibrate policy based on
 * current ringer mode that can be queried via {@link #getRingerMode()}.
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        return service.shouldVibrate(vibrateType);
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in shouldVibrate", e);
        return false;
    }
}
Body of Second Method:
{
    IAudioService service = getService();
    try {
        return service.shouldVibrate(vibrateType);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.mtp.MtpObjectInfo.getCompressedSize:COMMENT
Method Modifier: public      final       
Comment:/**
 * Returns the size of the MTP object
 *
 * @return the object size
 */

Body of Frist Method:
{
    return mCompressedSize;
}
Body of Second Method:
{
    Preconditions.checkState(mCompressedSize >= 0);
    return mCompressedSize;
}
------------------------
Find a silently evolved API code:android.telephony.CellSignalStrengthGsm.copyFrom:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    mSignalStrength = s.mSignalStrength;
    mBitErrorRate = s.mBitErrorRate;
}
Body of Second Method:
{
    mSignalStrength = s.mSignalStrength;
    mBitErrorRate = s.mBitErrorRate;
    mTimingAdvance = s.mTimingAdvance;
}
------------------------
Find a silently evolved API code:android.media.AudioManager.setVolumeController:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Registers a global volume controller interface.  Currently limited to SystemUI.
 *
 * @hide
 */

Body of Frist Method:
{
    try {
        getService().setVolumeController(controller);
    } catch (RemoteException e) {
        Log.w(TAG, "Error setting volume controller", e);
    }
}
Body of Second Method:
{
    try {
        getService().setVolumeController(controller);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.os.StrictMode.dropboxViolationAsync:COMMENT
Method Modifier: private     static      
Comment:/**
 * In the common case, as set by conditionallyEnableDebugLogging,
 * we're just dropboxing any violations but not showing a dialog,
 * not loggging, and not killing the process.  In these cases we
 * don't need to do a synchronous call to the ActivityManager.
 * This is used by both per-thread and vm-wide violations when
 * applicable.
 */

Body of Frist Method:
{
    int outstanding = sDropboxCallsInFlight.incrementAndGet();
    if (outstanding > 20) {
        // What's going on?  Let's not make make the situation
        // worse and just not log.
        sDropboxCallsInFlight.decrementAndGet();
        return;
    }
    if (LOG_V)
        Log.d(TAG, "Dropboxing async; in-flight=" + outstanding);
    new Thread("callActivityManagerForStrictModeDropbox") {

        public void run() {
            Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
            try {
                IActivityManager am = ActivityManagerNative.getDefault();
                if (am == null) {
                    Log.d(TAG, "No activity manager; failed to Dropbox violation.");
                } else {
                    am.handleApplicationStrictModeViolation(RuntimeInit.getApplicationObject(), violationMaskSubset, info);
                }
            } catch (RemoteException e) {
                Log.e(TAG, "RemoteException handling StrictMode violation", e);
            }
            int outstanding = sDropboxCallsInFlight.decrementAndGet();
            if (LOG_V)
                Log.d(TAG, "Dropbox complete; in-flight=" + outstanding);
        }
    }.start();
}
Body of Second Method:
{
    int outstanding = sDropboxCallsInFlight.incrementAndGet();
    if (outstanding > 20) {
        // What's going on?  Let's not make make the situation
        // worse and just not log.
        sDropboxCallsInFlight.decrementAndGet();
        return;
    }
    if (LOG_V)
        Log.d(TAG, "Dropboxing async; in-flight=" + outstanding);
    new Thread("callActivityManagerForStrictModeDropbox") {

        public void run() {
            Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
            try {
                IActivityManager am = ActivityManagerNative.getDefault();
                if (am == null) {
                    Log.d(TAG, "No activity manager; failed to Dropbox violation.");
                } else {
                    am.handleApplicationStrictModeViolation(RuntimeInit.getApplicationObject(), violationMaskSubset, info);
                }
            } catch (RemoteException e) {
                if (e instanceof DeadObjectException) {
                // System process is dead; ignore
                } else {
                    Log.e(TAG, "RemoteException handling StrictMode violation", e);
                }
            }
            int outstanding = sDropboxCallsInFlight.decrementAndGet();
            if (LOG_V)
                Log.d(TAG, "Dropbox complete; in-flight=" + outstanding);
        }
    }.start();
}
------------------------
Find a silently evolved API code:android.telephony.CellSignalStrengthLte.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Implement the Parcelable interface
 */

Body of Frist Method:
{
    if (DBG)
        log("writeToParcel(Parcel, int): " + toString());
    dest.writeInt(mSignalStrength);
    // Need to multiply rsrp and rsrq by -1
    // to ensure consistency when reading values written here
    dest.writeInt(mRsrp * -1);
    dest.writeInt(mRsrq * -1);
    dest.writeInt(mRssnr);
    dest.writeInt(mCqi);
    dest.writeInt(mTimingAdvance);
}
Body of Second Method:
{
    if (DBG)
        log("writeToParcel(Parcel, int): " + toString());
    dest.writeInt(mSignalStrength);
    // Need to multiply rsrp and rsrq by -1
    // to ensure consistency when reading values written here
    // unless the values are invalid
    dest.writeInt(mRsrp * (mRsrp != Integer.MAX_VALUE ? -1 : 1));
    dest.writeInt(mRsrq * (mRsrq != Integer.MAX_VALUE ? -1 : 1));
    dest.writeInt(mRssnr);
    dest.writeInt(mCqi);
    dest.writeInt(mTimingAdvance);
}
------------------------
Find a silently evolved API code:android.app.ActivityManager.TaskDescription.getIcon:COMMENT
Method Modifier: public      
Comment:/**
 * @return The icon that represents the current state of this task.
 */

Body of Frist Method:
{
    if (mIcon != null) {
        return mIcon;
    }
    return loadTaskDescriptionIcon(mIconFilename);
}
Body of Second Method:
{
    if (mIcon != null) {
        return mIcon;
    }
    return loadTaskDescriptionIcon(mIconFilename, UserHandle.myUserId());
}
------------------------
Find a silently evolved API code:android.telephony.CarrierConfigManager.getConfigForSubId:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the configuration values for a particular subscription, which is associated with a
 * specific SIM card. If an invalid subId is used, the returned config will contain default
 * values.
 *
 * <p>Requires Permission:
 * {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}
 *
 * @param subId the subscription ID, normally obtained from {@link SubscriptionManager}.
 * @return A {@link PersistableBundle} containing the config for the given subId, or default
 * values for an invalid subId.
 */

Body of Frist Method:
{
    try {
        return getICarrierConfigLoader().getConfigForSubId(subId);
    } catch (RemoteException ex) {
        Rlog.e(TAG, "Error getting config for subId " + Integer.toString(subId) + ": " + ex.toString());
    } catch (NullPointerException ex) {
        Rlog.e(TAG, "Error getting config for subId " + Integer.toString(subId) + ": " + ex.toString());
    }
    return null;
}
Body of Second Method:
{
    try {
        ICarrierConfigLoader loader = getICarrierConfigLoader();
        if (loader == null) {
            Rlog.w(TAG, "Error getting config for subId " + subId + " ICarrierConfigLoader is null");
            return null;
        }
        return loader.getConfigForSubId(subId);
    } catch (RemoteException ex) {
        Rlog.e(TAG, "Error getting config for subId " + subId + ": " + ex.toString());
    }
    return null;
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiManager.pingSupplicant:COMMENT
Method Modifier: public      
Comment:/**
 * Check that the supplicant daemon is responding to requests.
 * @return {@code true} if we were able to communicate with the supplicant and
 * it returned the expected response to the PING message.
 */

Body of Frist Method:
{
    if (mService == null)
        return false;
    try {
        return mService.pingSupplicant();
    } catch (RemoteException e) {
        return false;
    }
}
Body of Second Method:
{
    if (mService == null)
        return false;
    try {
        return mService.pingSupplicant();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.media.AudioManager.reloadAudioSettings:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 * Reload audio settings. This method is called by Settings backup
 * agent when audio settings are restored and causes the AudioService
 * to read and apply restored settings.
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        service.reloadAudioSettings();
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in reloadAudioSettings" + e);
    }
}
Body of Second Method:
{
    IAudioService service = getService();
    try {
        service.reloadAudioSettings();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiConfiguration.getKeyIdForCredentials:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get an identifier for associating credentials with this config
 * @param current configuration contains values for additional fields
 * that are not part of this configuration. Used
 * when a config with some fields is passed by an application.
 * @throws IllegalStateException if config is invalid for key id generation
 * @hide
 */

Body of Frist Method:
{
    String keyMgmt = null;
    try {
        // Get current config details for fields that are not initialized
        if (TextUtils.isEmpty(SSID))
            SSID = current.SSID;
        if (allowedKeyManagement.cardinality() == 0) {
            allowedKeyManagement = current.allowedKeyManagement;
        }
        if (allowedKeyManagement.get(KeyMgmt.WPA_EAP)) {
            keyMgmt = KeyMgmt.strings[KeyMgmt.WPA_EAP];
        }
        if (allowedKeyManagement.get(KeyMgmt.IEEE8021X)) {
            keyMgmt += KeyMgmt.strings[KeyMgmt.IEEE8021X];
        }
        if (TextUtils.isEmpty(keyMgmt)) {
            throw new IllegalStateException("Not an EAP network");
        }
        return trimStringForKeyId(SSID) + "_" + keyMgmt + "_" + trimStringForKeyId(enterpriseConfig.getKeyId(current != null ? current.enterpriseConfig : null));
    } catch (NullPointerException e) {
        throw new IllegalStateException("Invalid config details");
    }
}
Body of Second Method:
{
    String keyMgmt = null;
    try {
        // Get current config details for fields that are not initialized
        if (TextUtils.isEmpty(SSID))
            SSID = current.SSID;
        if (allowedKeyManagement.cardinality() == 0) {
            allowedKeyManagement = current.allowedKeyManagement;
        }
        if (allowedKeyManagement.get(KeyMgmt.WPA_EAP)) {
            keyMgmt = KeyMgmt.strings[KeyMgmt.WPA_EAP];
        }
        if (allowedKeyManagement.get(KeyMgmt.OSEN)) {
            keyMgmt = KeyMgmt.strings[KeyMgmt.OSEN];
        }
        if (allowedKeyManagement.get(KeyMgmt.IEEE8021X)) {
            keyMgmt += KeyMgmt.strings[KeyMgmt.IEEE8021X];
        }
        if (TextUtils.isEmpty(keyMgmt)) {
            throw new IllegalStateException("Not an EAP network");
        }
        return trimStringForKeyId(SSID) + "_" + keyMgmt + "_" + trimStringForKeyId(enterpriseConfig.getKeyId(current != null ? current.enterpriseConfig : null));
    } catch (NullPointerException e) {
        throw new IllegalStateException("Invalid config details");
    }
}
------------------------
Find a silently evolved API code:android.widget.MediaController.hide:COMMENT
Method Modifier: public      
Comment:/**
 * Remove the controller from the screen.
 */

Body of Frist Method:
{
    if (mAnchor == null)
        return;
    if (mShowing) {
        try {
            mHandler.removeMessages(SHOW_PROGRESS);
            mWindowManager.removeView(mDecor);
        } catch (IllegalArgumentException ex) {
            Log.w("MediaController", "already removed");
        }
        mShowing = false;
    }
}
Body of Second Method:
{
    if (mAnchor == null)
        return;
    if (mShowing) {
        try {
            removeCallbacks(mShowProgress);
            mWindowManager.removeView(mDecor);
        } catch (IllegalArgumentException ex) {
            Log.w("MediaController", "already removed");
        }
        mShowing = false;
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiManager.getWifiServiceMessenger:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get a reference to WifiService handler. This is used by a client to establish
 * an AsyncChannel communication with WifiService
 *
 * @return Messenger pointing to the WifiService handler
 * @hide
 */

Body of Frist Method:
{
    try {
        return mService.getWifiServiceMessenger();
    } catch (RemoteException e) {
        return null;
    } catch (SecurityException e) {
        return null;
    }
}
Body of Second Method:
{
    try {
        return mService.getWifiServiceMessenger();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.net.ConnectivityManager.reportInetCondition:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Report network connectivity status.  This is currently used only
 * to alter status bar UI.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#STATUS_BAR}.
 *
 * @param networkType The type of network you want to report on
 * @param percentage The quality of the connection 0 is bad, 100 is good
 * {@hide}
 */

Body of Frist Method:
{
    try {
        mService.reportInetCondition(networkType, percentage);
    } catch (RemoteException e) {
    }
}
Body of Second Method:
{
    try {
        mService.reportInetCondition(networkType, percentage);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.media.AudioAttributes.usageToString:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    switch(usage) {
        case USAGE_UNKNOWN:
            return new String("USAGE_UNKNOWN");
        case USAGE_MEDIA:
            return new String("USAGE_MEDIA");
        case USAGE_VOICE_COMMUNICATION:
            return new String("USAGE_VOICE_COMMUNICATION");
        case USAGE_VOICE_COMMUNICATION_SIGNALLING:
            return new String("USAGE_VOICE_COMMUNICATION");
        case USAGE_ALARM:
            return new String("USAGE_ALARM");
        case USAGE_NOTIFICATION:
            return new String("USAGE_NOTIFICATION");
        case USAGE_NOTIFICATION_RINGTONE:
            return new String("USAGE_NOTIFICATION");
        case USAGE_NOTIFICATION_COMMUNICATION_REQUEST:
            return new String("USAGE_NOTIFICATION");
        case USAGE_NOTIFICATION_COMMUNICATION_INSTANT:
            return new String("USAGE_NOTIFICATION_COMMUNICATION_INSTANT");
        case USAGE_NOTIFICATION_COMMUNICATION_DELAYED:
            return new String("USAGE_NOTIFICATION_COMMUNICATION_DELAYED");
        case USAGE_NOTIFICATION_EVENT:
            return new String("USAGE_NOTIFICATION_EVENT");
        case USAGE_ASSISTANCE_ACCESSIBILITY:
            return new String("USAGE_ASSISTANCE_ACCESSIBILITY");
        case USAGE_ASSISTANCE_NAVIGATION_GUIDANCE:
            return new String("USAGE_ASSISTANCE_NAVIGATION_GUIDANCE");
        case USAGE_ASSISTANCE_SONIFICATION:
            return new String("USAGE_ASSISTANCE_SONIFICATION");
        case USAGE_GAME:
            return new String("USAGE_GAME");
        default:
            return new String("unknown usage " + usage);
    }
}
Body of Second Method:
{
    switch(usage) {
        case USAGE_UNKNOWN:
            return new String("USAGE_UNKNOWN");
        case USAGE_MEDIA:
            return new String("USAGE_MEDIA");
        case USAGE_VOICE_COMMUNICATION:
            return new String("USAGE_VOICE_COMMUNICATION");
        case USAGE_VOICE_COMMUNICATION_SIGNALLING:
            return new String("USAGE_VOICE_COMMUNICATION_SIGNALLING");
        case USAGE_ALARM:
            return new String("USAGE_ALARM");
        case USAGE_NOTIFICATION:
            return new String("USAGE_NOTIFICATION");
        case USAGE_NOTIFICATION_RINGTONE:
            return new String("USAGE_NOTIFICATION_RINGTONE");
        case USAGE_NOTIFICATION_COMMUNICATION_REQUEST:
            return new String("USAGE_NOTIFICATION_COMMUNICATION_REQUEST");
        case USAGE_NOTIFICATION_COMMUNICATION_INSTANT:
            return new String("USAGE_NOTIFICATION_COMMUNICATION_INSTANT");
        case USAGE_NOTIFICATION_COMMUNICATION_DELAYED:
            return new String("USAGE_NOTIFICATION_COMMUNICATION_DELAYED");
        case USAGE_NOTIFICATION_EVENT:
            return new String("USAGE_NOTIFICATION_EVENT");
        case USAGE_ASSISTANCE_ACCESSIBILITY:
            return new String("USAGE_ASSISTANCE_ACCESSIBILITY");
        case USAGE_ASSISTANCE_NAVIGATION_GUIDANCE:
            return new String("USAGE_ASSISTANCE_NAVIGATION_GUIDANCE");
        case USAGE_ASSISTANCE_SONIFICATION:
            return new String("USAGE_ASSISTANCE_SONIFICATION");
        case USAGE_GAME:
            return new String("USAGE_GAME");
        default:
            return new String("unknown usage " + usage);
    }
}
------------------------
Find a silently evolved API code:android.renderscript.Sampler.MIRRORED_REPEAT_NEAREST:COMMENT
Method Modifier: public      static      
Comment:/**
 * Retrieve a sampler with min and mag set to nearest and wrap modes set to
 * mirrored repeat.
 *
 * @param rs Context to which the sampler will belong.
 *
 * @return Sampler
 */

Body of Frist Method:
{
    if (rs.mSampler_MIRRORED_REPEAT_NEAREST == null) {
        Builder b = new Builder(rs);
        b.setMinification(Value.NEAREST);
        b.setMagnification(Value.NEAREST);
        b.setWrapS(Value.MIRRORED_REPEAT);
        b.setWrapT(Value.MIRRORED_REPEAT);
        rs.mSampler_MIRRORED_REPEAT_NEAREST = b.create();
    }
    return rs.mSampler_MIRRORED_REPEAT_NEAREST;
}
Body of Second Method:
{
    if (rs.mSampler_MIRRORED_REPEAT_NEAREST == null) {
        synchronized (rs) {
            if (rs.mSampler_MIRRORED_REPEAT_NEAREST == null) {
                Builder b = new Builder(rs);
                b.setMinification(Value.NEAREST);
                b.setMagnification(Value.NEAREST);
                b.setWrapS(Value.MIRRORED_REPEAT);
                b.setWrapT(Value.MIRRORED_REPEAT);
                rs.mSampler_MIRRORED_REPEAT_NEAREST = b.create();
            }
        }
    }
    return rs.mSampler_MIRRORED_REPEAT_NEAREST;
}
------------------------
Find a silently evolved API code:android.net.NetworkRequest.Builder.setNetworkSpecifier:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the optional bearer specific network specifier.
 * This has no meaning if a single transport is also not specified, so calling
 * this without a single transport set will generate an exception, as will
 * subsequently adding or removing transports after this is set.
 * </p>
 * The interpretation of this {@code String} is bearer specific and bearers that use
 * it should document their particulars.  For example, Bluetooth may use some sort of
 * device id while WiFi could used ssid and/or bssid.  Cellular may use carrier spn.
 *
 * @param networkSpecifier An {@code String} of opaque format used to specify the bearer
 * specific network specifier where the bearer has a choice of
 * networks.
 */

Body of Frist Method:
{
    mNetworkCapabilities.setNetworkSpecifier(networkSpecifier);
    return this;
}
Body of Second Method:
{
    if (NetworkCapabilities.MATCH_ALL_REQUESTS_NETWORK_SPECIFIER.equals(networkSpecifier)) {
        throw new IllegalArgumentException("Invalid network specifier - must not be '" + NetworkCapabilities.MATCH_ALL_REQUESTS_NETWORK_SPECIFIER + "'");
    }
    mNetworkCapabilities.setNetworkSpecifier(networkSpecifier);
    return this;
}
------------------------
Find a silently evolved API code:android.media.AudioManager.setRingerModeInternal:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Only useful for volume controllers.
 * @hide
 */

Body of Frist Method:
{
    try {
        getService().setRingerModeInternal(ringerMode, getContext().getOpPackageName());
    } catch (RemoteException e) {
        Log.w(TAG, "Error calling setRingerModeInternal", e);
    }
}
Body of Second Method:
{
    try {
        getService().setRingerModeInternal(ringerMode, getContext().getOpPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.accounts.AccountManager.editProperties:COMMENT
Method Modifier: public      
Comment:/**
 * Offers the user an opportunity to change an authenticator's settings.
 * These properties are for the authenticator in general, not a particular
 * account.  Not all authenticators support this method.
 *
 * <p>This method may be called from any thread, but the returned
 * {@link AccountManagerFuture} must not be used on the main thread.
 *
 * <p>This method requires the caller to have the same signature as the
 * authenticator associated with the specified account type.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * MANAGE_ACCOUNTS permission is needed for those platforms. See docs
 * for this function in API level 22.
 *
 * @param accountType The account type associated with the authenticator
 * to adjust
 * @param activity The {@link Activity} context to use for launching a new
 * authenticator-defined sub-Activity to adjust authenticator settings;
 * used only to call startActivity(); if null, the settings dialog will
 * not be launched directly, but the necessary {@link Intent} will be
 * returned to the caller instead
 * @param callback Callback to invoke when the request completes,
 * null for no callback
 * @param handler {@link Handler} identifying the callback thread,
 * null for the main thread
 * @return An {@link AccountManagerFuture} which resolves to a Bundle
 * which is empty if properties were edited successfully, or
 * if no activity was specified, contains only {@link #KEY_INTENT}
 * needed to launch the authenticator's settings dialog.
 * If an error occurred, {@link AccountManagerFuture#getResult()}
 * throws:
 * <ul>
 * <li> {@link AuthenticatorException} if no authenticator was registered for
 * this account type or the authenticator failed to respond
 * <li> {@link OperationCanceledException} if the operation was canceled for
 * any reason, including the user canceling the settings dialog
 * <li> {@link IOException} if the authenticator experienced an I/O problem
 * updating settings, usually because of network trouble
 * </ul>
 */

Body of Frist Method:
{
    if (accountType == null)
        throw new IllegalArgumentException("accountType is null");
    return new AmsTask(activity, handler, callback) {

        public void doWork() throws RemoteException {
            mService.editProperties(mResponse, accountType, activity != null);
        }
    }.start();
}
Body of Second Method:
{
    if (accountType == null)
        throw new IllegalArgumentException("accountType is null");
    return new AmsTask(activity, handler, callback) {

        @Override
        public void doWork() throws RemoteException {
            mService.editProperties(mResponse, accountType, activity != null);
        }
    }.start();
}
------------------------
Find a silently evolved API code:android.app.KeyguardManager.createConfirmDeviceCredentialIntent:COMMENT
Method Modifier: public      
Comment:/**
 * Get an intent to prompt the user to confirm credentials (pin, pattern or password)
 * for the current user of the device. The caller is expected to launch this activity using
 * {@link android.app.Activity#startActivityForResult(Intent, int)} and check for
 * {@link android.app.Activity#RESULT_OK} if the user successfully completes the challenge.
 *
 * @return the intent for launching the activity or null if no password is required.
 */

Body of Frist Method:
{
    if (!isKeyguardSecure())
        return null;
    Intent intent = new Intent(ACTION_CONFIRM_DEVICE_CREDENTIAL);
    intent.putExtra(EXTRA_TITLE, title);
    intent.putExtra(EXTRA_DESCRIPTION, description);
    // For security reasons, only allow this to come from system settings.
    intent.setPackage("com.android.settings");
    return intent;
}
Body of Second Method:
{
    if (!isDeviceSecure())
        return null;
    Intent intent = new Intent(ACTION_CONFIRM_DEVICE_CREDENTIAL);
    intent.putExtra(EXTRA_TITLE, title);
    intent.putExtra(EXTRA_DESCRIPTION, description);
    // For security reasons, only allow this to come from system settings.
    intent.setPackage("com.android.settings");
    return intent;
}
------------------------
Find a silently evolved API code:android.transition.Transition.createAnimators:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * This method, essentially a wrapper around all calls to createAnimator for all
 * possible target views, is called with the entire set of start/end
 * values. The implementation in Transition iterates through these lists
 * and calls {@link #createAnimator(ViewGroup, TransitionValues, TransitionValues)}
 * with each set of start/end values on this transition. The
 * TransitionSet subclass overrides this method and delegates it to
 * each of its children in succession.
 *
 * @hide
 */

Body of Frist Method:
{
    if (DBG) {
        Log.d(LOG_TAG, "createAnimators() for " + this);
    }
    ArrayMap<Animator, AnimationInfo> runningAnimators = getRunningAnimators();
    long minStartDelay = Long.MAX_VALUE;
    int minAnimator = mAnimators.size();
    SparseLongArray startDelays = new SparseLongArray();
    int startValuesListCount = startValuesList.size();
    for (int i = 0; i < startValuesListCount; ++i) {
        TransitionValues start = startValuesList.get(i);
        TransitionValues end = endValuesList.get(i);
        if (start != null && !start.targetedTransitions.contains(this)) {
            start = null;
        }
        if (end != null && !end.targetedTransitions.contains(this)) {
            end = null;
        }
        if (start == null && end == null) {
            continue;
        }
        // Only bother trying to animate with values that differ between start/end
        boolean isChanged = start == null || end == null || isTransitionRequired(start, end);
        if (isChanged) {
            if (DBG) {
                View view = (end != null) ? end.view : start.view;
                Log.d(LOG_TAG, "  differing start/end values for view " + view);
                if (start == null || end == null) {
                    Log.d(LOG_TAG, "    " + ((start == null) ? "start null, end non-null" : "start non-null, end null"));
                } else {
                    for (String key : start.values.keySet()) {
                        Object startValue = start.values.get(key);
                        Object endValue = end.values.get(key);
                        if (startValue != endValue && !startValue.equals(endValue)) {
                            Log.d(LOG_TAG, "    " + key + ": start(" + startValue + "), end(" + endValue + ")");
                        }
                    }
                }
            }
            // TODO: what to do about targetIds and itemIds?
            Animator animator = createAnimator(sceneRoot, start, end);
            if (animator != null) {
                // Save animation info for future cancellation purposes
                View view = null;
                TransitionValues infoValues = null;
                if (end != null) {
                    view = end.view;
                    String[] properties = getTransitionProperties();
                    if (view != null && properties != null && properties.length > 0) {
                        infoValues = new TransitionValues();
                        infoValues.view = view;
                        TransitionValues newValues = endValues.viewValues.get(view);
                        if (newValues != null) {
                            for (int j = 0; j < properties.length; ++j) {
                                infoValues.values.put(properties[j], newValues.values.get(properties[j]));
                            }
                        }
                        int numExistingAnims = runningAnimators.size();
                        for (int j = 0; j < numExistingAnims; ++j) {
                            Animator anim = runningAnimators.keyAt(j);
                            AnimationInfo info = runningAnimators.get(anim);
                            if (info.values != null && info.view == view && ((info.name == null && getName() == null) || info.name.equals(getName()))) {
                                if (info.values.equals(infoValues)) {
                                    // Favor the old animator
                                    animator = null;
                                    break;
                                }
                            }
                        }
                    }
                } else {
                    view = (start != null) ? start.view : null;
                }
                if (animator != null) {
                    if (mPropagation != null) {
                        long delay = mPropagation.getStartDelay(sceneRoot, this, start, end);
                        startDelays.put(mAnimators.size(), delay);
                        minStartDelay = Math.min(delay, minStartDelay);
                    }
                    AnimationInfo info = new AnimationInfo(view, getName(), this, sceneRoot.getWindowId(), infoValues);
                    runningAnimators.put(animator, info);
                    mAnimators.add(animator);
                }
            }
        }
    }
    if (minStartDelay != 0) {
        for (int i = 0; i < startDelays.size(); i++) {
            int index = startDelays.keyAt(i);
            Animator animator = mAnimators.get(index);
            long delay = startDelays.valueAt(i) - minStartDelay + animator.getStartDelay();
            animator.setStartDelay(delay);
        }
    }
}
Body of Second Method:
{
    if (DBG) {
        Log.d(LOG_TAG, "createAnimators() for " + this);
    }
    ArrayMap<Animator, AnimationInfo> runningAnimators = getRunningAnimators();
    long minStartDelay = Long.MAX_VALUE;
    int minAnimator = mAnimators.size();
    SparseLongArray startDelays = new SparseLongArray();
    int startValuesListCount = startValuesList.size();
    for (int i = 0; i < startValuesListCount; ++i) {
        TransitionValues start = startValuesList.get(i);
        TransitionValues end = endValuesList.get(i);
        if (start != null && !start.targetedTransitions.contains(this)) {
            start = null;
        }
        if (end != null && !end.targetedTransitions.contains(this)) {
            end = null;
        }
        if (start == null && end == null) {
            continue;
        }
        // Only bother trying to animate with values that differ between start/end
        boolean isChanged = start == null || end == null || isTransitionRequired(start, end);
        if (isChanged) {
            if (DBG) {
                View view = (end != null) ? end.view : start.view;
                Log.d(LOG_TAG, "  differing start/end values for view " + view);
                if (start == null || end == null) {
                    Log.d(LOG_TAG, "    " + ((start == null) ? "start null, end non-null" : "start non-null, end null"));
                } else {
                    for (String key : start.values.keySet()) {
                        Object startValue = start.values.get(key);
                        Object endValue = end.values.get(key);
                        if (startValue != endValue && !startValue.equals(endValue)) {
                            Log.d(LOG_TAG, "    " + key + ": start(" + startValue + "), end(" + endValue + ")");
                        }
                    }
                }
            }
            // TODO: what to do about targetIds and itemIds?
            Animator animator = createAnimator(sceneRoot, start, end);
            if (animator != null) {
                // Save animation info for future cancellation purposes
                View view = null;
                TransitionValues infoValues = null;
                if (end != null) {
                    view = end.view;
                    String[] properties = getTransitionProperties();
                    if (view != null && properties != null && properties.length > 0) {
                        infoValues = new TransitionValues();
                        infoValues.view = view;
                        TransitionValues newValues = endValues.viewValues.get(view);
                        if (newValues != null) {
                            for (int j = 0; j < properties.length; ++j) {
                                infoValues.values.put(properties[j], newValues.values.get(properties[j]));
                            }
                        }
                        int numExistingAnims = runningAnimators.size();
                        for (int j = 0; j < numExistingAnims; ++j) {
                            Animator anim = runningAnimators.keyAt(j);
                            AnimationInfo info = runningAnimators.get(anim);
                            if (info.values != null && info.view == view && ((info.name == null && getName() == null) || info.name.equals(getName()))) {
                                if (info.values.equals(infoValues)) {
                                    // Favor the old animator
                                    animator = null;
                                    break;
                                }
                            }
                        }
                    }
                } else {
                    view = (start != null) ? start.view : null;
                }
                if (animator != null) {
                    if (mPropagation != null) {
                        long delay = mPropagation.getStartDelay(sceneRoot, this, start, end);
                        startDelays.put(mAnimators.size(), delay);
                        minStartDelay = Math.min(delay, minStartDelay);
                    }
                    AnimationInfo info = new AnimationInfo(view, getName(), this, sceneRoot.getWindowId(), infoValues);
                    runningAnimators.put(animator, info);
                    mAnimators.add(animator);
                }
            }
        }
    }
    if (startDelays.size() != 0) {
        for (int i = 0; i < startDelays.size(); i++) {
            int index = startDelays.keyAt(i);
            Animator animator = mAnimators.get(index);
            long delay = startDelays.valueAt(i) - minStartDelay + animator.getStartDelay();
            animator.setStartDelay(delay);
        }
    }
}
------------------------
Find a silently evolved API code:android.text.TextLine.measure:COMMENT
Method Modifier: default     hidden      
Comment:/**
 * Returns information about a position on the line.
 *
 * @param offset the line-relative character offset, between 0 and the
 * line length, inclusive
 * @param trailing true to measure the trailing edge of the character
 * before offset, false to measure the leading edge of the character
 * at offset.
 * @param fmi receives metrics information about the requested
 * character, can be null.
 * @return the signed offset from the leading margin to the requested
 * character edge.
 */

Body of Frist Method:
{
    int target = trailing ? offset - 1 : offset;
    if (target < 0) {
        return 0;
    }
    float h = 0;
    if (!mHasTabs) {
        if (mDirections == Layout.DIRS_ALL_LEFT_TO_RIGHT) {
            return measureRun(0, offset, mLen, false, fmi);
        }
        if (mDirections == Layout.DIRS_ALL_RIGHT_TO_LEFT) {
            return measureRun(0, offset, mLen, true, fmi);
        }
    }
    char[] chars = mChars;
    int[] runs = mDirections.mDirections;
    for (int i = 0; i < runs.length; i += 2) {
        int runStart = runs[i];
        int runLimit = runStart + (runs[i + 1] & Layout.RUN_LENGTH_MASK);
        if (runLimit > mLen) {
            runLimit = mLen;
        }
        boolean runIsRtl = (runs[i + 1] & Layout.RUN_RTL_FLAG) != 0;
        int segstart = runStart;
        for (int j = mHasTabs ? runStart : runLimit; j <= runLimit; j++) {
            int codept = 0;
            Bitmap bm = null;
            if (mHasTabs && j < runLimit) {
                codept = chars[j];
                if (codept >= 0xd800 && codept < 0xdc00 && j + 1 < runLimit) {
                    codept = Character.codePointAt(chars, j);
                    if (codept >= Layout.MIN_EMOJI && codept <= Layout.MAX_EMOJI) {
                        bm = Layout.EMOJI_FACTORY.getBitmapFromAndroidPua(codept);
                    } else if (codept > 0xffff) {
                        ++j;
                        continue;
                    }
                }
            }
            if (j == runLimit || codept == '\t' || bm != null) {
                boolean inSegment = target >= segstart && target < j;
                boolean advance = (mDir == Layout.DIR_RIGHT_TO_LEFT) == runIsRtl;
                if (inSegment && advance) {
                    return h += measureRun(segstart, offset, j, runIsRtl, fmi);
                }
                float w = measureRun(segstart, j, j, runIsRtl, fmi);
                h += advance ? w : -w;
                if (inSegment) {
                    return h += measureRun(segstart, offset, j, runIsRtl, null);
                }
                if (codept == '\t') {
                    if (offset == j) {
                        return h;
                    }
                    h = mDir * nextTab(h * mDir);
                    if (target == j) {
                        return h;
                    }
                }
                if (bm != null) {
                    float bmAscent = ascent(j);
                    float wid = bm.getWidth() * -bmAscent / bm.getHeight();
                    h += mDir * wid;
                    j++;
                }
                segstart = j + 1;
            }
        }
    }
    return h;
}
Body of Second Method:
{
    int target = trailing ? offset - 1 : offset;
    if (target < 0) {
        return 0;
    }
    float h = 0;
    if (!mHasTabs) {
        if (mDirections == Layout.DIRS_ALL_LEFT_TO_RIGHT) {
            return measureRun(0, offset, mLen, false, fmi);
        }
        if (mDirections == Layout.DIRS_ALL_RIGHT_TO_LEFT) {
            return measureRun(0, offset, mLen, true, fmi);
        }
    }
    char[] chars = mChars;
    int[] runs = mDirections.mDirections;
    for (int i = 0; i < runs.length; i += 2) {
        int runStart = runs[i];
        int runLimit = runStart + (runs[i + 1] & Layout.RUN_LENGTH_MASK);
        if (runLimit > mLen) {
            runLimit = mLen;
        }
        boolean runIsRtl = (runs[i + 1] & Layout.RUN_RTL_FLAG) != 0;
        int segstart = runStart;
        for (int j = mHasTabs ? runStart : runLimit; j <= runLimit; j++) {
            int codept = 0;
            if (mHasTabs && j < runLimit) {
                codept = chars[j];
                if (codept >= 0xD800 && codept < 0xDC00 && j + 1 < runLimit) {
                    codept = Character.codePointAt(chars, j);
                    if (codept > 0xFFFF) {
                        ++j;
                        continue;
                    }
                }
            }
            if (j == runLimit || codept == '\t') {
                boolean inSegment = target >= segstart && target < j;
                boolean advance = (mDir == Layout.DIR_RIGHT_TO_LEFT) == runIsRtl;
                if (inSegment && advance) {
                    return h += measureRun(segstart, offset, j, runIsRtl, fmi);
                }
                float w = measureRun(segstart, j, j, runIsRtl, fmi);
                h += advance ? w : -w;
                if (inSegment) {
                    return h += measureRun(segstart, offset, j, runIsRtl, null);
                }
                if (codept == '\t') {
                    if (offset == j) {
                        return h;
                    }
                    h = mDir * nextTab(h * mDir);
                    if (target == j) {
                        return h;
                    }
                }
                segstart = j + 1;
            }
        }
    }
    return h;
}
------------------------
Find a silently evolved API code:android.app.WallpaperManager.getWallpaperInfo:COMMENT
Method Modifier: public      
Comment:/**
 * If the current wallpaper is a live wallpaper component, return the
 * information about that wallpaper.  Otherwise, if it is a static image,
 * simply return null.
 */

Body of Frist Method:
{
    try {
        if (sGlobals.mService == null) {
            Log.w(TAG, "WallpaperService not running");
            return null;
        } else {
            return sGlobals.mService.getWallpaperInfo();
        }
    } catch (RemoteException e) {
        return null;
    }
}
Body of Second Method:
{
    try {
        if (sGlobals.mService == null) {
            Log.w(TAG, "WallpaperService not running");
            throw new RuntimeException(new DeadSystemException());
        } else {
            return sGlobals.mService.getWallpaperInfo();
        }
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.util.ArraySet.add:COMMENT
Method Modifier: public      
Comment:/**
 * Adds the specified object to this set. The set is not modified if it
 * already contains the object.
 *
 * @param value the object to add.
 * @return {@code true} if this set is modified, {@code false} otherwise.
 * @throws ClassCastException
 * when the class of the object is inappropriate for this set.
 */

Body of Frist Method:
{
    final int hash;
    int index;
    if (value == null) {
        hash = 0;
        index = indexOfNull();
    } else {
        hash = value.hashCode();
        index = indexOf(value, hash);
    }
    if (index >= 0) {
        return false;
    }
    index = ~index;
    if (mSize >= mHashes.length) {
        final int n = mSize >= (BASE_SIZE * 2) ? (mSize + (mSize >> 1)) : (mSize >= BASE_SIZE ? (BASE_SIZE * 2) : BASE_SIZE);
        if (DEBUG)
            Log.d(TAG, "add: grow from " + mHashes.length + " to " + n);
        final int[] ohashes = mHashes;
        final Object[] oarray = mArray;
        allocArrays(n);
        if (mHashes.length > 0) {
            if (DEBUG)
                Log.d(TAG, "add: copy 0-" + mSize + " to 0");
            System.arraycopy(ohashes, 0, mHashes, 0, ohashes.length);
            System.arraycopy(oarray, 0, mArray, 0, oarray.length);
        }
        freeArrays(ohashes, oarray, mSize);
    }
    if (index < mSize) {
        if (DEBUG)
            Log.d(TAG, "add: move " + index + "-" + (mSize - index) + " to " + (index + 1));
        System.arraycopy(mHashes, index, mHashes, index + 1, mSize - index);
        System.arraycopy(mArray, index, mArray, index + 1, mSize - index);
    }
    mHashes[index] = hash;
    mArray[index] = value;
    mSize++;
    return true;
}
Body of Second Method:
{
    final int hash;
    int index;
    if (value == null) {
        hash = 0;
        index = indexOfNull();
    } else {
        hash = mIdentityHashCode ? System.identityHashCode(value) : value.hashCode();
        index = indexOf(value, hash);
    }
    if (index >= 0) {
        return false;
    }
    index = ~index;
    if (mSize >= mHashes.length) {
        final int n = mSize >= (BASE_SIZE * 2) ? (mSize + (mSize >> 1)) : (mSize >= BASE_SIZE ? (BASE_SIZE * 2) : BASE_SIZE);
        if (DEBUG)
            Log.d(TAG, "add: grow from " + mHashes.length + " to " + n);
        final int[] ohashes = mHashes;
        final Object[] oarray = mArray;
        allocArrays(n);
        if (mHashes.length > 0) {
            if (DEBUG)
                Log.d(TAG, "add: copy 0-" + mSize + " to 0");
            System.arraycopy(ohashes, 0, mHashes, 0, ohashes.length);
            System.arraycopy(oarray, 0, mArray, 0, oarray.length);
        }
        freeArrays(ohashes, oarray, mSize);
    }
    if (index < mSize) {
        if (DEBUG)
            Log.d(TAG, "add: move " + index + "-" + (mSize - index) + " to " + (index + 1));
        System.arraycopy(mHashes, index, mHashes, index + 1, mSize - index);
        System.arraycopy(mArray, index, mArray, index + 1, mSize - index);
    }
    mHashes[index] = hash;
    mArray[index] = value;
    mSize++;
    return true;
}
------------------------
Find a silently evolved API code:android.net.LocalSocketImpl.SocketInputStream.available:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    FileDescriptor myFd = fd;
    if (myFd == null)
        throw new IOException("socket closed");
    return available_native(myFd);
}
Body of Second Method:
{
    FileDescriptor myFd = fd;
    if (myFd == null)
        throw new IOException("socket closed");
    MutableInt avail = new MutableInt(0);
    try {
        Os.ioctlInt(myFd, OsConstants.FIONREAD, avail);
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
    return avail.value;
}
------------------------
Find a silently evolved API code:android.widget.TextView.setShadowLayer:COMMENT
Method Modifier: public      
Comment:/**
 * Gives the text a shadow of the specified blur radius and color, the specified
 * distance from its drawn position.
 * <p>
 * The text shadow produced does not interact with the properties on view
 * that are responsible for real time shadows,
 * {@link View#getElevation() elevation} and
 * {@link View#getTranslationZ() translationZ}.
 *
 * @see Paint#setShadowLayer(float, float, float, int)
 *
 * @attr ref android.R.styleable#TextView_shadowColor
 * @attr ref android.R.styleable#TextView_shadowDx
 * @attr ref android.R.styleable#TextView_shadowDy
 * @attr ref android.R.styleable#TextView_shadowRadius
 */

Body of Frist Method:
{
    mTextPaint.setShadowLayer(radius, dx, dy, color);
    mShadowRadius = radius;
    mShadowDx = dx;
    mShadowDy = dy;
    mShadowColor = color;
    // Will change text clip region
    if (mEditor != null)
        mEditor.invalidateTextDisplayList();
    invalidate();
}
Body of Second Method:
{
    mTextPaint.setShadowLayer(radius, dx, dy, color);
    mShadowRadius = radius;
    mShadowDx = dx;
    mShadowDy = dy;
    mShadowColor = color;
    // Will change text clip region
    if (mEditor != null) {
        mEditor.invalidateTextDisplayList();
        mEditor.invalidateHandlesAndActionMode();
    }
    invalidate();
}
------------------------
Find a silently evolved API code:android.location.Location.removeSpeed:COMMENT
Method Modifier: public      
Comment:/**
 * Remove the speed from this location.
 *
 * <p>Following this call {@link #hasSpeed} will return false,
 * and {@link #getSpeed} will return 0.0.
 */

Body of Frist Method:
{
    mSpeed = 0.0f;
    mHasSpeed = false;
}
Body of Second Method:
{
    mSpeed = 0.0f;
    mFieldsMask &= ~HAS_SPEED_MASK;
}
------------------------
Find a silently evolved API code:android.inputmethodservice.InputMethodService.InputMethodImpl.hideSoftInput:COMMENT
Method Modifier: public      
Comment:/**
 * Handle a request by the system to hide the soft input area.
 */

Body of Frist Method:
{
    if (DEBUG)
        Log.v(TAG, "hideSoftInput()");
    boolean wasVis = isInputViewShown();
    mShowInputFlags = 0;
    mShowInputRequested = false;
    mShowInputForced = false;
    doHideWindow();
    clearInsetOfPreviousIme();
    if (resultReceiver != null) {
        resultReceiver.send(wasVis != isInputViewShown() ? InputMethodManager.RESULT_HIDDEN : (wasVis ? InputMethodManager.RESULT_UNCHANGED_SHOWN : InputMethodManager.RESULT_UNCHANGED_HIDDEN), null);
    }
}
Body of Second Method:
{
    if (DEBUG)
        Log.v(TAG, "hideSoftInput()");
    boolean wasVis = isInputViewShown();
    mShowInputFlags = 0;
    mShowInputRequested = false;
    doHideWindow();
    clearInsetOfPreviousIme();
    if (resultReceiver != null) {
        resultReceiver.send(wasVis != isInputViewShown() ? InputMethodManager.RESULT_HIDDEN : (wasVis ? InputMethodManager.RESULT_UNCHANGED_SHOWN : InputMethodManager.RESULT_UNCHANGED_HIDDEN), null);
    }
}
------------------------
Find a silently evolved API code:android.media.AudioManager.unregisterAudioPolicyAsync:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 * @param policy the non-null {@link AudioPolicy} to unregister.
 */

Body of Frist Method:
{
    if (policy == null) {
        throw new IllegalArgumentException("Illegal null AudioPolicy argument");
    }
    IAudioService service = getService();
    try {
        service.unregisterAudioPolicyAsync(policy.cb());
        policy.setRegistration(null);
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in unregisterAudioPolicyAsync()", e);
    }
}
Body of Second Method:
{
    if (policy == null) {
        throw new IllegalArgumentException("Illegal null AudioPolicy argument");
    }
    IAudioService service = getService();
    try {
        service.unregisterAudioPolicyAsync(policy.cb());
        policy.setRegistration(null);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothAdapter.isMultipleAdvertisementSupported:COMMENT
Method Modifier: public      
Comment:/**
 * Return true if the multi advertisement is supported by the chipset
 *
 * @return true if Multiple Advertisement feature is supported
 */

Body of Frist Method:
{
    if (getState() != STATE_ON)
        return false;
    try {
        return mService.isMultiAdvertisementSupported();
    } catch (RemoteException e) {
        Log.e(TAG, "failed to get isMultipleAdvertisementSupported, error: ", e);
    }
    return false;
}
Body of Second Method:
{
    if (getState() != STATE_ON)
        return false;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.isMultiAdvertisementSupported();
    } catch (RemoteException e) {
        Log.e(TAG, "failed to get isMultipleAdvertisementSupported, error: ", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}
------------------------
Find a silently evolved API code:android.content.pm.UserInfo.supportsSwitchTo:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @return true if this user can be switched to.
 */

Body of Frist Method:
{
    // TODO remove fw.show_hidden_users when we have finished developing managed profiles.
    return !isManagedProfile() || SystemProperties.getBoolean("fw.show_hidden_users", false);
}
Body of Second Method:
{
    if (isEphemeral() && !isEnabled()) {
        // Don't support switching to an ephemeral user with removal in progress.
        return false;
    }
    // TODO remove fw.show_hidden_users when we have finished developing managed profiles.
    return !isManagedProfile() || SystemProperties.getBoolean("fw.show_hidden_users", false);
}
------------------------
Find a silently evolved API code:android.app.Activity.dispatchKeyEvent:COMMENT
Method Modifier: public      
Comment:/**
 * Called to process key events.  You can override this to intercept all
 * key events before they are dispatched to the window.  Be sure to call
 * this implementation for key events that should be handled normally.
 *
 * @param event The key event.
 *
 * @return boolean Return true if this event was consumed.
 */

Body of Frist Method:
{
    onUserInteraction();
    // the window handling it
    if (event.getKeyCode() == KeyEvent.KEYCODE_MENU && mActionBar != null && mActionBar.onMenuKeyEvent(event)) {
        return true;
    }
    Window win = getWindow();
    if (win.superDispatchKeyEvent(event)) {
        return true;
    }
    View decor = mDecor;
    if (decor == null)
        decor = win.getDecorView();
    return event.dispatch(this, decor != null ? decor.getKeyDispatcherState() : null, this);
}
Body of Second Method:
{
    onUserInteraction();
    // Let action bars open menus in response to the menu key prioritized over
    // the window handling it
    final int keyCode = event.getKeyCode();
    if (keyCode == KeyEvent.KEYCODE_MENU && mActionBar != null && mActionBar.onMenuKeyEvent(event)) {
        return true;
    } else if (event.isCtrlPressed() && event.getUnicodeChar(event.getMetaState() & ~KeyEvent.META_CTRL_MASK) == '<') {
        // Capture the Control-< and send focus to the ActionBar
        final int action = event.getAction();
        if (action == KeyEvent.ACTION_DOWN) {
            final ActionBar actionBar = getActionBar();
            if (actionBar != null && actionBar.isShowing() && actionBar.requestFocus()) {
                mEatKeyUpEvent = true;
                return true;
            }
        } else if (action == KeyEvent.ACTION_UP && mEatKeyUpEvent) {
            mEatKeyUpEvent = false;
            return true;
        }
    }
    Window win = getWindow();
    if (win.superDispatchKeyEvent(event)) {
        return true;
    }
    View decor = mDecor;
    if (decor == null)
        decor = win.getDecorView();
    return event.dispatch(this, decor != null ? decor.getKeyDispatcherState() : null, this);
}
------------------------
Find a silently evolved API code:android.app.Activity.isTopOfTask:COMMENT
Method Modifier: private     
Comment:/**
 * Indication of whether this is the highest level activity in this task. Can be used to
 * determine whether an activity launched by this activity was placed in the same task or
 * another task.
 *
 * @return true if this is the topmost, non-finishing activity in its task.
 */

Body of Frist Method:
{
    try {
        return ActivityManagerNative.getDefault().isTopOfTask(mToken);
    } catch (RemoteException e) {
        return false;
    }
}
Body of Second Method:
{
    if (mToken == null || mWindow == null) {
        return false;
    }
    try {
        return ActivityManagerNative.getDefault().isTopOfTask(getActivityToken());
    } catch (RemoteException e) {
        return false;
    }
}
------------------------
Find a silently evolved API code:android.inputmethodservice.InputMethodService.sendKeyChar:COMMENT
Method Modifier: public      
Comment:/**
 * Send the given UTF-16 character to the current input connection.  Most
 * characters will be delivered simply by calling
 * {@link InputConnection#commitText InputConnection.commitText()} with
 * the character; some, however, may be handled different.  In particular,
 * the enter character ('\n') will either be delivered as an action code
 * or a raw key event, as appropriate.  Consider this as a convenience
 * method for IMEs that do not have a full implementation of actions; a
 * fully complying IME will decide of the right action for each event and
 * will likely never call this method except maybe to handle events coming
 * from an actual hardware keyboard.
 *
 * @param charCode The UTF-16 character code to send.
 */

Body of Frist Method:
{
    switch(charCode) {
        case // Apps may be listening to an enter key to perform an action
        '\n':
            if (!sendDefaultEditorAction(true)) {
                sendDownUpKeyEvents(KeyEvent.KEYCODE_ENTER);
            }
            break;
        default:
            // Make sure that digits go through any text watcher on the client side.
            if (charCode >= '0' && charCode <= '9') {
                sendDownUpKeyEvents(charCode - '0' + KeyEvent.KEYCODE_0);
            } else {
                InputConnection ic = getCurrentInputConnection();
                if (ic != null) {
                    ic.commitText(String.valueOf((char) charCode), 1);
                }
            }
            break;
    }
}
Body of Second Method:
{
    switch(charCode) {
        case // Apps may be listening to an enter key to perform an action
        '\n':
            if (!sendDefaultEditorAction(true)) {
                sendDownUpKeyEvents(KeyEvent.KEYCODE_ENTER);
            }
            break;
        default:
            // Make sure that digits go through any text watcher on the client side.
            if (charCode >= '0' && charCode <= '9') {
                sendDownUpKeyEvents(charCode - '0' + KeyEvent.KEYCODE_0);
            } else {
                InputConnection ic = getCurrentInputConnection();
                if (ic != null) {
                    ic.commitText(String.valueOf(charCode), 1);
                }
            }
            break;
    }
}
------------------------
Find a silently evolved API code:android.net.ConnectivityManager.isNetworkSupported:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns true if the hardware supports the given network type
 * else it returns false.  This doesn't indicate we have coverage
 * or are authorized onto a network, just whether or not the
 * hardware supports it.  For example a GSM phone without a SIM
 * should still return {@code true} for mobile data, but a wifi only
 * tablet would return {@code false}.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
 *
 * @param networkType The network type we'd like to check
 * @return {@code true} if supported, else {@code false}
 *
 * @hide
 */

Body of Frist Method:
{
    try {
        return mService.isNetworkSupported(networkType);
    } catch (RemoteException e) {
    }
    return false;
}
Body of Second Method:
{
    try {
        return mService.isNetworkSupported(networkType);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.telephony.TelephonyManager.getDataEnabled:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    boolean retVal = false;
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            retVal = telephony.getDataEnabled(subId);
    } catch (RemoteException e) {
        Log.e(TAG, "Error calling ITelephony#getDataEnabled", e);
    } catch (NullPointerException e) {
    }
    Log.d(TAG, "getDataEnabled: retVal=" + retVal);
    return retVal;
}
Body of Second Method:
{
    boolean retVal = false;
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            retVal = telephony.getDataEnabled(subId);
    } catch (RemoteException e) {
        Log.e(TAG, "Error calling ITelephony#getDataEnabled", e);
    } catch (NullPointerException e) {
    }
    return retVal;
}
------------------------
Find a silently evolved API code:android.animation.ValueAnimator.getCurrentAnimationsCount:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Return the number of animations currently running.
 *
 * Used by StrictMode internally to annotate violations.
 * May be called on arbitrary threads!
 *
 * @hide
 */

Body of Frist Method:
{
    AnimationHandler handler = sAnimationHandler.get();
    return handler != null ? handler.mAnimations.size() : 0;
}
Body of Second Method:
{
    return AnimationHandler.getAnimationCount();
}
------------------------
Find a silently evolved API code:android.net.NetworkCapabilities.clearAll:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Completely clears the contents of this object, removing even the capabilities that are set
 * by default when the object is constructed.
 * @hide
 */

Body of Frist Method:
{
    mNetworkCapabilities = mTransportTypes = 0;
    mLinkUpBandwidthKbps = mLinkDownBandwidthKbps = 0;
    mNetworkSpecifier = null;
}
Body of Second Method:
{
    mNetworkCapabilities = mTransportTypes = 0;
    mLinkUpBandwidthKbps = mLinkDownBandwidthKbps = 0;
    mNetworkSpecifier = null;
    mSignalStrength = SIGNAL_STRENGTH_UNSPECIFIED;
}
------------------------
Find a silently evolved API code:android.media.MediaDrm.CryptoSession.encrypt:COMMENT
Method Modifier: public      
Comment:/**
 * Encrypt data using the CryptoSession's cipher algorithm
 *
 * @param keyid specifies which key to use
 * @param input the data to encrypt
 * @param iv the initialization vector to use for the cipher
 */

Body of Frist Method:
{
    return encryptNative(mDrm, mSessionId, keyid, input, iv);
}
Body of Second Method:
{
    return encryptNative(MediaDrm.this, mSessionId, keyid, input, iv);
}
------------------------
Find a silently evolved API code:android.renderscript.Sampler.CLAMP_LINEAR:COMMENT
Method Modifier: public      static      
Comment:/**
 * Retrieve a sampler with min and mag set to linear and wrap modes set to
 * clamp.
 *
 * @param rs Context to which the sampler will belong.
 *
 * @return Sampler
 */

Body of Frist Method:
{
    if (rs.mSampler_CLAMP_LINEAR == null) {
        Builder b = new Builder(rs);
        b.setMinification(Value.LINEAR);
        b.setMagnification(Value.LINEAR);
        b.setWrapS(Value.CLAMP);
        b.setWrapT(Value.CLAMP);
        rs.mSampler_CLAMP_LINEAR = b.create();
    }
    return rs.mSampler_CLAMP_LINEAR;
}
Body of Second Method:
{
    if (rs.mSampler_CLAMP_LINEAR == null) {
        synchronized (rs) {
            if (rs.mSampler_CLAMP_LINEAR == null) {
                Builder b = new Builder(rs);
                b.setMinification(Value.LINEAR);
                b.setMagnification(Value.LINEAR);
                b.setWrapS(Value.CLAMP);
                b.setWrapT(Value.CLAMP);
                rs.mSampler_CLAMP_LINEAR = b.create();
            }
        }
    }
    return rs.mSampler_CLAMP_LINEAR;
}
------------------------
Find a silently evolved API code:android.media.RemoteController.getEstimatedMediaPosition:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * Return the estimated playback position of the current media track or a negative value
 * if not available.
 *
 * <p>The value returned is estimated by the current process and may not be perfect.
 * The time returned by this method is calculated from the last state change time based
 * on the current play position at that time and the last known playback speed.
 * An application may call {@link #setSynchronizationMode(int)} to apply
 * a synchronization policy that will periodically re-sync the estimated position
 * with the RemoteControlClient.</p>
 *
 * @return the current estimated playback position in milliseconds or a negative value
 * if not available
 *
 * @see OnClientUpdateListener#onClientPlaybackStateUpdate(int, long, long, float)
 */

Body of Frist Method:
{
    if (USE_SESSIONS) {
        synchronized (mInfoLock) {
            if (mCurrentSession != null) {
                PlaybackState state = mCurrentSession.getPlaybackState();
                if (state != null) {
                    return state.getPosition();
                }
            }
        }
    } else {
        final PlaybackInfo lastPlaybackInfo;
        synchronized (mInfoLock) {
            lastPlaybackInfo = mLastPlaybackInfo;
        }
        if (lastPlaybackInfo != null) {
            if (!RemoteControlClient.playbackPositionShouldMove(lastPlaybackInfo.mState)) {
                return lastPlaybackInfo.mCurrentPosMs;
            }
            // Take the current position at the time of state change and
            // estimate.
            final long thenPos = lastPlaybackInfo.mCurrentPosMs;
            if (thenPos < 0) {
                return -1;
            }
            final long now = SystemClock.elapsedRealtime();
            final long then = lastPlaybackInfo.mStateChangeTimeMs;
            final long sinceThen = now - then;
            final long scaledSinceThen = (long) (sinceThen * lastPlaybackInfo.mSpeed);
            return thenPos + scaledSinceThen;
        }
    }
    return -1;
}
Body of Second Method:
{
    synchronized (mInfoLock) {
        if (mCurrentSession != null) {
            PlaybackState state = mCurrentSession.getPlaybackState();
            if (state != null) {
                return state.getPosition();
            }
        }
    }
    return -1;
}
------------------------
Find a silently evolved API code:android.net.TrafficStats.getMobileIfaces:COMMENT
Method Modifier: private     static      
Comment:/**
 * Return set of any ifaces associated with mobile networks since boot.
 * Interfaces are never removed from this list, so counters should always be
 * monotonic.
 */

Body of Frist Method:
{
    try {
        return getStatsService().getMobileIfaces();
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}
Body of Second Method:
{
    try {
        return getStatsService().getMobileIfaces();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.accounts.AccountManager.getAccountsByTypeAsUser:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide Same as {@link #getAccountsByType(String)} but for a specific user.
 */

Body of Frist Method:
{
    try {
        return mService.getAccountsAsUser(type, userHandle.getIdentifier(), mContext.getOpPackageName());
    } catch (RemoteException e) {
        // won't ever happen
        throw new RuntimeException(e);
    }
}
Body of Second Method:
{
    try {
        return mService.getAccountsAsUser(type, userHandle.getIdentifier(), mContext.getOpPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.content.res.TypedArray.getChangingConfigurations:COMMENT
Method Modifier: public      
Comment:/**
 * Return a mask of the configuration parameters for which the values in
 * this typed array may change.
 *
 * @return Returns a mask of the changing configuration parameters, as
 * defined by {@link android.content.pm.ActivityInfo}.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @see android.content.pm.ActivityInfo
 */

Body of Frist Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    int changingConfig = 0;
    final int[] data = mData;
    final int N = length();
    for (int i = 0; i < N; i++) {
        final int index = i * AssetManager.STYLE_NUM_ENTRIES;
        final int type = data[index + AssetManager.STYLE_TYPE];
        if (type == TypedValue.TYPE_NULL) {
            continue;
        }
        changingConfig |= data[index + AssetManager.STYLE_CHANGING_CONFIGURATIONS];
    }
    return changingConfig;
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    @Config int changingConfig = 0;
    final int[] data = mData;
    final int N = length();
    for (int i = 0; i < N; i++) {
        final int index = i * AssetManager.STYLE_NUM_ENTRIES;
        final int type = data[index + AssetManager.STYLE_TYPE];
        if (type == TypedValue.TYPE_NULL) {
            continue;
        }
        changingConfig |= ActivityInfo.activityInfoConfigNativeToJava(data[index + AssetManager.STYLE_CHANGING_CONFIGURATIONS]);
    }
    return changingConfig;
}
------------------------
Find a silently evolved API code:android.graphics.drawable.BitmapDrawable.updateStateFromTypedArray:COMMENT
Method Modifier: private     
Comment:/**
 * Updates the constant state from the values in the typed array.
 */

Body of Frist Method:
{
    final Resources r = a.getResources();
    final BitmapState state = mBitmapState;
    // Account for any configuration changes.
    state.mChangingConfigurations |= a.getChangingConfigurations();
    // Extract the theme attributes, if any.
    state.mThemeAttrs = a.extractThemeAttrs();
    final int srcResId = a.getResourceId(R.styleable.BitmapDrawable_src, 0);
    if (srcResId != 0) {
        final Bitmap bitmap = BitmapFactory.decodeResource(r, srcResId);
        if (bitmap == null) {
            throw new XmlPullParserException(a.getPositionDescription() + ": <bitmap> requires a valid 'src' attribute");
        }
        state.mBitmap = bitmap;
    }
    state.mTargetDensity = r.getDisplayMetrics().densityDpi;
    final boolean defMipMap = state.mBitmap != null ? state.mBitmap.hasMipMap() : false;
    setMipMap(a.getBoolean(R.styleable.BitmapDrawable_mipMap, defMipMap));
    state.mAutoMirrored = a.getBoolean(R.styleable.BitmapDrawable_autoMirrored, state.mAutoMirrored);
    state.mBaseAlpha = a.getFloat(R.styleable.BitmapDrawable_alpha, state.mBaseAlpha);
    final int tintMode = a.getInt(R.styleable.BitmapDrawable_tintMode, -1);
    if (tintMode != -1) {
        state.mTintMode = Drawable.parseTintMode(tintMode, Mode.SRC_IN);
    }
    final ColorStateList tint = a.getColorStateList(R.styleable.BitmapDrawable_tint);
    if (tint != null) {
        state.mTint = tint;
    }
    final Paint paint = mBitmapState.mPaint;
    paint.setAntiAlias(a.getBoolean(R.styleable.BitmapDrawable_antialias, paint.isAntiAlias()));
    paint.setFilterBitmap(a.getBoolean(R.styleable.BitmapDrawable_filter, paint.isFilterBitmap()));
    paint.setDither(a.getBoolean(R.styleable.BitmapDrawable_dither, paint.isDither()));
    setGravity(a.getInt(R.styleable.BitmapDrawable_gravity, state.mGravity));
    final int tileMode = a.getInt(R.styleable.BitmapDrawable_tileMode, TILE_MODE_UNDEFINED);
    if (tileMode != TILE_MODE_UNDEFINED) {
        final Shader.TileMode mode = parseTileMode(tileMode);
        setTileModeXY(mode, mode);
    }
    final int tileModeX = a.getInt(R.styleable.BitmapDrawable_tileModeX, TILE_MODE_UNDEFINED);
    if (tileModeX != TILE_MODE_UNDEFINED) {
        setTileModeX(parseTileMode(tileModeX));
    }
    final int tileModeY = a.getInt(R.styleable.BitmapDrawable_tileModeY, TILE_MODE_UNDEFINED);
    if (tileModeY != TILE_MODE_UNDEFINED) {
        setTileModeY(parseTileMode(tileModeY));
    }
    final int densityDpi = r.getDisplayMetrics().densityDpi;
    state.mTargetDensity = densityDpi == 0 ? DisplayMetrics.DENSITY_DEFAULT : densityDpi;
}
Body of Second Method:
{
    final Resources r = a.getResources();
    final BitmapState state = mBitmapState;
    // Account for any configuration changes.
    state.mChangingConfigurations |= a.getChangingConfigurations();
    // Extract the theme attributes, if any.
    state.mThemeAttrs = a.extractThemeAttrs();
    final int srcResId = a.getResourceId(R.styleable.BitmapDrawable_src, 0);
    if (srcResId != 0) {
        final Bitmap bitmap = BitmapFactory.decodeResource(r, srcResId);
        if (bitmap == null) {
            throw new XmlPullParserException(a.getPositionDescription() + ": <bitmap> requires a valid 'src' attribute");
        }
        state.mBitmap = bitmap;
    }
    state.mTargetDensity = r.getDisplayMetrics().densityDpi;
    final boolean defMipMap = state.mBitmap != null ? state.mBitmap.hasMipMap() : false;
    setMipMap(a.getBoolean(R.styleable.BitmapDrawable_mipMap, defMipMap));
    state.mAutoMirrored = a.getBoolean(R.styleable.BitmapDrawable_autoMirrored, state.mAutoMirrored);
    state.mBaseAlpha = a.getFloat(R.styleable.BitmapDrawable_alpha, state.mBaseAlpha);
    final int tintMode = a.getInt(R.styleable.BitmapDrawable_tintMode, -1);
    if (tintMode != -1) {
        state.mTintMode = Drawable.parseTintMode(tintMode, Mode.SRC_IN);
    }
    final ColorStateList tint = a.getColorStateList(R.styleable.BitmapDrawable_tint);
    if (tint != null) {
        state.mTint = tint;
    }
    final Paint paint = mBitmapState.mPaint;
    paint.setAntiAlias(a.getBoolean(R.styleable.BitmapDrawable_antialias, paint.isAntiAlias()));
    paint.setFilterBitmap(a.getBoolean(R.styleable.BitmapDrawable_filter, paint.isFilterBitmap()));
    paint.setDither(a.getBoolean(R.styleable.BitmapDrawable_dither, paint.isDither()));
    setGravity(a.getInt(R.styleable.BitmapDrawable_gravity, state.mGravity));
    final int tileMode = a.getInt(R.styleable.BitmapDrawable_tileMode, TILE_MODE_UNDEFINED);
    if (tileMode != TILE_MODE_UNDEFINED) {
        final Shader.TileMode mode = parseTileMode(tileMode);
        setTileModeXY(mode, mode);
    }
    final int tileModeX = a.getInt(R.styleable.BitmapDrawable_tileModeX, TILE_MODE_UNDEFINED);
    if (tileModeX != TILE_MODE_UNDEFINED) {
        setTileModeX(parseTileMode(tileModeX));
    }
    final int tileModeY = a.getInt(R.styleable.BitmapDrawable_tileModeY, TILE_MODE_UNDEFINED);
    if (tileModeY != TILE_MODE_UNDEFINED) {
        setTileModeY(parseTileMode(tileModeY));
    }
    state.mTargetDensity = Drawable.resolveDensity(r, 0);
}
------------------------
Find a silently evolved API code:android.inputmethodservice.InputMethodService.onShowInputRequested:COMMENT
Method Modifier: public      
Comment:/**
 * The system has decided that it may be time to show your input method.
 * This is called due to a corresponding call to your
 * {@link InputMethod#showSoftInput InputMethod.showSoftInput()}
 * method.  The default implementation uses
 * {@link #onEvaluateInputViewShown()}, {@link #onEvaluateFullscreenMode()},
 * and the current configuration to decide whether the input view should
 * be shown at this point.
 *
 * @param flags Provides additional information about the show request,
 * as per {@link InputMethod#showSoftInput InputMethod.showSoftInput()}.
 * @param configChange This is true if we are re-showing due to a
 * configuration change.
 * @return Returns true to indicate that the window should be shown.
 */

Body of Frist Method:
{
    if (!onEvaluateInputViewShown()) {
        return false;
    }
    if ((flags & InputMethod.SHOW_EXPLICIT) == 0) {
        if (!configChange && onEvaluateFullscreenMode()) {
            // mode at this point.
            return false;
        }
        Configuration config = getResources().getConfiguration();
        if (config.keyboard != Configuration.KEYBOARD_NOKEYS) {
            // These kinds of devices don't need it that much.
            return false;
        }
    }
    if ((flags & InputMethod.SHOW_FORCED) != 0) {
        mShowInputForced = true;
    }
    return true;
}
Body of Second Method:
{
    if (!onEvaluateInputViewShown()) {
        return false;
    }
    if ((flags & InputMethod.SHOW_EXPLICIT) == 0) {
        if (!configChange && onEvaluateFullscreenMode()) {
            // mode at this point.
            return false;
        }
        if (!mSettingsObserver.shouldShowImeWithHardKeyboard() && getResources().getConfiguration().keyboard != Configuration.KEYBOARD_NOKEYS) {
            // These kinds of devices don't need it that much.
            return false;
        }
    }
    return true;
}
------------------------
Find a silently evolved API code:android.media.AudioManager.isBluetoothScoOn:COMMENT
Method Modifier: public      
Comment:/**
 * Checks whether communications use Bluetooth SCO.
 *
 * @return true if SCO is used for communications;
 * false if otherwise
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        return service.isBluetoothScoOn();
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in isBluetoothScoOn", e);
        return false;
    }
}
Body of Second Method:
{
    IAudioService service = getService();
    try {
        return service.isBluetoothScoOn();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.location.Location.setSpeed:COMMENT
Method Modifier: public      
Comment:/**
 * Set the speed, in meters/second over ground.
 *
 * <p>Following this call {@link #hasSpeed} will return true.
 */

Body of Frist Method:
{
    mSpeed = speed;
    mHasSpeed = true;
}
Body of Second Method:
{
    mSpeed = speed;
    mFieldsMask |= HAS_SPEED_MASK;
}
------------------------
Find a silently evolved API code:android.view.inputmethod.CursorAnchorInfo.getMatrix:COMMENT
Method Modifier: public      
Comment:/**
 * Returns a new instance of {@link android.graphics.Matrix} that indicates the transformation
 * matrix that is to be applied other positional data in this class.
 * @return a new instance (copy) of the transformation matrix.
 */

Body of Frist Method:
{
    return new Matrix(mMatrix);
}
Body of Second Method:
{
    final Matrix matrix = new Matrix();
    matrix.setValues(mMatrixValues);
    return matrix;
}
------------------------
Find a silently evolved API code:android.service.notification.StatusBarNotification.cloneLight:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    final Notification no = new Notification();
    // light copy
    this.notification.cloneInto(no, false);
    return new StatusBarNotification(this.pkg, this.opPkg, this.id, this.tag, this.uid, this.initialPid, this.score, no, this.user, this.postTime);
}
Body of Second Method:
{
    final Notification no = new Notification();
    // light copy
    this.notification.cloneInto(no, false);
    return new StatusBarNotification(this.pkg, this.opPkg, this.id, this.tag, this.uid, this.initialPid, no, this.user, this.overrideGroupKey, this.postTime);
}
------------------------
Find a silently evolved API code:android.telephony.CarrierConfigManager.getConfig:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the configuration values for the default subscription.
 *
 * <p>Requires Permission:
 * {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}
 *
 * @see #getConfigForSubId
 */

Body of Frist Method:
{
    return getConfigForSubId(SubscriptionManager.getDefaultSubId());
}
Body of Second Method:
{
    return getConfigForSubId(SubscriptionManager.getDefaultSubscriptionId());
}
------------------------
Find a silently evolved API code:android.accounts.AccountManager.getPreviousName:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the previous name associated with the account or {@code null}, if
 * none. This is intended so that clients of {@link
 * #LOGIN_ACCOUNTS_CHANGED_ACTION} broadcasts can determine if an
 * authenticator has renamed an account.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * @param account The account to query for a previous name.
 * @return The account's previous name, null if the account has never been
 * renamed.
 */

Body of Frist Method:
{
    if (account == null)
        throw new IllegalArgumentException("account is null");
    try {
        return mService.getPreviousName(account);
    } catch (RemoteException e) {
        // will never happen
        throw new RuntimeException(e);
    }
}
Body of Second Method:
{
    if (account == null)
        throw new IllegalArgumentException("account is null");
    try {
        return mService.getPreviousName(account);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.preference.PreferenceGroup.addPreference:COMMENT
Method Modifier: public      
Comment:/**
 * Adds a {@link Preference} at the correct position based on the
 * preference's order.
 *
 * @param preference The preference to add.
 * @return Whether the preference is now in this group.
 */

Body of Frist Method:
{
    if (mPreferenceList.contains(preference)) {
        // Exists
        return true;
    }
    if (preference.getOrder() == Preference.DEFAULT_ORDER) {
        if (mOrderingAsAdded) {
            preference.setOrder(mCurrentPreferenceOrder++);
        }
        if (preference instanceof PreferenceGroup) {
            // TODO: fix (method is called tail recursively when inflating,
            // so we won't end up properly passing this flag down to children
            ((PreferenceGroup) preference).setOrderingAsAdded(mOrderingAsAdded);
        }
    }
    int insertionIndex = Collections.binarySearch(mPreferenceList, preference);
    if (insertionIndex < 0) {
        insertionIndex = insertionIndex * -1 - 1;
    }
    if (!onPrepareAddPreference(preference)) {
        return false;
    }
    synchronized (this) {
        mPreferenceList.add(insertionIndex, preference);
    }
    preference.onAttachedToHierarchy(getPreferenceManager());
    if (mAttachedToActivity) {
        preference.onAttachedToActivity();
    }
    notifyHierarchyChanged();
    return true;
}
Body of Second Method:
{
    if (mPreferenceList.contains(preference)) {
        // Exists
        return true;
    }
    if (preference.getOrder() == Preference.DEFAULT_ORDER) {
        if (mOrderingAsAdded) {
            preference.setOrder(mCurrentPreferenceOrder++);
        }
        if (preference instanceof PreferenceGroup) {
            // TODO: fix (method is called tail recursively when inflating,
            // so we won't end up properly passing this flag down to children
            ((PreferenceGroup) preference).setOrderingAsAdded(mOrderingAsAdded);
        }
    }
    if (!onPrepareAddPreference(preference)) {
        return false;
    }
    synchronized (this) {
        int insertionIndex = Collections.binarySearch(mPreferenceList, preference);
        if (insertionIndex < 0) {
            insertionIndex = insertionIndex * -1 - 1;
        }
        mPreferenceList.add(insertionIndex, preference);
    }
    preference.onAttachedToHierarchy(getPreferenceManager());
    if (mAttachedToActivity) {
        preference.onAttachedToActivity();
    }
    notifyHierarchyChanged();
    return true;
}
------------------------
Find a silently evolved API code:android.os.Bundle.filterValues:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Filter values in Bundle to only basic types.
 * @hide
 */

Body of Frist Method:
{
    unparcel();
    if (mMap != null) {
        for (int i = mMap.size() - 1; i >= 0; i--) {
            Object value = mMap.valueAt(i);
            if (PersistableBundle.isValidType(value)) {
                continue;
            }
            if (value instanceof Bundle) {
                ((Bundle) value).filterValues();
            }
            if (value.getClass().getName().startsWith("android.")) {
                continue;
            }
            mMap.removeAt(i);
        }
    }
}
Body of Second Method:
{
    unparcel();
    if (mMap != null) {
        for (int i = mMap.size() - 1; i >= 0; i--) {
            Object value = mMap.valueAt(i);
            if (PersistableBundle.isValidType(value)) {
                continue;
            }
            if (value instanceof Bundle) {
                ((Bundle) value).filterValues();
            }
            if (value.getClass().getName().startsWith("android.")) {
                continue;
            }
            mMap.removeAt(i);
        }
    }
    mFlags |= FLAG_HAS_FDS_KNOWN;
    mFlags &= ~FLAG_HAS_FDS;
}
------------------------
Find a silently evolved API code:android.os.Build.isBuildConsistent:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Verifies the the current flash of the device is consistent with what
 * was expected at build time.
 * 1) Checks that device fingerprint is defined and that it matches across
 * various partitions.
 * 2) Verifies radio and bootloader partitions are those expected in the build.
 *
 * @hide
 */

Body of Frist Method:
{
    final String system = SystemProperties.get("ro.build.fingerprint");
    final String vendor = SystemProperties.get("ro.vendor.build.fingerprint");
    final String bootimage = SystemProperties.get("ro.bootimage.build.fingerprint");
    final String requiredBootloader = SystemProperties.get("ro.build.expect.bootloader");
    final String currentBootloader = SystemProperties.get("ro.bootloader");
    final String requiredRadio = SystemProperties.get("ro.build.expect.baseband");
    final String currentRadio = SystemProperties.get("gsm.version.baseband");
    if (TextUtils.isEmpty(system)) {
        Slog.e(TAG, "Required ro.build.fingerprint is empty!");
        return false;
    }
    if (!TextUtils.isEmpty(vendor)) {
        if (!Objects.equals(system, vendor)) {
            Slog.e(TAG, "Mismatched fingerprints; system reported " + system + " but vendor reported " + vendor);
            return false;
        }
    }
    return true;
}
Body of Second Method:
{
    // Don't care on eng builds.  Incremental build may trigger false negative.
    if ("eng".equals(TYPE))
        return true;
    final String system = SystemProperties.get("ro.build.fingerprint");
    final String vendor = SystemProperties.get("ro.vendor.build.fingerprint");
    final String bootimage = SystemProperties.get("ro.bootimage.build.fingerprint");
    final String requiredBootloader = SystemProperties.get("ro.build.expect.bootloader");
    final String currentBootloader = SystemProperties.get("ro.bootloader");
    final String requiredRadio = SystemProperties.get("ro.build.expect.baseband");
    final String currentRadio = SystemProperties.get("gsm.version.baseband");
    if (TextUtils.isEmpty(system)) {
        Slog.e(TAG, "Required ro.build.fingerprint is empty!");
        return false;
    }
    if (!TextUtils.isEmpty(vendor)) {
        if (!Objects.equals(system, vendor)) {
            Slog.e(TAG, "Mismatched fingerprints; system reported " + system + " but vendor reported " + vendor);
            return false;
        }
    }
    return true;
}
------------------------
Find a silently evolved API code:android.media.MediaDrm.CryptoSession.verify:COMMENT
Method Modifier: public      
Comment:/**
 * Verify a signature using the CryptoSessions's mac algorithm. Return true
 * if the signatures match, false if they do no.
 *
 * @param keyid specifies which key to use
 * @param message the data to verify
 * @param signature the reference signature which will be compared with the
 * computed signature
 */

Body of Frist Method:
{
    return verifyNative(mDrm, mSessionId, keyid, message, signature);
}
Body of Second Method:
{
    return verifyNative(MediaDrm.this, mSessionId, keyid, message, signature);
}
------------------------
Find a silently evolved API code:android.telephony.TelephonyManager.setPreferredNetworkTypeToGlobal:COMMENT
Method Modifier: public      
Comment:/**
 * Set the preferred network type to global mode which includes LTE, CDMA, EvDo and GSM/WCDMA.
 *
 * <p>
 * Requires that the calling app has carrier privileges.
 * @see #hasCarrierPrivileges
 *
 * @return true on success; false on any failure.
 */

Body of Frist Method:
{
    return setPreferredNetworkType(getDefaultSubscription(), RILConstants.NETWORK_MODE_LTE_CDMA_EVDO_GSM_WCDMA);
}
Body of Second Method:
{
    return setPreferredNetworkTypeToGlobal(getSubId());
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiManager.removeNetwork:COMMENT
Method Modifier: public      
Comment:/**
 * Remove the specified network from the list of configured networks.
 * This may result in the asynchronous delivery of state change
 * events.
 * @param netId the integer that identifies the network configuration
 * to the supplicant
 * @return {@code true} if the operation succeeded
 */

Body of Frist Method:
{
    try {
        return mService.removeNetwork(netId);
    } catch (RemoteException e) {
        return false;
    }
}
Body of Second Method:
{
    try {
        return mService.removeNetwork(netId);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.media.AudioManager.notifyVolumeControllerVisible:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Notify audio manager about volume controller visibility changes.
 * Currently limited to SystemUI.
 *
 * @hide
 */

Body of Frist Method:
{
    try {
        getService().notifyVolumeControllerVisible(controller, visible);
    } catch (RemoteException e) {
        Log.w(TAG, "Error notifying about volume controller visibility", e);
    }
}
Body of Second Method:
{
    try {
        getService().notifyVolumeControllerVisible(controller, visible);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothAdapter.getDiscoverableTimeout:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (getState() != STATE_ON)
        return -1;
    try {
        synchronized (mManagerCallback) {
            if (mService != null)
                return mService.getDiscoverableTimeout();
        }
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return -1;
}
Body of Second Method:
{
    if (getState() != STATE_ON)
        return -1;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.getDiscoverableTimeout();
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return -1;
}
------------------------
Find a silently evolved API code:android.net.ConnectivityManager.getNetworkForType:COMMENT
Method Modifier: public      hidden      deprecated  
Comment:/**
 * Returns the {@link Network} object currently serving a given type, or
 * null if the given type is not connected.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
 *
 * @hide
 * @deprecated This method does not support multiple connected networks
 * of the same type. Use {@link #getAllNetworks} and
 * {@link #getNetworkInfo(android.net.Network)} instead.
 */

Body of Frist Method:
{
    try {
        return mService.getNetworkForType(networkType);
    } catch (RemoteException e) {
        return null;
    }
}
Body of Second Method:
{
    try {
        return mService.getNetworkForType(networkType);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.view.inputmethod.BaseInputConnection.reportFullscreenMode:COMMENT
Method Modifier: public      
Comment:/**
 * Updates InputMethodManager with the current fullscreen mode.
 */

Body of Frist Method:
{
    mIMM.setFullscreenMode(enabled);
    return true;
}
Body of Second Method:
{
    return true;
}
------------------------
Find a silently evolved API code:android.net.ConnectivityManager.getActiveNetworkQuotaInfo:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Return quota status for the current active network, or {@code null} if no
 * network is active. Quota status can change rapidly, so these values
 * shouldn't be cached.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
 *
 * @hide
 */

Body of Frist Method:
{
    try {
        return mService.getActiveNetworkQuotaInfo();
    } catch (RemoteException e) {
        return null;
    }
}
Body of Second Method:
{
    try {
        return mService.getActiveNetworkQuotaInfo();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiManager.getConnectionStatistics:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    try {
        return mService.getConnectionStatistics();
    } catch (RemoteException e) {
        return null;
    }
}
Body of Second Method:
{
    try {
        return mService.getConnectionStatistics();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothAdapter.setName:COMMENT
Method Modifier: public      
Comment:/**
 * Set the friendly Bluetooth name of the local Bluetooth adapter.
 * <p>This name is visible to remote Bluetooth devices.
 * <p>Valid Bluetooth names are a maximum of 248 bytes using UTF-8
 * encoding, although many remote devices can only display the first
 * 40 characters, and some may be limited to just 20.
 * <p>If Bluetooth state is not {@link #STATE_ON}, this API
 * will return false. After turning on Bluetooth,
 * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}
 * to get the updated value.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}
 *
 * @param name a valid Bluetooth name
 * @return     true if the name was set, false otherwise
 */

Body of Frist Method:
{
    if (getState() != STATE_ON)
        return false;
    try {
        synchronized (mManagerCallback) {
            if (mService != null)
                return mService.setName(name);
        }
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
Body of Second Method:
{
    if (getState() != STATE_ON)
        return false;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.setName(name);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}
------------------------
Find a silently evolved API code:android.hardware.camera2.params.OutputConfiguration.hashCode:COMMENT
<android.hardware.camera2.params.OutputConfiguration: int hashCode()>
public      hidden      ->public      
Method Modifier: public      hidden      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    return HashCodeHelpers.hashCode(mSurface.hashCode(), mRotation);
}
Body of Second Method:
{
    return HashCodeHelpers.hashCode(mRotation, mSurface.hashCode(), mConfiguredGenerationId, mConfiguredSize.hashCode(), mConfiguredFormat, mConfiguredDataspace, mSurfaceGroupId);
}
------------------------
Find a silently evolved API code:android.widget.TextView.setExtracting:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (mEditor.mInputMethodState != null) {
        mEditor.mInputMethodState.mExtractedTextRequest = req;
    }
    // This would stop a possible selection mode, but no such mode is started in case
    // extracted mode will start. Some text is selected though, and will trigger an action mode
    // in the extracted view.
    mEditor.hideCursorAndSpanControllers();
    stopTextActionMode();
}
Body of Second Method:
{
    if (mEditor.mInputMethodState != null) {
        mEditor.mInputMethodState.mExtractedTextRequest = req;
    }
    // This would stop a possible selection mode, but no such mode is started in case
    // extracted mode will start. Some text is selected though, and will trigger an action mode
    // in the extracted view.
    mEditor.hideCursorAndSpanControllers();
    stopTextActionMode();
    if (mEditor.mSelectionModifierCursorController != null) {
        mEditor.mSelectionModifierCursorController.resetTouchOffsets();
    }
}
------------------------
Find a silently evolved API code:android.widget.ListPopupWindow.clearListSelection:COMMENT
Method Modifier: public      
Comment:/**
 * Clear any current list selection.
 * Only valid when {@link #isShowing()} == {@code true}.
 */

Body of Frist Method:
{
    final DropDownListView list = mDropDownList;
    if (list != null) {
        // WARNING: Please read the comment where mListSelectionHidden is declared
        list.mListSelectionHidden = true;
        list.hideSelector();
        list.requestLayout();
    }
}
Body of Second Method:
{
    final DropDownListView list = mDropDownList;
    if (list != null) {
        // WARNING: Please read the comment where mListSelectionHidden is declared
        list.setListSelectionHidden(true);
        list.hideSelector();
        list.requestLayout();
    }
}
------------------------
Find a silently evolved API code:android.telephony.CellIdentityLte.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Implement the Parcelable interface
 */

Body of Frist Method:
{
    if (DBG)
        log("writeToParcel(Parcel, int): " + toString());
    dest.writeInt(mMcc);
    dest.writeInt(mMnc);
    dest.writeInt(mCi);
    dest.writeInt(mPci);
    dest.writeInt(mTac);
}
Body of Second Method:
{
    if (DBG)
        log("writeToParcel(Parcel, int): " + toString());
    dest.writeInt(mMcc);
    dest.writeInt(mMnc);
    dest.writeInt(mCi);
    dest.writeInt(mPci);
    dest.writeInt(mTac);
    dest.writeInt(mEarfcn);
}
------------------------
Find a silently evolved API code:android.preference.Preference_Delegate.inflatePreference:COMMENT
Method Modifier: public      static      
Comment:/**
 * Inflates the parser and returns the ListView containing the Preferences.
 */

Body of Frist Method:
{
    PreferenceManager pm = new PreferenceManager(context);
    PreferenceScreen ps = pm.getPreferenceScreen();
    PreferenceInflater inflater = new BridgePreferenceInflater(context, pm);
    ps = (PreferenceScreen) inflater.inflate(parser, ps, true);
    ListView preferenceView = createContainerView(context, root);
    ps.bind(preferenceView);
    return preferenceView;
}
Body of Second Method:
{
    PreferenceManager pm = new PreferenceManager(context);
    PreferenceInflater inflater = new BridgePreferenceInflater(context, pm);
    PreferenceScreen ps = (PreferenceScreen) inflater.inflate(parser, null, true);
    pm.setPreferences(ps);
    ListView preferenceView = createContainerView(context, root);
    ps.bind(preferenceView);
    return preferenceView;
}
------------------------
Find a silently evolved API code:android.os.StrictMode.readAndHandleBinderCallViolations:COMMENT
Method Modifier: default     static      
Comment:/* package */

Body of Frist Method:
{
    // Our own stack trace to append
    StringWriter sw = new StringWriter();
    PrintWriter pw = new FastPrintWriter(sw, false, 256);
    new LogStackTrace().printStackTrace(pw);
    pw.flush();
    String ourStack = sw.toString();
    int policyMask = getThreadPolicyMask();
    boolean currentlyGathering = (policyMask & PENALTY_GATHER) != 0;
    int numViolations = p.readInt();
    for (int i = 0; i < numViolations; ++i) {
        if (LOG_V)
            Log.d(TAG, "strict mode violation stacks read from binder call.  i=" + i);
        ViolationInfo info = new ViolationInfo(p, !currentlyGathering);
        if (info.crashInfo.stackTrace != null && info.crashInfo.stackTrace.length() > 30000) {
            String front = info.crashInfo.stackTrace.substring(256);
            // First, drain the remaining violations from the parcel.
            while (i < numViolations) {
                info = new ViolationInfo(p, !currentlyGathering);
                i++;
            }
            // Next clear out all gathered violations.
            clearGatheredViolations();
            // Now report the problem.
            Slog.wtfStack(TAG, "Stack is too large: numViolations=" + numViolations + " policy=#" + Integer.toHexString(policyMask) + " front=" + front);
            return;
        }
        info.crashInfo.stackTrace += "# via Binder call with stack:\n" + ourStack;
        BlockGuard.Policy policy = BlockGuard.getThreadPolicy();
        if (policy instanceof AndroidBlockGuardPolicy) {
            ((AndroidBlockGuardPolicy) policy).handleViolationWithTimingAttempt(info);
        }
    }
}
Body of Second Method:
{
    // Our own stack trace to append
    StringWriter sw = new StringWriter();
    PrintWriter pw = new FastPrintWriter(sw, false, 256);
    new LogStackTrace().printStackTrace(pw);
    pw.flush();
    String ourStack = sw.toString();
    int policyMask = getThreadPolicyMask();
    boolean currentlyGathering = (policyMask & PENALTY_GATHER) != 0;
    int numViolations = p.readInt();
    for (int i = 0; i < numViolations; ++i) {
        if (LOG_V)
            Log.d(TAG, "strict mode violation stacks read from binder call.  i=" + i);
        ViolationInfo info = new ViolationInfo(p, !currentlyGathering);
        if (info.crashInfo.stackTrace != null && info.crashInfo.stackTrace.length() > 30000) {
            String front = info.crashInfo.stackTrace.substring(0, 256);
            // 30000 characters is way too large for this to be any sane kind of
            // strict mode collection of stacks.  We've had a problem where we leave
            // strict mode violations associated with the thread, and it keeps tacking
            // more and more stacks on to the violations.  Looks like we're in this casse,
            // so we'll report it and bail on all of the current strict mode violations
            // we currently are maintaining for this thread.
            // First, drain the remaining violations from the parcel.
            // Skip the current entry.
            i++;
            for (; i < numViolations; i++) {
                info = new ViolationInfo(p, !currentlyGathering);
            }
            // Next clear out all gathered violations.
            clearGatheredViolations();
            // Now report the problem.
            Slog.wtfStack(TAG, "Stack is too large: numViolations=" + numViolations + " policy=#" + Integer.toHexString(policyMask) + " front=" + front);
            return;
        }
        info.crashInfo.stackTrace += "# via Binder call with stack:\n" + ourStack;
        BlockGuard.Policy policy = BlockGuard.getThreadPolicy();
        if (policy instanceof AndroidBlockGuardPolicy) {
            ((AndroidBlockGuardPolicy) policy).handleViolationWithTimingAttempt(info);
        }
    }
}
------------------------
Find a silently evolved API code:android.view.inputmethod.CursorAnchorInfo.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Used to package this object into a {@link Parcel}.
 *
 * @param dest The {@link Parcel} to be written.
 * @param flags The flags used for parceling.
 */

Body of Frist Method:
{
    dest.writeInt(mSelectionStart);
    dest.writeInt(mSelectionEnd);
    dest.writeInt(mComposingTextStart);
    TextUtils.writeToParcel(mComposingText, dest, flags);
    dest.writeInt(mInsertionMarkerFlags);
    dest.writeFloat(mInsertionMarkerHorizontal);
    dest.writeFloat(mInsertionMarkerTop);
    dest.writeFloat(mInsertionMarkerBaseline);
    dest.writeFloat(mInsertionMarkerBottom);
    dest.writeParcelable(mCharacterBoundsArray, flags);
    final float[] matrixArray = new float[9];
    mMatrix.getValues(matrixArray);
    dest.writeFloatArray(matrixArray);
}
Body of Second Method:
{
    dest.writeInt(mHashCode);
    dest.writeInt(mSelectionStart);
    dest.writeInt(mSelectionEnd);
    dest.writeInt(mComposingTextStart);
    TextUtils.writeToParcel(mComposingText, dest, flags);
    dest.writeInt(mInsertionMarkerFlags);
    dest.writeFloat(mInsertionMarkerHorizontal);
    dest.writeFloat(mInsertionMarkerTop);
    dest.writeFloat(mInsertionMarkerBaseline);
    dest.writeFloat(mInsertionMarkerBottom);
    dest.writeParcelable(mCharacterBoundsArray, flags);
    dest.writeFloatArray(mMatrixValues);
}
------------------------
Find a silently evolved API code:android.net.wifi.p2p.WifiP2pManager.setMiracastMode:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Internal use only @hide
 */

Body of Frist Method:
{
    try {
        mService.setMiracastMode(mode);
    } catch (RemoteException e) {
    // ignore
    }
}
Body of Second Method:
{
    try {
        mService.setMiracastMode(mode);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.accounts.AccountManager.getAccountsAsUser:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 * Lists all accounts of any type registered on the device for a given
 * user id. Equivalent to getAccountsByType(null).
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>Clients of this method that have not been granted the
 * {@link android.Manifest.permission#GET_ACCOUNTS} permission,
 * will only see those accounts managed by AbstractAccountAuthenticators whose
 * signature matches the client.
 *
 * @return An array of {@link Account}, one for each account.  Empty
 * (never null) if no accounts have been added.
 */

Body of Frist Method:
{
    try {
        return mService.getAccountsAsUser(null, userId, mContext.getOpPackageName());
    } catch (RemoteException e) {
        // won't ever happen
        throw new RuntimeException(e);
    }
}
Body of Second Method:
{
    try {
        return mService.getAccountsAsUser(null, userId, mContext.getOpPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.widget.Editor.selectCurrentWordAndStartDrag:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * If the TextView allows text selection, selects the current word when no existing selection
 * was available and starts a drag.
 *
 * @return true if the drag was started.
 */

Body of Frist Method:
{
    if (mInsertionActionModeRunnable != null) {
        mTextView.removeCallbacks(mInsertionActionModeRunnable);
    }
    if (extractedTextModeWillBeStarted()) {
        return false;
    }
    if (mTextActionMode != null) {
        mTextActionMode.finish();
    }
    if (!checkFieldAndSelectCurrentWord()) {
        return false;
    }
    // Avoid dismissing the selection if it exists.
    mPreserveDetachedSelection = true;
    stopTextActionMode();
    mPreserveDetachedSelection = false;
    getSelectionController().enterDrag();
    return true;
}
Body of Second Method:
{
    if (mInsertionActionModeRunnable != null) {
        mTextView.removeCallbacks(mInsertionActionModeRunnable);
    }
    if (extractedTextModeWillBeStarted()) {
        return false;
    }
    if (!checkField()) {
        return false;
    }
    if (!mTextView.hasSelection() && !selectCurrentWord()) {
        // No selection and cannot select a word.
        return false;
    }
    stopTextActionModeWithPreservingSelection();
    getSelectionController().enterDrag(SelectionModifierCursorController.DRAG_ACCELERATOR_MODE_WORD);
    return true;
}
------------------------
Find a silently evolved API code:android.text.Layout.getLineExtent:COMMENT
Method Modifier: private     
Comment:/**
 * Returns the signed horizontal extent of the specified line, excluding
 * leading margin.  If full is false, excludes trailing whitespace.
 * @param line the index of the line
 * @param tabStops the tab stops, can be null if we know they're not used.
 * @param full whether to include trailing whitespace
 * @return the extent of the text on this line
 */

Body of Frist Method:
{
    int start = getLineStart(line);
    int end = full ? getLineEnd(line) : getLineVisibleEnd(line);
    boolean hasTabsOrEmoji = getLineContainsTab(line);
    Directions directions = getLineDirections(line);
    int dir = getParagraphDirection(line);
    TextLine tl = TextLine.obtain();
    tl.set(mPaint, mText, start, end, dir, directions, hasTabsOrEmoji, tabStops);
    float width = tl.metrics(null);
    TextLine.recycle(tl);
    return width;
}
Body of Second Method:
{
    int start = getLineStart(line);
    int end = full ? getLineEnd(line) : getLineVisibleEnd(line);
    boolean hasTabs = getLineContainsTab(line);
    Directions directions = getLineDirections(line);
    int dir = getParagraphDirection(line);
    TextLine tl = TextLine.obtain();
    tl.set(mPaint, mText, start, end, dir, directions, hasTabs, tabStops);
    float width = tl.metrics(null);
    TextLine.recycle(tl);
    return width;
}
------------------------
Find a silently evolved API code:android.widget.TimePicker.getCurrentMinute:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * @return the current minute
 * @deprecated Use {@link #getMinute()}
 */

Body of Frist Method:
{
    return mDelegate.getCurrentMinute();
}
Body of Second Method:
{
    return mDelegate.getMinute();
}
------------------------
Find a silently evolved API code:android.text.method.Touch.onTouchEvent:COMMENT
Method Modifier: public      static      
Comment:/**
 * Handles touch events for dragging.  You may want to do other actions
 * like moving the cursor on touch as well.
 */

Body of Frist Method:
{
    DragState[] ds;
    switch(event.getActionMasked()) {
        case MotionEvent.ACTION_DOWN:
            ds = buffer.getSpans(0, buffer.length(), DragState.class);
            for (int i = 0; i < ds.length; i++) {
                buffer.removeSpan(ds[i]);
            }
            buffer.setSpan(new DragState(event.getX(), event.getY(), widget.getScrollX(), widget.getScrollY()), 0, 0, Spannable.SPAN_MARK_MARK);
            return true;
        case MotionEvent.ACTION_UP:
            ds = buffer.getSpans(0, buffer.length(), DragState.class);
            for (int i = 0; i < ds.length; i++) {
                buffer.removeSpan(ds[i]);
            }
            if (ds.length > 0 && ds[0].mUsed) {
                return true;
            } else {
                return false;
            }
        case MotionEvent.ACTION_MOVE:
            ds = buffer.getSpans(0, buffer.length(), DragState.class);
            if (ds.length > 0) {
                ds[0].mIsSelectionStarted = false;
                if (ds[0].mFarEnough == false) {
                    int slop = ViewConfiguration.get(widget.getContext()).getScaledTouchSlop();
                    if (Math.abs(event.getX() - ds[0].mX) >= slop || Math.abs(event.getY() - ds[0].mY) >= slop) {
                        ds[0].mFarEnough = true;
                        if (event.isButtonPressed(MotionEvent.BUTTON_PRIMARY)) {
                            ds[0].mIsActivelySelecting = true;
                            ds[0].mIsSelectionStarted = true;
                        }
                    }
                }
                if (ds[0].mFarEnough) {
                    ds[0].mUsed = true;
                    boolean cap = (event.getMetaState() & KeyEvent.META_SHIFT_ON) != 0 || MetaKeyKeyListener.getMetaState(buffer, MetaKeyKeyListener.META_SHIFT_ON) == 1 || MetaKeyKeyListener.getMetaState(buffer, MetaKeyKeyListener.META_SELECTING) != 0;
                    if (!event.isButtonPressed(MotionEvent.BUTTON_PRIMARY)) {
                        ds[0].mIsActivelySelecting = false;
                    }
                    float dx;
                    float dy;
                    if (cap && event.isButtonPressed(MotionEvent.BUTTON_PRIMARY)) {
                        // if we're selecting, we want the scroll to go in
                        // the direction of the drag
                        dx = event.getX() - ds[0].mX;
                        dy = event.getY() - ds[0].mY;
                    } else {
                        dx = ds[0].mX - event.getX();
                        dy = ds[0].mY - event.getY();
                    }
                    ds[0].mX = event.getX();
                    ds[0].mY = event.getY();
                    int nx = widget.getScrollX() + (int) dx;
                    int ny = widget.getScrollY() + (int) dy;
                    int padding = widget.getTotalPaddingTop() + widget.getTotalPaddingBottom();
                    Layout layout = widget.getLayout();
                    ny = Math.min(ny, layout.getHeight() - (widget.getHeight() - padding));
                    ny = Math.max(ny, 0);
                    int oldX = widget.getScrollX();
                    int oldY = widget.getScrollY();
                    if (!event.isButtonPressed(MotionEvent.BUTTON_PRIMARY)) {
                        scrollTo(widget, layout, nx, ny);
                    }
                    // If we actually scrolled, then cancel the up action.
                    if (oldX != widget.getScrollX() || oldY != widget.getScrollY()) {
                        widget.cancelLongPress();
                    }
                    return true;
                }
            }
    }
    return false;
}
Body of Second Method:
{
    DragState[] ds;
    switch(event.getActionMasked()) {
        case MotionEvent.ACTION_DOWN:
            ds = buffer.getSpans(0, buffer.length(), DragState.class);
            for (int i = 0; i < ds.length; i++) {
                buffer.removeSpan(ds[i]);
            }
            buffer.setSpan(new DragState(event.getX(), event.getY(), widget.getScrollX(), widget.getScrollY()), 0, 0, Spannable.SPAN_MARK_MARK);
            return true;
        case MotionEvent.ACTION_UP:
            ds = buffer.getSpans(0, buffer.length(), DragState.class);
            for (int i = 0; i < ds.length; i++) {
                buffer.removeSpan(ds[i]);
            }
            if (ds.length > 0 && ds[0].mUsed) {
                return true;
            } else {
                return false;
            }
        case MotionEvent.ACTION_MOVE:
            ds = buffer.getSpans(0, buffer.length(), DragState.class);
            if (ds.length > 0) {
                if (ds[0].mFarEnough == false) {
                    int slop = ViewConfiguration.get(widget.getContext()).getScaledTouchSlop();
                    if (Math.abs(event.getX() - ds[0].mX) >= slop || Math.abs(event.getY() - ds[0].mY) >= slop) {
                        ds[0].mFarEnough = true;
                    }
                }
                if (ds[0].mFarEnough) {
                    ds[0].mUsed = true;
                    boolean cap = (event.getMetaState() & KeyEvent.META_SHIFT_ON) != 0 || MetaKeyKeyListener.getMetaState(buffer, MetaKeyKeyListener.META_SHIFT_ON) == 1 || MetaKeyKeyListener.getMetaState(buffer, MetaKeyKeyListener.META_SELECTING) != 0;
                    float dx;
                    float dy;
                    if (cap) {
                        // if we're selecting, we want the scroll to go in
                        // the direction of the drag
                        dx = event.getX() - ds[0].mX;
                        dy = event.getY() - ds[0].mY;
                    } else {
                        dx = ds[0].mX - event.getX();
                        dy = ds[0].mY - event.getY();
                    }
                    ds[0].mX = event.getX();
                    ds[0].mY = event.getY();
                    int nx = widget.getScrollX() + (int) dx;
                    int ny = widget.getScrollY() + (int) dy;
                    int padding = widget.getTotalPaddingTop() + widget.getTotalPaddingBottom();
                    Layout layout = widget.getLayout();
                    ny = Math.min(ny, layout.getHeight() - (widget.getHeight() - padding));
                    ny = Math.max(ny, 0);
                    int oldX = widget.getScrollX();
                    int oldY = widget.getScrollY();
                    scrollTo(widget, layout, nx, ny);
                    // If we actually scrolled, then cancel the up action.
                    if (oldX != widget.getScrollX() || oldY != widget.getScrollY()) {
                        widget.cancelLongPress();
                    }
                    return true;
                }
            }
    }
    return false;
}
------------------------
Find a silently evolved API code:android.app.ActivityManager.setPackageAskScreenCompat:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    try {
        ActivityManagerNative.getDefault().setPackageAskScreenCompat(packageName, ask);
    } catch (RemoteException e) {
    // System dead, we will be dead too soon!
    }
}
Body of Second Method:
{
    try {
        ActivityManagerNative.getDefault().setPackageAskScreenCompat(packageName, ask);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.media.Metadata.scanAllRecords:COMMENT
Method Modifier: private     hidden      deprecated  
Comment:/**
 * Go over all the records, collecting metadata keys and records'
 * type field offset in the Parcel. These are stored in
 * mKeyToPosMap for latter retrieval.
 * Format of a metadata record:
 * <pre>
 * 1                   2                   3
 * 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                     record size                               |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                     metadata key                              |  // TITLE
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                     metadata type                             |  // STRING_VAL
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * |                                                               |
 * |                .... metadata payload ....                     |
 * |                                                               |
 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * </pre>
 * @param parcel With the serialized records.
 * @param bytesLeft How many bytes in the parcel should be processed.
 * @return false if an error occurred during parsing.
 */

Body of Frist Method:
{
    int recCount = 0;
    boolean error = false;
    mKeyToPosMap.clear();
    while (bytesLeft > kRecordHeaderSize) {
        final int start = parcel.dataPosition();
        // Check the size.
        final int size = parcel.readInt();
        if (size <= kRecordHeaderSize) {
            // at least 1 byte should be present.
            Log.e(TAG, "Record is too short");
            error = true;
            break;
        }
        // Check the metadata key.
        final int metadataId = parcel.readInt();
        if (!checkMetadataId(metadataId)) {
            error = true;
            break;
        }
        // payload.
        if (mKeyToPosMap.containsKey(metadataId)) {
            Log.e(TAG, "Duplicate metadata ID found");
            error = true;
            break;
        }
        mKeyToPosMap.put(metadataId, parcel.dataPosition());
        // Check the metadata type.
        final int metadataType = parcel.readInt();
        if (metadataType <= 0 || metadataType > LAST_TYPE) {
            Log.e(TAG, "Invalid metadata type " + metadataType);
            error = true;
            break;
        }
        // Skip to the next one.
        parcel.setDataPosition(start + size);
        bytesLeft -= size;
        ++recCount;
    }
    if (0 != bytesLeft || error) {
        Log.e(TAG, "Ran out of data or error on record " + recCount);
        mKeyToPosMap.clear();
        return false;
    } else {
        return true;
    }
}
Body of Second Method:
{
    int recCount = 0;
    boolean error = false;
    mKeyToPosMap.clear();
    while (bytesLeft > kRecordHeaderSize) {
        final int start = parcel.dataPosition();
        // Check the size.
        final int size = parcel.readInt();
        if (size <= kRecordHeaderSize) {
            // at least 1 byte should be present.
            Log.e(TAG, "Record is too short");
            error = true;
            break;
        }
        // Check the metadata key.
        final int metadataId = parcel.readInt();
        if (!checkMetadataId(metadataId)) {
            error = true;
            break;
        }
        // payload.
        if (mKeyToPosMap.containsKey(metadataId)) {
            Log.e(TAG, "Duplicate metadata ID found");
            error = true;
            break;
        }
        mKeyToPosMap.put(metadataId, parcel.dataPosition());
        // Check the metadata type.
        final int metadataType = parcel.readInt();
        if (metadataType <= 0 || metadataType > LAST_TYPE) {
            Log.e(TAG, "Invalid metadata type " + metadataType);
            error = true;
            break;
        }
        // Skip to the next one.
        try {
            parcel.setDataPosition(MathUtils.addOrThrow(start, size));
        } catch (IllegalArgumentException e) {
            Log.e(TAG, "Invalid size: " + e.getMessage());
            error = true;
            break;
        }
        bytesLeft -= size;
        ++recCount;
    }
    if (0 != bytesLeft || error) {
        Log.e(TAG, "Ran out of data or error on record " + recCount);
        mKeyToPosMap.clear();
        return false;
    } else {
        return true;
    }
}
------------------------
Find a silently evolved API code:android.telephony.SubscriptionManager.getDefaultVoicePhoneId:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return getPhoneId(getDefaultVoiceSubId());
}
Body of Second Method:
{
    return getPhoneId(getDefaultVoiceSubscriptionId());
}
------------------------
Find a silently evolved API code:android.widget.ProgressBar.setIndeterminate:COMMENT
Method Modifier: public      
Comment:/**
 * <p>Change the indeterminate mode for this progress bar. In indeterminate
 * mode, the progress is ignored and the progress bar shows an infinite
 * animation instead.</p>
 *
 * If this progress bar's style only supports indeterminate mode (such as the circular
 * progress bars), then this will be ignored.
 *
 * @param indeterminate true to enable the indeterminate mode
 */

Body of Frist Method:
{
    if ((!mOnlyIndeterminate || !mIndeterminate) && indeterminate != mIndeterminate) {
        mIndeterminate = indeterminate;
        if (indeterminate) {
            // swap between indeterminate and regular backgrounds
            mCurrentDrawable = mIndeterminateDrawable;
            startAnimation();
        } else {
            mCurrentDrawable = mProgressDrawable;
            stopAnimation();
        }
    }
}
Body of Second Method:
{
    if ((!mOnlyIndeterminate || !mIndeterminate) && indeterminate != mIndeterminate) {
        mIndeterminate = indeterminate;
        if (indeterminate) {
            // swap between indeterminate and regular backgrounds
            swapCurrentDrawable(mIndeterminateDrawable);
            startAnimation();
        } else {
            swapCurrentDrawable(mProgressDrawable);
            stopAnimation();
        }
    }
}
------------------------
Find a silently evolved API code:android.app.ActivityManager.isUserRunning:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Return whether the given user is actively running.  This means that
 * the user is in the "started" state, not "stopped" -- it is currently
 * allowed to run code through scheduled alarms, receiving broadcasts,
 * etc.  A started user may be either the current foreground user or a
 * background user; the result here does not distinguish between the two.
 * @param userid the user's id. Zero indicates the default user.
 * @hide
 */

Body of Frist Method:
{
    try {
        return ActivityManagerNative.getDefault().isUserRunning(userid, false);
    } catch (RemoteException e) {
        return false;
    }
}
Body of Second Method:
{
    try {
        return ActivityManagerNative.getDefault().isUserRunning(userId, 0);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.app.ActivityManager.addAppTask:COMMENT
Method Modifier: public      
Comment:/**
 * Add a new {@link AppTask} for the calling application.  This will create a new
 * recents entry that is added to the <b>end</b> of all existing recents.
 *
 * @param activity The activity that is adding the entry.   This is used to help determine
 * the context that the new recents entry will be in.
 * @param intent The Intent that describes the recents entry.  This is the same Intent that
 * you would have used to launch the activity for it.  In generally you will want to set
 * both {@link Intent#FLAG_ACTIVITY_NEW_DOCUMENT} and
 * {@link Intent#FLAG_ACTIVITY_RETAIN_IN_RECENTS}; the latter is required since this recents
 * entry will exist without an activity, so it doesn't make sense to not retain it when
 * its activity disappears.  The given Intent here also must have an explicit ComponentName
 * set on it.
 * @param description Optional additional description information.
 * @param thumbnail Thumbnail to use for the recents entry.  Should be the size given by
 * {@link #getAppTaskThumbnailSize()}.  If the bitmap is not that exact size, it will be
 * recreated in your process, probably in a way you don't like, before the recents entry
 * is added.
 *
 * @return Returns the task id of the newly added app task, or -1 if the add failed.  The
 * most likely cause of failure is that there is no more room for more tasks for your app.
 */

Body of Frist Method:
{
    Point size;
    synchronized (this) {
        ensureAppTaskThumbnailSizeLocked();
        size = mAppTaskThumbnailSize;
    }
    final int tw = thumbnail.getWidth();
    final int th = thumbnail.getHeight();
    if (tw != size.x || th != size.y) {
        Bitmap bm = Bitmap.createBitmap(size.x, size.y, thumbnail.getConfig());
        // Use ScaleType.CENTER_CROP, except we leave the top edge at the top.
        float scale;
        float dx = 0, dy = 0;
        if (tw * size.x > size.y * th) {
            scale = (float) size.x / (float) th;
            dx = (size.y - tw * scale) * 0.5f;
        } else {
            scale = (float) size.y / (float) tw;
            dy = (size.x - th * scale) * 0.5f;
        }
        Matrix matrix = new Matrix();
        matrix.setScale(scale, scale);
        matrix.postTranslate((int) (dx + 0.5f), 0);
        Canvas canvas = new Canvas(bm);
        canvas.drawBitmap(thumbnail, matrix, null);
        canvas.setBitmap(null);
        thumbnail = bm;
    }
    if (description == null) {
        description = new TaskDescription();
    }
    try {
        return ActivityManagerNative.getDefault().addAppTask(activity.getActivityToken(), intent, description, thumbnail);
    } catch (RemoteException e) {
        throw new IllegalStateException("System dead?", e);
    }
}
Body of Second Method:
{
    Point size;
    synchronized (this) {
        ensureAppTaskThumbnailSizeLocked();
        size = mAppTaskThumbnailSize;
    }
    final int tw = thumbnail.getWidth();
    final int th = thumbnail.getHeight();
    if (tw != size.x || th != size.y) {
        Bitmap bm = Bitmap.createBitmap(size.x, size.y, thumbnail.getConfig());
        // Use ScaleType.CENTER_CROP, except we leave the top edge at the top.
        float scale;
        float dx = 0, dy = 0;
        if (tw * size.x > size.y * th) {
            scale = (float) size.x / (float) th;
            dx = (size.y - tw * scale) * 0.5f;
        } else {
            scale = (float) size.y / (float) tw;
            dy = (size.x - th * scale) * 0.5f;
        }
        Matrix matrix = new Matrix();
        matrix.setScale(scale, scale);
        matrix.postTranslate((int) (dx + 0.5f), 0);
        Canvas canvas = new Canvas(bm);
        canvas.drawBitmap(thumbnail, matrix, null);
        canvas.setBitmap(null);
        thumbnail = bm;
    }
    if (description == null) {
        description = new TaskDescription();
    }
    try {
        return ActivityManagerNative.getDefault().addAppTask(activity.getActivityToken(), intent, description, thumbnail);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.app.usage.NetworkStats.startHistoryEnumeration:COMMENT
Method Modifier: default     
Comment:/**
 * Collects history results for uid and resets history enumeration index.
 */

Body of Frist Method:
{
    mHistory = null;
    try {
        mHistory = mSession.getHistoryIntervalForUid(mTemplate, uid, android.net.NetworkStats.SET_ALL, android.net.NetworkStats.TAG_NONE, NetworkStatsHistory.FIELD_ALL, mStartTimeStamp, mEndTimeStamp);
        setSingleUid(uid);
    } catch (RemoteException e) {
        Log.w(TAG, e);
    // Leaving mHistory null
    }
    mEnumerationIndex = 0;
}
Body of Second Method:
{
    startHistoryEnumeration(uid, android.net.NetworkStats.TAG_NONE);
}
------------------------
Find a silently evolved API code:android.content.ClipboardManager.setPrimaryClip:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the current primary clip on the clipboard.  This is the clip that
 * is involved in normal cut and paste operations.
 *
 * @param clip The clipped data item to set.
 */

Body of Frist Method:
{
    try {
        if (clip != null) {
            clip.prepareToLeaveProcess();
        }
        getService().setPrimaryClip(clip, mContext.getOpPackageName());
    } catch (RemoteException e) {
    }
}
Body of Second Method:
{
    try {
        if (clip != null) {
            clip.prepareToLeaveProcess(true);
        }
        getService().setPrimaryClip(clip, mContext.getOpPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.app.DownloadManager.query:COMMENT
Method Modifier: public      
Comment:/**
 * Query the download manager about downloads that have been requested.
 * @param query parameters specifying filters for this query
 * @return a Cursor over the result set of downloads, with columns consisting of all the
 * COLUMN_* constants.
 */

Body of Frist Method:
{
    Cursor underlyingCursor = query.runQuery(mResolver, UNDERLYING_COLUMNS, mBaseUri);
    if (underlyingCursor == null) {
        return null;
    }
    return new CursorTranslator(underlyingCursor, mBaseUri);
}
Body of Second Method:
{
    Cursor underlyingCursor = query.runQuery(mResolver, UNDERLYING_COLUMNS, mBaseUri);
    if (underlyingCursor == null) {
        return null;
    }
    return new CursorTranslator(underlyingCursor, mBaseUri, mAccessFilename);
}
------------------------
Find a silently evolved API code:android.graphics.Bitmap.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Write the bitmap and its pixels to the parcel. The bitmap can be
 * rebuilt from the parcel by calling CREATOR.createFromParcel().
 * @param p    Parcel object to write the bitmap data into
 */

Body of Frist Method:
{
    checkRecycled("Can't parcel a recycled bitmap");
    if (!nativeWriteToParcel(mFinalizer.mNativeBitmap, mIsMutable, mDensity, p)) {
        throw new RuntimeException("native writeToParcel failed");
    }
}
Body of Second Method:
{
    checkRecycled("Can't parcel a recycled bitmap");
    if (!nativeWriteToParcel(mNativePtr, mIsMutable, mDensity, p)) {
        throw new RuntimeException("native writeToParcel failed");
    }
}
------------------------
Find a silently evolved API code:android.content.ClipboardManager.hasPrimaryClip:COMMENT
Method Modifier: public      
Comment:/**
 * Returns true if there is currently a primary clip on the clipboard.
 */

Body of Frist Method:
{
    try {
        return getService().hasPrimaryClip(mContext.getOpPackageName());
    } catch (RemoteException e) {
        return false;
    }
}
Body of Second Method:
{
    try {
        return getService().hasPrimaryClip(mContext.getOpPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.app.ActivityManager.AppTask.finishAndRemoveTask:COMMENT
Method Modifier: public      
Comment:/**
 * Finishes all activities in this task and removes it from the recent tasks list.
 */

Body of Frist Method:
{
    try {
        mAppTaskImpl.finishAndRemoveTask();
    } catch (RemoteException e) {
        Slog.e(TAG, "Invalid AppTask", e);
    }
}
Body of Second Method:
{
    try {
        mAppTaskImpl.finishAndRemoveTask();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.media.AudioManager.setVolumePolicy:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Only useful for volume controllers.
 * @hide
 */

Body of Frist Method:
{
    try {
        getService().setVolumePolicy(policy);
    } catch (RemoteException e) {
        Log.w(TAG, "Error calling setVolumePolicy", e);
    }
}
Body of Second Method:
{
    try {
        getService().setVolumePolicy(policy);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.renderscript.Sampler.WRAP_LINEAR:COMMENT
Method Modifier: public      static      
Comment:/**
 * Retrieve a sampler with min and mag set to linear and wrap modes set to
 * wrap.
 *
 * @param rs Context to which the sampler will belong.
 *
 * @return Sampler
 */

Body of Frist Method:
{
    if (rs.mSampler_WRAP_LINEAR == null) {
        Builder b = new Builder(rs);
        b.setMinification(Value.LINEAR);
        b.setMagnification(Value.LINEAR);
        b.setWrapS(Value.WRAP);
        b.setWrapT(Value.WRAP);
        rs.mSampler_WRAP_LINEAR = b.create();
    }
    return rs.mSampler_WRAP_LINEAR;
}
Body of Second Method:
{
    if (rs.mSampler_WRAP_LINEAR == null) {
        synchronized (rs) {
            if (rs.mSampler_WRAP_LINEAR == null) {
                Builder b = new Builder(rs);
                b.setMinification(Value.LINEAR);
                b.setMagnification(Value.LINEAR);
                b.setWrapS(Value.WRAP);
                b.setWrapT(Value.WRAP);
                rs.mSampler_WRAP_LINEAR = b.create();
            }
        }
    }
    return rs.mSampler_WRAP_LINEAR;
}
------------------------
Find a silently evolved API code:android.os.SystemClock_Delegate.currentThreadTimeMicro:COMMENT
Method Modifier: default     static      hidden      
Comment:/**
 * Returns microseconds running in the current thread.
 *
 * @return elapsed microseconds in the thread
 *
 * @hide
 */

Body of Frist Method:
{
    return System.currentTimeMillis() * 1000;
}
Body of Second Method:
{
    return System_Delegate.currentTimeMillis() * 1000;
}
------------------------
Find a silently evolved API code:android.graphics.Bitmap.getGenerationId:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the generation ID of this bitmap. The generation ID changes
 * whenever the bitmap is modified. This can be used as an efficient way to
 * check if a bitmap has changed.
 *
 * @return The current generation ID for this bitmap.
 */

Body of Frist Method:
{
    if (mRecycled) {
        Log.w(TAG, "Called getGenerationId() on a recycle()'d bitmap! This is undefined behavior!");
    }
    return nativeGenerationId(mFinalizer.mNativeBitmap);
}
Body of Second Method:
{
    if (mRecycled) {
        Log.w(TAG, "Called getGenerationId() on a recycle()'d bitmap! This is undefined behavior!");
    }
    return nativeGenerationId(mNativePtr);
}
------------------------
Find a silently evolved API code:android.app.ActivityManager.getMemoryInfo:COMMENT
Method Modifier: public      
Comment:/**
 * Return general information about the memory state of the system.  This
 * can be used to help decide how to manage your own memory, though note
 * that polling is not recommended and
 * {@link android.content.ComponentCallbacks2#onTrimMemory(int)
 * ComponentCallbacks2.onTrimMemory(int)} is the preferred way to do this.
 * Also see {@link #getMyMemoryState} for how to retrieve the current trim
 * level of your process as needed, which gives a better hint for how to
 * manage its memory.
 */

Body of Frist Method:
{
    try {
        ActivityManagerNative.getDefault().getMemoryInfo(outInfo);
    } catch (RemoteException e) {
    }
}
Body of Second Method:
{
    try {
        ActivityManagerNative.getDefault().getMemoryInfo(outInfo);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothActivityEnergyInfo.isValid:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @return if the record is valid
 */

Body of Frist Method:
{
    return ((mControllerTxTimeMs != 0) || (mControllerRxTimeMs != 0) || (mControllerIdleTimeMs != 0));
}
Body of Second Method:
{
    return ((mControllerTxTimeMs >= 0) && (mControllerRxTimeMs >= 0) && (mControllerIdleTimeMs >= 0));
}
------------------------
Find a silently evolved API code:android.app.ActivityManager.setWatchHeapLimit:COMMENT
Method Modifier: public      
Comment:/**
 * Request that the system start watching for the calling process to exceed a pss
 * size as given here.  Once called, the system will look for any occasions where it
 * sees the associated process with a larger pss size and, when this happens, automatically
 * pull a heap dump from it and allow the user to share the data.  Note that this request
 * continues running even if the process is killed and restarted.  To remove the watch,
 * use {@link #clearWatchHeapLimit()}.
 *
 * <p>This API only work if the calling process has been marked as
 * {@link ApplicationInfo#FLAG_DEBUGGABLE} or this is running on a debuggable
 * (userdebug or eng) build.</p>
 *
 * <p>Callers can optionally implement {@link #ACTION_REPORT_HEAP_LIMIT} to directly
 * handle heap limit reports themselves.</p>
 *
 * @param pssSize The size in bytes to set the limit at.
 */

Body of Frist Method:
{
    try {
        ActivityManagerNative.getDefault().setDumpHeapDebugLimit(null, 0, pssSize, mContext.getPackageName());
    } catch (RemoteException e) {
    }
}
Body of Second Method:
{
    try {
        ActivityManagerNative.getDefault().setDumpHeapDebugLimit(null, 0, pssSize, mContext.getPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.net.NetworkScoreManager.clearScores:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Clear network scores.
 *
 * <p>Should be called when all scores need to be invalidated, i.e. because the scoring
 * algorithm has changed and old scores can no longer be compared to future scores.
 *
 * <p>Note that scores will be cleared automatically when the active scorer changes, as scores
 * from one scorer cannot be compared to those from another scorer.
 *
 * @return whether the clear was successful.
 * @throws SecurityException if the caller is not the active scorer or privileged.
 */

Body of Frist Method:
{
    try {
        return mService.clearScores();
    } catch (RemoteException e) {
        return false;
    }
}
Body of Second Method:
{
    try {
        return mService.clearScores();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.content.res.TypedArray.getDimensionPixelOffset:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve a dimensional unit attribute at <var>index</var> for use
 * as an offset in raw pixels.  This is the same as
 * {@link #getDimension}, except the returned value is converted to
 * integer pixels for you.  An offset conversion involves simply
 * truncating the base value to an integer.
 * <p>
 * This method will throw an exception if the attribute is defined but is
 * not a dimension.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute dimension value multiplied by the appropriate
 * metric and truncated to integer pixels, or defValue if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not an integer.
 *
 * @see #getDimension
 * @see #getDimensionPixelSize
 */

Body of Frist Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimensionPixelOffset(data[index + AssetManager.STYLE_DATA], mMetrics);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index * AssetManager.STYLE_NUM_ENTRIES, value);
        throw new UnsupportedOperationException("Failed to resolve attribute at index " + index + ": " + value);
    }
    throw new UnsupportedOperationException("Can't convert to dimension: type=0x" + Integer.toHexString(type));
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    final int attrIndex = index;
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimensionPixelOffset(data[index + AssetManager.STYLE_DATA], mMetrics);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index, value);
        throw new UnsupportedOperationException("Failed to resolve attribute at index " + attrIndex + ": " + value);
    }
    throw new UnsupportedOperationException("Can't convert value at index " + attrIndex + " to dimension: type=0x" + Integer.toHexString(type));
}
------------------------
Find a silently evolved API code:android.app.backup.FullBackup.BackupScheme.tokenToDirectoryPath:COMMENT
Method Modifier: default     
Comment:/**
 * Parse out the semantic domains into the correct physical location.
 */

Body of Frist Method:
{
    try {
        if (domainToken.equals(FullBackup.DATA_TREE_TOKEN)) {
            return FILES_DIR.getCanonicalPath();
        } else if (domainToken.equals(FullBackup.DATABASE_TREE_TOKEN)) {
            return DATABASE_DIR.getCanonicalPath();
        } else if (domainToken.equals(FullBackup.ROOT_TREE_TOKEN)) {
            return ROOT_DIR.getCanonicalPath();
        } else if (domainToken.equals(FullBackup.SHAREDPREFS_TREE_TOKEN)) {
            return SHAREDPREF_DIR.getCanonicalPath();
        } else if (domainToken.equals(FullBackup.CACHE_TREE_TOKEN)) {
            return CACHE_DIR.getCanonicalPath();
        } else if (domainToken.equals(FullBackup.MANAGED_EXTERNAL_TREE_TOKEN)) {
            if (EXTERNAL_DIR != null) {
                return EXTERNAL_DIR.getCanonicalPath();
            } else {
                return null;
            }
        } else if (domainToken.equals(FullBackup.NO_BACKUP_TREE_TOKEN)) {
            return NOBACKUP_DIR.getCanonicalPath();
        }
        // Not a supported location
        Log.i(TAG, "Unrecognized domain " + domainToken);
        return null;
    } catch (IOException e) {
        Log.i(TAG, "Error reading directory for domain: " + domainToken);
        return null;
    }
}
Body of Second Method:
{
    try {
        if (domainToken.equals(FullBackup.FILES_TREE_TOKEN)) {
            return FILES_DIR.getCanonicalPath();
        } else if (domainToken.equals(FullBackup.DATABASE_TREE_TOKEN)) {
            return DATABASE_DIR.getCanonicalPath();
        } else if (domainToken.equals(FullBackup.ROOT_TREE_TOKEN)) {
            return ROOT_DIR.getCanonicalPath();
        } else if (domainToken.equals(FullBackup.SHAREDPREFS_TREE_TOKEN)) {
            return SHAREDPREF_DIR.getCanonicalPath();
        } else if (domainToken.equals(FullBackup.CACHE_TREE_TOKEN)) {
            return CACHE_DIR.getCanonicalPath();
        } else if (domainToken.equals(FullBackup.NO_BACKUP_TREE_TOKEN)) {
            return NOBACKUP_DIR.getCanonicalPath();
        } else if (domainToken.equals(FullBackup.DEVICE_FILES_TREE_TOKEN)) {
            return DEVICE_FILES_DIR.getCanonicalPath();
        } else if (domainToken.equals(FullBackup.DEVICE_DATABASE_TREE_TOKEN)) {
            return DEVICE_DATABASE_DIR.getCanonicalPath();
        } else if (domainToken.equals(FullBackup.DEVICE_ROOT_TREE_TOKEN)) {
            return DEVICE_ROOT_DIR.getCanonicalPath();
        } else if (domainToken.equals(FullBackup.DEVICE_SHAREDPREFS_TREE_TOKEN)) {
            return DEVICE_SHAREDPREF_DIR.getCanonicalPath();
        } else if (domainToken.equals(FullBackup.DEVICE_CACHE_TREE_TOKEN)) {
            return DEVICE_CACHE_DIR.getCanonicalPath();
        } else if (domainToken.equals(FullBackup.DEVICE_NO_BACKUP_TREE_TOKEN)) {
            return DEVICE_NOBACKUP_DIR.getCanonicalPath();
        } else if (domainToken.equals(FullBackup.MANAGED_EXTERNAL_TREE_TOKEN)) {
            if (EXTERNAL_DIR != null) {
                return EXTERNAL_DIR.getCanonicalPath();
            } else {
                return null;
            }
        }
        // Not a supported location
        Log.i(TAG, "Unrecognized domain " + domainToken);
        return null;
    } catch (IOException e) {
        Log.i(TAG, "Error reading directory for domain: " + domainToken);
        return null;
    }
}
------------------------
Find a silently evolved API code:android.telephony.CellSignalStrengthCdma.getEvdoLevel:COMMENT
Method Modifier: public      
Comment:/**
 * Get Evdo as level 0..4
 */

Body of Frist Method:
{
    int evdoDbm = getEvdoDbm();
    int evdoSnr = getEvdoSnr();
    int levelEvdoDbm;
    int levelEvdoSnr;
    if (evdoDbm >= -65)
        levelEvdoDbm = SIGNAL_STRENGTH_GREAT;
    else if (evdoDbm >= -75)
        levelEvdoDbm = SIGNAL_STRENGTH_GOOD;
    else if (evdoDbm >= -90)
        levelEvdoDbm = SIGNAL_STRENGTH_MODERATE;
    else if (evdoDbm >= -105)
        levelEvdoDbm = SIGNAL_STRENGTH_POOR;
    else
        levelEvdoDbm = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    if (evdoSnr >= 7)
        levelEvdoSnr = SIGNAL_STRENGTH_GREAT;
    else if (evdoSnr >= 5)
        levelEvdoSnr = SIGNAL_STRENGTH_GOOD;
    else if (evdoSnr >= 3)
        levelEvdoSnr = SIGNAL_STRENGTH_MODERATE;
    else if (evdoSnr >= 1)
        levelEvdoSnr = SIGNAL_STRENGTH_POOR;
    else
        levelEvdoSnr = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    int level = (levelEvdoDbm < levelEvdoSnr) ? levelEvdoDbm : levelEvdoSnr;
    if (DBG)
        log("getEvdoLevel=" + level);
    return level;
}
Body of Second Method:
{
    int evdoDbm = getEvdoDbm();
    int evdoSnr = getEvdoSnr();
    int levelEvdoDbm;
    int levelEvdoSnr;
    if (evdoDbm == Integer.MAX_VALUE)
        levelEvdoDbm = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    else if (evdoDbm >= -65)
        levelEvdoDbm = SIGNAL_STRENGTH_GREAT;
    else if (evdoDbm >= -75)
        levelEvdoDbm = SIGNAL_STRENGTH_GOOD;
    else if (evdoDbm >= -90)
        levelEvdoDbm = SIGNAL_STRENGTH_MODERATE;
    else if (evdoDbm >= -105)
        levelEvdoDbm = SIGNAL_STRENGTH_POOR;
    else
        levelEvdoDbm = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    if (evdoSnr == Integer.MAX_VALUE)
        levelEvdoSnr = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    else if (evdoSnr >= 7)
        levelEvdoSnr = SIGNAL_STRENGTH_GREAT;
    else if (evdoSnr >= 5)
        levelEvdoSnr = SIGNAL_STRENGTH_GOOD;
    else if (evdoSnr >= 3)
        levelEvdoSnr = SIGNAL_STRENGTH_MODERATE;
    else if (evdoSnr >= 1)
        levelEvdoSnr = SIGNAL_STRENGTH_POOR;
    else
        levelEvdoSnr = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    int level = (levelEvdoDbm < levelEvdoSnr) ? levelEvdoDbm : levelEvdoSnr;
    if (DBG)
        log("getEvdoLevel=" + level);
    return level;
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiManager.setTdlsEnabled:COMMENT
Method Modifier: public      
Comment:/**
 * Enable/Disable TDLS on a specific local route.
 *
 * <p>
 * TDLS enables two wireless endpoints to talk to each other directly
 * without going through the access point that is managing the local
 * network. It saves bandwidth and improves quality of the link.
 * </p>
 * <p>
 * This API enables/disables the option of using TDLS. If enabled, the
 * underlying hardware is free to use TDLS or a hop through the access
 * point. If disabled, existing TDLS session is torn down and
 * hardware is restricted to use access point for transferring wireless
 * packets. Default value for all routes is 'disabled', meaning restricted
 * to use access point for transferring packets.
 * </p>
 *
 * @param remoteIPAddress IP address of the endpoint to setup TDLS with
 * @param enable true = setup and false = tear down TDLS
 */

Body of Frist Method:
{
    try {
        mService.enableTdls(remoteIPAddress.getHostAddress(), enable);
    } catch (RemoteException e) {
    // Just ignore the exception
    }
}
Body of Second Method:
{
    try {
        mService.enableTdls(remoteIPAddress.getHostAddress(), enable);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.net.ConnectivityManager.getGlobalProxy:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Retrieve any network-independent global HTTP proxy.
 *
 * @return {@link ProxyInfo} for the current global HTTP proxy or {@code null}
 * if no global HTTP proxy is set.
 * @hide
 */

Body of Frist Method:
{
    try {
        return mService.getGlobalProxy();
    } catch (RemoteException e) {
        return null;
    }
}
Body of Second Method:
{
    try {
        return mService.getGlobalProxy();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.content.pm.PackageManager.permissionFlagToString:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * {@hide}
 */

Body of Frist Method:
{
    switch(flag) {
        case FLAG_PERMISSION_GRANTED_BY_DEFAULT:
            return "GRANTED_BY_DEFAULT";
        case FLAG_PERMISSION_POLICY_FIXED:
            return "POLICY_FIXED";
        case FLAG_PERMISSION_SYSTEM_FIXED:
            return "SYSTEM_FIXED";
        case FLAG_PERMISSION_USER_SET:
            return "USER_SET";
        case FLAG_PERMISSION_REVOKE_ON_UPGRADE:
            return "REVOKE_ON_UPGRADE";
        case FLAG_PERMISSION_USER_FIXED:
            return "USER_FIXED";
        default:
            return Integer.toString(flag);
    }
}
Body of Second Method:
{
    switch(flag) {
        case FLAG_PERMISSION_GRANTED_BY_DEFAULT:
            return "GRANTED_BY_DEFAULT";
        case FLAG_PERMISSION_POLICY_FIXED:
            return "POLICY_FIXED";
        case FLAG_PERMISSION_SYSTEM_FIXED:
            return "SYSTEM_FIXED";
        case FLAG_PERMISSION_USER_SET:
            return "USER_SET";
        case FLAG_PERMISSION_REVOKE_ON_UPGRADE:
            return "REVOKE_ON_UPGRADE";
        case FLAG_PERMISSION_USER_FIXED:
            return "USER_FIXED";
        case FLAG_PERMISSION_REVIEW_REQUIRED:
            return "REVIEW_REQUIRED";
        default:
            return Integer.toString(flag);
    }
}
------------------------
Find a silently evolved API code:android.graphics.Bitmap.setPixels:COMMENT
Method Modifier: public      
Comment:/**
 * <p>Replace pixels in the bitmap with the colors in the array. Each element
 * in the array is a packed int prepresenting a non-premultiplied ARGB
 * {@link Color}.</p>
 *
 * @param pixels   The colors to write to the bitmap
 * @param offset   The index of the first color to read from pixels[]
 * @param stride   The number of colors in pixels[] to skip between rows.
 * Normally this value will be the same as the width of
 * the bitmap, but it can be larger (or negative).
 * @param x        The x coordinate of the first pixel to write to in
 * the bitmap.
 * @param y        The y coordinate of the first pixel to write to in
 * the bitmap.
 * @param width    The number of colors to copy from pixels[] per row
 * @param height   The number of rows to write to the bitmap
 *
 * @throws IllegalStateException if the bitmap is not mutable
 * @throws IllegalArgumentException if x, y, width, height are outside of
 * the bitmap's bounds.
 * @throws ArrayIndexOutOfBoundsException if the pixels array is too small
 * to receive the specified number of pixels.
 */

Body of Frist Method:
{
    checkRecycled("Can't call setPixels() on a recycled bitmap");
    if (!isMutable()) {
        throw new IllegalStateException();
    }
    if (width == 0 || height == 0) {
        // nothing to do
        return;
    }
    checkPixelsAccess(x, y, width, height, offset, stride, pixels);
    nativeSetPixels(mFinalizer.mNativeBitmap, pixels, offset, stride, x, y, width, height);
}
Body of Second Method:
{
    checkRecycled("Can't call setPixels() on a recycled bitmap");
    if (!isMutable()) {
        throw new IllegalStateException();
    }
    if (width == 0 || height == 0) {
        // nothing to do
        return;
    }
    checkPixelsAccess(x, y, width, height, offset, stride, pixels);
    nativeSetPixels(mNativePtr, pixels, offset, stride, x, y, width, height);
}
------------------------
Find a silently evolved API code:android.os.PowerManager.isInteractive:COMMENT
Method Modifier: public      
Comment:/**
 * Returns true if the device is in an interactive state.
 * <p>
 * When this method returns true, the device is awake and ready to interact
 * with the user (although this is not a guarantee that the user is actively
 * interacting with the device just this moment).  The main screen is usually
 * turned on while in this state.  Certain features, such as the proximity
 * sensor, may temporarily turn off the screen while still leaving the device in an
 * interactive state.  Note in particular that the device is still considered
 * to be interactive while dreaming (since dreams can be interactive) but not
 * when it is dozing or asleep.
 * </p><p>
 * When this method returns false, the device is dozing or asleep and must
 * be awoken before it will become ready to interact with the user again.  The
 * main screen is usually turned off while in this state.  Certain features,
 * such as "ambient mode" may cause the main screen to remain on (albeit in a
 * low power state) to display system-provided content while the device dozes.
 * </p><p>
 * The system will send a {@link android.content.Intent#ACTION_SCREEN_ON screen on}
 * or {@link android.content.Intent#ACTION_SCREEN_OFF screen off} broadcast
 * whenever the interactive state of the device changes.  For historical reasons,
 * the names of these broadcasts refer to the power state of the screen
 * but they are actually sent in response to changes in the overall interactive
 * state of the device, as described by this method.
 * </p><p>
 * Services may use the non-interactive state as a hint to conserve power
 * since the user is not present.
 * </p>
 *
 * @return True if the device is in an interactive state.
 *
 * @see android.content.Intent#ACTION_SCREEN_ON
 * @see android.content.Intent#ACTION_SCREEN_OFF
 */

Body of Frist Method:
{
    try {
        return mService.isInteractive();
    } catch (RemoteException e) {
        return false;
    }
}
Body of Second Method:
{
    try {
        return mService.isInteractive();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.media.midi.MidiDevice.connectPorts:COMMENT
Method Modifier: public      
Comment:/**
 * Connects the supplied {@link MidiInputPort} to the output port of this device
 * with the specified port number. Once the connection is made, the MidiInput port instance
 * can no longer receive data via its {@link MidiReceiver#onSend} method.
 * This method returns a {@link MidiDevice.MidiConnection} object, which can be used
 * to close the connection.
 *
 * @param inputPort the inputPort to connect
 * @param outputPortNumber the port number of the output port to connect inputPort to.
 * @return {@link MidiDevice.MidiConnection} object if the connection is successful,
 * or null in case of failure.
 */

Body of Frist Method:
{
    if (outputPortNumber < 0 || outputPortNumber >= mDeviceInfo.getOutputPortCount()) {
        throw new IllegalArgumentException("outputPortNumber out of range");
    }
    ParcelFileDescriptor pfd = inputPort.claimFileDescriptor();
    if (pfd == null) {
        return null;
    }
    try {
        IBinder token = new Binder();
        mDeviceServer.connectPorts(token, pfd, outputPortNumber);
        // close our copy of the file descriptor
        IoUtils.closeQuietly(pfd);
        return new MidiConnection(token, inputPort);
    } catch (RemoteException e) {
        Log.e(TAG, "RemoteException in connectPorts");
        return null;
    }
}
Body of Second Method:
{
    if (outputPortNumber < 0 || outputPortNumber >= mDeviceInfo.getOutputPortCount()) {
        throw new IllegalArgumentException("outputPortNumber out of range");
    }
    if (mIsDeviceClosed) {
        return null;
    }
    ParcelFileDescriptor pfd = inputPort.claimFileDescriptor();
    if (pfd == null) {
        return null;
    }
    try {
        IBinder token = new Binder();
        int calleePid = mDeviceServer.connectPorts(token, pfd, outputPortNumber);
        // kill the connection. So don't do that.
        if (calleePid != Process.myPid()) {
            // close our copy of the file descriptor
            IoUtils.closeQuietly(pfd);
        }
        return new MidiConnection(token, inputPort);
    } catch (RemoteException e) {
        Log.e(TAG, "RemoteException in connectPorts");
        return null;
    }
}
------------------------
Find a silently evolved API code:android.net.NetworkIdentity.buildNetworkIdentity:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Build a {@link NetworkIdentity} from the given {@link NetworkState},
 * assuming that any mobile networks are using the current IMSI.
 */

Body of Frist Method:
{
    final int type = state.networkInfo.getType();
    final int subType = state.networkInfo.getSubtype();
    String subscriberId = null;
    String networkId = null;
    boolean roaming = false;
    if (isNetworkTypeMobile(type)) {
        if (state.subscriberId == null) {
            Slog.w(TAG, "Active mobile network without subscriber!");
        }
        subscriberId = state.subscriberId;
        roaming = state.networkInfo.isRoaming();
    } else if (type == TYPE_WIFI) {
        if (state.networkId != null) {
            networkId = state.networkId;
        } else {
            final WifiManager wifi = (WifiManager) context.getSystemService(Context.WIFI_SERVICE);
            final WifiInfo info = wifi.getConnectionInfo();
            networkId = info != null ? info.getSSID() : null;
        }
    }
    return new NetworkIdentity(type, subType, subscriberId, networkId, roaming);
}
Body of Second Method:
{
    final int type = state.networkInfo.getType();
    final int subType = state.networkInfo.getSubtype();
    String subscriberId = null;
    String networkId = null;
    boolean roaming = false;
    boolean metered = false;
    if (isNetworkTypeMobile(type)) {
        if (state.subscriberId == null) {
            Slog.w(TAG, "Active mobile network without subscriber!");
        }
        subscriberId = state.subscriberId;
        roaming = state.networkInfo.isRoaming();
        metered = !state.networkCapabilities.hasCapability(NetworkCapabilities.NET_CAPABILITY_NOT_METERED);
    } else if (type == TYPE_WIFI) {
        if (state.networkId != null) {
            networkId = state.networkId;
        } else {
            final WifiManager wifi = (WifiManager) context.getSystemService(Context.WIFI_SERVICE);
            final WifiInfo info = wifi.getConnectionInfo();
            networkId = info != null ? info.getSSID() : null;
        }
    }
    return new NetworkIdentity(type, subType, subscriberId, networkId, roaming, metered);
}
------------------------
Find a silently evolved API code:android.net.ConnectivityManager.getTetheredDhcpRanges:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the set of tethered dhcp ranges.
 *
 * @return an array of 0 or more {@code String} of tethered dhcp ranges.
 * {@hide}
 */

Body of Frist Method:
{
    try {
        return mService.getTetheredDhcpRanges();
    } catch (RemoteException e) {
        return new String[0];
    }
}
Body of Second Method:
{
    try {
        return mService.getTetheredDhcpRanges();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.graphics.Canvas.release:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Releases the resources associated with this canvas.
 *
 * @hide
 */

Body of Frist Method:
{
    mFinalizer.dispose();
}
Body of Second Method:
{
    mNativeCanvasWrapper = 0;
    if (mFinalizer != null) {
        mFinalizer.run();
        mFinalizer = null;
    }
}
------------------------
Find a silently evolved API code:android.content.SyncRequest.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Performs validation over the request and throws the runtime exception
 * <code>IllegalArgumentException</code> if this validation fails.
 *
 * @return a SyncRequest with the information contained within this
 * builder.
 */

Body of Frist Method:
{
    // Validate the extras bundle
    ContentResolver.validateSyncExtrasBundle(mCustomExtras);
    if (mCustomExtras == null) {
        mCustomExtras = new Bundle();
    }
    // Combine builder extra flags into the config bundle.
    mSyncConfigExtras = new Bundle();
    if (mIgnoreBackoff) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_IGNORE_BACKOFF, true);
    }
    if (mDisallowMetered) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_DISALLOW_METERED, true);
    }
    if (mIgnoreSettings) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_IGNORE_SETTINGS, true);
    }
    if (mNoRetry) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_DO_NOT_RETRY, true);
    }
    if (mExpedited) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_EXPEDITED, true);
    }
    if (mIsManual) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_IGNORE_BACKOFF, true);
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_IGNORE_SETTINGS, true);
    }
    if (mSyncType == SYNC_TYPE_PERIODIC) {
        // If this is a periodic sync ensure than invalid extras were not set.
        if (ContentResolver.invalidPeriodicExtras(mCustomExtras) || ContentResolver.invalidPeriodicExtras(mSyncConfigExtras)) {
            throw new IllegalArgumentException("Illegal extras were set");
        }
    }
    // Ensure that a target for the sync has been set.
    if (mSyncTarget == SYNC_TARGET_UNKNOWN) {
        throw new IllegalArgumentException("Must specify an adapter with" + " setSyncAdapter(Account, String");
    }
    return new SyncRequest(this);
}
Body of Second Method:
{
    // Validate the extras bundle
    ContentResolver.validateSyncExtrasBundle(mCustomExtras);
    if (mCustomExtras == null) {
        mCustomExtras = new Bundle();
    }
    // Combine builder extra flags into the config bundle.
    mSyncConfigExtras = new Bundle();
    if (mIgnoreBackoff) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_IGNORE_BACKOFF, true);
    }
    if (mDisallowMetered) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_DISALLOW_METERED, true);
    }
    if (mRequiresCharging) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_REQUIRE_CHARGING, true);
    }
    if (mIgnoreSettings) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_IGNORE_SETTINGS, true);
    }
    if (mNoRetry) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_DO_NOT_RETRY, true);
    }
    if (mExpedited) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_EXPEDITED, true);
    }
    if (mIsManual) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_IGNORE_BACKOFF, true);
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_IGNORE_SETTINGS, true);
    }
    if (mSyncType == SYNC_TYPE_PERIODIC) {
        // If this is a periodic sync ensure than invalid extras were not set.
        if (ContentResolver.invalidPeriodicExtras(mCustomExtras) || ContentResolver.invalidPeriodicExtras(mSyncConfigExtras)) {
            throw new IllegalArgumentException("Illegal extras were set");
        }
    }
    // Ensure that a target for the sync has been set.
    if (mSyncTarget == SYNC_TARGET_UNKNOWN) {
        throw new IllegalArgumentException("Must specify an adapter with" + " setSyncAdapter(Account, String");
    }
    return new SyncRequest(this);
}
------------------------
Find a silently evolved API code:android.app.usage.NetworkStats.getNextHistoryBucket:COMMENT
Method Modifier: private     
Comment:/**
 * Getting the next item in a history enumeration.
 * @param bucketOut Next item will be set here.
 * @return true if a next item could be set.
 */

Body of Frist Method:
{
    if (bucketOut != null && mHistory != null) {
        if (mEnumerationIndex < mHistory.size()) {
            mRecycledHistoryEntry = mHistory.getValues(mEnumerationIndex++, mRecycledHistoryEntry);
            bucketOut.mUid = Bucket.convertUid(getUid());
            bucketOut.mState = Bucket.STATE_ALL;
            bucketOut.mBeginTimeStamp = mRecycledHistoryEntry.bucketStart;
            bucketOut.mEndTimeStamp = mRecycledHistoryEntry.bucketStart + mRecycledHistoryEntry.bucketDuration;
            bucketOut.mRxBytes = mRecycledHistoryEntry.rxBytes;
            bucketOut.mRxPackets = mRecycledHistoryEntry.rxPackets;
            bucketOut.mTxBytes = mRecycledHistoryEntry.txBytes;
            bucketOut.mTxPackets = mRecycledHistoryEntry.txPackets;
            return true;
        } else if (hasNextUid()) {
            stepHistory();
            return getNextHistoryBucket(bucketOut);
        }
    }
    return false;
}
Body of Second Method:
{
    if (bucketOut != null && mHistory != null) {
        if (mEnumerationIndex < mHistory.size()) {
            mRecycledHistoryEntry = mHistory.getValues(mEnumerationIndex++, mRecycledHistoryEntry);
            bucketOut.mUid = Bucket.convertUid(getUid());
            bucketOut.mTag = Bucket.convertTag(mTag);
            bucketOut.mState = Bucket.STATE_ALL;
            bucketOut.mRoaming = Bucket.ROAMING_ALL;
            bucketOut.mBeginTimeStamp = mRecycledHistoryEntry.bucketStart;
            bucketOut.mEndTimeStamp = mRecycledHistoryEntry.bucketStart + mRecycledHistoryEntry.bucketDuration;
            bucketOut.mRxBytes = mRecycledHistoryEntry.rxBytes;
            bucketOut.mRxPackets = mRecycledHistoryEntry.rxPackets;
            bucketOut.mTxBytes = mRecycledHistoryEntry.txBytes;
            bucketOut.mTxPackets = mRecycledHistoryEntry.txPackets;
            return true;
        } else if (hasNextUid()) {
            stepHistory();
            return getNextHistoryBucket(bucketOut);
        }
    }
    return false;
}
------------------------
Find a silently evolved API code:android.text.SpannableStringBuilder.clear:COMMENT
Method Modifier: public      
Comment:// Documentation from interface

Body of Frist Method:
{
    replace(0, length(), "", 0, 0);
}
Body of Second Method:
{
    replace(0, length(), "", 0, 0);
    mSpanInsertCount = 0;
}
------------------------
Find a silently evolved API code:android.widget.TextView.paste:COMMENT
Method Modifier: private     
Comment:/**
 * Paste clipboard content between min and max positions.
 */

Body of Frist Method:
{
    ClipboardManager clipboard = (ClipboardManager) getContext().getSystemService(Context.CLIPBOARD_SERVICE);
    ClipData clip = clipboard.getPrimaryClip();
    if (clip != null) {
        boolean didFirst = false;
        for (int i = 0; i < clip.getItemCount(); i++) {
            final CharSequence paste;
            if (withFormatting) {
                paste = clip.getItemAt(i).coerceToStyledText(getContext());
            } else {
                // Get an item as text and remove all spans by toString().
                final CharSequence text = clip.getItemAt(i).coerceToText(getContext());
                paste = (text instanceof Spanned) ? text.toString() : text;
            }
            if (paste != null) {
                if (!didFirst) {
                    Selection.setSelection((Spannable) mText, max);
                    ((Editable) mText).replace(min, max, paste);
                    didFirst = true;
                } else {
                    ((Editable) mText).insert(getSelectionEnd(), "\n");
                    ((Editable) mText).insert(getSelectionEnd(), paste);
                }
            }
        }
        stopTextActionMode();
        sLastCutCopyOrTextChangedTime = 0;
    }
}
Body of Second Method:
{
    ClipboardManager clipboard = (ClipboardManager) getContext().getSystemService(Context.CLIPBOARD_SERVICE);
    ClipData clip = clipboard.getPrimaryClip();
    if (clip != null) {
        boolean didFirst = false;
        for (int i = 0; i < clip.getItemCount(); i++) {
            final CharSequence paste;
            if (withFormatting) {
                paste = clip.getItemAt(i).coerceToStyledText(getContext());
            } else {
                // Get an item as text and remove all spans by toString().
                final CharSequence text = clip.getItemAt(i).coerceToText(getContext());
                paste = (text instanceof Spanned) ? text.toString() : text;
            }
            if (paste != null) {
                if (!didFirst) {
                    Selection.setSelection((Spannable) mText, max);
                    ((Editable) mText).replace(min, max, paste);
                    didFirst = true;
                } else {
                    ((Editable) mText).insert(getSelectionEnd(), "\n");
                    ((Editable) mText).insert(getSelectionEnd(), paste);
                }
            }
        }
        sLastCutCopyOrTextChangedTime = 0;
    }
}
------------------------
Find a silently evolved API code:android.text.Layout.getParagraphSpans:COMMENT
Method Modifier: default     static      
Comment:/* package */

Body of Frist Method:
{
    if (start == end && start > 0) {
        return ArrayUtils.emptyArray(type);
    }
    return text.getSpans(start, end, type);
}
Body of Second Method:
{
    if (start == end && start > 0) {
        return ArrayUtils.emptyArray(type);
    }
    if (text instanceof SpannableStringBuilder) {
        return ((SpannableStringBuilder) text).getSpans(start, end, type, false);
    } else {
        return text.getSpans(start, end, type);
    }
}
------------------------
Find a silently evolved API code:android.widget.TimePicker.setCurrentMinute:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * Set the current minute (0-59).
 *
 * @deprecated Use {@link #setMinute(int)}
 */

Body of Frist Method:
{
    mDelegate.setCurrentMinute(currentMinute);
}
Body of Second Method:
{
    mDelegate.setMinute(currentMinute);
}
------------------------
Find a silently evolved API code:android.app.Activity.performSaveInstanceState:COMMENT
Method Modifier: default     final       
Comment:/**
 * The hook for {@link ActivityThread} to save the state of this activity.
 *
 * Calls {@link #onSaveInstanceState(android.os.Bundle)}
 * and {@link #saveManagedDialogs(android.os.Bundle)}.
 *
 * @param outState The bundle to save the state to.
 */

Body of Frist Method:
{
    onSaveInstanceState(outState);
    saveManagedDialogs(outState);
    mActivityTransitionState.saveState(outState);
    if (DEBUG_LIFECYCLE)
        Slog.v(TAG, "onSaveInstanceState " + this + ": " + outState);
}
Body of Second Method:
{
    onSaveInstanceState(outState);
    saveManagedDialogs(outState);
    mActivityTransitionState.saveState(outState);
    storeHasCurrentPermissionRequest(outState);
    if (DEBUG_LIFECYCLE)
        Slog.v(TAG, "onSaveInstanceState " + this + ": " + outState);
}
------------------------
Find a silently evolved API code:android.hardware.camera2.legacy.SurfaceTextureRenderer.configureSurfaces:COMMENT
Method Modifier: public      
Comment:/**
 * Set a collection of output {@link Surface}s that can be drawn to.
 *
 * @param surfaces a {@link Collection} of surfaces.
 */

Body of Frist Method:
{
    releaseEGLContext();
    if (surfaces == null || surfaces.size() == 0) {
        Log.w(TAG, "No output surfaces configured for GL drawing.");
        return;
    }
    for (Pair<Surface, Size> p : surfaces) {
        Surface s = p.first;
        Size surfaceSize = p.second;
        // If pixel conversions aren't handled by egl, use a pbuffer
        try {
            EGLSurfaceHolder holder = new EGLSurfaceHolder();
            holder.surface = s;
            holder.width = surfaceSize.getWidth();
            holder.height = surfaceSize.getHeight();
            if (LegacyCameraDevice.needsConversion(s)) {
                mConversionSurfaces.add(holder);
            } else {
                mSurfaces.add(holder);
            }
        } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
            Log.w(TAG, "Surface abandoned, skipping configuration... ", e);
        }
    }
    // Set up egl display
    configureEGLContext();
    // Set up regular egl surfaces if needed
    if (mSurfaces.size() > 0) {
        configureEGLOutputSurfaces(mSurfaces);
    }
    // Set up pbuffer surface if needed
    if (mConversionSurfaces.size() > 0) {
        configureEGLPbufferSurfaces(mConversionSurfaces);
    }
    makeCurrent((mSurfaces.size() > 0) ? mSurfaces.get(0).eglSurface : mConversionSurfaces.get(0).eglSurface);
    initializeGLState();
    mSurfaceTexture = new SurfaceTexture(getTextureId());
    // Set up performance tracking if enabled
    if (SystemProperties.getBoolean(LEGACY_PERF_PROPERTY, false)) {
        setupGlTiming();
    }
}
Body of Second Method:
{
    releaseEGLContext();
    if (surfaces == null || surfaces.size() == 0) {
        Log.w(TAG, "No output surfaces configured for GL drawing.");
        return;
    }
    for (Pair<Surface, Size> p : surfaces) {
        Surface s = p.first;
        Size surfaceSize = p.second;
        // If pixel conversions aren't handled by egl, use a pbuffer
        try {
            EGLSurfaceHolder holder = new EGLSurfaceHolder();
            holder.surface = s;
            holder.width = surfaceSize.getWidth();
            holder.height = surfaceSize.getHeight();
            if (LegacyCameraDevice.needsConversion(s)) {
                mConversionSurfaces.add(holder);
                // LegacyCameraDevice is the producer of surfaces if it's not handled by EGL,
                // so LegacyCameraDevice needs to connect to the surfaces.
                LegacyCameraDevice.connectSurface(s);
            } else {
                mSurfaces.add(holder);
            }
        } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
            Log.w(TAG, "Surface abandoned, skipping configuration... ", e);
        }
    }
    // Set up egl display
    configureEGLContext();
    // Set up regular egl surfaces if needed
    if (mSurfaces.size() > 0) {
        configureEGLOutputSurfaces(mSurfaces);
    }
    // Set up pbuffer surface if needed
    if (mConversionSurfaces.size() > 0) {
        configureEGLPbufferSurfaces(mConversionSurfaces);
    }
    makeCurrent((mSurfaces.size() > 0) ? mSurfaces.get(0).eglSurface : mConversionSurfaces.get(0).eglSurface);
    initializeGLState();
    mSurfaceTexture = new SurfaceTexture(getTextureId());
    // Set up performance tracking if enabled
    if (SystemProperties.getBoolean(LEGACY_PERF_PROPERTY, false)) {
        setupGlTiming();
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothAdapter.isDiscovering:COMMENT
Method Modifier: public      
Comment:/**
 * Return true if the local Bluetooth adapter is currently in the device
 * discovery process.
 * <p>Device discovery is a heavyweight procedure. New connections to
 * remote Bluetooth devices should not be attempted while discovery is in
 * progress, and existing connections will experience limited bandwidth
 * and high latency. Use {@link #cancelDiscovery()} to cancel an ongoing
 * discovery.
 * <p>Applications can also register for {@link #ACTION_DISCOVERY_STARTED}
 * or {@link #ACTION_DISCOVERY_FINISHED} to be notified when discovery
 * starts or completes.
 * <p>If Bluetooth state is not {@link #STATE_ON}, this API
 * will return false. After turning on Bluetooth,
 * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}
 * to get the updated value.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}.
 *
 * @return true if discovering
 */

Body of Frist Method:
{
    if (getState() != STATE_ON)
        return false;
    try {
        synchronized (mManagerCallback) {
            if (mService != null)
                return mService.isDiscovering();
        }
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
Body of Second Method:
{
    if (getState() != STATE_ON)
        return false;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.isDiscovering();
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}
------------------------
Find a silently evolved API code:android.content.pm.PermissionInfo.protectionToString:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    String protLevel = "????";
    switch(level & PROTECTION_MASK_BASE) {
        case PermissionInfo.PROTECTION_DANGEROUS:
            protLevel = "dangerous";
            break;
        case PermissionInfo.PROTECTION_NORMAL:
            protLevel = "normal";
            break;
        case PermissionInfo.PROTECTION_SIGNATURE:
            protLevel = "signature";
            break;
        case PermissionInfo.PROTECTION_SIGNATURE_OR_SYSTEM:
            protLevel = "signatureOrSystem";
            break;
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_PRIVILEGED) != 0) {
        protLevel += "|privileged";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_DEVELOPMENT) != 0) {
        protLevel += "|development";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_APPOP) != 0) {
        protLevel += "|appop";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_PRE23) != 0) {
        protLevel += "|pre23";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_INSTALLER) != 0) {
        protLevel += "|installer";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_VERIFIER) != 0) {
        protLevel += "|verifier";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_PREINSTALLED) != 0) {
        protLevel += "|preinstalled";
    }
    return protLevel;
}
Body of Second Method:
{
    String protLevel = "????";
    switch(level & PROTECTION_MASK_BASE) {
        case PermissionInfo.PROTECTION_DANGEROUS:
            protLevel = "dangerous";
            break;
        case PermissionInfo.PROTECTION_NORMAL:
            protLevel = "normal";
            break;
        case PermissionInfo.PROTECTION_SIGNATURE:
            protLevel = "signature";
            break;
        case PermissionInfo.PROTECTION_SIGNATURE_OR_SYSTEM:
            protLevel = "signatureOrSystem";
            break;
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_PRIVILEGED) != 0) {
        protLevel += "|privileged";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_DEVELOPMENT) != 0) {
        protLevel += "|development";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_APPOP) != 0) {
        protLevel += "|appop";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_PRE23) != 0) {
        protLevel += "|pre23";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_INSTALLER) != 0) {
        protLevel += "|installer";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_VERIFIER) != 0) {
        protLevel += "|verifier";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_PREINSTALLED) != 0) {
        protLevel += "|preinstalled";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_SETUP) != 0) {
        protLevel += "|setup";
    }
    return protLevel;
}
------------------------
Find a silently evolved API code:android.content.res.TypedArray.getInteger:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the integer value for the attribute at <var>index</var>.
 * <p>
 * Unlike {@link #getInt(int, int)}, this method will throw an exception if
 * the attribute is defined but is not an integer.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute integer value, or defValue if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not an integer.
 */

Body of Frist Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + AssetManager.STYLE_DATA];
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index * AssetManager.STYLE_NUM_ENTRIES, value);
        throw new UnsupportedOperationException("Failed to resolve attribute at index " + index + ": " + value);
    }
    throw new UnsupportedOperationException("Can't convert to integer: type=0x" + Integer.toHexString(type));
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    final int attrIndex = index;
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + AssetManager.STYLE_DATA];
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index, value);
        throw new UnsupportedOperationException("Failed to resolve attribute at index " + attrIndex + ": " + value);
    }
    throw new UnsupportedOperationException("Can't convert value at index " + attrIndex + " to integer: type=0x" + Integer.toHexString(type));
}
------------------------
Find a silently evolved API code:android.print.PrinterInfo.Builder.setDescription:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the <strong>localized</strong> printer description
 * which is shown to the user
 *
 * @param description The description.
 * @return This builder.
 */

Body of Frist Method:
{
    mPrototype.mDescription = description;
    return this;
}
Body of Second Method:
{
    mDescription = description;
    return this;
}
------------------------
Find a silently evolved API code:android.widget.GridView.setupChild:COMMENT
Method Modifier: private     
Comment:/**
 * Add a view as a child and make sure it is measured (if necessary) and
 * positioned properly.
 *
 * @param child The view to add
 * @param position The position of the view
 * @param y The y position relative to which this view will be positioned
 * @param flow if true, align top edge to y. If false, align bottom edge
 * to y.
 * @param childrenLeft Left edge where children should be positioned
 * @param selected Is this position selected?
 * @param recycled Has this view been pulled from the recycle bin? If so it
 * does not need to be remeasured.
 * @param where Where to add the item in the list
 */

Body of Frist Method:
{
    Trace.traceBegin(Trace.TRACE_TAG_VIEW, "setupGridItem");
    boolean isSelected = selected && shouldShowSelector();
    final boolean updateChildSelected = isSelected != child.isSelected();
    final int mode = mTouchMode;
    final boolean isPressed = mode > TOUCH_MODE_DOWN && mode < TOUCH_MODE_SCROLL && mMotionPosition == position;
    final boolean updateChildPressed = isPressed != child.isPressed();
    boolean needToMeasure = !recycled || updateChildSelected || child.isLayoutRequested();
    // Respect layout params that are already in the view. Otherwise make
    // some up...
    AbsListView.LayoutParams p = (AbsListView.LayoutParams) child.getLayoutParams();
    if (p == null) {
        p = (AbsListView.LayoutParams) generateDefaultLayoutParams();
    }
    p.viewType = mAdapter.getItemViewType(position);
    if (recycled && !p.forceAdd) {
        attachViewToParent(child, where, p);
    } else {
        p.forceAdd = false;
        addViewInLayout(child, where, p, true);
    }
    if (updateChildSelected) {
        child.setSelected(isSelected);
        if (isSelected) {
            requestFocus();
        }
    }
    if (updateChildPressed) {
        child.setPressed(isPressed);
    }
    if (mChoiceMode != CHOICE_MODE_NONE && mCheckStates != null) {
        if (child instanceof Checkable) {
            ((Checkable) child).setChecked(mCheckStates.get(position));
        } else if (getContext().getApplicationInfo().targetSdkVersion >= android.os.Build.VERSION_CODES.HONEYCOMB) {
            child.setActivated(mCheckStates.get(position));
        }
    }
    if (needToMeasure) {
        int childHeightSpec = ViewGroup.getChildMeasureSpec(MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED), 0, p.height);
        int childWidthSpec = ViewGroup.getChildMeasureSpec(MeasureSpec.makeMeasureSpec(mColumnWidth, MeasureSpec.EXACTLY), 0, p.width);
        child.measure(childWidthSpec, childHeightSpec);
    } else {
        cleanupLayoutState(child);
    }
    final int w = child.getMeasuredWidth();
    final int h = child.getMeasuredHeight();
    int childLeft;
    final int childTop = flow ? y : y - h;
    final int layoutDirection = getLayoutDirection();
    final int absoluteGravity = Gravity.getAbsoluteGravity(mGravity, layoutDirection);
    switch(absoluteGravity & Gravity.HORIZONTAL_GRAVITY_MASK) {
        case Gravity.LEFT:
            childLeft = childrenLeft;
            break;
        case Gravity.CENTER_HORIZONTAL:
            childLeft = childrenLeft + ((mColumnWidth - w) / 2);
            break;
        case Gravity.RIGHT:
            childLeft = childrenLeft + mColumnWidth - w;
            break;
        default:
            childLeft = childrenLeft;
            break;
    }
    if (needToMeasure) {
        final int childRight = childLeft + w;
        final int childBottom = childTop + h;
        child.layout(childLeft, childTop, childRight, childBottom);
    } else {
        child.offsetLeftAndRight(childLeft - child.getLeft());
        child.offsetTopAndBottom(childTop - child.getTop());
    }
    if (mCachingStarted) {
        child.setDrawingCacheEnabled(true);
    }
    if (recycled && (((AbsListView.LayoutParams) child.getLayoutParams()).scrappedFromPosition) != position) {
        child.jumpDrawablesToCurrentState();
    }
    Trace.traceEnd(Trace.TRACE_TAG_VIEW);
}
Body of Second Method:
{
    Trace.traceBegin(Trace.TRACE_TAG_VIEW, "setupGridItem");
    boolean isSelected = selected && shouldShowSelector();
    final boolean updateChildSelected = isSelected != child.isSelected();
    final int mode = mTouchMode;
    final boolean isPressed = mode > TOUCH_MODE_DOWN && mode < TOUCH_MODE_SCROLL && mMotionPosition == position;
    final boolean updateChildPressed = isPressed != child.isPressed();
    boolean needToMeasure = !recycled || updateChildSelected || child.isLayoutRequested();
    // Respect layout params that are already in the view. Otherwise make
    // some up...
    AbsListView.LayoutParams p = (AbsListView.LayoutParams) child.getLayoutParams();
    if (p == null) {
        p = (AbsListView.LayoutParams) generateDefaultLayoutParams();
    }
    p.viewType = mAdapter.getItemViewType(position);
    p.isEnabled = mAdapter.isEnabled(position);
    if (recycled && !p.forceAdd) {
        attachViewToParent(child, where, p);
    } else {
        p.forceAdd = false;
        addViewInLayout(child, where, p, true);
    }
    if (updateChildSelected) {
        child.setSelected(isSelected);
        if (isSelected) {
            requestFocus();
        }
    }
    if (updateChildPressed) {
        child.setPressed(isPressed);
    }
    if (mChoiceMode != CHOICE_MODE_NONE && mCheckStates != null) {
        if (child instanceof Checkable) {
            ((Checkable) child).setChecked(mCheckStates.get(position));
        } else if (getContext().getApplicationInfo().targetSdkVersion >= android.os.Build.VERSION_CODES.HONEYCOMB) {
            child.setActivated(mCheckStates.get(position));
        }
    }
    if (needToMeasure) {
        int childHeightSpec = ViewGroup.getChildMeasureSpec(MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED), 0, p.height);
        int childWidthSpec = ViewGroup.getChildMeasureSpec(MeasureSpec.makeMeasureSpec(mColumnWidth, MeasureSpec.EXACTLY), 0, p.width);
        child.measure(childWidthSpec, childHeightSpec);
    } else {
        cleanupLayoutState(child);
    }
    final int w = child.getMeasuredWidth();
    final int h = child.getMeasuredHeight();
    int childLeft;
    final int childTop = flow ? y : y - h;
    final int layoutDirection = getLayoutDirection();
    final int absoluteGravity = Gravity.getAbsoluteGravity(mGravity, layoutDirection);
    switch(absoluteGravity & Gravity.HORIZONTAL_GRAVITY_MASK) {
        case Gravity.LEFT:
            childLeft = childrenLeft;
            break;
        case Gravity.CENTER_HORIZONTAL:
            childLeft = childrenLeft + ((mColumnWidth - w) / 2);
            break;
        case Gravity.RIGHT:
            childLeft = childrenLeft + mColumnWidth - w;
            break;
        default:
            childLeft = childrenLeft;
            break;
    }
    if (needToMeasure) {
        final int childRight = childLeft + w;
        final int childBottom = childTop + h;
        child.layout(childLeft, childTop, childRight, childBottom);
    } else {
        child.offsetLeftAndRight(childLeft - child.getLeft());
        child.offsetTopAndBottom(childTop - child.getTop());
    }
    if (mCachingStarted) {
        child.setDrawingCacheEnabled(true);
    }
    if (recycled && (((AbsListView.LayoutParams) child.getLayoutParams()).scrappedFromPosition) != position) {
        child.jumpDrawablesToCurrentState();
    }
    Trace.traceEnd(Trace.TRACE_TAG_VIEW);
}
------------------------
Find a silently evolved API code:android.printservice.PrintService.generatePrinterId:COMMENT
Method Modifier: public      final       
Comment:/**
 * Generates a global printer id given the printer's locally unique one.
 *
 * @param localId A locally unique id in the context of your print service.
 * @return Global printer id.
 */

Body of Frist Method:
{
    throwIfNotCalledOnMainThread();
    return new PrinterId(new ComponentName(getPackageName(), getClass().getName()), localId);
}
Body of Second Method:
{
    throwIfNotCalledOnMainThread();
    localId = Preconditions.checkNotNull(localId, "localId cannot be null");
    return new PrinterId(new ComponentName(getPackageName(), getClass().getName()), localId);
}
------------------------
Find a silently evolved API code:android.location.Location.distanceTo:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the approximate distance in meters between this
 * location and the given location.  Distance is defined using
 * the WGS84 ellipsoid.
 *
 * @param dest the destination location
 * @return the approximate distance in meters
 */

Body of Frist Method:
{
    // See if we already have the result
    synchronized (mResults) {
        if (mLatitude != mLat1 || mLongitude != mLon1 || dest.mLatitude != mLat2 || dest.mLongitude != mLon2) {
            computeDistanceAndBearing(mLatitude, mLongitude, dest.mLatitude, dest.mLongitude, mResults);
            mLat1 = mLatitude;
            mLon1 = mLongitude;
            mLat2 = dest.mLatitude;
            mLon2 = dest.mLongitude;
            mDistance = mResults[0];
            mInitialBearing = mResults[1];
        }
        return mDistance;
    }
}
Body of Second Method:
{
    BearingDistanceCache cache = sBearingDistanceCache.get();
    // See if we already have the result
    if (mLatitude != cache.mLat1 || mLongitude != cache.mLon1 || dest.mLatitude != cache.mLat2 || dest.mLongitude != cache.mLon2) {
        computeDistanceAndBearing(mLatitude, mLongitude, dest.mLatitude, dest.mLongitude, cache);
    }
    return cache.mDistance;
}
------------------------
Find a silently evolved API code:android.widget.TextView.spanChange:COMMENT
Method Modifier: default     
Comment:/**
 * Not private so it can be called from an inner class without going
 * through a thunk.
 */

Body of Frist Method:
{
    // XXX Make the start and end move together if this ends up
    // spending too much time invalidating.
    boolean selChanged = false;
    int newSelStart = -1, newSelEnd = -1;
    final Editor.InputMethodState ims = mEditor == null ? null : mEditor.mInputMethodState;
    if (what == Selection.SELECTION_END) {
        selChanged = true;
        newSelEnd = newStart;
        if (oldStart >= 0 || newStart >= 0) {
            invalidateCursor(Selection.getSelectionStart(buf), oldStart, newStart);
            checkForResize();
            registerForPreDraw();
            if (mEditor != null)
                mEditor.makeBlink();
        }
    }
    if (what == Selection.SELECTION_START) {
        selChanged = true;
        newSelStart = newStart;
        if (oldStart >= 0 || newStart >= 0) {
            int end = Selection.getSelectionEnd(buf);
            invalidateCursor(end, oldStart, newStart);
        }
    }
    if (selChanged) {
        mHighlightPathBogus = true;
        if (mEditor != null && !isFocused())
            mEditor.mSelectionMoved = true;
        if ((buf.getSpanFlags(what) & Spanned.SPAN_INTERMEDIATE) == 0) {
            if (newSelStart < 0) {
                newSelStart = Selection.getSelectionStart(buf);
            }
            if (newSelEnd < 0) {
                newSelEnd = Selection.getSelectionEnd(buf);
            }
            onSelectionChanged(newSelStart, newSelEnd);
        }
    }
    if (what instanceof UpdateAppearance || what instanceof ParagraphStyle || what instanceof CharacterStyle) {
        if (ims == null || ims.mBatchEditNesting == 0) {
            invalidate();
            mHighlightPathBogus = true;
            checkForResize();
        } else {
            ims.mContentChanged = true;
        }
        if (mEditor != null) {
            if (oldStart >= 0)
                mEditor.invalidateTextDisplayList(mLayout, oldStart, oldEnd);
            if (newStart >= 0)
                mEditor.invalidateTextDisplayList(mLayout, newStart, newEnd);
        }
    }
    if (MetaKeyKeyListener.isMetaTracker(buf, what)) {
        mHighlightPathBogus = true;
        if (ims != null && MetaKeyKeyListener.isSelectingMetaTracker(buf, what)) {
            ims.mSelectionModeChanged = true;
        }
        if (Selection.getSelectionStart(buf) >= 0) {
            if (ims == null || ims.mBatchEditNesting == 0) {
                invalidateCursor();
            } else {
                ims.mCursorChanged = true;
            }
        }
    }
    if (what instanceof ParcelableSpan) {
        // the current extract editor would be interested in it.
        if (ims != null && ims.mExtractedTextRequest != null) {
            if (ims.mBatchEditNesting != 0) {
                if (oldStart >= 0) {
                    if (ims.mChangedStart > oldStart) {
                        ims.mChangedStart = oldStart;
                    }
                    if (ims.mChangedStart > oldEnd) {
                        ims.mChangedStart = oldEnd;
                    }
                }
                if (newStart >= 0) {
                    if (ims.mChangedStart > newStart) {
                        ims.mChangedStart = newStart;
                    }
                    if (ims.mChangedStart > newEnd) {
                        ims.mChangedStart = newEnd;
                    }
                }
            } else {
                if (DEBUG_EXTRACT)
                    Log.v(LOG_TAG, "Span change outside of batch: " + oldStart + "-" + oldEnd + "," + newStart + "-" + newEnd + " " + what);
                ims.mContentChanged = true;
            }
        }
    }
    if (mEditor != null && mEditor.mSpellChecker != null && newStart < 0 && what instanceof SpellCheckSpan) {
        mEditor.mSpellChecker.onSpellCheckSpanRemoved((SpellCheckSpan) what);
    }
}
Body of Second Method:
{
    // XXX Make the start and end move together if this ends up
    // spending too much time invalidating.
    boolean selChanged = false;
    int newSelStart = -1, newSelEnd = -1;
    final Editor.InputMethodState ims = mEditor == null ? null : mEditor.mInputMethodState;
    if (what == Selection.SELECTION_END) {
        selChanged = true;
        newSelEnd = newStart;
        if (oldStart >= 0 || newStart >= 0) {
            invalidateCursor(Selection.getSelectionStart(buf), oldStart, newStart);
            checkForResize();
            registerForPreDraw();
            if (mEditor != null)
                mEditor.makeBlink();
        }
    }
    if (what == Selection.SELECTION_START) {
        selChanged = true;
        newSelStart = newStart;
        if (oldStart >= 0 || newStart >= 0) {
            int end = Selection.getSelectionEnd(buf);
            invalidateCursor(end, oldStart, newStart);
        }
    }
    if (selChanged) {
        mHighlightPathBogus = true;
        if (mEditor != null && !isFocused())
            mEditor.mSelectionMoved = true;
        if ((buf.getSpanFlags(what) & Spanned.SPAN_INTERMEDIATE) == 0) {
            if (newSelStart < 0) {
                newSelStart = Selection.getSelectionStart(buf);
            }
            if (newSelEnd < 0) {
                newSelEnd = Selection.getSelectionEnd(buf);
            }
            if (mEditor != null) {
                mEditor.refreshTextActionMode();
                if (!hasSelection() && mEditor.mTextActionMode == null && hasTransientState()) {
                    // User generated selection has been removed.
                    setHasTransientState(false);
                }
            }
            onSelectionChanged(newSelStart, newSelEnd);
        }
    }
    if (what instanceof UpdateAppearance || what instanceof ParagraphStyle || what instanceof CharacterStyle) {
        if (ims == null || ims.mBatchEditNesting == 0) {
            invalidate();
            mHighlightPathBogus = true;
            checkForResize();
        } else {
            ims.mContentChanged = true;
        }
        if (mEditor != null) {
            if (oldStart >= 0)
                mEditor.invalidateTextDisplayList(mLayout, oldStart, oldEnd);
            if (newStart >= 0)
                mEditor.invalidateTextDisplayList(mLayout, newStart, newEnd);
            mEditor.invalidateHandlesAndActionMode();
        }
    }
    if (MetaKeyKeyListener.isMetaTracker(buf, what)) {
        mHighlightPathBogus = true;
        if (ims != null && MetaKeyKeyListener.isSelectingMetaTracker(buf, what)) {
            ims.mSelectionModeChanged = true;
        }
        if (Selection.getSelectionStart(buf) >= 0) {
            if (ims == null || ims.mBatchEditNesting == 0) {
                invalidateCursor();
            } else {
                ims.mCursorChanged = true;
            }
        }
    }
    if (what instanceof ParcelableSpan) {
        // the current extract editor would be interested in it.
        if (ims != null && ims.mExtractedTextRequest != null) {
            if (ims.mBatchEditNesting != 0) {
                if (oldStart >= 0) {
                    if (ims.mChangedStart > oldStart) {
                        ims.mChangedStart = oldStart;
                    }
                    if (ims.mChangedStart > oldEnd) {
                        ims.mChangedStart = oldEnd;
                    }
                }
                if (newStart >= 0) {
                    if (ims.mChangedStart > newStart) {
                        ims.mChangedStart = newStart;
                    }
                    if (ims.mChangedStart > newEnd) {
                        ims.mChangedStart = newEnd;
                    }
                }
            } else {
                if (DEBUG_EXTRACT)
                    Log.v(LOG_TAG, "Span change outside of batch: " + oldStart + "-" + oldEnd + "," + newStart + "-" + newEnd + " " + what);
                ims.mContentChanged = true;
            }
        }
    }
    if (mEditor != null && mEditor.mSpellChecker != null && newStart < 0 && what instanceof SpellCheckSpan) {
        mEditor.mSpellChecker.onSpellCheckSpanRemoved((SpellCheckSpan) what);
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiManager.getConnectionInfo:COMMENT
Method Modifier: public      
Comment:/**
 * Return dynamic information about the current Wi-Fi connection, if any is active.
 * @return the Wi-Fi information, contained in {@link WifiInfo}.
 */

Body of Frist Method:
{
    try {
        return mService.getConnectionInfo();
    } catch (RemoteException e) {
        return null;
    }
}
Body of Second Method:
{
    try {
        return mService.getConnectionInfo();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.net.NetworkStats.spliceOperationsFrom:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Splice in {@link #operations} from the given {@link NetworkStats} based
 * on matching {@link #uid} and {@link #tag} rows. Ignores {@link #iface},
 * since operation counts are at data layer.
 */

Body of Frist Method:
{
    for (int i = 0; i < size; i++) {
        final int j = stats.findIndex(iface[i], uid[i], set[i], tag[i]);
        if (j == -1) {
            operations[i] = 0;
        } else {
            operations[i] = stats.operations[j];
        }
    }
}
Body of Second Method:
{
    for (int i = 0; i < size; i++) {
        final int j = stats.findIndex(iface[i], uid[i], set[i], tag[i], roaming[i]);
        if (j == -1) {
            operations[i] = 0;
        } else {
            operations[i] = stats.operations[j];
        }
    }
}
------------------------
Find a silently evolved API code:android.media.AudioManager.setSpeakerphoneOn:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the speakerphone on or off.
 * <p>
 * This method should only be used by applications that replace the platform-wide
 * management of audio settings or the main telephony application.
 *
 * @param on set <var>true</var> to turn on speakerphone;
 * <var>false</var> to turn it off
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        service.setSpeakerphoneOn(on);
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in setSpeakerphoneOn", e);
    }
}
Body of Second Method:
{
    IAudioService service = getService();
    try {
        service.setSpeakerphoneOn(on);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.widget.ImageView.setImageBitmap:COMMENT
Method Modifier: public      
Comment:/**
 * Sets a Bitmap as the content of this ImageView.
 *
 * @param bm The bitmap to set
 */

Body of Frist Method:
{
    // Hacky fix to force setImageDrawable to do a full setImageDrawable
    // instead of doing an object reference comparison
    mDrawable = null;
    if (mRecycleableBitmapDrawable == null) {
        mRecycleableBitmapDrawable = new ImageViewBitmapDrawable(mContext.getResources(), bm);
    } else {
        mRecycleableBitmapDrawable.setBitmap(bm);
    }
    setImageDrawable(mRecycleableBitmapDrawable);
}
Body of Second Method:
{
    // Hacky fix to force setImageDrawable to do a full setImageDrawable
    // instead of doing an object reference comparison
    mDrawable = null;
    if (mRecycleableBitmapDrawable == null) {
        mRecycleableBitmapDrawable = new BitmapDrawable(mContext.getResources(), bm);
    } else {
        mRecycleableBitmapDrawable.setBitmap(bm);
    }
    setImageDrawable(mRecycleableBitmapDrawable);
}
------------------------
Find a silently evolved API code:android.content.pm.PackageManager.buildRequestPermissionsIntent:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns an {@link android.content.Intent} suitable for passing to
 * {@link android.app.Activity#startActivityForResult(android.content.Intent, int)}
 * which prompts the user to grant permissions to this application.
 *
 * @throws NullPointerException if {@code permissions} is {@code null} or empty.
 *
 * @hide
 */

Body of Frist Method:
{
    if (ArrayUtils.isEmpty(permissions)) {
        throw new NullPointerException("permission cannot be null or empty");
    }
    Intent intent = new Intent(ACTION_REQUEST_PERMISSIONS);
    intent.putExtra(EXTRA_REQUEST_PERMISSIONS_NAMES, permissions);
    intent.setPackage(getPermissionControllerPackageName());
    return intent;
}
Body of Second Method:
{
    if (ArrayUtils.isEmpty(permissions)) {
        throw new IllegalArgumentException("permission cannot be null or empty");
    }
    Intent intent = new Intent(ACTION_REQUEST_PERMISSIONS);
    intent.putExtra(EXTRA_REQUEST_PERMISSIONS_NAMES, permissions);
    intent.setPackage(getPermissionControllerPackageName());
    return intent;
}
------------------------
Find a silently evolved API code:android.widget.TimePicker.is24HourView:COMMENT
Method Modifier: public      
Comment:/**
 * @return {@code true} if this widget displays time in 24-hour mode,
 * {@code false} otherwise}
 * @see #setIs24HourView(Boolean)
 */

Body of Frist Method:
{
    return mDelegate.is24HourView();
}
Body of Second Method:
{
    return mDelegate.is24Hour();
}
------------------------
Find a silently evolved API code:android.widget.TimePickerClockDelegate.updateHeaderSeparator:COMMENT
Method Modifier: private     
Comment:/**
 * The time separator is defined in the Unicode CLDR and cannot be supposed to be ":".
 *
 * See http://unicode.org/cldr/trac/browser/trunk/common/main
 *
 * We pass the correct "skeleton" depending on 12 or 24 hours view and then extract the
 * separator as the character which is just after the hour marker in the returned pattern.
 */

Body of Frist Method:
{
    final String bestDateTimePattern = DateFormat.getBestDateTimePattern(mCurrentLocale, (mIs24HourView) ? "Hm" : "hm");
    final String separatorText;
    // See http://www.unicode.org/reports/tr35/tr35-dates.html for hour formats
    final char[] hourFormats = { 'H', 'h', 'K', 'k' };
    int hIndex = lastIndexOfAny(bestDateTimePattern, hourFormats);
    if (hIndex == -1) {
        // Default case
        separatorText = ":";
    } else {
        separatorText = Character.toString(bestDateTimePattern.charAt(hIndex + 1));
    }
    mSeparatorView.setText(separatorText);
}
Body of Second Method:
{
    final String bestDateTimePattern = DateFormat.getBestDateTimePattern(mLocale, (mIs24Hour) ? "Hm" : "hm");
    final String separatorText;
    // See http://www.unicode.org/reports/tr35/tr35-dates.html for hour formats
    final char[] hourFormats = { 'H', 'h', 'K', 'k' };
    int hIndex = lastIndexOfAny(bestDateTimePattern, hourFormats);
    if (hIndex == -1) {
        // Default case
        separatorText = ":";
    } else {
        separatorText = Character.toString(bestDateTimePattern.charAt(hIndex + 1));
    }
    mSeparatorView.setText(separatorText);
}
------------------------
Find a silently evolved API code:android.hardware.ConsumerIrManager.getCarrierFrequencies:COMMENT
Method Modifier: public      
Comment:/**
 * Query the infrared transmitter's supported carrier frequencies
 *
 * @return an array of
 * {@link android.hardware.ConsumerIrManager.CarrierFrequencyRange}
 * objects representing the ranges that the transmitter can support, or
 * null if there was an error communicating with the Consumer IR Service.
 */

Body of Frist Method:
{
    if (mService == null) {
        Log.w(TAG, "no consumer ir service.");
        return null;
    }
    try {
        int[] freqs = mService.getCarrierFrequencies();
        if (freqs.length % 2 != 0) {
            Log.w(TAG, "consumer ir service returned an uneven number of frequencies.");
            return null;
        }
        CarrierFrequencyRange[] range = new CarrierFrequencyRange[freqs.length / 2];
        for (int i = 0; i < freqs.length; i += 2) {
            range[i / 2] = new CarrierFrequencyRange(freqs[i], freqs[i + 1]);
        }
        return range;
    } catch (RemoteException e) {
    }
    return null;
}
Body of Second Method:
{
    if (mService == null) {
        Log.w(TAG, "no consumer ir service.");
        return null;
    }
    try {
        int[] freqs = mService.getCarrierFrequencies();
        if (freqs.length % 2 != 0) {
            Log.w(TAG, "consumer ir service returned an uneven number of frequencies.");
            return null;
        }
        CarrierFrequencyRange[] range = new CarrierFrequencyRange[freqs.length / 2];
        for (int i = 0; i < freqs.length; i += 2) {
            range[i / 2] = new CarrierFrequencyRange(freqs[i], freqs[i + 1]);
        }
        return range;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.appwidget.AppWidgetManager.unbindRemoteViewsService:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Unbinds the RemoteViewsService for a given appWidgetId and intent.
 *
 * The appWidgetId specified muse already be bound to the calling AppWidgetHost via
 * {@link android.appwidget.AppWidgetManager#bindAppWidgetId AppWidgetManager.bindAppWidgetId()}.
 *
 * @param packageName   The package from which the binding is requested.
 * @param appWidgetId   The AppWidget instance for which to bind the RemoteViewsService.
 * @param intent        The intent of the service which will be providing the data to the
 * RemoteViewsAdapter.
 * @hide
 */

Body of Frist Method:
{
    if (mService == null) {
        return;
    }
    try {
        mService.unbindRemoteViewsService(packageName, appWidgetId, intent);
    } catch (RemoteException e) {
        throw new RuntimeException("system server dead?", e);
    }
}
Body of Second Method:
{
    if (mService == null) {
        return;
    }
    try {
        mService.unbindRemoteViewsService(packageName, appWidgetId, intent);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.media.AudioManager.isSpeakerphoneOn:COMMENT
Method Modifier: public      
Comment:/**
 * Checks whether the speakerphone is on or off.
 *
 * @return true if speakerphone is on, false if it's off
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        return service.isSpeakerphoneOn();
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in isSpeakerphoneOn", e);
        return false;
    }
}
Body of Second Method:
{
    IAudioService service = getService();
    try {
        return service.isSpeakerphoneOn();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.renderscript.RenderScript.internalCreate:COMMENT
Method Modifier: private     static      
Comment:/**
 * Create a RenderScript context.
 *
 * @param ctx The context.
 * @return RenderScript
 */

Body of Frist Method:
{
    if (!sInitialized) {
        Log.e(LOG_TAG, "RenderScript.create() called when disabled; someone is likely to crash");
        return null;
    }
    if ((flags & ~(CREATE_FLAG_LOW_LATENCY | CREATE_FLAG_LOW_POWER)) != 0) {
        throw new RSIllegalArgumentException("Invalid flags passed.");
    }
    RenderScript rs = new RenderScript(ctx);
    rs.mDev = rs.nDeviceCreate();
    rs.mContext = rs.nContextCreate(rs.mDev, flags, sdkVersion, ct.mID);
    rs.mContextType = ct;
    rs.mContextFlags = flags;
    rs.mContextSdkVersion = sdkVersion;
    if (rs.mContext == 0) {
        throw new RSDriverException("Failed to create RS context.");
    }
    // set up cache directory for entire context
    final String CACHE_PATH = "com.android.renderscript.cache";
    File f = new File(RenderScriptCacheDir.mCacheDir, CACHE_PATH);
    String mCachePath = f.getAbsolutePath();
    f.mkdirs();
    rs.nContextSetCacheDir(mCachePath);
    rs.mMessageThread = new MessageThread(rs);
    rs.mMessageThread.start();
    return rs;
}
Body of Second Method:
{
    if (!sInitialized) {
        Log.e(LOG_TAG, "RenderScript.create() called when disabled; someone is likely to crash");
        return null;
    }
    if ((flags & ~(CREATE_FLAG_LOW_LATENCY | CREATE_FLAG_LOW_POWER | CREATE_FLAG_WAIT_FOR_ATTACH)) != 0) {
        throw new RSIllegalArgumentException("Invalid flags passed.");
    }
    RenderScript rs = new RenderScript(ctx);
    long device = rs.nDeviceCreate();
    rs.mContext = rs.nContextCreate(device, flags, sdkVersion, ct.mID);
    rs.mContextType = ct;
    rs.mContextFlags = flags;
    rs.mContextSdkVersion = sdkVersion;
    if (rs.mContext == 0) {
        throw new RSDriverException("Failed to create RS context.");
    }
    // set up cache directory for entire context
    rs.nContextSetCacheDir(RenderScript.getCachePath());
    rs.mMessageThread = new MessageThread(rs);
    rs.mMessageThread.start();
    return rs;
}
------------------------
Find a silently evolved API code:android.service.persistentdata.PersistentDataBlockManager.wipe:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Zeroes the previously written block in its entirety. Calling this method
 * will erase all data written to the persistent data partition.
 */

Body of Frist Method:
{
    try {
        sService.wipe();
    } catch (RemoteException e) {
        onError("wiping persistent partition");
    }
}
Body of Second Method:
{
    try {
        sService.wipe();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.app.ActivityManager.getAppTasks:COMMENT
Method Modifier: public      
Comment:/**
 * Get the list of tasks associated with the calling application.
 *
 * @return The list of tasks associated with the application making this call.
 * @throws SecurityException
 */

Body of Frist Method:
{
    ArrayList<AppTask> tasks = new ArrayList<AppTask>();
    List<IAppTask> appTasks;
    try {
        appTasks = ActivityManagerNative.getDefault().getAppTasks(mContext.getPackageName());
    } catch (RemoteException e) {
        // System dead, we will be dead too soon!
        return null;
    }
    int numAppTasks = appTasks.size();
    for (int i = 0; i < numAppTasks; i++) {
        tasks.add(new AppTask(appTasks.get(i)));
    }
    return tasks;
}
Body of Second Method:
{
    ArrayList<AppTask> tasks = new ArrayList<AppTask>();
    List<IAppTask> appTasks;
    try {
        appTasks = ActivityManagerNative.getDefault().getAppTasks(mContext.getPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
    int numAppTasks = appTasks.size();
    for (int i = 0; i < numAppTasks; i++) {
        tasks.add(new AppTask(appTasks.get(i)));
    }
    return tasks;
}
------------------------
Find a silently evolved API code:android.os.Environment.getDownloadCacheDirectory:COMMENT
Method Modifier: public      static      
Comment:/**
 * Return the download/cache content directory.
 */

Body of Frist Method:
{
    return DOWNLOAD_CACHE_DIRECTORY;
}
Body of Second Method:
{
    return DIR_DOWNLOAD_CACHE;
}
------------------------
Find a silently evolved API code:android.app.Instrumentation.execStartActivityAsCaller:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Special version!
 * @hide
 */

Body of Frist Method:
{
    IApplicationThread whoThread = (IApplicationThread) contextThread;
    if (mActivityMonitors != null) {
        synchronized (mSync) {
            final int N = mActivityMonitors.size();
            for (int i = 0; i < N; i++) {
                final ActivityMonitor am = mActivityMonitors.get(i);
                if (am.match(who, null, intent)) {
                    am.mHits++;
                    if (am.isBlocking()) {
                        return requestCode >= 0 ? am.getResult() : null;
                    }
                    break;
                }
            }
        }
    }
    try {
        intent.migrateExtraStreamToClipData();
        intent.prepareToLeaveProcess();
        int result = ActivityManagerNative.getDefault().startActivityAsCaller(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options, ignoreTargetSecurity, userId);
        checkStartActivityResult(result, intent);
    } catch (RemoteException e) {
        throw new RuntimeException("Failure from system", e);
    }
    return null;
}
Body of Second Method:
{
    IApplicationThread whoThread = (IApplicationThread) contextThread;
    if (mActivityMonitors != null) {
        synchronized (mSync) {
            final int N = mActivityMonitors.size();
            for (int i = 0; i < N; i++) {
                final ActivityMonitor am = mActivityMonitors.get(i);
                if (am.match(who, null, intent)) {
                    am.mHits++;
                    if (am.isBlocking()) {
                        return requestCode >= 0 ? am.getResult() : null;
                    }
                    break;
                }
            }
        }
    }
    try {
        intent.migrateExtraStreamToClipData();
        intent.prepareToLeaveProcess(who);
        int result = ActivityManagerNative.getDefault().startActivityAsCaller(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options, ignoreTargetSecurity, userId);
        checkStartActivityResult(result, intent);
    } catch (RemoteException e) {
        throw new RuntimeException("Failure from system", e);
    }
    return null;
}
------------------------
Find a silently evolved API code:android.os.SystemClock_Delegate.elapsedRealtimeNanos:COMMENT
Method Modifier: default     static      
Comment:/**
 * Returns nanoseconds since boot, including time spent in sleep.
 *
 * @return elapsed nanoseconds since boot.
 */

Body of Frist Method:
{
    return System.nanoTime() - sBootTimeNano;
}
Body of Second Method:
{
    return System_Delegate.nanoTime() - System_Delegate.bootTime();
}
------------------------
Find a silently evolved API code:android.os.StrictMode.AndroidBlockGuardPolicy.handleViolation:COMMENT
Method Modifier: default     
Comment:// hence the policy being passed around.

Body of Frist Method:
{
    if (info == null || info.crashInfo == null || info.crashInfo.stackTrace == null) {
        Log.wtf(TAG, "unexpected null stacktrace");
        return;
    }
    if (LOG_V)
        Log.d(TAG, "handleViolation; policy=" + info.policy);
    if ((info.policy & PENALTY_GATHER) != 0) {
        ArrayList<ViolationInfo> violations = gatheredViolations.get();
        if (violations == null) {
            violations = new ArrayList<ViolationInfo>(1);
            gatheredViolations.set(violations);
        } else if (violations.size() >= 5) {
            // Too many.  In a loop or something?  Don't gather them all.
            return;
        }
        for (ViolationInfo previous : violations) {
            if (info.crashInfo.stackTrace.equals(previous.crashInfo.stackTrace)) {
                // Duplicate. Don't log.
                return;
            }
        }
        violations.add(info);
        return;
    }
    // Not perfect, but fast and good enough for dup suppression.
    Integer crashFingerprint = info.hashCode();
    long lastViolationTime = 0;
    if (mLastViolationTime != null) {
        Long vtime = mLastViolationTime.get(crashFingerprint);
        if (vtime != null) {
            lastViolationTime = vtime;
        }
    } else {
        mLastViolationTime = new ArrayMap<Integer, Long>(1);
    }
    long now = SystemClock.uptimeMillis();
    mLastViolationTime.put(crashFingerprint, now);
    long timeSinceLastViolationMillis = lastViolationTime == 0 ? Long.MAX_VALUE : (now - lastViolationTime);
    if ((info.policy & PENALTY_LOG) != 0 && timeSinceLastViolationMillis > MIN_LOG_INTERVAL_MS) {
        if (info.durationMillis != -1) {
            Log.d(TAG, "StrictMode policy violation; ~duration=" + info.durationMillis + " ms: " + info.crashInfo.stackTrace);
        } else {
            Log.d(TAG, "StrictMode policy violation: " + info.crashInfo.stackTrace);
        }
    }
    // The violationMaskSubset, passed to ActivityManager, is a
    // subset of the original StrictMode policy bitmask, with
    // only the bit violated and penalty bits to be executed
    // by the ActivityManagerService remaining set.
    int violationMaskSubset = 0;
    if ((info.policy & PENALTY_DIALOG) != 0 && timeSinceLastViolationMillis > MIN_DIALOG_INTERVAL_MS) {
        violationMaskSubset |= PENALTY_DIALOG;
    }
    if ((info.policy & PENALTY_DROPBOX) != 0 && lastViolationTime == 0) {
        violationMaskSubset |= PENALTY_DROPBOX;
    }
    if (violationMaskSubset != 0) {
        int violationBit = parseViolationFromMessage(info.crashInfo.exceptionMessage);
        violationMaskSubset |= violationBit;
        final int savedPolicyMask = getThreadPolicyMask();
        final boolean justDropBox = (info.policy & THREAD_PENALTY_MASK) == PENALTY_DROPBOX;
        if (justDropBox) {
            // If all we're going to ask the activity manager
            // to do is dropbox it (the common case during
            // platform development), we can avoid doing this
            // call synchronously which Binder data suggests
            // isn't always super fast, despite the implementation
            // in the ActivityManager trying to be mostly async.
            dropboxViolationAsync(violationMaskSubset, info);
            return;
        }
        // Normal synchronous call to the ActivityManager.
        try {
            // First, remove any policy before we call into the Activity Manager,
            // otherwise we'll infinite recurse as we try to log policy violations
            // to disk, thus violating policy, thus requiring logging, etc...
            // We restore the current policy below, in the finally block.
            setThreadPolicyMask(0);
            ActivityManagerNative.getDefault().handleApplicationStrictModeViolation(RuntimeInit.getApplicationObject(), violationMaskSubset, info);
        } catch (RemoteException e) {
            Log.e(TAG, "RemoteException trying to handle StrictMode violation", e);
        } finally {
            // Restore the policy.
            setThreadPolicyMask(savedPolicyMask);
        }
    }
    if ((info.policy & PENALTY_DEATH) != 0) {
        executeDeathPenalty(info);
    }
}
Body of Second Method:
{
    if (info == null || info.crashInfo == null || info.crashInfo.stackTrace == null) {
        Log.wtf(TAG, "unexpected null stacktrace");
        return;
    }
    if (LOG_V)
        Log.d(TAG, "handleViolation; policy=" + info.policy);
    if ((info.policy & PENALTY_GATHER) != 0) {
        ArrayList<ViolationInfo> violations = gatheredViolations.get();
        if (violations == null) {
            violations = new ArrayList<ViolationInfo>(1);
            gatheredViolations.set(violations);
        } else if (violations.size() >= 5) {
            // Too many.  In a loop or something?  Don't gather them all.
            return;
        }
        for (ViolationInfo previous : violations) {
            if (info.crashInfo.stackTrace.equals(previous.crashInfo.stackTrace)) {
                // Duplicate. Don't log.
                return;
            }
        }
        violations.add(info);
        return;
    }
    // Not perfect, but fast and good enough for dup suppression.
    Integer crashFingerprint = info.hashCode();
    long lastViolationTime = 0;
    if (mLastViolationTime != null) {
        Long vtime = mLastViolationTime.get(crashFingerprint);
        if (vtime != null) {
            lastViolationTime = vtime;
        }
    } else {
        mLastViolationTime = new ArrayMap<Integer, Long>(1);
    }
    long now = SystemClock.uptimeMillis();
    mLastViolationTime.put(crashFingerprint, now);
    long timeSinceLastViolationMillis = lastViolationTime == 0 ? Long.MAX_VALUE : (now - lastViolationTime);
    if ((info.policy & PENALTY_LOG) != 0 && timeSinceLastViolationMillis > MIN_LOG_INTERVAL_MS) {
        if (info.durationMillis != -1) {
            Log.d(TAG, "StrictMode policy violation; ~duration=" + info.durationMillis + " ms: " + info.crashInfo.stackTrace);
        } else {
            Log.d(TAG, "StrictMode policy violation: " + info.crashInfo.stackTrace);
        }
    }
    // The violationMaskSubset, passed to ActivityManager, is a
    // subset of the original StrictMode policy bitmask, with
    // only the bit violated and penalty bits to be executed
    // by the ActivityManagerService remaining set.
    int violationMaskSubset = 0;
    if ((info.policy & PENALTY_DIALOG) != 0 && timeSinceLastViolationMillis > MIN_DIALOG_INTERVAL_MS) {
        violationMaskSubset |= PENALTY_DIALOG;
    }
    if ((info.policy & PENALTY_DROPBOX) != 0 && lastViolationTime == 0) {
        violationMaskSubset |= PENALTY_DROPBOX;
    }
    if (violationMaskSubset != 0) {
        int violationBit = parseViolationFromMessage(info.crashInfo.exceptionMessage);
        violationMaskSubset |= violationBit;
        final int savedPolicyMask = getThreadPolicyMask();
        final boolean justDropBox = (info.policy & THREAD_PENALTY_MASK) == PENALTY_DROPBOX;
        if (justDropBox) {
            // If all we're going to ask the activity manager
            // to do is dropbox it (the common case during
            // platform development), we can avoid doing this
            // call synchronously which Binder data suggests
            // isn't always super fast, despite the implementation
            // in the ActivityManager trying to be mostly async.
            dropboxViolationAsync(violationMaskSubset, info);
            return;
        }
        // Normal synchronous call to the ActivityManager.
        try {
            // First, remove any policy before we call into the Activity Manager,
            // otherwise we'll infinite recurse as we try to log policy violations
            // to disk, thus violating policy, thus requiring logging, etc...
            // We restore the current policy below, in the finally block.
            setThreadPolicyMask(0);
            ActivityManagerNative.getDefault().handleApplicationStrictModeViolation(RuntimeInit.getApplicationObject(), violationMaskSubset, info);
        } catch (RemoteException e) {
            if (e instanceof DeadObjectException) {
            // System process is dead; ignore
            } else {
                Log.e(TAG, "RemoteException trying to handle StrictMode violation", e);
            }
        } finally {
            // Restore the policy.
            setThreadPolicyMask(savedPolicyMask);
        }
    }
    if ((info.policy & PENALTY_DEATH) != 0) {
        executeDeathPenalty(info);
    }
}
------------------------
Find a silently evolved API code:android.widget.TextView.onTextContextMenuItem:COMMENT
Method Modifier: public      
Comment:/**
 * Called when a context menu option for the text view is selected.  Currently
 * this will be one of {@link android.R.id#selectAll}, {@link android.R.id#cut},
 * {@link android.R.id#copy}, {@link android.R.id#paste} or {@link android.R.id#shareText}.
 *
 * @return true if the context menu item action was performed.
 */

Body of Frist Method:
{
    int min = 0;
    int max = mText.length();
    if (isFocused()) {
        final int selStart = getSelectionStart();
        final int selEnd = getSelectionEnd();
        min = Math.max(0, Math.min(selStart, selEnd));
        max = Math.max(0, Math.max(selStart, selEnd));
    }
    switch(id) {
        case ID_SELECT_ALL:
            // This starts an action mode if triggered from another action mode. Text is
            // highlighted, so that it can be bulk edited, like selectAllOnFocus does. Returns
            // true even if text is empty.
            boolean shouldRestartActionMode = mEditor != null && mEditor.mTextActionMode != null;
            stopTextActionMode();
            selectAllText();
            if (shouldRestartActionMode) {
                mEditor.startSelectionActionMode();
            }
            return true;
        case ID_UNDO:
            if (mEditor != null) {
                mEditor.undo();
            }
            // Returns true even if nothing was undone.
            return true;
        case ID_REDO:
            if (mEditor != null) {
                mEditor.redo();
            }
            // Returns true even if nothing was undone.
            return true;
        case ID_PASTE:
            paste(min, max, true);
            return true;
        case ID_PASTE_AS_PLAIN_TEXT:
            paste(min, max, false);
            return true;
        case ID_CUT:
            setPrimaryClip(ClipData.newPlainText(null, getTransformedText(min, max)));
            deleteText_internal(min, max);
            stopTextActionMode();
            return true;
        case ID_COPY:
            setPrimaryClip(ClipData.newPlainText(null, getTransformedText(min, max)));
            stopTextActionMode();
            return true;
        case ID_REPLACE:
            if (mEditor != null) {
                mEditor.replace();
            }
            return true;
        case ID_SHARE:
            shareSelectedText();
            return true;
    }
    return false;
}
Body of Second Method:
{
    int min = 0;
    int max = mText.length();
    if (isFocused()) {
        final int selStart = getSelectionStart();
        final int selEnd = getSelectionEnd();
        min = Math.max(0, Math.min(selStart, selEnd));
        max = Math.max(0, Math.max(selStart, selEnd));
    }
    switch(id) {
        case ID_SELECT_ALL:
            selectAllText();
            return true;
        case ID_UNDO:
            if (mEditor != null) {
                mEditor.undo();
            }
            // Returns true even if nothing was undone.
            return true;
        case ID_REDO:
            if (mEditor != null) {
                mEditor.redo();
            }
            // Returns true even if nothing was undone.
            return true;
        case ID_PASTE:
            paste(min, max, true);
            return true;
        case ID_PASTE_AS_PLAIN_TEXT:
            paste(min, max, false);
            return true;
        case ID_CUT:
            setPrimaryClip(ClipData.newPlainText(null, getTransformedText(min, max)));
            deleteText_internal(min, max);
            return true;
        case ID_COPY:
            setPrimaryClip(ClipData.newPlainText(null, getTransformedText(min, max)));
            stopTextActionMode();
            return true;
        case ID_REPLACE:
            if (mEditor != null) {
                mEditor.replace();
            }
            return true;
        case ID_SHARE:
            shareSelectedText();
            return true;
    }
    return false;
}
------------------------
Find a silently evolved API code:android.net.ConnectivityManager.registerNetworkFactory:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * {@hide}
 */

Body of Frist Method:
{
    try {
        mService.registerNetworkFactory(messenger, name);
    } catch (RemoteException e) {
    }
}
Body of Second Method:
{
    try {
        mService.registerNetworkFactory(messenger, name);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.app.assist.AssistContent.setWebUri:COMMENT
Method Modifier: public      
Comment:/**
 * Set a web URI associated with the current data being shown to the user.
 * This URI could be opened in a web browser, or in the app as an
 * {@link Intent#ACTION_VIEW} Intent, to show the same data that is currently
 * being displayed by it.  The URI here should be something that is transportable
 * off the device into other environments to acesss the same data as is currently
 * being shown in the app; if the app does not have such a representation, it should
 * leave the null and only report the local intent and clip data.
 */

Body of Frist Method:
{
    mUri = uri;
}
Body of Second Method:
{
    mIsAppProvidedWebUri = true;
    mUri = uri;
}
------------------------
Find a silently evolved API code:android.telephony.SignalStrength.getDbm:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the signal strength as dBm
 *
 * @hide
 */

Body of Frist Method:
{
    int dBm;
    if (isGsm()) {
        dBm = getLteDbm();
        if (dBm == INVALID) {
            dBm = getGsmDbm();
        }
    } else {
        int cdmaDbm = getCdmaDbm();
        int evdoDbm = getEvdoDbm();
        return (evdoDbm == -120) ? cdmaDbm : ((cdmaDbm == -120) ? evdoDbm : (cdmaDbm < evdoDbm ? cdmaDbm : evdoDbm));
    }
    if (DBG)
        log("getDbm=" + dBm);
    return dBm;
}
Body of Second Method:
{
    int dBm = INVALID;
    if (isGsm()) {
        dBm = getLteDbm();
        if (dBm == INVALID) {
            if (getTdScdmaLevel() == SIGNAL_STRENGTH_NONE_OR_UNKNOWN) {
                dBm = getGsmDbm();
            } else {
                dBm = getTdScdmaDbm();
            }
        }
    } else {
        int cdmaDbm = getCdmaDbm();
        int evdoDbm = getEvdoDbm();
        return (evdoDbm == -120) ? cdmaDbm : ((cdmaDbm == -120) ? evdoDbm : (cdmaDbm < evdoDbm ? cdmaDbm : evdoDbm));
    }
    if (DBG)
        log("getDbm=" + dBm);
    return dBm;
}
------------------------
Find a silently evolved API code:android.graphics.Bitmap.setPremultiplied:COMMENT
Method Modifier: public      final       
Comment:/**
 * Sets whether the bitmap should treat its data as pre-multiplied.
 *
 * <p>Bitmaps are always treated as pre-multiplied by the view system and
 * {@link Canvas} for performance reasons. Storing un-pre-multiplied data in
 * a Bitmap (through {@link #setPixel}, {@link #setPixels}, or {@link
 * BitmapFactory.Options#inPremultiplied BitmapFactory.Options.inPremultiplied})
 * can lead to incorrect blending if drawn by the framework.</p>
 *
 * <p>This method will not affect the behavior of a bitmap without an alpha
 * channel, or if {@link #hasAlpha()} returns false.</p>
 *
 * <p>Calling {@link #createBitmap} or {@link #createScaledBitmap} with a source
 * Bitmap whose colors are not pre-multiplied may result in a RuntimeException,
 * since those functions require drawing the source, which is not supported for
 * un-pre-multiplied Bitmaps.</p>
 *
 * @see Bitmap#isPremultiplied()
 * @see BitmapFactory.Options#inPremultiplied
 */

Body of Frist Method:
{
    checkRecycled("setPremultiplied called on a recycled bitmap");
    mRequestPremultiplied = premultiplied;
    nativeSetPremultiplied(mFinalizer.mNativeBitmap, premultiplied);
}
Body of Second Method:
{
    checkRecycled("setPremultiplied called on a recycled bitmap");
    mRequestPremultiplied = premultiplied;
    nativeSetPremultiplied(mNativePtr, premultiplied);
}
------------------------
Find a silently evolved API code:android.app.WallpaperManager.setWallpaperComponent:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Set the live wallpaper.
 *
 * This can only be called by packages with android.permission.SET_WALLPAPER_COMPONENT
 * permission.
 *
 * @hide
 */

Body of Frist Method:
{
    if (sGlobals.mService == null) {
        Log.w(TAG, "WallpaperService not running");
        return false;
    }
    try {
        sGlobals.mService.setWallpaperComponentChecked(name, mContext.getOpPackageName());
        return true;
    } catch (RemoteException e) {
    // Ignore
    }
    return false;
}
Body of Second Method:
{
    if (sGlobals.mService == null) {
        Log.w(TAG, "WallpaperService not running");
        throw new RuntimeException(new DeadSystemException());
    }
    try {
        sGlobals.mService.setWallpaperComponentChecked(name, mContext.getOpPackageName());
        return true;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.net.ConnectivityManager.getTetherableWifiRegexs:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the list of regular expressions that define any tetherable
 * Wifi network interfaces.  If Wifi tethering is not supported by the
 * device, this list should be empty.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
 *
 * @return an array of 0 or more regular expression Strings defining
 * what interfaces are considered tetherable wifi interfaces.
 *
 * {@hide}
 */

Body of Frist Method:
{
    try {
        return mService.getTetherableWifiRegexs();
    } catch (RemoteException e) {
        return new String[0];
    }
}
Body of Second Method:
{
    try {
        return mService.getTetherableWifiRegexs();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.renderscript.Allocation.copyToFieldPacker:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 *
 * This is only intended to be used by auto-generated code reflected from
 * the RenderScript script files and should not be used by developers.
 *
 * @param xoff
 * @param yoff
 * @param zoff
 * @param component_number
 * @param fp
 */

Body of Frist Method:
{
    mRS.validate();
    if (component_number >= mType.mElement.mElements.length) {
        throw new RSIllegalArgumentException("Component_number " + component_number + " out of range.");
    }
    if (xoff < 0) {
        throw new RSIllegalArgumentException("Offset x must be >= 0.");
    }
    if (yoff < 0) {
        throw new RSIllegalArgumentException("Offset y must be >= 0.");
    }
    if (zoff < 0) {
        throw new RSIllegalArgumentException("Offset z must be >= 0.");
    }
    final byte[] data = fp.getData();
    int data_length = fp.getPos();
    int eSize = mType.mElement.mElements[component_number].getBytesSize();
    eSize *= mType.mElement.mArraySizes[component_number];
    if (data_length != eSize) {
        throw new RSIllegalArgumentException("Field packer sizelength " + data_length + " does not match component size " + eSize + ".");
    }
    mRS.nAllocationElementRead(getIDSafe(), xoff, yoff, zoff, mSelectedLOD, component_number, data, data_length);
}
Body of Second Method:
{
    mRS.validate();
    if (component_number >= mType.mElement.mElements.length) {
        throw new RSIllegalArgumentException("Component_number " + component_number + " out of range.");
    }
    if (xoff < 0) {
        throw new RSIllegalArgumentException("Offset x must be >= 0.");
    }
    if (yoff < 0) {
        throw new RSIllegalArgumentException("Offset y must be >= 0.");
    }
    if (zoff < 0) {
        throw new RSIllegalArgumentException("Offset z must be >= 0.");
    }
    final byte[] data = fp.getData();
    int data_length = data.length;
    int eSize = mType.mElement.mElements[component_number].getBytesSize();
    eSize *= mType.mElement.mArraySizes[component_number];
    if (data_length != eSize) {
        throw new RSIllegalArgumentException("Field packer sizelength " + data_length + " does not match component size " + eSize + ".");
    }
    mRS.nAllocationElementRead(getIDSafe(), xoff, yoff, zoff, mSelectedLOD, component_number, data, data_length);
}
------------------------
Find a silently evolved API code:android.app.ActivityManager.TaskDescription.saveToXml:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (mLabel != null) {
        out.attribute(null, ATTR_TASKDESCRIPTIONLABEL, mLabel);
    }
    if (mColorPrimary != 0) {
        out.attribute(null, ATTR_TASKDESCRIPTIONCOLOR, Integer.toHexString(mColorPrimary));
    }
    if (mIconFilename != null) {
        out.attribute(null, ATTR_TASKDESCRIPTIONICONFILENAME, mIconFilename);
    }
}
Body of Second Method:
{
    if (mLabel != null) {
        out.attribute(null, ATTR_TASKDESCRIPTIONLABEL, mLabel);
    }
    if (mColorPrimary != 0) {
        out.attribute(null, ATTR_TASKDESCRIPTIONCOLOR_PRIMARY, Integer.toHexString(mColorPrimary));
    }
    if (mColorBackground != 0) {
        out.attribute(null, ATTR_TASKDESCRIPTIONCOLOR_BACKGROUND, Integer.toHexString(mColorBackground));
    }
    if (mIconFilename != null) {
        out.attribute(null, ATTR_TASKDESCRIPTIONICONFILENAME, mIconFilename);
    }
}
------------------------
Find a silently evolved API code:android.app.WallpaperManager.setDisplayOffset:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Apply a raw offset to the wallpaper window.  Should only be used in
 * combination with {@link #setDisplayPadding(android.graphics.Rect)} when you
 * have ensured that the wallpaper will extend outside of the display area so that
 * it can be moved without leaving part of the display uncovered.
 * @param x The offset, in pixels, to apply to the left edge.
 * @param y The offset, in pixels, to apply to the top edge.
 * @hide
 */

Body of Frist Method:
{
    try {
        // Log.v(TAG, "Sending new wallpaper display offsets from app...");
        WindowManagerGlobal.getWindowSession().setWallpaperDisplayOffset(windowToken, x, y);
    // Log.v(TAG, "...app returning after sending display offset!");
    } catch (RemoteException e) {
    // Ignore.
    }
}
Body of Second Method:
{
    try {
        // Log.v(TAG, "Sending new wallpaper display offsets from app...");
        WindowManagerGlobal.getWindowSession().setWallpaperDisplayOffset(windowToken, x, y);
    // Log.v(TAG, "...app returning after sending display offset!");
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.renderscript.Sampler.WRAP_LINEAR_MIP_LINEAR:COMMENT
Method Modifier: public      static      
Comment:/**
 * Retrieve a sampler with mag set to linear, min linear mipmap linear, and
 * wrap modes set to wrap.
 *
 * @param rs Context to which the sampler will belong.
 *
 * @return Sampler
 */

Body of Frist Method:
{
    if (rs.mSampler_WRAP_LINEAR_MIP_LINEAR == null) {
        Builder b = new Builder(rs);
        b.setMinification(Value.LINEAR_MIP_LINEAR);
        b.setMagnification(Value.LINEAR);
        b.setWrapS(Value.WRAP);
        b.setWrapT(Value.WRAP);
        rs.mSampler_WRAP_LINEAR_MIP_LINEAR = b.create();
    }
    return rs.mSampler_WRAP_LINEAR_MIP_LINEAR;
}
Body of Second Method:
{
    if (rs.mSampler_WRAP_LINEAR_MIP_LINEAR == null) {
        synchronized (rs) {
            if (rs.mSampler_WRAP_LINEAR_MIP_LINEAR == null) {
                Builder b = new Builder(rs);
                b.setMinification(Value.LINEAR_MIP_LINEAR);
                b.setMagnification(Value.LINEAR);
                b.setWrapS(Value.WRAP);
                b.setWrapT(Value.WRAP);
                rs.mSampler_WRAP_LINEAR_MIP_LINEAR = b.create();
            }
        }
    }
    return rs.mSampler_WRAP_LINEAR_MIP_LINEAR;
}
------------------------
Find a silently evolved API code:android.accounts.AccountManager.addAccountExplicitly:COMMENT
Method Modifier: public      
Comment:/**
 * Adds an account directly to the AccountManager. Normally used by sign-up
 * wizards associated with authenticators, not directly by applications.
 * <p>Calling this method does not update the last authenticated timestamp,
 * referred by {@link #KEY_LAST_AUTHENTICATED_TIME}. To update it, call
 * {@link #notifyAccountAuthenticated(Account)} after getting success.
 * However, if this method is called when it is triggered by addAccount() or
 * addAccountAsUser() or similar functions, then there is no need to update
 * timestamp manually as it is updated automatically by framework on
 * successful completion of the mentioned functions.
 * <p>It is safe to call this method from the main thread.
 * <p>This method requires the caller to have a signature match with the
 * authenticator that owns the specified account.
 *
 * <p><b>NOTE:</b> If targeting your app to work on API level 22 and before,
 * AUTHENTICATE_ACCOUNTS permission is needed for those platforms. See docs
 * for this function in API level 22.
 *
 * @param account The {@link Account} to add
 * @param password The password to associate with the account, null for none
 * @param userdata String values to use for the account's userdata, null for
 * none
 * @return True if the account was successfully added, false if the account
 * already exists, the account is null, or another error occurs.
 */

Body of Frist Method:
{
    if (account == null)
        throw new IllegalArgumentException("account is null");
    try {
        return mService.addAccountExplicitly(account, password, userdata);
    } catch (RemoteException e) {
        // Can happen if there was a SecurityException was thrown.
        throw new RuntimeException(e);
    }
}
Body of Second Method:
{
    if (account == null)
        throw new IllegalArgumentException("account is null");
    try {
        return mService.addAccountExplicitly(account, password, userdata);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.app.ActivityManager.AppTask.getTaskInfo:COMMENT
Method Modifier: public      
Comment:/**
 * Get the RecentTaskInfo associated with this task.
 *
 * @return The RecentTaskInfo for this task, or null if the task no longer exists.
 */

Body of Frist Method:
{
    try {
        return mAppTaskImpl.getTaskInfo();
    } catch (RemoteException e) {
        Slog.e(TAG, "Invalid AppTask", e);
        return null;
    }
}
Body of Second Method:
{
    try {
        return mAppTaskImpl.getTaskInfo();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.location.Location.removeBearing:COMMENT
Method Modifier: public      
Comment:/**
 * Remove the bearing from this location.
 *
 * <p>Following this call {@link #hasBearing} will return false,
 * and {@link #getBearing} will return 0.0.
 */

Body of Frist Method:
{
    mBearing = 0.0f;
    mHasBearing = false;
}
Body of Second Method:
{
    mBearing = 0.0f;
    mFieldsMask &= ~HAS_BEARING_MASK;
}
------------------------
Find a silently evolved API code:android.graphics.Path_Delegate.rLineTo:COMMENT
<android.graphics.Path_Delegate: void rLineTo(float,float)>
private     ->public      
Method Modifier: public      private     
Method Modifier: No          Yes         
Method Updated:  Yes         No          
Comment:/**
 * Same as lineTo, but the coordinates are considered relative to the last
 * point on this contour. If there is no previous point, then a moveTo(0,0)
 * is inserted automatically.
 *
 * @param dx The amount to add to the x-coordinate of the previous point on
 * this contour, to specify a line
 * @param dy The amount to add to the y-coordinate of the previous point on
 * this contour, to specify a line
 */

Body of Frist Method:
{
    if (isEmpty()) {
        mPath.moveTo(mLastX = 0, mLastY = 0);
    }
    dx += mLastX;
    dy += mLastY;
    mPath.lineTo(mLastX = dx, mLastY = dy);
}
Body of Second Method:
{
    if (!hasPoints()) {
        mPath.moveTo(mLastX = 0, mLastY = 0);
    }
    if (Math.abs(dx) < EPSILON && Math.abs(dy) < EPSILON) {
        // The delta is so small that this shouldn't generate a line
        return;
    }
    dx += mLastX;
    dy += mLastY;
    mPath.lineTo(mLastX = dx, mLastY = dy);
}
------------------------
Find a silently evolved API code:android.service.persistentdata.PersistentDataBlockManager.setOemUnlockEnabled:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Writes a byte enabling or disabling the ability to "OEM unlock" the device.
 */

Body of Frist Method:
{
    try {
        sService.setOemUnlockEnabled(enabled);
    } catch (RemoteException e) {
        onError("setting OEM unlock enabled to " + enabled);
    }
}
Body of Second Method:
{
    try {
        sService.setOemUnlockEnabled(enabled);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.net.LocalSocketImpl.shutdownInput:COMMENT
Method Modifier: protected   
Comment:/**
 * Shuts down the input side of the socket.
 *
 * @throws IOException
 */

Body of Frist Method:
{
    if (fd == null) {
        throw new IOException("socket not created");
    }
    shutdown(fd, true);
}
Body of Second Method:
{
    if (fd == null) {
        throw new IOException("socket not created");
    }
    try {
        Os.shutdown(fd, OsConstants.SHUT_RD);
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
}
------------------------
Find a silently evolved API code:android.widget.Editor.UndoInputFilter.handleCompositionEdit:COMMENT
Method Modifier: private     
Comment:/**
 * Returns true iff the edit was handled, either because it should be ignored or because
 * this function created an undo operation for it.
 */

Body of Frist Method:
{
    // Ignore edits while the user is composing.
    if (isComposition(source)) {
        mHasComposition = true;
        return true;
    }
    final boolean hadComposition = mHasComposition;
    mHasComposition = false;
    // Check for the transition out of the composing state.
    if (hadComposition) {
        // If there was no text the user canceled composition. Ignore the edit.
        if (start == end) {
            return true;
        }
        // Otherwise the user inserted the composition.
        String newText = TextUtils.substring(source, start, end);
        EditOperation edit = new EditOperation(mEditor, "", dstart, newText);
        recordEdit(edit, false);
        return true;
    }
    // This was neither a composition event nor a transition out of composing.
    return false;
}
Body of Second Method:
{
    // Ignore edits while the user is composing.
    if (isComposition(source)) {
        mHasComposition = true;
        return true;
    }
    final boolean hadComposition = mHasComposition;
    mHasComposition = false;
    // Check for the transition out of the composing state.
    if (hadComposition) {
        // If there was no text the user canceled composition. Ignore the edit.
        if (start == end) {
            return true;
        }
        // Otherwise the user inserted the composition.
        String newText = TextUtils.substring(source, start, end);
        EditOperation edit = new EditOperation(mEditor, "", dstart, newText);
        recordEdit(edit, mForceMerge);
        return true;
    }
    // This was neither a composition event nor a transition out of composing.
    return false;
}
------------------------
Find a silently evolved API code:android.widget.TableRow.setColumnCollapsed:COMMENT
Method Modifier: default     hidden      
Comment:/**
 * <p>Collapses or restores a given column.</p>
 *
 * @param columnIndex the index of the column
 * @param collapsed true if the column must be collapsed, false otherwise
 * {@hide}
 */

Body of Frist Method:
{
    View child = getVirtualChildAt(columnIndex);
    if (child != null) {
        child.setVisibility(collapsed ? GONE : VISIBLE);
    }
}
Body of Second Method:
{
    final View child = getVirtualChildAt(columnIndex);
    if (child != null) {
        child.setVisibility(collapsed ? GONE : VISIBLE);
    }
}
------------------------
Find a silently evolved API code:android.widget.TextView.onInitializeAccessibilityNodeInfoInternal:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    super.onInitializeAccessibilityNodeInfoInternal(info);
    final boolean isPassword = hasPasswordTransformationMethod();
    info.setPassword(isPassword);
    if (!isPassword || shouldSpeakPasswordsForAccessibility()) {
        info.setText(getTextForAccessibility());
    }
    if (mBufferType == BufferType.EDITABLE) {
        info.setEditable(true);
    }
    if (mEditor != null) {
        info.setInputType(mEditor.mInputType);
        if (mEditor.mError != null) {
            info.setContentInvalid(true);
            info.setError(mEditor.mError);
        }
    }
    if (!TextUtils.isEmpty(mText)) {
        info.addAction(AccessibilityNodeInfo.ACTION_NEXT_AT_MOVEMENT_GRANULARITY);
        info.addAction(AccessibilityNodeInfo.ACTION_PREVIOUS_AT_MOVEMENT_GRANULARITY);
        info.setMovementGranularities(AccessibilityNodeInfo.MOVEMENT_GRANULARITY_CHARACTER | AccessibilityNodeInfo.MOVEMENT_GRANULARITY_WORD | AccessibilityNodeInfo.MOVEMENT_GRANULARITY_LINE | AccessibilityNodeInfo.MOVEMENT_GRANULARITY_PARAGRAPH | AccessibilityNodeInfo.MOVEMENT_GRANULARITY_PAGE);
        info.addAction(AccessibilityNodeInfo.ACTION_SET_SELECTION);
    }
    if (isFocused()) {
        if (canCopy()) {
            info.addAction(AccessibilityNodeInfo.ACTION_COPY);
        }
        if (canPaste()) {
            info.addAction(AccessibilityNodeInfo.ACTION_PASTE);
        }
        if (canCut()) {
            info.addAction(AccessibilityNodeInfo.ACTION_CUT);
        }
        if (canShare()) {
            info.addAction(new AccessibilityNodeInfo.AccessibilityAction(ACCESSIBILITY_ACTION_SHARE, getResources().getString(com.android.internal.R.string.share)));
        }
        if (canProcessText()) {
            // also implies mEditor is not null.
            mEditor.mProcessTextIntentActionsHandler.onInitializeAccessibilityNodeInfo(info);
        }
    }
    // Check for known input filter types.
    final int numFilters = mFilters.length;
    for (int i = 0; i < numFilters; i++) {
        final InputFilter filter = mFilters[i];
        if (filter instanceof InputFilter.LengthFilter) {
            info.setMaxTextLength(((InputFilter.LengthFilter) filter).getMax());
        }
    }
    if (!isSingleLine()) {
        info.setMultiLine(true);
    }
}
Body of Second Method:
{
    super.onInitializeAccessibilityNodeInfoInternal(info);
    final boolean isPassword = hasPasswordTransformationMethod();
    info.setPassword(isPassword);
    info.setText(getTextForAccessibility());
    if (mBufferType == BufferType.EDITABLE) {
        info.setEditable(true);
        if (isEnabled()) {
            info.addAction(AccessibilityNodeInfo.AccessibilityAction.ACTION_SET_TEXT);
        }
    }
    if (mEditor != null) {
        info.setInputType(mEditor.mInputType);
        if (mEditor.mError != null) {
            info.setContentInvalid(true);
            info.setError(mEditor.mError);
        }
    }
    if (!TextUtils.isEmpty(mText)) {
        info.addAction(AccessibilityNodeInfo.ACTION_NEXT_AT_MOVEMENT_GRANULARITY);
        info.addAction(AccessibilityNodeInfo.ACTION_PREVIOUS_AT_MOVEMENT_GRANULARITY);
        info.setMovementGranularities(AccessibilityNodeInfo.MOVEMENT_GRANULARITY_CHARACTER | AccessibilityNodeInfo.MOVEMENT_GRANULARITY_WORD | AccessibilityNodeInfo.MOVEMENT_GRANULARITY_LINE | AccessibilityNodeInfo.MOVEMENT_GRANULARITY_PARAGRAPH | AccessibilityNodeInfo.MOVEMENT_GRANULARITY_PAGE);
        info.addAction(AccessibilityNodeInfo.ACTION_SET_SELECTION);
    }
    if (isFocused()) {
        if (canCopy()) {
            info.addAction(AccessibilityNodeInfo.ACTION_COPY);
        }
        if (canPaste()) {
            info.addAction(AccessibilityNodeInfo.ACTION_PASTE);
        }
        if (canCut()) {
            info.addAction(AccessibilityNodeInfo.ACTION_CUT);
        }
        if (canShare()) {
            info.addAction(new AccessibilityNodeInfo.AccessibilityAction(ACCESSIBILITY_ACTION_SHARE, getResources().getString(com.android.internal.R.string.share)));
        }
        if (canProcessText()) {
            // also implies mEditor is not null.
            mEditor.mProcessTextIntentActionsHandler.onInitializeAccessibilityNodeInfo(info);
        }
    }
    // Check for known input filter types.
    final int numFilters = mFilters.length;
    for (int i = 0; i < numFilters; i++) {
        final InputFilter filter = mFilters[i];
        if (filter instanceof InputFilter.LengthFilter) {
            info.setMaxTextLength(((InputFilter.LengthFilter) filter).getMax());
        }
    }
    if (!isSingleLine()) {
        info.setMultiLine(true);
    }
}
------------------------
Find a silently evolved API code:android.media.AudioManager.setMasterMute:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        service.setMasterMute(mute, flags, getContext().getOpPackageName(), UserHandle.getCallingUserId());
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in setMasterMute", e);
    }
}
Body of Second Method:
{
    IAudioService service = getService();
    try {
        service.setMasterMute(mute, flags, getContext().getOpPackageName(), UserHandle.getCallingUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.app.admin.DeviceAdminInfo.getComponent:COMMENT
Method Modifier: public      
Comment:/**
 * Return the component of the receiver that implements this device admin.
 */

Body of Frist Method:
{
    return new ComponentName(mReceiver.activityInfo.packageName, mReceiver.activityInfo.name);
}
Body of Second Method:
{
    return new ComponentName(mActivityInfo.packageName, mActivityInfo.name);
}
------------------------
Find a silently evolved API code:android.content.ClipDescription.toShortString:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    boolean first = !toShortStringTypesOnly(b);
    if (mLabel != null) {
        if (!first) {
            b.append(' ');
        }
        first = false;
        b.append('"');
        b.append(mLabel);
        b.append('"');
    }
    return !first;
}
Body of Second Method:
{
    boolean first = !toShortStringTypesOnly(b);
    if (mLabel != null) {
        if (!first) {
            b.append(' ');
        }
        first = false;
        b.append('"');
        b.append(mLabel);
        b.append('"');
    }
    if (mExtras != null) {
        if (!first) {
            b.append(' ');
        }
        first = false;
        b.append(mExtras.toString());
    }
    return !first;
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiScanner.startTrackingWifiChange:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * track changes in wifi environment
 * @param listener object to report events on; this object must be unique and must also be
 * provided on {@link #stopTrackingWifiChange}
 */

Body of Frist Method:
{
    validateChannel();
    sAsyncChannel.sendMessage(CMD_START_TRACKING_CHANGE, 0, putListener(listener));
}
Body of Second Method:
{
    Preconditions.checkNotNull(listener, "listener cannot be null");
    int key = addListener(listener);
    if (key == INVALID_KEY)
        return;
    validateChannel();
    mAsyncChannel.sendMessage(CMD_START_TRACKING_CHANGE, 0, key);
}
------------------------
Find a silently evolved API code:android.app.Activity.createPendingResult:COMMENT
Method Modifier: public      
Comment:/**
 * Create a new PendingIntent object which you can hand to others
 * for them to use to send result data back to your
 * {@link #onActivityResult} callback.  The created object will be either
 * one-shot (becoming invalid after a result is sent back) or multiple
 * (allowing any number of results to be sent through it).
 *
 * @param requestCode Private request code for the sender that will be
 * associated with the result data when it is returned.  The sender can not
 * modify this value, allowing you to identify incoming results.
 * @param data Default data to supply in the result, which may be modified
 * by the sender.
 * @param flags May be {@link PendingIntent#FLAG_ONE_SHOT PendingIntent.FLAG_ONE_SHOT},
 * {@link PendingIntent#FLAG_NO_CREATE PendingIntent.FLAG_NO_CREATE},
 * {@link PendingIntent#FLAG_CANCEL_CURRENT PendingIntent.FLAG_CANCEL_CURRENT},
 * {@link PendingIntent#FLAG_UPDATE_CURRENT PendingIntent.FLAG_UPDATE_CURRENT},
 * or any of the flags as supported by
 * {@link Intent#fillIn Intent.fillIn()} to control which unspecified parts
 * of the intent that can be supplied when the actual send happens.
 *
 * @return Returns an existing or new PendingIntent matching the given
 * parameters.  May return null only if
 * {@link PendingIntent#FLAG_NO_CREATE PendingIntent.FLAG_NO_CREATE} has been
 * supplied.
 *
 * @see PendingIntent
 */

Body of Frist Method:
{
    String packageName = getPackageName();
    try {
        data.prepareToLeaveProcess();
        IIntentSender target = ActivityManagerNative.getDefault().getIntentSender(ActivityManager.INTENT_SENDER_ACTIVITY_RESULT, packageName, mParent == null ? mToken : mParent.mToken, mEmbeddedID, requestCode, new Intent[] { data }, null, flags, null, UserHandle.myUserId());
        return target != null ? new PendingIntent(target) : null;
    } catch (RemoteException e) {
    // Empty
    }
    return null;
}
Body of Second Method:
{
    String packageName = getPackageName();
    try {
        data.prepareToLeaveProcess(this);
        IIntentSender target = ActivityManagerNative.getDefault().getIntentSender(ActivityManager.INTENT_SENDER_ACTIVITY_RESULT, packageName, mParent == null ? mToken : mParent.mToken, mEmbeddedID, requestCode, new Intent[] { data }, null, flags, null, UserHandle.myUserId());
        return target != null ? new PendingIntent(target) : null;
    } catch (RemoteException e) {
    // Empty
    }
    return null;
}
------------------------
Find a silently evolved API code:android.widget.TextView.performAccessibilityActionInternal:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Performs an accessibility action after it has been offered to the
 * delegate.
 *
 * @hide
 */

Body of Frist Method:
{
    if (mEditor != null && mEditor.mProcessTextIntentActionsHandler.performAccessibilityAction(action)) {
        return true;
    }
    switch(action) {
        case AccessibilityNodeInfo.ACTION_CLICK:
            {
                boolean handled = false;
                // Simulate View.onTouchEvent for an ACTION_UP event.
                if (isClickable() || isLongClickable()) {
                    if (isFocusable() && !isFocused()) {
                        requestFocus();
                    }
                    performClick();
                    handled = true;
                }
                // Simulate TextView.onTouchEvent for an ACTION_UP event.
                if ((mMovement != null || onCheckIsTextEditor()) && isEnabled() && mText instanceof Spannable && mLayout != null && (isTextEditable() || isTextSelectable()) && isFocused()) {
                    // Show the IME, except when selecting in read-only text.
                    final InputMethodManager imm = InputMethodManager.peekInstance();
                    viewClicked(imm);
                    if (!isTextSelectable() && mEditor.mShowSoftInputOnFocus && imm != null) {
                        handled |= imm.showSoftInput(this, 0);
                    }
                }
                return handled;
            }
        case AccessibilityNodeInfo.ACTION_COPY:
            {
                if (isFocused() && canCopy()) {
                    if (onTextContextMenuItem(ID_COPY)) {
                        return true;
                    }
                }
            }
            return false;
        case AccessibilityNodeInfo.ACTION_PASTE:
            {
                if (isFocused() && canPaste()) {
                    if (onTextContextMenuItem(ID_PASTE)) {
                        return true;
                    }
                }
            }
            return false;
        case AccessibilityNodeInfo.ACTION_CUT:
            {
                if (isFocused() && canCut()) {
                    if (onTextContextMenuItem(ID_CUT)) {
                        return true;
                    }
                }
            }
            return false;
        case AccessibilityNodeInfo.ACTION_SET_SELECTION:
            {
                ensureIterableTextForAccessibilitySelectable();
                CharSequence text = getIterableTextForAccessibility();
                if (text == null) {
                    return false;
                }
                final int start = (arguments != null) ? arguments.getInt(AccessibilityNodeInfo.ACTION_ARGUMENT_SELECTION_START_INT, -1) : -1;
                final int end = (arguments != null) ? arguments.getInt(AccessibilityNodeInfo.ACTION_ARGUMENT_SELECTION_END_INT, -1) : -1;
                if ((getSelectionStart() != start || getSelectionEnd() != end)) {
                    // No arguments clears the selection.
                    if (start == end && end == -1) {
                        Selection.removeSelection((Spannable) text);
                        return true;
                    }
                    if (start >= 0 && start <= end && end <= text.length()) {
                        Selection.setSelection((Spannable) text, start, end);
                        // Make sure selection mode is engaged.
                        if (mEditor != null) {
                            mEditor.startSelectionActionMode();
                        }
                        return true;
                    }
                }
            }
            return false;
        case AccessibilityNodeInfo.ACTION_NEXT_AT_MOVEMENT_GRANULARITY:
        case AccessibilityNodeInfo.ACTION_PREVIOUS_AT_MOVEMENT_GRANULARITY:
            {
                ensureIterableTextForAccessibilitySelectable();
                return super.performAccessibilityActionInternal(action, arguments);
            }
        case ACCESSIBILITY_ACTION_SHARE:
            {
                if (isFocused() && canShare()) {
                    if (onTextContextMenuItem(ID_SHARE)) {
                        return true;
                    }
                }
            }
            return false;
        default:
            {
                return super.performAccessibilityActionInternal(action, arguments);
            }
    }
}
Body of Second Method:
{
    if (mEditor != null && mEditor.mProcessTextIntentActionsHandler.performAccessibilityAction(action)) {
        return true;
    }
    switch(action) {
        case AccessibilityNodeInfo.ACTION_CLICK:
            {
                return performAccessibilityActionClick(arguments);
            }
        case AccessibilityNodeInfo.ACTION_COPY:
            {
                if (isFocused() && canCopy()) {
                    if (onTextContextMenuItem(ID_COPY)) {
                        return true;
                    }
                }
            }
            return false;
        case AccessibilityNodeInfo.ACTION_PASTE:
            {
                if (isFocused() && canPaste()) {
                    if (onTextContextMenuItem(ID_PASTE)) {
                        return true;
                    }
                }
            }
            return false;
        case AccessibilityNodeInfo.ACTION_CUT:
            {
                if (isFocused() && canCut()) {
                    if (onTextContextMenuItem(ID_CUT)) {
                        return true;
                    }
                }
            }
            return false;
        case AccessibilityNodeInfo.ACTION_SET_SELECTION:
            {
                ensureIterableTextForAccessibilitySelectable();
                CharSequence text = getIterableTextForAccessibility();
                if (text == null) {
                    return false;
                }
                final int start = (arguments != null) ? arguments.getInt(AccessibilityNodeInfo.ACTION_ARGUMENT_SELECTION_START_INT, -1) : -1;
                final int end = (arguments != null) ? arguments.getInt(AccessibilityNodeInfo.ACTION_ARGUMENT_SELECTION_END_INT, -1) : -1;
                if ((getSelectionStart() != start || getSelectionEnd() != end)) {
                    // No arguments clears the selection.
                    if (start == end && end == -1) {
                        Selection.removeSelection((Spannable) text);
                        return true;
                    }
                    if (start >= 0 && start <= end && end <= text.length()) {
                        Selection.setSelection((Spannable) text, start, end);
                        // Make sure selection mode is engaged.
                        if (mEditor != null) {
                            mEditor.startSelectionActionMode();
                        }
                        return true;
                    }
                }
            }
            return false;
        case AccessibilityNodeInfo.ACTION_NEXT_AT_MOVEMENT_GRANULARITY:
        case AccessibilityNodeInfo.ACTION_PREVIOUS_AT_MOVEMENT_GRANULARITY:
            {
                ensureIterableTextForAccessibilitySelectable();
                return super.performAccessibilityActionInternal(action, arguments);
            }
        case ACCESSIBILITY_ACTION_SHARE:
            {
                if (isFocused() && canShare()) {
                    if (onTextContextMenuItem(ID_SHARE)) {
                        return true;
                    }
                }
            }
            return false;
        case AccessibilityNodeInfo.ACTION_SET_TEXT:
            {
                if (!isEnabled() || (mBufferType != BufferType.EDITABLE)) {
                    return false;
                }
                CharSequence text = (arguments != null) ? arguments.getCharSequence(AccessibilityNodeInfo.ACTION_ARGUMENT_SET_TEXT_CHARSEQUENCE) : null;
                setText(text);
                if (mText != null) {
                    int updatedTextLength = mText.length();
                    if (updatedTextLength > 0) {
                        Selection.setSelection((Spannable) mText, updatedTextLength);
                    }
                }
            }
            return true;
        default:
            {
                return super.performAccessibilityActionInternal(action, arguments);
            }
    }
}
------------------------
Find a silently evolved API code:android.text.TextLine.draw:COMMENT
Method Modifier: default     hidden      
Comment:/**
 * Renders the TextLine.
 *
 * @param c the canvas to render on
 * @param x the leading margin position
 * @param top the top of the line
 * @param y the baseline
 * @param bottom the bottom of the line
 */

Body of Frist Method:
{
    if (!mHasTabs) {
        if (mDirections == Layout.DIRS_ALL_LEFT_TO_RIGHT) {
            drawRun(c, 0, mLen, false, x, top, y, bottom, false);
            return;
        }
        if (mDirections == Layout.DIRS_ALL_RIGHT_TO_LEFT) {
            drawRun(c, 0, mLen, true, x, top, y, bottom, false);
            return;
        }
    }
    float h = 0;
    int[] runs = mDirections.mDirections;
    RectF emojiRect = null;
    int lastRunIndex = runs.length - 2;
    for (int i = 0; i < runs.length; i += 2) {
        int runStart = runs[i];
        int runLimit = runStart + (runs[i + 1] & Layout.RUN_LENGTH_MASK);
        if (runLimit > mLen) {
            runLimit = mLen;
        }
        boolean runIsRtl = (runs[i + 1] & Layout.RUN_RTL_FLAG) != 0;
        int segstart = runStart;
        for (int j = mHasTabs ? runStart : runLimit; j <= runLimit; j++) {
            int codept = 0;
            Bitmap bm = null;
            if (mHasTabs && j < runLimit) {
                codept = mChars[j];
                if (codept >= 0xd800 && codept < 0xdc00 && j + 1 < runLimit) {
                    codept = Character.codePointAt(mChars, j);
                    if (codept >= Layout.MIN_EMOJI && codept <= Layout.MAX_EMOJI) {
                        bm = Layout.EMOJI_FACTORY.getBitmapFromAndroidPua(codept);
                    } else if (codept > 0xffff) {
                        ++j;
                        continue;
                    }
                }
            }
            if (j == runLimit || codept == '\t' || bm != null) {
                h += drawRun(c, segstart, j, runIsRtl, x + h, top, y, bottom, i != lastRunIndex || j != mLen);
                if (codept == '\t') {
                    h = mDir * nextTab(h * mDir);
                } else if (bm != null) {
                    float bmAscent = ascent(j);
                    float bitmapHeight = bm.getHeight();
                    float scale = -bmAscent / bitmapHeight;
                    float width = bm.getWidth() * scale;
                    if (emojiRect == null) {
                        emojiRect = new RectF();
                    }
                    emojiRect.set(x + h, y + bmAscent, x + h + width, y);
                    c.drawBitmap(bm, null, emojiRect, mPaint);
                    h += width;
                    j++;
                }
                segstart = j + 1;
            }
        }
    }
}
Body of Second Method:
{
    if (!mHasTabs) {
        if (mDirections == Layout.DIRS_ALL_LEFT_TO_RIGHT) {
            drawRun(c, 0, mLen, false, x, top, y, bottom, false);
            return;
        }
        if (mDirections == Layout.DIRS_ALL_RIGHT_TO_LEFT) {
            drawRun(c, 0, mLen, true, x, top, y, bottom, false);
            return;
        }
    }
    float h = 0;
    int[] runs = mDirections.mDirections;
    int lastRunIndex = runs.length - 2;
    for (int i = 0; i < runs.length; i += 2) {
        int runStart = runs[i];
        int runLimit = runStart + (runs[i + 1] & Layout.RUN_LENGTH_MASK);
        if (runLimit > mLen) {
            runLimit = mLen;
        }
        boolean runIsRtl = (runs[i + 1] & Layout.RUN_RTL_FLAG) != 0;
        int segstart = runStart;
        for (int j = mHasTabs ? runStart : runLimit; j <= runLimit; j++) {
            int codept = 0;
            if (mHasTabs && j < runLimit) {
                codept = mChars[j];
                if (codept >= 0xD800 && codept < 0xDC00 && j + 1 < runLimit) {
                    codept = Character.codePointAt(mChars, j);
                    if (codept > 0xFFFF) {
                        ++j;
                        continue;
                    }
                }
            }
            if (j == runLimit || codept == '\t') {
                h += drawRun(c, segstart, j, runIsRtl, x + h, top, y, bottom, i != lastRunIndex || j != mLen);
                if (codept == '\t') {
                    h = mDir * nextTab(h * mDir);
                }
                segstart = j + 1;
            }
        }
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiManager.disconnect:COMMENT
Method Modifier: public      
Comment:/**
 * Disassociate from the currently active access point. This may result
 * in the asynchronous delivery of state change events.
 * @return {@code true} if the operation succeeded
 */

Body of Frist Method:
{
    try {
        mService.disconnect();
        return true;
    } catch (RemoteException e) {
        return false;
    }
}
Body of Second Method:
{
    try {
        mService.disconnect();
        return true;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.app.Instrumentation.execStartActivityFromAppTask:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Special version!
 * @hide
 */

Body of Frist Method:
{
    IApplicationThread whoThread = (IApplicationThread) contextThread;
    if (mActivityMonitors != null) {
        synchronized (mSync) {
            final int N = mActivityMonitors.size();
            for (int i = 0; i < N; i++) {
                final ActivityMonitor am = mActivityMonitors.get(i);
                if (am.match(who, null, intent)) {
                    am.mHits++;
                    if (am.isBlocking()) {
                        return;
                    }
                    break;
                }
            }
        }
    }
    try {
        intent.migrateExtraStreamToClipData();
        intent.prepareToLeaveProcess();
        int result = appTask.startActivity(whoThread.asBinder(), who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), options);
        checkStartActivityResult(result, intent);
    } catch (RemoteException e) {
        throw new RuntimeException("Failure from system", e);
    }
    return;
}
Body of Second Method:
{
    IApplicationThread whoThread = (IApplicationThread) contextThread;
    if (mActivityMonitors != null) {
        synchronized (mSync) {
            final int N = mActivityMonitors.size();
            for (int i = 0; i < N; i++) {
                final ActivityMonitor am = mActivityMonitors.get(i);
                if (am.match(who, null, intent)) {
                    am.mHits++;
                    if (am.isBlocking()) {
                        return;
                    }
                    break;
                }
            }
        }
    }
    try {
        intent.migrateExtraStreamToClipData();
        intent.prepareToLeaveProcess(who);
        int result = appTask.startActivity(whoThread.asBinder(), who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), options);
        checkStartActivityResult(result, intent);
    } catch (RemoteException e) {
        throw new RuntimeException("Failure from system", e);
    }
    return;
}
------------------------
Find a silently evolved API code:android.content.pm.LauncherApps.startMainActivity:COMMENT
Method Modifier: public      
Comment:/**
 * Starts a Main activity in the specified profile.
 *
 * @param component The ComponentName of the activity to launch
 * @param user The UserHandle of the profile
 * @param sourceBounds The Rect containing the source bounds of the clicked icon
 * @param opts Options to pass to startActivity
 */

Body of Frist Method:
{
    if (DEBUG) {
        Log.i(TAG, "StartMainActivity " + component + " " + user.getIdentifier());
    }
    try {
        mService.startActivityAsUser(component, sourceBounds, opts, user);
    } catch (RemoteException re) {
    // Oops!
    }
}
Body of Second Method:
{
    if (DEBUG) {
        Log.i(TAG, "StartMainActivity " + component + " " + user.getIdentifier());
    }
    try {
        mService.startActivityAsUser(component, sourceBounds, opts, user);
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.content.ClipboardManager.hasText:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * @deprecated Use {@link #hasPrimaryClip()} instead.
 */

Body of Frist Method:
{
    try {
        return getService().hasClipboardText(mContext.getOpPackageName());
    } catch (RemoteException e) {
        return false;
    }
}
Body of Second Method:
{
    try {
        return getService().hasClipboardText(mContext.getOpPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiManager.getAggressiveHandover:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the WiFi Handover aggressiveness.This is used by settings
 * to decide what to show within the picker.
 * @hide
 */

Body of Frist Method:
{
    try {
        return mService.getAggressiveHandover();
    } catch (RemoteException e) {
        return 0;
    }
}
Body of Second Method:
{
    try {
        return mService.getAggressiveHandover();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.telephony.SignalStrength.getLevel:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve an abstract level value for the overall signal strength.
 *
 * @return a single integer from 0 to 4 representing the general signal quality.
 * This may take into account many different radio technology inputs.
 * 0 represents very poor signal strength
 * while 4 represents a very strong signal strength.
 */

Body of Frist Method:
{
    int level;
    if (isGsm) {
        level = getLteLevel();
        if (level == SIGNAL_STRENGTH_NONE_OR_UNKNOWN) {
            level = getGsmLevel();
        }
    } else {
        int cdmaLevel = getCdmaLevel();
        int evdoLevel = getEvdoLevel();
        if (evdoLevel == SIGNAL_STRENGTH_NONE_OR_UNKNOWN) {
            /* We don't know evdo, use cdma */
            level = cdmaLevel;
        } else if (cdmaLevel == SIGNAL_STRENGTH_NONE_OR_UNKNOWN) {
            /* We don't know cdma, use evdo */
            level = evdoLevel;
        } else {
            /* We know both, use the lowest level */
            level = cdmaLevel < evdoLevel ? cdmaLevel : evdoLevel;
        }
    }
    if (DBG)
        log("getLevel=" + level);
    return level;
}
Body of Second Method:
{
    int level = 0;
    if (isGsm) {
        level = getLteLevel();
        if (level == SIGNAL_STRENGTH_NONE_OR_UNKNOWN) {
            level = getTdScdmaLevel();
            if (level == SIGNAL_STRENGTH_NONE_OR_UNKNOWN) {
                level = getGsmLevel();
            }
        }
    } else {
        int cdmaLevel = getCdmaLevel();
        int evdoLevel = getEvdoLevel();
        if (evdoLevel == SIGNAL_STRENGTH_NONE_OR_UNKNOWN) {
            /* We don't know evdo, use cdma */
            level = cdmaLevel;
        } else if (cdmaLevel == SIGNAL_STRENGTH_NONE_OR_UNKNOWN) {
            /* We don't know cdma, use evdo */
            level = evdoLevel;
        } else {
            /* We know both, use the lowest level */
            level = cdmaLevel < evdoLevel ? cdmaLevel : evdoLevel;
        }
    }
    if (DBG)
        log("getLevel=" + level);
    return level;
}
------------------------
Find a silently evolved API code:android.app.ActivityManager.setProcessMemoryTrimLevel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets the memory trim mode for a process and schedules a memory trim operation.
 *
 * <p><b>Note: this method is only intended for testing framework.</b></p>
 *
 * @return Returns true if successful.
 * @hide
 */

Body of Frist Method:
{
    try {
        return ActivityManagerNative.getDefault().setProcessMemoryTrimLevel(process, userId, level);
    } catch (RemoteException e) {
        return false;
    }
}
Body of Second Method:
{
    try {
        return ActivityManagerNative.getDefault().setProcessMemoryTrimLevel(process, userId, level);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.net.TrafficStats.getDataLayerSnapshotForUid:COMMENT
Method Modifier: private     static      
Comment:/**
 * Return detailed {@link NetworkStats} for the current UID. Requires no
 * special permission.
 */

Body of Frist Method:
{
    // TODO: take snapshot locally, since proc file is now visible
    final int uid = android.os.Process.myUid();
    try {
        return getStatsService().getDataLayerSnapshotForUid(uid);
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}
Body of Second Method:
{
    // TODO: take snapshot locally, since proc file is now visible
    final int uid = android.os.Process.myUid();
    try {
        return getStatsService().getDataLayerSnapshotForUid(uid);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.media.MediaDrm.CryptoSession.decrypt:COMMENT
Method Modifier: public      
Comment:/**
 * Decrypt data using the CryptoSessions's cipher algorithm
 *
 * @param keyid specifies which key to use
 * @param input the data to encrypt
 * @param iv the initialization vector to use for the cipher
 */

Body of Frist Method:
{
    return decryptNative(mDrm, mSessionId, keyid, input, iv);
}
Body of Second Method:
{
    return decryptNative(MediaDrm.this, mSessionId, keyid, input, iv);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothAdapter.isPeripheralModeSupported:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns whether peripheral mode is supported.
 *
 * @hide
 */

Body of Frist Method:
{
    if (getState() != STATE_ON)
        return false;
    try {
        return mService.isPeripheralModeSupported();
    } catch (RemoteException e) {
        Log.e(TAG, "failed to get peripheral mode capability: ", e);
    }
    return false;
}
Body of Second Method:
{
    if (getState() != STATE_ON)
        return false;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.isPeripheralModeSupported();
    } catch (RemoteException e) {
        Log.e(TAG, "failed to get peripheral mode capability: ", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}
------------------------
Find a silently evolved API code:android.telephony.TelephonyManager.getMsisdn:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns the MSISDN string.
 * for a GSM phone. Return null if it is unavailable.
 * <p>
 * Requires Permission:
 * {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}
 *
 * @hide
 */

Body of Frist Method:
{
    return getMsisdn(getDefaultSubscription());
}
Body of Second Method:
{
    return getMsisdn(getSubId());
}
------------------------
Find a silently evolved API code:android.media.AudioManager.registerAudioPolicy:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 * Register the given {@link AudioPolicy}.
 * This call is synchronous and blocks until the registration process successfully completed
 * or failed to complete.
 * @param policy the non-null {@link AudioPolicy} to register.
 * @return {@link #ERROR} if there was an error communicating with the registration service
 * or if the user doesn't have the required
 * {@link android.Manifest.permission#MODIFY_AUDIO_ROUTING} permission,
 * {@link #SUCCESS} otherwise.
 */

Body of Frist Method:
{
    if (policy == null) {
        throw new IllegalArgumentException("Illegal null AudioPolicy argument");
    }
    IAudioService service = getService();
    try {
        String regId = service.registerAudioPolicy(policy.getConfig(), policy.cb(), policy.hasFocusListener());
        if (regId == null) {
            return ERROR;
        } else {
            policy.setRegistration(regId);
        }
    // successful registration
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in registerAudioPolicyAsync()", e);
        return ERROR;
    }
    return SUCCESS;
}
Body of Second Method:
{
    if (policy == null) {
        throw new IllegalArgumentException("Illegal null AudioPolicy argument");
    }
    IAudioService service = getService();
    try {
        String regId = service.registerAudioPolicy(policy.getConfig(), policy.cb(), policy.hasFocusListener());
        if (regId == null) {
            return ERROR;
        } else {
            policy.setRegistration(regId);
        }
    // successful registration
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
    return SUCCESS;
}
------------------------
Find a silently evolved API code:android.location.Location.setAccuracy:COMMENT
Method Modifier: public      
Comment:/**
 * Set the estimated accuracy of this location, meters.
 *
 * <p>See {@link #getAccuracy} for the definition of accuracy.
 *
 * <p>Following this call {@link #hasAccuracy} will return true.
 */

Body of Frist Method:
{
    mAccuracy = accuracy;
    mHasAccuracy = true;
}
Body of Second Method:
{
    mAccuracy = accuracy;
    mFieldsMask |= HAS_ACCURACY_MASK;
}
------------------------
Find a silently evolved API code:android.app.Instrumentation.checkStartActivityResult:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (res >= ActivityManager.START_SUCCESS) {
        return;
    }
    switch(res) {
        case ActivityManager.START_INTENT_NOT_RESOLVED:
        case ActivityManager.START_CLASS_NOT_FOUND:
            if (intent instanceof Intent && ((Intent) intent).getComponent() != null)
                throw new ActivityNotFoundException("Unable to find explicit activity class " + ((Intent) intent).getComponent().toShortString() + "; have you declared this activity in your AndroidManifest.xml?");
            throw new ActivityNotFoundException("No Activity found to handle " + intent);
        case ActivityManager.START_PERMISSION_DENIED:
            throw new SecurityException("Not allowed to start activity " + intent);
        case ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT:
            throw new AndroidRuntimeException("FORWARD_RESULT_FLAG used while also requesting a result");
        case ActivityManager.START_NOT_ACTIVITY:
            throw new IllegalArgumentException("PendingIntent is not an activity");
        case ActivityManager.START_NOT_VOICE_COMPATIBLE:
            throw new SecurityException("Starting under voice control not allowed for: " + intent);
        case ActivityManager.START_NOT_CURRENT_USER_ACTIVITY:
            // Fail silently for this case so we don't break current apps.
            // TODO(b/22929608): Instead of failing silently or throwing an exception,
            // we should properly position the activity in the stack (i.e. behind all current
            // user activity/task) and not change the positioning of stacks.
            Log.e(TAG, "Not allowed to start background user activity that shouldn't be displayed" + " for all users. Failing silently...");
            break;
        default:
            throw new AndroidRuntimeException("Unknown error code " + res + " when starting " + intent);
    }
}
Body of Second Method:
{
    if (res >= ActivityManager.START_SUCCESS) {
        return;
    }
    switch(res) {
        case ActivityManager.START_INTENT_NOT_RESOLVED:
        case ActivityManager.START_CLASS_NOT_FOUND:
            if (intent instanceof Intent && ((Intent) intent).getComponent() != null)
                throw new ActivityNotFoundException("Unable to find explicit activity class " + ((Intent) intent).getComponent().toShortString() + "; have you declared this activity in your AndroidManifest.xml?");
            throw new ActivityNotFoundException("No Activity found to handle " + intent);
        case ActivityManager.START_PERMISSION_DENIED:
            throw new SecurityException("Not allowed to start activity " + intent);
        case ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT:
            throw new AndroidRuntimeException("FORWARD_RESULT_FLAG used while also requesting a result");
        case ActivityManager.START_NOT_ACTIVITY:
            throw new IllegalArgumentException("PendingIntent is not an activity");
        case ActivityManager.START_NOT_VOICE_COMPATIBLE:
            throw new SecurityException("Starting under voice control not allowed for: " + intent);
        case ActivityManager.START_VOICE_NOT_ACTIVE_SESSION:
            throw new IllegalStateException("Session calling startVoiceActivity does not match active session");
        case ActivityManager.START_VOICE_HIDDEN_SESSION:
            throw new IllegalStateException("Cannot start voice activity on a hidden session");
        case ActivityManager.START_CANCELED:
            throw new AndroidRuntimeException("Activity could not be started for " + intent);
        default:
            throw new AndroidRuntimeException("Unknown error code " + res + " when starting " + intent);
    }
}
------------------------
Find a silently evolved API code:android.widget.Switch.stopDrag:COMMENT
Method Modifier: private     
Comment:/**
 * Called from onTouchEvent to end a drag operation.
 *
 * @param ev Event that triggered the end of drag mode - ACTION_UP or ACTION_CANCEL
 */

Body of Frist Method:
{
    mTouchMode = TOUCH_MODE_IDLE;
    // Commit the change if the event is up and not canceled and the switch
    // has not been disabled during the drag.
    final boolean commitChange = ev.getAction() == MotionEvent.ACTION_UP && isEnabled();
    final boolean oldState = isChecked();
    final boolean newState;
    if (commitChange) {
        mVelocityTracker.computeCurrentVelocity(1000);
        final float xvel = mVelocityTracker.getXVelocity();
        if (Math.abs(xvel) > mMinFlingVelocity) {
            newState = isLayoutRtl() ? (xvel < 0) : (xvel > 0);
        } else {
            newState = getTargetCheckedState();
        }
    } else {
        newState = oldState;
    }
    if (newState != oldState) {
        playSoundEffect(SoundEffectConstants.CLICK);
        setChecked(newState);
    }
    cancelSuperTouch(ev);
}
Body of Second Method:
{
    mTouchMode = TOUCH_MODE_IDLE;
    // Commit the change if the event is up and not canceled and the switch
    // has not been disabled during the drag.
    final boolean commitChange = ev.getAction() == MotionEvent.ACTION_UP && isEnabled();
    final boolean oldState = isChecked();
    final boolean newState;
    if (commitChange) {
        mVelocityTracker.computeCurrentVelocity(1000);
        final float xvel = mVelocityTracker.getXVelocity();
        if (Math.abs(xvel) > mMinFlingVelocity) {
            newState = isLayoutRtl() ? (xvel < 0) : (xvel > 0);
        } else {
            newState = getTargetCheckedState();
        }
    } else {
        newState = oldState;
    }
    if (newState != oldState) {
        playSoundEffect(SoundEffectConstants.CLICK);
    }
    // Always call setChecked so that the thumb is moved back to the correct edge
    setChecked(newState);
    cancelSuperTouch(ev);
}
------------------------
Find a silently evolved API code:android.app.AlarmManager.setWindow:COMMENT
Method Modifier: public      
Comment:/**
 * Schedule an alarm to be delivered within a given window of time.  This method
 * is similar to {@link #set(int, long, PendingIntent)}, but allows the
 * application to precisely control the degree to which its delivery might be
 * adjusted by the OS. This method allows an application to take advantage of the
 * battery optimizations that arise from delivery batching even when it has
 * modest timeliness requirements for its alarms.
 *
 * <p>
 * This method can also be used to achieve strict ordering guarantees among
 * multiple alarms by ensuring that the windows requested for each alarm do
 * not intersect.
 *
 * <p>
 * When precise delivery is not required, applications should use the standard
 * {@link #set(int, long, PendingIntent)} method.  This will give the OS the most
 * flexibility to minimize wakeups and battery use.  For alarms that must be delivered
 * at precisely-specified times with no acceptable variation, applications can use
 * {@link #setExact(int, long, PendingIntent)}.
 *
 * @param type One of {@link #ELAPSED_REALTIME}, {@link #ELAPSED_REALTIME_WAKEUP},
 * {@link #RTC}, or {@link #RTC_WAKEUP}.
 * @param windowStartMillis The earliest time, in milliseconds, that the alarm should
 * be delivered, expressed in the appropriate clock's units (depending on the alarm
 * type).
 * @param windowLengthMillis The length of the requested delivery window,
 * in milliseconds.  The alarm will be delivered no later than this many
 * milliseconds after {@code windowStartMillis}.  Note that this parameter
 * is a <i>duration,</i> not the timestamp of the end of the window.
 * @param operation Action to perform when the alarm goes off;
 * typically comes from {@link PendingIntent#getBroadcast
 * IntentSender.getBroadcast()}.
 *
 * @see #set
 * @see #setExact
 * @see #setRepeating
 * @see #cancel
 * @see android.content.Context#sendBroadcast
 * @see android.content.Context#registerReceiver
 * @see android.content.Intent#filterEquals
 * @see #ELAPSED_REALTIME
 * @see #ELAPSED_REALTIME_WAKEUP
 * @see #RTC
 * @see #RTC_WAKEUP
 */

Body of Frist Method:
{
    setImpl(type, windowStartMillis, windowLengthMillis, 0, 0, operation, null, null);
}
Body of Second Method:
{
    setImpl(type, windowStartMillis, windowLengthMillis, 0, 0, operation, null, null, null, null, null);
}
------------------------
Find a silently evolved API code:android.net.ConnectivityManager.getActiveNetworkInfoForUid:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns details about the currently active default data network
 * for a given uid.  This is for internal use only to avoid spying
 * other apps.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#CONNECTIVITY_INTERNAL}
 *
 * @return a {@link NetworkInfo} object for the current default network
 * for the given uid or {@code null} if no default network is
 * available for the specified uid.
 *
 * {@hide}
 */

Body of Frist Method:
{
    try {
        return mService.getActiveNetworkInfoForUid(uid);
    } catch (RemoteException e) {
        return null;
    }
}
Body of Second Method:
{
    return getActiveNetworkInfoForUid(uid, false);
}
------------------------
Find a silently evolved API code:android.text.SpannableStringBuilder.restoreInvariants:COMMENT
Method Modifier: private     
Comment:// restores binary interval tree invariants after any mutation of span structure

Body of Frist Method:
{
    if (mSpanCount == 0)
        return;
    // This is a simple insertion sort because we expect it to be mostly sorted.
    for (int i = 1; i < mSpanCount; i++) {
        if (mSpanStarts[i] < mSpanStarts[i - 1]) {
            Object span = mSpans[i];
            int start = mSpanStarts[i];
            int end = mSpanEnds[i];
            int flags = mSpanFlags[i];
            int j = i;
            do {
                mSpans[j] = mSpans[j - 1];
                mSpanStarts[j] = mSpanStarts[j - 1];
                mSpanEnds[j] = mSpanEnds[j - 1];
                mSpanFlags[j] = mSpanFlags[j - 1];
                j--;
            } while (j > 0 && start < mSpanStarts[j - 1]);
            mSpans[j] = span;
            mSpanStarts[j] = start;
            mSpanEnds[j] = end;
            mSpanFlags[j] = flags;
            invalidateIndex(j);
        }
    }
    // invariant 2: max is max span end for each node and its descendants
    calcMax(treeRoot());
    // invariant 3: mIndexOfSpan maps spans back to indices
    if (mIndexOfSpan == null) {
        mIndexOfSpan = new IdentityHashMap<Object, Integer>();
    }
    for (int i = mLowWaterMark; i < mSpanCount; i++) {
        Integer existing = mIndexOfSpan.get(mSpans[i]);
        if (existing == null || existing != i) {
            mIndexOfSpan.put(mSpans[i], i);
        }
    }
    mLowWaterMark = Integer.MAX_VALUE;
}
Body of Second Method:
{
    if (mSpanCount == 0)
        return;
    // This is a simple insertion sort because we expect it to be mostly sorted.
    for (int i = 1; i < mSpanCount; i++) {
        if (mSpanStarts[i] < mSpanStarts[i - 1]) {
            Object span = mSpans[i];
            int start = mSpanStarts[i];
            int end = mSpanEnds[i];
            int flags = mSpanFlags[i];
            int insertionOrder = mSpanOrder[i];
            int j = i;
            do {
                mSpans[j] = mSpans[j - 1];
                mSpanStarts[j] = mSpanStarts[j - 1];
                mSpanEnds[j] = mSpanEnds[j - 1];
                mSpanFlags[j] = mSpanFlags[j - 1];
                mSpanOrder[j] = mSpanOrder[j - 1];
                j--;
            } while (j > 0 && start < mSpanStarts[j - 1]);
            mSpans[j] = span;
            mSpanStarts[j] = start;
            mSpanEnds[j] = end;
            mSpanFlags[j] = flags;
            mSpanOrder[j] = insertionOrder;
            invalidateIndex(j);
        }
    }
    // invariant 2: max is max span end for each node and its descendants
    calcMax(treeRoot());
    // invariant 3: mIndexOfSpan maps spans back to indices
    if (mIndexOfSpan == null) {
        mIndexOfSpan = new IdentityHashMap<Object, Integer>();
    }
    for (int i = mLowWaterMark; i < mSpanCount; i++) {
        Integer existing = mIndexOfSpan.get(mSpans[i]);
        if (existing == null || existing != i) {
            mIndexOfSpan.put(mSpans[i], i);
        }
    }
    mLowWaterMark = Integer.MAX_VALUE;
}
------------------------
Find a silently evolved API code:android.preference.EditTextPreference.setText:COMMENT
Method Modifier: public      
Comment:/**
 * Saves the text to the {@link SharedPreferences}.
 *
 * @param text The text to save
 */

Body of Frist Method:
{
    final boolean wasBlocking = shouldDisableDependents();
    mText = text;
    persistString(text);
    final boolean isBlocking = shouldDisableDependents();
    if (isBlocking != wasBlocking) {
        notifyDependencyChange(isBlocking);
    }
}
Body of Second Method:
{
    // Always persist/notify the first time.
    final boolean changed = !TextUtils.equals(mText, text);
    if (changed || !mTextSet) {
        mText = text;
        mTextSet = true;
        persistString(text);
        if (changed) {
            notifyDependencyChange(shouldDisableDependents());
            notifyChanged();
        }
    }
}
------------------------
Find a silently evolved API code:android.appwidget.AppWidgetManager.isBoundWidgetPackage:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (mService == null) {
        return false;
    }
    try {
        return mService.isBoundWidgetPackage(packageName, userId);
    } catch (RemoteException re) {
        throw new RuntimeException("system server dead?", re);
    }
}
Body of Second Method:
{
    if (mService == null) {
        return false;
    }
    try {
        return mService.isBoundWidgetPackage(packageName, userId);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.hardware.fingerprint.FingerprintManager.isHardwareDetected:COMMENT
Method Modifier: public      
Comment:/**
 * Determine if fingerprint hardware is present and functional.
 *
 * @return true if hardware is present and functional, false otherwise.
 */

Body of Frist Method:
{
    if (mService != null) {
        try {
            long deviceId = 0;
            /* TODO: plumb hardware id to FPMS */
            return mService.isHardwareDetected(deviceId, mContext.getOpPackageName());
        } catch (RemoteException e) {
            Log.v(TAG, "Remote exception in isFingerprintHardwareDetected(): ", e);
        }
    } else {
        Log.w(TAG, "isFingerprintHardwareDetected(): Service not connected!");
    }
    return false;
}
Body of Second Method:
{
    if (mService != null) {
        try {
            long deviceId = 0;
            /* TODO: plumb hardware id to FPMS */
            return mService.isHardwareDetected(deviceId, mContext.getOpPackageName());
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    } else {
        Log.w(TAG, "isFingerprintHardwareDetected(): Service not connected!");
    }
    return false;
}
------------------------
Find a silently evolved API code:android.view.inputmethod.BaseInputConnection.setComposingText:COMMENT
Method Modifier: public      
Comment:/**
 * The default implementation places the given text into the editable,
 * replacing any existing composing text.  The new text is marked as
 * in a composing state with the composing style.
 */

Body of Frist Method:
{
    if (DEBUG)
        Log.v(TAG, "setComposingText " + text);
    replaceText(text, newCursorPosition, true);
    mIMM.notifyUserAction();
    return true;
}
Body of Second Method:
{
    if (DEBUG)
        Log.v(TAG, "setComposingText " + text);
    replaceText(text, newCursorPosition, true);
    return true;
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiManager.getDhcpInfo:COMMENT
Method Modifier: public      
Comment:/**
 * Return the DHCP-assigned addresses from the last successful DHCP request,
 * if any.
 * @return the DHCP information
 */

Body of Frist Method:
{
    try {
        return mService.getDhcpInfo();
    } catch (RemoteException e) {
        return null;
    }
}
Body of Second Method:
{
    try {
        return mService.getDhcpInfo();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.net.ConnectivityManager.getActiveLinkProperties:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns the IP information for the current default network.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
 *
 * @return a {@link LinkProperties} object describing the IP info
 * for the current default network, or {@code null} if there
 * is no current default network.
 *
 * {@hide}
 */

Body of Frist Method:
{
    try {
        return mService.getActiveLinkProperties();
    } catch (RemoteException e) {
        return null;
    }
}
Body of Second Method:
{
    try {
        return mService.getActiveLinkProperties();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.net.NetworkScoreManager.registerNetworkScoreCache:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Register a network score cache.
 *
 * @param networkType the type of network this cache can handle. See {@link NetworkKey#type}.
 * @param scoreCache implementation of {@link INetworkScoreCache} to store the scores.
 * @throws SecurityException if the caller does not hold the
 * {@link android.Manifest.permission#BROADCAST_NETWORK_PRIVILEGED} permission.
 * @throws IllegalArgumentException if a score cache is already registered for this type.
 * @hide
 */

Body of Frist Method:
{
    try {
        mService.registerNetworkScoreCache(networkType, scoreCache);
    } catch (RemoteException e) {
    }
}
Body of Second Method:
{
    try {
        mService.registerNetworkScoreCache(networkType, scoreCache);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothAdapter.getProfileConnectionState:COMMENT
Method Modifier: public      
Comment:/**
 * Get the current connection state of a profile.
 * This function can be used to check whether the local Bluetooth adapter
 * is connected to any remote device for a specific profile.
 * Profile can be one of {@link BluetoothProfile#HEALTH}, {@link BluetoothProfile#HEADSET},
 * {@link BluetoothProfile#A2DP}.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}.
 *
 * <p> Return value can be one of
 * {@link BluetoothProfile#STATE_DISCONNECTED},
 * {@link BluetoothProfile#STATE_CONNECTING},
 * {@link BluetoothProfile#STATE_CONNECTED},
 * {@link BluetoothProfile#STATE_DISCONNECTING}
 */

Body of Frist Method:
{
    if (getState() != STATE_ON)
        return BluetoothProfile.STATE_DISCONNECTED;
    try {
        synchronized (mManagerCallback) {
            if (mService != null)
                return mService.getProfileConnectionState(profile);
        }
    } catch (RemoteException e) {
        Log.e(TAG, "getProfileConnectionState:", e);
    }
    return BluetoothProfile.STATE_DISCONNECTED;
}
Body of Second Method:
{
    if (getState() != STATE_ON)
        return BluetoothProfile.STATE_DISCONNECTED;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.getProfileConnectionState(profile);
    } catch (RemoteException e) {
        Log.e(TAG, "getProfileConnectionState:", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return BluetoothProfile.STATE_DISCONNECTED;
}
------------------------
Find a silently evolved API code:android.telephony.CarrierConfigManager.notifyConfigChangedForSubId:COMMENT
Method Modifier: public      
Comment:/**
 * Calling this method triggers telephony services to fetch the current carrier configuration.
 * <p>
 * Normally this does not need to be called because the platform reloads config on its own.
 * This should be called by a carrier service app if it wants to update config at an arbitrary
 * moment.
 * </p>
 * <p>Requires that the calling app has carrier privileges.
 * @see #hasCarrierPrivileges
 * <p>
 * This method returns before the reload has completed, and
 * {@link android.service.carrier.CarrierService#onLoadConfig} will be called from an
 * arbitrary thread.
 * </p>
 */

Body of Frist Method:
{
    try {
        getICarrierConfigLoader().notifyConfigChangedForSubId(subId);
    } catch (RemoteException ex) {
        Rlog.e(TAG, "Error reloading config for subId=" + subId + ": " + ex.toString());
    } catch (NullPointerException ex) {
        Rlog.e(TAG, "Error reloading config for subId=" + subId + ": " + ex.toString());
    }
}
Body of Second Method:
{
    try {
        ICarrierConfigLoader loader = getICarrierConfigLoader();
        if (loader == null) {
            Rlog.w(TAG, "Error reloading config for subId=" + subId + " ICarrierConfigLoader is null");
            return;
        }
        loader.notifyConfigChangedForSubId(subId);
    } catch (RemoteException ex) {
        Rlog.e(TAG, "Error reloading config for subId=" + subId + ": " + ex.toString());
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiManager.MulticastLock.release:COMMENT
Method Modifier: public      
Comment:/**
 * Unlocks Wifi Multicast, restoring the filter of packets
 * not addressed specifically to this device and saving power.
 *
 * If this MulticastLock is reference-counted, each call to
 * {@code release} will decrement the reference count, and the
 * multicast packets will only stop being received when the reference
 * count reaches zero.  If the reference count goes below zero (that
 * is, if {@code release} is called a greater number of times than
 * {@link #acquire}), an exception is thrown.
 *
 * If this MulticastLock is not reference-counted, the first call to
 * {@code release} (after the radio was multicast locked using
 * {@link #acquire}) will unlock the multicast, and subsequent calls
 * will be ignored.
 *
 * Note that if any other Wifi Multicast Locks are still outstanding
 * this {@code release} call will not have an immediate effect.  Only
 * when all applications have released all their Multicast Locks will
 * the Multicast filter be turned back on.
 *
 * Also note that when an app exits or crashes all of its Multicast
 * Locks will be automatically released.
 */

Body of Frist Method:
{
    synchronized (mBinder) {
        if (mRefCounted ? (--mRefCount == 0) : (mHeld)) {
            try {
                mService.releaseMulticastLock();
                synchronized (WifiManager.this) {
                    mActiveLockCount--;
                }
            } catch (RemoteException ignore) {
            }
            mHeld = false;
        }
        if (mRefCount < 0) {
            throw new RuntimeException("MulticastLock under-locked " + mTag);
        }
    }
}
Body of Second Method:
{
    synchronized (mBinder) {
        if (mRefCounted ? (--mRefCount == 0) : (mHeld)) {
            try {
                mService.releaseMulticastLock();
                synchronized (WifiManager.this) {
                    mActiveLockCount--;
                }
            } catch (RemoteException e) {
                throw e.rethrowFromSystemServer();
            }
            mHeld = false;
        }
        if (mRefCount < 0) {
            throw new RuntimeException("MulticastLock under-locked " + mTag);
        }
    }
}
------------------------
Find a silently evolved API code:android.os.DropBoxManager.addFile:COMMENT
Method Modifier: public      
Comment:/**
 * Stores the contents of a file, which may be ignored or discarded as with
 * {@link #addText}.
 *
 * @param tag describing the type of entry being stored
 * @param file to read from
 * @param flags describing the data
 * @throws IOException if the file can't be opened
 */

Body of Frist Method:
{
    if (file == null)
        throw new NullPointerException("file == null");
    Entry entry = new Entry(tag, 0, file, flags);
    try {
        mService.add(entry);
    } catch (RemoteException e) {
    // ignore
    } finally {
        entry.close();
    }
}
Body of Second Method:
{
    if (file == null)
        throw new NullPointerException("file == null");
    Entry entry = new Entry(tag, 0, file, flags);
    try {
        mService.add(entry);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    } finally {
        entry.close();
    }
}
------------------------
Find a silently evolved API code:android.os.Bundle.putParcelableList:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * {@hide}
 */

Body of Frist Method:
{
    unparcel();
    mMap.put(key, value);
    mFdsKnown = false;
}
Body of Second Method:
{
    unparcel();
    mMap.put(key, value);
    mFlags &= ~FLAG_HAS_FDS_KNOWN;
}
------------------------
Find a silently evolved API code:android.location.Location.hasSpeed:COMMENT
Method Modifier: public      
Comment:/**
 * True if this location has a speed.
 */

Body of Frist Method:
{
    return mHasSpeed;
}
Body of Second Method:
{
    return (mFieldsMask & HAS_SPEED_MASK) != 0;
}
------------------------
Find a silently evolved API code:android.net.NetworkScoreManager.updateScores:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Update network scores.
 *
 * <p>This may be called at any time to re-score active networks. Scores will generally be
 * updated quickly, but if this method is called too frequently, the scores may be held and
 * applied at a later time.
 *
 * @param networks the networks which have been scored by the scorer.
 * @return whether the update was successful.
 * @throws SecurityException if the caller is not the active scorer.
 */

Body of Frist Method:
{
    try {
        return mService.updateScores(networks);
    } catch (RemoteException e) {
        return false;
    }
}
Body of Second Method:
{
    try {
        return mService.updateScores(networks);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.telephony.ServiceState.setRilDataRadioTechnology:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    this.mRilDataRadioTechnology = rt;
    if (DBG)
        Rlog.d(LOG_TAG, "[ServiceState] setDataRadioTechnology=" + mRilDataRadioTechnology);
}
Body of Second Method:
{
    this.mRilDataRadioTechnology = rt;
    if (VDBG)
        Rlog.d(LOG_TAG, "[ServiceState] setRilDataRadioTechnology=" + mRilDataRadioTechnology);
}
------------------------
Find a silently evolved API code:android.content.res.TypedArray.getFraction:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieves a fractional unit attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 * @param base The base value of this fraction.  In other words, a
 * standard fraction is multiplied by this value.
 * @param pbase The parent base value of this fraction.  In other
 * words, a parent fraction (nn%p) is multiplied by this
 * value.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute fractional value multiplied by the appropriate
 * base value, or defValue if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not a fraction.
 */

Body of Frist Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_FRACTION) {
        return TypedValue.complexToFraction(data[index + AssetManager.STYLE_DATA], base, pbase);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index * AssetManager.STYLE_NUM_ENTRIES, value);
        throw new UnsupportedOperationException("Failed to resolve attribute at index " + index + ": " + value);
    }
    throw new UnsupportedOperationException("Can't convert to fraction: type=0x" + Integer.toHexString(type));
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    final int attrIndex = index;
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_FRACTION) {
        return TypedValue.complexToFraction(data[index + AssetManager.STYLE_DATA], base, pbase);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index, value);
        throw new UnsupportedOperationException("Failed to resolve attribute at index " + attrIndex + ": " + value);
    }
    throw new UnsupportedOperationException("Can't convert value at index " + attrIndex + " to fraction: type=0x" + Integer.toHexString(type));
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiManager.reassociate:COMMENT
Method Modifier: public      
Comment:/**
 * Reconnect to the currently active access point, even if we are already
 * connected. This may result in the asynchronous delivery of state
 * change events.
 * @return {@code true} if the operation succeeded
 */

Body of Frist Method:
{
    try {
        mService.reassociate();
        return true;
    } catch (RemoteException e) {
        return false;
    }
}
Body of Second Method:
{
    try {
        mService.reassociate();
        return true;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.RttManager.ParcelableRttParams.writeToParcel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Implement the Parcelable interface {@hide}
 */

Body of Frist Method:
{
    if (mParams != null) {
        dest.writeInt(mParams.length);
        for (RttParams params : mParams) {
            dest.writeInt(params.deviceType);
            dest.writeInt(params.requestType);
            dest.writeString(params.bssid);
            dest.writeInt(params.channelWidth);
            dest.writeInt(params.frequency);
            dest.writeInt(params.centerFreq0);
            dest.writeInt(params.centerFreq1);
            dest.writeInt(params.numberBurst);
            dest.writeInt(params.interval);
            dest.writeInt(params.numSamplesPerBurst);
            dest.writeInt(params.numRetriesPerMeasurementFrame);
            dest.writeInt(params.numRetriesPerFTMR);
            dest.writeInt(params.LCIRequest ? 1 : 0);
            dest.writeInt(params.LCRRequest ? 1 : 0);
            dest.writeInt(params.burstTimeout);
            dest.writeInt(params.preamble);
            dest.writeInt(params.bandwidth);
        }
    } else {
        dest.writeInt(0);
    }
}
Body of Second Method:
{
    dest.writeInt(mParams.length);
    for (RttParams params : mParams) {
        dest.writeInt(params.deviceType);
        dest.writeInt(params.requestType);
        dest.writeByte(params.secure ? (byte) 1 : 0);
        dest.writeString(params.bssid);
        dest.writeInt(params.channelWidth);
        dest.writeInt(params.frequency);
        dest.writeInt(params.centerFreq0);
        dest.writeInt(params.centerFreq1);
        dest.writeInt(params.numberBurst);
        dest.writeInt(params.interval);
        dest.writeInt(params.numSamplesPerBurst);
        dest.writeInt(params.numRetriesPerMeasurementFrame);
        dest.writeInt(params.numRetriesPerFTMR);
        dest.writeInt(params.LCIRequest ? 1 : 0);
        dest.writeInt(params.LCRRequest ? 1 : 0);
        dest.writeInt(params.burstTimeout);
        dest.writeInt(params.preamble);
        dest.writeInt(params.bandwidth);
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothAdapter.getScanMode:COMMENT
Method Modifier: public      
Comment:/**
 * Get the current Bluetooth scan mode of the local Bluetooth adapter.
 * <p>The Bluetooth scan mode determines if the local adapter is
 * connectable and/or discoverable from remote Bluetooth devices.
 * <p>Possible values are:
 * {@link #SCAN_MODE_NONE},
 * {@link #SCAN_MODE_CONNECTABLE},
 * {@link #SCAN_MODE_CONNECTABLE_DISCOVERABLE}.
 * <p>If Bluetooth state is not {@link #STATE_ON}, this API
 * will return {@link #SCAN_MODE_NONE}. After turning on Bluetooth,
 * wait for {@link #ACTION_STATE_CHANGED} with {@link #STATE_ON}
 * to get the updated value.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}
 *
 * @return scan mode
 */

Body of Frist Method:
{
    if (getState() != STATE_ON)
        return SCAN_MODE_NONE;
    try {
        synchronized (mManagerCallback) {
            if (mService != null)
                return mService.getScanMode();
        }
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return SCAN_MODE_NONE;
}
Body of Second Method:
{
    if (getState() != STATE_ON)
        return SCAN_MODE_NONE;
    try {
        mServiceLock.readLock().lock();
        if (mService != null)
            return mService.getScanMode();
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return SCAN_MODE_NONE;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothGatt.readDescriptor:COMMENT
Method Modifier: public      
Comment:/**
 * Reads the value for a given descriptor from the associated remote device.
 *
 * <p>Once the read operation has been completed, the
 * {@link BluetoothGattCallback#onDescriptorRead} callback is
 * triggered, signaling the result of the operation.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param descriptor Descriptor value to read from the remote device
 * @return true, if the read operation was initiated successfully
 */

Body of Frist Method:
{
    if (VDBG)
        Log.d(TAG, "readDescriptor() - uuid: " + descriptor.getUuid());
    if (mService == null || mClientIf == 0)
        return false;
    BluetoothGattCharacteristic characteristic = descriptor.getCharacteristic();
    if (characteristic == null)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusy) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.readDescriptor(mClientIf, device.getAddress(), service.getType(), service.getInstanceId(), new ParcelUuid(service.getUuid()), characteristic.getInstanceId(), new ParcelUuid(characteristic.getUuid()), descriptor.getInstanceId(), new ParcelUuid(descriptor.getUuid()), AUTHENTICATION_NONE);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}
Body of Second Method:
{
    if (VDBG)
        Log.d(TAG, "readDescriptor() - uuid: " + descriptor.getUuid());
    if (mService == null || mClientIf == 0)
        return false;
    BluetoothGattCharacteristic characteristic = descriptor.getCharacteristic();
    if (characteristic == null)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusy) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.readDescriptor(mClientIf, device.getAddress(), descriptor.getInstanceId(), AUTHENTICATION_NONE);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}
------------------------
Find a silently evolved API code:android.app.admin.DeviceAdminInfo.getActivityInfo:COMMENT
Method Modifier: public      
Comment:/**
 * Return the raw information about the receiver implementing this
 * device admin.  Do not modify the returned object.
 */

Body of Frist Method:
{
    return mReceiver.activityInfo;
}
Body of Second Method:
{
    return mActivityInfo;
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiManager.clearBlacklist:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Clear the supplicant blacklist
 *
 * This API is used by WifiWatchdogService
 *
 * @return {@code true} if the operation succeeds else {@code false}
 * @hide
 */

Body of Frist Method:
{
    try {
        mService.clearBlacklist();
        return true;
    } catch (RemoteException e) {
        return false;
    }
}
Body of Second Method:
{
    try {
        mService.clearBlacklist();
        return true;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.telephony.PhoneNumberUtils.getDefaultVoiceSubId:COMMENT
Method Modifier: private     static      
Comment:/**
 * Returns Default voice subscription Id.
 */

Body of Frist Method:
{
    return SubscriptionManager.getDefaultVoiceSubId();
}
Body of Second Method:
{
    return SubscriptionManager.getDefaultVoiceSubscriptionId();
}
------------------------
Find a silently evolved API code:android.widget.SimpleMonthView.drawDays:COMMENT
Method Modifier: private     
Comment:/**
 * Draws the month days.
 */

Body of Frist Method:
{
    final TextPaint p = mDayPaint;
    final int headerHeight = mMonthHeight + mDayOfWeekHeight;
    final int rowHeight = mDayHeight;
    final int colWidth = mCellWidth;
    // Text is vertically centered within the row height.
    final float halfLineHeight = (p.ascent() + p.descent()) / 2f;
    int rowCenter = headerHeight + rowHeight / 2;
    for (int day = 1, col = findDayOffset(); day <= mDaysInMonth; day++) {
        final int colCenter = colWidth * col + colWidth / 2;
        final int colCenterRtl;
        if (isLayoutRtl()) {
            colCenterRtl = mPaddedWidth - colCenter;
        } else {
            colCenterRtl = colCenter;
        }
        int stateMask = 0;
        final boolean isDayEnabled = isDayEnabled(day);
        if (isDayEnabled) {
            stateMask |= StateSet.VIEW_STATE_ENABLED;
        }
        final boolean isDayActivated = mActivatedDay == day;
        if (isDayActivated) {
            stateMask |= StateSet.VIEW_STATE_ACTIVATED;
            // Adjust the circle to be centered on the row.
            canvas.drawCircle(colCenterRtl, rowCenter, mDaySelectorRadius, mDaySelectorPaint);
        } else if (mTouchedItem == day) {
            stateMask |= StateSet.VIEW_STATE_PRESSED;
            if (isDayEnabled) {
                // Adjust the circle to be centered on the row.
                canvas.drawCircle(colCenterRtl, rowCenter, mDaySelectorRadius, mDayHighlightPaint);
            }
        }
        final boolean isDayToday = mToday == day;
        final int dayTextColor;
        if (isDayToday && !isDayActivated) {
            dayTextColor = mDaySelectorPaint.getColor();
        } else {
            final int[] stateSet = StateSet.get(stateMask);
            dayTextColor = mDayTextColor.getColorForState(stateSet, 0);
        }
        p.setColor(dayTextColor);
        canvas.drawText(mDayFormatter.format(day), colCenterRtl, rowCenter - halfLineHeight, p);
        col++;
        if (col == DAYS_IN_WEEK) {
            col = 0;
            rowCenter += rowHeight;
        }
    }
}
Body of Second Method:
{
    final TextPaint p = mDayPaint;
    final int headerHeight = mMonthHeight + mDayOfWeekHeight;
    final int rowHeight = mDayHeight;
    final int colWidth = mCellWidth;
    // Text is vertically centered within the row height.
    final float halfLineHeight = (p.ascent() + p.descent()) / 2f;
    int rowCenter = headerHeight + rowHeight / 2;
    for (int day = 1, col = findDayOffset(); day <= mDaysInMonth; day++) {
        final int colCenter = colWidth * col + colWidth / 2;
        final int colCenterRtl;
        if (isLayoutRtl()) {
            colCenterRtl = mPaddedWidth - colCenter;
        } else {
            colCenterRtl = colCenter;
        }
        int stateMask = 0;
        final boolean isDayEnabled = isDayEnabled(day);
        if (isDayEnabled) {
            stateMask |= StateSet.VIEW_STATE_ENABLED;
        }
        final boolean isDayActivated = mActivatedDay == day;
        final boolean isDayHighlighted = mHighlightedDay == day;
        if (isDayActivated) {
            stateMask |= StateSet.VIEW_STATE_ACTIVATED;
            // Adjust the circle to be centered on the row.
            final Paint paint = isDayHighlighted ? mDayHighlightSelectorPaint : mDaySelectorPaint;
            canvas.drawCircle(colCenterRtl, rowCenter, mDaySelectorRadius, paint);
        } else if (isDayHighlighted) {
            stateMask |= StateSet.VIEW_STATE_PRESSED;
            if (isDayEnabled) {
                // Adjust the circle to be centered on the row.
                canvas.drawCircle(colCenterRtl, rowCenter, mDaySelectorRadius, mDayHighlightPaint);
            }
        }
        final boolean isDayToday = mToday == day;
        final int dayTextColor;
        if (isDayToday && !isDayActivated) {
            dayTextColor = mDaySelectorPaint.getColor();
        } else {
            final int[] stateSet = StateSet.get(stateMask);
            dayTextColor = mDayTextColor.getColorForState(stateSet, 0);
        }
        p.setColor(dayTextColor);
        canvas.drawText(mDayFormatter.format(day), colCenterRtl, rowCenter - halfLineHeight, p);
        col++;
        if (col == DAYS_IN_WEEK) {
            col = 0;
            rowCenter += rowHeight;
        }
    }
}
------------------------
Find a silently evolved API code:android.content.ClipData.Item.coerceToText:COMMENT
Method Modifier: public      
Comment:// BEGIN_INCLUDE(coerceToText)

Body of Frist Method:
{
    // If this Item has an explicit textual value, simply return that.
    CharSequence text = getText();
    if (text != null) {
        return text;
    }
    // If this Item has a URI value, try using that.
    Uri uri = getUri();
    if (uri != null) {
        // First see if the URI can be opened as a plain text stream
        // (of any sub-type).  If so, this is the best textual
        // representation for it.
        FileInputStream stream = null;
        try {
            // Ask for a stream of the desired type.
            AssetFileDescriptor descr = context.getContentResolver().openTypedAssetFileDescriptor(uri, "text/*", null);
            stream = descr.createInputStream();
            InputStreamReader reader = new InputStreamReader(stream, "UTF-8");
            // Got it...  copy the stream into a local string and return it.
            StringBuilder builder = new StringBuilder(128);
            char[] buffer = new char[8192];
            int len;
            while ((len = reader.read(buffer)) > 0) {
                builder.append(buffer, 0, len);
            }
            return builder.toString();
        } catch (FileNotFoundException e) {
        // Unable to open content URI as text...  not really an
        // error, just something to ignore.
        } catch (IOException e) {
            // Something bad has happened.
            Log.w("ClippedData", "Failure loading text", e);
            return e.toString();
        } finally {
            if (stream != null) {
                try {
                    stream.close();
                } catch (IOException e) {
                }
            }
        }
        // probably serves fairly well as a textual representation.
        return uri.toString();
    }
    // Finally, if all we have is an Intent, then we can just turn that
    // into text.  Not the most user-friendly thing, but it's something.
    Intent intent = getIntent();
    if (intent != null) {
        return intent.toUri(Intent.URI_INTENT_SCHEME);
    }
    // Shouldn't get here, but just in case...
    return "";
}
Body of Second Method:
{
    // If this Item has an explicit textual value, simply return that.
    CharSequence text = getText();
    if (text != null) {
        return text;
    }
    // If this Item has a URI value, try using that.
    Uri uri = getUri();
    if (uri != null) {
        // First see if the URI can be opened as a plain text stream
        // (of any sub-type).  If so, this is the best textual
        // representation for it.
        FileInputStream stream = null;
        try {
            // Ask for a stream of the desired type.
            AssetFileDescriptor descr = context.getContentResolver().openTypedAssetFileDescriptor(uri, "text/*", null);
            stream = descr.createInputStream();
            InputStreamReader reader = new InputStreamReader(stream, "UTF-8");
            // Got it...  copy the stream into a local string and return it.
            StringBuilder builder = new StringBuilder(128);
            char[] buffer = new char[8192];
            int len;
            while ((len = reader.read(buffer)) > 0) {
                builder.append(buffer, 0, len);
            }
            return builder.toString();
        } catch (FileNotFoundException e) {
        // Unable to open content URI as text...  not really an
        // error, just something to ignore.
        } catch (IOException e) {
            // Something bad has happened.
            Log.w("ClipData", "Failure loading text", e);
            return e.toString();
        } finally {
            if (stream != null) {
                try {
                    stream.close();
                } catch (IOException e) {
                }
            }
        }
        // probably serves fairly well as a textual representation.
        return uri.toString();
    }
    // Finally, if all we have is an Intent, then we can just turn that
    // into text.  Not the most user-friendly thing, but it's something.
    Intent intent = getIntent();
    if (intent != null) {
        return intent.toUri(Intent.URI_INTENT_SCHEME);
    }
    // Shouldn't get here, but just in case...
    return "";
}
------------------------
Find a silently evolved API code:android.app.BackStackRecord.calculateFragments:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Finds the first removed fragment and last added fragments when going forward.
 * If none of the fragments have transitions, then both lists will be empty.
 *
 * @param firstOutFragments The list of first fragments to be removed, keyed on the
 * container ID. This list will be modified by the method.
 * @param lastInFragments The list of last fragments to be added, keyed on the
 * container ID. This list will be modified by the method.
 */

Body of Frist Method:
{
    if (!mManager.mContainer.onHasView()) {
        // nothing to see, so no transitions
        return;
    }
    Op op = mHead;
    while (op != null) {
        switch(op.cmd) {
            case OP_ADD:
                setLastIn(lastInFragments, op.fragment);
                break;
            case OP_REPLACE:
                {
                    Fragment f = op.fragment;
                    if (mManager.mAdded != null) {
                        for (int i = 0; i < mManager.mAdded.size(); i++) {
                            Fragment old = mManager.mAdded.get(i);
                            if (f == null || old.mContainerId == f.mContainerId) {
                                if (old == f) {
                                    f = null;
                                } else {
                                    setFirstOut(firstOutFragments, old);
                                }
                            }
                        }
                    }
                    setLastIn(lastInFragments, f);
                    break;
                }
            case OP_REMOVE:
                setFirstOut(firstOutFragments, op.fragment);
                break;
            case OP_HIDE:
                setFirstOut(firstOutFragments, op.fragment);
                break;
            case OP_SHOW:
                setLastIn(lastInFragments, op.fragment);
                break;
            case OP_DETACH:
                setFirstOut(firstOutFragments, op.fragment);
                break;
            case OP_ATTACH:
                setLastIn(lastInFragments, op.fragment);
                break;
        }
        op = op.next;
    }
}
Body of Second Method:
{
    if (!mManager.mContainer.onHasView()) {
        // nothing to see, so no transitions
        return;
    }
    Op op = mHead;
    while (op != null) {
        switch(op.cmd) {
            case OP_ADD:
                setLastIn(firstOutFragments, lastInFragments, op.fragment);
                break;
            case OP_REPLACE:
                {
                    Fragment f = op.fragment;
                    if (mManager.mAdded != null) {
                        for (int i = 0; i < mManager.mAdded.size(); i++) {
                            Fragment old = mManager.mAdded.get(i);
                            if (f == null || old.mContainerId == f.mContainerId) {
                                if (old == f) {
                                    f = null;
                                    lastInFragments.remove(old.mContainerId);
                                } else {
                                    setFirstOut(firstOutFragments, lastInFragments, old);
                                }
                            }
                        }
                    }
                    setLastIn(firstOutFragments, lastInFragments, op.fragment);
                    break;
                }
            case OP_REMOVE:
                setFirstOut(firstOutFragments, lastInFragments, op.fragment);
                break;
            case OP_HIDE:
                setFirstOut(firstOutFragments, lastInFragments, op.fragment);
                break;
            case OP_SHOW:
                setLastIn(firstOutFragments, lastInFragments, op.fragment);
                break;
            case OP_DETACH:
                setFirstOut(firstOutFragments, lastInFragments, op.fragment);
                break;
            case OP_ATTACH:
                setLastIn(firstOutFragments, lastInFragments, op.fragment);
                break;
        }
        op = op.next;
    }
}
------------------------
Find a silently evolved API code:android.renderscript.Allocation.resize:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * Resize a 1D allocation.  The contents of the allocation are preserved.
 * If new elements are allocated objects are created with null contents and
 * the new region is otherwise undefined.
 *
 * <p>If the new region is smaller the references of any objects outside the
 * new region will be released.</p>
 *
 * <p>A new type will be created with the new dimension.</p>
 *
 * @param dimX The new size of the allocation.
 *
 * @deprecated RenderScript objects should be immutable once created.  The
 * replacement is to create a new allocation and copy the contents. This
 * function will throw an exception if API 21 or higher is used.
 */

Body of Frist Method:
{
    if (mRS.getApplicationContext().getApplicationInfo().targetSdkVersion >= 21) {
        throw new RSRuntimeException("Resize is not allowed in API 21+.");
    }
    if ((mType.getY() > 0) || (mType.getZ() > 0) || mType.hasFaces() || mType.hasMipmaps()) {
        throw new RSInvalidStateException("Resize only support for 1D allocations at this time.");
    }
    mRS.nAllocationResize1D(getID(mRS), dimX);
    // Necessary because resize is fifoed and update is async.
    mRS.finish();
    long typeID = mRS.nAllocationGetType(getID(mRS));
    mType = new Type(typeID, mRS);
    mType.updateFromNative();
    updateCacheInfo(mType);
}
Body of Second Method:
{
    if (mRS.getApplicationContext().getApplicationInfo().targetSdkVersion >= 21) {
        throw new RSRuntimeException("Resize is not allowed in API 21+.");
    }
    if ((mType.getY() > 0) || (mType.getZ() > 0) || mType.hasFaces() || mType.hasMipmaps()) {
        throw new RSInvalidStateException("Resize only support for 1D allocations at this time.");
    }
    mRS.nAllocationResize1D(getID(mRS), dimX);
    // Necessary because resize is fifoed and update is async.
    mRS.finish();
    long typeID = mRS.nAllocationGetType(getID(mRS));
    // Sets zero the mID so that the finalizer of the old mType value won't
    // destroy the native object that is being reused.
    mType.setID(0);
    mType = new Type(typeID, mRS);
    mType.updateFromNative();
    updateCacheInfo(mType);
}
------------------------
Find a silently evolved API code:android.app.Instrumentation.execStartActivity:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Execute a startActivity call made by the application.  The default
 * implementation takes care of updating any active {@link ActivityMonitor}
 * objects and dispatches this call to the system activity manager; you can
 * override this to watch for the application to start an activity, and
 * modify what happens when it does.
 *
 * <p>This method returns an {@link ActivityResult} object, which you can
 * use when intercepting application calls to avoid performing the start
 * activity action but still return the result the application is
 * expecting.  To do this, override this method to catch the call to start
 * activity so that it returns a new ActivityResult containing the results
 * you would like the application to see, and don't call up to the super
 * class.  Note that an application is only expecting a result if
 * <var>requestCode</var> is &gt;= 0.
 *
 * <p>This method throws {@link android.content.ActivityNotFoundException}
 * if there was no Activity found to run the given Intent.
 *
 * @param who The Context from which the activity is being started.
 * @param contextThread The main thread of the Context from which the activity
 * is being started.
 * @param token Internal token identifying to the system who is starting
 * the activity; may be null.
 * @param target Which activity is performing the start (and thus receiving
 * any result); may be null if this call is not being made
 * from an activity.
 * @param intent The actual Intent to start.
 * @param requestCode Identifier for this request's result; less than zero
 * if the caller is not expecting a result.
 * @param options Addition options.
 *
 * @return To force the return of a particular result, return an
 * ActivityResult object containing the desired data; otherwise
 * return null.  The default implementation always returns null.
 *
 * @throws android.content.ActivityNotFoundException
 *
 * @see Activity#startActivity(Intent)
 * @see Activity#startActivityForResult(Intent, int)
 * @see Activity#startActivityFromChild
 *
 * {@hide}
 */

Body of Frist Method:
{
    IApplicationThread whoThread = (IApplicationThread) contextThread;
    Uri referrer = target != null ? target.onProvideReferrer() : null;
    if (referrer != null) {
        intent.putExtra(Intent.EXTRA_REFERRER, referrer);
    }
    if (mActivityMonitors != null) {
        synchronized (mSync) {
            final int N = mActivityMonitors.size();
            for (int i = 0; i < N; i++) {
                final ActivityMonitor am = mActivityMonitors.get(i);
                if (am.match(who, null, intent)) {
                    am.mHits++;
                    if (am.isBlocking()) {
                        return requestCode >= 0 ? am.getResult() : null;
                    }
                    break;
                }
            }
        }
    }
    try {
        intent.migrateExtraStreamToClipData();
        intent.prepareToLeaveProcess();
        int result = ActivityManagerNative.getDefault().startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options);
        checkStartActivityResult(result, intent);
    } catch (RemoteException e) {
        throw new RuntimeException("Failure from system", e);
    }
    return null;
}
Body of Second Method:
{
    IApplicationThread whoThread = (IApplicationThread) contextThread;
    Uri referrer = target != null ? target.onProvideReferrer() : null;
    if (referrer != null) {
        intent.putExtra(Intent.EXTRA_REFERRER, referrer);
    }
    if (mActivityMonitors != null) {
        synchronized (mSync) {
            final int N = mActivityMonitors.size();
            for (int i = 0; i < N; i++) {
                final ActivityMonitor am = mActivityMonitors.get(i);
                if (am.match(who, null, intent)) {
                    am.mHits++;
                    if (am.isBlocking()) {
                        return requestCode >= 0 ? am.getResult() : null;
                    }
                    break;
                }
            }
        }
    }
    try {
        intent.migrateExtraStreamToClipData();
        intent.prepareToLeaveProcess(who);
        int result = ActivityManagerNative.getDefault().startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options);
        checkStartActivityResult(result, intent);
    } catch (RemoteException e) {
        throw new RuntimeException("Failure from system", e);
    }
    return null;
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiManager.addToBlacklist:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Add a bssid to the supplicant blacklist
 *
 * This API is used by WifiWatchdogService
 *
 * @return {@code true} if the operation succeeds else {@code false}
 * @hide
 */

Body of Frist Method:
{
    try {
        mService.addToBlacklist(bssid);
        return true;
    } catch (RemoteException e) {
        return false;
    }
}
Body of Second Method:
{
    try {
        mService.addToBlacklist(bssid);
        return true;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.telephony.TelephonyManager.setLine1NumberForDisplay:COMMENT
Method Modifier: public      
Comment:/**
 * Set the line 1 phone number string and its alphatag for the current ICCID
 * for display purpose only, for example, displayed in Phone Status. It won't
 * change the actual MSISDN/MDN. To unset alphatag or number, pass in a null
 * value.
 *
 * <p>Requires that the calling app has carrier privileges.
 * @see #hasCarrierPrivileges
 *
 * @param alphaTag alpha-tagging of the dailing nubmer
 * @param number The dialing number
 * @return true if the operation was executed correctly.
 */

Body of Frist Method:
{
    return setLine1NumberForDisplayForSubscriber(getDefaultSubscription(), alphaTag, number);
}
Body of Second Method:
{
    return setLine1NumberForDisplay(getSubId(), alphaTag, number);
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiManager.reconnect:COMMENT
Method Modifier: public      
Comment:/**
 * Reconnect to the currently active access point, if we are currently
 * disconnected. This may result in the asynchronous delivery of state
 * change events.
 * @return {@code true} if the operation succeeded
 */

Body of Frist Method:
{
    try {
        mService.reconnect();
        return true;
    } catch (RemoteException e) {
        return false;
    }
}
Body of Second Method:
{
    try {
        mService.reconnect();
        return true;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiEnterpriseConfig.getPhase2Method:COMMENT
Method Modifier: public      
Comment:/**
 * Get the phase 2 authentication method.
 * @return a phase 2 method defined at {@link Phase2}
 */

Body of Frist Method:
{
    String phase2Method = removeDoubleQuotes(mFields.get(PHASE2_KEY));
    // Remove auth= prefix
    if (phase2Method.startsWith(Phase2.PREFIX)) {
        phase2Method = phase2Method.substring(Phase2.PREFIX.length());
    }
    return getStringIndex(Phase2.strings, phase2Method, Phase2.NONE);
}
Body of Second Method:
{
    return mPhase2Method;
}
------------------------
Find a silently evolved API code:android.app.ActivityManager.TaskDescription.restoreFromXml:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (ATTR_TASKDESCRIPTIONLABEL.equals(attrName)) {
        setLabel(attrValue);
    } else if (ATTR_TASKDESCRIPTIONCOLOR.equals(attrName)) {
        setPrimaryColor((int) Long.parseLong(attrValue, 16));
    } else if (ATTR_TASKDESCRIPTIONICONFILENAME.equals(attrName)) {
        setIconFilename(attrValue);
    }
}
Body of Second Method:
{
    if (ATTR_TASKDESCRIPTIONLABEL.equals(attrName)) {
        setLabel(attrValue);
    } else if (ATTR_TASKDESCRIPTIONCOLOR_PRIMARY.equals(attrName)) {
        setPrimaryColor((int) Long.parseLong(attrValue, 16));
    } else if (ATTR_TASKDESCRIPTIONCOLOR_BACKGROUND.equals(attrName)) {
        setBackgroundColor((int) Long.parseLong(attrValue, 16));
    } else if (ATTR_TASKDESCRIPTIONICONFILENAME.equals(attrName)) {
        setIconFilename(attrValue);
    }
}
------------------------
Find a silently evolved API code:android.telephony.ModemActivityInfo.isValid:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @return if the record is valid
 */

Body of Frist Method:
{
    int totalTxTimeMs = 0;
    int[] txTime = getTxTimeMillis();
    for (int i = 0; i < TX_POWER_LEVELS; i++) {
        totalTxTimeMs += txTime[i];
    }
    return ((getIdleTimeMillis() != 0) || (totalTxTimeMs != 0) || (getSleepTimeMillis() != 0) || (getIdleTimeMillis() != 0));
}
Body of Second Method:
{
    for (int txVal : getTxTimeMillis()) {
        if (txVal < 0) {
            return false;
        }
    }
    return ((getIdleTimeMillis() >= 0) && (getSleepTimeMillis() >= 0) && (getRxTimeMillis() >= 0) && (getEnergyUsed() >= 0) && !isEmpty());
}
------------------------
Find a silently evolved API code:android.media.AudioManager.setMicrophoneMute:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the microphone mute on or off.
 * <p>
 * This method should only be used by applications that replace the platform-wide
 * management of audio settings or the main telephony application.
 *
 * @param on set <var>true</var> to mute the microphone;
 * <var>false</var> to turn mute off
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        service.setMicrophoneMute(on, getContext().getOpPackageName(), UserHandle.getCallingUserId());
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in setMicrophoneMute", e);
    }
}
Body of Second Method:
{
    IAudioService service = getService();
    try {
        service.setMicrophoneMute(on, getContext().getOpPackageName(), UserHandle.getCallingUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.mtp.MtpObjectInfo.getImagePixHeight:COMMENT
Method Modifier: public      final       
Comment:/**
 * Returns the height of the MTP object in pixels
 * Will be zero for non-image objects
 *
 * @return the image height
 */

Body of Frist Method:
{
    return mImagePixHeight;
}
Body of Second Method:
{
    Preconditions.checkState(mImagePixHeight >= 0);
    return mImagePixHeight;
}
------------------------
Find a silently evolved API code:android.os.PowerManager.isDeviceIdleMode:COMMENT
Method Modifier: public      
Comment:/**
 * Returns true if the device is currently in idle mode.  This happens when a device
 * has been sitting unused and unmoving for a sufficiently long period of time, so that
 * it decides to go into a lower power-use state.  This may involve things like turning
 * off network access to apps.  You can monitor for changes to this state with
 * {@link #ACTION_DEVICE_IDLE_MODE_CHANGED}.
 *
 * @return Returns true if currently in active device idle mode, else false.  This is
 * when idle mode restrictions are being actively applied; it will return false if the
 * device is in a long-term idle mode but currently running a maintenance window where
 * restrictions have been lifted.
 */

Body of Frist Method:
{
    try {
        return mService.isDeviceIdleMode();
    } catch (RemoteException e) {
        return false;
    }
}
Body of Second Method:
{
    try {
        return mService.isDeviceIdleMode();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.app.ActivityManager.removeTask:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Completely remove the given task.
 *
 * @param taskId Identifier of the task to be removed.
 * @return Returns true if the given task was found and removed.
 *
 * @hide
 */

Body of Frist Method:
{
    try {
        return ActivityManagerNative.getDefault().removeTask(taskId);
    } catch (RemoteException e) {
        // System dead, we will be dead too soon!
        return false;
    }
}
Body of Second Method:
{
    try {
        return ActivityManagerNative.getDefault().removeTask(taskId);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.media.AudioManager.disableSafeMediaVolume:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Only useful for volume controllers.
 * @hide
 */

Body of Frist Method:
{
    try {
        getService().disableSafeMediaVolume(mApplicationContext.getOpPackageName());
    } catch (RemoteException e) {
        Log.w(TAG, "Error disabling safe media volume", e);
    }
}
Body of Second Method:
{
    try {
        getService().disableSafeMediaVolume(mApplicationContext.getOpPackageName());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.net.ConnectivityManager.updateLockdownVpn:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * If the LockdownVpn mechanism is enabled, updates the vpn
 * with a reload of its profile.
 *
 * @return a boolean with {@code} indicating success
 *
 * <p>This method can only be called by the system UID
 * {@hide}
 */

Body of Frist Method:
{
    try {
        return mService.updateLockdownVpn();
    } catch (RemoteException e) {
        return false;
    }
}
Body of Second Method:
{
    try {
        return mService.updateLockdownVpn();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.widget.TimePicker.setIs24HourView:COMMENT
Method Modifier: public      
Comment:/**
 * Sets whether this widget displays time in 24-hour mode or 12-hour mode
 * with an AM/PM picker.
 *
 * @param is24HourView {@code true} to display in 24-hour mode,
 * {@code false} for 12-hour mode with AM/PM
 * @see #is24HourView()
 */

Body of Frist Method:
{
    if (is24HourView == null) {
        return;
    }
    mDelegate.setIs24HourView(is24HourView);
}
Body of Second Method:
{
    if (is24HourView == null) {
        return;
    }
    mDelegate.setIs24Hour(is24HourView);
}
------------------------
Find a silently evolved API code:android.graphics.Outline.isEmpty:COMMENT
Method Modifier: public      
Comment:/**
 * Returns whether the Outline is empty.
 * <p>
 * Outlines are empty when constructed, or if {@link #setEmpty()} is called,
 * until a setter method is called
 *
 * @see #setEmpty()
 */

Body of Frist Method:
{
    return mRect == null && mPath == null;
}
Body of Second Method:
{
    return mMode == MODE_EMPTY;
}
------------------------
Find a silently evolved API code:android.app.AlarmManager.setAndAllowWhileIdle:COMMENT
Method Modifier: public      
Comment:/**
 * Like {@link #set(int, long, PendingIntent)}, but this alarm will be allowed to execute
 * even when the system is in low-power idle modes.  This type of alarm must <b>only</b>
 * be used for situations where it is actually required that the alarm go off while in
 * idle -- a reasonable example would be for a calendar notification that should make a
 * sound so the user is aware of it.  When the alarm is dispatched, the app will also be
 * added to the system's temporary whitelist for approximately 10 seconds to allow that
 * application to acquire further wake locks in which to complete its work.</p>
 *
 * <p>These alarms can significantly impact the power use
 * of the device when idle (and thus cause significant battery blame to the app scheduling
 * them), so they should be used with care.  To reduce abuse, there are restrictions on how
 * frequently these alarms will go off for a particular application.
 * Under normal system operation, it will not dispatch these
 * alarms more than about every minute (at which point every such pending alarm is
 * dispatched); when in low-power idle modes this duration may be significantly longer,
 * such as 15 minutes.</p>
 *
 * <p>Unlike other alarms, the system is free to reschedule this type of alarm to happen
 * out of order with any other alarms, even those from the same app.  This will clearly happen
 * when the device is idle (since this alarm can go off while idle, when any other alarms
 * from the app will be held until later), but may also happen even when not idle.</p>
 *
 * <p>Regardless of the app's target SDK version, this call always allows batching of the
 * alarm.</p>
 *
 * @param type One of {@link #ELAPSED_REALTIME}, {@link #ELAPSED_REALTIME_WAKEUP},
 * {@link #RTC}, or {@link #RTC_WAKEUP}.
 * @param triggerAtMillis time in milliseconds that the alarm should go
 * off, using the appropriate clock (depending on the alarm type).
 * @param operation Action to perform when the alarm goes off;
 * typically comes from {@link PendingIntent#getBroadcast
 * IntentSender.getBroadcast()}.
 *
 * @see #set(int, long, PendingIntent)
 * @see #setExactAndAllowWhileIdle
 * @see #cancel
 * @see android.content.Context#sendBroadcast
 * @see android.content.Context#registerReceiver
 * @see android.content.Intent#filterEquals
 * @see #ELAPSED_REALTIME
 * @see #ELAPSED_REALTIME_WAKEUP
 * @see #RTC
 * @see #RTC_WAKEUP
 */

Body of Frist Method:
{
    setImpl(type, triggerAtMillis, WINDOW_HEURISTIC, 0, FLAG_ALLOW_WHILE_IDLE, operation, null, null);
}
Body of Second Method:
{
    setImpl(type, triggerAtMillis, WINDOW_HEURISTIC, 0, FLAG_ALLOW_WHILE_IDLE, operation, null, null, null, null, null);
}
------------------------
Find a silently evolved API code:android.graphics.Bitmap.isPremultiplied:COMMENT
Method Modifier: public      final       
Comment:/**
 * <p>Indicates whether pixels stored in this bitmaps are stored pre-multiplied.
 * When a pixel is pre-multiplied, the RGB components have been multiplied by
 * the alpha component. For instance, if the original color is a 50%
 * translucent red <code>(128, 255, 0, 0)</code>, the pre-multiplied form is
 * <code>(128, 128, 0, 0)</code>.</p>
 *
 * <p>This method always returns false if {@link #getConfig()} is
 * {@link Bitmap.Config#RGB_565}.</p>
 *
 * <p>The return value is undefined if {@link #getConfig()} is
 * {@link Bitmap.Config#ALPHA_8}.</p>
 *
 * <p>This method only returns true if {@link #hasAlpha()} returns true.
 * A bitmap with no alpha channel can be used both as a pre-multiplied and
 * as a non pre-multiplied bitmap.</p>
 *
 * <p>Only pre-multiplied bitmaps may be drawn by the view system or
 * {@link Canvas}. If a non-pre-multiplied bitmap with an alpha channel is
 * drawn to a Canvas, a RuntimeException will be thrown.</p>
 *
 * @return true if the underlying pixels have been pre-multiplied, false
 * otherwise
 *
 * @see Bitmap#setPremultiplied(boolean)
 * @see BitmapFactory.Options#inPremultiplied
 */

Body of Frist Method:
{
    if (mRecycled) {
        Log.w(TAG, "Called isPremultiplied() on a recycle()'d bitmap! This is undefined behavior!");
    }
    return nativeIsPremultiplied(mFinalizer.mNativeBitmap);
}
Body of Second Method:
{
    if (mRecycled) {
        Log.w(TAG, "Called isPremultiplied() on a recycle()'d bitmap! This is undefined behavior!");
    }
    return nativeIsPremultiplied(mNativePtr);
}
------------------------
Find a silently evolved API code:android.provider.ContactsInternal.startQuickContactWithErrorToast:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Called by {@link ContactsContract} to star Quick Contact, possibly on the managed profile.
 */

Body of Frist Method:
{
    final Uri uri = intent.getData();
    final int match = sContactsUriMatcher.match(uri);
    switch(match) {
        case CONTACTS_URI_LOOKUP_ID:
            {
                if (maybeStartManagedQuickContact(context, intent)) {
                    // Request handled by DPM.  Just return here.
                    return;
                }
                break;
            }
    }
    // Launch on the current profile.
    startQuickContactWithErrorToastForUser(context, intent, Process.myUserHandle());
}
Body of Second Method:
{
    final Uri uri = intent.getData();
    final int match = sContactsUriMatcher.match(uri);
    switch(match) {
        case CONTACTS_URI_LOOKUP:
        case CONTACTS_URI_LOOKUP_ID:
            {
                if (maybeStartManagedQuickContact(context, intent)) {
                    // Request handled by DPM.  Just return here.
                    return;
                }
                break;
            }
    }
    // Launch on the current profile.
    startQuickContactWithErrorToastForUser(context, intent, Process.myUserHandle());
}
------------------------
Find a silently evolved API code:android.app.DownloadManager.Request.toContentValues:COMMENT
Method Modifier: default     
Comment:/**
 * @return ContentValues to be passed to DownloadProvider.insert()
 */

Body of Frist Method:
{
    ContentValues values = new ContentValues();
    assert mUri != null;
    values.put(Downloads.Impl.COLUMN_URI, mUri.toString());
    values.put(Downloads.Impl.COLUMN_IS_PUBLIC_API, true);
    values.put(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE, packageName);
    if (mDestinationUri != null) {
        values.put(Downloads.Impl.COLUMN_DESTINATION, Downloads.Impl.DESTINATION_FILE_URI);
        values.put(Downloads.Impl.COLUMN_FILE_NAME_HINT, mDestinationUri.toString());
    } else {
        values.put(Downloads.Impl.COLUMN_DESTINATION, (this.mUseSystemCache) ? Downloads.Impl.DESTINATION_SYSTEMCACHE_PARTITION : Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE);
    }
    // is the file supposed to be media-scannable?
    values.put(Downloads.Impl.COLUMN_MEDIA_SCANNED, (mScannable) ? SCANNABLE_VALUE_YES : SCANNABLE_VALUE_NO);
    if (!mRequestHeaders.isEmpty()) {
        encodeHttpHeaders(values);
    }
    putIfNonNull(values, Downloads.Impl.COLUMN_TITLE, mTitle);
    putIfNonNull(values, Downloads.Impl.COLUMN_DESCRIPTION, mDescription);
    putIfNonNull(values, Downloads.Impl.COLUMN_MIME_TYPE, mMimeType);
    values.put(Downloads.Impl.COLUMN_VISIBILITY, mNotificationVisibility);
    values.put(Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES, mAllowedNetworkTypes);
    values.put(Downloads.Impl.COLUMN_ALLOW_ROAMING, mRoamingAllowed);
    values.put(Downloads.Impl.COLUMN_ALLOW_METERED, mMeteredAllowed);
    values.put(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, mIsVisibleInDownloadsUi);
    return values;
}
Body of Second Method:
{
    ContentValues values = new ContentValues();
    assert mUri != null;
    values.put(Downloads.Impl.COLUMN_URI, mUri.toString());
    values.put(Downloads.Impl.COLUMN_IS_PUBLIC_API, true);
    values.put(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE, packageName);
    if (mDestinationUri != null) {
        values.put(Downloads.Impl.COLUMN_DESTINATION, Downloads.Impl.DESTINATION_FILE_URI);
        values.put(Downloads.Impl.COLUMN_FILE_NAME_HINT, mDestinationUri.toString());
    } else {
        values.put(Downloads.Impl.COLUMN_DESTINATION, (this.mUseSystemCache) ? Downloads.Impl.DESTINATION_SYSTEMCACHE_PARTITION : Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE);
    }
    // is the file supposed to be media-scannable?
    values.put(Downloads.Impl.COLUMN_MEDIA_SCANNED, (mScannable) ? SCANNABLE_VALUE_YES : SCANNABLE_VALUE_NO);
    if (!mRequestHeaders.isEmpty()) {
        encodeHttpHeaders(values);
    }
    putIfNonNull(values, Downloads.Impl.COLUMN_TITLE, mTitle);
    putIfNonNull(values, Downloads.Impl.COLUMN_DESCRIPTION, mDescription);
    putIfNonNull(values, Downloads.Impl.COLUMN_MIME_TYPE, mMimeType);
    values.put(Downloads.Impl.COLUMN_VISIBILITY, mNotificationVisibility);
    values.put(Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES, mAllowedNetworkTypes);
    values.put(Downloads.Impl.COLUMN_ALLOW_ROAMING, mRoamingAllowed);
    values.put(Downloads.Impl.COLUMN_ALLOW_METERED, mMeteredAllowed);
    values.put(Downloads.Impl.COLUMN_FLAGS, mFlags);
    values.put(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, mIsVisibleInDownloadsUi);
    return values;
}
------------------------
Find a silently evolved API code:android.net.ConnectivityManager.getActiveNetwork:COMMENT
Method Modifier: public      
Comment:/**
 * Returns a {@link Network} object corresponding to the currently active
 * default data network.  In the event that the current active default data
 * network disconnects, the returned {@code Network} object will no longer
 * be usable.  This will return {@code null} when there is no default
 * network.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#ACCESS_NETWORK_STATE}.
 *
 * @return a {@link Network} object for the current default network or
 * {@code null} if no default network is currently active
 */

Body of Frist Method:
{
    try {
        return mService.getActiveNetwork();
    } catch (RemoteException e) {
        return null;
    }
}
Body of Second Method:
{
    try {
        return mService.getActiveNetwork();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.app.ActivityManager.getRecentTasks:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * <p></p>Return a list of the tasks that the user has recently launched, with
 * the most recent being first and older ones after in order.
 *
 * <p><b>Note: this method is only intended for debugging and presenting
 * task management user interfaces</b>.  This should never be used for
 * core logic in an application, such as deciding between different
 * behaviors based on the information found here.  Such uses are
 * <em>not</em> supported, and will likely break in the future.  For
 * example, if multiple applications can be actively running at the
 * same time, assumptions made about the meaning of the data here for
 * purposes of control flow will be incorrect.</p>
 *
 * @deprecated As of {@link android.os.Build.VERSION_CODES#LOLLIPOP}, this method is
 * no longer available to third party applications: the introduction of
 * document-centric recents means
 * it can leak personal information to the caller.  For backwards compatibility,
 * it will still return a small subset of its data: at least the caller's
 * own tasks (though see {@link #getAppTasks()} for the correct supported
 * way to retrieve that information), and possibly some other tasks
 * such as home that are known to not be sensitive.
 *
 * @param maxNum The maximum number of entries to return in the list.  The
 * actual number returned may be smaller, depending on how many tasks the
 * user has started and the maximum number the system can remember.
 * @param flags Information about what to return.  May be any combination
 * of {@link #RECENT_WITH_EXCLUDED} and {@link #RECENT_IGNORE_UNAVAILABLE}.
 *
 * @return Returns a list of RecentTaskInfo records describing each of
 * the recent tasks.
 */

Body of Frist Method:
{
    try {
        return ActivityManagerNative.getDefault().getRecentTasks(maxNum, flags, UserHandle.myUserId());
    } catch (RemoteException e) {
        // System dead, we will be dead too soon!
        return null;
    }
}
Body of Second Method:
{
    try {
        return ActivityManagerNative.getDefault().getRecentTasks(maxNum, flags, UserHandle.myUserId()).getList();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothAdapter.factoryReset:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Factory reset bluetooth settings.
 *
 * <p>Requires the {@link android.Manifest.permission#BLUETOOTH_PRIVILEGED}
 * permission
 *
 * @return true to indicate that the config file was successfully cleared
 *
 * @hide
 */

Body of Frist Method:
{
    try {
        if (mService != null) {
            return mService.factoryReset();
        }
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
Body of Second Method:
{
    try {
        mServiceLock.readLock().lock();
        if (mService != null) {
            return mService.factoryReset();
        }
        SystemProperties.set("persist.bluetooth.factoryreset", "true");
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
    return false;
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiManager.connect:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Connect to a network with the given networkId.
 *
 * This function is used instead of a enableNetwork(), saveConfiguration() and
 * reconnect()
 *
 * @param networkId the network id identifiying the network in the
 * supplicant configuration list
 * @param listener for callbacks on success or failure. Can be null.
 * @throws IllegalStateException if the WifiManager instance needs to be
 * initialized again
 * @hide
 */

Body of Frist Method:
{
    if (networkId < 0)
        throw new IllegalArgumentException("Network id cannot be negative");
    validateChannel();
    sAsyncChannel.sendMessage(CONNECT_NETWORK, networkId, putListener(listener));
}
Body of Second Method:
{
    if (networkId < 0)
        throw new IllegalArgumentException("Network id cannot be negative");
    getChannel().sendMessage(CONNECT_NETWORK, networkId, putListener(listener));
}
------------------------
Find a silently evolved API code:android.app.ActivityManager.killBackgroundProcesses:COMMENT
Method Modifier: public      
Comment:/**
 * Have the system immediately kill all background processes associated
 * with the given package.  This is the same as the kernel killing those
 * processes to reclaim memory; the system will take care of restarting
 * these processes in the future as needed.
 *
 * <p>You must hold the permission
 * {@link android.Manifest.permission#KILL_BACKGROUND_PROCESSES} to be able to
 * call this method.
 *
 * @param packageName The name of the package whose processes are to
 * be killed.
 */

Body of Frist Method:
{
    try {
        ActivityManagerNative.getDefault().killBackgroundProcesses(packageName, UserHandle.myUserId());
    } catch (RemoteException e) {
    }
}
Body of Second Method:
{
    try {
        ActivityManagerNative.getDefault().killBackgroundProcesses(packageName, UserHandle.myUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiConfiguration.isLinked:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Helper function, identify if a configuration is linked
 * @hide
 */

Body of Frist Method:
{
    if (config.linkedConfigurations != null && linkedConfigurations != null) {
        if (config.linkedConfigurations.get(configKey()) != null && linkedConfigurations.get(config.configKey()) != null) {
            return true;
        }
    }
    return false;
}
Body of Second Method:
{
    if (config != null) {
        if (config.linkedConfigurations != null && linkedConfigurations != null) {
            if (config.linkedConfigurations.get(configKey()) != null && linkedConfigurations.get(config.configKey()) != null) {
                return true;
            }
        }
    }
    return false;
}
------------------------
Find a silently evolved API code:android.widget.ListPopupWindow.setSelection:COMMENT
Method Modifier: public      
Comment:/**
 * Set the selected position of the list.
 * Only valid when {@link #isShowing()} == {@code true}.
 *
 * @param position List position to set as selected.
 */

Body of Frist Method:
{
    DropDownListView list = mDropDownList;
    if (isShowing() && list != null) {
        list.mListSelectionHidden = false;
        list.setSelection(position);
        if (list.getChoiceMode() != ListView.CHOICE_MODE_NONE) {
            list.setItemChecked(position, true);
        }
    }
}
Body of Second Method:
{
    DropDownListView list = mDropDownList;
    if (isShowing() && list != null) {
        list.setListSelectionHidden(false);
        list.setSelection(position);
        if (list.getChoiceMode() != ListView.CHOICE_MODE_NONE) {
            list.setItemChecked(position, true);
        }
    }
}
------------------------
Find a silently evolved API code:android.media.AudioManager.isHdmiSystemAudioSupported:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns true if Hdmi Cec system audio mode is supported.
 *
 * @hide
 */

Body of Frist Method:
{
    try {
        return getService().isHdmiSystemAudioSupported();
    } catch (RemoteException e) {
        Log.w(TAG, "Error querying system audio mode", e);
        return false;
    }
}
Body of Second Method:
{
    try {
        return getService().isHdmiSystemAudioSupported();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.widget.CheckedTextView.setCheckMarkDrawable:COMMENT
Method Modifier: public      
Comment:/**
 * Set the check mark to the specified drawable.
 * <p>
 * When this view is checked, the drawable's state set will include
 * {@link android.R.attr#state_checked}.
 *
 * @param d the drawable to use for the check mark
 * @attr ref android.R.styleable#CheckedTextView_checkMark
 * @see #setCheckMarkDrawable(int)
 * @see #getCheckMarkDrawable()
 */

Body of Frist Method:
{
    if (mCheckMarkDrawable != null) {
        mCheckMarkDrawable.setCallback(null);
        unscheduleDrawable(mCheckMarkDrawable);
    }
    mNeedRequestlayout = (d != mCheckMarkDrawable);
    if (d != null) {
        d.setCallback(this);
        d.setVisible(getVisibility() == VISIBLE, false);
        d.setState(CHECKED_STATE_SET);
        setMinHeight(d.getIntrinsicHeight());
        mCheckMarkWidth = d.getIntrinsicWidth();
        d.setState(getDrawableState());
        applyCheckMarkTint();
    } else {
        mCheckMarkWidth = 0;
    }
    mCheckMarkDrawable = d;
    // Do padding resolution. This will call internalSetPadding() and do a
    // requestLayout() if needed.
    resolvePadding();
}
Body of Second Method:
{
    setCheckMarkDrawableInternal(d, 0);
}
------------------------
Find a silently evolved API code:android.widget.TextView.setTransformationMethod:COMMENT
Method Modifier: public      final       
Comment:/**
 * Sets the transformation that is applied to the text that this
 * TextView is displaying.
 *
 * @attr ref android.R.styleable#TextView_password
 * @attr ref android.R.styleable#TextView_singleLine
 */

Body of Frist Method:
{
    if (method == mTransformation) {
        // the same.
        return;
    }
    if (mTransformation != null) {
        if (mText instanceof Spannable) {
            ((Spannable) mText).removeSpan(mTransformation);
        }
    }
    mTransformation = method;
    if (method instanceof TransformationMethod2) {
        TransformationMethod2 method2 = (TransformationMethod2) method;
        mAllowTransformationLengthChange = !isTextSelectable() && !(mText instanceof Editable);
        method2.setLengthChangesAllowed(mAllowTransformationLengthChange);
    } else {
        mAllowTransformationLengthChange = false;
    }
    setText(mText);
    if (hasPasswordTransformationMethod()) {
        notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_UNDEFINED);
    }
}
Body of Second Method:
{
    if (method == mTransformation) {
        // the same.
        return;
    }
    if (mTransformation != null) {
        if (mText instanceof Spannable) {
            ((Spannable) mText).removeSpan(mTransformation);
        }
    }
    mTransformation = method;
    if (method instanceof TransformationMethod2) {
        TransformationMethod2 method2 = (TransformationMethod2) method;
        mAllowTransformationLengthChange = !isTextSelectable() && !(mText instanceof Editable);
        method2.setLengthChangesAllowed(mAllowTransformationLengthChange);
    } else {
        mAllowTransformationLengthChange = false;
    }
    setText(mText);
    if (hasPasswordTransformationMethod()) {
        notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_UNDEFINED);
    }
    // PasswordTransformationMethod always have LTR text direction heuristics returned by
    // getTextDirectionHeuristic, needs reset
    mTextDir = getTextDirectionHeuristic();
}
------------------------
Find a silently evolved API code:android.telephony.SignalStrength.hashCode:COMMENT
Method Modifier: public      
Comment:/**
 * @return hash code
 */

Body of Frist Method:
{
    int primeNum = 31;
    return ((mGsmSignalStrength * primeNum) + (mGsmBitErrorRate * primeNum) + (mCdmaDbm * primeNum) + (mCdmaEcio * primeNum) + (mEvdoDbm * primeNum) + (mEvdoEcio * primeNum) + (mEvdoSnr * primeNum) + (mLteSignalStrength * primeNum) + (mLteRsrp * primeNum) + (mLteRsrq * primeNum) + (mLteRssnr * primeNum) + (mLteCqi * primeNum) + (isGsm ? 1 : 0));
}
Body of Second Method:
{
    int primeNum = 31;
    return ((mGsmSignalStrength * primeNum) + (mGsmBitErrorRate * primeNum) + (mCdmaDbm * primeNum) + (mCdmaEcio * primeNum) + (mEvdoDbm * primeNum) + (mEvdoEcio * primeNum) + (mEvdoSnr * primeNum) + (mLteSignalStrength * primeNum) + (mLteRsrp * primeNum) + (mLteRsrq * primeNum) + (mLteRssnr * primeNum) + (mLteCqi * primeNum) + (mTdScdmaRscp * primeNum) + (isGsm ? 1 : 0));
}
------------------------
Find a silently evolved API code:android.media.AudioManager.getRingerModeInternal:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Only useful for volume controllers.
 * @hide
 */

Body of Frist Method:
{
    try {
        return getService().getRingerModeInternal();
    } catch (RemoteException e) {
        Log.w(TAG, "Error calling getRingerModeInternal", e);
        return RINGER_MODE_NORMAL;
    }
}
Body of Second Method:
{
    try {
        return getService().getRingerModeInternal();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.hardware.radio.RadioManager.FmBandConfig.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Combines all of the parameters that have been set and return a new
 * {@link FmBandConfig} object.
 * @return a new {@link FmBandConfig} object
 */

Body of Frist Method:
{
    FmBandConfig config = new FmBandConfig(mDescriptor.getRegion(), mDescriptor.getType(), mDescriptor.getLowerLimit(), mDescriptor.getUpperLimit(), mDescriptor.getSpacing(), mStereo, mRds, mTa, mAf);
    return config;
}
Body of Second Method:
{
    FmBandConfig config = new FmBandConfig(mDescriptor.getRegion(), mDescriptor.getType(), mDescriptor.getLowerLimit(), mDescriptor.getUpperLimit(), mDescriptor.getSpacing(), mStereo, mRds, mTa, mAf, mEa);
    return config;
}
------------------------
