Find a silently evolved API code:android.media.ImageUtils.imageCopy:COMMENT
Method Modifier: public      static      
Comment:/**
 * <p>
 * Copy source image data to destination Image.
 * </p>
 * <p>
 * Only support the copy between two non-{@link ImageFormat#PRIVATE PRIVATE} format
 * images with same properties (format, size, etc.). The data from the
 * source image will be copied to the byteBuffers from the destination Image
 * starting from position zero, and the destination image will be rewound to
 * zero after copy is done.
 * </p>
 *
 * @param src The source image to be copied from.
 * @param dst The destination image to be copied to.
 * @throws IllegalArgumentException If the source and destination images
 * have different format, or one of the images is not copyable.
 */

Body of Frist Method:
{
    if (src == null || dst == null) {
        throw new IllegalArgumentException("Images should be non-null");
    }
    if (src.getFormat() != dst.getFormat()) {
        throw new IllegalArgumentException("Src and dst images should have the same format");
    }
    if (src.getFormat() == ImageFormat.PRIVATE || dst.getFormat() == ImageFormat.PRIVATE) {
        throw new IllegalArgumentException("PRIVATE format images are not copyable");
    }
    if (src.getFormat() == ImageFormat.RAW_PRIVATE) {
        throw new IllegalArgumentException("Copy of RAW_OPAQUE format has not been implemented");
    }
    if (!(dst.getOwner() instanceof ImageWriter)) {
        throw new IllegalArgumentException("Destination image is not from ImageWriter. Only" + " the images from ImageWriter are writable");
    }
    Size srcSize = new Size(src.getWidth(), src.getHeight());
    Size dstSize = new Size(dst.getWidth(), dst.getHeight());
    if (!srcSize.equals(dstSize)) {
        throw new IllegalArgumentException("source image size " + srcSize + " is different" + " with " + "destination image size " + dstSize);
    }
    Plane[] srcPlanes = src.getPlanes();
    Plane[] dstPlanes = dst.getPlanes();
    ByteBuffer srcBuffer = null;
    ByteBuffer dstBuffer = null;
    for (int i = 0; i < srcPlanes.length; i++) {
        int srcRowStride = srcPlanes[i].getRowStride();
        int dstRowStride = dstPlanes[i].getRowStride();
        srcBuffer = srcPlanes[i].getBuffer();
        dstBuffer = dstPlanes[i].getBuffer();
        if (!(srcBuffer.isDirect() && dstBuffer.isDirect())) {
            throw new IllegalArgumentException("Source and destination ByteBuffers must be" + " direct byteBuffer!");
        }
        if (srcPlanes[i].getPixelStride() != dstPlanes[i].getPixelStride()) {
            throw new IllegalArgumentException("Source plane image pixel stride " + srcPlanes[i].getPixelStride() + " must be same as destination image pixel stride " + dstPlanes[i].getPixelStride());
        }
        int srcPos = srcBuffer.position();
        srcBuffer.rewind();
        dstBuffer.rewind();
        if (srcRowStride == dstRowStride) {
            // Fast path, just copy the content if the byteBuffer all together.
            dstBuffer.put(srcBuffer);
        } else {
            // Source and destination images may have different alignment requirements,
            // therefore may have different strides. Copy row by row for such case.
            int srcOffset = srcBuffer.position();
            int dstOffset = dstBuffer.position();
            Size effectivePlaneSize = getEffectivePlaneSizeForImage(src, i);
            int srcByteCount = effectivePlaneSize.getWidth() * srcPlanes[i].getPixelStride();
            for (int row = 0; row < effectivePlaneSize.getHeight(); row++) {
                if (row == effectivePlaneSize.getHeight() - 1) {
                    // Special case for NV21 backed YUV420_888: need handle the last row
                    // carefully to avoid memory corruption. Check if we have enough bytes to
                    // copy.
                    int remainingBytes = srcBuffer.remaining() - srcOffset;
                    if (srcByteCount > remainingBytes) {
                        srcByteCount = remainingBytes;
                    }
                }
                directByteBufferCopy(srcBuffer, srcOffset, dstBuffer, dstOffset, srcByteCount);
                srcOffset += srcRowStride;
                dstOffset += dstRowStride;
            }
        }
        srcBuffer.position(srcPos);
        dstBuffer.rewind();
    }
}
Body of Second Method:
{
    if (src == null || dst == null) {
        throw new IllegalArgumentException("Images should be non-null");
    }
    if (src.getFormat() != dst.getFormat()) {
        throw new IllegalArgumentException("Src and dst images should have the same format");
    }
    if (src.getFormat() == ImageFormat.PRIVATE || dst.getFormat() == ImageFormat.PRIVATE) {
        throw new IllegalArgumentException("PRIVATE format images are not copyable");
    }
    if (src.getFormat() == ImageFormat.RAW_PRIVATE) {
        throw new IllegalArgumentException("Copy of RAW_OPAQUE format has not been implemented");
    }
    if (src.getFormat() == ImageFormat.RAW_DEPTH) {
        throw new IllegalArgumentException("Copy of RAW_DEPTH format has not been implemented");
    }
    if (!(dst.getOwner() instanceof ImageWriter)) {
        throw new IllegalArgumentException("Destination image is not from ImageWriter. Only" + " the images from ImageWriter are writable");
    }
    Size srcSize = new Size(src.getWidth(), src.getHeight());
    Size dstSize = new Size(dst.getWidth(), dst.getHeight());
    if (!srcSize.equals(dstSize)) {
        throw new IllegalArgumentException("source image size " + srcSize + " is different" + " with " + "destination image size " + dstSize);
    }
    Plane[] srcPlanes = src.getPlanes();
    Plane[] dstPlanes = dst.getPlanes();
    ByteBuffer srcBuffer = null;
    ByteBuffer dstBuffer = null;
    for (int i = 0; i < srcPlanes.length; i++) {
        int srcRowStride = srcPlanes[i].getRowStride();
        int dstRowStride = dstPlanes[i].getRowStride();
        srcBuffer = srcPlanes[i].getBuffer();
        dstBuffer = dstPlanes[i].getBuffer();
        if (!(srcBuffer.isDirect() && dstBuffer.isDirect())) {
            throw new IllegalArgumentException("Source and destination ByteBuffers must be" + " direct byteBuffer!");
        }
        if (srcPlanes[i].getPixelStride() != dstPlanes[i].getPixelStride()) {
            throw new IllegalArgumentException("Source plane image pixel stride " + srcPlanes[i].getPixelStride() + " must be same as destination image pixel stride " + dstPlanes[i].getPixelStride());
        }
        int srcPos = srcBuffer.position();
        srcBuffer.rewind();
        dstBuffer.rewind();
        if (srcRowStride == dstRowStride) {
            // Fast path, just copy the content if the byteBuffer all together.
            dstBuffer.put(srcBuffer);
        } else {
            // Source and destination images may have different alignment requirements,
            // therefore may have different strides. Copy row by row for such case.
            int srcOffset = srcBuffer.position();
            int dstOffset = dstBuffer.position();
            Size effectivePlaneSize = getEffectivePlaneSizeForImage(src, i);
            int srcByteCount = effectivePlaneSize.getWidth() * srcPlanes[i].getPixelStride();
            for (int row = 0; row < effectivePlaneSize.getHeight(); row++) {
                if (row == effectivePlaneSize.getHeight() - 1) {
                    // Special case for NV21 backed YUV420_888: need handle the last row
                    // carefully to avoid memory corruption. Check if we have enough bytes to
                    // copy.
                    int remainingBytes = srcBuffer.remaining() - srcOffset;
                    if (srcByteCount > remainingBytes) {
                        srcByteCount = remainingBytes;
                    }
                }
                directByteBufferCopy(srcBuffer, srcOffset, dstBuffer, dstOffset, srcByteCount);
                srcOffset += srcRowStride;
                dstOffset += dstRowStride;
            }
        }
        srcBuffer.position(srcPos);
        dstBuffer.rewind();
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothAvrcpController.getDevicesMatchingConnectionStates:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (VDBG)
        log("getDevicesMatchingStates()");
    if (mService != null && isEnabled()) {
        try {
            return mService.getDevicesMatchingConnectionStates(states);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
Body of Second Method:
{
    if (VDBG)
        log("getDevicesMatchingStates()");
    final IBluetoothAvrcpController service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.getDevicesMatchingConnectionStates(states);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothAvrcpController.getConnectionState:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (VDBG)
        log("getState(" + device + ")");
    if (mService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mService.getConnectionState(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.STATE_DISCONNECTED;
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return BluetoothProfile.STATE_DISCONNECTED;
}
Body of Second Method:
{
    if (VDBG)
        log("getState(" + device + ")");
    final IBluetoothAvrcpController service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getConnectionState(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.STATE_DISCONNECTED;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return BluetoothProfile.STATE_DISCONNECTED;
}
------------------------
Find a silently evolved API code:android.telephony.TelephonyManager.getAllowedCarriers:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the allowed carrier list for slotIndex.
 * Require system privileges. In the future we may add this to carrier APIs.
 *
 * <p>This method returns valid data on devices with {@link
 * android.content.pm.PackageManager#FEATURE_TELEPHONY_CARRIERLOCK} enabled.
 *
 * @return List of {@link android.telephony.CarrierIdentifier}; empty list
 * means all carriers are allowed.
 * @hide
 */

Body of Frist Method:
{
    try {
        ITelephony service = getITelephony();
        if (service != null) {
            return service.getAllowedCarriers(slotIndex);
        }
    } catch (RemoteException e) {
        Log.e(TAG, "Error calling ITelephony#getAllowedCarriers", e);
    } catch (NullPointerException e) {
        Log.e(TAG, "Error calling ITelephony#setAllowedCarriers", e);
    }
    return new ArrayList<CarrierIdentifier>(0);
}
Body of Second Method:
{
    try {
        ITelephony service = getITelephony();
        if (service != null) {
            return service.getAllowedCarriers(slotIndex);
        }
    } catch (RemoteException e) {
        Log.e(TAG, "Error calling ITelephony#getAllowedCarriers", e);
    } catch (NullPointerException e) {
        Log.e(TAG, "Error calling ITelephony#getAllowedCarriers", e);
    }
    return new ArrayList<CarrierIdentifier>(0);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadset.setAudioRouteAllowed:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets whether audio routing is allowed. When set to {@code false}, the AG will not route any
 * audio to the HF unless explicitly told to.
 * This method should be used in cases where the SCO channel is shared between multiple profiles
 * and must be delegated by a source knowledgeable
 * Note: This is an internal function and shouldn't be exposed
 *
 * @param allowed {@code true} if the profile can reroute audio, {@code false} otherwise.
 *
 * @hide
 */

Body of Frist Method:
{
    if (VDBG)
        log("setAudioRouteAllowed");
    if (mService != null && isEnabled()) {
        try {
            mService.setAudioRouteAllowed(allowed);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
}
Body of Second Method:
{
    if (VDBG)
        log("setAudioRouteAllowed");
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled()) {
        try {
            service.setAudioRouteAllowed(allowed);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothInputDevice.getProtocolMode:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Send Get_Protocol_Mode command to the connected HID input device.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN} permission.
 *
 * @param device Remote Bluetooth Device
 * @return false on immediate error,
 * true otherwise
 * @hide
 */

Body of Frist Method:
{
    if (VDBG)
        log("getProtocolMode(" + device + ")");
    if (mService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mService.getProtocolMode(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (VDBG)
        log("getProtocolMode(" + device + ")");
    final IBluetoothInputDevice service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getProtocolMode(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothInputDevice.sendData:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Send Send_Data command to the connected HID input device.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN} permission.
 *
 * @param device Remote Bluetooth Device
 * @param report Report to send
 * @return false on immediate error,
 * true otherwise
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("sendData(" + device + "), report=" + report);
    if (mService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mService.sendData(device, report);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("sendData(" + device + "), report=" + report);
    final IBluetoothInputDevice service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.sendData(device, report);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.media.MediaCas.refreshEntitlements:COMMENT
Method Modifier: public      
Comment:/**
 * Notify the CA system to refresh entitlement keys.
 *
 * @param refreshType the type of the refreshment.
 * @param refreshData private data associated with the refreshment.
 *
 * @throws IllegalStateException if the MediaCas instance is not valid.
 * @throws MediaCasException for CAS-specific errors.
 * @throws MediaCasStateException for CAS-specific state exceptions.
 */

Body of Frist Method:
{
    validateInternalStates();
    try {
        mICas.refreshEntitlements(refreshType, refreshData);
    } catch (ServiceSpecificException e) {
        MediaCasException.throwExceptions(e);
    } catch (RemoteException e) {
        cleanupAndRethrowIllegalState();
    }
}
Body of Second Method:
{
    validateInternalStates();
    try {
        MediaCasException.throwExceptionIfNeeded(mICas.refreshEntitlements(refreshType, toByteArray(refreshData)));
    } catch (RemoteException e) {
        cleanupAndRethrowIllegalState();
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothSap.getPriority:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the priority of the profile.
 *
 * @param device Bluetooth device
 * @return priority of the device
 * @hide
 */

Body of Frist Method:
{
    if (VDBG)
        log("getPriority(" + device + ")");
    if (mService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mService.getPriority(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return PRIORITY_OFF;
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return PRIORITY_OFF;
}
Body of Second Method:
{
    if (VDBG)
        log("getPriority(" + device + ")");
    final IBluetoothSap service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getPriority(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return PRIORITY_OFF;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return PRIORITY_OFF;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.acceptCall:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Accepts a call
 *
 * @param device    remote device
 * @param flag      action policy while accepting a call. Possible values
 * {@link #CALL_ACCEPT_NONE}, {@link #CALL_ACCEPT_HOLD},
 * {@link #CALL_ACCEPT_TERMINATE}
 * @return          <code>true</code> if command has been issued successfully;
 * <code>false</code> otherwise;
 * upon completion HFP sends {@link #ACTION_CALL_CHANGED}
 * intent.
 */

Body of Frist Method:
{
    if (DBG)
        log("acceptCall()");
    if (mService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mService.acceptCall(device, flag);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("acceptCall()");
    final IBluetoothHeadsetClient service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.acceptCall(device, flag);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.os.Bundle.readFromParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Reads the Parcel contents into this Bundle, typically in order for
 * it to be passed through an IBinder connection.
 * @param parcel The parcel to overwrite this bundle from.
 */

Body of Frist Method:
{
    super.readFromParcelInner(parcel);
    mFlags = FLAG_HAS_FDS_KNOWN | FLAG_ALLOW_FDS;
    if (mParcelledData.hasFileDescriptors()) {
        mFlags |= FLAG_HAS_FDS;
    }
}
Body of Second Method:
{
    super.readFromParcelInner(parcel);
    mFlags = FLAG_ALLOW_FDS;
    maybePrefillHasFds();
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothDevice.getPhonebookAccessPermission:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Requires {@link android.Manifest.permission#BLUETOOTH}.
 * @return Whether the phonebook access is allowed to this device. Can be
 * {@link #ACCESS_UNKNOWN}, {@link #ACCESS_ALLOWED} or {@link #ACCESS_REJECTED}.
 * @hide
 */

Body of Frist Method:
{
    if (sService == null) {
        return ACCESS_UNKNOWN;
    }
    try {
        return sService.getPhonebookAccessPermission(this);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return ACCESS_UNKNOWN;
}
Body of Second Method:
{
    final IBluetooth service = sService;
    if (service == null) {
        return ACCESS_UNKNOWN;
    }
    try {
        return service.getPhonebookAccessPermission(this);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return ACCESS_UNKNOWN;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHealth.getConnectedDevices:COMMENT
Method Modifier: public      
Comment:/**
 * Get connected devices for the health profile.
 *
 * <p> Return the set of devices which are in state {@link #STATE_CONNECTED}
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * This is not specific to any application configuration but represents the connection
 * state of the local Bluetooth adapter for this profile. This can be used
 * by applications like status bar which would just like to know the state of the
 * local adapter.
 * @return List of devices. The list will be empty on error.
 */

Body of Frist Method:
{
    if (mService != null && isEnabled()) {
        try {
            return mService.getConnectedHealthDevices();
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
Body of Second Method:
{
    final IBluetoothHealth service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.getConnectedHealthDevices();
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothA2dpSink.getDevicesMatchingConnectionStates:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (VDBG)
        log("getDevicesMatchingStates()");
    if (mService != null && isEnabled()) {
        try {
            return mService.getDevicesMatchingConnectionStates(states);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
Body of Second Method:
{
    if (VDBG)
        log("getDevicesMatchingStates()");
    final IBluetoothA2dpSink service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.getDevicesMatchingConnectionStates(states);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
------------------------
Find a silently evolved API code:android.os.MemoryFile.getFileDescriptor:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Gets a FileDescriptor for the memory file.
 *
 * The returned file descriptor is not duplicated.
 *
 * @throws IOException If the memory file has been closed.
 *
 * @hide
 */

Body of Frist Method:
{
    return mFD;
}
Body of Second Method:
{
    return mSharedMemory.getFileDescriptor();
}
------------------------
Find a silently evolved API code:android.app.usage.NetworkStatsManager.querySummaryForUser:COMMENT
Method Modifier: public      
Comment:/**
 * Query network usage statistics summaries. Result is summarised data usage for all uids
 * belonging to calling user. Result is a single Bucket aggregated over time, state and uid.
 * This means the bucket's start and end timestamp are going to be the same as the 'startTime'
 * and 'endTime' parameters. State is going to be {@link NetworkStats.Bucket#STATE_ALL},
 * uid {@link NetworkStats.Bucket#UID_ALL}, tag {@link NetworkStats.Bucket#TAG_NONE},
 * metered {@link NetworkStats.Bucket#METERED_ALL}, and roaming
 * {@link NetworkStats.Bucket#ROAMING_ALL}.
 *
 * @param networkType As defined in {@link ConnectivityManager}, e.g.
 * {@link ConnectivityManager#TYPE_MOBILE}, {@link ConnectivityManager#TYPE_WIFI}
 * etc.
 * @param subscriberId If applicable, the subscriber id of the network interface.
 * @param startTime Start of period. Defined in terms of "Unix time", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param endTime End of period. Defined in terms of "Unix time", see
 * {@link java.lang.System#currentTimeMillis}.
 * @return Bucket object or null if permissions are insufficient or error happened during
 * statistics collection.
 */

Body of Frist Method:
{
    NetworkTemplate template;
    try {
        template = createTemplate(networkType, subscriberId);
    } catch (IllegalArgumentException e) {
        if (DBG)
            Log.e(TAG, "Cannot create template", e);
        return null;
    }
    NetworkStats stats;
    stats = new NetworkStats(mContext, template, startTime, endTime);
    stats.startSummaryEnumeration();
    stats.close();
    return stats.getSummaryAggregate();
}
Body of Second Method:
{
    NetworkTemplate template;
    try {
        template = createTemplate(networkType, subscriberId);
    } catch (IllegalArgumentException e) {
        if (DBG)
            Log.e(TAG, "Cannot create template", e);
        return null;
    }
    NetworkStats stats;
    stats = new NetworkStats(mContext, template, mFlags, startTime, endTime);
    stats.startSummaryEnumeration();
    stats.close();
    return stats.getSummaryAggregate();
}
------------------------
Find a silently evolved API code:android.media.ImageUtils.getNumPlanesForFormat:COMMENT
Method Modifier: public      static      
Comment:/**
 * Only a subset of the formats defined in
 * {@link android.graphics.ImageFormat ImageFormat} and
 * {@link android.graphics.PixelFormat PixelFormat} are supported by
 * ImageReader. When reading RGB data from a surface, the formats defined in
 * {@link android.graphics.PixelFormat PixelFormat} can be used; when
 * reading YUV, JPEG or raw sensor data (for example, from the camera or video
 * decoder), formats from {@link android.graphics.ImageFormat ImageFormat}
 * are used.
 */

Body of Frist Method:
{
    switch(format) {
        case ImageFormat.YV12:
        case ImageFormat.YUV_420_888:
        case ImageFormat.NV21:
            return 3;
        case ImageFormat.NV16:
            return 2;
        case PixelFormat.RGB_565:
        case PixelFormat.RGBA_8888:
        case PixelFormat.RGBX_8888:
        case PixelFormat.RGB_888:
        case ImageFormat.JPEG:
        case ImageFormat.YUY2:
        case ImageFormat.Y8:
        case ImageFormat.Y16:
        case ImageFormat.RAW_SENSOR:
        case ImageFormat.RAW_PRIVATE:
        case ImageFormat.RAW10:
        case ImageFormat.RAW12:
        case ImageFormat.DEPTH16:
        case ImageFormat.DEPTH_POINT_CLOUD:
            return 1;
        case ImageFormat.PRIVATE:
            return 0;
        default:
            throw new UnsupportedOperationException(String.format("Invalid format specified %d", format));
    }
}
Body of Second Method:
{
    switch(format) {
        case ImageFormat.YV12:
        case ImageFormat.YUV_420_888:
        case ImageFormat.NV21:
            return 3;
        case ImageFormat.NV16:
            return 2;
        case PixelFormat.RGB_565:
        case PixelFormat.RGBA_8888:
        case PixelFormat.RGBX_8888:
        case PixelFormat.RGB_888:
        case ImageFormat.JPEG:
        case ImageFormat.YUY2:
        case ImageFormat.Y8:
        case ImageFormat.Y16:
        case ImageFormat.RAW_SENSOR:
        case ImageFormat.RAW_PRIVATE:
        case ImageFormat.RAW10:
        case ImageFormat.RAW12:
        case ImageFormat.DEPTH16:
        case ImageFormat.DEPTH_POINT_CLOUD:
        case ImageFormat.RAW_DEPTH:
            return 1;
        case ImageFormat.PRIVATE:
            return 0;
        default:
            throw new UnsupportedOperationException(String.format("Invalid format specified %d", format));
    }
}
------------------------
Find a silently evolved API code:android.util.IntArray.get:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns the value at the specified position in this array.
 */

Body of Frist Method:
{
    if (index >= mSize) {
        throw new ArrayIndexOutOfBoundsException(mSize, index);
    }
    return mValues[index];
}
Body of Second Method:
{
    checkBounds(index);
    return mValues[index];
}
------------------------
Find a silently evolved API code:android.os.MemoryFile.readBytes:COMMENT
Method Modifier: public      
Comment:/**
 * Reads bytes from the memory file.
 * Will throw an IOException if the file has been purged.
 *
 * @param buffer byte array to read bytes into.
 * @param srcOffset offset into the memory file to read from.
 * @param destOffset offset into the byte array buffer to read into.
 * @param count number of bytes to read.
 * @return number of bytes read.
 * @throws IOException if the memory file has been purged or deactivated.
 */

Body of Frist Method:
{
    if (isDeactivated()) {
        throw new IOException("Can't read from deactivated memory file.");
    }
    if (destOffset < 0 || destOffset > buffer.length || count < 0 || count > buffer.length - destOffset || srcOffset < 0 || srcOffset > mLength || count > mLength - srcOffset) {
        throw new IndexOutOfBoundsException();
    }
    return native_read(mFD, mAddress, buffer, srcOffset, destOffset, count, mAllowPurging);
}
Body of Second Method:
{
    beginAccess();
    try {
        mMapping.position(srcOffset);
        mMapping.get(buffer, destOffset, count);
    } finally {
        endAccess();
    }
    return count;
}
------------------------
Find a silently evolved API code:android.view.accessibility.AccessibilityRecord.getSource:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the {@link AccessibilityNodeInfo} of the event source.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the received info
 * by calling {@link AccessibilityNodeInfo#recycle() AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 * @return The info of the source.
 */

Body of Frist Method:
{
    enforceSealed();
    if (mSourceNode != null) {
        return AccessibilityNodeInfo.obtain(mSourceNode);
    }
    return null;
}
Body of Second Method:
{
    enforceSealed();
    if ((mConnectionId == UNDEFINED) || (mSourceWindowId == AccessibilityWindowInfo.UNDEFINED_WINDOW_ID) || (AccessibilityNodeInfo.getAccessibilityViewId(mSourceNodeId) == AccessibilityNodeInfo.UNDEFINED_ITEM_ID)) {
        return null;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mSourceWindowId, mSourceNodeId, false, GET_SOURCE_PREFETCH_FLAGS, null);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothMap.getPriority:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the priority of the profile.
 *
 * <p> The priority can be any of:
 * {@link #PRIORITY_AUTO_CONNECT}, {@link #PRIORITY_OFF},
 * {@link #PRIORITY_ON}, {@link #PRIORITY_UNDEFINED}
 *
 * @param device Bluetooth device
 * @return priority of the device
 */

Body of Frist Method:
{
    if (VDBG)
        log("getPriority(" + device + ")");
    if (mService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mService.getPriority(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return PRIORITY_OFF;
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return PRIORITY_OFF;
}
Body of Second Method:
{
    if (VDBG)
        log("getPriority(" + device + ")");
    final IBluetoothMap service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getPriority(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return PRIORITY_OFF;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return PRIORITY_OFF;
}
------------------------
Find a silently evolved API code:android.media.MediaDescrambler.descramble:COMMENT
Method Modifier: public      final       
Comment:/**
 * Descramble a ByteBuffer of data described by a
 * {@link android.media.MediaCodec.CryptoInfo} structure.
 *
 * @param srcBuf ByteBuffer containing the scrambled data, which starts at
 * srcBuf.position().
 * @param dstBuf ByteBuffer to hold the descrambled data, which starts at
 * dstBuf.position().
 * @param cryptoInfo a {@link android.media.MediaCodec.CryptoInfo} structure
 * describing the subsamples contained in src.
 *
 * @return number of bytes that have been successfully descrambled, with negative
 * values indicating errors.
 *
 * @throws IllegalStateException if the descrambler instance is not valid.
 * @throws MediaCasStateException for CAS-specific state exceptions.
 */

Body of Frist Method:
{
    validateInternalStates();
    if (cryptoInfo.numSubSamples <= 0) {
        throw new IllegalArgumentException("Invalid CryptoInfo: invalid numSubSamples=" + cryptoInfo.numSubSamples);
    } else if (cryptoInfo.numBytesOfClearData == null && cryptoInfo.numBytesOfEncryptedData == null) {
        throw new IllegalArgumentException("Invalid CryptoInfo: clearData and encryptedData size arrays are both null!");
    } else if (cryptoInfo.numBytesOfClearData != null && cryptoInfo.numBytesOfClearData.length < cryptoInfo.numSubSamples) {
        throw new IllegalArgumentException("Invalid CryptoInfo: numBytesOfClearData is too small!");
    } else if (cryptoInfo.numBytesOfEncryptedData != null && cryptoInfo.numBytesOfEncryptedData.length < cryptoInfo.numSubSamples) {
        throw new IllegalArgumentException("Invalid CryptoInfo: numBytesOfEncryptedData is too small!");
    } else if (cryptoInfo.key == null || cryptoInfo.key.length != 16) {
        throw new IllegalArgumentException("Invalid CryptoInfo: key array is invalid!");
    }
    try {
        return native_descramble(cryptoInfo.key[0], cryptoInfo.numSubSamples, cryptoInfo.numBytesOfClearData, cryptoInfo.numBytesOfEncryptedData, srcBuf, srcBuf.position(), srcBuf.limit(), dstBuf, dstBuf.position(), dstBuf.limit());
    } catch (ServiceSpecificException e) {
        MediaCasStateException.throwExceptions(e);
    }
    return -1;
}
Body of Second Method:
{
    validateInternalStates();
    if (cryptoInfo.numSubSamples <= 0) {
        throw new IllegalArgumentException("Invalid CryptoInfo: invalid numSubSamples=" + cryptoInfo.numSubSamples);
    } else if (cryptoInfo.numBytesOfClearData == null && cryptoInfo.numBytesOfEncryptedData == null) {
        throw new IllegalArgumentException("Invalid CryptoInfo: clearData and encryptedData size arrays are both null!");
    } else if (cryptoInfo.numBytesOfClearData != null && cryptoInfo.numBytesOfClearData.length < cryptoInfo.numSubSamples) {
        throw new IllegalArgumentException("Invalid CryptoInfo: numBytesOfClearData is too small!");
    } else if (cryptoInfo.numBytesOfEncryptedData != null && cryptoInfo.numBytesOfEncryptedData.length < cryptoInfo.numSubSamples) {
        throw new IllegalArgumentException("Invalid CryptoInfo: numBytesOfEncryptedData is too small!");
    } else if (cryptoInfo.key == null || cryptoInfo.key.length != 16) {
        throw new IllegalArgumentException("Invalid CryptoInfo: key array is invalid!");
    }
    try {
        return native_descramble(cryptoInfo.key[0], cryptoInfo.numSubSamples, cryptoInfo.numBytesOfClearData, cryptoInfo.numBytesOfEncryptedData, srcBuf, srcBuf.position(), srcBuf.limit(), dstBuf, dstBuf.position(), dstBuf.limit());
    } catch (ServiceSpecificException e) {
        MediaCasStateException.throwExceptionIfNeeded(e.errorCode, e.getMessage());
    } catch (RemoteException e) {
        cleanupAndRethrowIllegalState();
    }
    return -1;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.getAudioState:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns current audio state of Audio Gateway.
 *
 * Note: This is an internal function and shouldn't be exposed
 */

Body of Frist Method:
{
    if (VDBG)
        log("getAudioState");
    if (mService != null && isEnabled()) {
        try {
            return mService.getAudioState(device);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return BluetoothHeadsetClient.STATE_AUDIO_DISCONNECTED;
}
Body of Second Method:
{
    if (VDBG)
        log("getAudioState");
    final IBluetoothHeadsetClient service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.getAudioState(device);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return BluetoothHeadsetClient.STATE_AUDIO_DISCONNECTED;
}
------------------------
Find a silently evolved API code:android.net.wifi.aware.WifiAwareNetworkSpecifier.toString:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    StringBuilder sb = new StringBuilder("WifiAwareNetworkSpecifier [");
    sb.append("type=").append(type).append(", role=").append(role).append(", clientId=").append(clientId).append(", sessionId=").append(sessionId).append(", peerId=").append(peerId).append(", peerMac=").append((peerMac == null) ? "<null>" : "<non-null>").append(", pmk=").append((pmk == null) ? "<null>" : "<non-null>").append(", passphrase=").append((passphrase == null) ? "<null>" : "<non-null>").append("]");
    return sb.toString();
}
Body of Second Method:
{
    StringBuilder sb = new StringBuilder("WifiAwareNetworkSpecifier [");
    sb.append("type=").append(type).append(", role=").append(role).append(", clientId=").append(clientId).append(", sessionId=").append(sessionId).append(", peerId=").append(peerId).append(", peerMac=").append((peerMac == null) ? "<null>" : "<non-null>").append(", pmk=").append((pmk == null) ? "<null>" : "<non-null>").append(", passphrase=").append((passphrase == null) ? "<null>" : "<non-null>").append(", requestorUid=").append(requestorUid).append("]");
    return sb.toString();
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadset.stopScoUsingVirtualVoiceCall:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Terminates an ongoing SCO connection and the associated virtual
 * call.
 *
 * @param device Remote Bluetooth Device
 * @return true if successful, false if there was some error.
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("stopScoUsingVirtualVoiceCall()");
    if (mService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mService.stopScoUsingVirtualVoiceCall(device);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("stopScoUsingVirtualVoiceCall()");
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.stopScoUsingVirtualVoiceCall(device);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return false;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothInputDevice.disconnect:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Initiate disconnection from a profile
 *
 * <p> This API will return false in scenarios like the profile on the
 * Bluetooth device is not in connected state etc. When this API returns,
 * true, it is guaranteed that the connection state change
 * intent will be broadcasted with the state. Users can get the
 * disconnection state of the profile from this intent.
 *
 * <p> If the disconnection is initiated by a remote device, the state
 * will transition from {@link #STATE_CONNECTED} to
 * {@link #STATE_DISCONNECTED}. If the disconnect is initiated by the
 * host (local) device the state will transition from
 * {@link #STATE_CONNECTED} to state {@link #STATE_DISCONNECTING} to
 * state {@link #STATE_DISCONNECTED}. The transition to
 * {@link #STATE_DISCONNECTING} can be used to distinguish between the
 * two scenarios.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}
 * permission.
 *
 * @param device Remote Bluetooth Device
 * @return false on immediate error,
 * true otherwise
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("disconnect(" + device + ")");
    if (mService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mService.disconnect(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("disconnect(" + device + ")");
    final IBluetoothInputDevice service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.disconnect(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothPbap.getState:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the current state of the BluetoothPbap service.
 * @return One of the STATE_ return codes, or STATE_ERROR if this proxy
 * object is currently not connected to the Pbap service.
 */

Body of Frist Method:
{
    if (VDBG)
        log("getState()");
    if (mService != null) {
        try {
            return mService.getState();
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            log(Log.getStackTraceString(new Throwable()));
    }
    return BluetoothPbap.STATE_ERROR;
}
Body of Second Method:
{
    if (VDBG)
        log("getState()");
    final IBluetoothPbap service = mService;
    if (service != null) {
        try {
            return service.getState();
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            log(Log.getStackTraceString(new Throwable()));
    }
    return BluetoothPbap.STATE_ERROR;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothDevice.isBondingInitiatedLocally:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    try {
        return sService.isBondingInitiatedLocally(this);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
Body of Second Method:
{
    final IBluetooth service = sService;
    if (service == null) {
        Log.w(TAG, "BT not enabled, isBondingInitiatedLocally failed");
        return false;
    }
    try {
        return service.isBondingInitiatedLocally(this);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadset.getDevicesMatchingConnectionStates:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (VDBG)
        log("getDevicesMatchingStates()");
    if (mService != null && isEnabled()) {
        try {
            return mService.getDevicesMatchingConnectionStates(states);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
Body of Second Method:
{
    if (VDBG)
        log("getDevicesMatchingStates()");
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.getDevicesMatchingConnectionStates(states);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.stopVoiceRecognition:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Stops voice recognition.
 *
 * @param device    remote device
 * @return          <code>true</code> if command has been issued successfully;
 * <code>false</code> otherwise;
 * upon completion HFP sends {@link #ACTION_AG_EVENT}
 * intent.
 *
 * <p>Feature required for successful execution is being reported by:
 * {@link #EXTRA_AG_FEATURE_VOICE_RECOGNITION}.
 * This method invocation will fail silently when feature is not supported.</p>
 */

Body of Frist Method:
{
    if (DBG)
        log("stopVoiceRecognition()");
    if (mService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mService.stopVoiceRecognition(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("stopVoiceRecognition()");
    final IBluetoothHeadsetClient service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.stopVoiceRecognition(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.hardware.usb.UsbManager.getDeviceList:COMMENT
Method Modifier: public      
Comment:/**
 * Returns a HashMap containing all USB devices currently attached.
 * USB device name is the key for the returned HashMap.
 * The result will be empty if no devices are attached, or if
 * USB host mode is inactive or unsupported.
 *
 * @return HashMap containing all connected USB devices.
 */

Body of Frist Method:
{
    Bundle bundle = new Bundle();
    try {
        mService.getDeviceList(bundle);
        HashMap<String, UsbDevice> result = new HashMap<String, UsbDevice>();
        for (String name : bundle.keySet()) {
            result.put(name, (UsbDevice) bundle.get(name));
        }
        return result;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    HashMap<String, UsbDevice> result = new HashMap<String, UsbDevice>();
    if (mService == null) {
        return result;
    }
    Bundle bundle = new Bundle();
    try {
        mService.getDeviceList(bundle);
        for (String name : bundle.keySet()) {
            result.put(name, (UsbDevice) bundle.get(name));
        }
        return result;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.net.NetworkCapabilities.removeTransportType:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Removes (if found) the given transport from this {@code NetworkCapability} instance.
 *
 * @param transportType the {@code NetworkCapabilities.TRANSPORT_*} to be removed.
 * @return This NetworkCapabilities instance, to facilitate chaining.
 * @hide
 */

Body of Frist Method:
{
    if (transportType < MIN_TRANSPORT || transportType > MAX_TRANSPORT) {
        throw new IllegalArgumentException("TransportType out of range");
    }
    mTransportTypes &= ~(1 << transportType);
    // used for exception checking
    setNetworkSpecifier(mNetworkSpecifier);
    return this;
}
Body of Second Method:
{
    checkValidTransportType(transportType);
    mTransportTypes &= ~(1 << transportType);
    // used for exception checking
    setNetworkSpecifier(mNetworkSpecifier);
    return this;
}
------------------------
Find a silently evolved API code:android.net.NetworkStats.subtract:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Subtract the two given {@link NetworkStats} objects, returning the delta
 * between two snapshots in time. Assumes that statistics rows collect over
 * time, and that none of them have disappeared.
 * <p>
 * If counters have rolled backwards, they are clamped to {@code 0} and
 * reported to the given {@link NonMonotonicObserver}.
 * <p>
 * If <var>recycle</var> is supplied, this NetworkStats object will be
 * reused (and returned) as the result if it is large enough to contain
 * the data.
 */

Body of Frist Method:
{
    long deltaRealtime = left.elapsedRealtime - right.elapsedRealtime;
    if (deltaRealtime < 0) {
        if (observer != null) {
            observer.foundNonMonotonic(left, -1, right, -1, cookie);
        }
        deltaRealtime = 0;
    }
    // result will have our rows, and elapsed time between snapshots
    final Entry entry = new Entry();
    final NetworkStats result;
    if (recycle != null && recycle.capacity >= left.size) {
        result = recycle;
        result.size = 0;
        result.elapsedRealtime = deltaRealtime;
    } else {
        result = new NetworkStats(deltaRealtime, left.size);
    }
    for (int i = 0; i < left.size; i++) {
        entry.iface = left.iface[i];
        entry.uid = left.uid[i];
        entry.set = left.set[i];
        entry.tag = left.tag[i];
        entry.metered = left.metered[i];
        entry.roaming = left.roaming[i];
        // find remote row that matches, and subtract
        final int j = right.findIndexHinted(entry.iface, entry.uid, entry.set, entry.tag, entry.metered, entry.roaming, i);
        if (j == -1) {
            // newly appearing row, return entire value
            entry.rxBytes = left.rxBytes[i];
            entry.rxPackets = left.rxPackets[i];
            entry.txBytes = left.txBytes[i];
            entry.txPackets = left.txPackets[i];
            entry.operations = left.operations[i];
        } else {
            // existing row, subtract remote value
            entry.rxBytes = left.rxBytes[i] - right.rxBytes[j];
            entry.rxPackets = left.rxPackets[i] - right.rxPackets[j];
            entry.txBytes = left.txBytes[i] - right.txBytes[j];
            entry.txPackets = left.txPackets[i] - right.txPackets[j];
            entry.operations = left.operations[i] - right.operations[j];
            if (entry.rxBytes < 0 || entry.rxPackets < 0 || entry.txBytes < 0 || entry.txPackets < 0 || entry.operations < 0) {
                if (observer != null) {
                    observer.foundNonMonotonic(left, i, right, j, cookie);
                }
                entry.rxBytes = Math.max(entry.rxBytes, 0);
                entry.rxPackets = Math.max(entry.rxPackets, 0);
                entry.txBytes = Math.max(entry.txBytes, 0);
                entry.txPackets = Math.max(entry.txPackets, 0);
                entry.operations = Math.max(entry.operations, 0);
            }
        }
        result.addValues(entry);
    }
    return result;
}
Body of Second Method:
{
    long deltaRealtime = left.elapsedRealtime - right.elapsedRealtime;
    if (deltaRealtime < 0) {
        if (observer != null) {
            observer.foundNonMonotonic(left, -1, right, -1, cookie);
        }
        deltaRealtime = 0;
    }
    // result will have our rows, and elapsed time between snapshots
    final Entry entry = new Entry();
    final NetworkStats result;
    if (recycle != null && recycle.capacity >= left.size) {
        result = recycle;
        result.size = 0;
        result.elapsedRealtime = deltaRealtime;
    } else {
        result = new NetworkStats(deltaRealtime, left.size);
    }
    for (int i = 0; i < left.size; i++) {
        entry.iface = left.iface[i];
        entry.uid = left.uid[i];
        entry.set = left.set[i];
        entry.tag = left.tag[i];
        entry.metered = left.metered[i];
        entry.roaming = left.roaming[i];
        entry.rxBytes = left.rxBytes[i];
        entry.rxPackets = left.rxPackets[i];
        entry.txBytes = left.txBytes[i];
        entry.txPackets = left.txPackets[i];
        entry.operations = left.operations[i];
        // find remote row that matches, and subtract
        final int j = right.findIndexHinted(entry.iface, entry.uid, entry.set, entry.tag, entry.metered, entry.roaming, i);
        if (j != -1) {
            // Found matching row, subtract remote value.
            entry.rxBytes -= right.rxBytes[j];
            entry.rxPackets -= right.rxPackets[j];
            entry.txBytes -= right.txBytes[j];
            entry.txPackets -= right.txPackets[j];
            entry.operations -= right.operations[j];
        }
        if (entry.isNegative()) {
            if (observer != null) {
                observer.foundNonMonotonic(left, i, right, j, cookie);
            }
            entry.rxBytes = Math.max(entry.rxBytes, 0);
            entry.rxPackets = Math.max(entry.rxPackets, 0);
            entry.txBytes = Math.max(entry.txBytes, 0);
            entry.txPackets = Math.max(entry.txPackets, 0);
            entry.operations = Math.max(entry.operations, 0);
        }
        result.addValues(entry);
    }
    return result;
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiConfiguration.writeToParcel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Implement the Parcelable interface {@hide}
 */

Body of Frist Method:
{
    dest.writeInt(networkId);
    dest.writeInt(status);
    mNetworkSelectionStatus.writeToParcel(dest);
    dest.writeString(SSID);
    dest.writeString(BSSID);
    dest.writeInt(apBand);
    dest.writeInt(apChannel);
    dest.writeString(FQDN);
    dest.writeString(providerFriendlyName);
    dest.writeInt(isHomeProviderNetwork ? 1 : 0);
    dest.writeInt(roamingConsortiumIds.length);
    for (long roamingConsortiumId : roamingConsortiumIds) {
        dest.writeLong(roamingConsortiumId);
    }
    dest.writeString(preSharedKey);
    for (String wepKey : wepKeys) {
        dest.writeString(wepKey);
    }
    dest.writeInt(wepTxKeyIndex);
    dest.writeInt(priority);
    dest.writeInt(hiddenSSID ? 1 : 0);
    dest.writeInt(requirePMF ? 1 : 0);
    dest.writeString(updateIdentifier);
    writeBitSet(dest, allowedKeyManagement);
    writeBitSet(dest, allowedProtocols);
    writeBitSet(dest, allowedAuthAlgorithms);
    writeBitSet(dest, allowedPairwiseCiphers);
    writeBitSet(dest, allowedGroupCiphers);
    dest.writeParcelable(enterpriseConfig, flags);
    dest.writeParcelable(mIpConfiguration, flags);
    dest.writeString(dhcpServer);
    dest.writeString(defaultGwMacAddress);
    dest.writeInt(selfAdded ? 1 : 0);
    dest.writeInt(didSelfAdd ? 1 : 0);
    dest.writeInt(validatedInternetAccess ? 1 : 0);
    dest.writeInt(isLegacyPasspointConfig ? 1 : 0);
    dest.writeInt(ephemeral ? 1 : 0);
    dest.writeInt(meteredHint ? 1 : 0);
    dest.writeInt(meteredOverride ? 1 : 0);
    dest.writeInt(useExternalScores ? 1 : 0);
    dest.writeInt(creatorUid);
    dest.writeInt(lastConnectUid);
    dest.writeInt(lastUpdateUid);
    dest.writeString(creatorName);
    dest.writeString(lastUpdateName);
    dest.writeLong(lastConnectionFailure);
    dest.writeLong(lastRoamingFailure);
    dest.writeInt(lastRoamingFailureReason);
    dest.writeLong(roamingFailureBlackListTimeMilli);
    dest.writeInt(numScorerOverride);
    dest.writeInt(numScorerOverrideAndSwitchedNetwork);
    dest.writeInt(numAssociation);
    dest.writeInt(userApproved);
    dest.writeInt(numNoInternetAccessReports);
    dest.writeInt(noInternetAccessExpected ? 1 : 0);
    dest.writeInt(shared ? 1 : 0);
    dest.writeString(mPasspointManagementObjectTree);
}
Body of Second Method:
{
    dest.writeInt(networkId);
    dest.writeInt(status);
    mNetworkSelectionStatus.writeToParcel(dest);
    dest.writeString(SSID);
    dest.writeString(BSSID);
    dest.writeInt(apBand);
    dest.writeInt(apChannel);
    dest.writeString(FQDN);
    dest.writeString(providerFriendlyName);
    dest.writeInt(isHomeProviderNetwork ? 1 : 0);
    dest.writeInt(roamingConsortiumIds.length);
    for (long roamingConsortiumId : roamingConsortiumIds) {
        dest.writeLong(roamingConsortiumId);
    }
    dest.writeString(preSharedKey);
    for (String wepKey : wepKeys) {
        dest.writeString(wepKey);
    }
    dest.writeInt(wepTxKeyIndex);
    dest.writeInt(priority);
    dest.writeInt(hiddenSSID ? 1 : 0);
    dest.writeInt(requirePMF ? 1 : 0);
    dest.writeString(updateIdentifier);
    writeBitSet(dest, allowedKeyManagement);
    writeBitSet(dest, allowedProtocols);
    writeBitSet(dest, allowedAuthAlgorithms);
    writeBitSet(dest, allowedPairwiseCiphers);
    writeBitSet(dest, allowedGroupCiphers);
    dest.writeParcelable(enterpriseConfig, flags);
    dest.writeParcelable(mIpConfiguration, flags);
    dest.writeString(dhcpServer);
    dest.writeString(defaultGwMacAddress);
    dest.writeInt(selfAdded ? 1 : 0);
    dest.writeInt(didSelfAdd ? 1 : 0);
    dest.writeInt(validatedInternetAccess ? 1 : 0);
    dest.writeInt(isLegacyPasspointConfig ? 1 : 0);
    dest.writeInt(ephemeral ? 1 : 0);
    dest.writeInt(meteredHint ? 1 : 0);
    dest.writeInt(meteredOverride);
    dest.writeInt(useExternalScores ? 1 : 0);
    dest.writeInt(creatorUid);
    dest.writeInt(lastConnectUid);
    dest.writeInt(lastUpdateUid);
    dest.writeString(creatorName);
    dest.writeString(lastUpdateName);
    dest.writeLong(lastConnectionFailure);
    dest.writeLong(lastRoamingFailure);
    dest.writeInt(lastRoamingFailureReason);
    dest.writeLong(roamingFailureBlackListTimeMilli);
    dest.writeInt(numScorerOverride);
    dest.writeInt(numScorerOverrideAndSwitchedNetwork);
    dest.writeInt(numAssociation);
    dest.writeInt(userApproved);
    dest.writeInt(numNoInternetAccessReports);
    dest.writeInt(noInternetAccessExpected ? 1 : 0);
    dest.writeInt(shared ? 1 : 0);
    dest.writeString(mPasspointManagementObjectTree);
    dest.writeInt(recentFailure.getAssociationStatus());
}
------------------------
Find a silently evolved API code:android.util.LongArray.remove:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Removes the value at the specified index from this array.
 */

Body of Frist Method:
{
    if (index >= mSize) {
        throw new ArrayIndexOutOfBoundsException(mSize, index);
    }
    System.arraycopy(mValues, index + 1, mValues, index, mSize - index - 1);
    mSize--;
}
Body of Second Method:
{
    checkBounds(index);
    System.arraycopy(mValues, index + 1, mValues, index, mSize - index - 1);
    mSize--;
}
------------------------
Find a silently evolved API code:android.widget.EdgeEffect.setSize:COMMENT
Method Modifier: public      
Comment:/**
 * Set the size of this edge effect in pixels.
 *
 * @param width Effect width in pixels
 * @param height Effect height in pixels
 */

Body of Frist Method:
{
    final float r = width * 0.75f / SIN;
    final float y = COS * r;
    final float h = r - y;
    final float or = height * 0.75f / SIN;
    final float oy = COS * or;
    final float oh = or - oy;
    mRadius = r;
    mBaseGlowScale = h > 0 ? Math.min(oh / h, 1.f) : 1.f;
    mBounds.set(mBounds.left, mBounds.top, width, (int) Math.min(height, h));
}
Body of Second Method:
{
    final float r = width * RADIUS_FACTOR / SIN;
    final float y = COS * r;
    final float h = r - y;
    final float or = height * RADIUS_FACTOR / SIN;
    final float oy = COS * or;
    final float oh = or - oy;
    mRadius = r;
    mBaseGlowScale = h > 0 ? Math.min(oh / h, 1.f) : 1.f;
    mBounds.set(mBounds.left, mBounds.top, width, (int) Math.min(height, h));
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothDevice.getUuids:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the supported features (UUIDs) of the remote device.
 *
 * <p>This method does not start a service discovery procedure to retrieve the UUIDs
 * from the remote device. Instead, the local cached copy of the service
 * UUIDs are returned.
 * <p>Use {@link #fetchUuidsWithSdp} if fresh UUIDs are desired.
 *
 * @return the supported features (UUIDs) of the remote device,
 * or null on error
 */

Body of Frist Method:
{
    if (sService == null || isBluetoothEnabled() == false) {
        Log.e(TAG, "BT not enabled. Cannot get remote device Uuids");
        return null;
    }
    try {
        return sService.getRemoteUuids(this);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return null;
}
Body of Second Method:
{
    final IBluetooth service = sService;
    if (service == null || !isBluetoothEnabled()) {
        Log.e(TAG, "BT not enabled. Cannot get remote device Uuids");
        return null;
    }
    try {
        return service.getRemoteUuids(this);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return null;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothDevice.getType:COMMENT
Method Modifier: public      
Comment:/**
 * Get the Bluetooth device type of the remote device.
 *
 * @return the device type {@link #DEVICE_TYPE_CLASSIC}, {@link #DEVICE_TYPE_LE}
 * {@link #DEVICE_TYPE_DUAL}.
 * {@link #DEVICE_TYPE_UNKNOWN} if it's not available
 */

Body of Frist Method:
{
    if (sService == null) {
        Log.e(TAG, "BT not enabled. Cannot get Remote Device type");
        return DEVICE_TYPE_UNKNOWN;
    }
    try {
        return sService.getRemoteType(this);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return DEVICE_TYPE_UNKNOWN;
}
Body of Second Method:
{
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, "BT not enabled. Cannot get Remote Device type");
        return DEVICE_TYPE_UNKNOWN;
    }
    try {
        return service.getRemoteType(this);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return DEVICE_TYPE_UNKNOWN;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHealth.registerAppConfiguration:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Register an application configuration that acts as a Health SINK or in a Health
 * SOURCE role.This is an asynchronous call and so
 * the callback is used to notify success or failure if the function returns true.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param name The friendly name associated with the application or configuration.
 * @param dataType The dataType of the Source role of Health Profile.
 * @param channelType The channel type. Will be one of
 * {@link #CHANNEL_TYPE_RELIABLE}  or
 * {@link #CHANNEL_TYPE_STREAMING}
 * @param callback - A callback to indicate success or failure.
 * @return If true, callback will be called.
 * @hide
 */

Body of Frist Method:
{
    boolean result = false;
    if (!isEnabled() || !checkAppParam(name, role, channelType, callback))
        return result;
    if (VDBG)
        log("registerApplication(" + name + ":" + dataType + ")");
    BluetoothHealthCallbackWrapper wrapper = new BluetoothHealthCallbackWrapper(callback);
    BluetoothHealthAppConfiguration config = new BluetoothHealthAppConfiguration(name, dataType, role, channelType);
    if (mService != null) {
        try {
            result = mService.registerAppConfiguration(config, wrapper);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return result;
}
Body of Second Method:
{
    boolean result = false;
    if (!isEnabled() || !checkAppParam(name, role, channelType, callback))
        return result;
    if (VDBG)
        log("registerApplication(" + name + ":" + dataType + ")");
    BluetoothHealthCallbackWrapper wrapper = new BluetoothHealthCallbackWrapper(callback);
    BluetoothHealthAppConfiguration config = new BluetoothHealthAppConfiguration(name, dataType, role, channelType);
    final IBluetoothHealth service = mService;
    if (service != null) {
        try {
            result = service.registerAppConfiguration(config, wrapper);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return result;
}
------------------------
Find a silently evolved API code:android.net.wifi.ScanResult.writeToParcel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Implement the Parcelable interface {@hide}
 */

Body of Frist Method:
{
    if (wifiSsid != null) {
        dest.writeInt(1);
        wifiSsid.writeToParcel(dest, flags);
    } else {
        dest.writeInt(0);
    }
    dest.writeString(SSID);
    dest.writeString(BSSID);
    dest.writeLong(hessid);
    dest.writeInt(anqpDomainId);
    dest.writeString(capabilities);
    dest.writeInt(level);
    dest.writeInt(frequency);
    dest.writeLong(timestamp);
    dest.writeInt(distanceCm);
    dest.writeInt(distanceSdCm);
    dest.writeInt(channelWidth);
    dest.writeInt(centerFreq0);
    dest.writeInt(centerFreq1);
    dest.writeLong(seen);
    dest.writeInt(untrusted ? 1 : 0);
    dest.writeInt(numConnection);
    dest.writeInt(numUsage);
    dest.writeInt(numIpConfigFailures);
    dest.writeString((venueName != null) ? venueName.toString() : "");
    dest.writeString((operatorFriendlyName != null) ? operatorFriendlyName.toString() : "");
    dest.writeLong(this.flags);
    if (informationElements != null) {
        dest.writeInt(informationElements.length);
        for (int i = 0; i < informationElements.length; i++) {
            dest.writeInt(informationElements[i].id);
            dest.writeInt(informationElements[i].bytes.length);
            dest.writeByteArray(informationElements[i].bytes);
        }
    } else {
        dest.writeInt(0);
    }
    if (anqpLines != null) {
        dest.writeInt(anqpLines.size());
        for (int i = 0; i < anqpLines.size(); i++) {
            dest.writeString(anqpLines.get(i));
        }
    } else {
        dest.writeInt(0);
    }
    if (anqpElements != null) {
        dest.writeInt(anqpElements.length);
        for (AnqpInformationElement element : anqpElements) {
            dest.writeInt(element.getVendorId());
            dest.writeInt(element.getElementId());
            dest.writeInt(element.getPayload().length);
            dest.writeByteArray(element.getPayload());
        }
    } else {
        dest.writeInt(0);
    }
}
Body of Second Method:
{
    if (wifiSsid != null) {
        dest.writeInt(1);
        wifiSsid.writeToParcel(dest, flags);
    } else {
        dest.writeInt(0);
    }
    dest.writeString(SSID);
    dest.writeString(BSSID);
    dest.writeLong(hessid);
    dest.writeInt(anqpDomainId);
    dest.writeString(capabilities);
    dest.writeInt(level);
    dest.writeInt(frequency);
    dest.writeLong(timestamp);
    dest.writeInt(distanceCm);
    dest.writeInt(distanceSdCm);
    dest.writeInt(channelWidth);
    dest.writeInt(centerFreq0);
    dest.writeInt(centerFreq1);
    dest.writeLong(seen);
    dest.writeInt(untrusted ? 1 : 0);
    dest.writeInt(numConnection);
    dest.writeInt(numUsage);
    dest.writeInt(numIpConfigFailures);
    dest.writeString((venueName != null) ? venueName.toString() : "");
    dest.writeString((operatorFriendlyName != null) ? operatorFriendlyName.toString() : "");
    dest.writeLong(this.flags);
    if (informationElements != null) {
        dest.writeInt(informationElements.length);
        for (int i = 0; i < informationElements.length; i++) {
            dest.writeInt(informationElements[i].id);
            dest.writeInt(informationElements[i].bytes.length);
            dest.writeByteArray(informationElements[i].bytes);
        }
    } else {
        dest.writeInt(0);
    }
    if (anqpLines != null) {
        dest.writeInt(anqpLines.size());
        for (int i = 0; i < anqpLines.size(); i++) {
            dest.writeString(anqpLines.get(i));
        }
    } else {
        dest.writeInt(0);
    }
    if (anqpElements != null) {
        dest.writeInt(anqpElements.length);
        for (AnqpInformationElement element : anqpElements) {
            dest.writeInt(element.getVendorId());
            dest.writeInt(element.getElementId());
            dest.writeInt(element.getPayload().length);
            dest.writeByteArray(element.getPayload());
        }
    } else {
        dest.writeInt(0);
    }
    dest.writeInt(isCarrierAp ? 1 : 0);
    dest.writeInt(carrierApEapType);
    dest.writeString(carrierName);
}
------------------------
Find a silently evolved API code:android.text.StaticLayout.Builder.addStyleRun:COMMENT
Method Modifier: default     
Comment:/* package */

Body of Frist Method:
{
    return nAddStyleRun(mNativePtr, paint.getNativeInstance(), paint.mNativeTypeface, start, end, isRtl);
}
Body of Second Method:
{
    setLocales(paint.getTextLocales());
    return nAddStyleRun(mNativePtr, paint.getNativeInstance(), paint.mNativeTypeface, start, end, isRtl);
}
------------------------
Find a silently evolved API code:android.media.MediaCas.Session.setPrivateData:COMMENT
Method Modifier: public      
Comment:/**
 * Set the private data for a session.
 *
 * @param data byte array of the private data.
 *
 * @throws IllegalStateException if the MediaCas instance is not valid.
 * @throws MediaCasException for CAS-specific errors.
 * @throws MediaCasStateException for CAS-specific state exceptions.
 */

Body of Frist Method:
{
    validateInternalStates();
    try {
        mICas.setSessionPrivateData(mSessionId, data);
    } catch (ServiceSpecificException e) {
        MediaCasException.throwExceptions(e);
    } catch (RemoteException e) {
        cleanupAndRethrowIllegalState();
    }
}
Body of Second Method:
{
    validateInternalStates();
    try {
        MediaCasException.throwExceptionIfNeeded(mICas.setSessionPrivateData(mSessionId, toByteArray(data, 0, data.length)));
    } catch (RemoteException e) {
        cleanupAndRethrowIllegalState();
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothDevice.setMessageAccessPermission:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets whether the message access is allowed to this device.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_PRIVILEGED}.
 * @param value Can be {@link #ACCESS_UNKNOWN}, {@link #ACCESS_ALLOWED} or
 * {@link #ACCESS_REJECTED}.
 * @return Whether the value has been successfully set.
 * @hide
 */

Body of Frist Method:
{
    if (sService == null) {
        return false;
    }
    try {
        return sService.setMessageAccessPermission(this, value);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
Body of Second Method:
{
    final IBluetooth service = sService;
    if (service == null) {
        return false;
    }
    try {
        return service.setMessageAccessPermission(this, value);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothInputHost.sendReport:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sends report to remote host using interrupt channel.
 *
 * @param id Report Id, as defined in descriptor. Can be 0 in case Report Id
 * are not defined in descriptor.
 * @param data Report data, not including Report Id.
 * @return
 */

Body of Frist Method:
{
    boolean result = false;
    if (mService != null) {
        try {
            result = mService.sendReport(device, id, data);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
    }
    return result;
}
Body of Second Method:
{
    boolean result = false;
    final IBluetoothInputHost service = mService;
    if (service != null) {
        try {
            result = service.sendReport(device, id, data);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
    }
    return result;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadset.phoneStateChanged:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Notify Headset of phone state change.
 * This is a backdoor for phone app to call BluetoothHeadset since
 * there is currently not a good way to get precise call state change outside
 * of phone app.
 *
 * @hide
 */

Body of Frist Method:
{
    if (mService != null && isEnabled()) {
        try {
            mService.phoneStateChanged(numActive, numHeld, callState, number, type);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
}
Body of Second Method:
{
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled()) {
        try {
            service.phoneStateChanged(numActive, numHeld, callState, number, type);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadset.getConnectedDevices:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (VDBG)
        log("getConnectedDevices()");
    if (mService != null && isEnabled()) {
        try {
            return mService.getConnectedDevices();
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
Body of Second Method:
{
    if (VDBG)
        log("getConnectedDevices()");
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.getConnectedDevices();
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadset.setPriority:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Set priority of the profile
 *
 * <p> The device should already be paired.
 * Priority can be one of {@link #PRIORITY_ON} or
 * {@link #PRIORITY_OFF},
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}
 * permission.
 *
 * @param device Paired bluetooth device
 * @param priority
 * @return true if priority is set, false on error
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("setPriority(" + device + ", " + priority + ")");
    if (mService != null && isEnabled() && isValidDevice(device)) {
        if (priority != BluetoothProfile.PRIORITY_OFF && priority != BluetoothProfile.PRIORITY_ON) {
            return false;
        }
        try {
            return mService.setPriority(device, priority);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("setPriority(" + device + ", " + priority + ")");
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        if (priority != BluetoothProfile.PRIORITY_OFF && priority != BluetoothProfile.PRIORITY_ON) {
            return false;
        }
        try {
            return service.setPriority(device, priority);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothInputDevice.setProtocolMode:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Send Set_Protocol_Mode command to the connected HID input device.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN} permission.
 *
 * @param device Remote Bluetooth Device
 * @return false on immediate error,
 * true otherwise
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("setProtocolMode(" + device + ")");
    if (mService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mService.setProtocolMode(device, protocolMode);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("setProtocolMode(" + device + ")");
    final IBluetoothInputDevice service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.setProtocolMode(device, protocolMode);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.getLastVoiceTagNumber:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get a number corresponding to last voice tag recorded on AG.
 *
 * @param device    remote device
 * @return          <code>true</code> if command has been issued successfully;
 * <code>false</code> otherwise;
 * upon completion HFP sends {@link #ACTION_LAST_VTAG}
 * or {@link #ACTION_RESULT} intent;
 *
 * <p>Feature required for successful execution is being reported by:
 * {@link #EXTRA_AG_FEATURE_ATTACH_NUMBER_TO_VT}.
 * This method invocation will fail silently when feature is not supported.</p>
 */

Body of Frist Method:
{
    if (DBG)
        log("getLastVoiceTagNumber()");
    if (mService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mService.getLastVoiceTagNumber(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("getLastVoiceTagNumber()");
    final IBluetoothHeadsetClient service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getLastVoiceTagNumber(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothPbapClient.disconnect:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Initiate disconnect.
 *
 * @param device Remote Bluetooth Device
 * @return false on error,
 * true otherwise
 */

Body of Frist Method:
{
    if (DBG) {
        log("disconnect(" + device + ")" + new Exception());
    }
    if (mService != null && isEnabled() && isValidDevice(device)) {
        try {
            mService.disconnect(device);
            return true;
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (mService == null) {
        Log.w(TAG, "Proxy not attached to service");
    }
    return false;
}
Body of Second Method:
{
    if (DBG) {
        log("disconnect(" + device + ")" + new Exception());
    }
    final IBluetoothPbapClient service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            service.disconnect(device);
            return true;
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null) {
        Log.w(TAG, "Proxy not attached to service");
    }
    return false;
}
------------------------
Find a silently evolved API code:android.net.IpSecTransform.startKeepalive:COMMENT
Method Modifier: default     hidden      
Comment:/* Package */

Body of Frist Method:
{
    // FIXME: NO_KEEPALIVE needs to be a constant
    if (mConfig.getNattKeepaliveInterval() == 0) {
        return;
    }
    ConnectivityManager cm = (ConnectivityManager) c.getSystemService(Context.CONNECTIVITY_SERVICE);
    if (mKeepalive != null) {
        Log.wtf(TAG, "Keepalive already started for this IpSecTransform.");
        return;
    }
    synchronized (mKeepaliveSyncLock) {
        mKeepalive = cm.startNattKeepalive(mConfig.getNetwork(), mConfig.getNattKeepaliveInterval(), mKeepaliveCallback, mConfig.getLocalAddress(), mConfig.getEncapLocalPort(), mConfig.getRemoteAddress());
        try {
            // FIXME: this is still a horrible way to fudge the synchronous callback
            mKeepaliveSyncLock.wait(2000);
        } catch (InterruptedException e) {
        }
    }
    if (mKeepaliveStatus != ConnectivityManager.PacketKeepalive.SUCCESS) {
        throw new UnsupportedOperationException("Packet Keepalive cannot be started");
    }
}
Body of Second Method:
{
    // FIXME: NO_KEEPALIVE needs to be a constant
    if (mConfig.getNattKeepaliveInterval() == 0) {
        return;
    }
    ConnectivityManager cm = (ConnectivityManager) c.getSystemService(Context.CONNECTIVITY_SERVICE);
    if (mKeepalive != null) {
        Log.wtf(TAG, "Keepalive already started for this IpSecTransform.");
        return;
    }
    synchronized (mKeepaliveSyncLock) {
        mKeepalive = cm.startNattKeepalive(mConfig.getNetwork(), mConfig.getNattKeepaliveInterval(), mKeepaliveCallback, mConfig.getLocalAddress(), 0x1234, /* FIXME: get the real port number again,
                                    which we need to retrieve from the provided
                                    EncapsulationSocket, and which isn't currently
                                    stashed in IpSecConfig */
        mConfig.getRemoteAddress());
        try {
            // FIXME: this is still a horrible way to fudge the synchronous callback
            mKeepaliveSyncLock.wait(2000);
        } catch (InterruptedException e) {
        }
    }
    if (mKeepaliveStatus != ConnectivityManager.PacketKeepalive.SUCCESS) {
        throw new UnsupportedOperationException("Packet Keepalive cannot be started");
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.setPriority:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Set priority of the profile
 *
 * The device should already be paired.
 */

Body of Frist Method:
{
    if (DBG)
        log("setPriority(" + device + ", " + priority + ")");
    if (mService != null && isEnabled() && isValidDevice(device)) {
        if (priority != BluetoothProfile.PRIORITY_OFF && priority != BluetoothProfile.PRIORITY_ON) {
            return false;
        }
        try {
            return mService.setPriority(device, priority);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("setPriority(" + device + ", " + priority + ")");
    final IBluetoothHeadsetClient service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        if (priority != BluetoothProfile.PRIORITY_OFF && priority != BluetoothProfile.PRIORITY_ON) {
            return false;
        }
        try {
            return service.setPriority(device, priority);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.widget.TimePickerClockDelegate.setMinute:COMMENT
Method Modifier: public      
Comment:/**
 * Set the current minute (0-59).
 */

Body of Frist Method:
{
    setMinuteInternal(minute, FROM_EXTERNAL_API);
}
Body of Second Method:
{
    setMinuteInternal(minute, FROM_EXTERNAL_API, true);
}
------------------------
Find a silently evolved API code:android.util.IntArray.remove:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Removes the value at the specified index from this array.
 */

Body of Frist Method:
{
    if (index >= mSize) {
        throw new ArrayIndexOutOfBoundsException(mSize, index);
    }
    System.arraycopy(mValues, index + 1, mValues, index, mSize - index - 1);
    mSize--;
}
Body of Second Method:
{
    checkBounds(index);
    System.arraycopy(mValues, index + 1, mValues, index, mSize - index - 1);
    mSize--;
}
------------------------
Find a silently evolved API code:android.view.accessibility.AccessibilityRecord.getSourceNodeId:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Gets the id of the source node.
 *
 * @return The id.
 *
 * @hide
 */

Body of Frist Method:
{
    return mSourceNode != null ? mSourceNode.getSourceNodeId() : UNDEFINED;
}
Body of Second Method:
{
    return mSourceNodeId;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothA2dpSink.isA2dpPlaying:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Check if A2DP profile is streaming music.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param device BluetoothDevice device
 */

Body of Frist Method:
{
    if (mService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mService.isA2dpPlaying(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    final IBluetoothA2dpSink service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.isA2dpPlaying(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothInputHost.disconnect:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Disconnects from currently connected host.
 *
 * @return
 */

Body of Frist Method:
{
    Log.v(TAG, "disconnect(): device=" + device);
    boolean result = false;
    if (mService != null) {
        try {
            result = mService.disconnect(device);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
    }
    return result;
}
Body of Second Method:
{
    Log.v(TAG, "disconnect(): device=" + device);
    boolean result = false;
    final IBluetoothInputHost service = mService;
    if (service != null) {
        try {
            result = service.disconnect(device);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
    }
    return result;
}
------------------------
Find a silently evolved API code:android.media.AudioPlaybackConfiguration.getIPlayer:COMMENT
Method Modifier: default     hidden      
Comment:/**
 * @hide
 * @return the IPlayer interface for the associated player
 */

Body of Frist Method:
{
    return mIPlayerShell == null ? null : mIPlayerShell.getIPlayer();
}
Body of Second Method:
{
    final IPlayerShell ips;
    synchronized (this) {
        ips = mIPlayerShell;
    }
    return ips == null ? null : ips.getIPlayer();
}
------------------------
Find a silently evolved API code:android.net.NetworkCapabilities.addTransportType:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Adds the given transport type to this {@code NetworkCapability} instance.
 * Multiple transports may be applied sequentially.  Note that when searching
 * for a network to satisfy a request, any listed in the request will satisfy the request.
 * For example {@code TRANSPORT_WIFI} and {@code TRANSPORT_ETHERNET} added to a
 * {@code NetworkCapabilities} would cause either a Wi-Fi network or an Ethernet network
 * to be selected.  This is logically different than
 * {@code NetworkCapabilities.NET_CAPABILITY_*} listed above.
 *
 * @param transportType the {@code NetworkCapabilities.TRANSPORT_*} to be added.
 * @return This NetworkCapabilities instance, to facilitate chaining.
 * @hide
 */

Body of Frist Method:
{
    if (transportType < MIN_TRANSPORT || transportType > MAX_TRANSPORT) {
        throw new IllegalArgumentException("TransportType out of range");
    }
    mTransportTypes |= 1 << transportType;
    // used for exception checking
    setNetworkSpecifier(mNetworkSpecifier);
    return this;
}
Body of Second Method:
{
    checkValidTransportType(transportType);
    mTransportTypes |= 1 << transportType;
    // used for exception checking
    setNetworkSpecifier(mNetworkSpecifier);
    return this;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothMap.setPriority:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Set priority of the profile
 *
 * <p> The device should already be paired.
 * Priority can be one of {@link #PRIORITY_ON} or
 * {@link #PRIORITY_OFF},
 *
 * @param device Paired bluetooth device
 * @param priority
 * @return true if priority is set, false on error
 */

Body of Frist Method:
{
    if (DBG)
        log("setPriority(" + device + ", " + priority + ")");
    if (mService != null && isEnabled() && isValidDevice(device)) {
        if (priority != BluetoothProfile.PRIORITY_OFF && priority != BluetoothProfile.PRIORITY_ON) {
            return false;
        }
        try {
            return mService.setPriority(device, priority);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("setPriority(" + device + ", " + priority + ")");
    final IBluetoothMap service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        if (priority != BluetoothProfile.PRIORITY_OFF && priority != BluetoothProfile.PRIORITY_ON) {
            return false;
        }
        try {
            return service.setPriority(device, priority);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.sendDTMF:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sends DTMF code.
 *
 * Possible code values : 0,1,2,3,4,5,6,7,8,9,A,B,C,D,*,#
 *
 * @param device    remote device
 * @param code  ASCII code
 * @return          <code>true</code> if command has been issued successfully;
 * <code>false</code> otherwise;
 * upon completion HFP sends {@link #ACTION_RESULT} intent;
 */

Body of Frist Method:
{
    if (DBG)
        log("sendDTMF()");
    if (mService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mService.sendDTMF(device, code);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("sendDTMF()");
    final IBluetoothHeadsetClient service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.sendDTMF(device, code);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothPbapClient.getDevicesMatchingConnectionStates:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the list of devices matching specified states. Currently at most one.
 *
 * @return list of matching devices
 */

Body of Frist Method:
{
    if (DBG) {
        log("getDevicesMatchingStates()");
    }
    if (mService != null && isEnabled()) {
        try {
            return mService.getDevicesMatchingConnectionStates(states);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (mService == null) {
        Log.w(TAG, "Proxy not attached to service");
    }
    return new ArrayList<BluetoothDevice>();
}
Body of Second Method:
{
    if (DBG) {
        log("getDevicesMatchingStates()");
    }
    final IBluetoothPbapClient service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.getDevicesMatchingConnectionStates(states);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null) {
        Log.w(TAG, "Proxy not attached to service");
    }
    return new ArrayList<BluetoothDevice>();
}
------------------------
Find a silently evolved API code:android.text.format.Formatter.formatBytes:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * {@hide}
 */

Body of Frist Method:
{
    final boolean isNegative = (sizeBytes < 0);
    float result = isNegative ? -sizeBytes : sizeBytes;
    int suffix = com.android.internal.R.string.byteShort;
    long mult = 1;
    if (result > 900) {
        suffix = com.android.internal.R.string.kilobyteShort;
        mult = 1000;
        result = result / 1000;
    }
    if (result > 900) {
        suffix = com.android.internal.R.string.megabyteShort;
        mult *= 1000;
        result = result / 1000;
    }
    if (result > 900) {
        suffix = com.android.internal.R.string.gigabyteShort;
        mult *= 1000;
        result = result / 1000;
    }
    if (result > 900) {
        suffix = com.android.internal.R.string.terabyteShort;
        mult *= 1000;
        result = result / 1000;
    }
    if (result > 900) {
        suffix = com.android.internal.R.string.petabyteShort;
        mult *= 1000;
        result = result / 1000;
    }
    // Note we calculate the rounded long by ourselves, but still let String.format()
    // compute the rounded value. String.format("%f", 0.1) might not return "0.1" due to
    // floating point errors.
    final int roundFactor;
    final String roundFormat;
    if (mult == 1 || result >= 100) {
        roundFactor = 1;
        roundFormat = "%.0f";
    } else if (result < 1) {
        roundFactor = 100;
        roundFormat = "%.2f";
    } else if (result < 10) {
        if ((flags & FLAG_SHORTER) != 0) {
            roundFactor = 10;
            roundFormat = "%.1f";
        } else {
            roundFactor = 100;
            roundFormat = "%.2f";
        }
    } else {
        // 10 <= result < 100
        if ((flags & FLAG_SHORTER) != 0) {
            roundFactor = 1;
            roundFormat = "%.0f";
        } else {
            roundFactor = 100;
            roundFormat = "%.2f";
        }
    }
    if (isNegative) {
        result = -result;
    }
    final String roundedString = String.format(roundFormat, result);
    // Note this might overflow if abs(result) >= Long.MAX_VALUE / 100, but that's like 80PB so
    // it's okay (for now)...
    final long roundedBytes = (flags & FLAG_CALCULATE_ROUNDED) == 0 ? 0 : (((long) Math.round(result * roundFactor)) * mult / roundFactor);
    final String units = res.getString(suffix);
    return new BytesResult(roundedString, units, roundedBytes);
}
Body of Second Method:
{
    final RoundedBytesResult rounded = RoundedBytesResult.roundBytes(sizeBytes, flags);
    final Locale locale = res.getConfiguration().getLocales().get(0);
    final NumberFormat numberFormatter = getNumberFormatter(locale, rounded.fractionDigits);
    final String formattedNumber = numberFormatter.format(rounded.value);
    final String units;
    if (rounded.units == MeasureUnit.BYTE || rounded.units == PETABYTE) {
        // ICU spells out "byte" instead of "B", and can't format petabytes yet.
        units = getSuffixOverride(res, rounded.units);
    } else {
        // Since ICU does not give us access to the pattern, we need to extract the unit string
        // from ICU, which we do by taking out the formatted number out of the formatted string
        // and trimming the result of spaces and controls.
        final String formattedMeasure = formatMeasureShort(locale, numberFormatter, rounded.value, rounded.units);
        final String numberRemoved = deleteFirstFromString(formattedMeasure, formattedNumber);
        units = SPACES_AND_CONTROLS.trim(numberRemoved).toString();
    }
    return new BytesResult(formattedNumber, units, rounded.roundedBytes);
}
------------------------
Find a silently evolved API code:android.hardware.camera2.CameraManager.getCameraCharacteristics:COMMENT
Method Modifier: public      
Comment:/**
 * <p>Query the capabilities of a camera device. These capabilities are
 * immutable for a given camera.</p>
 *
 * @param cameraId The id of the camera device to query
 * @return The properties of the given camera
 *
 * @throws IllegalArgumentException if the cameraId does not match any
 * known camera device.
 * @throws CameraAccessException if the camera device has been disconnected.
 *
 * @see #getCameraIdList
 * @see android.app.admin.DevicePolicyManager#setCameraDisabled
 */

Body of Frist Method:
{
    CameraCharacteristics characteristics = null;
    synchronized (mLock) {
        /*
             * Get the camera characteristics from the camera service directly if it supports it,
             * otherwise get them from the legacy shim instead.
             */
        ICameraService cameraService = CameraManagerGlobal.get().getCameraService();
        if (cameraService == null) {
            throw new CameraAccessException(CameraAccessException.CAMERA_DISCONNECTED, "Camera service is currently unavailable");
        }
        try {
            if (!supportsCamera2ApiLocked(cameraId)) {
                // Legacy backwards compatibility path; build static info from the camera
                // parameters
                int id = Integer.parseInt(cameraId);
                String parameters = cameraService.getLegacyParameters(id);
                CameraInfo info = cameraService.getCameraInfo(id);
                characteristics = LegacyMetadataMapper.createCharacteristics(parameters, info);
            } else {
                // Normal path: Get the camera characteristics directly from the camera service
                CameraMetadataNative info = cameraService.getCameraCharacteristics(cameraId);
                characteristics = new CameraCharacteristics(info);
            }
        } catch (ServiceSpecificException e) {
            throwAsPublicException(e);
        } catch (RemoteException e) {
            // Camera service died - act as if the camera was disconnected
            throw new CameraAccessException(CameraAccessException.CAMERA_DISCONNECTED, "Camera service is currently unavailable", e);
        }
    }
    return characteristics;
}
Body of Second Method:
{
    CameraCharacteristics characteristics = null;
    if (CameraManagerGlobal.sCameraServiceDisabled) {
        throw new IllegalArgumentException("No cameras available on device");
    }
    synchronized (mLock) {
        /*
             * Get the camera characteristics from the camera service directly if it supports it,
             * otherwise get them from the legacy shim instead.
             */
        ICameraService cameraService = CameraManagerGlobal.get().getCameraService();
        if (cameraService == null) {
            throw new CameraAccessException(CameraAccessException.CAMERA_DISCONNECTED, "Camera service is currently unavailable");
        }
        try {
            if (!supportsCamera2ApiLocked(cameraId)) {
                // Legacy backwards compatibility path; build static info from the camera
                // parameters
                int id = Integer.parseInt(cameraId);
                String parameters = cameraService.getLegacyParameters(id);
                CameraInfo info = cameraService.getCameraInfo(id);
                characteristics = LegacyMetadataMapper.createCharacteristics(parameters, info);
            } else {
                // Normal path: Get the camera characteristics directly from the camera service
                CameraMetadataNative info = cameraService.getCameraCharacteristics(cameraId);
                characteristics = new CameraCharacteristics(info);
            }
        } catch (ServiceSpecificException e) {
            throwAsPublicException(e);
        } catch (RemoteException e) {
            // Camera service died - act as if the camera was disconnected
            throw new CameraAccessException(CameraAccessException.CAMERA_DISCONNECTED, "Camera service is currently unavailable", e);
        }
    }
    return characteristics;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadset.rejectIncomingConnect:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Reject the incoming connection.
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("rejectIncomingConnect");
    if (mService != null) {
        try {
            return mService.rejectIncomingConnect(device);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("rejectIncomingConnect");
    final IBluetoothHeadset service = mService;
    if (service != null) {
        try {
            return service.rejectIncomingConnect(device);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return false;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.connect:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Connects to remote device.
 *
 * Currently, the system supports only 1 connection. So, in case of the
 * second connection, this implementation will disconnect already connected
 * device automatically and will process the new one.
 *
 * @param device    a remote device we want connect to
 * @return <code>true</code> if command has been issued successfully;
 * <code>false</code> otherwise;
 * upon completion HFP sends {@link #ACTION_CONNECTION_STATE_CHANGED}
 * intent.
 */

Body of Frist Method:
{
    if (DBG)
        log("connect(" + device + ")");
    if (mService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mService.connect(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("connect(" + device + ")");
    final IBluetoothHeadsetClient service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.connect(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.app.usage.NetworkStatsManager.queryDetails:COMMENT
Method Modifier: public      
Comment:/**
 * Query network usage statistics details. Result filtered to include only uids belonging to
 * calling user. Result is aggregated over state but not aggregated over time, uid, tag,
 * metered, nor roaming. This means buckets' start and end timestamps are going to be between
 * 'startTime' and 'endTime' parameters. State is going to be
 * {@link NetworkStats.Bucket#STATE_ALL}, uid will vary,
 * tag {@link NetworkStats.Bucket#TAG_NONE}, metered is going to be
 * {@link NetworkStats.Bucket#METERED_ALL}, and roaming is going to be
 * {@link NetworkStats.Bucket#ROAMING_ALL}.
 * <p>Only includes buckets that atomically occur in the inclusive time range. Doesn't
 * interpolate across partial buckets. Since bucket length is in the order of hours, this
 * method cannot be used to measure data usage on a fine grained time scale.
 *
 * @param networkType As defined in {@link ConnectivityManager}, e.g.
 * {@link ConnectivityManager#TYPE_MOBILE}, {@link ConnectivityManager#TYPE_WIFI}
 * etc.
 * @param subscriberId If applicable, the subscriber id of the network interface.
 * @param startTime Start of period. Defined in terms of "Unix time", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param endTime End of period. Defined in terms of "Unix time", see
 * {@link java.lang.System#currentTimeMillis}.
 * @return Statistics object or null if permissions are insufficient or error happened during
 * statistics collection.
 */

Body of Frist Method:
{
    NetworkTemplate template;
    try {
        template = createTemplate(networkType, subscriberId);
    } catch (IllegalArgumentException e) {
        if (DBG)
            Log.e(TAG, "Cannot create template", e);
        return null;
    }
    NetworkStats result;
    result = new NetworkStats(mContext, template, startTime, endTime);
    result.startUserUidEnumeration();
    return result;
}
Body of Second Method:
{
    NetworkTemplate template;
    try {
        template = createTemplate(networkType, subscriberId);
    } catch (IllegalArgumentException e) {
        if (DBG)
            Log.e(TAG, "Cannot create template", e);
        return null;
    }
    NetworkStats result;
    result = new NetworkStats(mContext, template, mFlags, startTime, endTime);
    result.startUserUidEnumeration();
    return result;
}
------------------------
Find a silently evolved API code:android.os.MemoryFile.close:COMMENT
Method Modifier: public      
Comment:/**
 * Closes the memory file. If there are no other open references to the memory
 * file, it will be deleted.
 */

Body of Frist Method:
{
    deactivate();
    if (!isClosed()) {
        native_close(mFD);
    }
}
Body of Second Method:
{
    deactivate();
    mSharedMemory.close();
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadset.disableWBS:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * disable WBS codec settting. It set NBS codec.
 *
 * @return true if successful
 * false if there was some error such as
 * there is no connected headset
 * @hide
 */

Body of Frist Method:
{
    if (mService != null && isEnabled()) {
        try {
            return mService.disableWBS();
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return false;
}
Body of Second Method:
{
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.disableWBS();
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return false;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothInputHost.unregisterApp:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Unregisters application. Active connection will be disconnected and no
 * new connections will be allowed until registered again using
 * {@link #registerApp(String, String, String, byte, byte[], BluetoothHidDeviceCallback)}
 *
 * @param config {@link BluetoothHidDeviceAppConfiguration} object as
 * obtained from
 * {@link BluetoothHidDeviceCallback#onAppStatusChanged(BluetoothDevice,
 * BluetoothHidDeviceAppConfiguration, boolean)}
 *
 * @return
 */

Body of Frist Method:
{
    Log.v(TAG, "unregisterApp()");
    boolean result = false;
    if (mService != null) {
        try {
            result = mService.unregisterApp(config);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
    }
    return result;
}
Body of Second Method:
{
    Log.v(TAG, "unregisterApp()");
    boolean result = false;
    final IBluetoothInputHost service = mService;
    if (service != null) {
        try {
            result = service.unregisterApp(config);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
    }
    return result;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothDevice.setPairingConfirmation:COMMENT
Method Modifier: public      
Comment:/**
 * Confirm passkey for {@link #PAIRING_VARIANT_PASSKEY_CONFIRMATION} pairing.
 *
 * @return true confirmation has been sent out
 * false for error
 */

Body of Frist Method:
{
    if (sService == null) {
        Log.e(TAG, "BT not enabled. Cannot set pairing confirmation");
        return false;
    }
    try {
        return sService.setPairingConfirmation(this, confirm);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
Body of Second Method:
{
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, "BT not enabled. Cannot set pairing confirmation");
        return false;
    }
    try {
        return service.setPairingConfirmation(this, confirm);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
------------------------
Find a silently evolved API code:android.os.ParcelableException.readFromParcel:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * {@hide}
 */

Body of Frist Method:
{
    final String name = in.readString();
    final String msg = in.readString();
    try {
        final Class<?> clazz = Class.forName(name, true, Parcelable.class.getClassLoader());
        return (Throwable) clazz.getConstructor(String.class).newInstance(msg);
    } catch (ReflectiveOperationException e) {
        throw new RuntimeException(name + ": " + msg);
    }
}
Body of Second Method:
{
    final String name = in.readString();
    final String msg = in.readString();
    try {
        final Class<?> clazz = Class.forName(name, true, Parcelable.class.getClassLoader());
        if (Throwable.class.isAssignableFrom(clazz)) {
            return (Throwable) clazz.getConstructor(String.class).newInstance(msg);
        }
    } catch (ReflectiveOperationException e) {
    }
    return new RuntimeException(name + ": " + msg);
}
------------------------
Find a silently evolved API code:android.graphics.Shader.getNativeInstance:COMMENT
Method Modifier: public      final       hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    // verify mNativeInstance is valid
    verifyNativeInstance();
    if (mNativeInstance == 0) {
        mNativeInstance = createNativeInstance(mLocalMatrix == null ? 0 : mLocalMatrix.native_instance);
        mCleaner = NoImagePreloadHolder.sRegistry.registerNativeAllocation(this, mNativeInstance);
    }
    return mNativeInstance;
}
Body of Second Method:
{
    // verify mNativeInstance is valid
    verifyNativeInstance();
    if (mNativeInstance == 0) {
        mNativeInstance = createNativeInstance(mLocalMatrix == null ? 0 : mLocalMatrix.native_instance);
        if (mNativeInstance != 0) {
            mCleaner = NoImagePreloadHolder.sRegistry.registerNativeAllocation(this, mNativeInstance);
        }
    }
    return mNativeInstance;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadset.getConnectionState:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (VDBG)
        log("getConnectionState(" + device + ")");
    if (mService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mService.getConnectionState(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.STATE_DISCONNECTED;
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return BluetoothProfile.STATE_DISCONNECTED;
}
Body of Second Method:
{
    if (VDBG)
        log("getConnectionState(" + device + ")");
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getConnectionState(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.STATE_DISCONNECTED;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return BluetoothProfile.STATE_DISCONNECTED;
}
------------------------
Find a silently evolved API code:android.media.MediaCas.provision:COMMENT
Method Modifier: public      
Comment:/**
 * Initiate a provisioning operation for a CA system.
 *
 * @param provisionString string containing information needed for the
 * provisioning operation, the format of which is scheme and implementation
 * specific.
 *
 * @throws IllegalStateException if the MediaCas instance is not valid.
 * @throws MediaCasException for CAS-specific errors.
 * @throws MediaCasStateException for CAS-specific state exceptions.
 */

Body of Frist Method:
{
    validateInternalStates();
    try {
        mICas.provision(provisionString);
    } catch (ServiceSpecificException e) {
        MediaCasException.throwExceptions(e);
    } catch (RemoteException e) {
        cleanupAndRethrowIllegalState();
    }
}
Body of Second Method:
{
    validateInternalStates();
    try {
        MediaCasException.throwExceptionIfNeeded(mICas.provision(provisionString));
    } catch (RemoteException e) {
        cleanupAndRethrowIllegalState();
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothInputHost.replyReport:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sends report to remote host as reply for GET_REPORT request from
 * {@link BluetoothHidDeviceCallback#onGetReport(BluetoothDevice, byte, byte, int)}.
 *
 * @param type Report Type, as in request.
 * @param id Report Id, as in request.
 * @param data Report data, not including Report Id.
 * @return
 */

Body of Frist Method:
{
    Log.v(TAG, "replyReport(): device=" + device + " type=" + type + " id=" + id);
    boolean result = false;
    if (mService != null) {
        try {
            result = mService.replyReport(device, type, id, data);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
    }
    return result;
}
Body of Second Method:
{
    Log.v(TAG, "replyReport(): device=" + device + " type=" + type + " id=" + id);
    boolean result = false;
    final IBluetoothInputHost service = mService;
    if (service != null) {
        try {
            result = service.replyReport(device, type, id, data);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
    }
    return result;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothAvrcpController.getConnectedDevices:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (VDBG)
        log("getConnectedDevices()");
    if (mService != null && isEnabled()) {
        try {
            return mService.getConnectedDevices();
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
Body of Second Method:
{
    if (VDBG)
        log("getConnectedDevices()");
    final IBluetoothAvrcpController service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.getConnectedDevices();
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
------------------------
Find a silently evolved API code:android.net.wifi.aware.WifiAwareNetworkSpecifier.hashCode:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    int result = 17;
    result = 31 * result + type;
    result = 31 * result + role;
    result = 31 * result + clientId;
    result = 31 * result + sessionId;
    result = 31 * result + peerId;
    result = 31 * result + Arrays.hashCode(peerMac);
    result = 31 * result + Arrays.hashCode(pmk);
    result = 31 * result + Objects.hashCode(passphrase);
    return result;
}
Body of Second Method:
{
    int result = 17;
    result = 31 * result + type;
    result = 31 * result + role;
    result = 31 * result + clientId;
    result = 31 * result + sessionId;
    result = 31 * result + peerId;
    result = 31 * result + Arrays.hashCode(peerMac);
    result = 31 * result + Arrays.hashCode(pmk);
    result = 31 * result + Objects.hashCode(passphrase);
    result = 31 * result + requestorUid;
    return result;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothPbap.isConnected:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns true if the specified Bluetooth device is connected (does not
 * include connecting). Returns false if not connected, or if this proxy
 * object is not currently connected to the Pbap service.
 */

Body of Frist Method:
{
    if (VDBG)
        log("isConnected(" + device + ")");
    if (mService != null) {
        try {
            return mService.isConnected(device);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            log(Log.getStackTraceString(new Throwable()));
    }
    return false;
}
Body of Second Method:
{
    if (VDBG)
        log("isConnected(" + device + ")");
    final IBluetoothPbap service = mService;
    if (service != null) {
        try {
            return service.isConnected(device);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            log(Log.getStackTraceString(new Throwable()));
    }
    return false;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothSap.getState:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the current state of the BluetoothSap service.
 * @return One of the STATE_ return codes, or STATE_ERROR if this proxy
 * object is currently not connected to the Sap service.
 * @hide
 */

Body of Frist Method:
{
    if (VDBG)
        log("getState()");
    if (mService != null) {
        try {
            return mService.getState();
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            log(Log.getStackTraceString(new Throwable()));
    }
    return BluetoothSap.STATE_ERROR;
}
Body of Second Method:
{
    if (VDBG)
        log("getState()");
    final IBluetoothSap service = mService;
    if (service != null) {
        try {
            return service.getState();
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            log(Log.getStackTraceString(new Throwable()));
    }
    return BluetoothSap.STATE_ERROR;
}
------------------------
Find a silently evolved API code:android.telephony.TelephonyManager.listen:COMMENT
Method Modifier: public      
Comment:/**
 * Registers a listener object to receive notification of changes
 * in specified telephony states.
 * <p>
 * To register a listener, pass a {@link PhoneStateListener}
 * and specify at least one telephony state of interest in
 * the events argument.
 *
 * At registration, and when a specified telephony state
 * changes, the telephony manager invokes the appropriate
 * callback method on the listener object and passes the
 * current (updated) values.
 * <p>
 * To unregister a listener, pass the listener object and set the
 * events argument to
 * {@link PhoneStateListener#LISTEN_NONE LISTEN_NONE} (0).
 *
 * @param listener The {@link PhoneStateListener} object to register
 * (or unregister)
 * @param events The telephony state(s) of interest to the listener,
 * as a bitwise-OR combination of {@link PhoneStateListener}
 * LISTEN_ flags.
 */

Body of Frist Method:
{
    if (mContext == null)
        return;
    try {
        boolean notifyNow = (getITelephony() != null);
        // telephony manager is created with.
        if (listener.mSubId == null) {
            listener.mSubId = mSubId;
        }
        sRegistry.listenForSubscriber(listener.mSubId, getOpPackageName(), listener.callback, events, notifyNow);
    } catch (RemoteException ex) {
    // system process dead
    } catch (NullPointerException ex) {
    // system process dead
    }
}
Body of Second Method:
{
    if (mContext == null)
        return;
    try {
        boolean notifyNow = (getITelephony() != null);
        // telephony manager is created with.
        if (listener.mSubId == null) {
            listener.mSubId = mSubId;
        }
        ITelephonyRegistry registry = getTelephonyRegistry();
        if (registry != null) {
            registry.listenForSubscriber(listener.mSubId, getOpPackageName(), listener.callback, events, notifyNow);
        } else {
            Rlog.w(TAG, "telephony registry not ready.");
        }
    } catch (RemoteException ex) {
    // system process dead
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothDevice.setSimAccessPermission:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets whether the Sim access is allowed to this device.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_PRIVILEGED}.
 * @param value Can be {@link #ACCESS_UNKNOWN}, {@link #ACCESS_ALLOWED} or
 * {@link #ACCESS_REJECTED}.
 * @return Whether the value has been successfully set.
 * @hide
 */

Body of Frist Method:
{
    if (sService == null) {
        return false;
    }
    try {
        return sService.setSimAccessPermission(this, value);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
Body of Second Method:
{
    final IBluetooth service = sService;
    if (service == null) {
        return false;
    }
    try {
        return service.setSimAccessPermission(this, value);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothInputHost.registerApp:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Registers application to be used for HID device. Connections to HID
 * Device are only possible when application is registered. Only one
 * application can be registered at time. When no longer used, application
 * should be unregistered using
 * {@link #unregisterApp(BluetoothHidDeviceAppConfiguration)}.
 *
 * @param sdp {@link BluetoothHidDeviceAppSdpSettings} object of
 * HID Device SDP record.
 * @param inQos {@link BluetoothHidDeviceAppQosSettings} object of
 * Incoming QoS Settings.
 * @param outQos {@link BluetoothHidDeviceAppQosSettings} object of
 * Outgoing QoS Settings.
 * @param callback {@link BluetoothHidDeviceCallback} object to which
 * callback messages will be sent.
 * @return
 */

Body of Frist Method:
{
    Log.v(TAG, "registerApp(): sdp=" + sdp + " inQos=" + inQos + " outQos=" + outQos + " callback=" + callback);
    boolean result = false;
    if (sdp == null || callback == null) {
        return false;
    }
    if (mService != null) {
        try {
            BluetoothHidDeviceAppConfiguration config = new BluetoothHidDeviceAppConfiguration();
            BluetoothHidDeviceCallbackWrapper cbw = new BluetoothHidDeviceCallbackWrapper(callback);
            result = mService.registerApp(config, sdp, inQos, outQos, cbw);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
    }
    return result;
}
Body of Second Method:
{
    Log.v(TAG, "registerApp(): sdp=" + sdp + " inQos=" + inQos + " outQos=" + outQos + " callback=" + callback);
    boolean result = false;
    if (sdp == null || callback == null) {
        return false;
    }
    final IBluetoothInputHost service = mService;
    if (service != null) {
        try {
            BluetoothHidDeviceAppConfiguration config = new BluetoothHidDeviceAppConfiguration();
            BluetoothHidDeviceCallbackWrapper cbw = new BluetoothHidDeviceCallbackWrapper(callback);
            result = service.registerApp(config, sdp, inQos, outQos, cbw);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
    }
    return result;
}
------------------------
Find a silently evolved API code:android.app.usage.NetworkStatsManager.querySummaryForDevice:COMMENT
Method Modifier: public      
Comment:/**
 * Query network usage statistics summaries. Result is summarised data usage for the whole
 * device. Result is a single Bucket aggregated over time, state, uid, tag, metered, and
 * roaming. This means the bucket's start and end timestamp are going to be the same as the
 * 'startTime' and 'endTime' parameters. State is going to be
 * {@link NetworkStats.Bucket#STATE_ALL}, uid {@link NetworkStats.Bucket#UID_ALL},
 * tag {@link NetworkStats.Bucket#TAG_NONE}, metered {@link NetworkStats.Bucket#METERED_ALL},
 * and roaming {@link NetworkStats.Bucket#ROAMING_ALL}.
 *
 * @param networkType As defined in {@link ConnectivityManager}, e.g.
 * {@link ConnectivityManager#TYPE_MOBILE}, {@link ConnectivityManager#TYPE_WIFI}
 * etc.
 * @param subscriberId If applicable, the subscriber id of the network interface.
 * @param startTime Start of period. Defined in terms of "Unix time", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param endTime End of period. Defined in terms of "Unix time", see
 * {@link java.lang.System#currentTimeMillis}.
 * @return Bucket object or null if permissions are insufficient or error happened during
 * statistics collection.
 */

Body of Frist Method:
{
    NetworkTemplate template;
    try {
        template = createTemplate(networkType, subscriberId);
    } catch (IllegalArgumentException e) {
        if (DBG)
            Log.e(TAG, "Cannot create template", e);
        return null;
    }
    Bucket bucket = null;
    NetworkStats stats = new NetworkStats(mContext, template, startTime, endTime);
    bucket = stats.getDeviceSummaryForNetwork();
    stats.close();
    return bucket;
}
Body of Second Method:
{
    NetworkTemplate template;
    try {
        template = createTemplate(networkType, subscriberId);
    } catch (IllegalArgumentException e) {
        if (DBG)
            Log.e(TAG, "Cannot create template", e);
        return null;
    }
    Bucket bucket = null;
    NetworkStats stats = new NetworkStats(mContext, template, mFlags, startTime, endTime);
    bucket = stats.getDeviceSummaryForNetwork();
    stats.close();
    return bucket;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHealth.unregisterAppConfiguration:COMMENT
Method Modifier: public      
Comment:/**
 * Unregister an application configuration that has been registered using
 * {@link #registerSinkAppConfiguration}
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param config  The health app configuration
 * @return Success or failure.
 */

Body of Frist Method:
{
    boolean result = false;
    if (mService != null && isEnabled() && config != null) {
        try {
            result = mService.unregisterAppConfiguration(config);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return result;
}
Body of Second Method:
{
    boolean result = false;
    final IBluetoothHealth service = mService;
    if (service != null && isEnabled() && config != null) {
        try {
            result = service.unregisterAppConfiguration(config);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return result;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadset.getAudioState:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the current audio state of the Headset.
 * Note: This is an internal function and shouldn't be exposed
 *
 * @hide
 */

Body of Frist Method:
{
    if (VDBG)
        log("getAudioState");
    if (mService != null && !isDisabled()) {
        try {
            return mService.getAudioState(device);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return BluetoothHeadset.STATE_AUDIO_DISCONNECTED;
}
Body of Second Method:
{
    if (VDBG)
        log("getAudioState");
    final IBluetoothHeadset service = mService;
    if (service != null && !isDisabled()) {
        try {
            return service.getAudioState(device);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return BluetoothHeadset.STATE_AUDIO_DISCONNECTED;
}
------------------------
Find a silently evolved API code:android.os.Debug.MemoryInfo.getOtherLabel:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    switch(which) {
        case OTHER_DALVIK_OTHER:
            return "Dalvik Other";
        case OTHER_STACK:
            return "Stack";
        case OTHER_CURSOR:
            return "Cursor";
        case OTHER_ASHMEM:
            return "Ashmem";
        case OTHER_GL_DEV:
            return "Gfx dev";
        case OTHER_UNKNOWN_DEV:
            return "Other dev";
        case OTHER_SO:
            return ".so mmap";
        case OTHER_JAR:
            return ".jar mmap";
        case OTHER_APK:
            return ".apk mmap";
        case OTHER_TTF:
            return ".ttf mmap";
        case OTHER_DEX:
            return ".dex mmap";
        case OTHER_OAT:
            return ".oat mmap";
        case OTHER_ART:
            return ".art mmap";
        case OTHER_UNKNOWN_MAP:
            return "Other mmap";
        case OTHER_GRAPHICS:
            return "EGL mtrack";
        case OTHER_GL:
            return "GL mtrack";
        case OTHER_OTHER_MEMTRACK:
            return "Other mtrack";
        case OTHER_DALVIK_NORMAL:
            return ".Heap";
        case OTHER_DALVIK_LARGE:
            return ".LOS";
        case OTHER_DALVIK_LINEARALLOC:
            return ".LinearAlloc";
        case OTHER_DALVIK_ACCOUNTING:
            return ".GC";
        case OTHER_DALVIK_CODE_CACHE:
            return ".JITCache";
        case OTHER_DALVIK_ZYGOTE:
            return ".Zygote";
        case OTHER_DALVIK_NON_MOVING:
            return ".NonMoving";
        case OTHER_DALVIK_INDIRECT_REFERENCE_TABLE:
            return ".IndirectRef";
        default:
            return "????";
    }
}
Body of Second Method:
{
    switch(which) {
        case OTHER_DALVIK_OTHER:
            return "Dalvik Other";
        case OTHER_STACK:
            return "Stack";
        case OTHER_CURSOR:
            return "Cursor";
        case OTHER_ASHMEM:
            return "Ashmem";
        case OTHER_GL_DEV:
            return "Gfx dev";
        case OTHER_UNKNOWN_DEV:
            return "Other dev";
        case OTHER_SO:
            return ".so mmap";
        case OTHER_JAR:
            return ".jar mmap";
        case OTHER_APK:
            return ".apk mmap";
        case OTHER_TTF:
            return ".ttf mmap";
        case OTHER_DEX:
            return ".dex mmap";
        case OTHER_OAT:
            return ".oat mmap";
        case OTHER_ART:
            return ".art mmap";
        case OTHER_UNKNOWN_MAP:
            return "Other mmap";
        case OTHER_GRAPHICS:
            return "EGL mtrack";
        case OTHER_GL:
            return "GL mtrack";
        case OTHER_OTHER_MEMTRACK:
            return "Other mtrack";
        case OTHER_DALVIK_NORMAL:
            return ".Heap";
        case OTHER_DALVIK_LARGE:
            return ".LOS";
        case OTHER_DALVIK_ZYGOTE:
            return ".Zygote";
        case OTHER_DALVIK_NON_MOVING:
            return ".NonMoving";
        case OTHER_DALVIK_OTHER_LINEARALLOC:
            return ".LinearAlloc";
        case OTHER_DALVIK_OTHER_ACCOUNTING:
            return ".GC";
        case OTHER_DALVIK_OTHER_CODE_CACHE:
            return ".JITCache";
        case OTHER_DALVIK_OTHER_COMPILER_METADATA:
            return ".CompilerMetadata";
        case OTHER_DALVIK_OTHER_INDIRECT_REFERENCE_TABLE:
            return ".IndirectRef";
        case OTHER_DEX_BOOT_VDEX:
            return ".Boot vdex";
        case OTHER_DEX_APP_DEX:
            return ".App dex";
        case OTHER_DEX_APP_VDEX:
            return ".App vdex";
        case OTHER_ART_APP:
            return ".App art";
        case OTHER_ART_BOOT:
            return ".Boot art";
        default:
            return "????";
    }
}
------------------------
Find a silently evolved API code:android.text.style.TextAppearanceSpan.getFamily:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the typeface family specified by this span, or <code>null</code>
 * if it does not specify one.
 */

Body of Frist Method:
{
    return mTypeface;
}
Body of Second Method:
{
    return mFamilyName;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothInputHost.unplug:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sends Virtual Cable Unplug to currently connected host.
 *
 * @return
 */

Body of Frist Method:
{
    Log.v(TAG, "unplug(): device=" + device);
    boolean result = false;
    if (mService != null) {
        try {
            result = mService.unplug(device);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
    }
    return result;
}
Body of Second Method:
{
    Log.v(TAG, "unplug(): device=" + device);
    boolean result = false;
    final IBluetoothInputHost service = mService;
    if (service != null) {
        try {
            result = service.unplug(device);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
    }
    return result;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.rejectCall:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Rejects a call.
 *
 * @param device    remote device
 * @return          <code>true</code> if command has been issued successfully;
 * <code>false</code> otherwise;
 * upon completion HFP sends {@link #ACTION_CALL_CHANGED}
 * intent.
 *
 * <p>Feature required for successful execution is being reported by:
 * {@link #EXTRA_AG_FEATURE_REJECT_CALL}.
 * This method invocation will fail silently when feature is not supported.</p>
 */

Body of Frist Method:
{
    if (DBG)
        log("rejectCall()");
    if (mService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mService.rejectCall(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("rejectCall()");
    final IBluetoothHeadsetClient service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.rejectCall(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.hardware.usb.UsbManager.setPortRoles:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets the desired role combination of the port.
 * <p>
 * The supported role combinations depend on what is connected to the port and may be
 * determined by consulting
 * {@link UsbPortStatus#isRoleCombinationSupported UsbPortStatus.isRoleCombinationSupported}.
 * </p><p>
 * Note: This function is asynchronous and may fail silently without applying
 * the requested changes.  If this function does cause a status change to occur then
 * a {@link #ACTION_USB_PORT_CHANGED} broadcast will be sent.
 * </p>
 *
 * @param powerRole The desired power role: {@link UsbPort#POWER_ROLE_SOURCE}
 * or {@link UsbPort#POWER_ROLE_SINK}, or 0 if no power role.
 * @param dataRole The desired data role: {@link UsbPort#DATA_ROLE_HOST}
 * or {@link UsbPort#DATA_ROLE_DEVICE}, or 0 if no data role.
 *
 * @hide
 */

Body of Frist Method:
{
    Preconditions.checkNotNull(port, "port must not be null");
    UsbPort.checkRoles(powerRole, dataRole);
    try {
        mService.setPortRoles(port.getId(), powerRole, dataRole);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    Preconditions.checkNotNull(port, "port must not be null");
    UsbPort.checkRoles(powerRole, dataRole);
    Log.d(TAG, "setPortRoles Package:" + mContext.getPackageName());
    try {
        mService.setPortRoles(port.getId(), powerRole, dataRole);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothA2dpSink.getConnectionState:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (VDBG)
        log("getState(" + device + ")");
    if (mService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mService.getConnectionState(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.STATE_DISCONNECTED;
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return BluetoothProfile.STATE_DISCONNECTED;
}
Body of Second Method:
{
    if (VDBG)
        log("getState(" + device + ")");
    final IBluetoothA2dpSink service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getConnectionState(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.STATE_DISCONNECTED;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return BluetoothProfile.STATE_DISCONNECTED;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.getCurrentAgEvents:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns list of current values of AG indicators.
 *
 * @param device    remote device
 * @return          bundle of AG  indicators; null if device is not in
 * CONNECTED state
 */

Body of Frist Method:
{
    if (DBG)
        log("getCurrentCalls()");
    if (mService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mService.getCurrentAgEvents(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return null;
}
Body of Second Method:
{
    if (DBG)
        log("getCurrentCalls()");
    final IBluetoothHeadsetClient service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getCurrentAgEvents(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return null;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothInputDevice.virtualUnplug:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Initiate virtual unplug for a HID input device.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN} permission.
 *
 * @param device Remote Bluetooth Device
 * @return false on immediate error,
 * true otherwise
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("virtualUnplug(" + device + ")");
    if (mService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mService.virtualUnplug(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("virtualUnplug(" + device + ")");
    final IBluetoothInputDevice service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.virtualUnplug(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothMap.getClient:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the currently connected remote Bluetooth device (PCE).
 * @return The remote Bluetooth device, or null if not in connected or
 * connecting state, or if this proxy object is not connected to
 * the Map service.
 */

Body of Frist Method:
{
    if (VDBG)
        log("getClient()");
    if (mService != null) {
        try {
            return mService.getClient();
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            log(Log.getStackTraceString(new Throwable()));
    }
    return null;
}
Body of Second Method:
{
    if (VDBG)
        log("getClient()");
    final IBluetoothMap service = mService;
    if (service != null) {
        try {
            return service.getClient();
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            log(Log.getStackTraceString(new Throwable()));
    }
    return null;
}
------------------------
Find a silently evolved API code:android.media.AudioPlaybackConfiguration.handleStateEvent:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 * Handle a player state change
 * @param event
 * @return true if the state changed, false otherwise
 */

Body of Frist Method:
{
    final boolean changed = (mPlayerState != event);
    mPlayerState = event;
    if ((event == PLAYER_STATE_RELEASED) && (mIPlayerShell != null)) {
        mIPlayerShell.release();
    }
    return changed;
}
Body of Second Method:
{
    final boolean changed;
    synchronized (this) {
        changed = (mPlayerState != event);
        mPlayerState = event;
        if (changed && (event == PLAYER_STATE_RELEASED) && (mIPlayerShell != null)) {
            mIPlayerShell.release();
            mIPlayerShell = null;
        }
    }
    return changed;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothPbap.disconnect:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Disconnects the current Pbap client (PCE). Currently this call blocks,
 * it may soon be made asynchronous. Returns false if this proxy object is
 * not currently connected to the Pbap service.
 */

Body of Frist Method:
{
    if (DBG)
        log("disconnect()");
    if (mService != null) {
        try {
            mService.disconnect();
            return true;
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            log(Log.getStackTraceString(new Throwable()));
    }
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("disconnect()");
    final IBluetoothPbap service = mService;
    if (service != null) {
        try {
            service.disconnect();
            return true;
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            log(Log.getStackTraceString(new Throwable()));
    }
    return false;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHealth.getConnectionState:COMMENT
Method Modifier: public      
Comment:/**
 * Get the current connection state of the profile.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * This is not specific to any application configuration but represents the connection
 * state of the local Bluetooth adapter with the remote device. This can be used
 * by applications like status bar which would just like to know the state of the
 * local adapter.
 *
 * @param device Remote bluetooth device.
 * @return State of the profile connection. One of
 * {@link #STATE_CONNECTED}, {@link #STATE_CONNECTING},
 * {@link #STATE_DISCONNECTED}, {@link #STATE_DISCONNECTING}
 */

Body of Frist Method:
{
    if (mService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mService.getHealthDeviceConnectionState(device);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return STATE_DISCONNECTED;
}
Body of Second Method:
{
    final IBluetoothHealth service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getHealthDeviceConnectionState(device);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return STATE_DISCONNECTED;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothSap.getClient:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the currently connected remote Bluetooth device (PCE).
 * @return The remote Bluetooth device, or null if not in connected or
 * connecting state, or if this proxy object is not connected to
 * the Sap service.
 * @hide
 */

Body of Frist Method:
{
    if (VDBG)
        log("getClient()");
    if (mService != null) {
        try {
            return mService.getClient();
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            log(Log.getStackTraceString(new Throwable()));
    }
    return null;
}
Body of Second Method:
{
    if (VDBG)
        log("getClient()");
    final IBluetoothSap service = mService;
    if (service != null) {
        try {
            return service.getClient();
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            log(Log.getStackTraceString(new Throwable()));
    }
    return null;
}
------------------------
Find a silently evolved API code:android.hardware.usb.UsbManager.getPorts:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns a list of physical USB ports on the device.
 * <p>
 * This list is guaranteed to contain all dual-role USB Type C ports but it might
 * be missing other ports depending on whether the kernel USB drivers have been
 * updated to publish all of the device's ports through the new "dual_role_usb"
 * device class (which supports all types of ports despite its name).
 * </p>
 *
 * @return The list of USB ports, or null if none.
 *
 * @hide
 */

Body of Frist Method:
{
    try {
        return mService.getPorts();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    if (mService == null) {
        return null;
    }
    try {
        return mService.getPorts();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.util.LongArray.get:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns the value at the specified position in this array.
 */

Body of Frist Method:
{
    if (index >= mSize) {
        throw new ArrayIndexOutOfBoundsException(mSize, index);
    }
    return mValues[index];
}
Body of Second Method:
{
    checkBounds(index);
    return mValues[index];
}
------------------------
Find a silently evolved API code:android.hardware.usb.UsbManager.getAccessoryList:COMMENT
Method Modifier: public      
Comment:/**
 * Returns a list of currently attached USB accessories.
 * (in the current implementation there can be at most one)
 *
 * @return list of USB accessories, or null if none are attached.
 */

Body of Frist Method:
{
    try {
        UsbAccessory accessory = mService.getCurrentAccessory();
        if (accessory == null) {
            return null;
        } else {
            return new UsbAccessory[] { accessory };
        }
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    if (mService == null) {
        return null;
    }
    try {
        UsbAccessory accessory = mService.getCurrentAccessory();
        if (accessory == null) {
            return null;
        } else {
            return new UsbAccessory[] { accessory };
        }
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.os.MemoryFile.deactivate:COMMENT
Method Modifier: default     hidden      
Comment:/**
 * Unmaps the memory file from the process's memory space, but does not close it.
 * After this method has been called, read and write operations through this object
 * will fail, but {@link #getFileDescriptor()} will still return a valid file descriptor.
 *
 * @hide
 */

Body of Frist Method:
{
    if (!isDeactivated()) {
        try {
            native_munmap(mAddress, mLength);
            mAddress = 0;
        } catch (IOException ex) {
            Log.e(TAG, ex.toString());
        }
    }
}
Body of Second Method:
{
    if (mMapping != null) {
        SharedMemory.unmap(mMapping);
        mMapping = null;
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothA2dpSink.disconnect:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Initiate disconnection from a profile
 *
 * <p> This API will return false in scenarios like the profile on the
 * Bluetooth device is not in connected state etc. When this API returns,
 * true, it is guaranteed that the connection state change
 * intent will be broadcasted with the state. Users can get the
 * disconnection state of the profile from this intent.
 *
 * <p> If the disconnection is initiated by a remote device, the state
 * will transition from {@link #STATE_CONNECTED} to
 * {@link #STATE_DISCONNECTED}. If the disconnect is initiated by the
 * host (local) device the state will transition from
 * {@link #STATE_CONNECTED} to state {@link #STATE_DISCONNECTING} to
 * state {@link #STATE_DISCONNECTED}. The transition to
 * {@link #STATE_DISCONNECTING} can be used to distinguish between the
 * two scenarios.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}
 * permission.
 *
 * @param device Remote Bluetooth Device
 * @return false on immediate error,
 * true otherwise
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("disconnect(" + device + ")");
    if (mService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mService.disconnect(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("disconnect(" + device + ")");
    final IBluetoothA2dpSink service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.disconnect(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.media.session.MediaSession.Callback.onMediaButtonEvent:COMMENT
Method Modifier: public      
Comment:/**
 * Called when a media button is pressed and this session has the
 * highest priority or a controller sends a media button event to the
 * session. The default behavior will call the relevant method if the
 * action for it was set.
 * <p>
 * The intent will be of type {@link Intent#ACTION_MEDIA_BUTTON} with a
 * KeyEvent in {@link Intent#EXTRA_KEY_EVENT}
 *
 * @param mediaButtonIntent an intent containing the KeyEvent as an
 * extra
 * @return True if the event was handled, false otherwise.
 */

Body of Frist Method:
{
    if (mSession != null && Intent.ACTION_MEDIA_BUTTON.equals(mediaButtonIntent.getAction())) {
        KeyEvent ke = mediaButtonIntent.getParcelableExtra(Intent.EXTRA_KEY_EVENT);
        if (ke != null && ke.getAction() == KeyEvent.ACTION_DOWN) {
            PlaybackState state = mSession.mPlaybackState;
            long validActions = state == null ? 0 : state.getActions();
            switch(ke.getKeyCode()) {
                case KeyEvent.KEYCODE_MEDIA_PLAY:
                    if ((validActions & PlaybackState.ACTION_PLAY) != 0) {
                        onPlay();
                        return true;
                    }
                    break;
                case KeyEvent.KEYCODE_MEDIA_PAUSE:
                    if ((validActions & PlaybackState.ACTION_PAUSE) != 0) {
                        onPause();
                        return true;
                    }
                    break;
                case KeyEvent.KEYCODE_MEDIA_NEXT:
                    if ((validActions & PlaybackState.ACTION_SKIP_TO_NEXT) != 0) {
                        onSkipToNext();
                        return true;
                    }
                    break;
                case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
                    if ((validActions & PlaybackState.ACTION_SKIP_TO_PREVIOUS) != 0) {
                        onSkipToPrevious();
                        return true;
                    }
                    break;
                case KeyEvent.KEYCODE_MEDIA_STOP:
                    if ((validActions & PlaybackState.ACTION_STOP) != 0) {
                        onStop();
                        return true;
                    }
                    break;
                case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD:
                    if ((validActions & PlaybackState.ACTION_FAST_FORWARD) != 0) {
                        onFastForward();
                        return true;
                    }
                    break;
                case KeyEvent.KEYCODE_MEDIA_REWIND:
                    if ((validActions & PlaybackState.ACTION_REWIND) != 0) {
                        onRewind();
                        return true;
                    }
                    break;
                case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
                case KeyEvent.KEYCODE_HEADSETHOOK:
                    boolean isPlaying = state == null ? false : state.getState() == PlaybackState.STATE_PLAYING;
                    boolean canPlay = (validActions & (PlaybackState.ACTION_PLAY_PAUSE | PlaybackState.ACTION_PLAY)) != 0;
                    boolean canPause = (validActions & (PlaybackState.ACTION_PLAY_PAUSE | PlaybackState.ACTION_PAUSE)) != 0;
                    if (isPlaying && canPause) {
                        onPause();
                        return true;
                    } else if (!isPlaying && canPlay) {
                        onPlay();
                        return true;
                    }
                    break;
            }
        }
    }
    return false;
}
Body of Second Method:
{
    if (mSession != null && mHandler != null && Intent.ACTION_MEDIA_BUTTON.equals(mediaButtonIntent.getAction())) {
        KeyEvent ke = mediaButtonIntent.getParcelableExtra(Intent.EXTRA_KEY_EVENT);
        if (ke != null && ke.getAction() == KeyEvent.ACTION_DOWN) {
            PlaybackState state = mSession.mPlaybackState;
            long validActions = state == null ? 0 : state.getActions();
            switch(ke.getKeyCode()) {
                case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
                case KeyEvent.KEYCODE_HEADSETHOOK:
                    if (ke.getRepeatCount() > 0) {
                        // Consider long-press as a single tap.
                        handleMediaPlayPauseKeySingleTapIfPending();
                    } else if (mMediaPlayPauseKeyPending) {
                        // Consider double tap as the next.
                        mHandler.removeMessages(CallbackMessageHandler.MSG_PLAY_PAUSE_KEY_DOUBLE_TAP_TIMEOUT);
                        mMediaPlayPauseKeyPending = false;
                        if ((validActions & PlaybackState.ACTION_SKIP_TO_NEXT) != 0) {
                            onSkipToNext();
                        }
                    } else {
                        mMediaPlayPauseKeyPending = true;
                        mHandler.sendEmptyMessageDelayed(CallbackMessageHandler.MSG_PLAY_PAUSE_KEY_DOUBLE_TAP_TIMEOUT, ViewConfiguration.getDoubleTapTimeout());
                    }
                    return true;
                default:
                    // If another key is pressed within double tap timeout, consider the
                    // pending play/pause as a single tap to handle media keys in order.
                    handleMediaPlayPauseKeySingleTapIfPending();
                    break;
            }
            switch(ke.getKeyCode()) {
                case KeyEvent.KEYCODE_MEDIA_PLAY:
                    if ((validActions & PlaybackState.ACTION_PLAY) != 0) {
                        onPlay();
                        return true;
                    }
                    break;
                case KeyEvent.KEYCODE_MEDIA_PAUSE:
                    if ((validActions & PlaybackState.ACTION_PAUSE) != 0) {
                        onPause();
                        return true;
                    }
                    break;
                case KeyEvent.KEYCODE_MEDIA_NEXT:
                    if ((validActions & PlaybackState.ACTION_SKIP_TO_NEXT) != 0) {
                        onSkipToNext();
                        return true;
                    }
                    break;
                case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
                    if ((validActions & PlaybackState.ACTION_SKIP_TO_PREVIOUS) != 0) {
                        onSkipToPrevious();
                        return true;
                    }
                    break;
                case KeyEvent.KEYCODE_MEDIA_STOP:
                    if ((validActions & PlaybackState.ACTION_STOP) != 0) {
                        onStop();
                        return true;
                    }
                    break;
                case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD:
                    if ((validActions & PlaybackState.ACTION_FAST_FORWARD) != 0) {
                        onFastForward();
                        return true;
                    }
                    break;
                case KeyEvent.KEYCODE_MEDIA_REWIND:
                    if ((validActions & PlaybackState.ACTION_REWIND) != 0) {
                        onRewind();
                        return true;
                    }
                    break;
            }
        }
    }
    return false;
}
------------------------
Find a silently evolved API code:android.widget.NumberPicker.updateInputTextView:COMMENT
Method Modifier: private     
Comment:/**
 * Updates the view of this NumberPicker. If displayValues were specified in
 * the string corresponding to the index specified by the current value will
 * be returned. Otherwise, the formatter specified in {@link #setFormatter}
 * will be used to format the number.
 *
 * @return Whether the text was updated.
 */

Body of Frist Method:
{
    /*
         * If we don't have displayed values then use the current number else
         * find the correct value in the displayed values for the current
         * number.
         */
    String text = (mDisplayedValues == null) ? formatNumber(mValue) : mDisplayedValues[mValue - mMinValue];
    if (!TextUtils.isEmpty(text) && !text.equals(mInputText.getText().toString())) {
        mInputText.setText(text);
        return true;
    }
    return false;
}
Body of Second Method:
{
    /*
         * If we don't have displayed values then use the current number else
         * find the correct value in the displayed values for the current
         * number.
         */
    String text = (mDisplayedValues == null) ? formatNumber(mValue) : mDisplayedValues[mValue - mMinValue];
    if (!TextUtils.isEmpty(text)) {
        CharSequence beforeText = mInputText.getText();
        if (!text.equals(beforeText.toString())) {
            mInputText.setText(text);
            if (AccessibilityManager.getInstance(mContext).isEnabled()) {
                AccessibilityEvent event = AccessibilityEvent.obtain(AccessibilityEvent.TYPE_VIEW_TEXT_CHANGED);
                mInputText.onInitializeAccessibilityEvent(event);
                mInputText.onPopulateAccessibilityEvent(event);
                event.setFromIndex(0);
                event.setRemovedCount(beforeText.length());
                event.setAddedCount(text.length());
                event.setBeforeText(beforeText);
                event.setSource(NumberPicker.this, AccessibilityNodeProviderImpl.VIRTUAL_VIEW_ID_INPUT);
                requestSendAccessibilityEvent(NumberPicker.this, event);
            }
            return true;
        }
    }
    return false;
}
------------------------
Find a silently evolved API code:android.hardware.usb.UsbManager.isFunctionEnabled:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns true if the specified USB function is currently enabled when in device mode.
 * <p>
 * USB functions represent interfaces which are published to the host to access
 * services offered by the device.
 * </p>
 *
 * @param function name of the USB function
 * @return true if the USB function is enabled
 *
 * {@hide}
 */

Body of Frist Method:
{
    try {
        return mService.isFunctionEnabled(function);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    if (mService == null) {
        return false;
    }
    try {
        return mService.isFunctionEnabled(function);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.aware.WifiAwareNetworkSpecifier.satisfiedBy:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    // MatchAllNetworkSpecifier is taken care in NetworkCapabilities#satisfiedBySpecifier.
    return equals(other);
}
Body of Second Method:
{
    // MatchAllNetworkSpecifier is taken care in NetworkCapabilities#satisfiedBySpecifier.
    if (other instanceof WifiAwareAgentNetworkSpecifier) {
        return ((WifiAwareAgentNetworkSpecifier) other).satisfiesAwareNetworkSpecifier(this);
    }
    return equals(other);
}
------------------------
Find a silently evolved API code:android.app.SharedElementCallback.onCaptureSharedElementSnapshot:COMMENT
Method Modifier: public      
Comment:/**
 * Creates a snapshot of a shared element to be used by the remote Activity and reconstituted
 * with {@link #onCreateSnapshotView(android.content.Context, android.os.Parcelable)}. A
 * null return value will mean that the remote Activity will have a null snapshot View in
 * {@link #onSharedElementStart(java.util.List, java.util.List, java.util.List)} and
 * {@link #onSharedElementEnd(java.util.List, java.util.List, java.util.List)}.
 *
 * <p>This is not called for Fragment Transitions.</p>
 *
 * @param sharedElement The shared element View to create a snapshot for.
 * @param viewToGlobalMatrix A matrix containing a transform from the view to the screen
 * coordinates.
 * @param screenBounds The bounds of shared element in screen coordinate space. This is
 * the bounds of the view with the viewToGlobalMatrix applied.
 * @return A snapshot to send to the remote Activity to be reconstituted with
 * {@link #onCreateSnapshotView(android.content.Context, android.os.Parcelable)} and passed
 * into {@link #onSharedElementStart(java.util.List, java.util.List, java.util.List)} and
 * {@link #onSharedElementEnd(java.util.List, java.util.List, java.util.List)}.
 */

Body of Frist Method:
{
    if (sharedElement instanceof ImageView) {
        ImageView imageView = ((ImageView) sharedElement);
        Drawable d = imageView.getDrawable();
        Drawable bg = imageView.getBackground();
        if (d != null && (bg == null || bg.getAlpha() == 0)) {
            Bitmap bitmap = TransitionUtils.createDrawableBitmap(d);
            if (bitmap != null) {
                Bundle bundle = new Bundle();
                bundle.putParcelable(BUNDLE_SNAPSHOT_BITMAP, bitmap);
                bundle.putString(BUNDLE_SNAPSHOT_IMAGE_SCALETYPE, imageView.getScaleType().toString());
                if (imageView.getScaleType() == ScaleType.MATRIX) {
                    Matrix matrix = imageView.getImageMatrix();
                    float[] values = new float[9];
                    matrix.getValues(values);
                    bundle.putFloatArray(BUNDLE_SNAPSHOT_IMAGE_MATRIX, values);
                }
                return bundle;
            }
        }
    }
    if (mTempMatrix == null) {
        mTempMatrix = new Matrix(viewToGlobalMatrix);
    } else {
        mTempMatrix.set(viewToGlobalMatrix);
    }
    return TransitionUtils.createViewBitmap(sharedElement, mTempMatrix, screenBounds);
}
Body of Second Method:
{
    if (sharedElement instanceof ImageView) {
        ImageView imageView = ((ImageView) sharedElement);
        Drawable d = imageView.getDrawable();
        Drawable bg = imageView.getBackground();
        if (d != null && (bg == null || bg.getAlpha() == 0)) {
            Bitmap bitmap = TransitionUtils.createDrawableBitmap(d, imageView);
            if (bitmap != null) {
                Bundle bundle = new Bundle();
                if (bitmap.getConfig() != Bitmap.Config.HARDWARE) {
                    bundle.putParcelable(BUNDLE_SNAPSHOT_BITMAP, bitmap);
                } else {
                    GraphicBuffer graphicBuffer = bitmap.createGraphicBufferHandle();
                    bundle.putParcelable(BUNDLE_SNAPSHOT_GRAPHIC_BUFFER, graphicBuffer);
                }
                bundle.putString(BUNDLE_SNAPSHOT_IMAGE_SCALETYPE, imageView.getScaleType().toString());
                if (imageView.getScaleType() == ScaleType.MATRIX) {
                    Matrix matrix = imageView.getImageMatrix();
                    float[] values = new float[9];
                    matrix.getValues(values);
                    bundle.putFloatArray(BUNDLE_SNAPSHOT_IMAGE_MATRIX, values);
                }
                return bundle;
            }
        }
    }
    if (mTempMatrix == null) {
        mTempMatrix = new Matrix(viewToGlobalMatrix);
    } else {
        mTempMatrix.set(viewToGlobalMatrix);
    }
    ViewGroup parent = (ViewGroup) sharedElement.getParent();
    return TransitionUtils.createViewBitmap(sharedElement, mTempMatrix, screenBounds, parent);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothInputDevice.getDevicesMatchingConnectionStates:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (VDBG)
        log("getDevicesMatchingStates()");
    if (mService != null && isEnabled()) {
        try {
            return mService.getDevicesMatchingConnectionStates(states);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
Body of Second Method:
{
    if (VDBG)
        log("getDevicesMatchingStates()");
    final IBluetoothInputDevice service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.getDevicesMatchingConnectionStates(states);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothDevice.cancelBondProcess:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Cancel an in-progress bonding request started with {@link #createBond}.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}.
 *
 * @return true on success, false on error
 * @hide
 */

Body of Frist Method:
{
    if (sService == null) {
        Log.e(TAG, "BT not enabled. Cannot cancel Remote Device bond");
        return false;
    }
    try {
        Log.i(TAG, "cancelBondProcess() for device " + getAddress() + " called by pid: " + Process.myPid() + " tid: " + Process.myTid());
        return sService.cancelBondProcess(this);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
Body of Second Method:
{
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, "BT not enabled. Cannot cancel Remote Device bond");
        return false;
    }
    try {
        Log.i(TAG, "cancelBondProcess() for device " + getAddress() + " called by pid: " + Process.myPid() + " tid: " + Process.myTid());
        return service.cancelBondProcess(this);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadset.sendVendorSpecificResultCode:COMMENT
Method Modifier: public      
Comment:/**
 * Sends a vendor-specific unsolicited result code to the headset.
 *
 * <p>The actual string to be sent is <code>command + ": " + arg</code>.
 * For example, if {@code command} is {@link #VENDOR_RESULT_CODE_COMMAND_ANDROID} and {@code arg}
 * is {@code "0"}, the string <code>"+ANDROID: 0"</code> will be sent.
 *
 * <p>Currently only {@link #VENDOR_RESULT_CODE_COMMAND_ANDROID} is allowed as {@code command}.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param device Bluetooth headset.
 * @param command A vendor-specific command.
 * @param arg The argument that will be attached to the command.
 * @return {@code false} if there is no headset connected, or if the command is not an allowed
 * vendor-specific unsolicited result code, or on error. {@code true} otherwise.
 * @throws IllegalArgumentException if {@code command} is {@code null}.
 */

Body of Frist Method:
{
    if (DBG) {
        log("sendVendorSpecificResultCode()");
    }
    if (command == null) {
        throw new IllegalArgumentException("command is null");
    }
    if (mService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mService.sendVendorSpecificResultCode(device, command, arg);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (mService == null) {
        Log.w(TAG, "Proxy not attached to service");
    }
    return false;
}
Body of Second Method:
{
    if (DBG) {
        log("sendVendorSpecificResultCode()");
    }
    if (command == null) {
        throw new IllegalArgumentException("command is null");
    }
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.sendVendorSpecificResultCode(device, command, arg);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null) {
        Log.w(TAG, "Proxy not attached to service");
    }
    return false;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHealth.getDevicesMatchingConnectionStates:COMMENT
Method Modifier: public      
Comment:/**
 * Get a list of devices that match any of the given connection
 * states.
 *
 * <p> If none of the devices match any of the given states,
 * an empty list will be returned.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 * This is not specific to any application configuration but represents the connection
 * state of the local Bluetooth adapter for this profile. This can be used
 * by applications like status bar which would just like to know the state of the
 * local adapter.
 *
 * @param states Array of states. States can be one of
 * {@link #STATE_CONNECTED}, {@link #STATE_CONNECTING},
 * {@link #STATE_DISCONNECTED}, {@link #STATE_DISCONNECTING},
 * @return List of devices. The list will be empty on error.
 */

Body of Frist Method:
{
    if (mService != null && isEnabled()) {
        try {
            return mService.getHealthDevicesMatchingConnectionStates(states);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
Body of Second Method:
{
    final IBluetoothHealth service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.getHealthDevicesMatchingConnectionStates(states);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.explicitCallTransfer:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Performs explicit call transfer.
 *
 * That means connect other calls and disconnect.
 *
 * @param device    remote device
 * @return          <code>true</code> if command has been issued successfully;
 * <code>false</code> otherwise;
 * upon completion HFP sends {@link #ACTION_CALL_CHANGED}
 * intent.
 *
 * <p>Feature required for successful execution is being reported by:
 * {@link #EXTRA_AG_FEATURE_MERGE_AND_DETACH}.
 * This method invocation will fail silently when feature is not supported.</p>
 */

Body of Frist Method:
{
    if (DBG)
        log("explicitCallTransfer()");
    if (mService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mService.explicitCallTransfer(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("explicitCallTransfer()");
    final IBluetoothHeadsetClient service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.explicitCallTransfer(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadset.clccResponse:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Send Headset of CLCC response
 *
 * @hide
 */

Body of Frist Method:
{
    if (mService != null && isEnabled()) {
        try {
            mService.clccResponse(index, direction, status, mode, mpty, number, type);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
}
Body of Second Method:
{
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled()) {
        try {
            service.clccResponse(index, direction, status, mode, mpty, number, type);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
}
------------------------
Find a silently evolved API code:android.view.accessibility.AccessibilityRecord.clear:COMMENT
Method Modifier: default     
Comment:/**
 * Clears the state of this instance.
 */

Body of Frist Method:
{
    mSealed = false;
    mBooleanProperties = 0;
    mCurrentItemIndex = UNDEFINED;
    mItemCount = UNDEFINED;
    mFromIndex = UNDEFINED;
    mToIndex = UNDEFINED;
    mScrollX = UNDEFINED;
    mScrollY = UNDEFINED;
    mMaxScrollX = UNDEFINED;
    mMaxScrollY = UNDEFINED;
    mAddedCount = UNDEFINED;
    mRemovedCount = UNDEFINED;
    mClassName = null;
    mContentDescription = null;
    mBeforeText = null;
    mParcelableData = null;
    mText.clear();
    clearSourceNode();
    mSourceWindowId = UNDEFINED;
    mConnectionId = UNDEFINED;
}
Body of Second Method:
{
    mSealed = false;
    mBooleanProperties = 0;
    mCurrentItemIndex = UNDEFINED;
    mItemCount = UNDEFINED;
    mFromIndex = UNDEFINED;
    mToIndex = UNDEFINED;
    mScrollX = UNDEFINED;
    mScrollY = UNDEFINED;
    mMaxScrollX = UNDEFINED;
    mMaxScrollY = UNDEFINED;
    mAddedCount = UNDEFINED;
    mRemovedCount = UNDEFINED;
    mClassName = null;
    mContentDescription = null;
    mBeforeText = null;
    mParcelableData = null;
    mText.clear();
    mSourceNodeId = AccessibilityNodeInfo.UNDEFINED_ITEM_ID;
    mSourceWindowId = AccessibilityWindowInfo.UNDEFINED_WINDOW_ID;
    mConnectionId = UNDEFINED;
}
------------------------
Find a silently evolved API code:android.database.sqlite.SQLiteConnectionPool.releaseConnection:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Releases a connection back to the pool.
 * <p>
 * It is ok to call this method after the pool has closed, to release
 * connections that were still in use at the time of closure.
 * </p>
 *
 * @param connection The connection to release.  Must not be null.
 *
 * @throws IllegalStateException if the connection was not acquired
 * from this pool or if it has already been released.
 */

Body of Frist Method:
{
    synchronized (mLock) {
        AcquiredConnectionStatus status = mAcquiredConnections.remove(connection);
        if (status == null) {
            throw new IllegalStateException("Cannot perform this operation " + "because the specified connection was not acquired " + "from this pool or has already been released.");
        }
        if (!mIsOpen) {
            closeConnectionAndLogExceptionsLocked(connection);
        } else if (connection.isPrimaryConnection()) {
            if (recycleConnectionLocked(connection, status)) {
                assert mAvailablePrimaryConnection == null;
                mAvailablePrimaryConnection = connection;
            }
            wakeConnectionWaitersLocked();
        } else if (mAvailableNonPrimaryConnections.size() >= mMaxConnectionPoolSize - 1) {
            closeConnectionAndLogExceptionsLocked(connection);
        } else {
            if (recycleConnectionLocked(connection, status)) {
                mAvailableNonPrimaryConnections.add(connection);
            }
            wakeConnectionWaitersLocked();
        }
    }
}
Body of Second Method:
{
    synchronized (mLock) {
        if (mIdleConnectionHandler != null) {
            mIdleConnectionHandler.connectionReleased(connection);
        }
        AcquiredConnectionStatus status = mAcquiredConnections.remove(connection);
        if (status == null) {
            throw new IllegalStateException("Cannot perform this operation " + "because the specified connection was not acquired " + "from this pool or has already been released.");
        }
        if (!mIsOpen) {
            closeConnectionAndLogExceptionsLocked(connection);
        } else if (connection.isPrimaryConnection()) {
            if (recycleConnectionLocked(connection, status)) {
                assert mAvailablePrimaryConnection == null;
                mAvailablePrimaryConnection = connection;
            }
            wakeConnectionWaitersLocked();
        } else if (mAvailableNonPrimaryConnections.size() >= mMaxConnectionPoolSize - 1) {
            closeConnectionAndLogExceptionsLocked(connection);
        } else {
            if (recycleConnectionLocked(connection, status)) {
                mAvailableNonPrimaryConnections.add(connection);
            }
            wakeConnectionWaitersLocked();
        }
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHealth.connectChannelToSink:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Connect to a health device which has the {@link #SINK_ROLE}.
 * This is an asynchronous call. If this function returns true, the callback
 * associated with the application configuration will be called.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param device The remote Bluetooth device.
 * @param config The application configuration which has been registered using
 * {@link #registerSinkAppConfiguration(String, int, BluetoothHealthCallback) }
 * @return If true, the callback associated with the application config will be called.
 * @hide
 */

Body of Frist Method:
{
    if (mService != null && isEnabled() && isValidDevice(device) && config != null) {
        try {
            return mService.connectChannelToSink(device, config, channelType);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return false;
}
Body of Second Method:
{
    final IBluetoothHealth service = mService;
    if (service != null && isEnabled() && isValidDevice(device) && config != null) {
        try {
            return service.connectChannelToSink(device, config, channelType);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return false;
}
------------------------
Find a silently evolved API code:android.media.MediaExtractor.getCasInfo:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieves the information about the conditional access system used to scramble
 * a track.
 *
 * @param index of the track.
 * @return an {@link CasInfo} object describing the conditional access system.
 */

Body of Frist Method:
{
    Map<String, Object> formatMap = getTrackFormatNative(index);
    if (formatMap.containsKey(MediaFormat.KEY_CA_SYSTEM_ID)) {
        int systemId = ((Integer) formatMap.get(MediaFormat.KEY_CA_SYSTEM_ID)).intValue();
        MediaCas.Session session = null;
        if (mMediaCas != null && formatMap.containsKey(MediaFormat.KEY_CA_SESSION_ID)) {
            ByteBuffer buf = (ByteBuffer) formatMap.get(MediaFormat.KEY_CA_SESSION_ID);
            buf.rewind();
            final byte[] sessionId = new byte[buf.remaining()];
            buf.get(sessionId);
            session = mMediaCas.createFromSessionId(sessionId);
        }
        return new CasInfo(systemId, session);
    }
    return null;
}
Body of Second Method:
{
    Map<String, Object> formatMap = getTrackFormatNative(index);
    if (formatMap.containsKey(MediaFormat.KEY_CA_SYSTEM_ID)) {
        int systemId = ((Integer) formatMap.get(MediaFormat.KEY_CA_SYSTEM_ID)).intValue();
        MediaCas.Session session = null;
        if (mMediaCas != null && formatMap.containsKey(MediaFormat.KEY_CA_SESSION_ID)) {
            ByteBuffer buf = (ByteBuffer) formatMap.get(MediaFormat.KEY_CA_SESSION_ID);
            buf.rewind();
            final byte[] sessionId = new byte[buf.remaining()];
            buf.get(sessionId);
            session = mMediaCas.createFromSessionId(toByteArray(sessionId));
        }
        return new CasInfo(systemId, session);
    }
    return null;
}
------------------------
Find a silently evolved API code:android.os.StrictMode.enterCriticalSpan:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Enter a named critical span (e.g. an animation)
 *
 * <p>The name is an arbitary label (or tag) that will be applied
 * to any strictmode violation that happens while this span is
 * active.  You must call finish() on the span when done.
 *
 * <p>This will never return null, but on devices without debugging
 * enabled, this may return a dummy object on which the finish()
 * method is a no-op.
 *
 * <p>TODO: add CloseGuard to this, verifying callers call finish.
 *
 * @hide
 */

Body of Frist Method:
{
    if (IS_USER_BUILD) {
        return NO_OP_SPAN;
    }
    if (name == null || name.isEmpty()) {
        throw new IllegalArgumentException("name must be non-null and non-empty");
    }
    ThreadSpanState state = sThisThreadSpanState.get();
    Span span = null;
    synchronized (state) {
        if (state.mFreeListHead != null) {
            span = state.mFreeListHead;
            state.mFreeListHead = span.mNext;
            state.mFreeListSize--;
        } else {
            // Shouldn't have to do this often.
            span = new Span(state);
        }
        span.mName = name;
        span.mCreateMillis = SystemClock.uptimeMillis();
        span.mNext = state.mActiveHead;
        span.mPrev = null;
        state.mActiveHead = span;
        state.mActiveSize++;
        if (span.mNext != null) {
            span.mNext.mPrev = span;
        }
        if (LOG_V)
            Log.d(TAG, "Span enter=" + name + "; size=" + state.mActiveSize);
    }
    return span;
}
Body of Second Method:
{
    if (Build.IS_USER) {
        return NO_OP_SPAN;
    }
    if (name == null || name.isEmpty()) {
        throw new IllegalArgumentException("name must be non-null and non-empty");
    }
    ThreadSpanState state = sThisThreadSpanState.get();
    Span span = null;
    synchronized (state) {
        if (state.mFreeListHead != null) {
            span = state.mFreeListHead;
            state.mFreeListHead = span.mNext;
            state.mFreeListSize--;
        } else {
            // Shouldn't have to do this often.
            span = new Span(state);
        }
        span.mName = name;
        span.mCreateMillis = SystemClock.uptimeMillis();
        span.mNext = state.mActiveHead;
        span.mPrev = null;
        state.mActiveHead = span;
        state.mActiveSize++;
        if (span.mNext != null) {
            span.mNext.mPrev = span;
        }
        if (LOG_V)
            Log.d(TAG, "Span enter=" + name + "; size=" + state.mActiveSize);
    }
    return span;
}
------------------------
Find a silently evolved API code:android.graphics.ImageFormat.isPublicFormat:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Determine whether or not this is a public-visible {@code format}.
 *
 * <p>In particular, {@code @hide} formats will return {@code false}.</p>
 *
 * <p>Any other formats (including UNKNOWN) will return {@code false}.</p>
 *
 * @param format an integer format
 * @return a boolean
 *
 * @hide
 */

Body of Frist Method:
{
    switch(format) {
        case RGB_565:
        case NV16:
        case YUY2:
        case YV12:
        case JPEG:
        case NV21:
        case YUV_420_888:
        case YUV_422_888:
        case YUV_444_888:
        case FLEX_RGB_888:
        case FLEX_RGBA_8888:
        case RAW_SENSOR:
        case RAW_PRIVATE:
        case RAW10:
        case RAW12:
        case DEPTH16:
        case DEPTH_POINT_CLOUD:
        case PRIVATE:
            return true;
    }
    return false;
}
Body of Second Method:
{
    switch(format) {
        case RGB_565:
        case NV16:
        case YUY2:
        case YV12:
        case JPEG:
        case NV21:
        case YUV_420_888:
        case YUV_422_888:
        case YUV_444_888:
        case FLEX_RGB_888:
        case FLEX_RGBA_8888:
        case RAW_SENSOR:
        case RAW_PRIVATE:
        case RAW10:
        case RAW12:
        case DEPTH16:
        case DEPTH_POINT_CLOUD:
        case PRIVATE:
        case RAW_DEPTH:
            return true;
    }
    return false;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothAvrcpController.sendGroupNavigationCmd:COMMENT
Method Modifier: public      hidden      
Comment:/*
     * Send Group Navigation Command to Remote.
     * possible keycode values: next_grp, previous_grp defined above
     */

Body of Frist Method:
{
    Log.d(TAG, "sendGroupNavigationCmd dev = " + device + " key " + keyCode + " State = " + keyState);
    if (mService != null && isEnabled()) {
        try {
            mService.sendGroupNavigationCmd(device, keyCode, keyState);
            return;
        } catch (RemoteException e) {
            Log.e(TAG, "Error talking to BT service in sendGroupNavigationCmd()", e);
            return;
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
}
Body of Second Method:
{
    Log.d(TAG, "sendGroupNavigationCmd dev = " + device + " key " + keyCode + " State = " + keyState);
    final IBluetoothAvrcpController service = mService;
    if (service != null && isEnabled()) {
        try {
            service.sendGroupNavigationCmd(device, keyCode, keyState);
            return;
        } catch (RemoteException e) {
            Log.e(TAG, "Error talking to BT service in sendGroupNavigationCmd()", e);
            return;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
}
------------------------
Find a silently evolved API code:android.media.AudioManager.isWiredHeadsetOn:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * Checks whether a wired headset is connected or not.
 * <p>This is not a valid indication that audio playback is
 * actually over the wired headset as audio routing depends on other conditions.
 *
 * @return true if a wired headset is connected.
 * false if otherwise
 * @deprecated Use {@link AudioManager#getDevices(int)} instead to list available audio devices.
 */

Body of Frist Method:
{
    if (AudioSystem.getDeviceConnectionState(DEVICE_OUT_WIRED_HEADSET, "") == AudioSystem.DEVICE_STATE_UNAVAILABLE && AudioSystem.getDeviceConnectionState(DEVICE_OUT_WIRED_HEADPHONE, "") == AudioSystem.DEVICE_STATE_UNAVAILABLE) {
        return false;
    } else {
        return true;
    }
}
Body of Second Method:
{
    if (AudioSystem.getDeviceConnectionState(DEVICE_OUT_WIRED_HEADSET, "") == AudioSystem.DEVICE_STATE_UNAVAILABLE && AudioSystem.getDeviceConnectionState(DEVICE_OUT_WIRED_HEADPHONE, "") == AudioSystem.DEVICE_STATE_UNAVAILABLE && AudioSystem.getDeviceConnectionState(DEVICE_OUT_USB_HEADSET, "") == AudioSystem.DEVICE_STATE_UNAVAILABLE) {
        return false;
    } else {
        return true;
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadset.enableWBS:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * enable WBS codec setting.
 *
 * @return true if successful
 * false if there was some error such as
 * there is no connected headset
 * @hide
 */

Body of Frist Method:
{
    if (mService != null && isEnabled()) {
        try {
            return mService.enableWBS();
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return false;
}
Body of Second Method:
{
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.enableWBS();
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return false;
}
------------------------
Find a silently evolved API code:android.telephony.SmsMessage.isCdmaVoice:COMMENT
Method Modifier: private     static      
Comment:/**
 * Determines whether or not to current phone type is cdma.
 *
 * @return true if current phone type is cdma, false otherwise.
 */

Body of Frist Method:
{
    int activePhone = TelephonyManager.getDefault().getCurrentPhoneType();
    return (PHONE_TYPE_CDMA == activePhone);
}
Body of Second Method:
{
    return isCdmaVoice(SubscriptionManager.getDefaultSmsSubscriptionId());
}
------------------------
Find a silently evolved API code:android.text.style.TextAppearanceSpan.writeToParcelInternal:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    dest.writeString(mTypeface);
    dest.writeInt(mStyle);
    dest.writeInt(mTextSize);
    if (mTextColor != null) {
        dest.writeInt(1);
        mTextColor.writeToParcel(dest, flags);
    } else {
        dest.writeInt(0);
    }
    if (mTextColorLink != null) {
        dest.writeInt(1);
        mTextColorLink.writeToParcel(dest, flags);
    } else {
        dest.writeInt(0);
    }
}
Body of Second Method:
{
    dest.writeString(mFamilyName);
    dest.writeInt(mStyle);
    dest.writeInt(mTextSize);
    if (mTextColor != null) {
        dest.writeInt(1);
        mTextColor.writeToParcel(dest, flags);
    } else {
        dest.writeInt(0);
    }
    if (mTextColorLink != null) {
        dest.writeInt(1);
        mTextColorLink.writeToParcel(dest, flags);
    } else {
        dest.writeInt(0);
    }
    LeakyTypefaceStorage.writeTypefaceToParcel(mTypeface, dest);
}
------------------------
Find a silently evolved API code:android.view.accessibility.AccessibilityRecord.setSealed:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets if this instance is sealed.
 *
 * @param sealed Whether is sealed.
 *
 * @hide
 */

Body of Frist Method:
{
    mSealed = sealed;
    if (mSourceNode != null) {
        mSourceNode.setSealed(sealed);
    }
}
Body of Second Method:
{
    mSealed = sealed;
}
------------------------
Find a silently evolved API code:android.media.AudioPlaybackConfiguration.getPlayerProxy:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 * Return a proxy for the player associated with this playback configuration
 * @return a proxy player
 */

Body of Frist Method:
{
    return mIPlayerShell == null ? null : new PlayerProxy(this);
}
Body of Second Method:
{
    final IPlayerShell ips;
    synchronized (this) {
        ips = mIPlayerShell;
    }
    return ips == null ? null : new PlayerProxy(this);
}
------------------------
Find a silently evolved API code:android.media.ImageUtils.getEstimatedNativeAllocBytes:COMMENT
Method Modifier: public      static      
Comment:/**
 * Return the estimated native allocation size in bytes based on width, height, format,
 * and number of images.
 *
 * <p>This is a very rough estimation and should only be used for native allocation
 * registration in VM so it can be accounted for during GC.</p>
 *
 * @param width The width of the images.
 * @param height The height of the images.
 * @param format The format of the images.
 * @param numImages The number of the images.
 */

Body of Frist Method:
{
    double estimatedBytePerPixel;
    switch(format) {
        // 10x compression from RGB_888
        case ImageFormat.JPEG:
        case ImageFormat.DEPTH_POINT_CLOUD:
            estimatedBytePerPixel = 0.3;
            break;
        case ImageFormat.Y8:
            estimatedBytePerPixel = 1.0;
            break;
        case ImageFormat.RAW10:
            estimatedBytePerPixel = 1.25;
            break;
        case ImageFormat.YV12:
        case ImageFormat.YUV_420_888:
        case ImageFormat.NV21:
        case ImageFormat.RAW12:
        case // A rough estimate because the real size is unknown.
        ImageFormat.PRIVATE:
            estimatedBytePerPixel = 1.5;
            break;
        case ImageFormat.NV16:
        case PixelFormat.RGB_565:
        case ImageFormat.YUY2:
        case ImageFormat.Y16:
        case ImageFormat.RAW_SENSOR:
        // round estimate, real size is unknown
        case ImageFormat.RAW_PRIVATE:
        case ImageFormat.DEPTH16:
            estimatedBytePerPixel = 2.0;
            break;
        case PixelFormat.RGB_888:
            estimatedBytePerPixel = 3.0;
            break;
        case PixelFormat.RGBA_8888:
        case PixelFormat.RGBX_8888:
            estimatedBytePerPixel = 4.0;
            break;
        default:
            throw new UnsupportedOperationException(String.format("Invalid format specified %d", format));
    }
    return (int) (width * height * estimatedBytePerPixel * numImages);
}
Body of Second Method:
{
    double estimatedBytePerPixel;
    switch(format) {
        // 10x compression from RGB_888
        case ImageFormat.JPEG:
        case ImageFormat.DEPTH_POINT_CLOUD:
            estimatedBytePerPixel = 0.3;
            break;
        case ImageFormat.Y8:
            estimatedBytePerPixel = 1.0;
            break;
        case ImageFormat.RAW10:
            estimatedBytePerPixel = 1.25;
            break;
        case ImageFormat.YV12:
        case ImageFormat.YUV_420_888:
        case ImageFormat.NV21:
        case ImageFormat.RAW12:
        case // A rough estimate because the real size is unknown.
        ImageFormat.PRIVATE:
            estimatedBytePerPixel = 1.5;
            break;
        case ImageFormat.NV16:
        case PixelFormat.RGB_565:
        case ImageFormat.YUY2:
        case ImageFormat.Y16:
        case ImageFormat.RAW_DEPTH:
        case ImageFormat.RAW_SENSOR:
        // round estimate, real size is unknown
        case ImageFormat.RAW_PRIVATE:
        case ImageFormat.DEPTH16:
            estimatedBytePerPixel = 2.0;
            break;
        case PixelFormat.RGB_888:
            estimatedBytePerPixel = 3.0;
            break;
        case PixelFormat.RGBA_8888:
        case PixelFormat.RGBX_8888:
            estimatedBytePerPixel = 4.0;
            break;
        default:
            throw new UnsupportedOperationException(String.format("Invalid format specified %d", format));
    }
    return (int) (width * height * estimatedBytePerPixel * numImages);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothPan.getConnectedDevices:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (VDBG)
        log("getConnectedDevices()");
    if (mPanService != null && isEnabled()) {
        try {
            return mPanService.getConnectedDevices();
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (mPanService == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
Body of Second Method:
{
    if (VDBG)
        log("getConnectedDevices()");
    final IBluetoothPan service = mPanService;
    if (service != null && isEnabled()) {
        try {
            return service.getConnectedDevices();
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothInputHost.getConnectionState:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    Log.v(TAG, "getConnectionState(): device=" + device);
    if (mService != null) {
        try {
            return mService.getConnectionState(device);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
    }
    return STATE_DISCONNECTED;
}
Body of Second Method:
{
    Log.v(TAG, "getConnectionState(): device=" + device);
    final IBluetoothInputHost service = mService;
    if (service != null) {
        try {
            return service.getConnectionState(device);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
    }
    return STATE_DISCONNECTED;
}
------------------------
Find a silently evolved API code:android.net.LinkAddress.isIPv6ULA:COMMENT
Method Modifier: private     
Comment:/**
 * Utility function to check if |address| is a Unique Local IPv6 Unicast Address
 * (a.k.a. "ULA"; RFC 4193).
 *
 * Per RFC 4193 section 8, fc00::/7 identifies these addresses.
 */

Body of Frist Method:
{
    if (address != null && address instanceof Inet6Address) {
        byte[] bytes = address.getAddress();
        return ((bytes[0] & (byte) 0xfe) == (byte) 0xfc);
    }
    return false;
}
Body of Second Method:
{
    if (isIPv6()) {
        byte[] bytes = address.getAddress();
        return ((bytes[0] & (byte) 0xfe) == (byte) 0xfc);
    }
    return false;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadset.startScoUsingVirtualVoiceCall:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Initiates a SCO channel connection with the headset (if connected).
 * Also initiates a virtual voice call for Handsfree devices as many devices
 * do not accept SCO audio without a call.
 * This API allows the handsfree device to be used for routing non-cellular
 * call audio.
 *
 * @param device Remote Bluetooth Device
 * @return true if successful, false if there was some error.
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("startScoUsingVirtualVoiceCall()");
    if (mService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mService.startScoUsingVirtualVoiceCall(device);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("startScoUsingVirtualVoiceCall()");
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.startScoUsingVirtualVoiceCall(device);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return false;
}
------------------------
Find a silently evolved API code:android.net.IpSecTransform.Builder.setSpi:COMMENT
Method Modifier: public      
Comment:/**
 * Set the SPI, which uniquely identifies a particular IPsec session from others. Because
 * IPsec operates at the IP layer, this 32-bit identifier uniquely identifies packets to a
 * given destination address.
 *
 * <p>Care should be chosen when selecting an SPI to ensure that is is as unique as
 * possible. To reserve a value call {@link IpSecManager#reserveSecurityParameterIndex(int,
 * InetAddress, int)}. Otherwise, SPI collisions would prevent a transform from being
 * activated. IpSecManager#reserveSecurityParameterIndex(int, InetAddres$s, int)}.
 *
 * <p>Unless an SPI is set for a given direction, traffic in that direction will be
 * sent/received without any IPsec applied.
 *
 * @param direction either {@link #DIRECTION_IN or #DIRECTION_OUT}
 * @param spi a unique {@link IpSecManager.SecurityParameterIndex} to identify transformed
 * traffic
 */

Body of Frist Method:
{
    // TODO: convert to using the resource Id of the SPI. Then build() can validate
    // the owner in the IpSecService
    mConfig.flow[direction].spi = spi.getSpi();
    return this;
}
Body of Second Method:
{
    // TODO: convert to using the resource Id of the SPI. Then build() can validate
    // the owner in the IpSecService
    mConfig.flow[direction].spiResourceId = spi.getResourceId();
    return this;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothA2dpSink.getPriority:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the priority of the profile.
 *
 * <p> The priority can be any of:
 * {@link #PRIORITY_AUTO_CONNECT}, {@link #PRIORITY_OFF},
 * {@link #PRIORITY_ON}, {@link #PRIORITY_UNDEFINED}
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param device Bluetooth device
 * @return priority of the device
 * @hide
 */

Body of Frist Method:
{
    if (VDBG)
        log("getPriority(" + device + ")");
    if (mService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mService.getPriority(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.PRIORITY_OFF;
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return BluetoothProfile.PRIORITY_OFF;
}
Body of Second Method:
{
    if (VDBG)
        log("getPriority(" + device + ")");
    final IBluetoothA2dpSink service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getPriority(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.PRIORITY_OFF;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return BluetoothProfile.PRIORITY_OFF;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothPbapClient.getPriority:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the priority of the profile.
 *
 * <p> The priority can be any of:
 * {@link #PRIORITY_AUTO_CONNECT}, {@link #PRIORITY_OFF},
 * {@link #PRIORITY_ON}, {@link #PRIORITY_UNDEFINED}
 *
 * @param device Bluetooth device
 * @return priority of the device
 */

Body of Frist Method:
{
    if (VDBG) {
        log("getPriority(" + device + ")");
    }
    if (mService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mService.getPriority(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return PRIORITY_OFF;
        }
    }
    if (mService == null) {
        Log.w(TAG, "Proxy not attached to service");
    }
    return PRIORITY_OFF;
}
Body of Second Method:
{
    if (VDBG) {
        log("getPriority(" + device + ")");
    }
    final IBluetoothPbapClient service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getPriority(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return PRIORITY_OFF;
        }
    }
    if (service == null) {
        Log.w(TAG, "Proxy not attached to service");
    }
    return PRIORITY_OFF;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.disconnect:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Disconnects remote device
 *
 * @param device    a remote device we want disconnect
 * @return          <code>true</code> if command has been issued successfully;
 * <code>false</code> otherwise;
 * upon completion HFP sends {@link #ACTION_CONNECTION_STATE_CHANGED}
 * intent.
 */

Body of Frist Method:
{
    if (DBG)
        log("disconnect(" + device + ")");
    if (mService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mService.disconnect(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("disconnect(" + device + ")");
    final IBluetoothHeadsetClient service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.disconnect(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothDevice.setPhonebookAccessPermission:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets whether the phonebook access is allowed to this device.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_PRIVILEGED}.
 * @param value Can be {@link #ACCESS_UNKNOWN}, {@link #ACCESS_ALLOWED} or
 * {@link #ACCESS_REJECTED}.
 * @return Whether the value has been successfully set.
 * @hide
 */

Body of Frist Method:
{
    if (sService == null) {
        return false;
    }
    try {
        return sService.setPhonebookAccessPermission(this, value);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
Body of Second Method:
{
    final IBluetooth service = sService;
    if (service == null) {
        return false;
    }
    try {
        return service.setPhonebookAccessPermission(this, value);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
------------------------
Find a silently evolved API code:android.media.MediaCas.openSession:COMMENT
Method Modifier: public      
Comment:/**
 * Open a session to descramble one or more streams scrambled by the
 * conditional access system.
 *
 * @return session the newly opened session.
 *
 * @throws IllegalStateException if the MediaCas instance is not valid.
 * @throws MediaCasException for CAS-specific errors.
 * @throws MediaCasStateException for CAS-specific state exceptions.
 */

Body of Frist Method:
{
    validateInternalStates();
    try {
        return createFromSessionId(mICas.openSession());
    } catch (ServiceSpecificException e) {
        MediaCasException.throwExceptions(e);
    } catch (RemoteException e) {
        cleanupAndRethrowIllegalState();
    }
    return null;
}
Body of Second Method:
{
    validateInternalStates();
    try {
        OpenSessionCallback cb = new OpenSessionCallback();
        mICas.openSession(cb);
        MediaCasException.throwExceptionIfNeeded(cb.mStatus);
        return cb.mSession;
    } catch (RemoteException e) {
        cleanupAndRethrowIllegalState();
    }
    return null;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothDevice.cancelPairingUserInput:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (sService == null) {
        Log.e(TAG, "BT not enabled. Cannot create pairing user input");
        return false;
    }
    try {
        return sService.cancelBondProcess(this);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
Body of Second Method:
{
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, "BT not enabled. Cannot create pairing user input");
        return false;
    }
    try {
        return service.cancelBondProcess(this);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.enterPrivateMode:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Enters private mode with a specified call.
 *
 * Works only when Extended Call Control is supported by Audio Gateway.
 *
 * @param device    remote device
 * @param index     index of the call to connect in private mode
 * @return          <code>true</code> if command has been issued successfully;
 * <code>false</code> otherwise;
 * upon completion HFP sends {@link #ACTION_CALL_CHANGED}
 * intent.
 *
 * <p>Feature required for successful execution is being reported by:
 * {@link #EXTRA_AG_FEATURE_ECC}.
 * This method invocation will fail silently when feature is not supported.</p>
 */

Body of Frist Method:
{
    if (DBG)
        log("enterPrivateMode()");
    if (mService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mService.enterPrivateMode(device, index);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("enterPrivateMode()");
    final IBluetoothHeadsetClient service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.enterPrivateMode(device, index);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.preference.Preference.setSingleLineTitle:COMMENT
Method Modifier: public      
Comment:/**
 * Sets whether to constrain the title of this Preference to a single line instead of
 * letting it wrap onto multiple lines.
 *
 * @param singleLineTitle set {@code true} if the title should be constrained to one line
 */

Body of Frist Method:
{
    mSingleLineTitle = singleLineTitle;
    notifyChanged();
}
Body of Second Method:
{
    mHasSingleLineTitleAttr = true;
    mSingleLineTitle = singleLineTitle;
    notifyChanged();
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadset.getAudioRouteAllowed:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns whether audio routing is allowed. see {@link #setAudioRouteAllowed(boolean)}.
 * Note: This is an internal function and shouldn't be exposed
 *
 * @hide
 */

Body of Frist Method:
{
    if (VDBG)
        log("getAudioRouteAllowed");
    if (mService != null && isEnabled()) {
        try {
            return mService.getAudioRouteAllowed();
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return false;
}
Body of Second Method:
{
    if (VDBG)
        log("getAudioRouteAllowed");
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.getAudioRouteAllowed();
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return false;
}
------------------------
Find a silently evolved API code:android.hardware.camera2.CameraManager.CameraManagerGlobal.getCameraService:COMMENT
Method Modifier: public      
Comment:/**
 * Return a best-effort ICameraService.
 *
 * <p>This will be null if the camera service is not currently available. If the camera
 * service has died since the last use of the camera service, will try to reconnect to the
 * service.</p>
 */

Body of Frist Method:
{
    synchronized (mLock) {
        connectCameraServiceLocked();
        if (mCameraService == null) {
            Log.e(TAG, "Camera service is unavailable");
        }
        return mCameraService;
    }
}
Body of Second Method:
{
    synchronized (mLock) {
        connectCameraServiceLocked();
        if (mCameraService == null && !sCameraServiceDisabled) {
            Log.e(TAG, "Camera service is unavailable");
        }
        return mCameraService;
    }
}
------------------------
Find a silently evolved API code:android.widget.NumberPicker.changeValueByOne:COMMENT
Method Modifier: private     
Comment:/**
 * Changes the current value by one which is increment or
 * decrement based on the passes argument.
 * decrement the current value.
 *
 * @param increment True to increment, false to decrement.
 */

Body of Frist Method:
{
    if (mHasSelectorWheel) {
        mInputText.setVisibility(View.INVISIBLE);
        if (!moveToFinalScrollerPosition(mFlingScroller)) {
            moveToFinalScrollerPosition(mAdjustScroller);
        }
        mPreviousScrollerY = 0;
        if (increment) {
            mFlingScroller.startScroll(0, 0, 0, -mSelectorElementHeight, SNAP_SCROLL_DURATION);
        } else {
            mFlingScroller.startScroll(0, 0, 0, mSelectorElementHeight, SNAP_SCROLL_DURATION);
        }
        invalidate();
    } else {
        if (increment) {
            setValueInternal(mValue + 1, true);
        } else {
            setValueInternal(mValue - 1, true);
        }
    }
}
Body of Second Method:
{
    if (mHasSelectorWheel) {
        hideSoftInput();
        if (!moveToFinalScrollerPosition(mFlingScroller)) {
            moveToFinalScrollerPosition(mAdjustScroller);
        }
        mPreviousScrollerY = 0;
        if (increment) {
            mFlingScroller.startScroll(0, 0, 0, -mSelectorElementHeight, SNAP_SCROLL_DURATION);
        } else {
            mFlingScroller.startScroll(0, 0, 0, mSelectorElementHeight, SNAP_SCROLL_DURATION);
        }
        invalidate();
    } else {
        if (increment) {
            setValueInternal(mValue + 1, true);
        } else {
            setValueInternal(mValue - 1, true);
        }
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadset.stopVoiceRecognition:COMMENT
Method Modifier: public      
Comment:/**
 * Stop Bluetooth Voice Recognition mode, and shut down the
 * Bluetooth audio path.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param device Bluetooth headset
 * @return false if there is no headset connected
 * or on error, true otherwise
 */

Body of Frist Method:
{
    if (DBG)
        log("stopVoiceRecognition()");
    if (mService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mService.stopVoiceRecognition(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("stopVoiceRecognition()");
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.stopVoiceRecognition(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothMap.isConnected:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns true if the specified Bluetooth device is connected.
 * Returns false if not connected, or if this proxy object is not
 * currently connected to the Map service.
 */

Body of Frist Method:
{
    if (VDBG)
        log("isConnected(" + device + ")");
    if (mService != null) {
        try {
            return mService.isConnected(device);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            log(Log.getStackTraceString(new Throwable()));
    }
    return false;
}
Body of Second Method:
{
    if (VDBG)
        log("isConnected(" + device + ")");
    final IBluetoothMap service = mService;
    if (service != null) {
        try {
            return service.isConnected(device);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            log(Log.getStackTraceString(new Throwable()));
    }
    return false;
}
------------------------
Find a silently evolved API code:android.graphics.ImageFormat.getBitsPerPixel:COMMENT
Method Modifier: public      static      
Comment:/**
 * Use this function to retrieve the number of bits per pixel of an
 * ImageFormat.
 *
 * @param format
 * @return the number of bits per pixel of the given format or -1 if the
 * format doesn't exist or is not supported.
 */

Body of Frist Method:
{
    switch(format) {
        case RGB_565:
            return 16;
        case NV16:
            return 16;
        case YUY2:
            return 16;
        case YV12:
            return 12;
        case Y8:
            return 8;
        case Y16:
        case DEPTH16:
            return 16;
        case NV21:
            return 12;
        case YUV_420_888:
            return 12;
        case YUV_422_888:
            return 16;
        case YUV_444_888:
            return 24;
        case FLEX_RGB_888:
            return 24;
        case FLEX_RGBA_8888:
            return 32;
        case RAW_SENSOR:
            return 16;
        case RAW10:
            return 10;
        case RAW12:
            return 12;
    }
    return -1;
}
Body of Second Method:
{
    switch(format) {
        case RGB_565:
            return 16;
        case NV16:
            return 16;
        case YUY2:
            return 16;
        case YV12:
            return 12;
        case Y8:
            return 8;
        case Y16:
        case DEPTH16:
            return 16;
        case NV21:
            return 12;
        case YUV_420_888:
            return 12;
        case YUV_422_888:
            return 16;
        case YUV_444_888:
            return 24;
        case FLEX_RGB_888:
            return 24;
        case FLEX_RGBA_8888:
            return 32;
        case RAW_DEPTH:
        case RAW_SENSOR:
            return 16;
        case RAW10:
            return 10;
        case RAW12:
            return 12;
    }
    return -1;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothDevice.setAlias:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Set the Bluetooth alias of the remote device.
 * <p>Alias is the locally modified name of a remote device.
 * <p>This methoid overwrites the alias. The changed
 * alias is saved in the local storage so that the change
 * is preserved over power cycle.
 *
 * @return true on success, false on error
 * @hide
 */

Body of Frist Method:
{
    if (sService == null) {
        Log.e(TAG, "BT not enabled. Cannot set Remote Device name");
        return false;
    }
    try {
        return sService.setRemoteAlias(this, alias);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
Body of Second Method:
{
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, "BT not enabled. Cannot set Remote Device name");
        return false;
    }
    try {
        return service.setRemoteAlias(this, alias);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothAvrcpController.getPlayerSettings:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Gets the player application settings.
 *
 * @return the {@link BluetoothAvrcpPlayerSettings} or {@link null} if there is an error.
 */

Body of Frist Method:
{
    if (DBG)
        Log.d(TAG, "getPlayerSettings");
    BluetoothAvrcpPlayerSettings settings = null;
    if (mService != null && isEnabled()) {
        try {
            settings = mService.getPlayerSettings(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Error talking to BT service in getMetadata() " + e);
            return null;
        }
    }
    return settings;
}
Body of Second Method:
{
    if (DBG)
        Log.d(TAG, "getPlayerSettings");
    BluetoothAvrcpPlayerSettings settings = null;
    final IBluetoothAvrcpController service = mService;
    if (service != null && isEnabled()) {
        try {
            settings = service.getPlayerSettings(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Error talking to BT service in getMetadata() " + e);
            return null;
        }
    }
    return settings;
}
------------------------
Find a silently evolved API code:android.widget.NumberPicker.hideSoftInput:COMMENT
Method Modifier: private     
Comment:/**
 * Hides the soft input if it is active for the input text.
 */

Body of Frist Method:
{
    InputMethodManager inputMethodManager = InputMethodManager.peekInstance();
    if (inputMethodManager != null && inputMethodManager.isActive(mInputText)) {
        inputMethodManager.hideSoftInputFromWindow(getWindowToken(), 0);
        if (mHasSelectorWheel) {
            mInputText.setVisibility(View.INVISIBLE);
        }
    }
}
Body of Second Method:
{
    InputMethodManager inputMethodManager = InputMethodManager.peekInstance();
    if (inputMethodManager != null && inputMethodManager.isActive(mInputText)) {
        inputMethodManager.hideSoftInputFromWindow(getWindowToken(), 0);
    }
    if (mHasSelectorWheel) {
        mInputText.setVisibility(View.INVISIBLE);
    }
}
------------------------
Find a silently evolved API code:android.hardware.usb.UsbManager.hasPermission:COMMENT
Method Modifier: public      
Comment:/**
 * Returns true if the caller has permission to access the accessory.
 * Permission might have been granted temporarily via
 * {@link #requestPermission(UsbAccessory, PendingIntent)} or
 * by the user choosing the caller as the default application for the accessory.
 *
 * @param accessory to check permissions for
 * @return true if caller has permission
 */

Body of Frist Method:
{
    try {
        return mService.hasAccessoryPermission(accessory);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    if (mService == null) {
        return false;
    }
    try {
        return mService.hasAccessoryPermission(accessory);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothPan.getConnectionState:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (VDBG)
        log("getState(" + device + ")");
    if (mPanService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mPanService.getConnectionState(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.STATE_DISCONNECTED;
        }
    }
    if (mPanService == null)
        Log.w(TAG, "Proxy not attached to service");
    return BluetoothProfile.STATE_DISCONNECTED;
}
Body of Second Method:
{
    if (VDBG)
        log("getState(" + device + ")");
    final IBluetoothPan service = mPanService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getConnectionState(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.STATE_DISCONNECTED;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return BluetoothProfile.STATE_DISCONNECTED;
}
------------------------
Find a silently evolved API code:android.app.SharedElementCallback.onCreateSnapshotView:COMMENT
Method Modifier: public      
Comment:/**
 * Reconstitutes a snapshot View from a Parcelable returned in
 * {@link #onCaptureSharedElementSnapshot(android.view.View, android.graphics.Matrix,
 * android.graphics.RectF)} to be used in {@link #onSharedElementStart(java.util.List,
 * java.util.List, java.util.List)} and {@link #onSharedElementEnd(java.util.List,
 * java.util.List, java.util.List)}. The returned View will be sized and positioned after
 * this call so that it is ready to be added to the decor View's overlay.
 *
 * <p>This is not called for Fragment Transitions.</p>
 *
 * @param context The Context used to create the snapshot View.
 * @param snapshot The Parcelable returned by {@link #onCaptureSharedElementSnapshot(
 * android.view.View, android.graphics.Matrix, android.graphics.RectF)}.
 * @return A View to be sent in {@link #onSharedElementStart(java.util.List, java.util.List,
 * java.util.List)} and {@link #onSharedElementEnd(java.util.List, java.util.List,
 * java.util.List)}. A null value will produce a null snapshot value for those two methods.
 */

Body of Frist Method:
{
    View view = null;
    if (snapshot instanceof Bundle) {
        Bundle bundle = (Bundle) snapshot;
        Bitmap bitmap = (Bitmap) bundle.getParcelable(BUNDLE_SNAPSHOT_BITMAP);
        if (bitmap == null) {
            return null;
        }
        ImageView imageView = new ImageView(context);
        view = imageView;
        imageView.setImageBitmap(bitmap);
        imageView.setScaleType(ScaleType.valueOf(bundle.getString(BUNDLE_SNAPSHOT_IMAGE_SCALETYPE)));
        if (imageView.getScaleType() == ScaleType.MATRIX) {
            float[] values = bundle.getFloatArray(BUNDLE_SNAPSHOT_IMAGE_MATRIX);
            Matrix matrix = new Matrix();
            matrix.setValues(values);
            imageView.setImageMatrix(matrix);
        }
    } else if (snapshot instanceof Bitmap) {
        Bitmap bitmap = (Bitmap) snapshot;
        view = new View(context);
        Resources resources = context.getResources();
        view.setBackground(new BitmapDrawable(resources, bitmap));
    }
    return view;
}
Body of Second Method:
{
    View view = null;
    if (snapshot instanceof Bundle) {
        Bundle bundle = (Bundle) snapshot;
        GraphicBuffer buffer = bundle.getParcelable(BUNDLE_SNAPSHOT_GRAPHIC_BUFFER);
        Bitmap bitmap = bundle.getParcelable(BUNDLE_SNAPSHOT_BITMAP);
        if (buffer == null && bitmap == null) {
            return null;
        }
        if (bitmap == null) {
            bitmap = Bitmap.createHardwareBitmap(buffer);
        }
        ImageView imageView = new ImageView(context);
        view = imageView;
        imageView.setImageBitmap(bitmap);
        imageView.setScaleType(ScaleType.valueOf(bundle.getString(BUNDLE_SNAPSHOT_IMAGE_SCALETYPE)));
        if (imageView.getScaleType() == ScaleType.MATRIX) {
            float[] values = bundle.getFloatArray(BUNDLE_SNAPSHOT_IMAGE_MATRIX);
            Matrix matrix = new Matrix();
            matrix.setValues(values);
            imageView.setImageMatrix(matrix);
        }
    } else if (snapshot instanceof Bitmap) {
        Bitmap bitmap = (Bitmap) snapshot;
        view = new View(context);
        Resources resources = context.getResources();
        view.setBackground(new BitmapDrawable(resources, bitmap));
    }
    return view;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothSap.isConnected:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns true if the specified Bluetooth device is connected.
 * Returns false if not connected, or if this proxy object is not
 * currently connected to the Sap service.
 * @hide
 */

Body of Frist Method:
{
    if (VDBG)
        log("isConnected(" + device + ")");
    if (mService != null) {
        try {
            return mService.isConnected(device);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            log(Log.getStackTraceString(new Throwable()));
    }
    return false;
}
Body of Second Method:
{
    if (VDBG)
        log("isConnected(" + device + ")");
    final IBluetoothSap service = mService;
    if (service != null) {
        try {
            return service.isConnected(device);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            log(Log.getStackTraceString(new Throwable()));
    }
    return false;
}
------------------------
Find a silently evolved API code:android.net.netlink.StructNlAttr.peek:COMMENT
Method Modifier: public      static      hidden      
Comment:// looking for instances of a particular type.

Body of Frist Method:
{
    if (byteBuffer == null || byteBuffer.remaining() < NLA_HEADERLEN) {
        return null;
    }
    final int baseOffset = byteBuffer.position();
    final StructNlAttr struct = new StructNlAttr();
    struct.nla_len = byteBuffer.getShort();
    struct.nla_type = byteBuffer.getShort();
    struct.mByteOrder = byteBuffer.order();
    byteBuffer.position(baseOffset);
    if (struct.nla_len < NLA_HEADERLEN) {
        // Malformed.
        return null;
    }
    return struct;
}
Body of Second Method:
{
    if (byteBuffer == null || byteBuffer.remaining() < NLA_HEADERLEN) {
        return null;
    }
    final int baseOffset = byteBuffer.position();
    // Assume the byte order of the buffer is the expected byte order of the value.
    final StructNlAttr struct = new StructNlAttr(byteBuffer.order());
    // The byte order of nla_len and nla_type is always native.
    final ByteOrder originalOrder = byteBuffer.order();
    byteBuffer.order(ByteOrder.nativeOrder());
    try {
        struct.nla_len = byteBuffer.getShort();
        struct.nla_type = byteBuffer.getShort();
    } finally {
        byteBuffer.order(originalOrder);
    }
    byteBuffer.position(baseOffset);
    if (struct.nla_len < NLA_HEADERLEN) {
        // Malformed.
        return null;
    }
    return struct;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothSap.getDevicesMatchingConnectionStates:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the list of devices matching specified states. Currently at most one.
 *
 * @return list of matching devices
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("getDevicesMatchingStates()");
    if (mService != null && isEnabled()) {
        try {
            return mService.getDevicesMatchingConnectionStates(states);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
Body of Second Method:
{
    if (DBG)
        log("getDevicesMatchingStates()");
    final IBluetoothSap service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.getDevicesMatchingConnectionStates(states);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothDevice.getAlias:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the Bluetooth alias of the remote device.
 * <p>Alias is the locally modified name of a remote device.
 *
 * @return the Bluetooth alias, or null if no alias or there was a problem
 * @hide
 */

Body of Frist Method:
{
    if (sService == null) {
        Log.e(TAG, "BT not enabled. Cannot get Remote Device Alias");
        return null;
    }
    try {
        return sService.getRemoteAlias(this);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return null;
}
Body of Second Method:
{
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, "BT not enabled. Cannot get Remote Device Alias");
        return null;
    }
    try {
        return service.getRemoteAlias(this);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return null;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothInputDevice.setReport:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Send Set_Report command to the connected HID input device.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN} permission.
 *
 * @param device Remote Bluetooth Device
 * @param reportType Report type
 * @param report Report receiving buffer size
 * @return false on immediate error,
 * true otherwise
 * @hide
 */

Body of Frist Method:
{
    if (VDBG)
        log("setReport(" + device + "), reportType=" + reportType + " report=" + report);
    if (mService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mService.setReport(device, reportType, report);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (VDBG)
        log("setReport(" + device + "), reportType=" + reportType + " report=" + report);
    final IBluetoothInputDevice service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.setReport(device, reportType, report);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.hardware.camera2.CameraManager.setTorchMode:COMMENT
Method Modifier: public      
Comment:/**
 * Set the flash unit's torch mode of the camera of the given ID without opening the camera
 * device.
 *
 * <p>Use {@link #getCameraIdList} to get the list of available camera devices and use
 * {@link #getCameraCharacteristics} to check whether the camera device has a flash unit.
 * Note that even if a camera device has a flash unit, turning on the torch mode may fail
 * if the camera device or other camera resources needed to turn on the torch mode are in use.
 * </p>
 *
 * <p> If {@link #setTorchMode} is called to turn on or off the torch mode successfully,
 * {@link CameraManager.TorchCallback#onTorchModeChanged} will be invoked.
 * However, even if turning on the torch mode is successful, the application does not have the
 * exclusive ownership of the flash unit or the camera device. The torch mode will be turned
 * off and becomes unavailable when the camera device that the flash unit belongs to becomes
 * unavailable or when other camera resources to keep the torch on become unavailable (
 * {@link CameraManager.TorchCallback#onTorchModeUnavailable} will be invoked). Also,
 * other applications are free to call {@link #setTorchMode} to turn off the torch mode (
 * {@link CameraManager.TorchCallback#onTorchModeChanged} will be invoked). If the latest
 * application that turned on the torch mode exits, the torch mode will be turned off.
 *
 * @param cameraId
 * The unique identifier of the camera device that the flash unit belongs to.
 * @param enabled
 * The desired state of the torch mode for the target camera device. Set to
 * {@code true} to turn on the torch mode. Set to {@code false} to turn off the
 * torch mode.
 *
 * @throws CameraAccessException if it failed to access the flash unit.
 * {@link CameraAccessException#CAMERA_IN_USE} will be thrown if the camera device
 * is in use. {@link CameraAccessException#MAX_CAMERAS_IN_USE} will be thrown if
 * other camera resources needed to turn on the torch mode are in use.
 * {@link CameraAccessException#CAMERA_DISCONNECTED} will be thrown if camera
 * service is not available.
 *
 * @throws IllegalArgumentException if cameraId was null, cameraId doesn't match any currently
 * or previously available camera device, or the camera device doesn't have a
 * flash unit.
 */

Body of Frist Method:
{
    CameraManagerGlobal.get().setTorchMode(cameraId, enabled);
}
Body of Second Method:
{
    if (CameraManagerGlobal.sCameraServiceDisabled) {
        throw new IllegalArgumentException("No cameras available on device");
    }
    CameraManagerGlobal.get().setTorchMode(cameraId, enabled);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothInputDevice.getReport:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Send Get_Report command to the connected HID input device.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN} permission.
 *
 * @param device Remote Bluetooth Device
 * @param reportType Report type
 * @param reportId Report ID
 * @param bufferSize Report receiving buffer size
 * @return false on immediate error,
 * true otherwise
 * @hide
 */

Body of Frist Method:
{
    if (VDBG)
        log("getReport(" + device + "), reportType=" + reportType + " reportId=" + reportId + "bufferSize=" + bufferSize);
    if (mService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mService.getReport(device, reportType, reportId, bufferSize);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (VDBG) {
        log("getReport(" + device + "), reportType=" + reportType + " reportId=" + reportId + "bufferSize=" + bufferSize);
    }
    final IBluetoothInputDevice service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getReport(device, reportType, reportId, bufferSize);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHealth.getMainChannelFd:COMMENT
Method Modifier: public      
Comment:/**
 * Get the file descriptor of the main channel associated with the remote device
 * and application configuration.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * <p> Its the responsibility of the caller to close the ParcelFileDescriptor
 * when done.
 *
 * @param device The remote Bluetooth health device
 * @param config The application configuration
 * @return null on failure, ParcelFileDescriptor on success.
 */

Body of Frist Method:
{
    if (mService != null && isEnabled() && isValidDevice(device) && config != null) {
        try {
            return mService.getMainChannelFd(device, config);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return null;
}
Body of Second Method:
{
    final IBluetoothHealth service = mService;
    if (service != null && isEnabled() && isValidDevice(device) && config != null) {
        try {
            return service.getMainChannelFd(device, config);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return null;
}
------------------------
Find a silently evolved API code:android.os.MemoryFile.length:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the length of the memory file.
 *
 * @return file length.
 */

Body of Frist Method:
{
    return mLength;
}
Body of Second Method:
{
    return mSharedMemory.getSize();
}
------------------------
Find a silently evolved API code:android.net.NetworkTemplate.matches:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Test if given {@link NetworkIdentity} matches this template.
 */

Body of Frist Method:
{
    switch(mMatchRule) {
        case MATCH_MOBILE_ALL:
            return matchesMobile(ident);
        case MATCH_MOBILE_3G_LOWER:
            return matchesMobile3gLower(ident);
        case MATCH_MOBILE_4G:
            return matchesMobile4g(ident);
        case MATCH_WIFI:
            return matchesWifi(ident);
        case MATCH_ETHERNET:
            return matchesEthernet(ident);
        case MATCH_MOBILE_WILDCARD:
            return matchesMobileWildcard(ident);
        case MATCH_WIFI_WILDCARD:
            return matchesWifiWildcard(ident);
        case MATCH_BLUETOOTH:
            return matchesBluetooth(ident);
        case MATCH_PROXY:
            return matchesProxy(ident);
        default:
            throw new IllegalArgumentException("unknown network template");
    }
}
Body of Second Method:
{
    switch(mMatchRule) {
        case MATCH_MOBILE_ALL:
            return matchesMobile(ident);
        case MATCH_MOBILE_3G_LOWER:
            return matchesMobile3gLower(ident);
        case MATCH_MOBILE_4G:
            return matchesMobile4g(ident);
        case MATCH_WIFI:
            return matchesWifi(ident);
        case MATCH_ETHERNET:
            return matchesEthernet(ident);
        case MATCH_MOBILE_WILDCARD:
            return matchesMobileWildcard(ident);
        case MATCH_WIFI_WILDCARD:
            return matchesWifiWildcard(ident);
        case MATCH_BLUETOOTH:
            return matchesBluetooth(ident);
        case MATCH_PROXY:
            return matchesProxy(ident);
        default:
            // just claim not to match anything.
            return false;
    }
}
------------------------
Find a silently evolved API code:android.app.usage.NetworkStatsManager.queryDetailsForUidTag:COMMENT
Method Modifier: public      
Comment:/**
 * Query network usage statistics details for a given uid and tag. Only usable for uids
 * belonging to calling user. Result is aggregated over state but not aggregated over time.
 * This means buckets' start and end timestamps are going to be between 'startTime' and
 * 'endTime' parameters. State is going to be {@link NetworkStats.Bucket#STATE_ALL}, uid the
 * same as the 'uid' parameter and tag the same as 'tag' parameter. metered is going to be
 * {@link NetworkStats.Bucket#METERED_ALL}, and roaming is going to be
 * {@link NetworkStats.Bucket#ROAMING_ALL}.
 * <p>Only includes buckets that atomically occur in the inclusive time range. Doesn't
 * interpolate across partial buckets. Since bucket length is in the order of hours, this
 * method cannot be used to measure data usage on a fine grained time scale.
 *
 * @param networkType As defined in {@link ConnectivityManager}, e.g.
 * {@link ConnectivityManager#TYPE_MOBILE}, {@link ConnectivityManager#TYPE_WIFI}
 * etc.
 * @param subscriberId If applicable, the subscriber id of the network interface.
 * @param startTime Start of period. Defined in terms of "Unix time", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param endTime End of period. Defined in terms of "Unix time", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param uid UID of app
 * @param tag TAG of interest. Use {@link NetworkStats.Bucket#TAG_NONE} for no tags.
 * @return Statistics object or null if an error happened during statistics collection.
 * @throws SecurityException if permissions are insufficient to read network statistics.
 */

Body of Frist Method:
{
    NetworkTemplate template;
    template = createTemplate(networkType, subscriberId);
    NetworkStats result;
    try {
        result = new NetworkStats(mContext, template, startTime, endTime);
        result.startHistoryEnumeration(uid, tag);
    } catch (RemoteException e) {
        Log.e(TAG, "Error while querying stats for uid=" + uid + " tag=" + tag, e);
        return null;
    }
    return result;
}
Body of Second Method:
{
    NetworkTemplate template;
    template = createTemplate(networkType, subscriberId);
    NetworkStats result;
    try {
        result = new NetworkStats(mContext, template, mFlags, startTime, endTime);
        result.startHistoryEnumeration(uid, tag);
    } catch (RemoteException e) {
        Log.e(TAG, "Error while querying stats for uid=" + uid + " tag=" + tag, e);
        return null;
    }
    return result;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothInputDevice.setPriority:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Set priority of the profile
 *
 * <p> The device should already be paired.
 * Priority can be one of {@link #PRIORITY_ON} or
 * {@link #PRIORITY_OFF},
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}
 * permission.
 *
 * @param device Paired bluetooth device
 * @param priority
 * @return true if priority is set, false on error
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("setPriority(" + device + ", " + priority + ")");
    if (mService != null && isEnabled() && isValidDevice(device)) {
        if (priority != BluetoothProfile.PRIORITY_OFF && priority != BluetoothProfile.PRIORITY_ON) {
            return false;
        }
        try {
            return mService.setPriority(device, priority);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("setPriority(" + device + ", " + priority + ")");
    final IBluetoothInputDevice service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        if (priority != BluetoothProfile.PRIORITY_OFF && priority != BluetoothProfile.PRIORITY_ON) {
            return false;
        }
        try {
            return service.setPriority(device, priority);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadset.connectAudio:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Initiates a connection of headset audio.
 * It setup SCO channel with remote connected headset device.
 *
 * @return true if successful
 * false if there was some error such as
 * there is no connected headset
 * @hide
 */

Body of Frist Method:
{
    if (mService != null && isEnabled()) {
        try {
            return mService.connectAudio();
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return false;
}
Body of Second Method:
{
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.connectAudio();
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return false;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadset.disconnectAudio:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Initiates a disconnection of headset audio.
 * It tears down the SCO channel from remote headset device.
 *
 * @return true if successful
 * false if there was some error such as
 * there is no connected SCO channel
 * @hide
 */

Body of Frist Method:
{
    if (mService != null && isEnabled()) {
        try {
            return mService.disconnectAudio();
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return false;
}
Body of Second Method:
{
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.disconnectAudio();
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return false;
}
------------------------
Find a silently evolved API code:android.net.wifi.p2p.WifiP2pManager.initialize:COMMENT
Method Modifier: public      
Comment:/**
 * Registers the application with the Wi-Fi framework. This function
 * must be the first to be called before any p2p operations are performed.
 *
 * @param srcContext is the context of the source
 * @param srcLooper is the Looper on which the callbacks are receivied
 * @param listener for callback at loss of framework communication. Can be null.
 * @return Channel instance that is necessary for performing any further p2p operations
 */

Body of Frist Method:
{
    return initalizeChannel(srcContext, srcLooper, listener, getMessenger());
}
Body of Second Method:
{
    Binder binder = new Binder();
    Channel channel = initalizeChannel(srcContext, srcLooper, listener, getMessenger(binder), binder);
    return channel;
}
------------------------
Find a silently evolved API code:android.transition.TransitionUtils.copyViewImage:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Creates a View using the bitmap copy of <code>view</code>. If <code>view</code> is large,
 * the copy will use a scaled bitmap of the given view.
 *
 * @param sceneRoot The ViewGroup in which the view copy will be displayed.
 * @param view The view to create a copy of.
 * @param parent The parent of view.
 */

Body of Frist Method:
{
    Matrix matrix = new Matrix();
    matrix.setTranslate(-parent.getScrollX(), -parent.getScrollY());
    view.transformMatrixToGlobal(matrix);
    sceneRoot.transformMatrixToLocal(matrix);
    RectF bounds = new RectF(0, 0, view.getWidth(), view.getHeight());
    matrix.mapRect(bounds);
    int left = Math.round(bounds.left);
    int top = Math.round(bounds.top);
    int right = Math.round(bounds.right);
    int bottom = Math.round(bounds.bottom);
    ImageView copy = new ImageView(view.getContext());
    copy.setScaleType(ImageView.ScaleType.CENTER_CROP);
    Bitmap bitmap = createViewBitmap(view, matrix, bounds);
    if (bitmap != null) {
        copy.setImageBitmap(bitmap);
    }
    int widthSpec = View.MeasureSpec.makeMeasureSpec(right - left, View.MeasureSpec.EXACTLY);
    int heightSpec = View.MeasureSpec.makeMeasureSpec(bottom - top, View.MeasureSpec.EXACTLY);
    copy.measure(widthSpec, heightSpec);
    copy.layout(left, top, right, bottom);
    return copy;
}
Body of Second Method:
{
    Matrix matrix = new Matrix();
    matrix.setTranslate(-parent.getScrollX(), -parent.getScrollY());
    view.transformMatrixToGlobal(matrix);
    sceneRoot.transformMatrixToLocal(matrix);
    RectF bounds = new RectF(0, 0, view.getWidth(), view.getHeight());
    matrix.mapRect(bounds);
    int left = Math.round(bounds.left);
    int top = Math.round(bounds.top);
    int right = Math.round(bounds.right);
    int bottom = Math.round(bounds.bottom);
    ImageView copy = new ImageView(view.getContext());
    copy.setScaleType(ImageView.ScaleType.CENTER_CROP);
    Bitmap bitmap = createViewBitmap(view, matrix, bounds, sceneRoot);
    if (bitmap != null) {
        copy.setImageBitmap(bitmap);
    }
    int widthSpec = View.MeasureSpec.makeMeasureSpec(right - left, View.MeasureSpec.EXACTLY);
    int heightSpec = View.MeasureSpec.makeMeasureSpec(bottom - top, View.MeasureSpec.EXACTLY);
    copy.measure(widthSpec, heightSpec);
    copy.layout(left, top, right, bottom);
    return copy;
}
------------------------
Find a silently evolved API code:android.net.wifi.p2p.WifiP2pManager.initializeInternal:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Registers the application with the Wi-Fi framework. Enables system-only functionality.
 * @hide
 */

Body of Frist Method:
{
    return initalizeChannel(srcContext, srcLooper, listener, getP2pStateMachineMessenger());
}
Body of Second Method:
{
    return initalizeChannel(srcContext, srcLooper, listener, getP2pStateMachineMessenger(), null);
}
------------------------
Find a silently evolved API code:android.telephony.TelephonyManager.isDataConnectivityPossible:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            return telephony.isDataConnectivityPossible();
    } catch (RemoteException e) {
        Log.e(TAG, "Error calling ITelephony#isDataConnectivityPossible", e);
    }
    return false;
}
Body of Second Method:
{
    try {
        ITelephony telephony = getITelephony();
        if (telephony != null)
            return telephony.isDataConnectivityPossible(getSubId(SubscriptionManager.getDefaultDataSubscriptionId()));
    } catch (RemoteException e) {
        Log.e(TAG, "Error calling ITelephony#isDataAllowed", e);
    }
    return false;
}
------------------------
Find a silently evolved API code:android.os.MemoryFile.writeBytes:COMMENT
Method Modifier: public      
Comment:/**
 * Write bytes to the memory file.
 * Will throw an IOException if the file has been purged.
 *
 * @param buffer byte array to write bytes from.
 * @param srcOffset offset into the byte array buffer to write from.
 * @param destOffset offset  into the memory file to write to.
 * @param count number of bytes to write.
 * @throws IOException if the memory file has been purged or deactivated.
 */

Body of Frist Method:
{
    if (isDeactivated()) {
        throw new IOException("Can't write to deactivated memory file.");
    }
    if (srcOffset < 0 || srcOffset > buffer.length || count < 0 || count > buffer.length - srcOffset || destOffset < 0 || destOffset > mLength || count > mLength - destOffset) {
        throw new IndexOutOfBoundsException();
    }
    native_write(mFD, mAddress, buffer, srcOffset, destOffset, count, mAllowPurging);
}
Body of Second Method:
{
    beginAccess();
    try {
        mMapping.position(destOffset);
        mMapping.put(buffer, srcOffset, count);
    } finally {
        endAccess();
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.disconnectAudio:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Disconnects audio channel.
 *
 * It tears down the SCO channel from remote AG device.
 *
 * @param   device  remote device
 * @return          <code>true</code> if command has been issued successfully;
 * <code>false</code> otherwise;
 * upon completion HFP sends {@link #ACTION_AUDIO_STATE_CHANGED}
 * intent;
 */

Body of Frist Method:
{
    if (mService != null && isEnabled()) {
        try {
            return mService.disconnectAudio(device);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return false;
}
Body of Second Method:
{
    final IBluetoothHeadsetClient service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.disconnectAudio(device);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return false;
}
------------------------
Find a silently evolved API code:android.hardware.camera2.CameraManager.openCameraForUid:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Open a connection to a camera with the given ID, on behalf of another application
 * specified by clientUid.
 *
 * <p>The behavior of this method matches that of {@link #openCamera}, except that it allows
 * the caller to specify the UID to use for permission/etc verification. This can only be
 * done by services trusted by the camera subsystem to act on behalf of applications and
 * to forward the real UID.</p>
 *
 * @param clientUid
 * The UID of the application on whose behalf the camera is being opened.
 * Must be USE_CALLING_UID unless the caller is a trusted service.
 *
 * @hide
 */

Body of Frist Method:
{
    if (cameraId == null) {
        throw new IllegalArgumentException("cameraId was null");
    } else if (callback == null) {
        throw new IllegalArgumentException("callback was null");
    } else if (handler == null) {
        if (Looper.myLooper() != null) {
            handler = new Handler();
        } else {
            throw new IllegalArgumentException("Handler argument is null, but no looper exists in the calling thread");
        }
    }
    openCameraDeviceUserAsync(cameraId, callback, handler, clientUid);
}
Body of Second Method:
{
    if (cameraId == null) {
        throw new IllegalArgumentException("cameraId was null");
    } else if (callback == null) {
        throw new IllegalArgumentException("callback was null");
    } else if (handler == null) {
        if (Looper.myLooper() != null) {
            handler = new Handler();
        } else {
            throw new IllegalArgumentException("Handler argument is null, but no looper exists in the calling thread");
        }
    }
    if (CameraManagerGlobal.sCameraServiceDisabled) {
        throw new IllegalArgumentException("No cameras available on device");
    }
    openCameraDeviceUserAsync(cameraId, callback, handler, clientUid);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothDevice.isEncrypted:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns whether there is an open connection to this device
 * that has been encrypted.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}.
 *
 * @return True if there is at least one encrypted connection to this device.
 * @hide
 */

Body of Frist Method:
{
    if (sService == null) {
        // BT is not enabled, we cannot be connected.
        return false;
    }
    try {
        return sService.getConnectionState(this) > CONNECTION_STATE_CONNECTED;
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        return false;
    }
}
Body of Second Method:
{
    final IBluetooth service = sService;
    if (service == null) {
        // BT is not enabled, we cannot be connected.
        return false;
    }
    try {
        return service.getConnectionState(this) > CONNECTION_STATE_CONNECTED;
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        return false;
    }
}
------------------------
Find a silently evolved API code:android.widget.NumberPicker.onScrollerFinished:COMMENT
Method Modifier: private     
Comment:/**
 * Callback invoked upon completion of a given <code>scroller</code>.
 */

Body of Frist Method:
{
    if (scroller == mFlingScroller) {
        if (!ensureScrollWheelAdjusted()) {
            updateInputTextView();
        }
        onScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
    } else {
        if (mScrollState != OnScrollListener.SCROLL_STATE_TOUCH_SCROLL) {
            updateInputTextView();
        }
    }
}
Body of Second Method:
{
    if (scroller == mFlingScroller) {
        ensureScrollWheelAdjusted();
        updateInputTextView();
        onScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
    } else {
        if (mScrollState != OnScrollListener.SCROLL_STATE_TOUCH_SCROLL) {
            updateInputTextView();
        }
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothPan.getDevicesMatchingConnectionStates:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (VDBG)
        log("getDevicesMatchingStates()");
    if (mPanService != null && isEnabled()) {
        try {
            return mPanService.getDevicesMatchingConnectionStates(states);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (mPanService == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
Body of Second Method:
{
    if (VDBG)
        log("getDevicesMatchingStates()");
    final IBluetoothPan service = mPanService;
    if (service != null && isEnabled()) {
        try {
            return service.getDevicesMatchingConnectionStates(states);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHealth.connectChannelToSource:COMMENT
Method Modifier: public      
Comment:/**
 * Connect to a health device which has the {@link #SOURCE_ROLE}.
 * This is an asynchronous call. If this function returns true, the callback
 * associated with the application configuration will be called.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param device The remote Bluetooth device.
 * @param config The application configuration which has been registered using
 * {@link #registerSinkAppConfiguration(String, int, BluetoothHealthCallback) }
 * @return If true, the callback associated with the application config will be called.
 */

Body of Frist Method:
{
    if (mService != null && isEnabled() && isValidDevice(device) && config != null) {
        try {
            return mService.connectChannelToSource(device, config);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return false;
}
Body of Second Method:
{
    final IBluetoothHealth service = mService;
    if (service != null && isEnabled() && isValidDevice(device) && config != null) {
        try {
            return service.connectChannelToSource(device, config);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return false;
}
------------------------
Find a silently evolved API code:android.media.AudioPlaybackConfiguration.init:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (mIPlayerShell != null) {
        mIPlayerShell.monitorDeath();
    }
}
Body of Second Method:
{
    synchronized (this) {
        if (mIPlayerShell != null) {
            mIPlayerShell.monitorDeath();
        }
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothDevice.getBondState:COMMENT
Method Modifier: public      
Comment:/**
 * Get the bond state of the remote device.
 * <p>Possible values for the bond state are:
 * {@link #BOND_NONE},
 * {@link #BOND_BONDING},
 * {@link #BOND_BONDED}.
 *
 * @return the bond state
 */

Body of Frist Method:
{
    if (sService == null) {
        Log.e(TAG, "BT not enabled. Cannot get bond state");
        return BOND_NONE;
    }
    try {
        return sService.getBondState(this);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    } catch (NullPointerException npe) {
        // Handle case where bluetooth service proxy
        // is already null.
        Log.e(TAG, "NullPointerException for getBondState() of device (" + getAddress() + ")", npe);
    }
    return BOND_NONE;
}
Body of Second Method:
{
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, "BT not enabled. Cannot get bond state");
        return BOND_NONE;
    }
    try {
        return service.getBondState(this);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return BOND_NONE;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadset.getPriority:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the priority of the profile.
 *
 * <p> The priority can be any of:
 * {@link #PRIORITY_AUTO_CONNECT}, {@link #PRIORITY_OFF},
 * {@link #PRIORITY_ON}, {@link #PRIORITY_UNDEFINED}
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param device Bluetooth device
 * @return priority of the device
 * @hide
 */

Body of Frist Method:
{
    if (VDBG)
        log("getPriority(" + device + ")");
    if (mService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mService.getPriority(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return PRIORITY_OFF;
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return PRIORITY_OFF;
}
Body of Second Method:
{
    if (VDBG)
        log("getPriority(" + device + ")");
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getPriority(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return PRIORITY_OFF;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return PRIORITY_OFF;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothInputDevice.connect:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Initiate connection to a profile of the remote bluetooth device.
 *
 * <p> The system supports connection to multiple input devices.
 *
 * <p> This API returns false in scenarios like the profile on the
 * device is already connected or Bluetooth is not turned on.
 * When this API returns true, it is guaranteed that
 * connection state intent for the profile will be broadcasted with
 * the state. Users can get the connection state of the profile
 * from this intent.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}
 * permission.
 *
 * @param device Remote Bluetooth Device
 * @return false on immediate error,
 * true otherwise
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("connect(" + device + ")");
    if (mService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mService.connect(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("connect(" + device + ")");
    final IBluetoothInputDevice service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.connect(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.net.NetworkCapabilities.transportNameOf:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (transport < 0 || TRANSPORT_NAMES.length <= transport) {
        return "UNKNOWN";
    }
    return TRANSPORT_NAMES[transport];
}
Body of Second Method:
{
    if (!isValidTransport(transport)) {
        return "UNKNOWN";
    }
    return TRANSPORT_NAMES[transport];
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothDevice.setPin:COMMENT
Method Modifier: public      
Comment:/**
 * Set the pin during pairing when the pairing method is {@link #PAIRING_VARIANT_PIN}
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}.
 *
 * @return true pin has been set
 * false for error
 */

Body of Frist Method:
{
    if (sService == null) {
        Log.e(TAG, "BT not enabled. Cannot set Remote Device pin");
        return false;
    }
    try {
        return sService.setPin(this, true, pin.length, pin);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
Body of Second Method:
{
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, "BT not enabled. Cannot set Remote Device pin");
        return false;
    }
    try {
        return service.setPin(this, true, pin.length, pin);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
------------------------
Find a silently evolved API code:android.widget.EdgeEffect.onAbsorb:COMMENT
Method Modifier: public      
Comment:/**
 * Call when the effect absorbs an impact at the given velocity.
 * Used when a fling reaches the scroll boundary.
 *
 * <p>When using a {@link android.widget.Scroller} or {@link android.widget.OverScroller},
 * the method <code>getCurrVelocity</code> will provide a reasonable approximation
 * to use here.</p>
 *
 * @param velocity Velocity at impact in pixels per second.
 */

Body of Frist Method:
{
    mState = STATE_ABSORB;
    velocity = Math.min(Math.max(MIN_VELOCITY, Math.abs(velocity)), MAX_VELOCITY);
    mStartTime = AnimationUtils.currentAnimationTimeMillis();
    mDuration = 0.15f + (velocity * 0.02f);
    // The glow depends more on the velocity, and therefore starts out
    // nearly invisible.
    mGlowAlphaStart = 0.3f;
    mGlowScaleYStart = Math.max(mGlowScaleY, 0.f);
    // Growth for the size of the glow should be quadratic to properly
    // respond
    // to a user's scrolling speed. The faster the scrolling speed, the more
    // intense the effect should be for both the size and the saturation.
    mGlowScaleYFinish = Math.min(0.025f + (velocity * (velocity / 100) * 0.00015f) / 2, 1.f);
    // Alpha should change for the glow as well as size.
    mGlowAlphaFinish = Math.max(mGlowAlphaStart, Math.min(velocity * VELOCITY_GLOW_FACTOR * .00001f, MAX_ALPHA));
    mTargetDisplacement = 0.5f;
}
Body of Second Method:
{
    mState = STATE_ABSORB;
    velocity = Math.min(Math.max(MIN_VELOCITY, Math.abs(velocity)), MAX_VELOCITY);
    mStartTime = AnimationUtils.currentAnimationTimeMillis();
    mDuration = 0.15f + (velocity * 0.02f);
    // The glow depends more on the velocity, and therefore starts out
    // nearly invisible.
    mGlowAlphaStart = GLOW_ALPHA_START;
    mGlowScaleYStart = Math.max(mGlowScaleY, 0.f);
    // Growth for the size of the glow should be quadratic to properly
    // respond
    // to a user's scrolling speed. The faster the scrolling speed, the more
    // intense the effect should be for both the size and the saturation.
    mGlowScaleYFinish = Math.min(0.025f + (velocity * (velocity / 100) * 0.00015f) / 2, 1.f);
    // Alpha should change for the glow as well as size.
    mGlowAlphaFinish = Math.max(mGlowAlphaStart, Math.min(velocity * VELOCITY_GLOW_FACTOR * .00001f, MAX_ALPHA));
    mTargetDisplacement = 0.5f;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.startVoiceRecognition:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Starts voice recognition.
 *
 * @param device    remote device
 * @return          <code>true</code> if command has been issued successfully;
 * <code>false</code> otherwise;
 * upon completion HFP sends {@link #ACTION_AG_EVENT}
 * intent.
 *
 * <p>Feature required for successful execution is being reported by:
 * {@link #EXTRA_AG_FEATURE_VOICE_RECOGNITION}.
 * This method invocation will fail silently when feature is not supported.</p>
 */

Body of Frist Method:
{
    if (DBG)
        log("startVoiceRecognition()");
    if (mService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mService.startVoiceRecognition(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("startVoiceRecognition()");
    final IBluetoothHeadsetClient service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.startVoiceRecognition(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothDevice.getMessageAccessPermission:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Requires {@link android.Manifest.permission#BLUETOOTH}.
 * @return Whether the message access is allowed to this device. Can be
 * {@link #ACCESS_UNKNOWN}, {@link #ACCESS_ALLOWED} or {@link #ACCESS_REJECTED}.
 * @hide
 */

Body of Frist Method:
{
    if (sService == null) {
        return ACCESS_UNKNOWN;
    }
    try {
        return sService.getMessageAccessPermission(this);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return ACCESS_UNKNOWN;
}
Body of Second Method:
{
    final IBluetooth service = sService;
    if (service == null) {
        return ACCESS_UNKNOWN;
    }
    try {
        return service.getMessageAccessPermission(this);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return ACCESS_UNKNOWN;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothDevice.removeBond:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Remove bond (pairing) with the remote device.
 * <p>Delete the link key associated with the remote device, and
 * immediately terminate connections to that device that require
 * authentication and encryption.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}.
 *
 * @return true on success, false on error
 * @hide
 */

Body of Frist Method:
{
    if (sService == null) {
        Log.e(TAG, "BT not enabled. Cannot remove Remote Device bond");
        return false;
    }
    try {
        Log.i(TAG, "removeBond() for device " + getAddress() + " called by pid: " + Process.myPid() + " tid: " + Process.myTid());
        return sService.removeBond(this);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
Body of Second Method:
{
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, "BT not enabled. Cannot remove Remote Device bond");
        return false;
    }
    try {
        Log.i(TAG, "removeBond() for device " + getAddress() + " called by pid: " + Process.myPid() + " tid: " + Process.myTid());
        return service.removeBond(this);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadset.connect:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Initiate connection to a profile of the remote bluetooth device.
 *
 * <p> Currently, the system supports only 1 connection to the
 * headset/handsfree profile. The API will automatically disconnect connected
 * devices before connecting.
 *
 * <p> This API returns false in scenarios like the profile on the
 * device is already connected or Bluetooth is not turned on.
 * When this API returns true, it is guaranteed that
 * connection state intent for the profile will be broadcasted with
 * the state. Users can get the connection state of the profile
 * from this intent.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}
 * permission.
 *
 * @param device Remote Bluetooth Device
 * @return false on immediate error,
 * true otherwise
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("connect(" + device + ")");
    if (mService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mService.connect(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("connect(" + device + ")");
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.connect(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothPan.disconnect:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Initiate disconnection from a profile
 *
 * <p> This API will return false in scenarios like the profile on the
 * Bluetooth device is not in connected state etc. When this API returns,
 * true, it is guaranteed that the connection state change
 * intent will be broadcasted with the state. Users can get the
 * disconnection state of the profile from this intent.
 *
 * <p> If the disconnection is initiated by a remote device, the state
 * will transition from {@link #STATE_CONNECTED} to
 * {@link #STATE_DISCONNECTED}. If the disconnect is initiated by the
 * host (local) device the state will transition from
 * {@link #STATE_CONNECTED} to state {@link #STATE_DISCONNECTING} to
 * state {@link #STATE_DISCONNECTED}. The transition to
 * {@link #STATE_DISCONNECTING} can be used to distinguish between the
 * two scenarios.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}
 * permission.
 *
 * @param device Remote Bluetooth Device
 * @return false on immediate error,
 * true otherwise
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("disconnect(" + device + ")");
    if (mPanService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mPanService.disconnect(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (mPanService == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("disconnect(" + device + ")");
    final IBluetoothPan service = mPanService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.disconnect(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadset.acceptIncomingConnect:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Accept the incoming connection.
 * Note: This is an internal function and shouldn't be exposed
 *
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("acceptIncomingConnect");
    if (mService != null && isEnabled()) {
        try {
            return mService.acceptIncomingConnect(device);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("acceptIncomingConnect");
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.acceptIncomingConnect(device);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return false;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothMap.getConnectedDevices:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the list of connected devices. Currently at most one.
 *
 * @return list of connected devices
 */

Body of Frist Method:
{
    if (DBG)
        log("getConnectedDevices()");
    if (mService != null && isEnabled()) {
        try {
            return mService.getConnectedDevices();
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
Body of Second Method:
{
    if (DBG)
        log("getConnectedDevices()");
    final IBluetoothMap service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.getConnectedDevices();
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
------------------------
Find a silently evolved API code:android.widget.NumberPicker.setValueInternal:COMMENT
Method Modifier: private     
Comment:/**
 * Sets the current value of this NumberPicker.
 *
 * @param current The new value of the NumberPicker.
 * @param notifyChange Whether to notify if the current value changed.
 */

Body of Frist Method:
{
    if (mValue == current) {
        return;
    }
    // Wrap around the values if we go past the start or end
    if (mWrapSelectorWheel) {
        current = getWrappedSelectorIndex(current);
    } else {
        current = Math.max(current, mMinValue);
        current = Math.min(current, mMaxValue);
    }
    int previous = mValue;
    mValue = current;
    updateInputTextView();
    if (notifyChange) {
        notifyChange(previous, current);
    }
    initializeSelectorWheelIndices();
    invalidate();
}
Body of Second Method:
{
    if (mValue == current) {
        return;
    }
    // Wrap around the values if we go past the start or end
    if (mWrapSelectorWheel) {
        current = getWrappedSelectorIndex(current);
    } else {
        current = Math.max(current, mMinValue);
        current = Math.min(current, mMaxValue);
    }
    int previous = mValue;
    mValue = current;
    // If we're flinging, we'll update the text view at the end when it becomes visible
    if (mScrollState != OnScrollListener.SCROLL_STATE_FLING) {
        updateInputTextView();
    }
    if (notifyChange) {
        notifyChange(previous, current);
    }
    initializeSelectorWheelIndices();
    invalidate();
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothPbap.getClient:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the currently connected remote Bluetooth device (PCE).
 * @return The remote Bluetooth device, or null if not in connected or
 * connecting state, or if this proxy object is not connected to
 * the Pbap service.
 */

Body of Frist Method:
{
    if (VDBG)
        log("getClient()");
    if (mService != null) {
        try {
            return mService.getClient();
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            log(Log.getStackTraceString(new Throwable()));
    }
    return null;
}
Body of Second Method:
{
    if (VDBG)
        log("getClient()");
    final IBluetoothPbap service = mService;
    if (service != null) {
        try {
            return service.getClient();
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            log(Log.getStackTraceString(new Throwable()));
    }
    return null;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothMap.getConnectionState:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get connection state of device
 *
 * @return device connection state
 */

Body of Frist Method:
{
    if (DBG)
        log("getConnectionState(" + device + ")");
    if (mService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mService.getConnectionState(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.STATE_DISCONNECTED;
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return BluetoothProfile.STATE_DISCONNECTED;
}
Body of Second Method:
{
    if (DBG)
        log("getConnectionState(" + device + ")");
    final IBluetoothMap service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getConnectionState(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.STATE_DISCONNECTED;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return BluetoothProfile.STATE_DISCONNECTED;
}
------------------------
Find a silently evolved API code:android.telephony.DisconnectCause.toString:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Returns descriptive string for the specified disconnect cause.
 */

Body of Frist Method:
{
    switch(cause) {
        case NOT_DISCONNECTED:
            return "NOT_DISCONNECTED";
        case INCOMING_MISSED:
            return "INCOMING_MISSED";
        case NORMAL:
            return "NORMAL";
        case LOCAL:
            return "LOCAL";
        case BUSY:
            return "BUSY";
        case CONGESTION:
            return "CONGESTION";
        case INVALID_NUMBER:
            return "INVALID_NUMBER";
        case NUMBER_UNREACHABLE:
            return "NUMBER_UNREACHABLE";
        case SERVER_UNREACHABLE:
            return "SERVER_UNREACHABLE";
        case INVALID_CREDENTIALS:
            return "INVALID_CREDENTIALS";
        case OUT_OF_NETWORK:
            return "OUT_OF_NETWORK";
        case SERVER_ERROR:
            return "SERVER_ERROR";
        case TIMED_OUT:
            return "TIMED_OUT";
        case LOST_SIGNAL:
            return "LOST_SIGNAL";
        case LIMIT_EXCEEDED:
            return "LIMIT_EXCEEDED";
        case INCOMING_REJECTED:
            return "INCOMING_REJECTED";
        case POWER_OFF:
            return "POWER_OFF";
        case OUT_OF_SERVICE:
            return "OUT_OF_SERVICE";
        case ICC_ERROR:
            return "ICC_ERROR";
        case CALL_BARRED:
            return "CALL_BARRED";
        case FDN_BLOCKED:
            return "FDN_BLOCKED";
        case CS_RESTRICTED:
            return "CS_RESTRICTED";
        case CS_RESTRICTED_NORMAL:
            return "CS_RESTRICTED_NORMAL";
        case CS_RESTRICTED_EMERGENCY:
            return "CS_RESTRICTED_EMERGENCY";
        case UNOBTAINABLE_NUMBER:
            return "UNOBTAINABLE_NUMBER";
        case CDMA_LOCKED_UNTIL_POWER_CYCLE:
            return "CDMA_LOCKED_UNTIL_POWER_CYCLE";
        case CDMA_DROP:
            return "CDMA_DROP";
        case CDMA_INTERCEPT:
            return "CDMA_INTERCEPT";
        case CDMA_REORDER:
            return "CDMA_REORDER";
        case CDMA_SO_REJECT:
            return "CDMA_SO_REJECT";
        case CDMA_RETRY_ORDER:
            return "CDMA_RETRY_ORDER";
        case CDMA_ACCESS_FAILURE:
            return "CDMA_ACCESS_FAILURE";
        case CDMA_PREEMPTED:
            return "CDMA_PREEMPTED";
        case CDMA_NOT_EMERGENCY:
            return "CDMA_NOT_EMERGENCY";
        case CDMA_ACCESS_BLOCKED:
            return "CDMA_ACCESS_BLOCKED";
        case EMERGENCY_ONLY:
            return "EMERGENCY_ONLY";
        case NO_PHONE_NUMBER_SUPPLIED:
            return "NO_PHONE_NUMBER_SUPPLIED";
        case DIALED_MMI:
            return "DIALED_MMI";
        case VOICEMAIL_NUMBER_MISSING:
            return "VOICEMAIL_NUMBER_MISSING";
        case CDMA_CALL_LOST:
            return "CDMA_CALL_LOST";
        case EXITED_ECM:
            return "EXITED_ECM";
        case DIAL_MODIFIED_TO_USSD:
            return "DIAL_MODIFIED_TO_USSD";
        case DIAL_MODIFIED_TO_SS:
            return "DIAL_MODIFIED_TO_SS";
        case DIAL_MODIFIED_TO_DIAL:
            return "DIAL_MODIFIED_TO_DIAL";
        case ERROR_UNSPECIFIED:
            return "ERROR_UNSPECIFIED";
        case OUTGOING_FAILURE:
            return "OUTGOING_FAILURE";
        case OUTGOING_CANCELED:
            return "OUTGOING_CANCELED";
        case IMS_MERGED_SUCCESSFULLY:
            return "IMS_MERGED_SUCCESSFULLY";
        case CDMA_ALREADY_ACTIVATED:
            return "CDMA_ALREADY_ACTIVATED";
        case VIDEO_CALL_NOT_ALLOWED_WHILE_TTY_ENABLED:
            return "VIDEO_CALL_NOT_ALLOWED_WHILE_TTY_ENABLED";
        case CALL_PULLED:
            return "CALL_PULLED";
        case ANSWERED_ELSEWHERE:
            return "ANSWERED_ELSEWHERE";
        case MAXIMUM_NUMBER_OF_CALLS_REACHED:
            return "MAXIMUM_NUMER_OF_CALLS_REACHED";
        case DATA_DISABLED:
            return "DATA_DISABLED";
        case DATA_LIMIT_REACHED:
            return "DATA_LIMIT_REACHED";
        case DIALED_ON_WRONG_SLOT:
            return "DIALED_ON_WRONG_SLOT";
        case DIALED_CALL_FORWARDING_WHILE_ROAMING:
            return "DIALED_CALL_FORWARDING_WHILE_ROAMING";
        case IMEI_NOT_ACCEPTED:
            return "IMEI_NOT_ACCEPTED";
        case WIFI_LOST:
            return "WIFI_LOST";
        default:
            return "INVALID: " + cause;
    }
}
Body of Second Method:
{
    switch(cause) {
        case NOT_DISCONNECTED:
            return "NOT_DISCONNECTED";
        case INCOMING_MISSED:
            return "INCOMING_MISSED";
        case NORMAL:
            return "NORMAL";
        case LOCAL:
            return "LOCAL";
        case BUSY:
            return "BUSY";
        case CONGESTION:
            return "CONGESTION";
        case INVALID_NUMBER:
            return "INVALID_NUMBER";
        case NUMBER_UNREACHABLE:
            return "NUMBER_UNREACHABLE";
        case SERVER_UNREACHABLE:
            return "SERVER_UNREACHABLE";
        case INVALID_CREDENTIALS:
            return "INVALID_CREDENTIALS";
        case OUT_OF_NETWORK:
            return "OUT_OF_NETWORK";
        case SERVER_ERROR:
            return "SERVER_ERROR";
        case TIMED_OUT:
            return "TIMED_OUT";
        case LOST_SIGNAL:
            return "LOST_SIGNAL";
        case LIMIT_EXCEEDED:
            return "LIMIT_EXCEEDED";
        case INCOMING_REJECTED:
            return "INCOMING_REJECTED";
        case POWER_OFF:
            return "POWER_OFF";
        case OUT_OF_SERVICE:
            return "OUT_OF_SERVICE";
        case ICC_ERROR:
            return "ICC_ERROR";
        case CALL_BARRED:
            return "CALL_BARRED";
        case FDN_BLOCKED:
            return "FDN_BLOCKED";
        case CS_RESTRICTED:
            return "CS_RESTRICTED";
        case CS_RESTRICTED_NORMAL:
            return "CS_RESTRICTED_NORMAL";
        case CS_RESTRICTED_EMERGENCY:
            return "CS_RESTRICTED_EMERGENCY";
        case UNOBTAINABLE_NUMBER:
            return "UNOBTAINABLE_NUMBER";
        case CDMA_LOCKED_UNTIL_POWER_CYCLE:
            return "CDMA_LOCKED_UNTIL_POWER_CYCLE";
        case CDMA_DROP:
            return "CDMA_DROP";
        case CDMA_INTERCEPT:
            return "CDMA_INTERCEPT";
        case CDMA_REORDER:
            return "CDMA_REORDER";
        case CDMA_SO_REJECT:
            return "CDMA_SO_REJECT";
        case CDMA_RETRY_ORDER:
            return "CDMA_RETRY_ORDER";
        case CDMA_ACCESS_FAILURE:
            return "CDMA_ACCESS_FAILURE";
        case CDMA_PREEMPTED:
            return "CDMA_PREEMPTED";
        case CDMA_NOT_EMERGENCY:
            return "CDMA_NOT_EMERGENCY";
        case CDMA_ACCESS_BLOCKED:
            return "CDMA_ACCESS_BLOCKED";
        case EMERGENCY_ONLY:
            return "EMERGENCY_ONLY";
        case NO_PHONE_NUMBER_SUPPLIED:
            return "NO_PHONE_NUMBER_SUPPLIED";
        case DIALED_MMI:
            return "DIALED_MMI";
        case VOICEMAIL_NUMBER_MISSING:
            return "VOICEMAIL_NUMBER_MISSING";
        case CDMA_CALL_LOST:
            return "CDMA_CALL_LOST";
        case EXITED_ECM:
            return "EXITED_ECM";
        case DIAL_MODIFIED_TO_USSD:
            return "DIAL_MODIFIED_TO_USSD";
        case DIAL_MODIFIED_TO_SS:
            return "DIAL_MODIFIED_TO_SS";
        case DIAL_MODIFIED_TO_DIAL:
            return "DIAL_MODIFIED_TO_DIAL";
        case ERROR_UNSPECIFIED:
            return "ERROR_UNSPECIFIED";
        case OUTGOING_FAILURE:
            return "OUTGOING_FAILURE";
        case OUTGOING_CANCELED:
            return "OUTGOING_CANCELED";
        case IMS_MERGED_SUCCESSFULLY:
            return "IMS_MERGED_SUCCESSFULLY";
        case CDMA_ALREADY_ACTIVATED:
            return "CDMA_ALREADY_ACTIVATED";
        case VIDEO_CALL_NOT_ALLOWED_WHILE_TTY_ENABLED:
            return "VIDEO_CALL_NOT_ALLOWED_WHILE_TTY_ENABLED";
        case CALL_PULLED:
            return "CALL_PULLED";
        case ANSWERED_ELSEWHERE:
            return "ANSWERED_ELSEWHERE";
        case MAXIMUM_NUMBER_OF_CALLS_REACHED:
            return "MAXIMUM_NUMER_OF_CALLS_REACHED";
        case DATA_DISABLED:
            return "DATA_DISABLED";
        case DATA_LIMIT_REACHED:
            return "DATA_LIMIT_REACHED";
        case DIALED_ON_WRONG_SLOT:
            return "DIALED_ON_WRONG_SLOT";
        case DIALED_CALL_FORWARDING_WHILE_ROAMING:
            return "DIALED_CALL_FORWARDING_WHILE_ROAMING";
        case IMEI_NOT_ACCEPTED:
            return "IMEI_NOT_ACCEPTED";
        case WIFI_LOST:
            return "WIFI_LOST";
        case IMS_ACCESS_BLOCKED:
            return "IMS_ACCESS_BLOCKED";
        case LOW_BATTERY:
            return "LOW_BATTERY";
        case DIAL_LOW_BATTERY:
            return "DIAL_LOW_BATTERY";
        default:
            return "INVALID: " + cause;
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothDevice.getBluetoothClass:COMMENT
Method Modifier: public      
Comment:/**
 * Get the Bluetooth class of the remote device.
 *
 * @return Bluetooth class object, or null on error
 */

Body of Frist Method:
{
    if (sService == null) {
        Log.e(TAG, "BT not enabled. Cannot get Bluetooth Class");
        return null;
    }
    try {
        int classInt = sService.getRemoteClass(this);
        if (classInt == BluetoothClass.ERROR)
            return null;
        return new BluetoothClass(classInt);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return null;
}
Body of Second Method:
{
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, "BT not enabled. Cannot get Bluetooth Class");
        return null;
    }
    try {
        int classInt = service.getRemoteClass(this);
        if (classInt == BluetoothClass.ERROR)
            return null;
        return new BluetoothClass(classInt);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return null;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothMap.getDevicesMatchingConnectionStates:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the list of devices matching specified states. Currently at most one.
 *
 * @return list of matching devices
 */

Body of Frist Method:
{
    if (DBG)
        log("getDevicesMatchingStates()");
    if (mService != null && isEnabled()) {
        try {
            return mService.getDevicesMatchingConnectionStates(states);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
Body of Second Method:
{
    if (DBG)
        log("getDevicesMatchingStates()");
    final IBluetoothMap service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.getDevicesMatchingConnectionStates(states);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
------------------------
Find a silently evolved API code:android.text.format.Formatter.formatShortFileSize:COMMENT
Method Modifier: public      static      
Comment:/**
 * Like {@link #formatFileSize}, but trying to generate shorter numbers
 * (showing fewer digits of precision).
 */

Body of Frist Method:
{
    if (context == null) {
        return "";
    }
    final BytesResult res = formatBytes(context.getResources(), sizeBytes, FLAG_SHORTER);
    return bidiWrap(context, context.getString(com.android.internal.R.string.fileSizeSuffix, res.value, res.units));
}
Body of Second Method:
{
    return formatFileSize(context, sizeBytes, FLAG_SHORTER);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.setAudioRouteAllowed:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets whether audio routing is allowed.
 *
 * @param device    remote device
 * @param allowed   if routing is allowed to the device
 * Note: This is an internal function and shouldn't be exposed
 */

Body of Frist Method:
{
    if (VDBG)
        log("setAudioRouteAllowed");
    if (mService != null && isEnabled()) {
        try {
            mService.setAudioRouteAllowed(device, allowed);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
}
Body of Second Method:
{
    if (VDBG)
        log("setAudioRouteAllowed");
    final IBluetoothHeadsetClient service = mService;
    if (service != null && isEnabled()) {
        try {
            service.setAudioRouteAllowed(device, allowed);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
}
------------------------
Find a silently evolved API code:android.widget.TimePickerClockDelegate.setHour:COMMENT
Method Modifier: public      
Comment:/**
 * Set the current hour.
 */

Body of Frist Method:
{
    setHourInternal(hour, FROM_EXTERNAL_API, true);
}
Body of Second Method:
{
    setHourInternal(hour, FROM_EXTERNAL_API, true, true);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothInputHost.connect:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Initiates connection to host which currently has Virtual Cable
 * established with device.
 *
 * @return
 */

Body of Frist Method:
{
    Log.v(TAG, "connect(): device=" + device);
    boolean result = false;
    if (mService != null) {
        try {
            result = mService.connect(device);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
    }
    return result;
}
Body of Second Method:
{
    Log.v(TAG, "connect(): device=" + device);
    boolean result = false;
    final IBluetoothInputHost service = mService;
    if (service != null) {
        try {
            result = service.connect(device);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
    }
    return result;
}
------------------------
Find a silently evolved API code:android.content.pm.ProviderInfo.dump:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    super.dumpFront(pw, prefix);
    pw.println(prefix + "authority=" + authority);
    pw.println(prefix + "flags=0x" + Integer.toHexString(flags));
    super.dumpBack(pw, prefix, flags);
}
Body of Second Method:
{
    super.dumpFront(pw, prefix);
    pw.println(prefix + "authority=" + authority);
    pw.println(prefix + "flags=0x" + Integer.toHexString(flags));
    super.dumpBack(pw, prefix, dumpFlags);
}
------------------------
Find a silently evolved API code:android.hardware.usb.UsbPort.modeToString:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    switch(mode) {
        case MODE_NONE:
            return "none";
        case MODE_DFP:
            return "dfp";
        case MODE_UFP:
            return "ufp";
        case MODE_DUAL:
            return "dual";
        default:
            return Integer.toString(mode);
    }
}
Body of Second Method:
{
    StringBuilder modeString = new StringBuilder();
    if (mode == MODE_NONE) {
        return "none";
    }
    if ((mode & MODE_DUAL) == MODE_DUAL) {
        modeString.append("dual, ");
    } else {
        if ((mode & MODE_DFP) == MODE_DFP) {
            modeString.append("dfp, ");
        } else if ((mode & MODE_UFP) == MODE_UFP) {
            modeString.append("ufp, ");
        }
    }
    if ((mode & MODE_AUDIO_ACCESSORY) == MODE_AUDIO_ACCESSORY) {
        modeString.append("audio_acc, ");
    }
    if ((mode & MODE_DEBUG_ACCESSORY) == MODE_DEBUG_ACCESSORY) {
        modeString.append("debug_acc, ");
    }
    if (modeString.length() == 0) {
        return Integer.toString(mode);
    }
    return modeString.substring(0, modeString.length() - 2);
}
------------------------
Find a silently evolved API code:android.hardware.camera2.params.StreamConfigurationMap.imageFormatToDataspace:COMMENT
Method Modifier: default     static      
Comment:/**
 * Convert a public format compatible with {@code ImageFormat} to an internal dataspace
 * from {@code graphics.h}.
 *
 * <p>In particular these formats are converted:
 * <ul>
 * <li>ImageFormat.JPEG => HAL_DATASPACE_V0_JFIF
 * <li>ImageFormat.DEPTH_POINT_CLOUD => HAL_DATASPACE_DEPTH
 * <li>ImageFormat.DEPTH16 => HAL_DATASPACE_DEPTH
 * <li>others => HAL_DATASPACE_UNKNOWN
 * </ul>
 * </p>
 *
 * <p>Passing in an implementation-defined format here will fail (it's not a public format);
 * as will passing in an internal format which has a different public format equivalent.
 * See {@link #checkArgumentFormat} for more details about a legal public format.</p>
 *
 * <p>All other formats are returned as-is, no invalid check is performed.</p>
 *
 * <p>This function is the dual of {@link #imageFormatToPublic}.</p>
 *
 * @param format public image format from {@link ImageFormat} or {@link PixelFormat}
 * @return the converted image formats
 *
 * @see ImageFormat
 * @see PixelFormat
 *
 * @throws IllegalArgumentException
 * if {@code format} was {@code HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED}
 */

Body of Frist Method:
{
    switch(format) {
        case ImageFormat.JPEG:
            return HAL_DATASPACE_V0_JFIF;
        case ImageFormat.DEPTH_POINT_CLOUD:
        case ImageFormat.DEPTH16:
            return HAL_DATASPACE_DEPTH;
        default:
            return HAL_DATASPACE_UNKNOWN;
    }
}
Body of Second Method:
{
    switch(format) {
        case ImageFormat.JPEG:
            return HAL_DATASPACE_V0_JFIF;
        case ImageFormat.DEPTH_POINT_CLOUD:
        case ImageFormat.DEPTH16:
        case ImageFormat.RAW_DEPTH:
            return HAL_DATASPACE_DEPTH;
        default:
            return HAL_DATASPACE_UNKNOWN;
    }
}
------------------------
Find a silently evolved API code:android.database.sqlite.SQLiteConnectionPool.dump:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Dumps debugging information about this connection pool.
 *
 * @param printer The printer to receive the dump, not null.
 * @param verbose True to dump more verbose information.
 */

Body of Frist Method:
{
    Printer indentedPrinter = PrefixPrinter.create(printer, "    ");
    synchronized (mLock) {
        printer.println("Connection pool for " + mConfiguration.path + ":");
        printer.println("  Open: " + mIsOpen);
        printer.println("  Max connections: " + mMaxConnectionPoolSize);
        printer.println("  Available primary connection:");
        if (mAvailablePrimaryConnection != null) {
            mAvailablePrimaryConnection.dump(indentedPrinter, verbose);
        } else {
            indentedPrinter.println("<none>");
        }
        printer.println("  Available non-primary connections:");
        if (!mAvailableNonPrimaryConnections.isEmpty()) {
            final int count = mAvailableNonPrimaryConnections.size();
            for (int i = 0; i < count; i++) {
                mAvailableNonPrimaryConnections.get(i).dump(indentedPrinter, verbose);
            }
        } else {
            indentedPrinter.println("<none>");
        }
        printer.println("  Acquired connections:");
        if (!mAcquiredConnections.isEmpty()) {
            for (Map.Entry<SQLiteConnection, AcquiredConnectionStatus> entry : mAcquiredConnections.entrySet()) {
                final SQLiteConnection connection = entry.getKey();
                connection.dumpUnsafe(indentedPrinter, verbose);
                indentedPrinter.println("  Status: " + entry.getValue());
            }
        } else {
            indentedPrinter.println("<none>");
        }
        printer.println("  Connection waiters:");
        if (mConnectionWaiterQueue != null) {
            int i = 0;
            final long now = SystemClock.uptimeMillis();
            for (ConnectionWaiter waiter = mConnectionWaiterQueue; waiter != null; waiter = waiter.mNext, i++) {
                indentedPrinter.println(i + ": waited for " + ((now - waiter.mStartTime) * 0.001f) + " ms - thread=" + waiter.mThread + ", priority=" + waiter.mPriority + ", sql='" + waiter.mSql + "'");
            }
        } else {
            indentedPrinter.println("<none>");
        }
    }
}
Body of Second Method:
{
    Printer indentedPrinter = PrefixPrinter.create(printer, "    ");
    synchronized (mLock) {
        printer.println("Connection pool for " + mConfiguration.path + ":");
        printer.println("  Open: " + mIsOpen);
        printer.println("  Max connections: " + mMaxConnectionPoolSize);
        if (mConfiguration.isLookasideConfigSet()) {
            printer.println("  Lookaside config: sz=" + mConfiguration.lookasideSlotSize + " cnt=" + mConfiguration.lookasideSlotCount);
        }
        if (mConfiguration.idleConnectionTimeoutMs != Long.MAX_VALUE) {
            printer.println("  Idle connection timeout: " + mConfiguration.idleConnectionTimeoutMs);
        }
        printer.println("  Available primary connection:");
        if (mAvailablePrimaryConnection != null) {
            mAvailablePrimaryConnection.dump(indentedPrinter, verbose);
        } else {
            indentedPrinter.println("<none>");
        }
        printer.println("  Available non-primary connections:");
        if (!mAvailableNonPrimaryConnections.isEmpty()) {
            final int count = mAvailableNonPrimaryConnections.size();
            for (int i = 0; i < count; i++) {
                mAvailableNonPrimaryConnections.get(i).dump(indentedPrinter, verbose);
            }
        } else {
            indentedPrinter.println("<none>");
        }
        printer.println("  Acquired connections:");
        if (!mAcquiredConnections.isEmpty()) {
            for (Map.Entry<SQLiteConnection, AcquiredConnectionStatus> entry : mAcquiredConnections.entrySet()) {
                final SQLiteConnection connection = entry.getKey();
                connection.dumpUnsafe(indentedPrinter, verbose);
                indentedPrinter.println("  Status: " + entry.getValue());
            }
        } else {
            indentedPrinter.println("<none>");
        }
        printer.println("  Connection waiters:");
        if (mConnectionWaiterQueue != null) {
            int i = 0;
            final long now = SystemClock.uptimeMillis();
            for (ConnectionWaiter waiter = mConnectionWaiterQueue; waiter != null; waiter = waiter.mNext, i++) {
                indentedPrinter.println(i + ": waited for " + ((now - waiter.mStartTime) * 0.001f) + " ms - thread=" + waiter.mThread + ", priority=" + waiter.mPriority + ", sql='" + waiter.mSql + "'");
            }
        } else {
            indentedPrinter.println("<none>");
        }
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothPbapClient.getConnectedDevices:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the list of connected devices.
 * Currently at most one.
 *
 * @return list of connected devices
 */

Body of Frist Method:
{
    if (DBG) {
        log("getConnectedDevices()");
    }
    if (mService != null && isEnabled()) {
        try {
            return mService.getConnectedDevices();
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (mService == null) {
        Log.w(TAG, "Proxy not attached to service");
    }
    return new ArrayList<BluetoothDevice>();
}
Body of Second Method:
{
    if (DBG) {
        log("getConnectedDevices()");
    }
    final IBluetoothPbapClient service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.getConnectedDevices();
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null) {
        Log.w(TAG, "Proxy not attached to service");
    }
    return new ArrayList<BluetoothDevice>();
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothA2dpSink.setPriority:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Set priority of the profile
 *
 * <p> The device should already be paired.
 * Priority can be one of {@link #PRIORITY_ON} orgetBluetoothManager
 * {@link #PRIORITY_OFF},
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}
 * permission.
 *
 * @param device Paired bluetooth device
 * @param priority
 * @return true if priority is set, false on error
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("setPriority(" + device + ", " + priority + ")");
    if (mService != null && isEnabled() && isValidDevice(device)) {
        if (priority != BluetoothProfile.PRIORITY_OFF && priority != BluetoothProfile.PRIORITY_ON) {
            return false;
        }
        try {
            return mService.setPriority(device, priority);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("setPriority(" + device + ", " + priority + ")");
    final IBluetoothA2dpSink service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        if (priority != BluetoothProfile.PRIORITY_OFF && priority != BluetoothProfile.PRIORITY_ON) {
            return false;
        }
        try {
            return service.setPriority(device, priority);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothInputDevice.getPriority:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the priority of the profile.
 *
 * <p> The priority can be any of:
 * {@link #PRIORITY_AUTO_CONNECT}, {@link #PRIORITY_OFF},
 * {@link #PRIORITY_ON}, {@link #PRIORITY_UNDEFINED}
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param device Bluetooth device
 * @return priority of the device
 * @hide
 */

Body of Frist Method:
{
    if (VDBG)
        log("getPriority(" + device + ")");
    if (mService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mService.getPriority(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.PRIORITY_OFF;
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return BluetoothProfile.PRIORITY_OFF;
}
Body of Second Method:
{
    if (VDBG)
        log("getPriority(" + device + ")");
    final IBluetoothInputDevice service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getPriority(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.PRIORITY_OFF;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return BluetoothProfile.PRIORITY_OFF;
}
------------------------
Find a silently evolved API code:android.content.pm.ApplicationInfo.dump:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    super.dumpFront(pw, prefix);
    if ((flags & DUMP_FLAG_DETAILS) != 0 && className != null) {
        pw.println(prefix + "className=" + className);
    }
    if (permission != null) {
        pw.println(prefix + "permission=" + permission);
    }
    pw.println(prefix + "processName=" + processName);
    if ((flags & DUMP_FLAG_DETAILS) != 0) {
        pw.println(prefix + "taskAffinity=" + taskAffinity);
    }
    pw.println(prefix + "uid=" + uid + " flags=0x" + Integer.toHexString(flags) + " privateFlags=0x" + Integer.toHexString(privateFlags) + " theme=0x" + Integer.toHexString(theme));
    if ((flags & DUMP_FLAG_DETAILS) != 0) {
        pw.println(prefix + "requiresSmallestWidthDp=" + requiresSmallestWidthDp + " compatibleWidthLimitDp=" + compatibleWidthLimitDp + " largestWidthLimitDp=" + largestWidthLimitDp);
    }
    pw.println(prefix + "sourceDir=" + sourceDir);
    if (!Objects.equals(sourceDir, publicSourceDir)) {
        pw.println(prefix + "publicSourceDir=" + publicSourceDir);
    }
    if (!ArrayUtils.isEmpty(splitSourceDirs)) {
        pw.println(prefix + "splitSourceDirs=" + Arrays.toString(splitSourceDirs));
    }
    if (!ArrayUtils.isEmpty(splitPublicSourceDirs) && !Arrays.equals(splitSourceDirs, splitPublicSourceDirs)) {
        pw.println(prefix + "splitPublicSourceDirs=" + Arrays.toString(splitPublicSourceDirs));
    }
    if (resourceDirs != null) {
        pw.println(prefix + "resourceDirs=" + Arrays.toString(resourceDirs));
    }
    if ((flags & DUMP_FLAG_DETAILS) != 0 && seInfo != null) {
        pw.println(prefix + "seinfo=" + seInfo);
        pw.println(prefix + "seinfoUser=" + seInfoUser);
    }
    pw.println(prefix + "dataDir=" + dataDir);
    if ((flags & DUMP_FLAG_DETAILS) != 0) {
        pw.println(prefix + "deviceProtectedDataDir=" + deviceProtectedDataDir);
        pw.println(prefix + "credentialProtectedDataDir=" + credentialProtectedDataDir);
        if (sharedLibraryFiles != null) {
            pw.println(prefix + "sharedLibraryFiles=" + Arrays.toString(sharedLibraryFiles));
        }
    }
    pw.println(prefix + "enabled=" + enabled + " minSdkVersion=" + minSdkVersion + " targetSdkVersion=" + targetSdkVersion + " versionCode=" + versionCode + " targetSandboxVersion=" + targetSandboxVersion);
    if ((flags & DUMP_FLAG_DETAILS) != 0) {
        if (manageSpaceActivityName != null) {
            pw.println(prefix + "manageSpaceActivityName=" + manageSpaceActivityName);
        }
        if (descriptionRes != 0) {
            pw.println(prefix + "description=0x" + Integer.toHexString(descriptionRes));
        }
        if (uiOptions != 0) {
            pw.println(prefix + "uiOptions=0x" + Integer.toHexString(uiOptions));
        }
        pw.println(prefix + "supportsRtl=" + (hasRtlSupport() ? "true" : "false"));
        if (fullBackupContent > 0) {
            pw.println(prefix + "fullBackupContent=@xml/" + fullBackupContent);
        } else {
            pw.println(prefix + "fullBackupContent=" + (fullBackupContent < 0 ? "false" : "true"));
        }
        if (networkSecurityConfigRes != 0) {
            pw.println(prefix + "networkSecurityConfigRes=0x" + Integer.toHexString(networkSecurityConfigRes));
        }
        if (category != CATEGORY_UNDEFINED) {
            pw.println(prefix + "category=" + category);
        }
    }
    super.dumpBack(pw, prefix);
}
Body of Second Method:
{
    super.dumpFront(pw, prefix);
    if ((dumpFlags & DUMP_FLAG_DETAILS) != 0 && className != null) {
        pw.println(prefix + "className=" + className);
    }
    if (permission != null) {
        pw.println(prefix + "permission=" + permission);
    }
    pw.println(prefix + "processName=" + processName);
    if ((dumpFlags & DUMP_FLAG_DETAILS) != 0) {
        pw.println(prefix + "taskAffinity=" + taskAffinity);
    }
    pw.println(prefix + "uid=" + uid + " flags=0x" + Integer.toHexString(flags) + " privateFlags=0x" + Integer.toHexString(privateFlags) + " theme=0x" + Integer.toHexString(theme));
    if ((dumpFlags & DUMP_FLAG_DETAILS) != 0) {
        pw.println(prefix + "requiresSmallestWidthDp=" + requiresSmallestWidthDp + " compatibleWidthLimitDp=" + compatibleWidthLimitDp + " largestWidthLimitDp=" + largestWidthLimitDp);
    }
    pw.println(prefix + "sourceDir=" + sourceDir);
    if (!Objects.equals(sourceDir, publicSourceDir)) {
        pw.println(prefix + "publicSourceDir=" + publicSourceDir);
    }
    if (!ArrayUtils.isEmpty(splitSourceDirs)) {
        pw.println(prefix + "splitSourceDirs=" + Arrays.toString(splitSourceDirs));
    }
    if (!ArrayUtils.isEmpty(splitPublicSourceDirs) && !Arrays.equals(splitSourceDirs, splitPublicSourceDirs)) {
        pw.println(prefix + "splitPublicSourceDirs=" + Arrays.toString(splitPublicSourceDirs));
    }
    if (resourceDirs != null) {
        pw.println(prefix + "resourceDirs=" + Arrays.toString(resourceDirs));
    }
    if ((dumpFlags & DUMP_FLAG_DETAILS) != 0 && seInfo != null) {
        pw.println(prefix + "seinfo=" + seInfo);
        pw.println(prefix + "seinfoUser=" + seInfoUser);
    }
    pw.println(prefix + "dataDir=" + dataDir);
    if ((dumpFlags & DUMP_FLAG_DETAILS) != 0) {
        pw.println(prefix + "deviceProtectedDataDir=" + deviceProtectedDataDir);
        pw.println(prefix + "credentialProtectedDataDir=" + credentialProtectedDataDir);
        if (sharedLibraryFiles != null) {
            pw.println(prefix + "sharedLibraryFiles=" + Arrays.toString(sharedLibraryFiles));
        }
    }
    if (classLoaderName != null) {
        pw.println(prefix + "classLoaderName=" + classLoaderName);
    }
    if (!ArrayUtils.isEmpty(splitClassLoaderNames)) {
        pw.println(prefix + "splitClassLoaderNames=" + Arrays.toString(splitClassLoaderNames));
    }
    pw.println(prefix + "enabled=" + enabled + " minSdkVersion=" + minSdkVersion + " targetSdkVersion=" + targetSdkVersion + " versionCode=" + versionCode + " targetSandboxVersion=" + targetSandboxVersion);
    if ((dumpFlags & DUMP_FLAG_DETAILS) != 0) {
        if (manageSpaceActivityName != null) {
            pw.println(prefix + "manageSpaceActivityName=" + manageSpaceActivityName);
        }
        if (descriptionRes != 0) {
            pw.println(prefix + "description=0x" + Integer.toHexString(descriptionRes));
        }
        if (uiOptions != 0) {
            pw.println(prefix + "uiOptions=0x" + Integer.toHexString(uiOptions));
        }
        pw.println(prefix + "supportsRtl=" + (hasRtlSupport() ? "true" : "false"));
        if (fullBackupContent > 0) {
            pw.println(prefix + "fullBackupContent=@xml/" + fullBackupContent);
        } else {
            pw.println(prefix + "fullBackupContent=" + (fullBackupContent < 0 ? "false" : "true"));
        }
        if (networkSecurityConfigRes != 0) {
            pw.println(prefix + "networkSecurityConfigRes=0x" + Integer.toHexString(networkSecurityConfigRes));
        }
        if (category != CATEGORY_UNDEFINED) {
            pw.println(prefix + "category=" + category);
        }
    }
    super.dumpBack(pw, prefix);
}
------------------------
Find a silently evolved API code:android.hardware.camera2.params.StreamConfigurationMap.depthFormatToPublic:COMMENT
Method Modifier: default     static      
Comment:/**
 * Convert an internal format compatible with {@code graphics.h} into public-visible
 * {@code ImageFormat}. This assumes the dataspace of the format is HAL_DATASPACE_DEPTH.
 *
 * <p>In particular these formats are converted:
 * <ul>
 * <li>HAL_PIXEL_FORMAT_BLOB => ImageFormat.DEPTH_POINT_CLOUD
 * <li>HAL_PIXEL_FORMAT_Y16 => ImageFormat.DEPTH16
 * </ul>
 * </p>
 *
 * <p>Passing in an implementation-defined format which has no public equivalent will fail;
 * as will passing in a public format which has a different internal format equivalent.
 * See {@link #checkArgumentFormat} for more details about a legal public format.</p>
 *
 * <p>All other formats are returned as-is, no further invalid check is performed.</p>
 *
 * <p>This function is the dual of {@link #imageFormatToInternal} for formats associated with
 * HAL_DATASPACE_DEPTH.</p>
 *
 * @param format image format from {@link ImageFormat} or {@link PixelFormat}
 * @return the converted image formats
 *
 * @throws IllegalArgumentException
 * if {@code format} is {@code HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED} or
 * {@link ImageFormat#JPEG}
 *
 * @see ImageFormat
 * @see PixelFormat
 * @see #checkArgumentFormat
 */

Body of Frist Method:
{
    switch(format) {
        case HAL_PIXEL_FORMAT_BLOB:
            return ImageFormat.DEPTH_POINT_CLOUD;
        case HAL_PIXEL_FORMAT_Y16:
            return ImageFormat.DEPTH16;
        case ImageFormat.JPEG:
            throw new IllegalArgumentException("ImageFormat.JPEG is an unknown internal format");
        case HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED:
            throw new IllegalArgumentException("IMPLEMENTATION_DEFINED must not leak to public API");
        default:
            throw new IllegalArgumentException("Unknown DATASPACE_DEPTH format " + format);
    }
}
Body of Second Method:
{
    switch(format) {
        case HAL_PIXEL_FORMAT_BLOB:
            return ImageFormat.DEPTH_POINT_CLOUD;
        case HAL_PIXEL_FORMAT_Y16:
            return ImageFormat.DEPTH16;
        case HAL_PIXEL_FORMAT_RAW16:
            return ImageFormat.RAW_DEPTH;
        case ImageFormat.JPEG:
            throw new IllegalArgumentException("ImageFormat.JPEG is an unknown internal format");
        case HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED:
            throw new IllegalArgumentException("IMPLEMENTATION_DEFINED must not leak to public API");
        default:
            throw new IllegalArgumentException("Unknown DATASPACE_DEPTH format " + format);
    }
}
------------------------
Find a silently evolved API code:android.text.StaticLayout.generate:COMMENT
Method Modifier: default     
Comment:/* package */

Body of Frist Method:
{
    CharSequence source = b.mText;
    int bufStart = b.mStart;
    int bufEnd = b.mEnd;
    TextPaint paint = b.mPaint;
    int outerWidth = b.mWidth;
    TextDirectionHeuristic textDir = b.mTextDir;
    float spacingmult = b.mSpacingMult;
    float spacingadd = b.mSpacingAdd;
    float ellipsizedWidth = b.mEllipsizedWidth;
    TextUtils.TruncateAt ellipsize = b.mEllipsize;
    // TODO: move to builder to avoid allocation costs
    LineBreaks lineBreaks = new LineBreaks();
    // store span end locations
    int[] spanEndCache = new int[4];
    // store fontMetrics per span range
    // must be a multiple of 4 (and > 0) (store top, bottom, ascent, and descent per range)
    int[] fmCache = new int[4 * 4];
    // TODO: also respect LocaleSpan within the text
    b.setLocale(paint.getTextLocale());
    mLineCount = 0;
    int v = 0;
    boolean needMultiply = (spacingmult != 1 || spacingadd != 0);
    Paint.FontMetricsInt fm = b.mFontMetricsInt;
    int[] chooseHtv = null;
    MeasuredText measured = b.mMeasuredText;
    Spanned spanned = null;
    if (source instanceof Spanned)
        spanned = (Spanned) source;
    int paraEnd;
    for (int paraStart = bufStart; paraStart <= bufEnd; paraStart = paraEnd) {
        paraEnd = TextUtils.indexOf(source, CHAR_NEW_LINE, paraStart, bufEnd);
        if (paraEnd < 0)
            paraEnd = bufEnd;
        else
            paraEnd++;
        int firstWidthLineCount = 1;
        int firstWidth = outerWidth;
        int restWidth = outerWidth;
        LineHeightSpan[] chooseHt = null;
        if (spanned != null) {
            LeadingMarginSpan[] sp = getParagraphSpans(spanned, paraStart, paraEnd, LeadingMarginSpan.class);
            for (int i = 0; i < sp.length; i++) {
                LeadingMarginSpan lms = sp[i];
                firstWidth -= sp[i].getLeadingMargin(true);
                restWidth -= sp[i].getLeadingMargin(false);
                // leading margin spans, not just this particular one
                if (lms instanceof LeadingMarginSpan2) {
                    LeadingMarginSpan2 lms2 = (LeadingMarginSpan2) lms;
                    firstWidthLineCount = Math.max(firstWidthLineCount, lms2.getLeadingMarginLineCount());
                }
            }
            chooseHt = getParagraphSpans(spanned, paraStart, paraEnd, LineHeightSpan.class);
            if (chooseHt.length == 0) {
                // So that out() would not assume it has any contents
                chooseHt = null;
            } else {
                if (chooseHtv == null || chooseHtv.length < chooseHt.length) {
                    chooseHtv = ArrayUtils.newUnpaddedIntArray(chooseHt.length);
                }
                for (int i = 0; i < chooseHt.length; i++) {
                    int o = spanned.getSpanStart(chooseHt[i]);
                    if (o < paraStart) {
                        // starts in this layout, before the
                        // current paragraph
                        chooseHtv[i] = getLineTop(getLineForOffset(o));
                    } else {
                        // starts in this paragraph
                        chooseHtv[i] = v;
                    }
                }
            }
        }
        measured.setPara(source, paraStart, paraEnd, textDir, b);
        char[] chs = measured.mChars;
        float[] widths = measured.mWidths;
        byte[] chdirs = measured.mLevels;
        int dir = measured.mDir;
        boolean easy = measured.mEasy;
        // tab stop locations
        int[] variableTabStops = null;
        if (spanned != null) {
            TabStopSpan[] spans = getParagraphSpans(spanned, paraStart, paraEnd, TabStopSpan.class);
            if (spans.length > 0) {
                int[] stops = new int[spans.length];
                for (int i = 0; i < spans.length; i++) {
                    stops[i] = spans[i].getTabStop();
                }
                Arrays.sort(stops, 0, stops.length);
                variableTabStops = stops;
            }
        }
        nSetupParagraph(b.mNativePtr, chs, paraEnd - paraStart, firstWidth, firstWidthLineCount, restWidth, variableTabStops, TAB_INCREMENT, b.mBreakStrategy, b.mHyphenationFrequency, // TODO: Support more justification mode, e.g. letter spacing, stretching.
        b.mJustificationMode != Layout.JUSTIFICATION_MODE_NONE);
        if (mLeftIndents != null || mRightIndents != null) {
            // TODO(raph) performance: it would be better to do this once per layout rather
            // than once per paragraph, but that would require a change to the native
            // interface.
            int leftLen = mLeftIndents == null ? 0 : mLeftIndents.length;
            int rightLen = mRightIndents == null ? 0 : mRightIndents.length;
            int indentsLen = Math.max(1, Math.max(leftLen, rightLen) - mLineCount);
            int[] indents = new int[indentsLen];
            for (int i = 0; i < indentsLen; i++) {
                int leftMargin = mLeftIndents == null ? 0 : mLeftIndents[Math.min(i + mLineCount, leftLen - 1)];
                int rightMargin = mRightIndents == null ? 0 : mRightIndents[Math.min(i + mLineCount, rightLen - 1)];
                indents[i] = leftMargin + rightMargin;
            }
            nSetIndents(b.mNativePtr, indents);
        }
        // measurement has to be done before performing line breaking
        // but we don't want to recompute fontmetrics or span ranges the
        // second time, so we cache those and then use those stored values
        int fmCacheCount = 0;
        int spanEndCacheCount = 0;
        for (int spanStart = paraStart, spanEnd; spanStart < paraEnd; spanStart = spanEnd) {
            if (fmCacheCount * 4 >= fmCache.length) {
                int[] grow = new int[fmCacheCount * 4 * 2];
                System.arraycopy(fmCache, 0, grow, 0, fmCacheCount * 4);
                fmCache = grow;
            }
            if (spanEndCacheCount >= spanEndCache.length) {
                int[] grow = new int[spanEndCacheCount * 2];
                System.arraycopy(spanEndCache, 0, grow, 0, spanEndCacheCount);
                spanEndCache = grow;
            }
            if (spanned == null) {
                spanEnd = paraEnd;
                int spanLen = spanEnd - spanStart;
                measured.addStyleRun(paint, spanLen, fm);
            } else {
                spanEnd = spanned.nextSpanTransition(spanStart, paraEnd, MetricAffectingSpan.class);
                int spanLen = spanEnd - spanStart;
                MetricAffectingSpan[] spans = spanned.getSpans(spanStart, spanEnd, MetricAffectingSpan.class);
                spans = TextUtils.removeEmptySpans(spans, spanned, MetricAffectingSpan.class);
                measured.addStyleRun(paint, spans, spanLen, fm);
            }
            // the order of storage here (top, bottom, ascent, descent) has to match the code below
            // where these values are retrieved
            fmCache[fmCacheCount * 4 + 0] = fm.top;
            fmCache[fmCacheCount * 4 + 1] = fm.bottom;
            fmCache[fmCacheCount * 4 + 2] = fm.ascent;
            fmCache[fmCacheCount * 4 + 3] = fm.descent;
            fmCacheCount++;
            spanEndCache[spanEndCacheCount] = spanEnd;
            spanEndCacheCount++;
        }
        nGetWidths(b.mNativePtr, widths);
        int breakCount = nComputeLineBreaks(b.mNativePtr, lineBreaks, lineBreaks.breaks, lineBreaks.widths, lineBreaks.flags, lineBreaks.breaks.length);
        int[] breaks = lineBreaks.breaks;
        float[] lineWidths = lineBreaks.widths;
        int[] flags = lineBreaks.flags;
        final int remainingLineCount = mMaximumVisibleLineCount - mLineCount;
        final boolean ellipsisMayBeApplied = ellipsize != null && (ellipsize == TextUtils.TruncateAt.END || (mMaximumVisibleLineCount == 1 && ellipsize != TextUtils.TruncateAt.MARQUEE));
        if (remainingLineCount > 0 && remainingLineCount < breakCount && ellipsisMayBeApplied) {
            // Calculate width and flag.
            float width = 0;
            int flag = 0;
            for (int i = remainingLineCount - 1; i < breakCount; i++) {
                if (i == breakCount - 1) {
                    width += lineWidths[i];
                } else {
                    for (int j = (i == 0 ? 0 : breaks[i - 1]); j < breaks[i]; j++) {
                        width += widths[j];
                    }
                }
                flag |= flags[i] & TAB_MASK;
            }
            // Treat the last line and overflowed lines as a single line.
            breaks[remainingLineCount - 1] = breaks[breakCount - 1];
            lineWidths[remainingLineCount - 1] = width;
            flags[remainingLineCount - 1] = flag;
            breakCount = remainingLineCount;
        }
        // here is the offset of the starting character of the line we are currently measuring
        int here = paraStart;
        int fmTop = 0, fmBottom = 0, fmAscent = 0, fmDescent = 0;
        int fmCacheIndex = 0;
        int spanEndCacheIndex = 0;
        int breakIndex = 0;
        for (int spanStart = paraStart, spanEnd; spanStart < paraEnd; spanStart = spanEnd) {
            // retrieve end of span
            spanEnd = spanEndCache[spanEndCacheIndex++];
            // retrieve cached metrics, order matches above
            fm.top = fmCache[fmCacheIndex * 4 + 0];
            fm.bottom = fmCache[fmCacheIndex * 4 + 1];
            fm.ascent = fmCache[fmCacheIndex * 4 + 2];
            fm.descent = fmCache[fmCacheIndex * 4 + 3];
            fmCacheIndex++;
            if (fm.top < fmTop) {
                fmTop = fm.top;
            }
            if (fm.ascent < fmAscent) {
                fmAscent = fm.ascent;
            }
            if (fm.descent > fmDescent) {
                fmDescent = fm.descent;
            }
            if (fm.bottom > fmBottom) {
                fmBottom = fm.bottom;
            }
            // skip breaks ending before current span range
            while (breakIndex < breakCount && paraStart + breaks[breakIndex] < spanStart) {
                breakIndex++;
            }
            while (breakIndex < breakCount && paraStart + breaks[breakIndex] <= spanEnd) {
                int endPos = paraStart + breaks[breakIndex];
                boolean moreChars = (endPos < bufEnd);
                v = out(source, here, endPos, fmAscent, fmDescent, fmTop, fmBottom, v, spacingmult, spacingadd, chooseHt, chooseHtv, fm, flags[breakIndex], needMultiply, chdirs, dir, easy, bufEnd, includepad, trackpad, chs, widths, paraStart, ellipsize, ellipsizedWidth, lineWidths[breakIndex], paint, moreChars);
                if (endPos < spanEnd) {
                    // preserve metrics for current span
                    fmTop = fm.top;
                    fmBottom = fm.bottom;
                    fmAscent = fm.ascent;
                    fmDescent = fm.descent;
                } else {
                    fmTop = fmBottom = fmAscent = fmDescent = 0;
                }
                here = endPos;
                breakIndex++;
                if (mLineCount >= mMaximumVisibleLineCount && mEllipsized) {
                    return;
                }
            }
        }
        if (paraEnd == bufEnd)
            break;
    }
    if ((bufEnd == bufStart || source.charAt(bufEnd - 1) == CHAR_NEW_LINE) && mLineCount < mMaximumVisibleLineCount) {
        // Log.e("text", "output last " + bufEnd);
        measured.setPara(source, bufEnd, bufEnd, textDir, b);
        paint.getFontMetricsInt(fm);
        v = out(source, bufEnd, bufEnd, fm.ascent, fm.descent, fm.top, fm.bottom, v, spacingmult, spacingadd, null, null, fm, 0, needMultiply, measured.mLevels, measured.mDir, measured.mEasy, bufEnd, includepad, trackpad, null, null, bufStart, ellipsize, ellipsizedWidth, 0, paint, false);
    }
}
Body of Second Method:
{
    CharSequence source = b.mText;
    int bufStart = b.mStart;
    int bufEnd = b.mEnd;
    TextPaint paint = b.mPaint;
    int outerWidth = b.mWidth;
    TextDirectionHeuristic textDir = b.mTextDir;
    float spacingmult = b.mSpacingMult;
    float spacingadd = b.mSpacingAdd;
    float ellipsizedWidth = b.mEllipsizedWidth;
    TextUtils.TruncateAt ellipsize = b.mEllipsize;
    // TODO: move to builder to avoid allocation costs
    LineBreaks lineBreaks = new LineBreaks();
    // store span end locations
    int[] spanEndCache = new int[4];
    // store fontMetrics per span range
    // must be a multiple of 4 (and > 0) (store top, bottom, ascent, and descent per range)
    int[] fmCache = new int[4 * 4];
    b.setLocales(paint.getTextLocales());
    mLineCount = 0;
    mEllipsized = false;
    mMaxLineHeight = mMaximumVisibleLineCount < 1 ? 0 : DEFAULT_MAX_LINE_HEIGHT;
    int v = 0;
    boolean needMultiply = (spacingmult != 1 || spacingadd != 0);
    Paint.FontMetricsInt fm = b.mFontMetricsInt;
    int[] chooseHtv = null;
    MeasuredText measured = b.mMeasuredText;
    Spanned spanned = null;
    if (source instanceof Spanned)
        spanned = (Spanned) source;
    int paraEnd;
    for (int paraStart = bufStart; paraStart <= bufEnd; paraStart = paraEnd) {
        paraEnd = TextUtils.indexOf(source, CHAR_NEW_LINE, paraStart, bufEnd);
        if (paraEnd < 0)
            paraEnd = bufEnd;
        else
            paraEnd++;
        int firstWidthLineCount = 1;
        int firstWidth = outerWidth;
        int restWidth = outerWidth;
        LineHeightSpan[] chooseHt = null;
        if (spanned != null) {
            LeadingMarginSpan[] sp = getParagraphSpans(spanned, paraStart, paraEnd, LeadingMarginSpan.class);
            for (int i = 0; i < sp.length; i++) {
                LeadingMarginSpan lms = sp[i];
                firstWidth -= sp[i].getLeadingMargin(true);
                restWidth -= sp[i].getLeadingMargin(false);
                // leading margin spans, not just this particular one
                if (lms instanceof LeadingMarginSpan2) {
                    LeadingMarginSpan2 lms2 = (LeadingMarginSpan2) lms;
                    firstWidthLineCount = Math.max(firstWidthLineCount, lms2.getLeadingMarginLineCount());
                }
            }
            chooseHt = getParagraphSpans(spanned, paraStart, paraEnd, LineHeightSpan.class);
            if (chooseHt.length == 0) {
                // So that out() would not assume it has any contents
                chooseHt = null;
            } else {
                if (chooseHtv == null || chooseHtv.length < chooseHt.length) {
                    chooseHtv = ArrayUtils.newUnpaddedIntArray(chooseHt.length);
                }
                for (int i = 0; i < chooseHt.length; i++) {
                    int o = spanned.getSpanStart(chooseHt[i]);
                    if (o < paraStart) {
                        // starts in this layout, before the
                        // current paragraph
                        chooseHtv[i] = getLineTop(getLineForOffset(o));
                    } else {
                        // starts in this paragraph
                        chooseHtv[i] = v;
                    }
                }
            }
        }
        measured.setPara(source, paraStart, paraEnd, textDir, b);
        char[] chs = measured.mChars;
        float[] widths = measured.mWidths;
        byte[] chdirs = measured.mLevels;
        int dir = measured.mDir;
        boolean easy = measured.mEasy;
        // tab stop locations
        int[] variableTabStops = null;
        if (spanned != null) {
            TabStopSpan[] spans = getParagraphSpans(spanned, paraStart, paraEnd, TabStopSpan.class);
            if (spans.length > 0) {
                int[] stops = new int[spans.length];
                for (int i = 0; i < spans.length; i++) {
                    stops[i] = spans[i].getTabStop();
                }
                Arrays.sort(stops, 0, stops.length);
                variableTabStops = stops;
            }
        }
        nSetupParagraph(b.mNativePtr, chs, paraEnd - paraStart, firstWidth, firstWidthLineCount, restWidth, variableTabStops, TAB_INCREMENT, b.mBreakStrategy, b.mHyphenationFrequency, // TODO: Support more justification mode, e.g. letter spacing, stretching.
        b.mJustificationMode != Layout.JUSTIFICATION_MODE_NONE);
        if (mLeftIndents != null || mRightIndents != null) {
            // TODO(raph) performance: it would be better to do this once per layout rather
            // than once per paragraph, but that would require a change to the native
            // interface.
            int leftLen = mLeftIndents == null ? 0 : mLeftIndents.length;
            int rightLen = mRightIndents == null ? 0 : mRightIndents.length;
            int indentsLen = Math.max(1, Math.max(leftLen, rightLen) - mLineCount);
            int[] indents = new int[indentsLen];
            for (int i = 0; i < indentsLen; i++) {
                int leftMargin = mLeftIndents == null ? 0 : mLeftIndents[Math.min(i + mLineCount, leftLen - 1)];
                int rightMargin = mRightIndents == null ? 0 : mRightIndents[Math.min(i + mLineCount, rightLen - 1)];
                indents[i] = leftMargin + rightMargin;
            }
            nSetIndents(b.mNativePtr, indents);
        }
        // measurement has to be done before performing line breaking
        // but we don't want to recompute fontmetrics or span ranges the
        // second time, so we cache those and then use those stored values
        int fmCacheCount = 0;
        int spanEndCacheCount = 0;
        for (int spanStart = paraStart, spanEnd; spanStart < paraEnd; spanStart = spanEnd) {
            if (fmCacheCount * 4 >= fmCache.length) {
                int[] grow = new int[fmCacheCount * 4 * 2];
                System.arraycopy(fmCache, 0, grow, 0, fmCacheCount * 4);
                fmCache = grow;
            }
            if (spanEndCacheCount >= spanEndCache.length) {
                int[] grow = new int[spanEndCacheCount * 2];
                System.arraycopy(spanEndCache, 0, grow, 0, spanEndCacheCount);
                spanEndCache = grow;
            }
            if (spanned == null) {
                spanEnd = paraEnd;
                int spanLen = spanEnd - spanStart;
                measured.addStyleRun(paint, spanLen, fm);
            } else {
                spanEnd = spanned.nextSpanTransition(spanStart, paraEnd, MetricAffectingSpan.class);
                int spanLen = spanEnd - spanStart;
                MetricAffectingSpan[] spans = spanned.getSpans(spanStart, spanEnd, MetricAffectingSpan.class);
                spans = TextUtils.removeEmptySpans(spans, spanned, MetricAffectingSpan.class);
                measured.addStyleRun(paint, spans, spanLen, fm);
            }
            // the order of storage here (top, bottom, ascent, descent) has to match the code below
            // where these values are retrieved
            fmCache[fmCacheCount * 4 + 0] = fm.top;
            fmCache[fmCacheCount * 4 + 1] = fm.bottom;
            fmCache[fmCacheCount * 4 + 2] = fm.ascent;
            fmCache[fmCacheCount * 4 + 3] = fm.descent;
            fmCacheCount++;
            spanEndCache[spanEndCacheCount] = spanEnd;
            spanEndCacheCount++;
        }
        nGetWidths(b.mNativePtr, widths);
        int breakCount = nComputeLineBreaks(b.mNativePtr, lineBreaks, lineBreaks.breaks, lineBreaks.widths, lineBreaks.flags, lineBreaks.breaks.length);
        int[] breaks = lineBreaks.breaks;
        float[] lineWidths = lineBreaks.widths;
        int[] flags = lineBreaks.flags;
        final int remainingLineCount = mMaximumVisibleLineCount - mLineCount;
        final boolean ellipsisMayBeApplied = ellipsize != null && (ellipsize == TextUtils.TruncateAt.END || (mMaximumVisibleLineCount == 1 && ellipsize != TextUtils.TruncateAt.MARQUEE));
        if (remainingLineCount > 0 && remainingLineCount < breakCount && ellipsisMayBeApplied) {
            // Calculate width and flag.
            float width = 0;
            int flag = 0;
            for (int i = remainingLineCount - 1; i < breakCount; i++) {
                if (i == breakCount - 1) {
                    width += lineWidths[i];
                } else {
                    for (int j = (i == 0 ? 0 : breaks[i - 1]); j < breaks[i]; j++) {
                        width += widths[j];
                    }
                }
                flag |= flags[i] & TAB_MASK;
            }
            // Treat the last line and overflowed lines as a single line.
            breaks[remainingLineCount - 1] = breaks[breakCount - 1];
            lineWidths[remainingLineCount - 1] = width;
            flags[remainingLineCount - 1] = flag;
            breakCount = remainingLineCount;
        }
        // here is the offset of the starting character of the line we are currently measuring
        int here = paraStart;
        int fmTop = 0, fmBottom = 0, fmAscent = 0, fmDescent = 0;
        int fmCacheIndex = 0;
        int spanEndCacheIndex = 0;
        int breakIndex = 0;
        for (int spanStart = paraStart, spanEnd; spanStart < paraEnd; spanStart = spanEnd) {
            // retrieve end of span
            spanEnd = spanEndCache[spanEndCacheIndex++];
            // retrieve cached metrics, order matches above
            fm.top = fmCache[fmCacheIndex * 4 + 0];
            fm.bottom = fmCache[fmCacheIndex * 4 + 1];
            fm.ascent = fmCache[fmCacheIndex * 4 + 2];
            fm.descent = fmCache[fmCacheIndex * 4 + 3];
            fmCacheIndex++;
            if (fm.top < fmTop) {
                fmTop = fm.top;
            }
            if (fm.ascent < fmAscent) {
                fmAscent = fm.ascent;
            }
            if (fm.descent > fmDescent) {
                fmDescent = fm.descent;
            }
            if (fm.bottom > fmBottom) {
                fmBottom = fm.bottom;
            }
            // skip breaks ending before current span range
            while (breakIndex < breakCount && paraStart + breaks[breakIndex] < spanStart) {
                breakIndex++;
            }
            while (breakIndex < breakCount && paraStart + breaks[breakIndex] <= spanEnd) {
                int endPos = paraStart + breaks[breakIndex];
                boolean moreChars = (endPos < bufEnd);
                v = out(source, here, endPos, fmAscent, fmDescent, fmTop, fmBottom, v, spacingmult, spacingadd, chooseHt, chooseHtv, fm, flags[breakIndex], needMultiply, chdirs, dir, easy, bufEnd, includepad, trackpad, chs, widths, paraStart, ellipsize, ellipsizedWidth, lineWidths[breakIndex], paint, moreChars);
                if (endPos < spanEnd) {
                    // preserve metrics for current span
                    fmTop = fm.top;
                    fmBottom = fm.bottom;
                    fmAscent = fm.ascent;
                    fmDescent = fm.descent;
                } else {
                    fmTop = fmBottom = fmAscent = fmDescent = 0;
                }
                here = endPos;
                breakIndex++;
                if (mLineCount >= mMaximumVisibleLineCount && mEllipsized) {
                    return;
                }
            }
        }
        if (paraEnd == bufEnd)
            break;
    }
    if ((bufEnd == bufStart || source.charAt(bufEnd - 1) == CHAR_NEW_LINE) && mLineCount < mMaximumVisibleLineCount) {
        // Log.e("text", "output last " + bufEnd);
        measured.setPara(source, bufEnd, bufEnd, textDir, b);
        paint.getFontMetricsInt(fm);
        v = out(source, bufEnd, bufEnd, fm.ascent, fm.descent, fm.top, fm.bottom, v, spacingmult, spacingadd, null, null, fm, 0, needMultiply, measured.mLevels, measured.mDir, measured.mEasy, bufEnd, includepad, trackpad, null, null, bufStart, ellipsize, ellipsizedWidth, 0, paint, false);
    }
}
------------------------
Find a silently evolved API code:android.database.sqlite.SQLiteOpenHelper.setWriteAheadLoggingEnabled:COMMENT
Method Modifier: public      
Comment:/**
 * Enables or disables the use of write-ahead logging for the database.
 *
 * Write-ahead logging cannot be used with read-only databases so the value of
 * this flag is ignored if the database is opened read-only.
 *
 * @param enabled True if write-ahead logging should be enabled, false if it
 * should be disabled.
 *
 * @see SQLiteDatabase#enableWriteAheadLogging()
 */

Body of Frist Method:
{
    synchronized (this) {
        if (mEnableWriteAheadLogging != enabled) {
            if (mDatabase != null && mDatabase.isOpen() && !mDatabase.isReadOnly()) {
                if (enabled) {
                    mDatabase.enableWriteAheadLogging();
                } else {
                    mDatabase.disableWriteAheadLogging();
                }
            }
            mEnableWriteAheadLogging = enabled;
        }
    }
}
Body of Second Method:
{
    synchronized (this) {
        if (mOpenParamsBuilder.isWriteAheadLoggingEnabled() != enabled) {
            if (mDatabase != null && mDatabase.isOpen() && !mDatabase.isReadOnly()) {
                if (enabled) {
                    mDatabase.enableWriteAheadLogging();
                } else {
                    mDatabase.disableWriteAheadLogging();
                }
            }
            mOpenParamsBuilder.setWriteAheadLoggingEnabled(enabled);
        }
    }
}
------------------------
Find a silently evolved API code:android.os.StrictMode.conditionallyEnableDebugLogging:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Enable DropBox logging for debug phone builds.
 *
 * @hide
 */

Body of Frist Method:
{
    boolean doFlashes = SystemProperties.getBoolean(VISUAL_PROPERTY, false) && !amTheSystemServerProcess();
    final boolean suppress = SystemProperties.getBoolean(DISABLE_PROPERTY, false);
    // Similar logic also appears in ActivityThread.java for system apps.
    if (!doFlashes && (IS_USER_BUILD || suppress)) {
        setCloseGuardEnabled(false);
        return false;
    }
    // check above.
    if (IS_ENG_BUILD) {
        doFlashes = true;
    }
    // Thread policy controls BlockGuard.
    int threadPolicyMask = StrictMode.DETECT_DISK_WRITE | StrictMode.DETECT_DISK_READ | StrictMode.DETECT_NETWORK;
    if (!IS_USER_BUILD) {
        threadPolicyMask |= StrictMode.PENALTY_DROPBOX;
    }
    if (doFlashes) {
        threadPolicyMask |= StrictMode.PENALTY_FLASH;
    }
    StrictMode.setThreadPolicyMask(threadPolicyMask);
    // and instance counting.
    if (IS_USER_BUILD) {
        setCloseGuardEnabled(false);
    } else {
        VmPolicy.Builder policyBuilder = new VmPolicy.Builder().detectAll();
        if (!IS_ENG_BUILD) {
            // Activity leak detection causes too much slowdown for userdebug because of the
            // GCs.
            policyBuilder = policyBuilder.disable(DETECT_VM_ACTIVITY_LEAKS);
        }
        policyBuilder = policyBuilder.penaltyDropBox();
        if (IS_ENG_BUILD) {
            policyBuilder.penaltyLog();
        }
        // system health investigations
        if (android.os.Process.myUid() < android.os.Process.FIRST_APPLICATION_UID) {
            policyBuilder.detectUntaggedSockets();
        }
        setVmPolicy(policyBuilder.build());
        setCloseGuardEnabled(vmClosableObjectLeaksEnabled());
    }
    return true;
}
Body of Second Method:
{
    boolean doFlashes = SystemProperties.getBoolean(VISUAL_PROPERTY, false) && !amTheSystemServerProcess();
    final boolean suppress = SystemProperties.getBoolean(DISABLE_PROPERTY, false);
    // Similar logic also appears in ActivityThread.java for system apps.
    if (!doFlashes && (Build.IS_USER || suppress)) {
        setCloseGuardEnabled(false);
        return false;
    }
    // check above.
    if (Build.IS_ENG) {
        doFlashes = true;
    }
    // Thread policy controls BlockGuard.
    int threadPolicyMask = StrictMode.DETECT_DISK_WRITE | StrictMode.DETECT_DISK_READ | StrictMode.DETECT_NETWORK;
    if (!Build.IS_USER) {
        threadPolicyMask |= StrictMode.PENALTY_DROPBOX;
    }
    if (doFlashes) {
        threadPolicyMask |= StrictMode.PENALTY_FLASH;
    }
    StrictMode.setThreadPolicyMask(threadPolicyMask);
    // and instance counting.
    if (Build.IS_USER) {
        setCloseGuardEnabled(false);
    } else {
        VmPolicy.Builder policyBuilder = new VmPolicy.Builder().detectAll();
        if (!Build.IS_ENG) {
            // Activity leak detection causes too much slowdown for userdebug because of the
            // GCs.
            policyBuilder = policyBuilder.disable(DETECT_VM_ACTIVITY_LEAKS);
        }
        policyBuilder = policyBuilder.penaltyDropBox();
        if (Build.IS_ENG) {
            policyBuilder.penaltyLog();
        }
        // system health investigations
        if (android.os.Process.myUid() < android.os.Process.FIRST_APPLICATION_UID) {
            policyBuilder.enable(DETECT_VM_UNTAGGED_SOCKET);
        } else {
            policyBuilder.disable(DETECT_VM_UNTAGGED_SOCKET);
        }
        setVmPolicy(policyBuilder.build());
        setCloseGuardEnabled(vmClosableObjectLeaksEnabled());
    }
    return true;
}
------------------------
Find a silently evolved API code:android.net.NetworkPolicy.hasCycle:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Test if this policy has a cycle defined, after which usage should reset.
 */

Body of Frist Method:
{
    return cycleDay != CYCLE_NONE;
}
Body of Second Method:
{
    return cycleRule.cycleIterator().hasNext();
}
------------------------
Find a silently evolved API code:android.service.autofill.SaveInfo.toString:COMMENT
Method Modifier: public      
Comment:// ///////////////////////////////////

Body of Frist Method:
{
    if (!sDebug)
        return super.toString();
    return new StringBuilder("SaveInfo: [type=").append(DebugUtils.flagsToString(SaveInfo.class, "SAVE_DATA_TYPE_", mType)).append(", requiredIds=").append(Arrays.toString(mRequiredIds)).append(", optionalIds=").append(Arrays.toString(mOptionalIds)).append(", description=").append(mDescription).append(DebugUtils.flagsToString(SaveInfo.class, "NEGATIVE_BUTTON_STYLE_", mNegativeButtonStyle)).append(", mFlags=").append(mFlags).append("]").toString();
}
Body of Second Method:
{
    if (!sDebug)
        return super.toString();
    return new StringBuilder("SaveInfo: [type=").append(DebugUtils.flagsToString(SaveInfo.class, "SAVE_DATA_TYPE_", mType)).append(", requiredIds=").append(Arrays.toString(mRequiredIds)).append(", optionalIds=").append(Arrays.toString(mOptionalIds)).append(", description=").append(mDescription).append(DebugUtils.flagsToString(SaveInfo.class, "NEGATIVE_BUTTON_STYLE_", mNegativeButtonStyle)).append(", mFlags=").append(mFlags).append(", mCustomDescription=").append(mCustomDescription).append(", validation=").append(mValidator).append("]").toString();
}
------------------------
Find a silently evolved API code:android.widget.TabHost.setup:COMMENT
Method Modifier: public      
Comment:/**
 * <p>Call setup() before adding tabs if loading TabHost using findViewById().
 * <i><b>However</i></b>: You do not need to call setup() after getTabHost()
 * in {@link android.app.TabActivity TabActivity}.
 * Example:</p>
 * <pre>mTabHost = (TabHost)findViewById(R.id.tabhost);
 * mTabHost.setup();
 * mTabHost.addTab(TAB_TAG_1, "Hello, world!", "Tab 1");
 */

Body of Frist Method:
{
    mTabWidget = findViewById(com.android.internal.R.id.tabs);
    if (mTabWidget == null) {
        throw new RuntimeException("Your TabHost must have a TabWidget whose id attribute is 'android.R.id.tabs'");
    }
    // KeyListener to attach to all tabs. Detects non-navigation keys
    // and relays them to the tab content.
    mTabKeyListener = new OnKeyListener() {

        public boolean onKey(View v, int keyCode, KeyEvent event) {
            switch(keyCode) {
                case KeyEvent.KEYCODE_DPAD_CENTER:
                case KeyEvent.KEYCODE_DPAD_LEFT:
                case KeyEvent.KEYCODE_DPAD_RIGHT:
                case KeyEvent.KEYCODE_DPAD_UP:
                case KeyEvent.KEYCODE_DPAD_DOWN:
                case KeyEvent.KEYCODE_ENTER:
                    return false;
            }
            mTabContent.requestFocus(View.FOCUS_FORWARD);
            return mTabContent.dispatchKeyEvent(event);
        }
    };
    mTabWidget.setTabSelectionListener(new TabWidget.OnTabSelectionChanged() {

        public void onTabSelectionChanged(int tabIndex, boolean clicked) {
            setCurrentTab(tabIndex);
            if (clicked) {
                mTabContent.requestFocus(View.FOCUS_FORWARD);
            }
        }
    });
    mTabContent = findViewById(com.android.internal.R.id.tabcontent);
    if (mTabContent == null) {
        throw new RuntimeException("Your TabHost must have a FrameLayout whose id attribute is " + "'android.R.id.tabcontent'");
    }
}
Body of Second Method:
{
    mTabWidget = findViewById(com.android.internal.R.id.tabs);
    if (mTabWidget == null) {
        throw new RuntimeException("Your TabHost must have a TabWidget whose id attribute is 'android.R.id.tabs'");
    }
    // KeyListener to attach to all tabs. Detects non-navigation keys
    // and relays them to the tab content.
    mTabKeyListener = new OnKeyListener() {

        public boolean onKey(View v, int keyCode, KeyEvent event) {
            if (KeyEvent.isModifierKey(keyCode)) {
                return false;
            }
            switch(keyCode) {
                case KeyEvent.KEYCODE_DPAD_CENTER:
                case KeyEvent.KEYCODE_DPAD_LEFT:
                case KeyEvent.KEYCODE_DPAD_RIGHT:
                case KeyEvent.KEYCODE_DPAD_UP:
                case KeyEvent.KEYCODE_DPAD_DOWN:
                case KeyEvent.KEYCODE_TAB:
                case KeyEvent.KEYCODE_SPACE:
                case KeyEvent.KEYCODE_ENTER:
                    return false;
            }
            mTabContent.requestFocus(View.FOCUS_FORWARD);
            return mTabContent.dispatchKeyEvent(event);
        }
    };
    mTabWidget.setTabSelectionListener(new TabWidget.OnTabSelectionChanged() {

        public void onTabSelectionChanged(int tabIndex, boolean clicked) {
            setCurrentTab(tabIndex);
            if (clicked) {
                mTabContent.requestFocus(View.FOCUS_FORWARD);
            }
        }
    });
    mTabContent = findViewById(com.android.internal.R.id.tabcontent);
    if (mTabContent == null) {
        throw new RuntimeException("Your TabHost must have a FrameLayout whose id attribute is " + "'android.R.id.tabcontent'");
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothDevice.isConnected:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns whether there is an open connection to this device.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}.
 *
 * @return True if there is at least one open connection to this device.
 * @hide
 */

Body of Frist Method:
{
    if (sService == null) {
        // BT is not enabled, we cannot be connected.
        return false;
    }
    try {
        return sService.getConnectionState(this) != CONNECTION_STATE_DISCONNECTED;
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        return false;
    }
}
Body of Second Method:
{
    final IBluetooth service = sService;
    if (service == null) {
        // BT is not enabled, we cannot be connected.
        return false;
    }
    try {
        return service.getConnectionState(this) != CONNECTION_STATE_DISCONNECTED;
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        return false;
    }
}
------------------------
Find a silently evolved API code:android.media.MediaCas.enumeratePlugins:COMMENT
Method Modifier: public      static      
Comment:/**
 * List all available CA plugins on the device.
 *
 * @return an array of descriptors for the available CA plugins.
 */

Body of Frist Method:
{
    IMediaCasService service = getService();
    if (service != null) {
        try {
            ParcelableCasPluginDescriptor[] descriptors = service.enumeratePlugins();
            if (descriptors.length == 0) {
                return null;
            }
            PluginDescriptor[] results = new PluginDescriptor[descriptors.length];
            for (int i = 0; i < results.length; i++) {
                results[i] = descriptors[i];
            }
            return results;
        } catch (RemoteException e) {
        }
    }
    return null;
}
Body of Second Method:
{
    IMediaCasService service = getService();
    if (service != null) {
        try {
            ArrayList<HidlCasPluginDescriptor> descriptors = service.enumeratePlugins();
            if (descriptors.size() == 0) {
                return null;
            }
            PluginDescriptor[] results = new PluginDescriptor[descriptors.size()];
            for (int i = 0; i < results.length; i++) {
                results[i] = new PluginDescriptor(descriptors.get(i));
            }
            return results;
        } catch (RemoteException e) {
        }
    }
    return null;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothPan.connect:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Initiate connection to a profile of the remote bluetooth device.
 *
 * <p> This API returns false in scenarios like the profile on the
 * device is already connected or Bluetooth is not turned on.
 * When this API returns true, it is guaranteed that
 * connection state intent for the profile will be broadcasted with
 * the state. Users can get the connection state of the profile
 * from this intent.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}
 * permission.
 *
 * @param device Remote Bluetooth Device
 * @return false on immediate error,
 * true otherwise
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("connect(" + device + ")");
    if (mPanService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mPanService.connect(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (mPanService == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("connect(" + device + ")");
    final IBluetoothPan service = mPanService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.connect(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.getConnectedDevices:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Return the list of connected remote devices
 *
 * @return list of connected devices; empty list if nothing is connected.
 */

Body of Frist Method:
{
    if (VDBG)
        log("getConnectedDevices()");
    if (mService != null && isEnabled()) {
        try {
            return mService.getConnectedDevices();
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
Body of Second Method:
{
    if (VDBG)
        log("getConnectedDevices()");
    final IBluetoothHeadsetClient service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.getConnectedDevices();
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothSap.disconnect:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Initiate disconnect.
 *
 * @param device Remote Bluetooth Device
 * @return false on error,
 * true otherwise
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("disconnect(" + device + ")");
    if (mService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mService.disconnect(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("disconnect(" + device + ")");
    final IBluetoothSap service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.disconnect(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.database.sqlite.SQLiteConnectionPool.closeConnectionAndLogExceptionsLocked:COMMENT
Method Modifier: private     hidden      
Comment:// Can't throw.

Body of Frist Method:
{
    try {
        // might throw
        connection.close();
    } catch (RuntimeException ex) {
        Log.e(TAG, "Failed to close connection, its fate is now in the hands " + "of the merciful GC: " + connection, ex);
    }
}
Body of Second Method:
{
    try {
        // might throw
        connection.close();
        if (mIdleConnectionHandler != null) {
            mIdleConnectionHandler.connectionClosed(connection);
        }
    } catch (RuntimeException ex) {
        Log.e(TAG, "Failed to close connection, its fate is now in the hands " + "of the merciful GC: " + connection, ex);
    }
}
------------------------
Find a silently evolved API code:android.media.MediaDescrambler.setMediaCasSession:COMMENT
Method Modifier: public      final       
Comment:/**
 * Associate a MediaCas session with this MediaDescrambler instance.
 * The MediaCas session is used to securely load decryption keys for
 * the descrambler. The crypto keys loaded through the MediaCas session
 * may be selected for use during the descrambling operation performed
 * by {@link android.media.MediaExtractor or @link
 * android.media.MediaCodec#queueSecureInputBuffer} by specifying even
 * or odd key in the {@link android.media.MediaCodec.CryptoInfo#key} field.
 *
 * @param session the MediaCas session to associate with this
 * MediaDescrambler instance.
 *
 * @throws IllegalStateException if the descrambler instance is not valid.
 * @throws MediaCasStateException for CAS-specific state exceptions.
 */

Body of Frist Method:
{
    validateInternalStates();
    try {
        mIDescrambler.setMediaCasSession(session.mSessionId);
    } catch (ServiceSpecificException e) {
        MediaCasStateException.throwExceptions(e);
    } catch (RemoteException e) {
        cleanupAndRethrowIllegalState();
    }
}
Body of Second Method:
{
    validateInternalStates();
    try {
        MediaCasStateException.throwExceptionIfNeeded(mIDescrambler.setMediaCasSession(session.mSessionId));
    } catch (RemoteException e) {
        cleanupAndRethrowIllegalState();
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothPbapClient.getConnectionState:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get connection state of device
 *
 * @return device connection state
 */

Body of Frist Method:
{
    if (DBG) {
        log("getConnectionState(" + device + ")");
    }
    if (mService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mService.getConnectionState(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.STATE_DISCONNECTED;
        }
    }
    if (mService == null) {
        Log.w(TAG, "Proxy not attached to service");
    }
    return BluetoothProfile.STATE_DISCONNECTED;
}
Body of Second Method:
{
    if (DBG) {
        log("getConnectionState(" + device + ")");
    }
    final IBluetoothPbapClient service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getConnectionState(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.STATE_DISCONNECTED;
        }
    }
    if (service == null) {
        Log.w(TAG, "Proxy not attached to service");
    }
    return BluetoothProfile.STATE_DISCONNECTED;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothSap.setPriority:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Set priority of the profile
 *
 * <p> The device should already be paired.
 *
 * @param device Paired bluetooth device
 * @param priority
 * @return true if priority is set, false on error
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("setPriority(" + device + ", " + priority + ")");
    if (mService != null && isEnabled() && isValidDevice(device)) {
        if (priority != BluetoothProfile.PRIORITY_OFF && priority != BluetoothProfile.PRIORITY_ON) {
            return false;
        }
        try {
            return mService.setPriority(device, priority);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("setPriority(" + device + ", " + priority + ")");
    final IBluetoothSap service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        if (priority != BluetoothProfile.PRIORITY_OFF && priority != BluetoothProfile.PRIORITY_ON) {
            return false;
        }
        try {
            return service.setPriority(device, priority);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothMap.disconnect:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Initiate disconnect.
 *
 * @param device Remote Bluetooth Device
 * @return false on error,
 * true otherwise
 */

Body of Frist Method:
{
    if (DBG)
        log("disconnect(" + device + ")");
    if (mService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mService.disconnect(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("disconnect(" + device + ")");
    final IBluetoothMap service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.disconnect(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadset.disconnect:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Initiate disconnection from a profile
 *
 * <p> This API will return false in scenarios like the profile on the
 * Bluetooth device is not in connected state etc. When this API returns,
 * true, it is guaranteed that the connection state change
 * intent will be broadcasted with the state. Users can get the
 * disconnection state of the profile from this intent.
 *
 * <p> If the disconnection is initiated by a remote device, the state
 * will transition from {@link #STATE_CONNECTED} to
 * {@link #STATE_DISCONNECTED}. If the disconnect is initiated by the
 * host (local) device the state will transition from
 * {@link #STATE_CONNECTED} to state {@link #STATE_DISCONNECTING} to
 * state {@link #STATE_DISCONNECTED}. The transition to
 * {@link #STATE_DISCONNECTING} can be used to distinguish between the
 * two scenarios.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}
 * permission.
 *
 * @param device Remote Bluetooth Device
 * @return false on immediate error,
 * true otherwise
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("disconnect(" + device + ")");
    if (mService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mService.disconnect(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("disconnect(" + device + ")");
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.disconnect(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothDevice.sdpSearch:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (sService == null) {
        Log.e(TAG, "BT not enabled. Cannot query remote device sdp records");
        return false;
    }
    try {
        return sService.sdpSearch(this, uuid);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
Body of Second Method:
{
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, "BT not enabled. Cannot query remote device sdp records");
        return false;
    }
    try {
        return service.sdpSearch(this, uuid);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
------------------------
Find a silently evolved API code:android.net.IpSecTransform.Builder.setIpv4Encapsulation:COMMENT
Method Modifier: public      
Comment:/**
 * Add UDP encapsulation to an IPv4 transform
 *
 * <p>This option allows IPsec traffic to pass through NAT. Refer to RFC 3947 and 3948 for
 * details on how UDP should be applied to IPsec.
 *
 * @param localSocket a {@link IpSecManager.UdpEncapsulationSocket} for sending and
 * receiving encapsulating traffic.
 * @param remotePort the UDP port number of the remote that will send and receive
 * encapsulated traffic. In the case of IKE, this is likely port 4500.
 */

Body of Frist Method:
{
    // TODO: check encap type is valid.
    mConfig.encapType = ENCAP_ESPINUDP;
    // TODO: plug in the encap socket
    mConfig.encapLocalPort = localSocket.getPort();
    mConfig.encapRemotePort = remotePort;
    return this;
}
Body of Second Method:
{
    // TODO: check encap type is valid.
    mConfig.encapType = ENCAP_ESPINUDP;
    mConfig.encapLocalPortResourceId = localSocket.getResourceId();
    mConfig.encapRemotePort = remotePort;
    return this;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.getConnectionState:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns state of the <code>device</code>
 *
 * @param device    a remote device
 * @return          the state of connection of the device
 */

Body of Frist Method:
{
    if (VDBG)
        log("getConnectionState(" + device + ")");
    if (mService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mService.getConnectionState(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.STATE_DISCONNECTED;
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return BluetoothProfile.STATE_DISCONNECTED;
}
Body of Second Method:
{
    if (VDBG)
        log("getConnectionState(" + device + ")");
    final IBluetoothHeadsetClient service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getConnectionState(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.STATE_DISCONNECTED;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return BluetoothProfile.STATE_DISCONNECTED;
}
------------------------
Find a silently evolved API code:android.view.ThreadedRenderer.isAvailable:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Indicates whether threaded rendering is available under any form for
 * the view hierarchy.
 *
 * @return True if the view hierarchy can potentially be defer rendered,
 * false otherwise
 */

Body of Frist Method:
{
    return sSupportsOpenGL;
}
Body of Second Method:
{
    if (sSupportsOpenGL != null) {
        return sSupportsOpenGL.booleanValue();
    }
    if (SystemProperties.getInt("ro.kernel.qemu", 0) == 0) {
        // Device is not an emulator.
        sSupportsOpenGL = true;
        return true;
    }
    int qemu_gles = SystemProperties.getInt("qemu.gles", -1);
    if (qemu_gles == -1) {
        // because the SurfaceFlinger service may not start at this point.
        return false;
    }
    // In the emulator this property will be set > 0 when OpenGL ES 2.0 is
    // enabled, 0 otherwise. On old emulator versions it will be undefined.
    sSupportsOpenGL = qemu_gles > 0;
    return sSupportsOpenGL.booleanValue();
}
------------------------
Find a silently evolved API code:android.media.MediaCas.sendEvent:COMMENT
Method Modifier: public      
Comment:/**
 * Send an event to a CA system. The format of the event is scheme-specific
 * and is opaque to the framework.
 *
 * @param event an integer denoting a scheme-specific event to be sent.
 * @param arg a scheme-specific integer argument for the event.
 * @param data a byte array containing scheme-specific data for the event.
 *
 * @throws IllegalStateException if the MediaCas instance is not valid.
 * @throws MediaCasException for CAS-specific errors.
 * @throws MediaCasStateException for CAS-specific state exceptions.
 */

Body of Frist Method:
{
    validateInternalStates();
    try {
        mICas.sendEvent(event, arg, data);
    } catch (ServiceSpecificException e) {
        MediaCasException.throwExceptions(e);
    } catch (RemoteException e) {
        cleanupAndRethrowIllegalState();
    }
}
Body of Second Method:
{
    validateInternalStates();
    try {
        MediaCasException.throwExceptionIfNeeded(mICas.sendEvent(event, arg, toByteArray(data)));
    } catch (RemoteException e) {
        cleanupAndRethrowIllegalState();
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.getCurrentAgFeatures:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get Audio Gateway features
 *
 * @param device    remote device
 * @return          bundle of AG features; null if no service or
 * AG not connected
 */

Body of Frist Method:
{
    if (mService != null && isEnabled()) {
        try {
            return mService.getCurrentAgFeatures(device);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return null;
}
Body of Second Method:
{
    final IBluetoothHeadsetClient service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.getCurrentAgFeatures(device);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return null;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothInputHost.reportError:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sends error handshake message as reply for invalid SET_REPORT request
 * from {@link BluetoothHidDeviceCallback#onSetReport(BluetoothDevice, byte, byte, byte[])}.
 *
 * @param error Error to be sent for SET_REPORT via HANDSHAKE.
 * @return
 */

Body of Frist Method:
{
    Log.v(TAG, "reportError(): device=" + device + " error=" + error);
    boolean result = false;
    if (mService != null) {
        try {
            result = mService.reportError(device, error);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
    }
    return result;
}
Body of Second Method:
{
    Log.v(TAG, "reportError(): device=" + device + " error=" + error);
    boolean result = false;
    final IBluetoothInputHost service = mService;
    if (service != null) {
        try {
            result = service.reportError(device, error);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
    }
    return result;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHealth.disconnectChannel:COMMENT
Method Modifier: public      
Comment:/**
 * Disconnect a connected health channel.
 * This is an asynchronous call. If this function returns true, the callback
 * associated with the application configuration will be called.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param device The remote Bluetooth device.
 * @param config The application configuration which has been registered using
 * {@link #registerSinkAppConfiguration(String, int, BluetoothHealthCallback) }
 * @param channelId The channel id associated with the channel
 * @return If true, the callback associated with the application config will be called.
 */

Body of Frist Method:
{
    if (mService != null && isEnabled() && isValidDevice(device) && config != null) {
        try {
            return mService.disconnectChannel(device, config, channelId);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return false;
}
Body of Second Method:
{
    final IBluetoothHealth service = mService;
    if (service != null && isEnabled() && isValidDevice(device) && config != null) {
        try {
            return service.disconnectChannel(device, config, channelId);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return false;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothInputDevice.getConnectionState:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (VDBG)
        log("getState(" + device + ")");
    if (mService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mService.getConnectionState(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.STATE_DISCONNECTED;
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return BluetoothProfile.STATE_DISCONNECTED;
}
Body of Second Method:
{
    if (VDBG)
        log("getState(" + device + ")");
    final IBluetoothInputDevice service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getConnectionState(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.STATE_DISCONNECTED;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return BluetoothProfile.STATE_DISCONNECTED;
}
------------------------
Find a silently evolved API code:android.net.NetworkCapabilities.hasTransport:COMMENT
Method Modifier: public      
Comment:/**
 * Tests for the presence of a transport on this instance.
 *
 * @param transportType the {@code NetworkCapabilities.TRANSPORT_*} to be tested for.
 * @return {@code true} if set on this instance.
 */

Body of Frist Method:
{
    if (transportType < MIN_TRANSPORT || transportType > MAX_TRANSPORT) {
        return false;
    }
    return ((mTransportTypes & (1 << transportType)) != 0);
}
Body of Second Method:
{
    return isValidTransport(transportType) && ((mTransportTypes & (1 << transportType)) != 0);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothSap.getConnectionState:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get connection state of device
 *
 * @return device connection state
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("getConnectionState(" + device + ")");
    if (mService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mService.getConnectionState(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.STATE_DISCONNECTED;
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return BluetoothProfile.STATE_DISCONNECTED;
}
Body of Second Method:
{
    if (DBG)
        log("getConnectionState(" + device + ")");
    final IBluetoothSap service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getConnectionState(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.STATE_DISCONNECTED;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return BluetoothProfile.STATE_DISCONNECTED;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothA2dpSink.getAudioConfig:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the current audio configuration for the A2DP source device,
 * or null if the device has no audio configuration
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param device Remote bluetooth device.
 * @return audio configuration for the device, or null
 *
 * {@see BluetoothAudioConfig}
 */

Body of Frist Method:
{
    if (VDBG)
        log("getAudioConfig(" + device + ")");
    if (mService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mService.getAudioConfig(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return null;
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return null;
}
Body of Second Method:
{
    if (VDBG)
        log("getAudioConfig(" + device + ")");
    final IBluetoothA2dpSink service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getAudioConfig(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return null;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return null;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothPbapClient.connect:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Initiate connection.
 * Upon successful connection to remote PBAP server the Client will
 * attempt to automatically download the users phonebook and call log.
 *
 * @param device    a remote device we want connect to
 * @return <code>true</code> if command has been issued successfully;
 * <code>false</code> otherwise;
 */

Body of Frist Method:
{
    if (DBG) {
        log("connect(" + device + ") for PBAP Client.");
    }
    if (mService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mService.connect(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (mService == null) {
        Log.w(TAG, "Proxy not attached to service");
    }
    return false;
}
Body of Second Method:
{
    if (DBG) {
        log("connect(" + device + ") for PBAP Client.");
    }
    final IBluetoothPbapClient service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.connect(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null) {
        Log.w(TAG, "Proxy not attached to service");
    }
    return false;
}
------------------------
Find a silently evolved API code:android.content.pm.PermissionInfo.protectionToString:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    String protLevel = "????";
    switch(level & PROTECTION_MASK_BASE) {
        case PermissionInfo.PROTECTION_DANGEROUS:
            protLevel = "dangerous";
            break;
        case PermissionInfo.PROTECTION_NORMAL:
            protLevel = "normal";
            break;
        case PermissionInfo.PROTECTION_SIGNATURE:
            protLevel = "signature";
            break;
        case PermissionInfo.PROTECTION_SIGNATURE_OR_SYSTEM:
            protLevel = "signatureOrSystem";
            break;
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_PRIVILEGED) != 0) {
        protLevel += "|privileged";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_DEVELOPMENT) != 0) {
        protLevel += "|development";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_APPOP) != 0) {
        protLevel += "|appop";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_PRE23) != 0) {
        protLevel += "|pre23";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_INSTALLER) != 0) {
        protLevel += "|installer";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_VERIFIER) != 0) {
        protLevel += "|verifier";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_PREINSTALLED) != 0) {
        protLevel += "|preinstalled";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_SETUP) != 0) {
        protLevel += "|setup";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_EPHEMERAL) != 0) {
        protLevel += "|ephemeral";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_RUNTIME_ONLY) != 0) {
        protLevel += "|runtime";
    }
    return protLevel;
}
Body of Second Method:
{
    String protLevel = "????";
    switch(level & PROTECTION_MASK_BASE) {
        case PermissionInfo.PROTECTION_DANGEROUS:
            protLevel = "dangerous";
            break;
        case PermissionInfo.PROTECTION_NORMAL:
            protLevel = "normal";
            break;
        case PermissionInfo.PROTECTION_SIGNATURE:
            protLevel = "signature";
            break;
        case PermissionInfo.PROTECTION_SIGNATURE_OR_SYSTEM:
            protLevel = "signatureOrSystem";
            break;
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_PRIVILEGED) != 0) {
        protLevel += "|privileged";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_DEVELOPMENT) != 0) {
        protLevel += "|development";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_APPOP) != 0) {
        protLevel += "|appop";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_PRE23) != 0) {
        protLevel += "|pre23";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_INSTALLER) != 0) {
        protLevel += "|installer";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_VERIFIER) != 0) {
        protLevel += "|verifier";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_PREINSTALLED) != 0) {
        protLevel += "|preinstalled";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_SETUP) != 0) {
        protLevel += "|setup";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_INSTANT) != 0) {
        protLevel += "|instant";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_RUNTIME_ONLY) != 0) {
        protLevel += "|runtime";
    }
    return protLevel;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.dial:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Places a call with specified number.
 *
 * @param device    remote device
 * @param number    valid phone number
 * @return          <code>{@link BluetoothHeadsetClientCall} call</code> if command has been
 * issued successfully;
 * <code>{@link null}</code> otherwise;
 * upon completion HFP sends {@link #ACTION_CALL_CHANGED}
 * intent in case of success; {@link #ACTION_RESULT} is sent
 * otherwise;
 */

Body of Frist Method:
{
    if (DBG)
        log("dial()");
    if (mService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mService.dial(device, number);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return null;
}
Body of Second Method:
{
    if (DBG)
        log("dial()");
    final IBluetoothHeadsetClient service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.dial(device, number);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return null;
}
------------------------
Find a silently evolved API code:android.webkit.UserPackage.hasCorrectTargetSdkVersion:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Returns whether the package represented by {@param packageInfo} targets a sdk version
 * supported by the current framework version.
 */

Body of Frist Method:
{
    return packageInfo.applicationInfo.targetSdkVersion >= Build.VERSION_CODES.O;
}
Body of Second Method:
{
    return packageInfo.applicationInfo.targetSdkVersion >= Build.VERSION_CODES.O_MR1;
}
------------------------
Find a silently evolved API code:android.content.pm.ServiceInfo.dump:COMMENT
Method Modifier: default     hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    super.dumpFront(pw, prefix);
    pw.println(prefix + "permission=" + permission);
    pw.println(prefix + "flags=0x" + Integer.toHexString(flags));
    super.dumpBack(pw, prefix, flags);
}
Body of Second Method:
{
    super.dumpFront(pw, prefix);
    pw.println(prefix + "permission=" + permission);
    pw.println(prefix + "flags=0x" + Integer.toHexString(flags));
    super.dumpBack(pw, prefix, dumpFlags);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothDevice.getSimAccessPermission:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Requires {@link android.Manifest.permission#BLUETOOTH}.
 * @return Whether the Sim access is allowed to this device. Can be
 * {@link #ACCESS_UNKNOWN}, {@link #ACCESS_ALLOWED} or {@link #ACCESS_REJECTED}.
 * @hide
 */

Body of Frist Method:
{
    if (sService == null) {
        return ACCESS_UNKNOWN;
    }
    try {
        return sService.getSimAccessPermission(this);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return ACCESS_UNKNOWN;
}
Body of Second Method:
{
    final IBluetooth service = sService;
    if (service == null) {
        return ACCESS_UNKNOWN;
    }
    try {
        return service.getSimAccessPermission(this);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return ACCESS_UNKNOWN;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadset.isAudioOn:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Check if Bluetooth SCO audio is connected.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @return true if SCO is connected,
 * false otherwise or on error
 * @hide
 */

Body of Frist Method:
{
    if (VDBG)
        log("isAudioOn()");
    if (mService != null && isEnabled()) {
        try {
            return mService.isAudioOn();
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (VDBG)
        log("isAudioOn()");
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.isAudioOn();
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.util.Log.printlns:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Helper function for long messages. Uses the LineBreakBufferedWriter to break
 * up long messages and stacktraces along newlines, but tries to write in large
 * chunks. This is to avoid truncation.
 * @hide
 */

Body of Frist Method:
{
    ImmediateLogWriter logWriter = new ImmediateLogWriter(bufID, priority, tag);
    // Acceptable buffer size. Get the native buffer size, subtract two zero terminators,
    // and the length of the tag.
    // Note: we implicitly accept possible truncation for Modified-UTF8 differences. It
    // is too expensive to compute that ahead of time.
    int bufferSize = // Base.
    NoPreloadHolder.LOGGER_ENTRY_MAX_PAYLOAD - // Two terminators.
    2 - // Tag length.
    (tag != null ? tag.length() : 0) - // Some slack.
    32;
    // At least assume you can print *some* characters (tag is not too large).
    bufferSize = Math.max(bufferSize, 100);
    LineBreakBufferedWriter lbbw = new LineBreakBufferedWriter(logWriter, bufferSize);
    lbbw.println(msg);
    if (tr != null) {
        // This is to reduce the amount of log spew that apps do in the non-error
        // condition of the network being unavailable.
        Throwable t = tr;
        while (t != null) {
            if (t instanceof UnknownHostException) {
                break;
            }
            if (t instanceof DeadSystemException) {
                lbbw.println("DeadSystemException: The system died; " + "earlier logs will point to the root cause");
                break;
            }
            t = t.getCause();
        }
        if (t == null) {
            tr.printStackTrace(lbbw);
        }
    }
    lbbw.flush();
    return logWriter.getWritten();
}
Body of Second Method:
{
    ImmediateLogWriter logWriter = new ImmediateLogWriter(bufID, priority, tag);
    // Acceptable buffer size. Get the native buffer size, subtract two zero terminators,
    // and the length of the tag.
    // Note: we implicitly accept possible truncation for Modified-UTF8 differences. It
    // is too expensive to compute that ahead of time.
    int bufferSize = // Base.
    PreloadHolder.LOGGER_ENTRY_MAX_PAYLOAD - // Two terminators.
    2 - // Tag length.
    (tag != null ? tag.length() : 0) - // Some slack.
    32;
    // At least assume you can print *some* characters (tag is not too large).
    bufferSize = Math.max(bufferSize, 100);
    LineBreakBufferedWriter lbbw = new LineBreakBufferedWriter(logWriter, bufferSize);
    lbbw.println(msg);
    if (tr != null) {
        // This is to reduce the amount of log spew that apps do in the non-error
        // condition of the network being unavailable.
        Throwable t = tr;
        while (t != null) {
            if (t instanceof UnknownHostException) {
                break;
            }
            if (t instanceof DeadSystemException) {
                lbbw.println("DeadSystemException: The system died; " + "earlier logs will point to the root cause");
                break;
            }
            t = t.getCause();
        }
        if (t == null) {
            tr.printStackTrace(lbbw);
        }
    }
    lbbw.flush();
    return logWriter.getWritten();
}
------------------------
Find a silently evolved API code:android.graphics.drawable.Icon.sameAs:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Compares if this icon is constructed from the same resources as another icon.
 * Note that this is an inexpensive operation and doesn't do deep Bitmap equality comparisons.
 *
 * @param otherIcon the other icon
 * @return whether this icon is the same as the another one
 * @hide
 */

Body of Frist Method:
{
    if (otherIcon == this) {
        return true;
    }
    if (mType != otherIcon.getType()) {
        return false;
    }
    switch(mType) {
        case TYPE_BITMAP:
        case TYPE_ADAPTIVE_BITMAP:
            return getBitmap() == otherIcon.getBitmap();
        case TYPE_DATA:
            return getDataLength() == otherIcon.getDataLength() && getDataOffset() == otherIcon.getDataOffset() && getDataBytes() == otherIcon.getDataBytes();
        case TYPE_RESOURCE:
            return getResId() == otherIcon.getResId() && Objects.equals(getResPackage(), otherIcon.getResPackage());
        case TYPE_URI:
            return Objects.equals(getUriString(), otherIcon.getUriString());
    }
    return false;
}
Body of Second Method:
{
    if (otherIcon == this) {
        return true;
    }
    if (mType != otherIcon.getType()) {
        return false;
    }
    switch(mType) {
        case TYPE_BITMAP:
        case TYPE_ADAPTIVE_BITMAP:
            return getBitmap() == otherIcon.getBitmap();
        case TYPE_DATA:
            return getDataLength() == otherIcon.getDataLength() && getDataOffset() == otherIcon.getDataOffset() && Arrays.equals(getDataBytes(), otherIcon.getDataBytes());
        case TYPE_RESOURCE:
            return getResId() == otherIcon.getResId() && Objects.equals(getResPackage(), otherIcon.getResPackage());
        case TYPE_URI:
            return Objects.equals(getUriString(), otherIcon.getUriString());
    }
    return false;
}
------------------------
Find a silently evolved API code:android.view.Surface.rotationToString:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Returns a human readable representation of a rotation.
 *
 * @param rotation The rotation.
 * @return The rotation symbolic name.
 *
 * @hide
 */

Body of Frist Method:
{
    switch(rotation) {
        case Surface.ROTATION_0:
            {
                return "ROTATION_0";
            }
        case Surface.ROTATION_90:
            {
                return "ROATATION_90";
            }
        case Surface.ROTATION_180:
            {
                return "ROATATION_180";
            }
        case Surface.ROTATION_270:
            {
                return "ROATATION_270";
            }
        default:
            {
                throw new IllegalArgumentException("Invalid rotation: " + rotation);
            }
    }
}
Body of Second Method:
{
    switch(rotation) {
        case Surface.ROTATION_0:
            {
                return "ROTATION_0";
            }
        case Surface.ROTATION_90:
            {
                return "ROTATION_90";
            }
        case Surface.ROTATION_180:
            {
                return "ROTATION_180";
            }
        case Surface.ROTATION_270:
            {
                return "ROTATION_270";
            }
        default:
            {
                throw new IllegalArgumentException("Invalid rotation: " + rotation);
            }
    }
}
------------------------
Find a silently evolved API code:android.media.MediaCas.Session.close:COMMENT
Method Modifier: public      
Comment:/**
 * Close the session.
 *
 * @throws IllegalStateException if the MediaCas instance is not valid.
 * @throws MediaCasStateException for CAS-specific state exceptions.
 */

Body of Frist Method:
{
    validateInternalStates();
    try {
        mICas.closeSession(mSessionId);
    } catch (ServiceSpecificException e) {
        MediaCasStateException.throwExceptions(e);
    } catch (RemoteException e) {
        cleanupAndRethrowIllegalState();
    }
}
Body of Second Method:
{
    validateInternalStates();
    try {
        MediaCasStateException.throwExceptionIfNeeded(mICas.closeSession(mSessionId));
    } catch (RemoteException e) {
        cleanupAndRethrowIllegalState();
    }
}
------------------------
Find a silently evolved API code:android.media.AudioPlaybackConfiguration.toLogFriendlyPlayerType:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    switch(type) {
        case PLAYER_TYPE_UNKNOWN:
            return "unknown";
        case PLAYER_TYPE_JAM_AUDIOTRACK:
            return "android.media.AudioTrack";
        case PLAYER_TYPE_JAM_MEDIAPLAYER:
            return "android.media.MediaPlayer";
        case PLAYER_TYPE_JAM_SOUNDPOOL:
            return "android.media.SoundPool";
        case PLAYER_TYPE_SLES_AUDIOPLAYER_BUFFERQUEUE:
            return "OpenSL ES AudioPlayer (Buffer Queue)";
        case PLAYER_TYPE_SLES_AUDIOPLAYER_URI_FD:
            return "OpenSL ES AudioPlayer (URI/FD)";
        case PLAYER_TYPE_AAUDIO:
            return "AAudio";
        case PLAYER_TYPE_HW_SOURCE:
            return "hardware source";
        case PLAYER_TYPE_EXTERNAL_PROXY:
            return "external proxy";
        default:
            return "unknown player type - FIXME";
    }
}
Body of Second Method:
{
    switch(type) {
        case PLAYER_TYPE_UNKNOWN:
            return "unknown";
        case PLAYER_TYPE_JAM_AUDIOTRACK:
            return "android.media.AudioTrack";
        case PLAYER_TYPE_JAM_MEDIAPLAYER:
            return "android.media.MediaPlayer";
        case PLAYER_TYPE_JAM_SOUNDPOOL:
            return "android.media.SoundPool";
        case PLAYER_TYPE_SLES_AUDIOPLAYER_BUFFERQUEUE:
            return "OpenSL ES AudioPlayer (Buffer Queue)";
        case PLAYER_TYPE_SLES_AUDIOPLAYER_URI_FD:
            return "OpenSL ES AudioPlayer (URI/FD)";
        case PLAYER_TYPE_AAUDIO:
            return "AAudio";
        case PLAYER_TYPE_HW_SOURCE:
            return "hardware source";
        case PLAYER_TYPE_EXTERNAL_PROXY:
            return "external proxy";
        default:
            return "unknown player type " + type + " - FIXME";
    }
}
------------------------
Find a silently evolved API code:android.app.usage.NetworkStatsManager.querySummary:COMMENT
Method Modifier: public      
Comment:/**
 * Query network usage statistics summaries. Result filtered to include only uids belonging to
 * calling user. Result is aggregated over time, hence all buckets will have the same start and
 * end timestamps. Not aggregated over state, uid, metered, or roaming. This means buckets'
 * start and end timestamps are going to be the same as the 'startTime' and 'endTime'
 * parameters. State, uid, metered, and roaming are going to vary, and tag is going to be the
 * same.
 *
 * @param networkType As defined in {@link ConnectivityManager}, e.g.
 * {@link ConnectivityManager#TYPE_MOBILE}, {@link ConnectivityManager#TYPE_WIFI}
 * etc.
 * @param subscriberId If applicable, the subscriber id of the network interface.
 * @param startTime Start of period. Defined in terms of "Unix time", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param endTime End of period. Defined in terms of "Unix time", see
 * {@link java.lang.System#currentTimeMillis}.
 * @return Statistics object or null if permissions are insufficient or error happened during
 * statistics collection.
 */

Body of Frist Method:
{
    NetworkTemplate template;
    try {
        template = createTemplate(networkType, subscriberId);
    } catch (IllegalArgumentException e) {
        if (DBG)
            Log.e(TAG, "Cannot create template", e);
        return null;
    }
    NetworkStats result;
    result = new NetworkStats(mContext, template, startTime, endTime);
    result.startSummaryEnumeration();
    return result;
}
Body of Second Method:
{
    NetworkTemplate template;
    try {
        template = createTemplate(networkType, subscriberId);
    } catch (IllegalArgumentException e) {
        if (DBG)
            Log.e(TAG, "Cannot create template", e);
        return null;
    }
    NetworkStats result;
    result = new NetworkStats(mContext, template, mFlags, startTime, endTime);
    result.startSummaryEnumeration();
    return result;
}
------------------------
Find a silently evolved API code:android.hardware.camera2.CameraManager.CameraManagerGlobal.connectCameraServiceLocked:COMMENT
Method Modifier: private     
Comment:/**
 * Connect to the camera service if it's available, and set up listeners.
 * If the service is already connected, do nothing.
 *
 * <p>Sets mCameraService to a valid pointer or null if the connection does not succeed.</p>
 */

Body of Frist Method:
{
    // Only reconnect if necessary
    if (mCameraService != null)
        return;
    Log.i(TAG, "Connecting to camera service");
    IBinder cameraServiceBinder = ServiceManager.getService(CAMERA_SERVICE_BINDER_NAME);
    if (cameraServiceBinder == null) {
        // Camera service is now down, leave mCameraService as null
        return;
    }
    try {
        cameraServiceBinder.linkToDeath(this, /*flags*/
        0);
    } catch (RemoteException e) {
        // Camera service is now down, leave mCameraService as null
        return;
    }
    ICameraService cameraService = ICameraService.Stub.asInterface(cameraServiceBinder);
    try {
        CameraMetadataNative.setupGlobalVendorTagDescriptor();
    } catch (ServiceSpecificException e) {
        handleRecoverableSetupErrors(e);
    }
    try {
        CameraStatus[] cameraStatuses = cameraService.addListener(this);
        for (CameraStatus c : cameraStatuses) {
            onStatusChangedLocked(c.status, c.cameraId);
        }
        mCameraService = cameraService;
    } catch (ServiceSpecificException e) {
        // Unexpected failure
        throw new IllegalStateException("Failed to register a camera service listener", e);
    } catch (RemoteException e) {
    // Camera service is now down, leave mCameraService as null
    }
}
Body of Second Method:
{
    // Only reconnect if necessary
    if (mCameraService != null || sCameraServiceDisabled)
        return;
    Log.i(TAG, "Connecting to camera service");
    IBinder cameraServiceBinder = ServiceManager.getService(CAMERA_SERVICE_BINDER_NAME);
    if (cameraServiceBinder == null) {
        // Camera service is now down, leave mCameraService as null
        return;
    }
    try {
        cameraServiceBinder.linkToDeath(this, /*flags*/
        0);
    } catch (RemoteException e) {
        // Camera service is now down, leave mCameraService as null
        return;
    }
    ICameraService cameraService = ICameraService.Stub.asInterface(cameraServiceBinder);
    try {
        CameraMetadataNative.setupGlobalVendorTagDescriptor();
    } catch (ServiceSpecificException e) {
        handleRecoverableSetupErrors(e);
    }
    try {
        CameraStatus[] cameraStatuses = cameraService.addListener(this);
        for (CameraStatus c : cameraStatuses) {
            onStatusChangedLocked(c.status, c.cameraId);
        }
        mCameraService = cameraService;
    } catch (ServiceSpecificException e) {
        // Unexpected failure
        throw new IllegalStateException("Failed to register a camera service listener", e);
    } catch (RemoteException e) {
    // Camera service is now down, leave mCameraService as null
    }
}
------------------------
Find a silently evolved API code:android.view.accessibility.AccessibilityRecord.init:COMMENT
Method Modifier: default     
Comment:/**
 * Initialize this record from another one.
 *
 * @param record The to initialize from.
 */

Body of Frist Method:
{
    mSealed = record.mSealed;
    mBooleanProperties = record.mBooleanProperties;
    mCurrentItemIndex = record.mCurrentItemIndex;
    mItemCount = record.mItemCount;
    mFromIndex = record.mFromIndex;
    mToIndex = record.mToIndex;
    mScrollX = record.mScrollX;
    mScrollY = record.mScrollY;
    mMaxScrollX = record.mMaxScrollX;
    mMaxScrollY = record.mMaxScrollY;
    mAddedCount = record.mAddedCount;
    mRemovedCount = record.mRemovedCount;
    mClassName = record.mClassName;
    mContentDescription = record.mContentDescription;
    mBeforeText = record.mBeforeText;
    mParcelableData = record.mParcelableData;
    mText.addAll(record.mText);
    mSourceWindowId = record.mSourceWindowId;
    if (record.mSourceNode != null) {
        mSourceNode = AccessibilityNodeInfo.obtain(record.mSourceNode);
    }
    mConnectionId = record.mConnectionId;
}
Body of Second Method:
{
    mSealed = record.mSealed;
    mBooleanProperties = record.mBooleanProperties;
    mCurrentItemIndex = record.mCurrentItemIndex;
    mItemCount = record.mItemCount;
    mFromIndex = record.mFromIndex;
    mToIndex = record.mToIndex;
    mScrollX = record.mScrollX;
    mScrollY = record.mScrollY;
    mMaxScrollX = record.mMaxScrollX;
    mMaxScrollY = record.mMaxScrollY;
    mAddedCount = record.mAddedCount;
    mRemovedCount = record.mRemovedCount;
    mClassName = record.mClassName;
    mContentDescription = record.mContentDescription;
    mBeforeText = record.mBeforeText;
    mParcelableData = record.mParcelableData;
    mText.addAll(record.mText);
    mSourceWindowId = record.mSourceWindowId;
    mSourceNodeId = record.mSourceNodeId;
    mConnectionId = record.mConnectionId;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadset.isAudioConnected:COMMENT
Method Modifier: public      
Comment:/**
 * Check if Bluetooth SCO audio is connected.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param device Bluetooth headset
 * @return true if SCO is connected,
 * false otherwise or on error
 */

Body of Frist Method:
{
    if (VDBG)
        log("isAudioConnected()");
    if (mService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mService.isAudioConnected(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (VDBG)
        log("isAudioConnected()");
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.isAudioConnected(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothInputHost.getDevicesMatchingConnectionStates:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    Log.v(TAG, "getDevicesMatchingConnectionStates(): states=" + Arrays.toString(states));
    if (mService != null) {
        try {
            return mService.getDevicesMatchingConnectionStates(states);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
    }
    return new ArrayList<BluetoothDevice>();
}
Body of Second Method:
{
    Log.v(TAG, "getDevicesMatchingConnectionStates(): states=" + Arrays.toString(states));
    final IBluetoothInputHost service = mService;
    if (service != null) {
        try {
            return service.getDevicesMatchingConnectionStates(states);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
    }
    return new ArrayList<BluetoothDevice>();
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothDevice.createBondOutOfBand:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Start the bonding (pairing) process with the remote device using the
 * Out Of Band mechanism.
 *
 * <p>This is an asynchronous call, it will return immediately. Register
 * for {@link #ACTION_BOND_STATE_CHANGED} intents to be notified when
 * the bonding process completes, and its result.
 *
 * <p>Android system services will handle the necessary user interactions
 * to confirm and complete the bonding process.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}.
 *
 * @param transport - Transport to use
 * @param oobData - Out Of Band data
 * @return false on immediate error, true if bonding will begin
 *
 * @hide
 */

Body of Frist Method:
{
    try {
        return sService.createBondOutOfBand(this, transport, oobData);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
Body of Second Method:
{
    final IBluetooth service = sService;
    if (service == null) {
        Log.w(TAG, "BT not enabled, createBondOutOfBand failed");
        return false;
    }
    try {
        return service.createBondOutOfBand(this, transport, oobData);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.getCurrentCalls:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns list of all calls in any state.
 *
 * @param device    remote device
 * @return          list of calls; empty list if none call exists
 */

Body of Frist Method:
{
    if (DBG)
        log("getCurrentCalls()");
    if (mService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mService.getCurrentCalls(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return null;
}
Body of Second Method:
{
    if (DBG)
        log("getCurrentCalls()");
    final IBluetoothHeadsetClient service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getCurrentCalls(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return null;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothInputHost.getConnectedDevices:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    Log.v(TAG, "getConnectedDevices()");
    if (mService != null) {
        try {
            return mService.getConnectedDevices();
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
    }
    return new ArrayList<BluetoothDevice>();
}
Body of Second Method:
{
    Log.v(TAG, "getConnectedDevices()");
    final IBluetoothInputHost service = mService;
    if (service != null) {
        try {
            return service.getConnectedDevices();
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
    }
    return new ArrayList<BluetoothDevice>();
}
------------------------
Find a silently evolved API code:android.view.accessibility.AccessibilityRecord.setConnectionId:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets the unique id of the IAccessibilityServiceConnection over which
 * this instance can send requests to the system.
 *
 * @param connectionId The connection id.
 *
 * @hide
 */

Body of Frist Method:
{
    enforceNotSealed();
    mConnectionId = connectionId;
    if (mSourceNode != null) {
        mSourceNode.setConnectionId(mConnectionId);
    }
}
Body of Second Method:
{
    enforceNotSealed();
    mConnectionId = connectionId;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.holdCall:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Holds a call.
 *
 * @param device    remote device
 * @return          <code>true</code> if command has been issued successfully;
 * <code>false</code> otherwise;
 * upon completion HFP sends {@link #ACTION_CALL_CHANGED}
 * intent.
 */

Body of Frist Method:
{
    if (DBG)
        log("holdCall()");
    if (mService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mService.holdCall(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("holdCall()");
    final IBluetoothHeadsetClient service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.holdCall(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.net.wifi.aware.WifiAwareNetworkSpecifier.equals:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof WifiAwareNetworkSpecifier)) {
        return false;
    }
    WifiAwareNetworkSpecifier lhs = (WifiAwareNetworkSpecifier) obj;
    return type == lhs.type && role == lhs.role && clientId == lhs.clientId && sessionId == lhs.sessionId && peerId == lhs.peerId && Arrays.equals(peerMac, lhs.peerMac) && Arrays.equals(pmk, lhs.pmk) && Objects.equals(passphrase, lhs.passphrase);
}
Body of Second Method:
{
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof WifiAwareNetworkSpecifier)) {
        return false;
    }
    WifiAwareNetworkSpecifier lhs = (WifiAwareNetworkSpecifier) obj;
    return type == lhs.type && role == lhs.role && clientId == lhs.clientId && sessionId == lhs.sessionId && peerId == lhs.peerId && Arrays.equals(peerMac, lhs.peerMac) && Arrays.equals(pmk, lhs.pmk) && Objects.equals(passphrase, lhs.passphrase) && requestorUid == lhs.requestorUid;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothA2dpSink.connect:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Initiate connection to a profile of the remote bluetooth device.
 *
 * <p> Currently, the system supports only 1 connection to the
 * A2DP profile. The API will automatically disconnect connected
 * devices before connecting.
 *
 * <p> This API returns false in scenarios like the profile on the
 * device is already connected or Bluetooth is not turned on.
 * When this API returns true, it is guaranteed that
 * connection state intent for the profile will be broadcasted with
 * the state. Users can get the connection state of the profile
 * from this intent.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}
 * permission.
 *
 * @param device Remote Bluetooth Device
 * @return false on immediate error,
 * true otherwise
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("connect(" + device + ")");
    if (mService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mService.connect(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("connect(" + device + ")");
    final IBluetoothA2dpSink service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.connect(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothAvrcpController.setPlayerApplicationSetting:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets the player app setting for current player.
 * returns true in case setting is supported by remote, false otherwise
 */

Body of Frist Method:
{
    if (DBG)
        Log.d(TAG, "setPlayerApplicationSetting");
    if (mService != null && isEnabled()) {
        try {
            return mService.setPlayerApplicationSetting(plAppSetting);
        } catch (RemoteException e) {
            Log.e(TAG, "Error talking to BT service in setPlayerApplicationSetting() " + e);
            return false;
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        Log.d(TAG, "setPlayerApplicationSetting");
    final IBluetoothAvrcpController service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.setPlayerApplicationSetting(plAppSetting);
        } catch (RemoteException e) {
            Log.e(TAG, "Error talking to BT service in setPlayerApplicationSetting() " + e);
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.getPriority:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the priority of the profile.
 */

Body of Frist Method:
{
    if (VDBG)
        log("getPriority(" + device + ")");
    if (mService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mService.getPriority(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return PRIORITY_OFF;
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return PRIORITY_OFF;
}
Body of Second Method:
{
    if (VDBG)
        log("getPriority(" + device + ")");
    final IBluetoothHeadsetClient service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getPriority(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return PRIORITY_OFF;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return PRIORITY_OFF;
}
------------------------
Find a silently evolved API code:android.media.PlayerBase.baseUpdateAudioAttributes:COMMENT
Method Modifier: default     hidden      
Comment:/**
 * To be called whenever the audio attributes of the player change
 * @param attr non-null audio attributes
 */

Body of Frist Method:
{
    if (attr == null) {
        throw new IllegalArgumentException("Illegal null AudioAttributes");
    }
    try {
        getService().playerAttributes(mPlayerIId, attr);
    } catch (RemoteException e) {
        Log.e(TAG, "Error talking to audio service, STARTED state will not be tracked", e);
    }
    synchronized (mLock) {
        mAttributes = attr;
        updateAppOpsPlayAudio_sync();
    }
}
Body of Second Method:
{
    if (attr == null) {
        throw new IllegalArgumentException("Illegal null AudioAttributes");
    }
    try {
        getService().playerAttributes(mPlayerIId, attr);
    } catch (RemoteException e) {
        Log.e(TAG, "Error talking to audio service, STARTED state will not be tracked", e);
    }
    synchronized (mLock) {
        boolean attributesChanged = (mAttributes != attr);
        mAttributes = attr;
        updateAppOpsPlayAudio_sync(attributesChanged);
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothDevice.getName:COMMENT
Method Modifier: public      
Comment:/**
 * Get the friendly Bluetooth name of the remote device.
 *
 * <p>The local adapter will automatically retrieve remote names when
 * performing a device scan, and will cache them. This method just returns
 * the name for this device from the cache.
 *
 * @return the Bluetooth name, or null if there was a problem.
 */

Body of Frist Method:
{
    if (sService == null) {
        Log.e(TAG, "BT not enabled. Cannot get Remote Device name");
        return null;
    }
    try {
        return sService.getRemoteName(this);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return null;
}
Body of Second Method:
{
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, "BT not enabled. Cannot get Remote Device name");
        return null;
    }
    try {
        return service.getRemoteName(this);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return null;
}
------------------------
Find a silently evolved API code:android.graphics.ColorFilter.getNativeInstance:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (mNativeInstance == -1) {
        throw new IllegalStateException("attempting to use a finalized ColorFilter");
    }
    if (mNativeInstance == 0) {
        mNativeInstance = createNativeInstance();
    }
    return mNativeInstance;
}
Body of Second Method:
{
    if (mNativeInstance == 0) {
        mNativeInstance = createNativeInstance();
        if (mNativeInstance != 0) {
            // Note: we must check for null here, since it's possible for createNativeInstance()
            // to return nullptr if the native SkColorFilter would be a no-op at draw time.
            // See native implementations of subclass create methods for more info.
            mCleaner = NoImagePreloadHolder.sRegistry.registerNativeAllocation(this, mNativeInstance);
        }
    }
    return mNativeInstance;
}
------------------------
Find a silently evolved API code:android.app.NotificationChannel.writeXml:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    out.startTag(null, TAG_CHANNEL);
    out.attribute(null, ATT_ID, getId());
    if (getName() != null) {
        out.attribute(null, ATT_NAME, getName().toString());
    }
    if (getDescription() != null) {
        out.attribute(null, ATT_DESC, getDescription());
    }
    if (getImportance() != DEFAULT_IMPORTANCE) {
        out.attribute(null, ATT_IMPORTANCE, Integer.toString(getImportance()));
    }
    if (canBypassDnd()) {
        out.attribute(null, ATT_PRIORITY, Integer.toString(Notification.PRIORITY_MAX));
    }
    if (getLockscreenVisibility() != DEFAULT_VISIBILITY) {
        out.attribute(null, ATT_VISIBILITY, Integer.toString(getLockscreenVisibility()));
    }
    if (getSound() != null) {
        out.attribute(null, ATT_SOUND, getSound().toString());
    }
    if (getAudioAttributes() != null) {
        out.attribute(null, ATT_USAGE, Integer.toString(getAudioAttributes().getUsage()));
        out.attribute(null, ATT_CONTENT_TYPE, Integer.toString(getAudioAttributes().getContentType()));
        out.attribute(null, ATT_FLAGS, Integer.toString(getAudioAttributes().getFlags()));
    }
    if (shouldShowLights()) {
        out.attribute(null, ATT_LIGHTS, Boolean.toString(shouldShowLights()));
    }
    if (getLightColor() != DEFAULT_LIGHT_COLOR) {
        out.attribute(null, ATT_LIGHT_COLOR, Integer.toString(getLightColor()));
    }
    if (shouldVibrate()) {
        out.attribute(null, ATT_VIBRATION_ENABLED, Boolean.toString(shouldVibrate()));
    }
    if (getVibrationPattern() != null) {
        out.attribute(null, ATT_VIBRATION, longArrayToString(getVibrationPattern()));
    }
    if (getUserLockedFields() != 0) {
        out.attribute(null, ATT_USER_LOCKED, Integer.toString(getUserLockedFields()));
    }
    if (canShowBadge()) {
        out.attribute(null, ATT_SHOW_BADGE, Boolean.toString(canShowBadge()));
    }
    if (isDeleted()) {
        out.attribute(null, ATT_DELETED, Boolean.toString(isDeleted()));
    }
    if (getGroup() != null) {
        out.attribute(null, ATT_GROUP, getGroup());
    }
    if (isBlockableSystem()) {
        out.attribute(null, ATT_BLOCKABLE_SYSTEM, Boolean.toString(isBlockableSystem()));
    }
    out.endTag(null, TAG_CHANNEL);
}
Body of Second Method:
{
    writeXml(out, false, null);
}
------------------------
Find a silently evolved API code:android.text.TextLine.handleRun:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Utility function for handling a unidirectional run.  The run must not
 * contain tabs but can contain styles.
 *
 * @param start the line-relative start of the run
 * @param measureLimit the offset to measure to, between start and limit inclusive
 * @param limit the limit of the run
 * @param runIsRtl true if the run is right-to-left
 * @param c the canvas, can be null
 * @param x the end of the run closest to the leading margin
 * @param top the top of the line
 * @param y the baseline
 * @param bottom the bottom of the line
 * @param fmi receives metrics information, can be null
 * @param needWidth true if the width is required
 * @return the signed width of the run based on the run direction; only
 * valid if needWidth is true
 */

Body of Frist Method:
{
    if (measureLimit < start || measureLimit > limit) {
        throw new IndexOutOfBoundsException("measureLimit (" + measureLimit + ") is out of " + "start (" + start + ") and limit (" + limit + ") bounds");
    }
    // Case of an empty line, make sure we update fmi according to mPaint
    if (start == measureLimit) {
        TextPaint wp = mWorkPaint;
        wp.set(mPaint);
        if (fmi != null) {
            expandMetricsFromPaint(fmi, wp);
        }
        return 0f;
    }
    if (mSpanned == null) {
        TextPaint wp = mWorkPaint;
        wp.set(mPaint);
        wp.setHyphenEdit(adjustHyphenEdit(start, limit, wp.getHyphenEdit()));
        return handleText(wp, start, limit, start, limit, runIsRtl, c, x, top, y, bottom, fmi, needWidth, measureLimit);
    }
    mMetricAffectingSpanSpanSet.init(mSpanned, mStart + start, mStart + limit);
    mCharacterStyleSpanSet.init(mSpanned, mStart + start, mStart + limit);
    // Shaping needs to take into account context up to metric boundaries,
    // but rendering needs to take into account character style boundaries.
    // So we iterate through metric runs to get metric bounds,
    // then within each metric run iterate through character style runs
    // for the run bounds.
    final float originalX = x;
    for (int i = start, inext; i < measureLimit; i = inext) {
        TextPaint wp = mWorkPaint;
        wp.set(mPaint);
        inext = mMetricAffectingSpanSpanSet.getNextTransition(mStart + i, mStart + limit) - mStart;
        int mlimit = Math.min(inext, measureLimit);
        ReplacementSpan replacement = null;
        for (int j = 0; j < mMetricAffectingSpanSpanSet.numberOfSpans; j++) {
            // empty by construction. This special case in getSpans() explains the >= & <= tests
            if ((mMetricAffectingSpanSpanSet.spanStarts[j] >= mStart + mlimit) || (mMetricAffectingSpanSpanSet.spanEnds[j] <= mStart + i))
                continue;
            MetricAffectingSpan span = mMetricAffectingSpanSpanSet.spans[j];
            if (span instanceof ReplacementSpan) {
                replacement = (ReplacementSpan) span;
            } else {
                // We might have a replacement that uses the draw
                // state, otherwise measure state would suffice.
                span.updateDrawState(wp);
            }
        }
        if (replacement != null) {
            x += handleReplacement(replacement, wp, i, mlimit, runIsRtl, c, x, top, y, bottom, fmi, needWidth || mlimit < measureLimit);
            continue;
        }
        for (int j = i, jnext; j < mlimit; j = jnext) {
            jnext = mCharacterStyleSpanSet.getNextTransition(mStart + j, mStart + inext) - mStart;
            int offset = Math.min(jnext, mlimit);
            wp.set(mPaint);
            for (int k = 0; k < mCharacterStyleSpanSet.numberOfSpans; k++) {
                // Intentionally using >= and <= as explained above
                if ((mCharacterStyleSpanSet.spanStarts[k] >= mStart + offset) || (mCharacterStyleSpanSet.spanEnds[k] <= mStart + j))
                    continue;
                CharacterStyle span = mCharacterStyleSpanSet.spans[k];
                span.updateDrawState(wp);
            }
            wp.setHyphenEdit(adjustHyphenEdit(j, jnext, wp.getHyphenEdit()));
            x += handleText(wp, j, jnext, i, inext, runIsRtl, c, x, top, y, bottom, fmi, needWidth || jnext < measureLimit, offset);
        }
    }
    return x - originalX;
}
Body of Second Method:
{
    if (measureLimit < start || measureLimit > limit) {
        throw new IndexOutOfBoundsException("measureLimit (" + measureLimit + ") is out of " + "start (" + start + ") and limit (" + limit + ") bounds");
    }
    // Case of an empty line, make sure we update fmi according to mPaint
    if (start == measureLimit) {
        final TextPaint wp = mWorkPaint;
        wp.set(mPaint);
        if (fmi != null) {
            expandMetricsFromPaint(fmi, wp);
        }
        return 0f;
    }
    final boolean needsSpanMeasurement;
    if (mSpanned == null) {
        needsSpanMeasurement = false;
    } else {
        mMetricAffectingSpanSpanSet.init(mSpanned, mStart + start, mStart + limit);
        mCharacterStyleSpanSet.init(mSpanned, mStart + start, mStart + limit);
        needsSpanMeasurement = mMetricAffectingSpanSpanSet.numberOfSpans != 0 || mCharacterStyleSpanSet.numberOfSpans != 0;
    }
    if (!needsSpanMeasurement) {
        final TextPaint wp = mWorkPaint;
        wp.set(mPaint);
        wp.setHyphenEdit(adjustHyphenEdit(start, limit, wp.getHyphenEdit()));
        return handleText(wp, start, limit, start, limit, runIsRtl, c, x, top, y, bottom, fmi, needWidth, measureLimit, null);
    }
    // Shaping needs to take into account context up to metric boundaries,
    // but rendering needs to take into account character style boundaries.
    // So we iterate through metric runs to get metric bounds,
    // then within each metric run iterate through character style runs
    // for the run bounds.
    final float originalX = x;
    for (int i = start, inext; i < measureLimit; i = inext) {
        final TextPaint wp = mWorkPaint;
        wp.set(mPaint);
        inext = mMetricAffectingSpanSpanSet.getNextTransition(mStart + i, mStart + limit) - mStart;
        int mlimit = Math.min(inext, measureLimit);
        ReplacementSpan replacement = null;
        for (int j = 0; j < mMetricAffectingSpanSpanSet.numberOfSpans; j++) {
            // empty by construction. This special case in getSpans() explains the >= & <= tests
            if ((mMetricAffectingSpanSpanSet.spanStarts[j] >= mStart + mlimit) || (mMetricAffectingSpanSpanSet.spanEnds[j] <= mStart + i))
                continue;
            final MetricAffectingSpan span = mMetricAffectingSpanSpanSet.spans[j];
            if (span instanceof ReplacementSpan) {
                replacement = (ReplacementSpan) span;
            } else {
                // We might have a replacement that uses the draw
                // state, otherwise measure state would suffice.
                span.updateDrawState(wp);
            }
        }
        if (replacement != null) {
            x += handleReplacement(replacement, wp, i, mlimit, runIsRtl, c, x, top, y, bottom, fmi, needWidth || mlimit < measureLimit);
            continue;
        }
        final TextPaint activePaint = mActivePaint;
        activePaint.set(mPaint);
        int activeStart = i;
        int activeEnd = mlimit;
        final DecorationInfo decorationInfo = mDecorationInfo;
        mDecorations.clear();
        for (int j = i, jnext; j < mlimit; j = jnext) {
            jnext = mCharacterStyleSpanSet.getNextTransition(mStart + j, mStart + inext) - mStart;
            final int offset = Math.min(jnext, mlimit);
            wp.set(mPaint);
            for (int k = 0; k < mCharacterStyleSpanSet.numberOfSpans; k++) {
                // Intentionally using >= and <= as explained above
                if ((mCharacterStyleSpanSet.spanStarts[k] >= mStart + offset) || (mCharacterStyleSpanSet.spanEnds[k] <= mStart + j))
                    continue;
                final CharacterStyle span = mCharacterStyleSpanSet.spans[k];
                span.updateDrawState(wp);
            }
            extractDecorationInfo(wp, decorationInfo);
            if (j == i) {
                // First chunk of text. We can't handle it yet, since we may need to merge it
                // with the next chunk. So we just save the TextPaint for future comparisons
                // and use.
                activePaint.set(wp);
            } else if (!wp.hasEqualAttributes(activePaint)) {
                // The style of the present chunk of text is substantially different from the
                // style of the previous chunk. We need to handle the active piece of text
                // and restart with the present chunk.
                activePaint.setHyphenEdit(adjustHyphenEdit(activeStart, activeEnd, mPaint.getHyphenEdit()));
                x += handleText(activePaint, activeStart, activeEnd, i, inext, runIsRtl, c, x, top, y, bottom, fmi, needWidth || activeEnd < measureLimit, Math.min(activeEnd, mlimit), mDecorations);
                activeStart = j;
                activePaint.set(wp);
                mDecorations.clear();
            } else {
            // The present TextPaint is substantially equal to the last TextPaint except
            // perhaps for decorations. We just need to expand the active piece of text to
            // include the present chunk, which we always do anyway. We don't need to save
            // wp to activePaint, since they are already equal.
            }
            activeEnd = jnext;
            if (decorationInfo.hasDecoration()) {
                final DecorationInfo copy = decorationInfo.copyInfo();
                copy.start = j;
                copy.end = jnext;
                mDecorations.add(copy);
            }
        }
        // Handle the final piece of text.
        activePaint.setHyphenEdit(adjustHyphenEdit(activeStart, activeEnd, mPaint.getHyphenEdit()));
        x += handleText(activePaint, activeStart, activeEnd, i, inext, runIsRtl, c, x, top, y, bottom, fmi, needWidth || activeEnd < measureLimit, Math.min(activeEnd, mlimit), mDecorations);
    }
    return x - originalX;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.getDevicesMatchingConnectionStates:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns list of remote devices in a particular state
 *
 * @param states    collection of states
 * @return          list of devices that state matches the states listed in
 * <code>states</code>; empty list if nothing matches the
 * <code>states</code>
 */

Body of Frist Method:
{
    if (VDBG)
        log("getDevicesMatchingStates()");
    if (mService != null && isEnabled()) {
        try {
            return mService.getDevicesMatchingConnectionStates(states);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
Body of Second Method:
{
    if (VDBG)
        log("getDevicesMatchingStates()");
    final IBluetoothHeadsetClient service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.getDevicesMatchingConnectionStates(states);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothInputDevice.getConnectedDevices:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (VDBG)
        log("getConnectedDevices()");
    if (mService != null && isEnabled()) {
        try {
            return mService.getConnectedDevices();
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
Body of Second Method:
{
    if (VDBG)
        log("getConnectedDevices()");
    final IBluetoothInputDevice service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.getConnectedDevices();
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothSap.getConnectedDevices:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the list of connected devices. Currently at most one.
 *
 * @return list of connected devices
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("getConnectedDevices()");
    if (mService != null && isEnabled()) {
        try {
            return mService.getConnectedDevices();
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
Body of Second Method:
{
    if (DBG)
        log("getConnectedDevices()");
    final IBluetoothSap service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.getConnectedDevices();
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.getAudioRouteAllowed:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns whether audio routing is allowed.
 * @param device    remote device
 * @return whether the command succeeded
 * Note: This is an internal function and shouldn't be exposed
 */

Body of Frist Method:
{
    if (VDBG)
        log("getAudioRouteAllowed");
    if (mService != null && isEnabled()) {
        try {
            return mService.getAudioRouteAllowed(device);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return false;
}
Body of Second Method:
{
    if (VDBG)
        log("getAudioRouteAllowed");
    final IBluetoothHeadsetClient service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.getAudioRouteAllowed(device);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return false;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.connectAudio:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Initiates a connection of audio channel.
 *
 * It setup SCO channel with remote connected Handsfree AG device.
 *
 * @param device    remote device
 * @return          <code>true</code> if command has been issued successfully;
 * <code>false</code> otherwise;
 * upon completion HFP sends {@link #ACTION_AUDIO_STATE_CHANGED}
 * intent;
 */

Body of Frist Method:
{
    if (mService != null && isEnabled()) {
        try {
            return mService.connectAudio(device);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return false;
}
Body of Second Method:
{
    final IBluetoothHeadsetClient service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.connectAudio(device);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return false;
}
------------------------
Find a silently evolved API code:android.telephony.TelephonyManager.getNetworkCountryIsoForPhone:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * {@hide}
 */

Body of Frist Method:
{
    return getTelephonyProperty(phoneId, TelephonyProperties.PROPERTY_OPERATOR_ISO_COUNTRY, "");
}
Body of Second Method:
{
    try {
        ITelephony telephony = getITelephony();
        if (telephony == null)
            return "";
        return telephony.getNetworkCountryIsoForPhone(phoneId);
    } catch (RemoteException ex) {
        return "";
    }
}
------------------------
Find a silently evolved API code:android.telephony.SmsMessage.useCdmaFormatForMoSms:COMMENT
Method Modifier: private     static      
Comment:/**
 * Determines whether or not to use CDMA format for MO SMS.
 * If SMS over IMS is supported, then format is based on IMS SMS format,
 * otherwise format is based on current phone type.
 *
 * @return true if Cdma format should be used for MO SMS, false otherwise.
 */

Body of Frist Method:
{
    if (!SmsManager.getDefault().isImsSmsSupported()) {
        // use Voice technology to determine SMS format.
        return isCdmaVoice();
    }
    // IMS is registered with SMS support, check the SMS format supported
    return (SmsConstants.FORMAT_3GPP2.equals(SmsManager.getDefault().getImsSmsFormat()));
}
Body of Second Method:
{
    // IMS is registered with SMS support, check the SMS format supported
    return useCdmaFormatForMoSms(SubscriptionManager.getDefaultSmsSubscriptionId());
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothMap.getState:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the current state of the BluetoothMap service.
 * @return One of the STATE_ return codes, or STATE_ERROR if this proxy
 * object is currently not connected to the Map service.
 */

Body of Frist Method:
{
    if (VDBG)
        log("getState()");
    if (mService != null) {
        try {
            return mService.getState();
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            log(Log.getStackTraceString(new Throwable()));
    }
    return BluetoothMap.STATE_ERROR;
}
Body of Second Method:
{
    if (VDBG)
        log("getState()");
    final IBluetoothMap service = mService;
    if (service != null) {
        try {
            return service.getState();
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            log(Log.getStackTraceString(new Throwable()));
    }
    return BluetoothMap.STATE_ERROR;
}
------------------------
Find a silently evolved API code:android.database.sqlite.SQLiteDatabaseConfiguration.updateParametersFrom:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Updates the non-immutable parameters of this configuration object
 * from the other configuration object.
 *
 * @param other The object from which to copy the parameters.
 */

Body of Frist Method:
{
    if (other == null) {
        throw new IllegalArgumentException("other must not be null.");
    }
    if (!path.equals(other.path)) {
        throw new IllegalArgumentException("other configuration must refer to " + "the same database.");
    }
    openFlags = other.openFlags;
    maxSqlCacheSize = other.maxSqlCacheSize;
    locale = other.locale;
    foreignKeyConstraintsEnabled = other.foreignKeyConstraintsEnabled;
    customFunctions.clear();
    customFunctions.addAll(other.customFunctions);
}
Body of Second Method:
{
    if (other == null) {
        throw new IllegalArgumentException("other must not be null.");
    }
    if (!path.equals(other.path)) {
        throw new IllegalArgumentException("other configuration must refer to " + "the same database.");
    }
    openFlags = other.openFlags;
    maxSqlCacheSize = other.maxSqlCacheSize;
    locale = other.locale;
    foreignKeyConstraintsEnabled = other.foreignKeyConstraintsEnabled;
    customFunctions.clear();
    customFunctions.addAll(other.customFunctions);
    lookasideSlotSize = other.lookasideSlotSize;
    lookasideSlotCount = other.lookasideSlotCount;
    idleConnectionTimeoutMs = other.idleConnectionTimeoutMs;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadset.getBatteryUsageHint:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get battery usage hint for Bluetooth Headset service.
 * This is a monotonically increasing integer. Wraps to 0 at
 * Integer.MAX_INT, and at boot.
 * Current implementation returns the number of AT commands handled since
 * boot. This is a good indicator for spammy headset/handsfree units that
 * can keep the device awake by polling for cellular status updates. As a
 * rule of thumb, each AT command prevents the CPU from sleeping for 500 ms
 *
 * @param device the bluetooth headset.
 * @return monotonically increasing battery usage hint, or a negative error
 * code on error
 * @hide
 */

Body of Frist Method:
{
    if (VDBG)
        log("getBatteryUsageHint()");
    if (mService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mService.getBatteryUsageHint(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return -1;
}
Body of Second Method:
{
    if (VDBG)
        log("getBatteryUsageHint()");
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getBatteryUsageHint(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return -1;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothA2dpSink.getConnectedDevices:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (VDBG)
        log("getConnectedDevices()");
    if (mService != null && isEnabled()) {
        try {
            return mService.getConnectedDevices();
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
Body of Second Method:
{
    if (VDBG)
        log("getConnectedDevices()");
    final IBluetoothA2dpSink service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.getConnectedDevices();
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
------------------------
Find a silently evolved API code:android.media.MediaCas.setPrivateData:COMMENT
Method Modifier: public      
Comment:/**
 * Send the private data for the CA system.
 *
 * @param data byte array of the private data.
 *
 * @throws IllegalStateException if the MediaCas instance is not valid.
 * @throws MediaCasException for CAS-specific errors.
 * @throws MediaCasStateException for CAS-specific state exceptions.
 */

Body of Frist Method:
{
    validateInternalStates();
    try {
        mICas.setPrivateData(data);
    } catch (ServiceSpecificException e) {
        MediaCasException.throwExceptions(e);
    } catch (RemoteException e) {
        cleanupAndRethrowIllegalState();
    }
}
Body of Second Method:
{
    validateInternalStates();
    try {
        MediaCasException.throwExceptionIfNeeded(mICas.setPrivateData(toByteArray(data, 0, data.length)));
    } catch (RemoteException e) {
        cleanupAndRethrowIllegalState();
    }
}
------------------------
Find a silently evolved API code:android.app.DownloadManager.Request.toContentValues:COMMENT
Method Modifier: default     
Comment:/**
 * @return ContentValues to be passed to DownloadProvider.insert()
 */

Body of Frist Method:
{
    ContentValues values = new ContentValues();
    assert mUri != null;
    values.put(Downloads.Impl.COLUMN_URI, mUri.toString());
    values.put(Downloads.Impl.COLUMN_IS_PUBLIC_API, true);
    values.put(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE, packageName);
    if (mDestinationUri != null) {
        values.put(Downloads.Impl.COLUMN_DESTINATION, Downloads.Impl.DESTINATION_FILE_URI);
        values.put(Downloads.Impl.COLUMN_FILE_NAME_HINT, mDestinationUri.toString());
    } else {
        values.put(Downloads.Impl.COLUMN_DESTINATION, (this.mUseSystemCache) ? Downloads.Impl.DESTINATION_SYSTEMCACHE_PARTITION : Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE);
    }
    // is the file supposed to be media-scannable?
    values.put(Downloads.Impl.COLUMN_MEDIA_SCANNED, (mScannable) ? SCANNABLE_VALUE_YES : SCANNABLE_VALUE_NO);
    if (!mRequestHeaders.isEmpty()) {
        encodeHttpHeaders(values);
    }
    putIfNonNull(values, Downloads.Impl.COLUMN_TITLE, mTitle);
    putIfNonNull(values, Downloads.Impl.COLUMN_DESCRIPTION, mDescription);
    putIfNonNull(values, Downloads.Impl.COLUMN_MIME_TYPE, mMimeType);
    values.put(Downloads.Impl.COLUMN_VISIBILITY, mNotificationVisibility);
    values.put(Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES, mAllowedNetworkTypes);
    values.put(Downloads.Impl.COLUMN_ALLOW_ROAMING, mRoamingAllowed);
    values.put(Downloads.Impl.COLUMN_ALLOW_METERED, mMeteredAllowed);
    values.put(Downloads.Impl.COLUMN_FLAGS, mFlags);
    values.put(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, mIsVisibleInDownloadsUi);
    return values;
}
Body of Second Method:
{
    ContentValues values = new ContentValues();
    assert mUri != null;
    values.put(Downloads.Impl.COLUMN_URI, mUri.toString());
    values.put(Downloads.Impl.COLUMN_IS_PUBLIC_API, true);
    values.put(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE, packageName);
    if (mDestinationUri != null) {
        values.put(Downloads.Impl.COLUMN_DESTINATION, Downloads.Impl.DESTINATION_FILE_URI);
        values.put(Downloads.Impl.COLUMN_FILE_NAME_HINT, mDestinationUri.toString());
    } else {
        values.put(Downloads.Impl.COLUMN_DESTINATION, Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE);
    }
    // is the file supposed to be media-scannable?
    values.put(Downloads.Impl.COLUMN_MEDIA_SCANNED, (mScannable) ? SCANNABLE_VALUE_YES : SCANNABLE_VALUE_NO);
    if (!mRequestHeaders.isEmpty()) {
        encodeHttpHeaders(values);
    }
    putIfNonNull(values, Downloads.Impl.COLUMN_TITLE, mTitle);
    putIfNonNull(values, Downloads.Impl.COLUMN_DESCRIPTION, mDescription);
    putIfNonNull(values, Downloads.Impl.COLUMN_MIME_TYPE, mMimeType);
    values.put(Downloads.Impl.COLUMN_VISIBILITY, mNotificationVisibility);
    values.put(Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES, mAllowedNetworkTypes);
    values.put(Downloads.Impl.COLUMN_ALLOW_ROAMING, mRoamingAllowed);
    values.put(Downloads.Impl.COLUMN_ALLOW_METERED, mMeteredAllowed);
    values.put(Downloads.Impl.COLUMN_FLAGS, mFlags);
    values.put(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, mIsVisibleInDownloadsUi);
    return values;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadset.startVoiceRecognition:COMMENT
Method Modifier: public      
Comment:/**
 * Start Bluetooth voice recognition. This methods sends the voice
 * recognition AT command to the headset and establishes the
 * audio connection.
 *
 * <p> Users can listen to {@link #ACTION_AUDIO_STATE_CHANGED}.
 * If this function returns true, this intent will be broadcasted with
 * {@link #EXTRA_STATE} set to {@link #STATE_AUDIO_CONNECTING}.
 *
 * <p> {@link #EXTRA_STATE} will transition from
 * {@link #STATE_AUDIO_CONNECTING} to {@link #STATE_AUDIO_CONNECTED} when
 * audio connection is established and to {@link #STATE_AUDIO_DISCONNECTED}
 * in case of failure to establish the audio connection.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param device Bluetooth headset
 * @return false if there is no headset connected of if the
 * connected headset doesn't support voice recognition
 * or on error, true otherwise
 */

Body of Frist Method:
{
    if (DBG)
        log("startVoiceRecognition()");
    if (mService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mService.startVoiceRecognition(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("startVoiceRecognition()");
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.startVoiceRecognition(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.net.NetworkCapabilities.transportNamesOf:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (types == null || types.length == 0) {
        return "";
    }
    StringBuilder transports = new StringBuilder();
    for (int t : types) {
        transports.append("|").append(transportNameOf(t));
    }
    return transports.substring(1);
}
Body of Second Method:
{
    StringJoiner joiner = new StringJoiner("|");
    if (types != null) {
        for (int t : types) {
            joiner.add(transportNameOf(t));
        }
    }
    return joiner.toString();
}
------------------------
Find a silently evolved API code:android.database.sqlite.SQLiteConnectionPool.acquireConnection:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Acquires a connection from the pool.
 * <p>
 * The caller must call {@link #releaseConnection} to release the connection
 * back to the pool when it is finished.  Failure to do so will result
 * in much unpleasantness.
 * </p>
 *
 * @param sql If not null, try to find a connection that already has
 * the specified SQL statement in its prepared statement cache.
 * @param connectionFlags The connection request flags.
 * @param cancellationSignal A signal to cancel the operation in progress, or null if none.
 * @return The connection that was acquired, never null.
 *
 * @throws IllegalStateException if the pool has been closed.
 * @throws SQLiteException if a database error occurs.
 * @throws OperationCanceledException if the operation was canceled.
 */

Body of Frist Method:
{
    return waitForConnection(sql, connectionFlags, cancellationSignal);
}
Body of Second Method:
{
    SQLiteConnection con = waitForConnection(sql, connectionFlags, cancellationSignal);
    synchronized (mLock) {
        if (mIdleConnectionHandler != null) {
            mIdleConnectionHandler.connectionAcquired(con);
        }
    }
    return con;
}
------------------------
