Find a silently evolved API code:android.content.res.TypedArray.getDimensionPixelSize:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve a dimensional unit attribute at <var>index</var> for use
 * as a size in raw pixels.  This is the same as
 * {@link #getDimension}, except the returned value is converted to
 * integer pixels for use as a size.  A size conversion involves
 * rounding the base value, and ensuring that a non-zero base value
 * is at least one pixel in size.
 * <p>
 * This method will throw an exception if the attribute is defined but is
 * not a dimension.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute dimension value multiplied by the appropriate
 * metric and truncated to integer pixels, or defValue if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not a dimension.
 *
 * @see #getDimension
 * @see #getDimensionPixelOffset
 */

Body of Frist Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    final int attrIndex = index;
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimensionPixelSize(data[index + AssetManager.STYLE_DATA], mMetrics);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index, value);
        throw new UnsupportedOperationException("Failed to resolve attribute at index " + attrIndex + ": " + value);
    }
    throw new UnsupportedOperationException("Can't convert value at index " + attrIndex + " to dimension: type=0x" + Integer.toHexString(type));
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    final int attrIndex = index;
    index *= STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimensionPixelSize(data[index + STYLE_DATA], mMetrics);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index, value);
        throw new UnsupportedOperationException("Failed to resolve attribute at index " + attrIndex + ": " + value);
    }
    throw new UnsupportedOperationException("Can't convert value at index " + attrIndex + " to dimension: type=0x" + Integer.toHexString(type));
}
------------------------
Find a silently evolved API code:android.content.pm.PackageItemInfo.loadLabel:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the current textual label associated with this item.  This
 * will call back on the given PackageManager to load the label from
 * the application.
 *
 * @param pm A PackageManager from which the label can be loaded; usually
 * the PackageManager from which you originally retrieved this item.
 *
 * @return Returns a CharSequence containing the item's label.  If the
 * item does not have a label, its name is returned.
 */

Body of Frist Method:
{
    if (nonLocalizedLabel != null) {
        return nonLocalizedLabel;
    }
    if (labelRes != 0) {
        CharSequence label = pm.getText(packageName, labelRes, getApplicationInfo());
        if (label != null) {
            return label.toString().trim();
        }
    }
    if (name != null) {
        return name;
    }
    return packageName;
}
Body of Second Method:
{
    if (sForceSafeLabels) {
        return loadSafeLabel(pm);
    } else {
        return loadUnsafeLabel(pm);
    }
}
------------------------
Find a silently evolved API code:android.os.Debug.MemoryInfo.getOtherSwappedOut:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return otherStats[which * NUM_CATEGORIES + offsetSwappedOut];
}
Body of Second Method:
{
    return otherStats[which * NUM_CATEGORIES + OFFSET_SWAPPED_OUT];
}
------------------------
Find a silently evolved API code:android.net.TrafficStats.getTotalTxPackets:COMMENT
Method Modifier: public      static      
Comment:/**
 * Return number of packets transmitted since device boot. Counts packets
 * across all network interfaces, and always increases monotonically since
 * device boot. Statistics are measured at the network layer, so they
 * include both TCP and UDP usage.
 * <p>
 * Before {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}, this may
 * return {@link #UNSUPPORTED} on devices where statistics aren't available.
 */

Body of Frist Method:
{
    return nativeGetTotalStat(TYPE_TX_PACKETS);
}
Body of Second Method:
{
    try {
        return getStatsService().getTotalStats(TYPE_TX_PACKETS);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.net.TrafficStats.getUidTxBytes:COMMENT
Method Modifier: public      static      
Comment:/**
 * Return number of bytes transmitted by the given UID since device boot.
 * Counts packets across all network interfaces, and always increases
 * monotonically since device boot. Statistics are measured at the network
 * layer, so they include both TCP and UDP usage.
 * <p>
 * Before {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}, this may
 * return {@link #UNSUPPORTED} on devices where statistics aren't available.
 * <p>
 * Starting in {@link android.os.Build.VERSION_CODES#N} this will only
 * report traffic statistics for the calling UID. It will return
 * {@link #UNSUPPORTED} for all other UIDs for privacy reasons. To access
 * historical network statistics belonging to other UIDs, use
 * {@link NetworkStatsManager}.
 *
 * @see android.os.Process#myUid()
 * @see android.content.pm.ApplicationInfo#uid
 */

Body of Frist Method:
{
    // This isn't actually enforcing any security; it just returns the
    // unsupported value. The real filtering is done at the kernel level.
    final int callingUid = android.os.Process.myUid();
    if (callingUid == android.os.Process.SYSTEM_UID || callingUid == uid) {
        return nativeGetUidStat(uid, TYPE_TX_BYTES);
    } else {
        return UNSUPPORTED;
    }
}
Body of Second Method:
{
    // This isn't actually enforcing any security; it just returns the
    // unsupported value. The real filtering is done at the kernel level.
    final int callingUid = android.os.Process.myUid();
    if (callingUid == android.os.Process.SYSTEM_UID || callingUid == uid) {
        try {
            return getStatsService().getUidStats(uid, TYPE_TX_BYTES);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    } else {
        return UNSUPPORTED;
    }
}
------------------------
Find a silently evolved API code:android.content.ContentProviderClient.setDetectNotResponding:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * {@hide}
 */

Body of Frist Method:
{
    synchronized (ContentProviderClient.class) {
        mAnrTimeout = timeoutMillis;
        if (timeoutMillis > 0) {
            if (mAnrRunnable == null) {
                mAnrRunnable = new NotRespondingRunnable();
            }
            if (sAnrHandler == null) {
                sAnrHandler = new Handler(Looper.getMainLooper(), null, true);
            }
        } else {
            mAnrRunnable = null;
        }
    }
}
Body of Second Method:
{
    synchronized (ContentProviderClient.class) {
        mAnrTimeout = timeoutMillis;
        if (timeoutMillis > 0) {
            if (mAnrRunnable == null) {
                mAnrRunnable = new NotRespondingRunnable();
            }
            if (sAnrHandler == null) {
                sAnrHandler = new Handler(Looper.getMainLooper(), null, true);
            }
            // If the remote process hangs, we're going to kill it, so we're
            // technically okay doing blocking calls.
            Binder.allowBlocking(mContentProvider.asBinder());
        } else {
            mAnrRunnable = null;
            // If we're no longer watching for hangs, revert back to default
            // blocking behavior.
            Binder.defaultBlocking(mContentProvider.asBinder());
        }
    }
}
------------------------
Find a silently evolved API code:android.media.BufferingParams.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Combines all of the fields that have been set and return a new
 * {@link BufferingParams} object. <code>IllegalStateException</code> will be
 * thrown if there is conflict between fields.
 * @return a new {@link BufferingParams} object
 */

Body of Frist Method:
{
    if (isTimeBasedMode(mRebufferingMode) && mRebufferingWatermarkLowMs > mRebufferingWatermarkHighMs) {
        throw new IllegalStateException("Illegal watermark:" + mRebufferingWatermarkLowMs + " : " + mRebufferingWatermarkHighMs);
    }
    if (isSizeBasedMode(mRebufferingMode) && mRebufferingWatermarkLowKB > mRebufferingWatermarkHighKB) {
        throw new IllegalStateException("Illegal watermark:" + mRebufferingWatermarkLowKB + " : " + mRebufferingWatermarkHighKB);
    }
    BufferingParams bp = new BufferingParams();
    bp.mInitialBufferingMode = mInitialBufferingMode;
    bp.mRebufferingMode = mRebufferingMode;
    bp.mInitialWatermarkMs = mInitialWatermarkMs;
    bp.mInitialWatermarkKB = mInitialWatermarkKB;
    bp.mRebufferingWatermarkLowMs = mRebufferingWatermarkLowMs;
    bp.mRebufferingWatermarkHighMs = mRebufferingWatermarkHighMs;
    bp.mRebufferingWatermarkLowKB = mRebufferingWatermarkLowKB;
    bp.mRebufferingWatermarkHighKB = mRebufferingWatermarkHighKB;
    return bp;
}
Body of Second Method:
{
    BufferingParams bp = new BufferingParams();
    bp.mInitialMarkMs = mInitialMarkMs;
    bp.mResumePlaybackMarkMs = mResumePlaybackMarkMs;
    return bp;
}
------------------------
Find a silently evolved API code:android.telephony.SmsManager.createMessageListFromRawRecords:COMMENT
<android.telephony.SmsManager: ArrayList<SmsMessage> createMessageListFromRawRecords(List<SmsRawData>)>
private     static      ->private     
Method Modifier: private     static      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * Create a list of <code>SmsMessage</code>s from a list of RawSmsData
 * records returned by <code>getAllMessagesFromIcc()</code>
 *
 * @param records SMS EF records, returned by
 * <code>getAllMessagesFromIcc</code>
 * @return <code>ArrayList</code> of <code>SmsMessage</code> objects.
 */

Body of Frist Method:
{
    ArrayList<SmsMessage> messages = new ArrayList<SmsMessage>();
    if (records != null) {
        int count = records.size();
        for (int i = 0; i < count; i++) {
            SmsRawData data = records.get(i);
            // List contains all records, including "free" records (null)
            if (data != null) {
                SmsMessage sms = SmsMessage.createFromEfRecord(i + 1, data.getBytes());
                if (sms != null) {
                    messages.add(sms);
                }
            }
        }
    }
    return messages;
}
Body of Second Method:
{
    ArrayList<SmsMessage> messages = new ArrayList<SmsMessage>();
    if (records != null) {
        int count = records.size();
        for (int i = 0; i < count; i++) {
            SmsRawData data = records.get(i);
            // List contains all records, including "free" records (null)
            if (data != null) {
                SmsMessage sms = SmsMessage.createFromEfRecord(i + 1, data.getBytes(), getSubscriptionId());
                if (sms != null) {
                    messages.add(sms);
                }
            }
        }
    }
    return messages;
}
------------------------
Find a silently evolved API code:android.database.sqlite.SQLiteConnectionPool.reconfigure:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Reconfigures the database configuration of the connection pool and all of its
 * connections.
 * <p>
 * Configuration changes are propagated down to connections immediately if
 * they are available or as soon as they are released.  This includes changes
 * that affect the size of the pool.
 * </p>
 *
 * @param configuration The new configuration.
 *
 * @throws IllegalStateException if the pool has been closed.
 */

Body of Frist Method:
{
    if (configuration == null) {
        throw new IllegalArgumentException("configuration must not be null.");
    }
    synchronized (mLock) {
        throwIfClosedLocked();
        boolean walModeChanged = ((configuration.openFlags ^ mConfiguration.openFlags) & SQLiteDatabase.ENABLE_WRITE_AHEAD_LOGGING) != 0;
        if (walModeChanged) {
            // because we need to close all but the primary connection first.
            if (!mAcquiredConnections.isEmpty()) {
                throw new IllegalStateException("Write Ahead Logging (WAL) mode cannot " + "be enabled or disabled while there are transactions in " + "progress.  Finish all transactions and release all active " + "database connections first.");
            }
            // Close all non-primary connections.  This should happen immediately
            // because none of them are in use.
            closeAvailableNonPrimaryConnectionsAndLogExceptionsLocked();
            assert mAvailableNonPrimaryConnections.isEmpty();
        }
        boolean foreignKeyModeChanged = configuration.foreignKeyConstraintsEnabled != mConfiguration.foreignKeyConstraintsEnabled;
        if (foreignKeyModeChanged) {
            // any acquired connections.
            if (!mAcquiredConnections.isEmpty()) {
                throw new IllegalStateException("Foreign Key Constraints cannot " + "be enabled or disabled while there are transactions in " + "progress.  Finish all transactions and release all active " + "database connections first.");
            }
        }
        if (mConfiguration.openFlags != configuration.openFlags) {
            // because there can only be one connection open when we change WAL mode.
            if (walModeChanged) {
                closeAvailableConnectionsAndLogExceptionsLocked();
            }
            // Try to reopen the primary connection using the new open flags then
            // close and discard all existing connections.
            // This might throw if the database is corrupt or cannot be opened in
            // the new mode in which case existing connections will remain untouched.
            SQLiteConnection newPrimaryConnection = openConnectionLocked(configuration, true);
            closeAvailableConnectionsAndLogExceptionsLocked();
            discardAcquiredConnectionsLocked();
            mAvailablePrimaryConnection = newPrimaryConnection;
            mConfiguration.updateParametersFrom(configuration);
            setMaxConnectionPoolSizeLocked();
        } else {
            // Reconfigure the database connections in place.
            mConfiguration.updateParametersFrom(configuration);
            setMaxConnectionPoolSizeLocked();
            closeExcessConnectionsAndLogExceptionsLocked();
            reconfigureAllConnectionsLocked();
        }
        wakeConnectionWaitersLocked();
    }
}
Body of Second Method:
{
    if (configuration == null) {
        throw new IllegalArgumentException("configuration must not be null.");
    }
    synchronized (mLock) {
        throwIfClosedLocked();
        boolean walModeChanged = ((configuration.openFlags ^ mConfiguration.openFlags) & SQLiteDatabase.ENABLE_WRITE_AHEAD_LOGGING) != 0;
        if (walModeChanged) {
            // because we need to close all but the primary connection first.
            if (!mAcquiredConnections.isEmpty()) {
                throw new IllegalStateException("Write Ahead Logging (WAL) mode cannot " + "be enabled or disabled while there are transactions in " + "progress.  Finish all transactions and release all active " + "database connections first.");
            }
            // Close all non-primary connections.  This should happen immediately
            // because none of them are in use.
            closeAvailableNonPrimaryConnectionsAndLogExceptionsLocked();
            assert mAvailableNonPrimaryConnections.isEmpty();
        }
        boolean foreignKeyModeChanged = configuration.foreignKeyConstraintsEnabled != mConfiguration.foreignKeyConstraintsEnabled;
        if (foreignKeyModeChanged) {
            // any acquired connections.
            if (!mAcquiredConnections.isEmpty()) {
                throw new IllegalStateException("Foreign Key Constraints cannot " + "be enabled or disabled while there are transactions in " + "progress.  Finish all transactions and release all active " + "database connections first.");
            }
        }
        // We should do in-place switching when transitioning from compatibility WAL
        // to rollback journal. Otherwise transient connection state will be lost
        boolean onlyCompatWalChanged = (mConfiguration.openFlags ^ configuration.openFlags) == SQLiteDatabase.DISABLE_COMPATIBILITY_WAL;
        if (!onlyCompatWalChanged && mConfiguration.openFlags != configuration.openFlags) {
            // because there can only be one connection open when we change WAL mode.
            if (walModeChanged) {
                closeAvailableConnectionsAndLogExceptionsLocked();
            }
            // Try to reopen the primary connection using the new open flags then
            // close and discard all existing connections.
            // This might throw if the database is corrupt or cannot be opened in
            // the new mode in which case existing connections will remain untouched.
            SQLiteConnection newPrimaryConnection = openConnectionLocked(configuration, true);
            closeAvailableConnectionsAndLogExceptionsLocked();
            discardAcquiredConnectionsLocked();
            mAvailablePrimaryConnection = newPrimaryConnection;
            mConfiguration.updateParametersFrom(configuration);
            setMaxConnectionPoolSizeLocked();
        } else {
            // Reconfigure the database connections in place.
            mConfiguration.updateParametersFrom(configuration);
            setMaxConnectionPoolSizeLocked();
            closeExcessConnectionsAndLogExceptionsLocked();
            reconfigureAllConnectionsLocked();
        }
        wakeConnectionWaitersLocked();
    }
}
------------------------
Find a silently evolved API code:android.util.DebugUtils.valueToString:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Use prefixed constants (static final values) on given class to turn value
 * into human-readable string.
 *
 * @hide
 */

Body of Frist Method:
{
    for (Field field : clazz.getDeclaredFields()) {
        final int modifiers = field.getModifiers();
        if (Modifier.isStatic(modifiers) && Modifier.isFinal(modifiers) && field.getType().equals(int.class) && field.getName().startsWith(prefix)) {
            try {
                if (value == field.getInt(null)) {
                    return field.getName().substring(prefix.length());
                }
            } catch (IllegalAccessException ignored) {
            }
        }
    }
    return Integer.toString(value);
}
Body of Second Method:
{
    for (Field field : clazz.getDeclaredFields()) {
        final int modifiers = field.getModifiers();
        if (Modifier.isStatic(modifiers) && Modifier.isFinal(modifiers) && field.getType().equals(int.class) && field.getName().startsWith(prefix)) {
            try {
                if (value == field.getInt(null)) {
                    return constNameWithoutPrefix(prefix, field);
                }
            } catch (IllegalAccessException ignored) {
            }
        }
    }
    return Integer.toString(value);
}
------------------------
Find a silently evolved API code:android.os.Looper.loop:COMMENT
Method Modifier: public      static      
Comment:/**
 * Run the message queue in this thread. Be sure to call
 * {@link #quit()} to end the loop.
 */

Body of Frist Method:
{
    final Looper me = myLooper();
    if (me == null) {
        throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread.");
    }
    final MessageQueue queue = me.mQueue;
    // Make sure the identity of this thread is that of the local process,
    // and keep track of what that identity token actually is.
    Binder.clearCallingIdentity();
    final long ident = Binder.clearCallingIdentity();
    for (; ; ) {
        // might block
        Message msg = queue.next();
        if (msg == null) {
            // No message indicates that the message queue is quitting.
            return;
        }
        // This must be in a local variable, in case a UI event sets the logger
        final Printer logging = me.mLogging;
        if (logging != null) {
            logging.println(">>>>> Dispatching to " + msg.target + " " + msg.callback + ": " + msg.what);
        }
        final long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;
        final long traceTag = me.mTraceTag;
        if (traceTag != 0 && Trace.isTagEnabled(traceTag)) {
            Trace.traceBegin(traceTag, msg.target.getTraceName(msg));
        }
        final long start = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();
        final long end;
        try {
            msg.target.dispatchMessage(msg);
            end = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();
        } finally {
            if (traceTag != 0) {
                Trace.traceEnd(traceTag);
            }
        }
        if (slowDispatchThresholdMs > 0) {
            final long time = end - start;
            if (time > slowDispatchThresholdMs) {
                Slog.w(TAG, "Dispatch took " + time + "ms on " + Thread.currentThread().getName() + ", h=" + msg.target + " cb=" + msg.callback + " msg=" + msg.what);
            }
        }
        if (logging != null) {
            logging.println("<<<<< Finished to " + msg.target + " " + msg.callback);
        }
        // Make sure that during the course of dispatching the
        // identity of the thread wasn't corrupted.
        final long newIdent = Binder.clearCallingIdentity();
        if (ident != newIdent) {
            Log.wtf(TAG, "Thread identity changed from 0x" + Long.toHexString(ident) + " to 0x" + Long.toHexString(newIdent) + " while dispatching to " + msg.target.getClass().getName() + " " + msg.callback + " what=" + msg.what);
        }
        msg.recycleUnchecked();
    }
}
Body of Second Method:
{
    final Looper me = myLooper();
    if (me == null) {
        throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread.");
    }
    final MessageQueue queue = me.mQueue;
    // Make sure the identity of this thread is that of the local process,
    // and keep track of what that identity token actually is.
    Binder.clearCallingIdentity();
    final long ident = Binder.clearCallingIdentity();
    // Allow overriding a threshold with a system prop. e.g.
    // adb shell 'setprop log.looper.1000.main.slow 1 && stop && start'
    final int thresholdOverride = SystemProperties.getInt("log.looper." + Process.myUid() + "." + Thread.currentThread().getName() + ".slow", 0);
    boolean slowDeliveryDetected = false;
    for (; ; ) {
        // might block
        Message msg = queue.next();
        if (msg == null) {
            // No message indicates that the message queue is quitting.
            return;
        }
        // This must be in a local variable, in case a UI event sets the logger
        final Printer logging = me.mLogging;
        if (logging != null) {
            logging.println(">>>>> Dispatching to " + msg.target + " " + msg.callback + ": " + msg.what);
        }
        final long traceTag = me.mTraceTag;
        long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;
        long slowDeliveryThresholdMs = me.mSlowDeliveryThresholdMs;
        if (thresholdOverride > 0) {
            slowDispatchThresholdMs = thresholdOverride;
            slowDeliveryThresholdMs = thresholdOverride;
        }
        final boolean logSlowDelivery = (slowDeliveryThresholdMs > 0) && (msg.when > 0);
        final boolean logSlowDispatch = (slowDispatchThresholdMs > 0);
        final boolean needStartTime = logSlowDelivery || logSlowDispatch;
        final boolean needEndTime = logSlowDispatch;
        if (traceTag != 0 && Trace.isTagEnabled(traceTag)) {
            Trace.traceBegin(traceTag, msg.target.getTraceName(msg));
        }
        final long dispatchStart = needStartTime ? SystemClock.uptimeMillis() : 0;
        final long dispatchEnd;
        try {
            msg.target.dispatchMessage(msg);
            dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0;
        } finally {
            if (traceTag != 0) {
                Trace.traceEnd(traceTag);
            }
        }
        if (logSlowDelivery) {
            if (slowDeliveryDetected) {
                if ((dispatchStart - msg.when) <= 10) {
                    Slog.w(TAG, "Drained");
                    slowDeliveryDetected = false;
                }
            } else {
                if (showSlowLog(slowDeliveryThresholdMs, msg.when, dispatchStart, "delivery", msg)) {
                    // Once we write a slow delivery log, suppress until the queue drains.
                    slowDeliveryDetected = true;
                }
            }
        }
        if (logSlowDispatch) {
            showSlowLog(slowDispatchThresholdMs, dispatchStart, dispatchEnd, "dispatch", msg);
        }
        if (logging != null) {
            logging.println("<<<<< Finished to " + msg.target + " " + msg.callback);
        }
        // Make sure that during the course of dispatching the
        // identity of the thread wasn't corrupted.
        final long newIdent = Binder.clearCallingIdentity();
        if (ident != newIdent) {
            Log.wtf(TAG, "Thread identity changed from 0x" + Long.toHexString(ident) + " to 0x" + Long.toHexString(newIdent) + " while dispatching to " + msg.target.getClass().getName() + " " + msg.callback + " what=" + msg.what);
        }
        msg.recycleUnchecked();
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.le.PeriodicAdvertisingReport.getRssi:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns the received signal strength in dBm. The valid range is [-127, 20].
 */

Body of Frist Method:
{
    return rssi;
}
Body of Second Method:
{
    return mRssi;
}
------------------------
Find a silently evolved API code:android.util.DebugUtils.flagsToString:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Use prefixed constants (static final values) on given class to turn flags
 * into human-readable string.
 *
 * @hide
 */

Body of Frist Method:
{
    final StringBuilder res = new StringBuilder();
    for (Field field : clazz.getDeclaredFields()) {
        final int modifiers = field.getModifiers();
        if (Modifier.isStatic(modifiers) && Modifier.isFinal(modifiers) && field.getType().equals(int.class) && field.getName().startsWith(prefix)) {
            try {
                final int value = field.getInt(null);
                if ((flags & value) != 0) {
                    flags &= ~value;
                    res.append(field.getName().substring(prefix.length())).append('|');
                }
            } catch (IllegalAccessException ignored) {
            }
        }
    }
    if (flags != 0 || res.length() == 0) {
        res.append(Integer.toHexString(flags));
    } else {
        res.deleteCharAt(res.length() - 1);
    }
    return res.toString();
}
Body of Second Method:
{
    final StringBuilder res = new StringBuilder();
    boolean flagsWasZero = flags == 0;
    for (Field field : clazz.getDeclaredFields()) {
        final int modifiers = field.getModifiers();
        if (Modifier.isStatic(modifiers) && Modifier.isFinal(modifiers) && field.getType().equals(int.class) && field.getName().startsWith(prefix)) {
            try {
                final int value = field.getInt(null);
                if (value == 0 && flagsWasZero) {
                    return constNameWithoutPrefix(prefix, field);
                }
                if ((flags & value) != 0) {
                    flags &= ~value;
                    res.append(constNameWithoutPrefix(prefix, field)).append('|');
                }
            } catch (IllegalAccessException ignored) {
            }
        }
    }
    if (flags != 0 || res.length() == 0) {
        res.append(Integer.toHexString(flags));
    } else {
        res.deleteCharAt(res.length() - 1);
    }
    return res.toString();
}
------------------------
Find a silently evolved API code:android.app.ActivityManagerNative.noteAlarmStart:COMMENT
Method Modifier: public      static      hidden      deprecated  
Comment:/**
 * @deprecated use ActivityManager.noteAlarmStart instead.
 */

Body of Frist Method:
{
    ActivityManager.noteAlarmStart(ps, sourceUid, tag);
}
Body of Second Method:
{
    ActivityManager.noteAlarmStart(ps, null, sourceUid, tag);
}
------------------------
Find a silently evolved API code:android.media.session.MediaController.TransportControls.pause:COMMENT
Method Modifier: public      
Comment:/**
 * Request that the player pause its playback and stay at its current
 * position.
 */

Body of Frist Method:
{
    try {
        mSessionBinder.pause();
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling pause.", e);
    }
}
Body of Second Method:
{
    try {
        mSessionBinder.pause(mContext.getPackageName(), mCbStub);
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling pause.", e);
    }
}
------------------------
Find a silently evolved API code:android.content.ContentResolver.getSyncAutomaticallyAsUser:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @see #getSyncAutomatically(Account, String)
 * @hide
 */

Body of Frist Method:
{
    try {
        return getContentService().getSyncAutomaticallyAsUser(account, authority, userId);
    } catch (RemoteException e) {
        throw new RuntimeException("the ContentService should always be reachable", e);
    }
}
Body of Second Method:
{
    try {
        return getContentService().getSyncAutomaticallyAsUser(account, authority, userId);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.telephony.SignalStrength.copyFrom:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    mGsmSignalStrength = s.mGsmSignalStrength;
    mGsmBitErrorRate = s.mGsmBitErrorRate;
    mCdmaDbm = s.mCdmaDbm;
    mCdmaEcio = s.mCdmaEcio;
    mEvdoDbm = s.mEvdoDbm;
    mEvdoEcio = s.mEvdoEcio;
    mEvdoSnr = s.mEvdoSnr;
    mLteSignalStrength = s.mLteSignalStrength;
    mLteRsrp = s.mLteRsrp;
    mLteRsrq = s.mLteRsrq;
    mLteRssnr = s.mLteRssnr;
    mLteCqi = s.mLteCqi;
    mLteRsrpBoost = s.mLteRsrpBoost;
    mTdScdmaRscp = s.mTdScdmaRscp;
    isGsm = s.isGsm;
}
Body of Second Method:
{
    mGsmSignalStrength = s.mGsmSignalStrength;
    mGsmBitErrorRate = s.mGsmBitErrorRate;
    mCdmaDbm = s.mCdmaDbm;
    mCdmaEcio = s.mCdmaEcio;
    mEvdoDbm = s.mEvdoDbm;
    mEvdoEcio = s.mEvdoEcio;
    mEvdoSnr = s.mEvdoSnr;
    mLteSignalStrength = s.mLteSignalStrength;
    mLteRsrp = s.mLteRsrp;
    mLteRsrq = s.mLteRsrq;
    mLteRssnr = s.mLteRssnr;
    mLteCqi = s.mLteCqi;
    mTdScdmaRscp = s.mTdScdmaRscp;
    mWcdmaSignalStrength = s.mWcdmaSignalStrength;
    mWcdmaRscpAsu = s.mWcdmaRscpAsu;
    mWcdmaRscp = s.mWcdmaRscp;
    mLteRsrpBoost = s.mLteRsrpBoost;
    mIsGsm = s.mIsGsm;
    mUseOnlyRsrpForLteLevel = s.mUseOnlyRsrpForLteLevel;
    mWcdmaDefaultSignalMeasurement = s.mWcdmaDefaultSignalMeasurement;
    setLteRsrpThresholds(s.mLteRsrpThresholds);
    setWcdmaRscpThresholds(s.mWcdmaRscpThresholds);
}
------------------------
Find a silently evolved API code:android.os.Debug.InstructionCount.globalMethodInvocations:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * Return the total number of method-invocation instructions
 * executed globally.
 */

Body of Frist Method:
{
    int count = 0;
    for (int i = 0; i < NUM_INSTR; i++) {
        if (OpcodeInfo.isInvoke(i)) {
            count += mCounts[i];
        }
    }
    return count;
}
Body of Second Method:
{
    return 0;
}
------------------------
Find a silently evolved API code:android.content.ContentResolver.getType:COMMENT
Method Modifier: public      final       
Comment:/**
 * Return the MIME type of the given content URL.
 *
 * @param url A Uri identifying content (either a list or specific type),
 * using the content:// scheme.
 * @return A MIME type for the content, or null if the URL is invalid or the type is unknown
 */

Body of Frist Method:
{
    Preconditions.checkNotNull(url, "url");
    // XXX would like to have an acquireExistingUnstableProvider for this.
    IContentProvider provider = acquireExistingProvider(url);
    if (provider != null) {
        try {
            return provider.getType(url);
        } catch (RemoteException e) {
            return null;
        } catch (java.lang.Exception e) {
            Log.w(TAG, "Failed to get type for: " + url + " (" + e.getMessage() + ")");
            return null;
        } finally {
            releaseProvider(provider);
        }
    }
    if (!SCHEME_CONTENT.equals(url.getScheme())) {
        return null;
    }
    try {
        String type = ActivityManager.getService().getProviderMimeType(ContentProvider.getUriWithoutUserId(url), resolveUserId(url));
        return type;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } catch (java.lang.Exception e) {
        Log.w(TAG, "Failed to get type for: " + url + " (" + e.getMessage() + ")");
        return null;
    }
}
Body of Second Method:
{
    Preconditions.checkNotNull(url, "url");
    // XXX would like to have an acquireExistingUnstableProvider for this.
    IContentProvider provider = acquireExistingProvider(url);
    if (provider != null) {
        try {
            return provider.getType(url);
        } catch (RemoteException e) {
            // Manager will kill this process shortly anyway.
            return null;
        } catch (java.lang.Exception e) {
            Log.w(TAG, "Failed to get type for: " + url + " (" + e.getMessage() + ")");
            return null;
        } finally {
            releaseProvider(provider);
        }
    }
    if (!SCHEME_CONTENT.equals(url.getScheme())) {
        return null;
    }
    try {
        String type = ActivityManager.getService().getProviderMimeType(ContentProvider.getUriWithoutUserId(url), resolveUserId(url));
        return type;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    } catch (java.lang.Exception e) {
        Log.w(TAG, "Failed to get type for: " + url + " (" + e.getMessage() + ")");
        return null;
    }
}
------------------------
Find a silently evolved API code:android.app.admin.SecurityLog.SecurityEvent.equals:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (this == o)
        return true;
    if (o == null || getClass() != o.getClass())
        return false;
    SecurityEvent other = (SecurityEvent) o;
    return mEvent.equals(other.mEvent);
}
Body of Second Method:
{
    if (this == o)
        return true;
    if (o == null || getClass() != o.getClass())
        return false;
    SecurityEvent other = (SecurityEvent) o;
    return mEvent.equals(other.mEvent) && mId == other.mId;
}
------------------------
Find a silently evolved API code:android.net.TrafficStats.getMobileTxBytes:COMMENT
Method Modifier: public      static      
Comment:/**
 * Return number of bytes transmitted across mobile networks since device
 * boot. Counts packets across all mobile network interfaces, and always
 * increases monotonically since device boot. Statistics are measured at the
 * network layer, so they include both TCP and UDP usage.
 * <p>
 * Before {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}, this may
 * return {@link #UNSUPPORTED} on devices where statistics aren't available.
 */

Body of Frist Method:
{
    long total = 0;
    for (String iface : getMobileIfaces()) {
        total += getTxBytes(iface);
    }
    return total;
}
Body of Second Method:
{
    long total = 0;
    for (String iface : getMobileIfaces()) {
        total += addIfSupported(getTxBytes(iface));
    }
    return total;
}
------------------------
Find a silently evolved API code:android.net.NetworkStats.groupedByIface:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Return total statistics grouped by {@link #iface}; doesn't mutate the
 * original structure.
 */

Body of Frist Method:
{
    final NetworkStats stats = new NetworkStats(elapsedRealtime, 10);
    final Entry entry = new Entry();
    entry.uid = UID_ALL;
    entry.set = SET_ALL;
    entry.tag = TAG_NONE;
    entry.metered = METERED_ALL;
    entry.roaming = ROAMING_ALL;
    entry.operations = 0L;
    for (int i = 0; i < size; i++) {
        // skip specific tags, since already counted in TAG_NONE
        if (tag[i] != TAG_NONE)
            continue;
        entry.iface = iface[i];
        entry.rxBytes = rxBytes[i];
        entry.rxPackets = rxPackets[i];
        entry.txBytes = txBytes[i];
        entry.txPackets = txPackets[i];
        stats.combineValues(entry);
    }
    return stats;
}
Body of Second Method:
{
    final NetworkStats stats = new NetworkStats(elapsedRealtime, 10);
    final Entry entry = new Entry();
    entry.uid = UID_ALL;
    entry.set = SET_ALL;
    entry.tag = TAG_NONE;
    entry.metered = METERED_ALL;
    entry.roaming = ROAMING_ALL;
    entry.defaultNetwork = DEFAULT_NETWORK_ALL;
    entry.operations = 0L;
    for (int i = 0; i < size; i++) {
        // skip specific tags, since already counted in TAG_NONE
        if (tag[i] != TAG_NONE)
            continue;
        entry.iface = iface[i];
        entry.rxBytes = rxBytes[i];
        entry.rxPackets = rxPackets[i];
        entry.txBytes = txBytes[i];
        entry.txPackets = txPackets[i];
        stats.combineValues(entry);
    }
    return stats;
}
------------------------
Find a silently evolved API code:android.net.VpnService.prepareAndAuthorize:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Version of {@link #prepare(Context)} which does not require user consent.
 *
 * <p>Requires {@link android.Manifest.permission#CONTROL_VPN} and should generally not be
 * used. Only acceptable in situations where user consent has been obtained through other means.
 *
 * <p>Once this is run, future preparations may be done with the standard prepare method as this
 * will authorize the package to prepare the VPN without consent in the future.
 *
 * @hide
 */

Body of Frist Method:
{
    IConnectivityManager cm = getService();
    String packageName = context.getPackageName();
    try {
        // Only prepare if we're not already prepared.
        int userId = UserHandle.myUserId();
        if (!cm.prepareVpn(packageName, null, userId)) {
            cm.prepareVpn(null, packageName, userId);
        }
        cm.setVpnPackageAuthorization(packageName, userId, true);
    } catch (RemoteException e) {
    // ignore
    }
}
Body of Second Method:
{
    IConnectivityManager cm = getService();
    String packageName = context.getPackageName();
    try {
        // Only prepare if we're not already prepared.
        int userId = context.getUserId();
        if (!cm.prepareVpn(packageName, null, userId)) {
            cm.prepareVpn(null, packageName, userId);
        }
        cm.setVpnPackageAuthorization(packageName, userId, true);
    } catch (RemoteException e) {
    // ignore
    }
}
------------------------
Find a silently evolved API code:android.util.proto.ProtoOutputStream.startObject:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * Start a child object.
 *
 * Returns a token which should be passed to endObject.  Calls to endObject must be
 * nested properly.
 *
 * @deprecated Use #start() instead.
 */

Body of Frist Method:
{
    assertNotCompacted();
    final int id = checkFieldId(fieldId, FIELD_COUNT_SINGLE | FIELD_TYPE_OBJECT);
    return startObjectImpl(id, false);
}
Body of Second Method:
{
    assertNotCompacted();
    final int id = checkFieldId(fieldId, FIELD_COUNT_SINGLE | FIELD_TYPE_MESSAGE);
    return startObjectImpl(id, false);
}
------------------------
Find a silently evolved API code:android.text.format.Formatter.formatShortElapsedTime:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Returns elapsed time for the given millis, in the following format:
 * 1 day, 5 hr; will include at most two units, can go down to seconds precision.
 * @param context the application context
 * @param millis the elapsed time in milli seconds
 * @return the formatted elapsed time
 * @hide
 */

Body of Frist Method:
{
    long secondsLong = millis / 1000;
    int days = 0, hours = 0, minutes = 0;
    if (secondsLong >= SECONDS_PER_DAY) {
        days = (int) (secondsLong / SECONDS_PER_DAY);
        secondsLong -= days * SECONDS_PER_DAY;
    }
    if (secondsLong >= SECONDS_PER_HOUR) {
        hours = (int) (secondsLong / SECONDS_PER_HOUR);
        secondsLong -= hours * SECONDS_PER_HOUR;
    }
    if (secondsLong >= SECONDS_PER_MINUTE) {
        minutes = (int) (secondsLong / SECONDS_PER_MINUTE);
        secondsLong -= minutes * SECONDS_PER_MINUTE;
    }
    int seconds = (int) secondsLong;
    final Locale locale = localeFromContext(context);
    final MeasureFormat measureFormat = MeasureFormat.getInstance(locale, MeasureFormat.FormatWidth.SHORT);
    if (days >= 2) {
        days += (hours + 12) / 24;
        return measureFormat.format(new Measure(days, MeasureUnit.DAY));
    } else if (days > 0) {
        return measureFormat.formatMeasures(new Measure(days, MeasureUnit.DAY), new Measure(hours, MeasureUnit.HOUR));
    } else if (hours >= 2) {
        hours += (minutes + 30) / 60;
        return measureFormat.format(new Measure(hours, MeasureUnit.HOUR));
    } else if (hours > 0) {
        return measureFormat.formatMeasures(new Measure(hours, MeasureUnit.HOUR), new Measure(minutes, MeasureUnit.MINUTE));
    } else if (minutes >= 2) {
        minutes += (seconds + 30) / 60;
        return measureFormat.format(new Measure(minutes, MeasureUnit.MINUTE));
    } else if (minutes > 0) {
        return measureFormat.formatMeasures(new Measure(minutes, MeasureUnit.MINUTE), new Measure(seconds, MeasureUnit.SECOND));
    } else {
        return measureFormat.format(new Measure(seconds, MeasureUnit.SECOND));
    }
}
Body of Second Method:
{
    long secondsLong = millis / 1000;
    int days = 0, hours = 0, minutes = 0;
    if (secondsLong >= SECONDS_PER_DAY) {
        days = (int) (secondsLong / SECONDS_PER_DAY);
        secondsLong -= days * SECONDS_PER_DAY;
    }
    if (secondsLong >= SECONDS_PER_HOUR) {
        hours = (int) (secondsLong / SECONDS_PER_HOUR);
        secondsLong -= hours * SECONDS_PER_HOUR;
    }
    if (secondsLong >= SECONDS_PER_MINUTE) {
        minutes = (int) (secondsLong / SECONDS_PER_MINUTE);
        secondsLong -= minutes * SECONDS_PER_MINUTE;
    }
    int seconds = (int) secondsLong;
    final Locale locale = localeFromContext(context);
    final MeasureFormat measureFormat = MeasureFormat.getInstance(locale, MeasureFormat.FormatWidth.SHORT);
    if (days >= 2 || (days > 0 && hours == 0)) {
        days += (hours + 12) / 24;
        return measureFormat.format(new Measure(days, MeasureUnit.DAY));
    } else if (days > 0) {
        return measureFormat.formatMeasures(new Measure(days, MeasureUnit.DAY), new Measure(hours, MeasureUnit.HOUR));
    } else if (hours >= 2 || (hours > 0 && minutes == 0)) {
        hours += (minutes + 30) / 60;
        return measureFormat.format(new Measure(hours, MeasureUnit.HOUR));
    } else if (hours > 0) {
        return measureFormat.formatMeasures(new Measure(hours, MeasureUnit.HOUR), new Measure(minutes, MeasureUnit.MINUTE));
    } else if (minutes >= 2 || (minutes > 0 && seconds == 0)) {
        minutes += (seconds + 30) / 60;
        return measureFormat.format(new Measure(minutes, MeasureUnit.MINUTE));
    } else if (minutes > 0) {
        return measureFormat.formatMeasures(new Measure(minutes, MeasureUnit.MINUTE), new Measure(seconds, MeasureUnit.SECOND));
    } else {
        return measureFormat.format(new Measure(seconds, MeasureUnit.SECOND));
    }
}
------------------------
Find a silently evolved API code:android.os.ServiceManager.listServices:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Return a list of all currently running services.
 * @return an array of all currently running services, or <code>null</code> in
 * case of an exception
 */

Body of Frist Method:
{
    try {
        return getIServiceManager().listServices();
    } catch (RemoteException e) {
        Log.e(TAG, "error in listServices", e);
        return null;
    }
}
Body of Second Method:
{
    try {
        return getIServiceManager().listServices(IServiceManager.DUMP_FLAG_PRIORITY_ALL);
    } catch (RemoteException e) {
        Log.e(TAG, "error in listServices", e);
        return null;
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.le.PeriodicAdvertisingReport.getData:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns the data contained in this periodic advertising report.
 */

Body of Frist Method:
{
    return data;
}
Body of Second Method:
{
    return mData;
}
------------------------
Find a silently evolved API code:android.app.usage.NetworkStatsManager.querySummaryForUser:COMMENT
Method Modifier: public      
Comment:/**
 * Query network usage statistics summaries. Result is summarised data usage for all uids
 * belonging to calling user. Result is a single Bucket aggregated over time, state and uid.
 * This means the bucket's start and end timestamp are going to be the same as the 'startTime'
 * and 'endTime' parameters. State is going to be {@link NetworkStats.Bucket#STATE_ALL},
 * uid {@link NetworkStats.Bucket#UID_ALL}, tag {@link NetworkStats.Bucket#TAG_NONE},
 * metered {@link NetworkStats.Bucket#METERED_ALL}, and roaming
 * {@link NetworkStats.Bucket#ROAMING_ALL}.
 *
 * @param networkType As defined in {@link ConnectivityManager}, e.g.
 * {@link ConnectivityManager#TYPE_MOBILE}, {@link ConnectivityManager#TYPE_WIFI}
 * etc.
 * @param subscriberId If applicable, the subscriber id of the network interface.
 * @param startTime Start of period. Defined in terms of "Unix time", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param endTime End of period. Defined in terms of "Unix time", see
 * {@link java.lang.System#currentTimeMillis}.
 * @return Bucket object or null if permissions are insufficient or error happened during
 * statistics collection.
 */

Body of Frist Method:
{
    NetworkTemplate template;
    try {
        template = createTemplate(networkType, subscriberId);
    } catch (IllegalArgumentException e) {
        if (DBG)
            Log.e(TAG, "Cannot create template", e);
        return null;
    }
    NetworkStats stats;
    stats = new NetworkStats(mContext, template, mFlags, startTime, endTime);
    stats.startSummaryEnumeration();
    stats.close();
    return stats.getSummaryAggregate();
}
Body of Second Method:
{
    NetworkTemplate template;
    try {
        template = createTemplate(networkType, subscriberId);
    } catch (IllegalArgumentException e) {
        if (DBG)
            Log.e(TAG, "Cannot create template", e);
        return null;
    }
    NetworkStats stats;
    stats = new NetworkStats(mContext, template, mFlags, startTime, endTime, mService);
    stats.startSummaryEnumeration();
    stats.close();
    return stats.getSummaryAggregate();
}
------------------------
Find a silently evolved API code:android.content.res.TypedArray.getBoolean:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the boolean value for the attribute at <var>index</var>.
 * <p>
 * If the attribute is an integer value, this method will return whether
 * it is equal to zero. If the attribute is not a boolean or integer value,
 * this method will attempt to coerce it to an integer using
 * {@link Integer#decode(String)} and return whether it is equal to zero.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * cannot be coerced to an integer.
 *
 * @return Boolean value of the attribute, or defValue if the attribute was
 * not defined or could not be coerced to an integer.
 * @throws RuntimeException if the TypedArray has already been recycled.
 */

Body of Frist Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + AssetManager.STYLE_DATA] != 0;
    }
    final TypedValue v = mValue;
    if (getValueAt(index, v)) {
        StrictMode.noteResourceMismatch(v);
        return XmlUtils.convertValueToBoolean(v.coerceToString(), defValue);
    }
    // We already checked for TYPE_NULL. This should never happen.
    throw new RuntimeException("getBoolean of bad type: 0x" + Integer.toHexString(type));
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    index *= STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + STYLE_DATA] != 0;
    }
    final TypedValue v = mValue;
    if (getValueAt(index, v)) {
        StrictMode.noteResourceMismatch(v);
        return XmlUtils.convertValueToBoolean(v.coerceToString(), defValue);
    }
    // We already checked for TYPE_NULL. This should never happen.
    throw new RuntimeException("getBoolean of bad type: 0x" + Integer.toHexString(type));
}
------------------------
Find a silently evolved API code:android.app.trust.TrustManager.registerTrustListener:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Registers a listener for trust events.
 *
 * Requires the {@link android.Manifest.permission#TRUST_LISTENER} permission.
 */

Body of Frist Method:
{
    try {
        ITrustListener.Stub iTrustListener = new ITrustListener.Stub() {

            @Override
            public void onTrustChanged(boolean enabled, int userId, int flags) {
                Message m = mHandler.obtainMessage(MSG_TRUST_CHANGED, (enabled ? 1 : 0), userId, trustListener);
                if (flags != 0) {
                    m.getData().putInt(DATA_FLAGS, flags);
                }
                m.sendToTarget();
            }

            @Override
            public void onTrustManagedChanged(boolean managed, int userId) {
                mHandler.obtainMessage(MSG_TRUST_MANAGED_CHANGED, (managed ? 1 : 0), userId, trustListener).sendToTarget();
            }
        };
        mService.registerTrustListener(iTrustListener);
        mTrustListeners.put(trustListener, iTrustListener);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    try {
        ITrustListener.Stub iTrustListener = new ITrustListener.Stub() {

            @Override
            public void onTrustChanged(boolean enabled, int userId, int flags) {
                Message m = mHandler.obtainMessage(MSG_TRUST_CHANGED, (enabled ? 1 : 0), userId, trustListener);
                if (flags != 0) {
                    m.getData().putInt(DATA_FLAGS, flags);
                }
                m.sendToTarget();
            }

            @Override
            public void onTrustManagedChanged(boolean managed, int userId) {
                mHandler.obtainMessage(MSG_TRUST_MANAGED_CHANGED, (managed ? 1 : 0), userId, trustListener).sendToTarget();
            }

            @Override
            public void onTrustError(CharSequence message) {
                Message m = mHandler.obtainMessage(MSG_TRUST_ERROR);
                m.getData().putCharSequence(DATA_MESSAGE, message);
                m.sendToTarget();
            }
        };
        mService.registerTrustListener(iTrustListener);
        mTrustListeners.put(trustListener, iTrustListener);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.content.res.TypedArray.hasValue:COMMENT
Method Modifier: public      
Comment:/**
 * Determines whether there is an attribute at <var>index</var>.
 * <p>
 * <strong>Note:</strong> If the attribute was set to {@code @empty} or
 * {@code @undefined}, this method returns {@code false}.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return True if the attribute has a value, false otherwise.
 * @throws RuntimeException if the TypedArray has already been recycled.
 */

Body of Frist Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    return type != TypedValue.TYPE_NULL;
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    index *= STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + STYLE_TYPE];
    return type != TypedValue.TYPE_NULL;
}
------------------------
Find a silently evolved API code:android.content.pm.ResolveInfo.loadIcon:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the current graphical icon associated with this resolution.  This
 * will call back on the given PackageManager to load the icon from
 * the application.
 *
 * @param pm A PackageManager from which the icon can be loaded; usually
 * the PackageManager from which you originally retrieved this item.
 *
 * @return Returns a Drawable containing the resolution's icon.  If the
 * item does not have an icon, the default activity icon is returned.
 */

Body of Frist Method:
{
    Drawable dr = null;
    if (resolvePackageName != null && iconResourceId != 0) {
        dr = pm.getDrawable(resolvePackageName, iconResourceId, null);
    }
    ComponentInfo ci = getComponentInfo();
    if (dr == null && iconResourceId != 0) {
        ApplicationInfo ai = ci.applicationInfo;
        dr = pm.getDrawable(ci.packageName, iconResourceId, ai);
    }
    if (dr != null) {
        return pm.getUserBadgedIcon(dr, new UserHandle(UserHandle.myUserId()));
    }
    return ci.loadIcon(pm);
}
Body of Second Method:
{
    Drawable dr = null;
    if (resolvePackageName != null && iconResourceId != 0) {
        dr = pm.getDrawable(resolvePackageName, iconResourceId, null);
    }
    ComponentInfo ci = getComponentInfo();
    if (dr == null && iconResourceId != 0) {
        ApplicationInfo ai = ci.applicationInfo;
        dr = pm.getDrawable(ci.packageName, iconResourceId, ai);
    }
    if (dr != null) {
        return pm.getUserBadgedIcon(dr, new UserHandle(pm.getUserId()));
    }
    return ci.loadIcon(pm);
}
------------------------
Find a silently evolved API code:android.text.SpannableStringBuilder.removeSpan:COMMENT
Method Modifier: public      
Comment:/**
 * Remove the specified markup object from the buffer.
 */

Body of Frist Method:
{
    if (mIndexOfSpan == null)
        return;
    Integer i = mIndexOfSpan.remove(what);
    if (i != null) {
        removeSpan(i.intValue());
    }
}
Body of Second Method:
{
    removeSpan(what, 0);
}
------------------------
Find a silently evolved API code:android.media.session.MediaController.TransportControls.fastForward:COMMENT
Method Modifier: public      
Comment:/**
 * Start fast forwarding. If playback is already fast forwarding this
 * may increase the rate.
 */

Body of Frist Method:
{
    try {
        mSessionBinder.fastForward();
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling fastForward.", e);
    }
}
Body of Second Method:
{
    try {
        mSessionBinder.fastForward(mContext.getPackageName(), mCbStub);
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling fastForward.", e);
    }
}
------------------------
Find a silently evolved API code:android.media.session.MediaController.sendCommand:COMMENT
Method Modifier: public      
Comment:/**
 * Sends a generic command to the session. It is up to the session creator
 * to decide what commands and parameters they will support. As such,
 * commands should only be sent to sessions that the controller owns.
 *
 * @param command The command to send
 * @param args Any parameters to include with the command
 * @param cb The callback to receive the result on
 */

Body of Frist Method:
{
    if (TextUtils.isEmpty(command)) {
        throw new IllegalArgumentException("command cannot be null or empty");
    }
    try {
        mSessionBinder.sendCommand(command, args, cb);
    } catch (RemoteException e) {
        Log.d(TAG, "Dead object in sendCommand.", e);
    }
}
Body of Second Method:
{
    if (TextUtils.isEmpty(command)) {
        throw new IllegalArgumentException("command cannot be null or empty");
    }
    try {
        mSessionBinder.sendCommand(mContext.getPackageName(), mCbStub, command, args, cb);
    } catch (RemoteException e) {
        Log.d(TAG, "Dead object in sendCommand.", e);
    }
}
------------------------
Find a silently evolved API code:android.net.LocalSocketImpl.SocketOutputStream.flush:COMMENT
Method Modifier: public      
Comment:/**
 * Wait until the data in sending queue is emptied. A polling version
 * for flush implementation.
 * @throws IOException
 * if an i/o error occurs.
 */

Body of Frist Method:
{
    FileDescriptor myFd = fd;
    if (myFd == null)
        throw new IOException("socket closed");
    // Loop until the output buffer is empty.
    MutableInt pending = new MutableInt(0);
    while (true) {
        try {
            // See linux/net/unix/af_unix.c
            Os.ioctlInt(myFd, OsConstants.TIOCOUTQ, pending);
        } catch (ErrnoException e) {
            throw e.rethrowAsIOException();
        }
        if (pending.value <= 0) {
            // The output buffer is empty.
            break;
        }
        try {
            Thread.sleep(10);
        } catch (InterruptedException ie) {
            break;
        }
    }
}
Body of Second Method:
{
    FileDescriptor myFd = fd;
    if (myFd == null)
        throw new IOException("socket closed");
    // Loop until the output buffer is empty.
    Int32Ref pending = new Int32Ref(0);
    while (true) {
        try {
            // See linux/net/unix/af_unix.c
            Os.ioctlInt(myFd, OsConstants.TIOCOUTQ, pending);
        } catch (ErrnoException e) {
            throw e.rethrowAsIOException();
        }
        if (pending.value <= 0) {
            // The output buffer is empty.
            break;
        }
        try {
            Thread.sleep(10);
        } catch (InterruptedException ie) {
            break;
        }
    }
}
------------------------
Find a silently evolved API code:android.text.Selection.removeSelection:COMMENT
Method Modifier: public      static      final       
Comment:/**
 * Remove the selection or cursor, if any, from the text.
 */

Body of Frist Method:
{
    text.removeSpan(SELECTION_START);
    text.removeSpan(SELECTION_END);
}
Body of Second Method:
{
    text.removeSpan(SELECTION_START, Spanned.SPAN_INTERMEDIATE);
    text.removeSpan(SELECTION_END);
    removeMemory(text);
}
------------------------
Find a silently evolved API code:android.bluetooth.le.PeriodicAdvertisingParameters.getInterval:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the periodic advertising interval, in 1.25ms unit.
 * Valid values are from 80 (100ms) to 65519 (81.89875s).
 */

Body of Frist Method:
{
    return interval;
}
Body of Second Method:
{
    return mInterval;
}
------------------------
Find a silently evolved API code:android.text.SpannableStringBuilder.removeSpansForChange:COMMENT
Method Modifier: private     
Comment:// Returns true if a node was removed (so we can restart search from root)

Body of Frist Method:
{
    if ((i & 1) != 0) {
        // internal tree node
        if (resolveGap(mSpanMax[i]) >= start && removeSpansForChange(start, end, textIsRemoved, leftChild(i))) {
            return true;
        }
    }
    if (i < mSpanCount) {
        if ((mSpanFlags[i] & Spanned.SPAN_EXCLUSIVE_EXCLUSIVE) == Spanned.SPAN_EXCLUSIVE_EXCLUSIVE && mSpanStarts[i] >= start && mSpanStarts[i] < mGapStart + mGapLength && mSpanEnds[i] >= start && mSpanEnds[i] < mGapStart + mGapLength && // The following condition indicates that the span would become empty
        (textIsRemoved || mSpanStarts[i] > start || mSpanEnds[i] < mGapStart)) {
            mIndexOfSpan.remove(mSpans[i]);
            removeSpan(i);
            return true;
        }
        return resolveGap(mSpanStarts[i]) <= end && (i & 1) != 0 && removeSpansForChange(start, end, textIsRemoved, rightChild(i));
    }
    return false;
}
Body of Second Method:
{
    if ((i & 1) != 0) {
        // internal tree node
        if (resolveGap(mSpanMax[i]) >= start && removeSpansForChange(start, end, textIsRemoved, leftChild(i))) {
            return true;
        }
    }
    if (i < mSpanCount) {
        if ((mSpanFlags[i] & Spanned.SPAN_EXCLUSIVE_EXCLUSIVE) == Spanned.SPAN_EXCLUSIVE_EXCLUSIVE && mSpanStarts[i] >= start && mSpanStarts[i] < mGapStart + mGapLength && mSpanEnds[i] >= start && mSpanEnds[i] < mGapStart + mGapLength && // The following condition indicates that the span would become empty
        (textIsRemoved || mSpanStarts[i] > start || mSpanEnds[i] < mGapStart)) {
            mIndexOfSpan.remove(mSpans[i]);
            removeSpan(i, 0);
            return true;
        }
        return resolveGap(mSpanStarts[i]) <= end && (i & 1) != 0 && removeSpansForChange(start, end, textIsRemoved, rightChild(i));
    }
    return false;
}
------------------------
Find a silently evolved API code:android.os.Debug.MemoryInfo.getOtherSwappablePss:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return otherStats[which * NUM_CATEGORIES + offsetSwappablePss];
}
Body of Second Method:
{
    return otherStats[which * NUM_CATEGORIES + OFFSET_SWAPPABLE_PSS];
}
------------------------
Find a silently evolved API code:android.media.AudioFormat.isEncodingLinearPcm:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    switch(audioFormat) {
        case ENCODING_PCM_8BIT:
        case ENCODING_PCM_16BIT:
        case ENCODING_PCM_FLOAT:
        case ENCODING_DEFAULT:
            return true;
        case ENCODING_AC3:
        case ENCODING_E_AC3:
        case ENCODING_DTS:
        case ENCODING_DTS_HD:
        case ENCODING_MP3:
        case ENCODING_AAC_LC:
        case ENCODING_AAC_HE_V1:
        case ENCODING_AAC_HE_V2:
        case // wrapped in PCM but compressed
        ENCODING_IEC61937:
            return false;
        case ENCODING_INVALID:
        default:
            throw new IllegalArgumentException("Bad audio format " + audioFormat);
    }
}
Body of Second Method:
{
    switch(audioFormat) {
        case ENCODING_PCM_8BIT:
        case ENCODING_PCM_16BIT:
        case ENCODING_PCM_FLOAT:
        case ENCODING_DEFAULT:
            return true;
        case ENCODING_AC3:
        case ENCODING_E_AC3:
        case ENCODING_E_AC3_JOC:
        case ENCODING_DTS:
        case ENCODING_DTS_HD:
        case ENCODING_MP3:
        case ENCODING_AAC_LC:
        case ENCODING_AAC_HE_V1:
        case ENCODING_AAC_HE_V2:
        // wrapped in PCM but compressed
        case ENCODING_IEC61937:
        case ENCODING_AAC_ELD:
        case ENCODING_AAC_XHE:
        case ENCODING_AC4:
            return false;
        case ENCODING_INVALID:
        default:
            throw new IllegalArgumentException("Bad audio format " + audioFormat);
    }
}
------------------------
Find a silently evolved API code:android.service.autofill.LuhnChecksumValidator.isValid:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (mIds == null || mIds.length == 0)
        return false;
    final StringBuilder number = new StringBuilder();
    for (AutofillId id : mIds) {
        final String partialNumber = finder.findByAutofillId(id);
        if (partialNumber == null) {
            if (sDebug)
                Log.d(TAG, "No partial number for id " + id);
            return false;
        }
        number.append(partialNumber);
    }
    return isLuhnChecksumValid(number.toString());
}
Body of Second Method:
{
    if (mIds == null || mIds.length == 0)
        return false;
    final StringBuilder builder = new StringBuilder();
    for (AutofillId id : mIds) {
        final String partialNumber = finder.findByAutofillId(id);
        if (partialNumber == null) {
            if (sDebug)
                Log.d(TAG, "No partial number for id " + id);
            return false;
        }
        builder.append(partialNumber);
    }
    final String number = builder.toString();
    boolean valid = isLuhnChecksumValid(number);
    if (sDebug)
        Log.d(TAG, "isValid(" + number.length() + " chars): " + valid);
    return valid;
}
------------------------
Find a silently evolved API code:android.util.proto.ProtoOutputStream.startRepeatedObject:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * Start a repeated child object.
 *
 * Returns a token which should be passed to endObject.  Calls to endObject must be
 * nested properly.
 *
 * @deprecated Use #start() instead.
 */

Body of Frist Method:
{
    assertNotCompacted();
    final int id = checkFieldId(fieldId, FIELD_COUNT_REPEATED | FIELD_TYPE_OBJECT);
    return startObjectImpl(id, true);
}
Body of Second Method:
{
    assertNotCompacted();
    final int id = checkFieldId(fieldId, FIELD_COUNT_REPEATED | FIELD_TYPE_MESSAGE);
    return startObjectImpl(id, true);
}
------------------------
Find a silently evolved API code:android.text.Selection.getSelectionEnd:COMMENT
Method Modifier: public      static      final       
Comment:/**
 * Return the offset of the selection edge or cursor, or -1 if
 * there is no selection or cursor.
 */

Body of Frist Method:
{
    if (text instanceof Spanned)
        return ((Spanned) text).getSpanStart(SELECTION_END);
    else
        return -1;
}
Body of Second Method:
{
    if (text instanceof Spanned) {
        return ((Spanned) text).getSpanStart(SELECTION_END);
    }
    return -1;
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiConfiguration.writeToParcel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Implement the Parcelable interface {@hide}
 */

Body of Frist Method:
{
    dest.writeInt(networkId);
    dest.writeInt(status);
    mNetworkSelectionStatus.writeToParcel(dest);
    dest.writeString(SSID);
    dest.writeString(BSSID);
    dest.writeInt(apBand);
    dest.writeInt(apChannel);
    dest.writeString(FQDN);
    dest.writeString(providerFriendlyName);
    dest.writeInt(isHomeProviderNetwork ? 1 : 0);
    dest.writeInt(roamingConsortiumIds.length);
    for (long roamingConsortiumId : roamingConsortiumIds) {
        dest.writeLong(roamingConsortiumId);
    }
    dest.writeString(preSharedKey);
    for (String wepKey : wepKeys) {
        dest.writeString(wepKey);
    }
    dest.writeInt(wepTxKeyIndex);
    dest.writeInt(priority);
    dest.writeInt(hiddenSSID ? 1 : 0);
    dest.writeInt(requirePMF ? 1 : 0);
    dest.writeString(updateIdentifier);
    writeBitSet(dest, allowedKeyManagement);
    writeBitSet(dest, allowedProtocols);
    writeBitSet(dest, allowedAuthAlgorithms);
    writeBitSet(dest, allowedPairwiseCiphers);
    writeBitSet(dest, allowedGroupCiphers);
    dest.writeParcelable(enterpriseConfig, flags);
    dest.writeParcelable(mIpConfiguration, flags);
    dest.writeString(dhcpServer);
    dest.writeString(defaultGwMacAddress);
    dest.writeInt(selfAdded ? 1 : 0);
    dest.writeInt(didSelfAdd ? 1 : 0);
    dest.writeInt(validatedInternetAccess ? 1 : 0);
    dest.writeInt(isLegacyPasspointConfig ? 1 : 0);
    dest.writeInt(ephemeral ? 1 : 0);
    dest.writeInt(meteredHint ? 1 : 0);
    dest.writeInt(meteredOverride);
    dest.writeInt(useExternalScores ? 1 : 0);
    dest.writeInt(creatorUid);
    dest.writeInt(lastConnectUid);
    dest.writeInt(lastUpdateUid);
    dest.writeString(creatorName);
    dest.writeString(lastUpdateName);
    dest.writeLong(lastConnectionFailure);
    dest.writeLong(lastRoamingFailure);
    dest.writeInt(lastRoamingFailureReason);
    dest.writeLong(roamingFailureBlackListTimeMilli);
    dest.writeInt(numScorerOverride);
    dest.writeInt(numScorerOverrideAndSwitchedNetwork);
    dest.writeInt(numAssociation);
    dest.writeInt(userApproved);
    dest.writeInt(numNoInternetAccessReports);
    dest.writeInt(noInternetAccessExpected ? 1 : 0);
    dest.writeInt(shared ? 1 : 0);
    dest.writeString(mPasspointManagementObjectTree);
    dest.writeInt(recentFailure.getAssociationStatus());
}
Body of Second Method:
{
    dest.writeInt(networkId);
    dest.writeInt(status);
    mNetworkSelectionStatus.writeToParcel(dest);
    dest.writeString(SSID);
    dest.writeString(BSSID);
    dest.writeInt(apBand);
    dest.writeInt(apChannel);
    dest.writeString(FQDN);
    dest.writeString(providerFriendlyName);
    dest.writeInt(isHomeProviderNetwork ? 1 : 0);
    dest.writeInt(roamingConsortiumIds.length);
    for (long roamingConsortiumId : roamingConsortiumIds) {
        dest.writeLong(roamingConsortiumId);
    }
    dest.writeString(preSharedKey);
    for (String wepKey : wepKeys) {
        dest.writeString(wepKey);
    }
    dest.writeInt(wepTxKeyIndex);
    dest.writeInt(priority);
    dest.writeInt(hiddenSSID ? 1 : 0);
    dest.writeInt(requirePMF ? 1 : 0);
    dest.writeString(updateIdentifier);
    writeBitSet(dest, allowedKeyManagement);
    writeBitSet(dest, allowedProtocols);
    writeBitSet(dest, allowedAuthAlgorithms);
    writeBitSet(dest, allowedPairwiseCiphers);
    writeBitSet(dest, allowedGroupCiphers);
    dest.writeParcelable(enterpriseConfig, flags);
    dest.writeParcelable(mIpConfiguration, flags);
    dest.writeString(dhcpServer);
    dest.writeString(defaultGwMacAddress);
    dest.writeInt(selfAdded ? 1 : 0);
    dest.writeInt(didSelfAdd ? 1 : 0);
    dest.writeInt(validatedInternetAccess ? 1 : 0);
    dest.writeInt(isLegacyPasspointConfig ? 1 : 0);
    dest.writeInt(ephemeral ? 1 : 0);
    dest.writeInt(meteredHint ? 1 : 0);
    dest.writeInt(meteredOverride);
    dest.writeInt(useExternalScores ? 1 : 0);
    dest.writeInt(creatorUid);
    dest.writeInt(lastConnectUid);
    dest.writeInt(lastUpdateUid);
    dest.writeString(creatorName);
    dest.writeString(lastUpdateName);
    dest.writeInt(numScorerOverride);
    dest.writeInt(numScorerOverrideAndSwitchedNetwork);
    dest.writeInt(numAssociation);
    dest.writeInt(userApproved);
    dest.writeInt(numNoInternetAccessReports);
    dest.writeInt(noInternetAccessExpected ? 1 : 0);
    dest.writeInt(shared ? 1 : 0);
    dest.writeString(mPasspointManagementObjectTree);
    dest.writeInt(recentFailure.getAssociationStatus());
    dest.writeParcelable(mRandomizedMacAddress, flags);
}
------------------------
Find a silently evolved API code:android.nfc.cardemulation.CardEmulation.removeAidsForService:COMMENT
Method Modifier: public      
Comment:/**
 * Removes a previously registered list of AIDs for the specified category for the
 * service provided.
 *
 * <p>Note that this will only remove AIDs that were dynamically
 * registered using the {@link #registerAidsForService(ComponentName, String, List)}
 * method. It will *not* remove AIDs that were statically registered in
 * the manifest. If dynamically registered AIDs are removed using
 * this method, and a statically registered AID group for the same category
 * exists in the manifest, the static AID group will become active again.
 *
 * @param service The component name of the service
 * @param category The category of the AIDs to be removed, e.g. {@link #CATEGORY_PAYMENT}
 * @return whether the group was successfully removed.
 */

Body of Frist Method:
{
    try {
        return sService.removeAidGroupForService(UserHandle.myUserId(), service, category);
    } catch (RemoteException e) {
        // Try one more time
        recoverService();
        if (sService == null) {
            Log.e(TAG, "Failed to recover CardEmulationService.");
            return false;
        }
        try {
            return sService.removeAidGroupForService(UserHandle.myUserId(), service, category);
        } catch (RemoteException ee) {
            Log.e(TAG, "Failed to reach CardEmulationService.");
            return false;
        }
    }
}
Body of Second Method:
{
    try {
        return sService.removeAidGroupForService(mContext.getUserId(), service, category);
    } catch (RemoteException e) {
        // Try one more time
        recoverService();
        if (sService == null) {
            Log.e(TAG, "Failed to recover CardEmulationService.");
            return false;
        }
        try {
            return sService.removeAidGroupForService(mContext.getUserId(), service, category);
        } catch (RemoteException ee) {
            Log.e(TAG, "Failed to reach CardEmulationService.");
            return false;
        }
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.le.PeriodicAdvertisingReport.getTxPower:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns the transmit power in dBm. The valid range is [-127, 126]. Value
 * of 127 means information was not available.
 */

Body of Frist Method:
{
    return txPower;
}
Body of Second Method:
{
    return mTxPower;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothServerSocket.setServiceName:COMMENT
Method Modifier: default     
Comment:/*package*/

Body of Frist Method:
{
    mSocket.setServiceName(ServiceName);
}
Body of Second Method:
{
    mSocket.setServiceName(serviceName);
}
------------------------
Find a silently evolved API code:android.os.Debug.InstructionCount.globalTotal:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * Return the total number of instructions executed globally (i.e. in
 * all threads).
 */

Body of Frist Method:
{
    int count = 0;
    for (int i = 0; i < NUM_INSTR; i++) {
        count += mCounts[i];
    }
    return count;
}
Body of Second Method:
{
    return 0;
}
------------------------
Find a silently evolved API code:android.net.Uri.StringUri.parsePath:COMMENT
Method Modifier: default     static      
Comment:/**
 * Parses a path out of this given URI string.
 *
 * @param uriString URI string
 * @param ssi scheme separator index, -1 for a relative URI
 *
 * @return the path
 */

Body of Frist Method:
{
    int length = uriString.length();
    // Find start of path.
    int pathStart;
    if (length > ssi + 2 && uriString.charAt(ssi + 1) == '/' && uriString.charAt(ssi + 2) == '/') {
        // Skip over authority to path.
        pathStart = ssi + 3;
        LOOP: while (pathStart < length) {
            switch(uriString.charAt(pathStart)) {
                // Start of query
                case '?':
                case // Start of fragment
                '#':
                    // Empty path.
                    return "";
                case // Start of path!
                '/':
                    break LOOP;
            }
            pathStart++;
        }
    } else {
        // Path starts immediately after scheme separator.
        pathStart = ssi + 1;
    }
    // Find end of path.
    int pathEnd = pathStart;
    LOOP: while (pathEnd < length) {
        switch(uriString.charAt(pathEnd)) {
            // Start of query
            case '?':
            case // Start of fragment
            '#':
                break LOOP;
        }
        pathEnd++;
    }
    return uriString.substring(pathStart, pathEnd);
}
Body of Second Method:
{
    int length = uriString.length();
    // Find start of path.
    int pathStart;
    if (length > ssi + 2 && uriString.charAt(ssi + 1) == '/' && uriString.charAt(ssi + 2) == '/') {
        // Skip over authority to path.
        pathStart = ssi + 3;
        LOOP: while (pathStart < length) {
            switch(uriString.charAt(pathStart)) {
                // Start of query
                case '?':
                case // Start of fragment
                '#':
                    // Empty path.
                    return "";
                // Start of path!
                case '/':
                case // Start of path!
                '\\':
                    // host
                    break LOOP;
            }
            pathStart++;
        }
    } else {
        // Path starts immediately after scheme separator.
        pathStart = ssi + 1;
    }
    // Find end of path.
    int pathEnd = pathStart;
    LOOP: while (pathEnd < length) {
        switch(uriString.charAt(pathEnd)) {
            // Start of query
            case '?':
            case // Start of fragment
            '#':
                break LOOP;
        }
        pathEnd++;
    }
    return uriString.substring(pathStart, pathEnd);
}
------------------------
Find a silently evolved API code:android.view.accessibility.AccessibilityWindowInfo.setPictureInPicture:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    mInPictureInPicture = pictureInPicture;
}
Body of Second Method:
{
    setBooleanProperty(BOOLEAN_PROPERTY_PICTURE_IN_PICTURE, pictureInPicture);
}
------------------------
Find a silently evolved API code:android.nfc.cardemulation.NfcFCardEmulation.getNfcFServices:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    try {
        return sService.getNfcFServices(UserHandle.myUserId());
    } catch (RemoteException e) {
        // Try one more time
        recoverService();
        if (sService == null) {
            Log.e(TAG, "Failed to recover CardEmulationService.");
            return null;
        }
        try {
            return sService.getNfcFServices(UserHandle.myUserId());
        } catch (RemoteException ee) {
            Log.e(TAG, "Failed to reach CardEmulationService.");
            return null;
        }
    }
}
Body of Second Method:
{
    try {
        return sService.getNfcFServices(mContext.getUserId());
    } catch (RemoteException e) {
        // Try one more time
        recoverService();
        if (sService == null) {
            Log.e(TAG, "Failed to recover CardEmulationService.");
            return null;
        }
        try {
            return sService.getNfcFServices(mContext.getUserId());
        } catch (RemoteException ee) {
            Log.e(TAG, "Failed to reach CardEmulationService.");
            return null;
        }
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.le.AdvertisingSetParameters.includeTxPower:COMMENT
Method Modifier: public      
Comment:/**
 * Returns whether the TX Power will be included.
 */

Body of Frist Method:
{
    return includeTxPower;
}
Body of Second Method:
{
    return mIncludeTxPower;
}
------------------------
Find a silently evolved API code:android.media.audiopolicy.AudioPolicy.createAudioRecordSink:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Create an {@link AudioRecord} instance that is associated with the given {@link AudioMix}.
 * Audio buffers recorded through the created instance will contain the mix of the audio
 * streams that fed the given mixer.
 * @param mix a non-null {@link AudioMix} instance whose routing flags was defined with
 * {@link AudioMix#ROUTE_FLAG_LOOP_BACK}, previously added to this policy.
 * @return a new {@link AudioRecord} instance whose data format is the one defined in the
 * {@link AudioMix}, or null if this policy was not successfully registered
 * with {@link AudioManager#registerAudioPolicy(AudioPolicy)}.
 * @throws IllegalArgumentException
 */

Body of Frist Method:
{
    if (!policyReadyToUse()) {
        Log.e(TAG, "Cannot create AudioRecord sink for AudioMix");
        return null;
    }
    checkMixReadyToUse(mix, false);
    // create an AudioFormat from the mix format compatible with recording, as the mix
    // was defined for playback
    AudioFormat mixFormat = new AudioFormat.Builder(mix.getFormat()).setChannelMask(AudioFormat.inChannelMaskFromOutChannelMask(mix.getFormat().getChannelMask())).build();
    // create the AudioRecord, configured for loop back, using the same format as the mix
    AudioRecord ar = new AudioRecord(new AudioAttributes.Builder().setInternalCapturePreset(MediaRecorder.AudioSource.REMOTE_SUBMIX).addTag(addressForTag(mix)).build(), mixFormat, AudioRecord.getMinBufferSize(mix.getFormat().getSampleRate(), // using stereo for buffer size to avoid the current poor support for masks
    AudioFormat.CHANNEL_IN_STEREO, mix.getFormat().getEncoding()), AudioManager.AUDIO_SESSION_ID_GENERATE);
    return ar;
}
Body of Second Method:
{
    if (!policyReadyToUse()) {
        Log.e(TAG, "Cannot create AudioRecord sink for AudioMix");
        return null;
    }
    checkMixReadyToUse(mix, false);
    // create an AudioFormat from the mix format compatible with recording, as the mix
    // was defined for playback
    AudioFormat mixFormat = new AudioFormat.Builder(mix.getFormat()).setChannelMask(AudioFormat.inChannelMaskFromOutChannelMask(mix.getFormat().getChannelMask())).build();
    // create the AudioRecord, configured for loop back, using the same format as the mix
    AudioRecord ar = new AudioRecord(new AudioAttributes.Builder().setInternalCapturePreset(MediaRecorder.AudioSource.REMOTE_SUBMIX).addTag(addressForTag(mix)).addTag(AudioRecord.SUBMIX_FIXED_VOLUME).build(), mixFormat, AudioRecord.getMinBufferSize(mix.getFormat().getSampleRate(), // using stereo for buffer size to avoid the current poor support for masks
    AudioFormat.CHANNEL_IN_STEREO, mix.getFormat().getEncoding()), AudioManager.AUDIO_SESSION_ID_GENERATE);
    return ar;
}
------------------------
Find a silently evolved API code:android.net.wifi.ScanResult.writeToParcel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Implement the Parcelable interface {@hide}
 */

Body of Frist Method:
{
    if (wifiSsid != null) {
        dest.writeInt(1);
        wifiSsid.writeToParcel(dest, flags);
    } else {
        dest.writeInt(0);
    }
    dest.writeString(SSID);
    dest.writeString(BSSID);
    dest.writeLong(hessid);
    dest.writeInt(anqpDomainId);
    dest.writeString(capabilities);
    dest.writeInt(level);
    dest.writeInt(frequency);
    dest.writeLong(timestamp);
    dest.writeInt(distanceCm);
    dest.writeInt(distanceSdCm);
    dest.writeInt(channelWidth);
    dest.writeInt(centerFreq0);
    dest.writeInt(centerFreq1);
    dest.writeLong(seen);
    dest.writeInt(untrusted ? 1 : 0);
    dest.writeInt(numConnection);
    dest.writeInt(numUsage);
    dest.writeInt(numIpConfigFailures);
    dest.writeString((venueName != null) ? venueName.toString() : "");
    dest.writeString((operatorFriendlyName != null) ? operatorFriendlyName.toString() : "");
    dest.writeLong(this.flags);
    if (informationElements != null) {
        dest.writeInt(informationElements.length);
        for (int i = 0; i < informationElements.length; i++) {
            dest.writeInt(informationElements[i].id);
            dest.writeInt(informationElements[i].bytes.length);
            dest.writeByteArray(informationElements[i].bytes);
        }
    } else {
        dest.writeInt(0);
    }
    if (anqpLines != null) {
        dest.writeInt(anqpLines.size());
        for (int i = 0; i < anqpLines.size(); i++) {
            dest.writeString(anqpLines.get(i));
        }
    } else {
        dest.writeInt(0);
    }
    if (anqpElements != null) {
        dest.writeInt(anqpElements.length);
        for (AnqpInformationElement element : anqpElements) {
            dest.writeInt(element.getVendorId());
            dest.writeInt(element.getElementId());
            dest.writeInt(element.getPayload().length);
            dest.writeByteArray(element.getPayload());
        }
    } else {
        dest.writeInt(0);
    }
    dest.writeInt(isCarrierAp ? 1 : 0);
    dest.writeInt(carrierApEapType);
    dest.writeString(carrierName);
}
Body of Second Method:
{
    if (wifiSsid != null) {
        dest.writeInt(1);
        wifiSsid.writeToParcel(dest, flags);
    } else {
        dest.writeInt(0);
    }
    dest.writeString(SSID);
    dest.writeString(BSSID);
    dest.writeLong(hessid);
    dest.writeInt(anqpDomainId);
    dest.writeString(capabilities);
    dest.writeInt(level);
    dest.writeInt(frequency);
    dest.writeLong(timestamp);
    dest.writeInt(distanceCm);
    dest.writeInt(distanceSdCm);
    dest.writeInt(channelWidth);
    dest.writeInt(centerFreq0);
    dest.writeInt(centerFreq1);
    dest.writeLong(seen);
    dest.writeInt(untrusted ? 1 : 0);
    dest.writeInt(numUsage);
    dest.writeString((venueName != null) ? venueName.toString() : "");
    dest.writeString((operatorFriendlyName != null) ? operatorFriendlyName.toString() : "");
    dest.writeLong(this.flags);
    if (informationElements != null) {
        dest.writeInt(informationElements.length);
        for (int i = 0; i < informationElements.length; i++) {
            dest.writeInt(informationElements[i].id);
            dest.writeInt(informationElements[i].bytes.length);
            dest.writeByteArray(informationElements[i].bytes);
        }
    } else {
        dest.writeInt(0);
    }
    if (anqpLines != null) {
        dest.writeInt(anqpLines.size());
        for (int i = 0; i < anqpLines.size(); i++) {
            dest.writeString(anqpLines.get(i));
        }
    } else {
        dest.writeInt(0);
    }
    if (anqpElements != null) {
        dest.writeInt(anqpElements.length);
        for (AnqpInformationElement element : anqpElements) {
            dest.writeInt(element.getVendorId());
            dest.writeInt(element.getElementId());
            dest.writeInt(element.getPayload().length);
            dest.writeByteArray(element.getPayload());
        }
    } else {
        dest.writeInt(0);
    }
    dest.writeInt(isCarrierAp ? 1 : 0);
    dest.writeInt(carrierApEapType);
    dest.writeString(carrierName);
    if (radioChainInfos != null) {
        dest.writeInt(radioChainInfos.length);
        for (int i = 0; i < radioChainInfos.length; i++) {
            dest.writeInt(radioChainInfos[i].id);
            dest.writeInt(radioChainInfos[i].level);
        }
    } else {
        dest.writeInt(0);
    }
}
------------------------
Find a silently evolved API code:android.content.res.TypedArray.getText:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieves the styled string value for the attribute at <var>index</var>.
 * <p>
 * If the attribute is not a string, this method will attempt to coerce
 * it to a string.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return CharSequence holding string data. May be styled. Returns
 * {@code null} if the attribute is not defined or could not be
 * coerced to a string.
 * @throws RuntimeException if the TypedArray has already been recycled.
 */

Body of Frist Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return null;
    } else if (type == TypedValue.TYPE_STRING) {
        return loadStringValueAt(index);
    }
    final TypedValue v = mValue;
    if (getValueAt(index, v)) {
        return v.coerceToString();
    }
    // We already checked for TYPE_NULL. This should never happen.
    throw new RuntimeException("getText of bad type: 0x" + Integer.toHexString(type));
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    index *= STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return null;
    } else if (type == TypedValue.TYPE_STRING) {
        return loadStringValueAt(index);
    }
    final TypedValue v = mValue;
    if (getValueAt(index, v)) {
        return v.coerceToString();
    }
    // We already checked for TYPE_NULL. This should never happen.
    throw new RuntimeException("getText of bad type: 0x" + Integer.toHexString(type));
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothSocket.write:COMMENT
Method Modifier: default     
Comment:/*package*/

Body of Frist Method:
{
    // to the actual message length.
    if (VDBG)
        Log.d(TAG, "write: " + mSocketOS + " length: " + length);
    if (mType == TYPE_L2CAP) {
        if (length <= mMaxTxPacketSize) {
            mSocketOS.write(b, offset, length);
        } else {
            if (DBG)
                Log.w(TAG, "WARNING: Write buffer larger than L2CAP packet size!\n" + "Packet will be divided into SDU packets of size " + mMaxTxPacketSize);
            int tmpOffset = offset;
            int bytesToWrite = length;
            while (bytesToWrite > 0) {
                int tmpLength = (bytesToWrite > mMaxTxPacketSize) ? mMaxTxPacketSize : bytesToWrite;
                mSocketOS.write(b, tmpOffset, tmpLength);
                tmpOffset += tmpLength;
                bytesToWrite -= tmpLength;
            }
        }
    } else {
        mSocketOS.write(b, offset, length);
    }
    // There is no good way to confirm since the entire process is asynchronous anyway
    if (VDBG)
        Log.d(TAG, "write out: " + mSocketOS + " length: " + length);
    return length;
}
Body of Second Method:
{
    // to the actual message length.
    if (VDBG)
        Log.d(TAG, "write: " + mSocketOS + " length: " + length);
    if ((mType == TYPE_L2CAP) || (mType == TYPE_L2CAP_LE)) {
        if (length <= mMaxTxPacketSize) {
            mSocketOS.write(b, offset, length);
        } else {
            if (DBG) {
                Log.w(TAG, "WARNING: Write buffer larger than L2CAP packet size!\n" + "Packet will be divided into SDU packets of size " + mMaxTxPacketSize);
            }
            int tmpOffset = offset;
            int bytesToWrite = length;
            while (bytesToWrite > 0) {
                int tmpLength = (bytesToWrite > mMaxTxPacketSize) ? mMaxTxPacketSize : bytesToWrite;
                mSocketOS.write(b, tmpOffset, tmpLength);
                tmpOffset += tmpLength;
                bytesToWrite -= tmpLength;
            }
        }
    } else {
        mSocketOS.write(b, offset, length);
    }
    // There is no good way to confirm since the entire process is asynchronous anyway
    if (VDBG)
        Log.d(TAG, "write out: " + mSocketOS + " length: " + length);
    return length;
}
------------------------
Find a silently evolved API code:android.telephony.euicc.EuiccManager.isEnabled:COMMENT
<android.telephony.euicc.EuiccManager: boolean isEnabled()>
public      hidden      ->public      
Method Modifier: public      hidden      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * Whether embedded subscriptions are currently enabled.
 *
 * <p>Even on devices with the {@link PackageManager#FEATURE_TELEPHONY_EUICC} feature, embedded
 * subscriptions may be turned off, e.g. because of a carrier restriction from an inserted
 * physical SIM. Therefore, this runtime check should be used before accessing embedded
 * subscription APIs.
 *
 * @return true if embedded subscriptions are currently enabled.
 */

Body of Frist Method:
{
    // restrictions.
    return mController != null;
}
Body of Second Method:
{
    // restrictions.
    return getIEuiccController() != null;
}
------------------------
Find a silently evolved API code:android.hardware.camera2.CaptureRequest.getNativeCopy:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns a copy of the underlying {@link CameraMetadataNative}.
 * @hide
 */

Body of Frist Method:
{
    return new CameraMetadataNative(mSettings);
}
Body of Second Method:
{
    return new CameraMetadataNative(mLogicalCameraSettings);
}
------------------------
Find a silently evolved API code:android.util.proto.ProtoOutputStream.writeRepeatedObject:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * Write an object that has already been flattend.
 *
 * @deprecated Use #write instead.
 */

Body of Frist Method:
{
    assertNotCompacted();
    final int id = checkFieldId(fieldId, FIELD_COUNT_REPEATED | FIELD_TYPE_OBJECT);
    writeRepeatedObjectImpl(id, value);
}
Body of Second Method:
{
    assertNotCompacted();
    final int id = checkFieldId(fieldId, FIELD_COUNT_REPEATED | FIELD_TYPE_MESSAGE);
    writeRepeatedObjectImpl(id, value);
}
------------------------
Find a silently evolved API code:android.media.AudioFormat.isValidEncoding:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    switch(audioFormat) {
        case ENCODING_PCM_8BIT:
        case ENCODING_PCM_16BIT:
        case ENCODING_PCM_FLOAT:
        case ENCODING_AC3:
        case ENCODING_E_AC3:
        case ENCODING_DTS:
        case ENCODING_DTS_HD:
        case ENCODING_MP3:
        case ENCODING_AAC_LC:
        case ENCODING_AAC_HE_V1:
        case ENCODING_AAC_HE_V2:
        case ENCODING_IEC61937:
            return true;
        default:
            return false;
    }
}
Body of Second Method:
{
    switch(audioFormat) {
        case ENCODING_PCM_8BIT:
        case ENCODING_PCM_16BIT:
        case ENCODING_PCM_FLOAT:
        case ENCODING_AC3:
        case ENCODING_E_AC3:
        case ENCODING_E_AC3_JOC:
        case ENCODING_DTS:
        case ENCODING_DTS_HD:
        case ENCODING_MP3:
        case ENCODING_AAC_LC:
        case ENCODING_AAC_HE_V1:
        case ENCODING_AAC_HE_V2:
        case ENCODING_IEC61937:
        case ENCODING_AAC_ELD:
        case ENCODING_AAC_XHE:
        case ENCODING_AC4:
            return true;
        default:
            return false;
    }
}
------------------------
Find a silently evolved API code:android.media.session.MediaController.TransportControls.setRating:COMMENT
Method Modifier: public      
Comment:/**
 * Rate the current content. This will cause the rating to be set for
 * the current user. The Rating type must match the type returned by
 * {@link #getRatingType()}.
 *
 * @param rating The rating to set for the current content
 */

Body of Frist Method:
{
    try {
        mSessionBinder.rate(rating);
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling rate.", e);
    }
}
Body of Second Method:
{
    try {
        mSessionBinder.rate(mContext.getPackageName(), mCbStub, rating);
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling rate.", e);
    }
}
------------------------
Find a silently evolved API code:android.graphics.drawable.RippleDrawable.tryRippleEnter:COMMENT
Method Modifier: private     
Comment:/**
 * Attempts to start an enter animation for the active hotspot. Fails if
 * there are too many animating ripples.
 */

Body of Frist Method:
{
    if (mExitingRipplesCount >= MAX_RIPPLES) {
        // or there is a bug that's preventing ripples from being removed.
        return;
    }
    if (mRipple == null) {
        final float x;
        final float y;
        if (mHasPending) {
            mHasPending = false;
            x = mPendingX;
            y = mPendingY;
        } else {
            x = mHotspotBounds.exactCenterX();
            y = mHotspotBounds.exactCenterY();
        }
        final boolean isBounded = isBounded();
        mRipple = new RippleForeground(this, mHotspotBounds, x, y, isBounded, mForceSoftware);
    }
    mRipple.setup(mState.mMaxRadius, mDensity);
    mRipple.enter(false);
}
Body of Second Method:
{
    if (mExitingRipplesCount >= MAX_RIPPLES) {
        // or there is a bug that's preventing ripples from being removed.
        return;
    }
    if (mRipple == null) {
        final float x;
        final float y;
        if (mHasPending) {
            mHasPending = false;
            x = mPendingX;
            y = mPendingY;
        } else {
            x = mHotspotBounds.exactCenterX();
            y = mHotspotBounds.exactCenterY();
        }
        mRipple = new RippleForeground(this, mHotspotBounds, x, y, mForceSoftware);
    }
    mRipple.setup(mState.mMaxRadius, mDensity);
    mRipple.enter();
}
------------------------
Find a silently evolved API code:android.content.ContentResolver.getCurrentSync:COMMENT
Method Modifier: public      static      deprecated  
Comment:/**
 * If a sync is active returns the information about it, otherwise returns null.
 * <p>
 * This method requires the caller to hold the permission
 * {@link android.Manifest.permission#READ_SYNC_STATS}.
 * <p>
 * @return the SyncInfo for the currently active sync or null if one is not active.
 * @deprecated
 * Since multiple concurrent syncs are now supported you should use
 * {@link #getCurrentSyncs()} to get the accurate list of current syncs.
 * This method returns the first item from the list of current syncs
 * or null if there are none.
 */

Body of Frist Method:
{
    try {
        final List<SyncInfo> syncs = getContentService().getCurrentSyncs();
        if (syncs.isEmpty()) {
            return null;
        }
        return syncs.get(0);
    } catch (RemoteException e) {
        throw new RuntimeException("the ContentService should always be reachable", e);
    }
}
Body of Second Method:
{
    try {
        final List<SyncInfo> syncs = getContentService().getCurrentSyncs();
        if (syncs.isEmpty()) {
            return null;
        }
        return syncs.get(0);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.le.AdvertisingSetParameters.getTxPowerLevel:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the TX power level for advertising.
 */

Body of Frist Method:
{
    return txPowerLevel;
}
Body of Second Method:
{
    return mTxPowerLevel;
}
------------------------
Find a silently evolved API code:android.util.ByteStringUtils.toHexString:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Returns the hex encoded string representation of bytes.
 * @param bytes Byte array to encode.
 * @return Hex encoded string representation of bytes.
 */

Body of Frist Method:
{
    if (bytes == null || bytes.length == 0 || bytes.length % 2 != 0) {
        return null;
    }
    final int byteLength = bytes.length;
    final int charCount = 2 * byteLength;
    final char[] chars = new char[charCount];
    for (int i = 0; i < byteLength; i++) {
        final int byteHex = bytes[i] & 0xFF;
        chars[i * 2] = HEX_ARRAY[byteHex >>> 4];
        chars[i * 2 + 1] = HEX_ARRAY[byteHex & 0x0F];
    }
    return new String(chars);
}
Body of Second Method:
{
    if (bytes == null || bytes.length == 0 || bytes.length % 2 != 0) {
        return null;
    }
    final int byteLength = bytes.length;
    final int charCount = 2 * byteLength;
    final char[] chars = new char[charCount];
    for (int i = 0; i < byteLength; i++) {
        final int byteHex = bytes[i] & 0xFF;
        chars[i * 2] = HEX_UPPERCASE_ARRAY[byteHex >>> 4];
        chars[i * 2 + 1] = HEX_UPPERCASE_ARRAY[byteHex & 0x0F];
    }
    return new String(chars);
}
------------------------
Find a silently evolved API code:android.content.pm.ApplicationInfo.isExternalAsec:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return TextUtils.isEmpty(volumeUuid) && (flags & ApplicationInfo.FLAG_EXTERNAL_STORAGE) != 0;
}
Body of Second Method:
{
    return TextUtils.isEmpty(volumeUuid) && isExternal();
}
------------------------
Find a silently evolved API code:android.bluetooth.OobData.setLeBluetoothDeviceAddress:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets the LE Bluetooth Device Address value to be used during LE pairing.
 * The value shall be 7 bytes. Please see Bluetooth CSSv6, Part A 1.16 for
 * a detailed description.
 */

Body of Frist Method:
{
    this.leBluetoothDeviceAddress = leBluetoothDeviceAddress;
}
Body of Second Method:
{
    mLeBluetoothDeviceAddress = leBluetoothDeviceAddress;
}
------------------------
Find a silently evolved API code:android.os.Debug.MemoryInfo.getOtherSwappedOutPss:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return otherStats[which * NUM_CATEGORIES + offsetSwappedOutPss];
}
Body of Second Method:
{
    return otherStats[which * NUM_CATEGORIES + OFFSET_SWAPPED_OUT_PSS];
}
------------------------
Find a silently evolved API code:android.view.textclassifier.logging.SmartSelectionEventTracker.SelectionEvent.selectionModified:COMMENT
Method Modifier: public      static      
Comment:/**
 * Creates a "selection modified" event.
 * Use when the user modifies the selection and the selection's entity type is known.
 *
 * @param start  the start word (inclusive) index of the selection
 * @param end  the end word (exclusive) index of the selection
 * @param classification  the TextClassification object returned by the TextClassifier that
 * classified the selected text
 */

Body of Frist Method:
{
    final String entityType = classification.getEntityCount() > 0 ? classification.getEntity(0) : TextClassifier.TYPE_UNKNOWN;
    final String versionTag = classification.getVersionInfo();
    return new SelectionEvent(start, end, EventType.SELECTION_MODIFIED, entityType, versionTag);
}
Body of Second Method:
{
    final String entityType = classification.getEntityCount() > 0 ? classification.getEntity(0) : TextClassifier.TYPE_UNKNOWN;
    final String versionTag = getVersionInfo(classification.getId());
    return new SelectionEvent(start, end, EventType.SELECTION_MODIFIED, entityType, versionTag);
}
------------------------
Find a silently evolved API code:android.media.session.MediaController.TransportControls.skipToQueueItem:COMMENT
Method Modifier: public      
Comment:/**
 * Play an item with a specific id in the play queue. If you specify an
 * id that is not in the play queue, the behavior is undefined.
 */

Body of Frist Method:
{
    try {
        mSessionBinder.skipToQueueItem(id);
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling skipToItem(" + id + ").", e);
    }
}
Body of Second Method:
{
    try {
        mSessionBinder.skipToQueueItem(mContext.getPackageName(), mCbStub, id);
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling skipToItem(" + id + ").", e);
    }
}
------------------------
Find a silently evolved API code:android.media.session.MediaController.adjustVolume:COMMENT
Method Modifier: public      
Comment:/**
 * Adjust the volume of the output this session is playing on. The direction
 * must be one of {@link AudioManager#ADJUST_LOWER},
 * {@link AudioManager#ADJUST_RAISE}, or {@link AudioManager#ADJUST_SAME}.
 * The command will be ignored if the session does not support
 * {@link VolumeProvider#VOLUME_CONTROL_RELATIVE} or
 * {@link VolumeProvider#VOLUME_CONTROL_ABSOLUTE}. The flags in
 * {@link AudioManager} may be used to affect the handling.
 *
 * @see #getPlaybackInfo()
 * @param direction The direction to adjust the volume in.
 * @param flags Any flags to pass with the command.
 */

Body of Frist Method:
{
    try {
        mSessionBinder.adjustVolume(direction, flags, mContext.getPackageName());
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling adjustVolumeBy.", e);
    }
}
Body of Second Method:
{
    try {
        mSessionBinder.adjustVolume(mContext.getPackageName(), mCbStub, false, direction, flags);
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling adjustVolumeBy.", e);
    }
}
------------------------
Find a silently evolved API code:android.media.audiopolicy.AudioPolicy.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Combines all of the attributes that have been set on this {@code Builder} and returns a
 * new {@link AudioPolicy} object.
 * @return a new {@code AudioPolicy} object.
 * @throws IllegalStateException if there is no
 * {@link AudioPolicy.AudioPolicyStatusListener} but the policy was configured
 * as an audio focus policy with {@link #setIsAudioFocusPolicy(boolean)}.
 */

Body of Frist Method:
{
    if (mStatusListener != null) {
        // the AudioPolicy status listener includes updates on each mix activity state
        for (AudioMix mix : mMixes) {
            mix.mCallbackFlags |= AudioMix.CALLBACK_FLAG_NOTIFY_ACTIVITY;
        }
    }
    if (mIsFocusPolicy && mFocusListener == null) {
        throw new IllegalStateException("Cannot be a focus policy without " + "an AudioPolicyFocusListener");
    }
    return new AudioPolicy(new AudioPolicyConfig(mMixes), mContext, mLooper, mFocusListener, mStatusListener, mIsFocusPolicy);
}
Body of Second Method:
{
    if (mStatusListener != null) {
        // the AudioPolicy status listener includes updates on each mix activity state
        for (AudioMix mix : mMixes) {
            mix.mCallbackFlags |= AudioMix.CALLBACK_FLAG_NOTIFY_ACTIVITY;
        }
    }
    if (mIsFocusPolicy && mFocusListener == null) {
        throw new IllegalStateException("Cannot be a focus policy without " + "an AudioPolicyFocusListener");
    }
    return new AudioPolicy(new AudioPolicyConfig(mMixes), mContext, mLooper, mFocusListener, mStatusListener, mIsFocusPolicy, mVolCb);
}
------------------------
Find a silently evolved API code:android.telephony.SignalStrength.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * {@link Parcelable#writeToParcel}
 */

Body of Frist Method:
{
    out.writeInt(mGsmSignalStrength);
    out.writeInt(mGsmBitErrorRate);
    out.writeInt(mCdmaDbm);
    out.writeInt(mCdmaEcio);
    out.writeInt(mEvdoDbm);
    out.writeInt(mEvdoEcio);
    out.writeInt(mEvdoSnr);
    out.writeInt(mLteSignalStrength);
    out.writeInt(mLteRsrp);
    out.writeInt(mLteRsrq);
    out.writeInt(mLteRssnr);
    out.writeInt(mLteCqi);
    out.writeInt(mLteRsrpBoost);
    out.writeInt(mTdScdmaRscp);
    out.writeInt(isGsm ? 1 : 0);
}
Body of Second Method:
{
    out.writeInt(mGsmSignalStrength);
    out.writeInt(mGsmBitErrorRate);
    out.writeInt(mCdmaDbm);
    out.writeInt(mCdmaEcio);
    out.writeInt(mEvdoDbm);
    out.writeInt(mEvdoEcio);
    out.writeInt(mEvdoSnr);
    out.writeInt(mLteSignalStrength);
    out.writeInt(mLteRsrp);
    out.writeInt(mLteRsrq);
    out.writeInt(mLteRssnr);
    out.writeInt(mLteCqi);
    out.writeInt(mTdScdmaRscp);
    out.writeInt(mWcdmaSignalStrength);
    out.writeInt(mWcdmaRscpAsu);
    out.writeInt(mWcdmaRscp);
    out.writeInt(mLteRsrpBoost);
    out.writeBoolean(mIsGsm);
    out.writeBoolean(mUseOnlyRsrpForLteLevel);
    out.writeString(mWcdmaDefaultSignalMeasurement);
    out.writeIntArray(mLteRsrpThresholds);
    out.writeIntArray(mWcdmaRscpThresholds);
}
------------------------
Find a silently evolved API code:android.net.TrafficStats.getRxBytes:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * {@hide}
 */

Body of Frist Method:
{
    return nativeGetIfaceStat(iface, TYPE_RX_BYTES);
}
Body of Second Method:
{
    try {
        return getStatsService().getIfaceStats(iface, TYPE_RX_BYTES);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.animation.ValueAnimator.doAnimationFrame:COMMENT
Method Modifier: public      final       hidden      
Comment:/**
 * Processes a frame of the animation, adjusting the start time if needed.
 *
 * @param frameTime The frame time.
 * @return true if the animation has ended.
 * @hide
 */

Body of Frist Method:
{
    if (mStartTime < 0) {
        // First frame. If there is start delay, start delay count down will happen *after* this
        // frame.
        mStartTime = mReversing ? frameTime : frameTime + (long) (mStartDelay * sDurationScale);
    }
    // Handle pause/resume
    if (mPaused) {
        mPauseTime = frameTime;
        removeAnimationCallback();
        return false;
    } else if (mResumed) {
        mResumed = false;
        if (mPauseTime > 0) {
            // Offset by the duration that the animation was paused
            mStartTime += (frameTime - mPauseTime);
        }
    }
    if (!mRunning) {
        // running animation. In the case of reversing, we want to run start delay in the end.
        if (mStartTime > frameTime && mSeekFraction == -1) {
            // right away.
            return false;
        } else {
            // If mRunning is not set by now, that means non-zero start delay,
            // no seeking, not reversing. At this point, start delay has passed.
            mRunning = true;
            startAnimation();
        }
    }
    if (mLastFrameTime < 0) {
        if (mSeekFraction >= 0) {
            long seekTime = (long) (getScaledDuration() * mSeekFraction);
            mStartTime = frameTime - seekTime;
            mSeekFraction = -1;
        }
        // allow start time to be compensated for jank
        mStartTimeCommitted = false;
    }
    mLastFrameTime = frameTime;
    // The frame time might be before the start time during the first frame of
    // an animation.  The "current time" must always be on or after the start
    // time to avoid animating frames at negative time intervals.  In practice, this
    // is very rare and only happens when seeking backwards.
    final long currentTime = Math.max(frameTime, mStartTime);
    boolean finished = animateBasedOnTime(currentTime);
    if (finished) {
        endAnimation();
    }
    return finished;
}
Body of Second Method:
{
    if (mStartTime < 0) {
        // First frame. If there is start delay, start delay count down will happen *after* this
        // frame.
        mStartTime = mReversing ? frameTime : frameTime + (long) (mStartDelay * resolveDurationScale());
    }
    // Handle pause/resume
    if (mPaused) {
        mPauseTime = frameTime;
        removeAnimationCallback();
        return false;
    } else if (mResumed) {
        mResumed = false;
        if (mPauseTime > 0) {
            // Offset by the duration that the animation was paused
            mStartTime += (frameTime - mPauseTime);
        }
    }
    if (!mRunning) {
        // running animation. In the case of reversing, we want to run start delay in the end.
        if (mStartTime > frameTime && mSeekFraction == -1) {
            // right away.
            return false;
        } else {
            // If mRunning is not set by now, that means non-zero start delay,
            // no seeking, not reversing. At this point, start delay has passed.
            mRunning = true;
            startAnimation();
        }
    }
    if (mLastFrameTime < 0) {
        if (mSeekFraction >= 0) {
            long seekTime = (long) (getScaledDuration() * mSeekFraction);
            mStartTime = frameTime - seekTime;
            mSeekFraction = -1;
        }
        // allow start time to be compensated for jank
        mStartTimeCommitted = false;
    }
    mLastFrameTime = frameTime;
    // The frame time might be before the start time during the first frame of
    // an animation.  The "current time" must always be on or after the start
    // time to avoid animating frames at negative time intervals.  In practice, this
    // is very rare and only happens when seeking backwards.
    final long currentTime = Math.max(frameTime, mStartTime);
    boolean finished = animateBasedOnTime(currentTime);
    if (finished) {
        endAnimation();
    }
    return finished;
}
------------------------
Find a silently evolved API code:android.net.metrics.WakeupStats.countEvent:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Update wakeup counters for the given WakeupEvent.
 */

Body of Frist Method:
{
    totalWakeups++;
    switch(ev.uid) {
        case Process.ROOT_UID:
            rootWakeups++;
            break;
        case Process.SYSTEM_UID:
            systemWakeups++;
            break;
        case NO_UID:
            noUidWakeups++;
            break;
        default:
            if (ev.uid >= Process.FIRST_APPLICATION_UID) {
                applicationWakeups++;
            } else {
                nonApplicationWakeups++;
            }
            break;
    }
}
Body of Second Method:
{
    totalWakeups++;
    switch(ev.uid) {
        case Process.ROOT_UID:
            rootWakeups++;
            break;
        case Process.SYSTEM_UID:
            systemWakeups++;
            break;
        case NO_UID:
            noUidWakeups++;
            break;
        default:
            if (ev.uid >= Process.FIRST_APPLICATION_UID) {
                applicationWakeups++;
            } else {
                nonApplicationWakeups++;
            }
            break;
    }
    switch(ev.dstHwAddr.getAddressType()) {
        case MacAddress.TYPE_UNICAST:
            l2UnicastCount++;
            break;
        case MacAddress.TYPE_MULTICAST:
            l2MulticastCount++;
            break;
        case MacAddress.TYPE_BROADCAST:
            l2BroadcastCount++;
            break;
        default:
            break;
    }
    increment(ethertypes, ev.ethertype);
    if (ev.ipNextHeader >= 0) {
        increment(ipNextHeaders, ev.ipNextHeader);
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.le.PeriodicAdvertisingReport.getTimestampNanos:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns timestamp since boot when the scan record was observed.
 */

Body of Frist Method:
{
    return timestampNanos;
}
Body of Second Method:
{
    return mTimestampNanos;
}
------------------------
Find a silently evolved API code:android.provider.SearchIndexablesProvider.attachInfo:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Implementation is provided by the parent class.
 */

Body of Frist Method:
{
    mAuthority = info.authority;
    mMatcher = new UriMatcher(UriMatcher.NO_MATCH);
    mMatcher.addURI(mAuthority, SearchIndexablesContract.INDEXABLES_XML_RES_PATH, MATCH_RES_CODE);
    mMatcher.addURI(mAuthority, SearchIndexablesContract.INDEXABLES_RAW_PATH, MATCH_RAW_CODE);
    mMatcher.addURI(mAuthority, SearchIndexablesContract.NON_INDEXABLES_KEYS_PATH, MATCH_NON_INDEXABLE_KEYS_CODE);
    // Sanity check our setup
    if (!info.exported) {
        throw new SecurityException("Provider must be exported");
    }
    if (!info.grantUriPermissions) {
        throw new SecurityException("Provider must grantUriPermissions");
    }
    if (!android.Manifest.permission.READ_SEARCH_INDEXABLES.equals(info.readPermission)) {
        throw new SecurityException("Provider must be protected by READ_SEARCH_INDEXABLES");
    }
    super.attachInfo(context, info);
}
Body of Second Method:
{
    mAuthority = info.authority;
    mMatcher = new UriMatcher(UriMatcher.NO_MATCH);
    mMatcher.addURI(mAuthority, SearchIndexablesContract.INDEXABLES_XML_RES_PATH, MATCH_RES_CODE);
    mMatcher.addURI(mAuthority, SearchIndexablesContract.INDEXABLES_RAW_PATH, MATCH_RAW_CODE);
    mMatcher.addURI(mAuthority, SearchIndexablesContract.NON_INDEXABLES_KEYS_PATH, MATCH_NON_INDEXABLE_KEYS_CODE);
    mMatcher.addURI(mAuthority, SearchIndexablesContract.SITE_MAP_PAIRS_PATH, MATCH_SITE_MAP_PAIRS_CODE);
    // Sanity check our setup
    if (!info.exported) {
        throw new SecurityException("Provider must be exported");
    }
    if (!info.grantUriPermissions) {
        throw new SecurityException("Provider must grantUriPermissions");
    }
    if (!android.Manifest.permission.READ_SEARCH_INDEXABLES.equals(info.readPermission)) {
        throw new SecurityException("Provider must be protected by READ_SEARCH_INDEXABLES");
    }
    super.attachInfo(context, info);
}
------------------------
Find a silently evolved API code:android.database.sqlite.SQLiteConnection.reconfigure:COMMENT
Method Modifier: default     hidden      
Comment:// Called by SQLiteConnectionPool only.

Body of Frist Method:
{
    mOnlyAllowReadOnlyOperations = false;
    // Register custom functions.
    final int functionCount = configuration.customFunctions.size();
    for (int i = 0; i < functionCount; i++) {
        SQLiteCustomFunction function = configuration.customFunctions.get(i);
        if (!mConfiguration.customFunctions.contains(function)) {
            nativeRegisterCustomFunction(mConnectionPtr, function);
        }
    }
    // Remember what changed.
    boolean foreignKeyModeChanged = configuration.foreignKeyConstraintsEnabled != mConfiguration.foreignKeyConstraintsEnabled;
    boolean walModeChanged = ((configuration.openFlags ^ mConfiguration.openFlags) & SQLiteDatabase.ENABLE_WRITE_AHEAD_LOGGING) != 0;
    boolean localeChanged = !configuration.locale.equals(mConfiguration.locale);
    // Update configuration parameters.
    mConfiguration.updateParametersFrom(configuration);
    // Update prepared statement cache size.
    mPreparedStatementCache.resize(configuration.maxSqlCacheSize);
    // Update foreign key mode.
    if (foreignKeyModeChanged) {
        setForeignKeyModeFromConfiguration();
    }
    // Update WAL.
    if (walModeChanged) {
        setWalModeFromConfiguration();
    }
    // Update locale.
    if (localeChanged) {
        setLocaleFromConfiguration();
    }
}
Body of Second Method:
{
    mOnlyAllowReadOnlyOperations = false;
    // Register custom functions.
    final int functionCount = configuration.customFunctions.size();
    for (int i = 0; i < functionCount; i++) {
        SQLiteCustomFunction function = configuration.customFunctions.get(i);
        if (!mConfiguration.customFunctions.contains(function)) {
            nativeRegisterCustomFunction(mConnectionPtr, function);
        }
    }
    // Remember what changed.
    boolean foreignKeyModeChanged = configuration.foreignKeyConstraintsEnabled != mConfiguration.foreignKeyConstraintsEnabled;
    boolean walModeChanged = ((configuration.openFlags ^ mConfiguration.openFlags) & (SQLiteDatabase.ENABLE_WRITE_AHEAD_LOGGING | SQLiteDatabase.DISABLE_COMPATIBILITY_WAL)) != 0;
    boolean localeChanged = !configuration.locale.equals(mConfiguration.locale);
    // Update configuration parameters.
    mConfiguration.updateParametersFrom(configuration);
    // Update prepared statement cache size.
    mPreparedStatementCache.resize(configuration.maxSqlCacheSize);
    // Update foreign key mode.
    if (foreignKeyModeChanged) {
        setForeignKeyModeFromConfiguration();
    }
    // Update WAL.
    if (walModeChanged) {
        setWalModeFromConfiguration();
    }
    // Update locale.
    if (localeChanged) {
        setLocaleFromConfiguration();
    }
}
------------------------
Find a silently evolved API code:android.os.Process.startWebView:COMMENT
Method Modifier: public      static      final       hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return WebViewZygote.getProcess().start(processClass, niceName, uid, gid, gids, debugFlags, mountExternal, targetSdkVersion, seInfo, abi, instructionSet, appDataDir, invokeWith, zygoteArgs);
}
Body of Second Method:
{
    return WebViewZygote.getProcess().start(processClass, niceName, uid, gid, gids, runtimeFlags, mountExternal, targetSdkVersion, seInfo, abi, instructionSet, appDataDir, invokeWith, zygoteArgs);
}
------------------------
Find a silently evolved API code:android.text.format.Formatter.formatBytes:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * {@hide}
 */

Body of Frist Method:
{
    final RoundedBytesResult rounded = RoundedBytesResult.roundBytes(sizeBytes, flags);
    final Locale locale = res.getConfiguration().getLocales().get(0);
    final NumberFormat numberFormatter = getNumberFormatter(locale, rounded.fractionDigits);
    final String formattedNumber = numberFormatter.format(rounded.value);
    final String units;
    if (rounded.units == MeasureUnit.BYTE || rounded.units == PETABYTE) {
        // ICU spells out "byte" instead of "B", and can't format petabytes yet.
        units = getSuffixOverride(res, rounded.units);
    } else {
        // Since ICU does not give us access to the pattern, we need to extract the unit string
        // from ICU, which we do by taking out the formatted number out of the formatted string
        // and trimming the result of spaces and controls.
        final String formattedMeasure = formatMeasureShort(locale, numberFormatter, rounded.value, rounded.units);
        final String numberRemoved = deleteFirstFromString(formattedMeasure, formattedNumber);
        units = SPACES_AND_CONTROLS.trim(numberRemoved).toString();
    }
    return new BytesResult(formattedNumber, units, rounded.roundedBytes);
}
Body of Second Method:
{
    final int unit = ((flags & FLAG_IEC_UNITS) != 0) ? 1024 : 1000;
    final boolean isNegative = (sizeBytes < 0);
    float result = isNegative ? -sizeBytes : sizeBytes;
    int suffix = com.android.internal.R.string.byteShort;
    long mult = 1;
    if (result > 900) {
        suffix = com.android.internal.R.string.kilobyteShort;
        mult = unit;
        result = result / unit;
    }
    if (result > 900) {
        suffix = com.android.internal.R.string.megabyteShort;
        mult *= unit;
        result = result / unit;
    }
    if (result > 900) {
        suffix = com.android.internal.R.string.gigabyteShort;
        mult *= unit;
        result = result / unit;
    }
    if (result > 900) {
        suffix = com.android.internal.R.string.terabyteShort;
        mult *= unit;
        result = result / unit;
    }
    if (result > 900) {
        suffix = com.android.internal.R.string.petabyteShort;
        mult *= unit;
        result = result / unit;
    }
    // Note we calculate the rounded long by ourselves, but still let String.format()
    // compute the rounded value. String.format("%f", 0.1) might not return "0.1" due to
    // floating point errors.
    final int roundFactor;
    final String roundFormat;
    if (mult == 1 || result >= 100) {
        roundFactor = 1;
        roundFormat = "%.0f";
    } else if (result < 1) {
        roundFactor = 100;
        roundFormat = "%.2f";
    } else if (result < 10) {
        if ((flags & FLAG_SHORTER) != 0) {
            roundFactor = 10;
            roundFormat = "%.1f";
        } else {
            roundFactor = 100;
            roundFormat = "%.2f";
        }
    } else {
        // 10 <= result < 100
        if ((flags & FLAG_SHORTER) != 0) {
            roundFactor = 1;
            roundFormat = "%.0f";
        } else {
            roundFactor = 100;
            roundFormat = "%.2f";
        }
    }
    if (isNegative) {
        result = -result;
    }
    final String roundedString = String.format(roundFormat, result);
    // Note this might overflow if abs(result) >= Long.MAX_VALUE / 100, but that's like 80PB so
    // it's okay (for now)...
    final long roundedBytes = (flags & FLAG_CALCULATE_ROUNDED) == 0 ? 0 : (((long) Math.round(result * roundFactor)) * mult / roundFactor);
    final String units = res.getString(suffix);
    return new BytesResult(roundedString, units, roundedBytes);
}
------------------------
Find a silently evolved API code:android.content.ContentResolver.removePeriodicSync:COMMENT
Method Modifier: public      static      
Comment:/**
 * Remove a periodic sync. Has no affect if account, authority and extras don't match
 * an existing periodic sync.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#WRITE_SYNC_SETTINGS}.
 *
 * @param account the account of the periodic sync to remove
 * @param authority the provider of the periodic sync to remove
 * @param extras the extras of the periodic sync to remove
 */

Body of Frist Method:
{
    validateSyncExtrasBundle(extras);
    try {
        getContentService().removePeriodicSync(account, authority, extras);
    } catch (RemoteException e) {
        throw new RuntimeException("the ContentService should always be reachable", e);
    }
}
Body of Second Method:
{
    validateSyncExtrasBundle(extras);
    try {
        getContentService().removePeriodicSync(account, authority, extras);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothDevice.getService:COMMENT
Method Modifier: default     static      
Comment:/*package*/

Body of Frist Method:
{
    synchronized (BluetoothDevice.class) {
        if (sService == null) {
            BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
            sService = adapter.getBluetoothService(mStateChangeCallback);
        }
    }
    return sService;
}
Body of Second Method:
{
    synchronized (BluetoothDevice.class) {
        if (sService == null) {
            BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
            sService = adapter.getBluetoothService(sStateChangeCallback);
        }
    }
    return sService;
}
------------------------
Find a silently evolved API code:android.os.Debug.MemoryInfo.getOtherPrivateClean:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return otherStats[which * NUM_CATEGORIES + offsetPrivateClean];
}
Body of Second Method:
{
    return otherStats[which * NUM_CATEGORIES + OFFSET_PRIVATE_CLEAN];
}
------------------------
Find a silently evolved API code:android.media.AudioFormat.isEncodingLinearFrames:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    switch(audioFormat) {
        case ENCODING_PCM_8BIT:
        case ENCODING_PCM_16BIT:
        case ENCODING_PCM_FLOAT:
        // same size as stereo PCM
        case ENCODING_IEC61937:
        case ENCODING_DEFAULT:
            return true;
        case ENCODING_AC3:
        case ENCODING_E_AC3:
        case ENCODING_DTS:
        case ENCODING_DTS_HD:
        case ENCODING_MP3:
        case ENCODING_AAC_LC:
        case ENCODING_AAC_HE_V1:
        case ENCODING_AAC_HE_V2:
            return false;
        case ENCODING_INVALID:
        default:
            throw new IllegalArgumentException("Bad audio format " + audioFormat);
    }
}
Body of Second Method:
{
    switch(audioFormat) {
        case ENCODING_PCM_8BIT:
        case ENCODING_PCM_16BIT:
        case ENCODING_PCM_FLOAT:
        // same size as stereo PCM
        case ENCODING_IEC61937:
        case ENCODING_DEFAULT:
            return true;
        case ENCODING_AC3:
        case ENCODING_E_AC3:
        case ENCODING_E_AC3_JOC:
        case ENCODING_DTS:
        case ENCODING_DTS_HD:
        case ENCODING_MP3:
        case ENCODING_AAC_LC:
        case ENCODING_AAC_HE_V1:
        case ENCODING_AAC_HE_V2:
        case ENCODING_AAC_ELD:
        case ENCODING_AAC_XHE:
        case ENCODING_AC4:
            return false;
        case ENCODING_INVALID:
        default:
            throw new IllegalArgumentException("Bad audio format " + audioFormat);
    }
}
------------------------
Find a silently evolved API code:android.content.ContentResolver.getIsSyncable:COMMENT
Method Modifier: public      static      
Comment:/**
 * Check if this account/provider is syncable.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#READ_SYNC_SETTINGS}.
 * @return >0 if it is syncable, 0 if not, and <0 if the state isn't known yet.
 */

Body of Frist Method:
{
    try {
        return getContentService().getIsSyncable(account, authority);
    } catch (RemoteException e) {
        throw new RuntimeException("the ContentService should always be reachable", e);
    }
}
Body of Second Method:
{
    try {
        return getContentService().getIsSyncable(account, authority);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.nfc.cardemulation.NfcFCardEmulation.getNfcid2ForService:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieves the current NFCID2 for the specified service.
 *
 * <p>Before calling {@link #setNfcid2ForService(ComponentName, String)},
 * the NFCID2 contained in the Manifest file is returned. If "random" is specified
 * in the Manifest file, a random number assigned by the system at installation time
 * is returned. After setting an NFCID2
 * with {@link #setNfcid2ForService(ComponentName, String)}, this NFCID2 is returned.
 *
 * @param service The component name of the service
 * @return the current NFCID2
 */

Body of Frist Method:
{
    if (service == null) {
        throw new NullPointerException("service is null");
    }
    try {
        return sService.getNfcid2ForService(UserHandle.myUserId(), service);
    } catch (RemoteException e) {
        // Try one more time
        recoverService();
        if (sService == null) {
            Log.e(TAG, "Failed to recover CardEmulationService.");
            return null;
        }
        try {
            return sService.getNfcid2ForService(UserHandle.myUserId(), service);
        } catch (RemoteException ee) {
            Log.e(TAG, "Failed to reach CardEmulationService.");
            ee.rethrowAsRuntimeException();
            return null;
        }
    }
}
Body of Second Method:
{
    if (service == null) {
        throw new NullPointerException("service is null");
    }
    try {
        return sService.getNfcid2ForService(mContext.getUserId(), service);
    } catch (RemoteException e) {
        // Try one more time
        recoverService();
        if (sService == null) {
            Log.e(TAG, "Failed to recover CardEmulationService.");
            return null;
        }
        try {
            return sService.getNfcid2ForService(mContext.getUserId(), service);
        } catch (RemoteException ee) {
            Log.e(TAG, "Failed to reach CardEmulationService.");
            ee.rethrowAsRuntimeException();
            return null;
        }
    }
}
------------------------
Find a silently evolved API code:android.util.PackageUtils.computeSha256Digest:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Computes the SHA256 digest of some data.
 * @param data The data.
 * @return The digest or null if an error occurs.
 */

Body of Frist Method:
{
    MessageDigest messageDigest;
    try {
        messageDigest = MessageDigest.getInstance("SHA256");
    } catch (NoSuchAlgorithmException e) {
        /* can't happen */
        return null;
    }
    messageDigest.update(data);
    return ByteStringUtils.toHexString(messageDigest.digest());
}
Body of Second Method:
{
    return ByteStringUtils.toHexString(computeSha256DigestBytes(data));
}
------------------------
Find a silently evolved API code:android.net.Uri.StringUri.parseAuthority:COMMENT
Method Modifier: default     static      
Comment:/**
 * Parses an authority out of the given URI string.
 *
 * @param uriString URI string
 * @param ssi scheme separator index, -1 for a relative URI
 *
 * @return the authority or null if none is found
 */

Body of Frist Method:
{
    int length = uriString.length();
    // If "//" follows the scheme separator, we have an authority.
    if (length > ssi + 2 && uriString.charAt(ssi + 1) == '/' && uriString.charAt(ssi + 2) == '/') {
        // We have an authority.
        // Look for the start of the path, query, or fragment, or the
        // end of the string.
        int end = ssi + 3;
        LOOP: while (end < length) {
            switch(uriString.charAt(end)) {
                // Start of path
                case '/':
                // Start of query
                case '?':
                case // Start of fragment
                '#':
                    break LOOP;
            }
            end++;
        }
        return uriString.substring(ssi + 3, end);
    } else {
        return null;
    }
}
Body of Second Method:
{
    int length = uriString.length();
    // If "//" follows the scheme separator, we have an authority.
    if (length > ssi + 2 && uriString.charAt(ssi + 1) == '/' && uriString.charAt(ssi + 2) == '/') {
        // We have an authority.
        // Look for the start of the path, query, or fragment, or the
        // end of the string.
        int end = ssi + 3;
        LOOP: while (end < length) {
            switch(uriString.charAt(end)) {
                // Start of path
                case '/':
                // Start of path
                case '\\':
                // Start of query
                case '?':
                case // Start of fragment
                '#':
                    break LOOP;
            }
            end++;
        }
        return uriString.substring(ssi + 3, end);
    } else {
        return null;
    }
}
------------------------
Find a silently evolved API code:android.nfc.cardemulation.CardEmulation.setDefaultForNextTap:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    try {
        return sService.setDefaultForNextTap(UserHandle.myUserId(), service);
    } catch (RemoteException e) {
        // Try one more time
        recoverService();
        if (sService == null) {
            Log.e(TAG, "Failed to recover CardEmulationService.");
            return false;
        }
        try {
            return sService.setDefaultForNextTap(UserHandle.myUserId(), service);
        } catch (RemoteException ee) {
            Log.e(TAG, "Failed to reach CardEmulationService.");
            return false;
        }
    }
}
Body of Second Method:
{
    try {
        return sService.setDefaultForNextTap(mContext.getUserId(), service);
    } catch (RemoteException e) {
        // Try one more time
        recoverService();
        if (sService == null) {
            Log.e(TAG, "Failed to recover CardEmulationService.");
            return false;
        }
        try {
            return sService.setDefaultForNextTap(mContext.getUserId(), service);
        } catch (RemoteException ee) {
            Log.e(TAG, "Failed to reach CardEmulationService.");
            return false;
        }
    }
}
------------------------
Find a silently evolved API code:android.text.style.QuoteSpan.writeToParcelInternal:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    dest.writeInt(mColor);
}
Body of Second Method:
{
    dest.writeInt(mColor);
    dest.writeInt(mStripeWidth);
    dest.writeInt(mGapWidth);
}
------------------------
Find a silently evolved API code:android.bluetooth.le.PeriodicAdvertisingReport.getDataStatus:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns the data status. Can be one of {@link PeriodicAdvertisingReport#DATA_COMPLETE}
 * or {@link PeriodicAdvertisingReport#DATA_INCOMPLETE_TRUNCATED}.
 */

Body of Frist Method:
{
    return dataStatus;
}
Body of Second Method:
{
    return mDataStatus;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothServerSocket.close:COMMENT
Method Modifier: public      
Comment:/**
 * Immediately close this socket, and release all associated resources.
 * <p>Causes blocked calls on this socket in other threads to immediately
 * throw an IOException.
 * <p>Closing the {@link BluetoothServerSocket} will <em>not</em>
 * close any {@link BluetoothSocket} received from {@link #accept()}.
 */

Body of Frist Method:
{
    synchronized (this) {
        if (mHandler != null) {
            mHandler.obtainMessage(mMessage).sendToTarget();
        }
    }
    mSocket.close();
}
Body of Second Method:
{
    if (DBG)
        Log.d(TAG, "BluetoothServerSocket:close() called. mChannel=" + mChannel);
    synchronized (this) {
        if (mHandler != null) {
            mHandler.obtainMessage(mMessage).sendToTarget();
        }
    }
    mSocket.close();
}
------------------------
Find a silently evolved API code:android.media.session.MediaController.TransportControls.playFromUri:COMMENT
Method Modifier: public      
Comment:/**
 * Request that the player start playback for a specific {@link Uri}.
 *
 * @param uri The URI of the requested media.
 * @param extras Optional extras that can include extra information about the media item
 * to be played.
 */

Body of Frist Method:
{
    if (uri == null || Uri.EMPTY.equals(uri)) {
        throw new IllegalArgumentException("You must specify a non-empty Uri for playFromUri.");
    }
    try {
        mSessionBinder.playFromUri(uri, extras);
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling play(" + uri + ").", e);
    }
}
Body of Second Method:
{
    if (uri == null || Uri.EMPTY.equals(uri)) {
        throw new IllegalArgumentException("You must specify a non-empty Uri for playFromUri.");
    }
    try {
        mSessionBinder.playFromUri(mContext.getPackageName(), mCbStub, uri, extras);
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling play(" + uri + ").", e);
    }
}
------------------------
Find a silently evolved API code:android.telephony.SignalStrength.getLteLevel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get LTE as level 0..4
 *
 * @hide
 */

Body of Frist Method:
{
    /*
         * TS 36.214 Physical Layer Section 5.1.3 TS 36.331 RRC RSSI = received
         * signal + noise RSRP = reference signal dBm RSRQ = quality of signal
         * dB= Number of Resource blocksxRSRP/RSSI SNR = gain=signal/noise ratio
         * = -10log P1/P2 dB
         */
    int rssiIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN, rsrpIconLevel = -1, snrIconLevel = -1;
    int[] threshRsrp = Resources.getSystem().getIntArray(com.android.internal.R.array.config_lteDbmThresholds);
    if (threshRsrp.length != 6) {
        Log.wtf(LOG_TAG, "getLteLevel - config_lteDbmThresholds has invalid num of elements." + " Cannot evaluate RSRP signal.");
    } else {
        if (mLteRsrp > threshRsrp[5]) {
            rsrpIconLevel = -1;
        } else if (mLteRsrp >= (threshRsrp[4] - mLteRsrpBoost)) {
            rsrpIconLevel = SIGNAL_STRENGTH_GREAT;
        } else if (mLteRsrp >= (threshRsrp[3] - mLteRsrpBoost)) {
            rsrpIconLevel = SIGNAL_STRENGTH_GOOD;
        } else if (mLteRsrp >= (threshRsrp[2] - mLteRsrpBoost)) {
            rsrpIconLevel = SIGNAL_STRENGTH_MODERATE;
        } else if (mLteRsrp >= (threshRsrp[1] - mLteRsrpBoost)) {
            rsrpIconLevel = SIGNAL_STRENGTH_POOR;
        } else if (mLteRsrp >= threshRsrp[0]) {
            rsrpIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
        }
    }
    /*
         * Values are -200 dB to +300 (SNR*10dB) RS_SNR >= 13.0 dB =>4 bars 4.5
         * dB <= RS_SNR < 13.0 dB => 3 bars 1.0 dB <= RS_SNR < 4.5 dB => 2 bars
         * -3.0 dB <= RS_SNR < 1.0 dB 1 bar RS_SNR < -3.0 dB/No Service Antenna
         * Icon Only
         */
    if (mLteRssnr > 300)
        snrIconLevel = -1;
    else if (mLteRssnr >= 130)
        snrIconLevel = SIGNAL_STRENGTH_GREAT;
    else if (mLteRssnr >= 45)
        snrIconLevel = SIGNAL_STRENGTH_GOOD;
    else if (mLteRssnr >= 10)
        snrIconLevel = SIGNAL_STRENGTH_MODERATE;
    else if (mLteRssnr >= -30)
        snrIconLevel = SIGNAL_STRENGTH_POOR;
    else if (mLteRssnr >= -200)
        snrIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    if (DBG)
        log("getLTELevel - rsrp:" + mLteRsrp + " snr:" + mLteRssnr + " rsrpIconLevel:" + rsrpIconLevel + " snrIconLevel:" + snrIconLevel + " lteRsrpBoost:" + mLteRsrpBoost);
    /* Choose a measurement type to use for notification */
    if (snrIconLevel != -1 && rsrpIconLevel != -1) {
        /*
             * The number of bars displayed shall be the smaller of the bars
             * associated with LTE RSRP and the bars associated with the LTE
             * RS_SNR
             */
        return (rsrpIconLevel < snrIconLevel ? rsrpIconLevel : snrIconLevel);
    }
    if (snrIconLevel != -1)
        return snrIconLevel;
    if (rsrpIconLevel != -1)
        return rsrpIconLevel;
    /* Valid values are (0-63, 99) as defined in TS 36.331 */
    if (mLteSignalStrength > 63)
        rssiIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    else if (mLteSignalStrength >= 12)
        rssiIconLevel = SIGNAL_STRENGTH_GREAT;
    else if (mLteSignalStrength >= 8)
        rssiIconLevel = SIGNAL_STRENGTH_GOOD;
    else if (mLteSignalStrength >= 5)
        rssiIconLevel = SIGNAL_STRENGTH_MODERATE;
    else if (mLteSignalStrength >= 0)
        rssiIconLevel = SIGNAL_STRENGTH_POOR;
    if (DBG)
        log("getLTELevel - rssi:" + mLteSignalStrength + " rssiIconLevel:" + rssiIconLevel);
    return rssiIconLevel;
}
Body of Second Method:
{
    /*
         * TS 36.214 Physical Layer Section 5.1.3
         * TS 36.331 RRC
         *
         * RSSI = received signal + noise
         * RSRP = reference signal dBm
         * RSRQ = quality of signal dB = Number of Resource blocks*RSRP/RSSI
         * SNR = gain = signal/noise ratio = -10log P1/P2 dB
         */
    int rssiIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN, rsrpIconLevel = -1, snrIconLevel = -1;
    if (mLteRsrp > MAX_LTE_RSRP || mLteRsrp < MIN_LTE_RSRP) {
        if (mLteRsrp != INVALID) {
            Log.wtf(LOG_TAG, "getLteLevel - invalid lte rsrp: mLteRsrp=" + mLteRsrp);
        }
    } else if (mLteRsrp >= (mLteRsrpThresholds[3] - mLteRsrpBoost)) {
        rsrpIconLevel = SIGNAL_STRENGTH_GREAT;
    } else if (mLteRsrp >= (mLteRsrpThresholds[2] - mLteRsrpBoost)) {
        rsrpIconLevel = SIGNAL_STRENGTH_GOOD;
    } else if (mLteRsrp >= (mLteRsrpThresholds[1] - mLteRsrpBoost)) {
        rsrpIconLevel = SIGNAL_STRENGTH_MODERATE;
    } else if (mLteRsrp >= (mLteRsrpThresholds[0] - mLteRsrpBoost)) {
        rsrpIconLevel = SIGNAL_STRENGTH_POOR;
    } else {
        rsrpIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    }
    if (useOnlyRsrpForLteLevel()) {
        log("getLTELevel - rsrp = " + rsrpIconLevel);
        if (rsrpIconLevel != -1) {
            return rsrpIconLevel;
        }
    }
    /*
         * Values are -200 dB to +300 (SNR*10dB) RS_SNR >= 13.0 dB =>4 bars 4.5
         * dB <= RS_SNR < 13.0 dB => 3 bars 1.0 dB <= RS_SNR < 4.5 dB => 2 bars
         * -3.0 dB <= RS_SNR < 1.0 dB 1 bar RS_SNR < -3.0 dB/No Service Antenna
         * Icon Only
         */
    if (mLteRssnr > 300)
        snrIconLevel = -1;
    else if (mLteRssnr >= 130)
        snrIconLevel = SIGNAL_STRENGTH_GREAT;
    else if (mLteRssnr >= 45)
        snrIconLevel = SIGNAL_STRENGTH_GOOD;
    else if (mLteRssnr >= 10)
        snrIconLevel = SIGNAL_STRENGTH_MODERATE;
    else if (mLteRssnr >= -30)
        snrIconLevel = SIGNAL_STRENGTH_POOR;
    else if (mLteRssnr >= -200)
        snrIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    if (DBG)
        log("getLTELevel - rsrp:" + mLteRsrp + " snr:" + mLteRssnr + " rsrpIconLevel:" + rsrpIconLevel + " snrIconLevel:" + snrIconLevel + " lteRsrpBoost:" + mLteRsrpBoost);
    /* Choose a measurement type to use for notification */
    if (snrIconLevel != -1 && rsrpIconLevel != -1) {
        /*
             * The number of bars displayed shall be the smaller of the bars
             * associated with LTE RSRP and the bars associated with the LTE
             * RS_SNR
             */
        return (rsrpIconLevel < snrIconLevel ? rsrpIconLevel : snrIconLevel);
    }
    if (snrIconLevel != -1)
        return snrIconLevel;
    if (rsrpIconLevel != -1)
        return rsrpIconLevel;
    // soak time
    if (mLteSignalStrength > 63)
        rssiIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    else if (mLteSignalStrength >= 12)
        rssiIconLevel = SIGNAL_STRENGTH_GREAT;
    else if (mLteSignalStrength >= 8)
        rssiIconLevel = SIGNAL_STRENGTH_GOOD;
    else if (mLteSignalStrength >= 5)
        rssiIconLevel = SIGNAL_STRENGTH_MODERATE;
    else if (mLteSignalStrength >= 0)
        rssiIconLevel = SIGNAL_STRENGTH_POOR;
    if (DBG)
        log("getLteLevel - rssi:" + mLteSignalStrength + " rssiIconLevel:" + rssiIconLevel);
    return rssiIconLevel;
}
------------------------
Find a silently evolved API code:android.nfc.cardemulation.CardEmulation.registerAidsForService:COMMENT
Method Modifier: public      
Comment:/**
 * Registers a list of AIDs for a specific category for the
 * specified service.
 *
 * <p>If a list of AIDs for that category was previously
 * registered for this service (either statically
 * through the manifest, or dynamically by using this API),
 * that list of AIDs will be replaced with this one.
 *
 * <p>Note that you can only register AIDs for a service that
 * is running under the same UID as the caller of this API. Typically
 * this means you need to call this from the same
 * package as the service itself, though UIDs can also
 * be shared between packages using shared UIDs.
 *
 * @param service The component name of the service
 * @param category The category of AIDs to be registered
 * @param aids A list containing the AIDs to be registered
 * @return whether the registration was successful.
 */

Body of Frist Method:
{
    AidGroup aidGroup = new AidGroup(aids, category);
    try {
        return sService.registerAidGroupForService(UserHandle.myUserId(), service, aidGroup);
    } catch (RemoteException e) {
        // Try one more time
        recoverService();
        if (sService == null) {
            Log.e(TAG, "Failed to recover CardEmulationService.");
            return false;
        }
        try {
            return sService.registerAidGroupForService(UserHandle.myUserId(), service, aidGroup);
        } catch (RemoteException ee) {
            Log.e(TAG, "Failed to reach CardEmulationService.");
            return false;
        }
    }
}
Body of Second Method:
{
    AidGroup aidGroup = new AidGroup(aids, category);
    try {
        return sService.registerAidGroupForService(mContext.getUserId(), service, aidGroup);
    } catch (RemoteException e) {
        // Try one more time
        recoverService();
        if (sService == null) {
            Log.e(TAG, "Failed to recover CardEmulationService.");
            return false;
        }
        try {
            return sService.registerAidGroupForService(mContext.getUserId(), service, aidGroup);
        } catch (RemoteException ee) {
            Log.e(TAG, "Failed to reach CardEmulationService.");
            return false;
        }
    }
}
------------------------
Find a silently evolved API code:android.net.TrafficStats.getUidRxPackets:COMMENT
Method Modifier: public      static      
Comment:/**
 * Return number of packets received by the given UID since device boot.
 * Counts packets across all network interfaces, and always increases
 * monotonically since device boot. Statistics are measured at the network
 * layer, so they include both TCP and UDP usage.
 * <p>
 * Before {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}, this may return
 * {@link #UNSUPPORTED} on devices where statistics aren't available.
 * <p>
 * Starting in {@link android.os.Build.VERSION_CODES#N} this will only
 * report traffic statistics for the calling UID. It will return
 * {@link #UNSUPPORTED} for all other UIDs for privacy reasons. To access
 * historical network statistics belonging to other UIDs, use
 * {@link NetworkStatsManager}.
 *
 * @see android.os.Process#myUid()
 * @see android.content.pm.ApplicationInfo#uid
 */

Body of Frist Method:
{
    // This isn't actually enforcing any security; it just returns the
    // unsupported value. The real filtering is done at the kernel level.
    final int callingUid = android.os.Process.myUid();
    if (callingUid == android.os.Process.SYSTEM_UID || callingUid == uid) {
        return nativeGetUidStat(uid, TYPE_RX_PACKETS);
    } else {
        return UNSUPPORTED;
    }
}
Body of Second Method:
{
    // This isn't actually enforcing any security; it just returns the
    // unsupported value. The real filtering is done at the kernel level.
    final int callingUid = android.os.Process.myUid();
    if (callingUid == android.os.Process.SYSTEM_UID || callingUid == uid) {
        try {
            return getStatsService().getUidStats(uid, TYPE_RX_PACKETS);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    } else {
        return UNSUPPORTED;
    }
}
------------------------
Find a silently evolved API code:android.widget.ListPopupWindow.show:COMMENT
Method Modifier: public      
Comment:/**
 * Show the popup list. If the list is already showing, this method
 * will recalculate the popup's size and position.
 */

Body of Frist Method:
{
    int height = buildDropDown();
    final boolean noInputMethod = isInputMethodNotNeeded();
    mPopup.setAllowScrollingAnchorParent(!noInputMethod);
    mPopup.setWindowLayoutType(mDropDownWindowLayoutType);
    if (mPopup.isShowing()) {
        if (!getAnchorView().isAttachedToWindow()) {
            // Don't update position if the anchor view is detached from window.
            return;
        }
        final int widthSpec;
        if (mDropDownWidth == ViewGroup.LayoutParams.MATCH_PARENT) {
            // The call to PopupWindow's update method below can accept -1 for any
            // value you do not want to update.
            widthSpec = -1;
        } else if (mDropDownWidth == ViewGroup.LayoutParams.WRAP_CONTENT) {
            widthSpec = getAnchorView().getWidth();
        } else {
            widthSpec = mDropDownWidth;
        }
        final int heightSpec;
        if (mDropDownHeight == ViewGroup.LayoutParams.MATCH_PARENT) {
            // The call to PopupWindow's update method below can accept -1 for any
            // value you do not want to update.
            heightSpec = noInputMethod ? height : ViewGroup.LayoutParams.MATCH_PARENT;
            if (noInputMethod) {
                mPopup.setWidth(mDropDownWidth == ViewGroup.LayoutParams.MATCH_PARENT ? ViewGroup.LayoutParams.MATCH_PARENT : 0);
                mPopup.setHeight(0);
            } else {
                mPopup.setWidth(mDropDownWidth == ViewGroup.LayoutParams.MATCH_PARENT ? ViewGroup.LayoutParams.MATCH_PARENT : 0);
                mPopup.setHeight(ViewGroup.LayoutParams.MATCH_PARENT);
            }
        } else if (mDropDownHeight == ViewGroup.LayoutParams.WRAP_CONTENT) {
            heightSpec = height;
        } else {
            heightSpec = mDropDownHeight;
        }
        mPopup.setOutsideTouchable(!mForceIgnoreOutsideTouch && !mDropDownAlwaysVisible);
        mPopup.update(getAnchorView(), mDropDownHorizontalOffset, mDropDownVerticalOffset, (widthSpec < 0) ? -1 : widthSpec, (heightSpec < 0) ? -1 : heightSpec);
    } else {
        final int widthSpec;
        if (mDropDownWidth == ViewGroup.LayoutParams.MATCH_PARENT) {
            widthSpec = ViewGroup.LayoutParams.MATCH_PARENT;
        } else {
            if (mDropDownWidth == ViewGroup.LayoutParams.WRAP_CONTENT) {
                widthSpec = getAnchorView().getWidth();
            } else {
                widthSpec = mDropDownWidth;
            }
        }
        final int heightSpec;
        if (mDropDownHeight == ViewGroup.LayoutParams.MATCH_PARENT) {
            heightSpec = ViewGroup.LayoutParams.MATCH_PARENT;
        } else {
            if (mDropDownHeight == ViewGroup.LayoutParams.WRAP_CONTENT) {
                heightSpec = height;
            } else {
                heightSpec = mDropDownHeight;
            }
        }
        mPopup.setWidth(widthSpec);
        mPopup.setHeight(heightSpec);
        mPopup.setClipToScreenEnabled(true);
        // use outside touchable to dismiss drop down when touching outside of it, so
        // only set this if the dropdown is not always visible
        mPopup.setOutsideTouchable(!mForceIgnoreOutsideTouch && !mDropDownAlwaysVisible);
        mPopup.setTouchInterceptor(mTouchInterceptor);
        mPopup.setEpicenterBounds(mEpicenterBounds);
        if (mOverlapAnchorSet) {
            mPopup.setOverlapAnchor(mOverlapAnchor);
        }
        mPopup.showAsDropDown(getAnchorView(), mDropDownHorizontalOffset, mDropDownVerticalOffset, mDropDownGravity);
        mDropDownList.setSelection(ListView.INVALID_POSITION);
        if (!mModal || mDropDownList.isInTouchMode()) {
            clearListSelection();
        }
        if (!mModal) {
            mHandler.post(mHideSelector);
        }
    }
}
Body of Second Method:
{
    int height = buildDropDown();
    final boolean noInputMethod = isInputMethodNotNeeded();
    mPopup.setAllowScrollingAnchorParent(!noInputMethod);
    mPopup.setWindowLayoutType(mDropDownWindowLayoutType);
    if (mPopup.isShowing()) {
        if (!getAnchorView().isAttachedToWindow()) {
            // Don't update position if the anchor view is detached from window.
            return;
        }
        final int widthSpec;
        if (mDropDownWidth == ViewGroup.LayoutParams.MATCH_PARENT) {
            // The call to PopupWindow's update method below can accept -1 for any
            // value you do not want to update.
            widthSpec = -1;
        } else if (mDropDownWidth == ViewGroup.LayoutParams.WRAP_CONTENT) {
            widthSpec = getAnchorView().getWidth();
        } else {
            widthSpec = mDropDownWidth;
        }
        final int heightSpec;
        if (mDropDownHeight == ViewGroup.LayoutParams.MATCH_PARENT) {
            // The call to PopupWindow's update method below can accept -1 for any
            // value you do not want to update.
            heightSpec = noInputMethod ? height : ViewGroup.LayoutParams.MATCH_PARENT;
            if (noInputMethod) {
                mPopup.setWidth(mDropDownWidth == ViewGroup.LayoutParams.MATCH_PARENT ? ViewGroup.LayoutParams.MATCH_PARENT : 0);
                mPopup.setHeight(0);
            } else {
                mPopup.setWidth(mDropDownWidth == ViewGroup.LayoutParams.MATCH_PARENT ? ViewGroup.LayoutParams.MATCH_PARENT : 0);
                mPopup.setHeight(ViewGroup.LayoutParams.MATCH_PARENT);
            }
        } else if (mDropDownHeight == ViewGroup.LayoutParams.WRAP_CONTENT) {
            heightSpec = height;
        } else {
            heightSpec = mDropDownHeight;
        }
        mPopup.setOutsideTouchable(!mForceIgnoreOutsideTouch && !mDropDownAlwaysVisible);
        mPopup.update(getAnchorView(), mDropDownHorizontalOffset, mDropDownVerticalOffset, (widthSpec < 0) ? -1 : widthSpec, (heightSpec < 0) ? -1 : heightSpec);
        mPopup.getContentView().restoreDefaultFocus();
    } else {
        final int widthSpec;
        if (mDropDownWidth == ViewGroup.LayoutParams.MATCH_PARENT) {
            widthSpec = ViewGroup.LayoutParams.MATCH_PARENT;
        } else {
            if (mDropDownWidth == ViewGroup.LayoutParams.WRAP_CONTENT) {
                widthSpec = getAnchorView().getWidth();
            } else {
                widthSpec = mDropDownWidth;
            }
        }
        final int heightSpec;
        if (mDropDownHeight == ViewGroup.LayoutParams.MATCH_PARENT) {
            heightSpec = ViewGroup.LayoutParams.MATCH_PARENT;
        } else {
            if (mDropDownHeight == ViewGroup.LayoutParams.WRAP_CONTENT) {
                heightSpec = height;
            } else {
                heightSpec = mDropDownHeight;
            }
        }
        mPopup.setWidth(widthSpec);
        mPopup.setHeight(heightSpec);
        mPopup.setClipToScreenEnabled(true);
        // use outside touchable to dismiss drop down when touching outside of it, so
        // only set this if the dropdown is not always visible
        mPopup.setOutsideTouchable(!mForceIgnoreOutsideTouch && !mDropDownAlwaysVisible);
        mPopup.setTouchInterceptor(mTouchInterceptor);
        mPopup.setEpicenterBounds(mEpicenterBounds);
        if (mOverlapAnchorSet) {
            mPopup.setOverlapAnchor(mOverlapAnchor);
        }
        mPopup.showAsDropDown(getAnchorView(), mDropDownHorizontalOffset, mDropDownVerticalOffset, mDropDownGravity);
        mDropDownList.setSelection(ListView.INVALID_POSITION);
        mPopup.getContentView().restoreDefaultFocus();
        if (!mModal || mDropDownList.isInTouchMode()) {
            clearListSelection();
        }
        if (!mModal) {
            mHandler.post(mHideSelector);
        }
    }
}
------------------------
Find a silently evolved API code:android.hardware.Camera.release:COMMENT
Method Modifier: public      final       deprecated  
Comment:/**
 * Disconnects and releases the Camera object resources.
 *
 * <p>You must call this as soon as you're done with the Camera object.</p>
 */

Body of Frist Method:
{
    native_release();
    mFaceDetectionRunning = false;
}
Body of Second Method:
{
    native_release();
    mFaceDetectionRunning = false;
    releaseAppOps();
}
------------------------
Find a silently evolved API code:android.bluetooth.le.AdvertisingSetParameters.isScannable:COMMENT
Method Modifier: public      
Comment:/**
 * Returns whether the advertisement will be scannable.
 */

Body of Frist Method:
{
    return scannable;
}
Body of Second Method:
{
    return mScannable;
}
------------------------
Find a silently evolved API code:android.app.timezone.RulesUpdaterContract.sendBroadcast:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Broadcasts an {@link #ACTION_TRIGGER_RULES_UPDATE_CHECK} intent with the
 * {@link #EXTRA_CHECK_TOKEN} that triggers an update check, including the required receiver
 * permission.
 */

Body of Frist Method:
{
    Intent intent = createUpdaterIntent(updaterAppPackageName);
    intent.putExtra(EXTRA_CHECK_TOKEN, checkTokenBytes);
    context.sendBroadcastAsUser(intent, UserHandle.of(UserHandle.myUserId()), RulesUpdaterContract.UPDATE_TIME_ZONE_RULES_PERMISSION);
}
Body of Second Method:
{
    Intent intent = createUpdaterIntent(updaterAppPackageName);
    intent.putExtra(EXTRA_CHECK_TOKEN, checkTokenBytes);
    context.sendBroadcastAsUser(intent, UserHandle.SYSTEM, RulesUpdaterContract.UPDATE_TIME_ZONE_RULES_PERMISSION);
}
------------------------
Find a silently evolved API code:android.bluetooth.le.PeriodicAdvertisingParameters.getIncludeTxPower:COMMENT
Method Modifier: public      
Comment:/**
 * Returns whether the TX Power will be included.
 */

Body of Frist Method:
{
    return includeTxPower;
}
Body of Second Method:
{
    return mIncludeTxPower;
}
------------------------
Find a silently evolved API code:android.app.ActivityManagerNative.noteWakeupAlarm:COMMENT
Method Modifier: public      static      hidden      deprecated  
Comment:/**
 * @deprecated use ActivityManager.noteWakeupAlarm instead.
 */

Body of Frist Method:
{
    ActivityManager.noteWakeupAlarm(ps, sourceUid, sourcePkg, tag);
}
Body of Second Method:
{
    ActivityManager.noteWakeupAlarm(ps, null, sourceUid, sourcePkg, tag);
}
------------------------
Find a silently evolved API code:android.telephony.mbms.MbmsUtils.getEmbmsTempFileDirForService:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Returns a File linked to the directory used to store temp files for this file service
 */

Body of Frist Method:
{
    File embmsTempFileDir = MbmsTempFileProvider.getEmbmsTempFileDir(context);
    return new File(embmsTempFileDir, serviceId);
}
Body of Second Method:
{
    // Replace all non-alphanumerics/underscores with an underscore. Some filesystems don't
    // like special characters.
    String sanitizedServiceId = serviceId.replaceAll("[^a-zA-Z0-9_]", "_");
    File embmsTempFileDir = MbmsTempFileProvider.getEmbmsTempFileDir(context);
    return new File(embmsTempFileDir, sanitizedServiceId);
}
------------------------
Find a silently evolved API code:android.net.apf.Bpf2Apf.main:COMMENT
Method Modifier: public      static      
Comment:/**
 * Convert the output of "tcpdump -d" (human readable BPF program dump) piped in stdin into an
 * APF program and output it via stdout.
 */

Body of Frist Method:
{
    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
    String line = null;
    StringBuilder responseData = new StringBuilder();
    ApfGenerator gen = new ApfGenerator();
    while ((line = in.readLine()) != null) convertLine(line, gen);
    System.out.write(gen.generate());
}
Body of Second Method:
{
    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
    String line = null;
    StringBuilder responseData = new StringBuilder();
    ApfGenerator gen = new ApfGenerator(3);
    while ((line = in.readLine()) != null) convertLine(line, gen);
    System.out.write(gen.generate());
}
------------------------
Find a silently evolved API code:android.content.ContentResolver.isSyncPendingAsUser:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @see #requestSync(Account, String, Bundle)
 * @hide
 */

Body of Frist Method:
{
    try {
        return getContentService().isSyncPendingAsUser(account, authority, null, userId);
    } catch (RemoteException e) {
        throw new RuntimeException("the ContentService should always be reachable", e);
    }
}
Body of Second Method:
{
    try {
        return getContentService().isSyncPendingAsUser(account, authority, null, userId);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.nfc.cardemulation.CardEmulation.isDefaultServiceForAid:COMMENT
Method Modifier: public      
Comment:/**
 * Allows an application to query whether a service is currently
 * the default handler for a specified ISO7816-4 Application ID.
 *
 * @param service The ComponentName of the service
 * @param aid The ISO7816-4 Application ID
 * @return whether the service is the default handler for the specified AID
 *
 * <p class="note">Requires the {@link android.Manifest.permission#NFC} permission.
 */

Body of Frist Method:
{
    try {
        return sService.isDefaultServiceForAid(UserHandle.myUserId(), service, aid);
    } catch (RemoteException e) {
        // Try one more time
        recoverService();
        if (sService == null) {
            Log.e(TAG, "Failed to recover CardEmulationService.");
            return false;
        }
        try {
            return sService.isDefaultServiceForAid(UserHandle.myUserId(), service, aid);
        } catch (RemoteException ee) {
            Log.e(TAG, "Failed to reach CardEmulationService.");
            return false;
        }
    }
}
Body of Second Method:
{
    try {
        return sService.isDefaultServiceForAid(mContext.getUserId(), service, aid);
    } catch (RemoteException e) {
        // Try one more time
        recoverService();
        if (sService == null) {
            Log.e(TAG, "Failed to recover CardEmulationService.");
            return false;
        }
        try {
            return sService.isDefaultServiceForAid(mContext.getUserId(), service, aid);
        } catch (RemoteException ee) {
            Log.e(TAG, "Failed to reach CardEmulationService.");
            return false;
        }
    }
}
------------------------
Find a silently evolved API code:android.view.Display.stateToString:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    switch(state) {
        case STATE_UNKNOWN:
            return "UNKNOWN";
        case STATE_OFF:
            return "OFF";
        case STATE_ON:
            return "ON";
        case STATE_DOZE:
            return "DOZE";
        case STATE_DOZE_SUSPEND:
            return "DOZE_SUSPEND";
        case STATE_VR:
            return "VR";
        default:
            return Integer.toString(state);
    }
}
Body of Second Method:
{
    switch(state) {
        case STATE_UNKNOWN:
            return "UNKNOWN";
        case STATE_OFF:
            return "OFF";
        case STATE_ON:
            return "ON";
        case STATE_DOZE:
            return "DOZE";
        case STATE_DOZE_SUSPEND:
            return "DOZE_SUSPEND";
        case STATE_VR:
            return "VR";
        case STATE_ON_SUSPEND:
            return "ON_SUSPEND";
        default:
            return Integer.toString(state);
    }
}
------------------------
Find a silently evolved API code:android.os.Debug.InstructionCount.collect:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * Collect instruction counts.  May or may not stop the
 * counting process.
 */

Body of Frist Method:
{
    try {
        VMDebug.stopInstructionCounting();
        VMDebug.getInstructionCount(mCounts);
    } catch (UnsupportedOperationException uoe) {
        return false;
    }
    return true;
}
Body of Second Method:
{
    return false;
}
------------------------
Find a silently evolved API code:android.nfc.NfcActivityManager.createBeamShareData:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Callback from NFC service, usually on binder thread
 */

Body of Frist Method:
{
    NfcAdapter.CreateNdefMessageCallback ndefCallback;
    NfcAdapter.CreateBeamUrisCallback urisCallback;
    NdefMessage message;
    Activity activity;
    Uri[] uris;
    int flags;
    NfcEvent event = new NfcEvent(mAdapter, peerLlcpVersion);
    synchronized (NfcActivityManager.this) {
        NfcActivityState state = findResumedActivityState();
        if (state == null)
            return null;
        ndefCallback = state.ndefMessageCallback;
        urisCallback = state.uriCallback;
        message = state.ndefMessage;
        uris = state.uris;
        flags = state.flags;
        activity = state.activity;
    }
    final long ident = Binder.clearCallingIdentity();
    try {
        // Make callbacks without lock
        if (ndefCallback != null) {
            message = ndefCallback.createNdefMessage(event);
        }
        if (urisCallback != null) {
            uris = urisCallback.createBeamUris(event);
            if (uris != null) {
                ArrayList<Uri> validUris = new ArrayList<Uri>();
                for (Uri uri : uris) {
                    if (uri == null) {
                        Log.e(TAG, "Uri not allowed to be null.");
                        continue;
                    }
                    String scheme = uri.getScheme();
                    if (scheme == null || (!scheme.equalsIgnoreCase("file") && !scheme.equalsIgnoreCase("content"))) {
                        Log.e(TAG, "Uri needs to have " + "either scheme file or scheme content");
                        continue;
                    }
                    uri = ContentProvider.maybeAddUserId(uri, UserHandle.myUserId());
                    validUris.add(uri);
                }
                uris = validUris.toArray(new Uri[validUris.size()]);
            }
        }
        if (uris != null && uris.length > 0) {
            for (Uri uri : uris) {
                // Grant the NFC process permission to read these URIs
                activity.grantUriPermission("com.android.nfc", uri, Intent.FLAG_GRANT_READ_URI_PERMISSION);
            }
        }
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
    return new BeamShareData(message, uris, new UserHandle(UserHandle.myUserId()), flags);
}
Body of Second Method:
{
    NfcAdapter.CreateNdefMessageCallback ndefCallback;
    NfcAdapter.CreateBeamUrisCallback urisCallback;
    NdefMessage message;
    Activity activity;
    Uri[] uris;
    int flags;
    NfcEvent event = new NfcEvent(mAdapter, peerLlcpVersion);
    synchronized (NfcActivityManager.this) {
        NfcActivityState state = findResumedActivityState();
        if (state == null)
            return null;
        ndefCallback = state.ndefMessageCallback;
        urisCallback = state.uriCallback;
        message = state.ndefMessage;
        uris = state.uris;
        flags = state.flags;
        activity = state.activity;
    }
    final long ident = Binder.clearCallingIdentity();
    try {
        // Make callbacks without lock
        if (ndefCallback != null) {
            message = ndefCallback.createNdefMessage(event);
        }
        if (urisCallback != null) {
            uris = urisCallback.createBeamUris(event);
            if (uris != null) {
                ArrayList<Uri> validUris = new ArrayList<Uri>();
                for (Uri uri : uris) {
                    if (uri == null) {
                        Log.e(TAG, "Uri not allowed to be null.");
                        continue;
                    }
                    String scheme = uri.getScheme();
                    if (scheme == null || (!scheme.equalsIgnoreCase("file") && !scheme.equalsIgnoreCase("content"))) {
                        Log.e(TAG, "Uri needs to have " + "either scheme file or scheme content");
                        continue;
                    }
                    uri = ContentProvider.maybeAddUserId(uri, activity.getUserId());
                    validUris.add(uri);
                }
                uris = validUris.toArray(new Uri[validUris.size()]);
            }
        }
        if (uris != null && uris.length > 0) {
            for (Uri uri : uris) {
                // Grant the NFC process permission to read these URIs
                activity.grantUriPermission("com.android.nfc", uri, Intent.FLAG_GRANT_READ_URI_PERMISSION);
            }
        }
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
    return new BeamShareData(message, uris, activity.getUser(), flags);
}
------------------------
Find a silently evolved API code:android.os.SystemClock.setCurrentTimeMillis:COMMENT
Method Modifier: public      static      
Comment:/**
 * Sets the current wall time, in milliseconds.  Requires the calling
 * process to have appropriate permissions.
 *
 * @return if the clock was successfully set to the specified time.
 */

Body of Frist Method:
{
    IBinder b = ServiceManager.getService(Context.ALARM_SERVICE);
    IAlarmManager mgr = IAlarmManager.Stub.asInterface(b);
    if (mgr == null) {
        return false;
    }
    try {
        return mgr.setTime(millis);
    } catch (RemoteException e) {
        Slog.e(TAG, "Unable to set RTC", e);
    } catch (SecurityException e) {
        Slog.e(TAG, "Unable to set RTC", e);
    }
    return false;
}
Body of Second Method:
{
    final IAlarmManager mgr = IAlarmManager.Stub.asInterface(ServiceManager.getService(Context.ALARM_SERVICE));
    if (mgr == null) {
        return false;
    }
    try {
        return mgr.setTime(millis);
    } catch (RemoteException e) {
        Slog.e(TAG, "Unable to set RTC", e);
    } catch (SecurityException e) {
        Slog.e(TAG, "Unable to set RTC", e);
    }
    return false;
}
------------------------
Find a silently evolved API code:android.telephony.CellIdentityWcdma.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Implement the Parcelable interface
 */

Body of Frist Method:
{
    if (DBG)
        log("writeToParcel(Parcel, int): " + toString());
    dest.writeInt(mMcc);
    dest.writeInt(mMnc);
    dest.writeInt(mLac);
    dest.writeInt(mCid);
    dest.writeInt(mPsc);
    dest.writeInt(mUarfcn);
}
Body of Second Method:
{
    if (DBG)
        log("writeToParcel(Parcel, int): " + toString());
    super.writeToParcel(dest, TYPE_WCDMA);
    dest.writeInt(mLac);
    dest.writeInt(mCid);
    dest.writeInt(mPsc);
    dest.writeInt(mUarfcn);
}
------------------------
Find a silently evolved API code:android.telephony.SignalStrength.validateInput:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Validate the individual signal strength fields as per the range
 * specified in ril.h
 * Set to invalid any field that is not in the valid range
 * Cdma, evdo, lte rsrp & rsrq values are sign converted
 * when received from ril interface
 *
 * @return
 * Valid values for all signalstrength fields
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("Signal before validate=" + this);
    // TS 27.007 8.5
    mGsmSignalStrength = mGsmSignalStrength >= 0 ? mGsmSignalStrength : 99;
    // BER no change;
    mCdmaDbm = mCdmaDbm > 0 ? -mCdmaDbm : -120;
    mCdmaEcio = (mCdmaEcio > 0) ? -mCdmaEcio : -160;
    mEvdoDbm = (mEvdoDbm > 0) ? -mEvdoDbm : -120;
    mEvdoEcio = (mEvdoEcio >= 0) ? -mEvdoEcio : -1;
    mEvdoSnr = ((mEvdoSnr > 0) && (mEvdoSnr <= 8)) ? mEvdoSnr : -1;
    // TS 36.214 Physical Layer Section 5.1.3, TS 36.331 RRC
    mLteSignalStrength = (mLteSignalStrength >= 0) ? mLteSignalStrength : 99;
    mLteRsrp = ((mLteRsrp >= 44) && (mLteRsrp <= 140)) ? -mLteRsrp : SignalStrength.INVALID;
    mLteRsrq = ((mLteRsrq >= 3) && (mLteRsrq <= 20)) ? -mLteRsrq : SignalStrength.INVALID;
    mLteRssnr = ((mLteRssnr >= -200) && (mLteRssnr <= 300)) ? mLteRssnr : SignalStrength.INVALID;
    mTdScdmaRscp = ((mTdScdmaRscp >= 25) && (mTdScdmaRscp <= 120)) ? -mTdScdmaRscp : SignalStrength.INVALID;
    // Cqi no change
    if (DBG)
        log("Signal after validate=" + this);
}
Body of Second Method:
{
    if (DBG)
        log("Signal before validate=" + this);
    // TS 27.007 8.5
    mGsmSignalStrength = mGsmSignalStrength >= 0 ? mGsmSignalStrength : 99;
    mWcdmaSignalStrength = (mWcdmaSignalStrength >= 0) ? mWcdmaSignalStrength : 99;
    mLteSignalStrength = (mLteSignalStrength >= 0) ? mLteSignalStrength : 99;
    // BER no change;
    // WCDMA RSCP valid values are -120 through -24 as defined in TS 27.007 8.69
    // but are reported in ASU which is 0 through 96, so we do the conversion here
    mWcdmaRscpAsu = ((mWcdmaRscpAsu - 120 >= MIN_WCDMA_RSCP) && (mWcdmaRscpAsu - 120 <= MAX_WCDMA_RSCP)) ? mWcdmaRscpAsu : 255;
    mWcdmaRscp = ((mWcdmaRscp >= MIN_WCDMA_RSCP) && (mWcdmaRscp <= MAX_WCDMA_RSCP)) ? mWcdmaRscp : INVALID;
    mCdmaDbm = mCdmaDbm > 0 ? -mCdmaDbm : -120;
    mCdmaEcio = (mCdmaEcio >= 0) ? -mCdmaEcio : -160;
    mEvdoDbm = (mEvdoDbm > 0) ? -mEvdoDbm : -120;
    mEvdoEcio = (mEvdoEcio >= 0) ? -mEvdoEcio : -160;
    mEvdoSnr = ((mEvdoSnr >= 0) && (mEvdoSnr <= 8)) ? mEvdoSnr : -1;
    // TS 36.214 Physical Layer Section 5.1.3, TS 36.331 RRC
    mLteRsrp = ((-mLteRsrp >= MIN_LTE_RSRP) && (-mLteRsrp <= MAX_LTE_RSRP)) ? -mLteRsrp : SignalStrength.INVALID;
    mLteRsrq = ((mLteRsrq >= 3) && (mLteRsrq <= 20)) ? -mLteRsrq : SignalStrength.INVALID;
    mLteRssnr = ((mLteRssnr >= -200) && (mLteRssnr <= 300)) ? mLteRssnr : SignalStrength.INVALID;
    mTdScdmaRscp = ((mTdScdmaRscp >= 0) && (mTdScdmaRscp <= 96)) ? (mTdScdmaRscp - 120) : SignalStrength.INVALID;
    // Cqi no change
    if (DBG)
        log("Signal after validate=" + this);
}
------------------------
Find a silently evolved API code:android.graphics.Picture.endRecording:COMMENT
Method Modifier: public      
Comment:/**
 * Call endRecording when the picture is built. After this call, the picture
 * may be drawn, but the canvas that was returned by beginRecording must not
 * be used anymore. This is automatically called if {@link Picture#draw}
 * or {@link Canvas#drawPicture(Picture)} is called.
 */

Body of Frist Method:
{
    if (mRecordingCanvas != null) {
        mRecordingCanvas = null;
        nativeEndRecording(mNativePicture);
    }
}
Body of Second Method:
{
    if (mRecordingCanvas != null) {
        mRequiresHwAcceleration = mRecordingCanvas.mHoldsHwBitmap;
        mRecordingCanvas = null;
        nativeEndRecording(mNativePicture);
    }
}
------------------------
Find a silently evolved API code:android.hardware.camera2.CaptureRequest.get:COMMENT
Method Modifier: public      
Comment:/**
 * Get a capture request field value.
 *
 * <p>The field definitions can be found in {@link CaptureRequest}.</p>
 *
 * <p>Querying the value for the same key more than once will return a value
 * which is equal to the previous queried value.</p>
 *
 * @throws IllegalArgumentException if the key was not valid
 *
 * @param key The result field to read.
 * @return The value of that key, or {@code null} if the field is not set.
 */

Body of Frist Method:
{
    return mSettings.get(key);
}
Body of Second Method:
{
    return mLogicalCameraSettings.get(key);
}
------------------------
Find a silently evolved API code:android.os.ZygoteProcess.waitForConnectionToZygote:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Try connecting to the Zygote over and over again until we hit a time-out.
 * @param socketName The name of the socket to connect to.
 */

Body of Frist Method:
{
    for (int n = 20; n >= 0; n--) {
        try {
            final ZygoteState zs = ZygoteState.connect(socketName);
            zs.close();
            return;
        } catch (IOException ioe) {
            Log.w(LOG_TAG, "Got error connecting to zygote, retrying. msg= " + ioe.getMessage());
        }
        try {
            Thread.sleep(1000);
        } catch (InterruptedException ie) {
        }
    }
    Slog.wtf(LOG_TAG, "Failed to connect to Zygote through socket " + socketName);
}
Body of Second Method:
{
    final LocalSocketAddress address = new LocalSocketAddress(socketName, LocalSocketAddress.Namespace.RESERVED);
    waitForConnectionToZygote(address);
}
------------------------
Find a silently evolved API code:android.text.SpannableStringInternal.removeSpan:COMMENT
Method Modifier: default     
Comment:/* package */

Body of Frist Method:
{
    int count = mSpanCount;
    Object[] spans = mSpans;
    int[] data = mSpanData;
    for (int i = count - 1; i >= 0; i--) {
        if (spans[i] == what) {
            int ostart = data[i * COLUMNS + START];
            int oend = data[i * COLUMNS + END];
            int c = count - (i + 1);
            System.arraycopy(spans, i + 1, spans, i, c);
            System.arraycopy(data, (i + 1) * COLUMNS, data, i * COLUMNS, c * COLUMNS);
            mSpanCount--;
            sendSpanRemoved(what, ostart, oend);
            return;
        }
    }
}
Body of Second Method:
{
    removeSpan(what, 0);
}
------------------------
Find a silently evolved API code:android.bluetooth.le.PeriodicAdvertisingParameters.Builder.setIncludeTxPower:COMMENT
Method Modifier: public      
Comment:/**
 * Whether the transmission power level should be included in the periodic
 * packet.
 */

Body of Frist Method:
{
    this.includeTxPower = includeTxPower;
    return this;
}
Body of Second Method:
{
    mIncludeTxPower = includeTxPower;
    return this;
}
------------------------
Find a silently evolved API code:android.media.session.MediaController.setVolumeTo:COMMENT
Method Modifier: public      
Comment:/**
 * Set the volume of the output this session is playing on. The command will
 * be ignored if it does not support
 * {@link VolumeProvider#VOLUME_CONTROL_ABSOLUTE}. The flags in
 * {@link AudioManager} may be used to affect the handling.
 *
 * @see #getPlaybackInfo()
 * @param value The value to set it to, between 0 and the reported max.
 * @param flags Flags from {@link AudioManager} to include with the volume
 * request.
 */

Body of Frist Method:
{
    try {
        mSessionBinder.setVolumeTo(value, flags, mContext.getPackageName());
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling setVolumeTo.", e);
    }
}
Body of Second Method:
{
    try {
        mSessionBinder.setVolumeTo(mContext.getPackageName(), mCbStub, value, flags);
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling setVolumeTo.", e);
    }
}
------------------------
Find a silently evolved API code:android.content.pm.PackageManager.getPackageSizeInfo:COMMENT
Method Modifier: public      hidden      deprecated  
Comment:/**
 * Like {@link #getPackageSizeInfoAsUser(String, int, IPackageStatsObserver)}, but
 * returns the size for the calling user.
 *
 * @deprecated use {@link StorageStatsManager} instead.
 * @hide
 */

Body of Frist Method:
{
    getPackageSizeInfoAsUser(packageName, UserHandle.myUserId(), observer);
}
Body of Second Method:
{
    getPackageSizeInfoAsUser(packageName, getUserId(), observer);
}
------------------------
Find a silently evolved API code:android.app.Instrumentation.newApplication:COMMENT
Method Modifier: public      
Comment:/**
 * Perform instantiation of the process's {@link Application} object.  The
 * default implementation provides the normal system behavior.
 *
 * @param cl The ClassLoader with which to instantiate the object.
 * @param className The name of the class implementing the Application
 * object.
 * @param context The context to initialize the application with
 *
 * @return The newly instantiated Application object.
 */

Body of Frist Method:
{
    return newApplication(cl.loadClass(className), context);
}
Body of Second Method:
{
    Application app = getFactory(context.getPackageName()).instantiateApplication(cl, className);
    app.attach(context);
    return app;
}
------------------------
Find a silently evolved API code:android.os.Looper.writeToProto:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    final long looperToken = proto.start(fieldId);
    proto.write(LooperProto.THREAD_NAME, mThread.getName());
    proto.write(LooperProto.THREAD_ID, mThread.getId());
    proto.write(LooperProto.IDENTITY_HASH_CODE, System.identityHashCode(this));
    mQueue.writeToProto(proto, LooperProto.QUEUE);
    proto.end(looperToken);
}
Body of Second Method:
{
    final long looperToken = proto.start(fieldId);
    proto.write(LooperProto.THREAD_NAME, mThread.getName());
    proto.write(LooperProto.THREAD_ID, mThread.getId());
    mQueue.writeToProto(proto, LooperProto.QUEUE);
    proto.end(looperToken);
}
------------------------
Find a silently evolved API code:android.text.style.TypefaceSpan.writeToParcelInternal:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    dest.writeString(mFamily);
}
Body of Second Method:
{
    dest.writeString(mFamily);
    LeakyTypefaceStorage.writeTypefaceToParcel(mTypeface, dest);
}
------------------------
Find a silently evolved API code:android.telephony.euicc.EuiccManager.getEid:COMMENT
<android.telephony.euicc.EuiccManager: String getEid()>
public      hidden      ->public      
Method Modifier: public      hidden      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * Returns the EID identifying the eUICC hardware.
 *
 * <p>Requires that the calling app has carrier privileges on the active subscription on the
 * eUICC.
 *
 * @return the EID. May be null if {@link #isEnabled()} is false or the eUICC is not ready.
 */

Body of Frist Method:
{
    if (!isEnabled()) {
        return null;
    }
    try {
        return mController.getEid();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    if (!isEnabled()) {
        return null;
    }
    try {
        return getIEuiccController().getEid();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.app.usage.UsageEvents.writeEventToParcel:COMMENT
Method Modifier: private     
Comment:/**
 * Writes a single event to the parcel. Modify this when updating {@link Event}.
 */

Body of Frist Method:
{
    final int packageIndex;
    if (event.mPackage != null) {
        packageIndex = findStringIndex(event.mPackage);
    } else {
        packageIndex = -1;
    }
    final int classIndex;
    if (event.mClass != null) {
        classIndex = findStringIndex(event.mClass);
    } else {
        classIndex = -1;
    }
    p.writeInt(packageIndex);
    p.writeInt(classIndex);
    p.writeInt(event.mEventType);
    p.writeLong(event.mTimeStamp);
    switch(event.mEventType) {
        case Event.CONFIGURATION_CHANGE:
            event.mConfiguration.writeToParcel(p, flags);
            break;
        case Event.SHORTCUT_INVOCATION:
            p.writeString(event.mShortcutId);
            break;
        case Event.CHOOSER_ACTION:
            p.writeString(event.mAction);
            p.writeString(event.mContentType);
            p.writeStringArray(event.mContentAnnotations);
            break;
    }
}
Body of Second Method:
{
    final int packageIndex;
    if (event.mPackage != null) {
        packageIndex = findStringIndex(event.mPackage);
    } else {
        packageIndex = -1;
    }
    final int classIndex;
    if (event.mClass != null) {
        classIndex = findStringIndex(event.mClass);
    } else {
        classIndex = -1;
    }
    p.writeInt(packageIndex);
    p.writeInt(classIndex);
    p.writeInt(event.mEventType);
    p.writeLong(event.mTimeStamp);
    switch(event.mEventType) {
        case Event.CONFIGURATION_CHANGE:
            event.mConfiguration.writeToParcel(p, flags);
            break;
        case Event.SHORTCUT_INVOCATION:
            p.writeString(event.mShortcutId);
            break;
        case Event.CHOOSER_ACTION:
            p.writeString(event.mAction);
            p.writeString(event.mContentType);
            p.writeStringArray(event.mContentAnnotations);
            break;
        case Event.STANDBY_BUCKET_CHANGED:
            p.writeInt(event.mBucketAndReason);
            break;
        case Event.NOTIFICATION_INTERRUPTION:
            p.writeString(event.mNotificationChannelId);
            break;
    }
}
------------------------
Find a silently evolved API code:android.widget.LinearLayout.measureVertical:COMMENT
Method Modifier: default     
Comment:/**
 * Measures the children when the orientation of this LinearLayout is set
 * to {@link #VERTICAL}.
 *
 * @param widthMeasureSpec Horizontal space requirements as imposed by the parent.
 * @param heightMeasureSpec Vertical space requirements as imposed by the parent.
 *
 * @see #getOrientation()
 * @see #setOrientation(int)
 * @see #onMeasure(int, int)
 */

Body of Frist Method:
{
    mTotalLength = 0;
    int maxWidth = 0;
    int childState = 0;
    int alternativeMaxWidth = 0;
    int weightedMaxWidth = 0;
    boolean allFillParent = true;
    float totalWeight = 0;
    final int count = getVirtualChildCount();
    final int widthMode = MeasureSpec.getMode(widthMeasureSpec);
    final int heightMode = MeasureSpec.getMode(heightMeasureSpec);
    boolean matchWidth = false;
    boolean skippedMeasure = false;
    final int baselineChildIndex = mBaselineAlignedChildIndex;
    final boolean useLargestChild = mUseLargestChild;
    int largestChildHeight = Integer.MIN_VALUE;
    int consumedExcessSpace = 0;
    int nonSkippedChildCount = 0;
    // See how tall everyone is. Also remember max width.
    for (int i = 0; i < count; ++i) {
        final View child = getVirtualChildAt(i);
        if (child == null) {
            mTotalLength += measureNullChild(i);
            continue;
        }
        if (child.getVisibility() == View.GONE) {
            i += getChildrenSkipCount(child, i);
            continue;
        }
        nonSkippedChildCount++;
        if (hasDividerBeforeChildAt(i)) {
            mTotalLength += mDividerHeight;
        }
        final LayoutParams lp = (LayoutParams) child.getLayoutParams();
        totalWeight += lp.weight;
        final boolean useExcessSpace = lp.height == 0 && lp.weight > 0;
        if (heightMode == MeasureSpec.EXACTLY && useExcessSpace) {
            // Optimization: don't bother measuring children who are only
            // laid out using excess space. These views will get measured
            // later if we have space to distribute.
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin);
            skippedMeasure = true;
        } else {
            if (useExcessSpace) {
                // The heightMode is either UNSPECIFIED or AT_MOST, and
                // this child is only laid out using excess space. Measure
                // using WRAP_CONTENT so that we can find out the view's
                // optimal height. We'll restore the original height of 0
                // after measurement.
                lp.height = LayoutParams.WRAP_CONTENT;
            }
            // Determine how big this child would like to be. If this or
            // previous children have given a weight, then we allow it to
            // use all available space (and we will shrink things later
            // if needed).
            final int usedHeight = totalWeight == 0 ? mTotalLength : 0;
            measureChildBeforeLayout(child, i, widthMeasureSpec, 0, heightMeasureSpec, usedHeight);
            final int childHeight = child.getMeasuredHeight();
            if (useExcessSpace) {
                // Restore the original height and record how much space
                // we've allocated to excess-only children so that we can
                // match the behavior of EXACTLY measurement.
                lp.height = 0;
                consumedExcessSpace += childHeight;
            }
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
            if (useLargestChild) {
                largestChildHeight = Math.max(childHeight, largestChildHeight);
            }
        }
        /**
         * If applicable, compute the additional offset to the child's baseline
         * we'll need later when asked {@link #getBaseline}.
         */
        if ((baselineChildIndex >= 0) && (baselineChildIndex == i + 1)) {
            mBaselineChildTop = mTotalLength;
        }
        // weight.  fail fast to aid the developer.
        if (i < baselineChildIndex && lp.weight > 0) {
            throw new RuntimeException("A child of LinearLayout with index " + "less than mBaselineAlignedChildIndex has weight > 0, which " + "won't work.  Either remove the weight, or don't set " + "mBaselineAlignedChildIndex.");
        }
        boolean matchWidthLocally = false;
        if (widthMode != MeasureSpec.EXACTLY && lp.width == LayoutParams.MATCH_PARENT) {
            // The width of the linear layout will scale, and at least one
            // child said it wanted to match our width. Set a flag
            // indicating that we need to remeasure at least that view when
            // we know our width.
            matchWidth = true;
            matchWidthLocally = true;
        }
        final int margin = lp.leftMargin + lp.rightMargin;
        final int measuredWidth = child.getMeasuredWidth() + margin;
        maxWidth = Math.max(maxWidth, measuredWidth);
        childState = combineMeasuredStates(childState, child.getMeasuredState());
        allFillParent = allFillParent && lp.width == LayoutParams.MATCH_PARENT;
        if (lp.weight > 0) {
            /*
                 * Widths of weighted Views are bogus if we end up
                 * remeasuring, so keep them separate.
                 */
            weightedMaxWidth = Math.max(weightedMaxWidth, matchWidthLocally ? margin : measuredWidth);
        } else {
            alternativeMaxWidth = Math.max(alternativeMaxWidth, matchWidthLocally ? margin : measuredWidth);
        }
        i += getChildrenSkipCount(child, i);
    }
    if (nonSkippedChildCount > 0 && hasDividerBeforeChildAt(count)) {
        mTotalLength += mDividerHeight;
    }
    if (useLargestChild && (heightMode == MeasureSpec.AT_MOST || heightMode == MeasureSpec.UNSPECIFIED)) {
        mTotalLength = 0;
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child == null) {
                mTotalLength += measureNullChild(i);
                continue;
            }
            if (child.getVisibility() == GONE) {
                i += getChildrenSkipCount(child, i);
                continue;
            }
            final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
            // Account for negative margins
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + largestChildHeight + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
        }
    }
    // Add in our padding
    mTotalLength += mPaddingTop + mPaddingBottom;
    int heightSize = mTotalLength;
    // Check against our minimum height
    heightSize = Math.max(heightSize, getSuggestedMinimumHeight());
    // Reconcile our calculated size with the heightMeasureSpec
    int heightSizeAndState = resolveSizeAndState(heightSize, heightMeasureSpec, 0);
    heightSize = heightSizeAndState & MEASURED_SIZE_MASK;
    // Either expand children with weight to take up available space or
    // shrink them if they extend beyond our current bounds. If we skipped
    // measurement on any children, we need to measure them now.
    int remainingExcess = heightSize - mTotalLength + (mAllowInconsistentMeasurement ? 0 : consumedExcessSpace);
    if (skippedMeasure || remainingExcess != 0 && totalWeight > 0.0f) {
        float remainingWeightSum = mWeightSum > 0.0f ? mWeightSum : totalWeight;
        mTotalLength = 0;
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child == null || child.getVisibility() == View.GONE) {
                continue;
            }
            final LayoutParams lp = (LayoutParams) child.getLayoutParams();
            final float childWeight = lp.weight;
            if (childWeight > 0) {
                final int share = (int) (childWeight * remainingExcess / remainingWeightSum);
                remainingExcess -= share;
                remainingWeightSum -= childWeight;
                final int childHeight;
                if (mUseLargestChild && heightMode != MeasureSpec.EXACTLY) {
                    childHeight = largestChildHeight;
                } else if (lp.height == 0 && (!mAllowInconsistentMeasurement || heightMode == MeasureSpec.EXACTLY)) {
                    // This child needs to be laid out from scratch using
                    // only its share of excess space.
                    childHeight = share;
                } else {
                    // This child had some intrinsic height to which we
                    // need to add its share of excess space.
                    childHeight = child.getMeasuredHeight() + share;
                }
                final int childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(Math.max(0, childHeight), MeasureSpec.EXACTLY);
                final int childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin, lp.width);
                child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
                // Child may now not fit in vertical dimension.
                childState = combineMeasuredStates(childState, child.getMeasuredState() & (MEASURED_STATE_MASK >> MEASURED_HEIGHT_STATE_SHIFT));
            }
            final int margin = lp.leftMargin + lp.rightMargin;
            final int measuredWidth = child.getMeasuredWidth() + margin;
            maxWidth = Math.max(maxWidth, measuredWidth);
            boolean matchWidthLocally = widthMode != MeasureSpec.EXACTLY && lp.width == LayoutParams.MATCH_PARENT;
            alternativeMaxWidth = Math.max(alternativeMaxWidth, matchWidthLocally ? margin : measuredWidth);
            allFillParent = allFillParent && lp.width == LayoutParams.MATCH_PARENT;
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
        }
        // Add in our padding
        mTotalLength += mPaddingTop + mPaddingBottom;
    // TODO: Should we recompute the heightSpec based on the new total length?
    } else {
        alternativeMaxWidth = Math.max(alternativeMaxWidth, weightedMaxWidth);
        // Children will have already been measured once.
        if (useLargestChild && heightMode != MeasureSpec.EXACTLY) {
            for (int i = 0; i < count; i++) {
                final View child = getVirtualChildAt(i);
                if (child == null || child.getVisibility() == View.GONE) {
                    continue;
                }
                final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
                float childExtra = lp.weight;
                if (childExtra > 0) {
                    child.measure(MeasureSpec.makeMeasureSpec(child.getMeasuredWidth(), MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(largestChildHeight, MeasureSpec.EXACTLY));
                }
            }
        }
    }
    if (!allFillParent && widthMode != MeasureSpec.EXACTLY) {
        maxWidth = alternativeMaxWidth;
    }
    maxWidth += mPaddingLeft + mPaddingRight;
    // Check against our minimum width
    maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());
    setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState), heightSizeAndState);
    if (matchWidth) {
        forceUniformWidth(count, heightMeasureSpec);
    }
}
Body of Second Method:
{
    mTotalLength = 0;
    int maxWidth = 0;
    int childState = 0;
    int alternativeMaxWidth = 0;
    int weightedMaxWidth = 0;
    boolean allFillParent = true;
    float totalWeight = 0;
    final int count = getVirtualChildCount();
    final int widthMode = MeasureSpec.getMode(widthMeasureSpec);
    final int heightMode = MeasureSpec.getMode(heightMeasureSpec);
    boolean matchWidth = false;
    boolean skippedMeasure = false;
    final int baselineChildIndex = mBaselineAlignedChildIndex;
    final boolean useLargestChild = mUseLargestChild;
    int largestChildHeight = Integer.MIN_VALUE;
    int consumedExcessSpace = 0;
    int nonSkippedChildCount = 0;
    // See how tall everyone is. Also remember max width.
    for (int i = 0; i < count; ++i) {
        final View child = getVirtualChildAt(i);
        if (child == null) {
            mTotalLength += measureNullChild(i);
            continue;
        }
        if (child.getVisibility() == View.GONE) {
            i += getChildrenSkipCount(child, i);
            continue;
        }
        nonSkippedChildCount++;
        if (hasDividerBeforeChildAt(i)) {
            mTotalLength += mDividerHeight;
        }
        final LayoutParams lp = (LayoutParams) child.getLayoutParams();
        totalWeight += lp.weight;
        final boolean useExcessSpace = lp.height == 0 && lp.weight > 0;
        if (heightMode == MeasureSpec.EXACTLY && useExcessSpace) {
            // Optimization: don't bother measuring children who are only
            // laid out using excess space. These views will get measured
            // later if we have space to distribute.
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin);
            skippedMeasure = true;
        } else {
            if (useExcessSpace) {
                // The heightMode is either UNSPECIFIED or AT_MOST, and
                // this child is only laid out using excess space. Measure
                // using WRAP_CONTENT so that we can find out the view's
                // optimal height. We'll restore the original height of 0
                // after measurement.
                lp.height = LayoutParams.WRAP_CONTENT;
            }
            // Determine how big this child would like to be. If this or
            // previous children have given a weight, then we allow it to
            // use all available space (and we will shrink things later
            // if needed).
            final int usedHeight = totalWeight == 0 ? mTotalLength : 0;
            measureChildBeforeLayout(child, i, widthMeasureSpec, 0, heightMeasureSpec, usedHeight);
            final int childHeight = child.getMeasuredHeight();
            if (useExcessSpace) {
                // Restore the original height and record how much space
                // we've allocated to excess-only children so that we can
                // match the behavior of EXACTLY measurement.
                lp.height = 0;
                consumedExcessSpace += childHeight;
            }
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
            if (useLargestChild) {
                largestChildHeight = Math.max(childHeight, largestChildHeight);
            }
        }
        /**
         * If applicable, compute the additional offset to the child's baseline
         * we'll need later when asked {@link #getBaseline}.
         */
        if ((baselineChildIndex >= 0) && (baselineChildIndex == i + 1)) {
            mBaselineChildTop = mTotalLength;
        }
        // weight.  fail fast to aid the developer.
        if (i < baselineChildIndex && lp.weight > 0) {
            throw new RuntimeException("A child of LinearLayout with index " + "less than mBaselineAlignedChildIndex has weight > 0, which " + "won't work.  Either remove the weight, or don't set " + "mBaselineAlignedChildIndex.");
        }
        boolean matchWidthLocally = false;
        if (widthMode != MeasureSpec.EXACTLY && lp.width == LayoutParams.MATCH_PARENT) {
            // The width of the linear layout will scale, and at least one
            // child said it wanted to match our width. Set a flag
            // indicating that we need to remeasure at least that view when
            // we know our width.
            matchWidth = true;
            matchWidthLocally = true;
        }
        final int margin = lp.leftMargin + lp.rightMargin;
        final int measuredWidth = child.getMeasuredWidth() + margin;
        maxWidth = Math.max(maxWidth, measuredWidth);
        childState = combineMeasuredStates(childState, child.getMeasuredState());
        allFillParent = allFillParent && lp.width == LayoutParams.MATCH_PARENT;
        if (lp.weight > 0) {
            /*
                 * Widths of weighted Views are bogus if we end up
                 * remeasuring, so keep them separate.
                 */
            weightedMaxWidth = Math.max(weightedMaxWidth, matchWidthLocally ? margin : measuredWidth);
        } else {
            alternativeMaxWidth = Math.max(alternativeMaxWidth, matchWidthLocally ? margin : measuredWidth);
        }
        i += getChildrenSkipCount(child, i);
    }
    if (nonSkippedChildCount > 0 && hasDividerBeforeChildAt(count)) {
        mTotalLength += mDividerHeight;
    }
    if (useLargestChild && (heightMode == MeasureSpec.AT_MOST || heightMode == MeasureSpec.UNSPECIFIED)) {
        mTotalLength = 0;
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child == null) {
                mTotalLength += measureNullChild(i);
                continue;
            }
            if (child.getVisibility() == GONE) {
                i += getChildrenSkipCount(child, i);
                continue;
            }
            final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
            // Account for negative margins
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + largestChildHeight + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
        }
    }
    // Add in our padding
    mTotalLength += mPaddingTop + mPaddingBottom;
    int heightSize = mTotalLength;
    // Check against our minimum height
    heightSize = Math.max(heightSize, getSuggestedMinimumHeight());
    // Reconcile our calculated size with the heightMeasureSpec
    int heightSizeAndState = resolveSizeAndState(heightSize, heightMeasureSpec, 0);
    heightSize = heightSizeAndState & MEASURED_SIZE_MASK;
    // Either expand children with weight to take up available space or
    // shrink them if they extend beyond our current bounds. If we skipped
    // measurement on any children, we need to measure them now.
    int remainingExcess = heightSize - mTotalLength + (mAllowInconsistentMeasurement ? 0 : consumedExcessSpace);
    if (skippedMeasure || ((sRemeasureWeightedChildren || remainingExcess != 0) && totalWeight > 0.0f)) {
        float remainingWeightSum = mWeightSum > 0.0f ? mWeightSum : totalWeight;
        mTotalLength = 0;
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child == null || child.getVisibility() == View.GONE) {
                continue;
            }
            final LayoutParams lp = (LayoutParams) child.getLayoutParams();
            final float childWeight = lp.weight;
            if (childWeight > 0) {
                final int share = (int) (childWeight * remainingExcess / remainingWeightSum);
                remainingExcess -= share;
                remainingWeightSum -= childWeight;
                final int childHeight;
                if (mUseLargestChild && heightMode != MeasureSpec.EXACTLY) {
                    childHeight = largestChildHeight;
                } else if (lp.height == 0 && (!mAllowInconsistentMeasurement || heightMode == MeasureSpec.EXACTLY)) {
                    // This child needs to be laid out from scratch using
                    // only its share of excess space.
                    childHeight = share;
                } else {
                    // This child had some intrinsic height to which we
                    // need to add its share of excess space.
                    childHeight = child.getMeasuredHeight() + share;
                }
                final int childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(Math.max(0, childHeight), MeasureSpec.EXACTLY);
                final int childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin, lp.width);
                child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
                // Child may now not fit in vertical dimension.
                childState = combineMeasuredStates(childState, child.getMeasuredState() & (MEASURED_STATE_MASK >> MEASURED_HEIGHT_STATE_SHIFT));
            }
            final int margin = lp.leftMargin + lp.rightMargin;
            final int measuredWidth = child.getMeasuredWidth() + margin;
            maxWidth = Math.max(maxWidth, measuredWidth);
            boolean matchWidthLocally = widthMode != MeasureSpec.EXACTLY && lp.width == LayoutParams.MATCH_PARENT;
            alternativeMaxWidth = Math.max(alternativeMaxWidth, matchWidthLocally ? margin : measuredWidth);
            allFillParent = allFillParent && lp.width == LayoutParams.MATCH_PARENT;
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
        }
        // Add in our padding
        mTotalLength += mPaddingTop + mPaddingBottom;
    // TODO: Should we recompute the heightSpec based on the new total length?
    } else {
        alternativeMaxWidth = Math.max(alternativeMaxWidth, weightedMaxWidth);
        // Children will have already been measured once.
        if (useLargestChild && heightMode != MeasureSpec.EXACTLY) {
            for (int i = 0; i < count; i++) {
                final View child = getVirtualChildAt(i);
                if (child == null || child.getVisibility() == View.GONE) {
                    continue;
                }
                final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
                float childExtra = lp.weight;
                if (childExtra > 0) {
                    child.measure(MeasureSpec.makeMeasureSpec(child.getMeasuredWidth(), MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(largestChildHeight, MeasureSpec.EXACTLY));
                }
            }
        }
    }
    if (!allFillParent && widthMode != MeasureSpec.EXACTLY) {
        maxWidth = alternativeMaxWidth;
    }
    maxWidth += mPaddingLeft + mPaddingRight;
    // Check against our minimum width
    maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());
    setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState), heightSizeAndState);
    if (matchWidth) {
        forceUniformWidth(count, heightMeasureSpec);
    }
}
------------------------
Find a silently evolved API code:android.content.pm.ShortcutManager.injectMyUserId:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * @hide injection point
 */

Body of Frist Method:
{
    return UserHandle.myUserId();
}
Body of Second Method:
{
    return mContext.getUserId();
}
------------------------
Find a silently evolved API code:android.content.pm.PermissionInfo.fixProtectionLevel:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (level == PROTECTION_SIGNATURE_OR_SYSTEM) {
        level = PROTECTION_SIGNATURE | PROTECTION_FLAG_PRIVILEGED;
    }
    return level;
}
Body of Second Method:
{
    if (level == PROTECTION_SIGNATURE_OR_SYSTEM) {
        level = PROTECTION_SIGNATURE | PROTECTION_FLAG_PRIVILEGED;
    }
    if ((level & PROTECTION_FLAG_VENDOR_PRIVILEGED) != 0 && (level & PROTECTION_FLAG_PRIVILEGED) == 0) {
        // 'vendorPrivileged' must be 'privileged'. If not,
        // drop the vendorPrivileged.
        level = level & ~PROTECTION_FLAG_VENDOR_PRIVILEGED;
    }
    return level;
}
------------------------
Find a silently evolved API code:android.media.AudioFormat.isPublicEncoding:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    switch(audioFormat) {
        case ENCODING_PCM_8BIT:
        case ENCODING_PCM_16BIT:
        case ENCODING_PCM_FLOAT:
        case ENCODING_AC3:
        case ENCODING_E_AC3:
        case ENCODING_DTS:
        case ENCODING_DTS_HD:
        case ENCODING_IEC61937:
            return true;
        default:
            return false;
    }
}
Body of Second Method:
{
    switch(audioFormat) {
        case ENCODING_PCM_8BIT:
        case ENCODING_PCM_16BIT:
        case ENCODING_PCM_FLOAT:
        case ENCODING_AC3:
        case ENCODING_E_AC3:
        case ENCODING_E_AC3_JOC:
        case ENCODING_DTS:
        case ENCODING_DTS_HD:
        case ENCODING_IEC61937:
        case ENCODING_MP3:
        case ENCODING_AAC_LC:
        case ENCODING_AAC_HE_V1:
        case ENCODING_AAC_HE_V2:
        case ENCODING_AAC_ELD:
        case ENCODING_AAC_XHE:
        case ENCODING_AC4:
            return true;
        default:
            return false;
    }
}
------------------------
Find a silently evolved API code:android.util.proto.ProtoOutputStream.start:COMMENT
Method Modifier: public      
Comment:/**
 * Start a sub object.
 */

Body of Frist Method:
{
    assertNotCompacted();
    final int id = (int) fieldId;
    if ((fieldId & FIELD_TYPE_MASK) == FIELD_TYPE_OBJECT) {
        final long count = fieldId & FIELD_COUNT_MASK;
        if (count == FIELD_COUNT_SINGLE) {
            return startObjectImpl(id, false);
        } else if (count == FIELD_COUNT_REPEATED || count == FIELD_COUNT_PACKED) {
            return startObjectImpl(id, true);
        }
    }
    throw new IllegalArgumentException("Attempt to call start(long) with " + getFieldIdString(fieldId));
}
Body of Second Method:
{
    assertNotCompacted();
    final int id = (int) fieldId;
    if ((fieldId & FIELD_TYPE_MASK) == FIELD_TYPE_MESSAGE) {
        final long count = fieldId & FIELD_COUNT_MASK;
        if (count == FIELD_COUNT_SINGLE) {
            return startObjectImpl(id, false);
        } else if (count == FIELD_COUNT_REPEATED || count == FIELD_COUNT_PACKED) {
            return startObjectImpl(id, true);
        }
    }
    throw new IllegalArgumentException("Attempt to call start(long) with " + getFieldIdString(fieldId));
}
------------------------
Find a silently evolved API code:android.telephony.SignalStrength.setFromNotifierBundle:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Set SignalStrength based on intent notifier map
 *
 * @param m intent notifier map
 * @hide
 */

Body of Frist Method:
{
    mGsmSignalStrength = m.getInt("GsmSignalStrength");
    mGsmBitErrorRate = m.getInt("GsmBitErrorRate");
    mCdmaDbm = m.getInt("CdmaDbm");
    mCdmaEcio = m.getInt("CdmaEcio");
    mEvdoDbm = m.getInt("EvdoDbm");
    mEvdoEcio = m.getInt("EvdoEcio");
    mEvdoSnr = m.getInt("EvdoSnr");
    mLteSignalStrength = m.getInt("LteSignalStrength");
    mLteRsrp = m.getInt("LteRsrp");
    mLteRsrq = m.getInt("LteRsrq");
    mLteRssnr = m.getInt("LteRssnr");
    mLteCqi = m.getInt("LteCqi");
    mLteRsrpBoost = m.getInt("lteRsrpBoost");
    mTdScdmaRscp = m.getInt("TdScdma");
    isGsm = m.getBoolean("isGsm");
}
Body of Second Method:
{
    mGsmSignalStrength = m.getInt("GsmSignalStrength");
    mGsmBitErrorRate = m.getInt("GsmBitErrorRate");
    mCdmaDbm = m.getInt("CdmaDbm");
    mCdmaEcio = m.getInt("CdmaEcio");
    mEvdoDbm = m.getInt("EvdoDbm");
    mEvdoEcio = m.getInt("EvdoEcio");
    mEvdoSnr = m.getInt("EvdoSnr");
    mLteSignalStrength = m.getInt("LteSignalStrength");
    mLteRsrp = m.getInt("LteRsrp");
    mLteRsrq = m.getInt("LteRsrq");
    mLteRssnr = m.getInt("LteRssnr");
    mLteCqi = m.getInt("LteCqi");
    mLteRsrpBoost = m.getInt("LteRsrpBoost");
    mTdScdmaRscp = m.getInt("TdScdma");
    mWcdmaSignalStrength = m.getInt("WcdmaSignalStrength");
    mWcdmaRscpAsu = m.getInt("WcdmaRscpAsu");
    mWcdmaRscp = m.getInt("WcdmaRscp");
    mIsGsm = m.getBoolean("IsGsm");
    mUseOnlyRsrpForLteLevel = m.getBoolean("UseOnlyRsrpForLteLevel");
    mWcdmaDefaultSignalMeasurement = m.getString("WcdmaDefaultSignalMeasurement");
    ArrayList<Integer> lteRsrpThresholds = m.getIntegerArrayList("lteRsrpThresholds");
    for (int i = 0; i < lteRsrpThresholds.size(); i++) {
        mLteRsrpThresholds[i] = lteRsrpThresholds.get(i);
    }
    ArrayList<Integer> wcdmaRscpThresholds = m.getIntegerArrayList("wcdmaRscpThresholds");
    for (int i = 0; i < wcdmaRscpThresholds.size(); i++) {
        mWcdmaRscpThresholds[i] = wcdmaRscpThresholds.get(i);
    }
}
------------------------
Find a silently evolved API code:android.text.format.Formatter.formatFileSize:COMMENT
Method Modifier: public      static      
Comment:/**
 * Formats a content size to be in the form of bytes, kilobytes, megabytes, etc.
 *
 * <p>As of O, the prefixes are used in their standard meanings in the SI system, so kB = 1000
 * bytes, MB = 1,000,000 bytes, etc.</p>
 *
 * <p class="note">In {@link android.os.Build.VERSION_CODES#N} and earlier, powers of 1024 are
 * used instead, with KB = 1024 bytes, MB = 1,048,576 bytes, etc.</p>
 *
 * <p>If the context has a right-to-left locale, the returned string is wrapped in bidi
 * formatting characters to make sure it's displayed correctly if inserted inside a
 * right-to-left string. (This is useful in cases where the unit strings, like "MB", are
 * left-to-right, but the locale is right-to-left.)</p>
 *
 * @param context Context to use to load the localized units
 * @param sizeBytes size value to be formatted, in bytes
 * @return formatted string with the number
 */

Body of Frist Method:
{
    return formatFileSize(context, sizeBytes, FLAG_DEFAULT);
}
Body of Second Method:
{
    if (context == null) {
        return "";
    }
    final BytesResult res = formatBytes(context.getResources(), sizeBytes, FLAG_SI_UNITS);
    return bidiWrap(context, context.getString(com.android.internal.R.string.fileSizeSuffix, res.value, res.units));
}
------------------------
Find a silently evolved API code:javax.obex.ObexHelper.updateHeaderSet:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Updates the HeaderSet with the headers received in the byte array
 * provided. Invalid headers are ignored.
 * <P>
 * The first two bits of an OBEX Header specifies the type of object that is
 * being sent. The table below specifies the meaning of the high bits.
 * <TABLE>
 * <TR>
 * <TH>Bits 8 and 7</TH>
 * <TH>Value</TH>
 * <TH>Description</TH>
 * </TR>
 * <TR>
 * <TD>00</TD>
 * <TD>0x00</TD>
 * <TD>Null Terminated Unicode text, prefixed with 2 byte unsigned integer</TD>
 * </TR>
 * <TR>
 * <TD>01</TD>
 * <TD>0x40</TD>
 * <TD>Byte Sequence, length prefixed with 2 byte unsigned integer</TD>
 * </TR>
 * <TR>
 * <TD>10</TD>
 * <TD>0x80</TD>
 * <TD>1 byte quantity</TD>
 * </TR>
 * <TR>
 * <TD>11</TD>
 * <TD>0xC0</TD>
 * <TD>4 byte quantity - transmitted in network byte order (high byte first</TD>
 * </TR>
 * </TABLE>
 * This method uses the information in this table to determine the type of
 * Java object to create and passes that object with the full header to
 * setHeader() to update the HeaderSet object. Invalid headers will cause an
 * exception to be thrown. When it is thrown, it is ignored.
 * @param header the HeaderSet to update
 * @param headerArray the byte array containing headers
 * @return the result of the last start body or end body header provided;
 * the first byte in the result will specify if a body or end of
 * body is received
 * @throws IOException if an invalid header was found
 */

Body of Frist Method:
{
    int index = 0;
    int length = 0;
    int headerID;
    byte[] value = null;
    byte[] body = null;
    HeaderSet headerImpl = header;
    try {
        while (index < headerArray.length) {
            headerID = 0xFF & headerArray[index];
            switch(headerID & (0xC0)) {
                /*
                     * 0x00 is a unicode null terminate string with the first
                     * two bytes after the header identifier being the length
                     */
                case 0x00:
                /*
                         * 0x40 is a byte sequence with the first
                         * two bytes after the header identifier being the length
                         */
                case 0x40:
                    boolean trimTail = true;
                    index++;
                    length = 0xFF & headerArray[index];
                    length = length << 8;
                    index++;
                    length += 0xFF & headerArray[index];
                    length -= 3;
                    index++;
                    value = new byte[length];
                    System.arraycopy(headerArray, index, value, 0, length);
                    if (length == 0 || (length > 0 && (value[length - 1] != 0))) {
                        trimTail = false;
                    }
                    switch(headerID) {
                        case HeaderSet.TYPE:
                            try {
                                // Remove trailing null
                                if (trimTail == false) {
                                    headerImpl.setHeader(headerID, new String(value, 0, value.length, "ISO8859_1"));
                                } else {
                                    headerImpl.setHeader(headerID, new String(value, 0, value.length - 1, "ISO8859_1"));
                                }
                            } catch (UnsupportedEncodingException e) {
                                throw e;
                            }
                            break;
                        case HeaderSet.AUTH_CHALLENGE:
                            headerImpl.mAuthChall = new byte[length];
                            System.arraycopy(headerArray, index, headerImpl.mAuthChall, 0, length);
                            break;
                        case HeaderSet.AUTH_RESPONSE:
                            headerImpl.mAuthResp = new byte[length];
                            System.arraycopy(headerArray, index, headerImpl.mAuthResp, 0, length);
                            break;
                        case HeaderSet.BODY:
                        /* Fall Through */
                        case HeaderSet.END_OF_BODY:
                            body = new byte[length + 1];
                            body[0] = (byte) headerID;
                            System.arraycopy(headerArray, index, body, 1, length);
                            break;
                        case HeaderSet.TIME_ISO_8601:
                            try {
                                String dateString = new String(value, "ISO8859_1");
                                Calendar temp = Calendar.getInstance();
                                if ((dateString.length() == 16) && (dateString.charAt(15) == 'Z')) {
                                    temp.setTimeZone(TimeZone.getTimeZone("UTC"));
                                }
                                temp.set(Calendar.YEAR, Integer.parseInt(dateString.substring(0, 4)));
                                temp.set(Calendar.MONTH, Integer.parseInt(dateString.substring(4, 6)));
                                temp.set(Calendar.DAY_OF_MONTH, Integer.parseInt(dateString.substring(6, 8)));
                                temp.set(Calendar.HOUR_OF_DAY, Integer.parseInt(dateString.substring(9, 11)));
                                temp.set(Calendar.MINUTE, Integer.parseInt(dateString.substring(11, 13)));
                                temp.set(Calendar.SECOND, Integer.parseInt(dateString.substring(13, 15)));
                                headerImpl.setHeader(HeaderSet.TIME_ISO_8601, temp);
                            } catch (UnsupportedEncodingException e) {
                                throw e;
                            }
                            break;
                        default:
                            if ((headerID & 0xC0) == 0x00) {
                                headerImpl.setHeader(headerID, ObexHelper.convertToUnicode(value, true));
                            } else {
                                headerImpl.setHeader(headerID, value);
                            }
                    }
                    index += length;
                    break;
                /*
                     * 0x80 is a byte header.  The only valid byte headers are
                     * the 16 user defined byte headers.
                     */
                case 0x80:
                    index++;
                    try {
                        headerImpl.setHeader(headerID, Byte.valueOf(headerArray[index]));
                    } catch (Exception e) {
                    // Not a valid header so ignore
                    }
                    index++;
                    break;
                /*
                     * 0xC0 is a 4 byte unsigned integer header and with the
                     * exception of TIME_4_BYTE will be converted to a Long
                     * and added.
                     */
                case 0xC0:
                    index++;
                    value = new byte[4];
                    System.arraycopy(headerArray, index, value, 0, 4);
                    try {
                        if (headerID != HeaderSet.TIME_4_BYTE) {
                            // need to be handled differently
                            if (headerID == HeaderSet.CONNECTION_ID) {
                                headerImpl.mConnectionID = new byte[4];
                                System.arraycopy(value, 0, headerImpl.mConnectionID, 0, 4);
                            } else {
                                headerImpl.setHeader(headerID, Long.valueOf(convertToLong(value)));
                            }
                        } else {
                            Calendar temp = Calendar.getInstance();
                            temp.setTime(new Date(convertToLong(value) * 1000L));
                            headerImpl.setHeader(HeaderSet.TIME_4_BYTE, temp);
                        }
                    } catch (Exception e) {
                        // Not a valid header so ignore
                        throw new IOException("Header was not formatted properly", e);
                    }
                    index += 4;
                    break;
            }
        }
    } catch (IOException e) {
        throw new IOException("Header was not formatted properly", e);
    }
    return body;
}
Body of Second Method:
{
    int index = 0;
    int length = 0;
    int headerID;
    byte[] value = null;
    byte[] body = null;
    HeaderSet headerImpl = header;
    try {
        while (index < headerArray.length) {
            headerID = 0xFF & headerArray[index];
            switch(headerID & (0xC0)) {
                /*
                     * 0x00 is a unicode null terminate string with the first
                     * two bytes after the header identifier being the length
                     */
                case 0x00:
                /*
                         * 0x40 is a byte sequence with the first
                         * two bytes after the header identifier being the length
                         */
                case 0x40:
                    boolean trimTail = true;
                    index++;
                    length = ((0xFF & headerArray[index]) << 8) + (0xFF & headerArray[index + 1]);
                    index += 2;
                    if (length <= OBEX_BYTE_SEQ_HEADER_LEN) {
                        Log.e(TAG, "Remote sent an OBEX packet with " + "incorrect header length = " + length);
                        break;
                    }
                    length -= OBEX_BYTE_SEQ_HEADER_LEN;
                    value = new byte[length];
                    System.arraycopy(headerArray, index, value, 0, length);
                    if (length == 0 || (length > 0 && (value[length - 1] != 0))) {
                        trimTail = false;
                    }
                    switch(headerID) {
                        case HeaderSet.TYPE:
                            try {
                                // Remove trailing null
                                if (trimTail == false) {
                                    headerImpl.setHeader(headerID, new String(value, 0, value.length, "ISO8859_1"));
                                } else {
                                    headerImpl.setHeader(headerID, new String(value, 0, value.length - 1, "ISO8859_1"));
                                }
                            } catch (UnsupportedEncodingException e) {
                                throw e;
                            }
                            break;
                        case HeaderSet.AUTH_CHALLENGE:
                            headerImpl.mAuthChall = new byte[length];
                            System.arraycopy(headerArray, index, headerImpl.mAuthChall, 0, length);
                            break;
                        case HeaderSet.AUTH_RESPONSE:
                            headerImpl.mAuthResp = new byte[length];
                            System.arraycopy(headerArray, index, headerImpl.mAuthResp, 0, length);
                            break;
                        case HeaderSet.BODY:
                        /* Fall Through */
                        case HeaderSet.END_OF_BODY:
                            body = new byte[length + 1];
                            body[0] = (byte) headerID;
                            System.arraycopy(headerArray, index, body, 1, length);
                            break;
                        case HeaderSet.TIME_ISO_8601:
                            try {
                                String dateString = new String(value, "ISO8859_1");
                                Calendar temp = Calendar.getInstance();
                                if ((dateString.length() == 16) && (dateString.charAt(15) == 'Z')) {
                                    temp.setTimeZone(TimeZone.getTimeZone("UTC"));
                                }
                                temp.set(Calendar.YEAR, Integer.parseInt(dateString.substring(0, 4)));
                                temp.set(Calendar.MONTH, Integer.parseInt(dateString.substring(4, 6)));
                                temp.set(Calendar.DAY_OF_MONTH, Integer.parseInt(dateString.substring(6, 8)));
                                temp.set(Calendar.HOUR_OF_DAY, Integer.parseInt(dateString.substring(9, 11)));
                                temp.set(Calendar.MINUTE, Integer.parseInt(dateString.substring(11, 13)));
                                temp.set(Calendar.SECOND, Integer.parseInt(dateString.substring(13, 15)));
                                headerImpl.setHeader(HeaderSet.TIME_ISO_8601, temp);
                            } catch (UnsupportedEncodingException e) {
                                throw e;
                            }
                            break;
                        default:
                            if ((headerID & 0xC0) == 0x00) {
                                headerImpl.setHeader(headerID, ObexHelper.convertToUnicode(value, true));
                            } else {
                                headerImpl.setHeader(headerID, value);
                            }
                    }
                    index += length;
                    break;
                /*
                     * 0x80 is a byte header.  The only valid byte headers are
                     * the 16 user defined byte headers.
                     */
                case 0x80:
                    index++;
                    try {
                        headerImpl.setHeader(headerID, Byte.valueOf(headerArray[index]));
                    } catch (Exception e) {
                    // Not a valid header so ignore
                    }
                    index++;
                    break;
                /*
                     * 0xC0 is a 4 byte unsigned integer header and with the
                     * exception of TIME_4_BYTE will be converted to a Long
                     * and added.
                     */
                case 0xC0:
                    index++;
                    value = new byte[4];
                    System.arraycopy(headerArray, index, value, 0, 4);
                    try {
                        if (headerID != HeaderSet.TIME_4_BYTE) {
                            // need to be handled differently
                            if (headerID == HeaderSet.CONNECTION_ID) {
                                headerImpl.mConnectionID = new byte[4];
                                System.arraycopy(value, 0, headerImpl.mConnectionID, 0, 4);
                            } else {
                                headerImpl.setHeader(headerID, Long.valueOf(convertToLong(value)));
                            }
                        } else {
                            Calendar temp = Calendar.getInstance();
                            temp.setTime(new Date(convertToLong(value) * 1000L));
                            headerImpl.setHeader(HeaderSet.TIME_4_BYTE, temp);
                        }
                    } catch (Exception e) {
                        // Not a valid header so ignore
                        throw new IOException("Header was not formatted properly", e);
                    }
                    index += 4;
                    break;
            }
        }
    } catch (IOException e) {
        throw new IOException("Header was not formatted properly", e);
    }
    return body;
}
------------------------
Find a silently evolved API code:android.content.ContentResolver.setIsSyncable:COMMENT
Method Modifier: public      static      
Comment:/**
 * Set whether this account/provider is syncable.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#WRITE_SYNC_SETTINGS}.
 * @param syncable >0 denotes syncable, 0 means not syncable, <0 means unknown
 */

Body of Frist Method:
{
    try {
        getContentService().setIsSyncable(account, authority, syncable);
    } catch (RemoteException e) {
    // exception ignored; if this is thrown then it means the runtime is in the midst of
    // being restarted
    }
}
Body of Second Method:
{
    try {
        getContentService().setIsSyncable(account, authority, syncable);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.view.accessibility.AccessibilityWindowInfo.clear:COMMENT
Method Modifier: private     
Comment:/**
 * Clears the internal state.
 */

Body of Frist Method:
{
    mType = UNDEFINED_WINDOW_ID;
    mLayer = UNDEFINED_WINDOW_ID;
    mBooleanProperties = 0;
    mId = UNDEFINED_WINDOW_ID;
    mParentId = UNDEFINED_WINDOW_ID;
    mBoundsInScreen.setEmpty();
    if (mChildIds != null) {
        mChildIds.clear();
    }
    mConnectionId = UNDEFINED_WINDOW_ID;
    mAnchorId = UNDEFINED_WINDOW_ID;
    mInPictureInPicture = false;
    mTitle = null;
}
Body of Second Method:
{
    mType = UNDEFINED_WINDOW_ID;
    mLayer = UNDEFINED_WINDOW_ID;
    mBooleanProperties = 0;
    mId = UNDEFINED_WINDOW_ID;
    mParentId = UNDEFINED_WINDOW_ID;
    mBoundsInScreen.setEmpty();
    if (mChildIds != null) {
        mChildIds.clear();
    }
    mConnectionId = UNDEFINED_WINDOW_ID;
    mAnchorId = AccessibilityNodeInfo.UNDEFINED_NODE_ID;
    mTitle = null;
}
------------------------
Find a silently evolved API code:android.util.AtomicFile.finishWrite:COMMENT
Method Modifier: public      
Comment:/**
 * Call when you have successfully finished writing to the stream
 * returned by {@link #startWrite()}.  This will close, sync, and
 * commit the new data.  The next attempt to read the atomic file
 * will return the new file stream.
 */

Body of Frist Method:
{
    if (str != null) {
        FileUtils.sync(str);
        try {
            str.close();
            mBackupName.delete();
        } catch (IOException e) {
            Log.w("AtomicFile", "finishWrite: Got exception:", e);
        }
    }
}
Body of Second Method:
{
    if (str != null) {
        FileUtils.sync(str);
        try {
            str.close();
            mBackupName.delete();
        } catch (IOException e) {
            Log.w("AtomicFile", "finishWrite: Got exception:", e);
        }
        if (mCommitTag != null) {
            com.android.internal.logging.EventLogTags.writeCommitSysConfigFile(mCommitTag, SystemClock.uptimeMillis() - mStartTime);
        }
    }
}
------------------------
Find a silently evolved API code:android.telephony.euicc.EuiccManager.getEuiccInfo:COMMENT
<android.telephony.euicc.EuiccManager: EuiccInfo getEuiccInfo()>
public      hidden      ->public      
Method Modifier: public      hidden      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * Returns information about the eUICC chip/device.
 *
 * @return the {@link EuiccInfo}. May be null if {@link #isEnabled()} is false or the eUICC is
 * not ready.
 */

Body of Frist Method:
{
    if (!isEnabled()) {
        return null;
    }
    try {
        return mController.getEuiccInfo();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    if (!isEnabled()) {
        return null;
    }
    try {
        return getIEuiccController().getEuiccInfo();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.le.PeriodicAdvertisingParameters.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Build the {@link AdvertisingSetParameters} object.
 */

Body of Frist Method:
{
    return new PeriodicAdvertisingParameters(includeTxPower, interval);
}
Body of Second Method:
{
    return new PeriodicAdvertisingParameters(mIncludeTxPower, mInterval);
}
------------------------
Find a silently evolved API code:android.media.session.MediaController.TransportControls.stop:COMMENT
Method Modifier: public      
Comment:/**
 * Request that the player stop its playback; it may clear its state in
 * whatever way is appropriate.
 */

Body of Frist Method:
{
    try {
        mSessionBinder.stop();
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling stop.", e);
    }
}
Body of Second Method:
{
    try {
        mSessionBinder.stop(mContext.getPackageName(), mCbStub);
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling stop.", e);
    }
}
------------------------
Find a silently evolved API code:android.text.Selection.getSelectionStart:COMMENT
Method Modifier: public      static      final       
Comment:/**
 * Return the offset of the selection anchor or cursor, or -1 if
 * there is no selection or cursor.
 */

Body of Frist Method:
{
    if (text instanceof Spanned)
        return ((Spanned) text).getSpanStart(SELECTION_START);
    else
        return -1;
}
Body of Second Method:
{
    if (text instanceof Spanned) {
        return ((Spanned) text).getSpanStart(SELECTION_START);
    }
    return -1;
}
------------------------
Find a silently evolved API code:android.content.res.TypedArray.hasValueOrEmpty:COMMENT
Method Modifier: public      
Comment:/**
 * Determines whether there is an attribute at <var>index</var>, returning
 * {@code true} if the attribute was explicitly set to {@code @empty} and
 * {@code false} only if the attribute was undefined.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return True if the attribute has a value or is empty, false otherwise.
 * @throws RuntimeException if the TypedArray has already been recycled.
 */

Body of Frist Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    return type != TypedValue.TYPE_NULL || data[index + AssetManager.STYLE_DATA] == TypedValue.DATA_NULL_EMPTY;
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    index *= STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + STYLE_TYPE];
    return type != TypedValue.TYPE_NULL || data[index + STYLE_DATA] == TypedValue.DATA_NULL_EMPTY;
}
------------------------
Find a silently evolved API code:android.net.NetworkPolicy.clearSnooze:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Clear any existing snooze values, setting to {@link #SNOOZE_NEVER}.
 */

Body of Frist Method:
{
    lastWarningSnooze = SNOOZE_NEVER;
    lastLimitSnooze = SNOOZE_NEVER;
}
Body of Second Method:
{
    lastWarningSnooze = SNOOZE_NEVER;
    lastLimitSnooze = SNOOZE_NEVER;
    lastRapidSnooze = SNOOZE_NEVER;
}
------------------------
Find a silently evolved API code:android.os.Debug.MemoryInfo.getOtherSharedClean:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return otherStats[which * NUM_CATEGORIES + offsetSharedClean];
}
Body of Second Method:
{
    return otherStats[which * NUM_CATEGORIES + OFFSET_SHARED_CLEAN];
}
------------------------
Find a silently evolved API code:android.app.usage.UsageEvents.readEventFromParcel:COMMENT
Method Modifier: private     
Comment:/**
 * Reads a single event from the parcel. Modify this when updating {@link Event}.
 */

Body of Frist Method:
{
    final int packageIndex = p.readInt();
    if (packageIndex >= 0) {
        eventOut.mPackage = mStringPool[packageIndex];
    } else {
        eventOut.mPackage = null;
    }
    final int classIndex = p.readInt();
    if (classIndex >= 0) {
        eventOut.mClass = mStringPool[classIndex];
    } else {
        eventOut.mClass = null;
    }
    eventOut.mEventType = p.readInt();
    eventOut.mTimeStamp = p.readLong();
    // Fill out the event-dependant fields.
    eventOut.mConfiguration = null;
    eventOut.mShortcutId = null;
    eventOut.mAction = null;
    eventOut.mContentType = null;
    eventOut.mContentAnnotations = null;
    switch(eventOut.mEventType) {
        case Event.CONFIGURATION_CHANGE:
            // Extract the configuration for configuration change events.
            eventOut.mConfiguration = Configuration.CREATOR.createFromParcel(p);
            break;
        case Event.SHORTCUT_INVOCATION:
            eventOut.mShortcutId = p.readString();
            break;
        case Event.CHOOSER_ACTION:
            eventOut.mAction = p.readString();
            eventOut.mContentType = p.readString();
            eventOut.mContentAnnotations = p.createStringArray();
            break;
    }
}
Body of Second Method:
{
    final int packageIndex = p.readInt();
    if (packageIndex >= 0) {
        eventOut.mPackage = mStringPool[packageIndex];
    } else {
        eventOut.mPackage = null;
    }
    final int classIndex = p.readInt();
    if (classIndex >= 0) {
        eventOut.mClass = mStringPool[classIndex];
    } else {
        eventOut.mClass = null;
    }
    eventOut.mEventType = p.readInt();
    eventOut.mTimeStamp = p.readLong();
    // Fill out the event-dependant fields.
    eventOut.mConfiguration = null;
    eventOut.mShortcutId = null;
    eventOut.mAction = null;
    eventOut.mContentType = null;
    eventOut.mContentAnnotations = null;
    eventOut.mNotificationChannelId = null;
    switch(eventOut.mEventType) {
        case Event.CONFIGURATION_CHANGE:
            // Extract the configuration for configuration change events.
            eventOut.mConfiguration = Configuration.CREATOR.createFromParcel(p);
            break;
        case Event.SHORTCUT_INVOCATION:
            eventOut.mShortcutId = p.readString();
            break;
        case Event.CHOOSER_ACTION:
            eventOut.mAction = p.readString();
            eventOut.mContentType = p.readString();
            eventOut.mContentAnnotations = p.createStringArray();
            break;
        case Event.STANDBY_BUCKET_CHANGED:
            eventOut.mBucketAndReason = p.readInt();
            break;
        case Event.NOTIFICATION_INTERRUPTION:
            eventOut.mNotificationChannelId = p.readString();
            break;
    }
}
------------------------
Find a silently evolved API code:android.media.session.MediaController.TransportControls.play:COMMENT
Method Modifier: public      
Comment:/**
 * Request that the player start its playback at its current position.
 */

Body of Frist Method:
{
    try {
        mSessionBinder.play();
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling play.", e);
    }
}
Body of Second Method:
{
    try {
        mSessionBinder.play(mContext.getPackageName(), mCbStub);
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling play.", e);
    }
}
------------------------
Find a silently evolved API code:android.text.format.DateFormat.getDateFormatOrder:COMMENT
Method Modifier: public      static      
Comment:/**
 * Gets the current date format stored as a char array. Returns a 3 element
 * array containing the day ({@code 'd'}), month ({@code 'M'}), and year ({@code 'y'}))
 * in the order specified by the user's format preference.  Note that this order is
 * <i>only</i> appropriate for all-numeric dates; spelled-out (MEDIUM and LONG)
 * dates will generally contain other punctuation, spaces, or words,
 * not just the day, month, and year, and not necessarily in the same
 * order returned here.
 */

Body of Frist Method:
{
    return ICU.getDateFormatOrder(getDateFormatString());
}
Body of Second Method:
{
    return ICU.getDateFormatOrder(getDateFormatString(context));
}
------------------------
Find a silently evolved API code:android.hardware.camera2.CaptureRequest.Builder.set:COMMENT
Method Modifier: public      
Comment:/**
 * Set a capture request field to a value. The field definitions can be
 * found in {@link CaptureRequest}.
 *
 * <p>Setting a field to {@code null} will remove that field from the capture request.
 * Unless the field is optional, removing it will likely produce an error from the camera
 * device when the request is submitted.</p>
 *
 * @param key The metadata field to write.
 * @param value The value to set the field to, which must be of a matching
 * type to the key.
 */

Body of Frist Method:
{
    mRequest.mSettings.set(key, value);
}
Body of Second Method:
{
    mRequest.mLogicalCameraSettings.set(key, value);
}
------------------------
Find a silently evolved API code:android.content.res.TypedArray.getComplexColor:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Retrieve the ComplexColor for the attribute at <var>index</var>.
 * The value may be either a {@link android.content.res.ColorStateList} which can wrap a simple
 * color value or a {@link android.content.res.GradientColor}
 * <p>
 * This method will return {@code null} if the attribute is not defined or
 * is not an integer color, color state list or GradientColor.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return ComplexColor for the attribute, or {@code null} if not defined.
 * @throws RuntimeException if the attribute if the TypedArray has already
 * been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not an integer color, color state list or GradientColor.
 * @hide
 */

Body of Frist Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    final TypedValue value = mValue;
    if (getValueAt(index * AssetManager.STYLE_NUM_ENTRIES, value)) {
        if (value.type == TypedValue.TYPE_ATTRIBUTE) {
            throw new UnsupportedOperationException("Failed to resolve attribute at index " + index + ": " + value);
        }
        return mResources.loadComplexColor(value, value.resourceId, mTheme);
    }
    return null;
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    final TypedValue value = mValue;
    if (getValueAt(index * STYLE_NUM_ENTRIES, value)) {
        if (value.type == TypedValue.TYPE_ATTRIBUTE) {
            throw new UnsupportedOperationException("Failed to resolve attribute at index " + index + ": " + value);
        }
        return mResources.loadComplexColor(value, value.resourceId, mTheme);
    }
    return null;
}
------------------------
Find a silently evolved API code:android.text.style.BulletSpan.writeToParcelInternal:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    dest.writeInt(mGapWidth);
    dest.writeInt(mWantColor ? 1 : 0);
    dest.writeInt(mColor);
}
Body of Second Method:
{
    dest.writeInt(mGapWidth);
    dest.writeInt(mWantColor ? 1 : 0);
    dest.writeInt(mColor);
    dest.writeInt(mBulletRadius);
}
------------------------
Find a silently evolved API code:android.telephony.SignalStrength.toString:COMMENT
Method Modifier: public      
Comment:/**
 * @return string representation.
 */

Body of Frist Method:
{
    return ("SignalStrength:" + " " + mGsmSignalStrength + " " + mGsmBitErrorRate + " " + mCdmaDbm + " " + mCdmaEcio + " " + mEvdoDbm + " " + mEvdoEcio + " " + mEvdoSnr + " " + mLteSignalStrength + " " + mLteRsrp + " " + mLteRsrq + " " + mLteRssnr + " " + mLteCqi + " " + mLteRsrpBoost + " " + mTdScdmaRscp + " " + (isGsm ? "gsm|lte" : "cdma"));
}
Body of Second Method:
{
    return ("SignalStrength:" + " " + mGsmSignalStrength + " " + mGsmBitErrorRate + " " + mCdmaDbm + " " + mCdmaEcio + " " + mEvdoDbm + " " + mEvdoEcio + " " + mEvdoSnr + " " + mLteSignalStrength + " " + mLteRsrp + " " + mLteRsrq + " " + mLteRssnr + " " + mLteCqi + " " + mLteRsrpBoost + " " + mTdScdmaRscp + " " + mWcdmaSignalStrength + " " + mWcdmaRscpAsu + " " + mWcdmaRscp + " " + (mIsGsm ? "gsm|lte" : "cdma") + " " + (mUseOnlyRsrpForLteLevel ? "use_only_rsrp_for_lte_level" : "use_rsrp_and_rssnr_for_lte_level") + " " + mWcdmaDefaultSignalMeasurement + " " + (Arrays.toString(mLteRsrpThresholds)) + " " + (Arrays.toString(mWcdmaRscpThresholds)));
}
------------------------
Find a silently evolved API code:android.content.res.TypedArray.getColor:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the color value for the attribute at <var>index</var>.  If
 * the attribute references a color resource holding a complex
 * {@link android.content.res.ColorStateList}, then the default color from
 * the set is returned.
 * <p>
 * This method will throw an exception if the attribute is defined but is
 * not an integer color or color state list.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute color value, or defValue if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not an integer color or color state list.
 */

Body of Frist Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    final int attrIndex = index;
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + AssetManager.STYLE_DATA];
    } else if (type == TypedValue.TYPE_STRING) {
        final TypedValue value = mValue;
        if (getValueAt(index, value)) {
            final ColorStateList csl = mResources.loadColorStateList(value, value.resourceId, mTheme);
            return csl.getDefaultColor();
        }
        return defValue;
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index, value);
        throw new UnsupportedOperationException("Failed to resolve attribute at index " + attrIndex + ": " + value);
    }
    throw new UnsupportedOperationException("Can't convert value at index " + attrIndex + " to color: type=0x" + Integer.toHexString(type));
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    final int attrIndex = index;
    index *= STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + STYLE_DATA];
    } else if (type == TypedValue.TYPE_STRING) {
        final TypedValue value = mValue;
        if (getValueAt(index, value)) {
            final ColorStateList csl = mResources.loadColorStateList(value, value.resourceId, mTheme);
            return csl.getDefaultColor();
        }
        return defValue;
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index, value);
        throw new UnsupportedOperationException("Failed to resolve attribute at index " + attrIndex + ": " + value);
    }
    throw new UnsupportedOperationException("Can't convert value at index " + attrIndex + " to color: type=0x" + Integer.toHexString(type));
}
------------------------
Find a silently evolved API code:android.util.proto.ProtoOutputStream.getFieldIdString:COMMENT
Method Modifier: private     
Comment:/**
 * Get a debug string for a fieldId.
 */

Body of Frist Method:
{
    final long fieldCount = fieldId & FIELD_COUNT_MASK;
    String countString = getFieldCountString(fieldCount);
    if (countString == null) {
        countString = "fieldCount=" + fieldCount;
    }
    final long fieldType = fieldId & FIELD_TYPE_MASK;
    String typeString = getFieldTypeString(fieldType);
    if (typeString == null) {
        typeString = "fieldType=" + fieldType;
    }
    return fieldCount + " " + typeString + " tag=" + ((int) fieldId) + " fieldId=0x" + Long.toHexString(fieldId);
}
Body of Second Method:
{
    final long fieldCount = fieldId & FIELD_COUNT_MASK;
    String countString = getFieldCountString(fieldCount);
    if (countString == null) {
        countString = "fieldCount=" + fieldCount;
    }
    if (countString.length() > 0) {
        countString += " ";
    }
    final long fieldType = fieldId & FIELD_TYPE_MASK;
    String typeString = getFieldTypeString(fieldType);
    if (typeString == null) {
        typeString = "fieldType=" + fieldType;
    }
    return countString + typeString + " tag=" + ((int) fieldId) + " fieldId=0x" + Long.toHexString(fieldId);
}
------------------------
Find a silently evolved API code:android.app.backup.FullBackup.BackupScheme.validateInnerTagContents:COMMENT
Method Modifier: private     
Comment:/**
 * Let's be strict about the type of xml the client can write. If we see anything untoward,
 * throw an XmlPullParserException.
 */

Body of Frist Method:
{
    if (parser.getAttributeCount() > 2) {
        throw new XmlPullParserException("At most 2 tag attributes allowed for \"" + parser.getName() + "\" tag (\"domain\" & \"path\".");
    }
    if (!"include".equals(parser.getName()) && !"exclude".equals(parser.getName())) {
        throw new XmlPullParserException("A valid tag is one of \"<include/>\" or" + " \"<exclude/>. You provided \"" + parser.getName() + "\"");
    }
}
Body of Second Method:
{
    if (parser == null) {
        return;
    }
    switch(parser.getName()) {
        case TAG_INCLUDE:
            if (parser.getAttributeCount() > 3) {
                throw new XmlPullParserException("At most 3 tag attributes allowed for " + "\"include\" tag (\"domain\" & \"path\"" + " & optional \"requiredFlags\").");
            }
            break;
        case TAG_EXCLUDE:
            if (parser.getAttributeCount() > 2) {
                throw new XmlPullParserException("At most 2 tag attributes allowed for " + "\"exclude\" tag (\"domain\" & \"path\".");
            }
            break;
        default:
            throw new XmlPullParserException("A valid tag is one of \"<include/>\" or" + " \"<exclude/>. You provided \"" + parser.getName() + "\"");
    }
}
------------------------
Find a silently evolved API code:android.media.session.MediaController.TransportControls.prepare:COMMENT
Method Modifier: public      
Comment:/**
 * Request that the player prepare its playback. In other words, other sessions can continue
 * to play during the preparation of this session. This method can be used to speed up the
 * start of the playback. Once the preparation is done, the session will change its playback
 * state to {@link PlaybackState#STATE_PAUSED}. Afterwards, {@link #play} can be called to
 * start playback.
 */

Body of Frist Method:
{
    try {
        mSessionBinder.prepare();
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling prepare.", e);
    }
}
Body of Second Method:
{
    try {
        mSessionBinder.prepare(mContext.getPackageName(), mCbStub);
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling prepare.", e);
    }
}
------------------------
Find a silently evolved API code:android.net.TrafficStats.getUidRxBytes:COMMENT
Method Modifier: public      static      
Comment:/**
 * Return number of bytes received by the given UID since device boot.
 * Counts packets across all network interfaces, and always increases
 * monotonically since device boot. Statistics are measured at the network
 * layer, so they include both TCP and UDP usage.
 * <p>
 * Before {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}, this may return
 * {@link #UNSUPPORTED} on devices where statistics aren't available.
 * <p>
 * Starting in {@link android.os.Build.VERSION_CODES#N} this will only
 * report traffic statistics for the calling UID. It will return
 * {@link #UNSUPPORTED} for all other UIDs for privacy reasons. To access
 * historical network statistics belonging to other UIDs, use
 * {@link NetworkStatsManager}.
 *
 * @see android.os.Process#myUid()
 * @see android.content.pm.ApplicationInfo#uid
 */

Body of Frist Method:
{
    // This isn't actually enforcing any security; it just returns the
    // unsupported value. The real filtering is done at the kernel level.
    final int callingUid = android.os.Process.myUid();
    if (callingUid == android.os.Process.SYSTEM_UID || callingUid == uid) {
        return nativeGetUidStat(uid, TYPE_RX_BYTES);
    } else {
        return UNSUPPORTED;
    }
}
Body of Second Method:
{
    // This isn't actually enforcing any security; it just returns the
    // unsupported value. The real filtering is done at the kernel level.
    final int callingUid = android.os.Process.myUid();
    if (callingUid == android.os.Process.SYSTEM_UID || callingUid == uid) {
        try {
            return getStatsService().getUidStats(uid, TYPE_RX_BYTES);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    } else {
        return UNSUPPORTED;
    }
}
------------------------
Find a silently evolved API code:android.os.ServiceManager.getService:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Returns a reference to a service with the given name.
 *
 * @param name the name of the service to get
 * @return a reference to the service, or <code>null</code> if the service doesn't exist
 */

Body of Frist Method:
{
    try {
        IBinder service = sCache.get(name);
        if (service != null) {
            return service;
        } else {
            return Binder.allowBlocking(getIServiceManager().getService(name));
        }
    } catch (RemoteException e) {
        Log.e(TAG, "error in getService", e);
    }
    return null;
}
Body of Second Method:
{
    try {
        IBinder service = sCache.get(name);
        if (service != null) {
            return service;
        } else {
            return Binder.allowBlocking(rawGetService(name));
        }
    } catch (RemoteException e) {
        Log.e(TAG, "error in getService", e);
    }
    return null;
}
------------------------
Find a silently evolved API code:android.net.Uri.toSafeString:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Return a string representation of the URI that is safe to print
 * to logs and other places where PII should be avoided.
 * @hide
 */

Body of Frist Method:
{
    String scheme = getScheme();
    String ssp = getSchemeSpecificPart();
    if (scheme != null) {
        if (scheme.equalsIgnoreCase("tel") || scheme.equalsIgnoreCase("sip") || scheme.equalsIgnoreCase("sms") || scheme.equalsIgnoreCase("smsto") || scheme.equalsIgnoreCase("mailto")) {
            StringBuilder builder = new StringBuilder(64);
            builder.append(scheme);
            builder.append(':');
            if (ssp != null) {
                for (int i = 0; i < ssp.length(); i++) {
                    char c = ssp.charAt(i);
                    if (c == '-' || c == '@' || c == '.') {
                        builder.append(c);
                    } else {
                        builder.append('x');
                    }
                }
            }
            return builder.toString();
        } else if (scheme.equalsIgnoreCase("http") || scheme.equalsIgnoreCase("https") || scheme.equalsIgnoreCase("ftp")) {
            ssp = "//" + ((getHost() != null) ? getHost() : "") + ((getPort() != -1) ? (":" + getPort()) : "") + "/...";
        }
    }
    // Not a sensitive scheme, but let's still be conservative about
    // the data we include -- only the ssp, not the query params or
    // fragment, because those can often have sensitive info.
    StringBuilder builder = new StringBuilder(64);
    if (scheme != null) {
        builder.append(scheme);
        builder.append(':');
    }
    if (ssp != null) {
        builder.append(ssp);
    }
    return builder.toString();
}
Body of Second Method:
{
    String scheme = getScheme();
    String ssp = getSchemeSpecificPart();
    if (scheme != null) {
        if (scheme.equalsIgnoreCase("tel") || scheme.equalsIgnoreCase("sip") || scheme.equalsIgnoreCase("sms") || scheme.equalsIgnoreCase("smsto") || scheme.equalsIgnoreCase("mailto") || scheme.equalsIgnoreCase("nfc")) {
            StringBuilder builder = new StringBuilder(64);
            builder.append(scheme);
            builder.append(':');
            if (ssp != null) {
                for (int i = 0; i < ssp.length(); i++) {
                    char c = ssp.charAt(i);
                    if (c == '-' || c == '@' || c == '.') {
                        builder.append(c);
                    } else {
                        builder.append('x');
                    }
                }
            }
            return builder.toString();
        } else if (scheme.equalsIgnoreCase("http") || scheme.equalsIgnoreCase("https") || scheme.equalsIgnoreCase("ftp")) {
            ssp = "//" + ((getHost() != null) ? getHost() : "") + ((getPort() != -1) ? (":" + getPort()) : "") + "/...";
        }
    }
    // Not a sensitive scheme, but let's still be conservative about
    // the data we include -- only the ssp, not the query params or
    // fragment, because those can often have sensitive info.
    StringBuilder builder = new StringBuilder(64);
    if (scheme != null) {
        builder.append(scheme);
        builder.append(':');
    }
    if (ssp != null) {
        builder.append(ssp);
    }
    return builder.toString();
}
------------------------
Find a silently evolved API code:android.bluetooth.OobData.setSecurityManagerTk:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets the Temporary Key value to be used by the LE Security Manager during
 * LE pairing. The value shall be 16 bytes. Please see Bluetooth CSSv6,
 * Part A 1.8 for a detailed description.
 */

Body of Frist Method:
{
    this.securityManagerTk = securityManagerTk;
}
Body of Second Method:
{
    mSecurityManagerTk = securityManagerTk;
}
------------------------
Find a silently evolved API code:android.transition.TransitionUtils.createDrawableBitmap:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Get a copy of bitmap of given drawable, return null if intrinsic size is zero
 */

Body of Frist Method:
{
    int width = drawable.getIntrinsicWidth();
    int height = drawable.getIntrinsicHeight();
    if (width <= 0 || height <= 0) {
        return null;
    }
    float scale = Math.min(1f, ((float) MAX_IMAGE_SIZE) / (width * height));
    if (drawable instanceof BitmapDrawable && scale == 1f) {
        // return same bitmap if scale down not needed
        return ((BitmapDrawable) drawable).getBitmap();
    }
    int bitmapWidth = (int) (width * scale);
    int bitmapHeight = (int) (height * scale);
    final RenderNode node = RenderNode.create("TransitionUtils", hostView);
    node.setLeftTopRightBottom(0, 0, width, height);
    node.setClipToBounds(false);
    final DisplayListCanvas canvas = node.start(width, height);
    // Do stuff with the canvas
    Rect existingBounds = drawable.getBounds();
    int left = existingBounds.left;
    int top = existingBounds.top;
    int right = existingBounds.right;
    int bottom = existingBounds.bottom;
    drawable.setBounds(0, 0, bitmapWidth, bitmapHeight);
    drawable.draw(canvas);
    drawable.setBounds(left, top, right, bottom);
    node.end(canvas);
    return ThreadedRenderer.createHardwareBitmap(node, width, height);
}
Body of Second Method:
{
    int width = drawable.getIntrinsicWidth();
    int height = drawable.getIntrinsicHeight();
    if (width <= 0 || height <= 0) {
        return null;
    }
    float scale = Math.min(1f, ((float) MAX_IMAGE_SIZE) / (width * height));
    if (drawable instanceof BitmapDrawable && scale == 1f) {
        // return same bitmap if scale down not needed
        return ((BitmapDrawable) drawable).getBitmap();
    }
    int bitmapWidth = (int) (width * scale);
    int bitmapHeight = (int) (height * scale);
    final Picture picture = new Picture();
    final Canvas canvas = picture.beginRecording(width, height);
    // Do stuff with the canvas
    Rect existingBounds = drawable.getBounds();
    int left = existingBounds.left;
    int top = existingBounds.top;
    int right = existingBounds.right;
    int bottom = existingBounds.bottom;
    drawable.setBounds(0, 0, bitmapWidth, bitmapHeight);
    drawable.draw(canvas);
    drawable.setBounds(left, top, right, bottom);
    picture.endRecording();
    return Bitmap.createBitmap(picture);
}
------------------------
Find a silently evolved API code:android.telephony.euicc.EuiccManager.retainSubscriptionsForFactoryReset:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Ensure that subscriptions will be retained on the next factory reset.
 *
 * <p>By default, all subscriptions on the eUICC are erased the first time a device boots (ever
 * and after factory resets). This ensures that the data is wiped after a factory reset is
 * performed via fastboot or recovery mode, as these modes do not support the necessary radio
 * communication needed to wipe the eSIM.
 *
 * <p>However, this method may be called right before a factory reset issued via settings when
 * the user elects to retain subscriptions. Doing so will mark them for retention so that they
 * are not cleared after the ensuing reset.
 *
 * <p>Requires that the calling app has the {@link android.Manifest.permission#MASTER_CLEAR}
 * permission. This is for internal system use only.
 *
 * @param callbackIntent a PendingIntent to launch when the operation completes.
 * @hide
 */

Body of Frist Method:
{
    if (!isEnabled()) {
        sendUnavailableError(callbackIntent);
        return;
    }
    try {
        mController.retainSubscriptionsForFactoryReset(callbackIntent);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    if (!isEnabled()) {
        sendUnavailableError(callbackIntent);
        return;
    }
    try {
        getIEuiccController().retainSubscriptionsForFactoryReset(callbackIntent);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.graphics.Picture.beginRecording:COMMENT
Method Modifier: public      
Comment:/**
 * To record a picture, call beginRecording() and then draw into the Canvas
 * that is returned. Nothing we appear on screen, but all of the draw
 * commands (e.g. {@link Canvas#drawRect(Rect, Paint)}) will be recorded.
 * To stop recording, call endRecording(). After endRecording() the Canvas
 * that was returned must no longer be used, and nothing should be drawn
 * into it.
 */

Body of Frist Method:
{
    long ni = nativeBeginRecording(mNativePicture, width, height);
    mRecordingCanvas = new RecordingCanvas(this, ni);
    return mRecordingCanvas;
}
Body of Second Method:
{
    if (mRecordingCanvas != null) {
        throw new IllegalStateException("Picture already recording, must call #endRecording()");
    }
    long ni = nativeBeginRecording(mNativePicture, width, height);
    mRecordingCanvas = new PictureCanvas(this, ni);
    mRequiresHwAcceleration = false;
    return mRecordingCanvas;
}
------------------------
Find a silently evolved API code:android.view.inputmethod.ExtractedText.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Used to package this object into a {@link Parcel}.
 *
 * @param dest The {@link Parcel} to be written.
 * @param flags The flags used for parceling.
 */

Body of Frist Method:
{
    TextUtils.writeToParcel(text, dest, flags);
    dest.writeInt(startOffset);
    dest.writeInt(partialStartOffset);
    dest.writeInt(partialEndOffset);
    dest.writeInt(selectionStart);
    dest.writeInt(selectionEnd);
    dest.writeInt(this.flags);
}
Body of Second Method:
{
    TextUtils.writeToParcel(text, dest, flags);
    dest.writeInt(startOffset);
    dest.writeInt(partialStartOffset);
    dest.writeInt(partialEndOffset);
    dest.writeInt(selectionStart);
    dest.writeInt(selectionEnd);
    dest.writeInt(this.flags);
    TextUtils.writeToParcel(hint, dest, flags);
}
------------------------
Find a silently evolved API code:android.widget.SimpleMonthView.findClosestColumn:COMMENT
Method Modifier: private     
Comment:/**
 * Returns the column (0 indexed) closest to the previouslyFocusedRect or center if null.
 * The 0 index is related to the first day of the week.
 */

Body of Frist Method:
{
    if (previouslyFocusedRect == null) {
        return DAYS_IN_WEEK / 2;
    } else {
        int centerX = previouslyFocusedRect.centerX() - mPaddingLeft;
        final int columnFromLeft = MathUtils.constrain(centerX / mCellWidth, 0, DAYS_IN_WEEK - 1);
        return isLayoutRtl() ? DAYS_IN_WEEK - columnFromLeft - 1 : columnFromLeft;
    }
}
Body of Second Method:
{
    if (previouslyFocusedRect == null) {
        return DAYS_IN_WEEK / 2;
    } else if (mCellWidth == 0) {
        // There hasn't been a layout, so we can just choose the first column
        return 0;
    } else {
        int centerX = previouslyFocusedRect.centerX() - mPaddingLeft;
        final int columnFromLeft = MathUtils.constrain(centerX / mCellWidth, 0, DAYS_IN_WEEK - 1);
        return isLayoutRtl() ? DAYS_IN_WEEK - columnFromLeft - 1 : columnFromLeft;
    }
}
------------------------
Find a silently evolved API code:android.content.ContentResolver.getContentService:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (sContentService != null) {
        return sContentService;
    }
    IBinder b = ServiceManager.getService(CONTENT_SERVICE_NAME);
    if (false)
        Log.v("ContentService", "default service binder = " + b);
    sContentService = IContentService.Stub.asInterface(b);
    if (false)
        Log.v("ContentService", "default service = " + sContentService);
    return sContentService;
}
Body of Second Method:
{
    if (sContentService != null) {
        return sContentService;
    }
    IBinder b = ServiceManager.getService(CONTENT_SERVICE_NAME);
    sContentService = IContentService.Stub.asInterface(b);
    return sContentService;
}
------------------------
Find a silently evolved API code:android.content.pm.InstrumentationInfo.copyTo:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * {@hide}
 */

Body of Frist Method:
{
    ai.packageName = packageName;
    ai.sourceDir = sourceDir;
    ai.publicSourceDir = publicSourceDir;
    ai.splitNames = splitNames;
    ai.splitSourceDirs = splitSourceDirs;
    ai.splitPublicSourceDirs = splitPublicSourceDirs;
    ai.splitDependencies = splitDependencies;
    ai.dataDir = dataDir;
    ai.deviceProtectedDataDir = deviceProtectedDataDir;
    ai.credentialProtectedDataDir = credentialProtectedDataDir;
    ai.nativeLibraryDir = nativeLibraryDir;
    ai.secondaryNativeLibraryDir = secondaryNativeLibraryDir;
}
Body of Second Method:
{
    ai.packageName = packageName;
    ai.sourceDir = sourceDir;
    ai.publicSourceDir = publicSourceDir;
    ai.splitNames = splitNames;
    ai.splitSourceDirs = splitSourceDirs;
    ai.splitPublicSourceDirs = splitPublicSourceDirs;
    ai.splitDependencies = splitDependencies;
    ai.dataDir = dataDir;
    ai.deviceProtectedDataDir = deviceProtectedDataDir;
    ai.credentialProtectedDataDir = credentialProtectedDataDir;
    ai.primaryCpuAbi = primaryCpuAbi;
    ai.secondaryCpuAbi = secondaryCpuAbi;
    ai.nativeLibraryDir = nativeLibraryDir;
    ai.secondaryNativeLibraryDir = secondaryNativeLibraryDir;
}
------------------------
Find a silently evolved API code:android.content.res.TypedArray.getDimension:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve a dimensional unit attribute at <var>index</var>. Unit
 * conversions are based on the current {@link DisplayMetrics}
 * associated with the resources this {@link TypedArray} object
 * came from.
 * <p>
 * This method will throw an exception if the attribute is defined but is
 * not a dimension.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute dimension value multiplied by the appropriate
 * metric, or defValue if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not an integer.
 *
 * @see #getDimensionPixelOffset
 * @see #getDimensionPixelSize
 */

Body of Frist Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    final int attrIndex = index;
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimension(data[index + AssetManager.STYLE_DATA], mMetrics);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index, value);
        throw new UnsupportedOperationException("Failed to resolve attribute at index " + attrIndex + ": " + value);
    }
    throw new UnsupportedOperationException("Can't convert value at index " + attrIndex + " to dimension: type=0x" + Integer.toHexString(type));
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    final int attrIndex = index;
    index *= STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimension(data[index + STYLE_DATA], mMetrics);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index, value);
        throw new UnsupportedOperationException("Failed to resolve attribute at index " + attrIndex + ": " + value);
    }
    throw new UnsupportedOperationException("Can't convert value at index " + attrIndex + " to dimension: type=0x" + Integer.toHexString(type));
}
------------------------
Find a silently evolved API code:android.net.TrafficStats.getMobileRxBytes:COMMENT
Method Modifier: public      static      
Comment:/**
 * Return number of bytes received across mobile networks since device boot.
 * Counts packets across all mobile network interfaces, and always increases
 * monotonically since device boot. Statistics are measured at the network
 * layer, so they include both TCP and UDP usage.
 * <p>
 * Before {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}, this may
 * return {@link #UNSUPPORTED} on devices where statistics aren't available.
 */

Body of Frist Method:
{
    long total = 0;
    for (String iface : getMobileIfaces()) {
        total += getRxBytes(iface);
    }
    return total;
}
Body of Second Method:
{
    long total = 0;
    for (String iface : getMobileIfaces()) {
        total += addIfSupported(getRxBytes(iface));
    }
    return total;
}
------------------------
Find a silently evolved API code:android.media.session.MediaController.TransportControls.prepareFromSearch:COMMENT
Method Modifier: public      
Comment:/**
 * Request that the player prepare playback for a specific search query. An empty or null
 * query should be treated as a request to prepare any music. In other words, other sessions
 * can continue to play during the preparation of this session. This method can be used to
 * speed up the start of the playback. Once the preparation is done, the session will
 * change its playback state to {@link PlaybackState#STATE_PAUSED}. Afterwards,
 * {@link #play} can be called to start playback. If the preparation is not needed,
 * {@link #playFromSearch} can be directly called without this method.
 *
 * @param query The search query.
 * @param extras Optional extras that can include extra information
 * about the query.
 */

Body of Frist Method:
{
    if (query == null) {
        // This is to remain compatible with
        // INTENT_ACTION_MEDIA_PLAY_FROM_SEARCH
        query = "";
    }
    try {
        mSessionBinder.prepareFromSearch(query, extras);
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling prepare(" + query + ").", e);
    }
}
Body of Second Method:
{
    if (query == null) {
        // This is to remain compatible with
        // INTENT_ACTION_MEDIA_PLAY_FROM_SEARCH
        query = "";
    }
    try {
        mSessionBinder.prepareFromSearch(mContext.getPackageName(), mCbStub, query, extras);
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling prepare(" + query + ").", e);
    }
}
------------------------
Find a silently evolved API code:android.os.ParcelFileDescriptor.detachFd:COMMENT
Method Modifier: public      
Comment:/**
 * Return the native fd int for this ParcelFileDescriptor and detach it from
 * the object here. You are now responsible for closing the fd in native
 * code.
 * <p>
 * You should not detach when the original creator of the descriptor is
 * expecting a reliable signal through {@link #close()} or
 * {@link #closeWithError(String)}.
 *
 * @see #canDetectErrors()
 */

Body of Frist Method:
{
    if (mWrapped != null) {
        return mWrapped.detachFd();
    } else {
        if (mClosed) {
            throw new IllegalStateException("Already closed");
        }
        final int fd = getFd();
        Parcel.clearFileDescriptor(mFd);
        writeCommStatusAndClose(Status.DETACHED, null);
        mClosed = true;
        mGuard.close();
        releaseResources();
        return fd;
    }
}
Body of Second Method:
{
    if (mWrapped != null) {
        return mWrapped.detachFd();
    } else {
        if (mClosed) {
            throw new IllegalStateException("Already closed");
        }
        final int fd = getFd();
        mFd.setInt$(-1);
        writeCommStatusAndClose(Status.DETACHED, null);
        mClosed = true;
        mGuard.close();
        releaseResources();
        return fd;
    }
}
------------------------
Find a silently evolved API code:android.view.inputmethod.BaseInputConnection.getSelectedText:COMMENT
Method Modifier: public      
Comment:/**
 * The default implementation returns the text currently selected, or null if none is
 * selected.
 */

Body of Frist Method:
{
    final Editable content = getEditable();
    if (content == null)
        return null;
    int a = Selection.getSelectionStart(content);
    int b = Selection.getSelectionEnd(content);
    if (a > b) {
        int tmp = a;
        a = b;
        b = tmp;
    }
    if (a == b)
        return null;
    if ((flags & GET_TEXT_WITH_STYLES) != 0) {
        return content.subSequence(a, b);
    }
    return TextUtils.substring(content, a, b);
}
Body of Second Method:
{
    final Editable content = getEditable();
    if (content == null)
        return null;
    int a = Selection.getSelectionStart(content);
    int b = Selection.getSelectionEnd(content);
    if (a > b) {
        int tmp = a;
        a = b;
        b = tmp;
    }
    if (a == b || a < 0)
        return null;
    if ((flags & GET_TEXT_WITH_STYLES) != 0) {
        return content.subSequence(a, b);
    }
    return TextUtils.substring(content, a, b);
}
------------------------
Find a silently evolved API code:android.telephony.SignalStrength.isGsm:COMMENT
Method Modifier: public      
Comment:/**
 * @return true if this is for GSM
 */

Body of Frist Method:
{
    return this.isGsm;
}
Body of Second Method:
{
    return this.mIsGsm;
}
------------------------
Find a silently evolved API code:android.net.TrafficStats.getMobileTcpRxPackets:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * {@hide}
 */

Body of Frist Method:
{
    long total = 0;
    for (String iface : getMobileIfaces()) {
        final long stat = nativeGetIfaceStat(iface, TYPE_TCP_RX_PACKETS);
        if (stat != UNSUPPORTED) {
            total += stat;
        }
    }
    return total;
}
Body of Second Method:
{
    long total = 0;
    for (String iface : getMobileIfaces()) {
        long stat = UNSUPPORTED;
        try {
            stat = getStatsService().getIfaceStats(iface, TYPE_TCP_RX_PACKETS);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
        total += addIfSupported(stat);
    }
    return total;
}
------------------------
Find a silently evolved API code:android.app.ActivityManagerNative.noteAlarmFinish:COMMENT
Method Modifier: public      static      hidden      deprecated  
Comment:/**
 * @deprecated use ActivityManager.noteAlarmFinish instead.
 */

Body of Frist Method:
{
    ActivityManager.noteAlarmFinish(ps, sourceUid, tag);
}
Body of Second Method:
{
    ActivityManager.noteAlarmFinish(ps, null, sourceUid, tag);
}
------------------------
Find a silently evolved API code:android.text.Selection.moveUp:COMMENT
Method Modifier: public      static      
Comment:/**
 * Move the cursor to the buffer offset physically above the current
 * offset, to the beginning if it is on the top line but not at the
 * start, or return false if the cursor is already on the top line.
 */

Body of Frist Method:
{
    int start = getSelectionStart(text);
    int end = getSelectionEnd(text);
    if (start != end) {
        int min = Math.min(start, end);
        int max = Math.max(start, end);
        setSelection(text, min);
        if (min == 0 && max == text.length()) {
            return false;
        }
        return true;
    } else {
        int line = layout.getLineForOffset(end);
        if (line > 0) {
            int move;
            if (layout.getParagraphDirection(line) == layout.getParagraphDirection(line - 1)) {
                float h = layout.getPrimaryHorizontal(end);
                move = layout.getOffsetForHorizontal(line - 1, h);
            } else {
                move = layout.getLineStart(line - 1);
            }
            setSelection(text, move);
            return true;
        } else if (end != 0) {
            setSelection(text, 0);
            return true;
        }
    }
    return false;
}
Body of Second Method:
{
    int start = getSelectionStart(text);
    int end = getSelectionEnd(text);
    if (start != end) {
        int min = Math.min(start, end);
        int max = Math.max(start, end);
        setSelection(text, min);
        if (min == 0 && max == text.length()) {
            return false;
        }
        return true;
    } else {
        int line = layout.getLineForOffset(end);
        if (line > 0) {
            setSelectionAndMemory(text, layout, line, end, -1, /* direction */
            false);
            return true;
        } else if (end != 0) {
            setSelection(text, 0);
            return true;
        }
    }
    return false;
}
------------------------
Find a silently evolved API code:android.net.TrafficStats.getUidTxPackets:COMMENT
Method Modifier: public      static      
Comment:/**
 * Return number of packets transmitted by the given UID since device boot.
 * Counts packets across all network interfaces, and always increases
 * monotonically since device boot. Statistics are measured at the network
 * layer, so they include both TCP and UDP usage.
 * <p>
 * Before {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}, this may return
 * {@link #UNSUPPORTED} on devices where statistics aren't available.
 * <p>
 * Starting in {@link android.os.Build.VERSION_CODES#N} this will only
 * report traffic statistics for the calling UID. It will return
 * {@link #UNSUPPORTED} for all other UIDs for privacy reasons. To access
 * historical network statistics belonging to other UIDs, use
 * {@link NetworkStatsManager}.
 *
 * @see android.os.Process#myUid()
 * @see android.content.pm.ApplicationInfo#uid
 */

Body of Frist Method:
{
    // This isn't actually enforcing any security; it just returns the
    // unsupported value. The real filtering is done at the kernel level.
    final int callingUid = android.os.Process.myUid();
    if (callingUid == android.os.Process.SYSTEM_UID || callingUid == uid) {
        return nativeGetUidStat(uid, TYPE_TX_PACKETS);
    } else {
        return UNSUPPORTED;
    }
}
Body of Second Method:
{
    // This isn't actually enforcing any security; it just returns the
    // unsupported value. The real filtering is done at the kernel level.
    final int callingUid = android.os.Process.myUid();
    if (callingUid == android.os.Process.SYSTEM_UID || callingUid == uid) {
        try {
            return getStatsService().getUidStats(uid, TYPE_TX_PACKETS);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    } else {
        return UNSUPPORTED;
    }
}
------------------------
Find a silently evolved API code:android.os.IncidentReportArgs.toString:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Print this report as a string.
 */

Body of Frist Method:
{
    final StringBuilder sb = new StringBuilder("Incident(");
    if (mAll) {
        sb.append("all");
    } else {
        final int N = mSections.size();
        if (N > 0) {
            sb.append(mSections.get(0));
        }
        for (int i = 1; i < N; i++) {
            sb.append(" ");
            sb.append(mSections.get(i));
        }
    }
    sb.append(", ");
    sb.append(mHeaders.size());
    sb.append(" headers)");
    return sb.toString();
}
Body of Second Method:
{
    final StringBuilder sb = new StringBuilder("Incident(");
    if (mAll) {
        sb.append("all");
    } else {
        final int N = mSections.size();
        if (N > 0) {
            sb.append(mSections.get(0));
        }
        for (int i = 1; i < N; i++) {
            sb.append(" ");
            sb.append(mSections.get(i));
        }
    }
    sb.append(", ");
    sb.append(mHeaders.size());
    sb.append(" headers), ");
    sb.append("Dest enum value: ").append(mDest);
    return sb.toString();
}
------------------------
Find a silently evolved API code:android.hardware.Camera.enableShutterSound:COMMENT
Method Modifier: public      final       deprecated  
Comment:/**
 * <p>Enable or disable the default shutter sound when taking a picture.</p>
 *
 * <p>By default, the camera plays the system-defined camera shutter sound
 * when {@link #takePicture} is called. Using this method, the shutter sound
 * can be disabled. It is strongly recommended that an alternative shutter
 * sound is played in the {@link ShutterCallback} when the system shutter
 * sound is disabled.</p>
 *
 * <p>Note that devices may not always allow disabling the camera shutter
 * sound. If the shutter sound state cannot be set to the desired value,
 * this method will return false. {@link CameraInfo#canDisableShutterSound}
 * can be used to determine whether the device will allow the shutter sound
 * to be disabled.</p>
 *
 * @param enabled whether the camera should play the system shutter sound
 * when {@link #takePicture takePicture} is called.
 * @return {@code true} if the shutter sound state was successfully
 * changed. {@code false} if the shutter sound state could not be
 * changed. {@code true} is also returned if shutter sound playback
 * is already set to the requested state.
 * @throws RuntimeException if the call fails; usually this would be because
 * of a hardware or other low-level error, or because release() has been
 * called on this Camera instance.
 * @see #takePicture
 * @see CameraInfo#canDisableShutterSound
 * @see ShutterCallback
 */

Body of Frist Method:
{
    if (!enabled) {
        IBinder b = ServiceManager.getService(Context.AUDIO_SERVICE);
        IAudioService audioService = IAudioService.Stub.asInterface(b);
        try {
            if (audioService.isCameraSoundForced())
                return false;
        } catch (RemoteException e) {
            Log.e(TAG, "Audio service is unavailable for queries");
        }
    }
    return _enableShutterSound(enabled);
}
Body of Second Method:
{
    boolean canDisableShutterSound = true;
    IBinder b = ServiceManager.getService(Context.AUDIO_SERVICE);
    IAudioService audioService = IAudioService.Stub.asInterface(b);
    try {
        if (audioService.isCameraSoundForced()) {
            canDisableShutterSound = false;
        }
    } catch (RemoteException e) {
        Log.e(TAG, "Audio service is unavailable for queries");
    }
    if (!enabled && !canDisableShutterSound) {
        return false;
    }
    synchronized (mShutterSoundLock) {
        mShutterSoundEnabledFromApp = enabled;
        // Return the result of _enableShutterSound(enabled) in all cases.
        // If the shutter sound can be disabled, disable it when the device is in DnD mode.
        boolean ret = _enableShutterSound(enabled);
        if (enabled && !mHasAppOpsPlayAudio) {
            Log.i(TAG, "Shutter sound is not allowed by AppOpsManager");
            if (canDisableShutterSound) {
                _enableShutterSound(false);
            }
        }
        return ret;
    }
}
------------------------
Find a silently evolved API code:android.content.ContentResolver.getPersistedUriPermissions:COMMENT
Method Modifier: public      
Comment:/**
 * Return list of all URI permission grants that have been persisted by the
 * calling app. That is, the returned permissions have been granted
 * <em>to</em> the calling app. Only persistable grants taken with
 * {@link #takePersistableUriPermission(Uri, int)} are returned.
 * <p>Note: Some of the returned URIs may not be usable until after the user is unlocked.
 *
 * @see #takePersistableUriPermission(Uri, int)
 * @see #releasePersistableUriPermission(Uri, int)
 */

Body of Frist Method:
{
    try {
        return ActivityManager.getService().getPersistedUriPermissions(mPackageName, true).getList();
    } catch (RemoteException e) {
        throw new RuntimeException("Activity manager has died", e);
    }
}
Body of Second Method:
{
    try {
        return ActivityManager.getService().getPersistedUriPermissions(mPackageName, true).getList();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.content.om.OverlayInfo.isEnabled:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Return true if this overlay is enabled, i.e. should be used to overlay
 * the resources in the target package.
 *
 * Disabled overlay packages are installed but are currently not in use.
 *
 * @return true if the overlay is enabled, else false.
 */

Body of Frist Method:
{
    switch(state) {
        case STATE_ENABLED:
            return true;
        default:
            return false;
    }
}
Body of Second Method:
{
    switch(state) {
        case STATE_ENABLED:
        case STATE_ENABLED_STATIC:
            return true;
        default:
            return false;
    }
}
------------------------
Find a silently evolved API code:android.service.autofill.FillCallback.onFailure:COMMENT
Method Modifier: public      
Comment:/**
 * Notifies the Android System that an
 * {@link AutofillService#onFillRequest(FillRequest, android.os.CancellationSignal,
 * FillCallback)} could not be fulfilled by the service.
 *
 * @param message error message to be displayed to the user.
 */

Body of Frist Method:
{
    assertNotCalled();
    mCalled = true;
    try {
        mCallback.onFailure(message);
    } catch (RemoteException e) {
        e.rethrowAsRuntimeException();
    }
}
Body of Second Method:
{
    assertNotCalled();
    mCalled = true;
    try {
        mCallback.onFailure(mRequestId, message);
    } catch (RemoteException e) {
        e.rethrowAsRuntimeException();
    }
}
------------------------
Find a silently evolved API code:android.util.proto.ProtoOutputStream.writeObject:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * Write an object that has already been flattend.
 *
 * @deprecated Use #write instead.
 */

Body of Frist Method:
{
    assertNotCompacted();
    final int id = checkFieldId(fieldId, FIELD_COUNT_SINGLE | FIELD_TYPE_OBJECT);
    writeObjectImpl(id, value);
}
Body of Second Method:
{
    assertNotCompacted();
    final int id = checkFieldId(fieldId, FIELD_COUNT_SINGLE | FIELD_TYPE_MESSAGE);
    writeObjectImpl(id, value);
}
------------------------
Find a silently evolved API code:android.content.res.TypedArray.getValue:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the raw TypedValue for the attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 * @param outValue TypedValue object in which to place the attribute's
 * data.
 *
 * @return {@code true} if the value was retrieved and not @empty, {@code false} otherwise.
 * @throws RuntimeException if the TypedArray has already been recycled.
 */

Body of Frist Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    return getValueAt(index * AssetManager.STYLE_NUM_ENTRIES, outValue);
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    return getValueAt(index * STYLE_NUM_ENTRIES, outValue);
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiActivityEnergyInfo.isValid:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @return if the record is valid
 */

Body of Frist Method:
{
    return ((mControllerTxTimeMs >= 0) && (mControllerRxTimeMs >= 0) && (mControllerIdleTimeMs >= 0));
}
Body of Second Method:
{
    return ((mControllerTxTimeMs >= 0) && (mControllerRxTimeMs >= 0) && (mControllerScanTimeMs >= 0) && (mControllerIdleTimeMs >= 0));
}
------------------------
Find a silently evolved API code:android.content.ContentResolver.getSyncStatusAsUser:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @see #getSyncStatus(Account, String)
 * @hide
 */

Body of Frist Method:
{
    try {
        return getContentService().getSyncStatusAsUser(account, authority, null, userId);
    } catch (RemoteException e) {
        throw new RuntimeException("the ContentService should always be reachable", e);
    }
}
Body of Second Method:
{
    try {
        return getContentService().getSyncStatusAsUser(account, authority, null, userId);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.speech.RecognitionService.checkPermissions:COMMENT
Method Modifier: private     
Comment:/**
 * Checks whether the caller has sufficient permissions
 *
 * @param listener to send the error message to in case of error
 * @return {@code true} if the caller has enough permissions, {@code false} otherwise
 */

Body of Frist Method:
{
    if (DBG)
        Log.d(TAG, "checkPermissions");
    if (RecognitionService.this.checkCallingOrSelfPermission(android.Manifest.permission.RECORD_AUDIO) == PackageManager.PERMISSION_GRANTED) {
        return true;
    }
    try {
        Log.e(TAG, "call for recognition service without RECORD_AUDIO permissions");
        listener.onError(SpeechRecognizer.ERROR_INSUFFICIENT_PERMISSIONS);
    } catch (RemoteException re) {
        Log.e(TAG, "sending ERROR_INSUFFICIENT_PERMISSIONS message failed", re);
    }
    return false;
}
Body of Second Method:
{
    if (DBG)
        Log.d(TAG, "checkPermissions");
    if (PermissionChecker.checkCallingOrSelfPermission(this, android.Manifest.permission.RECORD_AUDIO) == PermissionChecker.PERMISSION_GRANTED) {
        return true;
    }
    try {
        Log.e(TAG, "call for recognition service without RECORD_AUDIO permissions");
        listener.onError(SpeechRecognizer.ERROR_INSUFFICIENT_PERMISSIONS);
    } catch (RemoteException re) {
        Log.e(TAG, "sending ERROR_INSUFFICIENT_PERMISSIONS message failed", re);
    }
    return false;
}
------------------------
Find a silently evolved API code:android.graphics.drawable.RippleDrawable.clearHotspots:COMMENT
Method Modifier: private     
Comment:/**
 * Cancels and removes the active ripple, all exiting ripples, and the
 * background. Nothing will be drawn after this method is called.
 */

Body of Frist Method:
{
    if (mRipple != null) {
        mRipple.end();
        mRipple = null;
        mRippleActive = false;
    }
    if (mBackground != null) {
        mBackground.end();
        mBackground = null;
        mBackgroundActive = false;
    }
    cancelExitingRipples();
}
Body of Second Method:
{
    if (mRipple != null) {
        mRipple.end();
        mRipple = null;
        mRippleActive = false;
    }
    if (mBackground != null) {
        mBackground.setState(false, false, false);
    }
    cancelExitingRipples();
}
------------------------
Find a silently evolved API code:android.widget.LinearLayout.measureHorizontal:COMMENT
Method Modifier: default     
Comment:/**
 * Measures the children when the orientation of this LinearLayout is set
 * to {@link #HORIZONTAL}.
 *
 * @param widthMeasureSpec Horizontal space requirements as imposed by the parent.
 * @param heightMeasureSpec Vertical space requirements as imposed by the parent.
 *
 * @see #getOrientation()
 * @see #setOrientation(int)
 * @see #onMeasure(int, int)
 */

Body of Frist Method:
{
    mTotalLength = 0;
    int maxHeight = 0;
    int childState = 0;
    int alternativeMaxHeight = 0;
    int weightedMaxHeight = 0;
    boolean allFillParent = true;
    float totalWeight = 0;
    final int count = getVirtualChildCount();
    final int widthMode = MeasureSpec.getMode(widthMeasureSpec);
    final int heightMode = MeasureSpec.getMode(heightMeasureSpec);
    boolean matchHeight = false;
    boolean skippedMeasure = false;
    if (mMaxAscent == null || mMaxDescent == null) {
        mMaxAscent = new int[VERTICAL_GRAVITY_COUNT];
        mMaxDescent = new int[VERTICAL_GRAVITY_COUNT];
    }
    final int[] maxAscent = mMaxAscent;
    final int[] maxDescent = mMaxDescent;
    maxAscent[0] = maxAscent[1] = maxAscent[2] = maxAscent[3] = -1;
    maxDescent[0] = maxDescent[1] = maxDescent[2] = maxDescent[3] = -1;
    final boolean baselineAligned = mBaselineAligned;
    final boolean useLargestChild = mUseLargestChild;
    final boolean isExactly = widthMode == MeasureSpec.EXACTLY;
    int largestChildWidth = Integer.MIN_VALUE;
    int usedExcessSpace = 0;
    int nonSkippedChildCount = 0;
    // See how wide everyone is. Also remember max height.
    for (int i = 0; i < count; ++i) {
        final View child = getVirtualChildAt(i);
        if (child == null) {
            mTotalLength += measureNullChild(i);
            continue;
        }
        if (child.getVisibility() == GONE) {
            i += getChildrenSkipCount(child, i);
            continue;
        }
        nonSkippedChildCount++;
        if (hasDividerBeforeChildAt(i)) {
            mTotalLength += mDividerWidth;
        }
        final LayoutParams lp = (LayoutParams) child.getLayoutParams();
        totalWeight += lp.weight;
        final boolean useExcessSpace = lp.width == 0 && lp.weight > 0;
        if (widthMode == MeasureSpec.EXACTLY && useExcessSpace) {
            // later if we have space to distribute.
            if (isExactly) {
                mTotalLength += lp.leftMargin + lp.rightMargin;
            } else {
                final int totalLength = mTotalLength;
                mTotalLength = Math.max(totalLength, totalLength + lp.leftMargin + lp.rightMargin);
            }
            // later (and re-measure).
            if (baselineAligned) {
                final int freeWidthSpec = MeasureSpec.makeSafeMeasureSpec(MeasureSpec.getSize(widthMeasureSpec), MeasureSpec.UNSPECIFIED);
                final int freeHeightSpec = MeasureSpec.makeSafeMeasureSpec(MeasureSpec.getSize(heightMeasureSpec), MeasureSpec.UNSPECIFIED);
                child.measure(freeWidthSpec, freeHeightSpec);
            } else {
                skippedMeasure = true;
            }
        } else {
            if (useExcessSpace) {
                // The widthMode is either UNSPECIFIED or AT_MOST, and
                // this child is only laid out using excess space. Measure
                // using WRAP_CONTENT so that we can find out the view's
                // optimal width. We'll restore the original width of 0
                // after measurement.
                lp.width = LayoutParams.WRAP_CONTENT;
            }
            // Determine how big this child would like to be. If this or
            // previous children have given a weight, then we allow it to
            // use all available space (and we will shrink things later
            // if needed).
            final int usedWidth = totalWeight == 0 ? mTotalLength : 0;
            measureChildBeforeLayout(child, i, widthMeasureSpec, usedWidth, heightMeasureSpec, 0);
            final int childWidth = child.getMeasuredWidth();
            if (useExcessSpace) {
                // Restore the original width and record how much space
                // we've allocated to excess-only children so that we can
                // match the behavior of EXACTLY measurement.
                lp.width = 0;
                usedExcessSpace += childWidth;
            }
            if (isExactly) {
                mTotalLength += childWidth + lp.leftMargin + lp.rightMargin + getNextLocationOffset(child);
            } else {
                final int totalLength = mTotalLength;
                mTotalLength = Math.max(totalLength, totalLength + childWidth + lp.leftMargin + lp.rightMargin + getNextLocationOffset(child));
            }
            if (useLargestChild) {
                largestChildWidth = Math.max(childWidth, largestChildWidth);
            }
        }
        boolean matchHeightLocally = false;
        if (heightMode != MeasureSpec.EXACTLY && lp.height == LayoutParams.MATCH_PARENT) {
            // The height of the linear layout will scale, and at least one
            // child said it wanted to match our height. Set a flag indicating that
            // we need to remeasure at least that view when we know our height.
            matchHeight = true;
            matchHeightLocally = true;
        }
        final int margin = lp.topMargin + lp.bottomMargin;
        final int childHeight = child.getMeasuredHeight() + margin;
        childState = combineMeasuredStates(childState, child.getMeasuredState());
        if (baselineAligned) {
            final int childBaseline = child.getBaseline();
            if (childBaseline != -1) {
                // Translates the child's vertical gravity into an index
                // in the range 0..VERTICAL_GRAVITY_COUNT
                final int gravity = (lp.gravity < 0 ? mGravity : lp.gravity) & Gravity.VERTICAL_GRAVITY_MASK;
                final int index = ((gravity >> Gravity.AXIS_Y_SHIFT) & ~Gravity.AXIS_SPECIFIED) >> 1;
                maxAscent[index] = Math.max(maxAscent[index], childBaseline);
                maxDescent[index] = Math.max(maxDescent[index], childHeight - childBaseline);
            }
        }
        maxHeight = Math.max(maxHeight, childHeight);
        allFillParent = allFillParent && lp.height == LayoutParams.MATCH_PARENT;
        if (lp.weight > 0) {
            /*
                 * Heights of weighted Views are bogus if we end up
                 * remeasuring, so keep them separate.
                 */
            weightedMaxHeight = Math.max(weightedMaxHeight, matchHeightLocally ? margin : childHeight);
        } else {
            alternativeMaxHeight = Math.max(alternativeMaxHeight, matchHeightLocally ? margin : childHeight);
        }
        i += getChildrenSkipCount(child, i);
    }
    if (nonSkippedChildCount > 0 && hasDividerBeforeChildAt(count)) {
        mTotalLength += mDividerWidth;
    }
    // the most common case
    if (maxAscent[INDEX_TOP] != -1 || maxAscent[INDEX_CENTER_VERTICAL] != -1 || maxAscent[INDEX_BOTTOM] != -1 || maxAscent[INDEX_FILL] != -1) {
        final int ascent = Math.max(maxAscent[INDEX_FILL], Math.max(maxAscent[INDEX_CENTER_VERTICAL], Math.max(maxAscent[INDEX_TOP], maxAscent[INDEX_BOTTOM])));
        final int descent = Math.max(maxDescent[INDEX_FILL], Math.max(maxDescent[INDEX_CENTER_VERTICAL], Math.max(maxDescent[INDEX_TOP], maxDescent[INDEX_BOTTOM])));
        maxHeight = Math.max(maxHeight, ascent + descent);
    }
    if (useLargestChild && (widthMode == MeasureSpec.AT_MOST || widthMode == MeasureSpec.UNSPECIFIED)) {
        mTotalLength = 0;
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child == null) {
                mTotalLength += measureNullChild(i);
                continue;
            }
            if (child.getVisibility() == GONE) {
                i += getChildrenSkipCount(child, i);
                continue;
            }
            final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
            if (isExactly) {
                mTotalLength += largestChildWidth + lp.leftMargin + lp.rightMargin + getNextLocationOffset(child);
            } else {
                final int totalLength = mTotalLength;
                mTotalLength = Math.max(totalLength, totalLength + largestChildWidth + lp.leftMargin + lp.rightMargin + getNextLocationOffset(child));
            }
        }
    }
    // Add in our padding
    mTotalLength += mPaddingLeft + mPaddingRight;
    int widthSize = mTotalLength;
    // Check against our minimum width
    widthSize = Math.max(widthSize, getSuggestedMinimumWidth());
    // Reconcile our calculated size with the widthMeasureSpec
    int widthSizeAndState = resolveSizeAndState(widthSize, widthMeasureSpec, 0);
    widthSize = widthSizeAndState & MEASURED_SIZE_MASK;
    // Either expand children with weight to take up available space or
    // shrink them if they extend beyond our current bounds. If we skipped
    // measurement on any children, we need to measure them now.
    int remainingExcess = widthSize - mTotalLength + (mAllowInconsistentMeasurement ? 0 : usedExcessSpace);
    if (skippedMeasure || remainingExcess != 0 && totalWeight > 0.0f) {
        float remainingWeightSum = mWeightSum > 0.0f ? mWeightSum : totalWeight;
        maxAscent[0] = maxAscent[1] = maxAscent[2] = maxAscent[3] = -1;
        maxDescent[0] = maxDescent[1] = maxDescent[2] = maxDescent[3] = -1;
        maxHeight = -1;
        mTotalLength = 0;
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child == null || child.getVisibility() == View.GONE) {
                continue;
            }
            final LayoutParams lp = (LayoutParams) child.getLayoutParams();
            final float childWeight = lp.weight;
            if (childWeight > 0) {
                final int share = (int) (childWeight * remainingExcess / remainingWeightSum);
                remainingExcess -= share;
                remainingWeightSum -= childWeight;
                final int childWidth;
                if (mUseLargestChild && widthMode != MeasureSpec.EXACTLY) {
                    childWidth = largestChildWidth;
                } else if (lp.width == 0 && (!mAllowInconsistentMeasurement || widthMode == MeasureSpec.EXACTLY)) {
                    // This child needs to be laid out from scratch using
                    // only its share of excess space.
                    childWidth = share;
                } else {
                    // This child had some intrinsic width to which we
                    // need to add its share of excess space.
                    childWidth = child.getMeasuredWidth() + share;
                }
                final int childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(Math.max(0, childWidth), MeasureSpec.EXACTLY);
                final int childHeightMeasureSpec = getChildMeasureSpec(heightMeasureSpec, mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin, lp.height);
                child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
                // Child may now not fit in horizontal dimension.
                childState = combineMeasuredStates(childState, child.getMeasuredState() & MEASURED_STATE_MASK);
            }
            if (isExactly) {
                mTotalLength += child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin + getNextLocationOffset(child);
            } else {
                final int totalLength = mTotalLength;
                mTotalLength = Math.max(totalLength, totalLength + child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin + getNextLocationOffset(child));
            }
            boolean matchHeightLocally = heightMode != MeasureSpec.EXACTLY && lp.height == LayoutParams.MATCH_PARENT;
            final int margin = lp.topMargin + lp.bottomMargin;
            int childHeight = child.getMeasuredHeight() + margin;
            maxHeight = Math.max(maxHeight, childHeight);
            alternativeMaxHeight = Math.max(alternativeMaxHeight, matchHeightLocally ? margin : childHeight);
            allFillParent = allFillParent && lp.height == LayoutParams.MATCH_PARENT;
            if (baselineAligned) {
                final int childBaseline = child.getBaseline();
                if (childBaseline != -1) {
                    // Translates the child's vertical gravity into an index in the range 0..2
                    final int gravity = (lp.gravity < 0 ? mGravity : lp.gravity) & Gravity.VERTICAL_GRAVITY_MASK;
                    final int index = ((gravity >> Gravity.AXIS_Y_SHIFT) & ~Gravity.AXIS_SPECIFIED) >> 1;
                    maxAscent[index] = Math.max(maxAscent[index], childBaseline);
                    maxDescent[index] = Math.max(maxDescent[index], childHeight - childBaseline);
                }
            }
        }
        // Add in our padding
        mTotalLength += mPaddingLeft + mPaddingRight;
        // the most common case
        if (maxAscent[INDEX_TOP] != -1 || maxAscent[INDEX_CENTER_VERTICAL] != -1 || maxAscent[INDEX_BOTTOM] != -1 || maxAscent[INDEX_FILL] != -1) {
            final int ascent = Math.max(maxAscent[INDEX_FILL], Math.max(maxAscent[INDEX_CENTER_VERTICAL], Math.max(maxAscent[INDEX_TOP], maxAscent[INDEX_BOTTOM])));
            final int descent = Math.max(maxDescent[INDEX_FILL], Math.max(maxDescent[INDEX_CENTER_VERTICAL], Math.max(maxDescent[INDEX_TOP], maxDescent[INDEX_BOTTOM])));
            maxHeight = Math.max(maxHeight, ascent + descent);
        }
    } else {
        alternativeMaxHeight = Math.max(alternativeMaxHeight, weightedMaxHeight);
        // Children will have already been measured once.
        if (useLargestChild && widthMode != MeasureSpec.EXACTLY) {
            for (int i = 0; i < count; i++) {
                final View child = getVirtualChildAt(i);
                if (child == null || child.getVisibility() == View.GONE) {
                    continue;
                }
                final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
                float childExtra = lp.weight;
                if (childExtra > 0) {
                    child.measure(MeasureSpec.makeMeasureSpec(largestChildWidth, MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(child.getMeasuredHeight(), MeasureSpec.EXACTLY));
                }
            }
        }
    }
    if (!allFillParent && heightMode != MeasureSpec.EXACTLY) {
        maxHeight = alternativeMaxHeight;
    }
    maxHeight += mPaddingTop + mPaddingBottom;
    // Check against our minimum height
    maxHeight = Math.max(maxHeight, getSuggestedMinimumHeight());
    setMeasuredDimension(widthSizeAndState | (childState & MEASURED_STATE_MASK), resolveSizeAndState(maxHeight, heightMeasureSpec, (childState << MEASURED_HEIGHT_STATE_SHIFT)));
    if (matchHeight) {
        forceUniformHeight(count, widthMeasureSpec);
    }
}
Body of Second Method:
{
    mTotalLength = 0;
    int maxHeight = 0;
    int childState = 0;
    int alternativeMaxHeight = 0;
    int weightedMaxHeight = 0;
    boolean allFillParent = true;
    float totalWeight = 0;
    final int count = getVirtualChildCount();
    final int widthMode = MeasureSpec.getMode(widthMeasureSpec);
    final int heightMode = MeasureSpec.getMode(heightMeasureSpec);
    boolean matchHeight = false;
    boolean skippedMeasure = false;
    if (mMaxAscent == null || mMaxDescent == null) {
        mMaxAscent = new int[VERTICAL_GRAVITY_COUNT];
        mMaxDescent = new int[VERTICAL_GRAVITY_COUNT];
    }
    final int[] maxAscent = mMaxAscent;
    final int[] maxDescent = mMaxDescent;
    maxAscent[0] = maxAscent[1] = maxAscent[2] = maxAscent[3] = -1;
    maxDescent[0] = maxDescent[1] = maxDescent[2] = maxDescent[3] = -1;
    final boolean baselineAligned = mBaselineAligned;
    final boolean useLargestChild = mUseLargestChild;
    final boolean isExactly = widthMode == MeasureSpec.EXACTLY;
    int largestChildWidth = Integer.MIN_VALUE;
    int usedExcessSpace = 0;
    int nonSkippedChildCount = 0;
    // See how wide everyone is. Also remember max height.
    for (int i = 0; i < count; ++i) {
        final View child = getVirtualChildAt(i);
        if (child == null) {
            mTotalLength += measureNullChild(i);
            continue;
        }
        if (child.getVisibility() == GONE) {
            i += getChildrenSkipCount(child, i);
            continue;
        }
        nonSkippedChildCount++;
        if (hasDividerBeforeChildAt(i)) {
            mTotalLength += mDividerWidth;
        }
        final LayoutParams lp = (LayoutParams) child.getLayoutParams();
        totalWeight += lp.weight;
        final boolean useExcessSpace = lp.width == 0 && lp.weight > 0;
        if (widthMode == MeasureSpec.EXACTLY && useExcessSpace) {
            // later if we have space to distribute.
            if (isExactly) {
                mTotalLength += lp.leftMargin + lp.rightMargin;
            } else {
                final int totalLength = mTotalLength;
                mTotalLength = Math.max(totalLength, totalLength + lp.leftMargin + lp.rightMargin);
            }
            // later (and re-measure).
            if (baselineAligned) {
                final int freeWidthSpec = MeasureSpec.makeSafeMeasureSpec(MeasureSpec.getSize(widthMeasureSpec), MeasureSpec.UNSPECIFIED);
                final int freeHeightSpec = MeasureSpec.makeSafeMeasureSpec(MeasureSpec.getSize(heightMeasureSpec), MeasureSpec.UNSPECIFIED);
                child.measure(freeWidthSpec, freeHeightSpec);
            } else {
                skippedMeasure = true;
            }
        } else {
            if (useExcessSpace) {
                // The widthMode is either UNSPECIFIED or AT_MOST, and
                // this child is only laid out using excess space. Measure
                // using WRAP_CONTENT so that we can find out the view's
                // optimal width. We'll restore the original width of 0
                // after measurement.
                lp.width = LayoutParams.WRAP_CONTENT;
            }
            // Determine how big this child would like to be. If this or
            // previous children have given a weight, then we allow it to
            // use all available space (and we will shrink things later
            // if needed).
            final int usedWidth = totalWeight == 0 ? mTotalLength : 0;
            measureChildBeforeLayout(child, i, widthMeasureSpec, usedWidth, heightMeasureSpec, 0);
            final int childWidth = child.getMeasuredWidth();
            if (useExcessSpace) {
                // Restore the original width and record how much space
                // we've allocated to excess-only children so that we can
                // match the behavior of EXACTLY measurement.
                lp.width = 0;
                usedExcessSpace += childWidth;
            }
            if (isExactly) {
                mTotalLength += childWidth + lp.leftMargin + lp.rightMargin + getNextLocationOffset(child);
            } else {
                final int totalLength = mTotalLength;
                mTotalLength = Math.max(totalLength, totalLength + childWidth + lp.leftMargin + lp.rightMargin + getNextLocationOffset(child));
            }
            if (useLargestChild) {
                largestChildWidth = Math.max(childWidth, largestChildWidth);
            }
        }
        boolean matchHeightLocally = false;
        if (heightMode != MeasureSpec.EXACTLY && lp.height == LayoutParams.MATCH_PARENT) {
            // The height of the linear layout will scale, and at least one
            // child said it wanted to match our height. Set a flag indicating that
            // we need to remeasure at least that view when we know our height.
            matchHeight = true;
            matchHeightLocally = true;
        }
        final int margin = lp.topMargin + lp.bottomMargin;
        final int childHeight = child.getMeasuredHeight() + margin;
        childState = combineMeasuredStates(childState, child.getMeasuredState());
        if (baselineAligned) {
            final int childBaseline = child.getBaseline();
            if (childBaseline != -1) {
                // Translates the child's vertical gravity into an index
                // in the range 0..VERTICAL_GRAVITY_COUNT
                final int gravity = (lp.gravity < 0 ? mGravity : lp.gravity) & Gravity.VERTICAL_GRAVITY_MASK;
                final int index = ((gravity >> Gravity.AXIS_Y_SHIFT) & ~Gravity.AXIS_SPECIFIED) >> 1;
                maxAscent[index] = Math.max(maxAscent[index], childBaseline);
                maxDescent[index] = Math.max(maxDescent[index], childHeight - childBaseline);
            }
        }
        maxHeight = Math.max(maxHeight, childHeight);
        allFillParent = allFillParent && lp.height == LayoutParams.MATCH_PARENT;
        if (lp.weight > 0) {
            /*
                 * Heights of weighted Views are bogus if we end up
                 * remeasuring, so keep them separate.
                 */
            weightedMaxHeight = Math.max(weightedMaxHeight, matchHeightLocally ? margin : childHeight);
        } else {
            alternativeMaxHeight = Math.max(alternativeMaxHeight, matchHeightLocally ? margin : childHeight);
        }
        i += getChildrenSkipCount(child, i);
    }
    if (nonSkippedChildCount > 0 && hasDividerBeforeChildAt(count)) {
        mTotalLength += mDividerWidth;
    }
    // the most common case
    if (maxAscent[INDEX_TOP] != -1 || maxAscent[INDEX_CENTER_VERTICAL] != -1 || maxAscent[INDEX_BOTTOM] != -1 || maxAscent[INDEX_FILL] != -1) {
        final int ascent = Math.max(maxAscent[INDEX_FILL], Math.max(maxAscent[INDEX_CENTER_VERTICAL], Math.max(maxAscent[INDEX_TOP], maxAscent[INDEX_BOTTOM])));
        final int descent = Math.max(maxDescent[INDEX_FILL], Math.max(maxDescent[INDEX_CENTER_VERTICAL], Math.max(maxDescent[INDEX_TOP], maxDescent[INDEX_BOTTOM])));
        maxHeight = Math.max(maxHeight, ascent + descent);
    }
    if (useLargestChild && (widthMode == MeasureSpec.AT_MOST || widthMode == MeasureSpec.UNSPECIFIED)) {
        mTotalLength = 0;
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child == null) {
                mTotalLength += measureNullChild(i);
                continue;
            }
            if (child.getVisibility() == GONE) {
                i += getChildrenSkipCount(child, i);
                continue;
            }
            final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
            if (isExactly) {
                mTotalLength += largestChildWidth + lp.leftMargin + lp.rightMargin + getNextLocationOffset(child);
            } else {
                final int totalLength = mTotalLength;
                mTotalLength = Math.max(totalLength, totalLength + largestChildWidth + lp.leftMargin + lp.rightMargin + getNextLocationOffset(child));
            }
        }
    }
    // Add in our padding
    mTotalLength += mPaddingLeft + mPaddingRight;
    int widthSize = mTotalLength;
    // Check against our minimum width
    widthSize = Math.max(widthSize, getSuggestedMinimumWidth());
    // Reconcile our calculated size with the widthMeasureSpec
    int widthSizeAndState = resolveSizeAndState(widthSize, widthMeasureSpec, 0);
    widthSize = widthSizeAndState & MEASURED_SIZE_MASK;
    // Either expand children with weight to take up available space or
    // shrink them if they extend beyond our current bounds. If we skipped
    // measurement on any children, we need to measure them now.
    int remainingExcess = widthSize - mTotalLength + (mAllowInconsistentMeasurement ? 0 : usedExcessSpace);
    if (skippedMeasure || ((sRemeasureWeightedChildren || remainingExcess != 0) && totalWeight > 0.0f)) {
        float remainingWeightSum = mWeightSum > 0.0f ? mWeightSum : totalWeight;
        maxAscent[0] = maxAscent[1] = maxAscent[2] = maxAscent[3] = -1;
        maxDescent[0] = maxDescent[1] = maxDescent[2] = maxDescent[3] = -1;
        maxHeight = -1;
        mTotalLength = 0;
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child == null || child.getVisibility() == View.GONE) {
                continue;
            }
            final LayoutParams lp = (LayoutParams) child.getLayoutParams();
            final float childWeight = lp.weight;
            if (childWeight > 0) {
                final int share = (int) (childWeight * remainingExcess / remainingWeightSum);
                remainingExcess -= share;
                remainingWeightSum -= childWeight;
                final int childWidth;
                if (mUseLargestChild && widthMode != MeasureSpec.EXACTLY) {
                    childWidth = largestChildWidth;
                } else if (lp.width == 0 && (!mAllowInconsistentMeasurement || widthMode == MeasureSpec.EXACTLY)) {
                    // This child needs to be laid out from scratch using
                    // only its share of excess space.
                    childWidth = share;
                } else {
                    // This child had some intrinsic width to which we
                    // need to add its share of excess space.
                    childWidth = child.getMeasuredWidth() + share;
                }
                final int childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(Math.max(0, childWidth), MeasureSpec.EXACTLY);
                final int childHeightMeasureSpec = getChildMeasureSpec(heightMeasureSpec, mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin, lp.height);
                child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
                // Child may now not fit in horizontal dimension.
                childState = combineMeasuredStates(childState, child.getMeasuredState() & MEASURED_STATE_MASK);
            }
            if (isExactly) {
                mTotalLength += child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin + getNextLocationOffset(child);
            } else {
                final int totalLength = mTotalLength;
                mTotalLength = Math.max(totalLength, totalLength + child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin + getNextLocationOffset(child));
            }
            boolean matchHeightLocally = heightMode != MeasureSpec.EXACTLY && lp.height == LayoutParams.MATCH_PARENT;
            final int margin = lp.topMargin + lp.bottomMargin;
            int childHeight = child.getMeasuredHeight() + margin;
            maxHeight = Math.max(maxHeight, childHeight);
            alternativeMaxHeight = Math.max(alternativeMaxHeight, matchHeightLocally ? margin : childHeight);
            allFillParent = allFillParent && lp.height == LayoutParams.MATCH_PARENT;
            if (baselineAligned) {
                final int childBaseline = child.getBaseline();
                if (childBaseline != -1) {
                    // Translates the child's vertical gravity into an index in the range 0..2
                    final int gravity = (lp.gravity < 0 ? mGravity : lp.gravity) & Gravity.VERTICAL_GRAVITY_MASK;
                    final int index = ((gravity >> Gravity.AXIS_Y_SHIFT) & ~Gravity.AXIS_SPECIFIED) >> 1;
                    maxAscent[index] = Math.max(maxAscent[index], childBaseline);
                    maxDescent[index] = Math.max(maxDescent[index], childHeight - childBaseline);
                }
            }
        }
        // Add in our padding
        mTotalLength += mPaddingLeft + mPaddingRight;
        // the most common case
        if (maxAscent[INDEX_TOP] != -1 || maxAscent[INDEX_CENTER_VERTICAL] != -1 || maxAscent[INDEX_BOTTOM] != -1 || maxAscent[INDEX_FILL] != -1) {
            final int ascent = Math.max(maxAscent[INDEX_FILL], Math.max(maxAscent[INDEX_CENTER_VERTICAL], Math.max(maxAscent[INDEX_TOP], maxAscent[INDEX_BOTTOM])));
            final int descent = Math.max(maxDescent[INDEX_FILL], Math.max(maxDescent[INDEX_CENTER_VERTICAL], Math.max(maxDescent[INDEX_TOP], maxDescent[INDEX_BOTTOM])));
            maxHeight = Math.max(maxHeight, ascent + descent);
        }
    } else {
        alternativeMaxHeight = Math.max(alternativeMaxHeight, weightedMaxHeight);
        // Children will have already been measured once.
        if (useLargestChild && widthMode != MeasureSpec.EXACTLY) {
            for (int i = 0; i < count; i++) {
                final View child = getVirtualChildAt(i);
                if (child == null || child.getVisibility() == View.GONE) {
                    continue;
                }
                final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
                float childExtra = lp.weight;
                if (childExtra > 0) {
                    child.measure(MeasureSpec.makeMeasureSpec(largestChildWidth, MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(child.getMeasuredHeight(), MeasureSpec.EXACTLY));
                }
            }
        }
    }
    if (!allFillParent && heightMode != MeasureSpec.EXACTLY) {
        maxHeight = alternativeMaxHeight;
    }
    maxHeight += mPaddingTop + mPaddingBottom;
    // Check against our minimum height
    maxHeight = Math.max(maxHeight, getSuggestedMinimumHeight());
    setMeasuredDimension(widthSizeAndState | (childState & MEASURED_STATE_MASK), resolveSizeAndState(maxHeight, heightMeasureSpec, (childState << MEASURED_HEIGHT_STATE_SHIFT)));
    if (matchHeight) {
        forceUniformHeight(count, widthMeasureSpec);
    }
}
------------------------
Find a silently evolved API code:android.media.session.MediaController.TransportControls.seekTo:COMMENT
Method Modifier: public      
Comment:/**
 * Move to a new location in the media stream.
 *
 * @param pos Position to move to, in milliseconds.
 */

Body of Frist Method:
{
    try {
        mSessionBinder.seekTo(pos);
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling seekTo.", e);
    }
}
Body of Second Method:
{
    try {
        mSessionBinder.seekTo(mContext.getPackageName(), mCbStub, pos);
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling seekTo.", e);
    }
}
------------------------
Find a silently evolved API code:android.os.Debug.MemoryInfo.getOtherPrivateDirty:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return otherStats[which * NUM_CATEGORIES + offsetPrivateDirty];
}
Body of Second Method:
{
    return otherStats[which * NUM_CATEGORIES + OFFSET_PRIVATE_DIRTY];
}
------------------------
Find a silently evolved API code:android.telephony.SignalStrength.getAsuLevel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the signal level as an asu value between 0..31, 99 is unknown
 *
 * @hide
 */

Body of Frist Method:
{
    int asuLevel = 0;
    if (isGsm) {
        if (getLteLevel() == SIGNAL_STRENGTH_NONE_OR_UNKNOWN) {
            if (getTdScdmaLevel() == SIGNAL_STRENGTH_NONE_OR_UNKNOWN) {
                asuLevel = getGsmAsuLevel();
            } else {
                asuLevel = getTdScdmaAsuLevel();
            }
        } else {
            asuLevel = getLteAsuLevel();
        }
    } else {
        int cdmaAsuLevel = getCdmaAsuLevel();
        int evdoAsuLevel = getEvdoAsuLevel();
        if (evdoAsuLevel == 0) {
            /* We don't know evdo use, cdma */
            asuLevel = cdmaAsuLevel;
        } else if (cdmaAsuLevel == 0) {
            /* We don't know cdma use, evdo */
            asuLevel = evdoAsuLevel;
        } else {
            /* We know both, use the lowest level */
            asuLevel = cdmaAsuLevel < evdoAsuLevel ? cdmaAsuLevel : evdoAsuLevel;
        }
    }
    if (DBG)
        log("getAsuLevel=" + asuLevel);
    return asuLevel;
}
Body of Second Method:
{
    int asuLevel = 0;
    if (mIsGsm) {
        if (mLteRsrp != SignalStrength.INVALID) {
            asuLevel = getLteAsuLevel();
        } else if (mTdScdmaRscp != SignalStrength.INVALID) {
            asuLevel = getTdScdmaAsuLevel();
        } else if (mWcdmaRscp != SignalStrength.INVALID) {
            asuLevel = getWcdmaAsuLevel();
        } else {
            asuLevel = getGsmAsuLevel();
        }
    } else {
        int cdmaAsuLevel = getCdmaAsuLevel();
        int evdoAsuLevel = getEvdoAsuLevel();
        if (evdoAsuLevel == 0) {
            /* We don't know evdo use, cdma */
            asuLevel = cdmaAsuLevel;
        } else if (cdmaAsuLevel == 0) {
            /* We don't know cdma use, evdo */
            asuLevel = evdoAsuLevel;
        } else {
            /* We know both, use the lowest level */
            asuLevel = cdmaAsuLevel < evdoAsuLevel ? cdmaAsuLevel : evdoAsuLevel;
        }
    }
    if (DBG)
        log("getAsuLevel=" + asuLevel);
    return asuLevel;
}
------------------------
Find a silently evolved API code:android.content.ContentResolver.takePersistableUriPermission:COMMENT
Method Modifier: public      
Comment:/**
 * Take a persistable URI permission grant that has been offered. Once
 * taken, the permission grant will be remembered across device reboots.
 * Only URI permissions granted with
 * {@link Intent#FLAG_GRANT_PERSISTABLE_URI_PERMISSION} can be persisted. If
 * the grant has already been persisted, taking it again will touch
 * {@link UriPermission#getPersistedTime()}.
 *
 * @see #getPersistedUriPermissions()
 */

Body of Frist Method:
{
    Preconditions.checkNotNull(uri, "uri");
    try {
        ActivityManager.getService().takePersistableUriPermission(ContentProvider.getUriWithoutUserId(uri), modeFlags, resolveUserId(uri));
    } catch (RemoteException e) {
    }
}
Body of Second Method:
{
    Preconditions.checkNotNull(uri, "uri");
    try {
        ActivityManager.getService().takePersistableUriPermission(ContentProvider.getUriWithoutUserId(uri), modeFlags, /* toPackage= */
        null, resolveUserId(uri));
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.hardware.HardwareBuffer.isSupportedFormat:COMMENT
Method Modifier: private     static      
Comment:/**
 * Validates whether a particular format is supported by HardwareBuffer.
 *
 * @param format The format to validate.
 *
 * @return True if <code>format</code> is a supported format. false otherwise.
 * See {@link #create(int, int, int, int, long)}.
 */

Body of Frist Method:
{
    switch(format) {
        case RGBA_8888:
        case RGBA_FP16:
        case RGBA_1010102:
        case RGBX_8888:
        case RGB_565:
        case RGB_888:
        case BLOB:
            return true;
    }
    return false;
}
Body of Second Method:
{
    switch(format) {
        case RGBA_8888:
        case RGBA_FP16:
        case RGBA_1010102:
        case RGBX_8888:
        case RGB_565:
        case RGB_888:
        case BLOB:
        case D_16:
        case D_24:
        case DS_24UI8:
        case D_FP32:
        case DS_FP32UI8:
        case S_UI8:
            return true;
    }
    return false;
}
------------------------
Find a silently evolved API code:android.graphics.drawable.Icon.scaleDownIfNecessary:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Scale down a bitmap to a given max width and max height. The scaling will be done in a uniform way
 * @param bitmap the bitmap to scale down
 * @param maxWidth the maximum width allowed
 * @param maxHeight the maximum height allowed
 *
 * @return the scaled bitmap if necessary or the original bitmap if no scaling was needed
 * @hide
 */

Body of Frist Method:
{
    int bitmapWidth = bitmap.getWidth();
    int bitmapHeight = bitmap.getHeight();
    if (bitmapWidth > maxWidth || bitmapHeight > maxHeight) {
        float scale = Math.min((float) maxWidth / bitmapWidth, (float) maxHeight / bitmapHeight);
        bitmap = Bitmap.createScaledBitmap(bitmap, (int) (scale * bitmapWidth), (int) (scale * bitmapHeight), true);
    }
    return bitmap;
}
Body of Second Method:
{
    int bitmapWidth = bitmap.getWidth();
    int bitmapHeight = bitmap.getHeight();
    if (bitmapWidth > maxWidth || bitmapHeight > maxHeight) {
        float scale = Math.min((float) maxWidth / bitmapWidth, (float) maxHeight / bitmapHeight);
        bitmap = Bitmap.createScaledBitmap(bitmap, Math.max(1, (int) (scale * bitmapWidth)), Math.max(1, (int) (scale * bitmapHeight)), true);
    }
    return bitmap;
}
------------------------
Find a silently evolved API code:android.media.PlayerBase.baseRelease:COMMENT
Method Modifier: default     hidden      
Comment:/**
 * To be called from a subclass release or finalize method.
 * Releases AppOps related resources.
 */

Body of Frist Method:
{
    if (DEBUG) {
        Log.v(TAG, "baseRelease() piid=" + mPlayerIId + " state=" + mState);
    }
    try {
        synchronized (mLock) {
            if (mState != AudioPlaybackConfiguration.PLAYER_STATE_RELEASED) {
                getService().releasePlayer(mPlayerIId);
                mState = AudioPlaybackConfiguration.PLAYER_STATE_RELEASED;
            }
        }
    } catch (RemoteException e) {
        Log.e(TAG, "Error talking to audio service, the player will still be tracked", e);
    }
    try {
        if (mAppOps != null) {
            mAppOps.stopWatchingMode(mAppOpsCallback);
        }
    } catch (Exception e) {
    // nothing to do here, the object is supposed to be released anyway
    }
}
Body of Second Method:
{
    if (DEBUG) {
        Log.v(TAG, "baseRelease() piid=" + mPlayerIId + " state=" + mState);
    }
    boolean releasePlayer = false;
    synchronized (mLock) {
        if (mState != AudioPlaybackConfiguration.PLAYER_STATE_RELEASED) {
            releasePlayer = true;
            mState = AudioPlaybackConfiguration.PLAYER_STATE_RELEASED;
        }
    }
    try {
        if (releasePlayer) {
            getService().releasePlayer(mPlayerIId);
        }
    } catch (RemoteException e) {
        Log.e(TAG, "Error talking to audio service, the player will still be tracked", e);
    }
    try {
        if (mAppOps != null) {
            mAppOps.stopWatchingMode(mAppOpsCallback);
        }
    } catch (Exception e) {
    // nothing to do here, the object is supposed to be released anyway
    }
}
------------------------
Find a silently evolved API code:android.view.Surface.getNextFrameNumber:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns the next frame number which will be dequeued for rendering.
 * Intended for use with SurfaceFlinger's deferred transactions API.
 *
 * @hide
 */

Body of Frist Method:
{
    synchronized (mLock) {
        return nativeGetNextFrameNumber(mNativeObject);
    }
}
Body of Second Method:
{
    synchronized (mLock) {
        checkNotReleasedLocked();
        return nativeGetNextFrameNumber(mNativeObject);
    }
}
------------------------
Find a silently evolved API code:android.view.accessibility.AccessibilityWindowInfo.isInPictureInPictureMode:COMMENT
Method Modifier: public      
Comment:/**
 * Check if the window is in picture-in-picture mode.
 *
 * @return {@code true} if the window is in picture-in-picture mode, {@code false} otherwise.
 */

Body of Frist Method:
{
    return mInPictureInPicture;
}
Body of Second Method:
{
    return getBooleanProperty(BOOLEAN_PROPERTY_PICTURE_IN_PICTURE);
}
------------------------
Find a silently evolved API code:android.media.session.MediaController.TransportControls.skipToNext:COMMENT
Method Modifier: public      
Comment:/**
 * Skip to the next item.
 */

Body of Frist Method:
{
    try {
        mSessionBinder.next();
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling next.", e);
    }
}
Body of Second Method:
{
    try {
        mSessionBinder.next(mContext.getPackageName(), mCbStub);
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling next.", e);
    }
}
------------------------
Find a silently evolved API code:android.hardware.camera2.CaptureRequest.Builder.isEmpty:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return mRequest.mSettings.isEmpty();
}
Body of Second Method:
{
    return mRequest.mLogicalCameraSettings.isEmpty();
}
------------------------
Find a silently evolved API code:android.net.TrafficStats.getTxPackets:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * {@hide}
 */

Body of Frist Method:
{
    return nativeGetIfaceStat(iface, TYPE_TX_PACKETS);
}
Body of Second Method:
{
    try {
        return getStatsService().getIfaceStats(iface, TYPE_TX_PACKETS);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.content.ContentResolver.getMasterSyncAutomatically:COMMENT
Method Modifier: public      static      
Comment:/**
 * Gets the master auto-sync setting that applies to all the providers and accounts.
 * If this is false then the per-provider auto-sync setting is ignored.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#READ_SYNC_SETTINGS}.
 *
 * @return the master auto-sync setting that applies to all the providers and accounts
 */

Body of Frist Method:
{
    try {
        return getContentService().getMasterSyncAutomatically();
    } catch (RemoteException e) {
        throw new RuntimeException("the ContentService should always be reachable", e);
    }
}
Body of Second Method:
{
    try {
        return getContentService().getMasterSyncAutomatically();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.net.NetworkRequest.Builder.setCapabilities:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Set the {@code NetworkCapabilities} for this builder instance,
 * overriding any capabilities that had been previously set.
 *
 * @param nc The superseding {@code NetworkCapabilities} instance.
 * @return The builder to facilitate chaining.
 * @hide
 */

Body of Frist Method:
{
    mNetworkCapabilities.clearAll();
    mNetworkCapabilities.combineCapabilities(nc);
    return this;
}
Body of Second Method:
{
    mNetworkCapabilities.set(nc);
    return this;
}
------------------------
Find a silently evolved API code:android.bluetooth.le.AdvertisingSetParameters.isAnonymous:COMMENT
Method Modifier: public      
Comment:/**
 * Returns whether the advertisement will be anonymous.
 */

Body of Frist Method:
{
    return isAnonymous;
}
Body of Second Method:
{
    return mIsAnonymous;
}
------------------------
Find a silently evolved API code:android.nfc.cardemulation.CardEmulation.isDefaultServiceForCategory:COMMENT
Method Modifier: public      
Comment:/**
 * Allows an application to query whether a service is currently
 * the default service to handle a card emulation category.
 *
 * <p>Note that if {@link #getSelectionModeForCategory(String)}
 * returns {@link #SELECTION_MODE_ALWAYS_ASK} or {@link #SELECTION_MODE_ASK_IF_CONFLICT},
 * this method will always return false. That is because in these
 * selection modes a default can't be set at the category level. For categories where
 * the selection mode is {@link #SELECTION_MODE_ALWAYS_ASK} or
 * {@link #SELECTION_MODE_ASK_IF_CONFLICT}, use
 * {@link #isDefaultServiceForAid(ComponentName, String)} to determine whether a service
 * is the default for a specific AID.
 *
 * @param service The ComponentName of the service
 * @param category The category
 * @return whether service is currently the default service for the category.
 *
 * <p class="note">Requires the {@link android.Manifest.permission#NFC} permission.
 */

Body of Frist Method:
{
    try {
        return sService.isDefaultServiceForCategory(UserHandle.myUserId(), service, category);
    } catch (RemoteException e) {
        // Try one more time
        recoverService();
        if (sService == null) {
            Log.e(TAG, "Failed to recover CardEmulationService.");
            return false;
        }
        try {
            return sService.isDefaultServiceForCategory(UserHandle.myUserId(), service, category);
        } catch (RemoteException ee) {
            Log.e(TAG, "Failed to recover CardEmulationService.");
            return false;
        }
    }
}
Body of Second Method:
{
    try {
        return sService.isDefaultServiceForCategory(mContext.getUserId(), service, category);
    } catch (RemoteException e) {
        // Try one more time
        recoverService();
        if (sService == null) {
            Log.e(TAG, "Failed to recover CardEmulationService.");
            return false;
        }
        try {
            return sService.isDefaultServiceForCategory(mContext.getUserId(), service, category);
        } catch (RemoteException ee) {
            Log.e(TAG, "Failed to recover CardEmulationService.");
            return false;
        }
    }
}
------------------------
Find a silently evolved API code:android.net.TrafficStats.getMobileTxPackets:COMMENT
Method Modifier: public      static      
Comment:/**
 * Return number of packets transmitted across mobile networks since device
 * boot. Counts packets across all mobile network interfaces, and always
 * increases monotonically since device boot. Statistics are measured at the
 * network layer, so they include both TCP and UDP usage.
 * <p>
 * Before {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}, this may
 * return {@link #UNSUPPORTED} on devices where statistics aren't available.
 */

Body of Frist Method:
{
    long total = 0;
    for (String iface : getMobileIfaces()) {
        total += getTxPackets(iface);
    }
    return total;
}
Body of Second Method:
{
    long total = 0;
    for (String iface : getMobileIfaces()) {
        total += addIfSupported(getTxPackets(iface));
    }
    return total;
}
------------------------
Find a silently evolved API code:android.net.IpSecConfig.getMode:COMMENT
Method Modifier: public      hidden      
Comment:// Transport or Tunnel

Body of Frist Method:
{
    return mode;
}
Body of Second Method:
{
    return mMode;
}
------------------------
Find a silently evolved API code:android.widget.ProgressBar.onInitializeAccessibilityNodeInfoInternal:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    super.onInitializeAccessibilityNodeInfoInternal(info);
    if (!isIndeterminate()) {
        AccessibilityNodeInfo.RangeInfo rangeInfo = AccessibilityNodeInfo.RangeInfo.obtain(AccessibilityNodeInfo.RangeInfo.RANGE_TYPE_INT, 0, getMax(), getProgress());
        info.setRangeInfo(rangeInfo);
    }
}
Body of Second Method:
{
    super.onInitializeAccessibilityNodeInfoInternal(info);
    if (!isIndeterminate()) {
        AccessibilityNodeInfo.RangeInfo rangeInfo = AccessibilityNodeInfo.RangeInfo.obtain(AccessibilityNodeInfo.RangeInfo.RANGE_TYPE_INT, getMin(), getMax(), getProgress());
        info.setRangeInfo(rangeInfo);
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothAdapter.closeProfileProxy:COMMENT
Method Modifier: public      
Comment:/**
 * Close the connection of the profile proxy to the Service.
 *
 * <p> Clients should call this when they are no longer using
 * the proxy obtained from {@link #getProfileProxy}.
 * Profile can be one of  {@link BluetoothProfile#HEALTH}, {@link BluetoothProfile#HEADSET} or
 * {@link BluetoothProfile#A2DP}
 *
 * @param profile
 * @param proxy Profile proxy object
 */

Body of Frist Method:
{
    if (proxy == null)
        return;
    switch(profile) {
        case BluetoothProfile.HEADSET:
            BluetoothHeadset headset = (BluetoothHeadset) proxy;
            headset.close();
            break;
        case BluetoothProfile.A2DP:
            BluetoothA2dp a2dp = (BluetoothA2dp) proxy;
            a2dp.close();
            break;
        case BluetoothProfile.A2DP_SINK:
            BluetoothA2dpSink a2dpSink = (BluetoothA2dpSink) proxy;
            a2dpSink.close();
            break;
        case BluetoothProfile.AVRCP_CONTROLLER:
            BluetoothAvrcpController avrcp = (BluetoothAvrcpController) proxy;
            avrcp.close();
            break;
        case BluetoothProfile.INPUT_DEVICE:
            BluetoothInputDevice iDev = (BluetoothInputDevice) proxy;
            iDev.close();
            break;
        case BluetoothProfile.PAN:
            BluetoothPan pan = (BluetoothPan) proxy;
            pan.close();
            break;
        case BluetoothProfile.HEALTH:
            BluetoothHealth health = (BluetoothHealth) proxy;
            health.close();
            break;
        case BluetoothProfile.GATT:
            BluetoothGatt gatt = (BluetoothGatt) proxy;
            gatt.close();
            break;
        case BluetoothProfile.GATT_SERVER:
            BluetoothGattServer gattServer = (BluetoothGattServer) proxy;
            gattServer.close();
            break;
        case BluetoothProfile.MAP:
            BluetoothMap map = (BluetoothMap) proxy;
            map.close();
            break;
        case BluetoothProfile.HEADSET_CLIENT:
            BluetoothHeadsetClient headsetClient = (BluetoothHeadsetClient) proxy;
            headsetClient.close();
            break;
        case BluetoothProfile.SAP:
            BluetoothSap sap = (BluetoothSap) proxy;
            sap.close();
            break;
        case BluetoothProfile.PBAP_CLIENT:
            BluetoothPbapClient pbapClient = (BluetoothPbapClient) proxy;
            pbapClient.close();
            break;
        case BluetoothProfile.MAP_CLIENT:
            BluetoothMapClient mapClient = (BluetoothMapClient) proxy;
            mapClient.close();
            break;
        case BluetoothProfile.INPUT_HOST:
            BluetoothInputHost iHost = (BluetoothInputHost) proxy;
            iHost.close();
            break;
    }
}
Body of Second Method:
{
    if (proxy == null) {
        return;
    }
    switch(profile) {
        case BluetoothProfile.HEADSET:
            BluetoothHeadset headset = (BluetoothHeadset) proxy;
            headset.close();
            break;
        case BluetoothProfile.A2DP:
            BluetoothA2dp a2dp = (BluetoothA2dp) proxy;
            a2dp.close();
            break;
        case BluetoothProfile.A2DP_SINK:
            BluetoothA2dpSink a2dpSink = (BluetoothA2dpSink) proxy;
            a2dpSink.close();
            break;
        case BluetoothProfile.AVRCP_CONTROLLER:
            BluetoothAvrcpController avrcp = (BluetoothAvrcpController) proxy;
            avrcp.close();
            break;
        case BluetoothProfile.HID_HOST:
            BluetoothHidHost iDev = (BluetoothHidHost) proxy;
            iDev.close();
            break;
        case BluetoothProfile.PAN:
            BluetoothPan pan = (BluetoothPan) proxy;
            pan.close();
            break;
        case BluetoothProfile.HEALTH:
            BluetoothHealth health = (BluetoothHealth) proxy;
            health.close();
            break;
        case BluetoothProfile.GATT:
            BluetoothGatt gatt = (BluetoothGatt) proxy;
            gatt.close();
            break;
        case BluetoothProfile.GATT_SERVER:
            BluetoothGattServer gattServer = (BluetoothGattServer) proxy;
            gattServer.close();
            break;
        case BluetoothProfile.MAP:
            BluetoothMap map = (BluetoothMap) proxy;
            map.close();
            break;
        case BluetoothProfile.HEADSET_CLIENT:
            BluetoothHeadsetClient headsetClient = (BluetoothHeadsetClient) proxy;
            headsetClient.close();
            break;
        case BluetoothProfile.SAP:
            BluetoothSap sap = (BluetoothSap) proxy;
            sap.close();
            break;
        case BluetoothProfile.PBAP_CLIENT:
            BluetoothPbapClient pbapClient = (BluetoothPbapClient) proxy;
            pbapClient.close();
            break;
        case BluetoothProfile.MAP_CLIENT:
            BluetoothMapClient mapClient = (BluetoothMapClient) proxy;
            mapClient.close();
            break;
        case BluetoothProfile.HID_DEVICE:
            BluetoothHidDevice hidDevice = (BluetoothHidDevice) proxy;
            hidDevice.close();
            break;
        case BluetoothProfile.HEARING_AID:
            BluetoothHearingAid hearingAid = (BluetoothHearingAid) proxy;
            hearingAid.close();
    }
}
------------------------
Find a silently evolved API code:android.view.WindowInsets.isConsumed:COMMENT
Method Modifier: public      
Comment:/**
 * Check if these insets have been fully consumed.
 *
 * <p>Insets are considered "consumed" if the applicable <code>consume*</code> methods
 * have been called such that all insets have been set to zero. This affects propagation of
 * insets through the view hierarchy; insets that have not been fully consumed will continue
 * to propagate down to child views.</p>
 *
 * <p>The result of this method is equivalent to the return value of
 * {@link View#fitSystemWindows(android.graphics.Rect)}.</p>
 *
 * @return true if the insets have been fully consumed.
 */

Body of Frist Method:
{
    return mSystemWindowInsetsConsumed && mWindowDecorInsetsConsumed && mStableInsetsConsumed;
}
Body of Second Method:
{
    return mSystemWindowInsetsConsumed && mWindowDecorInsetsConsumed && mStableInsetsConsumed && mDisplayCutoutConsumed;
}
------------------------
Find a silently evolved API code:android.net.wifi.RttManager.ParcelableRttResults.writeToParcel:COMMENT
<android.net.wifi.RttManager.ParcelableRttResults: void writeToParcel(Parcel,int)>
public      hidden      ->public      hidden      deprecated  
Method Modifier: public      hidden      deprecated  
Method Modifier: Yes         Yes         No          
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * Implement the Parcelable interface {@hide}
 */

Body of Frist Method:
{
    if (mResults != null) {
        dest.writeInt(mResults.length);
        for (RttResult result : mResults) {
            dest.writeString(result.bssid);
            dest.writeInt(result.burstNumber);
            dest.writeInt(result.measurementFrameNumber);
            dest.writeInt(result.successMeasurementFrameNumber);
            dest.writeInt(result.frameNumberPerBurstPeer);
            dest.writeInt(result.status);
            dest.writeInt(result.measurementType);
            dest.writeInt(result.retryAfterDuration);
            dest.writeLong(result.ts);
            dest.writeInt(result.rssi);
            dest.writeInt(result.rssiSpread);
            dest.writeInt(result.txRate);
            dest.writeLong(result.rtt);
            dest.writeLong(result.rttStandardDeviation);
            dest.writeLong(result.rttSpread);
            dest.writeInt(result.distance);
            dest.writeInt(result.distanceStandardDeviation);
            dest.writeInt(result.distanceSpread);
            dest.writeInt(result.burstDuration);
            dest.writeInt(result.negotiatedBurstNum);
            dest.writeByte(result.LCI.id);
            if (result.LCI.id != (byte) 0xFF) {
                dest.writeByte((byte) result.LCI.data.length);
                dest.writeByteArray(result.LCI.data);
            }
            dest.writeByte(result.LCR.id);
            if (result.LCR.id != (byte) 0xFF) {
                dest.writeInt((byte) result.LCR.data.length);
                dest.writeByte(result.LCR.id);
            }
            dest.writeByte(result.secure ? (byte) 1 : 0);
        }
    } else {
        dest.writeInt(0);
    }
}
Body of Second Method:
{
    if (mResults != null) {
        dest.writeInt(mResults.length);
        for (RttResult result : mResults) {
            dest.writeString(result.bssid);
            dest.writeInt(result.burstNumber);
            dest.writeInt(result.measurementFrameNumber);
            dest.writeInt(result.successMeasurementFrameNumber);
            dest.writeInt(result.frameNumberPerBurstPeer);
            dest.writeInt(result.status);
            dest.writeInt(result.measurementType);
            dest.writeInt(result.retryAfterDuration);
            dest.writeLong(result.ts);
            dest.writeInt(result.rssi);
            dest.writeInt(result.rssiSpread);
            dest.writeInt(result.txRate);
            dest.writeLong(result.rtt);
            dest.writeLong(result.rttStandardDeviation);
            dest.writeLong(result.rttSpread);
            dest.writeInt(result.distance);
            dest.writeInt(result.distanceStandardDeviation);
            dest.writeInt(result.distanceSpread);
            dest.writeInt(result.burstDuration);
            dest.writeInt(result.negotiatedBurstNum);
            dest.writeByte(result.LCI.id);
            if (result.LCI.id != (byte) 0xFF) {
                dest.writeByte((byte) result.LCI.data.length);
                dest.writeByteArray(result.LCI.data);
            }
            dest.writeByte(result.LCR.id);
            if (result.LCR.id != (byte) 0xFF) {
                dest.writeByte((byte) result.LCR.data.length);
                dest.writeByteArray(result.LCR.data);
            }
            dest.writeByte(result.secure ? (byte) 1 : 0);
        }
    } else {
        dest.writeInt(0);
    }
}
------------------------
Find a silently evolved API code:android.content.ContentResolver.getOutgoingPersistedUriPermissions:COMMENT
Method Modifier: public      
Comment:/**
 * Return list of all persisted URI permission grants that are hosted by the
 * calling app. That is, the returned permissions have been granted
 * <em>from</em> the calling app. Only grants taken with
 * {@link #takePersistableUriPermission(Uri, int)} are returned.
 * <p>Note: Some of the returned URIs may not be usable until after the user is unlocked.
 */

Body of Frist Method:
{
    try {
        return ActivityManager.getService().getPersistedUriPermissions(mPackageName, false).getList();
    } catch (RemoteException e) {
        throw new RuntimeException("Activity manager has died", e);
    }
}
Body of Second Method:
{
    try {
        return ActivityManager.getService().getPersistedUriPermissions(mPackageName, false).getList();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.transition.TransitionUtils.createViewBitmap:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Creates a Bitmap of the given view, using the Matrix matrix to transform to the local
 * coordinates. <code>matrix</code> will be modified during the bitmap creation.
 *
 * <p>If the bitmap is large, it will be scaled uniformly down to at most 1MB size.</p>
 * @param view The view to create a bitmap for.
 * @param matrix The matrix converting the view local coordinates to the coordinates that
 * the bitmap will be displayed in. <code>matrix</code> will be modified before
 * returning.
 * @param bounds The bounds of the bitmap in the destination coordinate system (where the
 * view should be presented. Typically, this is matrix.mapRect(viewBounds);
 * @param sceneRoot A ViewGroup that is attached to the window to temporarily contain the view
 * if it isn't attached to the window.
 * @return A bitmap of the given view or null if bounds has no width or height.
 */

Body of Frist Method:
{
    final boolean addToOverlay = !view.isAttachedToWindow();
    if (addToOverlay) {
        if (sceneRoot == null || !sceneRoot.isAttachedToWindow()) {
            return null;
        }
        sceneRoot.getOverlay().add(view);
    }
    Bitmap bitmap = null;
    int bitmapWidth = Math.round(bounds.width());
    int bitmapHeight = Math.round(bounds.height());
    if (bitmapWidth > 0 && bitmapHeight > 0) {
        float scale = Math.min(1f, ((float) MAX_IMAGE_SIZE) / (bitmapWidth * bitmapHeight));
        bitmapWidth *= scale;
        bitmapHeight *= scale;
        matrix.postTranslate(-bounds.left, -bounds.top);
        matrix.postScale(scale, scale);
        final RenderNode node = RenderNode.create("TransitionUtils", view);
        node.setLeftTopRightBottom(0, 0, bitmapWidth, bitmapHeight);
        node.setClipToBounds(false);
        final DisplayListCanvas canvas = node.start(bitmapWidth, bitmapHeight);
        canvas.concat(matrix);
        view.draw(canvas);
        node.end(canvas);
        bitmap = ThreadedRenderer.createHardwareBitmap(node, bitmapWidth, bitmapHeight);
    }
    if (addToOverlay) {
        sceneRoot.getOverlay().remove(view);
    }
    return bitmap;
}
Body of Second Method:
{
    final boolean addToOverlay = !view.isAttachedToWindow();
    ViewGroup parent = null;
    int indexInParent = 0;
    if (addToOverlay) {
        if (sceneRoot == null || !sceneRoot.isAttachedToWindow()) {
            return null;
        }
        parent = (ViewGroup) view.getParent();
        indexInParent = parent.indexOfChild(view);
        sceneRoot.getOverlay().add(view);
    }
    Bitmap bitmap = null;
    int bitmapWidth = Math.round(bounds.width());
    int bitmapHeight = Math.round(bounds.height());
    if (bitmapWidth > 0 && bitmapHeight > 0) {
        float scale = Math.min(1f, ((float) MAX_IMAGE_SIZE) / (bitmapWidth * bitmapHeight));
        bitmapWidth *= scale;
        bitmapHeight *= scale;
        matrix.postTranslate(-bounds.left, -bounds.top);
        matrix.postScale(scale, scale);
        final Picture picture = new Picture();
        final Canvas canvas = picture.beginRecording(bitmapWidth, bitmapHeight);
        canvas.concat(matrix);
        view.draw(canvas);
        picture.endRecording();
        bitmap = Bitmap.createBitmap(picture);
    }
    if (addToOverlay) {
        sceneRoot.getOverlay().remove(view);
        parent.addView(view, indexInParent);
    }
    return bitmap;
}
------------------------
Find a silently evolved API code:android.database.DatabaseUtils.getSqlStatementType:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns one of the following which represent the type of the given SQL statement.
 * <ol>
 * <li>{@link #STATEMENT_SELECT}</li>
 * <li>{@link #STATEMENT_UPDATE}</li>
 * <li>{@link #STATEMENT_ATTACH}</li>
 * <li>{@link #STATEMENT_BEGIN}</li>
 * <li>{@link #STATEMENT_COMMIT}</li>
 * <li>{@link #STATEMENT_ABORT}</li>
 * <li>{@link #STATEMENT_OTHER}</li>
 * </ol>
 * @param sql the SQL statement whose type is returned by this method
 * @return one of the values listed above
 */

Body of Frist Method:
{
    sql = sql.trim();
    if (sql.length() < 3) {
        return STATEMENT_OTHER;
    }
    String prefixSql = sql.substring(0, 3).toUpperCase(Locale.ROOT);
    if (prefixSql.equals("SEL")) {
        return STATEMENT_SELECT;
    } else if (prefixSql.equals("INS") || prefixSql.equals("UPD") || prefixSql.equals("REP") || prefixSql.equals("DEL")) {
        return STATEMENT_UPDATE;
    } else if (prefixSql.equals("ATT")) {
        return STATEMENT_ATTACH;
    } else if (prefixSql.equals("COM")) {
        return STATEMENT_COMMIT;
    } else if (prefixSql.equals("END")) {
        return STATEMENT_COMMIT;
    } else if (prefixSql.equals("ROL")) {
        return STATEMENT_ABORT;
    } else if (prefixSql.equals("BEG")) {
        return STATEMENT_BEGIN;
    } else if (prefixSql.equals("PRA")) {
        return STATEMENT_PRAGMA;
    } else if (prefixSql.equals("CRE") || prefixSql.equals("DRO") || prefixSql.equals("ALT")) {
        return STATEMENT_DDL;
    } else if (prefixSql.equals("ANA") || prefixSql.equals("DET")) {
        return STATEMENT_UNPREPARED;
    }
    return STATEMENT_OTHER;
}
Body of Second Method:
{
    sql = sql.trim();
    if (sql.length() < 3) {
        return STATEMENT_OTHER;
    }
    String prefixSql = sql.substring(0, 3).toUpperCase(Locale.ROOT);
    if (prefixSql.equals("SEL")) {
        return STATEMENT_SELECT;
    } else if (prefixSql.equals("INS") || prefixSql.equals("UPD") || prefixSql.equals("REP") || prefixSql.equals("DEL")) {
        return STATEMENT_UPDATE;
    } else if (prefixSql.equals("ATT")) {
        return STATEMENT_ATTACH;
    } else if (prefixSql.equals("COM")) {
        return STATEMENT_COMMIT;
    } else if (prefixSql.equals("END")) {
        return STATEMENT_COMMIT;
    } else if (prefixSql.equals("ROL")) {
        boolean isRollbackToSavepoint = sql.toUpperCase(Locale.ROOT).contains(" TO ");
        if (isRollbackToSavepoint) {
            Log.w(TAG, "Statement '" + sql + "' may not work on API levels 16-27, use ';" + sql + "' instead");
            return STATEMENT_OTHER;
        }
        return STATEMENT_ABORT;
    } else if (prefixSql.equals("BEG")) {
        return STATEMENT_BEGIN;
    } else if (prefixSql.equals("PRA")) {
        return STATEMENT_PRAGMA;
    } else if (prefixSql.equals("CRE") || prefixSql.equals("DRO") || prefixSql.equals("ALT")) {
        return STATEMENT_DDL;
    } else if (prefixSql.equals("ANA") || prefixSql.equals("DET")) {
        return STATEMENT_UNPREPARED;
    }
    return STATEMENT_OTHER;
}
------------------------
Find a silently evolved API code:android.telecom.PhoneAccount.capabilitiesToString:COMMENT
Method Modifier: private     
Comment:/**
 * Generates a string representation of a capabilities bitmask.
 *
 * @param capabilities The capabilities bitmask.
 * @return String representation of the capabilities bitmask.
 */

Body of Frist Method:
{
    StringBuilder sb = new StringBuilder();
    if (hasCapabilities(CAPABILITY_SELF_MANAGED)) {
        sb.append("SelfManaged ");
    }
    if (hasCapabilities(CAPABILITY_SUPPORTS_VIDEO_CALLING)) {
        sb.append("SuppVideo ");
    }
    if (hasCapabilities(CAPABILITY_VIDEO_CALLING)) {
        sb.append("Video ");
    }
    if (hasCapabilities(CAPABILITY_VIDEO_CALLING_RELIES_ON_PRESENCE)) {
        sb.append("Presence ");
    }
    if (hasCapabilities(CAPABILITY_CALL_PROVIDER)) {
        sb.append("CallProvider ");
    }
    if (hasCapabilities(CAPABILITY_CALL_SUBJECT)) {
        sb.append("CallSubject ");
    }
    if (hasCapabilities(CAPABILITY_CONNECTION_MANAGER)) {
        sb.append("ConnectionMgr ");
    }
    if (hasCapabilities(CAPABILITY_EMERGENCY_CALLS_ONLY)) {
        sb.append("EmergOnly ");
    }
    if (hasCapabilities(CAPABILITY_MULTI_USER)) {
        sb.append("MultiUser ");
    }
    if (hasCapabilities(CAPABILITY_PLACE_EMERGENCY_CALLS)) {
        sb.append("PlaceEmerg ");
    }
    if (hasCapabilities(CAPABILITY_EMERGENCY_VIDEO_CALLING)) {
        sb.append("EmergVideo ");
    }
    if (hasCapabilities(CAPABILITY_SIM_SUBSCRIPTION)) {
        sb.append("SimSub ");
    }
    return sb.toString();
}
Body of Second Method:
{
    StringBuilder sb = new StringBuilder();
    if (hasCapabilities(CAPABILITY_SELF_MANAGED)) {
        sb.append("SelfManaged ");
    }
    if (hasCapabilities(CAPABILITY_SUPPORTS_VIDEO_CALLING)) {
        sb.append("SuppVideo ");
    }
    if (hasCapabilities(CAPABILITY_VIDEO_CALLING)) {
        sb.append("Video ");
    }
    if (hasCapabilities(CAPABILITY_VIDEO_CALLING_RELIES_ON_PRESENCE)) {
        sb.append("Presence ");
    }
    if (hasCapabilities(CAPABILITY_CALL_PROVIDER)) {
        sb.append("CallProvider ");
    }
    if (hasCapabilities(CAPABILITY_CALL_SUBJECT)) {
        sb.append("CallSubject ");
    }
    if (hasCapabilities(CAPABILITY_CONNECTION_MANAGER)) {
        sb.append("ConnectionMgr ");
    }
    if (hasCapabilities(CAPABILITY_EMERGENCY_CALLS_ONLY)) {
        sb.append("EmergOnly ");
    }
    if (hasCapabilities(CAPABILITY_MULTI_USER)) {
        sb.append("MultiUser ");
    }
    if (hasCapabilities(CAPABILITY_PLACE_EMERGENCY_CALLS)) {
        sb.append("PlaceEmerg ");
    }
    if (hasCapabilities(CAPABILITY_EMERGENCY_VIDEO_CALLING)) {
        sb.append("EmergVideo ");
    }
    if (hasCapabilities(CAPABILITY_SIM_SUBSCRIPTION)) {
        sb.append("SimSub ");
    }
    if (hasCapabilities(CAPABILITY_RTT)) {
        sb.append("Rtt");
    }
    return sb.toString();
}
------------------------
Find a silently evolved API code:android.view.TextureView.draw:COMMENT
Method Modifier: public      final       
Comment:/**
 * Subclasses of TextureView cannot do their own rendering
 * with the {@link Canvas} object.
 *
 * @param canvas The Canvas to which the View is rendered.
 */

Body of Frist Method:
{
    // NOTE: Maintain this carefully (see View#draw)
    mPrivateFlags = (mPrivateFlags & ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;
    if (canvas.isHardwareAccelerated()) {
        DisplayListCanvas displayListCanvas = (DisplayListCanvas) canvas;
        HardwareLayer layer = getHardwareLayer();
        if (layer != null) {
            applyUpdate();
            applyTransformMatrix();
            // ensure layer paint is up to date
            mLayer.setLayerPaint(mLayerPaint);
            displayListCanvas.drawHardwareLayer(layer);
        }
    }
}
Body of Second Method:
{
    // NOTE: Maintain this carefully (see View#draw)
    mPrivateFlags = (mPrivateFlags & ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;
    if (canvas.isHardwareAccelerated()) {
        DisplayListCanvas displayListCanvas = (DisplayListCanvas) canvas;
        TextureLayer layer = getTextureLayer();
        if (layer != null) {
            applyUpdate();
            applyTransformMatrix();
            // ensure layer paint is up to date
            mLayer.setLayerPaint(mLayerPaint);
            displayListCanvas.drawTextureLayer(layer);
        }
    }
}
------------------------
Find a silently evolved API code:android.app.admin.NetworkEvent.getTimestamp:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the timestamp of the event being reported in milliseconds, the difference between
 * the time the event was reported and midnight, January 1, 1970 UTC.
 */

Body of Frist Method:
{
    return timestamp;
}
Body of Second Method:
{
    return mTimestamp;
}
------------------------
Find a silently evolved API code:android.bluetooth.le.AdvertisingSet.setPeriodicAdvertisingParameters:COMMENT
Method Modifier: public      
Comment:/**
 * Update periodic advertising parameters associated with this set. Must be called when
 * periodic advertising is not enabled. This method returns immediately, the operation
 * status is delivered through {@code callback.onPeriodicAdvertisingParametersUpdated()}.
 */

Body of Frist Method:
{
    try {
        gatt.setPeriodicAdvertisingParameters(this.advertiserId, parameters);
    } catch (RemoteException e) {
        Log.e(TAG, "remote exception - ", e);
    }
}
Body of Second Method:
{
    try {
        mGatt.setPeriodicAdvertisingParameters(mAdvertiserId, parameters);
    } catch (RemoteException e) {
        Log.e(TAG, "remote exception - ", e);
    }
}
------------------------
Find a silently evolved API code:android.content.res.TypedArray.getResourceId:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieves the resource identifier for the attribute at
 * <var>index</var>.  Note that attribute resource as resolved when
 * the overall {@link TypedArray} object is retrieved.  As a
 * result, this function will return the resource identifier of the
 * final resource value that was found, <em>not</em> necessarily the
 * original resource that was specified by the attribute.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute resource identifier, or defValue if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 */

Body of Frist Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    if (data[index + AssetManager.STYLE_TYPE] != TypedValue.TYPE_NULL) {
        final int resid = data[index + AssetManager.STYLE_RESOURCE_ID];
        if (resid != 0) {
            return resid;
        }
    }
    return defValue;
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    index *= STYLE_NUM_ENTRIES;
    final int[] data = mData;
    if (data[index + STYLE_TYPE] != TypedValue.TYPE_NULL) {
        final int resid = data[index + STYLE_RESOURCE_ID];
        if (resid != 0) {
            return resid;
        }
    }
    return defValue;
}
------------------------
Find a silently evolved API code:android.bluetooth.le.AdvertisingSetParameters.Builder.setAnonymous:COMMENT
Method Modifier: public      
Comment:/**
 * Set whether advertiser address should be ommited from all packets. If this
 * mode is used, periodic advertising can't be enabled for this set.
 *
 * This is used only if legacy mode is not used.
 *
 * @param isAnonymous whether anonymous advertising should be used.
 */

Body of Frist Method:
{
    this.isAnonymous = isAnonymous;
    return this;
}
Body of Second Method:
{
    mIsAnonymous = isAnonymous;
    return this;
}
------------------------
Find a silently evolved API code:android.media.PlayerBase.baseRegisterPlayer:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * Call from derived class when instantiation / initialization is successful
 */

Body of Frist Method:
{
    int newPiid = AudioPlaybackConfiguration.PLAYER_PIID_INVALID;
    IBinder b = ServiceManager.getService(Context.APP_OPS_SERVICE);
    mAppOps = IAppOpsService.Stub.asInterface(b);
    // initialize mHasAppOpsPlayAudio
    updateAppOpsPlayAudio();
    // register a callback to monitor whether the OP_PLAY_AUDIO is still allowed
    mAppOpsCallback = new IAppOpsCallbackWrapper(this);
    try {
        mAppOps.startWatchingMode(AppOpsManager.OP_PLAY_AUDIO, ActivityThread.currentPackageName(), mAppOpsCallback);
    } catch (RemoteException e) {
        mHasAppOpsPlayAudio = false;
    }
    try {
        newPiid = getService().trackPlayer(new PlayerIdCard(mImplType, mAttributes, new IPlayerWrapper(this)));
    } catch (RemoteException e) {
        Log.e(TAG, "Error talking to audio service, player will not be tracked", e);
    }
    mPlayerIId = newPiid;
}
Body of Second Method:
{
    int newPiid = AudioPlaybackConfiguration.PLAYER_PIID_INVALID;
    IBinder b = ServiceManager.getService(Context.APP_OPS_SERVICE);
    mAppOps = IAppOpsService.Stub.asInterface(b);
    // initialize mHasAppOpsPlayAudio
    updateAppOpsPlayAudio();
    // register a callback to monitor whether the OP_PLAY_AUDIO is still allowed
    mAppOpsCallback = new IAppOpsCallbackWrapper(this);
    try {
        mAppOps.startWatchingMode(AppOpsManager.OP_PLAY_AUDIO, ActivityThread.currentPackageName(), mAppOpsCallback);
    } catch (RemoteException e) {
        Log.e(TAG, "Error registering appOps callback", e);
        mHasAppOpsPlayAudio = false;
    }
    try {
        newPiid = getService().trackPlayer(new PlayerIdCard(mImplType, mAttributes, new IPlayerWrapper(this)));
    } catch (RemoteException e) {
        Log.e(TAG, "Error talking to audio service, player will not be tracked", e);
    }
    mPlayerIId = newPiid;
}
------------------------
Find a silently evolved API code:android.nfc.cardemulation.NfcFCardEmulation.getSystemCodeForService:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieves the current System Code for the specified service.
 *
 * <p>Before calling {@link #registerSystemCodeForService(ComponentName, String)},
 * the System Code contained in the Manifest file is returned. After calling
 * {@link #registerSystemCodeForService(ComponentName, String)}, the System Code
 * registered there is returned. After calling
 * {@link #unregisterSystemCodeForService(ComponentName)}, "null" is returned.
 *
 * @param service The component name of the service
 * @return the current System Code
 */

Body of Frist Method:
{
    if (service == null) {
        throw new NullPointerException("service is null");
    }
    try {
        return sService.getSystemCodeForService(UserHandle.myUserId(), service);
    } catch (RemoteException e) {
        // Try one more time
        recoverService();
        if (sService == null) {
            Log.e(TAG, "Failed to recover CardEmulationService.");
            return null;
        }
        try {
            return sService.getSystemCodeForService(UserHandle.myUserId(), service);
        } catch (RemoteException ee) {
            Log.e(TAG, "Failed to reach CardEmulationService.");
            ee.rethrowAsRuntimeException();
            return null;
        }
    }
}
Body of Second Method:
{
    if (service == null) {
        throw new NullPointerException("service is null");
    }
    try {
        return sService.getSystemCodeForService(mContext.getUserId(), service);
    } catch (RemoteException e) {
        // Try one more time
        recoverService();
        if (sService == null) {
            Log.e(TAG, "Failed to recover CardEmulationService.");
            return null;
        }
        try {
            return sService.getSystemCodeForService(mContext.getUserId(), service);
        } catch (RemoteException ee) {
            Log.e(TAG, "Failed to reach CardEmulationService.");
            ee.rethrowAsRuntimeException();
            return null;
        }
    }
}
------------------------
Find a silently evolved API code:android.content.ContentResolver.getCurrentSyncs:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns a list with information about all the active syncs. This list will be empty
 * if there are no active syncs.
 * <p>
 * This method requires the caller to hold the permission
 * {@link android.Manifest.permission#READ_SYNC_STATS}.
 * <p>
 * @return a List of SyncInfo objects for the currently active syncs.
 */

Body of Frist Method:
{
    try {
        return getContentService().getCurrentSyncs();
    } catch (RemoteException e) {
        throw new RuntimeException("the ContentService should always be reachable", e);
    }
}
Body of Second Method:
{
    try {
        return getContentService().getCurrentSyncs();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.content.res.TypedArray.getColorStateList:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the ColorStateList for the attribute at <var>index</var>.
 * The value may be either a single solid color or a reference to
 * a color or complex {@link android.content.res.ColorStateList}
 * description.
 * <p>
 * This method will return {@code null} if the attribute is not defined or
 * is not an integer color or color state list.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return ColorStateList for the attribute, or {@code null} if not
 * defined.
 * @throws RuntimeException if the attribute if the TypedArray has already
 * been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not an integer color or color state list.
 */

Body of Frist Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    final TypedValue value = mValue;
    if (getValueAt(index * AssetManager.STYLE_NUM_ENTRIES, value)) {
        if (value.type == TypedValue.TYPE_ATTRIBUTE) {
            throw new UnsupportedOperationException("Failed to resolve attribute at index " + index + ": " + value);
        }
        return mResources.loadColorStateList(value, value.resourceId, mTheme);
    }
    return null;
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    final TypedValue value = mValue;
    if (getValueAt(index * STYLE_NUM_ENTRIES, value)) {
        if (value.type == TypedValue.TYPE_ATTRIBUTE) {
            throw new UnsupportedOperationException("Failed to resolve attribute at index " + index + ": " + value);
        }
        return mResources.loadColorStateList(value, value.resourceId, mTheme);
    }
    return null;
}
------------------------
Find a silently evolved API code:android.content.res.TypedArray.getType:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the type of attribute at the specified index.
 *
 * @param index Index of attribute whose type to retrieve.
 *
 * @return Attribute type.
 * @throws RuntimeException if the TypedArray has already been recycled.
 */

Body of Frist Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    return mData[index + AssetManager.STYLE_TYPE];
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    index *= STYLE_NUM_ENTRIES;
    return mData[index + STYLE_TYPE];
}
------------------------
Find a silently evolved API code:android.telephony.CellIdentityGsm.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Implement the Parcelable interface
 */

Body of Frist Method:
{
    if (DBG)
        log("writeToParcel(Parcel, int): " + toString());
    dest.writeInt(mMcc);
    dest.writeInt(mMnc);
    dest.writeInt(mLac);
    dest.writeInt(mCid);
    dest.writeInt(mArfcn);
    dest.writeInt(mBsic);
}
Body of Second Method:
{
    if (DBG)
        log("writeToParcel(Parcel, int): " + toString());
    super.writeToParcel(dest, TYPE_GSM);
    dest.writeInt(mLac);
    dest.writeInt(mCid);
    dest.writeInt(mArfcn);
    dest.writeInt(mBsic);
}
------------------------
Find a silently evolved API code:android.net.NetworkStats.groupedByUid:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Return total statistics grouped by {@link #uid}; doesn't mutate the
 * original structure.
 */

Body of Frist Method:
{
    final NetworkStats stats = new NetworkStats(elapsedRealtime, 10);
    final Entry entry = new Entry();
    entry.iface = IFACE_ALL;
    entry.set = SET_ALL;
    entry.tag = TAG_NONE;
    entry.metered = METERED_ALL;
    entry.roaming = ROAMING_ALL;
    for (int i = 0; i < size; i++) {
        // skip specific tags, since already counted in TAG_NONE
        if (tag[i] != TAG_NONE)
            continue;
        entry.uid = uid[i];
        entry.rxBytes = rxBytes[i];
        entry.rxPackets = rxPackets[i];
        entry.txBytes = txBytes[i];
        entry.txPackets = txPackets[i];
        entry.operations = operations[i];
        stats.combineValues(entry);
    }
    return stats;
}
Body of Second Method:
{
    final NetworkStats stats = new NetworkStats(elapsedRealtime, 10);
    final Entry entry = new Entry();
    entry.iface = IFACE_ALL;
    entry.set = SET_ALL;
    entry.tag = TAG_NONE;
    entry.metered = METERED_ALL;
    entry.roaming = ROAMING_ALL;
    entry.defaultNetwork = DEFAULT_NETWORK_ALL;
    for (int i = 0; i < size; i++) {
        // skip specific tags, since already counted in TAG_NONE
        if (tag[i] != TAG_NONE)
            continue;
        entry.uid = uid[i];
        entry.rxBytes = rxBytes[i];
        entry.rxPackets = rxPackets[i];
        entry.txBytes = txBytes[i];
        entry.txPackets = txPackets[i];
        entry.operations = operations[i];
        stats.combineValues(entry);
    }
    return stats;
}
------------------------
Find a silently evolved API code:android.content.ContentResolver.releasePersistableUriPermission:COMMENT
Method Modifier: public      
Comment:/**
 * Relinquish a persisted URI permission grant. The URI must have been
 * previously made persistent with
 * {@link #takePersistableUriPermission(Uri, int)}. Any non-persistent
 * grants to the calling package will remain intact.
 *
 * @see #getPersistedUriPermissions()
 */

Body of Frist Method:
{
    Preconditions.checkNotNull(uri, "uri");
    try {
        ActivityManager.getService().releasePersistableUriPermission(ContentProvider.getUriWithoutUserId(uri), modeFlags, resolveUserId(uri));
    } catch (RemoteException e) {
    }
}
Body of Second Method:
{
    Preconditions.checkNotNull(uri, "uri");
    try {
        ActivityManager.getService().releasePersistableUriPermission(ContentProvider.getUriWithoutUserId(uri), modeFlags, /* toPackage= */
        null, resolveUserId(uri));
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.media.AudioFormat.toLogFriendlyEncoding:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    switch(enc) {
        case ENCODING_INVALID:
            return "ENCODING_INVALID";
        case ENCODING_PCM_16BIT:
            return "ENCODING_PCM_16BIT";
        case ENCODING_PCM_8BIT:
            return "ENCODING_PCM_8BIT";
        case ENCODING_PCM_FLOAT:
            return "ENCODING_PCM_FLOAT";
        case ENCODING_AC3:
            return "ENCODING_AC3";
        case ENCODING_E_AC3:
            return "ENCODING_E_AC3";
        case ENCODING_DTS:
            return "ENCODING_DTS";
        case ENCODING_DTS_HD:
            return "ENCODING_DTS_HD";
        case ENCODING_MP3:
            return "ENCODING_MP3";
        case ENCODING_AAC_LC:
            return "ENCODING_AAC_LC";
        case ENCODING_AAC_HE_V1:
            return "ENCODING_AAC_HE_V1";
        case ENCODING_AAC_HE_V2:
            return "ENCODING_AAC_HE_V2";
        case ENCODING_IEC61937:
            return "ENCODING_IEC61937";
        case ENCODING_DOLBY_TRUEHD:
            return "ENCODING_DOLBY_TRUEHD";
        default:
            return "invalid encoding " + enc;
    }
}
Body of Second Method:
{
    switch(enc) {
        case ENCODING_INVALID:
            return "ENCODING_INVALID";
        case ENCODING_PCM_16BIT:
            return "ENCODING_PCM_16BIT";
        case ENCODING_PCM_8BIT:
            return "ENCODING_PCM_8BIT";
        case ENCODING_PCM_FLOAT:
            return "ENCODING_PCM_FLOAT";
        case ENCODING_AC3:
            return "ENCODING_AC3";
        case ENCODING_E_AC3:
            return "ENCODING_E_AC3";
        case ENCODING_DTS:
            return "ENCODING_DTS";
        case ENCODING_DTS_HD:
            return "ENCODING_DTS_HD";
        case ENCODING_MP3:
            return "ENCODING_MP3";
        case ENCODING_AAC_LC:
            return "ENCODING_AAC_LC";
        case ENCODING_AAC_HE_V1:
            return "ENCODING_AAC_HE_V1";
        case ENCODING_AAC_HE_V2:
            return "ENCODING_AAC_HE_V2";
        case ENCODING_IEC61937:
            return "ENCODING_IEC61937";
        case ENCODING_DOLBY_TRUEHD:
            return "ENCODING_DOLBY_TRUEHD";
        case ENCODING_AAC_ELD:
            return "ENCODING_AAC_ELD";
        case ENCODING_AAC_XHE:
            return "ENCODING_AAC_XHE";
        case ENCODING_AC4:
            return "ENCODING_AC4";
        default:
            return "invalid encoding " + enc;
    }
}
------------------------
Find a silently evolved API code:android.content.ContentResolver.getSyncAdapterPackagesForAuthorityAsUser:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 * Returns the package names of syncadapters that match a given user and authority.
 */

Body of Frist Method:
{
    try {
        return getContentService().getSyncAdapterPackagesForAuthorityAsUser(authority, userId);
    } catch (RemoteException e) {
    }
    return ArrayUtils.emptyArray(String.class);
}
Body of Second Method:
{
    try {
        return getContentService().getSyncAdapterPackagesForAuthorityAsUser(authority, userId);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.media.session.MediaController.TransportControls.prepareFromUri:COMMENT
Method Modifier: public      
Comment:/**
 * Request that the player prepare playback for a specific {@link Uri}. In other words,
 * other sessions can continue to play during the preparation of this session. This method
 * can be used to speed up the start of the playback. Once the preparation is done, the
 * session will change its playback state to {@link PlaybackState#STATE_PAUSED}. Afterwards,
 * {@link #play} can be called to start playback. If the preparation is not needed,
 * {@link #playFromUri} can be directly called without this method.
 *
 * @param uri The URI of the requested media.
 * @param extras Optional extras that can include extra information about the media item
 * to be prepared.
 */

Body of Frist Method:
{
    if (uri == null || Uri.EMPTY.equals(uri)) {
        throw new IllegalArgumentException("You must specify a non-empty Uri for prepareFromUri.");
    }
    try {
        mSessionBinder.prepareFromUri(uri, extras);
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling prepare(" + uri + ").", e);
    }
}
Body of Second Method:
{
    if (uri == null || Uri.EMPTY.equals(uri)) {
        throw new IllegalArgumentException("You must specify a non-empty Uri for prepareFromUri.");
    }
    try {
        mSessionBinder.prepareFromUri(mContext.getPackageName(), mCbStub, uri, extras);
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling prepare(" + uri + ").", e);
    }
}
------------------------
Find a silently evolved API code:android.content.ContentResolver.setSyncAutomaticallyAsUser:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @see #setSyncAutomatically(Account, String, boolean)
 * @hide
 */

Body of Frist Method:
{
    try {
        getContentService().setSyncAutomaticallyAsUser(account, authority, sync, userId);
    } catch (RemoteException e) {
    // exception ignored; if this is thrown then it means the runtime is in the midst of
    // being restarted
    }
}
Body of Second Method:
{
    try {
        getContentService().setSyncAutomaticallyAsUser(account, authority, sync, userId);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.content.ContentResolver.isSyncActive:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns true if there is currently a sync operation for the given account or authority
 * actively being processed.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#READ_SYNC_STATS}.
 * @param account the account whose setting we are querying
 * @param authority the provider whose behavior is being queried
 * @return true if a sync is active for the given account or authority.
 */

Body of Frist Method:
{
    if (account == null) {
        throw new IllegalArgumentException("account must not be null");
    }
    if (authority == null) {
        throw new IllegalArgumentException("authority must not be null");
    }
    try {
        return getContentService().isSyncActive(account, authority, null);
    } catch (RemoteException e) {
        throw new RuntimeException("the ContentService should always be reachable", e);
    }
}
Body of Second Method:
{
    if (account == null) {
        throw new IllegalArgumentException("account must not be null");
    }
    if (authority == null) {
        throw new IllegalArgumentException("authority must not be null");
    }
    try {
        return getContentService().isSyncActive(account, authority, null);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.os.Debug.InstructionCount.resetAndStart:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * Reset counters and ensure counts are running.  Counts may
 * have already been running.
 *
 * @return true if counting was started
 */

Body of Frist Method:
{
    try {
        VMDebug.startInstructionCounting();
        VMDebug.resetInstructionCount();
    } catch (UnsupportedOperationException uoe) {
        return false;
    }
    return true;
}
Body of Second Method:
{
    return false;
}
------------------------
Find a silently evolved API code:android.location.GnssMeasurement.getAccumulatedDeltaRangeStateString:COMMENT
Method Modifier: private     
Comment:/**
 * Gets a string representation of the 'Accumulated Delta Range state'.
 *
 * <p>For internal and logging use only.
 */

Body of Frist Method:
{
    if (mAccumulatedDeltaRangeState == ADR_STATE_UNKNOWN) {
        return "Unknown";
    }
    StringBuilder builder = new StringBuilder();
    if ((mAccumulatedDeltaRangeState & ADR_STATE_VALID) == ADR_STATE_VALID) {
        builder.append("Valid|");
    }
    if ((mAccumulatedDeltaRangeState & ADR_STATE_RESET) == ADR_STATE_RESET) {
        builder.append("Reset|");
    }
    if ((mAccumulatedDeltaRangeState & ADR_STATE_CYCLE_SLIP) == ADR_STATE_CYCLE_SLIP) {
        builder.append("CycleSlip|");
    }
    int remainingStates = mAccumulatedDeltaRangeState & ~ADR_ALL;
    if (remainingStates > 0) {
        builder.append("Other(");
        builder.append(Integer.toBinaryString(remainingStates));
        builder.append(")|");
    }
    builder.deleteCharAt(builder.length() - 1);
    return builder.toString();
}
Body of Second Method:
{
    if (mAccumulatedDeltaRangeState == ADR_STATE_UNKNOWN) {
        return "Unknown";
    }
    StringBuilder builder = new StringBuilder();
    if ((mAccumulatedDeltaRangeState & ADR_STATE_VALID) == ADR_STATE_VALID) {
        builder.append("Valid|");
    }
    if ((mAccumulatedDeltaRangeState & ADR_STATE_RESET) == ADR_STATE_RESET) {
        builder.append("Reset|");
    }
    if ((mAccumulatedDeltaRangeState & ADR_STATE_CYCLE_SLIP) == ADR_STATE_CYCLE_SLIP) {
        builder.append("CycleSlip|");
    }
    if ((mAccumulatedDeltaRangeState & ADR_STATE_HALF_CYCLE_RESOLVED) == ADR_STATE_HALF_CYCLE_RESOLVED) {
        builder.append("HalfCycleResolved|");
    }
    if ((mAccumulatedDeltaRangeState & ADR_STATE_HALF_CYCLE_REPORTED) == ADR_STATE_HALF_CYCLE_REPORTED) {
        builder.append("HalfCycleReported|");
    }
    int remainingStates = mAccumulatedDeltaRangeState & ~ADR_STATE_ALL;
    if (remainingStates > 0) {
        builder.append("Other(");
        builder.append(Integer.toBinaryString(remainingStates));
        builder.append(")|");
    }
    builder.deleteCharAt(builder.length() - 1);
    return builder.toString();
}
------------------------
Find a silently evolved API code:android.net.wifi.RttManager.getCapabilities:COMMENT
Method Modifier: public      hidden      deprecated  
Comment:/**
 * @deprecated Use the new {@link android.net.wifi.RttManager#getRttCapabilities()} API.
 */

Body of Frist Method:
{
    return new Capabilities();
}
Body of Second Method:
{
    throw new UnsupportedOperationException("getCapabilities is not supported in the adaptation layer");
}
------------------------
Find a silently evolved API code:android.database.AbstractCursor.setNotificationUri:COMMENT
Method Modifier: public      
Comment:/**
 * Specifies a content URI to watch for changes.
 *
 * @param cr The content resolver from the caller's context.
 * @param notifyUri The URI to watch for changes. This can be a
 * specific row URI, or a base URI for a whole class of content.
 */

Body of Frist Method:
{
    setNotificationUri(cr, notifyUri, UserHandle.myUserId());
}
Body of Second Method:
{
    setNotificationUri(cr, notifyUri, cr.getUserId());
}
------------------------
Find a silently evolved API code:android.media.ThumbnailUtils.createImageThumbnail:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * This method first examines if the thumbnail embedded in EXIF is bigger than our target
 * size. If not, then it'll create a thumbnail from original image. Due to efficiency
 * consideration, we want to let MediaThumbRequest avoid calling this method twice for
 * both kinds, so it only requests for MICRO_KIND and set saveImage to true.
 *
 * This method always returns a "square thumbnail" for MICRO_KIND thumbnail.
 *
 * @param filePath the path of image file
 * @param kind could be MINI_KIND or MICRO_KIND
 * @return Bitmap, or null on failures
 *
 * @hide This method is only used by media framework and media provider internally.
 */

Body of Frist Method:
{
    boolean wantMini = (kind == Images.Thumbnails.MINI_KIND);
    int targetSize = wantMini ? TARGET_SIZE_MINI_THUMBNAIL : TARGET_SIZE_MICRO_THUMBNAIL;
    int maxPixels = wantMini ? MAX_NUM_PIXELS_THUMBNAIL : MAX_NUM_PIXELS_MICRO_THUMBNAIL;
    SizedThumbnailBitmap sizedThumbnailBitmap = new SizedThumbnailBitmap();
    Bitmap bitmap = null;
    MediaFileType fileType = MediaFile.getFileType(filePath);
    if (fileType != null && (fileType.fileType == MediaFile.FILE_TYPE_JPEG || MediaFile.isRawImageFileType(fileType.fileType))) {
        createThumbnailFromEXIF(filePath, targetSize, maxPixels, sizedThumbnailBitmap);
        bitmap = sizedThumbnailBitmap.mBitmap;
    }
    if (bitmap == null) {
        FileInputStream stream = null;
        try {
            stream = new FileInputStream(filePath);
            FileDescriptor fd = stream.getFD();
            BitmapFactory.Options options = new BitmapFactory.Options();
            options.inSampleSize = 1;
            options.inJustDecodeBounds = true;
            BitmapFactory.decodeFileDescriptor(fd, null, options);
            if (options.mCancel || options.outWidth == -1 || options.outHeight == -1) {
                return null;
            }
            options.inSampleSize = computeSampleSize(options, targetSize, maxPixels);
            options.inJustDecodeBounds = false;
            options.inDither = false;
            options.inPreferredConfig = Bitmap.Config.ARGB_8888;
            bitmap = BitmapFactory.decodeFileDescriptor(fd, null, options);
        } catch (IOException ex) {
            Log.e(TAG, "", ex);
        } catch (OutOfMemoryError oom) {
            Log.e(TAG, "Unable to decode file " + filePath + ". OutOfMemoryError.", oom);
        } finally {
            try {
                if (stream != null) {
                    stream.close();
                }
            } catch (IOException ex) {
                Log.e(TAG, "", ex);
            }
        }
    }
    if (kind == Images.Thumbnails.MICRO_KIND) {
        // now we make it a "square thumbnail" for MICRO_KIND thumbnail
        bitmap = extractThumbnail(bitmap, TARGET_SIZE_MICRO_THUMBNAIL, TARGET_SIZE_MICRO_THUMBNAIL, OPTIONS_RECYCLE_INPUT);
    }
    return bitmap;
}
Body of Second Method:
{
    boolean wantMini = (kind == Images.Thumbnails.MINI_KIND);
    int targetSize = wantMini ? TARGET_SIZE_MINI_THUMBNAIL : TARGET_SIZE_MICRO_THUMBNAIL;
    int maxPixels = wantMini ? MAX_NUM_PIXELS_THUMBNAIL : MAX_NUM_PIXELS_MICRO_THUMBNAIL;
    SizedThumbnailBitmap sizedThumbnailBitmap = new SizedThumbnailBitmap();
    Bitmap bitmap = null;
    MediaFileType fileType = MediaFile.getFileType(filePath);
    if (fileType != null) {
        if (fileType.fileType == MediaFile.FILE_TYPE_JPEG || MediaFile.isRawImageFileType(fileType.fileType)) {
            createThumbnailFromEXIF(filePath, targetSize, maxPixels, sizedThumbnailBitmap);
            bitmap = sizedThumbnailBitmap.mBitmap;
        } else if (fileType.fileType == MediaFile.FILE_TYPE_HEIF) {
            bitmap = createThumbnailFromMetadataRetriever(filePath, targetSize, maxPixels);
        }
    }
    if (bitmap == null) {
        FileInputStream stream = null;
        try {
            stream = new FileInputStream(filePath);
            FileDescriptor fd = stream.getFD();
            BitmapFactory.Options options = new BitmapFactory.Options();
            options.inSampleSize = 1;
            options.inJustDecodeBounds = true;
            BitmapFactory.decodeFileDescriptor(fd, null, options);
            if (options.mCancel || options.outWidth == -1 || options.outHeight == -1) {
                return null;
            }
            options.inSampleSize = computeSampleSize(options, targetSize, maxPixels);
            options.inJustDecodeBounds = false;
            options.inDither = false;
            options.inPreferredConfig = Bitmap.Config.ARGB_8888;
            bitmap = BitmapFactory.decodeFileDescriptor(fd, null, options);
        } catch (IOException ex) {
            Log.e(TAG, "", ex);
        } catch (OutOfMemoryError oom) {
            Log.e(TAG, "Unable to decode file " + filePath + ". OutOfMemoryError.", oom);
        } finally {
            try {
                if (stream != null) {
                    stream.close();
                }
            } catch (IOException ex) {
                Log.e(TAG, "", ex);
            }
        }
    }
    if (kind == Images.Thumbnails.MICRO_KIND) {
        // now we make it a "square thumbnail" for MICRO_KIND thumbnail
        bitmap = extractThumbnail(bitmap, TARGET_SIZE_MICRO_THUMBNAIL, TARGET_SIZE_MICRO_THUMBNAIL, OPTIONS_RECYCLE_INPUT);
    }
    return bitmap;
}
------------------------
Find a silently evolved API code:android.nfc.cardemulation.CardEmulation.getServices:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    try {
        return sService.getServices(UserHandle.myUserId(), category);
    } catch (RemoteException e) {
        // Try one more time
        recoverService();
        if (sService == null) {
            Log.e(TAG, "Failed to recover CardEmulationService.");
            return null;
        }
        try {
            return sService.getServices(UserHandle.myUserId(), category);
        } catch (RemoteException ee) {
            Log.e(TAG, "Failed to reach CardEmulationService.");
            return null;
        }
    }
}
Body of Second Method:
{
    try {
        return sService.getServices(mContext.getUserId(), category);
    } catch (RemoteException e) {
        // Try one more time
        recoverService();
        if (sService == null) {
            Log.e(TAG, "Failed to recover CardEmulationService.");
            return null;
        }
        try {
            return sService.getServices(mContext.getUserId(), category);
        } catch (RemoteException ee) {
            Log.e(TAG, "Failed to reach CardEmulationService.");
            return null;
        }
    }
}
------------------------
Find a silently evolved API code:android.hardware.camera2.CaptureRequest.readFromParcel:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Expand this object from a Parcel.
 * Hidden since this breaks the immutability of CaptureRequest, but is
 * needed to receive CaptureRequests with aidl.
 *
 * @param in The parcel from which the object should be read
 * @hide
 */

Body of Frist Method:
{
    mSettings.readFromParcel(in);
    setNativeInstance(mSettings);
    mSurfaceSet.clear();
    Parcelable[] parcelableArray = in.readParcelableArray(Surface.class.getClassLoader());
    if (parcelableArray == null) {
        return;
    }
    for (Parcelable p : parcelableArray) {
        Surface s = (Surface) p;
        mSurfaceSet.add(s);
    }
    mIsReprocess = (in.readInt() == 0) ? false : true;
    mReprocessableSessionId = CameraCaptureSession.SESSION_ID_NONE;
}
Body of Second Method:
{
    int physicalCameraCount = in.readInt();
    if (physicalCameraCount <= 0) {
        throw new RuntimeException("Physical camera count" + physicalCameraCount + " should always be positive");
    }
    // Always start with the logical camera id
    mLogicalCameraId = in.readString();
    mLogicalCameraSettings = new CameraMetadataNative();
    mLogicalCameraSettings.readFromParcel(in);
    setNativeInstance(mLogicalCameraSettings);
    mPhysicalCameraSettings.put(mLogicalCameraId, mLogicalCameraSettings);
    for (int i = 1; i < physicalCameraCount; i++) {
        String physicalId = in.readString();
        CameraMetadataNative physicalCameraSettings = new CameraMetadataNative();
        physicalCameraSettings.readFromParcel(in);
        mPhysicalCameraSettings.put(physicalId, physicalCameraSettings);
    }
    mIsReprocess = (in.readInt() == 0) ? false : true;
    mReprocessableSessionId = CameraCaptureSession.SESSION_ID_NONE;
    synchronized (mSurfacesLock) {
        mSurfaceSet.clear();
        Parcelable[] parcelableArray = in.readParcelableArray(Surface.class.getClassLoader());
        if (parcelableArray != null) {
            for (Parcelable p : parcelableArray) {
                Surface s = (Surface) p;
                mSurfaceSet.add(s);
            }
        }
        // Intentionally disallow java side readFromParcel to receive streamIdx/surfaceIdx
        // Since there is no good way to convert indexes back to Surface
        int streamSurfaceSize = in.readInt();
        if (streamSurfaceSize != 0) {
            throw new RuntimeException("Reading cached CaptureRequest is not supported");
        }
    }
}
------------------------
Find a silently evolved API code:android.telephony.CellIdentityCdma.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Implement the Parcelable interface
 */

Body of Frist Method:
{
    if (DBG)
        log("writeToParcel(Parcel, int): " + toString());
    dest.writeInt(mNetworkId);
    dest.writeInt(mSystemId);
    dest.writeInt(mBasestationId);
    dest.writeInt(mLongitude);
    dest.writeInt(mLatitude);
}
Body of Second Method:
{
    if (DBG)
        log("writeToParcel(Parcel, int): " + toString());
    super.writeToParcel(dest, TYPE_CDMA);
    dest.writeInt(mNetworkId);
    dest.writeInt(mSystemId);
    dest.writeInt(mBasestationId);
    dest.writeInt(mLongitude);
    dest.writeInt(mLatitude);
}
------------------------
Find a silently evolved API code:android.net.NetworkTemplate.matches:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Test if given {@link NetworkIdentity} matches this template.
 */

Body of Frist Method:
{
    switch(mMatchRule) {
        case MATCH_MOBILE_ALL:
            return matchesMobile(ident);
        case MATCH_MOBILE_3G_LOWER:
            return matchesMobile3gLower(ident);
        case MATCH_MOBILE_4G:
            return matchesMobile4g(ident);
        case MATCH_WIFI:
            return matchesWifi(ident);
        case MATCH_ETHERNET:
            return matchesEthernet(ident);
        case MATCH_MOBILE_WILDCARD:
            return matchesMobileWildcard(ident);
        case MATCH_WIFI_WILDCARD:
            return matchesWifiWildcard(ident);
        case MATCH_BLUETOOTH:
            return matchesBluetooth(ident);
        case MATCH_PROXY:
            return matchesProxy(ident);
        default:
            // just claim not to match anything.
            return false;
    }
}
Body of Second Method:
{
    if (!matchesMetered(ident))
        return false;
    if (!matchesRoaming(ident))
        return false;
    if (!matchesDefaultNetwork(ident))
        return false;
    switch(mMatchRule) {
        case MATCH_MOBILE:
            return matchesMobile(ident);
        case MATCH_WIFI:
            return matchesWifi(ident);
        case MATCH_ETHERNET:
            return matchesEthernet(ident);
        case MATCH_MOBILE_WILDCARD:
            return matchesMobileWildcard(ident);
        case MATCH_WIFI_WILDCARD:
            return matchesWifiWildcard(ident);
        case MATCH_BLUETOOTH:
            return matchesBluetooth(ident);
        case MATCH_PROXY:
            return matchesProxy(ident);
        default:
            // just claim not to match anything.
            return false;
    }
}
------------------------
Find a silently evolved API code:android.view.accessibility.AccessibilityWindowInfo.getAnchor:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the node that anchors this window to another.
 *
 * @return The anchor node, or {@code null} if none exists.
 */

Body of Frist Method:
{
    if ((mConnectionId == UNDEFINED_WINDOW_ID) || (mAnchorId == UNDEFINED_WINDOW_ID) || (mParentId == UNDEFINED_WINDOW_ID)) {
        return null;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mParentId, mAnchorId, true, 0, null);
}
Body of Second Method:
{
    if ((mConnectionId == UNDEFINED_WINDOW_ID) || (mAnchorId == AccessibilityNodeInfo.UNDEFINED_NODE_ID) || (mParentId == UNDEFINED_WINDOW_ID)) {
        return null;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mParentId, mAnchorId, true, 0, null);
}
------------------------
Find a silently evolved API code:android.telephony.SignalStrength.fillInNotifierBundle:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Set intent notifier Bundle based on SignalStrength
 *
 * @param m intent notifier Bundle
 * @hide
 */

Body of Frist Method:
{
    m.putInt("GsmSignalStrength", mGsmSignalStrength);
    m.putInt("GsmBitErrorRate", mGsmBitErrorRate);
    m.putInt("CdmaDbm", mCdmaDbm);
    m.putInt("CdmaEcio", mCdmaEcio);
    m.putInt("EvdoDbm", mEvdoDbm);
    m.putInt("EvdoEcio", mEvdoEcio);
    m.putInt("EvdoSnr", mEvdoSnr);
    m.putInt("LteSignalStrength", mLteSignalStrength);
    m.putInt("LteRsrp", mLteRsrp);
    m.putInt("LteRsrq", mLteRsrq);
    m.putInt("LteRssnr", mLteRssnr);
    m.putInt("LteCqi", mLteCqi);
    m.putInt("lteRsrpBoost", mLteRsrpBoost);
    m.putInt("TdScdma", mTdScdmaRscp);
    m.putBoolean("isGsm", isGsm);
}
Body of Second Method:
{
    m.putInt("GsmSignalStrength", mGsmSignalStrength);
    m.putInt("GsmBitErrorRate", mGsmBitErrorRate);
    m.putInt("CdmaDbm", mCdmaDbm);
    m.putInt("CdmaEcio", mCdmaEcio);
    m.putInt("EvdoDbm", mEvdoDbm);
    m.putInt("EvdoEcio", mEvdoEcio);
    m.putInt("EvdoSnr", mEvdoSnr);
    m.putInt("LteSignalStrength", mLteSignalStrength);
    m.putInt("LteRsrp", mLteRsrp);
    m.putInt("LteRsrq", mLteRsrq);
    m.putInt("LteRssnr", mLteRssnr);
    m.putInt("LteCqi", mLteCqi);
    m.putInt("LteRsrpBoost", mLteRsrpBoost);
    m.putInt("TdScdma", mTdScdmaRscp);
    m.putInt("WcdmaSignalStrength", mWcdmaSignalStrength);
    m.putInt("WcdmaRscpAsu", mWcdmaRscpAsu);
    m.putInt("WcdmaRscp", mWcdmaRscp);
    m.putBoolean("IsGsm", mIsGsm);
    m.putBoolean("UseOnlyRsrpForLteLevel", mUseOnlyRsrpForLteLevel);
    m.putString("WcdmaDefaultSignalMeasurement", mWcdmaDefaultSignalMeasurement);
    ArrayList<Integer> lteRsrpThresholds = new ArrayList<Integer>();
    for (int value : mLteRsrpThresholds) {
        lteRsrpThresholds.add(value);
    }
    m.putIntegerArrayList("lteRsrpThresholds", lteRsrpThresholds);
    ArrayList<Integer> wcdmaRscpThresholds = new ArrayList<Integer>();
    for (int value : mWcdmaRscpThresholds) {
        wcdmaRscpThresholds.add(value);
    }
    m.putIntegerArrayList("wcdmaRscpThresholds", wcdmaRscpThresholds);
}
------------------------
Find a silently evolved API code:android.content.res.TypedArray.getString:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieves the string value for the attribute at <var>index</var>.
 * <p>
 * If the attribute is not a string, this method will attempt to coerce
 * it to a string.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return String holding string data. Any styling information is removed.
 * Returns {@code null} if the attribute is not defined or could
 * not be coerced to a string.
 * @throws RuntimeException if the TypedArray has already been recycled.
 */

Body of Frist Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return null;
    } else if (type == TypedValue.TYPE_STRING) {
        return loadStringValueAt(index).toString();
    }
    final TypedValue v = mValue;
    if (getValueAt(index, v)) {
        final CharSequence cs = v.coerceToString();
        return cs != null ? cs.toString() : null;
    }
    // We already checked for TYPE_NULL. This should never happen.
    throw new RuntimeException("getString of bad type: 0x" + Integer.toHexString(type));
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    index *= STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return null;
    } else if (type == TypedValue.TYPE_STRING) {
        return loadStringValueAt(index).toString();
    }
    final TypedValue v = mValue;
    if (getValueAt(index, v)) {
        final CharSequence cs = v.coerceToString();
        return cs != null ? cs.toString() : null;
    }
    // We already checked for TYPE_NULL. This should never happen.
    throw new RuntimeException("getString of bad type: 0x" + Integer.toHexString(type));
}
------------------------
Find a silently evolved API code:android.os.ZygoteProcess.openZygoteSocketIfNeeded:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Tries to open socket to Zygote process if not already open. If
 * already open, does nothing.  May block and retry.  Requires that mLock be held.
 */

Body of Frist Method:
{
    Preconditions.checkState(Thread.holdsLock(mLock), "ZygoteProcess lock not held");
    if (primaryZygoteState == null || primaryZygoteState.isClosed()) {
        try {
            primaryZygoteState = ZygoteState.connect(mSocket);
        } catch (IOException ioe) {
            throw new ZygoteStartFailedEx("Error connecting to primary zygote", ioe);
        }
    }
    if (primaryZygoteState.matches(abi)) {
        return primaryZygoteState;
    }
    // The primary zygote didn't match. Try the secondary.
    if (secondaryZygoteState == null || secondaryZygoteState.isClosed()) {
        try {
            secondaryZygoteState = ZygoteState.connect(mSecondarySocket);
        } catch (IOException ioe) {
            throw new ZygoteStartFailedEx("Error connecting to secondary zygote", ioe);
        }
    }
    if (secondaryZygoteState.matches(abi)) {
        return secondaryZygoteState;
    }
    throw new ZygoteStartFailedEx("Unsupported zygote ABI: " + abi);
}
Body of Second Method:
{
    Preconditions.checkState(Thread.holdsLock(mLock), "ZygoteProcess lock not held");
    if (primaryZygoteState == null || primaryZygoteState.isClosed()) {
        try {
            primaryZygoteState = ZygoteState.connect(mSocket);
        } catch (IOException ioe) {
            throw new ZygoteStartFailedEx("Error connecting to primary zygote", ioe);
        }
        maybeSetApiBlacklistExemptions(primaryZygoteState, false);
        maybeSetHiddenApiAccessLogSampleRate(primaryZygoteState);
    }
    if (primaryZygoteState.matches(abi)) {
        return primaryZygoteState;
    }
    // The primary zygote didn't match. Try the secondary.
    if (secondaryZygoteState == null || secondaryZygoteState.isClosed()) {
        try {
            secondaryZygoteState = ZygoteState.connect(mSecondarySocket);
        } catch (IOException ioe) {
            throw new ZygoteStartFailedEx("Error connecting to secondary zygote", ioe);
        }
        maybeSetApiBlacklistExemptions(secondaryZygoteState, false);
        maybeSetHiddenApiAccessLogSampleRate(secondaryZygoteState);
    }
    if (secondaryZygoteState.matches(abi)) {
        return secondaryZygoteState;
    }
    throw new ZygoteStartFailedEx("Unsupported zygote ABI: " + abi);
}
------------------------
Find a silently evolved API code:android.content.res.TypedArray.getInt:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the integer value for the attribute at <var>index</var>.
 * <p>
 * If the attribute is not an integer, this method will attempt to coerce
 * it to an integer using {@link Integer#decode(String)}.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * cannot be coerced to an integer.
 *
 * @return Integer value of the attribute, or defValue if the attribute was
 * not defined or could not be coerced to an integer.
 * @throws RuntimeException if the TypedArray has already been recycled.
 */

Body of Frist Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + AssetManager.STYLE_DATA];
    }
    final TypedValue v = mValue;
    if (getValueAt(index, v)) {
        StrictMode.noteResourceMismatch(v);
        return XmlUtils.convertValueToInt(v.coerceToString(), defValue);
    }
    // We already checked for TYPE_NULL. This should never happen.
    throw new RuntimeException("getInt of bad type: 0x" + Integer.toHexString(type));
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    index *= STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + STYLE_DATA];
    }
    final TypedValue v = mValue;
    if (getValueAt(index, v)) {
        StrictMode.noteResourceMismatch(v);
        return XmlUtils.convertValueToInt(v.coerceToString(), defValue);
    }
    // We already checked for TYPE_NULL. This should never happen.
    throw new RuntimeException("getInt of bad type: 0x" + Integer.toHexString(type));
}
------------------------
Find a silently evolved API code:android.content.ContentResolver.getSyncAdapterTypesAsUser:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @see #getSyncAdapterTypes()
 * @hide
 */

Body of Frist Method:
{
    try {
        return getContentService().getSyncAdapterTypesAsUser(userId);
    } catch (RemoteException e) {
        throw new RuntimeException("the ContentService should always be reachable", e);
    }
}
Body of Second Method:
{
    try {
        return getContentService().getSyncAdapterTypesAsUser(userId);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.content.res.TypedArray.getNonResourceString:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieves the string value for the attribute at <var>index</var>, but
 * only if that string comes from an immediate value in an XML file.  That
 * is, this does not allow references to string resources, string
 * attributes, or conversions from other types.  As such, this method
 * will only return strings for TypedArray objects that come from
 * attributes in an XML file.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return String holding string data. Any styling information is removed.
 * Returns {@code null} if the attribute is not defined or is not
 * an immediate string value.
 * @throws RuntimeException if the TypedArray has already been recycled.
 */

Body of Frist Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_STRING) {
        final int cookie = data[index + AssetManager.STYLE_ASSET_COOKIE];
        if (cookie < 0) {
            return mXml.getPooledString(data[index + AssetManager.STYLE_DATA]).toString();
        }
    }
    return null;
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    index *= STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + STYLE_TYPE];
    if (type == TypedValue.TYPE_STRING) {
        final int cookie = data[index + STYLE_ASSET_COOKIE];
        if (cookie < 0) {
            return mXml.getPooledString(data[index + STYLE_DATA]).toString();
        }
    }
    return null;
}
------------------------
Find a silently evolved API code:android.security.keystore.KeyProtection.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Builds an instance of {@link KeyProtection}.
 *
 * @throws IllegalArgumentException if a required field is missing
 */

Body of Frist Method:
{
    return new KeyProtection(mKeyValidityStart, mKeyValidityForOriginationEnd, mKeyValidityForConsumptionEnd, mPurposes, mEncryptionPaddings, mSignaturePaddings, mDigests, mBlockModes, mRandomizedEncryptionRequired, mUserAuthenticationRequired, mUserAuthenticationValidityDurationSeconds, mUserAuthenticationValidWhileOnBody, mInvalidatedByBiometricEnrollment, mBoundToSecureUserId, mCriticalToDeviceEncryption);
}
Body of Second Method:
{
    return new KeyProtection(mKeyValidityStart, mKeyValidityForOriginationEnd, mKeyValidityForConsumptionEnd, mPurposes, mEncryptionPaddings, mSignaturePaddings, mDigests, mBlockModes, mRandomizedEncryptionRequired, mUserAuthenticationRequired, mUserAuthenticationValidityDurationSeconds, mUserPresenceRequired, mUserAuthenticationValidWhileOnBody, mInvalidatedByBiometricEnrollment, mBoundToSecureUserId, mCriticalToDeviceEncryption, mUserConfirmationRequired, mUnlockedDeviceRequired, mIsStrongBoxBacked);
}
------------------------
Find a silently evolved API code:android.net.TrafficStats.getMobileTcpTxPackets:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * {@hide}
 */

Body of Frist Method:
{
    long total = 0;
    for (String iface : getMobileIfaces()) {
        final long stat = nativeGetIfaceStat(iface, TYPE_TCP_TX_PACKETS);
        if (stat != UNSUPPORTED) {
            total += stat;
        }
    }
    return total;
}
Body of Second Method:
{
    long total = 0;
    for (String iface : getMobileIfaces()) {
        long stat = UNSUPPORTED;
        try {
            stat = getStatsService().getIfaceStats(iface, TYPE_TCP_TX_PACKETS);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
        total += addIfSupported(stat);
    }
    return total;
}
------------------------
Find a silently evolved API code:android.text.Selection.extendSelection:COMMENT
Method Modifier: public      static      final       
Comment:/**
 * Move the selection edge to offset <code>index</code>.
 */

Body of Frist Method:
{
    if (text.getSpanStart(SELECTION_END) != index)
        text.setSpan(SELECTION_END, index, index, Spanned.SPAN_POINT_POINT);
}
Body of Second Method:
{
    extendSelection(text, index, -1);
}
------------------------
Find a silently evolved API code:android.content.ContentResolver.requestSync:COMMENT
Method Modifier: public      static      
Comment:/**
 * Register a sync with the SyncManager. These requests are built using the
 * {@link SyncRequest.Builder}.
 */

Body of Frist Method:
{
    try {
        getContentService().sync(request);
    } catch (RemoteException e) {
    // Shouldn't happen.
    }
}
Body of Second Method:
{
    try {
        getContentService().sync(request);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.le.AdvertisingSetParameters.isConnectable:COMMENT
Method Modifier: public      
Comment:/**
 * Returns whether the advertisement will be connectable.
 */

Body of Frist Method:
{
    return connectable;
}
Body of Second Method:
{
    return mConnectable;
}
------------------------
Find a silently evolved API code:android.media.session.MediaController.TransportControls.prepareFromMediaId:COMMENT
Method Modifier: public      
Comment:/**
 * Request that the player prepare playback for a specific media id. In other words, other
 * sessions can continue to play during the preparation of this session. This method can be
 * used to speed up the start of the playback. Once the preparation is done, the session
 * will change its playback state to {@link PlaybackState#STATE_PAUSED}. Afterwards,
 * {@link #play} can be called to start playback. If the preparation is not needed,
 * {@link #playFromMediaId} can be directly called without this method.
 *
 * @param mediaId The id of the requested media.
 * @param extras Optional extras that can include extra information about the media item
 * to be prepared.
 */

Body of Frist Method:
{
    if (TextUtils.isEmpty(mediaId)) {
        throw new IllegalArgumentException("You must specify a non-empty String for prepareFromMediaId.");
    }
    try {
        mSessionBinder.prepareFromMediaId(mediaId, extras);
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling prepare(" + mediaId + ").", e);
    }
}
Body of Second Method:
{
    if (TextUtils.isEmpty(mediaId)) {
        throw new IllegalArgumentException("You must specify a non-empty String for prepareFromMediaId.");
    }
    try {
        mSessionBinder.prepareFromMediaId(mContext.getPackageName(), mCbStub, mediaId, extras);
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling prepare(" + mediaId + ").", e);
    }
}
------------------------
Find a silently evolved API code:android.net.NetworkStats.getValues:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Return specific stats entry.
 */

Body of Frist Method:
{
    final Entry entry = recycle != null ? recycle : new Entry();
    entry.iface = iface[i];
    entry.uid = uid[i];
    entry.set = set[i];
    entry.tag = tag[i];
    entry.metered = metered[i];
    entry.roaming = roaming[i];
    entry.rxBytes = rxBytes[i];
    entry.rxPackets = rxPackets[i];
    entry.txBytes = txBytes[i];
    entry.txPackets = txPackets[i];
    entry.operations = operations[i];
    return entry;
}
Body of Second Method:
{
    final Entry entry = recycle != null ? recycle : new Entry();
    entry.iface = iface[i];
    entry.uid = uid[i];
    entry.set = set[i];
    entry.tag = tag[i];
    entry.metered = metered[i];
    entry.roaming = roaming[i];
    entry.defaultNetwork = defaultNetwork[i];
    entry.rxBytes = rxBytes[i];
    entry.rxPackets = rxPackets[i];
    entry.txBytes = txBytes[i];
    entry.txPackets = txPackets[i];
    entry.operations = operations[i];
    return entry;
}
------------------------
Find a silently evolved API code:android.security.keystore.KeyGenParameterSpec.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Builds an instance of {@code KeyGenParameterSpec}.
 */

Body of Frist Method:
{
    return new KeyGenParameterSpec(mKeystoreAlias, mUid, mKeySize, mSpec, mCertificateSubject, mCertificateSerialNumber, mCertificateNotBefore, mCertificateNotAfter, mKeyValidityStart, mKeyValidityForOriginationEnd, mKeyValidityForConsumptionEnd, mPurposes, mDigests, mEncryptionPaddings, mSignaturePaddings, mBlockModes, mRandomizedEncryptionRequired, mUserAuthenticationRequired, mUserAuthenticationValidityDurationSeconds, mAttestationChallenge, mUniqueIdIncluded, mUserAuthenticationValidWhileOnBody, mInvalidatedByBiometricEnrollment);
}
Body of Second Method:
{
    return new KeyGenParameterSpec(mKeystoreAlias, mUid, mKeySize, mSpec, mCertificateSubject, mCertificateSerialNumber, mCertificateNotBefore, mCertificateNotAfter, mKeyValidityStart, mKeyValidityForOriginationEnd, mKeyValidityForConsumptionEnd, mPurposes, mDigests, mEncryptionPaddings, mSignaturePaddings, mBlockModes, mRandomizedEncryptionRequired, mUserAuthenticationRequired, mUserAuthenticationValidityDurationSeconds, mUserPresenceRequired, mAttestationChallenge, mUniqueIdIncluded, mUserAuthenticationValidWhileOnBody, mInvalidatedByBiometricEnrollment, mIsStrongBoxBacked, mUserConfirmationRequired, mUnlockedDeviceRequired);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothSocket.bindListen:COMMENT
Method Modifier: default     
Comment:/*package*/

Body of Frist Method:
{
    int ret;
    if (mSocketState == SocketState.CLOSED)
        return EBADFD;
    IBluetooth bluetoothProxy = BluetoothAdapter.getDefaultAdapter().getBluetoothService(null);
    if (bluetoothProxy == null) {
        Log.e(TAG, "bindListen fail, reason: bluetooth is off");
        return -1;
    }
    try {
        mPfd = bluetoothProxy.createSocketChannel(mType, mServiceName, mUuid, mPort, getSecurityFlags());
    } catch (RemoteException e) {
        Log.e(TAG, Log.getStackTraceString(new Throwable()));
        return -1;
    }
    // read out port number
    try {
        synchronized (this) {
            if (DBG)
                Log.d(TAG, "bindListen(), SocketState: " + mSocketState + ", mPfd: " + mPfd);
            if (mSocketState != SocketState.INIT)
                return EBADFD;
            if (mPfd == null)
                return -1;
            FileDescriptor fd = mPfd.getFileDescriptor();
            if (fd == null) {
                Log.e(TAG, "bindListen(), null file descriptor");
                return -1;
            }
            if (DBG)
                Log.d(TAG, "bindListen(), Create LocalSocket");
            mSocket = LocalSocket.createConnectedLocalSocket(fd);
            if (DBG)
                Log.d(TAG, "bindListen(), new LocalSocket.getInputStream()");
            mSocketIS = mSocket.getInputStream();
            mSocketOS = mSocket.getOutputStream();
        }
        if (DBG)
            Log.d(TAG, "bindListen(), readInt mSocketIS: " + mSocketIS);
        int channel = readInt(mSocketIS);
        synchronized (this) {
            if (mSocketState == SocketState.INIT)
                mSocketState = SocketState.LISTENING;
        }
        if (DBG)
            Log.d(TAG, "channel: " + channel);
        if (mPort <= -1) {
            mPort = channel;
        }
        // else ASSERT(mPort == channel)
        ret = 0;
    } catch (IOException e) {
        if (mPfd != null) {
            try {
                mPfd.close();
            } catch (IOException e1) {
                Log.e(TAG, "bindListen, close mPfd: " + e1);
            }
            mPfd = null;
        }
        Log.e(TAG, "bindListen, fail to get port number, exception: " + e);
        return -1;
    }
    return ret;
}
Body of Second Method:
{
    int ret;
    if (mSocketState == SocketState.CLOSED)
        return EBADFD;
    IBluetooth bluetoothProxy = BluetoothAdapter.getDefaultAdapter().getBluetoothService(null);
    if (bluetoothProxy == null) {
        Log.e(TAG, "bindListen fail, reason: bluetooth is off");
        return -1;
    }
    try {
        if (DBG)
            Log.d(TAG, "bindListen(): mPort=" + mPort + ", mType=" + mType);
        mPfd = bluetoothProxy.getSocketManager().createSocketChannel(mType, mServiceName, mUuid, mPort, getSecurityFlags());
    } catch (RemoteException e) {
        Log.e(TAG, Log.getStackTraceString(new Throwable()));
        return -1;
    }
    // read out port number
    try {
        synchronized (this) {
            if (DBG) {
                Log.d(TAG, "bindListen(), SocketState: " + mSocketState + ", mPfd: " + mPfd);
            }
            if (mSocketState != SocketState.INIT)
                return EBADFD;
            if (mPfd == null)
                return -1;
            FileDescriptor fd = mPfd.getFileDescriptor();
            if (fd == null) {
                Log.e(TAG, "bindListen(), null file descriptor");
                return -1;
            }
            if (DBG)
                Log.d(TAG, "bindListen(), Create LocalSocket");
            mSocket = LocalSocket.createConnectedLocalSocket(fd);
            if (DBG)
                Log.d(TAG, "bindListen(), new LocalSocket.getInputStream()");
            mSocketIS = mSocket.getInputStream();
            mSocketOS = mSocket.getOutputStream();
        }
        if (DBG)
            Log.d(TAG, "bindListen(), readInt mSocketIS: " + mSocketIS);
        int channel = readInt(mSocketIS);
        synchronized (this) {
            if (mSocketState == SocketState.INIT) {
                mSocketState = SocketState.LISTENING;
            }
        }
        if (DBG)
            Log.d(TAG, "bindListen(): channel=" + channel + ", mPort=" + mPort);
        if (mPort <= -1) {
            mPort = channel;
        }
        // else ASSERT(mPort == channel)
        ret = 0;
    } catch (IOException e) {
        if (mPfd != null) {
            try {
                mPfd.close();
            } catch (IOException e1) {
                Log.e(TAG, "bindListen, close mPfd: " + e1);
            }
            mPfd = null;
        }
        Log.e(TAG, "bindListen, fail to get port number, exception: " + e);
        return -1;
    }
    return ret;
}
------------------------
Find a silently evolved API code:android.content.ContentResolver.cancelSyncAsUser:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @see #cancelSync(Account, String)
 * @hide
 */

Body of Frist Method:
{
    try {
        getContentService().cancelSyncAsUser(account, authority, null, userId);
    } catch (RemoteException e) {
    }
}
Body of Second Method:
{
    try {
        getContentService().cancelSyncAsUser(account, authority, null, userId);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothSocket.read:COMMENT
Method Modifier: default     
Comment:/*package*/

Body of Frist Method:
{
    int ret = 0;
    if (VDBG)
        Log.d(TAG, "read in:  " + mSocketIS + " len: " + length);
    if (mType == TYPE_L2CAP) {
        int bytesToRead = length;
        if (VDBG)
            Log.v(TAG, "l2cap: read(): offset: " + offset + " length:" + length + "mL2capBuffer= " + mL2capBuffer);
        if (mL2capBuffer == null) {
            createL2capRxBuffer();
        }
        if (mL2capBuffer.remaining() == 0) {
            if (VDBG)
                Log.v(TAG, "l2cap buffer empty, refilling...");
            if (fillL2capRxBuffer() == -1) {
                return -1;
            }
        }
        if (bytesToRead > mL2capBuffer.remaining()) {
            bytesToRead = mL2capBuffer.remaining();
        }
        if (VDBG)
            Log.v(TAG, "get(): offset: " + offset + " bytesToRead: " + bytesToRead);
        mL2capBuffer.get(b, offset, bytesToRead);
        ret = bytesToRead;
    } else {
        if (VDBG)
            Log.v(TAG, "default: read(): offset: " + offset + " length:" + length);
        ret = mSocketIS.read(b, offset, length);
    }
    if (ret < 0)
        throw new IOException("bt socket closed, read return: " + ret);
    if (VDBG)
        Log.d(TAG, "read out:  " + mSocketIS + " ret: " + ret);
    return ret;
}
Body of Second Method:
{
    int ret = 0;
    if (VDBG)
        Log.d(TAG, "read in:  " + mSocketIS + " len: " + length);
    if ((mType == TYPE_L2CAP) || (mType == TYPE_L2CAP_LE)) {
        int bytesToRead = length;
        if (VDBG) {
            Log.v(TAG, "l2cap: read(): offset: " + offset + " length:" + length + "mL2capBuffer= " + mL2capBuffer);
        }
        if (mL2capBuffer == null) {
            createL2capRxBuffer();
        }
        if (mL2capBuffer.remaining() == 0) {
            if (VDBG)
                Log.v(TAG, "l2cap buffer empty, refilling...");
            if (fillL2capRxBuffer() == -1) {
                return -1;
            }
        }
        if (bytesToRead > mL2capBuffer.remaining()) {
            bytesToRead = mL2capBuffer.remaining();
        }
        if (VDBG) {
            Log.v(TAG, "get(): offset: " + offset + " bytesToRead: " + bytesToRead);
        }
        mL2capBuffer.get(b, offset, bytesToRead);
        ret = bytesToRead;
    } else {
        if (VDBG)
            Log.v(TAG, "default: read(): offset: " + offset + " length:" + length);
        ret = mSocketIS.read(b, offset, length);
    }
    if (ret < 0) {
        throw new IOException("bt socket closed, read return: " + ret);
    }
    if (VDBG)
        Log.d(TAG, "read out:  " + mSocketIS + " ret: " + ret);
    return ret;
}
------------------------
Find a silently evolved API code:android.telephony.PhoneNumberUtils.networkPortionToCalledPartyBCDWithLength:COMMENT
Method Modifier: public      static      
Comment:/**
 * Same as {@link #networkPortionToCalledPartyBCD}, but includes a
 * one-byte length prefix.
 */

Body of Frist Method:
{
    String networkPortion = extractNetworkPortion(s);
    return numberToCalledPartyBCDHelper(networkPortion, true);
}
Body of Second Method:
{
    String networkPortion = extractNetworkPortion(s);
    return numberToCalledPartyBCDHelper(networkPortion, true, BCD_EXTENDED_TYPE_EF_ADN);
}
------------------------
Find a silently evolved API code:android.view.ThreadedRenderer.setupDiskCache:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Sets the directory to use as a persistent storage for threaded rendering
 * resources.
 *
 * @param cacheDir A directory the current process can write to
 *
 * @hide
 */

Body of Frist Method:
{
    ThreadedRenderer.setupShadersDiskCache(new File(cacheDir, CACHE_PATH_SHADERS).getAbsolutePath());
}
Body of Second Method:
{
    ThreadedRenderer.setupShadersDiskCache(new File(cacheDir, CACHE_PATH_SHADERS).getAbsolutePath(), new File(cacheDir, CACHE_PATH_SKIASHADERS).getAbsolutePath());
}
------------------------
Find a silently evolved API code:android.content.res.TypedArray.getNonConfigurationString:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Retrieves the string value for the attribute at <var>index</var> that is
 * not allowed to change with the given configurations.
 *
 * @param index Index of attribute to retrieve.
 * @param allowedChangingConfigs Bit mask of configurations from
 * {@link Configuration}.NATIVE_CONFIG_* that are allowed to change.
 *
 * @return String holding string data. Any styling information is removed.
 * Returns {@code null} if the attribute is not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @hide
 */

Body of Frist Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    @Config final int changingConfigs = ActivityInfo.activityInfoConfigNativeToJava(data[index + AssetManager.STYLE_CHANGING_CONFIGURATIONS]);
    if ((changingConfigs & ~allowedChangingConfigs) != 0) {
        return null;
    }
    if (type == TypedValue.TYPE_NULL) {
        return null;
    } else if (type == TypedValue.TYPE_STRING) {
        return loadStringValueAt(index).toString();
    }
    final TypedValue v = mValue;
    if (getValueAt(index, v)) {
        final CharSequence cs = v.coerceToString();
        return cs != null ? cs.toString() : null;
    }
    // We already checked for TYPE_NULL. This should never happen.
    throw new RuntimeException("getNonConfigurationString of bad type: 0x" + Integer.toHexString(type));
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    index *= STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + STYLE_TYPE];
    @Config final int changingConfigs = ActivityInfo.activityInfoConfigNativeToJava(data[index + STYLE_CHANGING_CONFIGURATIONS]);
    if ((changingConfigs & ~allowedChangingConfigs) != 0) {
        return null;
    }
    if (type == TypedValue.TYPE_NULL) {
        return null;
    } else if (type == TypedValue.TYPE_STRING) {
        return loadStringValueAt(index).toString();
    }
    final TypedValue v = mValue;
    if (getValueAt(index, v)) {
        final CharSequence cs = v.coerceToString();
        return cs != null ? cs.toString() : null;
    }
    // We already checked for TYPE_NULL. This should never happen.
    throw new RuntimeException("getNonConfigurationString of bad type: 0x" + Integer.toHexString(type));
}
------------------------
Find a silently evolved API code:android.graphics.Bitmap.getColorSpace:COMMENT
Method Modifier: public      final       
Comment:/**
 * Returns the color space associated with this bitmap. If the color
 * space is unknown, this method returns null.
 */

Body of Frist Method:
{
    // always linear scRGB at this time
    if (getConfig() == Config.RGBA_F16) {
        // Reset the color space for potential future reconfigurations
        mColorSpace = null;
        return ColorSpace.get(ColorSpace.Named.LINEAR_EXTENDED_SRGB);
    }
    // Cache the color space retrieval since it can be fairly expensive
    if (mColorSpace == null) {
        if (nativeIsSRGB(mNativePtr)) {
            mColorSpace = ColorSpace.get(ColorSpace.Named.SRGB);
        } else {
            float[] xyz = new float[9];
            float[] params = new float[7];
            boolean hasColorSpace = nativeGetColorSpace(mNativePtr, xyz, params);
            if (hasColorSpace) {
                ColorSpace.Rgb.TransferParameters parameters = new ColorSpace.Rgb.TransferParameters(params[0], params[1], params[2], params[3], params[4], params[5], params[6]);
                ColorSpace cs = ColorSpace.match(xyz, parameters);
                if (cs != null) {
                    mColorSpace = cs;
                } else {
                    mColorSpace = new ColorSpace.Rgb("Unknown", xyz, parameters);
                }
            }
        }
    }
    return mColorSpace;
}
Body of Second Method:
{
    // always linear scRGB at this time
    if (getConfig() == Config.RGBA_F16) {
        // Reset the color space for potential future reconfigurations
        mColorSpace = null;
        return ColorSpace.get(ColorSpace.Named.LINEAR_EXTENDED_SRGB);
    }
    // Cache the color space retrieval since it can be fairly expensive
    if (mColorSpace == null) {
        if (nativeIsSRGB(mNativePtr)) {
            mColorSpace = ColorSpace.get(ColorSpace.Named.SRGB);
        } else if (getConfig() == Config.HARDWARE && nativeIsSRGBLinear(mNativePtr)) {
            mColorSpace = ColorSpace.get(ColorSpace.Named.LINEAR_EXTENDED_SRGB);
        } else {
            float[] xyz = new float[9];
            float[] params = new float[7];
            boolean hasColorSpace = nativeGetColorSpace(mNativePtr, xyz, params);
            if (hasColorSpace) {
                ColorSpace.Rgb.TransferParameters parameters = new ColorSpace.Rgb.TransferParameters(params[0], params[1], params[2], params[3], params[4], params[5], params[6]);
                ColorSpace cs = ColorSpace.match(xyz, parameters);
                if (cs != null) {
                    mColorSpace = cs;
                } else {
                    mColorSpace = new ColorSpace.Rgb("Unknown", xyz, parameters);
                }
            }
        }
    }
    return mColorSpace;
}
------------------------
Find a silently evolved API code:android.app.admin.NetworkEvent.getPackageName:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the package name of the UID that performed the query, as returned by
 * {@link PackageManager#getNameForUid}.
 */

Body of Frist Method:
{
    return packageName;
}
Body of Second Method:
{
    return mPackageName;
}
------------------------
Find a silently evolved API code:android.nfc.cardemulation.NfcFCardEmulation.unregisterSystemCodeForService:COMMENT
Method Modifier: public      
Comment:/**
 * Removes a registered System Code for the specified service.
 *
 * @param service The component name of the service
 * @return whether the System Code was successfully removed.
 */

Body of Frist Method:
{
    if (service == null) {
        throw new NullPointerException("service is null");
    }
    try {
        return sService.removeSystemCodeForService(UserHandle.myUserId(), service);
    } catch (RemoteException e) {
        // Try one more time
        recoverService();
        if (sService == null) {
            Log.e(TAG, "Failed to recover CardEmulationService.");
            return false;
        }
        try {
            return sService.removeSystemCodeForService(UserHandle.myUserId(), service);
        } catch (RemoteException ee) {
            Log.e(TAG, "Failed to reach CardEmulationService.");
            ee.rethrowAsRuntimeException();
            return false;
        }
    }
}
Body of Second Method:
{
    if (service == null) {
        throw new NullPointerException("service is null");
    }
    try {
        return sService.removeSystemCodeForService(mContext.getUserId(), service);
    } catch (RemoteException e) {
        // Try one more time
        recoverService();
        if (sService == null) {
            Log.e(TAG, "Failed to recover CardEmulationService.");
            return false;
        }
        try {
            return sService.removeSystemCodeForService(mContext.getUserId(), service);
        } catch (RemoteException ee) {
            Log.e(TAG, "Failed to reach CardEmulationService.");
            ee.rethrowAsRuntimeException();
            return false;
        }
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.le.AdvertisingSet.getAdvertiserId:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns advertiserId associated with this advertising set.
 *
 * @hide
 */

Body of Frist Method:
{
    return advertiserId;
}
Body of Second Method:
{
    return mAdvertiserId;
}
------------------------
Find a silently evolved API code:android.app.admin.SecurityLog.SecurityEvent.hashCode:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return mEvent.hashCode();
}
Body of Second Method:
{
    return Objects.hash(mEvent, mId);
}
------------------------
Find a silently evolved API code:android.content.res.TypedArray.getDrawableForDensity:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Version of {@link #getDrawable(int)} that accepts an override density.
 * @hide
 */

Body of Frist Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    final TypedValue value = mValue;
    if (getValueAt(index * AssetManager.STYLE_NUM_ENTRIES, value)) {
        if (value.type == TypedValue.TYPE_ATTRIBUTE) {
            throw new UnsupportedOperationException("Failed to resolve attribute at index " + index + ": " + value);
        }
        if (density > 0) {
            // If the density is overridden, the value in the TypedArray will not reflect this.
            // Do a separate lookup of the resourceId with the density override.
            mResources.getValueForDensity(value.resourceId, density, value, true);
        }
        return mResources.loadDrawable(value, value.resourceId, density, mTheme);
    }
    return null;
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    final TypedValue value = mValue;
    if (getValueAt(index * STYLE_NUM_ENTRIES, value)) {
        if (value.type == TypedValue.TYPE_ATTRIBUTE) {
            throw new UnsupportedOperationException("Failed to resolve attribute at index " + index + ": " + value);
        }
        if (density > 0) {
            // If the density is overridden, the value in the TypedArray will not reflect this.
            // Do a separate lookup of the resourceId with the density override.
            mResources.getValueForDensity(value.resourceId, density, value, true);
        }
        return mResources.loadDrawable(value, value.resourceId, density, mTheme);
    }
    return null;
}
------------------------
Find a silently evolved API code:android.view.Surface.lockHardwareCanvas:COMMENT
Method Modifier: public      
Comment:/**
 * Gets a {@link Canvas} for drawing into this surface.
 *
 * After drawing into the provided {@link Canvas}, the caller must
 * invoke {@link #unlockCanvasAndPost} to post the new contents to the surface.
 *
 * Unlike {@link #lockCanvas(Rect)} this will return a hardware-accelerated
 * canvas. See the <a href="{@docRoot}guide/topics/graphics/hardware-accel.html#unsupported">
 * unsupported drawing operations</a> for a list of what is and isn't
 * supported in a hardware-accelerated canvas. It is also required to
 * fully cover the surface every time {@link #lockHardwareCanvas()} is
 * called as the buffer is not preserved between frames. Partial updates
 * are not supported.
 *
 * @return A canvas for drawing into the surface.
 *
 * @throws IllegalStateException If the canvas cannot be locked.
 */

Body of Frist Method:
{
    synchronized (mLock) {
        checkNotReleasedLocked();
        if (mHwuiContext == null) {
            mHwuiContext = new HwuiContext();
        }
        return mHwuiContext.lockCanvas(nativeGetWidth(mNativeObject), nativeGetHeight(mNativeObject));
    }
}
Body of Second Method:
{
    synchronized (mLock) {
        checkNotReleasedLocked();
        if (mHwuiContext == null) {
            mHwuiContext = new HwuiContext(false);
        }
        return mHwuiContext.lockCanvas(nativeGetWidth(mNativeObject), nativeGetHeight(mNativeObject));
    }
}
------------------------
Find a silently evolved API code:android.app.Instrumentation.execStartActivities:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Like {@link #execStartActivity(Context, IBinder, IBinder, Activity, Intent, int, Bundle)},
 * but accepts an array of activities to be started.  Note that active
 * {@link ActivityMonitor} objects only match against the first activity in
 * the array.
 *
 * {@hide}
 */

Body of Frist Method:
{
    execStartActivitiesAsUser(who, contextThread, token, target, intents, options, UserHandle.myUserId());
}
Body of Second Method:
{
    execStartActivitiesAsUser(who, contextThread, token, target, intents, options, who.getUserId());
}
------------------------
Find a silently evolved API code:android.net.NetworkTemplate.buildTemplateMobileAll:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Template to match {@link ConnectivityManager#TYPE_MOBILE} networks with
 * the given IMSI.
 */

Body of Frist Method:
{
    return new NetworkTemplate(MATCH_MOBILE_ALL, subscriberId, null);
}
Body of Second Method:
{
    return new NetworkTemplate(MATCH_MOBILE, subscriberId, null);
}
------------------------
Find a silently evolved API code:android.telephony.DisconnectCause.toString:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Returns descriptive string for the specified disconnect cause.
 */

Body of Frist Method:
{
    switch(cause) {
        case NOT_DISCONNECTED:
            return "NOT_DISCONNECTED";
        case INCOMING_MISSED:
            return "INCOMING_MISSED";
        case NORMAL:
            return "NORMAL";
        case LOCAL:
            return "LOCAL";
        case BUSY:
            return "BUSY";
        case CONGESTION:
            return "CONGESTION";
        case INVALID_NUMBER:
            return "INVALID_NUMBER";
        case NUMBER_UNREACHABLE:
            return "NUMBER_UNREACHABLE";
        case SERVER_UNREACHABLE:
            return "SERVER_UNREACHABLE";
        case INVALID_CREDENTIALS:
            return "INVALID_CREDENTIALS";
        case OUT_OF_NETWORK:
            return "OUT_OF_NETWORK";
        case SERVER_ERROR:
            return "SERVER_ERROR";
        case TIMED_OUT:
            return "TIMED_OUT";
        case LOST_SIGNAL:
            return "LOST_SIGNAL";
        case LIMIT_EXCEEDED:
            return "LIMIT_EXCEEDED";
        case INCOMING_REJECTED:
            return "INCOMING_REJECTED";
        case POWER_OFF:
            return "POWER_OFF";
        case OUT_OF_SERVICE:
            return "OUT_OF_SERVICE";
        case ICC_ERROR:
            return "ICC_ERROR";
        case CALL_BARRED:
            return "CALL_BARRED";
        case FDN_BLOCKED:
            return "FDN_BLOCKED";
        case CS_RESTRICTED:
            return "CS_RESTRICTED";
        case CS_RESTRICTED_NORMAL:
            return "CS_RESTRICTED_NORMAL";
        case CS_RESTRICTED_EMERGENCY:
            return "CS_RESTRICTED_EMERGENCY";
        case UNOBTAINABLE_NUMBER:
            return "UNOBTAINABLE_NUMBER";
        case CDMA_LOCKED_UNTIL_POWER_CYCLE:
            return "CDMA_LOCKED_UNTIL_POWER_CYCLE";
        case CDMA_DROP:
            return "CDMA_DROP";
        case CDMA_INTERCEPT:
            return "CDMA_INTERCEPT";
        case CDMA_REORDER:
            return "CDMA_REORDER";
        case CDMA_SO_REJECT:
            return "CDMA_SO_REJECT";
        case CDMA_RETRY_ORDER:
            return "CDMA_RETRY_ORDER";
        case CDMA_ACCESS_FAILURE:
            return "CDMA_ACCESS_FAILURE";
        case CDMA_PREEMPTED:
            return "CDMA_PREEMPTED";
        case CDMA_NOT_EMERGENCY:
            return "CDMA_NOT_EMERGENCY";
        case CDMA_ACCESS_BLOCKED:
            return "CDMA_ACCESS_BLOCKED";
        case EMERGENCY_ONLY:
            return "EMERGENCY_ONLY";
        case NO_PHONE_NUMBER_SUPPLIED:
            return "NO_PHONE_NUMBER_SUPPLIED";
        case DIALED_MMI:
            return "DIALED_MMI";
        case VOICEMAIL_NUMBER_MISSING:
            return "VOICEMAIL_NUMBER_MISSING";
        case CDMA_CALL_LOST:
            return "CDMA_CALL_LOST";
        case EXITED_ECM:
            return "EXITED_ECM";
        case DIAL_MODIFIED_TO_USSD:
            return "DIAL_MODIFIED_TO_USSD";
        case DIAL_MODIFIED_TO_SS:
            return "DIAL_MODIFIED_TO_SS";
        case DIAL_MODIFIED_TO_DIAL:
            return "DIAL_MODIFIED_TO_DIAL";
        case ERROR_UNSPECIFIED:
            return "ERROR_UNSPECIFIED";
        case OUTGOING_FAILURE:
            return "OUTGOING_FAILURE";
        case OUTGOING_CANCELED:
            return "OUTGOING_CANCELED";
        case IMS_MERGED_SUCCESSFULLY:
            return "IMS_MERGED_SUCCESSFULLY";
        case CDMA_ALREADY_ACTIVATED:
            return "CDMA_ALREADY_ACTIVATED";
        case VIDEO_CALL_NOT_ALLOWED_WHILE_TTY_ENABLED:
            return "VIDEO_CALL_NOT_ALLOWED_WHILE_TTY_ENABLED";
        case CALL_PULLED:
            return "CALL_PULLED";
        case ANSWERED_ELSEWHERE:
            return "ANSWERED_ELSEWHERE";
        case MAXIMUM_NUMBER_OF_CALLS_REACHED:
            return "MAXIMUM_NUMER_OF_CALLS_REACHED";
        case DATA_DISABLED:
            return "DATA_DISABLED";
        case DATA_LIMIT_REACHED:
            return "DATA_LIMIT_REACHED";
        case DIALED_ON_WRONG_SLOT:
            return "DIALED_ON_WRONG_SLOT";
        case DIALED_CALL_FORWARDING_WHILE_ROAMING:
            return "DIALED_CALL_FORWARDING_WHILE_ROAMING";
        case IMEI_NOT_ACCEPTED:
            return "IMEI_NOT_ACCEPTED";
        case WIFI_LOST:
            return "WIFI_LOST";
        case IMS_ACCESS_BLOCKED:
            return "IMS_ACCESS_BLOCKED";
        case LOW_BATTERY:
            return "LOW_BATTERY";
        case DIAL_LOW_BATTERY:
            return "DIAL_LOW_BATTERY";
        default:
            return "INVALID: " + cause;
    }
}
Body of Second Method:
{
    switch(cause) {
        case NOT_DISCONNECTED:
            return "NOT_DISCONNECTED";
        case INCOMING_MISSED:
            return "INCOMING_MISSED";
        case NORMAL:
            return "NORMAL";
        case LOCAL:
            return "LOCAL";
        case BUSY:
            return "BUSY";
        case CONGESTION:
            return "CONGESTION";
        case INVALID_NUMBER:
            return "INVALID_NUMBER";
        case NUMBER_UNREACHABLE:
            return "NUMBER_UNREACHABLE";
        case SERVER_UNREACHABLE:
            return "SERVER_UNREACHABLE";
        case INVALID_CREDENTIALS:
            return "INVALID_CREDENTIALS";
        case OUT_OF_NETWORK:
            return "OUT_OF_NETWORK";
        case SERVER_ERROR:
            return "SERVER_ERROR";
        case TIMED_OUT:
            return "TIMED_OUT";
        case LOST_SIGNAL:
            return "LOST_SIGNAL";
        case LIMIT_EXCEEDED:
            return "LIMIT_EXCEEDED";
        case INCOMING_REJECTED:
            return "INCOMING_REJECTED";
        case POWER_OFF:
            return "POWER_OFF";
        case OUT_OF_SERVICE:
            return "OUT_OF_SERVICE";
        case ICC_ERROR:
            return "ICC_ERROR";
        case CALL_BARRED:
            return "CALL_BARRED";
        case FDN_BLOCKED:
            return "FDN_BLOCKED";
        case CS_RESTRICTED:
            return "CS_RESTRICTED";
        case CS_RESTRICTED_NORMAL:
            return "CS_RESTRICTED_NORMAL";
        case CS_RESTRICTED_EMERGENCY:
            return "CS_RESTRICTED_EMERGENCY";
        case UNOBTAINABLE_NUMBER:
            return "UNOBTAINABLE_NUMBER";
        case CDMA_LOCKED_UNTIL_POWER_CYCLE:
            return "CDMA_LOCKED_UNTIL_POWER_CYCLE";
        case CDMA_DROP:
            return "CDMA_DROP";
        case CDMA_INTERCEPT:
            return "CDMA_INTERCEPT";
        case CDMA_REORDER:
            return "CDMA_REORDER";
        case CDMA_SO_REJECT:
            return "CDMA_SO_REJECT";
        case CDMA_RETRY_ORDER:
            return "CDMA_RETRY_ORDER";
        case CDMA_ACCESS_FAILURE:
            return "CDMA_ACCESS_FAILURE";
        case CDMA_PREEMPTED:
            return "CDMA_PREEMPTED";
        case CDMA_NOT_EMERGENCY:
            return "CDMA_NOT_EMERGENCY";
        case CDMA_ACCESS_BLOCKED:
            return "CDMA_ACCESS_BLOCKED";
        case EMERGENCY_ONLY:
            return "EMERGENCY_ONLY";
        case NO_PHONE_NUMBER_SUPPLIED:
            return "NO_PHONE_NUMBER_SUPPLIED";
        case DIALED_MMI:
            return "DIALED_MMI";
        case VOICEMAIL_NUMBER_MISSING:
            return "VOICEMAIL_NUMBER_MISSING";
        case CDMA_CALL_LOST:
            return "CDMA_CALL_LOST";
        case EXITED_ECM:
            return "EXITED_ECM";
        case DIAL_MODIFIED_TO_USSD:
            return "DIAL_MODIFIED_TO_USSD";
        case DIAL_MODIFIED_TO_SS:
            return "DIAL_MODIFIED_TO_SS";
        case DIAL_MODIFIED_TO_DIAL:
            return "DIAL_MODIFIED_TO_DIAL";
        case DIAL_MODIFIED_TO_DIAL_VIDEO:
            return "DIAL_MODIFIED_TO_DIAL_VIDEO";
        case DIAL_VIDEO_MODIFIED_TO_SS:
            return "DIAL_VIDEO_MODIFIED_TO_SS";
        case DIAL_VIDEO_MODIFIED_TO_USSD:
            return "DIAL_VIDEO_MODIFIED_TO_USSD";
        case DIAL_VIDEO_MODIFIED_TO_DIAL:
            return "DIAL_VIDEO_MODIFIED_TO_DIAL";
        case DIAL_VIDEO_MODIFIED_TO_DIAL_VIDEO:
            return "DIAL_VIDEO_MODIFIED_TO_DIAL_VIDEO";
        case ERROR_UNSPECIFIED:
            return "ERROR_UNSPECIFIED";
        case OUTGOING_FAILURE:
            return "OUTGOING_FAILURE";
        case OUTGOING_CANCELED:
            return "OUTGOING_CANCELED";
        case IMS_MERGED_SUCCESSFULLY:
            return "IMS_MERGED_SUCCESSFULLY";
        case CDMA_ALREADY_ACTIVATED:
            return "CDMA_ALREADY_ACTIVATED";
        case VIDEO_CALL_NOT_ALLOWED_WHILE_TTY_ENABLED:
            return "VIDEO_CALL_NOT_ALLOWED_WHILE_TTY_ENABLED";
        case CALL_PULLED:
            return "CALL_PULLED";
        case ANSWERED_ELSEWHERE:
            return "ANSWERED_ELSEWHERE";
        case MAXIMUM_NUMBER_OF_CALLS_REACHED:
            return "MAXIMUM_NUMER_OF_CALLS_REACHED";
        case DATA_DISABLED:
            return "DATA_DISABLED";
        case DATA_LIMIT_REACHED:
            return "DATA_LIMIT_REACHED";
        case DIALED_CALL_FORWARDING_WHILE_ROAMING:
            return "DIALED_CALL_FORWARDING_WHILE_ROAMING";
        case IMEI_NOT_ACCEPTED:
            return "IMEI_NOT_ACCEPTED";
        case WIFI_LOST:
            return "WIFI_LOST";
        case IMS_ACCESS_BLOCKED:
            return "IMS_ACCESS_BLOCKED";
        case LOW_BATTERY:
            return "LOW_BATTERY";
        case DIAL_LOW_BATTERY:
            return "DIAL_LOW_BATTERY";
        case EMERGENCY_TEMP_FAILURE:
            return "EMERGENCY_TEMP_FAILURE";
        case EMERGENCY_PERM_FAILURE:
            return "EMERGENCY_PERM_FAILURE";
        case NORMAL_UNSPECIFIED:
            return "NORMAL_UNSPECIFIED";
        case IMS_SIP_ALTERNATE_EMERGENCY_CALL:
            return "IMS_SIP_ALTERNATE_EMERGENCY_CALL";
        default:
            return "INVALID: " + cause;
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.le.PeriodicAdvertisingReport.getSyncHandle:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns the synchronization handle.
 */

Body of Frist Method:
{
    return syncHandle;
}
Body of Second Method:
{
    return mSyncHandle;
}
------------------------
Find a silently evolved API code:android.net.TrafficStats.getTxBytes:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * {@hide}
 */

Body of Frist Method:
{
    return nativeGetIfaceStat(iface, TYPE_TX_BYTES);
}
Body of Second Method:
{
    try {
        return getStatsService().getIfaceStats(iface, TYPE_TX_BYTES);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.le.AdvertisingSet.setAdvertiserId:COMMENT
Method Modifier: default     
Comment:/* package */

Body of Frist Method:
{
    this.advertiserId = advertiserId;
}
Body of Second Method:
{
    mAdvertiserId = advertiserId;
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiScanner.ScanSettings.writeToParcel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Implement the Parcelable interface {@hide}
 */

Body of Frist Method:
{
    dest.writeInt(band);
    dest.writeInt(periodInMs);
    dest.writeInt(reportEvents);
    dest.writeInt(numBssidsPerScan);
    dest.writeInt(maxScansToCache);
    dest.writeInt(maxPeriodInMs);
    dest.writeInt(stepCount);
    dest.writeInt(isPnoScan ? 1 : 0);
    if (channels != null) {
        dest.writeInt(channels.length);
        for (int i = 0; i < channels.length; i++) {
            dest.writeInt(channels[i].frequency);
            dest.writeInt(channels[i].dwellTimeMS);
            dest.writeInt(channels[i].passive ? 1 : 0);
        }
    } else {
        dest.writeInt(0);
    }
    if (hiddenNetworks != null) {
        dest.writeInt(hiddenNetworks.length);
        for (int i = 0; i < hiddenNetworks.length; i++) {
            dest.writeString(hiddenNetworks[i].ssid);
        }
    } else {
        dest.writeInt(0);
    }
}
Body of Second Method:
{
    dest.writeInt(band);
    dest.writeInt(periodInMs);
    dest.writeInt(reportEvents);
    dest.writeInt(numBssidsPerScan);
    dest.writeInt(maxScansToCache);
    dest.writeInt(maxPeriodInMs);
    dest.writeInt(stepCount);
    dest.writeInt(isPnoScan ? 1 : 0);
    dest.writeInt(type);
    if (channels != null) {
        dest.writeInt(channels.length);
        for (int i = 0; i < channels.length; i++) {
            dest.writeInt(channels[i].frequency);
            dest.writeInt(channels[i].dwellTimeMS);
            dest.writeInt(channels[i].passive ? 1 : 0);
        }
    } else {
        dest.writeInt(0);
    }
    if (hiddenNetworks != null) {
        dest.writeInt(hiddenNetworks.length);
        for (int i = 0; i < hiddenNetworks.length; i++) {
            dest.writeString(hiddenNetworks[i].ssid);
        }
    } else {
        dest.writeInt(0);
    }
}
------------------------
Find a silently evolved API code:android.text.format.Formatter.formatShortFileSize:COMMENT
Method Modifier: public      static      
Comment:/**
 * Like {@link #formatFileSize}, but trying to generate shorter numbers
 * (showing fewer digits of precision).
 */

Body of Frist Method:
{
    return formatFileSize(context, sizeBytes, FLAG_SHORTER);
}
Body of Second Method:
{
    if (context == null) {
        return "";
    }
    final BytesResult res = formatBytes(context.getResources(), sizeBytes, FLAG_SI_UNITS | FLAG_SHORTER);
    return bidiWrap(context, context.getString(com.android.internal.R.string.fileSizeSuffix, res.value, res.units));
}
------------------------
Find a silently evolved API code:android.telephony.SignalStrength.equals:COMMENT
Method Modifier: public      
Comment:/**
 * @return true if the signal strengths are the same
 */

Body of Frist Method:
{
    SignalStrength s;
    try {
        s = (SignalStrength) o;
    } catch (ClassCastException ex) {
        return false;
    }
    if (o == null) {
        return false;
    }
    return (mGsmSignalStrength == s.mGsmSignalStrength && mGsmBitErrorRate == s.mGsmBitErrorRate && mCdmaDbm == s.mCdmaDbm && mCdmaEcio == s.mCdmaEcio && mEvdoDbm == s.mEvdoDbm && mEvdoEcio == s.mEvdoEcio && mEvdoSnr == s.mEvdoSnr && mLteSignalStrength == s.mLteSignalStrength && mLteRsrp == s.mLteRsrp && mLteRsrq == s.mLteRsrq && mLteRssnr == s.mLteRssnr && mLteCqi == s.mLteCqi && mLteRsrpBoost == s.mLteRsrpBoost && mTdScdmaRscp == s.mTdScdmaRscp && isGsm == s.isGsm);
}
Body of Second Method:
{
    SignalStrength s;
    try {
        s = (SignalStrength) o;
    } catch (ClassCastException ex) {
        return false;
    }
    if (o == null) {
        return false;
    }
    return (mGsmSignalStrength == s.mGsmSignalStrength && mGsmBitErrorRate == s.mGsmBitErrorRate && mCdmaDbm == s.mCdmaDbm && mCdmaEcio == s.mCdmaEcio && mEvdoDbm == s.mEvdoDbm && mEvdoEcio == s.mEvdoEcio && mEvdoSnr == s.mEvdoSnr && mLteSignalStrength == s.mLteSignalStrength && mLteRsrp == s.mLteRsrp && mLteRsrq == s.mLteRsrq && mLteRssnr == s.mLteRssnr && mLteCqi == s.mLteCqi && mLteRsrpBoost == s.mLteRsrpBoost && mTdScdmaRscp == s.mTdScdmaRscp && mWcdmaSignalStrength == s.mWcdmaSignalStrength && mWcdmaRscpAsu == s.mWcdmaRscpAsu && mWcdmaRscp == s.mWcdmaRscp && mIsGsm == s.mIsGsm && mUseOnlyRsrpForLteLevel == s.mUseOnlyRsrpForLteLevel && Objects.equals(mWcdmaDefaultSignalMeasurement, s.mWcdmaDefaultSignalMeasurement) && Arrays.equals(mLteRsrpThresholds, s.mLteRsrpThresholds) && Arrays.equals(mWcdmaRscpThresholds, s.mWcdmaRscpThresholds));
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothUuid.containsAnyUuid:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Returns true if there any common ParcelUuids in uuidA and uuidB.
 *
 * @param uuidA - List of ParcelUuids
 * @param uuidB - List of ParcelUuids
 */

Body of Frist Method:
{
    if (uuidA == null && uuidB == null)
        return true;
    if (uuidA == null) {
        return uuidB.length == 0 ? true : false;
    }
    if (uuidB == null) {
        return uuidA.length == 0 ? true : false;
    }
    HashSet<ParcelUuid> uuidSet = new HashSet<ParcelUuid>(Arrays.asList(uuidA));
    for (ParcelUuid uuid : uuidB) {
        if (uuidSet.contains(uuid))
            return true;
    }
    return false;
}
Body of Second Method:
{
    if (uuidA == null && uuidB == null)
        return true;
    if (uuidA == null) {
        return uuidB.length == 0;
    }
    if (uuidB == null) {
        return uuidA.length == 0;
    }
    HashSet<ParcelUuid> uuidSet = new HashSet<ParcelUuid>(Arrays.asList(uuidA));
    for (ParcelUuid uuid : uuidB) {
        if (uuidSet.contains(uuid))
            return true;
    }
    return false;
}
------------------------
Find a silently evolved API code:android.content.ContentResolver.getSyncAdapterTypes:COMMENT
Method Modifier: public      static      
Comment:/**
 * Get information about the SyncAdapters that are known to the system.
 * @return an array of SyncAdapters that have registered with the system
 */

Body of Frist Method:
{
    try {
        return getContentService().getSyncAdapterTypes();
    } catch (RemoteException e) {
        throw new RuntimeException("the ContentService should always be reachable", e);
    }
}
Body of Second Method:
{
    try {
        return getContentService().getSyncAdapterTypes();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.webkit.WebViewUpdateService.getAllWebViewPackages:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Fetch all packages that could potentially implement WebView.
 */

Body of Frist Method:
{
    try {
        return getUpdateService().getAllWebViewPackages();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    IWebViewUpdateService service = getUpdateService();
    if (service == null) {
        return new WebViewProviderInfo[0];
    }
    try {
        return service.getAllWebViewPackages();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.aware.PublishConfig.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Build {@link PublishConfig} given the current requests made on the
 * builder.
 */

Body of Frist Method:
{
    return new PublishConfig(mServiceName, mServiceSpecificInfo, mMatchFilter, mPublishType, mTtlSec, mEnableTerminateNotification);
}
Body of Second Method:
{
    return new PublishConfig(mServiceName, mServiceSpecificInfo, mMatchFilter, mPublishType, mTtlSec, mEnableTerminateNotification, mEnableRanging);
}
------------------------
Find a silently evolved API code:android.net.TrafficStats.getTotalRxPackets:COMMENT
Method Modifier: public      static      
Comment:/**
 * Return number of packets received since device boot. Counts packets
 * across all network interfaces, and always increases monotonically since
 * device boot. Statistics are measured at the network layer, so they
 * include both TCP and UDP usage.
 * <p>
 * Before {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}, this may
 * return {@link #UNSUPPORTED} on devices where statistics aren't available.
 */

Body of Frist Method:
{
    return nativeGetTotalStat(TYPE_RX_PACKETS);
}
Body of Second Method:
{
    try {
        return getStatsService().getTotalStats(TYPE_RX_PACKETS);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.hardware.camera2.CaptureRequest.getProtected:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * {@inheritDoc}
 * @hide
 */

Body of Frist Method:
{
    return (T) mSettings.get(key);
}
Body of Second Method:
{
    return (T) mLogicalCameraSettings.get(key);
}
------------------------
Find a silently evolved API code:android.app.admin.DeviceAdminInfo.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Used to package this object into a {@link Parcel}.
 *
 * @param dest The {@link Parcel} to be written.
 * @param flags The flags used for parceling.
 */

Body of Frist Method:
{
    mActivityInfo.writeToParcel(dest, flags);
    dest.writeInt(mUsesPolicies);
}
Body of Second Method:
{
    mActivityInfo.writeToParcel(dest, flags);
    dest.writeInt(mUsesPolicies);
    dest.writeBoolean(mSupportsTransferOwnership);
}
------------------------
Find a silently evolved API code:android.net.wifi.aware.SubscribeConfig.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Build {@link SubscribeConfig} given the current requests made on the
 * builder.
 */

Body of Frist Method:
{
    return new SubscribeConfig(mServiceName, mServiceSpecificInfo, mMatchFilter, mSubscribeType, mTtlSec, mEnableTerminateNotification);
}
Body of Second Method:
{
    return new SubscribeConfig(mServiceName, mServiceSpecificInfo, mMatchFilter, mSubscribeType, mTtlSec, mEnableTerminateNotification, mMinDistanceMmSet, mMinDistanceMm, mMaxDistanceMmSet, mMaxDistanceMm);
}
------------------------
Find a silently evolved API code:android.database.sqlite.SQLiteConnectionPool.dump:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Dumps debugging information about this connection pool.
 *
 * @param printer The printer to receive the dump, not null.
 * @param verbose True to dump more verbose information.
 */

Body of Frist Method:
{
    Printer indentedPrinter = PrefixPrinter.create(printer, "    ");
    synchronized (mLock) {
        printer.println("Connection pool for " + mConfiguration.path + ":");
        printer.println("  Open: " + mIsOpen);
        printer.println("  Max connections: " + mMaxConnectionPoolSize);
        if (mConfiguration.isLookasideConfigSet()) {
            printer.println("  Lookaside config: sz=" + mConfiguration.lookasideSlotSize + " cnt=" + mConfiguration.lookasideSlotCount);
        }
        if (mConfiguration.idleConnectionTimeoutMs != Long.MAX_VALUE) {
            printer.println("  Idle connection timeout: " + mConfiguration.idleConnectionTimeoutMs);
        }
        printer.println("  Available primary connection:");
        if (mAvailablePrimaryConnection != null) {
            mAvailablePrimaryConnection.dump(indentedPrinter, verbose);
        } else {
            indentedPrinter.println("<none>");
        }
        printer.println("  Available non-primary connections:");
        if (!mAvailableNonPrimaryConnections.isEmpty()) {
            final int count = mAvailableNonPrimaryConnections.size();
            for (int i = 0; i < count; i++) {
                mAvailableNonPrimaryConnections.get(i).dump(indentedPrinter, verbose);
            }
        } else {
            indentedPrinter.println("<none>");
        }
        printer.println("  Acquired connections:");
        if (!mAcquiredConnections.isEmpty()) {
            for (Map.Entry<SQLiteConnection, AcquiredConnectionStatus> entry : mAcquiredConnections.entrySet()) {
                final SQLiteConnection connection = entry.getKey();
                connection.dumpUnsafe(indentedPrinter, verbose);
                indentedPrinter.println("  Status: " + entry.getValue());
            }
        } else {
            indentedPrinter.println("<none>");
        }
        printer.println("  Connection waiters:");
        if (mConnectionWaiterQueue != null) {
            int i = 0;
            final long now = SystemClock.uptimeMillis();
            for (ConnectionWaiter waiter = mConnectionWaiterQueue; waiter != null; waiter = waiter.mNext, i++) {
                indentedPrinter.println(i + ": waited for " + ((now - waiter.mStartTime) * 0.001f) + " ms - thread=" + waiter.mThread + ", priority=" + waiter.mPriority + ", sql='" + waiter.mSql + "'");
            }
        } else {
            indentedPrinter.println("<none>");
        }
    }
}
Body of Second Method:
{
    Printer indentedPrinter = PrefixPrinter.create(printer, "    ");
    synchronized (mLock) {
        printer.println("Connection pool for " + mConfiguration.path + ":");
        printer.println("  Open: " + mIsOpen);
        printer.println("  Max connections: " + mMaxConnectionPoolSize);
        printer.println("  Total execution time: " + mTotalExecutionTimeCounter);
        printer.println("  Configuration: openFlags=" + mConfiguration.openFlags + ", useCompatibilityWal=" + mConfiguration.useCompatibilityWal() + ", journalMode=" + TextUtils.emptyIfNull(mConfiguration.journalMode) + ", syncMode=" + TextUtils.emptyIfNull(mConfiguration.syncMode));
        if (SQLiteCompatibilityWalFlags.areFlagsSet()) {
            printer.println("  Compatibility WAL settings: compatibility_wal_supported=" + SQLiteCompatibilityWalFlags.isCompatibilityWalSupported() + ", wal_syncmode=" + SQLiteCompatibilityWalFlags.getWALSyncMode());
        }
        if (mConfiguration.isLookasideConfigSet()) {
            printer.println("  Lookaside config: sz=" + mConfiguration.lookasideSlotSize + " cnt=" + mConfiguration.lookasideSlotCount);
        }
        if (mConfiguration.idleConnectionTimeoutMs != Long.MAX_VALUE) {
            printer.println("  Idle connection timeout: " + mConfiguration.idleConnectionTimeoutMs);
        }
        printer.println("  Available primary connection:");
        if (mAvailablePrimaryConnection != null) {
            mAvailablePrimaryConnection.dump(indentedPrinter, verbose);
        } else {
            indentedPrinter.println("<none>");
        }
        printer.println("  Available non-primary connections:");
        if (!mAvailableNonPrimaryConnections.isEmpty()) {
            final int count = mAvailableNonPrimaryConnections.size();
            for (int i = 0; i < count; i++) {
                mAvailableNonPrimaryConnections.get(i).dump(indentedPrinter, verbose);
            }
        } else {
            indentedPrinter.println("<none>");
        }
        printer.println("  Acquired connections:");
        if (!mAcquiredConnections.isEmpty()) {
            for (Map.Entry<SQLiteConnection, AcquiredConnectionStatus> entry : mAcquiredConnections.entrySet()) {
                final SQLiteConnection connection = entry.getKey();
                connection.dumpUnsafe(indentedPrinter, verbose);
                indentedPrinter.println("  Status: " + entry.getValue());
            }
        } else {
            indentedPrinter.println("<none>");
        }
        printer.println("  Connection waiters:");
        if (mConnectionWaiterQueue != null) {
            int i = 0;
            final long now = SystemClock.uptimeMillis();
            for (ConnectionWaiter waiter = mConnectionWaiterQueue; waiter != null; waiter = waiter.mNext, i++) {
                indentedPrinter.println(i + ": waited for " + ((now - waiter.mStartTime) * 0.001f) + " ms - thread=" + waiter.mThread + ", priority=" + waiter.mPriority + ", sql='" + waiter.mSql + "'");
            }
        } else {
            indentedPrinter.println("<none>");
        }
    }
}
------------------------
Find a silently evolved API code:android.view.textclassifier.logging.SmartSelectionEventTracker.logEvent:COMMENT
Method Modifier: public      
Comment:/**
 * Logs a selection event.
 *
 * @param event the selection event
 */

Body of Frist Method:
{
    Preconditions.checkNotNull(event);
    if (event.mEventType != SelectionEvent.EventType.SELECTION_STARTED && mSessionId == null && DEBUG_LOG_ENABLED) {
        Log.d(LOG_TAG, "Selection session not yet started. Ignoring event");
        return;
    }
    final long now = System.currentTimeMillis();
    switch(event.mEventType) {
        case SelectionEvent.EventType.SELECTION_STARTED:
            mSessionId = startNewSession();
            Preconditions.checkArgument(event.mEnd == event.mStart + 1);
            mOrigStart = event.mStart;
            mSessionStartTime = now;
            break;
        // fall through
        case SelectionEvent.EventType.SMART_SELECTION_SINGLE:
        case SelectionEvent.EventType.SMART_SELECTION_MULTI:
            mSmartSelectionTriggered = true;
            mVersionTag = getVersionTag(event);
            mSmartIndices[0] = event.mStart;
            mSmartIndices[1] = event.mEnd;
            break;
        // fall through
        case SelectionEvent.EventType.SELECTION_MODIFIED:
        case SelectionEvent.EventType.AUTO_SELECTION:
            if (mPrevIndices[0] == event.mStart && mPrevIndices[1] == event.mEnd) {
                // Selection did not change. Ignore event.
                return;
            }
    }
    writeEvent(event, now);
    if (event.isTerminal()) {
        endSession();
    }
}
Body of Second Method:
{
    Preconditions.checkNotNull(event);
    if (event.mEventType != SelectionEvent.EventType.SELECTION_STARTED && mSessionId == null && DEBUG_LOG_ENABLED) {
        Log.d(LOG_TAG, "Selection session not yet started. Ignoring event");
        return;
    }
    final long now = System.currentTimeMillis();
    switch(event.mEventType) {
        case SelectionEvent.EventType.SELECTION_STARTED:
            mSessionId = startNewSession();
            Preconditions.checkArgument(event.mEnd == event.mStart + 1);
            mOrigStart = event.mStart;
            mSessionStartTime = now;
            break;
        // fall through
        case SelectionEvent.EventType.SMART_SELECTION_SINGLE:
        case SelectionEvent.EventType.SMART_SELECTION_MULTI:
            mSmartSelectionTriggered = true;
            mModelName = getModelName(event);
            mSmartIndices[0] = event.mStart;
            mSmartIndices[1] = event.mEnd;
            break;
        // fall through
        case SelectionEvent.EventType.SELECTION_MODIFIED:
        case SelectionEvent.EventType.AUTO_SELECTION:
            if (mPrevIndices[0] == event.mStart && mPrevIndices[1] == event.mEnd) {
                // Selection did not change. Ignore event.
                return;
            }
    }
    writeEvent(event, now);
    if (event.isTerminal()) {
        endSession();
    }
}
------------------------
Find a silently evolved API code:android.app.admin.DeviceAdminReceiver.onReceive:COMMENT
Method Modifier: public      
Comment:/**
 * Intercept standard device administrator broadcasts.  Implementations
 * should not override this method; it is better to implement the
 * convenience callbacks for each action.
 */

Body of Frist Method:
{
    String action = intent.getAction();
    if (ACTION_PASSWORD_CHANGED.equals(action)) {
        onPasswordChanged(context, intent, intent.getParcelableExtra(Intent.EXTRA_USER));
    } else if (ACTION_PASSWORD_FAILED.equals(action)) {
        onPasswordFailed(context, intent, intent.getParcelableExtra(Intent.EXTRA_USER));
    } else if (ACTION_PASSWORD_SUCCEEDED.equals(action)) {
        onPasswordSucceeded(context, intent, intent.getParcelableExtra(Intent.EXTRA_USER));
    } else if (ACTION_DEVICE_ADMIN_ENABLED.equals(action)) {
        onEnabled(context, intent);
    } else if (ACTION_DEVICE_ADMIN_DISABLE_REQUESTED.equals(action)) {
        CharSequence res = onDisableRequested(context, intent);
        if (res != null) {
            Bundle extras = getResultExtras(true);
            extras.putCharSequence(EXTRA_DISABLE_WARNING, res);
        }
    } else if (ACTION_DEVICE_ADMIN_DISABLED.equals(action)) {
        onDisabled(context, intent);
    } else if (ACTION_PASSWORD_EXPIRING.equals(action)) {
        onPasswordExpiring(context, intent, intent.getParcelableExtra(Intent.EXTRA_USER));
    } else if (ACTION_PROFILE_PROVISIONING_COMPLETE.equals(action)) {
        onProfileProvisioningComplete(context, intent);
    } else if (ACTION_CHOOSE_PRIVATE_KEY_ALIAS.equals(action)) {
        int uid = intent.getIntExtra(EXTRA_CHOOSE_PRIVATE_KEY_SENDER_UID, -1);
        Uri uri = intent.getParcelableExtra(EXTRA_CHOOSE_PRIVATE_KEY_URI);
        String alias = intent.getStringExtra(EXTRA_CHOOSE_PRIVATE_KEY_ALIAS);
        String chosenAlias = onChoosePrivateKeyAlias(context, intent, uid, uri, alias);
        setResultData(chosenAlias);
    } else if (ACTION_LOCK_TASK_ENTERING.equals(action)) {
        String pkg = intent.getStringExtra(EXTRA_LOCK_TASK_PACKAGE);
        onLockTaskModeEntering(context, intent, pkg);
    } else if (ACTION_LOCK_TASK_EXITING.equals(action)) {
        onLockTaskModeExiting(context, intent);
    } else if (ACTION_NOTIFY_PENDING_SYSTEM_UPDATE.equals(action)) {
        long receivedTime = intent.getLongExtra(EXTRA_SYSTEM_UPDATE_RECEIVED_TIME, -1);
        onSystemUpdatePending(context, intent, receivedTime);
    } else if (ACTION_BUGREPORT_SHARING_DECLINED.equals(action)) {
        onBugreportSharingDeclined(context, intent);
    } else if (ACTION_BUGREPORT_SHARE.equals(action)) {
        String bugreportFileHash = intent.getStringExtra(EXTRA_BUGREPORT_HASH);
        onBugreportShared(context, intent, bugreportFileHash);
    } else if (ACTION_BUGREPORT_FAILED.equals(action)) {
        int failureCode = intent.getIntExtra(EXTRA_BUGREPORT_FAILURE_REASON, BUGREPORT_FAILURE_FAILED_COMPLETING);
        onBugreportFailed(context, intent, failureCode);
    } else if (ACTION_SECURITY_LOGS_AVAILABLE.equals(action)) {
        onSecurityLogsAvailable(context, intent);
    } else if (ACTION_NETWORK_LOGS_AVAILABLE.equals(action)) {
        long batchToken = intent.getLongExtra(EXTRA_NETWORK_LOGS_TOKEN, -1);
        int networkLogsCount = intent.getIntExtra(EXTRA_NETWORK_LOGS_COUNT, 0);
        onNetworkLogsAvailable(context, intent, batchToken, networkLogsCount);
    } else if (ACTION_USER_ADDED.equals(action)) {
        onUserAdded(context, intent, intent.getParcelableExtra(Intent.EXTRA_USER));
    } else if (ACTION_USER_REMOVED.equals(action)) {
        onUserRemoved(context, intent, intent.getParcelableExtra(Intent.EXTRA_USER));
    }
}
Body of Second Method:
{
    String action = intent.getAction();
    if (ACTION_PASSWORD_CHANGED.equals(action)) {
        onPasswordChanged(context, intent, intent.getParcelableExtra(Intent.EXTRA_USER));
    } else if (ACTION_PASSWORD_FAILED.equals(action)) {
        onPasswordFailed(context, intent, intent.getParcelableExtra(Intent.EXTRA_USER));
    } else if (ACTION_PASSWORD_SUCCEEDED.equals(action)) {
        onPasswordSucceeded(context, intent, intent.getParcelableExtra(Intent.EXTRA_USER));
    } else if (ACTION_DEVICE_ADMIN_ENABLED.equals(action)) {
        onEnabled(context, intent);
    } else if (ACTION_DEVICE_ADMIN_DISABLE_REQUESTED.equals(action)) {
        CharSequence res = onDisableRequested(context, intent);
        if (res != null) {
            Bundle extras = getResultExtras(true);
            extras.putCharSequence(EXTRA_DISABLE_WARNING, res);
        }
    } else if (ACTION_DEVICE_ADMIN_DISABLED.equals(action)) {
        onDisabled(context, intent);
    } else if (ACTION_PASSWORD_EXPIRING.equals(action)) {
        onPasswordExpiring(context, intent, intent.getParcelableExtra(Intent.EXTRA_USER));
    } else if (ACTION_PROFILE_PROVISIONING_COMPLETE.equals(action)) {
        onProfileProvisioningComplete(context, intent);
    } else if (ACTION_CHOOSE_PRIVATE_KEY_ALIAS.equals(action)) {
        int uid = intent.getIntExtra(EXTRA_CHOOSE_PRIVATE_KEY_SENDER_UID, -1);
        Uri uri = intent.getParcelableExtra(EXTRA_CHOOSE_PRIVATE_KEY_URI);
        String alias = intent.getStringExtra(EXTRA_CHOOSE_PRIVATE_KEY_ALIAS);
        String chosenAlias = onChoosePrivateKeyAlias(context, intent, uid, uri, alias);
        setResultData(chosenAlias);
    } else if (ACTION_LOCK_TASK_ENTERING.equals(action)) {
        String pkg = intent.getStringExtra(EXTRA_LOCK_TASK_PACKAGE);
        onLockTaskModeEntering(context, intent, pkg);
    } else if (ACTION_LOCK_TASK_EXITING.equals(action)) {
        onLockTaskModeExiting(context, intent);
    } else if (ACTION_NOTIFY_PENDING_SYSTEM_UPDATE.equals(action)) {
        long receivedTime = intent.getLongExtra(EXTRA_SYSTEM_UPDATE_RECEIVED_TIME, -1);
        onSystemUpdatePending(context, intent, receivedTime);
    } else if (ACTION_BUGREPORT_SHARING_DECLINED.equals(action)) {
        onBugreportSharingDeclined(context, intent);
    } else if (ACTION_BUGREPORT_SHARE.equals(action)) {
        String bugreportFileHash = intent.getStringExtra(EXTRA_BUGREPORT_HASH);
        onBugreportShared(context, intent, bugreportFileHash);
    } else if (ACTION_BUGREPORT_FAILED.equals(action)) {
        int failureCode = intent.getIntExtra(EXTRA_BUGREPORT_FAILURE_REASON, BUGREPORT_FAILURE_FAILED_COMPLETING);
        onBugreportFailed(context, intent, failureCode);
    } else if (ACTION_SECURITY_LOGS_AVAILABLE.equals(action)) {
        onSecurityLogsAvailable(context, intent);
    } else if (ACTION_NETWORK_LOGS_AVAILABLE.equals(action)) {
        long batchToken = intent.getLongExtra(EXTRA_NETWORK_LOGS_TOKEN, -1);
        int networkLogsCount = intent.getIntExtra(EXTRA_NETWORK_LOGS_COUNT, 0);
        onNetworkLogsAvailable(context, intent, batchToken, networkLogsCount);
    } else if (ACTION_USER_ADDED.equals(action)) {
        onUserAdded(context, intent, intent.getParcelableExtra(Intent.EXTRA_USER));
    } else if (ACTION_USER_REMOVED.equals(action)) {
        onUserRemoved(context, intent, intent.getParcelableExtra(Intent.EXTRA_USER));
    } else if (ACTION_USER_STARTED.equals(action)) {
        onUserStarted(context, intent, intent.getParcelableExtra(Intent.EXTRA_USER));
    } else if (ACTION_USER_STOPPED.equals(action)) {
        onUserStopped(context, intent, intent.getParcelableExtra(Intent.EXTRA_USER));
    } else if (ACTION_USER_SWITCHED.equals(action)) {
        onUserSwitched(context, intent, intent.getParcelableExtra(Intent.EXTRA_USER));
    } else if (ACTION_TRANSFER_OWNERSHIP_COMPLETE.equals(action)) {
        PersistableBundle bundle = intent.getParcelableExtra(EXTRA_TRANSFER_OWNERSHIP_ADMIN_EXTRAS_BUNDLE);
        onTransferOwnershipComplete(context, bundle);
    } else if (ACTION_AFFILIATED_PROFILE_TRANSFER_OWNERSHIP_COMPLETE.equals(action)) {
        onTransferAffiliatedProfileOwnershipComplete(context, intent.getParcelableExtra(Intent.EXTRA_USER));
    }
}
------------------------
Find a silently evolved API code:android.database.sqlite.SQLiteOpenHelper.setWriteAheadLoggingEnabled:COMMENT
Method Modifier: public      
Comment:/**
 * Enables or disables the use of write-ahead logging for the database.
 *
 * Write-ahead logging cannot be used with read-only databases so the value of
 * this flag is ignored if the database is opened read-only.
 *
 * @param enabled True if write-ahead logging should be enabled, false if it
 * should be disabled.
 *
 * @see SQLiteDatabase#enableWriteAheadLogging()
 */

Body of Frist Method:
{
    synchronized (this) {
        if (mOpenParamsBuilder.isWriteAheadLoggingEnabled() != enabled) {
            if (mDatabase != null && mDatabase.isOpen() && !mDatabase.isReadOnly()) {
                if (enabled) {
                    mDatabase.enableWriteAheadLogging();
                } else {
                    mDatabase.disableWriteAheadLogging();
                }
            }
            mOpenParamsBuilder.setWriteAheadLoggingEnabled(enabled);
        }
    }
}
Body of Second Method:
{
    synchronized (this) {
        if (mOpenParamsBuilder.isWriteAheadLoggingEnabled() != enabled) {
            if (mDatabase != null && mDatabase.isOpen() && !mDatabase.isReadOnly()) {
                if (enabled) {
                    mDatabase.enableWriteAheadLogging();
                } else {
                    mDatabase.disableWriteAheadLogging();
                }
            }
            mOpenParamsBuilder.setWriteAheadLoggingEnabled(enabled);
        }
        // Compatibility WAL is disabled if an app disables or enables WAL
        mOpenParamsBuilder.addOpenFlags(SQLiteDatabase.DISABLE_COMPATIBILITY_WAL);
    }
}
------------------------
Find a silently evolved API code:android.content.res.TypedArray.getTextArray:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the CharSequence[] for the attribute at <var>index</var>.
 * This gets the resource ID of the selected attribute, and uses
 * {@link Resources#getTextArray Resources.getTextArray} of the owning
 * Resources object to retrieve its String[].
 * <p>
 * This method will throw an exception if the attribute is defined but is
 * not a text array resource.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return CharSequence[] for the attribute, or {@code null} if not
 * defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 */

Body of Frist Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    final TypedValue value = mValue;
    if (getValueAt(index * AssetManager.STYLE_NUM_ENTRIES, value)) {
        return mResources.getTextArray(value.resourceId);
    }
    return null;
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    final TypedValue value = mValue;
    if (getValueAt(index * STYLE_NUM_ENTRIES, value)) {
        return mResources.getTextArray(value.resourceId);
    }
    return null;
}
------------------------
Find a silently evolved API code:android.media.AudioFocusRequest.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Builds a new {@code AudioFocusRequest} instance combining all the information gathered
 * by this {@code Builder}'s configuration methods.
 * @return the {@code AudioFocusRequest} instance qualified by all the properties set
 * on this {@code Builder}.
 * @throws IllegalStateException thrown when attempting to build a focus request that is set
 * to accept delayed focus, or to pause on duck, but no focus change listener was set.
 */

Body of Frist Method:
{
    if ((mDelayedFocus || mPausesOnDuck) && (mFocusListener == null)) {
        throw new IllegalStateException("Can't use delayed focus or pause on duck without a listener");
    }
    final int flags = 0 | (mDelayedFocus ? AudioManager.AUDIOFOCUS_FLAG_DELAY_OK : 0) | (mPausesOnDuck ? AudioManager.AUDIOFOCUS_FLAG_PAUSES_ON_DUCKABLE_LOSS : 0) | (mFocusLocked ? AudioManager.AUDIOFOCUS_FLAG_LOCK : 0);
    return new AudioFocusRequest(mFocusListener, mListenerHandler, mAttr, mFocusGain, flags);
}
Body of Second Method:
{
    if ((mDelayedFocus || mPausesOnDuck) && (mFocusListener == null)) {
        throw new IllegalStateException("Can't use delayed focus or pause on duck without a listener");
    }
    if (mA11yForceDucking) {
        final Bundle extraInfo;
        if (mAttr.getBundle() == null) {
            extraInfo = new Bundle();
        } else {
            extraInfo = mAttr.getBundle();
        }
        // checking of usage and focus request is done server side
        extraInfo.putBoolean(KEY_ACCESSIBILITY_FORCE_FOCUS_DUCKING, true);
        mAttr = new AudioAttributes.Builder(mAttr).addBundle(extraInfo).build();
    }
    final int flags = 0 | (mDelayedFocus ? AudioManager.AUDIOFOCUS_FLAG_DELAY_OK : 0) | (mPausesOnDuck ? AudioManager.AUDIOFOCUS_FLAG_PAUSES_ON_DUCKABLE_LOSS : 0) | (mFocusLocked ? AudioManager.AUDIOFOCUS_FLAG_LOCK : 0);
    return new AudioFocusRequest(mFocusListener, mListenerHandler, mAttr, mFocusGain, flags);
}
------------------------
Find a silently evolved API code:android.media.session.MediaController.TransportControls.playFromMediaId:COMMENT
Method Modifier: public      
Comment:/**
 * Request that the player start playback for a specific media id.
 *
 * @param mediaId The id of the requested media.
 * @param extras Optional extras that can include extra information about the media item
 * to be played.
 */

Body of Frist Method:
{
    if (TextUtils.isEmpty(mediaId)) {
        throw new IllegalArgumentException("You must specify a non-empty String for playFromMediaId.");
    }
    try {
        mSessionBinder.playFromMediaId(mediaId, extras);
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling play(" + mediaId + ").", e);
    }
}
Body of Second Method:
{
    if (TextUtils.isEmpty(mediaId)) {
        throw new IllegalArgumentException("You must specify a non-empty String for playFromMediaId.");
    }
    try {
        mSessionBinder.playFromMediaId(mContext.getPackageName(), mCbStub, mediaId, extras);
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling play(" + mediaId + ").", e);
    }
}
------------------------
Find a silently evolved API code:android.graphics.drawable.RippleDrawable.draw:COMMENT
Method Modifier: public      
Comment:/**
 * Optimized for drawing ripples with a mask layer and optional content.
 */

Body of Frist Method:
{
    pruneRipples();
    // Clip to the dirty bounds, which will be the drawable bounds if we
    // have a mask or content and the ripple bounds if we're projecting.
    final Rect bounds = getDirtyBounds();
    final int saveCount = canvas.save(Canvas.CLIP_SAVE_FLAG);
    canvas.clipRect(bounds);
    drawContent(canvas);
    drawBackgroundAndRipples(canvas);
    canvas.restoreToCount(saveCount);
}
Body of Second Method:
{
    pruneRipples();
    // Clip to the dirty bounds, which will be the drawable bounds if we
    // have a mask or content and the ripple bounds if we're projecting.
    final Rect bounds = getDirtyBounds();
    final int saveCount = canvas.save(Canvas.CLIP_SAVE_FLAG);
    if (isBounded()) {
        canvas.clipRect(bounds);
    }
    drawContent(canvas);
    drawBackgroundAndRipples(canvas);
    canvas.restoreToCount(saveCount);
}
------------------------
Find a silently evolved API code:android.content.ContentResolver.getPeriodicSyncs:COMMENT
Method Modifier: public      static      
Comment:/**
 * Get the list of information about the periodic syncs for the given account and authority.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#READ_SYNC_SETTINGS}.
 *
 * @param account the account whose periodic syncs we are querying
 * @param authority the provider whose periodic syncs we are querying
 * @return a list of PeriodicSync objects. This list may be empty but will never be null.
 */

Body of Frist Method:
{
    try {
        return getContentService().getPeriodicSyncs(account, authority, null);
    } catch (RemoteException e) {
        throw new RuntimeException("the ContentService should always be reachable", e);
    }
}
Body of Second Method:
{
    try {
        return getContentService().getPeriodicSyncs(account, authority, null);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothGattService.setDevice:COMMENT
Method Modifier: default     
Comment:/*package*/

Body of Frist Method:
{
    this.mDevice = device;
}
Body of Second Method:
{
    mDevice = device;
}
------------------------
Find a silently evolved API code:android.service.trust.TrustAgentService.unlockUserWithToken:COMMENT
Method Modifier: public      final       hidden      
Comment:/**
 * Call to unlock user's FBE.
 *
 * @param handle the handle of escrow tokent to the internal synthetic password.
 * @param token the escrow token
 * @param user the user about to be unlocked.
 */

Body of Frist Method:
{
    UserManager um = (UserManager) getSystemService(Context.USER_SERVICE);
    if (um.isUserUnlocked()) {
        Slog.i(TAG, "User already unlocked");
        return;
    }
    synchronized (mLock) {
        if (mCallback == null) {
            Slog.w(TAG, "Cannot add escrow token if the agent is not connecting to framework");
            throw new IllegalStateException("Trust agent is not connected");
        }
        try {
            mCallback.unlockUserWithToken(handle, token, user.getIdentifier());
        } catch (RemoteException e) {
            onError("calling unlockUserWithToken");
        }
    }
}
Body of Second Method:
{
    UserManager um = (UserManager) getSystemService(Context.USER_SERVICE);
    if (um.isUserUnlocked(user)) {
        Slog.i(TAG, "User already unlocked");
        return;
    }
    synchronized (mLock) {
        if (mCallback == null) {
            Slog.w(TAG, "Cannot add escrow token if the agent is not connecting to framework");
            throw new IllegalStateException("Trust agent is not connected");
        }
        try {
            mCallback.unlockUserWithToken(handle, token, user.getIdentifier());
        } catch (RemoteException e) {
            onError("calling unlockUserWithToken");
        }
    }
}
------------------------
Find a silently evolved API code:android.content.ContentResolver.setMasterSyncAutomaticallyAsUser:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @see #setMasterSyncAutomatically(boolean)
 * @hide
 */

Body of Frist Method:
{
    try {
        getContentService().setMasterSyncAutomaticallyAsUser(sync, userId);
    } catch (RemoteException e) {
    // exception ignored; if this is thrown then it means the runtime is in the midst of
    // being restarted
    }
}
Body of Second Method:
{
    try {
        getContentService().setMasterSyncAutomaticallyAsUser(sync, userId);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.webkit.WebViewUpdateService.getValidWebViewPackages:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Fetch all packages that could potentially implement WebView and are currently valid.
 */

Body of Frist Method:
{
    try {
        return getUpdateService().getValidWebViewPackages();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    IWebViewUpdateService service = getUpdateService();
    if (service == null) {
        return new WebViewProviderInfo[0];
    }
    try {
        return service.getValidWebViewPackages();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.telephony.CellSignalStrengthCdma.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Implement the Parcelable interface
 */

Body of Frist Method:
{
    if (DBG)
        log("writeToParcel(Parcel, int): " + toString());
    // Need to multiply CdmaDbm, CdmaEcio, EvdoDbm and EvdoEcio by -1
    // to ensure consistency when reading values written here
    // unless the value is invalid
    dest.writeInt(mCdmaDbm * (mCdmaDbm != Integer.MAX_VALUE ? -1 : 1));
    dest.writeInt(mCdmaEcio * (mCdmaEcio != Integer.MAX_VALUE ? -1 : 1));
    dest.writeInt(mEvdoDbm * (mEvdoDbm != Integer.MAX_VALUE ? -1 : 1));
    dest.writeInt(mEvdoEcio * (mEvdoEcio != Integer.MAX_VALUE ? -1 : 1));
    dest.writeInt(mEvdoSnr);
}
Body of Second Method:
{
    if (DBG)
        log("writeToParcel(Parcel, int): " + toString());
    dest.writeInt(mCdmaDbm);
    dest.writeInt(mCdmaEcio);
    dest.writeInt(mEvdoDbm);
    dest.writeInt(mEvdoEcio);
    dest.writeInt(mEvdoSnr);
}
------------------------
Find a silently evolved API code:android.bluetooth.le.AdvertisingSetParameters.getInterval:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the advertising interval.
 */

Body of Frist Method:
{
    return interval;
}
Body of Second Method:
{
    return mInterval;
}
------------------------
Find a silently evolved API code:android.nfc.cardemulation.NfcFCardEmulation.registerSystemCodeForService:COMMENT
Method Modifier: public      
Comment:/**
 * Registers a System Code for the specified service.
 *
 * <p>The System Code must be in range from "4000" to "4FFF" (excluding "4*FF").
 *
 * <p>If a System Code was previously registered for this service
 * (either statically through the manifest, or dynamically by using this API),
 * it will be replaced with this one.
 *
 * <p>Even if the same System Code is already registered for another service,
 * this method succeeds in registering the System Code.
 *
 * <p>Note that you can only register a System Code for a service that
 * is running under the same UID as the caller of this API. Typically
 * this means you need to call this from the same
 * package as the service itself, though UIDs can also
 * be shared between packages using shared UIDs.
 *
 * @param service The component name of the service
 * @param systemCode The System Code to be registered
 * @return whether the registration was successful.
 */

Body of Frist Method:
{
    if (service == null || systemCode == null) {
        throw new NullPointerException("service or systemCode is null");
    }
    try {
        return sService.registerSystemCodeForService(UserHandle.myUserId(), service, systemCode);
    } catch (RemoteException e) {
        // Try one more time
        recoverService();
        if (sService == null) {
            Log.e(TAG, "Failed to recover CardEmulationService.");
            return false;
        }
        try {
            return sService.registerSystemCodeForService(UserHandle.myUserId(), service, systemCode);
        } catch (RemoteException ee) {
            Log.e(TAG, "Failed to reach CardEmulationService.");
            ee.rethrowAsRuntimeException();
            return false;
        }
    }
}
Body of Second Method:
{
    if (service == null || systemCode == null) {
        throw new NullPointerException("service or systemCode is null");
    }
    try {
        return sService.registerSystemCodeForService(mContext.getUserId(), service, systemCode);
    } catch (RemoteException e) {
        // Try one more time
        recoverService();
        if (sService == null) {
            Log.e(TAG, "Failed to recover CardEmulationService.");
            return false;
        }
        try {
            return sService.registerSystemCodeForService(mContext.getUserId(), service, systemCode);
        } catch (RemoteException ee) {
            Log.e(TAG, "Failed to reach CardEmulationService.");
            ee.rethrowAsRuntimeException();
            return false;
        }
    }
}
------------------------
Find a silently evolved API code:android.app.WallpaperInfo.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Used to package this object into a {@link Parcel}.
 *
 * @param dest The {@link Parcel} to be written.
 * @param flags The flags used for parceling.
 */

Body of Frist Method:
{
    dest.writeString(mSettingsActivityName);
    dest.writeInt(mThumbnailResource);
    dest.writeInt(mAuthorResource);
    dest.writeInt(mDescriptionResource);
    dest.writeInt(mContextUriResource);
    dest.writeInt(mContextDescriptionResource);
    dest.writeInt(mShowMetadataInPreview ? 1 : 0);
    mService.writeToParcel(dest, flags);
}
Body of Second Method:
{
    dest.writeString(mSettingsActivityName);
    dest.writeInt(mThumbnailResource);
    dest.writeInt(mAuthorResource);
    dest.writeInt(mDescriptionResource);
    dest.writeInt(mContextUriResource);
    dest.writeInt(mContextDescriptionResource);
    dest.writeInt(mShowMetadataInPreview ? 1 : 0);
    dest.writeInt(mSupportsAmbientMode ? 1 : 0);
    mService.writeToParcel(dest, flags);
}
------------------------
Find a silently evolved API code:android.view.textclassifier.logging.SmartSelectionEventTracker.SelectionEvent.selectionAction:COMMENT
Method Modifier: public      static      
Comment:/**
 * Creates an event specifying an action taken on a selection.
 * Use when the user clicks on an action to act on the selected text and the selection's
 * entity type is known.
 *
 * @param start  the start word (inclusive) index of the selection
 * @param end  the end word (exclusive) index of the selection
 * @param actionType  the action that was performed on the selection
 * @param classification  the TextClassification object returned by the TextClassifier that
 * classified the selected text
 */

Body of Frist Method:
{
    final String entityType = classification.getEntityCount() > 0 ? classification.getEntity(0) : TextClassifier.TYPE_UNKNOWN;
    final String versionTag = classification.getVersionInfo();
    return new SelectionEvent(start, end, actionType, entityType, versionTag);
}
Body of Second Method:
{
    final String entityType = classification.getEntityCount() > 0 ? classification.getEntity(0) : TextClassifier.TYPE_UNKNOWN;
    final String versionTag = getVersionInfo(classification.getId());
    return new SelectionEvent(start, end, actionType, entityType, versionTag);
}
------------------------
Find a silently evolved API code:android.bluetooth.le.AdvertisingSet.setAdvertisingParameters:COMMENT
Method Modifier: public      
Comment:/**
 * Update advertising parameters associated with this AdvertisingSet. Must be called when
 * advertising is not active. This method returns immediately, the operation status is delivered
 * through {@code callback.onAdvertisingParametersUpdated}.
 *
 * @param parameters advertising set parameters.
 */

Body of Frist Method:
{
    try {
        gatt.setAdvertisingParameters(this.advertiserId, parameters);
    } catch (RemoteException e) {
        Log.e(TAG, "remote exception - ", e);
    }
}
Body of Second Method:
{
    try {
        mGatt.setAdvertisingParameters(mAdvertiserId, parameters);
    } catch (RemoteException e) {
        Log.e(TAG, "remote exception - ", e);
    }
}
------------------------
Find a silently evolved API code:android.content.pm.PackageManager.installStatusToPublicStatus:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * {@hide}
 */

Body of Frist Method:
{
    switch(status) {
        case INSTALL_SUCCEEDED:
            return PackageInstaller.STATUS_SUCCESS;
        case INSTALL_FAILED_ALREADY_EXISTS:
            return PackageInstaller.STATUS_FAILURE_CONFLICT;
        case INSTALL_FAILED_INVALID_APK:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_FAILED_INVALID_URI:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_FAILED_INSUFFICIENT_STORAGE:
            return PackageInstaller.STATUS_FAILURE_STORAGE;
        case INSTALL_FAILED_DUPLICATE_PACKAGE:
            return PackageInstaller.STATUS_FAILURE_CONFLICT;
        case INSTALL_FAILED_NO_SHARED_USER:
            return PackageInstaller.STATUS_FAILURE_CONFLICT;
        case INSTALL_FAILED_UPDATE_INCOMPATIBLE:
            return PackageInstaller.STATUS_FAILURE_CONFLICT;
        case INSTALL_FAILED_SHARED_USER_INCOMPATIBLE:
            return PackageInstaller.STATUS_FAILURE_CONFLICT;
        case INSTALL_FAILED_MISSING_SHARED_LIBRARY:
            return PackageInstaller.STATUS_FAILURE_INCOMPATIBLE;
        case INSTALL_FAILED_REPLACE_COULDNT_DELETE:
            return PackageInstaller.STATUS_FAILURE_CONFLICT;
        case INSTALL_FAILED_DEXOPT:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_FAILED_OLDER_SDK:
            return PackageInstaller.STATUS_FAILURE_INCOMPATIBLE;
        case INSTALL_FAILED_CONFLICTING_PROVIDER:
            return PackageInstaller.STATUS_FAILURE_CONFLICT;
        case INSTALL_FAILED_NEWER_SDK:
            return PackageInstaller.STATUS_FAILURE_INCOMPATIBLE;
        case INSTALL_FAILED_TEST_ONLY:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_FAILED_CPU_ABI_INCOMPATIBLE:
            return PackageInstaller.STATUS_FAILURE_INCOMPATIBLE;
        case INSTALL_FAILED_MISSING_FEATURE:
            return PackageInstaller.STATUS_FAILURE_INCOMPATIBLE;
        case INSTALL_FAILED_CONTAINER_ERROR:
            return PackageInstaller.STATUS_FAILURE_STORAGE;
        case INSTALL_FAILED_INVALID_INSTALL_LOCATION:
            return PackageInstaller.STATUS_FAILURE_STORAGE;
        case INSTALL_FAILED_MEDIA_UNAVAILABLE:
            return PackageInstaller.STATUS_FAILURE_STORAGE;
        case INSTALL_FAILED_VERIFICATION_TIMEOUT:
            return PackageInstaller.STATUS_FAILURE_ABORTED;
        case INSTALL_FAILED_VERIFICATION_FAILURE:
            return PackageInstaller.STATUS_FAILURE_ABORTED;
        case INSTALL_FAILED_PACKAGE_CHANGED:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_FAILED_UID_CHANGED:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_FAILED_VERSION_DOWNGRADE:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_FAILED_PERMISSION_MODEL_DOWNGRADE:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_PARSE_FAILED_NOT_APK:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_PARSE_FAILED_BAD_MANIFEST:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_PARSE_FAILED_UNEXPECTED_EXCEPTION:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_PARSE_FAILED_NO_CERTIFICATES:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_PARSE_FAILED_CERTIFICATE_ENCODING:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_PARSE_FAILED_BAD_SHARED_USER_ID:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_PARSE_FAILED_MANIFEST_MALFORMED:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_PARSE_FAILED_MANIFEST_EMPTY:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_FAILED_INTERNAL_ERROR:
            return PackageInstaller.STATUS_FAILURE;
        case INSTALL_FAILED_USER_RESTRICTED:
            return PackageInstaller.STATUS_FAILURE_INCOMPATIBLE;
        case INSTALL_FAILED_DUPLICATE_PERMISSION:
            return PackageInstaller.STATUS_FAILURE_CONFLICT;
        case INSTALL_FAILED_NO_MATCHING_ABIS:
            return PackageInstaller.STATUS_FAILURE_INCOMPATIBLE;
        case INSTALL_FAILED_ABORTED:
            return PackageInstaller.STATUS_FAILURE_ABORTED;
        default:
            return PackageInstaller.STATUS_FAILURE;
    }
}
Body of Second Method:
{
    switch(status) {
        case INSTALL_SUCCEEDED:
            return PackageInstaller.STATUS_SUCCESS;
        case INSTALL_FAILED_ALREADY_EXISTS:
            return PackageInstaller.STATUS_FAILURE_CONFLICT;
        case INSTALL_FAILED_INVALID_APK:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_FAILED_INVALID_URI:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_FAILED_INSUFFICIENT_STORAGE:
            return PackageInstaller.STATUS_FAILURE_STORAGE;
        case INSTALL_FAILED_DUPLICATE_PACKAGE:
            return PackageInstaller.STATUS_FAILURE_CONFLICT;
        case INSTALL_FAILED_NO_SHARED_USER:
            return PackageInstaller.STATUS_FAILURE_CONFLICT;
        case INSTALL_FAILED_UPDATE_INCOMPATIBLE:
            return PackageInstaller.STATUS_FAILURE_CONFLICT;
        case INSTALL_FAILED_SHARED_USER_INCOMPATIBLE:
            return PackageInstaller.STATUS_FAILURE_CONFLICT;
        case INSTALL_FAILED_MISSING_SHARED_LIBRARY:
            return PackageInstaller.STATUS_FAILURE_INCOMPATIBLE;
        case INSTALL_FAILED_REPLACE_COULDNT_DELETE:
            return PackageInstaller.STATUS_FAILURE_CONFLICT;
        case INSTALL_FAILED_DEXOPT:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_FAILED_OLDER_SDK:
            return PackageInstaller.STATUS_FAILURE_INCOMPATIBLE;
        case INSTALL_FAILED_CONFLICTING_PROVIDER:
            return PackageInstaller.STATUS_FAILURE_CONFLICT;
        case INSTALL_FAILED_NEWER_SDK:
            return PackageInstaller.STATUS_FAILURE_INCOMPATIBLE;
        case INSTALL_FAILED_TEST_ONLY:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_FAILED_CPU_ABI_INCOMPATIBLE:
            return PackageInstaller.STATUS_FAILURE_INCOMPATIBLE;
        case INSTALL_FAILED_MISSING_FEATURE:
            return PackageInstaller.STATUS_FAILURE_INCOMPATIBLE;
        case INSTALL_FAILED_CONTAINER_ERROR:
            return PackageInstaller.STATUS_FAILURE_STORAGE;
        case INSTALL_FAILED_INVALID_INSTALL_LOCATION:
            return PackageInstaller.STATUS_FAILURE_STORAGE;
        case INSTALL_FAILED_MEDIA_UNAVAILABLE:
            return PackageInstaller.STATUS_FAILURE_STORAGE;
        case INSTALL_FAILED_VERIFICATION_TIMEOUT:
            return PackageInstaller.STATUS_FAILURE_ABORTED;
        case INSTALL_FAILED_VERIFICATION_FAILURE:
            return PackageInstaller.STATUS_FAILURE_ABORTED;
        case INSTALL_FAILED_PACKAGE_CHANGED:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_FAILED_UID_CHANGED:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_FAILED_VERSION_DOWNGRADE:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_FAILED_PERMISSION_MODEL_DOWNGRADE:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_PARSE_FAILED_NOT_APK:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_PARSE_FAILED_BAD_MANIFEST:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_PARSE_FAILED_UNEXPECTED_EXCEPTION:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_PARSE_FAILED_NO_CERTIFICATES:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_PARSE_FAILED_CERTIFICATE_ENCODING:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_PARSE_FAILED_BAD_SHARED_USER_ID:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_PARSE_FAILED_MANIFEST_MALFORMED:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_PARSE_FAILED_MANIFEST_EMPTY:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_FAILED_BAD_DEX_METADATA:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_FAILED_INTERNAL_ERROR:
            return PackageInstaller.STATUS_FAILURE;
        case INSTALL_FAILED_USER_RESTRICTED:
            return PackageInstaller.STATUS_FAILURE_INCOMPATIBLE;
        case INSTALL_FAILED_DUPLICATE_PERMISSION:
            return PackageInstaller.STATUS_FAILURE_CONFLICT;
        case INSTALL_FAILED_NO_MATCHING_ABIS:
            return PackageInstaller.STATUS_FAILURE_INCOMPATIBLE;
        case INSTALL_FAILED_ABORTED:
            return PackageInstaller.STATUS_FAILURE_ABORTED;
        default:
            return PackageInstaller.STATUS_FAILURE;
    }
}
------------------------
Find a silently evolved API code:android.net.LocalSocketImpl.SocketInputStream.available:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    FileDescriptor myFd = fd;
    if (myFd == null)
        throw new IOException("socket closed");
    MutableInt avail = new MutableInt(0);
    try {
        Os.ioctlInt(myFd, OsConstants.FIONREAD, avail);
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
    return avail.value;
}
Body of Second Method:
{
    FileDescriptor myFd = fd;
    if (myFd == null)
        throw new IOException("socket closed");
    Int32Ref avail = new Int32Ref(0);
    try {
        Os.ioctlInt(myFd, OsConstants.FIONREAD, avail);
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
    return avail.value;
}
------------------------
Find a silently evolved API code:android.view.ThreadedRenderer.dumpGfxInfo:COMMENT
Method Modifier: default     hidden      
Comment:/**
 * Outputs extra debugging information in the specified file descriptor.
 */

Body of Frist Method:
{
    pw.flush();
    int flags = 0;
    for (int i = 0; i < args.length; i++) {
        switch(args[i]) {
            case "framestats":
                flags |= FLAG_DUMP_FRAMESTATS;
                break;
            case "reset":
                flags |= FLAG_DUMP_RESET;
                break;
        }
    }
    nDumpProfileInfo(mNativeProxy, fd, flags);
}
Body of Second Method:
{
    pw.flush();
    // If there's no arguments, eg 'dumpsys gfxinfo', then dump everything.
    // If there's a targetted package, eg 'dumpsys gfxinfo com.android.systemui', then only
    // dump the summary information
    int flags = (args == null || args.length == 0) ? FLAG_DUMP_ALL : 0;
    for (int i = 0; i < args.length; i++) {
        switch(args[i]) {
            case "framestats":
                flags |= FLAG_DUMP_FRAMESTATS;
                break;
            case "reset":
                flags |= FLAG_DUMP_RESET;
                break;
            case // magic option passed when dumping a bugreport.
            "-a":
                flags = FLAG_DUMP_ALL;
                break;
        }
    }
    nDumpProfileInfo(mNativeProxy, fd, flags);
}
------------------------
Find a silently evolved API code:android.hardware.camera2.CaptureRequest.Builder.get:COMMENT
Method Modifier: public      
Comment:/**
 * Get a capture request field value. The field definitions can be
 * found in {@link CaptureRequest}.
 *
 * @throws IllegalArgumentException if the key was not valid
 *
 * @param key The metadata field to read.
 * @return The value of that key, or {@code null} if the field is not set.
 */

Body of Frist Method:
{
    return mRequest.mSettings.get(key);
}
Body of Second Method:
{
    return mRequest.mLogicalCameraSettings.get(key);
}
------------------------
Find a silently evolved API code:android.content.res.TypedArray.getChangingConfigurations:COMMENT
Method Modifier: public      
Comment:/**
 * Return a mask of the configuration parameters for which the values in
 * this typed array may change.
 *
 * @return Returns a mask of the changing configuration parameters, as
 * defined by {@link android.content.pm.ActivityInfo}.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @see android.content.pm.ActivityInfo
 */

Body of Frist Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    @Config int changingConfig = 0;
    final int[] data = mData;
    final int N = length();
    for (int i = 0; i < N; i++) {
        final int index = i * AssetManager.STYLE_NUM_ENTRIES;
        final int type = data[index + AssetManager.STYLE_TYPE];
        if (type == TypedValue.TYPE_NULL) {
            continue;
        }
        changingConfig |= ActivityInfo.activityInfoConfigNativeToJava(data[index + AssetManager.STYLE_CHANGING_CONFIGURATIONS]);
    }
    return changingConfig;
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    @Config int changingConfig = 0;
    final int[] data = mData;
    final int N = length();
    for (int i = 0; i < N; i++) {
        final int index = i * STYLE_NUM_ENTRIES;
        final int type = data[index + STYLE_TYPE];
        if (type == TypedValue.TYPE_NULL) {
            continue;
        }
        changingConfig |= ActivityInfo.activityInfoConfigNativeToJava(data[index + STYLE_CHANGING_CONFIGURATIONS]);
    }
    return changingConfig;
}
------------------------
Find a silently evolved API code:android.os.Build.isBuildConsistent:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Verifies the current flash of the device is consistent with what
 * was expected at build time.
 *
 * Treble devices will verify the Vendor Interface (VINTF). A device
 * launched without Treble:
 *
 * 1) Checks that device fingerprint is defined and that it matches across
 * various partitions.
 * 2) Verifies radio and bootloader partitions are those expected in the build.
 *
 * @hide
 */

Body of Frist Method:
{
    // Don't care on eng builds.  Incremental build may trigger false negative.
    if (IS_ENG)
        return true;
    if (IS_TREBLE_ENABLED) {
        int result = VintfObject.verify(new String[0]);
        if (result != 0) {
            Slog.e(TAG, "Vendor interface is incompatible, error=" + String.valueOf(result));
        }
        return result == 0;
    }
    final String system = SystemProperties.get("ro.build.fingerprint");
    final String vendor = SystemProperties.get("ro.vendor.build.fingerprint");
    final String bootimage = SystemProperties.get("ro.bootimage.build.fingerprint");
    final String requiredBootloader = SystemProperties.get("ro.build.expect.bootloader");
    final String currentBootloader = SystemProperties.get("ro.bootloader");
    final String requiredRadio = SystemProperties.get("ro.build.expect.baseband");
    final String currentRadio = SystemProperties.get("gsm.version.baseband");
    if (TextUtils.isEmpty(system)) {
        Slog.e(TAG, "Required ro.build.fingerprint is empty!");
        return false;
    }
    if (!TextUtils.isEmpty(vendor)) {
        if (!Objects.equals(system, vendor)) {
            Slog.e(TAG, "Mismatched fingerprints; system reported " + system + " but vendor reported " + vendor);
            return false;
        }
    }
    return true;
}
Body of Second Method:
{
    // Don't care on eng builds.  Incremental build may trigger false negative.
    if (IS_ENG)
        return true;
    if (IS_TREBLE_ENABLED) {
        // If we can run this code, the device should already pass AVB.
        // So, we don't need to check AVB here.
        int result = VintfObject.verifyWithoutAvb();
        if (result != 0) {
            Slog.e(TAG, "Vendor interface is incompatible, error=" + String.valueOf(result));
        }
        return result == 0;
    }
    final String system = SystemProperties.get("ro.build.fingerprint");
    final String vendor = SystemProperties.get("ro.vendor.build.fingerprint");
    final String bootimage = SystemProperties.get("ro.bootimage.build.fingerprint");
    final String requiredBootloader = SystemProperties.get("ro.build.expect.bootloader");
    final String currentBootloader = SystemProperties.get("ro.bootloader");
    final String requiredRadio = SystemProperties.get("ro.build.expect.baseband");
    final String currentRadio = SystemProperties.get("gsm.version.baseband");
    if (TextUtils.isEmpty(system)) {
        Slog.e(TAG, "Required ro.build.fingerprint is empty!");
        return false;
    }
    if (!TextUtils.isEmpty(vendor)) {
        if (!Objects.equals(system, vendor)) {
            Slog.e(TAG, "Mismatched fingerprints; system reported " + system + " but vendor reported " + vendor);
            return false;
        }
    }
    return true;
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiConfiguration.setIpConfiguration:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    mIpConfiguration = ipConfiguration;
}
Body of Second Method:
{
    if (ipConfiguration == null)
        ipConfiguration = new IpConfiguration();
    mIpConfiguration = ipConfiguration;
}
------------------------
Find a silently evolved API code:android.content.ContentResolver.getSyncAutomatically:COMMENT
Method Modifier: public      static      
Comment:/**
 * Check if the provider should be synced when a network tickle is received
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#READ_SYNC_SETTINGS}.
 *
 * @param account the account whose setting we are querying
 * @param authority the provider whose setting we are querying
 * @return true if the provider should be synced when a network tickle is received
 */

Body of Frist Method:
{
    try {
        return getContentService().getSyncAutomatically(account, authority);
    } catch (RemoteException e) {
        throw new RuntimeException("the ContentService should always be reachable", e);
    }
}
Body of Second Method:
{
    try {
        return getContentService().getSyncAutomatically(account, authority);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.app.BroadcastOptions.toBundle:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns the created options as a Bundle, which can be passed to
 * {@link android.content.Context#sendBroadcast(android.content.Intent)
 * Context.sendBroadcast(Intent)} and related methods.
 * Note that the returned Bundle is still owned by the BroadcastOptions
 * object; you must not modify it, but can supply it to the sendBroadcast
 * methods that take an options Bundle.
 */

Body of Frist Method:
{
    Bundle b = new Bundle();
    if (mTemporaryAppWhitelistDuration > 0) {
        b.putLong(KEY_TEMPORARY_APP_WHITELIST_DURATION, mTemporaryAppWhitelistDuration);
    }
    if (mMinManifestReceiverApiLevel != 0) {
        b.putInt(KEY_MIN_MANIFEST_RECEIVER_API_LEVEL, mMinManifestReceiverApiLevel);
    }
    if (mMaxManifestReceiverApiLevel != Build.VERSION_CODES.CUR_DEVELOPMENT) {
        b.putInt(KEY_MAX_MANIFEST_RECEIVER_API_LEVEL, mMaxManifestReceiverApiLevel);
    }
    return b.isEmpty() ? null : b;
}
Body of Second Method:
{
    Bundle b = new Bundle();
    if (mTemporaryAppWhitelistDuration > 0) {
        b.putLong(KEY_TEMPORARY_APP_WHITELIST_DURATION, mTemporaryAppWhitelistDuration);
    }
    if (mMinManifestReceiverApiLevel != 0) {
        b.putInt(KEY_MIN_MANIFEST_RECEIVER_API_LEVEL, mMinManifestReceiverApiLevel);
    }
    if (mMaxManifestReceiverApiLevel != Build.VERSION_CODES.CUR_DEVELOPMENT) {
        b.putInt(KEY_MAX_MANIFEST_RECEIVER_API_LEVEL, mMaxManifestReceiverApiLevel);
    }
    if (mDontSendToRestrictedApps) {
        b.putBoolean(KEY_DONT_SEND_TO_RESTRICTED_APPS, true);
    }
    return b.isEmpty() ? null : b;
}
------------------------
Find a silently evolved API code:android.hardware.camera2.params.OutputConfiguration.hashCode:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    // surface is set.
    if (mIsDeferredConfig) {
        return HashCodeHelpers.hashCode(mRotation, mConfiguredSize.hashCode(), mConfiguredFormat, mConfiguredDataspace, mSurfaceGroupId, mSurfaceType, mIsShared ? 1 : 0);
    }
    return HashCodeHelpers.hashCode(mRotation, mSurfaces.hashCode(), mConfiguredGenerationId, mConfiguredSize.hashCode(), mConfiguredFormat, mConfiguredDataspace, mSurfaceGroupId, mIsShared ? 1 : 0);
}
Body of Second Method:
{
    // surface is set.
    if (mIsDeferredConfig) {
        return HashCodeHelpers.hashCode(mRotation, mConfiguredSize.hashCode(), mConfiguredFormat, mConfiguredDataspace, mSurfaceGroupId, mSurfaceType, mIsShared ? 1 : 0, mPhysicalCameraId == null ? 0 : mPhysicalCameraId.hashCode());
    }
    return HashCodeHelpers.hashCode(mRotation, mSurfaces.hashCode(), mConfiguredGenerationId, mConfiguredSize.hashCode(), mConfiguredFormat, mConfiguredDataspace, mSurfaceGroupId, mIsShared ? 1 : 0, mPhysicalCameraId == null ? 0 : mPhysicalCameraId.hashCode());
}
------------------------
Find a silently evolved API code:android.telephony.CellIdentityLte.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Implement the Parcelable interface
 */

Body of Frist Method:
{
    if (DBG)
        log("writeToParcel(Parcel, int): " + toString());
    dest.writeInt(mMcc);
    dest.writeInt(mMnc);
    dest.writeInt(mCi);
    dest.writeInt(mPci);
    dest.writeInt(mTac);
    dest.writeInt(mEarfcn);
}
Body of Second Method:
{
    if (DBG)
        log("writeToParcel(Parcel, int): " + toString());
    super.writeToParcel(dest, TYPE_LTE);
    dest.writeInt(mCi);
    dest.writeInt(mPci);
    dest.writeInt(mTac);
    dest.writeInt(mEarfcn);
    dest.writeInt(mBandwidth);
}
------------------------
Find a silently evolved API code:android.bluetooth.le.AdvertisingSetParameters.isLegacy:COMMENT
Method Modifier: public      
Comment:/**
 * Returns whether the legacy advertisement will be used.
 */

Body of Frist Method:
{
    return isLegacy;
}
Body of Second Method:
{
    return mIsLegacy;
}
------------------------
Find a silently evolved API code:android.app.NotificationChannel.toJson:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    JSONObject record = new JSONObject();
    record.put(ATT_ID, getId());
    record.put(ATT_NAME, getName());
    record.put(ATT_DESC, getDescription());
    if (getImportance() != DEFAULT_IMPORTANCE) {
        record.put(ATT_IMPORTANCE, NotificationListenerService.Ranking.importanceToString(getImportance()));
    }
    if (canBypassDnd()) {
        record.put(ATT_PRIORITY, Notification.PRIORITY_MAX);
    }
    if (getLockscreenVisibility() != DEFAULT_VISIBILITY) {
        record.put(ATT_VISIBILITY, Notification.visibilityToString(getLockscreenVisibility()));
    }
    if (getSound() != null) {
        record.put(ATT_SOUND, getSound().toString());
    }
    if (getAudioAttributes() != null) {
        record.put(ATT_USAGE, Integer.toString(getAudioAttributes().getUsage()));
        record.put(ATT_CONTENT_TYPE, Integer.toString(getAudioAttributes().getContentType()));
        record.put(ATT_FLAGS, Integer.toString(getAudioAttributes().getFlags()));
    }
    record.put(ATT_LIGHTS, Boolean.toString(shouldShowLights()));
    record.put(ATT_LIGHT_COLOR, Integer.toString(getLightColor()));
    record.put(ATT_VIBRATION_ENABLED, Boolean.toString(shouldVibrate()));
    record.put(ATT_USER_LOCKED, Integer.toString(getUserLockedFields()));
    record.put(ATT_VIBRATION, longArrayToString(getVibrationPattern()));
    record.put(ATT_SHOW_BADGE, Boolean.toString(canShowBadge()));
    record.put(ATT_DELETED, Boolean.toString(isDeleted()));
    record.put(ATT_GROUP, getGroup());
    record.put(ATT_BLOCKABLE_SYSTEM, isBlockableSystem());
    return record;
}
Body of Second Method:
{
    JSONObject record = new JSONObject();
    record.put(ATT_ID, getId());
    record.put(ATT_NAME, getName());
    record.put(ATT_DESC, getDescription());
    if (getImportance() != DEFAULT_IMPORTANCE) {
        record.put(ATT_IMPORTANCE, NotificationListenerService.Ranking.importanceToString(getImportance()));
    }
    if (canBypassDnd()) {
        record.put(ATT_PRIORITY, Notification.PRIORITY_MAX);
    }
    if (getLockscreenVisibility() != DEFAULT_VISIBILITY) {
        record.put(ATT_VISIBILITY, Notification.visibilityToString(getLockscreenVisibility()));
    }
    if (getSound() != null) {
        record.put(ATT_SOUND, getSound().toString());
    }
    if (getAudioAttributes() != null) {
        record.put(ATT_USAGE, Integer.toString(getAudioAttributes().getUsage()));
        record.put(ATT_CONTENT_TYPE, Integer.toString(getAudioAttributes().getContentType()));
        record.put(ATT_FLAGS, Integer.toString(getAudioAttributes().getFlags()));
    }
    record.put(ATT_LIGHTS, Boolean.toString(shouldShowLights()));
    record.put(ATT_LIGHT_COLOR, Integer.toString(getLightColor()));
    record.put(ATT_VIBRATION_ENABLED, Boolean.toString(shouldVibrate()));
    record.put(ATT_USER_LOCKED, Integer.toString(getUserLockedFields()));
    record.put(ATT_FG_SERVICE_SHOWN, Boolean.toString(isFgServiceShown()));
    record.put(ATT_VIBRATION, longArrayToString(getVibrationPattern()));
    record.put(ATT_SHOW_BADGE, Boolean.toString(canShowBadge()));
    record.put(ATT_DELETED, Boolean.toString(isDeleted()));
    record.put(ATT_GROUP, getGroup());
    record.put(ATT_BLOCKABLE_SYSTEM, isBlockableSystem());
    return record;
}
------------------------
Find a silently evolved API code:android.content.ContentResolver.requestSyncAsUser:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @see #requestSync(Account, String, Bundle)
 * @hide
 */

Body of Frist Method:
{
    if (extras == null) {
        throw new IllegalArgumentException("Must specify extras.");
    }
    SyncRequest request = new SyncRequest.Builder().setSyncAdapter(account, authority).setExtras(extras).syncOnce().build();
    try {
        getContentService().syncAsUser(request, userId);
    } catch (RemoteException e) {
    // Shouldn't happen.
    }
}
Body of Second Method:
{
    if (extras == null) {
        throw new IllegalArgumentException("Must specify extras.");
    }
    SyncRequest request = new SyncRequest.Builder().setSyncAdapter(account, authority).setExtras(extras).syncOnce().build();
    try {
        getContentService().syncAsUser(request, userId);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.telephony.euicc.EuiccManager.updateSubscriptionNickname:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Update the nickname for the given subscription.
 *
 * <p>Requires that the calling app has the
 * {@link android.Manifest.permission#WRITE_EMBEDDED_SUBSCRIPTIONS} permission. This is for
 * internal system use only.
 *
 * @param subscriptionId the ID of the subscription to update.
 * @param nickname the new nickname to apply.
 * @param callbackIntent a PendingIntent to launch when the operation completes.
 * @hide
 */

Body of Frist Method:
{
    if (!isEnabled()) {
        sendUnavailableError(callbackIntent);
        return;
    }
    try {
        mController.updateSubscriptionNickname(subscriptionId, nickname, callbackIntent);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    if (!isEnabled()) {
        sendUnavailableError(callbackIntent);
        return;
    }
    try {
        getIEuiccController().updateSubscriptionNickname(subscriptionId, nickname, callbackIntent);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.telephony.PhoneNumberUtils.networkPortionToCalledPartyBCD:COMMENT
Method Modifier: public      static      
Comment:/**
 * Note: calls extractNetworkPortion(), so do not use for
 * SIM EF[ADN] style records
 *
 * Returns null if network portion is empty.
 */

Body of Frist Method:
{
    String networkPortion = extractNetworkPortion(s);
    return numberToCalledPartyBCDHelper(networkPortion, false);
}
Body of Second Method:
{
    String networkPortion = extractNetworkPortion(s);
    return numberToCalledPartyBCDHelper(networkPortion, false, BCD_EXTENDED_TYPE_EF_ADN);
}
------------------------
Find a silently evolved API code:android.content.res.TypedArray.peekValue:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the raw TypedValue for the attribute at <var>index</var>
 * and return a temporary object holding its data.  This object is only
 * valid until the next call on to {@link TypedArray}.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return Returns a TypedValue object if the attribute is defined,
 * containing its data; otherwise returns null.  (You will not
 * receive a TypedValue whose type is TYPE_NULL.)
 * @throws RuntimeException if the TypedArray has already been recycled.
 */

Body of Frist Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    final TypedValue value = mValue;
    if (getValueAt(index * AssetManager.STYLE_NUM_ENTRIES, value)) {
        return value;
    }
    return null;
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    final TypedValue value = mValue;
    if (getValueAt(index * STYLE_NUM_ENTRIES, value)) {
        return value;
    }
    return null;
}
------------------------
Find a silently evolved API code:android.content.ContentResolver.getCurrentSyncsAsUser:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @see #getCurrentSyncs()
 * @hide
 */

Body of Frist Method:
{
    try {
        return getContentService().getCurrentSyncsAsUser(userId);
    } catch (RemoteException e) {
        throw new RuntimeException("the ContentService should always be reachable", e);
    }
}
Body of Second Method:
{
    try {
        return getContentService().getCurrentSyncsAsUser(userId);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiInfo.reset:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    setInetAddress(null);
    setBSSID(null);
    setSSID(null);
    setNetworkId(-1);
    setRssi(INVALID_RSSI);
    setLinkSpeed(-1);
    setFrequency(-1);
    setMeteredHint(false);
    setEphemeral(false);
    txBad = 0;
    txSuccess = 0;
    rxSuccess = 0;
    txRetries = 0;
    txBadRate = 0;
    txSuccessRate = 0;
    rxSuccessRate = 0;
    txRetriesRate = 0;
    lowRssiCount = 0;
    badRssiCount = 0;
    linkStuckCount = 0;
    score = 0;
    mLastPacketCountUpdateTimeStamp = RESET_TIME_STAMP;
}
Body of Second Method:
{
    setInetAddress(null);
    setBSSID(null);
    setSSID(null);
    setNetworkId(-1);
    setRssi(INVALID_RSSI);
    setLinkSpeed(-1);
    setFrequency(-1);
    setMeteredHint(false);
    setEphemeral(false);
    txBad = 0;
    txSuccess = 0;
    rxSuccess = 0;
    txRetries = 0;
    txBadRate = 0;
    txSuccessRate = 0;
    rxSuccessRate = 0;
    txRetriesRate = 0;
    score = 0;
}
------------------------
Find a silently evolved API code:android.media.session.MediaController.TransportControls.skipToPrevious:COMMENT
Method Modifier: public      
Comment:/**
 * Skip to the previous item.
 */

Body of Frist Method:
{
    try {
        mSessionBinder.previous();
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling previous.", e);
    }
}
Body of Second Method:
{
    try {
        mSessionBinder.previous(mContext.getPackageName(), mCbStub);
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling previous.", e);
    }
}
------------------------
Find a silently evolved API code:android.webkit.WebViewUpdateService.getCurrentWebViewPackageName:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Used by DevelopmentSetting to get the name of the WebView provider currently in use.
 */

Body of Frist Method:
{
    try {
        return getUpdateService().getCurrentWebViewPackageName();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    IWebViewUpdateService service = getUpdateService();
    if (service == null) {
        return null;
    }
    try {
        return service.getCurrentWebViewPackageName();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.text.Selection.moveDown:COMMENT
Method Modifier: public      static      
Comment:/**
 * Move the cursor to the buffer offset physically below the current
 * offset, to the end of the buffer if it is on the bottom line but
 * not at the end, or return false if the cursor is already at the
 * end of the buffer.
 */

Body of Frist Method:
{
    int start = getSelectionStart(text);
    int end = getSelectionEnd(text);
    if (start != end) {
        int min = Math.min(start, end);
        int max = Math.max(start, end);
        setSelection(text, max);
        if (min == 0 && max == text.length()) {
            return false;
        }
        return true;
    } else {
        int line = layout.getLineForOffset(end);
        if (line < layout.getLineCount() - 1) {
            int move;
            if (layout.getParagraphDirection(line) == layout.getParagraphDirection(line + 1)) {
                float h = layout.getPrimaryHorizontal(end);
                move = layout.getOffsetForHorizontal(line + 1, h);
            } else {
                move = layout.getLineStart(line + 1);
            }
            setSelection(text, move);
            return true;
        } else if (end != text.length()) {
            setSelection(text, text.length());
            return true;
        }
    }
    return false;
}
Body of Second Method:
{
    int start = getSelectionStart(text);
    int end = getSelectionEnd(text);
    if (start != end) {
        int min = Math.min(start, end);
        int max = Math.max(start, end);
        setSelection(text, max);
        if (min == 0 && max == text.length()) {
            return false;
        }
        return true;
    } else {
        int line = layout.getLineForOffset(end);
        if (line < layout.getLineCount() - 1) {
            setSelectionAndMemory(text, layout, line, end, 1, /* direction */
            false);
            return true;
        } else if (end != text.length()) {
            setSelection(text, text.length());
            return true;
        }
    }
    return false;
}
------------------------
Find a silently evolved API code:android.content.res.TypedArray.getDimensionPixelOffset:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve a dimensional unit attribute at <var>index</var> for use
 * as an offset in raw pixels.  This is the same as
 * {@link #getDimension}, except the returned value is converted to
 * integer pixels for you.  An offset conversion involves simply
 * truncating the base value to an integer.
 * <p>
 * This method will throw an exception if the attribute is defined but is
 * not a dimension.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute dimension value multiplied by the appropriate
 * metric and truncated to integer pixels, or defValue if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not an integer.
 *
 * @see #getDimension
 * @see #getDimensionPixelSize
 */

Body of Frist Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    final int attrIndex = index;
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimensionPixelOffset(data[index + AssetManager.STYLE_DATA], mMetrics);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index, value);
        throw new UnsupportedOperationException("Failed to resolve attribute at index " + attrIndex + ": " + value);
    }
    throw new UnsupportedOperationException("Can't convert value at index " + attrIndex + " to dimension: type=0x" + Integer.toHexString(type));
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    final int attrIndex = index;
    index *= STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimensionPixelOffset(data[index + STYLE_DATA], mMetrics);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index, value);
        throw new UnsupportedOperationException("Failed to resolve attribute at index " + attrIndex + ": " + value);
    }
    throw new UnsupportedOperationException("Can't convert value at index " + attrIndex + " to dimension: type=0x" + Integer.toHexString(type));
}
------------------------
Find a silently evolved API code:android.view.WindowInsets.hasInsets:COMMENT
Method Modifier: public      
Comment:/**
 * Returns true if this WindowInsets has any nonzero insets.
 *
 * @return true if any inset values are nonzero
 */

Body of Frist Method:
{
    return hasSystemWindowInsets() || hasWindowDecorInsets() || hasStableInsets();
}
Body of Second Method:
{
    return hasSystemWindowInsets() || hasWindowDecorInsets() || hasStableInsets() || mDisplayCutout != null;
}
------------------------
Find a silently evolved API code:android.widget.SimpleMonthView.findClosestRow:COMMENT
Method Modifier: private     
Comment:/**
 * Returns the row (0 indexed) closest to previouslyFocusedRect or center if null.
 */

Body of Frist Method:
{
    if (previouslyFocusedRect == null) {
        return 3;
    } else {
        int centerY = previouslyFocusedRect.centerY();
        final TextPaint p = mDayPaint;
        final int headerHeight = mMonthHeight + mDayOfWeekHeight;
        final int rowHeight = mDayHeight;
        // Text is vertically centered within the row height.
        final float halfLineHeight = (p.ascent() + p.descent()) / 2f;
        final int rowCenter = headerHeight + rowHeight / 2;
        centerY -= rowCenter - halfLineHeight;
        int row = Math.round(centerY / (float) rowHeight);
        final int maxDay = findDayOffset() + mDaysInMonth;
        final int maxRows = (maxDay / DAYS_IN_WEEK) - ((maxDay % DAYS_IN_WEEK == 0) ? 1 : 0);
        row = MathUtils.constrain(row, 0, maxRows);
        return row;
    }
}
Body of Second Method:
{
    if (previouslyFocusedRect == null) {
        return 3;
    } else if (mDayHeight == 0) {
        // There hasn't been a layout, so just choose the first row
        return 0;
    } else {
        int centerY = previouslyFocusedRect.centerY();
        final TextPaint p = mDayPaint;
        final int headerHeight = mMonthHeight + mDayOfWeekHeight;
        final int rowHeight = mDayHeight;
        // Text is vertically centered within the row height.
        final float halfLineHeight = (p.ascent() + p.descent()) / 2f;
        final int rowCenter = headerHeight + rowHeight / 2;
        centerY -= rowCenter - halfLineHeight;
        int row = Math.round(centerY / (float) rowHeight);
        final int maxDay = findDayOffset() + mDaysInMonth;
        final int maxRows = (maxDay / DAYS_IN_WEEK) - ((maxDay % DAYS_IN_WEEK == 0) ? 1 : 0);
        row = MathUtils.constrain(row, 0, maxRows);
        return row;
    }
}
------------------------
Find a silently evolved API code:android.app.Instrumentation.newActivity:COMMENT
Method Modifier: public      
Comment:/**
 * Perform instantiation of the process's {@link Activity} object.  The
 * default implementation provides the normal system behavior.
 *
 * @param cl The ClassLoader with which to instantiate the object.
 * @param className The name of the class implementing the Activity
 * object.
 * @param intent The Intent object that specified the activity class being
 * instantiated.
 *
 * @return The newly instantiated Activity object.
 */

Body of Frist Method:
{
    return (Activity) cl.loadClass(className).newInstance();
}
Body of Second Method:
{
    String pkg = intent != null && intent.getComponent() != null ? intent.getComponent().getPackageName() : null;
    return getFactory(pkg).instantiateActivity(cl, className, intent);
}
------------------------
Find a silently evolved API code:android.text.Emoji.isNewEmoji:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Returns true if the character is a new emoji still not supported in our version of ICU.
 */

Body of Frist Method:
{
    // TODO: Remove once emoji-data.text 5.0 is in ICU or update to 6.0.
    if (codePoint < 0x1F6F7 || codePoint > 0x1F9E6) {
        // Optimization for characters outside the new emoji range.
        return false;
    }
    return (0x1F6F7 <= codePoint && codePoint <= 0x1F6F8) || codePoint == 0x1F91F || (0x1F928 <= codePoint && codePoint <= 0x1F92F) || (0x1F931 <= codePoint && codePoint <= 0x1F932) || codePoint == 0x1F94C || (0x1F95F <= codePoint && codePoint <= 0x1F96B) || (0x1F992 <= codePoint && codePoint <= 0x1F997) || (0x1F9D0 <= codePoint && codePoint <= 0x1F9E6);
}
Body of Second Method:
{
    // TODO: Remove once emoji-data.text 11 is in ICU or update to 11.
    if (c < 0x1F6F9 || c > 0x1F9FF) {
        // Optimization for characters outside the new emoji range.
        return false;
    }
    return c == 0x265F || c == 0x267E || c == 0x1F6F9 || c == 0x1F97A || (0x1F94D <= c && c <= 0x1F94F) || (0x1F96C <= c && c <= 0x1F970) || (0x1F973 <= c && c <= 0x1F976) || (0x1F97C <= c && c <= 0x1F97F) || (0x1F998 <= c && c <= 0x1F9A2) || (0x1F9B0 <= c && c <= 0x1F9B9) || (0x1F9C1 <= c && c <= 0x1F9C2) || (0x1F9E7 <= c && c <= 0x1F9FF);
}
------------------------
Find a silently evolved API code:android.content.ContentResolver.removeStatusChangeListener:COMMENT
Method Modifier: public      static      
Comment:/**
 * Remove a previously registered status change listener.
 * @param handle the handle that was returned by {@link #addStatusChangeListener}
 */

Body of Frist Method:
{
    if (handle == null) {
        throw new IllegalArgumentException("you passed in a null handle");
    }
    try {
        getContentService().removeStatusChangeListener((ISyncStatusObserver.Stub) handle);
    } catch (RemoteException e) {
    // exception ignored; if this is thrown then it means the runtime is in the midst of
    // being restarted
    }
}
Body of Second Method:
{
    if (handle == null) {
        throw new IllegalArgumentException("you passed in a null handle");
    }
    try {
        getContentService().removeStatusChangeListener((ISyncStatusObserver.Stub) handle);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.app.usage.NetworkStats.getNextHistoryBucket:COMMENT
Method Modifier: private     
Comment:/**
 * Getting the next item in a history enumeration.
 * @param bucketOut Next item will be set here.
 * @return true if a next item could be set.
 */

Body of Frist Method:
{
    if (bucketOut != null && mHistory != null) {
        if (mEnumerationIndex < mHistory.size()) {
            mRecycledHistoryEntry = mHistory.getValues(mEnumerationIndex++, mRecycledHistoryEntry);
            bucketOut.mUid = Bucket.convertUid(getUid());
            bucketOut.mTag = Bucket.convertTag(mTag);
            bucketOut.mState = Bucket.STATE_ALL;
            bucketOut.mMetered = Bucket.METERED_ALL;
            bucketOut.mRoaming = Bucket.ROAMING_ALL;
            bucketOut.mBeginTimeStamp = mRecycledHistoryEntry.bucketStart;
            bucketOut.mEndTimeStamp = mRecycledHistoryEntry.bucketStart + mRecycledHistoryEntry.bucketDuration;
            bucketOut.mRxBytes = mRecycledHistoryEntry.rxBytes;
            bucketOut.mRxPackets = mRecycledHistoryEntry.rxPackets;
            bucketOut.mTxBytes = mRecycledHistoryEntry.txBytes;
            bucketOut.mTxPackets = mRecycledHistoryEntry.txPackets;
            return true;
        } else if (hasNextUid()) {
            stepHistory();
            return getNextHistoryBucket(bucketOut);
        }
    }
    return false;
}
Body of Second Method:
{
    if (bucketOut != null && mHistory != null) {
        if (mEnumerationIndex < mHistory.size()) {
            mRecycledHistoryEntry = mHistory.getValues(mEnumerationIndex++, mRecycledHistoryEntry);
            bucketOut.mUid = Bucket.convertUid(getUid());
            bucketOut.mTag = Bucket.convertTag(mTag);
            bucketOut.mState = mState;
            bucketOut.mDefaultNetworkStatus = Bucket.DEFAULT_NETWORK_ALL;
            bucketOut.mMetered = Bucket.METERED_ALL;
            bucketOut.mRoaming = Bucket.ROAMING_ALL;
            bucketOut.mBeginTimeStamp = mRecycledHistoryEntry.bucketStart;
            bucketOut.mEndTimeStamp = mRecycledHistoryEntry.bucketStart + mRecycledHistoryEntry.bucketDuration;
            bucketOut.mRxBytes = mRecycledHistoryEntry.rxBytes;
            bucketOut.mRxPackets = mRecycledHistoryEntry.rxPackets;
            bucketOut.mTxBytes = mRecycledHistoryEntry.txBytes;
            bucketOut.mTxPackets = mRecycledHistoryEntry.txPackets;
            return true;
        } else if (hasNextUid()) {
            stepHistory();
            return getNextHistoryBucket(bucketOut);
        }
    }
    return false;
}
------------------------
Find a silently evolved API code:android.content.ContentResolver.addStatusChangeListener:COMMENT
Method Modifier: public      static      
Comment:/**
 * Request notifications when the different aspects of the SyncManager change. The
 * different items that can be requested are:
 * <ul>
 * <li> {@link #SYNC_OBSERVER_TYPE_PENDING}
 * <li> {@link #SYNC_OBSERVER_TYPE_ACTIVE}
 * <li> {@link #SYNC_OBSERVER_TYPE_SETTINGS}
 * </ul>
 * The caller can set one or more of the status types in the mask for any
 * given listener registration.
 * @param mask the status change types that will cause the callback to be invoked
 * @param callback observer to be invoked when the status changes
 * @return a handle that can be used to remove the listener at a later time
 */

Body of Frist Method:
{
    if (callback == null) {
        throw new IllegalArgumentException("you passed in a null callback");
    }
    try {
        ISyncStatusObserver.Stub observer = new ISyncStatusObserver.Stub() {

            @Override
            public void onStatusChanged(int which) throws RemoteException {
                callback.onStatusChanged(which);
            }
        };
        getContentService().addStatusChangeListener(mask, observer);
        return observer;
    } catch (RemoteException e) {
        throw new RuntimeException("the ContentService should always be reachable", e);
    }
}
Body of Second Method:
{
    if (callback == null) {
        throw new IllegalArgumentException("you passed in a null callback");
    }
    try {
        ISyncStatusObserver.Stub observer = new ISyncStatusObserver.Stub() {

            @Override
            public void onStatusChanged(int which) throws RemoteException {
                callback.onStatusChanged(which);
            }
        };
        getContentService().addStatusChangeListener(mask, observer);
        return observer;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothUuid.containsAllUuids:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Returns true if all the ParcelUuids in ParcelUuidB are present in
 * ParcelUuidA
 *
 * @param uuidA - Array of ParcelUuidsA
 * @param uuidB - Array of ParcelUuidsB
 */

Body of Frist Method:
{
    if (uuidA == null && uuidB == null)
        return true;
    if (uuidA == null) {
        return uuidB.length == 0 ? true : false;
    }
    if (uuidB == null)
        return true;
    HashSet<ParcelUuid> uuidSet = new HashSet<ParcelUuid>(Arrays.asList(uuidA));
    for (ParcelUuid uuid : uuidB) {
        if (!uuidSet.contains(uuid))
            return false;
    }
    return true;
}
Body of Second Method:
{
    if (uuidA == null && uuidB == null)
        return true;
    if (uuidA == null) {
        return uuidB.length == 0;
    }
    if (uuidB == null)
        return true;
    HashSet<ParcelUuid> uuidSet = new HashSet<ParcelUuid>(Arrays.asList(uuidA));
    for (ParcelUuid uuid : uuidB) {
        if (!uuidSet.contains(uuid))
            return false;
    }
    return true;
}
------------------------
Find a silently evolved API code:android.speech.tts.AudioPlaybackHandler.removeWorkItemsFor:COMMENT
Method Modifier: private     
Comment:/*
     * Remove all messages that originate from a given calling app.
     */

Body of Frist Method:
{
    Iterator<PlaybackQueueItem> it = mQueue.iterator();
    while (it.hasNext()) {
        final PlaybackQueueItem item = it.next();
        if (item.getCallerIdentity() == callerIdentity) {
            it.remove();
        }
    }
}
Body of Second Method:
{
    Iterator<PlaybackQueueItem> it = mQueue.iterator();
    while (it.hasNext()) {
        final PlaybackQueueItem item = it.next();
        if (item.getCallerIdentity() == callerIdentity) {
            it.remove();
            stop(item);
        }
    }
}
------------------------
Find a silently evolved API code:android.content.pm.PackageManager.getPackageArchiveInfo:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve overall information about an application package defined in a
 * package archive file
 *
 * @param archiveFilePath The path to the archive file
 * @param flags Additional option flags to modify the data returned.
 * @return A PackageInfo object containing information about the package
 * archive. If the package could not be parsed, returns null.
 */

Body of Frist Method:
{
    final PackageParser parser = new PackageParser();
    parser.setCallback(new PackageParser.CallbackImpl(this));
    final File apkFile = new File(archiveFilePath);
    try {
        if ((flags & (MATCH_DIRECT_BOOT_UNAWARE | MATCH_DIRECT_BOOT_AWARE)) != 0) {
        // Caller expressed an explicit opinion about what encryption
        // aware/unaware components they want to see, so fall through and
        // give them what they want
        } else {
            // Caller expressed no opinion, so match everything
            flags |= MATCH_DIRECT_BOOT_AWARE | MATCH_DIRECT_BOOT_UNAWARE;
        }
        PackageParser.Package pkg = parser.parseMonolithicPackage(apkFile, 0);
        if ((flags & GET_SIGNATURES) != 0) {
            PackageParser.collectCertificates(pkg, 0);
        }
        PackageUserState state = new PackageUserState();
        return PackageParser.generatePackageInfo(pkg, null, flags, 0, 0, null, state);
    } catch (PackageParserException e) {
        return null;
    }
}
Body of Second Method:
{
    final PackageParser parser = new PackageParser();
    parser.setCallback(new PackageParser.CallbackImpl(this));
    final File apkFile = new File(archiveFilePath);
    try {
        if ((flags & (MATCH_DIRECT_BOOT_UNAWARE | MATCH_DIRECT_BOOT_AWARE)) != 0) {
        // Caller expressed an explicit opinion about what encryption
        // aware/unaware components they want to see, so fall through and
        // give them what they want
        } else {
            // Caller expressed no opinion, so match everything
            flags |= MATCH_DIRECT_BOOT_AWARE | MATCH_DIRECT_BOOT_UNAWARE;
        }
        PackageParser.Package pkg = parser.parseMonolithicPackage(apkFile, 0);
        if ((flags & GET_SIGNATURES) != 0) {
            PackageParser.collectCertificates(pkg, false);
        }
        PackageUserState state = new PackageUserState();
        return PackageParser.generatePackageInfo(pkg, null, flags, 0, 0, null, state);
    } catch (PackageParserException e) {
        return null;
    }
}
------------------------
Find a silently evolved API code:android.text.Selection.extendUp:COMMENT
Method Modifier: public      static      
Comment:/**
 * Move the selection end to the buffer offset physically above
 * the current selection end.
 */

Body of Frist Method:
{
    int end = getSelectionEnd(text);
    int line = layout.getLineForOffset(end);
    if (line > 0) {
        int move;
        if (layout.getParagraphDirection(line) == layout.getParagraphDirection(line - 1)) {
            float h = layout.getPrimaryHorizontal(end);
            move = layout.getOffsetForHorizontal(line - 1, h);
        } else {
            move = layout.getLineStart(line - 1);
        }
        extendSelection(text, move);
        return true;
    } else if (end != 0) {
        extendSelection(text, 0);
        return true;
    }
    return true;
}
Body of Second Method:
{
    int end = getSelectionEnd(text);
    int line = layout.getLineForOffset(end);
    if (line > 0) {
        setSelectionAndMemory(text, layout, line, end, -1, /* direction */
        true);
        return true;
    } else if (end != 0) {
        extendSelection(text, 0);
        return true;
    }
    return true;
}
------------------------
Find a silently evolved API code:android.media.session.MediaController.dispatchMediaButtonEvent:COMMENT
Method Modifier: public      
Comment:/**
 * Send the specified media button event to the session. Only media keys can
 * be sent by this method, other keys will be ignored.
 *
 * @param keyEvent The media button event to dispatch.
 * @return true if the event was sent to the session, false otherwise.
 */

Body of Frist Method:
{
    if (keyEvent == null) {
        throw new IllegalArgumentException("KeyEvent may not be null");
    }
    if (!KeyEvent.isMediaKey(keyEvent.getKeyCode())) {
        return false;
    }
    try {
        return mSessionBinder.sendMediaButton(keyEvent);
    } catch (RemoteException e) {
    // System is dead. =(
    }
    return false;
}
Body of Second Method:
{
    return dispatchMediaButtonEventInternal(false, keyEvent);
}
------------------------
Find a silently evolved API code:android.content.pm.PermissionInfo.protectionToString:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    String protLevel = "????";
    switch(level & PROTECTION_MASK_BASE) {
        case PermissionInfo.PROTECTION_DANGEROUS:
            protLevel = "dangerous";
            break;
        case PermissionInfo.PROTECTION_NORMAL:
            protLevel = "normal";
            break;
        case PermissionInfo.PROTECTION_SIGNATURE:
            protLevel = "signature";
            break;
        case PermissionInfo.PROTECTION_SIGNATURE_OR_SYSTEM:
            protLevel = "signatureOrSystem";
            break;
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_PRIVILEGED) != 0) {
        protLevel += "|privileged";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_DEVELOPMENT) != 0) {
        protLevel += "|development";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_APPOP) != 0) {
        protLevel += "|appop";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_PRE23) != 0) {
        protLevel += "|pre23";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_INSTALLER) != 0) {
        protLevel += "|installer";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_VERIFIER) != 0) {
        protLevel += "|verifier";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_PREINSTALLED) != 0) {
        protLevel += "|preinstalled";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_SETUP) != 0) {
        protLevel += "|setup";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_INSTANT) != 0) {
        protLevel += "|instant";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_RUNTIME_ONLY) != 0) {
        protLevel += "|runtime";
    }
    return protLevel;
}
Body of Second Method:
{
    String protLevel = "????";
    switch(level & PROTECTION_MASK_BASE) {
        case PermissionInfo.PROTECTION_DANGEROUS:
            protLevel = "dangerous";
            break;
        case PermissionInfo.PROTECTION_NORMAL:
            protLevel = "normal";
            break;
        case PermissionInfo.PROTECTION_SIGNATURE:
            protLevel = "signature";
            break;
        case PermissionInfo.PROTECTION_SIGNATURE_OR_SYSTEM:
            protLevel = "signatureOrSystem";
            break;
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_PRIVILEGED) != 0) {
        protLevel += "|privileged";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_DEVELOPMENT) != 0) {
        protLevel += "|development";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_APPOP) != 0) {
        protLevel += "|appop";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_PRE23) != 0) {
        protLevel += "|pre23";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_INSTALLER) != 0) {
        protLevel += "|installer";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_VERIFIER) != 0) {
        protLevel += "|verifier";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_PREINSTALLED) != 0) {
        protLevel += "|preinstalled";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_SETUP) != 0) {
        protLevel += "|setup";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_INSTANT) != 0) {
        protLevel += "|instant";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_RUNTIME_ONLY) != 0) {
        protLevel += "|runtime";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_OEM) != 0) {
        protLevel += "|oem";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_VENDOR_PRIVILEGED) != 0) {
        protLevel += "|vendorPrivileged";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_SYSTEM_TEXT_CLASSIFIER) != 0) {
        protLevel += "|textClassifier";
    }
    return protLevel;
}
------------------------
Find a silently evolved API code:android.util.jar.StrictJarVerifier.verifyCertificate:COMMENT
Method Modifier: private     
Comment:/**
 * @param certFile
 */

Body of Frist Method:
{
    // Found Digital Sig, .SF should already have been read
    String signatureFile = certFile.substring(0, certFile.lastIndexOf('.')) + ".SF";
    byte[] sfBytes = metaEntries.get(signatureFile);
    if (sfBytes == null) {
        return;
    }
    byte[] manifestBytes = metaEntries.get(JarFile.MANIFEST_NAME);
    // Manifest entry is required for any verifications.
    if (manifestBytes == null) {
        return;
    }
    byte[] sBlockBytes = metaEntries.get(certFile);
    try {
        Certificate[] signerCertChain = verifyBytes(sBlockBytes, sfBytes);
        if (signerCertChain != null) {
            certificates.put(signatureFile, signerCertChain);
        }
    } catch (GeneralSecurityException e) {
        throw failedVerification(jarName, signatureFile, e);
    }
    // Verify manifest hash in .sf file
    Attributes attributes = new Attributes();
    HashMap<String, Attributes> entries = new HashMap<String, Attributes>();
    try {
        StrictJarManifestReader im = new StrictJarManifestReader(sfBytes, attributes);
        im.readEntries(entries, null);
    } catch (IOException e) {
        return;
    }
    // If requested, check whether APK Signature Scheme v2 signature was stripped.
    if (signatureSchemeRollbackProtectionsEnforced) {
        String apkSignatureSchemeIdList = attributes.getValue(ApkSignatureSchemeV2Verifier.SF_ATTRIBUTE_ANDROID_APK_SIGNED_NAME);
        if (apkSignatureSchemeIdList != null) {
            // This field contains a comma-separated list of APK signature scheme IDs which
            // were used to sign this APK. If an ID is known to us, it means signatures of that
            // scheme were stripped from the APK because otherwise we wouldn't have fallen back
            // to verifying the APK using the JAR signature scheme.
            boolean v2SignatureGenerated = false;
            StringTokenizer tokenizer = new StringTokenizer(apkSignatureSchemeIdList, ",");
            while (tokenizer.hasMoreTokens()) {
                String idText = tokenizer.nextToken().trim();
                if (idText.isEmpty()) {
                    continue;
                }
                int id;
                try {
                    id = Integer.parseInt(idText);
                } catch (Exception ignored) {
                    continue;
                }
                if (id == ApkSignatureSchemeV2Verifier.SF_ATTRIBUTE_ANDROID_APK_SIGNED_ID) {
                    // This APK was supposed to be signed with APK Signature Scheme v2 but no
                    // such signature was found.
                    v2SignatureGenerated = true;
                    break;
                }
            }
            if (v2SignatureGenerated) {
                throw new SecurityException(signatureFile + " indicates " + jarName + " is signed using APK Signature Scheme v2, but no such signature was" + " found. Signature stripped?");
            }
        }
    }
    // Do we actually have any signatures to look at?
    if (attributes.get(Attributes.Name.SIGNATURE_VERSION) == null) {
        return;
    }
    boolean createdBySigntool = false;
    String createdBy = attributes.getValue("Created-By");
    if (createdBy != null) {
        createdBySigntool = createdBy.indexOf("signtool") != -1;
    }
    // such verification.
    if (mainAttributesEnd > 0 && !createdBySigntool) {
        String digestAttribute = "-Digest-Manifest-Main-Attributes";
        if (!verify(attributes, digestAttribute, manifestBytes, 0, mainAttributesEnd, false, true)) {
            throw failedVerification(jarName, signatureFile);
        }
    }
    // Use .SF to verify the whole manifest.
    String digestAttribute = createdBySigntool ? "-Digest" : "-Digest-Manifest";
    if (!verify(attributes, digestAttribute, manifestBytes, 0, manifestBytes.length, false, false)) {
        Iterator<Map.Entry<String, Attributes>> it = entries.entrySet().iterator();
        while (it.hasNext()) {
            Map.Entry<String, Attributes> entry = it.next();
            StrictJarManifest.Chunk chunk = manifest.getChunk(entry.getKey());
            if (chunk == null) {
                return;
            }
            if (!verify(entry.getValue(), "-Digest", manifestBytes, chunk.start, chunk.end, createdBySigntool, false)) {
                throw invalidDigest(signatureFile, entry.getKey(), jarName);
            }
        }
    }
    metaEntries.put(signatureFile, null);
    signatures.put(signatureFile, entries);
}
Body of Second Method:
{
    // Found Digital Sig, .SF should already have been read
    String signatureFile = certFile.substring(0, certFile.lastIndexOf('.')) + ".SF";
    byte[] sfBytes = metaEntries.get(signatureFile);
    if (sfBytes == null) {
        return;
    }
    byte[] manifestBytes = metaEntries.get(JarFile.MANIFEST_NAME);
    // Manifest entry is required for any verifications.
    if (manifestBytes == null) {
        return;
    }
    byte[] sBlockBytes = metaEntries.get(certFile);
    try {
        Certificate[] signerCertChain = verifyBytes(sBlockBytes, sfBytes);
        if (signerCertChain != null) {
            certificates.put(signatureFile, signerCertChain);
        }
    } catch (GeneralSecurityException e) {
        throw failedVerification(jarName, signatureFile, e);
    }
    // Verify manifest hash in .sf file
    Attributes attributes = new Attributes();
    HashMap<String, Attributes> entries = new HashMap<String, Attributes>();
    try {
        StrictJarManifestReader im = new StrictJarManifestReader(sfBytes, attributes);
        im.readEntries(entries, null);
    } catch (IOException e) {
        return;
    }
    // If requested, check whether a newer APK Signature Scheme signature was stripped.
    if (signatureSchemeRollbackProtectionsEnforced) {
        String apkSignatureSchemeIdList = attributes.getValue(SF_ATTRIBUTE_ANDROID_APK_SIGNED_NAME);
        if (apkSignatureSchemeIdList != null) {
            // This field contains a comma-separated list of APK signature scheme IDs which
            // were used to sign this APK. If an ID is known to us, it means signatures of that
            // scheme were stripped from the APK because otherwise we wouldn't have fallen back
            // to verifying the APK using the JAR signature scheme.
            boolean v2SignatureGenerated = false;
            boolean v3SignatureGenerated = false;
            StringTokenizer tokenizer = new StringTokenizer(apkSignatureSchemeIdList, ",");
            while (tokenizer.hasMoreTokens()) {
                String idText = tokenizer.nextToken().trim();
                if (idText.isEmpty()) {
                    continue;
                }
                int id;
                try {
                    id = Integer.parseInt(idText);
                } catch (Exception ignored) {
                    continue;
                }
                if (id == ApkSignatureSchemeV2Verifier.SF_ATTRIBUTE_ANDROID_APK_SIGNED_ID) {
                    // This APK was supposed to be signed with APK Signature Scheme v2 but no
                    // such signature was found.
                    v2SignatureGenerated = true;
                    break;
                }
                if (id == ApkSignatureSchemeV3Verifier.SF_ATTRIBUTE_ANDROID_APK_SIGNED_ID) {
                    // This APK was supposed to be signed with APK Signature Scheme v3 but no
                    // such signature was found.
                    v3SignatureGenerated = true;
                    break;
                }
            }
            if (v2SignatureGenerated) {
                throw new SecurityException(signatureFile + " indicates " + jarName + " is signed using APK Signature Scheme v2, but no such signature was" + " found. Signature stripped?");
            }
            if (v3SignatureGenerated) {
                throw new SecurityException(signatureFile + " indicates " + jarName + " is signed using APK Signature Scheme v3, but no such signature was" + " found. Signature stripped?");
            }
        }
    }
    // Do we actually have any signatures to look at?
    if (attributes.get(Attributes.Name.SIGNATURE_VERSION) == null) {
        return;
    }
    boolean createdBySigntool = false;
    String createdBy = attributes.getValue("Created-By");
    if (createdBy != null) {
        createdBySigntool = createdBy.indexOf("signtool") != -1;
    }
    // such verification.
    if (mainAttributesEnd > 0 && !createdBySigntool) {
        String digestAttribute = "-Digest-Manifest-Main-Attributes";
        if (!verify(attributes, digestAttribute, manifestBytes, 0, mainAttributesEnd, false, true)) {
            throw failedVerification(jarName, signatureFile);
        }
    }
    // Use .SF to verify the whole manifest.
    String digestAttribute = createdBySigntool ? "-Digest" : "-Digest-Manifest";
    if (!verify(attributes, digestAttribute, manifestBytes, 0, manifestBytes.length, false, false)) {
        Iterator<Map.Entry<String, Attributes>> it = entries.entrySet().iterator();
        while (it.hasNext()) {
            Map.Entry<String, Attributes> entry = it.next();
            StrictJarManifest.Chunk chunk = manifest.getChunk(entry.getKey());
            if (chunk == null) {
                return;
            }
            if (!verify(entry.getValue(), "-Digest", manifestBytes, chunk.start, chunk.end, createdBySigntool, false)) {
                throw invalidDigest(signatureFile, entry.getKey(), jarName);
            }
        }
    }
    metaEntries.put(signatureFile, null);
    signatures.put(signatureFile, entries);
}
------------------------
Find a silently evolved API code:android.content.res.TypedArray.getInteger:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the integer value for the attribute at <var>index</var>.
 * <p>
 * Unlike {@link #getInt(int, int)}, this method will throw an exception if
 * the attribute is defined but is not an integer.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute integer value, or defValue if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not an integer.
 */

Body of Frist Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    final int attrIndex = index;
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + AssetManager.STYLE_DATA];
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index, value);
        throw new UnsupportedOperationException("Failed to resolve attribute at index " + attrIndex + ": " + value);
    }
    throw new UnsupportedOperationException("Can't convert value at index " + attrIndex + " to integer: type=0x" + Integer.toHexString(type));
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    final int attrIndex = index;
    index *= STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + STYLE_DATA];
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index, value);
        throw new UnsupportedOperationException("Failed to resolve attribute at index " + attrIndex + ": " + value);
    }
    throw new UnsupportedOperationException("Can't convert value at index " + attrIndex + " to integer: type=0x" + Integer.toHexString(type));
}
------------------------
Find a silently evolved API code:android.text.Selection.extendDown:COMMENT
Method Modifier: public      static      
Comment:/**
 * Move the selection end to the buffer offset physically below
 * the current selection end.
 */

Body of Frist Method:
{
    int end = getSelectionEnd(text);
    int line = layout.getLineForOffset(end);
    if (line < layout.getLineCount() - 1) {
        int move;
        if (layout.getParagraphDirection(line) == layout.getParagraphDirection(line + 1)) {
            float h = layout.getPrimaryHorizontal(end);
            move = layout.getOffsetForHorizontal(line + 1, h);
        } else {
            move = layout.getLineStart(line + 1);
        }
        extendSelection(text, move);
        return true;
    } else if (end != text.length()) {
        extendSelection(text, text.length());
        return true;
    }
    return true;
}
Body of Second Method:
{
    int end = getSelectionEnd(text);
    int line = layout.getLineForOffset(end);
    if (line < layout.getLineCount() - 1) {
        setSelectionAndMemory(text, layout, line, end, 1, /* direction */
        true);
        return true;
    } else if (end != text.length()) {
        extendSelection(text, text.length(), -1);
        return true;
    }
    return true;
}
------------------------
Find a silently evolved API code:android.webkit.UserPackage.hasCorrectTargetSdkVersion:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Returns whether the package represented by {@param packageInfo} targets a sdk version
 * supported by the current framework version.
 */

Body of Frist Method:
{
    return packageInfo.applicationInfo.targetSdkVersion >= Build.VERSION_CODES.O_MR1;
}
Body of Second Method:
{
    return packageInfo.applicationInfo.targetSdkVersion >= MINIMUM_SUPPORTED_SDK;
}
------------------------
Find a silently evolved API code:android.content.ContentResolver.getSyncStatus:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Returns the status that matches the authority.
 * @param account the account whose setting we are querying
 * @param authority the provider whose behavior is being queried
 * @return the SyncStatusInfo for the authority, or null if none exists
 * @hide
 */

Body of Frist Method:
{
    try {
        return getContentService().getSyncStatus(account, authority, null);
    } catch (RemoteException e) {
        throw new RuntimeException("the ContentService should always be reachable", e);
    }
}
Body of Second Method:
{
    try {
        return getContentService().getSyncStatus(account, authority, null);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.net.NetworkStats.spliceOperationsFrom:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Splice in {@link #operations} from the given {@link NetworkStats} based
 * on matching {@link #uid} and {@link #tag} rows. Ignores {@link #iface},
 * since operation counts are at data layer.
 */

Body of Frist Method:
{
    for (int i = 0; i < size; i++) {
        final int j = stats.findIndex(iface[i], uid[i], set[i], tag[i], metered[i], roaming[i]);
        if (j == -1) {
            operations[i] = 0;
        } else {
            operations[i] = stats.operations[j];
        }
    }
}
Body of Second Method:
{
    for (int i = 0; i < size; i++) {
        final int j = stats.findIndex(iface[i], uid[i], set[i], tag[i], metered[i], roaming[i], defaultNetwork[i]);
        if (j == -1) {
            operations[i] = 0;
        } else {
            operations[i] = stats.operations[j];
        }
    }
}
------------------------
Find a silently evolved API code:android.view.Surface.rotationToString:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Returns a human readable representation of a rotation.
 *
 * @param rotation The rotation.
 * @return The rotation symbolic name.
 *
 * @hide
 */

Body of Frist Method:
{
    switch(rotation) {
        case Surface.ROTATION_0:
            {
                return "ROTATION_0";
            }
        case Surface.ROTATION_90:
            {
                return "ROTATION_90";
            }
        case Surface.ROTATION_180:
            {
                return "ROTATION_180";
            }
        case Surface.ROTATION_270:
            {
                return "ROTATION_270";
            }
        default:
            {
                throw new IllegalArgumentException("Invalid rotation: " + rotation);
            }
    }
}
Body of Second Method:
{
    switch(rotation) {
        case Surface.ROTATION_0:
            {
                return "ROTATION_0";
            }
        case Surface.ROTATION_90:
            {
                return "ROTATION_90";
            }
        case Surface.ROTATION_180:
            {
                return "ROTATION_180";
            }
        case Surface.ROTATION_270:
            {
                return "ROTATION_270";
            }
        default:
            {
                return Integer.toString(rotation);
            }
    }
}
------------------------
Find a silently evolved API code:android.content.res.TypedArray.getThemeAttributeId:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Retrieves the theme attribute resource identifier for the attribute at
 * <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or not a
 * resource.
 *
 * @return Theme attribute resource identifier, or defValue if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @hide
 */

Body of Frist Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    if (data[index + AssetManager.STYLE_TYPE] == TypedValue.TYPE_ATTRIBUTE) {
        return data[index + AssetManager.STYLE_DATA];
    }
    return defValue;
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    index *= STYLE_NUM_ENTRIES;
    final int[] data = mData;
    if (data[index + STYLE_TYPE] == TypedValue.TYPE_ATTRIBUTE) {
        return data[index + STYLE_DATA];
    }
    return defValue;
}
------------------------
Find a silently evolved API code:android.widget.TimePickerClockDelegate.updateHeaderSeparator:COMMENT
Method Modifier: private     
Comment:/**
 * The time separator is defined in the Unicode CLDR and cannot be supposed to be ":".
 *
 * See http://unicode.org/cldr/trac/browser/trunk/common/main
 *
 * We pass the correct "skeleton" depending on 12 or 24 hours view and then extract the
 * separator as the character which is just after the hour marker in the returned pattern.
 */

Body of Frist Method:
{
    final String bestDateTimePattern = DateFormat.getBestDateTimePattern(mLocale, (mIs24Hour) ? "Hm" : "hm");
    final String separatorText;
    // See http://www.unicode.org/reports/tr35/tr35-dates.html for hour formats
    final char[] hourFormats = { 'H', 'h', 'K', 'k' };
    int hIndex = lastIndexOfAny(bestDateTimePattern, hourFormats);
    if (hIndex == -1) {
        // Default case
        separatorText = ":";
    } else {
        separatorText = Character.toString(bestDateTimePattern.charAt(hIndex + 1));
    }
    mSeparatorView.setText(separatorText);
    mTextInputPickerView.updateSeparator(separatorText);
}
Body of Second Method:
{
    final String bestDateTimePattern = DateFormat.getBestDateTimePattern(mLocale, (mIs24Hour) ? "Hm" : "hm");
    final String separatorText = getHourMinSeparatorFromPattern(bestDateTimePattern);
    mSeparatorView.setText(separatorText);
    mTextInputPickerView.updateSeparator(separatorText);
}
------------------------
Find a silently evolved API code:android.content.ContentResolver.unregisterContentObserver:COMMENT
Method Modifier: public      final       
Comment:/**
 * Unregisters a change observer.
 *
 * @param observer The previously registered observer that is no longer needed.
 * @see #registerContentObserver
 */

Body of Frist Method:
{
    Preconditions.checkNotNull(observer, "observer");
    try {
        IContentObserver contentObserver = observer.releaseContentObserver();
        if (contentObserver != null) {
            getContentService().unregisterContentObserver(contentObserver);
        }
    } catch (RemoteException e) {
    }
}
Body of Second Method:
{
    Preconditions.checkNotNull(observer, "observer");
    try {
        IContentObserver contentObserver = observer.releaseContentObserver();
        if (contentObserver != null) {
            getContentService().unregisterContentObserver(contentObserver);
        }
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.content.ContentResolver.getIsSyncableAsUser:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @see #getIsSyncable(Account, String)
 * @hide
 */

Body of Frist Method:
{
    try {
        return getContentService().getIsSyncableAsUser(account, authority, userId);
    } catch (RemoteException e) {
        throw new RuntimeException("the ContentService should always be reachable", e);
    }
}
Body of Second Method:
{
    try {
        return getContentService().getIsSyncableAsUser(account, authority, userId);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.content.ContentResolver.getMasterSyncAutomaticallyAsUser:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @see #getMasterSyncAutomatically()
 * @hide
 */

Body of Frist Method:
{
    try {
        return getContentService().getMasterSyncAutomaticallyAsUser(userId);
    } catch (RemoteException e) {
        throw new RuntimeException("the ContentService should always be reachable", e);
    }
}
Body of Second Method:
{
    try {
        return getContentService().getMasterSyncAutomaticallyAsUser(userId);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.nfc.cardemulation.CardEmulation.setDefaultServiceForCategory:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    try {
        return sService.setDefaultServiceForCategory(UserHandle.myUserId(), service, category);
    } catch (RemoteException e) {
        // Try one more time
        recoverService();
        if (sService == null) {
            Log.e(TAG, "Failed to recover CardEmulationService.");
            return false;
        }
        try {
            return sService.setDefaultServiceForCategory(UserHandle.myUserId(), service, category);
        } catch (RemoteException ee) {
            Log.e(TAG, "Failed to reach CardEmulationService.");
            return false;
        }
    }
}
Body of Second Method:
{
    try {
        return sService.setDefaultServiceForCategory(mContext.getUserId(), service, category);
    } catch (RemoteException e) {
        // Try one more time
        recoverService();
        if (sService == null) {
            Log.e(TAG, "Failed to recover CardEmulationService.");
            return false;
        }
        try {
            return sService.setDefaultServiceForCategory(mContext.getUserId(), service, category);
        } catch (RemoteException ee) {
            Log.e(TAG, "Failed to reach CardEmulationService.");
            return false;
        }
    }
}
------------------------
Find a silently evolved API code:android.telephony.SignalStrength.getDbm:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the signal strength as dBm
 *
 * @hide
 */

Body of Frist Method:
{
    int dBm = INVALID;
    if (isGsm()) {
        dBm = getLteDbm();
        if (dBm == INVALID) {
            if (getTdScdmaLevel() == SIGNAL_STRENGTH_NONE_OR_UNKNOWN) {
                dBm = getGsmDbm();
            } else {
                dBm = getTdScdmaDbm();
            }
        }
    } else {
        int cdmaDbm = getCdmaDbm();
        int evdoDbm = getEvdoDbm();
        return (evdoDbm == -120) ? cdmaDbm : ((cdmaDbm == -120) ? evdoDbm : (cdmaDbm < evdoDbm ? cdmaDbm : evdoDbm));
    }
    if (DBG)
        log("getDbm=" + dBm);
    return dBm;
}
Body of Second Method:
{
    int dBm = INVALID;
    if (isGsm()) {
        dBm = getLteDbm();
        if (dBm == INVALID) {
            if (getTdScdmaLevel() == SIGNAL_STRENGTH_NONE_OR_UNKNOWN) {
                if (getWcdmaDbm() == INVALID) {
                    dBm = getGsmDbm();
                } else {
                    dBm = getWcdmaDbm();
                }
            } else {
                dBm = getTdScdmaDbm();
            }
        }
    } else {
        int cdmaDbm = getCdmaDbm();
        int evdoDbm = getEvdoDbm();
        return (evdoDbm == -120) ? cdmaDbm : ((cdmaDbm == -120) ? evdoDbm : (cdmaDbm < evdoDbm ? cdmaDbm : evdoDbm));
    }
    if (DBG)
        log("getDbm=" + dBm);
    return dBm;
}
------------------------
Find a silently evolved API code:android.content.ContentResolver.registerContentObserver:COMMENT
Method Modifier: public      final       hidden      
Comment:/**
 * @hide - designated user version
 */

Body of Frist Method:
{
    try {
        getContentService().registerContentObserver(uri, notifyForDescendents, observer.getContentObserver(), userHandle, mTargetSdkVersion);
    } catch (RemoteException e) {
    }
}
Body of Second Method:
{
    try {
        getContentService().registerContentObserver(uri, notifyForDescendents, observer.getContentObserver(), userHandle, mTargetSdkVersion);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.location.GnssMeasurement.getMultipathIndicatorString:COMMENT
Method Modifier: private     
Comment:/**
 * Gets a string representation of the 'multi-path indicator'.
 *
 * <p>For internal and logging use only.
 */

Body of Frist Method:
{
    switch(mMultipathIndicator) {
        case MULTIPATH_INDICATOR_UNKNOWN:
            return "Unknown";
        case MULTIPATH_INDICATOR_DETECTED:
            return "Detected";
        case MULTIPATH_INDICATOR_NOT_DETECTED:
            return "NotDetected";
        default:
            return "<Invalid:" + mMultipathIndicator + ">";
    }
}
Body of Second Method:
{
    switch(mMultipathIndicator) {
        case MULTIPATH_INDICATOR_UNKNOWN:
            return "Unknown";
        case MULTIPATH_INDICATOR_DETECTED:
            return "Detected";
        case MULTIPATH_INDICATOR_NOT_DETECTED:
            return "NotDetected";
        default:
            return "<Invalid: " + mMultipathIndicator + ">";
    }
}
------------------------
Find a silently evolved API code:android.metrics.LogMaker.setLatency:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Set event latency.
 *
 * @hide // TODO Expose in the future?  Too late for O.
 */

Body of Frist Method:
{
    entries.put(MetricsEvent.NOTIFICATION_SINCE_CREATE_MILLIS, milliseconds);
    return this;
}
Body of Second Method:
{
    entries.put(MetricsEvent.RESERVED_FOR_LOGBUILDER_LATENCY_MILLIS, milliseconds);
    return this;
}
------------------------
Find a silently evolved API code:android.net.VpnService.prepare:COMMENT
Method Modifier: public      static      
Comment:/**
 * Prepare to establish a VPN connection. This method returns {@code null}
 * if the VPN application is already prepared or if the user has previously
 * consented to the VPN application. Otherwise, it returns an
 * {@link Intent} to a system activity. The application should launch the
 * activity using {@link Activity#startActivityForResult} to get itself
 * prepared. The activity may pop up a dialog to require user action, and
 * the result will come back via its {@link Activity#onActivityResult}.
 * If the result is {@link Activity#RESULT_OK}, the application becomes
 * prepared and is granted to use other methods in this class.
 *
 * <p>Only one application can be granted at the same time. The right
 * is revoked when another application is granted. The application
 * losing the right will be notified via its {@link #onRevoke}. Unless
 * it becomes prepared again, subsequent calls to other methods in this
 * class will fail.
 *
 * <p>The user may disable the VPN at any time while it is activated, in
 * which case this method will return an intent the next time it is
 * executed to obtain the user's consent again.
 *
 * @see #onRevoke
 */

Body of Frist Method:
{
    try {
        if (getService().prepareVpn(context.getPackageName(), null, UserHandle.myUserId())) {
            return null;
        }
    } catch (RemoteException e) {
    // ignore
    }
    return VpnConfig.getIntentForConfirmation();
}
Body of Second Method:
{
    try {
        if (getService().prepareVpn(context.getPackageName(), null, context.getUserId())) {
            return null;
        }
    } catch (RemoteException e) {
    // ignore
    }
    return VpnConfig.getIntentForConfirmation();
}
------------------------
Find a silently evolved API code:android.content.Context.createPackageContextAsUser:COMMENT
<android.content.Context: Context createPackageContextAsUser(String,int,UserHandle)>
public      abstract    hidden      ->public      hidden      
Method Modifier: public      abstract    hidden      
Method Modifier: Yes         Yes         Yes         
Method Updated:  Yes         No          Yes         
Comment:/**
 * Similar to {@link #createPackageContext(String, int)}, but with a
 * different {@link UserHandle}. For example, {@link #getContentResolver()}
 * will open any {@link Uri} as the given user.
 *
 * @hide
 */

Body of Frist Method:

Body of Second Method:
{
    if (Build.IS_ENG) {
        throw new IllegalStateException("createPackageContextAsUser not overridden!");
    }
    return this;
}
------------------------
Find a silently evolved API code:android.net.TrafficStats.getMobileRxPackets:COMMENT
Method Modifier: public      static      
Comment:/**
 * Return number of packets received across mobile networks since device
 * boot. Counts packets across all mobile network interfaces, and always
 * increases monotonically since device boot. Statistics are measured at the
 * network layer, so they include both TCP and UDP usage.
 * <p>
 * Before {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}, this may
 * return {@link #UNSUPPORTED} on devices where statistics aren't available.
 */

Body of Frist Method:
{
    long total = 0;
    for (String iface : getMobileIfaces()) {
        total += getRxPackets(iface);
    }
    return total;
}
Body of Second Method:
{
    long total = 0;
    for (String iface : getMobileIfaces()) {
        total += addIfSupported(getRxPackets(iface));
    }
    return total;
}
------------------------
Find a silently evolved API code:android.view.TouchDelegate.onTouchEvent:COMMENT
Method Modifier: public      
Comment:/**
 * Will forward touch events to the delegate view if the event is within the bounds
 * specified in the constructor.
 *
 * @param event The touch event to forward
 * @return True if the event was forwarded to the delegate, false otherwise.
 */

Body of Frist Method:
{
    int x = (int) event.getX();
    int y = (int) event.getY();
    boolean sendToDelegate = false;
    boolean hit = true;
    boolean handled = false;
    switch(event.getAction()) {
        case MotionEvent.ACTION_DOWN:
            Rect bounds = mBounds;
            if (bounds.contains(x, y)) {
                mDelegateTargeted = true;
                sendToDelegate = true;
            }
            break;
        case MotionEvent.ACTION_UP:
        case MotionEvent.ACTION_MOVE:
            sendToDelegate = mDelegateTargeted;
            if (sendToDelegate) {
                Rect slopBounds = mSlopBounds;
                if (!slopBounds.contains(x, y)) {
                    hit = false;
                }
            }
            break;
        case MotionEvent.ACTION_CANCEL:
            sendToDelegate = mDelegateTargeted;
            mDelegateTargeted = false;
            break;
    }
    if (sendToDelegate) {
        final View delegateView = mDelegateView;
        if (hit) {
            // Offset event coordinates to be inside the target view
            event.setLocation(delegateView.getWidth() / 2, delegateView.getHeight() / 2);
        } else {
            // Offset event coordinates to be outside the target view (in case it does
            // something like tracking pressed state)
            int slop = mSlop;
            event.setLocation(-(slop * 2), -(slop * 2));
        }
        handled = delegateView.dispatchTouchEvent(event);
    }
    return handled;
}
Body of Second Method:
{
    int x = (int) event.getX();
    int y = (int) event.getY();
    boolean sendToDelegate = false;
    boolean hit = true;
    boolean handled = false;
    switch(event.getActionMasked()) {
        case MotionEvent.ACTION_DOWN:
            mDelegateTargeted = mBounds.contains(x, y);
            sendToDelegate = mDelegateTargeted;
            break;
        case MotionEvent.ACTION_POINTER_DOWN:
        case MotionEvent.ACTION_POINTER_UP:
        case MotionEvent.ACTION_UP:
        case MotionEvent.ACTION_MOVE:
            sendToDelegate = mDelegateTargeted;
            if (sendToDelegate) {
                Rect slopBounds = mSlopBounds;
                if (!slopBounds.contains(x, y)) {
                    hit = false;
                }
            }
            break;
        case MotionEvent.ACTION_CANCEL:
            sendToDelegate = mDelegateTargeted;
            mDelegateTargeted = false;
            break;
    }
    if (sendToDelegate) {
        final View delegateView = mDelegateView;
        if (hit) {
            // Offset event coordinates to be inside the target view
            event.setLocation(delegateView.getWidth() / 2, delegateView.getHeight() / 2);
        } else {
            // Offset event coordinates to be outside the target view (in case it does
            // something like tracking pressed state)
            int slop = mSlop;
            event.setLocation(-(slop * 2), -(slop * 2));
        }
        handled = delegateView.dispatchTouchEvent(event);
    }
    return handled;
}
------------------------
Find a silently evolved API code:android.graphics.Picture.draw:COMMENT
Method Modifier: public      
Comment:/**
 * Draw this picture on the canvas.
 * <p>
 * Prior to {@link android.os.Build.VERSION_CODES#LOLLIPOP}, this call could
 * have the side effect of changing the matrix and clip of the canvas
 * if this picture had imbalanced saves/restores.
 *
 * <p>
 * <strong>Note:</strong> This forces the picture to internally call
 * {@link Picture#endRecording()} in order to prepare for playback.
 *
 * @param canvas  The picture is drawn to this canvas
 */

Body of Frist Method:
{
    if (mRecordingCanvas != null) {
        endRecording();
    }
    nativeDraw(canvas.getNativeCanvasWrapper(), mNativePicture);
}
Body of Second Method:
{
    if (mRecordingCanvas != null) {
        endRecording();
    }
    if (mRequiresHwAcceleration && !canvas.isHardwareAccelerated()) {
        canvas.onHwBitmapInSwMode();
    }
    nativeDraw(canvas.getNativeCanvasWrapper(), mNativePicture);
}
------------------------
Find a silently evolved API code:android.bluetooth.le.AdvertisingSetParameters.getPrimaryPhy:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the primary advertising phy.
 */

Body of Frist Method:
{
    return primaryPhy;
}
Body of Second Method:
{
    return mPrimaryPhy;
}
------------------------
Find a silently evolved API code:android.os.Debug.MemoryInfo.getOtherSharedDirty:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return otherStats[which * NUM_CATEGORIES + offsetSharedDirty];
}
Body of Second Method:
{
    return otherStats[which * NUM_CATEGORIES + OFFSET_SHARED_DIRTY];
}
------------------------
Find a silently evolved API code:android.nfc.cardemulation.CardEmulation.getAidsForService:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieves the currently registered AIDs for the specified
 * category for a service.
 *
 * <p>Note that this will only return AIDs that were dynamically
 * registered using {@link #registerAidsForService(ComponentName, String, List)}
 * method. It will *not* return AIDs that were statically registered
 * in the manifest.
 *
 * @param service The component name of the service
 * @param category The category for which the AIDs were registered,
 * e.g. {@link #CATEGORY_PAYMENT}
 * @return The list of AIDs registered for this category, or null if it couldn't be found.
 */

Body of Frist Method:
{
    try {
        AidGroup group = sService.getAidGroupForService(UserHandle.myUserId(), service, category);
        return (group != null ? group.getAids() : null);
    } catch (RemoteException e) {
        recoverService();
        if (sService == null) {
            Log.e(TAG, "Failed to recover CardEmulationService.");
            return null;
        }
        try {
            AidGroup group = sService.getAidGroupForService(UserHandle.myUserId(), service, category);
            return (group != null ? group.getAids() : null);
        } catch (RemoteException ee) {
            Log.e(TAG, "Failed to recover CardEmulationService.");
            return null;
        }
    }
}
Body of Second Method:
{
    try {
        AidGroup group = sService.getAidGroupForService(mContext.getUserId(), service, category);
        return (group != null ? group.getAids() : null);
    } catch (RemoteException e) {
        recoverService();
        if (sService == null) {
            Log.e(TAG, "Failed to recover CardEmulationService.");
            return null;
        }
        try {
            AidGroup group = sService.getAidGroupForService(mContext.getUserId(), service, category);
            return (group != null ? group.getAids() : null);
        } catch (RemoteException ee) {
            Log.e(TAG, "Failed to recover CardEmulationService.");
            return null;
        }
    }
}
------------------------
Find a silently evolved API code:android.telephony.SignalStrength.getLevel:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve an abstract level value for the overall signal strength.
 *
 * @return a single integer from 0 to 4 representing the general signal quality.
 * This may take into account many different radio technology inputs.
 * 0 represents very poor signal strength
 * while 4 represents a very strong signal strength.
 */

Body of Frist Method:
{
    int level = 0;
    if (isGsm) {
        level = getLteLevel();
        if (level == SIGNAL_STRENGTH_NONE_OR_UNKNOWN) {
            level = getTdScdmaLevel();
            if (level == SIGNAL_STRENGTH_NONE_OR_UNKNOWN) {
                level = getGsmLevel();
            }
        }
    } else {
        int cdmaLevel = getCdmaLevel();
        int evdoLevel = getEvdoLevel();
        if (evdoLevel == SIGNAL_STRENGTH_NONE_OR_UNKNOWN) {
            /* We don't know evdo, use cdma */
            level = cdmaLevel;
        } else if (cdmaLevel == SIGNAL_STRENGTH_NONE_OR_UNKNOWN) {
            /* We don't know cdma, use evdo */
            level = evdoLevel;
        } else {
            /* We know both, use the lowest level */
            level = cdmaLevel < evdoLevel ? cdmaLevel : evdoLevel;
        }
    }
    if (DBG)
        log("getLevel=" + level);
    return level;
}
Body of Second Method:
{
    int level = mIsGsm ? getGsmRelatedSignalStrength() : getCdmaRelatedSignalStrength();
    if (DBG)
        log("getLevel=" + level);
    return level;
}
------------------------
Find a silently evolved API code:android.net.TrafficStats.getRxPackets:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * {@hide}
 */

Body of Frist Method:
{
    return nativeGetIfaceStat(iface, TYPE_RX_PACKETS);
}
Body of Second Method:
{
    try {
        return getStatsService().getIfaceStats(iface, TYPE_RX_PACKETS);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.telephony.mbms.DownloadRequest.getHash:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Retrieves the hash string that should be used as the filename when storing a token for
 * this DownloadRequest.
 * @hide
 */

Body of Frist Method:
{
    MessageDigest digest;
    try {
        digest = MessageDigest.getInstance("SHA-256");
    } catch (NoSuchAlgorithmException e) {
        throw new RuntimeException("Could not get sha256 hash object");
    }
    if (version >= 1) {
        // Hash the source URI and the app intent
        digest.update(sourceUri.toString().getBytes(StandardCharsets.UTF_8));
        if (serializedResultIntentForApp != null) {
            digest.update(serializedResultIntentForApp.getBytes(StandardCharsets.UTF_8));
        }
    }
    // Add updates for future versions here
    return Base64.encodeToString(digest.digest(), Base64.URL_SAFE | Base64.NO_WRAP);
}
Body of Second Method:
{
    MessageDigest digest;
    try {
        digest = MessageDigest.getInstance("SHA-256");
    } catch (NoSuchAlgorithmException e) {
        throw new RuntimeException("Could not get sha256 hash object");
    }
    if (version >= 1) {
        // Hash the source, destination, and the app intent
        digest.update(sourceUri.toString().getBytes(StandardCharsets.UTF_8));
        digest.update(destinationUri.toString().getBytes(StandardCharsets.UTF_8));
        if (serializedResultIntentForApp != null) {
            digest.update(serializedResultIntentForApp.getBytes(StandardCharsets.UTF_8));
        }
    }
    // Add updates for future versions here
    return Base64.encodeToString(digest.digest(), Base64.URL_SAFE | Base64.NO_WRAP);
}
------------------------
Find a silently evolved API code:android.text.Selection.setSelection:COMMENT
Method Modifier: public      static      
Comment:/**
 * Set the selection anchor to <code>start</code> and the selection edge
 * to <code>stop</code>.
 */

Body of Frist Method:
{
    // int len = text.length();
    // start = pin(start, 0, len);  XXX remove unless we really need it
    // stop = pin(stop, 0, len);
    int ostart = getSelectionStart(text);
    int oend = getSelectionEnd(text);
    if (ostart != start || oend != stop) {
        text.setSpan(SELECTION_START, start, start, Spanned.SPAN_POINT_POINT | Spanned.SPAN_INTERMEDIATE);
        text.setSpan(SELECTION_END, stop, stop, Spanned.SPAN_POINT_POINT);
    }
}
Body of Second Method:
{
    setSelection(text, start, stop, -1);
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiInfo.writeToParcel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Implement the Parcelable interface {@hide}
 */

Body of Frist Method:
{
    dest.writeInt(mNetworkId);
    dest.writeInt(mRssi);
    dest.writeInt(mLinkSpeed);
    dest.writeInt(mFrequency);
    if (mIpAddress != null) {
        dest.writeByte((byte) 1);
        dest.writeByteArray(mIpAddress.getAddress());
    } else {
        dest.writeByte((byte) 0);
    }
    if (mWifiSsid != null) {
        dest.writeInt(1);
        mWifiSsid.writeToParcel(dest, flags);
    } else {
        dest.writeInt(0);
    }
    dest.writeString(mBSSID);
    dest.writeString(mMacAddress);
    dest.writeInt(mMeteredHint ? 1 : 0);
    dest.writeInt(mEphemeral ? 1 : 0);
    dest.writeInt(score);
    dest.writeDouble(txSuccessRate);
    dest.writeDouble(txRetriesRate);
    dest.writeDouble(txBadRate);
    dest.writeDouble(rxSuccessRate);
    dest.writeInt(badRssiCount);
    dest.writeInt(lowRssiCount);
    mSupplicantState.writeToParcel(dest, flags);
}
Body of Second Method:
{
    dest.writeInt(mNetworkId);
    dest.writeInt(mRssi);
    dest.writeInt(mLinkSpeed);
    dest.writeInt(mFrequency);
    if (mIpAddress != null) {
        dest.writeByte((byte) 1);
        dest.writeByteArray(mIpAddress.getAddress());
    } else {
        dest.writeByte((byte) 0);
    }
    if (mWifiSsid != null) {
        dest.writeInt(1);
        mWifiSsid.writeToParcel(dest, flags);
    } else {
        dest.writeInt(0);
    }
    dest.writeString(mBSSID);
    dest.writeString(mMacAddress);
    dest.writeInt(mMeteredHint ? 1 : 0);
    dest.writeInt(mEphemeral ? 1 : 0);
    dest.writeInt(score);
    dest.writeDouble(txSuccessRate);
    dest.writeDouble(txRetriesRate);
    dest.writeDouble(txBadRate);
    dest.writeDouble(rxSuccessRate);
    mSupplicantState.writeToParcel(dest, flags);
}
------------------------
Find a silently evolved API code:android.media.session.MediaController.TransportControls.playFromSearch:COMMENT
Method Modifier: public      
Comment:/**
 * Request that the player start playback for a specific search query.
 * An empty or null query should be treated as a request to play any
 * music.
 *
 * @param query The search query.
 * @param extras Optional extras that can include extra information
 * about the query.
 */

Body of Frist Method:
{
    if (query == null) {
        // This is to remain compatible with
        // INTENT_ACTION_MEDIA_PLAY_FROM_SEARCH
        query = "";
    }
    try {
        mSessionBinder.playFromSearch(query, extras);
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling play(" + query + ").", e);
    }
}
Body of Second Method:
{
    if (query == null) {
        // This is to remain compatible with
        // INTENT_ACTION_MEDIA_PLAY_FROM_SEARCH
        query = "";
    }
    try {
        mSessionBinder.playFromSearch(mContext.getPackageName(), mCbStub, query, extras);
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling play(" + query + ").", e);
    }
}
------------------------
Find a silently evolved API code:android.net.apf.Bpf2Apf.convert:COMMENT
Method Modifier: public      static      
Comment:/**
 * Convert the output of "tcpdump -d" (human readable BPF program dump) {@code bpf} into an APF
 * program and return it.
 */

Body of Frist Method:
{
    ApfGenerator gen = new ApfGenerator();
    for (String line : bpf.split("\\n")) convertLine(line, gen);
    return gen.generate();
}
Body of Second Method:
{
    ApfGenerator gen = new ApfGenerator(3);
    for (String line : bpf.split("\\n")) convertLine(line, gen);
    return gen.generate();
}
------------------------
Find a silently evolved API code:android.content.res.TypedArray.getFont:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the Typeface for the attribute at <var>index</var>.
 * <p>
 * This method will throw an exception if the attribute is defined but is
 * not a font.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return Typeface for the attribute, or {@code null} if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not a font resource.
 */

Body of Frist Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    final TypedValue value = mValue;
    if (getValueAt(index * AssetManager.STYLE_NUM_ENTRIES, value)) {
        if (value.type == TypedValue.TYPE_ATTRIBUTE) {
            throw new UnsupportedOperationException("Failed to resolve attribute at index " + index + ": " + value);
        }
        return mResources.getFont(value, value.resourceId);
    }
    return null;
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    final TypedValue value = mValue;
    if (getValueAt(index * STYLE_NUM_ENTRIES, value)) {
        if (value.type == TypedValue.TYPE_ATTRIBUTE) {
            throw new UnsupportedOperationException("Failed to resolve attribute at index " + index + ": " + value);
        }
        return mResources.getFont(value, value.resourceId);
    }
    return null;
}
------------------------
Find a silently evolved API code:android.nfc.cardemulation.NfcFCardEmulation.setNfcid2ForService:COMMENT
Method Modifier: public      
Comment:/**
 * Set a NFCID2 for the specified service.
 *
 * <p>The NFCID2 must be in range from "02FE000000000000" to "02FEFFFFFFFFFFFF".
 *
 * <p>If a NFCID2 was previously set for this service
 * (either statically through the manifest, or dynamically by using this API),
 * it will be replaced.
 *
 * <p>Note that you can only set the NFCID2 for a service that
 * is running under the same UID as the caller of this API. Typically
 * this means you need to call this from the same
 * package as the service itself, though UIDs can also
 * be shared between packages using shared UIDs.
 *
 * @param service The component name of the service
 * @param nfcid2 The NFCID2 to be registered
 * @return whether the setting was successful.
 */

Body of Frist Method:
{
    if (service == null || nfcid2 == null) {
        throw new NullPointerException("service or nfcid2 is null");
    }
    try {
        return sService.setNfcid2ForService(UserHandle.myUserId(), service, nfcid2);
    } catch (RemoteException e) {
        // Try one more time
        recoverService();
        if (sService == null) {
            Log.e(TAG, "Failed to recover CardEmulationService.");
            return false;
        }
        try {
            return sService.setNfcid2ForService(UserHandle.myUserId(), service, nfcid2);
        } catch (RemoteException ee) {
            Log.e(TAG, "Failed to reach CardEmulationService.");
            ee.rethrowAsRuntimeException();
            return false;
        }
    }
}
Body of Second Method:
{
    if (service == null || nfcid2 == null) {
        throw new NullPointerException("service or nfcid2 is null");
    }
    try {
        return sService.setNfcid2ForService(mContext.getUserId(), service, nfcid2);
    } catch (RemoteException e) {
        // Try one more time
        recoverService();
        if (sService == null) {
            Log.e(TAG, "Failed to recover CardEmulationService.");
            return false;
        }
        try {
            return sService.setNfcid2ForService(mContext.getUserId(), service, nfcid2);
        } catch (RemoteException ee) {
            Log.e(TAG, "Failed to reach CardEmulationService.");
            ee.rethrowAsRuntimeException();
            return false;
        }
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothDevice.getName:COMMENT
Method Modifier: public      
Comment:/**
 * Get the friendly Bluetooth name of the remote device.
 *
 * <p>The local adapter will automatically retrieve remote names when
 * performing a device scan, and will cache them. This method just returns
 * the name for this device from the cache.
 *
 * @return the Bluetooth name, or null if there was a problem.
 */

Body of Frist Method:
{
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, "BT not enabled. Cannot get Remote Device name");
        return null;
    }
    try {
        return service.getRemoteName(this);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return null;
}
Body of Second Method:
{
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, "BT not enabled. Cannot get Remote Device name");
        return null;
    }
    try {
        String name = service.getRemoteName(this);
        if (name != null) {
            return name.replaceAll("[\\t\\n\\r]+", " ");
        }
        return null;
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return null;
}
------------------------
Find a silently evolved API code:android.telecom.InCallAdapter.setAudioRoute:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets the audio route (speaker, bluetooth, etc...). See {@link CallAudioState}.
 *
 * @param route The audio route to use.
 */

Body of Frist Method:
{
    try {
        mAdapter.setAudioRoute(route);
    } catch (RemoteException e) {
    }
}
Body of Second Method:
{
    try {
        mAdapter.setAudioRoute(route, null);
    } catch (RemoteException e) {
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.le.AdvertisingSetParameters.getSecondaryPhy:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the secondary advertising phy.
 */

Body of Frist Method:
{
    return secondaryPhy;
}
Body of Second Method:
{
    return mSecondaryPhy;
}
------------------------
Find a silently evolved API code:android.content.res.TypedArray.getFraction:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieves a fractional unit attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 * @param base The base value of this fraction.  In other words, a
 * standard fraction is multiplied by this value.
 * @param pbase The parent base value of this fraction.  In other
 * words, a parent fraction (nn%p) is multiplied by this
 * value.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute fractional value multiplied by the appropriate
 * base value, or defValue if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not a fraction.
 */

Body of Frist Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    final int attrIndex = index;
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_FRACTION) {
        return TypedValue.complexToFraction(data[index + AssetManager.STYLE_DATA], base, pbase);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index, value);
        throw new UnsupportedOperationException("Failed to resolve attribute at index " + attrIndex + ": " + value);
    }
    throw new UnsupportedOperationException("Can't convert value at index " + attrIndex + " to fraction: type=0x" + Integer.toHexString(type));
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    final int attrIndex = index;
    index *= STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_FRACTION) {
        return TypedValue.complexToFraction(data[index + STYLE_DATA], base, pbase);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index, value);
        throw new UnsupportedOperationException("Failed to resolve attribute at index " + attrIndex + ": " + value);
    }
    throw new UnsupportedOperationException("Can't convert value at index " + attrIndex + " to fraction: type=0x" + Integer.toHexString(type));
}
------------------------
Find a silently evolved API code:android.bluetooth.le.AdvertisingSetParameters.Builder.setLegacyMode:COMMENT
Method Modifier: public      
Comment:/**
 * When set to true, advertising set will advertise 4.x Spec compliant
 * advertisements.
 *
 * @param isLegacy whether legacy advertising mode should be used.
 */

Body of Frist Method:
{
    this.isLegacy = isLegacy;
    return this;
}
Body of Second Method:
{
    mIsLegacy = isLegacy;
    return this;
}
------------------------
Find a silently evolved API code:android.hardware.location.ContextHubInfo.getStaticSwVersion:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * get static platform version number
 *
 * @return int - platform version number
 */

Body of Frist Method:
{
    return mStaticSwVersion;
}
Body of Second Method:
{
    return (mChreApiMajorVersion << 24) | (mChreApiMinorVersion << 16) | (mChrePatchVersion);
}
------------------------
Find a silently evolved API code:android.animation.ValueAnimator.getCurrentPlayTime:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the current position of the animation in time, which is equal to the current
 * time minus the time that the animation started. An animation that is not yet started will
 * return a value of zero, unless the animation has has its play time set via
 * {@link #setCurrentPlayTime(long)} or {@link #setCurrentFraction(float)}, in which case
 * it will return the time that was set.
 *
 * @return The current position in time of the animation.
 */

Body of Frist Method:
{
    if (!mInitialized || (!mStarted && mSeekFraction < 0)) {
        return 0;
    }
    if (mSeekFraction >= 0) {
        return (long) (mDuration * mSeekFraction);
    }
    float durationScale = sDurationScale == 0 ? 1 : sDurationScale;
    return (long) ((AnimationUtils.currentAnimationTimeMillis() - mStartTime) / durationScale);
}
Body of Second Method:
{
    if (!mInitialized || (!mStarted && mSeekFraction < 0)) {
        return 0;
    }
    if (mSeekFraction >= 0) {
        return (long) (mDuration * mSeekFraction);
    }
    float durationScale = resolveDurationScale();
    if (durationScale == 0f) {
        durationScale = 1f;
    }
    return (long) ((AnimationUtils.currentAnimationTimeMillis() - mStartTime) / durationScale);
}
------------------------
Find a silently evolved API code:android.util.proto.ProtoOutputStream.checkFieldId:COMMENT
Method Modifier: public      static      
Comment:/**
 * Validates that the fieldId providied is of the type and count from expectedType.
 *
 * The type must match exactly to pass this check.
 *
 * The count must match according to this truth table to pass the check:
 *
 * expectedFlags
 * UNKNOWN     SINGLE      REPEATED    PACKED
 * fieldId
 * UNKNOWN       true        false       false       false
 * SINGLE        x           true        false       false
 * REPEATED      x           false       true        false
 * PACKED        x           false       true        true
 *
 * @throws IllegalArgumentException if it is not.
 *
 * @return The raw ID of that field.
 */

Body of Frist Method:
{
    final long fieldCount = fieldId & FIELD_COUNT_MASK;
    final long fieldType = fieldId & FIELD_TYPE_MASK;
    final long expectedCount = expectedFlags & FIELD_COUNT_MASK;
    final long expectedType = expectedFlags & FIELD_TYPE_MASK;
    if (((int) fieldId) == 0) {
        throw new IllegalArgumentException("Invalid proto field " + (int) fieldId + " fieldId=" + Long.toHexString(fieldId));
    }
    if (fieldType != expectedType || !((fieldCount == expectedCount) || (fieldCount == FIELD_COUNT_PACKED && expectedCount == FIELD_COUNT_REPEATED))) {
        final String countString = getFieldCountString(fieldCount);
        final String typeString = getFieldTypeString(fieldType);
        if (typeString != null && countString != null) {
            final StringBuilder sb = new StringBuilder();
            if (expectedType == FIELD_TYPE_OBJECT) {
                sb.append("start");
            } else {
                sb.append("write");
            }
            sb.append(getFieldCountString(expectedCount));
            sb.append(getFieldTypeString(expectedType));
            sb.append(" called for field ");
            sb.append((int) fieldId);
            sb.append(" which should be used with ");
            if (fieldType == FIELD_TYPE_OBJECT) {
                sb.append("start");
            } else {
                sb.append("write");
            }
            sb.append(countString);
            sb.append(typeString);
            if (fieldCount == FIELD_COUNT_PACKED) {
                sb.append(" or writeRepeated");
                sb.append(typeString);
            }
            sb.append('.');
            throw new IllegalArgumentException(sb.toString());
        } else {
            final StringBuilder sb = new StringBuilder();
            if (expectedType == FIELD_TYPE_OBJECT) {
                sb.append("start");
            } else {
                sb.append("write");
            }
            sb.append(getFieldCountString(expectedCount));
            sb.append(getFieldTypeString(expectedType));
            sb.append(" called with an invalid fieldId: 0x");
            sb.append(Long.toHexString(fieldId));
            sb.append(". The proto field ID might be ");
            sb.append((int) fieldId);
            sb.append('.');
            throw new IllegalArgumentException(sb.toString());
        }
    }
    return (int) fieldId;
}
Body of Second Method:
{
    final long fieldCount = fieldId & FIELD_COUNT_MASK;
    final long fieldType = fieldId & FIELD_TYPE_MASK;
    final long expectedCount = expectedFlags & FIELD_COUNT_MASK;
    final long expectedType = expectedFlags & FIELD_TYPE_MASK;
    if (((int) fieldId) == 0) {
        throw new IllegalArgumentException("Invalid proto field " + (int) fieldId + " fieldId=" + Long.toHexString(fieldId));
    }
    if (fieldType != expectedType || !((fieldCount == expectedCount) || (fieldCount == FIELD_COUNT_PACKED && expectedCount == FIELD_COUNT_REPEATED))) {
        final String countString = getFieldCountString(fieldCount);
        final String typeString = getFieldTypeString(fieldType);
        if (typeString != null && countString != null) {
            final StringBuilder sb = new StringBuilder();
            if (expectedType == FIELD_TYPE_MESSAGE) {
                sb.append("start");
            } else {
                sb.append("write");
            }
            sb.append(getFieldCountString(expectedCount));
            sb.append(getFieldTypeString(expectedType));
            sb.append(" called for field ");
            sb.append((int) fieldId);
            sb.append(" which should be used with ");
            if (fieldType == FIELD_TYPE_MESSAGE) {
                sb.append("start");
            } else {
                sb.append("write");
            }
            sb.append(countString);
            sb.append(typeString);
            if (fieldCount == FIELD_COUNT_PACKED) {
                sb.append(" or writeRepeated");
                sb.append(typeString);
            }
            sb.append('.');
            throw new IllegalArgumentException(sb.toString());
        } else {
            final StringBuilder sb = new StringBuilder();
            if (expectedType == FIELD_TYPE_MESSAGE) {
                sb.append("start");
            } else {
                sb.append("write");
            }
            sb.append(getFieldCountString(expectedCount));
            sb.append(getFieldTypeString(expectedType));
            sb.append(" called with an invalid fieldId: 0x");
            sb.append(Long.toHexString(fieldId));
            sb.append(". The proto field ID might be ");
            sb.append((int) fieldId);
            sb.append('.');
            throw new IllegalArgumentException(sb.toString());
        }
    }
    return (int) fieldId;
}
------------------------
Find a silently evolved API code:android.os.Debug.MemoryInfo.getOtherPss:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return otherStats[which * NUM_CATEGORIES + offsetPss];
}
Body of Second Method:
{
    return otherStats[which * NUM_CATEGORIES + OFFSET_PSS];
}
------------------------
Find a silently evolved API code:android.database.sqlite.SQLiteDatabaseConfiguration.updateParametersFrom:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Updates the non-immutable parameters of this configuration object
 * from the other configuration object.
 *
 * @param other The object from which to copy the parameters.
 */

Body of Frist Method:
{
    if (other == null) {
        throw new IllegalArgumentException("other must not be null.");
    }
    if (!path.equals(other.path)) {
        throw new IllegalArgumentException("other configuration must refer to " + "the same database.");
    }
    openFlags = other.openFlags;
    maxSqlCacheSize = other.maxSqlCacheSize;
    locale = other.locale;
    foreignKeyConstraintsEnabled = other.foreignKeyConstraintsEnabled;
    customFunctions.clear();
    customFunctions.addAll(other.customFunctions);
    lookasideSlotSize = other.lookasideSlotSize;
    lookasideSlotCount = other.lookasideSlotCount;
    idleConnectionTimeoutMs = other.idleConnectionTimeoutMs;
}
Body of Second Method:
{
    if (other == null) {
        throw new IllegalArgumentException("other must not be null.");
    }
    if (!path.equals(other.path)) {
        throw new IllegalArgumentException("other configuration must refer to " + "the same database.");
    }
    openFlags = other.openFlags;
    maxSqlCacheSize = other.maxSqlCacheSize;
    locale = other.locale;
    foreignKeyConstraintsEnabled = other.foreignKeyConstraintsEnabled;
    customFunctions.clear();
    customFunctions.addAll(other.customFunctions);
    lookasideSlotSize = other.lookasideSlotSize;
    lookasideSlotCount = other.lookasideSlotCount;
    idleConnectionTimeoutMs = other.idleConnectionTimeoutMs;
    journalMode = other.journalMode;
    syncMode = other.syncMode;
}
------------------------
Find a silently evolved API code:android.widget.TextInputTimePickerView.updateTextInputValues:COMMENT
Method Modifier: default     hidden      
Comment:/**
 * Computes the display value and updates the text of the view.
 * <p>
 * This method should be called whenever the current value or display
 * properties (leading zeroes, max digits) change.
 */

Body of Frist Method:
{
    final String format = "%d";
    mIs24Hour = is24Hour;
    mHourFormatStartsAtZero = hourFormatStartsAtZero;
    mAmPmSpinner.setVisibility(is24Hour ? View.INVISIBLE : View.VISIBLE);
    if (amOrPm == AM) {
        mAmPmSpinner.setSelection(0);
    } else {
        mAmPmSpinner.setSelection(1);
    }
    mHourEditText.setText(String.format(format, localizedHour));
    mMinuteEditText.setText(String.format(format, minute));
    if (mErrorShowing) {
        validateInput();
    }
}
Body of Second Method:
{
    final String hourFormat = "%d";
    final String minuteFormat = "%02d";
    mIs24Hour = is24Hour;
    mHourFormatStartsAtZero = hourFormatStartsAtZero;
    mAmPmSpinner.setVisibility(is24Hour ? View.INVISIBLE : View.VISIBLE);
    if (amOrPm == AM) {
        mAmPmSpinner.setSelection(0);
    } else {
        mAmPmSpinner.setSelection(1);
    }
    mHourEditText.setText(String.format(hourFormat, localizedHour));
    mMinuteEditText.setText(String.format(minuteFormat, minute));
    if (mErrorShowing) {
        validateInput();
    }
}
------------------------
Find a silently evolved API code:android.provider.ContactsInternal.startQuickContactWithErrorToast:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Called by {@link ContactsContract} to star Quick Contact, possibly on the managed profile.
 */

Body of Frist Method:
{
    final Uri uri = intent.getData();
    final int match = sContactsUriMatcher.match(uri);
    switch(match) {
        case CONTACTS_URI_LOOKUP:
        case CONTACTS_URI_LOOKUP_ID:
            {
                if (maybeStartManagedQuickContact(context, intent)) {
                    // Request handled by DPM.  Just return here.
                    return;
                }
                break;
            }
    }
    // Launch on the current profile.
    startQuickContactWithErrorToastForUser(context, intent, Process.myUserHandle());
}
Body of Second Method:
{
    final Uri uri = intent.getData();
    final int match = sContactsUriMatcher.match(uri);
    switch(match) {
        case CONTACTS_URI_LOOKUP:
        case CONTACTS_URI_LOOKUP_ID:
            {
                if (maybeStartManagedQuickContact(context, intent)) {
                    // Request handled by DPM.  Just return here.
                    return;
                }
                break;
            }
    }
    // Launch on the current profile.
    startQuickContactWithErrorToastForUser(context, intent, context.getUser());
}
------------------------
Find a silently evolved API code:android.net.TrafficStats.getTotalTxBytes:COMMENT
Method Modifier: public      static      
Comment:/**
 * Return number of bytes transmitted since device boot. Counts packets
 * across all network interfaces, and always increases monotonically since
 * device boot. Statistics are measured at the network layer, so they
 * include both TCP and UDP usage.
 * <p>
 * Before {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}, this may
 * return {@link #UNSUPPORTED} on devices where statistics aren't available.
 */

Body of Frist Method:
{
    return nativeGetTotalStat(TYPE_TX_BYTES);
}
Body of Second Method:
{
    try {
        return getStatsService().getTotalStats(TYPE_TX_BYTES);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.os.UEventObserver.stopObserving:COMMENT
Method Modifier: public      final       hidden      
Comment:/**
 * End observation of UEvents.<p>
 * This process's UEvent thread will never call onUEvent() on this
 * UEventObserver after this call. Repeated calls have no effect.
 */

Body of Frist Method:
{
    final UEventThread t = getThread();
    if (t != null) {
        t.removeObserver(this);
    }
}
Body of Second Method:
{
    final UEventThread t = peekThread();
    if (t != null) {
        t.removeObserver(this);
    }
}
------------------------
Find a silently evolved API code:android.content.res.TypedArray.getFloat:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the float value for the attribute at <var>index</var>.
 * <p>
 * If the attribute is not a float or an integer, this method will attempt
 * to coerce it to a float using {@link Float#parseFloat(String)}.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return Attribute float value, or defValue if the attribute was
 * not defined or could not be coerced to a float.
 * @throws RuntimeException if the TypedArray has already been recycled.
 */

Body of Frist Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_FLOAT) {
        return Float.intBitsToFloat(data[index + AssetManager.STYLE_DATA]);
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + AssetManager.STYLE_DATA];
    }
    final TypedValue v = mValue;
    if (getValueAt(index, v)) {
        final CharSequence str = v.coerceToString();
        if (str != null) {
            StrictMode.noteResourceMismatch(v);
            return Float.parseFloat(str.toString());
        }
    }
    // We already checked for TYPE_NULL. This should never happen.
    throw new RuntimeException("getFloat of bad type: 0x" + Integer.toHexString(type));
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    index *= STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_FLOAT) {
        return Float.intBitsToFloat(data[index + STYLE_DATA]);
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + STYLE_DATA];
    }
    final TypedValue v = mValue;
    if (getValueAt(index, v)) {
        final CharSequence str = v.coerceToString();
        if (str != null) {
            StrictMode.noteResourceMismatch(v);
            return Float.parseFloat(str.toString());
        }
    }
    // We already checked for TYPE_NULL. This should never happen.
    throw new RuntimeException("getFloat of bad type: 0x" + Integer.toHexString(type));
}
------------------------
Find a silently evolved API code:android.net.TrafficStats.getTotalRxBytes:COMMENT
Method Modifier: public      static      
Comment:/**
 * Return number of bytes received since device boot. Counts packets across
 * all network interfaces, and always increases monotonically since device
 * boot. Statistics are measured at the network layer, so they include both
 * TCP and UDP usage.
 * <p>
 * Before {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}, this may
 * return {@link #UNSUPPORTED} on devices where statistics aren't available.
 */

Body of Frist Method:
{
    return nativeGetTotalStat(TYPE_RX_BYTES);
}
Body of Second Method:
{
    try {
        return getStatsService().getTotalStats(TYPE_RX_BYTES);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.media.session.MediaController.TransportControls.rewind:COMMENT
Method Modifier: public      
Comment:/**
 * Start rewinding. If playback is already rewinding this may increase
 * the rate.
 */

Body of Frist Method:
{
    try {
        mSessionBinder.rewind();
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling rewind.", e);
    }
}
Body of Second Method:
{
    try {
        mSessionBinder.rewind(mContext.getPackageName(), mCbStub);
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling rewind.", e);
    }
}
------------------------
Find a silently evolved API code:android.telephony.SignalStrength.hashCode:COMMENT
Method Modifier: public      
Comment:/**
 * @return hash code
 */

Body of Frist Method:
{
    int primeNum = 31;
    return ((mGsmSignalStrength * primeNum) + (mGsmBitErrorRate * primeNum) + (mCdmaDbm * primeNum) + (mCdmaEcio * primeNum) + (mEvdoDbm * primeNum) + (mEvdoEcio * primeNum) + (mEvdoSnr * primeNum) + (mLteSignalStrength * primeNum) + (mLteRsrp * primeNum) + (mLteRsrq * primeNum) + (mLteRssnr * primeNum) + (mLteCqi * primeNum) + (mLteRsrpBoost * primeNum) + (mTdScdmaRscp * primeNum) + (isGsm ? 1 : 0));
}
Body of Second Method:
{
    int primeNum = 31;
    return ((mGsmSignalStrength * primeNum) + (mGsmBitErrorRate * primeNum) + (mCdmaDbm * primeNum) + (mCdmaEcio * primeNum) + (mEvdoDbm * primeNum) + (mEvdoEcio * primeNum) + (mEvdoSnr * primeNum) + (mLteSignalStrength * primeNum) + (mLteRsrp * primeNum) + (mLteRsrq * primeNum) + (mLteRssnr * primeNum) + (mLteCqi * primeNum) + (mLteRsrpBoost * primeNum) + (mTdScdmaRscp * primeNum) + (mWcdmaSignalStrength * primeNum) + (mWcdmaRscpAsu * primeNum) + (mWcdmaRscp * primeNum) + (mIsGsm ? 1 : 0) + (mUseOnlyRsrpForLteLevel ? 1 : 0) + (Objects.hashCode(mWcdmaDefaultSignalMeasurement)) + (Arrays.hashCode(mLteRsrpThresholds)) + (Arrays.hashCode(mWcdmaRscpThresholds)));
}
------------------------
