Find a silently evolved API code:android.provider.Settings.Global.getStringForUser:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return sNameValueCache.getStringForUser(resolver, name, userHandle);
}
Body of Second Method:
{
    if (MOVED_TO_SECURE.contains(name)) {
        Log.w(TAG, "Setting " + name + " has moved from android.provider.Settings.Global" + " to android.provider.Settings.Secure, returning read-only value.");
        return Secure.getStringForUser(resolver, name, userHandle);
    }
    return sNameValueCache.getStringForUser(resolver, name, userHandle);
}
------------------------
Find a silently evolved API code:android.media.AudioService.startBluetoothSco:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @see AudioManager#startBluetoothSco()
 */

Body of Frist Method:
{
    if (!checkAudioSettingsPermission("startBluetoothSco()") || !mBootCompleted) {
        return;
    }
    ScoClient client = getScoClient(cb, true);
    // The calling identity must be cleared before calling ScoClient.incCount().
    // inCount() calls requestScoState() which in turn can call BluetoothHeadset APIs
    // and this must be done on behalf of system server to make sure permissions are granted.
    // The caller identity must be cleared after getScoClient() because it is needed if a new
    // client is created.
    final long ident = Binder.clearCallingIdentity();
    client.incCount(targetSdkVersion);
    Binder.restoreCallingIdentity(ident);
}
Body of Second Method:
{
    int scoAudioMode = (targetSdkVersion < Build.VERSION_CODES.JELLY_BEAN_MR2) ? SCO_MODE_VIRTUAL_CALL : SCO_MODE_UNDEFINED;
    startBluetoothScoInt(cb, scoAudioMode);
}
------------------------
Find a silently evolved API code:android.content.res.TypedArray.getDimensionPixelSize:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve a dimensional unit attribute at <var>index</var> for use
 * as a size in raw pixels.  This is the same as
 * {@link #getDimension}, except the returned value is converted to
 * integer pixels for use as a size.  A size conversion involves
 * rounding the base value, and ensuring that a non-zero base value
 * is at least one pixel in size.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute dimension value multiplied by the appropriate
 * metric and truncated to integer pixels, or defValue if not defined.
 *
 * @see #getDimension
 * @see #getDimensionPixelOffset
 */

Body of Frist Method:
{
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimensionPixelSize(data[index + AssetManager.STYLE_DATA], mResources.mMetrics);
    }
    throw new UnsupportedOperationException("Can't convert to dimension: type=0x" + Integer.toHexString(type));
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimensionPixelSize(data[index + AssetManager.STYLE_DATA], mMetrics);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        throw new RuntimeException("Failed to resolve attribute at index " + index);
    }
    throw new UnsupportedOperationException("Can't convert to dimension: type=0x" + Integer.toHexString(type));
}
------------------------
Find a silently evolved API code:android.net.http.CertificateChainValidator.verifyServerDomainAndCertificates:COMMENT
Method Modifier: private     static      hidden      
Comment:/**
 * Common code of doHandshakeAndValidateServerCertificates and verifyServerCertificates.
 * Calls DomainNamevalidator to verify the domain, and TrustManager to verify the certs.
 * @param chain the cert chain in X509 cert format.
 * @param domain The full website hostname and domain
 * @param authType The authentication type for the cert chain
 * @return An SSL error object if there is an error and null otherwise
 */

Body of Frist Method:
{
    // check if the first certificate in the chain is for this site
    X509Certificate currCertificate = chain[0];
    if (currCertificate == null) {
        throw new IllegalArgumentException("certificate for this site is null");
    }
    boolean valid = domain != null && !domain.isEmpty() && sVerifier.verify(domain, currCertificate);
    if (!valid) {
        if (HttpLog.LOGV) {
            HttpLog.v("certificate not for this host: " + domain);
        }
        return new SslError(SslError.SSL_IDMISMATCH, currCertificate);
    }
    try {
        X509TrustManager x509TrustManager = SSLParametersImpl.getDefaultTrustManager();
        if (x509TrustManager instanceof TrustManagerImpl) {
            TrustManagerImpl trustManager = (TrustManagerImpl) x509TrustManager;
            trustManager.checkServerTrusted(chain, authType, domain);
        } else {
            x509TrustManager.checkServerTrusted(chain, authType);
        }
        // No errors.
        return null;
    } catch (GeneralSecurityException e) {
        if (HttpLog.LOGV) {
            HttpLog.v("failed to validate the certificate chain, error: " + e.getMessage());
        }
        return new SslError(SslError.SSL_UNTRUSTED, currCertificate);
    }
}
Body of Second Method:
{
    // check if the first certificate in the chain is for this site
    X509Certificate currCertificate = chain[0];
    if (currCertificate == null) {
        throw new IllegalArgumentException("certificate for this site is null");
    }
    boolean valid = domain != null && !domain.isEmpty() && NoPreloadHolder.sVerifier.verify(domain, new DelegatingSSLSession.CertificateWrap(currCertificate));
    if (!valid) {
        if (HttpLog.LOGV) {
            HttpLog.v("certificate not for this host: " + domain);
        }
        return new SslError(SslError.SSL_IDMISMATCH, currCertificate);
    }
    try {
        X509TrustManager x509TrustManager = SSLParametersImpl.getDefaultX509TrustManager();
        if (x509TrustManager instanceof TrustManagerImpl) {
            TrustManagerImpl trustManager = (TrustManagerImpl) x509TrustManager;
            trustManager.checkServerTrusted(chain, authType, domain);
        } else {
            x509TrustManager.checkServerTrusted(chain, authType);
        }
        // No errors.
        return null;
    } catch (GeneralSecurityException e) {
        if (HttpLog.LOGV) {
            HttpLog.v("failed to validate the certificate chain, error: " + e.getMessage());
        }
        return new SslError(SslError.SSL_UNTRUSTED, currCertificate);
    }
}
------------------------
Find a silently evolved API code:android.graphics.Paint.setXfermode:COMMENT
Method Modifier: public      
Comment:/**
 * Set or clear the xfermode object.
 * <p />
 * Pass null to clear any previous xfermode.
 * As a convenience, the parameter passed is also returned.
 *
 * @param xfermode May be null. The xfermode to be installed in the paint
 * @return         xfermode
 */

Body of Frist Method:
{
    int xfermodeNative = 0;
    if (xfermode != null)
        xfermodeNative = xfermode.native_instance;
    native_setXfermode(mNativePaint, xfermodeNative);
    mXfermode = xfermode;
    return xfermode;
}
Body of Second Method:
{
    long xfermodeNative = 0;
    if (xfermode != null)
        xfermodeNative = xfermode.native_instance;
    native_setXfermode(mNativePaint, xfermodeNative);
    mXfermode = xfermode;
    return xfermode;
}
------------------------
Find a silently evolved API code:android.os.Vibrator.vibrate:COMMENT
<android.os.Vibrator: void vibrate(long[],int)>
public      abstract    ->public      
Method Modifier: public      abstract    
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * Vibrate with a given pattern.
 *
 * <p>
 * Pass in an array of ints that are the durations for which to turn on or off
 * the vibrator in milliseconds.  The first value indicates the number of milliseconds
 * to wait before turning the vibrator on.  The next value indicates the number of milliseconds
 * for which to keep the vibrator on before turning it off.  Subsequent values alternate
 * between durations in milliseconds to turn the vibrator off or to turn the vibrator on.
 * </p><p>
 * To cause the pattern to repeat, pass the index into the pattern array at which
 * to start the repeat, or -1 to disable repeating.
 * </p>
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#VIBRATE}.
 *
 * @param pattern an array of longs of times for which to turn the vibrator on or off.
 * @param repeat the index into pattern at which to repeat, or -1 if
 * you don't want to repeat.
 */

Body of Frist Method:

Body of Second Method:
{
    vibrate(pattern, repeat, null);
}
------------------------
Find a silently evolved API code:android.content.res.BridgeTypedArray.getDrawable:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the Drawable for the attribute at <var>index</var>.  This
 * gets the resource ID of the selected attribute, and uses
 * {@link Resources#getDrawable Resources.getDrawable} of the owning
 * Resources object to retrieve its Drawable.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return Drawable for the attribute, or null if not defined.
 */

Body of Frist Method:
{
    if (index < 0 || index >= mResourceData.length) {
        return null;
    }
    if (mResourceData[index] == null) {
        return null;
    }
    ResourceValue value = mResourceData[index];
    String stringValue = value.getValue();
    if (stringValue == null || RenderResources.REFERENCE_NULL.equals(stringValue)) {
        return null;
    }
    return ResourceHelper.getDrawable(value, mContext);
}
Body of Second Method:
{
    if (!hasValue(index)) {
        return null;
    }
    ResourceValue value = mResourceData[index];
    return ResourceHelper.getDrawable(value, mContext);
}
------------------------
Find a silently evolved API code:android.content.res.Resources.loadDrawable:COMMENT
Method Modifier: default     
Comment:/*package*/

Body of Frist Method:
{
    if (TRACE_FOR_PRELOAD) {
        // Log only framework resources
        if ((id >>> 24) == 0x1) {
            final String name = getResourceName(id);
            if (name != null)
                android.util.Log.d("PreloadDrawable", name);
        }
    }
    boolean isColorDrawable = false;
    if (value.type >= TypedValue.TYPE_FIRST_COLOR_INT && value.type <= TypedValue.TYPE_LAST_COLOR_INT) {
        isColorDrawable = true;
    }
    final long key = isColorDrawable ? value.data : (((long) value.assetCookie) << 32) | value.data;
    Drawable dr = getCachedDrawable(isColorDrawable ? mColorDrawableCache : mDrawableCache, key);
    if (dr != null) {
        return dr;
    }
    Drawable.ConstantState cs;
    if (isColorDrawable) {
        cs = sPreloadedColorDrawables.get(key);
    } else {
        cs = sPreloadedDrawables[mConfiguration.getLayoutDirection()].get(key);
    }
    if (cs != null) {
        dr = cs.newDrawable(this);
    } else {
        if (isColorDrawable) {
            dr = new ColorDrawable(value.data);
        }
        if (dr == null) {
            if (value.string == null) {
                throw new NotFoundException("Resource is not a Drawable (color or path): " + value);
            }
            String file = value.string.toString();
            if (TRACE_FOR_MISS_PRELOAD) {
                // Log only framework resources
                if ((id >>> 24) == 0x1) {
                    final String name = getResourceName(id);
                    if (name != null)
                        android.util.Log.d(TAG, "Loading framework drawable #" + Integer.toHexString(id) + ": " + name + " at " + file);
                }
            }
            if (DEBUG_LOAD)
                Log.v(TAG, "Loading drawable for cookie " + value.assetCookie + ": " + file);
            if (file.endsWith(".xml")) {
                Trace.traceBegin(Trace.TRACE_TAG_RESOURCES, file);
                try {
                    XmlResourceParser rp = loadXmlResourceParser(file, id, value.assetCookie, "drawable");
                    dr = Drawable.createFromXml(this, rp);
                    rp.close();
                } catch (Exception e) {
                    Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
                    NotFoundException rnf = new NotFoundException("File " + file + " from drawable resource ID #0x" + Integer.toHexString(id));
                    rnf.initCause(e);
                    throw rnf;
                }
                Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
            } else {
                Trace.traceBegin(Trace.TRACE_TAG_RESOURCES, file);
                try {
                    InputStream is = mAssets.openNonAsset(value.assetCookie, file, AssetManager.ACCESS_STREAMING);
                    // System.out.println("Opened file " + file + ": " + is);
                    dr = Drawable.createFromResourceStream(this, value, is, file, null);
                    is.close();
                // System.out.println("Created stream: " + dr);
                } catch (Exception e) {
                    Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
                    NotFoundException rnf = new NotFoundException("File " + file + " from drawable resource ID #0x" + Integer.toHexString(id));
                    rnf.initCause(e);
                    throw rnf;
                }
                Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
            }
        }
    }
    if (dr != null) {
        dr.setChangingConfigurations(value.changingConfigurations);
        cs = dr.getConstantState();
        if (cs != null) {
            if (mPreloading) {
                final int changingConfigs = cs.getChangingConfigurations();
                if (isColorDrawable) {
                    if (verifyPreloadConfig(changingConfigs, 0, value.resourceId, "drawable")) {
                        sPreloadedColorDrawables.put(key, cs);
                    }
                } else {
                    if (verifyPreloadConfig(changingConfigs, LAYOUT_DIR_CONFIG, value.resourceId, "drawable")) {
                        if ((changingConfigs & LAYOUT_DIR_CONFIG) == 0) {
                            // If this resource does not vary based on layout direction,
                            // we can put it in all of the preload maps.
                            sPreloadedDrawables[0].put(key, cs);
                            sPreloadedDrawables[1].put(key, cs);
                        } else {
                            // Otherwise, only in the layout dir we loaded it for.
                            final LongSparseArray<Drawable.ConstantState> preloads = sPreloadedDrawables[mConfiguration.getLayoutDirection()];
                            preloads.put(key, cs);
                        }
                    }
                }
            } else {
                synchronized (mAccessLock) {
                    // + " in " + this + ": " + cs);
                    if (isColorDrawable) {
                        mColorDrawableCache.put(key, new WeakReference<Drawable.ConstantState>(cs));
                    } else {
                        mDrawableCache.put(key, new WeakReference<Drawable.ConstantState>(cs));
                    }
                }
            }
        }
    }
    return dr;
}
Body of Second Method:
{
    if (TRACE_FOR_PRELOAD) {
        // Log only framework resources
        if ((id >>> 24) == 0x1) {
            final String name = getResourceName(id);
            if (name != null) {
                Log.d("PreloadDrawable", name);
            }
        }
    }
    final boolean isColorDrawable;
    final ArrayMap<String, LongSparseArray<WeakReference<ConstantState>>> caches;
    final long key;
    if (value.type >= TypedValue.TYPE_FIRST_COLOR_INT && value.type <= TypedValue.TYPE_LAST_COLOR_INT) {
        isColorDrawable = true;
        caches = mColorDrawableCache;
        key = value.data;
    } else {
        isColorDrawable = false;
        caches = mDrawableCache;
        key = (((long) value.assetCookie) << 32) | value.data;
    }
    // that was inflated against the specified theme.
    if (!mPreloading) {
        final Drawable cachedDrawable = getCachedDrawable(caches, key, theme);
        if (cachedDrawable != null) {
            return cachedDrawable;
        }
    }
    // Next, check preloaded drawables. These are unthemed but may have
    // themeable attributes.
    final ConstantState cs;
    if (isColorDrawable) {
        cs = sPreloadedColorDrawables.get(key);
    } else {
        cs = sPreloadedDrawables[mConfiguration.getLayoutDirection()].get(key);
    }
    final Drawable dr;
    if (cs != null) {
        dr = cs.newDrawable(this, theme);
    } else if (isColorDrawable) {
        dr = new ColorDrawable(value.data);
    } else {
        dr = loadDrawableForCookie(value, id, theme);
    }
    // cache (either preload or themed).
    if (dr != null) {
        dr.setChangingConfigurations(value.changingConfigurations);
        cacheDrawable(value, theme, isColorDrawable, caches, key, dr);
    }
    return dr;
}
------------------------
Find a silently evolved API code:android.widget.FastScroller.createPreviewTextView:COMMENT
Method Modifier: private     
Comment:/**
 * Creates a view into which preview text can be placed.
 */

Body of Frist Method:
{
    final LayoutParams params = new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);
    final Resources res = context.getResources();
    final int minSize = res.getDimensionPixelSize(R.dimen.fastscroll_overlay_size);
    final ColorStateList textColor = ta.getColorStateList(TEXT_COLOR);
    final float textSize = res.getDimensionPixelSize(R.dimen.fastscroll_overlay_text_size);
    final TextView textView = new TextView(context);
    textView.setLayoutParams(params);
    textView.setTextColor(textColor);
    textView.setTextSize(TypedValue.COMPLEX_UNIT_PX, textSize);
    textView.setSingleLine(true);
    textView.setEllipsize(TruncateAt.MIDDLE);
    textView.setGravity(Gravity.CENTER);
    textView.setAlpha(0f);
    // Manually propagate inherited layout direction.
    textView.setLayoutDirection(mList.getLayoutDirection());
    return textView;
}
Body of Second Method:
{
    final LayoutParams params = new LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);
    final TextView textView = new TextView(context);
    textView.setLayoutParams(params);
    textView.setSingleLine(true);
    textView.setEllipsize(TruncateAt.MIDDLE);
    textView.setGravity(Gravity.CENTER);
    textView.setAlpha(0f);
    // Manually propagate inherited layout direction.
    textView.setLayoutDirection(mList.getLayoutDirection());
    return textView;
}
------------------------
Find a silently evolved API code:android.app.SharedPreferencesImpl.hasFileChangedUnexpectedly:COMMENT
Method Modifier: private     
Comment:// we didn't instigate.

Body of Frist Method:
{
    synchronized (this) {
        if (mDiskWritesInFlight > 0) {
            // If we know we caused it, it's not unexpected.
            if (DEBUG)
                Log.d(TAG, "disk write in flight, not unexpected.");
            return false;
        }
    }
    final StructStat stat;
    try {
        /*
             * Metadata operations don't usually count as a block guard
             * violation, but we explicitly want this one.
             */
        BlockGuard.getThreadPolicy().onReadFromDisk();
        stat = Libcore.os.stat(mFile.getPath());
    } catch (ErrnoException e) {
        return true;
    }
    synchronized (this) {
        return mStatTimestamp != stat.st_mtime || mStatSize != stat.st_size;
    }
}
Body of Second Method:
{
    synchronized (this) {
        if (mDiskWritesInFlight > 0) {
            // If we know we caused it, it's not unexpected.
            if (DEBUG)
                Log.d(TAG, "disk write in flight, not unexpected.");
            return false;
        }
    }
    final StructStat stat;
    try {
        /*
             * Metadata operations don't usually count as a block guard
             * violation, but we explicitly want this one.
             */
        BlockGuard.getThreadPolicy().onReadFromDisk();
        stat = Os.stat(mFile.getPath());
    } catch (ErrnoException e) {
        return true;
    }
    synchronized (this) {
        return mStatTimestamp != stat.st_mtime || mStatSize != stat.st_size;
    }
}
------------------------
Find a silently evolved API code:android.hardware.SystemSensorManager.cancelTriggerSensorImpl:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (sensor != null && Sensor.getReportingMode(sensor) != Sensor.REPORTING_MODE_ONE_SHOT) {
        return false;
    }
    synchronized (mTriggerListeners) {
        TriggerEventQueue queue = mTriggerListeners.get(listener);
        if (queue != null) {
            boolean result;
            if (sensor == null) {
                result = queue.removeAllSensors();
            } else {
                result = queue.removeSensor(sensor, disable);
            }
            if (result && !queue.hasSensors()) {
                mTriggerListeners.remove(listener);
                queue.dispose();
            }
            return result;
        }
        return false;
    }
}
Body of Second Method:
{
    if (sensor != null && sensor.getReportingMode() != Sensor.REPORTING_MODE_ONE_SHOT) {
        return false;
    }
    synchronized (mTriggerListeners) {
        TriggerEventQueue queue = mTriggerListeners.get(listener);
        if (queue != null) {
            boolean result;
            if (sensor == null) {
                result = queue.removeAllSensors();
            } else {
                result = queue.removeSensor(sensor, disable);
            }
            if (result && !queue.hasSensors()) {
                mTriggerListeners.remove(listener);
                queue.dispose();
            }
            return result;
        }
        return false;
    }
}
------------------------
Find a silently evolved API code:android.os.Bundle.putCharSequenceArrayList:COMMENT
Method Modifier: public      
Comment:/**
 * Inserts an ArrayList<CharSequence> value into the mapping of this Bundle, replacing
 * any existing value for the given key.  Either key or value may be null.
 *
 * @param key a String, or null
 * @param value an ArrayList<CharSequence> object, or null
 */

Body of Frist Method:
{
    unparcel();
    mMap.put(key, value);
}
Body of Second Method:
{
    super.putCharSequenceArrayList(key, value);
}
------------------------
Find a silently evolved API code:android.widget.Switch.setThumbDrawable:COMMENT
Method Modifier: public      
Comment:/**
 * Set the drawable used for the switch "thumb" - the piece that the user
 * can physically touch and drag along the track.
 *
 * @param thumb Thumb drawable
 *
 * @attr ref android.R.styleable#Switch_thumb
 */

Body of Frist Method:
{
    mThumbDrawable = thumb;
    requestLayout();
}
Body of Second Method:
{
    if (mThumbDrawable != null) {
        mThumbDrawable.setCallback(null);
    }
    mThumbDrawable = thumb;
    if (thumb != null) {
        thumb.setCallback(this);
    }
    requestLayout();
}
------------------------
Find a silently evolved API code:android.media.MediaRouter.selectRouteInt:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide internal use
 */

Body of Frist Method:
{
    selectRouteStatic(types, route);
}
Body of Second Method:
{
    selectRouteStatic(types, route, explicit);
}
------------------------
Find a silently evolved API code:android.animation.ValueAnimator.start:COMMENT
Method Modifier: private     
Comment:/**
 * Start the animation playing. This version of start() takes a boolean flag that indicates
 * whether the animation should play in reverse. The flag is usually false, but may be set
 * to true if called from the reverse() method.
 *
 * <p>The animation started by calling this method will be run on the thread that called
 * this method. This thread should have a Looper on it (a runtime exception will be thrown if
 * this is not the case). Also, if the animation will animate
 * properties of objects in the view hierarchy, then the calling thread should be the UI
 * thread for that view hierarchy.</p>
 *
 * @param playBackwards Whether the ValueAnimator should start playing in reverse.
 */

Body of Frist Method:
{
    if (Looper.myLooper() == null) {
        throw new AndroidRuntimeException("Animators may only be run on Looper threads");
    }
    mPlayingBackwards = playBackwards;
    mCurrentIteration = 0;
    mPlayingState = STOPPED;
    mStarted = true;
    mStartedDelay = false;
    mPaused = false;
    AnimationHandler animationHandler = getOrCreateAnimationHandler();
    animationHandler.mPendingAnimations.add(this);
    if (mStartDelay == 0) {
        // This sets the initial value of the animation, prior to actually starting it running
        setCurrentPlayTime(0);
        mPlayingState = STOPPED;
        mRunning = true;
        notifyStartListeners();
    }
    animationHandler.start();
}
Body of Second Method:
{
    if (Looper.myLooper() == null) {
        throw new AndroidRuntimeException("Animators may only be run on Looper threads");
    }
    mPlayingBackwards = playBackwards;
    mCurrentIteration = 0;
    mPlayingState = STOPPED;
    mStarted = true;
    mStartedDelay = false;
    mPaused = false;
    // in case the scale factor has changed since creation time
    updateScaledDuration();
    AnimationHandler animationHandler = getOrCreateAnimationHandler();
    animationHandler.mPendingAnimations.add(this);
    if (mStartDelay == 0) {
        // This sets the initial value of the animation, prior to actually starting it running
        setCurrentPlayTime(0);
        mPlayingState = STOPPED;
        mRunning = true;
        notifyStartListeners();
    }
    animationHandler.start();
}
------------------------
Find a silently evolved API code:android.widget.CalendarView.setShowWeekNumber:COMMENT
Method Modifier: public      
Comment:/**
 * Sets whether to show the week number.
 *
 * @param showWeekNumber True to show the week number.
 *
 * @attr ref android.R.styleable#CalendarView_showWeekNumber
 */

Body of Frist Method:
{
    if (mShowWeekNumber == showWeekNumber) {
        return;
    }
    mShowWeekNumber = showWeekNumber;
    mAdapter.notifyDataSetChanged();
    setUpHeader();
}
Body of Second Method:
{
    mDelegate.setShowWeekNumber(showWeekNumber);
}
------------------------
Find a silently evolved API code:android.os.Looper.loop:COMMENT
Method Modifier: public      static      
Comment:/**
 * Run the message queue in this thread. Be sure to call
 * {@link #quit()} to end the loop.
 */

Body of Frist Method:
{
    final Looper me = myLooper();
    if (me == null) {
        throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread.");
    }
    final MessageQueue queue = me.mQueue;
    // Make sure the identity of this thread is that of the local process,
    // and keep track of what that identity token actually is.
    Binder.clearCallingIdentity();
    final long ident = Binder.clearCallingIdentity();
    for (; ; ) {
        // might block
        Message msg = queue.next();
        if (msg == null) {
            // No message indicates that the message queue is quitting.
            return;
        }
        // This must be in a local variable, in case a UI event sets the logger
        Printer logging = me.mLogging;
        if (logging != null) {
            logging.println(">>>>> Dispatching to " + msg.target + " " + msg.callback + ": " + msg.what);
        }
        msg.target.dispatchMessage(msg);
        if (logging != null) {
            logging.println("<<<<< Finished to " + msg.target + " " + msg.callback);
        }
        // Make sure that during the course of dispatching the
        // identity of the thread wasn't corrupted.
        final long newIdent = Binder.clearCallingIdentity();
        if (ident != newIdent) {
            Log.wtf(TAG, "Thread identity changed from 0x" + Long.toHexString(ident) + " to 0x" + Long.toHexString(newIdent) + " while dispatching to " + msg.target.getClass().getName() + " " + msg.callback + " what=" + msg.what);
        }
        msg.recycle();
    }
}
Body of Second Method:
{
    final Looper me = myLooper();
    if (me == null) {
        throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread.");
    }
    final MessageQueue queue = me.mQueue;
    // Make sure the identity of this thread is that of the local process,
    // and keep track of what that identity token actually is.
    Binder.clearCallingIdentity();
    final long ident = Binder.clearCallingIdentity();
    for (; ; ) {
        // might block
        Message msg = queue.next();
        if (msg == null) {
            // No message indicates that the message queue is quitting.
            return;
        }
        // This must be in a local variable, in case a UI event sets the logger
        Printer logging = me.mLogging;
        if (logging != null) {
            logging.println(">>>>> Dispatching to " + msg.target + " " + msg.callback + ": " + msg.what);
        }
        msg.target.dispatchMessage(msg);
        if (logging != null) {
            logging.println("<<<<< Finished to " + msg.target + " " + msg.callback);
        }
        // Make sure that during the course of dispatching the
        // identity of the thread wasn't corrupted.
        final long newIdent = Binder.clearCallingIdentity();
        if (ident != newIdent) {
            Log.wtf(TAG, "Thread identity changed from 0x" + Long.toHexString(ident) + " to 0x" + Long.toHexString(newIdent) + " while dispatching to " + msg.target.getClass().getName() + " " + msg.callback + " what=" + msg.what);
        }
        msg.recycleUnchecked();
    }
}
------------------------
Find a silently evolved API code:android.widget.CalendarView.getShowWeekNumber:COMMENT
Method Modifier: public      
Comment:/**
 * Gets whether to show the week number.
 *
 * @return True if showing the week number.
 *
 * @attr ref android.R.styleable#CalendarView_showWeekNumber
 */

Body of Frist Method:
{
    return mShowWeekNumber;
}
Body of Second Method:
{
    return mDelegate.getShowWeekNumber();
}
------------------------
Find a silently evolved API code:android.graphics.Canvas.restore:COMMENT
<android.graphics.Canvas: void restore()>
public      native      ->public      
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * This call balances a previous call to save(), and is used to remove all
 * modifications to the matrix/clip state since the last save call. It is
 * an error to call restore() more times than save() was called.
 */

Body of Frist Method:

Body of Second Method:
{
    native_restore(mNativeCanvasWrapper);
}
------------------------
Find a silently evolved API code:android.media.MediaScanner.scanSingleFile:COMMENT
Method Modifier: public      hidden      
Comment:// this function is used to scan a single file

Body of Frist Method:
{
    try {
        initialize(volumeName);
        prescan(path, true);
        File file = new File(path);
        if (!file.exists()) {
            return null;
        }
        // lastModified is in milliseconds on Files.
        long lastModifiedSeconds = file.lastModified() / 1000;
        // always scan the file, so we can return the content://media Uri for existing files
        return mClient.doScanFile(path, mimeType, lastModifiedSeconds, file.length(), false, true, MediaScanner.isNoMediaPath(path));
    } catch (RemoteException e) {
        Log.e(TAG, "RemoteException in MediaScanner.scanFile()", e);
        return null;
    }
}
Body of Second Method:
{
    try {
        initialize(volumeName);
        prescan(path, true);
        File file = new File(path);
        if (!file.exists()) {
            return null;
        }
        // lastModified is in milliseconds on Files.
        long lastModifiedSeconds = file.lastModified() / 1000;
        // always scan the file, so we can return the content://media Uri for existing files
        return mClient.doScanFile(path, mimeType, lastModifiedSeconds, file.length(), false, true, MediaScanner.isNoMediaPath(path));
    } catch (RemoteException e) {
        Log.e(TAG, "RemoteException in MediaScanner.scanFile()", e);
        return null;
    } finally {
        releaseResources();
    }
}
------------------------
Find a silently evolved API code:android.os.UserManager.hasUserRestriction:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 * Returns whether the given user has been disallowed from performing certain actions
 * or setting certain settings.
 * @param restrictionKey the string key representing the restriction
 * @param userHandle the UserHandle of the user for whom to retrieve the restrictions.
 */

Body of Frist Method:
{
    return getUserRestrictions(userHandle).getBoolean(restrictionKey, false);
}
Body of Second Method:
{
    try {
        return mService.hasUserRestriction(restrictionKey, userHandle.getIdentifier());
    } catch (RemoteException re) {
        Log.w(TAG, "Could not check user restrictions", re);
        return false;
    }
}
------------------------
Find a silently evolved API code:android.graphics.Canvas.drawARGB:COMMENT
Method Modifier: public      
Comment:/**
 * Fill the entire canvas' bitmap (restricted to the current clip) with the
 * specified ARGB color, using srcover porterduff mode.
 *
 * @param a alpha component (0..255) of the color to draw onto the canvas
 * @param r red component (0..255) of the color to draw onto the canvas
 * @param g green component (0..255) of the color to draw onto the canvas
 * @param b blue component (0..255) of the color to draw onto the canvas
 */

Body of Frist Method:
{
    native_drawARGB(mNativeCanvas, a, r, g, b);
}
Body of Second Method:
{
    drawColor(Color.argb(a, r, g, b));
}
------------------------
Find a silently evolved API code:android.media.MediaPlayer.prepare:COMMENT
<android.media.MediaPlayer: void prepare()>
public      native      ->public      
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * Prepares the player for playback, synchronously.
 *
 * After setting the datasource and the display surface, you need to either
 * call prepare() or prepareAsync(). For files, it is OK to call prepare(),
 * which blocks until MediaPlayer is ready for playback.
 *
 * @throws IllegalStateException if it is called in an invalid state
 */

Body of Frist Method:

Body of Second Method:
{
    _prepare();
    scanInternalSubtitleTracks();
}
------------------------
Find a silently evolved API code:android.media.MiniThumbFile.getMiniThumbFromFile:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Gallery app can use this method to retrieve mini-thumbnail. Full size
 * images share the same IDs with their corresponding thumbnails.
 *
 * @param id the ID of the image (same of full size image).
 * @param data the buffer to store mini-thumbnail.
 */

Body of Frist Method:
{
    RandomAccessFile r = miniThumbDataFile();
    if (r == null)
        return null;
    long pos = id * BYTES_PER_MINTHUMB;
    FileLock lock = null;
    try {
        mBuffer.clear();
        lock = mChannel.lock(pos, BYTES_PER_MINTHUMB, true);
        int size = mChannel.read(mBuffer, pos);
        if (size > 1 + 8 + 4) {
            // flag, magic, length
            mBuffer.position(0);
            byte flag = mBuffer.get();
            long magic = mBuffer.getLong();
            int length = mBuffer.getInt();
            if (size >= 1 + 8 + 4 + length && data.length >= length) {
                mBuffer.get(data, 0, length);
                return data;
            }
        }
    } catch (IOException ex) {
        Log.w(TAG, "got exception when reading thumbnail id=" + id + ", exception: " + ex);
    } catch (RuntimeException ex) {
        // Other NIO related exception like disk full, read only channel..etc
        Log.e(TAG, "Got exception when reading thumbnail, id = " + id + ", disk full or mount read-only? " + ex.getClass());
    } finally {
        try {
            if (lock != null)
                lock.release();
        } catch (IOException ex) {
        // ignore it.
        }
    }
    return null;
}
Body of Second Method:
{
    RandomAccessFile r = miniThumbDataFile();
    if (r == null)
        return null;
    long pos = id * BYTES_PER_MINTHUMB;
    FileLock lock = null;
    try {
        mBuffer.clear();
        lock = mChannel.lock(pos, BYTES_PER_MINTHUMB, true);
        int size = mChannel.read(mBuffer, pos);
        if (size > 1 + 8 + 4) {
            // flag, magic, length
            mBuffer.position(0);
            byte flag = mBuffer.get();
            long magic = mBuffer.getLong();
            int length = mBuffer.getInt();
            if (size >= 1 + 8 + 4 + length && length != 0 && magic != 0 && flag == 1 && data.length >= length) {
                mBuffer.get(data, 0, length);
                return data;
            }
        }
    } catch (IOException ex) {
        Log.w(TAG, "got exception when reading thumbnail id=" + id + ", exception: " + ex);
    } catch (RuntimeException ex) {
        // Other NIO related exception like disk full, read only channel..etc
        Log.e(TAG, "Got exception when reading thumbnail, id = " + id + ", disk full or mount read-only? " + ex.getClass());
    } finally {
        try {
            if (lock != null)
                lock.release();
        } catch (IOException ex) {
        // ignore it.
        }
    }
    return null;
}
------------------------
Find a silently evolved API code:android.service.dreams.DreamService.attach:COMMENT
Method Modifier: private     final       
Comment:/**
 * Called when the Dream is ready to be shown.
 *
 * Must run on mHandler.
 *
 * @param windowToken A window token that will allow a window to be created in the correct layer.
 */

Body of Frist Method:
{
    if (mWindowToken != null) {
        Slog.e(TAG, "attach() called when already attached with token=" + mWindowToken);
        return;
    }
    if (mDebug)
        Slog.v(TAG, "Attached on thread " + Thread.currentThread().getId());
    if (mSandman == null) {
        loadSandman();
    }
    mWindowToken = windowToken;
    mWindow = PolicyManager.makeNewWindow(this);
    mWindow.setCallback(this);
    mWindow.requestFeature(Window.FEATURE_NO_TITLE);
    mWindow.setBackgroundDrawable(new ColorDrawable(0xFF000000));
    mWindow.setFormat(PixelFormat.OPAQUE);
    if (mDebug)
        Slog.v(TAG, String.format("Attaching window token: %s to window of type %s", windowToken, WindowManager.LayoutParams.TYPE_DREAM));
    WindowManager.LayoutParams lp = mWindow.getAttributes();
    lp.type = WindowManager.LayoutParams.TYPE_DREAM;
    lp.token = windowToken;
    lp.windowAnimations = com.android.internal.R.style.Animation_Dream;
    lp.flags |= (WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR | WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED | WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD | WindowManager.LayoutParams.FLAG_ALLOW_LOCK_WHILE_SCREEN_ON | (mFullscreen ? WindowManager.LayoutParams.FLAG_FULLSCREEN : 0) | (mScreenBright ? WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON : 0));
    mWindow.setAttributes(lp);
    if (mDebug)
        Slog.v(TAG, "Created and attached window: " + mWindow);
    mWindow.setWindowManager(null, windowToken, "dream", true);
    mWindowManager = mWindow.getWindowManager();
    if (mDebug)
        Slog.v(TAG, "Window added on thread " + Thread.currentThread().getId());
    try {
        applySystemUiVisibilityFlags((mLowProfile ? View.SYSTEM_UI_FLAG_LOW_PROFILE : 0), View.SYSTEM_UI_FLAG_LOW_PROFILE);
        getWindowManager().addView(mWindow.getDecorView(), mWindow.getAttributes());
    } catch (Throwable t) {
        Slog.w(TAG, "Crashed adding window view", t);
        safelyFinish();
        return;
    }
    // start it up
    mHandler.post(new Runnable() {

        @Override
        public void run() {
            try {
                onDreamingStarted();
            } catch (Throwable t) {
                Slog.w(TAG, "Crashed in onDreamingStarted()", t);
                safelyFinish();
            }
        }
    });
}
Body of Second Method:
{
    if (mWindowToken != null) {
        Slog.e(TAG, "attach() called when already attached with token=" + mWindowToken);
        return;
    }
    if (mFinished || mWaking) {
        Slog.w(TAG, "attach() called after dream already finished");
        try {
            mSandman.finishSelf(windowToken, true);
        } catch (RemoteException ex) {
        // system server died
        }
        return;
    }
    mWindowToken = windowToken;
    mCanDoze = canDoze;
    if (mWindowless && !mCanDoze) {
        throw new IllegalStateException("Only doze dreams can be windowless");
    }
    if (!mWindowless) {
        mWindow = PolicyManager.makeNewWindow(this);
        mWindow.setCallback(this);
        mWindow.requestFeature(Window.FEATURE_NO_TITLE);
        mWindow.setBackgroundDrawable(new ColorDrawable(0xFF000000));
        mWindow.setFormat(PixelFormat.OPAQUE);
        if (mDebug)
            Slog.v(TAG, String.format("Attaching window token: %s to window of type %s", windowToken, WindowManager.LayoutParams.TYPE_DREAM));
        WindowManager.LayoutParams lp = mWindow.getAttributes();
        lp.type = WindowManager.LayoutParams.TYPE_DREAM;
        lp.token = windowToken;
        lp.windowAnimations = com.android.internal.R.style.Animation_Dream;
        lp.flags |= (WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR | WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED | WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD | WindowManager.LayoutParams.FLAG_ALLOW_LOCK_WHILE_SCREEN_ON | (mFullscreen ? WindowManager.LayoutParams.FLAG_FULLSCREEN : 0) | (mScreenBright ? WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON : 0));
        mWindow.setAttributes(lp);
        // Workaround: Currently low-profile and in-window system bar backgrounds don't go
        // along well. Dreams usually don't need such bars anyways, so disable them by default.
        mWindow.clearFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);
        mWindow.setWindowManager(null, windowToken, "dream", true);
        applySystemUiVisibilityFlags((mLowProfile ? View.SYSTEM_UI_FLAG_LOW_PROFILE : 0), View.SYSTEM_UI_FLAG_LOW_PROFILE);
        try {
            getWindowManager().addView(mWindow.getDecorView(), mWindow.getAttributes());
        } catch (WindowManager.BadTokenException ex) {
            // This can happen because the dream manager service will remove the token
            // immediately without necessarily waiting for the dream to start.
            // We should receive a finish message soon.
            Slog.i(TAG, "attach() called after window token already removed, dream will " + "finish soon");
            mWindow = null;
            return;
        }
    }
    // We need to defer calling onDreamingStarted until after onWindowAttached,
    // which is posted to the handler by addView, so we post onDreamingStarted
    // to the handler also.  Need to watch out here in case detach occurs before
    // this callback is invoked.
    mHandler.post(new Runnable() {

        @Override
        public void run() {
            if (mWindow != null || mWindowless) {
                if (mDebug)
                    Slog.v(TAG, "Calling onDreamingStarted()");
                mStarted = true;
                onDreamingStarted();
            }
        }
    });
}
------------------------
Find a silently evolved API code:android.graphics.Paint.clearShadowLayer:COMMENT
Method Modifier: public      
Comment:/**
 * Clear the shadow layer.
 */

Body of Frist Method:
{
    hasShadow = false;
    nSetShadowLayer(0, 0, 0, 0);
}
Body of Second Method:
{
    setShadowLayer(0, 0, 0, 0);
}
------------------------
Find a silently evolved API code:android.view.Window.setFlags:COMMENT
Method Modifier: public      
Comment:/**
 * Set the flags of the window, as per the
 * {@link WindowManager.LayoutParams WindowManager.LayoutParams}
 * flags.
 *
 * <p>Note that some flags must be set before the window decoration is
 * created (by the first call to
 * {@link #setContentView(View, android.view.ViewGroup.LayoutParams)} or
 * {@link #getDecorView()}:
 * {@link WindowManager.LayoutParams#FLAG_LAYOUT_IN_SCREEN} and
 * {@link WindowManager.LayoutParams#FLAG_LAYOUT_INSET_DECOR}.  These
 * will be set for you based on the {@link android.R.attr#windowIsFloating}
 * attribute.
 *
 * @param flags The new window flags (see WindowManager.LayoutParams).
 * @param mask Which of the window flag bits to modify.
 * @see #addFlags
 * @see #clearFlags
 */

Body of Frist Method:
{
    final WindowManager.LayoutParams attrs = getAttributes();
    attrs.flags = (attrs.flags & ~mask) | (flags & mask);
    if ((mask & WindowManager.LayoutParams.FLAG_NEEDS_MENU_KEY) != 0) {
        attrs.privateFlags |= WindowManager.LayoutParams.PRIVATE_FLAG_SET_NEEDS_MENU_KEY;
    }
    mForcedWindowFlags |= mask;
    if (mCallback != null) {
        mCallback.onWindowAttributesChanged(attrs);
    }
}
Body of Second Method:
{
    final WindowManager.LayoutParams attrs = getAttributes();
    attrs.flags = (attrs.flags & ~mask) | (flags & mask);
    if ((mask & WindowManager.LayoutParams.FLAG_NEEDS_MENU_KEY) != 0) {
        attrs.privateFlags |= WindowManager.LayoutParams.PRIVATE_FLAG_SET_NEEDS_MENU_KEY;
    }
    mForcedWindowFlags |= mask;
    dispatchWindowAttributesChanged(attrs);
}
------------------------
Find a silently evolved API code:android.webkit.WebSyncManager.startSync:COMMENT
<android.webkit.WebSyncManager: void startSync()>
public      ->public      deprecated  
Method Modifier: public      deprecated  
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * startSync() requests sync manager to start sync
 */

Body of Frist Method:
{
    if (DebugFlags.WEB_SYNC_MANAGER) {
        Log.v(LOGTAG, "***  WebSyncManager startSync ***, Ref count:" + mStartSyncRefCount);
    }
    if (mHandler == null) {
        return;
    }
    if (++mStartSyncRefCount == 1) {
        Message msg = mHandler.obtainMessage(SYNC_MESSAGE);
        mHandler.sendMessageDelayed(msg, SYNC_LATER_INTERVAL);
    }
}
Body of Second Method:
{
}
------------------------
Find a silently evolved API code:android.media.MediaFocusControl.removeFocusStackEntry:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Helper function:
 * Called synchronized on mAudioFocusLock
 * Remove a focus listener from the focus stack.
 * @param clientToRemove the focus listener
 * @param signal if true and the listener was at the top of the focus stack, i.e. it was holding
 * focus, notify the next item in the stack it gained focus.
 */

Body of Frist Method:
{
    // is the current top of the focus stack abandoning focus? (because of request, not death)
    if (!mFocusStack.empty() && mFocusStack.peek().hasSameClient(clientToRemove)) {
        // Log.i(TAG, "   removeFocusStackEntry() removing top of stack");
        FocusRequester fr = mFocusStack.pop();
        fr.release();
        if (signal) {
            // notify the new top of the stack it gained focus
            notifyTopOfAudioFocusStack();
            // there's a new top of the stack, let the remote control know
            synchronized (mRCStack) {
                checkUpdateRemoteControlDisplay_syncAfRcs(RC_INFO_ALL);
            }
        }
    } else {
        // focus is abandoned by a client that's not at the top of the stack,
        // no need to update focus.
        // (using an iterator on the stack so we can safely remove an entry after having
        // evaluated it, traversal order doesn't matter here)
        Iterator<FocusRequester> stackIterator = mFocusStack.iterator();
        while (stackIterator.hasNext()) {
            FocusRequester fr = (FocusRequester) stackIterator.next();
            if (fr.hasSameClient(clientToRemove)) {
                Log.i(TAG, "AudioFocus  removeFocusStackEntry(): removing entry for " + clientToRemove);
                stackIterator.remove();
                fr.release();
            }
        }
    }
}
Body of Second Method:
{
    // is the current top of the focus stack abandoning focus? (because of request, not death)
    if (!mFocusStack.empty() && mFocusStack.peek().hasSameClient(clientToRemove)) {
        // Log.i(TAG, "   removeFocusStackEntry() removing top of stack");
        FocusRequester fr = mFocusStack.pop();
        fr.release();
        if (signal) {
            // notify the new top of the stack it gained focus
            notifyTopOfAudioFocusStack();
        }
    } else {
        // focus is abandoned by a client that's not at the top of the stack,
        // no need to update focus.
        // (using an iterator on the stack so we can safely remove an entry after having
        // evaluated it, traversal order doesn't matter here)
        Iterator<FocusRequester> stackIterator = mFocusStack.iterator();
        while (stackIterator.hasNext()) {
            FocusRequester fr = stackIterator.next();
            if (fr.hasSameClient(clientToRemove)) {
                Log.i(TAG, "AudioFocus  removeFocusStackEntry(): removing entry for " + clientToRemove);
                stackIterator.remove();
                fr.release();
            }
        }
    }
}
------------------------
Find a silently evolved API code:android.os.Bundle.readFromParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Reads the Parcel contents into this Bundle, typically in order for
 * it to be passed through an IBinder connection.
 * @param parcel The parcel to overwrite this bundle from.
 */

Body of Frist Method:
{
    int length = parcel.readInt();
    if (length < 0) {
        throw new RuntimeException("Bad length in parcel: " + length);
    }
    readFromParcelInner(parcel, length);
}
Body of Second Method:
{
    super.readFromParcelInner(parcel);
    mHasFds = mParcelledData.hasFileDescriptors();
    mFdsKnown = true;
}
------------------------
Find a silently evolved API code:android.graphics.drawable.Drawable.createFromXml:COMMENT
Method Modifier: public      static      
Comment:/**
 * Create a drawable from an XML document. For more information on how to
 * create resources in XML, see
 * <a href="{@docRoot}guide/topics/resources/drawable-resource.html">Drawable Resources</a>.
 */

Body of Frist Method:
{
    AttributeSet attrs = Xml.asAttributeSet(parser);
    int type;
    while ((type = parser.next()) != XmlPullParser.START_TAG && type != XmlPullParser.END_DOCUMENT) {
    // Empty loop
    }
    if (type != XmlPullParser.START_TAG) {
        throw new XmlPullParserException("No start tag found");
    }
    Drawable drawable = createFromXmlInner(r, parser, attrs);
    if (drawable == null) {
        throw new RuntimeException("Unknown initial tag: " + parser.getName());
    }
    return drawable;
}
Body of Second Method:
{
    return createFromXml(r, parser, null);
}
------------------------
Find a silently evolved API code:android.content.ContentResolver.getType:COMMENT
Method Modifier: public      final       
Comment:/**
 * Return the MIME type of the given content URL.
 *
 * @param url A Uri identifying content (either a list or specific type),
 * using the content:// scheme.
 * @return A MIME type for the content, or null if the URL is invalid or the type is unknown
 */

Body of Frist Method:
{
    // XXX would like to have an acquireExistingUnstableProvider for this.
    IContentProvider provider = acquireExistingProvider(url);
    if (provider != null) {
        try {
            return provider.getType(url);
        } catch (RemoteException e) {
            return null;
        } catch (java.lang.Exception e) {
            Log.w(TAG, "Failed to get type for: " + url + " (" + e.getMessage() + ")");
            return null;
        } finally {
            releaseProvider(provider);
        }
    }
    if (!SCHEME_CONTENT.equals(url.getScheme())) {
        return null;
    }
    try {
        String type = ActivityManagerNative.getDefault().getProviderMimeType(url, UserHandle.myUserId());
        return type;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } catch (java.lang.Exception e) {
        Log.w(TAG, "Failed to get type for: " + url + " (" + e.getMessage() + ")");
        return null;
    }
}
Body of Second Method:
{
    // XXX would like to have an acquireExistingUnstableProvider for this.
    IContentProvider provider = acquireExistingProvider(url);
    if (provider != null) {
        try {
            return provider.getType(url);
        } catch (RemoteException e) {
            return null;
        } catch (java.lang.Exception e) {
            Log.w(TAG, "Failed to get type for: " + url + " (" + e.getMessage() + ")");
            return null;
        } finally {
            releaseProvider(provider);
        }
    }
    if (!SCHEME_CONTENT.equals(url.getScheme())) {
        return null;
    }
    try {
        String type = ActivityManagerNative.getDefault().getProviderMimeType(ContentProvider.getUriWithoutUserId(url), resolveUserId(url));
        return type;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } catch (java.lang.Exception e) {
        Log.w(TAG, "Failed to get type for: " + url + " (" + e.getMessage() + ")");
        return null;
    }
}
------------------------
Find a silently evolved API code:android.view.accessibility.AccessibilityNodeInfo.initFromParcel:COMMENT
Method Modifier: private     
Comment:/**
 * Creates a new instance from a {@link Parcel}.
 *
 * @param parcel A parcel containing the state of a {@link AccessibilityNodeInfo}.
 */

Body of Frist Method:
{
    mSealed = (parcel.readInt() == 1);
    mSourceNodeId = parcel.readLong();
    mWindowId = parcel.readInt();
    mParentNodeId = parcel.readLong();
    mLabelForId = parcel.readLong();
    mLabeledById = parcel.readLong();
    mConnectionId = parcel.readInt();
    SparseLongArray childIds = mChildNodeIds;
    final int childrenSize = parcel.readInt();
    for (int i = 0; i < childrenSize; i++) {
        final long childId = parcel.readLong();
        childIds.put(i, childId);
    }
    mBoundsInParent.top = parcel.readInt();
    mBoundsInParent.bottom = parcel.readInt();
    mBoundsInParent.left = parcel.readInt();
    mBoundsInParent.right = parcel.readInt();
    mBoundsInScreen.top = parcel.readInt();
    mBoundsInScreen.bottom = parcel.readInt();
    mBoundsInScreen.left = parcel.readInt();
    mBoundsInScreen.right = parcel.readInt();
    mActions = parcel.readInt();
    mMovementGranularities = parcel.readInt();
    mBooleanProperties = parcel.readInt();
    mPackageName = parcel.readCharSequence();
    mClassName = parcel.readCharSequence();
    mText = parcel.readCharSequence();
    mContentDescription = parcel.readCharSequence();
    mViewIdResourceName = parcel.readString();
    mTextSelectionStart = parcel.readInt();
    mTextSelectionEnd = parcel.readInt();
    mInputType = parcel.readInt();
    mLiveRegion = parcel.readInt();
    if (parcel.readInt() == 1) {
        getExtras().putAll(parcel.readBundle());
    }
    if (parcel.readInt() == 1) {
        mRangeInfo = RangeInfo.obtain(parcel.readInt(), parcel.readFloat(), parcel.readFloat(), parcel.readFloat());
    }
    if (parcel.readInt() == 1) {
        mCollectionInfo = CollectionInfo.obtain(parcel.readInt(), parcel.readInt(), parcel.readInt() == 1);
    }
    if (parcel.readInt() == 1) {
        mCollectionItemInfo = CollectionItemInfo.obtain(parcel.readInt(), parcel.readInt(), parcel.readInt(), parcel.readInt(), parcel.readInt() == 1);
    }
}
Body of Second Method:
{
    mSealed = (parcel.readInt() == 1);
    mSourceNodeId = parcel.readLong();
    mWindowId = parcel.readInt();
    mParentNodeId = parcel.readLong();
    mLabelForId = parcel.readLong();
    mLabeledById = parcel.readLong();
    mConnectionId = parcel.readInt();
    final int childrenSize = parcel.readInt();
    if (childrenSize <= 0) {
        mChildNodeIds = null;
    } else {
        mChildNodeIds = new LongArray(childrenSize);
        for (int i = 0; i < childrenSize; i++) {
            final long childId = parcel.readLong();
            mChildNodeIds.add(childId);
        }
    }
    mBoundsInParent.top = parcel.readInt();
    mBoundsInParent.bottom = parcel.readInt();
    mBoundsInParent.left = parcel.readInt();
    mBoundsInParent.right = parcel.readInt();
    mBoundsInScreen.top = parcel.readInt();
    mBoundsInScreen.bottom = parcel.readInt();
    mBoundsInScreen.left = parcel.readInt();
    mBoundsInScreen.right = parcel.readInt();
    final int actionCount = parcel.readInt();
    if (actionCount > 0) {
        final int legacyStandardActions = parcel.readInt();
        addLegacyStandardActions(legacyStandardActions);
        final int nonLegacyActionCount = actionCount - Integer.bitCount(legacyStandardActions);
        for (int i = 0; i < nonLegacyActionCount; i++) {
            AccessibilityAction action = new AccessibilityAction(parcel.readInt(), parcel.readCharSequence());
            addAction(action);
        }
    }
    mMaxTextLength = parcel.readInt();
    mMovementGranularities = parcel.readInt();
    mBooleanProperties = parcel.readInt();
    mPackageName = parcel.readCharSequence();
    mClassName = parcel.readCharSequence();
    mText = parcel.readCharSequence();
    mError = parcel.readCharSequence();
    mContentDescription = parcel.readCharSequence();
    mViewIdResourceName = parcel.readString();
    mTextSelectionStart = parcel.readInt();
    mTextSelectionEnd = parcel.readInt();
    mInputType = parcel.readInt();
    mLiveRegion = parcel.readInt();
    if (parcel.readInt() == 1) {
        getExtras().putAll(parcel.readBundle());
    }
    if (parcel.readInt() == 1) {
        mRangeInfo = RangeInfo.obtain(parcel.readInt(), parcel.readFloat(), parcel.readFloat(), parcel.readFloat());
    }
    if (parcel.readInt() == 1) {
        mCollectionInfo = CollectionInfo.obtain(parcel.readInt(), parcel.readInt(), parcel.readInt() == 1, parcel.readInt());
    }
    if (parcel.readInt() == 1) {
        mCollectionItemInfo = CollectionItemInfo.obtain(parcel.readInt(), parcel.readInt(), parcel.readInt(), parcel.readInt(), parcel.readInt() == 1, parcel.readInt() == 1);
    }
}
------------------------
Find a silently evolved API code:android.media.AudioRecord.audioBuffSizeCheck:COMMENT
Method Modifier: private     
Comment:// mNativeBufferSizeInBytes is valid (multiple of frame size, positive)

Body of Frist Method:
{
    // NB: this section is only valid with PCM data.
    // To update when supporting compressed formats
    int frameSizeInBytes = mChannelCount * (mAudioFormat == AudioFormat.ENCODING_PCM_8BIT ? 1 : 2);
    if ((audioBufferSize % frameSizeInBytes != 0) || (audioBufferSize < 1)) {
        throw new IllegalArgumentException("Invalid audio buffer size.");
    }
    mNativeBufferSizeInBytes = audioBufferSize;
}
Body of Second Method:
{
    // NB: this section is only valid with PCM data.
    // To update when supporting compressed formats
    int frameSizeInBytes = mChannelCount * (AudioFormat.getBytesPerSample(mAudioFormat));
    if ((audioBufferSize % frameSizeInBytes != 0) || (audioBufferSize < 1)) {
        throw new IllegalArgumentException("Invalid audio buffer size.");
    }
    mNativeBufferSizeInBytes = audioBufferSize;
}
------------------------
Find a silently evolved API code:android.util.ArraySet.contains:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Check whether a value exists in the set.
 *
 * @param key The value to search for.
 * @return Returns true if the value exists, else false.
 */

Body of Frist Method:
{
    return key == null ? (indexOfNull() >= 0) : (indexOf(key, key.hashCode()) >= 0);
}
Body of Second Method:
{
    return indexOf(key) >= 0;
}
------------------------
Find a silently evolved API code:android.animation.PropertyValuesHolder.setEvaluator:COMMENT
Method Modifier: public      
Comment:/**
 * The TypeEvaluator will be automatically determined based on the type of values
 * supplied to PropertyValuesHolder. The evaluator can be manually set, however, if so
 * desired. This may be important in cases where either the type of the values supplied
 * do not match the way that they should be interpolated between, or if the values
 * are of a custom type or one not currently understood by the animation system. Currently,
 * only values of type float and int (and their Object equivalents: Float
 * and Integer) are  correctly interpolated; all other types require setting a TypeEvaluator.
 * @param evaluator
 */

Body of Frist Method:
{
    mEvaluator = evaluator;
    mKeyframeSet.setEvaluator(evaluator);
}
Body of Second Method:
{
    mEvaluator = evaluator;
    mKeyframes.setEvaluator(evaluator);
}
------------------------
Find a silently evolved API code:android.view.LayoutInflater.setPrivateFactory:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide for use by framework
 */

Body of Frist Method:
{
    mPrivateFactory = factory;
}
Body of Second Method:
{
    if (mPrivateFactory == null) {
        mPrivateFactory = factory;
    } else {
        mPrivateFactory = new FactoryMerger(factory, factory, mPrivateFactory, mPrivateFactory);
    }
}
------------------------
Find a silently evolved API code:android.media.MediaRouter.UserRouteInfo.setPlaybackStream:COMMENT
Method Modifier: public      
Comment:/**
 * Defines over what stream type the media is presented.
 * @param stream
 */

Body of Frist Method:
{
    if (mPlaybackStream != stream) {
        mPlaybackStream = stream;
        setPlaybackInfoOnRcc(RemoteControlClient.PLAYBACKINFO_USES_STREAM, stream);
    }
}
Body of Second Method:
{
    if (mPlaybackStream != stream) {
        mPlaybackStream = stream;
        configureSessionVolume();
    }
}
------------------------
Find a silently evolved API code:android.util.JsonReader.skipValue:COMMENT
Method Modifier: public      
Comment:/**
 * Skips the next value recursively. If it is an object or array, all nested
 * elements are skipped. This method is intended for use when the JSON token
 * stream contains unrecognized or unhandled values.
 */

Body of Frist Method:
{
    skipping = true;
    try {
        int count = 0;
        do {
            JsonToken token = advance();
            if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {
                count++;
            } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {
                count--;
            }
        } while (count != 0);
    } finally {
        skipping = false;
    }
}
Body of Second Method:
{
    skipping = true;
    try {
        if (!hasNext() || peek() == JsonToken.END_DOCUMENT) {
            throw new IllegalStateException("No element left to skip");
        }
        int count = 0;
        do {
            JsonToken token = advance();
            if (token == JsonToken.BEGIN_ARRAY || token == JsonToken.BEGIN_OBJECT) {
                count++;
            } else if (token == JsonToken.END_ARRAY || token == JsonToken.END_OBJECT) {
                count--;
            }
        } while (count != 0);
    } finally {
        skipping = false;
    }
}
------------------------
Find a silently evolved API code:android.media.MediaRouter.Static.startMonitoringRoutes:COMMENT
Method Modifier: default     
Comment:// Called after sStatic is initialized

Body of Frist Method:
{
    mDefaultAudioVideo = new RouteInfo(mSystemCategory);
    mDefaultAudioVideo.mNameResId = com.android.internal.R.string.default_audio_route_name;
    mDefaultAudioVideo.mSupportedTypes = ROUTE_TYPE_LIVE_AUDIO | ROUTE_TYPE_LIVE_VIDEO;
    mDefaultAudioVideo.mPresentationDisplay = choosePresentationDisplayForRoute(mDefaultAudioVideo, getAllPresentationDisplays());
    addRouteStatic(mDefaultAudioVideo);
    // This will select the active wifi display route if there is one.
    updateWifiDisplayStatus(mDisplayService.getWifiDisplayStatus());
    appContext.registerReceiver(new WifiDisplayStatusChangedReceiver(), new IntentFilter(DisplayManager.ACTION_WIFI_DISPLAY_STATUS_CHANGED));
    appContext.registerReceiver(new VolumeChangeReceiver(), new IntentFilter(AudioManager.VOLUME_CHANGED_ACTION));
    mDisplayService.registerDisplayListener(this, mHandler);
    AudioRoutesInfo newAudioRoutes = null;
    try {
        newAudioRoutes = mAudioService.startWatchingRoutes(mAudioRoutesObserver);
    } catch (RemoteException e) {
    }
    if (newAudioRoutes != null) {
        // This will select the active BT route if there is one and the current
        // selected route is the default system route, or if there is no selected
        // route yet.
        updateAudioRoutes(newAudioRoutes);
    }
    // appropriately with relevant system state.
    if (mSelectedRoute == null) {
        selectRouteStatic(mDefaultAudioVideo.getSupportedTypes(), mDefaultAudioVideo);
    }
}
Body of Second Method:
{
    mDefaultAudioVideo = new RouteInfo(mSystemCategory);
    mDefaultAudioVideo.mNameResId = com.android.internal.R.string.default_audio_route_name;
    mDefaultAudioVideo.mSupportedTypes = ROUTE_TYPE_LIVE_AUDIO | ROUTE_TYPE_LIVE_VIDEO;
    mDefaultAudioVideo.updatePresentationDisplay();
    addRouteStatic(mDefaultAudioVideo);
    // This will select the active wifi display route if there is one.
    updateWifiDisplayStatus(mDisplayService.getWifiDisplayStatus());
    appContext.registerReceiver(new WifiDisplayStatusChangedReceiver(), new IntentFilter(DisplayManager.ACTION_WIFI_DISPLAY_STATUS_CHANGED));
    appContext.registerReceiver(new VolumeChangeReceiver(), new IntentFilter(AudioManager.VOLUME_CHANGED_ACTION));
    mDisplayService.registerDisplayListener(this, mHandler);
    AudioRoutesInfo newAudioRoutes = null;
    try {
        newAudioRoutes = mAudioService.startWatchingRoutes(mAudioRoutesObserver);
    } catch (RemoteException e) {
    }
    if (newAudioRoutes != null) {
        // This will select the active BT route if there is one and the current
        // selected route is the default system route, or if there is no selected
        // route yet.
        updateAudioRoutes(newAudioRoutes);
    }
    // Bind to the media router service.
    rebindAsUser(UserHandle.myUserId());
    // appropriately with relevant system state.
    if (mSelectedRoute == null) {
        selectDefaultRouteStatic();
    }
}
------------------------
Find a silently evolved API code:android.appwidget.AppWidgetManager.getInstance:COMMENT
Method Modifier: public      static      
Comment:/**
 * Get the AppWidgetManager instance to use for the supplied {@link android.content.Context
 * Context} object.
 */

Body of Frist Method:
{
    synchronized (sManagerCache) {
        if (sService == null) {
            IBinder b = ServiceManager.getService(Context.APPWIDGET_SERVICE);
            sService = IAppWidgetService.Stub.asInterface(b);
        }
        WeakReference<AppWidgetManager> ref = sManagerCache.get(context);
        AppWidgetManager result = null;
        if (ref != null) {
            result = ref.get();
        }
        if (result == null) {
            result = new AppWidgetManager(context);
            sManagerCache.put(context, new WeakReference<AppWidgetManager>(result));
        }
        return result;
    }
}
Body of Second Method:
{
    return (AppWidgetManager) context.getSystemService(Context.APPWIDGET_SERVICE);
}
------------------------
Find a silently evolved API code:android.content.AsyncTaskLoader.LoadTask.onPostExecute:COMMENT
Method Modifier: protected   
Comment:/* Runs on the UI thread */

Body of Frist Method:
{
    if (DEBUG)
        Slog.v(TAG, this + " onPostExecute");
    try {
        AsyncTaskLoader.this.dispatchOnLoadComplete(this, data);
    } finally {
        mDone.countDown();
    }
}
Body of Second Method:
{
    if (DEBUG)
        Log.v(TAG, this + " onPostExecute");
    try {
        AsyncTaskLoader.this.dispatchOnLoadComplete(this, data);
    } finally {
        mDone.countDown();
    }
}
------------------------
Find a silently evolved API code:android.view.accessibility.AccessibilityNodeInfo.getLabeledBy:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the node info which serves as the label of the view represented by
 * this info for accessibility purposes.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 *
 * @return The label.
 */

Body of Frist Method:
{
    enforceSealed();
    if (!canPerformRequestOverConnection(mLabeledById)) {
        return null;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mWindowId, mLabeledById, false, FLAG_PREFETCH_DESCENDANTS | FLAG_PREFETCH_SIBLINGS);
}
Body of Second Method:
{
    enforceSealed();
    if (!canPerformRequestOverConnection(mLabeledById)) {
        return null;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mWindowId, mLabeledById, false, FLAG_PREFETCH_PREDECESSORS | FLAG_PREFETCH_DESCENDANTS | FLAG_PREFETCH_SIBLINGS);
}
------------------------
Find a silently evolved API code:android.media.Ringtone.setUri:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Set {@link Uri} to be used for ringtone playback. Attempts to open
 * locally, otherwise will delegate playback to remote
 * {@link IRingtonePlayer}.
 *
 * @hide
 */

Body of Frist Method:
{
    destroyLocalPlayer();
    mUri = uri;
    if (mUri == null) {
        return;
    }
    // TODO: detect READ_EXTERNAL and specific content provider case, instead of relying on throwing
    // try opening uri locally before delegating to remote player
    mLocalPlayer = new MediaPlayer();
    try {
        mLocalPlayer.setDataSource(mContext, mUri);
        mLocalPlayer.setAudioStreamType(mStreamType);
        mLocalPlayer.prepare();
    } catch (SecurityException e) {
        destroyLocalPlayer();
        if (!mAllowRemote) {
            Log.w(TAG, "Remote playback not allowed: " + e);
        }
    } catch (IOException e) {
        destroyLocalPlayer();
        if (!mAllowRemote) {
            Log.w(TAG, "Remote playback not allowed: " + e);
        }
    }
    if (LOGD) {
        if (mLocalPlayer != null) {
            Log.d(TAG, "Successfully created local player");
        } else {
            Log.d(TAG, "Problem opening; delegating to remote player");
        }
    }
}
Body of Second Method:
{
    destroyLocalPlayer();
    mUri = uri;
    if (mUri == null) {
        return;
    }
    // TODO: detect READ_EXTERNAL and specific content provider case, instead of relying on throwing
    // try opening uri locally before delegating to remote player
    mLocalPlayer = new MediaPlayer();
    try {
        mLocalPlayer.setDataSource(mContext, mUri);
        mLocalPlayer.setAudioAttributes(mAudioAttributes);
        mLocalPlayer.prepare();
    } catch (SecurityException e) {
        destroyLocalPlayer();
        if (!mAllowRemote) {
            Log.w(TAG, "Remote playback not allowed: " + e);
        }
    } catch (IOException e) {
        destroyLocalPlayer();
        if (!mAllowRemote) {
            Log.w(TAG, "Remote playback not allowed: " + e);
        }
    }
    if (LOGD) {
        if (mLocalPlayer != null) {
            Log.d(TAG, "Successfully created local player");
        } else {
            Log.d(TAG, "Problem opening; delegating to remote player");
        }
    }
}
------------------------
Find a silently evolved API code:android.os.Process.myTid:COMMENT
Method Modifier: public      static      final       
Comment:/**
 * Returns the identifier of the calling thread, which be used with
 * {@link #setThreadPriority(int, int)}.
 */

Body of Frist Method:
{
    return Libcore.os.gettid();
}
Body of Second Method:
{
    return Os.gettid();
}
------------------------
Find a silently evolved API code:android.view.PointerIcon.load:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Loads the bitmap and hotspot information for a pointer icon, if it is not already loaded.
 * Returns a pointer icon (not necessarily the same instance) with the information filled in.
 *
 * @param context The context.
 * @return The loaded pointer icon.
 *
 * @throws IllegalArgumentException if context is null.
 * @see #isLoaded()
 * @hide
 */

Body of Frist Method:
{
    if (context == null) {
        throw new IllegalArgumentException("context must not be null");
    }
    if (mSystemIconResourceId == 0 || mBitmap != null) {
        return this;
    }
    PointerIcon result = new PointerIcon(mStyle);
    result.mSystemIconResourceId = mSystemIconResourceId;
    result.loadResource(context.getResources(), mSystemIconResourceId);
    return result;
}
Body of Second Method:
{
    if (context == null) {
        throw new IllegalArgumentException("context must not be null");
    }
    if (mSystemIconResourceId == 0 || mBitmap != null) {
        return this;
    }
    PointerIcon result = new PointerIcon(mStyle);
    result.mSystemIconResourceId = mSystemIconResourceId;
    result.loadResource(context, context.getResources(), mSystemIconResourceId);
    return result;
}
------------------------
Find a silently evolved API code:android.content.res.TypedArray.getBoolean:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the boolean value for the attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined.
 *
 * @return Attribute boolean value, or defValue if not defined.
 */

Body of Frist Method:
{
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + AssetManager.STYLE_DATA] != 0;
    }
    TypedValue v = mValue;
    if (getValueAt(index, v)) {
        Log.w(Resources.TAG, "Converting to boolean: " + v);
        return XmlUtils.convertValueToBoolean(v.coerceToString(), defValue);
    }
    Log.w(Resources.TAG, "getBoolean of bad type: 0x" + Integer.toHexString(type));
    return defValue;
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + AssetManager.STYLE_DATA] != 0;
    }
    TypedValue v = mValue;
    if (getValueAt(index, v)) {
        Log.w(Resources.TAG, "Converting to boolean: " + v);
        return XmlUtils.convertValueToBoolean(v.coerceToString(), defValue);
    }
    Log.w(Resources.TAG, "getBoolean of bad type: 0x" + Integer.toHexString(type));
    return defValue;
}
------------------------
Find a silently evolved API code:android.transition.Transition.captureValues:COMMENT
Method Modifier: default     
Comment:/**
 * Recursive method that captures values for the given view and the
 * hierarchy underneath it.
 * @param sceneRoot The root of the view hierarchy being captured
 * @param start true if this capture is happening before the scene change,
 * false otherwise
 */

Body of Frist Method:
{
    if (start) {
        mStartValues.viewValues.clear();
        mStartValues.idValues.clear();
        mStartValues.itemIdValues.clear();
    } else {
        mEndValues.viewValues.clear();
        mEndValues.idValues.clear();
        mEndValues.itemIdValues.clear();
    }
    if (mTargetIds.size() > 0 || mTargets.size() > 0) {
        if (mTargetIds.size() > 0) {
            for (int i = 0; i < mTargetIds.size(); ++i) {
                int id = mTargetIds.get(i);
                View view = sceneRoot.findViewById(id);
                if (view != null) {
                    TransitionValues values = new TransitionValues();
                    values.view = view;
                    if (start) {
                        captureStartValues(values);
                    } else {
                        captureEndValues(values);
                    }
                    if (start) {
                        mStartValues.viewValues.put(view, values);
                        if (id >= 0) {
                            mStartValues.idValues.put(id, values);
                        }
                    } else {
                        mEndValues.viewValues.put(view, values);
                        if (id >= 0) {
                            mEndValues.idValues.put(id, values);
                        }
                    }
                }
            }
        }
        if (mTargets.size() > 0) {
            for (int i = 0; i < mTargets.size(); ++i) {
                View view = mTargets.get(i);
                if (view != null) {
                    TransitionValues values = new TransitionValues();
                    values.view = view;
                    if (start) {
                        captureStartValues(values);
                    } else {
                        captureEndValues(values);
                    }
                    if (start) {
                        mStartValues.viewValues.put(view, values);
                    } else {
                        mEndValues.viewValues.put(view, values);
                    }
                }
            }
        }
    } else {
        captureHierarchy(sceneRoot, start);
    }
}
Body of Second Method:
{
    clearValues(start);
    if ((mTargetIds.size() > 0 || mTargets.size() > 0) && (mTargetNames == null || mTargetNames.isEmpty()) && (mTargetTypes == null || mTargetTypes.isEmpty())) {
        for (int i = 0; i < mTargetIds.size(); ++i) {
            int id = mTargetIds.get(i);
            View view = sceneRoot.findViewById(id);
            if (view != null) {
                TransitionValues values = new TransitionValues();
                values.view = view;
                if (start) {
                    captureStartValues(values);
                } else {
                    captureEndValues(values);
                }
                values.targetedTransitions.add(this);
                capturePropagationValues(values);
                if (start) {
                    addViewValues(mStartValues, view, values);
                } else {
                    addViewValues(mEndValues, view, values);
                }
            }
        }
        for (int i = 0; i < mTargets.size(); ++i) {
            View view = mTargets.get(i);
            TransitionValues values = new TransitionValues();
            values.view = view;
            if (start) {
                captureStartValues(values);
            } else {
                captureEndValues(values);
            }
            values.targetedTransitions.add(this);
            capturePropagationValues(values);
            if (start) {
                addViewValues(mStartValues, view, values);
            } else {
                addViewValues(mEndValues, view, values);
            }
        }
    } else {
        captureHierarchy(sceneRoot, start);
    }
    if (!start && mNameOverrides != null) {
        int numOverrides = mNameOverrides.size();
        ArrayList<View> overriddenViews = new ArrayList<View>(numOverrides);
        for (int i = 0; i < numOverrides; i++) {
            String fromName = mNameOverrides.keyAt(i);
            overriddenViews.add(mStartValues.nameValues.remove(fromName));
        }
        for (int i = 0; i < numOverrides; i++) {
            View view = overriddenViews.get(i);
            if (view != null) {
                String toName = mNameOverrides.valueAt(i);
                mStartValues.nameValues.put(toName, view);
            }
        }
    }
}
------------------------
Find a silently evolved API code:android.graphics.Paint.setColorFilter:COMMENT
Method Modifier: public      
Comment:/**
 * Set or clear the paint's colorfilter, returning the parameter.
 *
 * @param filter May be null. The new filter to be installed in the paint
 * @return       filter
 */

Body of Frist Method:
{
    int filterNative = 0;
    if (filter != null)
        filterNative = filter.native_instance;
    native_setColorFilter(mNativePaint, filterNative);
    mColorFilter = filter;
    return filter;
}
Body of Second Method:
{
    long filterNative = 0;
    if (filter != null)
        filterNative = filter.native_instance;
    native_setColorFilter(mNativePaint, filterNative);
    mColorFilter = filter;
    return filter;
}
------------------------
Find a silently evolved API code:android.content.ContentResolver.setMasterSyncAutomatically:COMMENT
Method Modifier: public      static      
Comment:/**
 * Sets the master auto-sync setting that applies to all the providers and accounts.
 * If this is false then the per-provider auto-sync setting is ignored.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#WRITE_SYNC_SETTINGS}.
 *
 * @param sync the master auto-sync setting that applies to all the providers and accounts
 */

Body of Frist Method:
{
    try {
        getContentService().setMasterSyncAutomatically(sync);
    } catch (RemoteException e) {
    // exception ignored; if this is thrown then it means the runtime is in the midst of
    // being restarted
    }
}
Body of Second Method:
{
    setMasterSyncAutomaticallyAsUser(sync, UserHandle.myUserId());
}
------------------------
Find a silently evolved API code:android.provider.DocumentsProvider.openFile:COMMENT
Method Modifier: public      final       
Comment:/**
 * Implementation is provided by the parent class. Cannot be overriden.
 *
 * @see #openDocument(String, String, CancellationSignal)
 */

Body of Frist Method:
{
    return openDocument(getDocumentId(uri), mode, signal);
}
Body of Second Method:
{
    enforceTree(uri);
    return openDocument(getDocumentId(uri), mode, null);
}
------------------------
Find a silently evolved API code:android.os.Bundle.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Writes the Bundle contents to a Parcel, typically in order for
 * it to be passed through an IBinder connection.
 * @param parcel The parcel to copy this bundle to.
 */

Body of Frist Method:
{
    final boolean oldAllowFds = parcel.pushAllowFds(mAllowFds);
    try {
        if (mParcelledData != null) {
            int length = mParcelledData.dataSize();
            parcel.writeInt(length);
            parcel.writeInt(BUNDLE_MAGIC);
            parcel.appendFrom(mParcelledData, 0, length);
        } else {
            int lengthPos = parcel.dataPosition();
            // dummy, will hold length
            parcel.writeInt(-1);
            parcel.writeInt(BUNDLE_MAGIC);
            int startPos = parcel.dataPosition();
            parcel.writeArrayMapInternal(mMap);
            int endPos = parcel.dataPosition();
            // Backpatch length
            parcel.setDataPosition(lengthPos);
            int length = endPos - startPos;
            parcel.writeInt(length);
            parcel.setDataPosition(endPos);
        }
    } finally {
        parcel.restoreAllowFds(oldAllowFds);
    }
}
Body of Second Method:
{
    final boolean oldAllowFds = parcel.pushAllowFds(mAllowFds);
    try {
        super.writeToParcelInner(parcel, flags);
    } finally {
        parcel.restoreAllowFds(oldAllowFds);
    }
}
------------------------
Find a silently evolved API code:android.view.accessibility.AccessibilityNodeInfo.getChildCount:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the number of children.
 *
 * @return The child count.
 */

Body of Frist Method:
{
    return mChildNodeIds.size();
}
Body of Second Method:
{
    return mChildNodeIds == null ? 0 : mChildNodeIds.size();
}
------------------------
Find a silently evolved API code:android.content.res.TypedArray.hasValue:COMMENT
Method Modifier: public      
Comment:/**
 * Determines whether there is an attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return True if the attribute has a value, false otherwise.
 */

Body of Frist Method:
{
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    return type != TypedValue.TYPE_NULL;
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    return type != TypedValue.TYPE_NULL;
}
------------------------
Find a silently evolved API code:android.util.ArrayMap.remove:COMMENT
Method Modifier: public      
Comment:/**
 * Remove an existing key from the array map.
 * @param key The key of the mapping to remove.
 * @return Returns the value that was stored under the key, or null if there
 * was no such key.
 */

Body of Frist Method:
{
    int index = key == null ? indexOfNull() : indexOf(key, key.hashCode());
    if (index >= 0) {
        return removeAt(index);
    }
    return null;
}
Body of Second Method:
{
    final int index = indexOfKey(key);
    if (index >= 0) {
        return removeAt(index);
    }
    return null;
}
------------------------
Find a silently evolved API code:android.accessibilityservice.AccessibilityServiceInfo.flagToString:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns the string representation of a flag. For example,
 * {@link #DEFAULT} is represented by the string DEFAULT.
 *
 * @param flag The flag.
 * @return The string representation.
 */

Body of Frist Method:
{
    switch(flag) {
        case DEFAULT:
            return "DEFAULT";
        case FLAG_INCLUDE_NOT_IMPORTANT_VIEWS:
            return "FLAG_INCLUDE_NOT_IMPORTANT_VIEWS";
        case FLAG_REQUEST_TOUCH_EXPLORATION_MODE:
            return "FLAG_REQUEST_TOUCH_EXPLORATION_MODE";
        case FLAG_REQUEST_ENHANCED_WEB_ACCESSIBILITY:
            return "FLAG_REQUEST_ENHANCED_WEB_ACCESSIBILITY";
        case FLAG_REPORT_VIEW_IDS:
            return "FLAG_REPORT_VIEW_IDS";
        case FLAG_REQUEST_FILTER_KEY_EVENTS:
            return "FLAG_REQUEST_FILTER_KEY_EVENTS";
        default:
            return null;
    }
}
Body of Second Method:
{
    switch(flag) {
        case DEFAULT:
            return "DEFAULT";
        case FLAG_INCLUDE_NOT_IMPORTANT_VIEWS:
            return "FLAG_INCLUDE_NOT_IMPORTANT_VIEWS";
        case FLAG_REQUEST_TOUCH_EXPLORATION_MODE:
            return "FLAG_REQUEST_TOUCH_EXPLORATION_MODE";
        case FLAG_REQUEST_ENHANCED_WEB_ACCESSIBILITY:
            return "FLAG_REQUEST_ENHANCED_WEB_ACCESSIBILITY";
        case FLAG_REPORT_VIEW_IDS:
            return "FLAG_REPORT_VIEW_IDS";
        case FLAG_REQUEST_FILTER_KEY_EVENTS:
            return "FLAG_REQUEST_FILTER_KEY_EVENTS";
        case FLAG_RETRIEVE_INTERACTIVE_WINDOWS:
            return "FLAG_RETRIEVE_INTERACTIVE_WINDOWS";
        default:
            return null;
    }
}
------------------------
Find a silently evolved API code:android.os.FileUtils.getUid:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Return owning UID of given path, otherwise -1.
 */

Body of Frist Method:
{
    try {
        return Libcore.os.stat(path).st_uid;
    } catch (ErrnoException e) {
        return -1;
    }
}
Body of Second Method:
{
    try {
        return Os.stat(path).st_uid;
    } catch (ErrnoException e) {
        return -1;
    }
}
------------------------
Find a silently evolved API code:android.app.Notification.BigTextStyle.addExtras:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    super.addExtras(extras);
    extras.putCharSequence(EXTRA_TEXT, mBigText);
}
Body of Second Method:
{
    super.addExtras(extras);
    extras.putCharSequence(EXTRA_BIG_TEXT, mBigText);
}
------------------------
Find a silently evolved API code:android.transition.TransitionSet.setDuration:COMMENT
Method Modifier: public      
Comment:/**
 * Setting a non-negative duration on a TransitionSet causes all of the child
 * transitions (current and future) to inherit this duration.
 *
 * @param duration The length of the animation, in milliseconds.
 * @return This transitionSet object.
 */

Body of Frist Method:
{
    super.setDuration(duration);
    if (mDuration >= 0) {
        int numTransitions = mTransitions.size();
        for (int i = 0; i < numTransitions; ++i) {
            mTransitions.get(i).setDuration(duration);
        }
    }
    return this;
}
Body of Second Method:
{
    super.setDuration(duration);
    if (mDuration >= 0 && mTransitions != null) {
        int numTransitions = mTransitions.size();
        for (int i = 0; i < numTransitions; ++i) {
            mTransitions.get(i).setDuration(duration);
        }
    }
    return this;
}
------------------------
Find a silently evolved API code:android.transition.TransitionSet.runAnimators:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    setupStartEndListeners();
    if (!mPlayTogether) {
        // TODO: Need to add listeners in such a way that we can remove them later if canceled
        for (int i = 1; i < mTransitions.size(); ++i) {
            Transition previousTransition = mTransitions.get(i - 1);
            final Transition nextTransition = mTransitions.get(i);
            previousTransition.addListener(new TransitionListenerAdapter() {

                @Override
                public void onTransitionEnd(Transition transition) {
                    nextTransition.runAnimators();
                    transition.removeListener(this);
                }
            });
        }
        Transition firstTransition = mTransitions.get(0);
        if (firstTransition != null) {
            firstTransition.runAnimators();
        }
    } else {
        for (Transition childTransition : mTransitions) {
            childTransition.runAnimators();
        }
    }
}
Body of Second Method:
{
    if (mTransitions.isEmpty()) {
        start();
        end();
        return;
    }
    setupStartEndListeners();
    int numTransitions = mTransitions.size();
    if (!mPlayTogether) {
        // TODO: Need to add listeners in such a way that we can remove them later if canceled
        for (int i = 1; i < numTransitions; ++i) {
            Transition previousTransition = mTransitions.get(i - 1);
            final Transition nextTransition = mTransitions.get(i);
            previousTransition.addListener(new TransitionListenerAdapter() {

                @Override
                public void onTransitionEnd(Transition transition) {
                    nextTransition.runAnimators();
                    transition.removeListener(this);
                }
            });
        }
        Transition firstTransition = mTransitions.get(0);
        if (firstTransition != null) {
            firstTransition.runAnimators();
        }
    } else {
        for (int i = 0; i < numTransitions; ++i) {
            mTransitions.get(i).runAnimators();
        }
    }
}
------------------------
Find a silently evolved API code:android.animation.PropertyValuesHolder.ofKeyframe:COMMENT
Method Modifier: public      static      
Comment:/**
 * Constructs and returns a PropertyValuesHolder object with the specified property name and set
 * of values. These values can be of any type, but the type should be consistent so that
 * an appropriate {@link android.animation.TypeEvaluator} can be found that matches
 * the common type.
 * <p>If there is only one value, it is assumed to be the end value of an animation,
 * and an initial value will be derived, if possible, by calling a getter function
 * on the object. Also, if any value is null, the value will be filled in when the animation
 * starts in the same way. This mechanism of automatically getting null values only works
 * if the PropertyValuesHolder object is used in conjunction
 * {@link ObjectAnimator}, and with a getter function
 * derived automatically from <code>propertyName</code>, since otherwise PropertyValuesHolder has
 * no way of determining what the value should be.
 * @param propertyName The name of the property associated with this set of values. This
 * can be the actual property name to be used when using a ObjectAnimator object, or
 * just a name used to get animated values, such as if this object is used with an
 * ValueAnimator object.
 * @param values The set of values to animate between.
 */

Body of Frist Method:
{
    KeyframeSet keyframeSet = KeyframeSet.ofKeyframe(values);
    if (keyframeSet instanceof IntKeyframeSet) {
        return new IntPropertyValuesHolder(propertyName, (IntKeyframeSet) keyframeSet);
    } else if (keyframeSet instanceof FloatKeyframeSet) {
        return new FloatPropertyValuesHolder(propertyName, (FloatKeyframeSet) keyframeSet);
    } else {
        PropertyValuesHolder pvh = new PropertyValuesHolder(propertyName);
        pvh.mKeyframeSet = keyframeSet;
        pvh.mValueType = ((Keyframe) values[0]).getType();
        return pvh;
    }
}
Body of Second Method:
{
    KeyframeSet keyframeSet = KeyframeSet.ofKeyframe(values);
    return ofKeyframes(propertyName, keyframeSet);
}
------------------------
Find a silently evolved API code:android.widget.CalendarView.setSelectedWeekBackgroundColor:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the background color for the selected week.
 *
 * @param color The week background color.
 *
 * @attr ref android.R.styleable#CalendarView_selectedWeekBackgroundColor
 */

Body of Frist Method:
{
    if (mSelectedWeekBackgroundColor != color) {
        mSelectedWeekBackgroundColor = color;
        final int childCount = mListView.getChildCount();
        for (int i = 0; i < childCount; i++) {
            WeekView weekView = (WeekView) mListView.getChildAt(i);
            if (weekView.mHasSelectedDay) {
                weekView.invalidate();
            }
        }
    }
}
Body of Second Method:
{
    mDelegate.setSelectedWeekBackgroundColor(color);
}
------------------------
Find a silently evolved API code:android.appwidget.AppWidgetHostView.getRemoteContext:COMMENT
Method Modifier: private     
Comment:/**
 * Build a {@link Context} cloned into another package name, usually for the
 * purposes of reading remote resources.
 */

Body of Frist Method:
{
    // Bail if missing package name
    final String packageName = views.getPackage();
    if (packageName == null)
        return mContext;
    try {
        // Return if cloned successfully, otherwise default
        return mContext.createPackageContextAsUser(packageName, Context.CONTEXT_RESTRICTED, mUser);
    } catch (NameNotFoundException e) {
        Log.e(TAG, "Package name " + packageName + " not found");
        return mContext;
    }
}
Body of Second Method:
{
    try {
        // Return if cloned successfully, otherwise default
        return mContext.createApplicationContext(mInfo.providerInfo.applicationInfo, Context.CONTEXT_RESTRICTED);
    } catch (NameNotFoundException e) {
        Log.e(TAG, "Package name " + mInfo.providerInfo.packageName + " not found");
        return mContext;
    }
}
------------------------
Find a silently evolved API code:android.graphics.Rect.unflattenFromString:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns a Rect from a string of the form returned by {@link #flattenToString},
 * or null if the string is not of that form.
 */

Body of Frist Method:
{
    Matcher matcher = FLATTENED_PATTERN.matcher(str);
    if (!matcher.matches()) {
        return null;
    }
    return new Rect(Integer.parseInt(matcher.group(1)), Integer.parseInt(matcher.group(2)), Integer.parseInt(matcher.group(3)), Integer.parseInt(matcher.group(4)));
}
Body of Second Method:
{
    Matcher matcher = UnflattenHelper.getMatcher(str);
    if (!matcher.matches()) {
        return null;
    }
    return new Rect(Integer.parseInt(matcher.group(1)), Integer.parseInt(matcher.group(2)), Integer.parseInt(matcher.group(3)), Integer.parseInt(matcher.group(4)));
}
------------------------
Find a silently evolved API code:android.appwidget.AppWidgetHost.deleteAppWidgetId:COMMENT
Method Modifier: public      
Comment:/**
 * Stop listening to changes for this AppWidget.
 */

Body of Frist Method:
{
    synchronized (mViews) {
        mViews.remove(appWidgetId);
        try {
            sService.deleteAppWidgetId(appWidgetId, mContext.getUserId());
        } catch (RemoteException e) {
            throw new RuntimeException("system server dead?", e);
        }
    }
}
Body of Second Method:
{
    synchronized (mViews) {
        mViews.remove(appWidgetId);
        try {
            sService.deleteAppWidgetId(mContext.getOpPackageName(), appWidgetId);
        } catch (RemoteException e) {
            throw new RuntimeException("system server dead?", e);
        }
    }
}
------------------------
Find a silently evolved API code:android.provider.MediaStore.InternalThumbnails.getThumbnail:COMMENT
Method Modifier: default     static      
Comment:/**
 * This method ensure thumbnails associated with origId are generated and decode the byte
 * stream from database (MICRO_KIND) or file (MINI_KIND).
 *
 * Special optimization has been done to avoid further IPC communication for MICRO_KIND
 * thumbnails.
 *
 * @param cr ContentResolver
 * @param origId original image or video id
 * @param kind could be MINI_KIND or MICRO_KIND
 * @param options this is only used for MINI_KIND when decoding the Bitmap
 * @param baseUri the base URI of requested thumbnails
 * @param groupId the id of group to which this request belongs
 * @return Bitmap bitmap of specified thumbnail kind
 */

Body of Frist Method:
{
    Bitmap bitmap = null;
    String filePath = null;
    // Log.v(TAG, "getThumbnail: origId="+origId+", kind="+kind+", isVideo="+isVideo);
    // If the magic is non-zero, we simply return thumbnail if it does exist.
    // querying MediaProvider and simply return thumbnail.
    MiniThumbFile thumbFile = new MiniThumbFile(isVideo ? Video.Media.EXTERNAL_CONTENT_URI : Images.Media.EXTERNAL_CONTENT_URI);
    Cursor c = null;
    try {
        long magic = thumbFile.getMagic(origId);
        if (magic != 0) {
            if (kind == MICRO_KIND) {
                synchronized (sThumbBufLock) {
                    if (sThumbBuf == null) {
                        sThumbBuf = new byte[MiniThumbFile.BYTES_PER_MINTHUMB];
                    }
                    if (thumbFile.getMiniThumbFromFile(origId, sThumbBuf) != null) {
                        bitmap = BitmapFactory.decodeByteArray(sThumbBuf, 0, sThumbBuf.length);
                        if (bitmap == null) {
                            Log.w(TAG, "couldn't decode byte array.");
                        }
                    }
                }
                return bitmap;
            } else if (kind == MINI_KIND) {
                String column = isVideo ? "video_id=" : "image_id=";
                c = cr.query(baseUri, PROJECTION, column + origId, null, null);
                if (c != null && c.moveToFirst()) {
                    bitmap = getMiniThumbFromFile(c, baseUri, cr, options);
                    if (bitmap != null) {
                        return bitmap;
                    }
                }
            }
        }
        Uri blockingUri = baseUri.buildUpon().appendQueryParameter("blocking", "1").appendQueryParameter("orig_id", String.valueOf(origId)).appendQueryParameter("group_id", String.valueOf(groupId)).build();
        if (c != null)
            c.close();
        c = cr.query(blockingUri, PROJECTION, null, null, null);
        // This happens when original image/video doesn't exist.
        if (c == null)
            return null;
        // Assuming thumbnail has been generated, at least original image exists.
        if (kind == MICRO_KIND) {
            synchronized (sThumbBufLock) {
                if (sThumbBuf == null) {
                    sThumbBuf = new byte[MiniThumbFile.BYTES_PER_MINTHUMB];
                }
                if (thumbFile.getMiniThumbFromFile(origId, sThumbBuf) != null) {
                    bitmap = BitmapFactory.decodeByteArray(sThumbBuf, 0, sThumbBuf.length);
                    if (bitmap == null) {
                        Log.w(TAG, "couldn't decode byte array.");
                    }
                }
            }
        } else if (kind == MINI_KIND) {
            if (c.moveToFirst()) {
                bitmap = getMiniThumbFromFile(c, baseUri, cr, options);
            }
        } else {
            throw new IllegalArgumentException("Unsupported kind: " + kind);
        }
        // We probably run out of space, so create the thumbnail in memory.
        if (bitmap == null) {
            Log.v(TAG, "Create the thumbnail in memory: origId=" + origId + ", kind=" + kind + ", isVideo=" + isVideo);
            Uri uri = Uri.parse(baseUri.buildUpon().appendPath(String.valueOf(origId)).toString().replaceFirst("thumbnails", "media"));
            if (filePath == null) {
                if (c != null)
                    c.close();
                c = cr.query(uri, PROJECTION, null, null, null);
                if (c == null || !c.moveToFirst()) {
                    return null;
                }
                filePath = c.getString(1);
            }
            if (isVideo) {
                bitmap = ThumbnailUtils.createVideoThumbnail(filePath, kind);
            } else {
                bitmap = ThumbnailUtils.createImageThumbnail(filePath, kind);
            }
        }
    } catch (SQLiteException ex) {
        Log.w(TAG, ex);
    } finally {
        if (c != null)
            c.close();
        // To avoid file descriptor leak in application process.
        thumbFile.deactivate();
        thumbFile = null;
    }
    return bitmap;
}
Body of Second Method:
{
    Bitmap bitmap = null;
    String filePath = null;
    // Log.v(TAG, "getThumbnail: origId="+origId+", kind="+kind+", isVideo="+isVideo);
    // If the magic is non-zero, we simply return thumbnail if it does exist.
    // querying MediaProvider and simply return thumbnail.
    MiniThumbFile thumbFile = new MiniThumbFile(isVideo ? Video.Media.EXTERNAL_CONTENT_URI : Images.Media.EXTERNAL_CONTENT_URI);
    Cursor c = null;
    try {
        long magic = thumbFile.getMagic(origId);
        if (magic != 0) {
            if (kind == MICRO_KIND) {
                synchronized (sThumbBufLock) {
                    if (sThumbBuf == null) {
                        sThumbBuf = new byte[MiniThumbFile.BYTES_PER_MINTHUMB];
                    }
                    if (thumbFile.getMiniThumbFromFile(origId, sThumbBuf) != null) {
                        bitmap = BitmapFactory.decodeByteArray(sThumbBuf, 0, sThumbBuf.length);
                        if (bitmap == null) {
                            Log.w(TAG, "couldn't decode byte array.");
                        }
                    }
                }
                return bitmap;
            } else if (kind == MINI_KIND) {
                String column = isVideo ? "video_id=" : "image_id=";
                c = cr.query(baseUri, PROJECTION, column + origId, null, null);
                if (c != null && c.moveToFirst()) {
                    bitmap = getMiniThumbFromFile(c, baseUri, cr, options);
                    if (bitmap != null) {
                        return bitmap;
                    }
                }
            }
        }
        Uri blockingUri = baseUri.buildUpon().appendQueryParameter("blocking", "1").appendQueryParameter("orig_id", String.valueOf(origId)).appendQueryParameter("group_id", String.valueOf(groupId)).build();
        if (c != null)
            c.close();
        c = cr.query(blockingUri, PROJECTION, null, null, null);
        // This happens when original image/video doesn't exist.
        if (c == null)
            return null;
        // Assuming thumbnail has been generated, at least original image exists.
        if (kind == MICRO_KIND) {
            synchronized (sThumbBufLock) {
                if (sThumbBuf == null) {
                    sThumbBuf = new byte[MiniThumbFile.BYTES_PER_MINTHUMB];
                }
                Arrays.fill(sThumbBuf, (byte) 0);
                if (thumbFile.getMiniThumbFromFile(origId, sThumbBuf) != null) {
                    bitmap = BitmapFactory.decodeByteArray(sThumbBuf, 0, sThumbBuf.length);
                    if (bitmap == null) {
                        Log.w(TAG, "couldn't decode byte array.");
                    }
                }
            }
        } else if (kind == MINI_KIND) {
            if (c.moveToFirst()) {
                bitmap = getMiniThumbFromFile(c, baseUri, cr, options);
            }
        } else {
            throw new IllegalArgumentException("Unsupported kind: " + kind);
        }
        // We probably run out of space, so create the thumbnail in memory.
        if (bitmap == null) {
            Log.v(TAG, "Create the thumbnail in memory: origId=" + origId + ", kind=" + kind + ", isVideo=" + isVideo);
            Uri uri = Uri.parse(baseUri.buildUpon().appendPath(String.valueOf(origId)).toString().replaceFirst("thumbnails", "media"));
            if (filePath == null) {
                if (c != null)
                    c.close();
                c = cr.query(uri, PROJECTION, null, null, null);
                if (c == null || !c.moveToFirst()) {
                    return null;
                }
                filePath = c.getString(1);
            }
            if (isVideo) {
                bitmap = ThumbnailUtils.createVideoThumbnail(filePath, kind);
            } else {
                bitmap = ThumbnailUtils.createImageThumbnail(filePath, kind);
            }
        }
    } catch (SQLiteException ex) {
        Log.w(TAG, ex);
    } finally {
        if (c != null)
            c.close();
        // To avoid file descriptor leak in application process.
        thumbFile.deactivate();
        thumbFile = null;
    }
    return bitmap;
}
------------------------
Find a silently evolved API code:android.content.res.BridgeTypedArray.getColorStateList:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the ColorStateList for the attribute at <var>index</var>.
 * The value may be either a single solid color or a reference to
 * a color or complex {@link android.content.res.ColorStateList} description.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return ColorStateList for the attribute, or null if not defined.
 */

Body of Frist Method:
{
    if (index < 0 || index >= mResourceData.length) {
        return null;
    }
    if (mResourceData[index] == null) {
        return null;
    }
    ResourceValue resValue = mResourceData[index];
    String value = resValue.getValue();
    if (value == null) {
        return null;
    }
    if (RenderResources.REFERENCE_NULL.equals(value)) {
        return null;
    }
    // let the framework inflate the ColorStateList from the XML file.
    File f = new File(value);
    if (f.isFile()) {
        try {
            XmlPullParser parser = ParserFactory.create(f);
            BridgeXmlBlockParser blockParser = new BridgeXmlBlockParser(parser, mContext, resValue.isFramework());
            try {
                return ColorStateList.createFromXml(mContext.getResources(), blockParser);
            } finally {
                blockParser.ensurePopped();
            }
        } catch (XmlPullParserException e) {
            Bridge.getLog().error(LayoutLog.TAG_BROKEN, "Failed to configure parser for " + value, e, null);
            return null;
        } catch (Exception e) {
            // this is an error and not warning since the file existence is checked before
            // attempting to parse it.
            Bridge.getLog().error(LayoutLog.TAG_RESOURCES_READ, "Failed to parse file " + value, e, null);
            return null;
        }
    }
    try {
        int color = ResourceHelper.getColor(value);
        return ColorStateList.valueOf(color);
    } catch (NumberFormatException e) {
        Bridge.getLog().error(LayoutLog.TAG_RESOURCES_FORMAT, e.getMessage(), e, null);
    }
    return null;
}
Body of Second Method:
{
    if (!hasValue(index)) {
        return null;
    }
    ResourceValue resValue = mResourceData[index];
    String value = resValue.getValue();
    if (value == null) {
        return null;
    }
    // let the framework inflate the ColorStateList from the XML file.
    File f = new File(value);
    if (f.isFile()) {
        try {
            XmlPullParser parser = ParserFactory.create(f);
            BridgeXmlBlockParser blockParser = new BridgeXmlBlockParser(parser, mContext, resValue.isFramework());
            try {
                return ColorStateList.createFromXml(mContext.getResources(), blockParser);
            } finally {
                blockParser.ensurePopped();
            }
        } catch (XmlPullParserException e) {
            Bridge.getLog().error(LayoutLog.TAG_BROKEN, "Failed to configure parser for " + value, e, null);
            return null;
        } catch (Exception e) {
            // this is an error and not warning since the file existence is checked before
            // attempting to parse it.
            Bridge.getLog().error(LayoutLog.TAG_RESOURCES_READ, "Failed to parse file " + value, e, null);
            return null;
        }
    }
    try {
        int color = ResourceHelper.getColor(value);
        return ColorStateList.valueOf(color);
    } catch (NumberFormatException e) {
        Bridge.getLog().error(LayoutLog.TAG_RESOURCES_FORMAT, e.getMessage(), e, null);
    }
    return null;
}
------------------------
Find a silently evolved API code:android.media.AudioTrack.audioParamCheck:COMMENT
Method Modifier: private     
Comment:// mDataLoadMode is valid

Body of Frist Method:
{
    // stream type
    if ((streamType != AudioManager.STREAM_ALARM) && (streamType != AudioManager.STREAM_MUSIC) && (streamType != AudioManager.STREAM_RING) && (streamType != AudioManager.STREAM_SYSTEM) && (streamType != AudioManager.STREAM_VOICE_CALL) && (streamType != AudioManager.STREAM_NOTIFICATION) && (streamType != AudioManager.STREAM_BLUETOOTH_SCO) && (streamType != AudioManager.STREAM_DTMF)) {
        throw new IllegalArgumentException("Invalid stream type.");
    }
    mStreamType = streamType;
    // sample rate, note these values are subject to change
    if ((sampleRateInHz < 4000) || (sampleRateInHz > 48000)) {
        throw new IllegalArgumentException(sampleRateInHz + "Hz is not a supported sample rate.");
    }
    mSampleRate = sampleRateInHz;
    // --------------
    // channel config
    mChannelConfiguration = channelConfig;
    switch(channelConfig) {
        // AudioFormat.CHANNEL_CONFIGURATION_DEFAULT
        case AudioFormat.CHANNEL_OUT_DEFAULT:
        case AudioFormat.CHANNEL_OUT_MONO:
        case AudioFormat.CHANNEL_CONFIGURATION_MONO:
            mChannelCount = 1;
            mChannels = AudioFormat.CHANNEL_OUT_MONO;
            break;
        case AudioFormat.CHANNEL_OUT_STEREO:
        case AudioFormat.CHANNEL_CONFIGURATION_STEREO:
            mChannelCount = 2;
            mChannels = AudioFormat.CHANNEL_OUT_STEREO;
            break;
        default:
            if (!isMultichannelConfigSupported(channelConfig)) {
                // input channel configuration features unsupported channels
                throw new IllegalArgumentException("Unsupported channel configuration.");
            }
            mChannels = channelConfig;
            mChannelCount = Integer.bitCount(channelConfig);
    }
    // audio format
    switch(audioFormat) {
        case AudioFormat.ENCODING_DEFAULT:
            mAudioFormat = AudioFormat.ENCODING_PCM_16BIT;
            break;
        case AudioFormat.ENCODING_PCM_16BIT:
        case AudioFormat.ENCODING_PCM_8BIT:
            mAudioFormat = audioFormat;
            break;
        default:
            throw new IllegalArgumentException("Unsupported sample encoding." + " Should be ENCODING_PCM_8BIT or ENCODING_PCM_16BIT.");
    }
    // audio load mode
    if ((mode != MODE_STREAM) && (mode != MODE_STATIC)) {
        throw new IllegalArgumentException("Invalid mode.");
    }
    mDataLoadMode = mode;
}
Body of Second Method:
{
    // sample rate, note these values are subject to change
    if (sampleRateInHz < SAMPLE_RATE_HZ_MIN || sampleRateInHz > SAMPLE_RATE_HZ_MAX) {
        throw new IllegalArgumentException(sampleRateInHz + "Hz is not a supported sample rate.");
    }
    mSampleRate = sampleRateInHz;
    // --------------
    // channel config
    mChannelConfiguration = channelConfig;
    switch(channelConfig) {
        // AudioFormat.CHANNEL_CONFIGURATION_DEFAULT
        case AudioFormat.CHANNEL_OUT_DEFAULT:
        case AudioFormat.CHANNEL_OUT_MONO:
        case AudioFormat.CHANNEL_CONFIGURATION_MONO:
            mChannelCount = 1;
            mChannels = AudioFormat.CHANNEL_OUT_MONO;
            break;
        case AudioFormat.CHANNEL_OUT_STEREO:
        case AudioFormat.CHANNEL_CONFIGURATION_STEREO:
            mChannelCount = 2;
            mChannels = AudioFormat.CHANNEL_OUT_STEREO;
            break;
        default:
            if (!isMultichannelConfigSupported(channelConfig)) {
                // input channel configuration features unsupported channels
                throw new IllegalArgumentException("Unsupported channel configuration.");
            }
            mChannels = channelConfig;
            mChannelCount = Integer.bitCount(channelConfig);
    }
    // audio format
    if (audioFormat == AudioFormat.ENCODING_DEFAULT) {
        audioFormat = AudioFormat.ENCODING_PCM_16BIT;
    }
    if (!AudioFormat.isValidEncoding(audioFormat)) {
        throw new IllegalArgumentException("Unsupported audio encoding.");
    }
    mAudioFormat = audioFormat;
    // audio load mode
    if (((mode != MODE_STREAM) && (mode != MODE_STATIC)) || ((mode != MODE_STREAM) && !AudioFormat.isEncodingLinearPcm(mAudioFormat))) {
        throw new IllegalArgumentException("Invalid mode.");
    }
    mDataLoadMode = mode;
}
------------------------
Find a silently evolved API code:android.view.ViewGroup.invalidateChildInParent:COMMENT
Method Modifier: public      
Comment:/**
 * Don't call or override this method. It is used for the implementation of
 * the view hierarchy.
 *
 * This implementation returns null if this ViewGroup does not have a parent,
 * if this ViewGroup is already fully invalidated or if the dirty rectangle
 * does not intersect with this ViewGroup's bounds.
 */

Body of Frist Method:
{
    if ((mPrivateFlags & PFLAG_DRAWN) == PFLAG_DRAWN || (mPrivateFlags & PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID) {
        if ((mGroupFlags & (FLAG_OPTIMIZE_INVALIDATE | FLAG_ANIMATION_DONE)) != FLAG_OPTIMIZE_INVALIDATE) {
            dirty.offset(location[CHILD_LEFT_INDEX] - mScrollX, location[CHILD_TOP_INDEX] - mScrollY);
            if ((mGroupFlags & FLAG_CLIP_CHILDREN) == 0) {
                dirty.union(0, 0, mRight - mLeft, mBottom - mTop);
            }
            final int left = mLeft;
            final int top = mTop;
            if ((mGroupFlags & FLAG_CLIP_CHILDREN) == FLAG_CLIP_CHILDREN) {
                if (!dirty.intersect(0, 0, mRight - left, mBottom - top)) {
                    dirty.setEmpty();
                }
            }
            mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
            location[CHILD_LEFT_INDEX] = left;
            location[CHILD_TOP_INDEX] = top;
            if (mLayerType != LAYER_TYPE_NONE) {
                mPrivateFlags |= PFLAG_INVALIDATED;
                mLocalDirtyRect.union(dirty);
            }
            return mParent;
        } else {
            mPrivateFlags &= ~PFLAG_DRAWN & ~PFLAG_DRAWING_CACHE_VALID;
            location[CHILD_LEFT_INDEX] = mLeft;
            location[CHILD_TOP_INDEX] = mTop;
            if ((mGroupFlags & FLAG_CLIP_CHILDREN) == FLAG_CLIP_CHILDREN) {
                dirty.set(0, 0, mRight - mLeft, mBottom - mTop);
            } else {
                // in case the dirty rect extends outside the bounds of this container
                dirty.union(0, 0, mRight - mLeft, mBottom - mTop);
            }
            if (mLayerType != LAYER_TYPE_NONE) {
                mPrivateFlags |= PFLAG_INVALIDATED;
                mLocalDirtyRect.union(dirty);
            }
            return mParent;
        }
    }
    return null;
}
Body of Second Method:
{
    if ((mPrivateFlags & PFLAG_DRAWN) == PFLAG_DRAWN || (mPrivateFlags & PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID) {
        if ((mGroupFlags & (FLAG_OPTIMIZE_INVALIDATE | FLAG_ANIMATION_DONE)) != FLAG_OPTIMIZE_INVALIDATE) {
            dirty.offset(location[CHILD_LEFT_INDEX] - mScrollX, location[CHILD_TOP_INDEX] - mScrollY);
            if ((mGroupFlags & FLAG_CLIP_CHILDREN) == 0) {
                dirty.union(0, 0, mRight - mLeft, mBottom - mTop);
            }
            final int left = mLeft;
            final int top = mTop;
            if ((mGroupFlags & FLAG_CLIP_CHILDREN) == FLAG_CLIP_CHILDREN) {
                if (!dirty.intersect(0, 0, mRight - left, mBottom - top)) {
                    dirty.setEmpty();
                }
            }
            mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
            location[CHILD_LEFT_INDEX] = left;
            location[CHILD_TOP_INDEX] = top;
            if (mLayerType != LAYER_TYPE_NONE) {
                mPrivateFlags |= PFLAG_INVALIDATED;
            }
            return mParent;
        } else {
            mPrivateFlags &= ~PFLAG_DRAWN & ~PFLAG_DRAWING_CACHE_VALID;
            location[CHILD_LEFT_INDEX] = mLeft;
            location[CHILD_TOP_INDEX] = mTop;
            if ((mGroupFlags & FLAG_CLIP_CHILDREN) == FLAG_CLIP_CHILDREN) {
                dirty.set(0, 0, mRight - mLeft, mBottom - mTop);
            } else {
                // in case the dirty rect extends outside the bounds of this container
                dirty.union(0, 0, mRight - mLeft, mBottom - mTop);
            }
            if (mLayerType != LAYER_TYPE_NONE) {
                mPrivateFlags |= PFLAG_INVALIDATED;
            }
            return mParent;
        }
    }
    return null;
}
------------------------
Find a silently evolved API code:android.media.MediaRecorder.setCaptureRate:COMMENT
Method Modifier: public      
Comment:/**
 * Set video frame capture rate. This can be used to set a different video frame capture
 * rate than the recorded video's playback rate. This method also sets the recording mode
 * to time lapse. In time lapse video recording, only video is recorded. Audio related
 * parameters are ignored when a time lapse recording session starts, if an application
 * sets them.
 *
 * @param fps Rate at which frames should be captured in frames per second.
 * The fps can go as low as desired. However the fastest fps will be limited by the hardware.
 * For resolutions that can be captured by the video camera, the fastest fps can be computed using
 * {@link android.hardware.Camera.Parameters#getPreviewFpsRange(int[])}. For higher
 * resolutions the fastest fps may be more restrictive.
 * Note that the recorder cannot guarantee that frames will be captured at the
 * given rate due to camera/encoder limitations. However it tries to be as close as
 * possible.
 */

Body of Frist Method:
{
    // Make sure that time lapse is enabled when this method is called.
    setParameter("time-lapse-enable=1");
    double timeBetweenFrameCapture = 1 / fps;
    int timeBetweenFrameCaptureMs = (int) (1000 * timeBetweenFrameCapture);
    setParameter("time-between-time-lapse-frame-capture=" + timeBetweenFrameCaptureMs);
}
Body of Second Method:
{
    // Make sure that time lapse is enabled when this method is called.
    setParameter("time-lapse-enable=1");
    double timeBetweenFrameCapture = 1 / fps;
    long timeBetweenFrameCaptureUs = (long) (1000000 * timeBetweenFrameCapture);
    setParameter("time-between-time-lapse-frame-capture=" + timeBetweenFrameCaptureUs);
}
------------------------
Find a silently evolved API code:android.content.res.BridgeTypedArray.getTextArray:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the CharSequence[] for the attribute at <var>index</var>.
 * This gets the resource ID of the selected attribute, and uses
 * {@link Resources#getTextArray Resources.getTextArray} of the owning
 * Resources object to retrieve its String[].
 *
 * @param index Index of attribute to retrieve.
 *
 * @return CharSequence[] for the attribute, or null if not defined.
 */

Body of Frist Method:
{
    if (index < 0 || index >= mResourceData.length) {
        return null;
    }
    if (mResourceData[index] == null) {
        return null;
    }
    String value = mResourceData[index].getValue();
    if (value != null) {
        if (RenderResources.REFERENCE_NULL.equals(value)) {
            return null;
        }
        return new CharSequence[] { value };
    }
    Bridge.getLog().warning(LayoutLog.TAG_RESOURCES_FORMAT, String.format(// DEBUG
    String.format(// DEBUG
    "Unknown value for getTextArray(%d) => %s", index, mResourceData[index].getName())), null);
    return null;
}
Body of Second Method:
{
    String value = getString(index);
    if (value != null) {
        return new CharSequence[] { value };
    }
    return null;
}
------------------------
Find a silently evolved API code:android.transition.TransitionInflater.from:COMMENT
Method Modifier: public      static      
Comment:/**
 * Obtains the TransitionInflater from the given context.
 */

Body of Frist Method:
{
    TransitionInflater inflater = sInflaterMap.get(context);
    if (inflater != null) {
        return inflater;
    }
    inflater = new TransitionInflater(context);
    sInflaterMap.put(context, inflater);
    return inflater;
}
Body of Second Method:
{
    return new TransitionInflater(context);
}
------------------------
Find a silently evolved API code:android.graphics.Path.isInverseFillType:COMMENT
Method Modifier: public      
Comment:/**
 * Returns true if the filltype is one of the INVERSE variants
 *
 * @return true if the filltype is one of the INVERSE variants
 */

Body of Frist Method:
{
    final int ft = native_getFillType(mNativePath);
    return (ft & 2) != 0;
}
Body of Second Method:
{
    final int ft = native_getFillType(mNativePath);
    return (ft & FillType.INVERSE_WINDING.nativeInt) != 0;
}
------------------------
Find a silently evolved API code:android.media.AudioService.checkSendBecomingNoisyIntent:COMMENT
Method Modifier: private     hidden      
Comment:// must be called before removing the device from mConnectedDevices

Body of Frist Method:
{
    int delay = 0;
    if ((state == 0) && ((device & mBecomingNoisyIntentDevices) != 0)) {
        int devices = 0;
        for (int dev : mConnectedDevices.keySet()) {
            if ((dev & mBecomingNoisyIntentDevices) != 0) {
                devices |= dev;
            }
        }
        if (devices == device) {
            sendMsg(mAudioHandler, MSG_BROADCAST_AUDIO_BECOMING_NOISY, SENDMSG_REPLACE, 0, 0, null, 0);
            delay = 1000;
        }
    }
    if (mAudioHandler.hasMessages(MSG_SET_A2DP_CONNECTION_STATE) || mAudioHandler.hasMessages(MSG_SET_WIRED_DEVICE_CONNECTION_STATE)) {
        delay = 1000;
    }
    return delay;
}
Body of Second Method:
{
    int delay = 0;
    if ((state == 0) && ((device & mBecomingNoisyIntentDevices) != 0)) {
        int devices = 0;
        for (int dev : mConnectedDevices.keySet()) {
            if (((dev & AudioSystem.DEVICE_BIT_IN) == 0) && ((dev & mBecomingNoisyIntentDevices) != 0)) {
                devices |= dev;
            }
        }
        if (devices == device) {
            sendMsg(mAudioHandler, MSG_BROADCAST_AUDIO_BECOMING_NOISY, SENDMSG_REPLACE, 0, 0, null, 0);
            delay = 1000;
        }
    }
    if (mAudioHandler.hasMessages(MSG_SET_A2DP_SRC_CONNECTION_STATE) || mAudioHandler.hasMessages(MSG_SET_A2DP_SINK_CONNECTION_STATE) || mAudioHandler.hasMessages(MSG_SET_WIRED_DEVICE_CONNECTION_STATE)) {
        delay = 1000;
    }
    return delay;
}
------------------------
Find a silently evolved API code:android.content.pm.Signature.areExactMatch:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Test if given {@link Signature} sets are exactly equal.
 *
 * @hide
 */

Body of Frist Method:
{
    return ArrayUtils.containsAll(a, b) && ArrayUtils.containsAll(b, a);
}
Body of Second Method:
{
    return (a.length == b.length) && ArrayUtils.containsAll(a, b) && ArrayUtils.containsAll(b, a);
}
------------------------
Find a silently evolved API code:android.content.RestrictionEntry.setType:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the type for this restriction.
 * @param type the type for this restriction.
 */

Body of Frist Method:
{
    this.type = type;
}
Body of Second Method:
{
    this.mType = type;
}
------------------------
Find a silently evolved API code:android.animation.AnimatorSet.Builder.before:COMMENT
Method Modifier: public      
Comment:/**
 * Sets up the given animation to play when the animation supplied in the
 * {@link AnimatorSet#play(Animator)} call that created this <code>Builder</code> object
 * ends.
 *
 * @param anim The animation that will play when the animation supplied to the
 * {@link AnimatorSet#play(Animator)} method ends.
 */

Body of Frist Method:
{
    Node node = mNodeMap.get(anim);
    if (node == null) {
        node = new Node(anim);
        mNodeMap.put(anim, node);
        mNodes.add(node);
    }
    Dependency dependency = new Dependency(mCurrentNode, Dependency.AFTER);
    node.addDependency(dependency);
    return this;
}
Body of Second Method:
{
    mReversible = false;
    Node node = mNodeMap.get(anim);
    if (node == null) {
        node = new Node(anim);
        mNodeMap.put(anim, node);
        mNodes.add(node);
    }
    Dependency dependency = new Dependency(mCurrentNode, Dependency.AFTER);
    node.addDependency(dependency);
    return this;
}
------------------------
Find a silently evolved API code:android.os.Bundle.getBoolean:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the value associated with the given key, or false if
 * no mapping of the desired type exists for the given key.
 *
 * @param key a String
 * @return a boolean value
 */

Body of Frist Method:
{
    unparcel();
    if (DEBUG)
        Log.d(TAG, "Getting boolean in " + Integer.toHexString(System.identityHashCode(this)));
    return getBoolean(key, false);
}
Body of Second Method:
{
    return super.getBoolean(key);
}
------------------------
Find a silently evolved API code:android.graphics.drawable.AnimationDrawable.stop:COMMENT
Method Modifier: public      
Comment:/**
 * <p>Stops the animation. This method has no effect if the animation is
 * not running.</p>
 *
 * @see #isRunning()
 * @see #start()
 */

Body of Frist Method:
{
    if (isRunning()) {
        unscheduleSelf(this);
    }
}
Body of Second Method:
{
    mAnimating = false;
    if (isRunning()) {
        unscheduleSelf(this);
    }
}
------------------------
Find a silently evolved API code:android.widget.AbsListView.onLayout:COMMENT
Method Modifier: protected   
Comment:/**
 * Subclasses should NOT override this method but
 * {@link #layoutChildren()} instead.
 */

Body of Frist Method:
{
    super.onLayout(changed, l, t, r, b);
    mInLayout = true;
    if (changed) {
        int childCount = getChildCount();
        for (int i = 0; i < childCount; i++) {
            getChildAt(i).forceLayout();
        }
        mRecycler.markChildrenDirty();
    }
    if (mFastScroller != null && (mItemCount != mOldItemCount || mDataChanged)) {
        mFastScroller.onItemCountChanged(mItemCount);
    }
    layoutChildren();
    mInLayout = false;
    mOverscrollMax = (b - t) / OVERSCROLL_LIMIT_DIVISOR;
}
Body of Second Method:
{
    super.onLayout(changed, l, t, r, b);
    mInLayout = true;
    final int childCount = getChildCount();
    if (changed) {
        for (int i = 0; i < childCount; i++) {
            getChildAt(i).forceLayout();
        }
        mRecycler.markChildrenDirty();
    }
    layoutChildren();
    mInLayout = false;
    mOverscrollMax = (b - t) / OVERSCROLL_LIMIT_DIVISOR;
    // TODO: Move somewhere sane. This doesn't belong in onLayout().
    if (mFastScroll != null) {
        mFastScroll.onItemCountChanged(getChildCount(), mItemCount);
    }
}
------------------------
Find a silently evolved API code:android.widget.CalendarView.getMinDate:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the minimal date supported by this {@link CalendarView} in milliseconds
 * since January 1, 1970 00:00:00 in {@link TimeZone#getDefault()} time
 * zone.
 * <p>
 * Note: The default minimal date is 01/01/1900.
 * <p>
 *
 * @return The minimal supported date.
 *
 * @attr ref android.R.styleable#CalendarView_minDate
 */

Body of Frist Method:
{
    return mMinDate.getTimeInMillis();
}
Body of Second Method:
{
    return mDelegate.getMinDate();
}
------------------------
Find a silently evolved API code:android.widget.TextView.handleTextChanged:COMMENT
Method Modifier: default     
Comment:/**
 * Not private so it can be called from an inner class without going
 * through a thunk.
 */

Body of Frist Method:
{
    final Editor.InputMethodState ims = mEditor == null ? null : mEditor.mInputMethodState;
    if (ims == null || ims.mBatchEditNesting == 0) {
        updateAfterEdit();
    }
    if (ims != null) {
        ims.mContentChanged = true;
        if (ims.mChangedStart < 0) {
            ims.mChangedStart = start;
            ims.mChangedEnd = start + before;
        } else {
            ims.mChangedStart = Math.min(ims.mChangedStart, start);
            ims.mChangedEnd = Math.max(ims.mChangedEnd, start + before - ims.mChangedDelta);
        }
        ims.mChangedDelta += after - before;
    }
    sendOnTextChanged(buffer, start, before, after);
    onTextChanged(buffer, start, before, after);
}
Body of Second Method:
{
    final Editor.InputMethodState ims = mEditor == null ? null : mEditor.mInputMethodState;
    if (ims == null || ims.mBatchEditNesting == 0) {
        updateAfterEdit();
    }
    if (ims != null) {
        ims.mContentChanged = true;
        if (ims.mChangedStart < 0) {
            ims.mChangedStart = start;
            ims.mChangedEnd = start + before;
        } else {
            ims.mChangedStart = Math.min(ims.mChangedStart, start);
            ims.mChangedEnd = Math.max(ims.mChangedEnd, start + before - ims.mChangedDelta);
        }
        ims.mChangedDelta += after - before;
    }
    resetErrorChangedFlag();
    sendOnTextChanged(buffer, start, before, after);
    onTextChanged(buffer, start, before, after);
}
------------------------
Find a silently evolved API code:android.print.PrintJobInfo.Builder.putAdvancedOption:COMMENT
Method Modifier: public      
Comment:/**
 * Puts an advanced (printer specific) option.
 *
 * @param key The option key.
 * @param value The option value.
 */

Body of Frist Method:
{
}
Body of Second Method:
{
    if (mPrototype.mAdvancedOptions == null) {
        mPrototype.mAdvancedOptions = new Bundle();
    }
    mPrototype.mAdvancedOptions.putInt(key, value);
}
------------------------
Find a silently evolved API code:android.media.RemoteController.seekTo:COMMENT
<android.media.RemoteController: boolean seekTo(long)>
public      ->public      deprecated  
Method Modifier: public      deprecated  
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Sets the new playback position.
 * This method can only be called on a registered RemoteController.
 * @param timeMs a 0 or positive value for the new playback position, expressed in ms.
 * @return true if the command to set the playback position was successfully sent.
 * @throws IllegalArgumentException
 */

Body of Frist Method:
{
    if (!mEnabled) {
        Log.e(TAG, "Cannot use seekTo() from a disabled RemoteController");
        return false;
    }
    if (timeMs < 0) {
        throw new IllegalArgumentException("illegal negative time value");
    }
    final int genId;
    synchronized (mGenLock) {
        genId = mClientGenerationIdCurrent;
    }
    mAudioManager.setRemoteControlClientPlaybackPosition(genId, timeMs);
    return true;
}
Body of Second Method:
{
    if (!mEnabled) {
        Log.e(TAG, "Cannot use seekTo() from a disabled RemoteController");
        return false;
    }
    if (timeMs < 0) {
        throw new IllegalArgumentException("illegal negative time value");
    }
    synchronized (mInfoLock) {
        if (mCurrentSession != null) {
            mCurrentSession.getTransportControls().seekTo(timeMs);
        }
    }
    return true;
}
------------------------
Find a silently evolved API code:android.content.AsyncTaskLoader.LoadTask.doInBackground:COMMENT
Method Modifier: protected   
Comment:/* Runs on a worker thread */

Body of Frist Method:
{
    if (DEBUG)
        Slog.v(TAG, this + " >>> doInBackground");
    try {
        D data = AsyncTaskLoader.this.onLoadInBackground();
        if (DEBUG)
            Slog.v(TAG, this + "  <<< doInBackground");
        return data;
    } catch (OperationCanceledException ex) {
        if (!isCancelled()) {
            // So we treat this case as an unhandled exception.
            throw ex;
        }
        if (DEBUG)
            Slog.v(TAG, this + "  <<< doInBackground (was canceled)", ex);
        return null;
    }
}
Body of Second Method:
{
    if (DEBUG)
        Log.v(TAG, this + " >>> doInBackground");
    try {
        D data = AsyncTaskLoader.this.onLoadInBackground();
        if (DEBUG)
            Log.v(TAG, this + "  <<< doInBackground");
        return data;
    } catch (OperationCanceledException ex) {
        if (!isCancelled()) {
            // So we treat this case as an unhandled exception.
            throw ex;
        }
        if (DEBUG)
            Log.v(TAG, this + "  <<< doInBackground (was canceled)", ex);
        return null;
    }
}
------------------------
Find a silently evolved API code:android.view.ScaleGestureDetector.onTouchEvent:COMMENT
Method Modifier: public      
Comment:/**
 * Accepts MotionEvents and dispatches events to a {@link OnScaleGestureListener}
 * when appropriate.
 *
 * <p>Applications should pass a complete and consistent event stream to this method.
 * A complete and consistent event stream involves all MotionEvents from the initial
 * ACTION_DOWN to the final ACTION_UP or ACTION_CANCEL.</p>
 *
 * @param event The event to process
 * @return true if the event was processed and the detector wants to receive the
 * rest of the MotionEvents in this event stream.
 */

Body of Frist Method:
{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(event, 0);
    }
    mCurrTime = event.getEventTime();
    final int action = event.getActionMasked();
    // Forward the event to check for double tap gesture
    if (mQuickScaleEnabled) {
        mGestureDetector.onTouchEvent(event);
    }
    final boolean streamComplete = action == MotionEvent.ACTION_UP || action == MotionEvent.ACTION_CANCEL;
    if (action == MotionEvent.ACTION_DOWN || streamComplete) {
        // This means the app probably didn't give us all the events. Shame on it.
        if (mInProgress) {
            mListener.onScaleEnd(this);
            mInProgress = false;
            mInitialSpan = 0;
            mDoubleTapMode = DOUBLE_TAP_MODE_NONE;
        }
        if (streamComplete) {
            clearTouchHistory();
            return true;
        }
    }
    final boolean configChanged = action == MotionEvent.ACTION_DOWN || action == MotionEvent.ACTION_POINTER_UP || action == MotionEvent.ACTION_POINTER_DOWN;
    final boolean pointerUp = action == MotionEvent.ACTION_POINTER_UP;
    final int skipIndex = pointerUp ? event.getActionIndex() : -1;
    // Determine focal point
    float sumX = 0, sumY = 0;
    final int count = event.getPointerCount();
    final int div = pointerUp ? count - 1 : count;
    final float focusX;
    final float focusY;
    if (mDoubleTapMode == DOUBLE_TAP_MODE_IN_PROGRESS) {
        // In double tap mode, the focal pt is always where the double tap
        // gesture started
        focusX = mDoubleTapEvent.getX();
        focusY = mDoubleTapEvent.getY();
        if (event.getY() < focusY) {
            mEventBeforeOrAboveStartingGestureEvent = true;
        } else {
            mEventBeforeOrAboveStartingGestureEvent = false;
        }
    } else {
        for (int i = 0; i < count; i++) {
            if (skipIndex == i)
                continue;
            sumX += event.getX(i);
            sumY += event.getY(i);
        }
        focusX = sumX / div;
        focusY = sumY / div;
    }
    addTouchHistory(event);
    // Determine average deviation from focal point
    float devSumX = 0, devSumY = 0;
    for (int i = 0; i < count; i++) {
        if (skipIndex == i)
            continue;
        // Convert the resulting diameter into a radius.
        final float touchSize = mTouchHistoryLastAccepted / 2;
        devSumX += Math.abs(event.getX(i) - focusX) + touchSize;
        devSumY += Math.abs(event.getY(i) - focusY) + touchSize;
    }
    final float devX = devSumX / div;
    final float devY = devSumY / div;
    // Span is the average distance between touch points through the focal point;
    // i.e. the diameter of the circle with a radius of the average deviation from
    // the focal point.
    final float spanX = devX * 2;
    final float spanY = devY * 2;
    final float span;
    if (inDoubleTapMode()) {
        span = spanY;
    } else {
        span = FloatMath.sqrt(spanX * spanX + spanY * spanY);
    }
    // Dispatch begin/end events as needed.
    // If the configuration changes, notify the app to reset its current state by beginning
    // a fresh scale event stream.
    final boolean wasInProgress = mInProgress;
    mFocusX = focusX;
    mFocusY = focusY;
    if (!inDoubleTapMode() && mInProgress && (span < mMinSpan || configChanged)) {
        mListener.onScaleEnd(this);
        mInProgress = false;
        mInitialSpan = span;
        mDoubleTapMode = DOUBLE_TAP_MODE_NONE;
    }
    if (configChanged) {
        mPrevSpanX = mCurrSpanX = spanX;
        mPrevSpanY = mCurrSpanY = spanY;
        mInitialSpan = mPrevSpan = mCurrSpan = span;
    }
    final int minSpan = inDoubleTapMode() ? mSpanSlop : mMinSpan;
    if (!mInProgress && span >= minSpan && (wasInProgress || Math.abs(span - mInitialSpan) > mSpanSlop)) {
        mPrevSpanX = mCurrSpanX = spanX;
        mPrevSpanY = mCurrSpanY = spanY;
        mPrevSpan = mCurrSpan = span;
        mPrevTime = mCurrTime;
        mInProgress = mListener.onScaleBegin(this);
    }
    // Handle motion; focal point and span/scale factor are changing.
    if (action == MotionEvent.ACTION_MOVE) {
        mCurrSpanX = spanX;
        mCurrSpanY = spanY;
        mCurrSpan = span;
        boolean updatePrev = true;
        if (mInProgress) {
            updatePrev = mListener.onScale(this);
        }
        if (updatePrev) {
            mPrevSpanX = mCurrSpanX;
            mPrevSpanY = mCurrSpanY;
            mPrevSpan = mCurrSpan;
            mPrevTime = mCurrTime;
        }
    }
    return true;
}
Body of Second Method:
{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(event, 0);
    }
    mCurrTime = event.getEventTime();
    final int action = event.getActionMasked();
    // Forward the event to check for double tap gesture
    if (mQuickScaleEnabled) {
        mGestureDetector.onTouchEvent(event);
    }
    final boolean streamComplete = action == MotionEvent.ACTION_UP || action == MotionEvent.ACTION_CANCEL;
    if (action == MotionEvent.ACTION_DOWN || streamComplete) {
        // This means the app probably didn't give us all the events. Shame on it.
        if (mInProgress) {
            mListener.onScaleEnd(this);
            mInProgress = false;
            mInitialSpan = 0;
            mDoubleTapMode = DOUBLE_TAP_MODE_NONE;
        } else if (mDoubleTapMode == DOUBLE_TAP_MODE_IN_PROGRESS && streamComplete) {
            mInProgress = false;
            mInitialSpan = 0;
            mDoubleTapMode = DOUBLE_TAP_MODE_NONE;
        }
        if (streamComplete) {
            clearTouchHistory();
            return true;
        }
    }
    final boolean configChanged = action == MotionEvent.ACTION_DOWN || action == MotionEvent.ACTION_POINTER_UP || action == MotionEvent.ACTION_POINTER_DOWN;
    final boolean pointerUp = action == MotionEvent.ACTION_POINTER_UP;
    final int skipIndex = pointerUp ? event.getActionIndex() : -1;
    // Determine focal point
    float sumX = 0, sumY = 0;
    final int count = event.getPointerCount();
    final int div = pointerUp ? count - 1 : count;
    final float focusX;
    final float focusY;
    if (mDoubleTapMode == DOUBLE_TAP_MODE_IN_PROGRESS) {
        // In double tap mode, the focal pt is always where the double tap
        // gesture started
        focusX = mDoubleTapEvent.getX();
        focusY = mDoubleTapEvent.getY();
        if (event.getY() < focusY) {
            mEventBeforeOrAboveStartingGestureEvent = true;
        } else {
            mEventBeforeOrAboveStartingGestureEvent = false;
        }
    } else {
        for (int i = 0; i < count; i++) {
            if (skipIndex == i)
                continue;
            sumX += event.getX(i);
            sumY += event.getY(i);
        }
        focusX = sumX / div;
        focusY = sumY / div;
    }
    addTouchHistory(event);
    // Determine average deviation from focal point
    float devSumX = 0, devSumY = 0;
    for (int i = 0; i < count; i++) {
        if (skipIndex == i)
            continue;
        // Convert the resulting diameter into a radius.
        final float touchSize = mTouchHistoryLastAccepted / 2;
        devSumX += Math.abs(event.getX(i) - focusX) + touchSize;
        devSumY += Math.abs(event.getY(i) - focusY) + touchSize;
    }
    final float devX = devSumX / div;
    final float devY = devSumY / div;
    // Span is the average distance between touch points through the focal point;
    // i.e. the diameter of the circle with a radius of the average deviation from
    // the focal point.
    final float spanX = devX * 2;
    final float spanY = devY * 2;
    final float span;
    if (inDoubleTapMode()) {
        span = spanY;
    } else {
        span = FloatMath.sqrt(spanX * spanX + spanY * spanY);
    }
    // Dispatch begin/end events as needed.
    // If the configuration changes, notify the app to reset its current state by beginning
    // a fresh scale event stream.
    final boolean wasInProgress = mInProgress;
    mFocusX = focusX;
    mFocusY = focusY;
    if (!inDoubleTapMode() && mInProgress && (span < mMinSpan || configChanged)) {
        mListener.onScaleEnd(this);
        mInProgress = false;
        mInitialSpan = span;
        mDoubleTapMode = DOUBLE_TAP_MODE_NONE;
    }
    if (configChanged) {
        mPrevSpanX = mCurrSpanX = spanX;
        mPrevSpanY = mCurrSpanY = spanY;
        mInitialSpan = mPrevSpan = mCurrSpan = span;
    }
    final int minSpan = inDoubleTapMode() ? mSpanSlop : mMinSpan;
    if (!mInProgress && span >= minSpan && (wasInProgress || Math.abs(span - mInitialSpan) > mSpanSlop)) {
        mPrevSpanX = mCurrSpanX = spanX;
        mPrevSpanY = mCurrSpanY = spanY;
        mPrevSpan = mCurrSpan = span;
        mPrevTime = mCurrTime;
        mInProgress = mListener.onScaleBegin(this);
    }
    // Handle motion; focal point and span/scale factor are changing.
    if (action == MotionEvent.ACTION_MOVE) {
        mCurrSpanX = spanX;
        mCurrSpanY = spanY;
        mCurrSpan = span;
        boolean updatePrev = true;
        if (mInProgress) {
            updatePrev = mListener.onScale(this);
        }
        if (updatePrev) {
            mPrevSpanX = mCurrSpanX;
            mPrevSpanY = mCurrSpanY;
            mPrevSpan = mCurrSpan;
            mPrevTime = mCurrTime;
        }
    }
    return true;
}
------------------------
Find a silently evolved API code:android.os.Bundle.putByteArray:COMMENT
Method Modifier: public      
Comment:/**
 * Inserts a byte array value into the mapping of this Bundle, replacing
 * any existing value for the given key.  Either key or value may be null.
 *
 * @param key a String, or null
 * @param value a byte array object, or null
 */

Body of Frist Method:
{
    unparcel();
    mMap.put(key, value);
}
Body of Second Method:
{
    super.putByteArray(key, value);
}
------------------------
Find a silently evolved API code:android.view.HardwareRenderer.setupDiskCache:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Sets the directory to use as a persistent storage for hardware rendering
 * resources.
 *
 * @param cacheDir A directory the current process can write to
 *
 * @hide
 */

Body of Frist Method:
{
    nSetupShadersDiskCache(new File(cacheDir, CACHE_PATH_SHADERS).getAbsolutePath());
}
Body of Second Method:
{
    ThreadedRenderer.setupShadersDiskCache(new File(cacheDir, CACHE_PATH_SHADERS).getAbsolutePath());
}
------------------------
Find a silently evolved API code:android.net.NetworkStats.subtract:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Subtract the two given {@link NetworkStats} objects, returning the delta
 * between two snapshots in time. Assumes that statistics rows collect over
 * time, and that none of them have disappeared.
 * <p>
 * If counters have rolled backwards, they are clamped to {@code 0} and
 * reported to the given {@link NonMonotonicObserver}.
 */

Body of Frist Method:
{
    long deltaRealtime = left.elapsedRealtime - right.elapsedRealtime;
    if (deltaRealtime < 0) {
        if (observer != null) {
            observer.foundNonMonotonic(left, -1, right, -1, cookie);
        }
        deltaRealtime = 0;
    }
    // result will have our rows, and elapsed time between snapshots
    final Entry entry = new Entry();
    final NetworkStats result = new NetworkStats(deltaRealtime, left.size);
    for (int i = 0; i < left.size; i++) {
        entry.iface = left.iface[i];
        entry.uid = left.uid[i];
        entry.set = left.set[i];
        entry.tag = left.tag[i];
        // find remote row that matches, and subtract
        final int j = right.findIndexHinted(entry.iface, entry.uid, entry.set, entry.tag, i);
        if (j == -1) {
            // newly appearing row, return entire value
            entry.rxBytes = left.rxBytes[i];
            entry.rxPackets = left.rxPackets[i];
            entry.txBytes = left.txBytes[i];
            entry.txPackets = left.txPackets[i];
            entry.operations = left.operations[i];
        } else {
            // existing row, subtract remote value
            entry.rxBytes = left.rxBytes[i] - right.rxBytes[j];
            entry.rxPackets = left.rxPackets[i] - right.rxPackets[j];
            entry.txBytes = left.txBytes[i] - right.txBytes[j];
            entry.txPackets = left.txPackets[i] - right.txPackets[j];
            entry.operations = left.operations[i] - right.operations[j];
            if (entry.rxBytes < 0 || entry.rxPackets < 0 || entry.txBytes < 0 || entry.txPackets < 0 || entry.operations < 0) {
                if (observer != null) {
                    observer.foundNonMonotonic(left, i, right, j, cookie);
                }
                entry.rxBytes = Math.max(entry.rxBytes, 0);
                entry.rxPackets = Math.max(entry.rxPackets, 0);
                entry.txBytes = Math.max(entry.txBytes, 0);
                entry.txPackets = Math.max(entry.txPackets, 0);
                entry.operations = Math.max(entry.operations, 0);
            }
        }
        result.addValues(entry);
    }
    return result;
}
Body of Second Method:
{
    return subtract(left, right, observer, cookie, null);
}
------------------------
Find a silently evolved API code:android.util.TimeUtils.getTimeZone:COMMENT
Method Modifier: public      static      
Comment:/**
 * Tries to return a time zone that would have had the specified offset
 * and DST value at the specified moment in the specified country.
 * Returns null if no suitable zone could be found.
 */

Body of Frist Method:
{
    TimeZone best = null;
    Resources r = Resources.getSystem();
    XmlResourceParser parser = r.getXml(com.android.internal.R.xml.time_zones_by_country);
    Date d = new Date(when);
    TimeZone current = TimeZone.getDefault();
    String currentName = current.getID();
    int currentOffset = current.getOffset(when);
    boolean currentDst = current.inDaylightTime(d);
    for (TimeZone tz : getTimeZones(country)) {
        if (tz.getID().equals(currentName)) {
            if (currentOffset == offset && currentDst == dst) {
                return current;
            }
        }
        if (best == null) {
            if (tz.getOffset(when) == offset && tz.inDaylightTime(d) == dst) {
                best = tz;
            }
        }
    }
    return best;
}
Body of Second Method:
{
    TimeZone best = null;
    final Date d = new Date(when);
    TimeZone current = TimeZone.getDefault();
    String currentName = current.getID();
    int currentOffset = current.getOffset(when);
    boolean currentDst = current.inDaylightTime(d);
    for (TimeZone tz : getTimeZones(country)) {
        if (tz.getID().equals(currentName)) {
            if (currentOffset == offset && currentDst == dst) {
                return current;
            }
        }
        if (best == null) {
            if (tz.getOffset(when) == offset && tz.inDaylightTime(d) == dst) {
                best = tz;
            }
        }
    }
    return best;
}
------------------------
Find a silently evolved API code:android.util.ArrayMap.containsKey:COMMENT
Method Modifier: public      
Comment:/**
 * Check whether a key exists in the array.
 *
 * @param key The key to search for.
 * @return Returns true if the key exists, else false.
 */

Body of Frist Method:
{
    return key == null ? (indexOfNull() >= 0) : (indexOf(key, key.hashCode()) >= 0);
}
Body of Second Method:
{
    return indexOfKey(key) >= 0;
}
------------------------
Find a silently evolved API code:android.printservice.PrintJob.hasAdvancedOption:COMMENT
Method Modifier: public      
Comment:/**
 * Gets whether this job has a given advanced (printer specific) print
 * option.
 *
 * @param key The option key.
 * @return Whether the option is present.
 */

Body of Frist Method:
{
    PrintService.throwIfNotCalledOnMainThread();
    return false;
}
Body of Second Method:
{
    PrintService.throwIfNotCalledOnMainThread();
    return getInfo().hasAdvancedOption(key);
}
------------------------
Find a silently evolved API code:android.view.textservice.TextServicesManager.newSpellCheckerSession:COMMENT
Method Modifier: public      
Comment:/**
 * Get a spell checker session for the specified spell checker
 * @param locale the locale for the spell checker. If {@code locale} is null and
 * referToSpellCheckerLanguageSettings is true, the locale specified in Settings will be
 * returned. If {@code locale} is not null and referToSpellCheckerLanguageSettings is true,
 * the locale specified in Settings will be returned only when it is same as {@code locale}.
 * Exceptionally, when referToSpellCheckerLanguageSettings is true and {@code locale} is
 * only language (e.g. "en"), the specified locale in Settings (e.g. "en_US") will be
 * selected.
 * @param listener a spell checker session lister for getting results from a spell checker.
 * @param referToSpellCheckerLanguageSettings if true, the session for one of enabled
 * languages in settings will be returned.
 * @return the spell checker session of the spell checker
 */

Body of Frist Method:
{
    if (listener == null) {
        throw new NullPointerException();
    }
    if (!referToSpellCheckerLanguageSettings && locale == null) {
        throw new IllegalArgumentException("Locale should not be null if you don't refer" + " settings.");
    }
    if (referToSpellCheckerLanguageSettings && !isSpellCheckerEnabled()) {
        return null;
    }
    final SpellCheckerInfo sci;
    try {
        sci = sService.getCurrentSpellChecker(null);
    } catch (RemoteException e) {
        return null;
    }
    if (sci == null) {
        return null;
    }
    SpellCheckerSubtype subtypeInUse = null;
    if (referToSpellCheckerLanguageSettings) {
        subtypeInUse = getCurrentSpellCheckerSubtype(true);
        if (subtypeInUse == null) {
            return null;
        }
        if (locale != null) {
            final String subtypeLocale = subtypeInUse.getLocale();
            final String inputLocale = locale.toString();
            if (subtypeLocale.length() < 2 || inputLocale.length() < 2 || !subtypeLocale.substring(0, 2).equals(inputLocale.substring(0, 2))) {
                return null;
            }
        }
    } else {
        final String localeStr = locale.toString();
        for (int i = 0; i < sci.getSubtypeCount(); ++i) {
            final SpellCheckerSubtype subtype = sci.getSubtypeAt(i);
            final String tempSubtypeLocale = subtype.getLocale();
            if (tempSubtypeLocale.equals(localeStr)) {
                subtypeInUse = subtype;
                break;
            } else if (localeStr.length() >= 2 && tempSubtypeLocale.length() >= 2 && localeStr.startsWith(tempSubtypeLocale)) {
                subtypeInUse = subtype;
            }
        }
    }
    if (subtypeInUse == null) {
        return null;
    }
    final SpellCheckerSession session = new SpellCheckerSession(sci, sService, listener, subtypeInUse);
    try {
        sService.getSpellCheckerService(sci.getId(), subtypeInUse.getLocale(), session.getTextServicesSessionListener(), session.getSpellCheckerSessionListener(), bundle);
    } catch (RemoteException e) {
        return null;
    }
    return session;
}
Body of Second Method:
{
    if (listener == null) {
        throw new NullPointerException();
    }
    if (!referToSpellCheckerLanguageSettings && locale == null) {
        throw new IllegalArgumentException("Locale should not be null if you don't refer" + " settings.");
    }
    if (referToSpellCheckerLanguageSettings && !isSpellCheckerEnabled()) {
        return null;
    }
    final SpellCheckerInfo sci;
    try {
        sci = sService.getCurrentSpellChecker(null);
    } catch (RemoteException e) {
        return null;
    }
    if (sci == null) {
        return null;
    }
    SpellCheckerSubtype subtypeInUse = null;
    if (referToSpellCheckerLanguageSettings) {
        subtypeInUse = getCurrentSpellCheckerSubtype(true);
        if (subtypeInUse == null) {
            return null;
        }
        if (locale != null) {
            final String subtypeLocale = subtypeInUse.getLocale();
            final String subtypeLanguage = parseLanguageFromLocaleString(subtypeLocale);
            if (subtypeLanguage.length() < 2 || !locale.getLanguage().equals(subtypeLanguage)) {
                return null;
            }
        }
    } else {
        final String localeStr = locale.toString();
        for (int i = 0; i < sci.getSubtypeCount(); ++i) {
            final SpellCheckerSubtype subtype = sci.getSubtypeAt(i);
            final String tempSubtypeLocale = subtype.getLocale();
            final String tempSubtypeLanguage = parseLanguageFromLocaleString(tempSubtypeLocale);
            if (tempSubtypeLocale.equals(localeStr)) {
                subtypeInUse = subtype;
                break;
            } else if (tempSubtypeLanguage.length() >= 2 && locale.getLanguage().equals(tempSubtypeLanguage)) {
                subtypeInUse = subtype;
            }
        }
    }
    if (subtypeInUse == null) {
        return null;
    }
    final SpellCheckerSession session = new SpellCheckerSession(sci, sService, listener, subtypeInUse);
    try {
        sService.getSpellCheckerService(sci.getId(), subtypeInUse.getLocale(), session.getTextServicesSessionListener(), session.getSpellCheckerSessionListener(), bundle);
    } catch (RemoteException e) {
        return null;
    }
    return session;
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiConfiguration.writeToParcel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Implement the Parcelable interface {@hide}
 */

Body of Frist Method:
{
    dest.writeInt(networkId);
    dest.writeInt(status);
    dest.writeInt(disableReason);
    dest.writeString(SSID);
    dest.writeString(BSSID);
    dest.writeString(preSharedKey);
    for (String wepKey : wepKeys) {
        dest.writeString(wepKey);
    }
    dest.writeInt(wepTxKeyIndex);
    dest.writeInt(priority);
    dest.writeInt(hiddenSSID ? 1 : 0);
    writeBitSet(dest, allowedKeyManagement);
    writeBitSet(dest, allowedProtocols);
    writeBitSet(dest, allowedAuthAlgorithms);
    writeBitSet(dest, allowedPairwiseCiphers);
    writeBitSet(dest, allowedGroupCiphers);
    dest.writeParcelable(enterpriseConfig, flags);
    dest.writeString(ipAssignment.name());
    dest.writeString(proxySettings.name());
    dest.writeParcelable(linkProperties, flags);
}
Body of Second Method:
{
    dest.writeInt(networkId);
    dest.writeInt(status);
    dest.writeInt(disableReason);
    dest.writeString(SSID);
    dest.writeString(BSSID);
    dest.writeString(autoJoinBSSID);
    dest.writeString(FQDN);
    dest.writeString(naiRealm);
    dest.writeString(preSharedKey);
    for (String wepKey : wepKeys) {
        dest.writeString(wepKey);
    }
    dest.writeInt(wepTxKeyIndex);
    dest.writeInt(priority);
    dest.writeInt(hiddenSSID ? 1 : 0);
    dest.writeInt(requirePMF ? 1 : 0);
    dest.writeString(updateIdentifier);
    writeBitSet(dest, allowedKeyManagement);
    writeBitSet(dest, allowedProtocols);
    writeBitSet(dest, allowedAuthAlgorithms);
    writeBitSet(dest, allowedPairwiseCiphers);
    writeBitSet(dest, allowedGroupCiphers);
    dest.writeParcelable(enterpriseConfig, flags);
    dest.writeParcelable(mIpConfiguration, flags);
    dest.writeString(dhcpServer);
    dest.writeString(defaultGwMacAddress);
    dest.writeInt(autoJoinStatus);
    dest.writeInt(selfAdded ? 1 : 0);
    dest.writeInt(didSelfAdd ? 1 : 0);
    dest.writeInt(noInternetAccess ? 1 : 0);
    dest.writeInt(creatorUid);
    dest.writeInt(lastConnectUid);
    dest.writeInt(lastUpdateUid);
    dest.writeLong(blackListTimestamp);
    dest.writeLong(lastConnectionFailure);
    dest.writeInt(numConnectionFailures);
    dest.writeInt(numIpConfigFailures);
    dest.writeInt(numAuthFailures);
    dest.writeInt(numScorerOverride);
    dest.writeInt(numScorerOverrideAndSwitchedNetwork);
    dest.writeInt(numAssociation);
    dest.writeInt(numUserTriggeredWifiDisableLowRSSI);
    dest.writeInt(numUserTriggeredWifiDisableBadRSSI);
    dest.writeInt(numUserTriggeredWifiDisableNotHighRSSI);
    dest.writeInt(numTicksAtLowRSSI);
    dest.writeInt(numTicksAtBadRSSI);
    dest.writeInt(numTicksAtNotHighRSSI);
    dest.writeInt(numUserTriggeredJoinAttempts);
    dest.writeInt(autoJoinUseAggressiveJoinAttemptThreshold);
    dest.writeInt(autoJoinBailedDueToLowRssi ? 1 : 0);
}
------------------------
Find a silently evolved API code:android.widget.AutoCompleteTextView.setDropDownBackgroundResource:COMMENT
Method Modifier: public      
Comment:/**
 * <p>Sets the background of the auto-complete drop-down list.</p>
 *
 * @param id the id of the drawable to set as the background
 *
 * @attr ref android.R.styleable#PopupWindow_popupBackground
 */

Body of Frist Method:
{
    mPopup.setBackgroundDrawable(getResources().getDrawable(id));
}
Body of Second Method:
{
    mPopup.setBackgroundDrawable(getContext().getDrawable(id));
}
------------------------
Find a silently evolved API code:android.view.accessibility.AccessibilityNodeInfo.getLabelFor:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the node info for which the view represented by this info serves as
 * a label for accessibility purposes.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 *
 * @return The labeled info.
 */

Body of Frist Method:
{
    enforceSealed();
    if (!canPerformRequestOverConnection(mLabelForId)) {
        return null;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mWindowId, mLabelForId, false, FLAG_PREFETCH_DESCENDANTS | FLAG_PREFETCH_SIBLINGS);
}
Body of Second Method:
{
    enforceSealed();
    if (!canPerformRequestOverConnection(mLabelForId)) {
        return null;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mWindowId, mLabelForId, false, FLAG_PREFETCH_PREDECESSORS | FLAG_PREFETCH_DESCENDANTS | FLAG_PREFETCH_SIBLINGS);
}
------------------------
Find a silently evolved API code:android.view.MotionEvent.PointerCoords.getAxisValue:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the value associated with the specified axis.
 *
 * @param axis The axis identifier for the axis value to retrieve.
 * @return The value associated with the axis, or 0 if none.
 *
 * @see MotionEvent#AXIS_X
 * @see MotionEvent#AXIS_Y
 */

Body of Frist Method:
{
    switch(axis) {
        case AXIS_X:
            return x;
        case AXIS_Y:
            return y;
        case AXIS_PRESSURE:
            return pressure;
        case AXIS_SIZE:
            return size;
        case AXIS_TOUCH_MAJOR:
            return touchMajor;
        case AXIS_TOUCH_MINOR:
            return touchMinor;
        case AXIS_TOOL_MAJOR:
            return toolMajor;
        case AXIS_TOOL_MINOR:
            return toolMinor;
        case AXIS_ORIENTATION:
            return orientation;
        default:
            {
                if (axis < 0 || axis > 63) {
                    throw new IllegalArgumentException("Axis out of range.");
                }
                final long bits = mPackedAxisBits;
                final long axisBit = 1L << axis;
                if ((bits & axisBit) == 0) {
                    return 0;
                }
                final int index = Long.bitCount(bits & (axisBit - 1L));
                return mPackedAxisValues[index];
            }
    }
}
Body of Second Method:
{
    switch(axis) {
        case AXIS_X:
            return x;
        case AXIS_Y:
            return y;
        case AXIS_PRESSURE:
            return pressure;
        case AXIS_SIZE:
            return size;
        case AXIS_TOUCH_MAJOR:
            return touchMajor;
        case AXIS_TOUCH_MINOR:
            return touchMinor;
        case AXIS_TOOL_MAJOR:
            return toolMajor;
        case AXIS_TOOL_MINOR:
            return toolMinor;
        case AXIS_ORIENTATION:
            return orientation;
        default:
            {
                if (axis < 0 || axis > 63) {
                    throw new IllegalArgumentException("Axis out of range.");
                }
                final long bits = mPackedAxisBits;
                final long axisBit = 0x8000000000000000L >>> axis;
                if ((bits & axisBit) == 0) {
                    return 0;
                }
                final int index = Long.bitCount(bits & ~(0xFFFFFFFFFFFFFFFFL >>> axis));
                return mPackedAxisValues[index];
            }
    }
}
------------------------
Find a silently evolved API code:android.ddm.DdmHandleProfiling.handleChunk:COMMENT
Method Modifier: public      
Comment:/**
 * Handle a chunk of data.
 */

Body of Frist Method:
{
    if (false)
        Log.v("ddm-heap", "Handling " + name(request.type) + " chunk");
    int type = request.type;
    if (type == CHUNK_MPRS) {
        return handleMPRS(request);
    } else if (type == CHUNK_MPRE) {
        return handleMPRE(request);
    } else if (type == CHUNK_MPSS) {
        return handleMPSS(request);
    } else if (type == CHUNK_MPSE) {
        return handleMPSE(request);
    } else if (type == CHUNK_MPRQ) {
        return handleMPRQ(request);
    } else if (type == CHUNK_SPSS) {
        return handleSPSS(request);
    } else if (type == CHUNK_SPSE) {
        return handleSPSE(request);
    } else {
        throw new RuntimeException("Unknown packet " + ChunkHandler.name(type));
    }
}
Body of Second Method:
{
    if (DEBUG)
        Log.v("ddm-heap", "Handling " + name(request.type) + " chunk");
    int type = request.type;
    if (type == CHUNK_MPRS) {
        return handleMPRS(request);
    } else if (type == CHUNK_MPRE) {
        return handleMPRE(request);
    } else if (type == CHUNK_MPSS) {
        return handleMPSS(request);
    } else if (type == CHUNK_MPSE) {
        return handleMPSEOrSPSE(request, "Method");
    } else if (type == CHUNK_MPRQ) {
        return handleMPRQ(request);
    } else if (type == CHUNK_SPSS) {
        return handleSPSS(request);
    } else if (type == CHUNK_SPSE) {
        return handleMPSEOrSPSE(request, "Sample");
    } else {
        throw new RuntimeException("Unknown packet " + ChunkHandler.name(type));
    }
}
------------------------
Find a silently evolved API code:android.graphics.Canvas.setBitmap:COMMENT
Method Modifier: public      
Comment:/**
 * Specify a bitmap for the canvas to draw into. All canvas state such as
 * layers, filters, and the save/restore stack are reset with the exception
 * of the current matrix and clip stack. Additionally, as a side-effect
 * the canvas' target density is updated to match that of the bitmap.
 *
 * @param bitmap Specifies a mutable bitmap for the canvas to draw into.
 * @see #setDensity(int)
 * @see #getDensity()
 */

Body of Frist Method:
{
    if (isHardwareAccelerated()) {
        throw new RuntimeException("Can't set a bitmap device on a GL canvas");
    }
    if (bitmap == null) {
        safeCanvasSwap(initRaster(0), false);
        mDensity = Bitmap.DENSITY_NONE;
    } else {
        if (!bitmap.isMutable()) {
            throw new IllegalStateException();
        }
        throwIfCannotDraw(bitmap);
        safeCanvasSwap(initRaster(bitmap.ni()), true);
        mDensity = bitmap.mDensity;
    }
    mBitmap = bitmap;
}
Body of Second Method:
{
    if (isHardwareAccelerated()) {
        throw new RuntimeException("Can't set a bitmap device on a HW accelerated canvas");
    }
    if (bitmap == null) {
        native_setBitmap(mNativeCanvasWrapper, 0, false);
        mDensity = Bitmap.DENSITY_NONE;
    } else {
        if (!bitmap.isMutable()) {
            throw new IllegalStateException();
        }
        throwIfCannotDraw(bitmap);
        native_setBitmap(mNativeCanvasWrapper, bitmap.ni(), true);
        mDensity = bitmap.mDensity;
    }
    mBitmap = bitmap;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothSocket.connect:COMMENT
Method Modifier: public      
Comment:/**
 * Attempt to connect to a remote device.
 * <p>This method will block until a connection is made or the connection
 * fails. If this method returns without an exception then this socket
 * is now connected.
 * <p>Creating new connections to
 * remote Bluetooth devices should not be attempted while device discovery
 * is in progress. Device discovery is a heavyweight procedure on the
 * Bluetooth adapter and will significantly slow a device connection.
 * Use {@link BluetoothAdapter#cancelDiscovery()} to cancel an ongoing
 * discovery. Discovery is not managed by the Activity,
 * but is run as a system service, so an application should always call
 * {@link BluetoothAdapter#cancelDiscovery()} even if it
 * did not directly request a discovery, just to be sure.
 * <p>{@link #close} can be used to abort this call from another thread.
 * @throws IOException on error, for example connection failure
 */

Body of Frist Method:
{
    if (mDevice == null)
        throw new IOException("Connect is called on null device");
    try {
        if (mSocketState == SocketState.CLOSED)
            throw new IOException("socket closed");
        IBluetooth bluetoothProxy = BluetoothAdapter.getDefaultAdapter().getBluetoothService(null);
        if (bluetoothProxy == null)
            throw new IOException("Bluetooth is off");
        mPfd = bluetoothProxy.connectSocket(mDevice, mType, mUuid, mPort, getSecurityFlags());
        synchronized (this) {
            if (DBG)
                Log.d(TAG, "connect(), SocketState: " + mSocketState + ", mPfd: " + mPfd);
            if (mSocketState == SocketState.CLOSED)
                throw new IOException("socket closed");
            if (mPfd == null)
                throw new IOException("bt socket connect failed");
            FileDescriptor fd = mPfd.getFileDescriptor();
            mSocket = new LocalSocket(fd);
            mSocketIS = mSocket.getInputStream();
            mSocketOS = mSocket.getOutputStream();
        }
        int channel = readInt(mSocketIS);
        if (channel <= 0)
            throw new IOException("bt socket connect failed");
        mPort = channel;
        waitSocketSignal(mSocketIS);
        synchronized (this) {
            if (mSocketState == SocketState.CLOSED)
                throw new IOException("bt socket closed");
            mSocketState = SocketState.CONNECTED;
        }
    } catch (RemoteException e) {
        Log.e(TAG, Log.getStackTraceString(new Throwable()));
    }
}
Body of Second Method:
{
    if (mDevice == null)
        throw new IOException("Connect is called on null device");
    try {
        if (mSocketState == SocketState.CLOSED)
            throw new IOException("socket closed");
        IBluetooth bluetoothProxy = BluetoothAdapter.getDefaultAdapter().getBluetoothService(null);
        if (bluetoothProxy == null)
            throw new IOException("Bluetooth is off");
        mPfd = bluetoothProxy.connectSocket(mDevice, mType, mUuid, mPort, getSecurityFlags());
        synchronized (this) {
            if (DBG)
                Log.d(TAG, "connect(), SocketState: " + mSocketState + ", mPfd: " + mPfd);
            if (mSocketState == SocketState.CLOSED)
                throw new IOException("socket closed");
            if (mPfd == null)
                throw new IOException("bt socket connect failed");
            FileDescriptor fd = mPfd.getFileDescriptor();
            mSocket = new LocalSocket(fd);
            mSocketIS = mSocket.getInputStream();
            mSocketOS = mSocket.getOutputStream();
        }
        int channel = readInt(mSocketIS);
        if (channel <= 0)
            throw new IOException("bt socket connect failed");
        mPort = channel;
        waitSocketSignal(mSocketIS);
        synchronized (this) {
            if (mSocketState == SocketState.CLOSED)
                throw new IOException("bt socket closed");
            mSocketState = SocketState.CONNECTED;
        }
    } catch (RemoteException e) {
        Log.e(TAG, Log.getStackTraceString(new Throwable()));
        throw new IOException("unable to send RPC: " + e.getMessage());
    }
}
------------------------
Find a silently evolved API code:android.graphics.Paint.setClassVariablesFrom:COMMENT
Method Modifier: private     
Comment:/**
 * Set all class variables using current values from the given
 * {@link Paint}.
 */

Body of Frist Method:
{
    mColorFilter = paint.mColorFilter;
    mMaskFilter = paint.mMaskFilter;
    mPathEffect = paint.mPathEffect;
    mRasterizer = paint.mRasterizer;
    if (paint.mShader != null) {
        mShader = paint.mShader.copy();
    } else {
        mShader = null;
    }
    mTypeface = paint.mTypeface;
    mXfermode = paint.mXfermode;
    mHasCompatScaling = paint.mHasCompatScaling;
    mCompatScaling = paint.mCompatScaling;
    mInvCompatScaling = paint.mInvCompatScaling;
    hasShadow = paint.hasShadow;
    shadowDx = paint.shadowDx;
    shadowDy = paint.shadowDy;
    shadowRadius = paint.shadowRadius;
    shadowColor = paint.shadowColor;
    mBidiFlags = paint.mBidiFlags;
    mLocale = paint.mLocale;
}
Body of Second Method:
{
    mColorFilter = paint.mColorFilter;
    mMaskFilter = paint.mMaskFilter;
    mPathEffect = paint.mPathEffect;
    mRasterizer = paint.mRasterizer;
    if (paint.mShader != null) {
        mShader = paint.mShader.copy();
    } else {
        mShader = null;
    }
    mTypeface = paint.mTypeface;
    mNativeTypeface = paint.mNativeTypeface;
    mXfermode = paint.mXfermode;
    mHasCompatScaling = paint.mHasCompatScaling;
    mCompatScaling = paint.mCompatScaling;
    mInvCompatScaling = paint.mInvCompatScaling;
    mBidiFlags = paint.mBidiFlags;
    mLocale = paint.mLocale;
    mFontFeatureSettings = paint.mFontFeatureSettings;
}
------------------------
Find a silently evolved API code:android.widget.EdgeEffect.setSize:COMMENT
Method Modifier: public      
Comment:/**
 * Set the size of this edge effect in pixels.
 *
 * @param width Effect width in pixels
 * @param height Effect height in pixels
 */

Body of Frist Method:
{
    mWidth = width;
    mHeight = height;
}
Body of Second Method:
{
    final float r = width * 0.75f / SIN;
    final float y = COS * r;
    final float h = r - y;
    final float or = height * 0.75f / SIN;
    final float oy = COS * or;
    final float oh = or - oy;
    mRadius = r;
    mBaseGlowScale = h > 0 ? Math.min(oh / h, 1.f) : 1.f;
    mBounds.set(mBounds.left, mBounds.top, width, (int) Math.min(height, h));
}
------------------------
Find a silently evolved API code:android.media.MediaRecorder.prepare:COMMENT
Method Modifier: public      
Comment:/**
 * Prepares the recorder to begin capturing and encoding data. This method
 * must be called after setting up the desired audio and video sources,
 * encoders, file format, etc., but before start().
 *
 * @throws IllegalStateException if it is called after
 * start() or before setOutputFormat().
 * @throws IOException if prepare fails otherwise.
 */

Body of Frist Method:
{
    if (mPath != null) {
        FileOutputStream fos = new FileOutputStream(mPath);
        try {
            _setOutputFile(fos.getFD(), 0, 0);
        } finally {
            fos.close();
        }
    } else if (mFd != null) {
        _setOutputFile(mFd, 0, 0);
    } else {
        throw new IOException("No valid output file");
    }
    _prepare();
}
Body of Second Method:
{
    if (mPath != null) {
        RandomAccessFile file = new RandomAccessFile(mPath, "rws");
        try {
            _setOutputFile(file.getFD(), 0, 0);
        } finally {
            file.close();
        }
    } else if (mFd != null) {
        _setOutputFile(mFd, 0, 0);
    } else {
        throw new IOException("No valid output file");
    }
    _prepare();
}
------------------------
Find a silently evolved API code:android.app.admin.DevicePolicyManager.getActiveAdmins:COMMENT
Method Modifier: public      
Comment:/**
 * Return a list of all currently active device administrator's component
 * names.  Note that if there are no administrators than null may be
 * returned.
 */

Body of Frist Method:
{
    if (mService != null) {
        try {
            return mService.getActiveAdmins(UserHandle.myUserId());
        } catch (RemoteException e) {
            Log.w(TAG, "Failed talking with device policy service", e);
        }
    }
    return null;
}
Body of Second Method:
{
    return getActiveAdminsAsUser(UserHandle.myUserId());
}
------------------------
Find a silently evolved API code:android.widget.TimePicker.setOnTimeChangedListener:COMMENT
Method Modifier: public      
Comment:/**
 * Set the callback that indicates the time has been adjusted by the user.
 *
 * @param onTimeChangedListener the callback, should not be null.
 */

Body of Frist Method:
{
    mOnTimeChangedListener = onTimeChangedListener;
}
Body of Second Method:
{
    mDelegate.setOnTimeChangedListener(onTimeChangedListener);
}
------------------------
Find a silently evolved API code:android.graphics.Bitmap.setHasAlpha:COMMENT
Method Modifier: public      
Comment:/**
 * Tell the bitmap if all of the pixels are known to be opaque (false)
 * or if some of the pixels may contain non-opaque alpha values (true).
 * Note, for some configs (e.g. RGB_565) this call is ignored, since it
 * does not support per-pixel alpha values.
 *
 * This is meant as a drawing hint, as in some cases a bitmap that is known
 * to be opaque can take a faster drawing case than one that may have
 * non-opaque per-pixel alpha values.
 */

Body of Frist Method:
{
    nativeSetHasAlpha(mNativeBitmap, hasAlpha);
}
Body of Second Method:
{
    nativeSetHasAlpha(mNativeBitmap, hasAlpha, mRequestPremultiplied);
}
------------------------
Find a silently evolved API code:android.app.Activity.startActivityAsUser:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide Implement to provide correct calling token.
 */

Body of Frist Method:
{
    if (mParent != null) {
        throw new RuntimeException("Called be called from a child");
    }
    Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity(this, mMainThread.getApplicationThread(), mToken, this, intent, -1, options, user);
    if (ar != null) {
        mMainThread.sendActivityResult(mToken, mEmbeddedID, -1, ar.getResultCode(), ar.getResultData());
    }
}
Body of Second Method:
{
    if (mParent != null) {
        throw new RuntimeException("Can't be called from a child");
    }
    Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity(this, mMainThread.getApplicationThread(), mToken, this, intent, -1, options, user);
    if (ar != null) {
        mMainThread.sendActivityResult(mToken, mEmbeddedID, -1, ar.getResultCode(), ar.getResultData());
    }
}
------------------------
Find a silently evolved API code:android.app.UiAutomation.takeScreenshot:COMMENT
Method Modifier: public      
Comment:/**
 * Takes a screenshot.
 *
 * @return The screenshot bitmap on success, null otherwise.
 */

Body of Frist Method:
{
    synchronized (mLock) {
        throwIfNotConnectedLocked();
    }
    Display display = DisplayManagerGlobal.getInstance().getRealDisplay(Display.DEFAULT_DISPLAY);
    Point displaySize = new Point();
    display.getRealSize(displaySize);
    final int displayWidth = displaySize.x;
    final int displayHeight = displaySize.y;
    final float screenshotWidth;
    final float screenshotHeight;
    final int rotation = display.getRotation();
    switch(rotation) {
        case ROTATION_FREEZE_0:
            {
                screenshotWidth = displayWidth;
                screenshotHeight = displayHeight;
            }
            break;
        case ROTATION_FREEZE_90:
            {
                screenshotWidth = displayHeight;
                screenshotHeight = displayWidth;
            }
            break;
        case ROTATION_FREEZE_180:
            {
                screenshotWidth = displayWidth;
                screenshotHeight = displayHeight;
            }
            break;
        case ROTATION_FREEZE_270:
            {
                screenshotWidth = displayHeight;
                screenshotHeight = displayWidth;
            }
            break;
        default:
            {
                throw new IllegalArgumentException("Invalid rotation: " + rotation);
            }
    }
    // Take the screenshot
    Bitmap screenShot = null;
    try {
        // Calling out without a lock held.
        screenShot = mUiAutomationConnection.takeScreenshot((int) screenshotWidth, (int) screenshotHeight);
        if (screenShot == null) {
            return null;
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, "Error while taking screnshot!", re);
        return null;
    }
    // Rotate the screenshot to the current orientation
    if (rotation != ROTATION_FREEZE_0) {
        Bitmap unrotatedScreenShot = Bitmap.createBitmap(displayWidth, displayHeight, Bitmap.Config.ARGB_8888);
        Canvas canvas = new Canvas(unrotatedScreenShot);
        canvas.translate(unrotatedScreenShot.getWidth() / 2, unrotatedScreenShot.getHeight() / 2);
        canvas.rotate(getDegreesForRotation(rotation));
        canvas.translate(-screenshotWidth / 2, -screenshotHeight / 2);
        canvas.drawBitmap(screenShot, 0, 0, null);
        canvas.setBitmap(null);
        screenShot = unrotatedScreenShot;
    }
    // Optimization
    screenShot.setHasAlpha(false);
    return screenShot;
}
Body of Second Method:
{
    synchronized (mLock) {
        throwIfNotConnectedLocked();
    }
    Display display = DisplayManagerGlobal.getInstance().getRealDisplay(Display.DEFAULT_DISPLAY);
    Point displaySize = new Point();
    display.getRealSize(displaySize);
    final int displayWidth = displaySize.x;
    final int displayHeight = displaySize.y;
    final float screenshotWidth;
    final float screenshotHeight;
    final int rotation = display.getRotation();
    switch(rotation) {
        case ROTATION_FREEZE_0:
            {
                screenshotWidth = displayWidth;
                screenshotHeight = displayHeight;
            }
            break;
        case ROTATION_FREEZE_90:
            {
                screenshotWidth = displayHeight;
                screenshotHeight = displayWidth;
            }
            break;
        case ROTATION_FREEZE_180:
            {
                screenshotWidth = displayWidth;
                screenshotHeight = displayHeight;
            }
            break;
        case ROTATION_FREEZE_270:
            {
                screenshotWidth = displayHeight;
                screenshotHeight = displayWidth;
            }
            break;
        default:
            {
                throw new IllegalArgumentException("Invalid rotation: " + rotation);
            }
    }
    // Take the screenshot
    Bitmap screenShot = null;
    try {
        // Calling out without a lock held.
        screenShot = mUiAutomationConnection.takeScreenshot((int) screenshotWidth, (int) screenshotHeight);
        if (screenShot == null) {
            return null;
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, "Error while taking screnshot!", re);
        return null;
    }
    // Rotate the screenshot to the current orientation
    if (rotation != ROTATION_FREEZE_0) {
        Bitmap unrotatedScreenShot = Bitmap.createBitmap(displayWidth, displayHeight, Bitmap.Config.ARGB_8888);
        Canvas canvas = new Canvas(unrotatedScreenShot);
        canvas.translate(unrotatedScreenShot.getWidth() / 2, unrotatedScreenShot.getHeight() / 2);
        canvas.rotate(getDegreesForRotation(rotation));
        canvas.translate(-screenshotWidth / 2, -screenshotHeight / 2);
        canvas.drawBitmap(screenShot, 0, 0, null);
        canvas.setBitmap(null);
        screenShot.recycle();
        screenShot = unrotatedScreenShot;
    }
    // Optimization
    screenShot.setHasAlpha(false);
    return screenShot;
}
------------------------
Find a silently evolved API code:android.graphics.drawable.DrawableContainer.DrawableContainerState.ConstantStateFuture.get:COMMENT
Method Modifier: public      
Comment:/**
 * Obtains and prepares the Drawable represented by this future.
 *
 * @param state the container into which this future will be placed
 * @return a prepared Drawable
 */

Body of Frist Method:
{
    final Drawable result = (state.mRes == null) ? mConstantState.newDrawable() : mConstantState.newDrawable(state.mRes);
    result.setLayoutDirection(state.mLayoutDirection);
    result.setCallback(state.mOwner);
    if (state.mMutated) {
        result.mutate();
    }
    return result;
}
Body of Second Method:
{
    final Drawable result;
    if (state.mRes == null) {
        result = mConstantState.newDrawable();
    } else if (state.mTheme == null) {
        result = mConstantState.newDrawable(state.mRes);
    } else {
        result = mConstantState.newDrawable(state.mRes, state.mTheme);
    }
    result.setLayoutDirection(state.mLayoutDirection);
    result.setCallback(state.mOwner);
    if (state.mMutated) {
        result.mutate();
    }
    return result;
}
------------------------
Find a silently evolved API code:android.telephony.PhoneNumberUtils.isPotentialEmergencyNumber:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Checks if a given number might *potentially* result in a call to an
 * emergency service, for a specific country.
 *
 * Specifically, this method will return true if the specified number
 * is an emergency number in the specified country, *or* if the number
 * simply starts with the same digits as any emergency number for that
 * country.
 *
 * This method is intended for internal use by the phone app when
 * deciding whether to allow ACTION_CALL intents from 3rd party apps
 * (where we're required to *not* allow emergency calls to be placed.)
 *
 * @param number the number to look up.
 * @param defaultCountryIso the specific country which the number should be checked against
 * @return true if the number is an emergency number for the specific
 * country, *or* if the number starts with the same digits as
 * any of those emergency numbers.
 *
 * @hide
 */

Body of Frist Method:
{
    return isEmergencyNumberInternal(number, defaultCountryIso, false);
}
Body of Second Method:
{
    return isPotentialEmergencyNumber(getDefaultVoiceSubId(), number, defaultCountryIso);
}
------------------------
Find a silently evolved API code:android.media.AudioManager.registerMediaButtonIntent:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 * no-op if (pi == null) or (eventReceiver == null)
 */

Body of Frist Method:
{
    if (pi == null) {
        Log.e(TAG, "Cannot call registerMediaButtonIntent() with a null parameter");
        return;
    }
    IAudioService service = getService();
    try {
        // pi != null
        service.registerMediaButtonIntent(pi, eventReceiver, eventReceiver == null ? mToken : null);
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in registerMediaButtonIntent" + e);
    }
}
Body of Second Method:
{
    if (pi == null) {
        Log.e(TAG, "Cannot call registerMediaButtonIntent() with a null parameter");
        return;
    }
    MediaSessionLegacyHelper helper = MediaSessionLegacyHelper.getHelper(mContext);
    helper.addMediaButtonListener(pi, eventReceiver, mContext);
}
------------------------
Find a silently evolved API code:android.net.wifi.ScanResult.writeToParcel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Implement the Parcelable interface {@hide}
 */

Body of Frist Method:
{
    if (wifiSsid != null) {
        dest.writeInt(1);
        wifiSsid.writeToParcel(dest, flags);
    } else {
        dest.writeInt(0);
    }
    dest.writeString(BSSID);
    dest.writeString(capabilities);
    dest.writeInt(level);
    dest.writeInt(frequency);
    dest.writeLong(timestamp);
    dest.writeInt(distanceCm);
    dest.writeInt(distanceSdCm);
}
Body of Second Method:
{
    if (wifiSsid != null) {
        dest.writeInt(1);
        wifiSsid.writeToParcel(dest, flags);
    } else {
        dest.writeInt(0);
    }
    dest.writeString(BSSID);
    dest.writeString(capabilities);
    dest.writeInt(level);
    dest.writeInt(frequency);
    dest.writeLong(timestamp);
    dest.writeInt(distanceCm);
    dest.writeInt(distanceSdCm);
    dest.writeLong(seen);
    dest.writeInt(autoJoinStatus);
    dest.writeInt(untrusted ? 1 : 0);
    dest.writeInt(numConnection);
    dest.writeInt(numUsage);
    dest.writeInt(numIpConfigFailures);
    dest.writeInt(isAutoJoinCandidate);
    if (informationElements != null) {
        dest.writeInt(informationElements.length);
        for (int i = 0; i < informationElements.length; i++) {
            dest.writeInt(informationElements[i].id);
            dest.writeInt(informationElements[i].bytes.length);
            dest.writeByteArray(informationElements[i].bytes);
        }
    } else {
        dest.writeInt(0);
    }
}
------------------------
Find a silently evolved API code:android.transition.TransitionSet.pause:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    super.pause();
    int numTransitions = mTransitions.size();
    for (int i = 0; i < numTransitions; ++i) {
        mTransitions.get(i).pause();
    }
}
Body of Second Method:
{
    super.pause(sceneRoot);
    int numTransitions = mTransitions.size();
    for (int i = 0; i < numTransitions; ++i) {
        mTransitions.get(i).pause(sceneRoot);
    }
}
------------------------
Find a silently evolved API code:android.media.Ringtone.isPlaying:COMMENT
Method Modifier: public      
Comment:/**
 * Whether this ringtone is currently playing.
 *
 * @return True if playing, false otherwise.
 */

Body of Frist Method:
{
    if (mLocalPlayer != null) {
        return mLocalPlayer.isPlaying();
    } else if (mAllowRemote) {
        try {
            return mRemotePlayer.isPlaying(mRemoteToken);
        } catch (RemoteException e) {
            Log.w(TAG, "Problem checking ringtone: " + e);
            return false;
        }
    } else {
        Log.w(TAG, "Neither local nor remote playback available");
        return false;
    }
}
Body of Second Method:
{
    if (mLocalPlayer != null) {
        return mLocalPlayer.isPlaying();
    } else if (mAllowRemote && (mRemotePlayer != null)) {
        try {
            return mRemotePlayer.isPlaying(mRemoteToken);
        } catch (RemoteException e) {
            Log.w(TAG, "Problem checking ringtone: " + e);
            return false;
        }
    } else {
        Log.w(TAG, "Neither local nor remote playback available");
        return false;
    }
}
------------------------
Find a silently evolved API code:android.widget.AbsListView.obtainView:COMMENT
Method Modifier: default     
Comment:/**
 * Get a view and have it show the data associated with the specified
 * position. This is called when we have already discovered that the view is
 * not available for reuse in the recycle bin. The only choices left are
 * converting an old view or making a new one.
 *
 * @param position The position to display
 * @param isScrap Array of at least 1 boolean, the first entry will become true if
 * the returned view was taken from the scrap heap, false if otherwise.
 *
 * @return A view displaying the data associated with the specified position
 */

Body of Frist Method:
{
    Trace.traceBegin(Trace.TRACE_TAG_VIEW, "obtainView");
    isScrap[0] = false;
    View scrapView;
    scrapView = mRecycler.getTransientStateView(position);
    if (scrapView == null) {
        scrapView = mRecycler.getScrapView(position);
    }
    View child;
    if (scrapView != null) {
        child = mAdapter.getView(position, scrapView, this);
        if (child.getImportantForAccessibility() == IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
            child.setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_YES);
        }
        if (child != scrapView) {
            mRecycler.addScrapView(scrapView, position);
            if (mCacheColorHint != 0) {
                child.setDrawingCacheBackgroundColor(mCacheColorHint);
            }
        } else {
            isScrap[0] = true;
            // recycle this view and bind it to different data.
            if (child.isAccessibilityFocused()) {
                child.clearAccessibilityFocus();
            }
            child.dispatchFinishTemporaryDetach();
        }
    } else {
        child = mAdapter.getView(position, null, this);
        if (child.getImportantForAccessibility() == IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
            child.setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_YES);
        }
        if (mCacheColorHint != 0) {
            child.setDrawingCacheBackgroundColor(mCacheColorHint);
        }
    }
    if (mAdapterHasStableIds) {
        final ViewGroup.LayoutParams vlp = child.getLayoutParams();
        LayoutParams lp;
        if (vlp == null) {
            lp = (LayoutParams) generateDefaultLayoutParams();
        } else if (!checkLayoutParams(vlp)) {
            lp = (LayoutParams) generateLayoutParams(vlp);
        } else {
            lp = (LayoutParams) vlp;
        }
        lp.itemId = mAdapter.getItemId(position);
        child.setLayoutParams(lp);
    }
    if (AccessibilityManager.getInstance(mContext).isEnabled()) {
        if (mAccessibilityDelegate == null) {
            mAccessibilityDelegate = new ListItemAccessibilityDelegate();
        }
        if (child.getAccessibilityDelegate() == null) {
            child.setAccessibilityDelegate(mAccessibilityDelegate);
        }
    }
    Trace.traceEnd(Trace.TRACE_TAG_VIEW);
    return child;
}
Body of Second Method:
{
    Trace.traceBegin(Trace.TRACE_TAG_VIEW, "obtainView");
    isScrap[0] = false;
    // Check whether we have a transient state view. Attempt to re-bind the
    // data and discard the view if we fail.
    final View transientView = mRecycler.getTransientStateView(position);
    if (transientView != null) {
        final LayoutParams params = (LayoutParams) transientView.getLayoutParams();
        // If the view type hasn't changed, attempt to re-bind the data.
        if (params.viewType == mAdapter.getItemViewType(position)) {
            final View updatedView = mAdapter.getView(position, transientView, this);
            // If we failed to re-bind the data, scrap the obtained view.
            if (updatedView != transientView) {
                setItemViewLayoutParams(updatedView, position);
                mRecycler.addScrapView(updatedView, position);
            }
        }
        // Scrap view implies temporary detachment.
        isScrap[0] = true;
        return transientView;
    }
    final View scrapView = mRecycler.getScrapView(position);
    final View child = mAdapter.getView(position, scrapView, this);
    if (scrapView != null) {
        if (child != scrapView) {
            // Failed to re-bind the data, return scrap to the heap.
            mRecycler.addScrapView(scrapView, position);
        } else {
            isScrap[0] = true;
            child.dispatchFinishTemporaryDetach();
        }
    }
    if (mCacheColorHint != 0) {
        child.setDrawingCacheBackgroundColor(mCacheColorHint);
    }
    if (child.getImportantForAccessibility() == IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
        child.setImportantForAccessibility(IMPORTANT_FOR_ACCESSIBILITY_YES);
    }
    setItemViewLayoutParams(child, position);
    if (AccessibilityManager.getInstance(mContext).isEnabled()) {
        if (mAccessibilityDelegate == null) {
            mAccessibilityDelegate = new ListItemAccessibilityDelegate();
        }
        if (child.getAccessibilityDelegate() == null) {
            child.setAccessibilityDelegate(mAccessibilityDelegate);
        }
    }
    Trace.traceEnd(Trace.TRACE_TAG_VIEW);
    return child;
}
------------------------
Find a silently evolved API code:android.content.res.TypedArray.getText:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the styled string value for the attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return CharSequence holding string data.  May be styled.  Returns
 * null if the attribute is not defined.
 */

Body of Frist Method:
{
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return null;
    } else if (type == TypedValue.TYPE_STRING) {
        return loadStringValueAt(index);
    }
    TypedValue v = mValue;
    if (getValueAt(index, v)) {
        Log.w(Resources.TAG, "Converting to string: " + v);
        return v.coerceToString();
    }
    Log.w(Resources.TAG, "getString of bad type: 0x" + Integer.toHexString(type));
    return null;
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return null;
    } else if (type == TypedValue.TYPE_STRING) {
        return loadStringValueAt(index);
    }
    TypedValue v = mValue;
    if (getValueAt(index, v)) {
        Log.w(Resources.TAG, "Converting to string: " + v);
        return v.coerceToString();
    }
    Log.w(Resources.TAG, "getString of bad type: 0x" + Integer.toHexString(type));
    return null;
}
------------------------
Find a silently evolved API code:android.app.Dialog.show:COMMENT
Method Modifier: public      
Comment:/**
 * Start the dialog and display it on screen.  The window is placed in the
 * application layer and opaque.  Note that you should not override this
 * method to do initialization when the dialog is shown, instead implement
 * that in {@link #onStart}.
 */

Body of Frist Method:
{
    if (mShowing) {
        if (mDecor != null) {
            if (mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) {
                mWindow.invalidatePanelMenu(Window.FEATURE_ACTION_BAR);
            }
            mDecor.setVisibility(View.VISIBLE);
        }
        return;
    }
    mCanceled = false;
    if (!mCreated) {
        dispatchOnCreate(null);
    }
    onStart();
    mDecor = mWindow.getDecorView();
    if (mActionBar == null && mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) {
        final ApplicationInfo info = mContext.getApplicationInfo();
        mWindow.setDefaultIcon(info.icon);
        mWindow.setDefaultLogo(info.logo);
        mActionBar = new ActionBarImpl(this);
    }
    WindowManager.LayoutParams l = mWindow.getAttributes();
    if ((l.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) == 0) {
        WindowManager.LayoutParams nl = new WindowManager.LayoutParams();
        nl.copyFrom(l);
        nl.softInputMode |= WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
        l = nl;
    }
    try {
        mWindowManager.addView(mDecor, l);
        mShowing = true;
        sendShowMessage();
    } finally {
    }
}
Body of Second Method:
{
    if (mShowing) {
        if (mDecor != null) {
            if (mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) {
                mWindow.invalidatePanelMenu(Window.FEATURE_ACTION_BAR);
            }
            mDecor.setVisibility(View.VISIBLE);
        }
        return;
    }
    mCanceled = false;
    if (!mCreated) {
        dispatchOnCreate(null);
    }
    onStart();
    mDecor = mWindow.getDecorView();
    if (mActionBar == null && mWindow.hasFeature(Window.FEATURE_ACTION_BAR)) {
        final ApplicationInfo info = mContext.getApplicationInfo();
        mWindow.setDefaultIcon(info.icon);
        mWindow.setDefaultLogo(info.logo);
        mActionBar = new WindowDecorActionBar(this);
    }
    WindowManager.LayoutParams l = mWindow.getAttributes();
    if ((l.softInputMode & WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION) == 0) {
        WindowManager.LayoutParams nl = new WindowManager.LayoutParams();
        nl.copyFrom(l);
        nl.softInputMode |= WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION;
        l = nl;
    }
    try {
        mWindowManager.addView(mDecor, l);
        mShowing = true;
        sendShowMessage();
    } finally {
    }
}
------------------------
Find a silently evolved API code:android.service.dreams.DreamService.getWindowManager:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieves the current {@link android.view.WindowManager} for the dream.
 * Behaves similarly to {@link android.app.Activity#getWindowManager()}.
 *
 * @return The current window manager, or null if the dream is not started.
 */

Body of Frist Method:
{
    return mWindowManager;
}
Body of Second Method:
{
    return mWindow != null ? mWindow.getWindowManager() : null;
}
------------------------
Find a silently evolved API code:android.media.MediaDrm.provideProvisionResponse:COMMENT
<android.media.MediaDrm: void provideProvisionResponse(byte[])>
public      native      ->public      
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * After a provision response is received by the app, it is provided to the DRM
 * engine plugin using this method.
 *
 * @param response the opaque provisioning response byte array to provide to the
 * DRM engine plugin.
 *
 * @throws DeniedByServerException if the response indicates that the
 * server rejected the request
 */

Body of Frist Method:

Body of Second Method:
{
    provideProvisionResponseNative(response);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothSocket.write:COMMENT
Method Modifier: default     
Comment:/*package*/

Body of Frist Method:
{
    if (VDBG)
        Log.d(TAG, "write: " + mSocketOS + " length: " + length);
    mSocketOS.write(b, offset, length);
    // There is no good way to confirm since the entire process is asynchronous anyway
    if (VDBG)
        Log.d(TAG, "write out: " + mSocketOS + " length: " + length);
    return length;
}
Body of Second Method:
{
    if (mSocketOS == null)
        throw new IOException("write is called on null OutputStream");
    if (VDBG)
        Log.d(TAG, "write: " + mSocketOS + " length: " + length);
    mSocketOS.write(b, offset, length);
    // There is no good way to confirm since the entire process is asynchronous anyway
    if (VDBG)
        Log.d(TAG, "write out: " + mSocketOS + " length: " + length);
    return length;
}
------------------------
Find a silently evolved API code:android.view.ViewRootImpl.outputDisplayList:COMMENT
Method Modifier: default     hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (mAttachInfo != null && mAttachInfo.mHardwareCanvas != null) {
        DisplayList displayList = view.getDisplayList();
        if (displayList != null) {
            mAttachInfo.mHardwareCanvas.outputDisplayList(displayList);
        }
    }
}
Body of Second Method:
{
    RenderNode renderNode = view.getDisplayList();
    if (renderNode != null) {
        renderNode.output();
    }
}
------------------------
Find a silently evolved API code:android.app.ActivityOptions.makeCustomAnimation:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Create an ActivityOptions specifying a custom animation to run when
 * the activity is displayed.
 *
 * @param context Who is defining this.  This is the application that the
 * animation resources will be loaded from.
 * @param enterResId A resource ID of the animation resource to use for
 * the incoming activity.  Use 0 for no animation.
 * @param exitResId A resource ID of the animation resource to use for
 * the outgoing activity.  Use 0 for no animation.
 * @param handler If <var>listener</var> is non-null this must be a valid
 * Handler on which to dispatch the callback; otherwise it should be null.
 * @param listener Optional OnAnimationStartedListener to find out when the
 * requested animation has started running.  If for some reason the animation
 * is not executed, the callback will happen immediately.
 * @return Returns a new ActivityOptions object that you can use to
 * supply these options as the options Bundle when starting an activity.
 * @hide
 */

Body of Frist Method:
{
    ActivityOptions opts = new ActivityOptions();
    opts.mPackageName = context.getPackageName();
    opts.mAnimationType = ANIM_CUSTOM;
    opts.mCustomEnterResId = enterResId;
    opts.mCustomExitResId = exitResId;
    opts.setListener(handler, listener);
    return opts;
}
Body of Second Method:
{
    ActivityOptions opts = new ActivityOptions();
    opts.mPackageName = context.getPackageName();
    opts.mAnimationType = ANIM_CUSTOM;
    opts.mCustomEnterResId = enterResId;
    opts.mCustomExitResId = exitResId;
    opts.setOnAnimationStartedListener(handler, listener);
    return opts;
}
------------------------
Find a silently evolved API code:android.view.ViewPropertyAnimator.cancel:COMMENT
Method Modifier: public      
Comment:/**
 * Cancels all property animations that are currently running or pending.
 */

Body of Frist Method:
{
    if (mAnimatorMap.size() > 0) {
        HashMap<Animator, PropertyBundle> mAnimatorMapCopy = (HashMap<Animator, PropertyBundle>) mAnimatorMap.clone();
        Set<Animator> animatorSet = mAnimatorMapCopy.keySet();
        for (Animator runningAnim : animatorSet) {
            runningAnim.cancel();
        }
    }
    mPendingAnimations.clear();
    mView.removeCallbacks(mAnimationStarter);
}
Body of Second Method:
{
    if (mAnimatorMap.size() > 0) {
        HashMap<Animator, PropertyBundle> mAnimatorMapCopy = (HashMap<Animator, PropertyBundle>) mAnimatorMap.clone();
        Set<Animator> animatorSet = mAnimatorMapCopy.keySet();
        for (Animator runningAnim : animatorSet) {
            runningAnim.cancel();
        }
    }
    mPendingAnimations.clear();
    mPendingSetupAction = null;
    mPendingCleanupAction = null;
    mPendingOnStartAction = null;
    mPendingOnEndAction = null;
    mView.removeCallbacks(mAnimationStarter);
    if (mRTBackend != null) {
        mRTBackend.cancelAll();
    }
}
------------------------
Find a silently evolved API code:android.view.ViewGroup.dispatchGenericPointerEvent:COMMENT
Method Modifier: protected   
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    // Send the event to the child under the pointer.
    final int childrenCount = mChildrenCount;
    if (childrenCount != 0) {
        final View[] children = mChildren;
        final float x = event.getX();
        final float y = event.getY();
        final boolean customOrder = isChildrenDrawingOrderEnabled();
        for (int i = childrenCount - 1; i >= 0; i--) {
            final int childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i;
            final View child = children[childIndex];
            if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) {
                continue;
            }
            if (dispatchTransformedGenericPointerEvent(event, child)) {
                return true;
            }
        }
    }
    // No child handled the event.  Send it to this view group.
    return super.dispatchGenericPointerEvent(event);
}
Body of Second Method:
{
    // Send the event to the child under the pointer.
    final int childrenCount = mChildrenCount;
    if (childrenCount != 0) {
        final float x = event.getX();
        final float y = event.getY();
        final ArrayList<View> preorderedList = buildOrderedChildList();
        final boolean customOrder = preorderedList == null && isChildrenDrawingOrderEnabled();
        final View[] children = mChildren;
        for (int i = childrenCount - 1; i >= 0; i--) {
            int childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i;
            final View child = (preorderedList == null) ? children[childIndex] : preorderedList.get(childIndex);
            if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) {
                continue;
            }
            if (dispatchTransformedGenericPointerEvent(event, child)) {
                if (preorderedList != null)
                    preorderedList.clear();
                return true;
            }
        }
        if (preorderedList != null)
            preorderedList.clear();
    }
    // No child handled the event.  Send it to this view group.
    return super.dispatchGenericPointerEvent(event);
}
------------------------
Find a silently evolved API code:android.animation.ObjectAnimator.animateValue:COMMENT
Method Modifier: default     
Comment:/**
 * This method is called with the elapsed fraction of the animation during every
 * animation frame. This function turns the elapsed fraction into an interpolated fraction
 * and then into an animated value (from the evaluator. The function is called mostly during
 * animation updates, but it is also called when the <code>end()</code>
 * function is called, to set the final value on the property.
 *
 * <p>Overrides of this method must call the superclass to perform the calculation
 * of the animated value.</p>
 *
 * @param fraction The elapsed fraction of the animation.
 */

Body of Frist Method:
{
    super.animateValue(fraction);
    int numValues = mValues.length;
    for (int i = 0; i < numValues; ++i) {
        mValues[i].setAnimatedValue(mTarget);
    }
}
Body of Second Method:
{
    final Object target = getTarget();
    if (mTarget != null && target == null) {
        // We lost the target reference, cancel and clean up.
        cancel();
        return;
    }
    super.animateValue(fraction);
    int numValues = mValues.length;
    for (int i = 0; i < numValues; ++i) {
        mValues[i].setAnimatedValue(target);
    }
}
------------------------
Find a silently evolved API code:android.print.PrintDocumentInfo.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Creates a new {@link PrintDocumentInfo} instance.
 *
 * @return The new instance.
 */

Body of Frist Method:
{
    return new PrintDocumentInfo(mPrototype);
}
Body of Second Method:
{
    // wiritten PDF file for the page count.
    if (mPrototype.mPageCount == 0) {
        mPrototype.mPageCount = PAGE_COUNT_UNKNOWN;
    }
    return new PrintDocumentInfo(mPrototype);
}
------------------------
Find a silently evolved API code:android.media.MediaFocusControl.removeFocusStackEntryForClient:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Helper function:
 * Called synchronized on mAudioFocusLock
 * Remove focus listeners from the focus stack for a particular client when it has died.
 */

Body of Frist Method:
{
    // is the owner of the audio focus part of the client to remove?
    boolean isTopOfStackForClientToRemove = !mFocusStack.isEmpty() && mFocusStack.peek().hasSameBinder(cb);
    // (using an iterator on the stack so we can safely remove an entry after having
    // evaluated it, traversal order doesn't matter here)
    Iterator<FocusRequester> stackIterator = mFocusStack.iterator();
    while (stackIterator.hasNext()) {
        FocusRequester fr = (FocusRequester) stackIterator.next();
        if (fr.hasSameBinder(cb)) {
            Log.i(TAG, "AudioFocus  removeFocusStackEntry(): removing entry for " + cb);
            stackIterator.remove();
        // the client just died, no need to unlink to its death
        }
    }
    if (isTopOfStackForClientToRemove) {
        // we removed an entry at the top of the stack:
        // notify the new top of the stack it gained focus.
        notifyTopOfAudioFocusStack();
        // there's a new top of the stack, let the remote control know
        synchronized (mRCStack) {
            checkUpdateRemoteControlDisplay_syncAfRcs(RC_INFO_ALL);
        }
    }
}
Body of Second Method:
{
    // is the owner of the audio focus part of the client to remove?
    boolean isTopOfStackForClientToRemove = !mFocusStack.isEmpty() && mFocusStack.peek().hasSameBinder(cb);
    // (using an iterator on the stack so we can safely remove an entry after having
    // evaluated it, traversal order doesn't matter here)
    Iterator<FocusRequester> stackIterator = mFocusStack.iterator();
    while (stackIterator.hasNext()) {
        FocusRequester fr = stackIterator.next();
        if (fr.hasSameBinder(cb)) {
            Log.i(TAG, "AudioFocus  removeFocusStackEntry(): removing entry for " + cb);
            stackIterator.remove();
        // the client just died, no need to unlink to its death
        }
    }
    if (isTopOfStackForClientToRemove) {
        // we removed an entry at the top of the stack:
        // notify the new top of the stack it gained focus.
        notifyTopOfAudioFocusStack();
    }
}
------------------------
Find a silently evolved API code:android.content.res.TypedArray.getPositionDescription:COMMENT
Method Modifier: public      
Comment:/**
 * Returns a message about the parser state suitable for printing error messages.
 */

Body of Frist Method:
{
    return mXml != null ? mXml.getPositionDescription() : "<internal>";
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    return mXml != null ? mXml.getPositionDescription() : "<internal>";
}
------------------------
Find a silently evolved API code:android.text.PackedIntVector.growBuffer:COMMENT
Method Modifier: private     final       
Comment:/**
 * Grows the value and gap arrays to be large enough to store at least
 * one more than the current number of rows.
 */

Body of Frist Method:
{
    final int columns = mColumns;
    int newsize = size() + 1;
    newsize = ArrayUtils.idealIntArraySize(newsize * columns) / columns;
    int[] newvalues = new int[newsize * columns];
    final int[] valuegap = mValueGap;
    final int rowgapstart = mRowGapStart;
    int after = mRows - (rowgapstart + mRowGapLength);
    if (mValues != null) {
        System.arraycopy(mValues, 0, newvalues, 0, columns * rowgapstart);
        System.arraycopy(mValues, (mRows - after) * columns, newvalues, (newsize - after) * columns, after * columns);
    }
    for (int i = 0; i < columns; i++) {
        if (valuegap[i] >= rowgapstart) {
            valuegap[i] += newsize - mRows;
            if (valuegap[i] < rowgapstart) {
                valuegap[i] = rowgapstart;
            }
        }
    }
    mRowGapLength += newsize - mRows;
    mRows = newsize;
    mValues = newvalues;
}
Body of Second Method:
{
    final int columns = mColumns;
    int[] newvalues = ArrayUtils.newUnpaddedIntArray(GrowingArrayUtils.growSize(size()) * columns);
    int newsize = newvalues.length / columns;
    final int[] valuegap = mValueGap;
    final int rowgapstart = mRowGapStart;
    int after = mRows - (rowgapstart + mRowGapLength);
    if (mValues != null) {
        System.arraycopy(mValues, 0, newvalues, 0, columns * rowgapstart);
        System.arraycopy(mValues, (mRows - after) * columns, newvalues, (newsize - after) * columns, after * columns);
    }
    for (int i = 0; i < columns; i++) {
        if (valuegap[i] >= rowgapstart) {
            valuegap[i] += newsize - mRows;
            if (valuegap[i] < rowgapstart) {
                valuegap[i] = rowgapstart;
            }
        }
    }
    mRowGapLength += newsize - mRows;
    mRows = newsize;
    mValues = newvalues;
}
------------------------
Find a silently evolved API code:android.media.MediaFocusControl.remoteControlDisplayUsesBitmapSize:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * Update the size of the artwork used by an IRemoteControlDisplay.
 * @see android.media.IAudioService#remoteControlDisplayUsesBitmapSize(android.media.IRemoteControlDisplay, int, int)
 * @param rcd the IRemoteControlDisplay with the new artwork size requirement
 * @param w the maximum width of the expected bitmap. Negative or zero values indicate this
 * display doesn't need to receive artwork.
 * @param h the maximum height of the expected bitmap. Negative or zero values indicate this
 * display doesn't need to receive artwork.
 */

Body of Frist Method:
{
    synchronized (mRCStack) {
        final Iterator<DisplayInfoForServer> displayIterator = mRcDisplays.iterator();
        boolean artworkSizeUpdate = false;
        while (displayIterator.hasNext() && !artworkSizeUpdate) {
            final DisplayInfoForServer di = (DisplayInfoForServer) displayIterator.next();
            if (di.mRcDisplay.asBinder().equals(rcd.asBinder())) {
                if ((di.mArtworkExpectedWidth != w) || (di.mArtworkExpectedHeight != h)) {
                    di.mArtworkExpectedWidth = w;
                    di.mArtworkExpectedHeight = h;
                    artworkSizeUpdate = true;
                }
            }
        }
        if (artworkSizeUpdate) {
            // RCD is currently plugged in and its artwork size has changed, notify all RCCs,
            // stack traversal order doesn't matter
            final Iterator<RemoteControlStackEntry> stackIterator = mRCStack.iterator();
            while (stackIterator.hasNext()) {
                final RemoteControlStackEntry rcse = stackIterator.next();
                if (rcse.mRcClient != null) {
                    try {
                        rcse.mRcClient.setBitmapSizeForDisplay(rcd, w, h);
                    } catch (RemoteException e) {
                        Log.e(TAG, "Error setting bitmap size for RCD on RCC: ", e);
                    }
                }
            }
        }
    }
}
Body of Second Method:
{
    synchronized (mPRStack) {
        final Iterator<DisplayInfoForServer> displayIterator = mRcDisplays.iterator();
        boolean artworkSizeUpdate = false;
        while (displayIterator.hasNext() && !artworkSizeUpdate) {
            final DisplayInfoForServer di = displayIterator.next();
            if (di.mRcDisplay.asBinder().equals(rcd.asBinder())) {
                if ((di.mArtworkExpectedWidth != w) || (di.mArtworkExpectedHeight != h)) {
                    di.mArtworkExpectedWidth = w;
                    di.mArtworkExpectedHeight = h;
                    artworkSizeUpdate = true;
                }
            }
        }
        if (artworkSizeUpdate) {
            // RCD is currently plugged in and its artwork size has changed, notify all RCCs,
            // stack traversal order doesn't matter
            final Iterator<PlayerRecord> stackIterator = mPRStack.iterator();
            while (stackIterator.hasNext()) {
                final PlayerRecord prse = stackIterator.next();
                if (prse.getRcc() != null) {
                    try {
                        prse.getRcc().setBitmapSizeForDisplay(rcd, w, h);
                    } catch (RemoteException e) {
                        Log.e(TAG, "Error setting bitmap size for RCD on RCC: ", e);
                    }
                }
            }
        }
    }
}
------------------------
Find a silently evolved API code:android.os.storage.IMountService.Stub.Proxy.mountSecureContainer:COMMENT
Method Modifier: public      
Comment:/*
             * Mount a secure container with the specified key and owner UID.
             * Returns an int consistent with MountServiceResultCode
             */

Body of Frist Method:
{
    Parcel _data = Parcel.obtain();
    Parcel _reply = Parcel.obtain();
    int _result;
    try {
        _data.writeInterfaceToken(DESCRIPTOR);
        _data.writeString(id);
        _data.writeString(key);
        _data.writeInt(ownerUid);
        mRemote.transact(Stub.TRANSACTION_mountSecureContainer, _data, _reply, 0);
        _reply.readException();
        _result = _reply.readInt();
    } finally {
        _reply.recycle();
        _data.recycle();
    }
    return _result;
}
Body of Second Method:
{
    Parcel _data = Parcel.obtain();
    Parcel _reply = Parcel.obtain();
    int _result;
    try {
        _data.writeInterfaceToken(DESCRIPTOR);
        _data.writeString(id);
        _data.writeString(key);
        _data.writeInt(ownerUid);
        _data.writeInt(readOnly ? 1 : 0);
        mRemote.transact(Stub.TRANSACTION_mountSecureContainer, _data, _reply, 0);
        _reply.readException();
        _result = _reply.readInt();
    } finally {
        _reply.recycle();
        _data.recycle();
    }
    return _result;
}
------------------------
Find a silently evolved API code:android.widget.CalendarView.setWeekDayTextAppearance:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the text appearance for the week day abbreviation of the calendar header.
 *
 * @param resourceId The text appearance resource id.
 *
 * @attr ref android.R.styleable#CalendarView_weekDayTextAppearance
 */

Body of Frist Method:
{
    if (mWeekDayTextAppearanceResId != resourceId) {
        mWeekDayTextAppearanceResId = resourceId;
        setUpHeader();
    }
}
Body of Second Method:
{
    mDelegate.setWeekDayTextAppearance(resourceId);
}
------------------------
Find a silently evolved API code:android.inputmethodservice.SoftInputWindow.setGravity:COMMENT
<android.inputmethodservice.SoftInputWindow: void setGravity(int)>
public      ->public      hidden      
Method Modifier: public      hidden      
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Set which boundary of the screen the DockWindow sticks to.
 *
 * @param gravity The boundary of the screen to stick. See {#link
 * android.view.Gravity.LEFT}, {#link android.view.Gravity.TOP},
 * {#link android.view.Gravity.BOTTOM}, {#link
 * android.view.Gravity.RIGHT}.
 */

Body of Frist Method:
{
    WindowManager.LayoutParams lp = getWindow().getAttributes();
    boolean oldIsVertical = (lp.gravity == Gravity.TOP || lp.gravity == Gravity.BOTTOM);
    lp.gravity = gravity;
    boolean newIsVertical = (lp.gravity == Gravity.TOP || lp.gravity == Gravity.BOTTOM);
    if (oldIsVertical != newIsVertical) {
        int tmp = lp.width;
        lp.width = lp.height;
        lp.height = tmp;
        getWindow().setAttributes(lp);
    }
}
Body of Second Method:
{
    WindowManager.LayoutParams lp = getWindow().getAttributes();
    lp.gravity = gravity;
    updateWidthHeight(lp);
    getWindow().setAttributes(lp);
}
------------------------
Find a silently evolved API code:android.graphics.drawable.Drawable.createFromStream:COMMENT
Method Modifier: public      static      
Comment:/**
 * Create a drawable from an inputstream
 */

Body of Frist Method:
{
    Trace.traceBegin(Trace.TRACE_TAG_RESOURCES, srcName != null ? srcName : "Unknown drawable");
    try {
        return createFromResourceStream(null, null, is, srcName, null);
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
    }
}
Body of Second Method:
{
    Trace.traceBegin(Trace.TRACE_TAG_RESOURCES, srcName != null ? srcName : "Unknown drawable");
    try {
        return createFromResourceStream(null, null, is, srcName);
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
    }
}
------------------------
Find a silently evolved API code:android.media.MediaPlayer.reset:COMMENT
Method Modifier: public      
Comment:/**
 * Resets the MediaPlayer to its uninitialized state. After calling
 * this method, you will have to initialize it again by setting the
 * data source and calling prepare().
 */

Body of Frist Method:
{
    mSelectedSubtitleTrackIndex = -1;
    synchronized (mOpenSubtitleSources) {
        for (final InputStream is : mOpenSubtitleSources) {
            try {
                is.close();
            } catch (IOException e) {
            }
        }
        mOpenSubtitleSources.clear();
    }
    mOutOfBandSubtitleTracks.clear();
    mInbandSubtitleTracks = new SubtitleTrack[0];
    if (mSubtitleController != null) {
        mSubtitleController.reset();
    }
    if (mTimeProvider != null) {
        mTimeProvider.close();
        mTimeProvider = null;
    }
    stayAwake(false);
    _reset();
    // make sure none of the listeners get called anymore
    if (mEventHandler != null) {
        mEventHandler.removeCallbacksAndMessages(null);
    }
    disableProxyListener();
}
Body of Second Method:
{
    mSelectedSubtitleTrackIndex = -1;
    synchronized (mOpenSubtitleSources) {
        for (final InputStream is : mOpenSubtitleSources) {
            try {
                is.close();
            } catch (IOException e) {
            }
        }
        mOpenSubtitleSources.clear();
    }
    mOutOfBandSubtitleTracks.clear();
    mInbandSubtitleTracks = new SubtitleTrack[0];
    if (mSubtitleController != null) {
        mSubtitleController.reset();
    }
    if (mTimeProvider != null) {
        mTimeProvider.close();
        mTimeProvider = null;
    }
    stayAwake(false);
    _reset();
    // make sure none of the listeners get called anymore
    if (mEventHandler != null) {
        mEventHandler.removeCallbacksAndMessages(null);
    }
}
------------------------
Find a silently evolved API code:android.media.SubtitleTrack.hide:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (!mVisible) {
        return;
    }
    if (mTimeProvider != null) {
        mTimeProvider.cancelNotifications(this);
    }
    getRenderingWidget().setVisible(false);
    mVisible = false;
}
Body of Second Method:
{
    if (!mVisible) {
        return;
    }
    if (mTimeProvider != null) {
        mTimeProvider.cancelNotifications(this);
    }
    RenderingWidget renderingWidget = getRenderingWidget();
    if (renderingWidget != null) {
        renderingWidget.setVisible(false);
    }
    mVisible = false;
}
------------------------
Find a silently evolved API code:android.widget.FastScroller.setEnabled:COMMENT
Method Modifier: public      
Comment:/**
 * @param enabled Whether the fast scroll thumb is enabled.
 */

Body of Frist Method:
{
    if (mEnabled != enabled) {
        mEnabled = enabled;
        onStateDependencyChanged();
    }
}
Body of Second Method:
{
    if (mEnabled != enabled) {
        mEnabled = enabled;
        onStateDependencyChanged(true);
    }
}
------------------------
Find a silently evolved API code:android.content.res.TypedArray.getIndex:COMMENT
Method Modifier: public      
Comment:/**
 * Return an index in the array that has data.
 *
 * @param at The index you would like to returned, ranging from 0 to
 * {@link #getIndexCount()}.
 *
 * @return The index at the given offset, which can be used with
 * {@link #getValue} and related APIs.
 */

Body of Frist Method:
{
    return mIndices[1 + at];
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    return mIndices[1 + at];
}
------------------------
Find a silently evolved API code:android.os.ParcelFileDescriptor.createSocketPair:COMMENT
Method Modifier: public      static      
Comment:/**
 * Create two ParcelFileDescriptors structured as a pair of sockets
 * connected to each other. The two sockets are indistinguishable.
 */

Body of Frist Method:
{
    try {
        final FileDescriptor fd0 = new FileDescriptor();
        final FileDescriptor fd1 = new FileDescriptor();
        Libcore.os.socketpair(AF_UNIX, SOCK_STREAM, 0, fd0, fd1);
        return new ParcelFileDescriptor[] { new ParcelFileDescriptor(fd0), new ParcelFileDescriptor(fd1) };
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
}
Body of Second Method:
{
    try {
        final FileDescriptor fd0 = new FileDescriptor();
        final FileDescriptor fd1 = new FileDescriptor();
        Os.socketpair(AF_UNIX, SOCK_STREAM, 0, fd0, fd1);
        return new ParcelFileDescriptor[] { new ParcelFileDescriptor(fd0), new ParcelFileDescriptor(fd1) };
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
}
------------------------
Find a silently evolved API code:android.view.accessibility.AccessibilityNodeInfo.getParent:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the parent.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 *
 * @return The parent.
 */

Body of Frist Method:
{
    enforceSealed();
    if (!canPerformRequestOverConnection(mParentNodeId)) {
        return null;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mWindowId, mParentNodeId, false, FLAG_PREFETCH_DESCENDANTS | FLAG_PREFETCH_SIBLINGS);
}
Body of Second Method:
{
    enforceSealed();
    if (!canPerformRequestOverConnection(mParentNodeId)) {
        return null;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mWindowId, mParentNodeId, false, FLAG_PREFETCH_PREDECESSORS | FLAG_PREFETCH_DESCENDANTS | FLAG_PREFETCH_SIBLINGS);
}
------------------------
Find a silently evolved API code:android.media.MediaPlayer.TimeProvider.onStopped:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    synchronized (this) {
        if (DEBUG)
            Log.d(TAG, "onStopped");
        mPaused = true;
        scheduleNotification(NOTIFY_STOP, 0);
    }
}
Body of Second Method:
{
    synchronized (this) {
        if (DEBUG)
            Log.d(TAG, "onStopped");
        mPaused = true;
        mStopped = true;
        mSeeking = false;
        scheduleNotification(NOTIFY_STOP, 0);
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothDevice.connectGatt:COMMENT
Method Modifier: public      
Comment:/**
 * Connect to GATT Server hosted by this device. Caller acts as GATT client.
 * The callback is used to deliver results to Caller, such as connection status as well
 * as any further GATT client operations.
 * The method returns a BluetoothGatt instance. You can use BluetoothGatt to conduct
 * GATT client operations.
 * @param callback GATT callback handler that will receive asynchronous callbacks.
 * @param autoConnect Whether to directly connect to the remote device (false)
 * or to automatically connect as soon as the remote
 * device becomes available (true).
 * @throws IllegalArgumentException if callback is null
 */

Body of Frist Method:
{
    // TODO(Bluetooth) check whether platform support BLE
    // Do the check here or in GattServer?
    BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
    IBluetoothManager managerService = adapter.getBluetoothManager();
    try {
        IBluetoothGatt iGatt = managerService.getBluetoothGatt();
        if (iGatt == null) {
            // BLE is not supported
            return null;
        }
        BluetoothGatt gatt = new BluetoothGatt(context, iGatt, this);
        gatt.connect(autoConnect, callback);
        return gatt;
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return null;
}
Body of Second Method:
{
    return (connectGatt(context, autoConnect, callback, TRANSPORT_AUTO));
}
------------------------
Find a silently evolved API code:android.view.DisplayInfo.toString:COMMENT
Method Modifier: public      hidden      
Comment:// For debugging purposes

Body of Frist Method:
{
    StringBuilder sb = new StringBuilder();
    sb.append("DisplayInfo{\"");
    sb.append(name);
    sb.append("\", app ");
    sb.append(appWidth);
    sb.append(" x ");
    sb.append(appHeight);
    sb.append(", real ");
    sb.append(logicalWidth);
    sb.append(" x ");
    sb.append(logicalHeight);
    if (overscanLeft != 0 || overscanTop != 0 || overscanRight != 0 || overscanBottom != 0) {
        sb.append(", overscan (");
        sb.append(overscanLeft);
        sb.append(",");
        sb.append(overscanTop);
        sb.append(",");
        sb.append(overscanRight);
        sb.append(",");
        sb.append(overscanBottom);
        sb.append(")");
    }
    sb.append(", largest app ");
    sb.append(largestNominalAppWidth);
    sb.append(" x ");
    sb.append(largestNominalAppHeight);
    sb.append(", smallest app ");
    sb.append(smallestNominalAppWidth);
    sb.append(" x ");
    sb.append(smallestNominalAppHeight);
    sb.append(", ");
    sb.append(refreshRate);
    sb.append(" fps, rotation");
    sb.append(rotation);
    sb.append(", density ");
    sb.append(logicalDensityDpi);
    sb.append(" (");
    sb.append(physicalXDpi);
    sb.append(" x ");
    sb.append(physicalYDpi);
    sb.append(") dpi, layerStack ");
    sb.append(layerStack);
    sb.append(", type ");
    sb.append(Display.typeToString(type));
    if (address != null) {
        sb.append(", address ").append(address);
    }
    if (ownerUid != 0 || ownerPackageName != null) {
        sb.append(", owner ").append(ownerPackageName);
        sb.append(" (uid ").append(ownerUid).append(")");
    }
    sb.append(flagsToString(flags));
    sb.append("}");
    return sb.toString();
}
Body of Second Method:
{
    StringBuilder sb = new StringBuilder();
    sb.append("DisplayInfo{\"");
    sb.append(name);
    sb.append("\", app ");
    sb.append(appWidth);
    sb.append(" x ");
    sb.append(appHeight);
    sb.append(", real ");
    sb.append(logicalWidth);
    sb.append(" x ");
    sb.append(logicalHeight);
    if (overscanLeft != 0 || overscanTop != 0 || overscanRight != 0 || overscanBottom != 0) {
        sb.append(", overscan (");
        sb.append(overscanLeft);
        sb.append(",");
        sb.append(overscanTop);
        sb.append(",");
        sb.append(overscanRight);
        sb.append(",");
        sb.append(overscanBottom);
        sb.append(")");
    }
    sb.append(", largest app ");
    sb.append(largestNominalAppWidth);
    sb.append(" x ");
    sb.append(largestNominalAppHeight);
    sb.append(", smallest app ");
    sb.append(smallestNominalAppWidth);
    sb.append(" x ");
    sb.append(smallestNominalAppHeight);
    sb.append(", ");
    sb.append(refreshRate);
    sb.append(" fps, supportedRefreshRates ");
    sb.append(Arrays.toString(supportedRefreshRates));
    sb.append(", rotation ");
    sb.append(rotation);
    sb.append(", density ");
    sb.append(logicalDensityDpi);
    sb.append(" (");
    sb.append(physicalXDpi);
    sb.append(" x ");
    sb.append(physicalYDpi);
    sb.append(") dpi, layerStack ");
    sb.append(layerStack);
    sb.append(", appVsyncOff ");
    sb.append(appVsyncOffsetNanos);
    sb.append(", presDeadline ");
    sb.append(presentationDeadlineNanos);
    sb.append(", type ");
    sb.append(Display.typeToString(type));
    if (address != null) {
        sb.append(", address ").append(address);
    }
    sb.append(", state ");
    sb.append(Display.stateToString(state));
    if (ownerUid != 0 || ownerPackageName != null) {
        sb.append(", owner ").append(ownerPackageName);
        sb.append(" (uid ").append(ownerUid).append(")");
    }
    sb.append(flagsToString(flags));
    sb.append("}");
    return sb.toString();
}
------------------------
Find a silently evolved API code:android.app.backup.BackupManager.beginRestoreSession:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Begin the process of restoring data from backup.  See the
 * {@link android.app.backup.RestoreSession} class for documentation on that process.
 * @hide
 */

Body of Frist Method:
{
    RestoreSession session = null;
    checkServiceBinder();
    if (sService != null) {
        try {
            // All packages, current transport
            IRestoreSession binder = sService.beginRestoreSession(null, null);
            if (binder != null) {
                session = new RestoreSession(mContext, binder);
            }
        } catch (RemoteException e) {
            Log.w(TAG, "beginRestoreSession() couldn't connect");
        }
    }
    return session;
}
Body of Second Method:
{
    RestoreSession session = null;
    checkServiceBinder();
    if (sService != null) {
        try {
            // All packages, current transport
            IRestoreSession binder = sService.beginRestoreSession(null, null);
            if (binder != null) {
                session = new RestoreSession(mContext, binder);
            }
        } catch (RemoteException e) {
            Log.e(TAG, "beginRestoreSession() couldn't connect");
        }
    }
    return session;
}
------------------------
Find a silently evolved API code:android.telephony.PhoneNumberUtils.cdmaCheckAndProcessPlusCodeByNumberFormat:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * This function should be called from checkAndProcessPlusCode only
 * And it is used for test purpose also.
 *
 * It checks the dial string by looping through the network portion,
 * post dial portion 1, post dial porting 2, etc. If there is any
 * plus sign, then process the plus sign.
 * Currently, this function supports the plus sign conversion within NANP only.
 * Specifically, it handles the plus sign in the following ways:
 * 1)+1NANP,remove +, e.g.
 * +18475797000 is converted to 18475797000,
 * 2)+NANP or +non-NANP Numbers,replace + with the current NANP IDP, e.g,
 * +8475797000 is converted to 0118475797000,
 * +11875767800 is converted to 01111875767800
 * 3)+1NANP in post dial string(s), e.g.
 * 8475797000;+18475231753 is converted to 8475797000;18475231753
 *
 * @param dialStr the original dial string
 * @param currFormat the numbering system of the current country that the phone is camped on
 * @param defaultFormat the numbering system of the country that the phone is activated on
 * @return the converted dial string if the current/default countries belong to NANP,
 * and if there is the "+" in the original dial string. Otherwise, the original dial
 * string returns.
 *
 * @hide
 */

Body of Frist Method:
{
    String retStr = dialStr;
    // Checks if the plus sign character is in the passed-in dial string
    if (dialStr != null && dialStr.lastIndexOf(PLUS_SIGN_STRING) != -1) {
        // and the current country the phone is camped on.
        if ((currFormat == defaultFormat) && (currFormat == FORMAT_NANP)) {
            // Handle case where default and current telephone numbering plans are NANP.
            String postDialStr = null;
            String tempDialStr = dialStr;
            // Sets the retStr to null since the conversion will be performed below.
            retStr = null;
            if (DBG)
                log("checkAndProcessPlusCode,dialStr=" + dialStr);
            // applied
            do {
                String networkDialStr;
                networkDialStr = extractNetworkPortion(tempDialStr);
                // Handles the conversion within NANP
                networkDialStr = processPlusCodeWithinNanp(networkDialStr);
                // Concatenates the string that is converted from network portion
                if (!TextUtils.isEmpty(networkDialStr)) {
                    if (retStr == null) {
                        retStr = networkDialStr;
                    } else {
                        retStr = retStr.concat(networkDialStr);
                    }
                } else {
                    // This should never happen since we checked the if dialStr is null
                    // and if it contains the plus sign in the beginning of this function.
                    // The plus sign is part of the network portion.
                    Rlog.e("checkAndProcessPlusCode: null newDialStr", networkDialStr);
                    return dialStr;
                }
                postDialStr = extractPostDialPortion(tempDialStr);
                if (!TextUtils.isEmpty(postDialStr)) {
                    int dialableIndex = findDialableIndexFromPostDialStr(postDialStr);
                    // dialableIndex should always be greater than 0
                    if (dialableIndex >= 1) {
                        retStr = appendPwCharBackToOrigDialStr(dialableIndex, retStr, postDialStr);
                        // Skips the P/W character, extracts the dialable portion
                        tempDialStr = postDialStr.substring(dialableIndex);
                    } else {
                        // Set the postDialStr to "" to break out of the loop
                        if (dialableIndex < 0) {
                            postDialStr = "";
                        }
                        Rlog.e("wrong postDialStr=", postDialStr);
                    }
                }
                if (DBG)
                    log("checkAndProcessPlusCode,postDialStr=" + postDialStr);
            } while (!TextUtils.isEmpty(postDialStr) && !TextUtils.isEmpty(tempDialStr));
        } else {
            // TODO: Support NANP international conversion and other telephone numbering plans.
            // Currently the phone is never used in non-NANP system, so return the original
            // dial string.
            Rlog.e("checkAndProcessPlusCode:non-NANP not supported", dialStr);
        }
    }
    return retStr;
}
Body of Second Method:
{
    String retStr = dialStr;
    boolean useNanp = (currFormat == defaultFormat) && (currFormat == FORMAT_NANP);
    // Checks if the plus sign character is in the passed-in dial string
    if (dialStr != null && dialStr.lastIndexOf(PLUS_SIGN_STRING) != -1) {
        // Handle case where default and current telephone numbering plans are NANP.
        String postDialStr = null;
        String tempDialStr = dialStr;
        // Sets the retStr to null since the conversion will be performed below.
        retStr = null;
        if (DBG)
            log("checkAndProcessPlusCode,dialStr=" + dialStr);
        // applied
        do {
            String networkDialStr;
            // and the current country the phone is camped
            if (useNanp) {
                networkDialStr = extractNetworkPortion(tempDialStr);
            } else {
                networkDialStr = extractNetworkPortionAlt(tempDialStr);
            }
            networkDialStr = processPlusCode(networkDialStr, useNanp);
            // Concatenates the string that is converted from network portion
            if (!TextUtils.isEmpty(networkDialStr)) {
                if (retStr == null) {
                    retStr = networkDialStr;
                } else {
                    retStr = retStr.concat(networkDialStr);
                }
            } else {
                // This should never happen since we checked the if dialStr is null
                // and if it contains the plus sign in the beginning of this function.
                // The plus sign is part of the network portion.
                Rlog.e("checkAndProcessPlusCode: null newDialStr", networkDialStr);
                return dialStr;
            }
            postDialStr = extractPostDialPortion(tempDialStr);
            if (!TextUtils.isEmpty(postDialStr)) {
                int dialableIndex = findDialableIndexFromPostDialStr(postDialStr);
                // dialableIndex should always be greater than 0
                if (dialableIndex >= 1) {
                    retStr = appendPwCharBackToOrigDialStr(dialableIndex, retStr, postDialStr);
                    // Skips the P/W character, extracts the dialable portion
                    tempDialStr = postDialStr.substring(dialableIndex);
                } else {
                    // Set the postDialStr to "" to break out of the loop
                    if (dialableIndex < 0) {
                        postDialStr = "";
                    }
                    Rlog.e("wrong postDialStr=", postDialStr);
                }
            }
            if (DBG)
                log("checkAndProcessPlusCode,postDialStr=" + postDialStr);
        } while (!TextUtils.isEmpty(postDialStr) && !TextUtils.isEmpty(tempDialStr));
    }
    return retStr;
}
------------------------
Find a silently evolved API code:android.os.Bundle.putByte:COMMENT
Method Modifier: public      
Comment:/**
 * Inserts a byte value into the mapping of this Bundle, replacing
 * any existing value for the given key.
 *
 * @param key a String, or null
 * @param value a byte
 */

Body of Frist Method:
{
    unparcel();
    mMap.put(key, value);
}
Body of Second Method:
{
    super.putByte(key, value);
}
------------------------
Find a silently evolved API code:android.os.Bundle.putFloat:COMMENT
Method Modifier: public      
Comment:/**
 * Inserts a float value into the mapping of this Bundle, replacing
 * any existing value for the given key.
 *
 * @param key a String, or null
 * @param value a float
 */

Body of Frist Method:
{
    unparcel();
    mMap.put(key, value);
}
Body of Second Method:
{
    super.putFloat(key, value);
}
------------------------
Find a silently evolved API code:android.view.PointerIcon.getSystemIcon:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Gets a system pointer icon for the given style.
 * If style is not recognized, returns the default pointer icon.
 *
 * @param context The context.
 * @param style The pointer icon style.
 * @return The pointer icon.
 *
 * @throws IllegalArgumentException if context is null.
 */

Body of Frist Method:
{
    if (context == null) {
        throw new IllegalArgumentException("context must not be null");
    }
    if (style == STYLE_NULL) {
        return gNullIcon;
    }
    int styleIndex = getSystemIconStyleIndex(style);
    if (styleIndex == 0) {
        styleIndex = getSystemIconStyleIndex(STYLE_DEFAULT);
    }
    TypedArray a = context.obtainStyledAttributes(null, com.android.internal.R.styleable.Pointer, com.android.internal.R.attr.pointerStyle, 0);
    int resourceId = a.getResourceId(styleIndex, -1);
    a.recycle();
    if (resourceId == -1) {
        Log.w(TAG, "Missing theme resources for pointer icon style " + style);
        return style == STYLE_DEFAULT ? gNullIcon : getSystemIcon(context, STYLE_DEFAULT);
    }
    PointerIcon icon = new PointerIcon(style);
    if ((resourceId & 0xff000000) == 0x01000000) {
        icon.mSystemIconResourceId = resourceId;
    } else {
        icon.loadResource(context.getResources(), resourceId);
    }
    return icon;
}
Body of Second Method:
{
    if (context == null) {
        throw new IllegalArgumentException("context must not be null");
    }
    if (style == STYLE_NULL) {
        return gNullIcon;
    }
    int styleIndex = getSystemIconStyleIndex(style);
    if (styleIndex == 0) {
        styleIndex = getSystemIconStyleIndex(STYLE_DEFAULT);
    }
    TypedArray a = context.obtainStyledAttributes(null, com.android.internal.R.styleable.Pointer, com.android.internal.R.attr.pointerStyle, 0);
    int resourceId = a.getResourceId(styleIndex, -1);
    a.recycle();
    if (resourceId == -1) {
        Log.w(TAG, "Missing theme resources for pointer icon style " + style);
        return style == STYLE_DEFAULT ? gNullIcon : getSystemIcon(context, STYLE_DEFAULT);
    }
    PointerIcon icon = new PointerIcon(style);
    if ((resourceId & 0xff000000) == 0x01000000) {
        icon.mSystemIconResourceId = resourceId;
    } else {
        icon.loadResource(context, context.getResources(), resourceId);
    }
    return icon;
}
------------------------
Find a silently evolved API code:android.os.CountDownTimer.start:COMMENT
Method Modifier: public      final       
Comment:/**
 * Start the countdown.
 */

Body of Frist Method:
{
    if (mMillisInFuture <= 0) {
        onFinish();
        return this;
    }
    mStopTimeInFuture = SystemClock.elapsedRealtime() + mMillisInFuture;
    mHandler.sendMessage(mHandler.obtainMessage(MSG));
    return this;
}
Body of Second Method:
{
    mCancelled = false;
    if (mMillisInFuture <= 0) {
        onFinish();
        return this;
    }
    mStopTimeInFuture = SystemClock.elapsedRealtime() + mMillisInFuture;
    mHandler.sendMessage(mHandler.obtainMessage(MSG));
    return this;
}
------------------------
Find a silently evolved API code:android.content.RestrictionEntry.getChoiceValues:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the list of possible string values set earlier.
 * @return the list of possible values.
 */

Body of Frist Method:
{
    return values;
}
Body of Second Method:
{
    return mChoiceValues;
}
------------------------
Find a silently evolved API code:android.graphics.Canvas.drawRoundRect:COMMENT
Method Modifier: public      
Comment:/**
 * Draw the specified round-rect using the specified paint. The roundrect
 * will be filled or framed based on the Style in the paint.
 *
 * @param rect  The rectangular bounds of the roundRect to be drawn
 * @param rx    The x-radius of the oval used to round the corners
 * @param ry    The y-radius of the oval used to round the corners
 * @param paint The paint used to draw the roundRect
 */

Body of Frist Method:
{
    if (rect == null) {
        throw new NullPointerException();
    }
    native_drawRoundRect(mNativeCanvas, rect, rx, ry, paint.mNativePaint);
}
Body of Second Method:
{
    drawRoundRect(rect.left, rect.top, rect.right, rect.bottom, rx, ry, paint);
}
------------------------
Find a silently evolved API code:android.media.MediaFocusControl.unregisterMediaButtonEventReceiverForCalls:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * see AudioManager.unregisterMediaButtonEventReceiverForCalls()
 */

Body of Frist Method:
{
    if (mContext.checkCallingPermission("android.permission.MODIFY_PHONE_STATE") != PackageManager.PERMISSION_GRANTED) {
        Log.e(TAG, "Invalid permissions to unregister media button receiver for calls");
        return;
    }
    synchronized (mRCStack) {
        mMediaReceiverForCalls = null;
    }
}
Body of Second Method:
{
    if (mContext.checkCallingPermission("android.permission.MODIFY_PHONE_STATE") != PackageManager.PERMISSION_GRANTED) {
        Log.e(TAG, "Invalid permissions to unregister media button receiver for calls");
        return;
    }
    synchronized (mPRStack) {
        mMediaReceiverForCalls = null;
    }
}
------------------------
Find a silently evolved API code:android.media.MediaRouter.removeUserRoute:COMMENT
Method Modifier: public      
Comment:/**
 * Remove an app-specified route for media from the MediaRouter.
 *
 * @param info Definition of the route to remove
 * @see #addUserRoute(UserRouteInfo)
 */

Body of Frist Method:
{
    removeRoute(info);
}
Body of Second Method:
{
    removeRouteStatic(info);
}
------------------------
Find a silently evolved API code:android.text.TextLine.handleText:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Utility function for measuring and rendering text.  The text must
 * not include a tab or emoji.
 *
 * @param wp the working paint
 * @param start the start of the text
 * @param end the end of the text
 * @param runIsRtl true if the run is right-to-left
 * @param c the canvas, can be null if rendering is not needed
 * @param x the edge of the run closest to the leading margin
 * @param top the top of the line
 * @param y the baseline
 * @param bottom the bottom of the line
 * @param fmi receives metrics information, can be null
 * @param needWidth true if the width of the run is needed
 * @return the signed width of the run based on the run direction; only
 * valid if needWidth is true
 */

Body of Frist Method:
{
    // Get metrics first (even for empty strings or "0" width runs)
    if (fmi != null) {
        expandMetricsFromPaint(fmi, wp);
    }
    int runLen = end - start;
    // No need to do anything if the run width is "0"
    if (runLen == 0) {
        return 0f;
    }
    float ret = 0;
    int contextLen = contextEnd - contextStart;
    if (needWidth || (c != null && (wp.bgColor != 0 || wp.underlineColor != 0 || runIsRtl))) {
        int flags = runIsRtl ? Paint.DIRECTION_RTL : Paint.DIRECTION_LTR;
        if (mCharsValid) {
            ret = wp.getTextRunAdvances(mChars, start, runLen, contextStart, contextLen, flags, null, 0);
        } else {
            int delta = mStart;
            ret = wp.getTextRunAdvances(mText, delta + start, delta + end, delta + contextStart, delta + contextEnd, flags, null, 0);
        }
    }
    if (c != null) {
        if (runIsRtl) {
            x -= ret;
        }
        if (wp.bgColor != 0) {
            int previousColor = wp.getColor();
            Paint.Style previousStyle = wp.getStyle();
            wp.setColor(wp.bgColor);
            wp.setStyle(Paint.Style.FILL);
            c.drawRect(x, top, x + ret, bottom, wp);
            wp.setStyle(previousStyle);
            wp.setColor(previousColor);
        }
        if (wp.underlineColor != 0) {
            // kStdUnderline_Offset = 1/9, defined in SkTextFormatParams.h
            float underlineTop = y + wp.baselineShift + (1.0f / 9.0f) * wp.getTextSize();
            int previousColor = wp.getColor();
            Paint.Style previousStyle = wp.getStyle();
            boolean previousAntiAlias = wp.isAntiAlias();
            wp.setStyle(Paint.Style.FILL);
            wp.setAntiAlias(true);
            wp.setColor(wp.underlineColor);
            c.drawRect(x, underlineTop, x + ret, underlineTop + wp.underlineThickness, wp);
            wp.setStyle(previousStyle);
            wp.setColor(previousColor);
            wp.setAntiAlias(previousAntiAlias);
        }
        drawTextRun(c, wp, start, end, contextStart, contextEnd, runIsRtl, x, y + wp.baselineShift);
    }
    return runIsRtl ? -ret : ret;
}
Body of Second Method:
{
    // Get metrics first (even for empty strings or "0" width runs)
    if (fmi != null) {
        expandMetricsFromPaint(fmi, wp);
    }
    int runLen = end - start;
    // No need to do anything if the run width is "0"
    if (runLen == 0) {
        return 0f;
    }
    float ret = 0;
    int contextLen = contextEnd - contextStart;
    if (needWidth || (c != null && (wp.bgColor != 0 || wp.underlineColor != 0 || runIsRtl))) {
        if (mCharsValid) {
            ret = wp.getTextRunAdvances(mChars, start, runLen, contextStart, contextLen, runIsRtl, null, 0);
        } else {
            int delta = mStart;
            ret = wp.getTextRunAdvances(mText, delta + start, delta + end, delta + contextStart, delta + contextEnd, runIsRtl, null, 0);
        }
    }
    if (c != null) {
        if (runIsRtl) {
            x -= ret;
        }
        if (wp.bgColor != 0) {
            int previousColor = wp.getColor();
            Paint.Style previousStyle = wp.getStyle();
            wp.setColor(wp.bgColor);
            wp.setStyle(Paint.Style.FILL);
            c.drawRect(x, top, x + ret, bottom, wp);
            wp.setStyle(previousStyle);
            wp.setColor(previousColor);
        }
        if (wp.underlineColor != 0) {
            // kStdUnderline_Offset = 1/9, defined in SkTextFormatParams.h
            float underlineTop = y + wp.baselineShift + (1.0f / 9.0f) * wp.getTextSize();
            int previousColor = wp.getColor();
            Paint.Style previousStyle = wp.getStyle();
            boolean previousAntiAlias = wp.isAntiAlias();
            wp.setStyle(Paint.Style.FILL);
            wp.setAntiAlias(true);
            wp.setColor(wp.underlineColor);
            c.drawRect(x, underlineTop, x + ret, underlineTop + wp.underlineThickness, wp);
            wp.setStyle(previousStyle);
            wp.setColor(previousColor);
            wp.setAntiAlias(previousAntiAlias);
        }
        drawTextRun(c, wp, start, end, contextStart, contextEnd, runIsRtl, x, y + wp.baselineShift);
    }
    return runIsRtl ? -ret : ret;
}
------------------------
Find a silently evolved API code:android.hardware.location.GeofenceHardwareImpl.reportGeofenceMonitorStatus:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Used to report Monitor status changes.
 */

Body of Frist Method:
{
    // TODO: use the source if needed in the future
    setMonitorAvailability(monitoringType, monitoringStatus);
    acquireWakeLock();
    Message message = mCallbacksHandler.obtainMessage(GEOFENCE_STATUS, location);
    message.arg1 = monitoringStatus;
    message.arg2 = monitoringType;
    message.sendToTarget();
}
Body of Second Method:
{
    setMonitorAvailability(monitoringType, monitoringStatus);
    acquireWakeLock();
    GeofenceHardwareMonitorEvent event = new GeofenceHardwareMonitorEvent(monitoringType, monitoringStatus, source, location);
    Message message = mCallbacksHandler.obtainMessage(GEOFENCE_STATUS, event);
    message.sendToTarget();
}
------------------------
Find a silently evolved API code:android.media.MediaRouter.RouteInfo.requestSetVolume:COMMENT
Method Modifier: public      
Comment:/**
 * Request a volume change for this route.
 * @param volume value between 0 and getVolumeMax
 */

Body of Frist Method:
{
    if (mPlaybackType == PLAYBACK_TYPE_LOCAL) {
        try {
            sStatic.mAudioService.setStreamVolume(mPlaybackStream, volume, 0, ActivityThread.currentPackageName());
        } catch (RemoteException e) {
            Log.e(TAG, "Error setting local stream volume", e);
        }
    } else {
        Log.e(TAG, getClass().getSimpleName() + ".requestSetVolume(): " + "Non-local volume playback on system route? " + "Could not request volume change.");
    }
}
Body of Second Method:
{
    if (mPlaybackType == PLAYBACK_TYPE_LOCAL) {
        try {
            sStatic.mAudioService.setStreamVolume(mPlaybackStream, volume, 0, ActivityThread.currentPackageName());
        } catch (RemoteException e) {
            Log.e(TAG, "Error setting local stream volume", e);
        }
    } else {
        sStatic.requestSetVolume(this, volume);
    }
}
------------------------
Find a silently evolved API code:android.content.res.AssetManager.addAssetPath:COMMENT
Method Modifier: public      final       hidden      
Comment:/**
 * Add an additional set of assets to the asset manager.  This can be
 * either a directory or ZIP file.  Not for use by applications.  Returns
 * the cookie of the added asset, or 0 on failure.
 * {@hide}
 */

Body of Frist Method:
{
    int res = addAssetPathNative(path);
    return res;
}
Body of Second Method:
{
    synchronized (this) {
        int res = addAssetPathNative(path);
        makeStringBlocks(mStringBlocks);
        return res;
    }
}
------------------------
Find a silently evolved API code:android.os.Bundle.getShortArray:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return a short[] value, or null
 */

Body of Frist Method:
{
    unparcel();
    Object o = mMap.get(key);
    if (o == null) {
        return null;
    }
    try {
        return (short[]) o;
    } catch (ClassCastException e) {
        typeWarning(key, o, "short[]", e);
        return null;
    }
}
Body of Second Method:
{
    return super.getShortArray(key);
}
------------------------
Find a silently evolved API code:android.graphics.drawable.LayerDrawable.setDrawableByLayerId:COMMENT
Method Modifier: public      
Comment:/**
 * Sets (or replaces) the {@link Drawable} for the layer with the given id.
 *
 * @param id The layer ID to search for.
 * @param drawable The replacement {@link Drawable}.
 * @return Whether the {@link Drawable} was replaced (could return false if
 * the id was not found).
 */

Body of Frist Method:
{
    final ChildDrawable[] layers = mLayerState.mChildren;
    for (int i = mLayerState.mNum - 1; i >= 0; i--) {
        if (layers[i].mId == id) {
            if (layers[i].mDrawable != null) {
                if (drawable != null) {
                    Rect bounds = layers[i].mDrawable.getBounds();
                    drawable.setBounds(bounds);
                }
                layers[i].mDrawable.setCallback(null);
            }
            if (drawable != null) {
                drawable.setCallback(this);
            }
            layers[i].mDrawable = drawable;
            return true;
        }
    }
    return false;
}
Body of Second Method:
{
    final ChildDrawable[] layers = mLayerState.mChildren;
    final int N = mLayerState.mNum;
    for (int i = 0; i < N; i++) {
        final ChildDrawable childDrawable = layers[i];
        if (childDrawable.mId == id) {
            if (childDrawable.mDrawable != null) {
                if (drawable != null) {
                    final Rect bounds = childDrawable.mDrawable.getBounds();
                    drawable.setBounds(bounds);
                }
                childDrawable.mDrawable.setCallback(null);
            }
            if (drawable != null) {
                drawable.setCallback(this);
            }
            childDrawable.mDrawable = drawable;
            mLayerState.invalidateCache();
            return true;
        }
    }
    return false;
}
------------------------
Find a silently evolved API code:android.media.MediaFocusControl.checkUpdateRemoteStateIfActive:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * Checks if a remote client is active on the supplied stream type. Update the remote stream
 * volume state if found and playing
 * @param streamType
 * @return false if no remote playing is currently playing
 */

Body of Frist Method:
{
    synchronized (mRCStack) {
        // iterating from top of stack as active playback is more likely on entries at the top
        try {
            for (int index = mRCStack.size() - 1; index >= 0; index--) {
                final RemoteControlStackEntry rcse = mRCStack.elementAt(index);
                if ((rcse.mPlaybackType == RemoteControlClient.PLAYBACK_TYPE_REMOTE) && isPlaystateActive(rcse.mPlaybackState.mState) && (rcse.mPlaybackStream == streamType)) {
                    if (DEBUG_RC)
                        Log.d(TAG, "remote playback active on stream " + streamType + ", vol =" + rcse.mPlaybackVolume);
                    synchronized (mMainRemote) {
                        mMainRemote.mRccId = rcse.mRccId;
                        mMainRemote.mVolume = rcse.mPlaybackVolume;
                        mMainRemote.mVolumeMax = rcse.mPlaybackVolumeMax;
                        mMainRemote.mVolumeHandling = rcse.mPlaybackVolumeHandling;
                        mMainRemoteIsActive = true;
                    }
                    return true;
                }
            }
        } catch (ArrayIndexOutOfBoundsException e) {
            // not expected to happen, indicates improper concurrent modification
            Log.e(TAG, "Wrong index accessing RC stack, lock error? ", e);
        }
    }
    synchronized (mMainRemote) {
        mMainRemoteIsActive = false;
    }
    return false;
}
Body of Second Method:
{
    synchronized (mPRStack) {
        // iterating from top of stack as active playback is more likely on entries at the top
        try {
            for (int index = mPRStack.size() - 1; index >= 0; index--) {
                final PlayerRecord prse = mPRStack.elementAt(index);
                if ((prse.mPlaybackType == RemoteControlClient.PLAYBACK_TYPE_REMOTE) && isPlaystateActive(prse.mPlaybackState.mState) && (prse.mPlaybackStream == streamType)) {
                    if (DEBUG_RC)
                        Log.d(TAG, "remote playback active on stream " + streamType + ", vol =" + prse.mPlaybackVolume);
                    synchronized (mMainRemote) {
                        mMainRemote.mRccId = prse.getRccId();
                        mMainRemote.mVolume = prse.mPlaybackVolume;
                        mMainRemote.mVolumeMax = prse.mPlaybackVolumeMax;
                        mMainRemote.mVolumeHandling = prse.mPlaybackVolumeHandling;
                        mMainRemoteIsActive = true;
                    }
                    return true;
                }
            }
        } catch (ArrayIndexOutOfBoundsException e) {
            // not expected to happen, indicates improper concurrent modification
            Log.e(TAG, "Wrong index accessing RC stack, lock error? ", e);
        }
    }
    synchronized (mMainRemote) {
        mMainRemoteIsActive = false;
    }
    return false;
}
------------------------
Find a silently evolved API code:android.widget.ListPopupWindow.DropDownListView.onForwardedEvent:COMMENT
Method Modifier: public      
Comment:/**
 * Handles forwarded events.
 *
 * @param activePointerId id of the pointer that activated forwarding
 * @return whether the event was handled
 */

Body of Frist Method:
{
    boolean handledEvent = true;
    boolean clearPressedItem = false;
    final int actionMasked = event.getActionMasked();
    switch(actionMasked) {
        case MotionEvent.ACTION_CANCEL:
            handledEvent = false;
            break;
        case MotionEvent.ACTION_UP:
            handledEvent = false;
        // $FALL-THROUGH$
        case MotionEvent.ACTION_MOVE:
            final int activeIndex = event.findPointerIndex(activePointerId);
            if (activeIndex < 0) {
                handledEvent = false;
                break;
            }
            final int x = (int) event.getX(activeIndex);
            final int y = (int) event.getY(activeIndex);
            final int position = pointToPosition(x, y);
            if (position == INVALID_POSITION) {
                clearPressedItem = true;
                break;
            }
            final View child = getChildAt(position - getFirstVisiblePosition());
            setPressedItem(child, position);
            handledEvent = true;
            if (actionMasked == MotionEvent.ACTION_UP) {
                clickPressedItem(child, position);
            }
            break;
    }
    // Failure to handle the event cancels forwarding.
    if (!handledEvent || clearPressedItem) {
        clearPressedItem();
    }
    // Manage automatic scrolling.
    if (handledEvent) {
        if (mScrollHelper == null) {
            mScrollHelper = new AbsListViewAutoScroller(this);
        }
        mScrollHelper.setEnabled(true);
        mScrollHelper.onTouch(this, event);
    } else if (mScrollHelper != null) {
        mScrollHelper.setEnabled(false);
    }
    return handledEvent;
}
Body of Second Method:
{
    boolean handledEvent = true;
    boolean clearPressedItem = false;
    final int actionMasked = event.getActionMasked();
    switch(actionMasked) {
        case MotionEvent.ACTION_CANCEL:
            handledEvent = false;
            break;
        case MotionEvent.ACTION_UP:
            handledEvent = false;
        // $FALL-THROUGH$
        case MotionEvent.ACTION_MOVE:
            final int activeIndex = event.findPointerIndex(activePointerId);
            if (activeIndex < 0) {
                handledEvent = false;
                break;
            }
            final int x = (int) event.getX(activeIndex);
            final int y = (int) event.getY(activeIndex);
            final int position = pointToPosition(x, y);
            if (position == INVALID_POSITION) {
                clearPressedItem = true;
                break;
            }
            final View child = getChildAt(position - getFirstVisiblePosition());
            setPressedItem(child, position, x, y);
            handledEvent = true;
            if (actionMasked == MotionEvent.ACTION_UP) {
                clickPressedItem(child, position);
            }
            break;
    }
    // Failure to handle the event cancels forwarding.
    if (!handledEvent || clearPressedItem) {
        clearPressedItem();
    }
    // Manage automatic scrolling.
    if (handledEvent) {
        if (mScrollHelper == null) {
            mScrollHelper = new AbsListViewAutoScroller(this);
        }
        mScrollHelper.setEnabled(true);
        mScrollHelper.onTouch(this, event);
    } else if (mScrollHelper != null) {
        mScrollHelper.setEnabled(false);
    }
    return handledEvent;
}
------------------------
Find a silently evolved API code:android.net.LocalSocketImpl.close:COMMENT
Method Modifier: public      
Comment:/**
 * Closes the socket.
 *
 * @throws IOException
 */

Body of Frist Method:
{
    synchronized (LocalSocketImpl.this) {
        if ((fd == null) || (mFdCreatedInternally == false)) {
            fd = null;
            return;
        }
        try {
            Libcore.os.close(fd);
        } catch (ErrnoException e) {
            e.rethrowAsIOException();
        }
        fd = null;
    }
}
Body of Second Method:
{
    synchronized (LocalSocketImpl.this) {
        if ((fd == null) || (mFdCreatedInternally == false)) {
            fd = null;
            return;
        }
        try {
            Os.close(fd);
        } catch (ErrnoException e) {
            e.rethrowAsIOException();
        }
        fd = null;
    }
}
------------------------
Find a silently evolved API code:android.app.WallpaperManager.suggestDesiredDimensions:COMMENT
Method Modifier: public      
Comment:/**
 * For use only by the current home application, to specify the size of
 * wallpaper it would like to use.  This allows such applications to have
 * a virtual wallpaper that is larger than the physical screen, matching
 * the size of their workspace.
 *
 * <p>Note developers, who don't seem to be reading this.  This is
 * for <em>home screens</em> to tell what size wallpaper they would like.
 * Nobody else should be calling this!  Certainly not other non-home-screen
 * apps that change the wallpaper.  Those apps are supposed to
 * <b>retrieve</b> the suggested size so they can construct a wallpaper
 * that matches it.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#SET_WALLPAPER_HINTS}.
 *
 * @param minimumWidth Desired minimum width
 * @param minimumHeight Desired minimum height
 */

Body of Frist Method:
{
    try {
        if (sGlobals.mService == null) {
            Log.w(TAG, "WallpaperService not running");
        } else {
            sGlobals.mService.setDimensionHints(minimumWidth, minimumHeight);
        }
    } catch (RemoteException e) {
    // Ignore
    }
}
Body of Second Method:
{
    try {
        /**
         * The framework makes no attempt to limit the window size
         * to the maximum texture size. Any window larger than this
         * cannot be composited.
         *
         * Read maximum texture size from system property and scale down
         * minimumWidth and minimumHeight accordingly.
         */
        int maximumTextureSize;
        try {
            maximumTextureSize = SystemProperties.getInt("sys.max_texture_size", 0);
        } catch (Exception e) {
            maximumTextureSize = 0;
        }
        if (maximumTextureSize > 0) {
            if ((minimumWidth > maximumTextureSize) || (minimumHeight > maximumTextureSize)) {
                float aspect = (float) minimumHeight / (float) minimumWidth;
                if (minimumWidth > minimumHeight) {
                    minimumWidth = maximumTextureSize;
                    minimumHeight = (int) ((minimumWidth * aspect) + 0.5);
                } else {
                    minimumHeight = maximumTextureSize;
                    minimumWidth = (int) ((minimumHeight / aspect) + 0.5);
                }
            }
        }
        if (sGlobals.mService == null) {
            Log.w(TAG, "WallpaperService not running");
        } else {
            sGlobals.mService.setDimensionHints(minimumWidth, minimumHeight);
        }
    } catch (RemoteException e) {
    // Ignore
    }
}
------------------------
Find a silently evolved API code:android.content.RestrictionEntry.getTitle:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the user-visible title for the entry, if any.
 * @return the user-visible title for the entry, null if none was set earlier.
 */

Body of Frist Method:
{
    return title;
}
Body of Second Method:
{
    return mTitle;
}
------------------------
Find a silently evolved API code:android.graphics.Path.rewind:COMMENT
Method Modifier: public      
Comment:/**
 * Rewinds the path: clears any lines and curves from the path but
 * keeps the internal data structure for faster reuse.
 */

Body of Frist Method:
{
    isSimplePath = true;
    if (mDetectSimplePaths) {
        mLastDirection = null;
        if (rects != null)
            rects.setEmpty();
    }
    native_rewind(mNativePath);
}
Body of Second Method:
{
    isSimplePath = true;
    mLastDirection = null;
    if (rects != null)
        rects.setEmpty();
    native_rewind(mNativePath);
}
------------------------
Find a silently evolved API code:android.widget.SuggestionsAdapter.getDrawable:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Gets a drawable by URI, without using the cache.
 *
 * @return A drawable, or {@code null} if the drawable could not be loaded.
 */

Body of Frist Method:
{
    try {
        String scheme = uri.getScheme();
        if (ContentResolver.SCHEME_ANDROID_RESOURCE.equals(scheme)) {
            // Load drawables through Resources, to get the source density information
            OpenResourceIdResult r = mProviderContext.getContentResolver().getResourceId(uri);
            try {
                return r.r.getDrawable(r.id);
            } catch (Resources.NotFoundException ex) {
                throw new FileNotFoundException("Resource does not exist: " + uri);
            }
        } else {
            // Let the ContentResolver handle content and file URIs.
            InputStream stream = mProviderContext.getContentResolver().openInputStream(uri);
            if (stream == null) {
                throw new FileNotFoundException("Failed to open " + uri);
            }
            try {
                return Drawable.createFromStream(stream, null);
            } finally {
                try {
                    stream.close();
                } catch (IOException ex) {
                    Log.e(LOG_TAG, "Error closing icon stream for " + uri, ex);
                }
            }
        }
    } catch (FileNotFoundException fnfe) {
        Log.w(LOG_TAG, "Icon not found: " + uri + ", " + fnfe.getMessage());
        return null;
    }
}
Body of Second Method:
{
    try {
        String scheme = uri.getScheme();
        if (ContentResolver.SCHEME_ANDROID_RESOURCE.equals(scheme)) {
            // Load drawables through Resources, to get the source density information
            OpenResourceIdResult r = mProviderContext.getContentResolver().getResourceId(uri);
            try {
                return r.r.getDrawable(r.id, mContext.getTheme());
            } catch (Resources.NotFoundException ex) {
                throw new FileNotFoundException("Resource does not exist: " + uri);
            }
        } else {
            // Let the ContentResolver handle content and file URIs.
            InputStream stream = mProviderContext.getContentResolver().openInputStream(uri);
            if (stream == null) {
                throw new FileNotFoundException("Failed to open " + uri);
            }
            try {
                return Drawable.createFromStream(stream, null);
            } finally {
                try {
                    stream.close();
                } catch (IOException ex) {
                    Log.e(LOG_TAG, "Error closing icon stream for " + uri, ex);
                }
            }
        }
    } catch (FileNotFoundException fnfe) {
        Log.w(LOG_TAG, "Icon not found: " + uri + ", " + fnfe.getMessage());
        return null;
    }
}
------------------------
Find a silently evolved API code:android.view.InputQueue.sendInputEvent:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    ActiveInputEvent event = obtainActiveInputEvent(token, callback);
    int id;
    if (e instanceof KeyEvent) {
        id = nativeSendKeyEvent(mPtr, (KeyEvent) e, predispatch);
    } else {
        id = nativeSendMotionEvent(mPtr, (MotionEvent) e);
    }
    mActiveEventArray.put(id, event);
}
Body of Second Method:
{
    ActiveInputEvent event = obtainActiveInputEvent(token, callback);
    long id;
    if (e instanceof KeyEvent) {
        id = nativeSendKeyEvent(mPtr, (KeyEvent) e, predispatch);
    } else {
        id = nativeSendMotionEvent(mPtr, (MotionEvent) e);
    }
    mActiveEventArray.put(id, event);
}
------------------------
Find a silently evolved API code:android.net.Proxy.getProxy:COMMENT
Method Modifier: public      static      final       hidden      
Comment:/**
 * Return the proxy object to be used for the URL given as parameter.
 * @param ctx A Context used to get the settings for the proxy host.
 * @param url A URL to be accessed. Used to evaluate exclusion list.
 * @return Proxy (java.net) object containing the host name. If the
 * user did not set a hostname it returns the default host.
 * A null value means that no host is to be used.
 * {@hide}
 */

Body of Frist Method:
{
    String host = "";
    if (url != null) {
        URI uri = URI.create(url);
        host = uri.getHost();
    }
    if (!isLocalHost(host)) {
        if (sConnectivityManager == null) {
            sConnectivityManager = (ConnectivityManager) ctx.getSystemService(Context.CONNECTIVITY_SERVICE);
        }
        if (sConnectivityManager == null)
            return java.net.Proxy.NO_PROXY;
        ProxyProperties proxyProperties = sConnectivityManager.getProxy();
        if (proxyProperties != null) {
            if (!proxyProperties.isExcluded(host)) {
                return proxyProperties.makeProxy();
            }
        }
    }
    return java.net.Proxy.NO_PROXY;
}
Body of Second Method:
{
    String host = "";
    if ((url != null) && !isLocalHost(host)) {
        URI uri = URI.create(url);
        ProxySelector proxySelector = ProxySelector.getDefault();
        List<java.net.Proxy> proxyList = proxySelector.select(uri);
        if (proxyList.size() > 0) {
            return proxyList.get(0);
        }
    }
    return java.net.Proxy.NO_PROXY;
}
------------------------
Find a silently evolved API code:android.os.Process.myUid:COMMENT
Method Modifier: public      static      final       
Comment:/**
 * Returns the identifier of this process's uid.  This is the kernel uid
 * that the process is running under, which is the identity of its
 * app-specific sandbox.  It is different from {@link #myUserHandle} in that
 * a uid identifies a specific app sandbox in a specific user.
 */

Body of Frist Method:
{
    return Libcore.os.getuid();
}
Body of Second Method:
{
    return Os.getuid();
}
------------------------
Find a silently evolved API code:android.widget.Scroller.computeScrollOffset:COMMENT
Method Modifier: public      
Comment:/**
 * Call this when you want to know the new location.  If it returns true,
 * the animation is not yet finished.
 */

Body of Frist Method:
{
    if (mFinished) {
        return false;
    }
    int timePassed = (int) (AnimationUtils.currentAnimationTimeMillis() - mStartTime);
    if (timePassed < mDuration) {
        switch(mMode) {
            case SCROLL_MODE:
                float x = timePassed * mDurationReciprocal;
                if (mInterpolator == null)
                    x = viscousFluid(x);
                else
                    x = mInterpolator.getInterpolation(x);
                mCurrX = mStartX + Math.round(x * mDeltaX);
                mCurrY = mStartY + Math.round(x * mDeltaY);
                break;
            case FLING_MODE:
                final float t = (float) timePassed / mDuration;
                final int index = (int) (NB_SAMPLES * t);
                float distanceCoef = 1.f;
                float velocityCoef = 0.f;
                if (index < NB_SAMPLES) {
                    final float t_inf = (float) index / NB_SAMPLES;
                    final float t_sup = (float) (index + 1) / NB_SAMPLES;
                    final float d_inf = SPLINE_POSITION[index];
                    final float d_sup = SPLINE_POSITION[index + 1];
                    velocityCoef = (d_sup - d_inf) / (t_sup - t_inf);
                    distanceCoef = d_inf + (t - t_inf) * velocityCoef;
                }
                mCurrVelocity = velocityCoef * mDistance / mDuration * 1000.0f;
                mCurrX = mStartX + Math.round(distanceCoef * (mFinalX - mStartX));
                // Pin to mMinX <= mCurrX <= mMaxX
                mCurrX = Math.min(mCurrX, mMaxX);
                mCurrX = Math.max(mCurrX, mMinX);
                mCurrY = mStartY + Math.round(distanceCoef * (mFinalY - mStartY));
                // Pin to mMinY <= mCurrY <= mMaxY
                mCurrY = Math.min(mCurrY, mMaxY);
                mCurrY = Math.max(mCurrY, mMinY);
                if (mCurrX == mFinalX && mCurrY == mFinalY) {
                    mFinished = true;
                }
                break;
        }
    } else {
        mCurrX = mFinalX;
        mCurrY = mFinalY;
        mFinished = true;
    }
    return true;
}
Body of Second Method:
{
    if (mFinished) {
        return false;
    }
    int timePassed = (int) (AnimationUtils.currentAnimationTimeMillis() - mStartTime);
    if (timePassed < mDuration) {
        switch(mMode) {
            case SCROLL_MODE:
                final float x = mInterpolator.getInterpolation(timePassed * mDurationReciprocal);
                mCurrX = mStartX + Math.round(x * mDeltaX);
                mCurrY = mStartY + Math.round(x * mDeltaY);
                break;
            case FLING_MODE:
                final float t = (float) timePassed / mDuration;
                final int index = (int) (NB_SAMPLES * t);
                float distanceCoef = 1.f;
                float velocityCoef = 0.f;
                if (index < NB_SAMPLES) {
                    final float t_inf = (float) index / NB_SAMPLES;
                    final float t_sup = (float) (index + 1) / NB_SAMPLES;
                    final float d_inf = SPLINE_POSITION[index];
                    final float d_sup = SPLINE_POSITION[index + 1];
                    velocityCoef = (d_sup - d_inf) / (t_sup - t_inf);
                    distanceCoef = d_inf + (t - t_inf) * velocityCoef;
                }
                mCurrVelocity = velocityCoef * mDistance / mDuration * 1000.0f;
                mCurrX = mStartX + Math.round(distanceCoef * (mFinalX - mStartX));
                // Pin to mMinX <= mCurrX <= mMaxX
                mCurrX = Math.min(mCurrX, mMaxX);
                mCurrX = Math.max(mCurrX, mMinX);
                mCurrY = mStartY + Math.round(distanceCoef * (mFinalY - mStartY));
                // Pin to mMinY <= mCurrY <= mMaxY
                mCurrY = Math.min(mCurrY, mMaxY);
                mCurrY = Math.max(mCurrY, mMinY);
                if (mCurrX == mFinalX && mCurrY == mFinalY) {
                    mFinished = true;
                }
                break;
        }
    } else {
        mCurrX = mFinalX;
        mCurrY = mFinalY;
        mFinished = true;
    }
    return true;
}
------------------------
Find a silently evolved API code:android.os.Bundle.putIntegerArrayList:COMMENT
Method Modifier: public      
Comment:/**
 * Inserts an ArrayList<Integer> value into the mapping of this Bundle, replacing
 * any existing value for the given key.  Either key or value may be null.
 *
 * @param key a String, or null
 * @param value an ArrayList<Integer> object, or null
 */

Body of Frist Method:
{
    unparcel();
    mMap.put(key, value);
}
Body of Second Method:
{
    super.putIntegerArrayList(key, value);
}
------------------------
Find a silently evolved API code:android.animation.ValueAnimator.setDuration:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the length of the animation. The default duration is 300 milliseconds.
 *
 * @param duration The length of the animation, in milliseconds. This value cannot
 * be negative.
 * @return ValueAnimator The object called with setDuration(). This return
 * value makes it easier to compose statements together that construct and then set the
 * duration, as in <code>ValueAnimator.ofInt(0, 10).setDuration(500).start()</code>.
 */

Body of Frist Method:
{
    if (duration < 0) {
        throw new IllegalArgumentException("Animators cannot have negative duration: " + duration);
    }
    mUnscaledDuration = duration;
    mDuration = (long) (duration * sDurationScale);
    return this;
}
Body of Second Method:
{
    if (duration < 0) {
        throw new IllegalArgumentException("Animators cannot have negative duration: " + duration);
    }
    mUnscaledDuration = duration;
    updateScaledDuration();
    return this;
}
------------------------
Find a silently evolved API code:android.net.NetworkStats.findIndexHinted:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Find first stats index that matches the requested parameters, starting
 * search around the hinted index as an optimization.
 */

Body of Frist Method:
{
    for (int offset = 0; offset < size; offset++) {
        final int halfOffset = offset / 2;
        // search outwards from hint index, alternating forward and backward
        final int i;
        if (offset % 2 == 0) {
            i = (hintIndex + halfOffset) % size;
        } else {
            i = (size + hintIndex - halfOffset - 1) % size;
        }
        if (uid == this.uid[i] && set == this.set[i] && tag == this.tag[i] && Objects.equal(iface, this.iface[i])) {
            return i;
        }
    }
    return -1;
}
Body of Second Method:
{
    for (int offset = 0; offset < size; offset++) {
        final int halfOffset = offset / 2;
        // search outwards from hint index, alternating forward and backward
        final int i;
        if (offset % 2 == 0) {
            i = (hintIndex + halfOffset) % size;
        } else {
            i = (size + hintIndex - halfOffset - 1) % size;
        }
        if (uid == this.uid[i] && set == this.set[i] && tag == this.tag[i] && Objects.equals(iface, this.iface[i])) {
            return i;
        }
    }
    return -1;
}
------------------------
Find a silently evolved API code:android.view.ViewGroup.focusableViewAvailable:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (mParent != null && // getting focus
    (getDescendantFocusability() != FOCUS_BLOCK_DESCENDANTS) && // an ancestor of v; this will get checked for at ViewAncestor
    !(isFocused() && getDescendantFocusability() != FOCUS_AFTER_DESCENDANTS)) {
        mParent.focusableViewAvailable(v);
    }
}
Body of Second Method:
{
    if (mParent != null && // getting focus
    (getDescendantFocusability() != FOCUS_BLOCK_DESCENDANTS) && (isFocusableInTouchMode() || !shouldBlockFocusForTouchscreen()) && // an ancestor of v; this will get checked for at ViewAncestor
    !(isFocused() && getDescendantFocusability() != FOCUS_AFTER_DESCENDANTS)) {
        mParent.focusableViewAvailable(v);
    }
}
------------------------
Find a silently evolved API code:android.webkit.WebSyncManager.resetSync:COMMENT
<android.webkit.WebSyncManager: void resetSync()>
public      ->public      deprecated  
Method Modifier: public      deprecated  
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * resetSync() resets sync manager's timer
 */

Body of Frist Method:
{
    if (DebugFlags.WEB_SYNC_MANAGER) {
        Log.v(LOGTAG, "*** WebSyncManager resetSync ***");
    }
    if (mHandler == null) {
        return;
    }
    mHandler.removeMessages(SYNC_MESSAGE);
    Message msg = mHandler.obtainMessage(SYNC_MESSAGE);
    mHandler.sendMessageDelayed(msg, SYNC_LATER_INTERVAL);
}
Body of Second Method:
{
}
------------------------
Find a silently evolved API code:android.media.MediaPlayer.getTrackInfo:COMMENT
Method Modifier: public      
Comment:/**
 * Returns an array of track information.
 *
 * @return Array of track info. The total number of tracks is the array length.
 * Must be called again if an external timed text source has been added after any of the
 * addTimedTextSource methods are called.
 * @throws IllegalStateException if it is called in an invalid state.
 */

Body of Frist Method:
{
    TrackInfo[] trackInfo = getInbandTrackInfo();
    // add out-of-band tracks
    TrackInfo[] allTrackInfo = new TrackInfo[trackInfo.length + mOutOfBandSubtitleTracks.size()];
    System.arraycopy(trackInfo, 0, allTrackInfo, 0, trackInfo.length);
    int i = trackInfo.length;
    for (SubtitleTrack track : mOutOfBandSubtitleTracks) {
        allTrackInfo[i] = new TrackInfo(TrackInfo.MEDIA_TRACK_TYPE_SUBTITLE, track.getFormat());
        ++i;
    }
    return allTrackInfo;
}
Body of Second Method:
{
    TrackInfo[] trackInfo = getInbandTrackInfo();
    // add out-of-band tracks
    TrackInfo[] allTrackInfo = new TrackInfo[trackInfo.length + mOutOfBandSubtitleTracks.size()];
    System.arraycopy(trackInfo, 0, allTrackInfo, 0, trackInfo.length);
    int i = trackInfo.length;
    for (SubtitleTrack track : mOutOfBandSubtitleTracks) {
        int type = track.isTimedText() ? TrackInfo.MEDIA_TRACK_TYPE_TIMEDTEXT : TrackInfo.MEDIA_TRACK_TYPE_SUBTITLE;
        allTrackInfo[i] = new TrackInfo(type, track.getFormat());
        ++i;
    }
    return allTrackInfo;
}
------------------------
Find a silently evolved API code:android.view.accessibility.CaptioningManager.CaptionStyle.getCustomStyle:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    final CaptionStyle defStyle = CaptionStyle.DEFAULT_CUSTOM;
    final int foregroundColor = Secure.getInt(cr, Secure.ACCESSIBILITY_CAPTIONING_FOREGROUND_COLOR, defStyle.foregroundColor);
    final int backgroundColor = Secure.getInt(cr, Secure.ACCESSIBILITY_CAPTIONING_BACKGROUND_COLOR, defStyle.backgroundColor);
    final int edgeType = Secure.getInt(cr, Secure.ACCESSIBILITY_CAPTIONING_EDGE_TYPE, defStyle.edgeType);
    final int edgeColor = Secure.getInt(cr, Secure.ACCESSIBILITY_CAPTIONING_EDGE_COLOR, defStyle.edgeColor);
    String rawTypeface = Secure.getString(cr, Secure.ACCESSIBILITY_CAPTIONING_TYPEFACE);
    if (rawTypeface == null) {
        rawTypeface = defStyle.mRawTypeface;
    }
    return new CaptionStyle(foregroundColor, backgroundColor, edgeType, edgeColor, rawTypeface);
}
Body of Second Method:
{
    final CaptionStyle defStyle = CaptionStyle.DEFAULT_CUSTOM;
    final int foregroundColor = Secure.getInt(cr, Secure.ACCESSIBILITY_CAPTIONING_FOREGROUND_COLOR, defStyle.foregroundColor);
    final int backgroundColor = Secure.getInt(cr, Secure.ACCESSIBILITY_CAPTIONING_BACKGROUND_COLOR, defStyle.backgroundColor);
    final int edgeType = Secure.getInt(cr, Secure.ACCESSIBILITY_CAPTIONING_EDGE_TYPE, defStyle.edgeType);
    final int edgeColor = Secure.getInt(cr, Secure.ACCESSIBILITY_CAPTIONING_EDGE_COLOR, defStyle.edgeColor);
    final int windowColor = Secure.getInt(cr, Secure.ACCESSIBILITY_CAPTIONING_WINDOW_COLOR, defStyle.windowColor);
    String rawTypeface = Secure.getString(cr, Secure.ACCESSIBILITY_CAPTIONING_TYPEFACE);
    if (rawTypeface == null) {
        rawTypeface = defStyle.mRawTypeface;
    }
    return new CaptionStyle(foregroundColor, backgroundColor, edgeType, edgeColor, windowColor, rawTypeface);
}
------------------------
Find a silently evolved API code:android.media.MediaPlayer.TimeProvider.onPaused:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    synchronized (this) {
        if (DEBUG)
            Log.d(TAG, "onPaused: " + paused);
        if (mStopped) {
            // handle as seek if we were stopped
            scheduleNotification(NOTIFY_SEEK, 0);
        } else {
            // special handling if player disappeared
            mPausing = paused;
            scheduleNotification(REFRESH_AND_NOTIFY_TIME, 0);
        }
    }
}
Body of Second Method:
{
    synchronized (this) {
        if (DEBUG)
            Log.d(TAG, "onPaused: " + paused);
        if (mStopped) {
            // handle as seek if we were stopped
            mStopped = false;
            mSeeking = true;
            scheduleNotification(NOTIFY_SEEK, 0);
        } else {
            // special handling if player disappeared
            mPausing = paused;
            mSeeking = false;
            scheduleNotification(REFRESH_AND_NOTIFY_TIME, 0);
        }
    }
}
------------------------
Find a silently evolved API code:android.view.Window.setWindowAnimations:COMMENT
Method Modifier: public      
Comment:/**
 * Specify custom animations to use for the window, as per
 * {@link WindowManager.LayoutParams#windowAnimations
 * WindowManager.LayoutParams.windowAnimations}.  Providing anything besides
 * 0 here will override the animations the window would
 * normally retrieve from its theme.
 */

Body of Frist Method:
{
    final WindowManager.LayoutParams attrs = getAttributes();
    attrs.windowAnimations = resId;
    if (mCallback != null) {
        mCallback.onWindowAttributesChanged(attrs);
    }
}
Body of Second Method:
{
    final WindowManager.LayoutParams attrs = getAttributes();
    attrs.windowAnimations = resId;
    dispatchWindowAttributesChanged(attrs);
}
------------------------
Find a silently evolved API code:android.app.ActivityThread.performStopActivityInner:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Core implementation of stopping an activity.  Note this is a little
 * tricky because the server's meaning of stop is slightly different
 * than our client -- for the server, stop means to save state and give
 * it the result when it is done, but the window may still be visible.
 * For the client, we want to call onStop()/onStart() to indicate when
 * the activity's UI visibillity changes.
 */

Body of Frist Method:
{
    if (localLOGV)
        Slog.v(TAG, "Performing stop of " + r);
    Bundle state = null;
    if (r != null) {
        if (!keepShown && r.stopped) {
            if (r.activity.mFinished) {
                // if the activity isn't resumed.
                return;
            }
            RuntimeException e = new RuntimeException("Performing stop of activity that is not resumed: " + r.intent.getComponent().toShortString());
            Slog.e(TAG, e.getMessage(), e);
        }
        if (info != null) {
            try {
                // First create a thumbnail for the activity...
                // For now, don't create the thumbnail here; we are
                // doing that by doing a screen snapshot.
                // createThumbnailBitmap(r);
                info.thumbnail = null;
                info.description = r.activity.onCreateDescription();
            } catch (Exception e) {
                if (!mInstrumentation.onException(r.activity, e)) {
                    throw new RuntimeException("Unable to save state of activity " + r.intent.getComponent().toShortString() + ": " + e.toString(), e);
                }
            }
        }
        // Next have the activity save its current state and managed dialogs...
        if (!r.activity.mFinished && saveState) {
            if (r.state == null) {
                state = new Bundle();
                state.setAllowFds(false);
                mInstrumentation.callActivityOnSaveInstanceState(r.activity, state);
                r.state = state;
            } else {
                state = r.state;
            }
        }
        if (!keepShown) {
            try {
                // Now we are idle.
                r.activity.performStop();
            } catch (Exception e) {
                if (!mInstrumentation.onException(r.activity, e)) {
                    throw new RuntimeException("Unable to stop activity " + r.intent.getComponent().toShortString() + ": " + e.toString(), e);
                }
            }
            r.stopped = true;
        }
        r.paused = true;
    }
}
Body of Second Method:
{
    if (localLOGV)
        Slog.v(TAG, "Performing stop of " + r);
    if (r != null) {
        if (!keepShown && r.stopped) {
            if (r.activity.mFinished) {
                // if the activity isn't resumed.
                return;
            }
            RuntimeException e = new RuntimeException("Performing stop of activity that is not resumed: " + r.intent.getComponent().toShortString());
            Slog.e(TAG, e.getMessage(), e);
        }
        if (info != null) {
            try {
                // First create a thumbnail for the activity...
                // For now, don't create the thumbnail here; we are
                // doing that by doing a screen snapshot.
                info.description = r.activity.onCreateDescription();
            } catch (Exception e) {
                if (!mInstrumentation.onException(r.activity, e)) {
                    throw new RuntimeException("Unable to save state of activity " + r.intent.getComponent().toShortString() + ": " + e.toString(), e);
                }
            }
        }
        // Next have the activity save its current state and managed dialogs...
        if (!r.activity.mFinished && saveState) {
            if (r.state == null) {
                callCallActivityOnSaveInstanceState(r);
            }
        }
        if (!keepShown) {
            try {
                // Now we are idle.
                r.activity.performStop();
            } catch (Exception e) {
                if (!mInstrumentation.onException(r.activity, e)) {
                    throw new RuntimeException("Unable to stop activity " + r.intent.getComponent().toShortString() + ": " + e.toString(), e);
                }
            }
            r.stopped = true;
        }
        r.paused = true;
    }
}
------------------------
Find a silently evolved API code:android.hardware.SensorManager.getRotationMatrixFromVector:COMMENT
Method Modifier: public      static      
Comment:/**
 * Helper function to convert a rotation vector to a rotation matrix.
 * Given a rotation vector (presumably from a ROTATION_VECTOR sensor), returns a
 * 9  or 16 element rotation matrix in the array R.  R must have length 9 or 16.
 * If R.length == 9, the following matrix is returned:
 * <pre>
 * /  R[ 0]   R[ 1]   R[ 2]   \
 * |  R[ 3]   R[ 4]   R[ 5]   |
 * \  R[ 6]   R[ 7]   R[ 8]   /
 * </pre>
 * If R.length == 16, the following matrix is returned:
 * <pre>
 * /  R[ 0]   R[ 1]   R[ 2]   0  \
 * |  R[ 4]   R[ 5]   R[ 6]   0  |
 * |  R[ 8]   R[ 9]   R[10]   0  |
 * \  0       0       0       1  /
 * </pre>
 * @param rotationVector the rotation vector to convert
 * @param R an array of floats in which to store the rotation matrix
 */

Body of Frist Method:
{
    float q0;
    float q1 = rotationVector[0];
    float q2 = rotationVector[1];
    float q3 = rotationVector[2];
    if (rotationVector.length == 4) {
        q0 = rotationVector[3];
    } else {
        q0 = 1 - q1 * q1 - q2 * q2 - q3 * q3;
        q0 = (q0 > 0) ? (float) Math.sqrt(q0) : 0;
    }
    float sq_q1 = 2 * q1 * q1;
    float sq_q2 = 2 * q2 * q2;
    float sq_q3 = 2 * q3 * q3;
    float q1_q2 = 2 * q1 * q2;
    float q3_q0 = 2 * q3 * q0;
    float q1_q3 = 2 * q1 * q3;
    float q2_q0 = 2 * q2 * q0;
    float q2_q3 = 2 * q2 * q3;
    float q1_q0 = 2 * q1 * q0;
    if (R.length == 9) {
        R[0] = 1 - sq_q2 - sq_q3;
        R[1] = q1_q2 - q3_q0;
        R[2] = q1_q3 + q2_q0;
        R[3] = q1_q2 + q3_q0;
        R[4] = 1 - sq_q1 - sq_q3;
        R[5] = q2_q3 - q1_q0;
        R[6] = q1_q3 - q2_q0;
        R[7] = q2_q3 + q1_q0;
        R[8] = 1 - sq_q1 - sq_q2;
    } else if (R.length == 16) {
        R[0] = 1 - sq_q2 - sq_q3;
        R[1] = q1_q2 - q3_q0;
        R[2] = q1_q3 + q2_q0;
        R[3] = 0.0f;
        R[4] = q1_q2 + q3_q0;
        R[5] = 1 - sq_q1 - sq_q3;
        R[6] = q2_q3 - q1_q0;
        R[7] = 0.0f;
        R[8] = q1_q3 - q2_q0;
        R[9] = q2_q3 + q1_q0;
        R[10] = 1 - sq_q1 - sq_q2;
        R[11] = 0.0f;
        R[12] = R[13] = R[14] = 0.0f;
        R[15] = 1.0f;
    }
}
Body of Second Method:
{
    float q0;
    float q1 = rotationVector[0];
    float q2 = rotationVector[1];
    float q3 = rotationVector[2];
    if (rotationVector.length >= 4) {
        q0 = rotationVector[3];
    } else {
        q0 = 1 - q1 * q1 - q2 * q2 - q3 * q3;
        q0 = (q0 > 0) ? (float) Math.sqrt(q0) : 0;
    }
    float sq_q1 = 2 * q1 * q1;
    float sq_q2 = 2 * q2 * q2;
    float sq_q3 = 2 * q3 * q3;
    float q1_q2 = 2 * q1 * q2;
    float q3_q0 = 2 * q3 * q0;
    float q1_q3 = 2 * q1 * q3;
    float q2_q0 = 2 * q2 * q0;
    float q2_q3 = 2 * q2 * q3;
    float q1_q0 = 2 * q1 * q0;
    if (R.length == 9) {
        R[0] = 1 - sq_q2 - sq_q3;
        R[1] = q1_q2 - q3_q0;
        R[2] = q1_q3 + q2_q0;
        R[3] = q1_q2 + q3_q0;
        R[4] = 1 - sq_q1 - sq_q3;
        R[5] = q2_q3 - q1_q0;
        R[6] = q1_q3 - q2_q0;
        R[7] = q2_q3 + q1_q0;
        R[8] = 1 - sq_q1 - sq_q2;
    } else if (R.length == 16) {
        R[0] = 1 - sq_q2 - sq_q3;
        R[1] = q1_q2 - q3_q0;
        R[2] = q1_q3 + q2_q0;
        R[3] = 0.0f;
        R[4] = q1_q2 + q3_q0;
        R[5] = 1 - sq_q1 - sq_q3;
        R[6] = q2_q3 - q1_q0;
        R[7] = 0.0f;
        R[8] = q1_q3 - q2_q0;
        R[9] = q2_q3 + q1_q0;
        R[10] = 1 - sq_q1 - sq_q2;
        R[11] = 0.0f;
        R[12] = R[13] = R[14] = 0.0f;
        R[15] = 1.0f;
    }
}
------------------------
Find a silently evolved API code:android.os.Bundle.hasFileDescriptors:COMMENT
Method Modifier: public      
Comment:/**
 * Reports whether the bundle contains any parcelled file descriptors.
 */

Body of Frist Method:
{
    if (!mFdsKnown) {
        // keep going until we find one or run out of data
        boolean fdFound = false;
        if (mParcelledData != null) {
            if (mParcelledData.hasFileDescriptors()) {
                fdFound = true;
            }
        } else {
            // It's been unparcelled, so we need to walk the map
            for (int i = mMap.size() - 1; i >= 0; i--) {
                Object obj = mMap.valueAt(i);
                if (obj instanceof Parcelable) {
                    if ((((Parcelable) obj).describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0) {
                        fdFound = true;
                        break;
                    }
                } else if (obj instanceof Parcelable[]) {
                    Parcelable[] array = (Parcelable[]) obj;
                    for (int n = array.length - 1; n >= 0; n--) {
                        if ((array[n].describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0) {
                            fdFound = true;
                            break;
                        }
                    }
                } else if (obj instanceof SparseArray) {
                    SparseArray<? extends Parcelable> array = (SparseArray<? extends Parcelable>) obj;
                    for (int n = array.size() - 1; n >= 0; n--) {
                        if ((array.get(n).describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0) {
                            fdFound = true;
                            break;
                        }
                    }
                } else if (obj instanceof ArrayList) {
                    ArrayList array = (ArrayList) obj;
                    // Parcelables; only look inside for Parcelables
                    if ((array.size() > 0) && (array.get(0) instanceof Parcelable)) {
                        for (int n = array.size() - 1; n >= 0; n--) {
                            Parcelable p = (Parcelable) array.get(n);
                            if (p != null && ((p.describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0)) {
                                fdFound = true;
                                break;
                            }
                        }
                    }
                }
            }
        }
        mHasFds = fdFound;
        mFdsKnown = true;
    }
    return mHasFds;
}
Body of Second Method:
{
    if (!mFdsKnown) {
        // keep going until we find one or run out of data
        boolean fdFound = false;
        if (mParcelledData != null) {
            if (mParcelledData.hasFileDescriptors()) {
                fdFound = true;
            }
        } else {
            // It's been unparcelled, so we need to walk the map
            for (int i = mMap.size() - 1; i >= 0; i--) {
                Object obj = mMap.valueAt(i);
                if (obj instanceof Parcelable) {
                    if ((((Parcelable) obj).describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0) {
                        fdFound = true;
                        break;
                    }
                } else if (obj instanceof Parcelable[]) {
                    Parcelable[] array = (Parcelable[]) obj;
                    for (int n = array.length - 1; n >= 0; n--) {
                        if ((array[n].describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0) {
                            fdFound = true;
                            break;
                        }
                    }
                } else if (obj instanceof SparseArray) {
                    SparseArray<? extends Parcelable> array = (SparseArray<? extends Parcelable>) obj;
                    for (int n = array.size() - 1; n >= 0; n--) {
                        if ((array.valueAt(n).describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0) {
                            fdFound = true;
                            break;
                        }
                    }
                } else if (obj instanceof ArrayList) {
                    ArrayList array = (ArrayList) obj;
                    // Parcelables; only look inside for Parcelables
                    if (!array.isEmpty() && (array.get(0) instanceof Parcelable)) {
                        for (int n = array.size() - 1; n >= 0; n--) {
                            Parcelable p = (Parcelable) array.get(n);
                            if (p != null && ((p.describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0)) {
                                fdFound = true;
                                break;
                            }
                        }
                    }
                }
            }
        }
        mHasFds = fdFound;
        mFdsKnown = true;
    }
    return mHasFds;
}
------------------------
Find a silently evolved API code:android.os.ParcelFileDescriptor.getStatSize:COMMENT
Method Modifier: public      
Comment:/**
 * Return the total size of the file representing this fd, as determined by
 * {@code stat()}. Returns -1 if the fd is not a file.
 */

Body of Frist Method:
{
    if (mWrapped != null) {
        return mWrapped.getStatSize();
    } else {
        try {
            final StructStat st = Libcore.os.fstat(mFd);
            if (S_ISREG(st.st_mode) || S_ISLNK(st.st_mode)) {
                return st.st_size;
            } else {
                return -1;
            }
        } catch (ErrnoException e) {
            Log.w(TAG, "fstat() failed: " + e);
            return -1;
        }
    }
}
Body of Second Method:
{
    if (mWrapped != null) {
        return mWrapped.getStatSize();
    } else {
        try {
            final StructStat st = Os.fstat(mFd);
            if (S_ISREG(st.st_mode) || S_ISLNK(st.st_mode)) {
                return st.st_size;
            } else {
                return -1;
            }
        } catch (ErrnoException e) {
            Log.w(TAG, "fstat() failed: " + e);
            return -1;
        }
    }
}
------------------------
Find a silently evolved API code:android.view.Surface.unlockCanvasAndPost:COMMENT
Method Modifier: public      
Comment:/**
 * Posts the new contents of the {@link Canvas} to the surface and
 * releases the {@link Canvas}.
 *
 * @param canvas The canvas previously obtained from {@link #lockCanvas}.
 */

Body of Frist Method:
{
    if (canvas != mCanvas) {
        throw new IllegalArgumentException("canvas object must be the same instance that " + "was previously returned by lockCanvas");
    }
    synchronized (mLock) {
        checkNotReleasedLocked();
        if (mNativeObject != mLockedObject) {
            Log.w(TAG, "WARNING: Surface's mNativeObject (0x" + Integer.toHexString(mNativeObject) + ") != mLockedObject (0x" + Integer.toHexString(mLockedObject) + ")");
        }
        if (mLockedObject == 0) {
            throw new IllegalStateException("Surface was not locked");
        }
        nativeUnlockCanvasAndPost(mLockedObject, canvas);
        nativeRelease(mLockedObject);
        mLockedObject = 0;
    }
}
Body of Second Method:
{
    if (canvas != mCanvas) {
        throw new IllegalArgumentException("canvas object must be the same instance that " + "was previously returned by lockCanvas");
    }
    synchronized (mLock) {
        checkNotReleasedLocked();
        if (mNativeObject != mLockedObject) {
            Log.w(TAG, "WARNING: Surface's mNativeObject (0x" + Long.toHexString(mNativeObject) + ") != mLockedObject (0x" + Long.toHexString(mLockedObject) + ")");
        }
        if (mLockedObject == 0) {
            throw new IllegalStateException("Surface was not locked");
        }
        try {
            nativeUnlockCanvasAndPost(mLockedObject, canvas);
        } finally {
            nativeRelease(mLockedObject);
            mLockedObject = 0;
        }
    }
}
------------------------
Find a silently evolved API code:android.view.MotionEvent.axisFromString:COMMENT
Method Modifier: public      static      
Comment:/**
 * Gets an axis by its symbolic name such as "AXIS_X" or an
 * equivalent numeric constant such as "42".
 *
 * @param symbolicName The symbolic name of the axis.
 * @return The axis or -1 if not found.
 * @see KeyEvent#keyCodeToString(int)
 */

Body of Frist Method:
{
    if (symbolicName == null) {
        throw new IllegalArgumentException("symbolicName must not be null");
    }
    final int count = AXIS_SYMBOLIC_NAMES.size();
    for (int i = 0; i < count; i++) {
        if (symbolicName.equals(AXIS_SYMBOLIC_NAMES.valueAt(i))) {
            return i;
        }
    }
    try {
        return Integer.parseInt(symbolicName, 10);
    } catch (NumberFormatException ex) {
        return -1;
    }
}
Body of Second Method:
{
    if (symbolicName.startsWith(LABEL_PREFIX)) {
        symbolicName = symbolicName.substring(LABEL_PREFIX.length());
        int axis = nativeAxisFromString(symbolicName);
        if (axis >= 0) {
            return axis;
        }
    }
    try {
        return Integer.parseInt(symbolicName, 10);
    } catch (NumberFormatException ex) {
        return -1;
    }
}
------------------------
Find a silently evolved API code:android.webkit.WebSyncManager.sync:COMMENT
<android.webkit.WebSyncManager: void sync()>
public      ->public      deprecated  
Method Modifier: public      deprecated  
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * sync() forces sync manager to sync now
 */

Body of Frist Method:
{
    if (DebugFlags.WEB_SYNC_MANAGER) {
        Log.v(LOGTAG, "*** WebSyncManager sync ***");
    }
    if (mHandler == null) {
        return;
    }
    mHandler.removeMessages(SYNC_MESSAGE);
    Message msg = mHandler.obtainMessage(SYNC_MESSAGE);
    mHandler.sendMessageDelayed(msg, SYNC_NOW_INTERVAL);
}
Body of Second Method:
{
}
------------------------
Find a silently evolved API code:android.animation.PropertyValuesHolder.getPropertyFunction:COMMENT
Method Modifier: private     
Comment:/**
 * Determine the setter or getter function using the JavaBeans convention of setFoo or
 * getFoo for a property named 'foo'. This function figures out what the name of the
 * function should be and uses reflection to find the Method with that name on the
 * target object.
 *
 * @param targetClass The class to search for the method
 * @param prefix "set" or "get", depending on whether we need a setter or getter.
 * @param valueType The type of the parameter (in the case of a setter). This type
 * is derived from the values set on this PropertyValuesHolder. This type is used as
 * a first guess at the parameter type, but we check for methods with several different
 * types to avoid problems with slight mis-matches between supplied values and actual
 * value types used on the setter.
 * @return Method the method associated with mPropertyName.
 */

Body of Frist Method:
{
    // TODO: faster implementation...
    Method returnVal = null;
    String methodName = getMethodName(prefix, mPropertyName);
    Class[] args = null;
    if (valueType == null) {
        try {
            returnVal = targetClass.getMethod(methodName, args);
        } catch (NoSuchMethodException e) {
        // Swallow the error, log it later
        }
    } else {
        args = new Class[1];
        Class[] typeVariants;
        if (mValueType.equals(Float.class)) {
            typeVariants = FLOAT_VARIANTS;
        } else if (mValueType.equals(Integer.class)) {
            typeVariants = INTEGER_VARIANTS;
        } else if (mValueType.equals(Double.class)) {
            typeVariants = DOUBLE_VARIANTS;
        } else {
            typeVariants = new Class[1];
            typeVariants[0] = mValueType;
        }
        for (Class typeVariant : typeVariants) {
            args[0] = typeVariant;
            try {
                returnVal = targetClass.getMethod(methodName, args);
                // change the value type to suit
                mValueType = typeVariant;
                return returnVal;
            } catch (NoSuchMethodException e) {
            // Swallow the error and keep trying other variants
            }
        }
    // If we got here, then no appropriate function was found
    }
    if (returnVal == null) {
        Log.w("PropertyValuesHolder", "Method " + getMethodName(prefix, mPropertyName) + "() with type " + mValueType + " not found on target class " + targetClass);
    }
    return returnVal;
}
Body of Second Method:
{
    // TODO: faster implementation...
    Method returnVal = null;
    String methodName = getMethodName(prefix, mPropertyName);
    Class[] args = null;
    if (valueType == null) {
        try {
            returnVal = targetClass.getMethod(methodName, args);
        } catch (NoSuchMethodException e) {
        // Swallow the error, log it later
        }
    } else {
        args = new Class[1];
        Class[] typeVariants;
        if (valueType.equals(Float.class)) {
            typeVariants = FLOAT_VARIANTS;
        } else if (valueType.equals(Integer.class)) {
            typeVariants = INTEGER_VARIANTS;
        } else if (valueType.equals(Double.class)) {
            typeVariants = DOUBLE_VARIANTS;
        } else {
            typeVariants = new Class[1];
            typeVariants[0] = valueType;
        }
        for (Class typeVariant : typeVariants) {
            args[0] = typeVariant;
            try {
                returnVal = targetClass.getMethod(methodName, args);
                if (mConverter == null) {
                    // change the value type to suit
                    mValueType = typeVariant;
                }
                return returnVal;
            } catch (NoSuchMethodException e) {
            // Swallow the error and keep trying other variants
            }
        }
    // If we got here, then no appropriate function was found
    }
    if (returnVal == null) {
        Log.w("PropertyValuesHolder", "Method " + getMethodName(prefix, mPropertyName) + "() with type " + valueType + " not found on target class " + targetClass);
    }
    return returnVal;
}
------------------------
Find a silently evolved API code:android.media.SubtitleTrack.show:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (mVisible) {
        return;
    }
    mVisible = true;
    getRenderingWidget().setVisible(true);
    if (mTimeProvider != null) {
        mTimeProvider.scheduleUpdate(this);
    }
}
Body of Second Method:
{
    if (mVisible) {
        return;
    }
    mVisible = true;
    RenderingWidget renderingWidget = getRenderingWidget();
    if (renderingWidget != null) {
        renderingWidget.setVisible(true);
    }
    if (mTimeProvider != null) {
        mTimeProvider.scheduleUpdate(this);
    }
}
------------------------
Find a silently evolved API code:android.widget.CalendarView.getSelectedWeekBackgroundColor:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the background color for the selected week.
 *
 * @return The week background color.
 *
 * @attr ref android.R.styleable#CalendarView_selectedWeekBackgroundColor
 */

Body of Frist Method:
{
    return mSelectedWeekBackgroundColor;
}
Body of Second Method:
{
    return mDelegate.getSelectedWeekBackgroundColor();
}
------------------------
Find a silently evolved API code:android.util.Patterns.concatGroups:COMMENT
Method Modifier: public      static      final       
Comment:/**
 * Convenience method to take all of the non-null matching groups in a
 * regex Matcher and return them as a concatenated string.
 *
 * @param matcher      The Matcher object from which grouped text will
 * be extracted
 *
 * @return             A String comprising all of the non-null matched
 * groups concatenated together
 */

Body of Frist Method:
{
    StringBuilder b = new StringBuilder();
    final int numGroups = matcher.groupCount();
    for (int i = 1; i <= numGroups; i++) {
        String s = matcher.group(i);
        System.err.println("Group(" + i + ") : " + s);
        if (s != null) {
            b.append(s);
        }
    }
    return b.toString();
}
Body of Second Method:
{
    StringBuilder b = new StringBuilder();
    final int numGroups = matcher.groupCount();
    for (int i = 1; i <= numGroups; i++) {
        String s = matcher.group(i);
        if (s != null) {
            b.append(s);
        }
    }
    return b.toString();
}
------------------------
Find a silently evolved API code:android.widget.AbsListView.smoothScrollToPosition:COMMENT
Method Modifier: public      
Comment:/**
 * Smoothly scroll to the specified adapter position. The view will
 * scroll such that the indicated position is displayed.
 * @param position Scroll to this adapter position.
 */

Body of Frist Method:
{
    if (mPositionScroller == null) {
        mPositionScroller = new PositionScroller();
    }
    mPositionScroller.start(position);
}
Body of Second Method:
{
    if (mPositionScroller == null) {
        mPositionScroller = createPositionScroller();
    }
    mPositionScroller.start(position);
}
------------------------
Find a silently evolved API code:android.os.PowerManager.WakeLock.setWorkSource:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the work source associated with the wake lock.
 * <p>
 * The work source is used to determine on behalf of which application
 * the wake lock is being held.  This is useful in the case where a
 * service is performing work on behalf of an application so that the
 * cost of that work can be accounted to the application.
 * </p>
 *
 * @param ws The work source, or null if none.
 */

Body of Frist Method:
{
    synchronized (mToken) {
        if (ws != null && ws.size() == 0) {
            ws = null;
        }
        final boolean changed;
        if (ws == null) {
            changed = mWorkSource != null;
            mWorkSource = null;
        } else if (mWorkSource == null) {
            changed = true;
            mWorkSource = new WorkSource(ws);
        } else {
            changed = mWorkSource.diff(ws);
            if (changed) {
                mWorkSource.set(ws);
            }
        }
        if (changed && mHeld) {
            try {
                mService.updateWakeLockWorkSource(mToken, mWorkSource);
            } catch (RemoteException e) {
            }
        }
    }
}
Body of Second Method:
{
    synchronized (mToken) {
        if (ws != null && ws.size() == 0) {
            ws = null;
        }
        final boolean changed;
        if (ws == null) {
            changed = mWorkSource != null;
            mWorkSource = null;
        } else if (mWorkSource == null) {
            changed = true;
            mWorkSource = new WorkSource(ws);
        } else {
            changed = mWorkSource.diff(ws);
            if (changed) {
                mWorkSource.set(ws);
            }
        }
        if (changed && mHeld) {
            try {
                mService.updateWakeLockWorkSource(mToken, mWorkSource, mHistoryTag);
            } catch (RemoteException e) {
            }
        }
    }
}
------------------------
Find a silently evolved API code:android.view.accessibility.AccessibilityEvent.setSealed:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets if this instance is sealed.
 *
 * @param sealed Whether is sealed.
 *
 * @hide
 */

Body of Frist Method:
{
    super.setSealed(sealed);
    List<AccessibilityRecord> records = mRecords;
    final int recordCount = records.size();
    for (int i = 0; i < recordCount; i++) {
        AccessibilityRecord record = records.get(i);
        record.setSealed(sealed);
    }
}
Body of Second Method:
{
    super.setSealed(sealed);
    final List<AccessibilityRecord> records = mRecords;
    if (records != null) {
        final int recordCount = records.size();
        for (int i = 0; i < recordCount; i++) {
            AccessibilityRecord record = records.get(i);
            record.setSealed(sealed);
        }
    }
}
------------------------
Find a silently evolved API code:android.graphics.drawable.GradientDrawable.setGradientRadius:COMMENT
Method Modifier: public      
Comment:/**
 * <p>Sets the radius of the gradient. The radius is honored only when the
 * gradient type is set to {@link #RADIAL_GRADIENT}.</p>
 * <p><strong>Note</strong>: changing this property will affect all instances
 * of a drawable loaded from a resource. It is recommended to invoke
 * {@link #mutate()} before changing this property.</p>
 *
 * @param gradientRadius The radius of the gradient in pixels
 *
 * @see #mutate()
 * @see #setGradientType(int)
 */

Body of Frist Method:
{
    mGradientState.setGradientRadius(gradientRadius);
    mRectIsDirty = true;
    invalidateSelf();
}
Body of Second Method:
{
    mGradientState.setGradientRadius(gradientRadius, TypedValue.COMPLEX_UNIT_PX);
    mGradientIsDirty = true;
    invalidateSelf();
}
------------------------
Find a silently evolved API code:android.graphics.Matrix.preConcat:COMMENT
Method Modifier: public      
Comment:/**
 * Preconcats the matrix with the specified matrix.
 * M' = M * other
 */

Body of Frist Method:
{
    return native_preConcat(native_instance, other.native_instance);
}
Body of Second Method:
{
    native_preConcat(native_instance, other.native_instance);
    return true;
}
------------------------
Find a silently evolved API code:android.view.accessibility.AccessibilityNodeInfo.clear:COMMENT
Method Modifier: private     
Comment:/**
 * Clears the state of this instance.
 */

Body of Frist Method:
{
    mSealed = false;
    mSourceNodeId = ROOT_NODE_ID;
    mParentNodeId = ROOT_NODE_ID;
    mLabelForId = ROOT_NODE_ID;
    mLabeledById = ROOT_NODE_ID;
    mWindowId = UNDEFINED;
    mConnectionId = UNDEFINED;
    mMovementGranularities = 0;
    mChildNodeIds.clear();
    mBoundsInParent.set(0, 0, 0, 0);
    mBoundsInScreen.set(0, 0, 0, 0);
    mBooleanProperties = 0;
    mPackageName = null;
    mClassName = null;
    mText = null;
    mContentDescription = null;
    mViewIdResourceName = null;
    mActions = 0;
    mTextSelectionStart = UNDEFINED;
    mTextSelectionEnd = UNDEFINED;
    mInputType = InputType.TYPE_NULL;
    mLiveRegion = View.ACCESSIBILITY_LIVE_REGION_NONE;
    if (mExtras != null) {
        mExtras.clear();
    }
    if (mRangeInfo != null) {
        mRangeInfo.recycle();
        mRangeInfo = null;
    }
    if (mCollectionInfo != null) {
        mCollectionInfo.recycle();
        mCollectionInfo = null;
    }
    if (mCollectionItemInfo != null) {
        mCollectionItemInfo.recycle();
        mCollectionItemInfo = null;
    }
}
Body of Second Method:
{
    mSealed = false;
    mSourceNodeId = ROOT_NODE_ID;
    mParentNodeId = ROOT_NODE_ID;
    mLabelForId = ROOT_NODE_ID;
    mLabeledById = ROOT_NODE_ID;
    mWindowId = UNDEFINED_ITEM_ID;
    mConnectionId = UNDEFINED_CONNECTION_ID;
    mMaxTextLength = -1;
    mMovementGranularities = 0;
    if (mChildNodeIds != null) {
        mChildNodeIds.clear();
    }
    mBoundsInParent.set(0, 0, 0, 0);
    mBoundsInScreen.set(0, 0, 0, 0);
    mBooleanProperties = 0;
    mPackageName = null;
    mClassName = null;
    mText = null;
    mError = null;
    mContentDescription = null;
    mViewIdResourceName = null;
    if (mActions != null) {
        mActions.clear();
    }
    mTextSelectionStart = UNDEFINED_SELECTION_INDEX;
    mTextSelectionEnd = UNDEFINED_SELECTION_INDEX;
    mInputType = InputType.TYPE_NULL;
    mLiveRegion = View.ACCESSIBILITY_LIVE_REGION_NONE;
    if (mExtras != null) {
        mExtras.clear();
    }
    if (mRangeInfo != null) {
        mRangeInfo.recycle();
        mRangeInfo = null;
    }
    if (mCollectionInfo != null) {
        mCollectionInfo.recycle();
        mCollectionInfo = null;
    }
    if (mCollectionItemInfo != null) {
        mCollectionItemInfo.recycle();
        mCollectionItemInfo = null;
    }
}
------------------------
Find a silently evolved API code:android.text.Layout.getLineMax:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the unsigned horizontal extent of the specified line, including
 * leading margin indent, but excluding trailing whitespace.
 */

Body of Frist Method:
{
    float margin = getParagraphLeadingMargin(line);
    float signedExtent = getLineExtent(line, false);
    return margin + signedExtent >= 0 ? signedExtent : -signedExtent;
}
Body of Second Method:
{
    float margin = getParagraphLeadingMargin(line);
    float signedExtent = getLineExtent(line, false);
    return margin + (signedExtent >= 0 ? signedExtent : -signedExtent);
}
------------------------
Find a silently evolved API code:android.graphics.ColorMatrix.setConcat:COMMENT
Method Modifier: public      
Comment:/**
 * Set this colormatrix to the concatenation of the two specified
 * colormatrices, such that the resulting colormatrix has the same effect
 * as applying matB and then applying matA. It is legal for either matA or
 * matB to be the same colormatrix as this.
 */

Body of Frist Method:
{
    float[] tmp = null;
    if (matA == this || matB == this) {
        tmp = new float[20];
    } else {
        tmp = mArray;
    }
    final float[] a = matA.mArray;
    final float[] b = matB.mArray;
    int index = 0;
    for (int j = 0; j < 20; j += 5) {
        for (int i = 0; i < 4; i++) {
            tmp[index++] = a[j + 0] * b[i + 0] + a[j + 1] * b[i + 5] + a[j + 2] * b[i + 10] + a[j + 3] * b[i + 15];
        }
        tmp[index++] = a[j + 0] * b[4] + a[j + 1] * b[9] + a[j + 2] * b[14] + a[j + 3] * b[19] + a[j + 4];
    }
    if (tmp != mArray) {
        System.arraycopy(tmp, 0, mArray, 0, 20);
    }
}
Body of Second Method:
{
    float[] tmp;
    if (matA == this || matB == this) {
        tmp = new float[20];
    } else {
        tmp = mArray;
    }
    final float[] a = matA.mArray;
    final float[] b = matB.mArray;
    int index = 0;
    for (int j = 0; j < 20; j += 5) {
        for (int i = 0; i < 4; i++) {
            tmp[index++] = a[j + 0] * b[i + 0] + a[j + 1] * b[i + 5] + a[j + 2] * b[i + 10] + a[j + 3] * b[i + 15];
        }
        tmp[index++] = a[j + 0] * b[4] + a[j + 1] * b[9] + a[j + 2] * b[14] + a[j + 3] * b[19] + a[j + 4];
    }
    if (tmp != mArray) {
        System.arraycopy(tmp, 0, mArray, 0, 20);
    }
}
------------------------
Find a silently evolved API code:android.os.Parcel.writeArrayMapInternal:COMMENT
Method Modifier: default     
Comment:/* package */

Body of Frist Method:
{
    if (val == null) {
        writeInt(-1);
        return;
    }
    final int N = val.size();
    writeInt(N);
    if (DEBUG_ARRAY_MAP) {
        RuntimeException here = new RuntimeException("here");
        here.fillInStackTrace();
        Log.d(TAG, "Writing " + N + " ArrayMap entries", here);
    }
    for (int i = 0; i < N; i++) {
        if (DEBUG_ARRAY_MAP)
            Log.d(TAG, "  Write #" + i + ": key=0x" + (val.keyAt(i) != null ? val.keyAt(i).hashCode() : 0) + " " + val.keyAt(i));
        writeValue(val.keyAt(i));
        writeValue(val.valueAt(i));
    }
}
Body of Second Method:
{
    if (val == null) {
        writeInt(-1);
        return;
    }
    final int N = val.size();
    writeInt(N);
    if (DEBUG_ARRAY_MAP) {
        RuntimeException here = new RuntimeException("here");
        here.fillInStackTrace();
        Log.d(TAG, "Writing " + N + " ArrayMap entries", here);
    }
    int startPos;
    for (int i = 0; i < N; i++) {
        if (DEBUG_ARRAY_MAP)
            startPos = dataPosition();
        writeString(val.keyAt(i));
        writeValue(val.valueAt(i));
        if (DEBUG_ARRAY_MAP)
            Log.d(TAG, "  Write #" + i + " " + (dataPosition() - startPos) + " bytes: key=0x" + Integer.toHexString(val.keyAt(i) != null ? val.keyAt(i).hashCode() : 0) + " " + val.keyAt(i));
    }
}
------------------------
Find a silently evolved API code:android.view.ViewGroup.dispatchDraw:COMMENT
Method Modifier: protected   
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    final int count = mChildrenCount;
    final View[] children = mChildren;
    int flags = mGroupFlags;
    if ((flags & FLAG_RUN_ANIMATION) != 0 && canAnimate()) {
        final boolean cache = (mGroupFlags & FLAG_ANIMATION_CACHE) == FLAG_ANIMATION_CACHE;
        final boolean buildCache = !isHardwareAccelerated();
        for (int i = 0; i < count; i++) {
            final View child = children[i];
            if ((child.mViewFlags & VISIBILITY_MASK) == VISIBLE) {
                final LayoutParams params = child.getLayoutParams();
                attachLayoutAnimationParameters(child, params, i, count);
                bindLayoutAnimation(child);
                if (cache) {
                    child.setDrawingCacheEnabled(true);
                    if (buildCache) {
                        child.buildDrawingCache(true);
                    }
                }
            }
        }
        final LayoutAnimationController controller = mLayoutAnimationController;
        if (controller.willOverlap()) {
            mGroupFlags |= FLAG_OPTIMIZE_INVALIDATE;
        }
        controller.start();
        mGroupFlags &= ~FLAG_RUN_ANIMATION;
        mGroupFlags &= ~FLAG_ANIMATION_DONE;
        if (cache) {
            mGroupFlags |= FLAG_CHILDREN_DRAWN_WITH_CACHE;
        }
        if (mAnimationListener != null) {
            mAnimationListener.onAnimationStart(controller.getAnimation());
        }
    }
    int saveCount = 0;
    final boolean clipToPadding = (flags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK;
    if (clipToPadding) {
        saveCount = canvas.save();
        canvas.clipRect(mScrollX + mPaddingLeft, mScrollY + mPaddingTop, mScrollX + mRight - mLeft - mPaddingRight, mScrollY + mBottom - mTop - mPaddingBottom);
    }
    // We will draw our child's animation, let's reset the flag
    mPrivateFlags &= ~PFLAG_DRAW_ANIMATION;
    mGroupFlags &= ~FLAG_INVALIDATE_REQUIRED;
    boolean more = false;
    final long drawingTime = getDrawingTime();
    if ((flags & FLAG_USE_CHILD_DRAWING_ORDER) == 0) {
        for (int i = 0; i < count; i++) {
            final View child = children[i];
            if ((child.mViewFlags & VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) {
                more |= drawChild(canvas, child, drawingTime);
            }
        }
    } else {
        for (int i = 0; i < count; i++) {
            final View child = children[getChildDrawingOrder(count, i)];
            if ((child.mViewFlags & VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) {
                more |= drawChild(canvas, child, drawingTime);
            }
        }
    }
    // Draw any disappearing views that have animations
    if (mDisappearingChildren != null) {
        final ArrayList<View> disappearingChildren = mDisappearingChildren;
        final int disappearingCount = disappearingChildren.size() - 1;
        // Go backwards -- we may delete as animations finish
        for (int i = disappearingCount; i >= 0; i--) {
            final View child = disappearingChildren.get(i);
            more |= drawChild(canvas, child, drawingTime);
        }
    }
    if (debugDraw()) {
        onDebugDraw(canvas);
    }
    if (clipToPadding) {
        canvas.restoreToCount(saveCount);
    }
    // mGroupFlags might have been updated by drawChild()
    flags = mGroupFlags;
    if ((flags & FLAG_INVALIDATE_REQUIRED) == FLAG_INVALIDATE_REQUIRED) {
        invalidate(true);
    }
    if ((flags & FLAG_ANIMATION_DONE) == 0 && (flags & FLAG_NOTIFY_ANIMATION_LISTENER) == 0 && mLayoutAnimationController.isDone() && !more) {
        // We want to erase the drawing cache and notify the listener after the
        // next frame is drawn because one extra invalidate() is caused by
        // drawChild() after the animation is over
        mGroupFlags |= FLAG_NOTIFY_ANIMATION_LISTENER;
        final Runnable end = new Runnable() {

            public void run() {
                notifyAnimationListener();
            }
        };
        post(end);
    }
}
Body of Second Method:
{
    boolean usingRenderNodeProperties = canvas.isRecordingFor(mRenderNode);
    final int childrenCount = mChildrenCount;
    final View[] children = mChildren;
    int flags = mGroupFlags;
    if ((flags & FLAG_RUN_ANIMATION) != 0 && canAnimate()) {
        final boolean cache = (mGroupFlags & FLAG_ANIMATION_CACHE) == FLAG_ANIMATION_CACHE;
        final boolean buildCache = !isHardwareAccelerated();
        for (int i = 0; i < childrenCount; i++) {
            final View child = children[i];
            if ((child.mViewFlags & VISIBILITY_MASK) == VISIBLE) {
                final LayoutParams params = child.getLayoutParams();
                attachLayoutAnimationParameters(child, params, i, childrenCount);
                bindLayoutAnimation(child);
                if (cache) {
                    child.setDrawingCacheEnabled(true);
                    if (buildCache) {
                        child.buildDrawingCache(true);
                    }
                }
            }
        }
        final LayoutAnimationController controller = mLayoutAnimationController;
        if (controller.willOverlap()) {
            mGroupFlags |= FLAG_OPTIMIZE_INVALIDATE;
        }
        controller.start();
        mGroupFlags &= ~FLAG_RUN_ANIMATION;
        mGroupFlags &= ~FLAG_ANIMATION_DONE;
        if (cache) {
            mGroupFlags |= FLAG_CHILDREN_DRAWN_WITH_CACHE;
        }
        if (mAnimationListener != null) {
            mAnimationListener.onAnimationStart(controller.getAnimation());
        }
    }
    int clipSaveCount = 0;
    final boolean clipToPadding = (flags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK;
    if (clipToPadding) {
        clipSaveCount = canvas.save();
        canvas.clipRect(mScrollX + mPaddingLeft, mScrollY + mPaddingTop, mScrollX + mRight - mLeft - mPaddingRight, mScrollY + mBottom - mTop - mPaddingBottom);
    }
    // We will draw our child's animation, let's reset the flag
    mPrivateFlags &= ~PFLAG_DRAW_ANIMATION;
    mGroupFlags &= ~FLAG_INVALIDATE_REQUIRED;
    boolean more = false;
    final long drawingTime = getDrawingTime();
    if (usingRenderNodeProperties)
        canvas.insertReorderBarrier();
    // Only use the preordered list if not HW accelerated, since the HW pipeline will do the
    // draw reordering internally
    final ArrayList<View> preorderedList = usingRenderNodeProperties ? null : buildOrderedChildList();
    final boolean customOrder = preorderedList == null && isChildrenDrawingOrderEnabled();
    for (int i = 0; i < childrenCount; i++) {
        int childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i;
        final View child = (preorderedList == null) ? children[childIndex] : preorderedList.get(childIndex);
        if ((child.mViewFlags & VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) {
            more |= drawChild(canvas, child, drawingTime);
        }
    }
    if (preorderedList != null)
        preorderedList.clear();
    // Draw any disappearing views that have animations
    if (mDisappearingChildren != null) {
        final ArrayList<View> disappearingChildren = mDisappearingChildren;
        final int disappearingCount = disappearingChildren.size() - 1;
        // Go backwards -- we may delete as animations finish
        for (int i = disappearingCount; i >= 0; i--) {
            final View child = disappearingChildren.get(i);
            more |= drawChild(canvas, child, drawingTime);
        }
    }
    if (usingRenderNodeProperties)
        canvas.insertInorderBarrier();
    if (debugDraw()) {
        onDebugDraw(canvas);
    }
    if (clipToPadding) {
        canvas.restoreToCount(clipSaveCount);
    }
    // mGroupFlags might have been updated by drawChild()
    flags = mGroupFlags;
    if ((flags & FLAG_INVALIDATE_REQUIRED) == FLAG_INVALIDATE_REQUIRED) {
        invalidate(true);
    }
    if ((flags & FLAG_ANIMATION_DONE) == 0 && (flags & FLAG_NOTIFY_ANIMATION_LISTENER) == 0 && mLayoutAnimationController.isDone() && !more) {
        // We want to erase the drawing cache and notify the listener after the
        // next frame is drawn because one extra invalidate() is caused by
        // drawChild() after the animation is over
        mGroupFlags |= FLAG_NOTIFY_ANIMATION_LISTENER;
        final Runnable end = new Runnable() {

            public void run() {
                notifyAnimationListener();
            }
        };
        post(end);
    }
}
------------------------
Find a silently evolved API code:android.hardware.SystemSensorManager.requestTriggerSensorImpl:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (sensor == null)
        throw new IllegalArgumentException("sensor cannot be null");
    if (Sensor.getReportingMode(sensor) != Sensor.REPORTING_MODE_ONE_SHOT)
        return false;
    synchronized (mTriggerListeners) {
        TriggerEventQueue queue = mTriggerListeners.get(listener);
        if (queue == null) {
            queue = new TriggerEventQueue(listener, mMainLooper, this);
            if (!queue.addSensor(sensor, 0, 0, 0)) {
                queue.dispose();
                return false;
            }
            mTriggerListeners.put(listener, queue);
            return true;
        } else {
            return queue.addSensor(sensor, 0, 0, 0);
        }
    }
}
Body of Second Method:
{
    if (sensor == null)
        throw new IllegalArgumentException("sensor cannot be null");
    if (sensor.getReportingMode() != Sensor.REPORTING_MODE_ONE_SHOT)
        return false;
    synchronized (mTriggerListeners) {
        TriggerEventQueue queue = mTriggerListeners.get(listener);
        if (queue == null) {
            queue = new TriggerEventQueue(listener, mMainLooper, this);
            if (!queue.addSensor(sensor, 0, 0, 0)) {
                queue.dispose();
                return false;
            }
            mTriggerListeners.put(listener, queue);
            return true;
        } else {
            return queue.addSensor(sensor, 0, 0, 0);
        }
    }
}
------------------------
Find a silently evolved API code:android.view.Window.setSoftInputMode:COMMENT
Method Modifier: public      
Comment:/**
 * Specify an explicit soft input mode to use for the window, as per
 * {@link WindowManager.LayoutParams#softInputMode
 * WindowManager.LayoutParams.softInputMode}.  Providing anything besides
 * "unspecified" here will override the input mode the window would
 * normally retrieve from its theme.
 */

Body of Frist Method:
{
    final WindowManager.LayoutParams attrs = getAttributes();
    if (mode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) {
        attrs.softInputMode = mode;
        mHasSoftInputMode = true;
    } else {
        mHasSoftInputMode = false;
    }
    if (mCallback != null) {
        mCallback.onWindowAttributesChanged(attrs);
    }
}
Body of Second Method:
{
    final WindowManager.LayoutParams attrs = getAttributes();
    if (mode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) {
        attrs.softInputMode = mode;
        mHasSoftInputMode = true;
    } else {
        mHasSoftInputMode = false;
    }
    dispatchWindowAttributesChanged(attrs);
}
------------------------
Find a silently evolved API code:android.transition.TransitionSet.resume:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    super.resume();
    int numTransitions = mTransitions.size();
    for (int i = 0; i < numTransitions; ++i) {
        mTransitions.get(i).resume();
    }
}
Body of Second Method:
{
    super.resume(sceneRoot);
    int numTransitions = mTransitions.size();
    for (int i = 0; i < numTransitions; ++i) {
        mTransitions.get(i).resume(sceneRoot);
    }
}
------------------------
Find a silently evolved API code:android.print.PrintManager.addPrintJobStateChangeListener:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Adds a listener for observing the state of print jobs.
 *
 * @param listener The listener to add.
 * @hide
 */

Body of Frist Method:
{
    if (mPrintJobStateChangeListeners == null) {
        mPrintJobStateChangeListeners = new ArrayMap<PrintJobStateChangeListener, PrintJobStateChangeListenerWrapper>();
    }
    PrintJobStateChangeListenerWrapper wrappedListener = new PrintJobStateChangeListenerWrapper(listener, mHandler);
    try {
        mService.addPrintJobStateChangeListener(wrappedListener, mAppId, mUserId);
        mPrintJobStateChangeListeners.put(listener, wrappedListener);
    } catch (RemoteException re) {
        Log.e(LOG_TAG, "Error adding print job state change listener", re);
    }
}
Body of Second Method:
{
    if (mService == null) {
        Log.w(LOG_TAG, "Feature android.software.print not available");
        return;
    }
    if (mPrintJobStateChangeListeners == null) {
        mPrintJobStateChangeListeners = new ArrayMap<PrintJobStateChangeListener, PrintJobStateChangeListenerWrapper>();
    }
    PrintJobStateChangeListenerWrapper wrappedListener = new PrintJobStateChangeListenerWrapper(listener, mHandler);
    try {
        mService.addPrintJobStateChangeListener(wrappedListener, mAppId, mUserId);
        mPrintJobStateChangeListeners.put(listener, wrappedListener);
    } catch (RemoteException re) {
        Log.e(LOG_TAG, "Error adding print job state change listener", re);
    }
}
------------------------
Find a silently evolved API code:android.widget.TextView.onPreDraw:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (mLayout == null) {
        assumeLayout();
    }
    if (mMovement != null) {
        /* This code also provides auto-scrolling when a cursor is moved using a
             * CursorController (insertion point or selection limits).
             * For selection, ensure start or end is visible depending on controller's state.
             */
        int curs = getSelectionEnd();
        // Do not create the controller if it is not already created.
        if (mEditor != null && mEditor.mSelectionModifierCursorController != null && mEditor.mSelectionModifierCursorController.isSelectionStartDragged()) {
            curs = getSelectionStart();
        }
        /*
             * TODO: This should really only keep the end in view if
             * it already was before the text changed.  I'm not sure
             * of a good way to tell from here if it was.
             */
        if (curs < 0 && (mGravity & Gravity.VERTICAL_GRAVITY_MASK) == Gravity.BOTTOM) {
            curs = mText.length();
        }
        if (curs >= 0) {
            bringPointIntoView(curs);
        }
    } else {
        bringTextIntoView();
    }
    // a screen rotation) since layout is not yet initialized at that point.
    if (mEditor != null && mEditor.mCreatedWithASelection) {
        mEditor.startSelectionActionMode();
        mEditor.mCreatedWithASelection = false;
    }
    // not be set. Do the test here instead.
    if (this instanceof ExtractEditText && hasSelection() && mEditor != null) {
        mEditor.startSelectionActionMode();
    }
    getViewTreeObserver().removeOnPreDrawListener(this);
    mPreDrawRegistered = false;
    return true;
}
Body of Second Method:
{
    if (mLayout == null) {
        assumeLayout();
    }
    if (mMovement != null) {
        /* This code also provides auto-scrolling when a cursor is moved using a
             * CursorController (insertion point or selection limits).
             * For selection, ensure start or end is visible depending on controller's state.
             */
        int curs = getSelectionEnd();
        // Do not create the controller if it is not already created.
        if (mEditor != null && mEditor.mSelectionModifierCursorController != null && mEditor.mSelectionModifierCursorController.isSelectionStartDragged()) {
            curs = getSelectionStart();
        }
        /*
             * TODO: This should really only keep the end in view if
             * it already was before the text changed.  I'm not sure
             * of a good way to tell from here if it was.
             */
        if (curs < 0 && (mGravity & Gravity.VERTICAL_GRAVITY_MASK) == Gravity.BOTTOM) {
            curs = mText.length();
        }
        if (curs >= 0) {
            bringPointIntoView(curs);
        }
    } else {
        bringTextIntoView();
    }
    // a screen rotation) since layout is not yet initialized at that point.
    if (mEditor != null && mEditor.mCreatedWithASelection) {
        mEditor.startSelectionActionMode();
        mEditor.mCreatedWithASelection = false;
    }
    // not be set. Do the test here instead.
    if (this instanceof ExtractEditText && hasSelection() && mEditor != null) {
        mEditor.startSelectionActionMode();
    }
    unregisterForPreDraw();
    return true;
}
------------------------
Find a silently evolved API code:android.appwidget.AppWidgetManager.getInstalledProviders:COMMENT
Method Modifier: public      
Comment:/**
 * Return a list of the AppWidget providers that are currently installed.
 */

Body of Frist Method:
{
    return getInstalledProviders(AppWidgetProviderInfo.WIDGET_CATEGORY_HOME_SCREEN);
}
Body of Second Method:
{
    if (mService == null) {
        return Collections.emptyList();
    }
    return getInstalledProvidersForProfile(AppWidgetProviderInfo.WIDGET_CATEGORY_HOME_SCREEN, null);
}
------------------------
Find a silently evolved API code:android.widget.DatePicker.getYear:COMMENT
Method Modifier: public      
Comment:/**
 * @return The selected year.
 */

Body of Frist Method:
{
    return mCurrentDate.get(Calendar.YEAR);
}
Body of Second Method:
{
    return mDelegate.getYear();
}
------------------------
Find a silently evolved API code:android.os.Parcel.writeValue:COMMENT
Method Modifier: public      final       
Comment:/**
 * Flatten a generic object in to a parcel.  The given Object value may
 * currently be one of the following types:
 *
 * <ul>
 * <li> null
 * <li> String
 * <li> Byte
 * <li> Short
 * <li> Integer
 * <li> Long
 * <li> Float
 * <li> Double
 * <li> Boolean
 * <li> String[]
 * <li> boolean[]
 * <li> byte[]
 * <li> int[]
 * <li> long[]
 * <li> Object[] (supporting objects of the same type defined here).
 * <li> {@link Bundle}
 * <li> Map (as supported by {@link #writeMap}).
 * <li> Any object that implements the {@link Parcelable} protocol.
 * <li> Parcelable[]
 * <li> CharSequence (as supported by {@link TextUtils#writeToParcel}).
 * <li> List (as supported by {@link #writeList}).
 * <li> {@link SparseArray} (as supported by {@link #writeSparseArray(SparseArray)}).
 * <li> {@link IBinder}
 * <li> Any object that implements Serializable (but see
 * {@link #writeSerializable} for caveats).  Note that all of the
 * previous types have relatively efficient implementations for
 * writing to a Parcel; having to rely on the generic serialization
 * approach is much less efficient and should be avoided whenever
 * possible.
 * </ul>
 *
 * <p class="caution">{@link Parcelable} objects are written with
 * {@link Parcelable#writeToParcel} using contextual flags of 0.  When
 * serializing objects containing {@link ParcelFileDescriptor}s,
 * this may result in file descriptor leaks when they are returned from
 * Binder calls (where {@link Parcelable#PARCELABLE_WRITE_RETURN_VALUE}
 * should be used).</p>
 */

Body of Frist Method:
{
    if (v == null) {
        writeInt(VAL_NULL);
    } else if (v instanceof String) {
        writeInt(VAL_STRING);
        writeString((String) v);
    } else if (v instanceof Integer) {
        writeInt(VAL_INTEGER);
        writeInt((Integer) v);
    } else if (v instanceof Map) {
        writeInt(VAL_MAP);
        writeMap((Map) v);
    } else if (v instanceof Bundle) {
        // Must be before Parcelable
        writeInt(VAL_BUNDLE);
        writeBundle((Bundle) v);
    } else if (v instanceof Parcelable) {
        writeInt(VAL_PARCELABLE);
        writeParcelable((Parcelable) v, 0);
    } else if (v instanceof Short) {
        writeInt(VAL_SHORT);
        writeInt(((Short) v).intValue());
    } else if (v instanceof Long) {
        writeInt(VAL_LONG);
        writeLong((Long) v);
    } else if (v instanceof Float) {
        writeInt(VAL_FLOAT);
        writeFloat((Float) v);
    } else if (v instanceof Double) {
        writeInt(VAL_DOUBLE);
        writeDouble((Double) v);
    } else if (v instanceof Boolean) {
        writeInt(VAL_BOOLEAN);
        writeInt((Boolean) v ? 1 : 0);
    } else if (v instanceof CharSequence) {
        // Must be after String
        writeInt(VAL_CHARSEQUENCE);
        writeCharSequence((CharSequence) v);
    } else if (v instanceof List) {
        writeInt(VAL_LIST);
        writeList((List) v);
    } else if (v instanceof SparseArray) {
        writeInt(VAL_SPARSEARRAY);
        writeSparseArray((SparseArray) v);
    } else if (v instanceof boolean[]) {
        writeInt(VAL_BOOLEANARRAY);
        writeBooleanArray((boolean[]) v);
    } else if (v instanceof byte[]) {
        writeInt(VAL_BYTEARRAY);
        writeByteArray((byte[]) v);
    } else if (v instanceof String[]) {
        writeInt(VAL_STRINGARRAY);
        writeStringArray((String[]) v);
    } else if (v instanceof CharSequence[]) {
        // Must be after String[] and before Object[]
        writeInt(VAL_CHARSEQUENCEARRAY);
        writeCharSequenceArray((CharSequence[]) v);
    } else if (v instanceof IBinder) {
        writeInt(VAL_IBINDER);
        writeStrongBinder((IBinder) v);
    } else if (v instanceof Parcelable[]) {
        writeInt(VAL_PARCELABLEARRAY);
        writeParcelableArray((Parcelable[]) v, 0);
    } else if (v instanceof Object[]) {
        writeInt(VAL_OBJECTARRAY);
        writeArray((Object[]) v);
    } else if (v instanceof int[]) {
        writeInt(VAL_INTARRAY);
        writeIntArray((int[]) v);
    } else if (v instanceof long[]) {
        writeInt(VAL_LONGARRAY);
        writeLongArray((long[]) v);
    } else if (v instanceof Byte) {
        writeInt(VAL_BYTE);
        writeInt((Byte) v);
    } else if (v instanceof Serializable) {
        // Must be last
        writeInt(VAL_SERIALIZABLE);
        writeSerializable((Serializable) v);
    } else {
        throw new RuntimeException("Parcel: unable to marshal value " + v);
    }
}
Body of Second Method:
{
    if (v == null) {
        writeInt(VAL_NULL);
    } else if (v instanceof String) {
        writeInt(VAL_STRING);
        writeString((String) v);
    } else if (v instanceof Integer) {
        writeInt(VAL_INTEGER);
        writeInt((Integer) v);
    } else if (v instanceof Map) {
        writeInt(VAL_MAP);
        writeMap((Map) v);
    } else if (v instanceof Bundle) {
        // Must be before Parcelable
        writeInt(VAL_BUNDLE);
        writeBundle((Bundle) v);
    } else if (v instanceof Parcelable) {
        writeInt(VAL_PARCELABLE);
        writeParcelable((Parcelable) v, 0);
    } else if (v instanceof Short) {
        writeInt(VAL_SHORT);
        writeInt(((Short) v).intValue());
    } else if (v instanceof Long) {
        writeInt(VAL_LONG);
        writeLong((Long) v);
    } else if (v instanceof Float) {
        writeInt(VAL_FLOAT);
        writeFloat((Float) v);
    } else if (v instanceof Double) {
        writeInt(VAL_DOUBLE);
        writeDouble((Double) v);
    } else if (v instanceof Boolean) {
        writeInt(VAL_BOOLEAN);
        writeInt((Boolean) v ? 1 : 0);
    } else if (v instanceof CharSequence) {
        // Must be after String
        writeInt(VAL_CHARSEQUENCE);
        writeCharSequence((CharSequence) v);
    } else if (v instanceof List) {
        writeInt(VAL_LIST);
        writeList((List) v);
    } else if (v instanceof SparseArray) {
        writeInt(VAL_SPARSEARRAY);
        writeSparseArray((SparseArray) v);
    } else if (v instanceof boolean[]) {
        writeInt(VAL_BOOLEANARRAY);
        writeBooleanArray((boolean[]) v);
    } else if (v instanceof byte[]) {
        writeInt(VAL_BYTEARRAY);
        writeByteArray((byte[]) v);
    } else if (v instanceof String[]) {
        writeInt(VAL_STRINGARRAY);
        writeStringArray((String[]) v);
    } else if (v instanceof CharSequence[]) {
        // Must be after String[] and before Object[]
        writeInt(VAL_CHARSEQUENCEARRAY);
        writeCharSequenceArray((CharSequence[]) v);
    } else if (v instanceof IBinder) {
        writeInt(VAL_IBINDER);
        writeStrongBinder((IBinder) v);
    } else if (v instanceof Parcelable[]) {
        writeInt(VAL_PARCELABLEARRAY);
        writeParcelableArray((Parcelable[]) v, 0);
    } else if (v instanceof int[]) {
        writeInt(VAL_INTARRAY);
        writeIntArray((int[]) v);
    } else if (v instanceof long[]) {
        writeInt(VAL_LONGARRAY);
        writeLongArray((long[]) v);
    } else if (v instanceof Byte) {
        writeInt(VAL_BYTE);
        writeInt((Byte) v);
    } else if (v instanceof PersistableBundle) {
        writeInt(VAL_PERSISTABLEBUNDLE);
        writePersistableBundle((PersistableBundle) v);
    } else if (v instanceof Size) {
        writeInt(VAL_SIZE);
        writeSize((Size) v);
    } else if (v instanceof SizeF) {
        writeInt(VAL_SIZEF);
        writeSizeF((SizeF) v);
    } else {
        Class<?> clazz = v.getClass();
        if (clazz.isArray() && clazz.getComponentType() == Object.class) {
            // Only pure Object[] are written here, Other arrays of non-primitive types are
            // handled by serialization as this does not record the component type.
            writeInt(VAL_OBJECTARRAY);
            writeArray((Object[]) v);
        } else if (v instanceof Serializable) {
            // Must be last
            writeInt(VAL_SERIALIZABLE);
            writeSerializable((Serializable) v);
        } else {
            throw new RuntimeException("Parcel: unable to marshal value " + v);
        }
    }
}
------------------------
Find a silently evolved API code:android.graphics.Path.offset:COMMENT
Method Modifier: public      
Comment:/**
 * Offset the path by (dx,dy), returning true on success
 *
 * @param dx  The amount in the X direction to offset the entire path
 * @param dy  The amount in the Y direction to offset the entire path
 * @param dst The translated path is written here. If this is null, then
 * the original path is modified.
 */

Body of Frist Method:
{
    int dstNative = 0;
    if (dst != null) {
        dstNative = dst.mNativePath;
        dst.isSimplePath = false;
    }
    native_offset(mNativePath, dx, dy, dstNative);
}
Body of Second Method:
{
    long dstNative = 0;
    if (dst != null) {
        dstNative = dst.mNativePath;
        dst.isSimplePath = false;
    }
    native_offset(mNativePath, dx, dy, dstNative);
}
------------------------
Find a silently evolved API code:android.media.MediaCodecInfo.getCapabilitiesForType:COMMENT
Method Modifier: public      final       
Comment:/**
 * Enumerates the capabilities of the codec component. Since a single
 * component can support data of a variety of types, the type has to be
 * specified to yield a meaningful result.
 * @param type The MIME type to query
 */

Body of Frist Method:
{
    return MediaCodecList.getCodecCapabilities(mIndex, type);
}
Body of Second Method:
{
    CodecCapabilities caps = mCaps.get(type);
    if (caps == null) {
        throw new IllegalArgumentException("codec does not support type");
    }
    // clone writable object
    return caps.dup();
}
------------------------
Find a silently evolved API code:android.hardware.SystemSensorManager.SensorEventQueue.dispatchSensorEvent:COMMENT
Method Modifier: protected   
Comment:// Called from native code.

Body of Frist Method:
{
    final Sensor sensor = sHandleToSensor.get(handle);
    SensorEvent t = mSensorsEvents.get(handle);
    if (t == null) {
        Log.e(TAG, "Error: Sensor Event is null for Sensor: " + sensor);
        return;
    }
    // Copy from the values array.
    System.arraycopy(values, 0, t.values, 0, t.values.length);
    t.timestamp = timestamp;
    t.accuracy = inAccuracy;
    t.sensor = sensor;
    switch(t.sensor.getType()) {
        // Only report accuracy for sensors that support it.
        case Sensor.TYPE_MAGNETIC_FIELD:
        case Sensor.TYPE_ORIENTATION:
            // call onAccuracyChanged() only if the value changes
            final int accuracy = mSensorAccuracies.get(handle);
            if ((t.accuracy >= 0) && (accuracy != t.accuracy)) {
                mSensorAccuracies.put(handle, t.accuracy);
                mListener.onAccuracyChanged(t.sensor, t.accuracy);
            }
            break;
        default:
            // For other sensors, just report the accuracy once
            if (mFirstEvent.get(handle) == false) {
                mFirstEvent.put(handle, true);
                mListener.onAccuracyChanged(t.sensor, SENSOR_STATUS_ACCURACY_HIGH);
            }
            break;
    }
    mListener.onSensorChanged(t);
}
Body of Second Method:
{
    final Sensor sensor = sHandleToSensor.get(handle);
    SensorEvent t = null;
    synchronized (mSensorsEvents) {
        t = mSensorsEvents.get(handle);
    }
    if (t == null) {
        // the queue waiting to be delivered. Ignore.
        return;
    }
    // Copy from the values array.
    System.arraycopy(values, 0, t.values, 0, t.values.length);
    t.timestamp = timestamp;
    t.accuracy = inAccuracy;
    t.sensor = sensor;
    // call onAccuracyChanged() only if the value changes
    final int accuracy = mSensorAccuracies.get(handle);
    if ((t.accuracy >= 0) && (accuracy != t.accuracy)) {
        mSensorAccuracies.put(handle, t.accuracy);
        mListener.onAccuracyChanged(t.sensor, t.accuracy);
    }
    mListener.onSensorChanged(t);
}
------------------------
Find a silently evolved API code:android.util.Spline.createMonotoneCubicSpline:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Creates a monotone cubic spline from a given set of control points.
 *
 * The spline is guaranteed to pass through each control point exactly.
 * Moreover, assuming the control points are monotonic (Y is non-decreasing or
 * non-increasing) then the interpolated values will also be monotonic.
 *
 * This function uses the Fritsch-Carlson method for computing the spline parameters.
 * http://en.wikipedia.org/wiki/Monotone_cubic_interpolation
 *
 * @param x The X component of the control points, strictly increasing.
 * @param y The Y component of the control points, monotonic.
 * @return
 *
 * @throws IllegalArgumentException if the X or Y arrays are null, have
 * different lengths or have fewer than 2 values.
 * @throws IllegalArgumentException if the control points are not monotonic.
 */

Body of Frist Method:
{
    if (x == null || y == null || x.length != y.length || x.length < 2) {
        throw new IllegalArgumentException("There must be at least two control " + "points and the arrays must be of equal length.");
    }
    final int n = x.length;
    // could optimize this out
    float[] d = new float[n - 1];
    float[] m = new float[n];
    // Compute slopes of secant lines between successive points.
    for (int i = 0; i < n - 1; i++) {
        float h = x[i + 1] - x[i];
        if (h <= 0f) {
            throw new IllegalArgumentException("The control points must all " + "have strictly increasing X values.");
        }
        d[i] = (y[i + 1] - y[i]) / h;
    }
    // Initialize the tangents as the average of the secants.
    m[0] = d[0];
    for (int i = 1; i < n - 1; i++) {
        m[i] = (d[i - 1] + d[i]) * 0.5f;
    }
    m[n - 1] = d[n - 2];
    // Update the tangents to preserve monotonicity.
    for (int i = 0; i < n - 1; i++) {
        if (d[i] == 0f) {
            // successive Y values are equal
            m[i] = 0f;
            m[i + 1] = 0f;
        } else {
            float a = m[i] / d[i];
            float b = m[i + 1] / d[i];
            if (a < 0f || b < 0f) {
                throw new IllegalArgumentException("The control points must have " + "monotonic Y values.");
            }
            float h = FloatMath.hypot(a, b);
            if (h > 9f) {
                float t = 3f / h;
                m[i] = t * a * d[i];
                m[i + 1] = t * b * d[i];
            }
        }
    }
    return new Spline(x, y, m);
}
Body of Second Method:
{
    return new MonotoneCubicSpline(x, y);
}
------------------------
Find a silently evolved API code:android.animation.PropertyValuesHolder.setKeyframes:COMMENT
Method Modifier: public      
Comment:/**
 * Set the animated values for this object to this set of Keyframes.
 *
 * @param values One or more values that the animation will animate between.
 */

Body of Frist Method:
{
    int numKeyframes = values.length;
    Keyframe[] keyframes = new Keyframe[Math.max(numKeyframes, 2)];
    mValueType = ((Keyframe) values[0]).getType();
    for (int i = 0; i < numKeyframes; ++i) {
        keyframes[i] = (Keyframe) values[i];
    }
    mKeyframeSet = new KeyframeSet(keyframes);
}
Body of Second Method:
{
    int numKeyframes = values.length;
    Keyframe[] keyframes = new Keyframe[Math.max(numKeyframes, 2)];
    mValueType = ((Keyframe) values[0]).getType();
    for (int i = 0; i < numKeyframes; ++i) {
        keyframes[i] = (Keyframe) values[i];
    }
    mKeyframes = new KeyframeSet(keyframes);
}
------------------------
Find a silently evolved API code:android.view.textservice.TextInfo.getText:COMMENT
Method Modifier: public      
Comment:/**
 * @return the text which is an input of a text service
 */

Body of Frist Method:
{
    return mText;
}
Body of Second Method:
{
    if (mCharSequence == null) {
        return null;
    }
    return mCharSequence.toString();
}
------------------------
Find a silently evolved API code:android.widget.DatePicker.getCalendarView:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the {@link CalendarView}.
 *
 * @return The calendar view.
 * @see #getCalendarViewShown()
 */

Body of Frist Method:
{
    return mCalendarView;
}
Body of Second Method:
{
    return mDelegate.getCalendarView();
}
------------------------
Find a silently evolved API code:android.app.WallpaperManager.clear:COMMENT
Method Modifier: public      
Comment:/**
 * Remove any currently set wallpaper, reverting to the system's built-in
 * wallpaper. On success, the intent {@link Intent#ACTION_WALLPAPER_CHANGED}
 * is broadcast.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#SET_WALLPAPER}.
 *
 * @throws IOException If an error occurs reverting to the built-in
 * wallpaper.
 */

Body of Frist Method:
{
    setResource(com.android.internal.R.drawable.default_wallpaper);
}
Body of Second Method:
{
    setStream(openDefaultWallpaper(mContext));
}
------------------------
Find a silently evolved API code:android.app.Instrumentation.finish:COMMENT
Method Modifier: public      
Comment:/**
 * Terminate instrumentation of the application.  This will cause the
 * application process to exit, removing this instrumentation from the next
 * time the application is started.
 *
 * @param resultCode Overall success/failure of instrumentation.
 * @param results Any results to send back to the code that started the
 * instrumentation.
 */

Body of Frist Method:
{
    if (mAutomaticPerformanceSnapshots) {
        endPerformanceSnapshot();
    }
    if (mPerfMetrics != null) {
        results.putAll(mPerfMetrics);
    }
    if (mUiAutomation != null) {
        mUiAutomation.disconnect();
        mUiAutomation = null;
    }
    mThread.finishInstrumentation(resultCode, results);
}
Body of Second Method:
{
    if (mAutomaticPerformanceSnapshots) {
        endPerformanceSnapshot();
    }
    if (mPerfMetrics != null) {
        if (results == null) {
            results = new Bundle();
        }
        results.putAll(mPerfMetrics);
    }
    if (mUiAutomation != null) {
        mUiAutomation.disconnect();
        mUiAutomation = null;
    }
    mThread.finishInstrumentation(resultCode, results);
}
------------------------
Find a silently evolved API code:android.service.dreams.DreamService.setLowProfile:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets View.SYSTEM_UI_FLAG_LOW_PROFILE on the content view.
 *
 * @param lowProfile True to set View.SYSTEM_UI_FLAG_LOW_PROFILE
 * @hide There is no reason to have this -- dreams can set this flag
 * on their own content view, and from there can actually do the
 * correct interactions with it (seeing when it is cleared etc).
 */

Body of Frist Method:
{
    mLowProfile = lowProfile;
    int flag = View.SYSTEM_UI_FLAG_LOW_PROFILE;
    applySystemUiVisibilityFlags(mLowProfile ? flag : 0, flag);
}
Body of Second Method:
{
    if (mLowProfile != lowProfile) {
        mLowProfile = lowProfile;
        int flag = View.SYSTEM_UI_FLAG_LOW_PROFILE;
        applySystemUiVisibilityFlags(mLowProfile ? flag : 0, flag);
    }
}
------------------------
Find a silently evolved API code:android.os.StrictMode.conditionallyCheckInstanceCounts:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    VmPolicy policy = getVmPolicy();
    if (policy.classInstanceLimit.size() == 0) {
        return;
    }
    Runtime.getRuntime().gc();
    // Note: classInstanceLimit is immutable, so this is lock-free
    for (Map.Entry<Class, Integer> entry : policy.classInstanceLimit.entrySet()) {
        Class klass = entry.getKey();
        int limit = entry.getValue();
        long instances = VMDebug.countInstancesOfClass(klass, false);
        if (instances <= limit) {
            continue;
        }
        Throwable tr = new InstanceCountViolation(klass, instances, limit);
        onVmPolicyViolation(tr.getMessage(), tr);
    }
}
Body of Second Method:
{
    VmPolicy policy = getVmPolicy();
    if (policy.classInstanceLimit.size() == 0) {
        return;
    }
    System.gc();
    System.runFinalization();
    System.gc();
    // Note: classInstanceLimit is immutable, so this is lock-free
    for (Map.Entry<Class, Integer> entry : policy.classInstanceLimit.entrySet()) {
        Class klass = entry.getKey();
        int limit = entry.getValue();
        long instances = VMDebug.countInstancesOfClass(klass, false);
        if (instances <= limit) {
            continue;
        }
        Throwable tr = new InstanceCountViolation(klass, instances, limit);
        onVmPolicyViolation(tr.getMessage(), tr);
    }
}
------------------------
Find a silently evolved API code:android.graphics.Bitmap.compress:COMMENT
Method Modifier: public      
Comment:/**
 * Write a compressed version of the bitmap to the specified outputstream.
 * If this returns true, the bitmap can be reconstructed by passing a
 * corresponding inputstream to BitmapFactory.decodeStream(). Note: not
 * all Formats support all bitmap configs directly, so it is possible that
 * the returned bitmap from BitmapFactory could be in a different bitdepth,
 * and/or may have lost per-pixel alpha (e.g. JPEG only supports opaque
 * pixels).
 *
 * @param format   The format of the compressed image
 * @param quality  Hint to the compressor, 0-100. 0 meaning compress for
 * small size, 100 meaning compress for max quality. Some
 * formats, like PNG which is lossless, will ignore the
 * quality setting
 * @param stream   The outputstream to write the compressed data.
 * @return true if successfully compressed to the specified stream.
 */

Body of Frist Method:
{
    checkRecycled("Can't compress a recycled bitmap");
    // do explicit check before calling the native method
    if (stream == null) {
        throw new NullPointerException();
    }
    if (quality < 0 || quality > 100) {
        throw new IllegalArgumentException("quality must be 0..100");
    }
    return nativeCompress(mNativeBitmap, format.nativeInt, quality, stream, new byte[WORKING_COMPRESS_STORAGE]);
}
Body of Second Method:
{
    checkRecycled("Can't compress a recycled bitmap");
    // do explicit check before calling the native method
    if (stream == null) {
        throw new NullPointerException();
    }
    if (quality < 0 || quality > 100) {
        throw new IllegalArgumentException("quality must be 0..100");
    }
    Trace.traceBegin(Trace.TRACE_TAG_RESOURCES, "Bitmap.compress");
    boolean result = nativeCompress(mNativeBitmap, format.nativeInt, quality, stream, new byte[WORKING_COMPRESS_STORAGE]);
    Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
    return result;
}
------------------------
Find a silently evolved API code:android.util.ArrayMap.removeAt:COMMENT
Method Modifier: public      
Comment:/**
 * Remove the key/value mapping at the given index.
 * @param index The desired index, must be between 0 and {@link #size()}-1.
 * @return Returns the value that was stored at this index.
 */

Body of Frist Method:
{
    final Object old = mArray[(index << 1) + 1];
    if (mSize <= 1) {
        // Now empty.
        if (DEBUG)
            Log.d(TAG, "remove: shrink from " + mHashes.length + " to 0");
        freeArrays(mHashes, mArray, mSize);
        mHashes = ContainerHelpers.EMPTY_INTS;
        mArray = ContainerHelpers.EMPTY_OBJECTS;
        mSize = 0;
    } else {
        if (mHashes.length > (BASE_SIZE * 2) && mSize < mHashes.length / 3) {
            // Shrunk enough to reduce size of arrays.  We don't allow it to
            // shrink smaller than (BASE_SIZE*2) to avoid flapping between
            // that and BASE_SIZE.
            final int n = mSize > (BASE_SIZE * 2) ? (mSize + (mSize >> 1)) : (BASE_SIZE * 2);
            if (DEBUG)
                Log.d(TAG, "remove: shrink from " + mHashes.length + " to " + n);
            final int[] ohashes = mHashes;
            final Object[] oarray = mArray;
            allocArrays(n);
            mSize--;
            if (index > 0) {
                if (DEBUG)
                    Log.d(TAG, "remove: copy from 0-" + index + " to 0");
                System.arraycopy(ohashes, 0, mHashes, 0, index);
                System.arraycopy(oarray, 0, mArray, 0, index << 1);
            }
            if (index < mSize) {
                if (DEBUG)
                    Log.d(TAG, "remove: copy from " + (index + 1) + "-" + mSize + " to " + index);
                System.arraycopy(ohashes, index + 1, mHashes, index, mSize - index);
                System.arraycopy(oarray, (index + 1) << 1, mArray, index << 1, (mSize - index) << 1);
            }
        } else {
            mSize--;
            if (index < mSize) {
                if (DEBUG)
                    Log.d(TAG, "remove: move " + (index + 1) + "-" + mSize + " to " + index);
                System.arraycopy(mHashes, index + 1, mHashes, index, mSize - index);
                System.arraycopy(mArray, (index + 1) << 1, mArray, index << 1, (mSize - index) << 1);
            }
            mArray[mSize << 1] = null;
            mArray[(mSize << 1) + 1] = null;
        }
    }
    return (V) old;
}
Body of Second Method:
{
    final Object old = mArray[(index << 1) + 1];
    if (mSize <= 1) {
        // Now empty.
        if (DEBUG)
            Log.d(TAG, "remove: shrink from " + mHashes.length + " to 0");
        freeArrays(mHashes, mArray, mSize);
        mHashes = EmptyArray.INT;
        mArray = EmptyArray.OBJECT;
        mSize = 0;
    } else {
        if (mHashes.length > (BASE_SIZE * 2) && mSize < mHashes.length / 3) {
            // Shrunk enough to reduce size of arrays.  We don't allow it to
            // shrink smaller than (BASE_SIZE*2) to avoid flapping between
            // that and BASE_SIZE.
            final int n = mSize > (BASE_SIZE * 2) ? (mSize + (mSize >> 1)) : (BASE_SIZE * 2);
            if (DEBUG)
                Log.d(TAG, "remove: shrink from " + mHashes.length + " to " + n);
            final int[] ohashes = mHashes;
            final Object[] oarray = mArray;
            allocArrays(n);
            mSize--;
            if (index > 0) {
                if (DEBUG)
                    Log.d(TAG, "remove: copy from 0-" + index + " to 0");
                System.arraycopy(ohashes, 0, mHashes, 0, index);
                System.arraycopy(oarray, 0, mArray, 0, index << 1);
            }
            if (index < mSize) {
                if (DEBUG)
                    Log.d(TAG, "remove: copy from " + (index + 1) + "-" + mSize + " to " + index);
                System.arraycopy(ohashes, index + 1, mHashes, index, mSize - index);
                System.arraycopy(oarray, (index + 1) << 1, mArray, index << 1, (mSize - index) << 1);
            }
        } else {
            mSize--;
            if (index < mSize) {
                if (DEBUG)
                    Log.d(TAG, "remove: move " + (index + 1) + "-" + mSize + " to " + index);
                System.arraycopy(mHashes, index + 1, mHashes, index, mSize - index);
                System.arraycopy(mArray, (index + 1) << 1, mArray, index << 1, (mSize - index) << 1);
            }
            mArray[mSize << 1] = null;
            mArray[(mSize << 1) + 1] = null;
        }
    }
    return (V) old;
}
------------------------
Find a silently evolved API code:android.hardware.location.GeofenceHardware.addGeofence:COMMENT
<android.hardware.location.GeofenceHardware: boolean addGeofence(int,int,GeofenceHardwareRequest,GeofenceHardwareCallback)>
public      ->public      hidden      
Method Modifier: public      hidden      
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Creates a circular geofence which is monitored by subsystems in the hardware.
 *
 * <p> When the device detects that is has entered, exited or is uncertain
 * about the area specified by the geofence, the given callback will be called.
 *
 * <p> If this call returns true, it means that the geofence has been sent to the hardware.
 * {@link GeofenceHardwareCallback#onGeofenceAdd} will be called with the result of the
 * add call from the hardware. The {@link GeofenceHardwareCallback#onGeofenceAdd} will be
 * called with the following parameters when a transition event occurs.
 * <ul>
 * <li> The geofence Id
 * <li> The location object indicating the last known location.
 * <li> The transition associated with the geofence. One of
 * {@link #GEOFENCE_ENTERED}, {@link #GEOFENCE_EXITED}, {@link #GEOFENCE_UNCERTAIN}
 * <li> The timestamp when the geofence transition occured.
 * <li> The monitoring type ({@link #MONITORING_TYPE_GPS_HARDWARE} is one such example)
 * that was used.
 * </ul>
 *
 * <p> The geofence will be monitored by the subsystem specified by monitoring_type parameter.
 * The application does not need to hold a wakelock when the monitoring
 * is being done by the underlying hardware subsystem. If the same geofence Id is being
 * monitored by two different monitoring systems, the same id can be used for both calls, as
 * long as the same callback object is used.
 *
 * <p> Requires {@link android.Manifest.permission#ACCESS_FINE_LOCATION} permission when
 * {@link #MONITORING_TYPE_GPS_HARDWARE} is used.
 *
 * <p> Requires {@link android.Manifest.permission#LOCATION_HARDWARE} permission to access
 * geofencing in hardware.
 *
 * <p>This API should not be called directly by the app developers. A higher level api
 * which abstracts the hardware should be used instead. All the checks are done by the higher
 * level public API. Any needed locking should be handled by the higher level API.
 *
 * <p> Create a geofence request object using the methods in {@link GeofenceHardwareRequest} to
 * set all the characteristics of the geofence. Use the created GeofenceHardwareRequest object
 * in this call.
 *
 * @param geofenceId The id associated with the geofence.
 * @param monitoringType The type of the hardware subsystem that should be used
 * to monitor the geofence.
 * @param geofenceRequest The {@link GeofenceHardwareRequest} object associated with the
 * geofence.
 * @param callback {@link GeofenceHardwareCallback} that will be use to notify the
 * transition.
 * @return true when the geofence is successfully sent to the hardware for addition.
 * @throws IllegalArgumentException when the geofence request type is not supported.
 */

Body of Frist Method:
{
    try {
        if (geofenceRequest.getType() == GeofenceHardwareRequest.GEOFENCE_TYPE_CIRCLE) {
            return mService.addCircularFence(geofenceId, monitoringType, geofenceRequest.getLatitude(), geofenceRequest.getLongitude(), geofenceRequest.getRadius(), geofenceRequest.getLastTransition(), geofenceRequest.getMonitorTransitions(), geofenceRequest.getNotificationResponsiveness(), geofenceRequest.getUnknownTimer(), getCallbackWrapper(callback));
        } else {
            throw new IllegalArgumentException("Geofence Request type not supported");
        }
    } catch (RemoteException e) {
    }
    return false;
}
Body of Second Method:
{
    try {
        if (geofenceRequest.getType() == GeofenceHardwareRequest.GEOFENCE_TYPE_CIRCLE) {
            return mService.addCircularFence(monitoringType, new GeofenceHardwareRequestParcelable(geofenceId, geofenceRequest), getCallbackWrapper(callback));
        } else {
            throw new IllegalArgumentException("Geofence Request type not supported");
        }
    } catch (RemoteException e) {
    }
    return false;
}
------------------------
Find a silently evolved API code:android.media.MediaFocusControl.discardAudioFocusOwner:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * Discard the current audio focus owner.
 * Notify top of audio focus stack that it lost focus (regardless of possibility to reassign
 * focus), remove it from the stack, and clear the remote control display.
 */

Body of Frist Method:
{
    synchronized (mAudioFocusLock) {
        if (!mFocusStack.empty()) {
            // notify the current focus owner it lost focus after removing it from stack
            final FocusRequester exFocusOwner = mFocusStack.pop();
            exFocusOwner.handleFocusLoss(AudioManager.AUDIOFOCUS_LOSS);
            exFocusOwner.release();
            // clear RCD
            synchronized (mRCStack) {
                clearRemoteControlDisplay_syncAfRcs();
            }
        }
    }
}
Body of Second Method:
{
    synchronized (mAudioFocusLock) {
        if (!mFocusStack.empty()) {
            // notify the current focus owner it lost focus after removing it from stack
            final FocusRequester exFocusOwner = mFocusStack.pop();
            exFocusOwner.handleFocusLoss(AudioManager.AUDIOFOCUS_LOSS);
            exFocusOwner.release();
        }
    }
}
------------------------
Find a silently evolved API code:android.provider.Settings.Secure.putStringForUser:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (MOVED_TO_GLOBAL.contains(name)) {
        Log.w(TAG, "Setting " + name + " has moved from android.provider.Settings.System" + " to android.provider.Settings.Global");
        return Global.putStringForUser(resolver, name, value, userHandle);
    }
    return sNameValueCache.putStringForUser(resolver, name, value, userHandle);
}
Body of Second Method:
{
    if (LOCATION_MODE.equals(name)) {
        // TODO: once b/10491283 fixed, remove this hack
        return setLocationModeForUser(resolver, Integer.parseInt(value), userHandle);
    }
    if (MOVED_TO_GLOBAL.contains(name)) {
        Log.w(TAG, "Setting " + name + " has moved from android.provider.Settings.System" + " to android.provider.Settings.Global");
        return Global.putStringForUser(resolver, name, value, userHandle);
    }
    return sNameValueCache.putStringForUser(resolver, name, value, userHandle);
}
------------------------
Find a silently evolved API code:android.app.NotificationManager.notifyAsUser:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    int[] idOut = new int[1];
    INotificationManager service = getService();
    String pkg = mContext.getPackageName();
    if (notification.sound != null) {
        notification.sound = notification.sound.getCanonicalUri();
        if (StrictMode.vmFileUriExposureEnabled()) {
            notification.sound.checkFileUriExposed("Notification.sound");
        }
    }
    if (localLOGV)
        Log.v(TAG, pkg + ": notify(" + id + ", " + notification + ")");
    try {
        service.enqueueNotificationWithTag(pkg, mContext.getOpPackageName(), tag, id, notification, idOut, user.getIdentifier());
        if (id != idOut[0]) {
            Log.w(TAG, "notify: id corrupted: sent " + id + ", got back " + idOut[0]);
        }
    } catch (RemoteException e) {
    }
}
Body of Second Method:
{
    int[] idOut = new int[1];
    INotificationManager service = getService();
    String pkg = mContext.getPackageName();
    if (notification.sound != null) {
        notification.sound = notification.sound.getCanonicalUri();
        if (StrictMode.vmFileUriExposureEnabled()) {
            notification.sound.checkFileUriExposed("Notification.sound");
        }
    }
    if (localLOGV)
        Log.v(TAG, pkg + ": notify(" + id + ", " + notification + ")");
    Notification stripped = notification.clone();
    Builder.stripForDelivery(stripped);
    try {
        service.enqueueNotificationWithTag(pkg, mContext.getOpPackageName(), tag, id, stripped, idOut, user.getIdentifier());
        if (id != idOut[0]) {
            Log.w(TAG, "notify: id corrupted: sent " + id + ", got back " + idOut[0]);
        }
    } catch (RemoteException e) {
    }
}
------------------------
Find a silently evolved API code:android.media.MediaRouter.UserRouteInfo.setPlaybackType:COMMENT
Method Modifier: public      
Comment:/**
 * Defines whether playback associated with this route is "local"
 * ({@link RouteInfo#PLAYBACK_TYPE_LOCAL}) or "remote"
 * ({@link RouteInfo#PLAYBACK_TYPE_REMOTE}).
 * @param type
 */

Body of Frist Method:
{
    if (mPlaybackType != type) {
        mPlaybackType = type;
        setPlaybackInfoOnRcc(RemoteControlClient.PLAYBACKINFO_PLAYBACK_TYPE, type);
    }
}
Body of Second Method:
{
    if (mPlaybackType != type) {
        mPlaybackType = type;
        configureSessionVolume();
    }
}
------------------------
Find a silently evolved API code:android.widget.DatePicker.getMinDate:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the minimal date supported by this {@link DatePicker} in
 * milliseconds since January 1, 1970 00:00:00 in
 * {@link TimeZone#getDefault()} time zone.
 * <p>
 * Note: The default minimal date is 01/01/1900.
 * <p>
 *
 * @return The minimal supported date.
 */

Body of Frist Method:
{
    return mCalendarView.getMinDate();
}
Body of Second Method:
{
    return mDelegate.getMinDate().getTimeInMillis();
}
------------------------
Find a silently evolved API code:android.animation.PropertyValuesHolder.setObjectValues:COMMENT
Method Modifier: public      
Comment:/**
 * Set the animated values for this object to this set of Objects.
 * If there is only one value, it is assumed to be the end value of an animation,
 * and an initial value will be derived, if possible, by calling a getter function
 * on the object. Also, if any value is null, the value will be filled in when the animation
 * starts in the same way. This mechanism of automatically getting null values only works
 * if the PropertyValuesHolder object is used in conjunction
 * {@link ObjectAnimator}, and with a getter function
 * derived automatically from <code>propertyName</code>, since otherwise PropertyValuesHolder has
 * no way of determining what the value should be.
 *
 * @param values One or more values that the animation will animate between.
 */

Body of Frist Method:
{
    mValueType = values[0].getClass();
    mKeyframeSet = KeyframeSet.ofObject(values);
}
Body of Second Method:
{
    mValueType = values[0].getClass();
    mKeyframes = KeyframeSet.ofObject(values);
    if (mEvaluator != null) {
        mKeyframes.setEvaluator(mEvaluator);
    }
}
------------------------
Find a silently evolved API code:android.graphics.Canvas.restoreToCount:COMMENT
<android.graphics.Canvas: void restoreToCount(int)>
public      native      ->public      
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * Efficient way to pop any calls to save() that happened after the save
 * count reached saveCount. It is an error for saveCount to be less than 1.
 *
 * Example:
 * int count = canvas.save();
 * ... // more calls potentially to save()
 * canvas.restoreToCount(count);
 * // now the canvas is back in the same state it was before the initial
 * // call to save().
 *
 * @param saveCount The save level to restore to.
 */

Body of Frist Method:

Body of Second Method:
{
    native_restoreToCount(mNativeCanvasWrapper, saveCount);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothSocket.flush:COMMENT
Method Modifier: default     
Comment:/*package*/

Body of Frist Method:
{
    if (VDBG)
        Log.d(TAG, "flush: " + mSocketOS);
    mSocketOS.flush();
}
Body of Second Method:
{
    if (mSocketOS == null)
        throw new IOException("flush is called on null OutputStream");
    if (VDBG)
        Log.d(TAG, "flush: " + mSocketOS);
    mSocketOS.flush();
}
------------------------
Find a silently evolved API code:android.media.AudioManager.querySoundEffectsEnabled:COMMENT
Method Modifier: private     
Comment:/**
 * Settings has an in memory cache, so this is fast.
 */

Body of Frist Method:
{
    return Settings.System.getInt(mContext.getContentResolver(), Settings.System.SOUND_EFFECTS_ENABLED, 0) != 0;
}
Body of Second Method:
{
    return Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SOUND_EFFECTS_ENABLED, 0, user) != 0;
}
------------------------
Find a silently evolved API code:android.service.dreams.DreamService.dispatchGenericMotionEvent:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (!mInteractive) {
        if (mDebug)
            Slog.v(TAG, "Finishing on genericMotionEvent");
        safelyFinish();
        return true;
    }
    return mWindow.superDispatchGenericMotionEvent(event);
}
Body of Second Method:
{
    if (!mInteractive) {
        if (mDebug)
            Slog.v(TAG, "Waking up on genericMotionEvent");
        wakeUp();
        return true;
    }
    return mWindow.superDispatchGenericMotionEvent(event);
}
------------------------
Find a silently evolved API code:android.view.accessibility.AccessibilityEvent.appendRecord:COMMENT
Method Modifier: public      
Comment:/**
 * Appends an {@link AccessibilityRecord} to the end of event records.
 *
 * @param record The record to append.
 *
 * @throws IllegalStateException If called from an AccessibilityService.
 */

Body of Frist Method:
{
    enforceNotSealed();
    mRecords.add(record);
}
Body of Second Method:
{
    enforceNotSealed();
    if (mRecords == null) {
        mRecords = new ArrayList<AccessibilityRecord>();
    }
    mRecords.add(record);
}
------------------------
Find a silently evolved API code:android.app.ActivityOptions.toBundle:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the created options as a Bundle, which can be passed to
 * {@link android.content.Context#startActivity(android.content.Intent, android.os.Bundle)
 * Context.startActivity(Intent, Bundle)} and related methods.
 * Note that the returned Bundle is still owned by the ActivityOptions
 * object; you must not modify it, but can supply it to the startActivity
 * methods that take an options Bundle.
 */

Body of Frist Method:
{
    Bundle b = new Bundle();
    if (mPackageName != null) {
        b.putString(KEY_PACKAGE_NAME, mPackageName);
    }
    switch(mAnimationType) {
        case ANIM_CUSTOM:
            b.putInt(KEY_ANIM_TYPE, mAnimationType);
            b.putInt(KEY_ANIM_ENTER_RES_ID, mCustomEnterResId);
            b.putInt(KEY_ANIM_EXIT_RES_ID, mCustomExitResId);
            b.putIBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_SCALE_UP:
            b.putInt(KEY_ANIM_TYPE, mAnimationType);
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_START_WIDTH, mStartWidth);
            b.putInt(KEY_ANIM_START_HEIGHT, mStartHeight);
            break;
        case ANIM_THUMBNAIL_SCALE_UP:
        case ANIM_THUMBNAIL_SCALE_DOWN:
            b.putInt(KEY_ANIM_TYPE, mAnimationType);
            b.putParcelable(KEY_ANIM_THUMBNAIL, mThumbnail);
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putIBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
    }
    return b;
}
Body of Second Method:
{
    if (mAnimationType == ANIM_DEFAULT) {
        return null;
    }
    Bundle b = new Bundle();
    if (mPackageName != null) {
        b.putString(KEY_PACKAGE_NAME, mPackageName);
    }
    b.putInt(KEY_ANIM_TYPE, mAnimationType);
    switch(mAnimationType) {
        case ANIM_CUSTOM:
            b.putInt(KEY_ANIM_ENTER_RES_ID, mCustomEnterResId);
            b.putInt(KEY_ANIM_EXIT_RES_ID, mCustomExitResId);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_SCALE_UP:
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            break;
        case ANIM_THUMBNAIL_SCALE_UP:
        case ANIM_THUMBNAIL_SCALE_DOWN:
        case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
        case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
            b.putParcelable(KEY_ANIM_THUMBNAIL, mThumbnail);
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_SCENE_TRANSITION:
            if (mTransitionReceiver != null) {
                b.putParcelable(KEY_TRANSITION_COMPLETE_LISTENER, mTransitionReceiver);
            }
            b.putBoolean(KEY_TRANSITION_IS_RETURNING, mIsReturning);
            b.putStringArrayList(KEY_TRANSITION_SHARED_ELEMENTS, mSharedElementNames);
            b.putParcelable(KEY_RESULT_DATA, mResultData);
            b.putInt(KEY_RESULT_CODE, mResultCode);
            b.putInt(KEY_EXIT_COORDINATOR_INDEX, mExitCoordinatorIndex);
            break;
    }
    return b;
}
------------------------
Find a silently evolved API code:android.view.ViewPropertyAnimator.setValue:COMMENT
Method Modifier: private     
Comment:/**
 * This method handles setting the property values directly in the View object's fields.
 * propertyConstant tells it which property should be set, value is the value to set
 * the property to.
 *
 * @param propertyConstant The property to be set
 * @param value The value to set the property to
 */

Body of Frist Method:
{
    final View.TransformationInfo info = mView.mTransformationInfo;
    final DisplayList displayList = mView.mDisplayList;
    switch(propertyConstant) {
        case TRANSLATION_X:
            info.mTranslationX = value;
            if (displayList != null)
                displayList.setTranslationX(value);
            break;
        case TRANSLATION_Y:
            info.mTranslationY = value;
            if (displayList != null)
                displayList.setTranslationY(value);
            break;
        case ROTATION:
            info.mRotation = value;
            if (displayList != null)
                displayList.setRotation(value);
            break;
        case ROTATION_X:
            info.mRotationX = value;
            if (displayList != null)
                displayList.setRotationX(value);
            break;
        case ROTATION_Y:
            info.mRotationY = value;
            if (displayList != null)
                displayList.setRotationY(value);
            break;
        case SCALE_X:
            info.mScaleX = value;
            if (displayList != null)
                displayList.setScaleX(value);
            break;
        case SCALE_Y:
            info.mScaleY = value;
            if (displayList != null)
                displayList.setScaleY(value);
            break;
        case X:
            info.mTranslationX = value - mView.mLeft;
            if (displayList != null)
                displayList.setTranslationX(value - mView.mLeft);
            break;
        case Y:
            info.mTranslationY = value - mView.mTop;
            if (displayList != null)
                displayList.setTranslationY(value - mView.mTop);
            break;
        case ALPHA:
            info.mAlpha = value;
            if (displayList != null)
                displayList.setAlpha(value);
            break;
    }
}
Body of Second Method:
{
    final View.TransformationInfo info = mView.mTransformationInfo;
    final RenderNode renderNode = mView.mRenderNode;
    switch(propertyConstant) {
        case TRANSLATION_X:
            renderNode.setTranslationX(value);
            break;
        case TRANSLATION_Y:
            renderNode.setTranslationY(value);
            break;
        case TRANSLATION_Z:
            renderNode.setTranslationZ(value);
            break;
        case ROTATION:
            renderNode.setRotation(value);
            break;
        case ROTATION_X:
            renderNode.setRotationX(value);
            break;
        case ROTATION_Y:
            renderNode.setRotationY(value);
            break;
        case SCALE_X:
            renderNode.setScaleX(value);
            break;
        case SCALE_Y:
            renderNode.setScaleY(value);
            break;
        case X:
            renderNode.setTranslationX(value - mView.mLeft);
            break;
        case Y:
            renderNode.setTranslationY(value - mView.mTop);
            break;
        case Z:
            renderNode.setTranslationZ(value - renderNode.getElevation());
            break;
        case ALPHA:
            info.mAlpha = value;
            renderNode.setAlpha(value);
            break;
    }
}
------------------------
Find a silently evolved API code:android.content.RestrictionEntry.getSelectedState:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the current selected state for an entry of type {@link #TYPE_BOOLEAN}.
 * @return the current selected state of the entry.
 */

Body of Frist Method:
{
    return Boolean.parseBoolean(currentValue);
}
Body of Second Method:
{
    return Boolean.parseBoolean(mCurrentValue);
}
------------------------
Find a silently evolved API code:android.database.sqlite.SQLiteDatabase.deleteDatabase:COMMENT
Method Modifier: public      static      
Comment:/**
 * Deletes a database including its journal file and other auxiliary files
 * that may have been created by the database engine.
 *
 * @param file The database file path.
 * @return True if the database was successfully deleted.
 */

Body of Frist Method:
{
    if (file == null) {
        throw new IllegalArgumentException("file must not be null");
    }
    boolean deleted = false;
    deleted |= file.delete();
    deleted |= new File(file.getPath() + "-journal").delete();
    deleted |= new File(file.getPath() + "-shm").delete();
    deleted |= new File(file.getPath() + "-wal").delete();
    File dir = file.getParentFile();
    if (dir != null) {
        final String prefix = file.getName() + "-mj";
        final FileFilter filter = new FileFilter() {

            @Override
            public boolean accept(File candidate) {
                return candidate.getName().startsWith(prefix);
            }
        };
        for (File masterJournal : dir.listFiles(filter)) {
            deleted |= masterJournal.delete();
        }
    }
    return deleted;
}
Body of Second Method:
{
    if (file == null) {
        throw new IllegalArgumentException("file must not be null");
    }
    boolean deleted = false;
    deleted |= file.delete();
    deleted |= new File(file.getPath() + "-journal").delete();
    deleted |= new File(file.getPath() + "-shm").delete();
    deleted |= new File(file.getPath() + "-wal").delete();
    File dir = file.getParentFile();
    if (dir != null) {
        final String prefix = file.getName() + "-mj";
        File[] files = dir.listFiles(new FileFilter() {

            @Override
            public boolean accept(File candidate) {
                return candidate.getName().startsWith(prefix);
            }
        });
        if (files != null) {
            for (File masterJournal : files) {
                deleted |= masterJournal.delete();
            }
        }
    }
    return deleted;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothAdapter.getProfileProxy:COMMENT
Method Modifier: public      
Comment:/**
 * Get the profile proxy object associated with the profile.
 *
 * <p>Profile can be one of {@link BluetoothProfile#HEALTH}, {@link BluetoothProfile#HEADSET},
 * {@link BluetoothProfile#A2DP}, {@link BluetoothProfile#GATT}, or
 * {@link BluetoothProfile#GATT_SERVER}. Clients must implement
 * {@link BluetoothProfile.ServiceListener} to get notified of
 * the connection status and to get the proxy object.
 *
 * @param context Context of the application
 * @param listener The service Listener for connection callbacks.
 * @param profile The Bluetooth profile; either {@link BluetoothProfile#HEALTH},
 * {@link BluetoothProfile#HEADSET} or {@link BluetoothProfile#A2DP}.
 * @return true on success, false on error
 */

Body of Frist Method:
{
    if (context == null || listener == null)
        return false;
    if (profile == BluetoothProfile.HEADSET) {
        BluetoothHeadset headset = new BluetoothHeadset(context, listener);
        return true;
    } else if (profile == BluetoothProfile.A2DP) {
        BluetoothA2dp a2dp = new BluetoothA2dp(context, listener);
        return true;
    } else if (profile == BluetoothProfile.INPUT_DEVICE) {
        BluetoothInputDevice iDev = new BluetoothInputDevice(context, listener);
        return true;
    } else if (profile == BluetoothProfile.PAN) {
        BluetoothPan pan = new BluetoothPan(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEALTH) {
        BluetoothHealth health = new BluetoothHealth(context, listener);
        return true;
    } else if (profile == BluetoothProfile.MAP) {
        BluetoothMap map = new BluetoothMap(context, listener);
        return true;
    } else {
        return false;
    }
}
Body of Second Method:
{
    if (context == null || listener == null)
        return false;
    if (profile == BluetoothProfile.HEADSET) {
        BluetoothHeadset headset = new BluetoothHeadset(context, listener);
        return true;
    } else if (profile == BluetoothProfile.A2DP) {
        BluetoothA2dp a2dp = new BluetoothA2dp(context, listener);
        return true;
    } else if (profile == BluetoothProfile.A2DP_SINK) {
        BluetoothA2dpSink a2dpSink = new BluetoothA2dpSink(context, listener);
        return true;
    } else if (profile == BluetoothProfile.AVRCP_CONTROLLER) {
        BluetoothAvrcpController avrcp = new BluetoothAvrcpController(context, listener);
        return true;
    } else if (profile == BluetoothProfile.INPUT_DEVICE) {
        BluetoothInputDevice iDev = new BluetoothInputDevice(context, listener);
        return true;
    } else if (profile == BluetoothProfile.PAN) {
        BluetoothPan pan = new BluetoothPan(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEALTH) {
        BluetoothHealth health = new BluetoothHealth(context, listener);
        return true;
    } else if (profile == BluetoothProfile.MAP) {
        BluetoothMap map = new BluetoothMap(context, listener);
        return true;
    } else if (profile == BluetoothProfile.HEADSET_CLIENT) {
        BluetoothHeadsetClient headsetClient = new BluetoothHeadsetClient(context, listener);
        return true;
    } else {
        return false;
    }
}
------------------------
Find a silently evolved API code:android.graphics.Matrix.postConcat:COMMENT
Method Modifier: public      
Comment:/**
 * Postconcats the matrix with the specified matrix.
 * M' = other * M
 */

Body of Frist Method:
{
    return native_postConcat(native_instance, other.native_instance);
}
Body of Second Method:
{
    native_postConcat(native_instance, other.native_instance);
    return true;
}
------------------------
Find a silently evolved API code:android.os.Bundle.clear:COMMENT
Method Modifier: public      
Comment:/**
 * Removes all elements from the mapping of this Bundle.
 */

Body of Frist Method:
{
    unparcel();
    mMap.clear();
    mHasFds = false;
    mFdsKnown = true;
}
Body of Second Method:
{
    super.clear();
    mHasFds = false;
    mFdsKnown = true;
}
------------------------
Find a silently evolved API code:android.os.Bundle.getClassLoader:COMMENT
Method Modifier: public      
Comment:/**
 * Return the ClassLoader currently associated with this Bundle.
 */

Body of Frist Method:
{
    return mClassLoader;
}
Body of Second Method:
{
    return super.getClassLoader();
}
------------------------
Find a silently evolved API code:android.media.MediaRouter.RouteInfo.getStatusCode:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return mStatusCode;
}
Body of Second Method:
{
    return mResolvedStatusCode;
}
------------------------
Find a silently evolved API code:android.graphics.Typeface.create:COMMENT
Method Modifier: public      static      
Comment:/**
 * Create a typeface object that best matches the specified existing
 * typeface and the specified Style. Use this call if you want to pick a new
 * style from the same family of an existing typeface object. If family is
 * null, this selects from the default font's family.
 *
 * @param family May be null. The name of the existing type face.
 * @param style  The style (normal, bold, italic) of the typeface.
 * e.g. NORMAL, BOLD, ITALIC, BOLD_ITALIC
 * @return The best matching typeface.
 */

Body of Frist Method:
{
    int ni = 0;
    if (family != null) {
        // Return early if we're asked for the same face/style
        if (family.mStyle == style) {
            return family;
        }
        ni = family.native_instance;
    }
    Typeface typeface;
    SparseArray<Typeface> styles = sTypefaceCache.get(ni);
    if (styles != null) {
        typeface = styles.get(style);
        if (typeface != null) {
            return typeface;
        }
    }
    typeface = new Typeface(nativeCreateFromTypeface(ni, style));
    if (styles == null) {
        styles = new SparseArray<Typeface>(4);
        sTypefaceCache.put(ni, styles);
    }
    styles.put(style, typeface);
    return typeface;
}
Body of Second Method:
{
    if (style < 0 || style > 3) {
        style = 0;
    }
    long ni = 0;
    if (family != null) {
        // Return early if we're asked for the same face/style
        if (family.mStyle == style) {
            return family;
        }
        ni = family.native_instance;
    }
    Typeface typeface;
    SparseArray<Typeface> styles = sTypefaceCache.get(ni);
    if (styles != null) {
        typeface = styles.get(style);
        if (typeface != null) {
            return typeface;
        }
    }
    typeface = new Typeface(nativeCreateFromTypeface(ni, style));
    if (styles == null) {
        styles = new SparseArray<Typeface>(4);
        sTypefaceCache.put(ni, styles);
    }
    styles.put(style, typeface);
    return typeface;
}
------------------------
Find a silently evolved API code:android.media.AudioManager.dispatchMediaKeyEvent:COMMENT
Method Modifier: public      
Comment:/**
 * Sends a simulated key event for a media button.
 * To simulate a key press, you must first send a KeyEvent built with a
 * {@link KeyEvent#ACTION_DOWN} action, then another event with the {@link KeyEvent#ACTION_UP}
 * action.
 * <p>The key event will be sent to the current media key event consumer which registered with
 * {@link AudioManager#registerMediaButtonEventReceiver(PendingIntent)}.
 * @param keyEvent a {@link KeyEvent} instance whose key code is one of
 * {@link KeyEvent#KEYCODE_MUTE},
 * {@link KeyEvent#KEYCODE_HEADSETHOOK},
 * {@link KeyEvent#KEYCODE_MEDIA_PLAY},
 * {@link KeyEvent#KEYCODE_MEDIA_PAUSE},
 * {@link KeyEvent#KEYCODE_MEDIA_PLAY_PAUSE},
 * {@link KeyEvent#KEYCODE_MEDIA_STOP},
 * {@link KeyEvent#KEYCODE_MEDIA_NEXT},
 * {@link KeyEvent#KEYCODE_MEDIA_PREVIOUS},
 * {@link KeyEvent#KEYCODE_MEDIA_REWIND},
 * {@link KeyEvent#KEYCODE_MEDIA_RECORD},
 * {@link KeyEvent#KEYCODE_MEDIA_FAST_FORWARD},
 * {@link KeyEvent#KEYCODE_MEDIA_CLOSE},
 * {@link KeyEvent#KEYCODE_MEDIA_EJECT},
 * or {@link KeyEvent#KEYCODE_MEDIA_AUDIO_TRACK}.
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        service.dispatchMediaKeyEvent(keyEvent);
    } catch (RemoteException e) {
        Log.e(TAG, "dispatchMediaKeyEvent threw exception ", e);
    }
}
Body of Second Method:
{
    MediaSessionLegacyHelper helper = MediaSessionLegacyHelper.getHelper(mContext);
    helper.sendMediaButtonEvent(keyEvent, false);
}
------------------------
Find a silently evolved API code:android.media.RemoteControlClient.MetadataEditor.apply:COMMENT
<android.media.RemoteControlClient.MetadataEditor: void apply()>
public      ->public      deprecated  
Method Modifier: public      deprecated  
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Associates all the metadata that has been set since the MetadataEditor instance was
 * created with {@link RemoteControlClient#editMetadata(boolean)}, or since
 * {@link #clear()} was called, with the RemoteControlClient. Once "applied",
 * this MetadataEditor cannot be reused to edit the RemoteControlClient's metadata.
 */

Body of Frist Method:
{
    if (mApplied) {
        Log.e(TAG, "Can't apply a previously applied MetadataEditor");
        return;
    }
    synchronized (mCacheLock) {
        // assign the edited data
        mMetadata = new Bundle(mEditorMetadata);
        // add the information about editable keys
        mMetadata.putLong(String.valueOf(KEY_EDITABLE_MASK), mEditableKeys);
        if ((mOriginalArtwork != null) && (!mOriginalArtwork.equals(mEditorArtwork))) {
            mOriginalArtwork.recycle();
        }
        mOriginalArtwork = mEditorArtwork;
        mEditorArtwork = null;
        if (mMetadataChanged & mArtworkChanged) {
            // send to remote control display if conditions are met
            sendMetadataWithArtwork_syncCacheLock(null, 0, 0);
        } else if (mMetadataChanged) {
            // send to remote control display if conditions are met
            sendMetadata_syncCacheLock(null);
        } else if (mArtworkChanged) {
            // send to remote control display if conditions are met
            sendArtwork_syncCacheLock(null, 0, 0);
        }
        mApplied = true;
    }
}
Body of Second Method:
{
    if (mApplied) {
        Log.e(TAG, "Can't apply a previously applied MetadataEditor");
        return;
    }
    synchronized (mCacheLock) {
        // Still build the old metadata so when creating a new editor
        // you get the expected values.
        // assign the edited data
        mMetadata = new Bundle(mEditorMetadata);
        // add the information about editable keys
        mMetadata.putLong(String.valueOf(KEY_EDITABLE_MASK), mEditableKeys);
        if ((mOriginalArtwork != null) && (!mOriginalArtwork.equals(mEditorArtwork))) {
            mOriginalArtwork.recycle();
        }
        mOriginalArtwork = mEditorArtwork;
        mEditorArtwork = null;
        // USE_SESSIONS
        if (mSession != null && mMetadataBuilder != null) {
            mMediaMetadata = mMetadataBuilder.build();
            mSession.setMetadata(mMediaMetadata);
        }
        mApplied = true;
    }
}
------------------------
Find a silently evolved API code:android.text.TextUtils.getLayoutDirectionFromLocale:COMMENT
Method Modifier: public      static      
Comment:/**
 * Return the layout direction for a given Locale
 *
 * @param locale the Locale for which we want the layout direction. Can be null.
 * @return the layout direction. This may be one of:
 * {@link android.view.View#LAYOUT_DIRECTION_LTR} or
 * {@link android.view.View#LAYOUT_DIRECTION_RTL}.
 *
 * Be careful: this code will need to be updated when vertical scripts will be supported
 */

Body of Frist Method:
{
    if (locale != null && !locale.equals(Locale.ROOT)) {
        final String scriptSubtag = ICU.getScript(ICU.addLikelySubtags(locale.toString()));
        if (scriptSubtag == null)
            return getLayoutDirectionFromFirstChar(locale);
        if (scriptSubtag.equalsIgnoreCase(ARAB_SCRIPT_SUBTAG) || scriptSubtag.equalsIgnoreCase(HEBR_SCRIPT_SUBTAG)) {
            return View.LAYOUT_DIRECTION_RTL;
        }
    }
    // If forcing into RTL layout mode, return RTL as default, else LTR
    return SystemProperties.getBoolean(Settings.Global.DEVELOPMENT_FORCE_RTL, false) ? View.LAYOUT_DIRECTION_RTL : View.LAYOUT_DIRECTION_LTR;
}
Body of Second Method:
{
    if (locale != null && !locale.equals(Locale.ROOT)) {
        final String scriptSubtag = ICU.addLikelySubtags(locale).getScript();
        if (scriptSubtag == null)
            return getLayoutDirectionFromFirstChar(locale);
        if (scriptSubtag.equalsIgnoreCase(ARAB_SCRIPT_SUBTAG) || scriptSubtag.equalsIgnoreCase(HEBR_SCRIPT_SUBTAG)) {
            return View.LAYOUT_DIRECTION_RTL;
        }
    }
    // If forcing into RTL layout mode, return RTL as default, else LTR
    return SystemProperties.getBoolean(Settings.Global.DEVELOPMENT_FORCE_RTL, false) ? View.LAYOUT_DIRECTION_RTL : View.LAYOUT_DIRECTION_LTR;
}
------------------------
Find a silently evolved API code:android.print.PrintManager.getEnabledPrintServices:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Gets the list of enabled print services.
 *
 * @return The enabled service list or an empty list.
 * @hide
 */

Body of Frist Method:
{
    try {
        List<PrintServiceInfo> enabledServices = mService.getEnabledPrintServices(mUserId);
        if (enabledServices != null) {
            return enabledServices;
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, "Error getting the enabled print services", re);
    }
    return Collections.emptyList();
}
Body of Second Method:
{
    if (mService == null) {
        Log.w(LOG_TAG, "Feature android.software.print not available");
        return Collections.emptyList();
    }
    try {
        List<PrintServiceInfo> enabledServices = mService.getEnabledPrintServices(mUserId);
        if (enabledServices != null) {
            return enabledServices;
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, "Error getting the enabled print services", re);
    }
    return Collections.emptyList();
}
------------------------
Find a silently evolved API code:android.app.NotificationManager.notify:COMMENT
Method Modifier: public      
Comment:/**
 * Post a notification to be shown in the status bar. If a notification with
 * the same tag and id has already been posted by your application and has not yet been
 * canceled, it will be replaced by the updated information.
 *
 * @param tag A string identifier for this notification.  May be {@code null}.
 * @param id An identifier for this notification.  The pair (tag, id) must be unique
 * within your application.
 * @param notification A {@link Notification} object describing what to
 * show the user. Must not be null.
 */

Body of Frist Method:
{
    int[] idOut = new int[1];
    INotificationManager service = getService();
    String pkg = mContext.getPackageName();
    if (notification.sound != null) {
        notification.sound = notification.sound.getCanonicalUri();
        if (StrictMode.vmFileUriExposureEnabled()) {
            notification.sound.checkFileUriExposed("Notification.sound");
        }
    }
    if (localLOGV)
        Log.v(TAG, pkg + ": notify(" + id + ", " + notification + ")");
    try {
        service.enqueueNotificationWithTag(pkg, mContext.getOpPackageName(), tag, id, notification, idOut, UserHandle.myUserId());
        if (id != idOut[0]) {
            Log.w(TAG, "notify: id corrupted: sent " + id + ", got back " + idOut[0]);
        }
    } catch (RemoteException e) {
    }
}
Body of Second Method:
{
    int[] idOut = new int[1];
    INotificationManager service = getService();
    String pkg = mContext.getPackageName();
    if (notification.sound != null) {
        notification.sound = notification.sound.getCanonicalUri();
        if (StrictMode.vmFileUriExposureEnabled()) {
            notification.sound.checkFileUriExposed("Notification.sound");
        }
    }
    if (localLOGV)
        Log.v(TAG, pkg + ": notify(" + id + ", " + notification + ")");
    Notification stripped = notification.clone();
    Builder.stripForDelivery(stripped);
    try {
        service.enqueueNotificationWithTag(pkg, mContext.getOpPackageName(), tag, id, stripped, idOut, UserHandle.myUserId());
        if (id != idOut[0]) {
            Log.w(TAG, "notify: id corrupted: sent " + id + ", got back " + idOut[0]);
        }
    } catch (RemoteException e) {
    }
}
------------------------
Find a silently evolved API code:android.widget.QuickContactBadge.setImageToDefault:COMMENT
Method Modifier: public      
Comment:/**
 * Resets the contact photo to the default state.
 */

Body of Frist Method:
{
    if (mDefaultAvatar == null) {
        mDefaultAvatar = getResources().getDrawable(R.drawable.ic_contact_picture);
    }
    setImageDrawable(mDefaultAvatar);
}
Body of Second Method:
{
    if (mDefaultAvatar == null) {
        mDefaultAvatar = mContext.getDrawable(R.drawable.ic_contact_picture);
    }
    setImageDrawable(mDefaultAvatar);
}
------------------------
Find a silently evolved API code:android.provider.Browser.requestAllIcons:COMMENT
Method Modifier: public      static      final       
Comment:/**
 * Request all icons from the database.  This call must either be called
 * in the main thread or have had Looper.prepare() invoked in the calling
 * thread.
 * Requires {@link android.Manifest.permission#READ_HISTORY_BOOKMARKS}
 * @param  cr The ContentResolver used to access the database.
 * @param  where Clause to be used to limit the query from the database.
 * Must be an allowable string to be passed into a database query.
 * @param  listener IconListener that gets the icons once they are
 * retrieved.
 */

Body of Frist Method:
{
    WebIconDatabase.getInstance().bulkRequestIconForPageUrl(cr, where, listener);
}
Body of Second Method:
{
// Do nothing: this is no longer used.
}
------------------------
Find a silently evolved API code:android.media.AudioService.getMasterStreamType:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @see AudioManager#getMasterStreamType()
 */

Body of Frist Method:
{
    if (mVoiceCapable) {
        return AudioSystem.STREAM_RING;
    } else {
        return AudioSystem.STREAM_MUSIC;
    }
}
Body of Second Method:
{
    return mStreamVolumeAlias[AudioSystem.STREAM_SYSTEM];
}
------------------------
Find a silently evolved API code:android.provider.DocumentsProvider.openTypedAssetFile:COMMENT
Method Modifier: public      final       
Comment:/**
 * Implementation is provided by the parent class. Cannot be overriden.
 *
 * @see #openDocumentThumbnail(String, Point, CancellationSignal)
 */

Body of Frist Method:
{
    if (opts != null && opts.containsKey(EXTRA_THUMBNAIL_SIZE)) {
        final Point sizeHint = opts.getParcelable(EXTRA_THUMBNAIL_SIZE);
        return openDocumentThumbnail(getDocumentId(uri), sizeHint, null);
    } else {
        return super.openTypedAssetFile(uri, mimeTypeFilter, opts);
    }
}
Body of Second Method:
{
    enforceTree(uri);
    if (opts != null && opts.containsKey(ContentResolver.EXTRA_SIZE)) {
        final Point sizeHint = opts.getParcelable(ContentResolver.EXTRA_SIZE);
        return openDocumentThumbnail(getDocumentId(uri), sizeHint, signal);
    } else {
        return super.openTypedAssetFile(uri, mimeTypeFilter, opts, signal);
    }
}
------------------------
Find a silently evolved API code:android.widget.GridLayout.measureChildrenWithMargins:COMMENT
Method Modifier: private     
Comment:// Note: padding has already been removed from the supplied specs

Body of Frist Method:
{
    for (int i = 0, N = getChildCount(); i < N; i++) {
        View c = getChildAt(i);
        if (c.getVisibility() == View.GONE)
            continue;
        LayoutParams lp = getLayoutParams(c);
        if (firstPass) {
            measureChildWithMargins2(c, widthSpec, heightSpec, lp.width, lp.height);
        } else {
            boolean horizontal = (mOrientation == HORIZONTAL);
            Spec spec = horizontal ? lp.columnSpec : lp.rowSpec;
            if (spec.alignment == FILL) {
                Interval span = spec.span;
                Axis axis = horizontal ? mHorizontalAxis : mVerticalAxis;
                int[] locations = axis.getLocations();
                int cellSize = locations[span.max] - locations[span.min];
                int viewSize = cellSize - getTotalMargin(c, horizontal);
                if (horizontal) {
                    measureChildWithMargins2(c, widthSpec, heightSpec, viewSize, lp.height);
                } else {
                    measureChildWithMargins2(c, widthSpec, heightSpec, lp.width, viewSize);
                }
            }
        }
    }
}
Body of Second Method:
{
    for (int i = 0, N = getChildCount(); i < N; i++) {
        View c = getChildAt(i);
        if (c.getVisibility() == View.GONE)
            continue;
        LayoutParams lp = getLayoutParams(c);
        if (firstPass) {
            measureChildWithMargins2(c, widthSpec, heightSpec, lp.width, lp.height);
            mHorizontalAxis.recordOriginalMeasurement(i);
            mVerticalAxis.recordOriginalMeasurement(i);
        } else {
            boolean horizontal = (mOrientation == HORIZONTAL);
            Spec spec = horizontal ? lp.columnSpec : lp.rowSpec;
            if (spec.alignment == FILL) {
                Interval span = spec.span;
                Axis axis = horizontal ? mHorizontalAxis : mVerticalAxis;
                int[] locations = axis.getLocations();
                int cellSize = locations[span.max] - locations[span.min];
                int viewSize = cellSize - getTotalMargin(c, horizontal);
                if (horizontal) {
                    measureChildWithMargins2(c, widthSpec, heightSpec, viewSize, lp.height);
                } else {
                    measureChildWithMargins2(c, widthSpec, heightSpec, lp.width, viewSize);
                }
            }
        }
    }
}
------------------------
Find a silently evolved API code:android.graphics.Matrix.preSkew:COMMENT
Method Modifier: public      
Comment:/**
 * Preconcats the matrix with the specified skew.
 * M' = M * K(kx, ky, px, py)
 */

Body of Frist Method:
{
    return native_preSkew(native_instance, kx, ky, px, py);
}
Body of Second Method:
{
    native_preSkew(native_instance, kx, ky, px, py);
    return true;
}
------------------------
Find a silently evolved API code:android.util.LongSparseArray.append:COMMENT
Method Modifier: public      
Comment:/**
 * Puts a key/value pair into the array, optimizing for the case where
 * the key is greater than all existing keys in the array.
 */

Body of Frist Method:
{
    if (mSize != 0 && key <= mKeys[mSize - 1]) {
        put(key, value);
        return;
    }
    if (mGarbage && mSize >= mKeys.length) {
        gc();
    }
    int pos = mSize;
    if (pos >= mKeys.length) {
        int n = ArrayUtils.idealLongArraySize(pos + 1);
        long[] nkeys = new long[n];
        Object[] nvalues = new Object[n];
        // Log.e("SparseArray", "grow " + mKeys.length + " to " + n);
        System.arraycopy(mKeys, 0, nkeys, 0, mKeys.length);
        System.arraycopy(mValues, 0, nvalues, 0, mValues.length);
        mKeys = nkeys;
        mValues = nvalues;
    }
    mKeys[pos] = key;
    mValues[pos] = value;
    mSize = pos + 1;
}
Body of Second Method:
{
    if (mSize != 0 && key <= mKeys[mSize - 1]) {
        put(key, value);
        return;
    }
    if (mGarbage && mSize >= mKeys.length) {
        gc();
    }
    mKeys = GrowingArrayUtils.append(mKeys, mSize, key);
    mValues = GrowingArrayUtils.append(mValues, mSize, value);
    mSize++;
}
------------------------
Find a silently evolved API code:android.content.res.ColorStateList.createFromXml:COMMENT
Method Modifier: public      static      
Comment:/**
 * Create a ColorStateList from an XML document, given a set of {@link Resources}.
 */

Body of Frist Method:
{
    AttributeSet attrs = Xml.asAttributeSet(parser);
    int type;
    while ((type = parser.next()) != XmlPullParser.START_TAG && type != XmlPullParser.END_DOCUMENT) {
    }
    if (type != XmlPullParser.START_TAG) {
        throw new XmlPullParserException("No start tag found");
    }
    return createFromXmlInner(r, parser, attrs);
}
Body of Second Method:
{
    final AttributeSet attrs = Xml.asAttributeSet(parser);
    int type;
    while ((type = parser.next()) != XmlPullParser.START_TAG && type != XmlPullParser.END_DOCUMENT) {
    }
    if (type != XmlPullParser.START_TAG) {
        throw new XmlPullParserException("No start tag found");
    }
    return createFromXmlInner(r, parser, attrs);
}
------------------------
Find a silently evolved API code:android.media.RemoteControlClient.setTransportControlFlags:COMMENT
<android.media.RemoteControlClient: void setTransportControlFlags(int)>
public      ->public      deprecated  
Method Modifier: public      deprecated  
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Sets the flags for the media transport control buttons that this client supports.
 * @param transportControlFlags A combination of the following flags:
 * {@link #FLAG_KEY_MEDIA_PREVIOUS},
 * {@link #FLAG_KEY_MEDIA_REWIND},
 * {@link #FLAG_KEY_MEDIA_PLAY},
 * {@link #FLAG_KEY_MEDIA_PLAY_PAUSE},
 * {@link #FLAG_KEY_MEDIA_PAUSE},
 * {@link #FLAG_KEY_MEDIA_STOP},
 * {@link #FLAG_KEY_MEDIA_FAST_FORWARD},
 * {@link #FLAG_KEY_MEDIA_NEXT},
 * {@link #FLAG_KEY_MEDIA_POSITION_UPDATE},
 * {@link #FLAG_KEY_MEDIA_RATING}.
 */

Body of Frist Method:
{
    synchronized (mCacheLock) {
        // store locally
        mTransportControlFlags = transportControlFlags;
        // send to remote control display if conditions are met
        sendTransportControlInfo_syncCacheLock(null);
    }
}
Body of Second Method:
{
    synchronized (mCacheLock) {
        // store locally
        mTransportControlFlags = transportControlFlags;
        // USE_SESSIONS
        if (mSession != null) {
            PlaybackState.Builder bob = new PlaybackState.Builder(mSessionPlaybackState);
            bob.setActions(PlaybackState.getActionsFromRccControlFlags(transportControlFlags));
            mSessionPlaybackState = bob.build();
            mSession.setPlaybackState(mSessionPlaybackState);
        }
    }
}
------------------------
Find a silently evolved API code:android.nfc.NfcActivityManager.createBeamShareData:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Callback from NFC service, usually on binder thread
 */

Body of Frist Method:
{
    NfcAdapter.CreateNdefMessageCallback ndefCallback;
    NfcAdapter.CreateBeamUrisCallback urisCallback;
    NdefMessage message;
    Uri[] uris;
    int flags;
    synchronized (NfcActivityManager.this) {
        NfcActivityState state = findResumedActivityState();
        if (state == null)
            return null;
        ndefCallback = state.ndefMessageCallback;
        urisCallback = state.uriCallback;
        message = state.ndefMessage;
        uris = state.uris;
        flags = state.flags;
    }
    // Make callbacks without lock
    if (ndefCallback != null) {
        message = ndefCallback.createNdefMessage(mDefaultEvent);
    }
    if (urisCallback != null) {
        uris = urisCallback.createBeamUris(mDefaultEvent);
        if (uris != null) {
            for (Uri uri : uris) {
                if (uri == null) {
                    Log.e(TAG, "Uri not allowed to be null.");
                    return null;
                }
                String scheme = uri.getScheme();
                if (scheme == null || (!scheme.equalsIgnoreCase("file") && !scheme.equalsIgnoreCase("content"))) {
                    Log.e(TAG, "Uri needs to have " + "either scheme file or scheme content");
                    return null;
                }
            }
        }
    }
    return new BeamShareData(message, uris, flags);
}
Body of Second Method:
{
    NfcAdapter.CreateNdefMessageCallback ndefCallback;
    NfcAdapter.CreateBeamUrisCallback urisCallback;
    NdefMessage message;
    Activity activity;
    Uri[] uris;
    int flags;
    synchronized (NfcActivityManager.this) {
        NfcActivityState state = findResumedActivityState();
        if (state == null)
            return null;
        ndefCallback = state.ndefMessageCallback;
        urisCallback = state.uriCallback;
        message = state.ndefMessage;
        uris = state.uris;
        flags = state.flags;
        activity = state.activity;
    }
    // Make callbacks without lock
    if (ndefCallback != null) {
        message = ndefCallback.createNdefMessage(mDefaultEvent);
    }
    if (urisCallback != null) {
        uris = urisCallback.createBeamUris(mDefaultEvent);
        if (uris != null) {
            for (Uri uri : uris) {
                if (uri == null) {
                    Log.e(TAG, "Uri not allowed to be null.");
                    return null;
                }
                String scheme = uri.getScheme();
                if (scheme == null || (!scheme.equalsIgnoreCase("file") && !scheme.equalsIgnoreCase("content"))) {
                    Log.e(TAG, "Uri needs to have " + "either scheme file or scheme content");
                    return null;
                }
            }
        }
    }
    if (uris != null && uris.length > 0) {
        for (Uri uri : uris) {
            // Grant the NFC process permission to read these URIs
            activity.grantUriPermission("com.android.nfc", uri, Intent.FLAG_GRANT_READ_URI_PERMISSION);
        }
    }
    return new BeamShareData(message, uris, flags);
}
------------------------
Find a silently evolved API code:android.view.inputmethod.BaseInputConnection.setSelection:COMMENT
Method Modifier: public      
Comment:/**
 * The default implementation changes the selection position in the
 * current editable text.
 */

Body of Frist Method:
{
    if (DEBUG)
        Log.v(TAG, "setSelection " + start + ", " + end);
    final Editable content = getEditable();
    if (content == null)
        return false;
    int len = content.length();
    if (start > len || end > len) {
        // anyway.
        return true;
    }
    if (start == end && MetaKeyKeyListener.getMetaState(content, MetaKeyKeyListener.META_SELECTING) != 0) {
        // If we are in selection mode, then we want to extend the
        // selection instead of replacing it.
        Selection.extendSelection(content, start);
    } else {
        Selection.setSelection(content, start, end);
    }
    return true;
}
Body of Second Method:
{
    if (DEBUG)
        Log.v(TAG, "setSelection " + start + ", " + end);
    final Editable content = getEditable();
    if (content == null)
        return false;
    int len = content.length();
    if (start > len || end > len || start < 0 || end < 0) {
        // anyway.
        return true;
    }
    if (start == end && MetaKeyKeyListener.getMetaState(content, MetaKeyKeyListener.META_SELECTING) != 0) {
        // If we are in selection mode, then we want to extend the
        // selection instead of replacing it.
        Selection.extendSelection(content, start);
    } else {
        Selection.setSelection(content, start, end);
    }
    return true;
}
------------------------
Find a silently evolved API code:android.preference.PreferenceFragment.setPreferenceScreen:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the root of the preference hierarchy that this fragment is showing.
 *
 * @param preferenceScreen The root {@link PreferenceScreen} of the preference hierarchy.
 */

Body of Frist Method:
{
    if (mPreferenceManager.setPreferences(preferenceScreen) && preferenceScreen != null) {
        mHavePrefs = true;
        if (mInitDone) {
            postBindPreferences();
        }
    }
}
Body of Second Method:
{
    if (mPreferenceManager.setPreferences(preferenceScreen) && preferenceScreen != null) {
        onUnbindPreferences();
        mHavePrefs = true;
        if (mInitDone) {
            postBindPreferences();
        }
    }
}
------------------------
Find a silently evolved API code:javax.obex.ObexHelper.createHeader:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Creates the header part of OBEX packet based on the header provided.
 * TODO: Could use getHeaderList() to get the array of headers to include
 * and then use the high two bits to determine the the type of the object
 * and construct the byte array from that. This will make the size smaller.
 * @param head the header used to construct the byte array
 * @param nullOut <code>true</code> if the header should be set to
 * <code>null</code> once it is added to the array or
 * <code>false</code> if it should not be nulled out
 * @return the header of an OBEX packet
 */

Body of Frist Method:
{
    Long intHeader = null;
    String stringHeader = null;
    Calendar dateHeader = null;
    Byte byteHeader = null;
    StringBuffer buffer = null;
    byte[] value = null;
    byte[] result = null;
    byte[] lengthArray = new byte[2];
    int length;
    HeaderSet headImpl = null;
    ByteArrayOutputStream out = new ByteArrayOutputStream();
    headImpl = head;
    try {
        /*
             * Determine if there is a connection ID to send.  If there is,
             * then it should be the first header in the packet.
             */
        if ((headImpl.mConnectionID != null) && (headImpl.getHeader(HeaderSet.TARGET) == null)) {
            out.write((byte) HeaderSet.CONNECTION_ID);
            out.write(headImpl.mConnectionID);
        }
        // Count Header
        intHeader = (Long) headImpl.getHeader(HeaderSet.COUNT);
        if (intHeader != null) {
            out.write((byte) HeaderSet.COUNT);
            value = ObexHelper.convertToByteArray(intHeader.longValue());
            out.write(value);
            if (nullOut) {
                headImpl.setHeader(HeaderSet.COUNT, null);
            }
        }
        // Name Header
        stringHeader = (String) headImpl.getHeader(HeaderSet.NAME);
        if (stringHeader != null) {
            out.write((byte) HeaderSet.NAME);
            value = ObexHelper.convertToUnicodeByteArray(stringHeader);
            length = value.length + 3;
            lengthArray[0] = (byte) (0xFF & (length >> 8));
            lengthArray[1] = (byte) (0xFF & length);
            out.write(lengthArray);
            out.write(value);
            if (nullOut) {
                headImpl.setHeader(HeaderSet.NAME, null);
            }
        }
        // Type Header
        stringHeader = (String) headImpl.getHeader(HeaderSet.TYPE);
        if (stringHeader != null) {
            out.write((byte) HeaderSet.TYPE);
            try {
                value = stringHeader.getBytes("ISO8859_1");
            } catch (UnsupportedEncodingException e) {
                throw e;
            }
            length = value.length + 4;
            lengthArray[0] = (byte) (255 & (length >> 8));
            lengthArray[1] = (byte) (255 & length);
            out.write(lengthArray);
            out.write(value);
            out.write(0x00);
            if (nullOut) {
                headImpl.setHeader(HeaderSet.TYPE, null);
            }
        }
        // Length Header
        intHeader = (Long) headImpl.getHeader(HeaderSet.LENGTH);
        if (intHeader != null) {
            out.write((byte) HeaderSet.LENGTH);
            value = ObexHelper.convertToByteArray(intHeader.longValue());
            out.write(value);
            if (nullOut) {
                headImpl.setHeader(HeaderSet.LENGTH, null);
            }
        }
        // Time ISO Header
        dateHeader = (Calendar) headImpl.getHeader(HeaderSet.TIME_ISO_8601);
        if (dateHeader != null) {
            /*
                 * The ISO Header should take the form YYYYMMDDTHHMMSSZ.  The
                 * 'Z' will only be included if it is a UTC time.
                 */
            buffer = new StringBuffer();
            int temp = dateHeader.get(Calendar.YEAR);
            for (int i = temp; i < 1000; i = i * 10) {
                buffer.append("0");
            }
            buffer.append(temp);
            temp = dateHeader.get(Calendar.MONTH);
            if (temp < 10) {
                buffer.append("0");
            }
            buffer.append(temp);
            temp = dateHeader.get(Calendar.DAY_OF_MONTH);
            if (temp < 10) {
                buffer.append("0");
            }
            buffer.append(temp);
            buffer.append("T");
            temp = dateHeader.get(Calendar.HOUR_OF_DAY);
            if (temp < 10) {
                buffer.append("0");
            }
            buffer.append(temp);
            temp = dateHeader.get(Calendar.MINUTE);
            if (temp < 10) {
                buffer.append("0");
            }
            buffer.append(temp);
            temp = dateHeader.get(Calendar.SECOND);
            if (temp < 10) {
                buffer.append("0");
            }
            buffer.append(temp);
            if (dateHeader.getTimeZone().getID().equals("UTC")) {
                buffer.append("Z");
            }
            try {
                value = buffer.toString().getBytes("ISO8859_1");
            } catch (UnsupportedEncodingException e) {
                throw e;
            }
            length = value.length + 3;
            lengthArray[0] = (byte) (255 & (length >> 8));
            lengthArray[1] = (byte) (255 & length);
            out.write(HeaderSet.TIME_ISO_8601);
            out.write(lengthArray);
            out.write(value);
            if (nullOut) {
                headImpl.setHeader(HeaderSet.TIME_ISO_8601, null);
            }
        }
        // Time 4 Byte Header
        dateHeader = (Calendar) headImpl.getHeader(HeaderSet.TIME_4_BYTE);
        if (dateHeader != null) {
            out.write(HeaderSet.TIME_4_BYTE);
            /*
                 * Need to call getTime() twice.  The first call will return
                 * a java.util.Date object.  The second call returns the number
                 * of milliseconds since January 1, 1970.  We need to convert
                 * it to seconds since the TIME_4_BYTE expects the number of
                 * seconds since January 1, 1970.
                 */
            value = ObexHelper.convertToByteArray(dateHeader.getTime().getTime() / 1000L);
            out.write(value);
            if (nullOut) {
                headImpl.setHeader(HeaderSet.TIME_4_BYTE, null);
            }
        }
        // Description Header
        stringHeader = (String) headImpl.getHeader(HeaderSet.DESCRIPTION);
        if (stringHeader != null) {
            out.write((byte) HeaderSet.DESCRIPTION);
            value = ObexHelper.convertToUnicodeByteArray(stringHeader);
            length = value.length + 3;
            lengthArray[0] = (byte) (255 & (length >> 8));
            lengthArray[1] = (byte) (255 & length);
            out.write(lengthArray);
            out.write(value);
            if (nullOut) {
                headImpl.setHeader(HeaderSet.DESCRIPTION, null);
            }
        }
        // Target Header
        value = (byte[]) headImpl.getHeader(HeaderSet.TARGET);
        if (value != null) {
            out.write((byte) HeaderSet.TARGET);
            length = value.length + 3;
            lengthArray[0] = (byte) (255 & (length >> 8));
            lengthArray[1] = (byte) (255 & length);
            out.write(lengthArray);
            out.write(value);
            if (nullOut) {
                headImpl.setHeader(HeaderSet.TARGET, null);
            }
        }
        // HTTP Header
        value = (byte[]) headImpl.getHeader(HeaderSet.HTTP);
        if (value != null) {
            out.write((byte) HeaderSet.HTTP);
            length = value.length + 3;
            lengthArray[0] = (byte) (255 & (length >> 8));
            lengthArray[1] = (byte) (255 & length);
            out.write(lengthArray);
            out.write(value);
            if (nullOut) {
                headImpl.setHeader(HeaderSet.HTTP, null);
            }
        }
        // Who Header
        value = (byte[]) headImpl.getHeader(HeaderSet.WHO);
        if (value != null) {
            out.write((byte) HeaderSet.WHO);
            length = value.length + 3;
            lengthArray[0] = (byte) (255 & (length >> 8));
            lengthArray[1] = (byte) (255 & length);
            out.write(lengthArray);
            out.write(value);
            if (nullOut) {
                headImpl.setHeader(HeaderSet.WHO, null);
            }
        }
        // Connection ID Header
        value = (byte[]) headImpl.getHeader(HeaderSet.APPLICATION_PARAMETER);
        if (value != null) {
            out.write((byte) HeaderSet.APPLICATION_PARAMETER);
            length = value.length + 3;
            lengthArray[0] = (byte) (255 & (length >> 8));
            lengthArray[1] = (byte) (255 & length);
            out.write(lengthArray);
            out.write(value);
            if (nullOut) {
                headImpl.setHeader(HeaderSet.APPLICATION_PARAMETER, null);
            }
        }
        // Object Class Header
        value = (byte[]) headImpl.getHeader(HeaderSet.OBJECT_CLASS);
        if (value != null) {
            out.write((byte) HeaderSet.OBJECT_CLASS);
            length = value.length + 3;
            lengthArray[0] = (byte) (255 & (length >> 8));
            lengthArray[1] = (byte) (255 & length);
            out.write(lengthArray);
            out.write(value);
            if (nullOut) {
                headImpl.setHeader(HeaderSet.OBJECT_CLASS, null);
            }
        }
        // Check User Defined Headers
        for (int i = 0; i < 16; i++) {
            // Unicode String Header
            stringHeader = (String) headImpl.getHeader(i + 0x30);
            if (stringHeader != null) {
                out.write((byte) i + 0x30);
                value = ObexHelper.convertToUnicodeByteArray(stringHeader);
                length = value.length + 3;
                lengthArray[0] = (byte) (255 & (length >> 8));
                lengthArray[1] = (byte) (255 & length);
                out.write(lengthArray);
                out.write(value);
                if (nullOut) {
                    headImpl.setHeader(i + 0x30, null);
                }
            }
            // Byte Sequence Header
            value = (byte[]) headImpl.getHeader(i + 0x70);
            if (value != null) {
                out.write((byte) i + 0x70);
                length = value.length + 3;
                lengthArray[0] = (byte) (255 & (length >> 8));
                lengthArray[1] = (byte) (255 & length);
                out.write(lengthArray);
                out.write(value);
                if (nullOut) {
                    headImpl.setHeader(i + 0x70, null);
                }
            }
            // Byte Header
            byteHeader = (Byte) headImpl.getHeader(i + 0xB0);
            if (byteHeader != null) {
                out.write((byte) i + 0xB0);
                out.write(byteHeader.byteValue());
                if (nullOut) {
                    headImpl.setHeader(i + 0xB0, null);
                }
            }
            // Integer header
            intHeader = (Long) headImpl.getHeader(i + 0xF0);
            if (intHeader != null) {
                out.write((byte) i + 0xF0);
                out.write(ObexHelper.convertToByteArray(intHeader.longValue()));
                if (nullOut) {
                    headImpl.setHeader(i + 0xF0, null);
                }
            }
        }
        // Add the authentication challenge header
        if (headImpl.mAuthChall != null) {
            out.write((byte) HeaderSet.AUTH_CHALLENGE);
            length = headImpl.mAuthChall.length + 3;
            lengthArray[0] = (byte) (255 & (length >> 8));
            lengthArray[1] = (byte) (255 & length);
            out.write(lengthArray);
            out.write(headImpl.mAuthChall);
            if (nullOut) {
                headImpl.mAuthChall = null;
            }
        }
        // Add the authentication response header
        if (headImpl.mAuthResp != null) {
            out.write((byte) HeaderSet.AUTH_RESPONSE);
            length = headImpl.mAuthResp.length + 3;
            lengthArray[0] = (byte) (255 & (length >> 8));
            lengthArray[1] = (byte) (255 & length);
            out.write(lengthArray);
            out.write(headImpl.mAuthResp);
            if (nullOut) {
                headImpl.mAuthResp = null;
            }
        }
    } catch (IOException e) {
    } finally {
        result = out.toByteArray();
        try {
            out.close();
        } catch (Exception ex) {
        }
    }
    return result;
}
Body of Second Method:
{
    Long intHeader = null;
    String stringHeader = null;
    Calendar dateHeader = null;
    Byte byteHeader = null;
    StringBuffer buffer = null;
    byte[] value = null;
    byte[] result = null;
    byte[] lengthArray = new byte[2];
    int length;
    HeaderSet headImpl = null;
    ByteArrayOutputStream out = new ByteArrayOutputStream();
    headImpl = head;
    try {
        /*
             * Determine if there is a connection ID to send.  If there is,
             * then it should be the first header in the packet.
             */
        if ((headImpl.mConnectionID != null) && (headImpl.getHeader(HeaderSet.TARGET) == null)) {
            out.write((byte) HeaderSet.CONNECTION_ID);
            out.write(headImpl.mConnectionID);
        }
        // Count Header
        intHeader = (Long) headImpl.getHeader(HeaderSet.COUNT);
        if (intHeader != null) {
            out.write((byte) HeaderSet.COUNT);
            value = ObexHelper.convertToByteArray(intHeader.longValue());
            out.write(value);
            if (nullOut) {
                headImpl.setHeader(HeaderSet.COUNT, null);
            }
        }
        // Name Header
        stringHeader = (String) headImpl.getHeader(HeaderSet.NAME);
        if (stringHeader != null) {
            out.write((byte) HeaderSet.NAME);
            value = ObexHelper.convertToUnicodeByteArray(stringHeader);
            length = value.length + 3;
            lengthArray[0] = (byte) (0xFF & (length >> 8));
            lengthArray[1] = (byte) (0xFF & length);
            out.write(lengthArray);
            out.write(value);
            if (nullOut) {
                headImpl.setHeader(HeaderSet.NAME, null);
            }
        } else if (headImpl.getEmptyNameHeader()) {
            out.write((byte) HeaderSet.NAME);
            lengthArray[0] = (byte) 0x00;
            lengthArray[1] = (byte) 0x03;
            out.write(lengthArray);
        }
        // Type Header
        stringHeader = (String) headImpl.getHeader(HeaderSet.TYPE);
        if (stringHeader != null) {
            out.write((byte) HeaderSet.TYPE);
            try {
                value = stringHeader.getBytes("ISO8859_1");
            } catch (UnsupportedEncodingException e) {
                throw e;
            }
            length = value.length + 4;
            lengthArray[0] = (byte) (255 & (length >> 8));
            lengthArray[1] = (byte) (255 & length);
            out.write(lengthArray);
            out.write(value);
            out.write(0x00);
            if (nullOut) {
                headImpl.setHeader(HeaderSet.TYPE, null);
            }
        }
        // Length Header
        intHeader = (Long) headImpl.getHeader(HeaderSet.LENGTH);
        if (intHeader != null) {
            out.write((byte) HeaderSet.LENGTH);
            value = ObexHelper.convertToByteArray(intHeader.longValue());
            out.write(value);
            if (nullOut) {
                headImpl.setHeader(HeaderSet.LENGTH, null);
            }
        }
        // Time ISO Header
        dateHeader = (Calendar) headImpl.getHeader(HeaderSet.TIME_ISO_8601);
        if (dateHeader != null) {
            /*
                 * The ISO Header should take the form YYYYMMDDTHHMMSSZ.  The
                 * 'Z' will only be included if it is a UTC time.
                 */
            buffer = new StringBuffer();
            int temp = dateHeader.get(Calendar.YEAR);
            for (int i = temp; i < 1000; i = i * 10) {
                buffer.append("0");
            }
            buffer.append(temp);
            temp = dateHeader.get(Calendar.MONTH);
            if (temp < 10) {
                buffer.append("0");
            }
            buffer.append(temp);
            temp = dateHeader.get(Calendar.DAY_OF_MONTH);
            if (temp < 10) {
                buffer.append("0");
            }
            buffer.append(temp);
            buffer.append("T");
            temp = dateHeader.get(Calendar.HOUR_OF_DAY);
            if (temp < 10) {
                buffer.append("0");
            }
            buffer.append(temp);
            temp = dateHeader.get(Calendar.MINUTE);
            if (temp < 10) {
                buffer.append("0");
            }
            buffer.append(temp);
            temp = dateHeader.get(Calendar.SECOND);
            if (temp < 10) {
                buffer.append("0");
            }
            buffer.append(temp);
            if (dateHeader.getTimeZone().getID().equals("UTC")) {
                buffer.append("Z");
            }
            try {
                value = buffer.toString().getBytes("ISO8859_1");
            } catch (UnsupportedEncodingException e) {
                throw e;
            }
            length = value.length + 3;
            lengthArray[0] = (byte) (255 & (length >> 8));
            lengthArray[1] = (byte) (255 & length);
            out.write(HeaderSet.TIME_ISO_8601);
            out.write(lengthArray);
            out.write(value);
            if (nullOut) {
                headImpl.setHeader(HeaderSet.TIME_ISO_8601, null);
            }
        }
        // Time 4 Byte Header
        dateHeader = (Calendar) headImpl.getHeader(HeaderSet.TIME_4_BYTE);
        if (dateHeader != null) {
            out.write(HeaderSet.TIME_4_BYTE);
            /*
                 * Need to call getTime() twice.  The first call will return
                 * a java.util.Date object.  The second call returns the number
                 * of milliseconds since January 1, 1970.  We need to convert
                 * it to seconds since the TIME_4_BYTE expects the number of
                 * seconds since January 1, 1970.
                 */
            value = ObexHelper.convertToByteArray(dateHeader.getTime().getTime() / 1000L);
            out.write(value);
            if (nullOut) {
                headImpl.setHeader(HeaderSet.TIME_4_BYTE, null);
            }
        }
        // Description Header
        stringHeader = (String) headImpl.getHeader(HeaderSet.DESCRIPTION);
        if (stringHeader != null) {
            out.write((byte) HeaderSet.DESCRIPTION);
            value = ObexHelper.convertToUnicodeByteArray(stringHeader);
            length = value.length + 3;
            lengthArray[0] = (byte) (255 & (length >> 8));
            lengthArray[1] = (byte) (255 & length);
            out.write(lengthArray);
            out.write(value);
            if (nullOut) {
                headImpl.setHeader(HeaderSet.DESCRIPTION, null);
            }
        }
        // Target Header
        value = (byte[]) headImpl.getHeader(HeaderSet.TARGET);
        if (value != null) {
            out.write((byte) HeaderSet.TARGET);
            length = value.length + 3;
            lengthArray[0] = (byte) (255 & (length >> 8));
            lengthArray[1] = (byte) (255 & length);
            out.write(lengthArray);
            out.write(value);
            if (nullOut) {
                headImpl.setHeader(HeaderSet.TARGET, null);
            }
        }
        // HTTP Header
        value = (byte[]) headImpl.getHeader(HeaderSet.HTTP);
        if (value != null) {
            out.write((byte) HeaderSet.HTTP);
            length = value.length + 3;
            lengthArray[0] = (byte) (255 & (length >> 8));
            lengthArray[1] = (byte) (255 & length);
            out.write(lengthArray);
            out.write(value);
            if (nullOut) {
                headImpl.setHeader(HeaderSet.HTTP, null);
            }
        }
        // Who Header
        value = (byte[]) headImpl.getHeader(HeaderSet.WHO);
        if (value != null) {
            out.write((byte) HeaderSet.WHO);
            length = value.length + 3;
            lengthArray[0] = (byte) (255 & (length >> 8));
            lengthArray[1] = (byte) (255 & length);
            out.write(lengthArray);
            out.write(value);
            if (nullOut) {
                headImpl.setHeader(HeaderSet.WHO, null);
            }
        }
        // Connection ID Header
        value = (byte[]) headImpl.getHeader(HeaderSet.APPLICATION_PARAMETER);
        if (value != null) {
            out.write((byte) HeaderSet.APPLICATION_PARAMETER);
            length = value.length + 3;
            lengthArray[0] = (byte) (255 & (length >> 8));
            lengthArray[1] = (byte) (255 & length);
            out.write(lengthArray);
            out.write(value);
            if (nullOut) {
                headImpl.setHeader(HeaderSet.APPLICATION_PARAMETER, null);
            }
        }
        // Object Class Header
        value = (byte[]) headImpl.getHeader(HeaderSet.OBJECT_CLASS);
        if (value != null) {
            out.write((byte) HeaderSet.OBJECT_CLASS);
            length = value.length + 3;
            lengthArray[0] = (byte) (255 & (length >> 8));
            lengthArray[1] = (byte) (255 & length);
            out.write(lengthArray);
            out.write(value);
            if (nullOut) {
                headImpl.setHeader(HeaderSet.OBJECT_CLASS, null);
            }
        }
        // Check User Defined Headers
        for (int i = 0; i < 16; i++) {
            // Unicode String Header
            stringHeader = (String) headImpl.getHeader(i + 0x30);
            if (stringHeader != null) {
                out.write((byte) i + 0x30);
                value = ObexHelper.convertToUnicodeByteArray(stringHeader);
                length = value.length + 3;
                lengthArray[0] = (byte) (255 & (length >> 8));
                lengthArray[1] = (byte) (255 & length);
                out.write(lengthArray);
                out.write(value);
                if (nullOut) {
                    headImpl.setHeader(i + 0x30, null);
                }
            }
            // Byte Sequence Header
            value = (byte[]) headImpl.getHeader(i + 0x70);
            if (value != null) {
                out.write((byte) i + 0x70);
                length = value.length + 3;
                lengthArray[0] = (byte) (255 & (length >> 8));
                lengthArray[1] = (byte) (255 & length);
                out.write(lengthArray);
                out.write(value);
                if (nullOut) {
                    headImpl.setHeader(i + 0x70, null);
                }
            }
            // Byte Header
            byteHeader = (Byte) headImpl.getHeader(i + 0xB0);
            if (byteHeader != null) {
                out.write((byte) i + 0xB0);
                out.write(byteHeader.byteValue());
                if (nullOut) {
                    headImpl.setHeader(i + 0xB0, null);
                }
            }
            // Integer header
            intHeader = (Long) headImpl.getHeader(i + 0xF0);
            if (intHeader != null) {
                out.write((byte) i + 0xF0);
                out.write(ObexHelper.convertToByteArray(intHeader.longValue()));
                if (nullOut) {
                    headImpl.setHeader(i + 0xF0, null);
                }
            }
        }
        // Add the authentication challenge header
        if (headImpl.mAuthChall != null) {
            out.write((byte) HeaderSet.AUTH_CHALLENGE);
            length = headImpl.mAuthChall.length + 3;
            lengthArray[0] = (byte) (255 & (length >> 8));
            lengthArray[1] = (byte) (255 & length);
            out.write(lengthArray);
            out.write(headImpl.mAuthChall);
            if (nullOut) {
                headImpl.mAuthChall = null;
            }
        }
        // Add the authentication response header
        if (headImpl.mAuthResp != null) {
            out.write((byte) HeaderSet.AUTH_RESPONSE);
            length = headImpl.mAuthResp.length + 3;
            lengthArray[0] = (byte) (255 & (length >> 8));
            lengthArray[1] = (byte) (255 & length);
            out.write(lengthArray);
            out.write(headImpl.mAuthResp);
            if (nullOut) {
                headImpl.mAuthResp = null;
            }
        }
    } catch (IOException e) {
    } finally {
        result = out.toByteArray();
        try {
            out.close();
        } catch (Exception ex) {
        }
    }
    return result;
}
------------------------
Find a silently evolved API code:android.os.SystemClock.setCurrentTimeMillis:COMMENT
<android.os.SystemClock: boolean setCurrentTimeMillis(long)>
public      static      native      ->public      static      
Method Modifier: public      static      native      
Method Modifier: Yes         Yes         Yes         
Method Updated:  Yes         Yes         No          
Comment:/**
 * Sets the current wall time, in milliseconds.  Requires the calling
 * process to have appropriate permissions.
 *
 * @return if the clock was successfully set to the specified time.
 */

Body of Frist Method:

Body of Second Method:
{
    IBinder b = ServiceManager.getService(Context.ALARM_SERVICE);
    IAlarmManager mgr = IAlarmManager.Stub.asInterface(b);
    if (mgr == null) {
        return false;
    }
    try {
        return mgr.setTime(millis);
    } catch (RemoteException e) {
        Slog.e(TAG, "Unable to set RTC", e);
    } catch (SecurityException e) {
        Slog.e(TAG, "Unable to set RTC", e);
    }
    return false;
}
------------------------
Find a silently evolved API code:android.os.ParcelFileDescriptor.dup:COMMENT
Method Modifier: public      static      
Comment:/**
 * Create a new ParcelFileDescriptor that is a dup of an existing
 * FileDescriptor.  This obeys standard POSIX semantics, where the
 * new file descriptor shared state such as file position with the
 * original file descriptor.
 */

Body of Frist Method:
{
    try {
        final FileDescriptor fd = Libcore.os.dup(orig);
        return new ParcelFileDescriptor(fd);
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
}
Body of Second Method:
{
    try {
        final FileDescriptor fd = Os.dup(orig);
        return new ParcelFileDescriptor(fd);
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
}
------------------------
Find a silently evolved API code:android.view.ViewRootImpl.setView:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * We have one child
 */

Body of Frist Method:
{
    synchronized (this) {
        if (mView == null) {
            mView = view;
            mViewLayoutDirectionInitial = mView.getRawLayoutDirection();
            mFallbackEventHandler.setView(view);
            mWindowAttributes.copyFrom(attrs);
            if (mWindowAttributes.packageName == null) {
                mWindowAttributes.packageName = mBasePackageName;
            }
            attrs = mWindowAttributes;
            // Keep track of the actual window flags supplied by the client.
            mClientWindowLayoutFlags = attrs.flags;
            setAccessibilityFocus(null, null);
            if (view instanceof RootViewSurfaceTaker) {
                mSurfaceHolderCallback = ((RootViewSurfaceTaker) view).willYouTakeTheSurface();
                if (mSurfaceHolderCallback != null) {
                    mSurfaceHolder = new TakenSurfaceHolder();
                    mSurfaceHolder.setFormat(PixelFormat.UNKNOWN);
                }
            }
            CompatibilityInfo compatibilityInfo = mDisplayAdjustments.getCompatibilityInfo();
            mTranslator = compatibilityInfo.getTranslator();
            mDisplayAdjustments.setActivityToken(attrs.token);
            // If the application owns the surface, don't enable hardware acceleration
            if (mSurfaceHolder == null) {
                enableHardwareAcceleration(attrs);
            }
            boolean restore = false;
            if (mTranslator != null) {
                mSurface.setCompatibilityTranslator(mTranslator);
                restore = true;
                attrs.backup();
                mTranslator.translateWindowLayout(attrs);
            }
            if (DEBUG_LAYOUT)
                Log.d(TAG, "WindowLayout in setView:" + attrs);
            if (!compatibilityInfo.supportsScreen()) {
                attrs.privateFlags |= WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;
                mLastInCompatMode = true;
            }
            mSoftInputMode = attrs.softInputMode;
            mWindowAttributesChanged = true;
            mWindowAttributesChangesFlag = WindowManager.LayoutParams.EVERYTHING_CHANGED;
            mAttachInfo.mRootView = view;
            mAttachInfo.mScalingRequired = mTranslator != null;
            mAttachInfo.mApplicationScale = mTranslator == null ? 1.0f : mTranslator.applicationScale;
            if (panelParentView != null) {
                mAttachInfo.mPanelParentWindowToken = panelParentView.getApplicationWindowToken();
            }
            mAdded = true;
            int res;
            /* = WindowManagerImpl.ADD_OKAY; */
            // Schedule the first layout -before- adding to the window
            // manager, to make sure we do the relayout before receiving
            // any other events from the system.
            requestLayout();
            if ((mWindowAttributes.inputFeatures & WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == 0) {
                mInputChannel = new InputChannel();
            }
            try {
                mOrigWindowType = mWindowAttributes.type;
                mAttachInfo.mRecomputeGlobalAttributes = true;
                collectViewAttributes();
                res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes, getHostVisibility(), mDisplay.getDisplayId(), mAttachInfo.mContentInsets, mInputChannel);
            } catch (RemoteException e) {
                mAdded = false;
                mView = null;
                mAttachInfo.mRootView = null;
                mInputChannel = null;
                mFallbackEventHandler.setView(null);
                unscheduleTraversals();
                setAccessibilityFocus(null, null);
                throw new RuntimeException("Adding window failed", e);
            } finally {
                if (restore) {
                    attrs.restore();
                }
            }
            if (mTranslator != null) {
                mTranslator.translateRectInScreenToAppWindow(mAttachInfo.mContentInsets);
            }
            mPendingOverscanInsets.set(0, 0, 0, 0);
            mPendingContentInsets.set(mAttachInfo.mContentInsets);
            mPendingVisibleInsets.set(0, 0, 0, 0);
            if (DEBUG_LAYOUT)
                Log.v(TAG, "Added window " + mWindow);
            if (res < WindowManagerGlobal.ADD_OKAY) {
                mAttachInfo.mRootView = null;
                mAdded = false;
                mFallbackEventHandler.setView(null);
                unscheduleTraversals();
                setAccessibilityFocus(null, null);
                switch(res) {
                    case WindowManagerGlobal.ADD_BAD_APP_TOKEN:
                    case WindowManagerGlobal.ADD_BAD_SUBWINDOW_TOKEN:
                        throw new WindowManager.BadTokenException("Unable to add window -- token " + attrs.token + " is not valid; is your activity running?");
                    case WindowManagerGlobal.ADD_NOT_APP_TOKEN:
                        throw new WindowManager.BadTokenException("Unable to add window -- token " + attrs.token + " is not for an application");
                    case WindowManagerGlobal.ADD_APP_EXITING:
                        throw new WindowManager.BadTokenException("Unable to add window -- app for token " + attrs.token + " is exiting");
                    case WindowManagerGlobal.ADD_DUPLICATE_ADD:
                        throw new WindowManager.BadTokenException("Unable to add window -- window " + mWindow + " has already been added");
                    case WindowManagerGlobal.ADD_STARTING_NOT_NEEDED:
                        // right away, anyway.
                        return;
                    case WindowManagerGlobal.ADD_MULTIPLE_SINGLETON:
                        throw new WindowManager.BadTokenException("Unable to add window " + mWindow + " -- another window of this type already exists");
                    case WindowManagerGlobal.ADD_PERMISSION_DENIED:
                        throw new WindowManager.BadTokenException("Unable to add window " + mWindow + " -- permission denied for this window type");
                    case WindowManagerGlobal.ADD_INVALID_DISPLAY:
                        throw new WindowManager.InvalidDisplayException("Unable to add window " + mWindow + " -- the specified display can not be found");
                }
                throw new RuntimeException("Unable to add window -- unknown error code " + res);
            }
            if (view instanceof RootViewSurfaceTaker) {
                mInputQueueCallback = ((RootViewSurfaceTaker) view).willYouTakeTheInputQueue();
            }
            if (mInputChannel != null) {
                if (mInputQueueCallback != null) {
                    mInputQueue = new InputQueue();
                    mInputQueueCallback.onInputQueueCreated(mInputQueue);
                }
                mInputEventReceiver = new WindowInputEventReceiver(mInputChannel, Looper.myLooper());
            }
            view.assignParent(this);
            mAddedTouchMode = (res & WindowManagerGlobal.ADD_FLAG_IN_TOUCH_MODE) != 0;
            mAppVisible = (res & WindowManagerGlobal.ADD_FLAG_APP_VISIBLE) != 0;
            if (mAccessibilityManager.isEnabled()) {
                mAccessibilityInteractionConnectionManager.ensureConnection();
            }
            if (view.getImportantForAccessibility() == View.IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
                view.setImportantForAccessibility(View.IMPORTANT_FOR_ACCESSIBILITY_YES);
            }
            // Set up the input pipeline.
            CharSequence counterSuffix = attrs.getTitle();
            InputStage syntheticInputStage = new SyntheticInputStage();
            InputStage viewPostImeStage = new ViewPostImeInputStage(syntheticInputStage);
            InputStage nativePostImeStage = new NativePostImeInputStage(viewPostImeStage, "aq:native-post-ime:" + counterSuffix);
            InputStage earlyPostImeStage = new EarlyPostImeInputStage(nativePostImeStage);
            InputStage imeStage = new ImeInputStage(earlyPostImeStage, "aq:ime:" + counterSuffix);
            InputStage viewPreImeStage = new ViewPreImeInputStage(imeStage);
            InputStage nativePreImeStage = new NativePreImeInputStage(viewPreImeStage, "aq:native-pre-ime:" + counterSuffix);
            mFirstInputStage = nativePreImeStage;
            mFirstPostImeInputStage = earlyPostImeStage;
            mPendingInputEventQueueLengthCounterName = "aq:pending:" + counterSuffix;
        }
    }
}
Body of Second Method:
{
    synchronized (this) {
        if (mView == null) {
            mView = view;
            mAttachInfo.mDisplayState = mDisplay.getState();
            mDisplayManager.registerDisplayListener(mDisplayListener, mHandler);
            mViewLayoutDirectionInitial = mView.getRawLayoutDirection();
            mFallbackEventHandler.setView(view);
            mWindowAttributes.copyFrom(attrs);
            if (mWindowAttributes.packageName == null) {
                mWindowAttributes.packageName = mBasePackageName;
            }
            attrs = mWindowAttributes;
            // Keep track of the actual window flags supplied by the client.
            mClientWindowLayoutFlags = attrs.flags;
            setAccessibilityFocus(null, null);
            if (view instanceof RootViewSurfaceTaker) {
                mSurfaceHolderCallback = ((RootViewSurfaceTaker) view).willYouTakeTheSurface();
                if (mSurfaceHolderCallback != null) {
                    mSurfaceHolder = new TakenSurfaceHolder();
                    mSurfaceHolder.setFormat(PixelFormat.UNKNOWN);
                }
            }
            // Compute surface insets required to draw at specified Z value.
            // TODO: Use real shadow insets for a constant max Z.
            final int surfaceInset = (int) Math.ceil(view.getZ() * 2);
            attrs.surfaceInsets.set(surfaceInset, surfaceInset, surfaceInset, surfaceInset);
            CompatibilityInfo compatibilityInfo = mDisplayAdjustments.getCompatibilityInfo();
            mTranslator = compatibilityInfo.getTranslator();
            mDisplayAdjustments.setActivityToken(attrs.token);
            // If the application owns the surface, don't enable hardware acceleration
            if (mSurfaceHolder == null) {
                enableHardwareAcceleration(attrs);
            }
            boolean restore = false;
            if (mTranslator != null) {
                mSurface.setCompatibilityTranslator(mTranslator);
                restore = true;
                attrs.backup();
                mTranslator.translateWindowLayout(attrs);
            }
            if (DEBUG_LAYOUT)
                Log.d(TAG, "WindowLayout in setView:" + attrs);
            if (!compatibilityInfo.supportsScreen()) {
                attrs.privateFlags |= WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;
                mLastInCompatMode = true;
            }
            mSoftInputMode = attrs.softInputMode;
            mWindowAttributesChanged = true;
            mWindowAttributesChangesFlag = WindowManager.LayoutParams.EVERYTHING_CHANGED;
            mAttachInfo.mRootView = view;
            mAttachInfo.mScalingRequired = mTranslator != null;
            mAttachInfo.mApplicationScale = mTranslator == null ? 1.0f : mTranslator.applicationScale;
            if (panelParentView != null) {
                mAttachInfo.mPanelParentWindowToken = panelParentView.getApplicationWindowToken();
            }
            mAdded = true;
            int res;
            /* = WindowManagerImpl.ADD_OKAY; */
            // Schedule the first layout -before- adding to the window
            // manager, to make sure we do the relayout before receiving
            // any other events from the system.
            requestLayout();
            if ((mWindowAttributes.inputFeatures & WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == 0) {
                mInputChannel = new InputChannel();
            }
            try {
                mOrigWindowType = mWindowAttributes.type;
                mAttachInfo.mRecomputeGlobalAttributes = true;
                collectViewAttributes();
                res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes, getHostVisibility(), mDisplay.getDisplayId(), mAttachInfo.mContentInsets, mInputChannel);
            } catch (RemoteException e) {
                mAdded = false;
                mView = null;
                mAttachInfo.mRootView = null;
                mInputChannel = null;
                mFallbackEventHandler.setView(null);
                unscheduleTraversals();
                setAccessibilityFocus(null, null);
                throw new RuntimeException("Adding window failed", e);
            } finally {
                if (restore) {
                    attrs.restore();
                }
            }
            if (mTranslator != null) {
                mTranslator.translateRectInScreenToAppWindow(mAttachInfo.mContentInsets);
            }
            mPendingOverscanInsets.set(0, 0, 0, 0);
            mPendingContentInsets.set(mAttachInfo.mContentInsets);
            mPendingStableInsets.set(mAttachInfo.mStableInsets);
            mPendingVisibleInsets.set(0, 0, 0, 0);
            if (DEBUG_LAYOUT)
                Log.v(TAG, "Added window " + mWindow);
            if (res < WindowManagerGlobal.ADD_OKAY) {
                mAttachInfo.mRootView = null;
                mAdded = false;
                mFallbackEventHandler.setView(null);
                unscheduleTraversals();
                setAccessibilityFocus(null, null);
                switch(res) {
                    case WindowManagerGlobal.ADD_BAD_APP_TOKEN:
                    case WindowManagerGlobal.ADD_BAD_SUBWINDOW_TOKEN:
                        throw new WindowManager.BadTokenException("Unable to add window -- token " + attrs.token + " is not valid; is your activity running?");
                    case WindowManagerGlobal.ADD_NOT_APP_TOKEN:
                        throw new WindowManager.BadTokenException("Unable to add window -- token " + attrs.token + " is not for an application");
                    case WindowManagerGlobal.ADD_APP_EXITING:
                        throw new WindowManager.BadTokenException("Unable to add window -- app for token " + attrs.token + " is exiting");
                    case WindowManagerGlobal.ADD_DUPLICATE_ADD:
                        throw new WindowManager.BadTokenException("Unable to add window -- window " + mWindow + " has already been added");
                    case WindowManagerGlobal.ADD_STARTING_NOT_NEEDED:
                        // right away, anyway.
                        return;
                    case WindowManagerGlobal.ADD_MULTIPLE_SINGLETON:
                        throw new WindowManager.BadTokenException("Unable to add window " + mWindow + " -- another window of this type already exists");
                    case WindowManagerGlobal.ADD_PERMISSION_DENIED:
                        throw new WindowManager.BadTokenException("Unable to add window " + mWindow + " -- permission denied for this window type");
                    case WindowManagerGlobal.ADD_INVALID_DISPLAY:
                        throw new WindowManager.InvalidDisplayException("Unable to add window " + mWindow + " -- the specified display can not be found");
                }
                throw new RuntimeException("Unable to add window -- unknown error code " + res);
            }
            if (view instanceof RootViewSurfaceTaker) {
                mInputQueueCallback = ((RootViewSurfaceTaker) view).willYouTakeTheInputQueue();
            }
            if (mInputChannel != null) {
                if (mInputQueueCallback != null) {
                    mInputQueue = new InputQueue();
                    mInputQueueCallback.onInputQueueCreated(mInputQueue);
                }
                mInputEventReceiver = new WindowInputEventReceiver(mInputChannel, Looper.myLooper());
            }
            view.assignParent(this);
            mAddedTouchMode = (res & WindowManagerGlobal.ADD_FLAG_IN_TOUCH_MODE) != 0;
            mAppVisible = (res & WindowManagerGlobal.ADD_FLAG_APP_VISIBLE) != 0;
            if (mAccessibilityManager.isEnabled()) {
                mAccessibilityInteractionConnectionManager.ensureConnection();
            }
            if (view.getImportantForAccessibility() == View.IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
                view.setImportantForAccessibility(View.IMPORTANT_FOR_ACCESSIBILITY_YES);
            }
            // Set up the input pipeline.
            CharSequence counterSuffix = attrs.getTitle();
            mSyntheticInputStage = new SyntheticInputStage();
            InputStage viewPostImeStage = new ViewPostImeInputStage(mSyntheticInputStage);
            InputStage nativePostImeStage = new NativePostImeInputStage(viewPostImeStage, "aq:native-post-ime:" + counterSuffix);
            InputStage earlyPostImeStage = new EarlyPostImeInputStage(nativePostImeStage);
            InputStage imeStage = new ImeInputStage(earlyPostImeStage, "aq:ime:" + counterSuffix);
            InputStage viewPreImeStage = new ViewPreImeInputStage(imeStage);
            InputStage nativePreImeStage = new NativePreImeInputStage(viewPreImeStage, "aq:native-pre-ime:" + counterSuffix);
            mFirstInputStage = nativePreImeStage;
            mFirstPostImeInputStage = earlyPostImeStage;
            mPendingInputEventQueueLengthCounterName = "aq:pending:" + counterSuffix;
        }
    }
}
------------------------
Find a silently evolved API code:android.media.AudioManager.unregisterMediaButtonIntent:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        service.unregisterMediaButtonIntent(pi);
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in unregisterMediaButtonIntent" + e);
    }
}
Body of Second Method:
{
    MediaSessionLegacyHelper helper = MediaSessionLegacyHelper.getHelper(mContext);
    helper.removeMediaButtonListener(pi);
}
------------------------
Find a silently evolved API code:android.view.animation.Transformation.postCompose:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Like {@link #compose(Transformation)} but does this.postConcat(t) of
 * the transformation matrix.
 * @hide
 */

Body of Frist Method:
{
    mAlpha *= t.getAlpha();
    mMatrix.postConcat(t.getMatrix());
}
Body of Second Method:
{
    mAlpha *= t.getAlpha();
    mMatrix.postConcat(t.getMatrix());
    if (t.mHasClipRect) {
        setClipRect(t.getClipRect());
    }
}
------------------------
Find a silently evolved API code:android.media.MediaPlayer.TimeProvider.onSeekComplete:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    synchronized (this) {
        scheduleNotification(NOTIFY_SEEK, 0);
    }
}
Body of Second Method:
{
    synchronized (this) {
        mStopped = false;
        mSeeking = true;
        scheduleNotification(NOTIFY_SEEK, 0);
    }
}
------------------------
Find a silently evolved API code:android.graphics.Paint.setMaskFilter:COMMENT
Method Modifier: public      
Comment:/**
 * Set or clear the maskfilter object.
 * <p />
 * Pass null to clear any previous maskfilter.
 * As a convenience, the parameter passed is also returned.
 *
 * @param maskfilter May be null. The maskfilter to be installed in the
 * paint
 * @return           maskfilter
 */

Body of Frist Method:
{
    int maskfilterNative = 0;
    if (maskfilter != null) {
        maskfilterNative = maskfilter.native_instance;
    }
    native_setMaskFilter(mNativePaint, maskfilterNative);
    mMaskFilter = maskfilter;
    return maskfilter;
}
Body of Second Method:
{
    long maskfilterNative = 0;
    if (maskfilter != null) {
        maskfilterNative = maskfilter.native_instance;
    }
    native_setMaskFilter(mNativePaint, maskfilterNative);
    mMaskFilter = maskfilter;
    return maskfilter;
}
------------------------
Find a silently evolved API code:android.view.accessibility.AccessibilityEvent.clear:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * Clears the state of this instance.
 *
 * @hide
 */

Body of Frist Method:
{
    super.clear();
    mEventType = 0;
    mMovementGranularity = 0;
    mAction = 0;
    mContentChangeTypes = 0;
    mPackageName = null;
    mEventTime = 0;
    while (!mRecords.isEmpty()) {
        AccessibilityRecord record = mRecords.remove(0);
        record.recycle();
    }
}
Body of Second Method:
{
    super.clear();
    mEventType = 0;
    mMovementGranularity = 0;
    mAction = 0;
    mContentChangeTypes = 0;
    mPackageName = null;
    mEventTime = 0;
    if (mRecords != null) {
        while (!mRecords.isEmpty()) {
            AccessibilityRecord record = mRecords.remove(0);
            record.recycle();
        }
    }
}
------------------------
Find a silently evolved API code:android.animation.ObjectAnimator.ofPropertyValuesHolder:COMMENT
Method Modifier: public      static      
Comment:/**
 * Constructs and returns an ObjectAnimator that animates between the sets of values specified
 * in <code>PropertyValueHolder</code> objects. This variant should be used when animating
 * several properties at once with the same ObjectAnimator, since PropertyValuesHolder allows
 * you to associate a set of animation values with a property name.
 *
 * @param target The object whose property is to be animated. Depending on how the
 * PropertyValuesObjects were constructed, the target object should either have the {@link
 * android.util.Property} objects used to construct the PropertyValuesHolder objects or (if the
 * PropertyValuesHOlder objects were created with property names) the target object should have
 * public methods on it called <code>setName()</code>, where <code>name</code> is the name of
 * the property passed in as the <code>propertyName</code> parameter for each of the
 * PropertyValuesHolder objects.
 * @param values A set of PropertyValuesHolder objects whose values will be animated between
 * over time.
 * @return An ObjectAnimator object that is set up to animate between the given values.
 */

Body of Frist Method:
{
    ObjectAnimator anim = new ObjectAnimator();
    anim.mTarget = target;
    anim.setValues(values);
    return anim;
}
Body of Second Method:
{
    ObjectAnimator anim = new ObjectAnimator();
    anim.setTarget(target);
    anim.setValues(values);
    return anim;
}
------------------------
Find a silently evolved API code:android.app.admin.DevicePolicyManager.isAdminActive:COMMENT
Method Modifier: public      
Comment:/**
 * Return true if the given administrator component is currently
 * active (enabled) in the system.
 */

Body of Frist Method:
{
    if (mService != null) {
        try {
            return mService.isAdminActive(who, UserHandle.myUserId());
        } catch (RemoteException e) {
            Log.w(TAG, "Failed talking with device policy service", e);
        }
    }
    return false;
}
Body of Second Method:
{
    return isAdminActiveAsUser(who, UserHandle.myUserId());
}
------------------------
Find a silently evolved API code:android.graphics.Bitmap.getPixel:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the {@link Color} at the specified location. Throws an exception
 * if x or y are out of bounds (negative or >= to the width or height
 * respectively). The returned color is a non-premultiplied ARGB value.
 *
 * @param x    The x coordinate (0...width-1) of the pixel to return
 * @param y    The y coordinate (0...height-1) of the pixel to return
 * @return     The argb {@link Color} at the specified coordinate
 * @throws IllegalArgumentException if x, y exceed the bitmap's bounds
 */

Body of Frist Method:
{
    checkRecycled("Can't call getPixel() on a recycled bitmap");
    checkPixelAccess(x, y);
    return nativeGetPixel(mNativeBitmap, x, y, mIsPremultiplied);
}
Body of Second Method:
{
    checkRecycled("Can't call getPixel() on a recycled bitmap");
    checkPixelAccess(x, y);
    return nativeGetPixel(mNativeBitmap, x, y);
}
------------------------
Find a silently evolved API code:android.preference.PreferenceActivity.switchToHeader:COMMENT
Method Modifier: public      
Comment:/**
 * When in two-pane mode, switch to the fragment pane to show the given
 * preference fragment.
 *
 * @param header The new header to display.
 */

Body of Frist Method:
{
    if (mCurHeader == header) {
        // This is the header we are currently displaying.  Just make sure
        // to pop the stack up to its root state.
        getFragmentManager().popBackStack(BACK_STACK_PREFS, FragmentManager.POP_BACK_STACK_INCLUSIVE);
    } else {
        if (header.fragment == null) {
            throw new IllegalStateException("can't switch to header that has no fragment");
        }
        int direction = mHeaders.indexOf(header) - mHeaders.indexOf(mCurHeader);
        switchToHeaderInner(header.fragment, header.fragmentArguments, direction);
        setSelectedHeader(header);
    }
}
Body of Second Method:
{
    if (mCurHeader == header) {
        // This is the header we are currently displaying.  Just make sure
        // to pop the stack up to its root state.
        getFragmentManager().popBackStack(BACK_STACK_PREFS, FragmentManager.POP_BACK_STACK_INCLUSIVE);
    } else {
        if (header.fragment == null) {
            throw new IllegalStateException("can't switch to header that has no fragment");
        }
        switchToHeaderInner(header.fragment, header.fragmentArguments);
        setSelectedHeader(header);
    }
}
------------------------
Find a silently evolved API code:android.media.AudioTrack.audioBuffSizeCheck:COMMENT
Method Modifier: private     
Comment:// mNativeBufferSizeInBytes is valid (multiple of frame size, positive)

Body of Frist Method:
{
    // NB: this section is only valid with PCM data.
    // To update when supporting compressed formats
    int frameSizeInBytes = mChannelCount * (mAudioFormat == AudioFormat.ENCODING_PCM_8BIT ? 1 : 2);
    if ((audioBufferSize % frameSizeInBytes != 0) || (audioBufferSize < 1)) {
        throw new IllegalArgumentException("Invalid audio buffer size.");
    }
    mNativeBufferSizeInBytes = audioBufferSize;
    mNativeBufferSizeInFrames = audioBufferSize / frameSizeInBytes;
}
Body of Second Method:
{
    // NB: this section is only valid with PCM data.
    // To update when supporting compressed formats
    int frameSizeInBytes;
    if (AudioFormat.isEncodingLinearPcm(mAudioFormat)) {
        frameSizeInBytes = mChannelCount * (AudioFormat.getBytesPerSample(mAudioFormat));
    } else {
        frameSizeInBytes = 1;
    }
    if ((audioBufferSize % frameSizeInBytes != 0) || (audioBufferSize < 1)) {
        throw new IllegalArgumentException("Invalid audio buffer size.");
    }
    mNativeBufferSizeInBytes = audioBufferSize;
    mNativeBufferSizeInFrames = audioBufferSize / frameSizeInBytes;
}
------------------------
Find a silently evolved API code:android.net.NetworkStats.findIndex:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Find first stats index that matches the requested parameters.
 */

Body of Frist Method:
{
    for (int i = 0; i < size; i++) {
        if (uid == this.uid[i] && set == this.set[i] && tag == this.tag[i] && Objects.equal(iface, this.iface[i])) {
            return i;
        }
    }
    return -1;
}
Body of Second Method:
{
    for (int i = 0; i < size; i++) {
        if (uid == this.uid[i] && set == this.set[i] && tag == this.tag[i] && Objects.equals(iface, this.iface[i])) {
            return i;
        }
    }
    return -1;
}
------------------------
Find a silently evolved API code:android.view.Window.setFormat:COMMENT
Method Modifier: public      
Comment:/**
 * Set the format of window, as per the PixelFormat types.  This overrides
 * the default format that is selected by the Window based on its
 * window decorations.
 *
 * @param format The new window format (see PixelFormat).  Use
 * PixelFormat.UNKNOWN to allow the Window to select
 * the format.
 *
 * @see PixelFormat
 */

Body of Frist Method:
{
    final WindowManager.LayoutParams attrs = getAttributes();
    if (format != PixelFormat.UNKNOWN) {
        attrs.format = format;
        mHaveWindowFormat = true;
    } else {
        attrs.format = mDefaultWindowFormat;
        mHaveWindowFormat = false;
    }
    if (mCallback != null) {
        mCallback.onWindowAttributesChanged(attrs);
    }
}
Body of Second Method:
{
    final WindowManager.LayoutParams attrs = getAttributes();
    if (format != PixelFormat.UNKNOWN) {
        attrs.format = format;
        mHaveWindowFormat = true;
    } else {
        attrs.format = mDefaultWindowFormat;
        mHaveWindowFormat = false;
    }
    dispatchWindowAttributesChanged(attrs);
}
------------------------
Find a silently evolved API code:android.animation.ObjectAnimator.initAnimation:COMMENT
Method Modifier: default     
Comment:/**
 * This function is called immediately before processing the first animation
 * frame of an animation. If there is a nonzero <code>startDelay</code>, the
 * function is called after that delay ends.
 * It takes care of the final initialization steps for the
 * animation. This includes setting mEvaluator, if the user has not yet
 * set it up, and the setter/getter methods, if the user did not supply
 * them.
 *
 * <p>Overriders of this method should call the superclass method to cause
 * internal mechanisms to be set up correctly.</p>
 */

Body of Frist Method:
{
    if (!mInitialized) {
        // mValueType may change due to setter/getter setup; do this before calling super.init(),
        // which uses mValueType to set up the default type evaluator.
        int numValues = mValues.length;
        for (int i = 0; i < numValues; ++i) {
            mValues[i].setupSetterAndGetter(mTarget);
        }
        super.initAnimation();
    }
}
Body of Second Method:
{
    if (!mInitialized) {
        // mValueType may change due to setter/getter setup; do this before calling super.init(),
        // which uses mValueType to set up the default type evaluator.
        final Object target = getTarget();
        if (target != null) {
            final int numValues = mValues.length;
            for (int i = 0; i < numValues; ++i) {
                mValues[i].setupSetterAndGetter(target);
            }
        }
        super.initAnimation();
    }
}
------------------------
Find a silently evolved API code:android.app.backup.WallpaperBackupHelper.restoreEntity:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Restore one absolute file entity from the restore stream.  If we're restoring the
 * magic wallpaper file, take specific action to determine whether it is suitable for
 * the current device.
 */

Body of Frist Method:
{
    final String key = data.getKey();
    if (isKeyInList(key, mKeys)) {
        if (key.equals(WALLPAPER_IMAGE_KEY)) {
            // restore the file to the stage for inspection
            File f = new File(STAGE_FILE);
            if (writeFile(f, data)) {
                // Preflight the restored image's dimensions without loading it
                BitmapFactory.Options options = new BitmapFactory.Options();
                options.inJustDecodeBounds = true;
                BitmapFactory.decodeFile(STAGE_FILE, options);
                if (DEBUG)
                    Slog.d(TAG, "Restoring wallpaper image w=" + options.outWidth + " h=" + options.outHeight);
                // How much does the image differ from our preference?  The threshold
                // here is set to accept any image larger than our target, because
                // scaling down is acceptable; but to reject images that are deemed
                // "too small" to scale up attractively.  The value 1.33 is just barely
                // too low to pass Nexus 1 or Droid wallpapers for use on a Xoom, but
                // will pass anything relatively larger.
                double widthRatio = mDesiredMinWidth / options.outWidth;
                double heightRatio = mDesiredMinHeight / options.outHeight;
                if (widthRatio > 0 && widthRatio < 1.33 && heightRatio > 0 && heightRatio < 1.33) {
                    // sufficiently close to our resolution; go ahead and use it
                    if (DEBUG)
                        Slog.d(TAG, "wallpaper dimension match; using");
                    f.renameTo(new File(WALLPAPER_IMAGE));
                // TODO: spin a service to copy the restored image to sd/usb storage,
                // since it does not exist anywhere other than the private wallpaper
                // file.
                } else {
                    if (DEBUG)
                        Slog.d(TAG, "dimensions too far off: wr=" + widthRatio + " hr=" + heightRatio);
                    f.delete();
                }
            }
        } else if (key.equals(WALLPAPER_INFO_KEY)) {
            // XML file containing wallpaper info
            File f = new File(WALLPAPER_INFO);
            writeFile(f, data);
        }
    }
}
Body of Second Method:
{
    final String key = data.getKey();
    if (isKeyInList(key, mKeys)) {
        if (key.equals(WALLPAPER_IMAGE_KEY)) {
            // restore the file to the stage for inspection
            File f = new File(STAGE_FILE);
            if (writeFile(f, data)) {
                // Preflight the restored image's dimensions without loading it
                BitmapFactory.Options options = new BitmapFactory.Options();
                options.inJustDecodeBounds = true;
                BitmapFactory.decodeFile(STAGE_FILE, options);
                if (DEBUG)
                    Slog.d(TAG, "Restoring wallpaper image w=" + options.outWidth + " h=" + options.outHeight);
                if (REJECT_OUTSIZED_RESTORE) {
                    // We accept any wallpaper that is at least as wide as our preference
                    // (i.e. wide enough to fill the screen), and is within a comfortable
                    // factor of the target height, to avoid significant clipping/scaling/
                    // letterboxing.
                    final double heightRatio = mDesiredMinHeight / options.outHeight;
                    if (options.outWidth < mDesiredMinWidth || heightRatio >= MAX_HEIGHT_RATIO || heightRatio <= MIN_HEIGHT_RATIO) {
                        // Not wide enough for the screen, or too short/tall to be a good fit
                        // for the height of the screen, broken image file, or the system's
                        // desires for wallpaper size are in a bad state.  Probably one of the
                        // first two.
                        Slog.i(TAG, "Restored image dimensions (w=" + options.outWidth + ", h=" + options.outHeight + ") too far off target (tw=" + mDesiredMinWidth + ", th=" + mDesiredMinHeight + "); falling back to default wallpaper.");
                        f.delete();
                        return;
                    }
                }
                // We passed the acceptable-dimensions test (if any), so we're going to
                // use the restored image.
                // TODO: spin a service to copy the restored image to sd/usb storage,
                // since it does not exist anywhere other than the private wallpaper
                // file.
                Slog.d(TAG, "Applying restored wallpaper image.");
                f.renameTo(new File(WALLPAPER_IMAGE));
            }
        } else if (key.equals(WALLPAPER_INFO_KEY)) {
            // XML file containing wallpaper info
            File f = new File(WALLPAPER_INFO);
            writeFile(f, data);
        }
    }
}
------------------------
Find a silently evolved API code:android.app.Activity.getMenuInflater:COMMENT
Method Modifier: public      
Comment:/**
 * Returns a {@link MenuInflater} with this context.
 */

Body of Frist Method:
{
    // Make sure that action views can get an appropriate theme.
    if (mMenuInflater == null) {
        initActionBar();
        if (mActionBar != null) {
            mMenuInflater = new MenuInflater(mActionBar.getThemedContext(), this);
        } else {
            mMenuInflater = new MenuInflater(this);
        }
    }
    return mMenuInflater;
}
Body of Second Method:
{
    // Make sure that action views can get an appropriate theme.
    if (mMenuInflater == null) {
        initWindowDecorActionBar();
        if (mActionBar != null) {
            mMenuInflater = new MenuInflater(mActionBar.getThemedContext(), this);
        } else {
            mMenuInflater = new MenuInflater(this);
        }
    }
    return mMenuInflater;
}
------------------------
Find a silently evolved API code:android.view.accessibility.AccessibilityNodeInfo.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 * <p>
 * <strong>Note:</strong> After the instance is written to a parcel it
 * is recycled. You must not touch the object after calling this function.
 * </p>
 */

Body of Frist Method:
{
    parcel.writeInt(isSealed() ? 1 : 0);
    parcel.writeLong(mSourceNodeId);
    parcel.writeInt(mWindowId);
    parcel.writeLong(mParentNodeId);
    parcel.writeLong(mLabelForId);
    parcel.writeLong(mLabeledById);
    parcel.writeInt(mConnectionId);
    SparseLongArray childIds = mChildNodeIds;
    final int childIdsSize = childIds.size();
    parcel.writeInt(childIdsSize);
    for (int i = 0; i < childIdsSize; i++) {
        parcel.writeLong(childIds.valueAt(i));
    }
    parcel.writeInt(mBoundsInParent.top);
    parcel.writeInt(mBoundsInParent.bottom);
    parcel.writeInt(mBoundsInParent.left);
    parcel.writeInt(mBoundsInParent.right);
    parcel.writeInt(mBoundsInScreen.top);
    parcel.writeInt(mBoundsInScreen.bottom);
    parcel.writeInt(mBoundsInScreen.left);
    parcel.writeInt(mBoundsInScreen.right);
    parcel.writeInt(mActions);
    parcel.writeInt(mMovementGranularities);
    parcel.writeInt(mBooleanProperties);
    parcel.writeCharSequence(mPackageName);
    parcel.writeCharSequence(mClassName);
    parcel.writeCharSequence(mText);
    parcel.writeCharSequence(mContentDescription);
    parcel.writeString(mViewIdResourceName);
    parcel.writeInt(mTextSelectionStart);
    parcel.writeInt(mTextSelectionEnd);
    parcel.writeInt(mInputType);
    parcel.writeInt(mLiveRegion);
    if (mExtras != null) {
        parcel.writeInt(1);
        parcel.writeBundle(mExtras);
    } else {
        parcel.writeInt(0);
    }
    if (mRangeInfo != null) {
        parcel.writeInt(1);
        parcel.writeInt(mRangeInfo.getType());
        parcel.writeFloat(mRangeInfo.getMin());
        parcel.writeFloat(mRangeInfo.getMax());
        parcel.writeFloat(mRangeInfo.getCurrent());
    } else {
        parcel.writeInt(0);
    }
    if (mCollectionInfo != null) {
        parcel.writeInt(1);
        parcel.writeInt(mCollectionInfo.getRowCount());
        parcel.writeInt(mCollectionInfo.getColumnCount());
        parcel.writeInt(mCollectionInfo.isHierarchical() ? 1 : 0);
    } else {
        parcel.writeInt(0);
    }
    if (mCollectionItemInfo != null) {
        parcel.writeInt(1);
        parcel.writeInt(mCollectionItemInfo.getColumnIndex());
        parcel.writeInt(mCollectionItemInfo.getColumnSpan());
        parcel.writeInt(mCollectionItemInfo.getRowIndex());
        parcel.writeInt(mCollectionItemInfo.getRowSpan());
        parcel.writeInt(mCollectionItemInfo.isHeading() ? 1 : 0);
    } else {
        parcel.writeInt(0);
    }
    // Since instances of this class are fetched via synchronous i.e. blocking
    // calls in IPCs we always recycle as soon as the instance is marshaled.
    recycle();
}
Body of Second Method:
{
    parcel.writeInt(isSealed() ? 1 : 0);
    parcel.writeLong(mSourceNodeId);
    parcel.writeInt(mWindowId);
    parcel.writeLong(mParentNodeId);
    parcel.writeLong(mLabelForId);
    parcel.writeLong(mLabeledById);
    parcel.writeInt(mConnectionId);
    final LongArray childIds = mChildNodeIds;
    if (childIds == null) {
        parcel.writeInt(0);
    } else {
        final int childIdsSize = childIds.size();
        parcel.writeInt(childIdsSize);
        for (int i = 0; i < childIdsSize; i++) {
            parcel.writeLong(childIds.get(i));
        }
    }
    parcel.writeInt(mBoundsInParent.top);
    parcel.writeInt(mBoundsInParent.bottom);
    parcel.writeInt(mBoundsInParent.left);
    parcel.writeInt(mBoundsInParent.right);
    parcel.writeInt(mBoundsInScreen.top);
    parcel.writeInt(mBoundsInScreen.bottom);
    parcel.writeInt(mBoundsInScreen.left);
    parcel.writeInt(mBoundsInScreen.right);
    if (mActions != null && !mActions.isEmpty()) {
        final int actionCount = mActions.size();
        parcel.writeInt(actionCount);
        int defaultLegacyStandardActions = 0;
        for (int i = 0; i < actionCount; i++) {
            AccessibilityAction action = mActions.get(i);
            if (isDefaultLegacyStandardAction(action)) {
                defaultLegacyStandardActions |= action.getId();
            }
        }
        parcel.writeInt(defaultLegacyStandardActions);
        for (int i = 0; i < actionCount; i++) {
            AccessibilityAction action = mActions.get(i);
            if (!isDefaultLegacyStandardAction(action)) {
                parcel.writeInt(action.getId());
                parcel.writeCharSequence(action.getLabel());
            }
        }
    } else {
        parcel.writeInt(0);
    }
    parcel.writeInt(mMaxTextLength);
    parcel.writeInt(mMovementGranularities);
    parcel.writeInt(mBooleanProperties);
    parcel.writeCharSequence(mPackageName);
    parcel.writeCharSequence(mClassName);
    parcel.writeCharSequence(mText);
    parcel.writeCharSequence(mError);
    parcel.writeCharSequence(mContentDescription);
    parcel.writeString(mViewIdResourceName);
    parcel.writeInt(mTextSelectionStart);
    parcel.writeInt(mTextSelectionEnd);
    parcel.writeInt(mInputType);
    parcel.writeInt(mLiveRegion);
    if (mExtras != null) {
        parcel.writeInt(1);
        parcel.writeBundle(mExtras);
    } else {
        parcel.writeInt(0);
    }
    if (mRangeInfo != null) {
        parcel.writeInt(1);
        parcel.writeInt(mRangeInfo.getType());
        parcel.writeFloat(mRangeInfo.getMin());
        parcel.writeFloat(mRangeInfo.getMax());
        parcel.writeFloat(mRangeInfo.getCurrent());
    } else {
        parcel.writeInt(0);
    }
    if (mCollectionInfo != null) {
        parcel.writeInt(1);
        parcel.writeInt(mCollectionInfo.getRowCount());
        parcel.writeInt(mCollectionInfo.getColumnCount());
        parcel.writeInt(mCollectionInfo.isHierarchical() ? 1 : 0);
        parcel.writeInt(mCollectionInfo.getSelectionMode());
    } else {
        parcel.writeInt(0);
    }
    if (mCollectionItemInfo != null) {
        parcel.writeInt(1);
        parcel.writeInt(mCollectionItemInfo.getColumnIndex());
        parcel.writeInt(mCollectionItemInfo.getColumnSpan());
        parcel.writeInt(mCollectionItemInfo.getRowIndex());
        parcel.writeInt(mCollectionItemInfo.getRowSpan());
        parcel.writeInt(mCollectionItemInfo.isHeading() ? 1 : 0);
        parcel.writeInt(mCollectionItemInfo.isSelected() ? 1 : 0);
    } else {
        parcel.writeInt(0);
    }
    // Since instances of this class are fetched via synchronous i.e. blocking
    // calls in IPCs we always recycle as soon as the instance is marshaled.
    recycle();
}
------------------------
Find a silently evolved API code:android.widget.CalendarView.setUnfocusedMonthDateColor:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the color for the dates of a not focused month.
 *
 * @param color A not focused month date color.
 *
 * @attr ref android.R.styleable#CalendarView_unfocusedMonthDateColor
 */

Body of Frist Method:
{
    if (mUnfocusedMonthDateColor != color) {
        mUnfocusedMonthDateColor = color;
        final int childCount = mListView.getChildCount();
        for (int i = 0; i < childCount; i++) {
            WeekView weekView = (WeekView) mListView.getChildAt(i);
            if (weekView.mHasUnfocusedDay) {
                weekView.invalidate();
            }
        }
    }
}
Body of Second Method:
{
    mDelegate.setUnfocusedMonthDateColor(color);
}
------------------------
Find a silently evolved API code:android.widget.CalendarView.getSelectedDateVerticalBar:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the drawable for the vertical bar shown at the beginning and at
 * the end of the selected date.
 *
 * @return The vertical bar drawable.
 */

Body of Frist Method:
{
    return mSelectedDateVerticalBar;
}
Body of Second Method:
{
    return mDelegate.getSelectedDateVerticalBar();
}
------------------------
Find a silently evolved API code:android.graphics.pdf.PdfDocument.finishPage:COMMENT
Method Modifier: public      
Comment:/**
 * Finishes a started page. You should always finish the last started page.
 * <p>
 * <strong>Note:</strong> Do not call this method after {@link #close()}.
 * You should not finish the same page more than once.
 * </p>
 *
 * @param page The page. Cannot be null.
 *
 * @see #startPage(PageInfo)
 */

Body of Frist Method:
{
    throwIfClosed();
    if (page == null) {
        throw new IllegalArgumentException("page cannot be null");
    }
    if (page != mCurrentPage) {
        throw new IllegalStateException("invalid page");
    }
    if (page.isFinished()) {
        throw new IllegalStateException("page already finished");
    }
    mPages.add(page.getInfo());
    mCurrentPage = null;
    nativeAppendPage(mNativeDocument, page.mCanvas.mNativeCanvas);
    page.finish();
}
Body of Second Method:
{
    throwIfClosed();
    if (page == null) {
        throw new IllegalArgumentException("page cannot be null");
    }
    if (page != mCurrentPage) {
        throw new IllegalStateException("invalid page");
    }
    if (page.isFinished()) {
        throw new IllegalStateException("page already finished");
    }
    mPages.add(page.getInfo());
    mCurrentPage = null;
    nativeFinishPage(mNativeDocument);
    page.finish();
}
------------------------
Find a silently evolved API code:android.media.MediaPlayer.addSubtitleSource:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    final InputStream fIs = is;
    final MediaFormat fFormat = format;
    // way to implement timeouts in the future.
    synchronized (mOpenSubtitleSources) {
        mOpenSubtitleSources.add(is);
    }
    // process each subtitle in its own thread
    final HandlerThread thread = new HandlerThread("SubtitleReadThread", Process.THREAD_PRIORITY_BACKGROUND + Process.THREAD_PRIORITY_MORE_FAVORABLE);
    thread.start();
    Handler handler = new Handler(thread.getLooper());
    handler.post(new Runnable() {

        private int addTrack() {
            if (fIs == null || mSubtitleController == null) {
                return MEDIA_INFO_UNSUPPORTED_SUBTITLE;
            }
            SubtitleTrack track = mSubtitleController.addTrack(fFormat);
            if (track == null) {
                return MEDIA_INFO_UNSUPPORTED_SUBTITLE;
            }
            // TODO: do the conversion in the subtitle track
            Scanner scanner = new Scanner(fIs, "UTF-8");
            String contents = scanner.useDelimiter("\\A").next();
            synchronized (mOpenSubtitleSources) {
                mOpenSubtitleSources.remove(fIs);
            }
            scanner.close();
            mOutOfBandSubtitleTracks.add(track);
            track.onData(contents, true, /* eos */
            ~0);
            return MEDIA_INFO_EXTERNAL_METADATA_UPDATE;
        }

        public void run() {
            int res = addTrack();
            if (mEventHandler != null) {
                Message m = mEventHandler.obtainMessage(MEDIA_INFO, res, 0, null);
                mEventHandler.sendMessage(m);
            }
            thread.getLooper().quitSafely();
        }
    });
}
Body of Second Method:
{
    final InputStream fIs = is;
    final MediaFormat fFormat = format;
    // way to implement timeouts in the future.
    synchronized (mOpenSubtitleSources) {
        mOpenSubtitleSources.add(is);
    }
    // process each subtitle in its own thread
    final HandlerThread thread = new HandlerThread("SubtitleReadThread", Process.THREAD_PRIORITY_BACKGROUND + Process.THREAD_PRIORITY_MORE_FAVORABLE);
    thread.start();
    Handler handler = new Handler(thread.getLooper());
    handler.post(new Runnable() {

        private int addTrack() {
            if (fIs == null || mSubtitleController == null) {
                return MEDIA_INFO_UNSUPPORTED_SUBTITLE;
            }
            SubtitleTrack track = mSubtitleController.addTrack(fFormat);
            if (track == null) {
                return MEDIA_INFO_UNSUPPORTED_SUBTITLE;
            }
            // TODO: do the conversion in the subtitle track
            Scanner scanner = new Scanner(fIs, "UTF-8");
            String contents = scanner.useDelimiter("\\A").next();
            synchronized (mOpenSubtitleSources) {
                mOpenSubtitleSources.remove(fIs);
            }
            scanner.close();
            mOutOfBandSubtitleTracks.add(track);
            track.onData(contents.getBytes(), true, /* eos */
            ~0);
            return MEDIA_INFO_EXTERNAL_METADATA_UPDATE;
        }

        public void run() {
            int res = addTrack();
            if (mEventHandler != null) {
                Message m = mEventHandler.obtainMessage(MEDIA_INFO, res, 0, null);
                mEventHandler.sendMessage(m);
            }
            thread.getLooper().quitSafely();
        }
    });
}
------------------------
Find a silently evolved API code:android.net.ConnectivityManager.isNetworkTypeMobile:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Checks if a given type uses the cellular data connection.
 * This should be replaced in the future by a network property.
 * @param networkType the type to check
 * @return a boolean - {@code true} if uses cellular network, else {@code false}
 * {@hide}
 */

Body of Frist Method:
{
    switch(networkType) {
        case TYPE_MOBILE:
        case TYPE_MOBILE_MMS:
        case TYPE_MOBILE_SUPL:
        case TYPE_MOBILE_DUN:
        case TYPE_MOBILE_HIPRI:
        case TYPE_MOBILE_FOTA:
        case TYPE_MOBILE_IMS:
        case TYPE_MOBILE_CBS:
        case TYPE_MOBILE_IA:
            return true;
        default:
            return false;
    }
}
Body of Second Method:
{
    switch(networkType) {
        case TYPE_MOBILE:
        case TYPE_MOBILE_MMS:
        case TYPE_MOBILE_SUPL:
        case TYPE_MOBILE_DUN:
        case TYPE_MOBILE_HIPRI:
        case TYPE_MOBILE_FOTA:
        case TYPE_MOBILE_IMS:
        case TYPE_MOBILE_CBS:
        case TYPE_MOBILE_IA:
        case TYPE_MOBILE_EMERGENCY:
            return true;
        default:
            return false;
    }
}
------------------------
Find a silently evolved API code:android.os.Parcel.readArrayMapSafelyInternal:COMMENT
Method Modifier: default     
Comment:/* package */

Body of Frist Method:
{
    if (DEBUG_ARRAY_MAP) {
        RuntimeException here = new RuntimeException("here");
        here.fillInStackTrace();
        Log.d(TAG, "Reading safely " + N + " ArrayMap entries", here);
    }
    while (N > 0) {
        Object key = readValue(loader);
        if (DEBUG_ARRAY_MAP)
            Log.d(TAG, "  Read safe #" + (N - 1) + ": key=0x" + (key != null ? key.hashCode() : 0) + " " + key);
        Object value = readValue(loader);
        outVal.put(key, value);
        N--;
    }
}
Body of Second Method:
{
    if (DEBUG_ARRAY_MAP) {
        RuntimeException here = new RuntimeException("here");
        here.fillInStackTrace();
        Log.d(TAG, "Reading safely " + N + " ArrayMap entries", here);
    }
    while (N > 0) {
        String key = readString();
        if (DEBUG_ARRAY_MAP)
            Log.d(TAG, "  Read safe #" + (N - 1) + ": key=0x" + (key != null ? key.hashCode() : 0) + " " + key);
        Object value = readValue(loader);
        outVal.put(key, value);
        N--;
    }
}
------------------------
Find a silently evolved API code:android.os.ParcelFileDescriptor.createReliableSocketPair:COMMENT
Method Modifier: public      static      
Comment:/**
 * Create two ParcelFileDescriptors structured as a pair of sockets
 * connected to each other. The two sockets are indistinguishable.
 * <p>
 * Both ends have the ability to deliver an error message through
 * {@link #closeWithError(String)} which can be detected by the other end
 * calling {@link #checkError()}, usually after detecting an EOF.
 * This can also be used to detect remote crashes.
 */

Body of Frist Method:
{
    try {
        final FileDescriptor[] comm = createCommSocketPair(false);
        final FileDescriptor fd0 = new FileDescriptor();
        final FileDescriptor fd1 = new FileDescriptor();
        Libcore.os.socketpair(AF_UNIX, SOCK_STREAM, 0, fd0, fd1);
        return new ParcelFileDescriptor[] { new ParcelFileDescriptor(fd0, comm[0]), new ParcelFileDescriptor(fd1, comm[1]) };
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
}
Body of Second Method:
{
    try {
        final FileDescriptor[] comm = createCommSocketPair();
        final FileDescriptor fd0 = new FileDescriptor();
        final FileDescriptor fd1 = new FileDescriptor();
        Os.socketpair(AF_UNIX, SOCK_STREAM, 0, fd0, fd1);
        return new ParcelFileDescriptor[] { new ParcelFileDescriptor(fd0, comm[0]), new ParcelFileDescriptor(fd1, comm[1]) };
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
}
------------------------
Find a silently evolved API code:android.media.MediaRouter.selectRoute:COMMENT
Method Modifier: public      
Comment:/**
 * Select the specified route to use for output of the given media types.
 * <p class="note">
 * As API version 18, this function may be used to select any route.
 * In prior versions, this function could only be used to select user
 * routes and would ignore any attempt to select a system route.
 * </p>
 *
 * @param types type flags indicating which types this route should be used for.
 * The route must support at least a subset.
 * @param route Route to select
 */

Body of Frist Method:
{
    selectRouteStatic(types, route);
}
Body of Second Method:
{
    selectRouteStatic(types, route, true);
}
------------------------
Find a silently evolved API code:android.transition.TransitionSet.createAnimators:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    for (Transition childTransition : mTransitions) {
        childTransition.createAnimators(sceneRoot, startValues, endValues);
    }
}
Body of Second Method:
{
    long startDelay = getStartDelay();
    int numTransitions = mTransitions.size();
    for (int i = 0; i < numTransitions; i++) {
        Transition childTransition = mTransitions.get(i);
        // the transitions sequentially.
        if (startDelay > 0 && (mPlayTogether || i == 0)) {
            long childStartDelay = childTransition.getStartDelay();
            if (childStartDelay > 0) {
                childTransition.setStartDelay(startDelay + childStartDelay);
            } else {
                childTransition.setStartDelay(startDelay);
            }
        }
        childTransition.createAnimators(sceneRoot, startValues, endValues, startValuesList, endValuesList);
    }
}
------------------------
Find a silently evolved API code:android.media.MediaFocusControl.onRegisterVolumeObserverForRcc:COMMENT
Method Modifier: private     hidden      
Comment:// handler for MSG_RCC_NEW_VOLUME_OBS

Body of Frist Method:
{
    synchronized (mRCStack) {
        // start iterating from the top.
        try {
            for (int index = mRCStack.size() - 1; index >= 0; index--) {
                final RemoteControlStackEntry rcse = mRCStack.elementAt(index);
                if (rcse.mRccId == rccId) {
                    rcse.mRemoteVolumeObs = rvo;
                    break;
                }
            }
        } catch (ArrayIndexOutOfBoundsException e) {
            // not expected to happen, indicates improper concurrent modification
            Log.e(TAG, "Wrong index accessing media button stack, lock error? ", e);
        }
    }
}
Body of Second Method:
{
    synchronized (mPRStack) {
        // start iterating from the top.
        try {
            for (int index = mPRStack.size() - 1; index >= 0; index--) {
                final PlayerRecord prse = mPRStack.elementAt(index);
                if (prse.getRccId() == rccId) {
                    prse.mRemoteVolumeObs = rvo;
                    break;
                }
            }
        } catch (ArrayIndexOutOfBoundsException e) {
            // not expected to happen, indicates improper concurrent modification
            Log.e(TAG, "Wrong index accessing media button stack, lock error? ", e);
        }
    }
}
------------------------
Find a silently evolved API code:android.text.SpannableStringBuilder.getTextRunAdvances:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Don't call this yourself -- exists for Paint to use internally.
 * {@hide}
 */

Body of Frist Method:
{
    float ret;
    int contextLen = contextEnd - contextStart;
    int len = end - start;
    if (end <= mGapStart) {
        ret = p.getTextRunAdvances(mText, start, len, contextStart, contextLen, flags, advances, advancesPos);
    } else if (start >= mGapStart) {
        ret = p.getTextRunAdvances(mText, start + mGapLength, len, contextStart + mGapLength, contextLen, flags, advances, advancesPos);
    } else {
        char[] buf = TextUtils.obtain(contextLen);
        getChars(contextStart, contextEnd, buf, 0);
        ret = p.getTextRunAdvances(buf, start - contextStart, len, 0, contextLen, flags, advances, advancesPos);
        TextUtils.recycle(buf);
    }
    return ret;
}
Body of Second Method:
{
    float ret;
    int contextLen = contextEnd - contextStart;
    int len = end - start;
    if (end <= mGapStart) {
        ret = p.getTextRunAdvances(mText, start, len, contextStart, contextLen, isRtl, advances, advancesPos);
    } else if (start >= mGapStart) {
        ret = p.getTextRunAdvances(mText, start + mGapLength, len, contextStart + mGapLength, contextLen, isRtl, advances, advancesPos);
    } else {
        char[] buf = TextUtils.obtain(contextLen);
        getChars(contextStart, contextEnd, buf, 0);
        ret = p.getTextRunAdvances(buf, start - contextStart, len, 0, contextLen, isRtl, advances, advancesPos);
        TextUtils.recycle(buf);
    }
    return ret;
}
------------------------
Find a silently evolved API code:android.widget.CalendarView.setDateTextAppearance:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the text appearance for the calendar dates.
 *
 * @param resourceId The text appearance resource id.
 *
 * @attr ref android.R.styleable#CalendarView_dateTextAppearance
 */

Body of Frist Method:
{
    if (mDateTextAppearanceResId != resourceId) {
        mDateTextAppearanceResId = resourceId;
        updateDateTextSize();
        invalidateAllWeekViews();
    }
}
Body of Second Method:
{
    mDelegate.setDateTextAppearance(resourceId);
}
------------------------
Find a silently evolved API code:android.net.ConnectivityManager.setProvisioningNotificationVisible:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Set sign in error notification to visible or in visible
 *
 * @param visible
 * @param networkType
 *
 * {@hide}
 */

Body of Frist Method:
{
    try {
        mService.setProvisioningNotificationVisible(visible, networkType, extraInfo, url);
    } catch (RemoteException e) {
    }
}
Body of Second Method:
{
    try {
        mService.setProvisioningNotificationVisible(visible, networkType, action);
    } catch (RemoteException e) {
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiInfo.getHiddenSSID:COMMENT
Method Modifier: public      
Comment:/**
 * @return {@code true} if this network does not broadcast its SSID, so an
 * SSID-specific probe request must be used for scans.
 */

Body of Frist Method:
{
    return mHiddenSSID;
}
Body of Second Method:
{
    if (mWifiSsid == null)
        return false;
    return mWifiSsid.isHidden();
}
------------------------
Find a silently evolved API code:android.os.Parcel.writeException:COMMENT
Method Modifier: public      final       
Comment:/**
 * Special function for writing an exception result at the header of
 * a parcel, to be used when returning an exception from a transaction.
 * Note that this currently only supports a few exception types; any other
 * exception will be re-thrown by this function as a RuntimeException
 * (to be caught by the system's last-resort exception handling when
 * dispatching a transaction).
 *
 * <p>The supported exception types are:
 * <ul>
 * <li>{@link BadParcelableException}
 * <li>{@link IllegalArgumentException}
 * <li>{@link IllegalStateException}
 * <li>{@link NullPointerException}
 * <li>{@link SecurityException}
 * <li>{@link NetworkOnMainThreadException}
 * </ul>
 *
 * @param e The Exception to be written.
 *
 * @see #writeNoException
 * @see #readException
 */

Body of Frist Method:
{
    int code = 0;
    if (e instanceof SecurityException) {
        code = EX_SECURITY;
    } else if (e instanceof BadParcelableException) {
        code = EX_BAD_PARCELABLE;
    } else if (e instanceof IllegalArgumentException) {
        code = EX_ILLEGAL_ARGUMENT;
    } else if (e instanceof NullPointerException) {
        code = EX_NULL_POINTER;
    } else if (e instanceof IllegalStateException) {
        code = EX_ILLEGAL_STATE;
    } else if (e instanceof NetworkOnMainThreadException) {
        code = EX_NETWORK_MAIN_THREAD;
    }
    writeInt(code);
    StrictMode.clearGatheredViolations();
    if (code == 0) {
        if (e instanceof RuntimeException) {
            throw (RuntimeException) e;
        }
        throw new RuntimeException(e);
    }
    writeString(e.getMessage());
}
Body of Second Method:
{
    int code = 0;
    if (e instanceof SecurityException) {
        code = EX_SECURITY;
    } else if (e instanceof BadParcelableException) {
        code = EX_BAD_PARCELABLE;
    } else if (e instanceof IllegalArgumentException) {
        code = EX_ILLEGAL_ARGUMENT;
    } else if (e instanceof NullPointerException) {
        code = EX_NULL_POINTER;
    } else if (e instanceof IllegalStateException) {
        code = EX_ILLEGAL_STATE;
    } else if (e instanceof NetworkOnMainThreadException) {
        code = EX_NETWORK_MAIN_THREAD;
    } else if (e instanceof UnsupportedOperationException) {
        code = EX_UNSUPPORTED_OPERATION;
    }
    writeInt(code);
    StrictMode.clearGatheredViolations();
    if (code == 0) {
        if (e instanceof RuntimeException) {
            throw (RuntimeException) e;
        }
        throw new RuntimeException(e);
    }
    writeString(e.getMessage());
}
------------------------
Find a silently evolved API code:android.content.res.BridgeTypedArray.getValue:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the raw TypedValue for the attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 * @param outValue TypedValue object in which to place the attribute's
 * data.
 *
 * @return Returns true if the value was retrieved, else false.
 */

Body of Frist Method:
{
    if (index < 0 || index >= mResourceData.length) {
        return false;
    }
    if (mResourceData[index] == null) {
        return false;
    }
    String s = mResourceData[index].getValue();
    return ResourceHelper.parseFloatAttribute(mNames[index], s, outValue, false);
}
Body of Second Method:
{
    String s = getString(index);
    return s != null && ResourceHelper.parseFloatAttribute(mNames[index], s, outValue, false);
}
------------------------
Find a silently evolved API code:android.widget.LinearLayout.measureVertical:COMMENT
Method Modifier: default     
Comment:/**
 * Measures the children when the orientation of this LinearLayout is set
 * to {@link #VERTICAL}.
 *
 * @param widthMeasureSpec Horizontal space requirements as imposed by the parent.
 * @param heightMeasureSpec Vertical space requirements as imposed by the parent.
 *
 * @see #getOrientation()
 * @see #setOrientation(int)
 * @see #onMeasure(int, int)
 */

Body of Frist Method:
{
    mTotalLength = 0;
    int maxWidth = 0;
    int childState = 0;
    int alternativeMaxWidth = 0;
    int weightedMaxWidth = 0;
    boolean allFillParent = true;
    float totalWeight = 0;
    final int count = getVirtualChildCount();
    final int widthMode = MeasureSpec.getMode(widthMeasureSpec);
    final int heightMode = MeasureSpec.getMode(heightMeasureSpec);
    boolean matchWidth = false;
    final int baselineChildIndex = mBaselineAlignedChildIndex;
    final boolean useLargestChild = mUseLargestChild;
    int largestChildHeight = Integer.MIN_VALUE;
    // See how tall everyone is. Also remember max width.
    for (int i = 0; i < count; ++i) {
        final View child = getVirtualChildAt(i);
        if (child == null) {
            mTotalLength += measureNullChild(i);
            continue;
        }
        if (child.getVisibility() == View.GONE) {
            i += getChildrenSkipCount(child, i);
            continue;
        }
        if (hasDividerBeforeChildAt(i)) {
            mTotalLength += mDividerHeight;
        }
        LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
        totalWeight += lp.weight;
        if (heightMode == MeasureSpec.EXACTLY && lp.height == 0 && lp.weight > 0) {
            // Optimization: don't bother measuring children who are going to use
            // leftover space. These views will get measured again down below if
            // there is any leftover space.
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin);
        } else {
            int oldHeight = Integer.MIN_VALUE;
            if (lp.height == 0 && lp.weight > 0) {
                // heightMode is either UNSPECIFIED or AT_MOST, and this
                // child wanted to stretch to fill available space.
                // Translate that to WRAP_CONTENT so that it does not end up
                // with a height of 0
                oldHeight = 0;
                lp.height = LayoutParams.WRAP_CONTENT;
            }
            // Determine how big this child would like to be. If this or
            // previous children have given a weight, then we allow it to
            // use all available space (and we will shrink things later
            // if needed).
            measureChildBeforeLayout(child, i, widthMeasureSpec, 0, heightMeasureSpec, totalWeight == 0 ? mTotalLength : 0);
            if (oldHeight != Integer.MIN_VALUE) {
                lp.height = oldHeight;
            }
            final int childHeight = child.getMeasuredHeight();
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
            if (useLargestChild) {
                largestChildHeight = Math.max(childHeight, largestChildHeight);
            }
        }
        /**
         * If applicable, compute the additional offset to the child's baseline
         * we'll need later when asked {@link #getBaseline}.
         */
        if ((baselineChildIndex >= 0) && (baselineChildIndex == i + 1)) {
            mBaselineChildTop = mTotalLength;
        }
        // weight.  fail fast to aid the developer.
        if (i < baselineChildIndex && lp.weight > 0) {
            throw new RuntimeException("A child of LinearLayout with index " + "less than mBaselineAlignedChildIndex has weight > 0, which " + "won't work.  Either remove the weight, or don't set " + "mBaselineAlignedChildIndex.");
        }
        boolean matchWidthLocally = false;
        if (widthMode != MeasureSpec.EXACTLY && lp.width == LayoutParams.MATCH_PARENT) {
            // The width of the linear layout will scale, and at least one
            // child said it wanted to match our width. Set a flag
            // indicating that we need to remeasure at least that view when
            // we know our width.
            matchWidth = true;
            matchWidthLocally = true;
        }
        final int margin = lp.leftMargin + lp.rightMargin;
        final int measuredWidth = child.getMeasuredWidth() + margin;
        maxWidth = Math.max(maxWidth, measuredWidth);
        childState = combineMeasuredStates(childState, child.getMeasuredState());
        allFillParent = allFillParent && lp.width == LayoutParams.MATCH_PARENT;
        if (lp.weight > 0) {
            /*
                 * Widths of weighted Views are bogus if we end up
                 * remeasuring, so keep them separate.
                 */
            weightedMaxWidth = Math.max(weightedMaxWidth, matchWidthLocally ? margin : measuredWidth);
        } else {
            alternativeMaxWidth = Math.max(alternativeMaxWidth, matchWidthLocally ? margin : measuredWidth);
        }
        i += getChildrenSkipCount(child, i);
    }
    if (mTotalLength > 0 && hasDividerBeforeChildAt(count)) {
        mTotalLength += mDividerHeight;
    }
    if (useLargestChild && (heightMode == MeasureSpec.AT_MOST || heightMode == MeasureSpec.UNSPECIFIED)) {
        mTotalLength = 0;
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child == null) {
                mTotalLength += measureNullChild(i);
                continue;
            }
            if (child.getVisibility() == GONE) {
                i += getChildrenSkipCount(child, i);
                continue;
            }
            final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
            // Account for negative margins
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + largestChildHeight + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
        }
    }
    // Add in our padding
    mTotalLength += mPaddingTop + mPaddingBottom;
    int heightSize = mTotalLength;
    // Check against our minimum height
    heightSize = Math.max(heightSize, getSuggestedMinimumHeight());
    // Reconcile our calculated size with the heightMeasureSpec
    int heightSizeAndState = resolveSizeAndState(heightSize, heightMeasureSpec, 0);
    heightSize = heightSizeAndState & MEASURED_SIZE_MASK;
    // Either expand children with weight to take up available space or
    // shrink them if they extend beyond our current bounds
    int delta = heightSize - mTotalLength;
    if (delta != 0 && totalWeight > 0.0f) {
        float weightSum = mWeightSum > 0.0f ? mWeightSum : totalWeight;
        mTotalLength = 0;
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child.getVisibility() == View.GONE) {
                continue;
            }
            LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
            float childExtra = lp.weight;
            if (childExtra > 0) {
                // Child said it could absorb extra space -- give him his share
                int share = (int) (childExtra * delta / weightSum);
                weightSum -= childExtra;
                delta -= share;
                final int childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin, lp.width);
                // child has been previously measured
                if ((lp.height != 0) || (heightMode != MeasureSpec.EXACTLY)) {
                    // child was measured once already above...
                    // base new measurement on stored values
                    int childHeight = child.getMeasuredHeight() + share;
                    if (childHeight < 0) {
                        childHeight = 0;
                    }
                    child.measure(childWidthMeasureSpec, MeasureSpec.makeMeasureSpec(childHeight, MeasureSpec.EXACTLY));
                } else {
                    // child was skipped in the loop above.
                    // Measure for this first time here
                    child.measure(childWidthMeasureSpec, MeasureSpec.makeMeasureSpec(share > 0 ? share : 0, MeasureSpec.EXACTLY));
                }
                // Child may now not fit in vertical dimension.
                childState = combineMeasuredStates(childState, child.getMeasuredState() & (MEASURED_STATE_MASK >> MEASURED_HEIGHT_STATE_SHIFT));
            }
            final int margin = lp.leftMargin + lp.rightMargin;
            final int measuredWidth = child.getMeasuredWidth() + margin;
            maxWidth = Math.max(maxWidth, measuredWidth);
            boolean matchWidthLocally = widthMode != MeasureSpec.EXACTLY && lp.width == LayoutParams.MATCH_PARENT;
            alternativeMaxWidth = Math.max(alternativeMaxWidth, matchWidthLocally ? margin : measuredWidth);
            allFillParent = allFillParent && lp.width == LayoutParams.MATCH_PARENT;
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
        }
        // Add in our padding
        mTotalLength += mPaddingTop + mPaddingBottom;
    // TODO: Should we recompute the heightSpec based on the new total length?
    } else {
        alternativeMaxWidth = Math.max(alternativeMaxWidth, weightedMaxWidth);
        // Children will have already been measured once.
        if (useLargestChild && heightMode != MeasureSpec.EXACTLY) {
            for (int i = 0; i < count; i++) {
                final View child = getVirtualChildAt(i);
                if (child == null || child.getVisibility() == View.GONE) {
                    continue;
                }
                final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
                float childExtra = lp.weight;
                if (childExtra > 0) {
                    child.measure(MeasureSpec.makeMeasureSpec(child.getMeasuredWidth(), MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(largestChildHeight, MeasureSpec.EXACTLY));
                }
            }
        }
    }
    if (!allFillParent && widthMode != MeasureSpec.EXACTLY) {
        maxWidth = alternativeMaxWidth;
    }
    maxWidth += mPaddingLeft + mPaddingRight;
    // Check against our minimum width
    maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());
    setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState), heightSizeAndState);
    if (matchWidth) {
        forceUniformWidth(count, heightMeasureSpec);
    }
}
Body of Second Method:
{
    mTotalLength = 0;
    int maxWidth = 0;
    int childState = 0;
    int alternativeMaxWidth = 0;
    int weightedMaxWidth = 0;
    boolean allFillParent = true;
    float totalWeight = 0;
    final int count = getVirtualChildCount();
    final int widthMode = MeasureSpec.getMode(widthMeasureSpec);
    final int heightMode = MeasureSpec.getMode(heightMeasureSpec);
    boolean matchWidth = false;
    boolean skippedMeasure = false;
    final int baselineChildIndex = mBaselineAlignedChildIndex;
    final boolean useLargestChild = mUseLargestChild;
    int largestChildHeight = Integer.MIN_VALUE;
    // See how tall everyone is. Also remember max width.
    for (int i = 0; i < count; ++i) {
        final View child = getVirtualChildAt(i);
        if (child == null) {
            mTotalLength += measureNullChild(i);
            continue;
        }
        if (child.getVisibility() == View.GONE) {
            i += getChildrenSkipCount(child, i);
            continue;
        }
        if (hasDividerBeforeChildAt(i)) {
            mTotalLength += mDividerHeight;
        }
        LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
        totalWeight += lp.weight;
        if (heightMode == MeasureSpec.EXACTLY && lp.height == 0 && lp.weight > 0) {
            // Optimization: don't bother measuring children who are going to use
            // leftover space. These views will get measured again down below if
            // there is any leftover space.
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + lp.topMargin + lp.bottomMargin);
            skippedMeasure = true;
        } else {
            int oldHeight = Integer.MIN_VALUE;
            if (lp.height == 0 && lp.weight > 0) {
                // heightMode is either UNSPECIFIED or AT_MOST, and this
                // child wanted to stretch to fill available space.
                // Translate that to WRAP_CONTENT so that it does not end up
                // with a height of 0
                oldHeight = 0;
                lp.height = LayoutParams.WRAP_CONTENT;
            }
            // Determine how big this child would like to be. If this or
            // previous children have given a weight, then we allow it to
            // use all available space (and we will shrink things later
            // if needed).
            measureChildBeforeLayout(child, i, widthMeasureSpec, 0, heightMeasureSpec, totalWeight == 0 ? mTotalLength : 0);
            if (oldHeight != Integer.MIN_VALUE) {
                lp.height = oldHeight;
            }
            final int childHeight = child.getMeasuredHeight();
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
            if (useLargestChild) {
                largestChildHeight = Math.max(childHeight, largestChildHeight);
            }
        }
        /**
         * If applicable, compute the additional offset to the child's baseline
         * we'll need later when asked {@link #getBaseline}.
         */
        if ((baselineChildIndex >= 0) && (baselineChildIndex == i + 1)) {
            mBaselineChildTop = mTotalLength;
        }
        // weight.  fail fast to aid the developer.
        if (i < baselineChildIndex && lp.weight > 0) {
            throw new RuntimeException("A child of LinearLayout with index " + "less than mBaselineAlignedChildIndex has weight > 0, which " + "won't work.  Either remove the weight, or don't set " + "mBaselineAlignedChildIndex.");
        }
        boolean matchWidthLocally = false;
        if (widthMode != MeasureSpec.EXACTLY && lp.width == LayoutParams.MATCH_PARENT) {
            // The width of the linear layout will scale, and at least one
            // child said it wanted to match our width. Set a flag
            // indicating that we need to remeasure at least that view when
            // we know our width.
            matchWidth = true;
            matchWidthLocally = true;
        }
        final int margin = lp.leftMargin + lp.rightMargin;
        final int measuredWidth = child.getMeasuredWidth() + margin;
        maxWidth = Math.max(maxWidth, measuredWidth);
        childState = combineMeasuredStates(childState, child.getMeasuredState());
        allFillParent = allFillParent && lp.width == LayoutParams.MATCH_PARENT;
        if (lp.weight > 0) {
            /*
                 * Widths of weighted Views are bogus if we end up
                 * remeasuring, so keep them separate.
                 */
            weightedMaxWidth = Math.max(weightedMaxWidth, matchWidthLocally ? margin : measuredWidth);
        } else {
            alternativeMaxWidth = Math.max(alternativeMaxWidth, matchWidthLocally ? margin : measuredWidth);
        }
        i += getChildrenSkipCount(child, i);
    }
    if (mTotalLength > 0 && hasDividerBeforeChildAt(count)) {
        mTotalLength += mDividerHeight;
    }
    if (useLargestChild && (heightMode == MeasureSpec.AT_MOST || heightMode == MeasureSpec.UNSPECIFIED)) {
        mTotalLength = 0;
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child == null) {
                mTotalLength += measureNullChild(i);
                continue;
            }
            if (child.getVisibility() == GONE) {
                i += getChildrenSkipCount(child, i);
                continue;
            }
            final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
            // Account for negative margins
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + largestChildHeight + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
        }
    }
    // Add in our padding
    mTotalLength += mPaddingTop + mPaddingBottom;
    int heightSize = mTotalLength;
    // Check against our minimum height
    heightSize = Math.max(heightSize, getSuggestedMinimumHeight());
    // Reconcile our calculated size with the heightMeasureSpec
    int heightSizeAndState = resolveSizeAndState(heightSize, heightMeasureSpec, 0);
    heightSize = heightSizeAndState & MEASURED_SIZE_MASK;
    // Either expand children with weight to take up available space or
    // shrink them if they extend beyond our current bounds. If we skipped
    // measurement on any children, we need to measure them now.
    int delta = heightSize - mTotalLength;
    if (skippedMeasure || delta != 0 && totalWeight > 0.0f) {
        float weightSum = mWeightSum > 0.0f ? mWeightSum : totalWeight;
        mTotalLength = 0;
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child.getVisibility() == View.GONE) {
                continue;
            }
            LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
            float childExtra = lp.weight;
            if (childExtra > 0) {
                // Child said it could absorb extra space -- give him his share
                int share = (int) (childExtra * delta / weightSum);
                weightSum -= childExtra;
                delta -= share;
                final int childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin, lp.width);
                // child has been previously measured
                if ((lp.height != 0) || (heightMode != MeasureSpec.EXACTLY)) {
                    // child was measured once already above...
                    // base new measurement on stored values
                    int childHeight = child.getMeasuredHeight() + share;
                    if (childHeight < 0) {
                        childHeight = 0;
                    }
                    child.measure(childWidthMeasureSpec, MeasureSpec.makeMeasureSpec(childHeight, MeasureSpec.EXACTLY));
                } else {
                    // child was skipped in the loop above.
                    // Measure for this first time here
                    child.measure(childWidthMeasureSpec, MeasureSpec.makeMeasureSpec(share > 0 ? share : 0, MeasureSpec.EXACTLY));
                }
                // Child may now not fit in vertical dimension.
                childState = combineMeasuredStates(childState, child.getMeasuredState() & (MEASURED_STATE_MASK >> MEASURED_HEIGHT_STATE_SHIFT));
            }
            final int margin = lp.leftMargin + lp.rightMargin;
            final int measuredWidth = child.getMeasuredWidth() + margin;
            maxWidth = Math.max(maxWidth, measuredWidth);
            boolean matchWidthLocally = widthMode != MeasureSpec.EXACTLY && lp.width == LayoutParams.MATCH_PARENT;
            alternativeMaxWidth = Math.max(alternativeMaxWidth, matchWidthLocally ? margin : measuredWidth);
            allFillParent = allFillParent && lp.width == LayoutParams.MATCH_PARENT;
            final int totalLength = mTotalLength;
            mTotalLength = Math.max(totalLength, totalLength + child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin + getNextLocationOffset(child));
        }
        // Add in our padding
        mTotalLength += mPaddingTop + mPaddingBottom;
    // TODO: Should we recompute the heightSpec based on the new total length?
    } else {
        alternativeMaxWidth = Math.max(alternativeMaxWidth, weightedMaxWidth);
        // Children will have already been measured once.
        if (useLargestChild && heightMode != MeasureSpec.EXACTLY) {
            for (int i = 0; i < count; i++) {
                final View child = getVirtualChildAt(i);
                if (child == null || child.getVisibility() == View.GONE) {
                    continue;
                }
                final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
                float childExtra = lp.weight;
                if (childExtra > 0) {
                    child.measure(MeasureSpec.makeMeasureSpec(child.getMeasuredWidth(), MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(largestChildHeight, MeasureSpec.EXACTLY));
                }
            }
        }
    }
    if (!allFillParent && widthMode != MeasureSpec.EXACTLY) {
        maxWidth = alternativeMaxWidth;
    }
    maxWidth += mPaddingLeft + mPaddingRight;
    // Check against our minimum width
    maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());
    setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState), heightSizeAndState);
    if (matchWidth) {
        forceUniformWidth(count, heightMeasureSpec);
    }
}
------------------------
Find a silently evolved API code:android.graphics.Paint_Delegate.updateFontObject:COMMENT
Method Modifier: private     
Comment:/**
 * Update the {@link Font} object from the typeface, text size and scaling
 */

Body of Frist Method:
{
    if (mTypeface != null) {
        // Get the fonts from the TypeFace object.
        List<Font> fonts = mTypeface.getFonts();
        // create new font objects as well as FontMetrics, based on the current text size
        // and skew info.
        ArrayList<FontInfo> infoList = new ArrayList<FontInfo>(fonts.size());
        for (Font font : fonts) {
            FontInfo info = new FontInfo();
            info.mFont = font.deriveFont(mTextSize);
            if (mTextScaleX != 1.0 || mTextSkewX != 0) {
                // TODO: support skew
                info.mFont = info.mFont.deriveFont(new AffineTransform(mTextScaleX, mTextSkewX, 0, 1, 0, 0));
            }
            // The metrics here don't have anti-aliasing set.
            info.mMetrics = Toolkit.getDefaultToolkit().getFontMetrics(info.mFont);
            infoList.add(info);
        }
        mFonts = Collections.unmodifiableList(infoList);
    }
}
Body of Second Method:
{
    if (mTypeface != null) {
        // Get the fonts from the TypeFace object.
        List<Font> fonts = mTypeface.getFonts(mFontVariant);
        // create new font objects as well as FontMetrics, based on the current text size
        // and skew info.
        ArrayList<FontInfo> infoList = new ArrayList<FontInfo>(fonts.size());
        for (Font font : fonts) {
            if (font == null) {
                // If the font is null, add null to infoList. When rendering the text, if this
                // null is reached, a warning will be logged.
                infoList.add(null);
                continue;
            }
            FontInfo info = new FontInfo();
            info.mFont = font.deriveFont(mTextSize);
            if (mTextScaleX != 1.0 || mTextSkewX != 0) {
                // TODO: support skew
                info.mFont = info.mFont.deriveFont(new AffineTransform(mTextScaleX, mTextSkewX, 0, 1, 0, 0));
            }
            // The metrics here don't have anti-aliasing set.
            info.mMetrics = Toolkit.getDefaultToolkit().getFontMetrics(info.mFont);
            infoList.add(info);
        }
        mFonts = Collections.unmodifiableList(infoList);
    }
}
------------------------
Find a silently evolved API code:android.net.http.CertificateChainValidator.getInstance:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @return The singleton instance of the certificates chain validator
 */

Body of Frist Method:
{
    return sInstance;
}
Body of Second Method:
{
    return NoPreloadHolder.sInstance;
}
------------------------
Find a silently evolved API code:android.widget.EdgeEffect.draw:COMMENT
Method Modifier: public      
Comment:/**
 * Draw into the provided canvas. Assumes that the canvas has been rotated
 * accordingly and the size has been set. The effect will be drawn the full
 * width of X=0 to X=width, beginning from Y=0 and extending to some factor <
 * 1.f of height.
 *
 * @param canvas Canvas to draw into
 * @return true if drawing should continue beyond this frame to continue the
 * animation
 */

Body of Frist Method:
{
    update();
    mGlow.setAlpha((int) (Math.max(0, Math.min(mGlowAlpha, 1)) * 255));
    int glowBottom = (int) Math.min(mGlowHeight * mGlowScaleY * mGlowHeight / mGlowWidth * 0.6f, mGlowHeight * MAX_GLOW_HEIGHT);
    if (mWidth < mMinWidth) {
        // Center the glow and clip it.
        int glowLeft = (mWidth - mMinWidth) / 2;
        mGlow.setBounds(glowLeft, 0, mWidth - glowLeft, glowBottom);
    } else {
        // Stretch the glow to fit.
        mGlow.setBounds(0, 0, mWidth, glowBottom);
    }
    mGlow.draw(canvas);
    mEdge.setAlpha((int) (Math.max(0, Math.min(mEdgeAlpha, 1)) * 255));
    int edgeBottom = (int) (mEdgeHeight * mEdgeScaleY);
    if (mWidth < mMinWidth) {
        // Center the edge and clip it.
        int edgeLeft = (mWidth - mMinWidth) / 2;
        mEdge.setBounds(edgeLeft, 0, mWidth - edgeLeft, edgeBottom);
    } else {
        // Stretch the edge to fit.
        mEdge.setBounds(0, 0, mWidth, edgeBottom);
    }
    mEdge.draw(canvas);
    if (mState == STATE_RECEDE && glowBottom == 0 && edgeBottom == 0) {
        mState = STATE_IDLE;
    }
    return mState != STATE_IDLE;
}
Body of Second Method:
{
    update();
    final int count = canvas.save();
    final float centerX = mBounds.centerX();
    final float centerY = mBounds.height() - mRadius;
    canvas.scale(1.f, Math.min(mGlowScaleY, 1.f) * mBaseGlowScale, centerX, 0);
    final float displacement = Math.max(0, Math.min(mDisplacement, 1.f)) - 0.5f;
    float translateX = mBounds.width() * displacement / 2;
    canvas.clipRect(mBounds);
    canvas.translate(translateX, 0);
    mPaint.setAlpha((int) (0xff * mGlowAlpha));
    canvas.drawCircle(centerX, centerY, mRadius, mPaint);
    canvas.restoreToCount(count);
    boolean oneLastFrame = false;
    if (mState == STATE_RECEDE && mGlowScaleY == 0) {
        mState = STATE_IDLE;
        oneLastFrame = true;
    }
    return mState != STATE_IDLE || oneLastFrame;
}
------------------------
Find a silently evolved API code:android.graphics.Paint.setShader:COMMENT
Method Modifier: public      
Comment:/**
 * Set or clear the shader object.
 * <p />
 * Pass null to clear any previous shader.
 * As a convenience, the parameter passed is also returned.
 *
 * @param shader May be null. the new shader to be installed in the paint
 * @return       shader
 */

Body of Frist Method:
{
    int shaderNative = 0;
    if (shader != null)
        shaderNative = shader.native_instance;
    native_setShader(mNativePaint, shaderNative);
    mShader = shader;
    return shader;
}
Body of Second Method:
{
    long shaderNative = 0;
    if (shader != null)
        shaderNative = shader.getNativeInstance();
    native_setShader(mNativePaint, shaderNative);
    mShader = shader;
    return shader;
}
------------------------
Find a silently evolved API code:android.widget.CalendarView.getWeekDayTextAppearance:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the text appearance for the week day abbreviation of the calendar header.
 *
 * @return The text appearance resource id.
 *
 * @attr ref android.R.styleable#CalendarView_weekDayTextAppearance
 */

Body of Frist Method:
{
    return mWeekDayTextAppearanceResId;
}
Body of Second Method:
{
    return mDelegate.getWeekDayTextAppearance();
}
------------------------
Find a silently evolved API code:android.os.Binder.execTransact:COMMENT
Method Modifier: private     
Comment:// Entry point from android_util_Binder.cpp's onTransact

Body of Frist Method:
{
    Parcel data = Parcel.obtain(dataObj);
    Parcel reply = Parcel.obtain(replyObj);
    // theoretically, we should call transact, which will call onTransact,
    // but all that does is rewind it, and we just got these from an IPC,
    // so we'll just call it directly.
    boolean res;
    // If the call was FLAG_ONEWAY then these exceptions disappear into the ether.
    try {
        res = onTransact(code, data, reply, flags);
    } catch (RemoteException e) {
        if ((flags & FLAG_ONEWAY) != 0) {
            Log.w(TAG, "Binder call failed.", e);
        }
        reply.setDataPosition(0);
        reply.writeException(e);
        res = true;
    } catch (RuntimeException e) {
        if ((flags & FLAG_ONEWAY) != 0) {
            Log.w(TAG, "Caught a RuntimeException from the binder stub implementation.", e);
        }
        reply.setDataPosition(0);
        reply.writeException(e);
        res = true;
    } catch (OutOfMemoryError e) {
        // Unconditionally log this, since this is generally unrecoverable.
        Log.e(TAG, "Caught an OutOfMemoryError from the binder stub implementation.", e);
        RuntimeException re = new RuntimeException("Out of memory", e);
        reply.setDataPosition(0);
        reply.writeException(re);
        res = true;
    }
    reply.recycle();
    data.recycle();
    return res;
}
Body of Second Method:
{
    Parcel data = Parcel.obtain(dataObj);
    Parcel reply = Parcel.obtain(replyObj);
    // theoretically, we should call transact, which will call onTransact,
    // but all that does is rewind it, and we just got these from an IPC,
    // so we'll just call it directly.
    boolean res;
    // If the call was FLAG_ONEWAY then these exceptions disappear into the ether.
    try {
        res = onTransact(code, data, reply, flags);
    } catch (RemoteException e) {
        if ((flags & FLAG_ONEWAY) != 0) {
            Log.w(TAG, "Binder call failed.", e);
        } else {
            reply.setDataPosition(0);
            reply.writeException(e);
        }
        res = true;
    } catch (RuntimeException e) {
        if ((flags & FLAG_ONEWAY) != 0) {
            Log.w(TAG, "Caught a RuntimeException from the binder stub implementation.", e);
        } else {
            reply.setDataPosition(0);
            reply.writeException(e);
        }
        res = true;
    } catch (OutOfMemoryError e) {
        // Unconditionally log this, since this is generally unrecoverable.
        Log.e(TAG, "Caught an OutOfMemoryError from the binder stub implementation.", e);
        RuntimeException re = new RuntimeException("Out of memory", e);
        reply.setDataPosition(0);
        reply.writeException(re);
        res = true;
    }
    checkParcel(this, code, reply, "Unreasonably large binder reply buffer");
    reply.recycle();
    data.recycle();
    // Just in case -- we are done with the IPC, so there should be no more strict
    // mode violations that have gathered for this thread.  Either they have been
    // parceled and are now in transport off to the caller, or we are returning back
    // to the main transaction loop to wait for another incoming transaction.  Either
    // way, strict mode begone!
    StrictMode.clearGatheredViolations();
    return res;
}
------------------------
Find a silently evolved API code:android.view.accessibility.AccessibilityEvent.getRecord:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the record at a given index.
 *
 * @param index The index.
 * @return The record at the specified index.
 */

Body of Frist Method:
{
    return mRecords.get(index);
}
Body of Second Method:
{
    if (mRecords == null) {
        throw new IndexOutOfBoundsException("Invalid index " + index + ", size is 0");
    }
    return mRecords.get(index);
}
------------------------
Find a silently evolved API code:android.animation.AnimatorSet.playSequentially:COMMENT
Method Modifier: public      
Comment:/**
 * Sets up this AnimatorSet to play each of the supplied animations when the
 * previous animation ends.
 *
 * @param items The animations that will be started one after another.
 */

Body of Frist Method:
{
    if (items != null && items.size() > 0) {
        mNeedsSort = true;
        if (items.size() == 1) {
            play(items.get(0));
        } else {
            for (int i = 0; i < items.size() - 1; ++i) {
                play(items.get(i)).before(items.get(i + 1));
            }
        }
    }
}
Body of Second Method:
{
    if (items != null && items.size() > 0) {
        mNeedsSort = true;
        if (items.size() == 1) {
            play(items.get(0));
        } else {
            mReversible = false;
            for (int i = 0; i < items.size() - 1; ++i) {
                play(items.get(i)).before(items.get(i + 1));
            }
        }
    }
}
------------------------
Find a silently evolved API code:android.net.NetworkTemplate.matchesWifi:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Check if matches Wi-Fi network template.
 */

Body of Frist Method:
{
    switch(ident.mType) {
        case TYPE_WIFI:
            return Objects.equal(removeDoubleQuotes(mNetworkId), removeDoubleQuotes(ident.mNetworkId));
        default:
            return false;
    }
}
Body of Second Method:
{
    switch(ident.mType) {
        case TYPE_WIFI:
            return Objects.equals(removeDoubleQuotes(mNetworkId), removeDoubleQuotes(ident.mNetworkId));
        default:
            return false;
    }
}
------------------------
Find a silently evolved API code:android.view.accessibility.AccessibilityNodeInfo.getChild:COMMENT
Method Modifier: public      
Comment:/**
 * Get the child at given index.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 *
 * @param index The child index.
 * @return The child node.
 *
 * @throws IllegalStateException If called outside of an AccessibilityService.
 */

Body of Frist Method:
{
    enforceSealed();
    if (!canPerformRequestOverConnection(mSourceNodeId)) {
        return null;
    }
    final long childId = mChildNodeIds.get(index);
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mWindowId, childId, false, FLAG_PREFETCH_DESCENDANTS);
}
Body of Second Method:
{
    enforceSealed();
    if (mChildNodeIds == null) {
        return null;
    }
    if (!canPerformRequestOverConnection(mSourceNodeId)) {
        return null;
    }
    final long childId = mChildNodeIds.get(index);
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mWindowId, childId, false, FLAG_PREFETCH_DESCENDANTS);
}
------------------------
Find a silently evolved API code:android.graphics.Matrix.postScale:COMMENT
Method Modifier: public      
Comment:/**
 * Postconcats the matrix with the specified scale.
 * M' = S(sx, sy, px, py) * M
 */

Body of Frist Method:
{
    return native_postScale(native_instance, sx, sy, px, py);
}
Body of Second Method:
{
    native_postScale(native_instance, sx, sy, px, py);
    return true;
}
------------------------
Find a silently evolved API code:android.content.pm.ResolveInfo.getIconResource:COMMENT
Method Modifier: public      final       
Comment:/**
 * Return the icon resource identifier to use for this match.  If the
 * match defines an icon, that is used; else if the activity defines
 * an icon, that is used; else, the application icon is used.
 *
 * @return The icon associated with this match.
 */

Body of Frist Method:
{
    if (icon != 0)
        return icon;
    final ComponentInfo ci = getComponentInfo();
    if (ci != null)
        return ci.getIconResource();
    return 0;
}
Body of Second Method:
{
    if (noResourceId)
        return 0;
    if (icon != 0)
        return icon;
    final ComponentInfo ci = getComponentInfo();
    if (ci != null) {
        return ci.getIconResource();
    }
    return 0;
}
------------------------
Find a silently evolved API code:android.media.AudioService.setStreamMute:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @see AudioManager#setStreamMute(int, boolean)
 */

Body of Frist Method:
{
    if (mUseFixedVolume) {
        return;
    }
    if (isStreamAffectedByMute(streamType)) {
        mStreamStates[streamType].mute(cb, state);
    }
}
Body of Second Method:
{
    if (mUseFixedVolume) {
        return;
    }
    if (isStreamAffectedByMute(streamType)) {
        if (mHdmiManager != null) {
            synchronized (mHdmiManager) {
                if (streamType == AudioSystem.STREAM_MUSIC && mHdmiTvClient != null) {
                    synchronized (mHdmiTvClient) {
                        if (mHdmiSystemAudioSupported) {
                            mHdmiTvClient.setSystemAudioMute(state);
                        }
                    }
                }
            }
        }
        mStreamStates[streamType].mute(cb, state);
    }
}
------------------------
Find a silently evolved API code:android.media.AudioService.makeA2dpDeviceUnavailableNow:COMMENT
Method Modifier: private     hidden      
Comment:// must be called synchronized on mConnectedDevices

Body of Frist Method:
{
    synchronized (mA2dpAvrcpLock) {
        mAvrcpAbsVolSupported = false;
    }
    AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP, AudioSystem.DEVICE_STATE_UNAVAILABLE, address);
    mConnectedDevices.remove(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP);
}
Body of Second Method:
{
    synchronized (mA2dpAvrcpLock) {
        mAvrcpAbsVolSupported = false;
    }
    AudioSystem.setDeviceConnectionState(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP, AudioSystem.DEVICE_STATE_UNAVAILABLE, address);
    mConnectedDevices.remove(AudioSystem.DEVICE_OUT_BLUETOOTH_A2DP);
    synchronized (mCurAudioRoutes) {
        // Remove A2DP routes as well
        if (mCurAudioRoutes.mBluetoothName != null) {
            mCurAudioRoutes.mBluetoothName = null;
            sendMsg(mAudioHandler, MSG_REPORT_NEW_ROUTES, SENDMSG_NOOP, 0, 0, null, 0);
        }
    }
}
------------------------
Find a silently evolved API code:android.widget.CalendarView.getMaxDate:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the maximal date supported by this {@link CalendarView} in milliseconds
 * since January 1, 1970 00:00:00 in {@link TimeZone#getDefault()} time
 * zone.
 * <p>
 * Note: The default maximal date is 01/01/2100.
 * <p>
 *
 * @return The maximal supported date.
 *
 * @attr ref android.R.styleable#CalendarView_maxDate
 */

Body of Frist Method:
{
    return mMaxDate.getTimeInMillis();
}
Body of Second Method:
{
    return mDelegate.getMaxDate();
}
------------------------
Find a silently evolved API code:android.media.MediaFocusControl.onRcDisplayClear:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Called when processing MSG_RCDISPLAY_CLEAR event
 */

Body of Frist Method:
{
    if (DEBUG_RC)
        Log.i(TAG, "Clear remote control display");
    synchronized (mRCStack) {
        synchronized (mCurrentRcLock) {
            mCurrentRcClientGen++;
            // synchronously update the displays and clients with the new client generation
            setNewRcClient_syncRcsCurrc(mCurrentRcClientGen, null, /*newMediaIntent*/
            true);
        }
    }
}
Body of Second Method:
{
    if (DEBUG_RC)
        Log.i(TAG, "Clear remote control display");
    synchronized (mPRStack) {
        synchronized (mCurrentRcLock) {
            mCurrentRcClientGen++;
            // synchronously update the displays and clients with the new client generation
            setNewRcClient_syncRcsCurrc(mCurrentRcClientGen, null, /*newMediaIntent*/
            true);
        }
    }
}
------------------------
Find a silently evolved API code:android.widget.DatePicker.setSpinnersShown:COMMENT
Method Modifier: public      
Comment:/**
 * Sets whether the spinners are shown.
 *
 * @param shown True if the spinners are to be shown.
 */

Body of Frist Method:
{
    mSpinners.setVisibility(shown ? VISIBLE : GONE);
}
Body of Second Method:
{
    mDelegate.setSpinnersShown(shown);
}
------------------------
Find a silently evolved API code:android.content.RestrictionEntry.setAllSelectedStrings:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the current list of selected values for an entry of type {@link #TYPE_MULTI_SELECT}.
 * These values will be persisted by the system for later use by the application.
 * @param allSelectedStrings the current list of selected values.
 */

Body of Frist Method:
{
    currentValues = allSelectedStrings;
}
Body of Second Method:
{
    mCurrentValues = allSelectedStrings;
}
------------------------
Find a silently evolved API code:android.graphics.drawable.Drawable.createFromResourceStream:COMMENT
Method Modifier: public      static      
Comment:/**
 * Create a drawable from an inputstream, using the given resources and
 * value to determine density information.
 */

Body of Frist Method:
{
    if (is == null) {
        return null;
    }
    /*  ugh. The decodeStream contract is that we have already allocated
            the pad rect, but if the bitmap does not had a ninepatch chunk,
            then the pad will be ignored. If we could change this to lazily
            alloc/assign the rect, we could avoid the GC churn of making new
            Rects only to drop them on the floor.
        */
    Rect pad = new Rect();
    // drawn to the screen.
    if (opts == null)
        opts = new BitmapFactory.Options();
    opts.inScreenDensity = res != null ? res.getDisplayMetrics().noncompatDensityDpi : DisplayMetrics.DENSITY_DEVICE;
    Bitmap bm = BitmapFactory.decodeResourceStream(res, value, is, pad, opts);
    if (bm != null) {
        byte[] np = bm.getNinePatchChunk();
        if (np == null || !NinePatch.isNinePatchChunk(np)) {
            np = null;
            pad = null;
        }
        int[] layoutBounds = bm.getLayoutBounds();
        Rect layoutBoundsRect = null;
        if (layoutBounds != null) {
            layoutBoundsRect = new Rect(layoutBounds[0], layoutBounds[1], layoutBounds[2], layoutBounds[3]);
        }
        return drawableFromBitmap(res, bm, np, pad, layoutBoundsRect, srcName);
    }
    return null;
}
Body of Second Method:
{
    Trace.traceBegin(Trace.TRACE_TAG_RESOURCES, srcName != null ? srcName : "Unknown drawable");
    try {
        return createFromResourceStream(res, value, is, srcName, null);
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
    }
}
------------------------
Find a silently evolved API code:android.app.WallpaperManager.getCropAndSetWallpaperIntent:COMMENT
Method Modifier: public      
Comment:/**
 * Gets an Intent that will launch an activity that crops the given
 * image and sets the device's wallpaper. If there is a default HOME activity
 * that supports cropping wallpapers, it will be preferred as the default.
 * Use this method instead of directly creating a {@link #ACTION_CROP_AND_SET_WALLPAPER}
 * intent.
 *
 * @param imageUri The image URI that will be set in the intent. The must be a content
 * URI and its provider must resolve its type to "image/*"
 *
 * @throws IllegalArgumentException if the URI is not a content URI or its MIME type is
 * not "image/*"
 */

Body of Frist Method:
{
    if (!ContentResolver.SCHEME_CONTENT.equals(imageUri.getScheme())) {
        throw new IllegalArgumentException("Image URI must be of the " + ContentResolver.SCHEME_CONTENT + " scheme type");
    }
    final PackageManager packageManager = mContext.getPackageManager();
    Intent cropAndSetWallpaperIntent = new Intent(ACTION_CROP_AND_SET_WALLPAPER, imageUri);
    cropAndSetWallpaperIntent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
    // Find out if the default HOME activity supports CROP_AND_SET_WALLPAPER
    Intent homeIntent = new Intent(Intent.ACTION_MAIN).addCategory(Intent.CATEGORY_HOME);
    ResolveInfo resolvedHome = packageManager.resolveActivity(homeIntent, PackageManager.MATCH_DEFAULT_ONLY);
    if (resolvedHome != null) {
        cropAndSetWallpaperIntent.setPackage(resolvedHome.activityInfo.packageName);
        List<ResolveInfo> cropAppList = packageManager.queryIntentActivities(cropAndSetWallpaperIntent, 0);
        if (cropAppList.size() > 0) {
            return cropAndSetWallpaperIntent;
        }
    }
    // fallback crop activity
    cropAndSetWallpaperIntent.setPackage("com.android.wallpapercropper");
    List<ResolveInfo> cropAppList = packageManager.queryIntentActivities(cropAndSetWallpaperIntent, 0);
    if (cropAppList.size() > 0) {
        return cropAndSetWallpaperIntent;
    }
    // cropper doesn't exist, return null
    throw new IllegalArgumentException("Cannot use passed URI to set wallpaper; " + "check that the type returned by ContentProvider matches image/*");
}
Body of Second Method:
{
    if (imageUri == null) {
        throw new IllegalArgumentException("Image URI must not be null");
    }
    if (!ContentResolver.SCHEME_CONTENT.equals(imageUri.getScheme())) {
        throw new IllegalArgumentException("Image URI must be of the " + ContentResolver.SCHEME_CONTENT + " scheme type");
    }
    final PackageManager packageManager = mContext.getPackageManager();
    Intent cropAndSetWallpaperIntent = new Intent(ACTION_CROP_AND_SET_WALLPAPER, imageUri);
    cropAndSetWallpaperIntent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
    // Find out if the default HOME activity supports CROP_AND_SET_WALLPAPER
    Intent homeIntent = new Intent(Intent.ACTION_MAIN).addCategory(Intent.CATEGORY_HOME);
    ResolveInfo resolvedHome = packageManager.resolveActivity(homeIntent, PackageManager.MATCH_DEFAULT_ONLY);
    if (resolvedHome != null) {
        cropAndSetWallpaperIntent.setPackage(resolvedHome.activityInfo.packageName);
        List<ResolveInfo> cropAppList = packageManager.queryIntentActivities(cropAndSetWallpaperIntent, 0);
        if (cropAppList.size() > 0) {
            return cropAndSetWallpaperIntent;
        }
    }
    // fallback crop activity
    cropAndSetWallpaperIntent.setPackage("com.android.wallpapercropper");
    List<ResolveInfo> cropAppList = packageManager.queryIntentActivities(cropAndSetWallpaperIntent, 0);
    if (cropAppList.size() > 0) {
        return cropAndSetWallpaperIntent;
    }
    // cropper doesn't exist, return null
    throw new IllegalArgumentException("Cannot use passed URI to set wallpaper; " + "check that the type returned by ContentProvider matches image/*");
}
------------------------
Find a silently evolved API code:android.view.ViewGroup.resetTouchState:COMMENT
Method Modifier: private     
Comment:/**
 * Resets all touch state in preparation for a new cycle.
 */

Body of Frist Method:
{
    clearTouchTargets();
    resetCancelNextUpFlag(this);
    mGroupFlags &= ~FLAG_DISALLOW_INTERCEPT;
}
Body of Second Method:
{
    clearTouchTargets();
    resetCancelNextUpFlag(this);
    mGroupFlags &= ~FLAG_DISALLOW_INTERCEPT;
    mNestedScrollAxes = SCROLL_AXIS_NONE;
}
------------------------
Find a silently evolved API code:android.net.NetworkTemplate.matchesMobile:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Check if mobile network with matching IMSI.
 */

Body of Frist Method:
{
    if (ident.mType == TYPE_WIMAX) {
        // TODO: consider matching against WiMAX subscriber identity
        return true;
    } else {
        return ((sForceAllNetworkTypes || contains(DATA_USAGE_NETWORK_TYPES, ident.mType)) && Objects.equal(mSubscriberId, ident.mSubscriberId));
    }
}
Body of Second Method:
{
    if (ident.mType == TYPE_WIMAX) {
        // TODO: consider matching against WiMAX subscriber identity
        return true;
    } else {
        return ((sForceAllNetworkTypes || contains(DATA_USAGE_NETWORK_TYPES, ident.mType)) && Objects.equals(mSubscriberId, ident.mSubscriberId));
    }
}
------------------------
Find a silently evolved API code:android.os.Bundle.getCharSequenceArray:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return a CharSequence[] value, or null
 */

Body of Frist Method:
{
    unparcel();
    Object o = mMap.get(key);
    if (o == null) {
        return null;
    }
    try {
        return (CharSequence[]) o;
    } catch (ClassCastException e) {
        typeWarning(key, o, "CharSequence[]", e);
        return null;
    }
}
Body of Second Method:
{
    return super.getCharSequenceArray(key);
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiEnterpriseConfig.setEapMethod:COMMENT
Method Modifier: public      
Comment:/**
 * Set the EAP authentication method.
 * @param  eapMethod is one {@link Eap#PEAP}, {@link Eap#TLS}, {@link Eap#TTLS} or
 * {@link Eap#PWD}
 * @throws IllegalArgumentException on an invalid eap method
 */

Body of Frist Method:
{
    switch(eapMethod) {
        /**
         * Valid methods
         */
        case Eap.PEAP:
        case Eap.PWD:
        case Eap.TLS:
        case Eap.TTLS:
            mFields.put(EAP_KEY, Eap.strings[eapMethod]);
            mFields.put(OPP_KEY_CACHING, "1");
            break;
        default:
            throw new IllegalArgumentException("Unknown EAP method");
    }
}
Body of Second Method:
{
    switch(eapMethod) {
        /**
         * Valid methods
         */
        case Eap.TLS:
            setPhase2Method(Phase2.NONE);
        /* fall through */
        case Eap.PEAP:
        case Eap.PWD:
        case Eap.TTLS:
        case Eap.SIM:
        case Eap.AKA:
            mFields.put(EAP_KEY, Eap.strings[eapMethod]);
            mFields.put(OPP_KEY_CACHING, "1");
            break;
        default:
            throw new IllegalArgumentException("Unknown EAP method");
    }
}
------------------------
Find a silently evolved API code:android.view.ViewGroup.removeAllViewsInLayout:COMMENT
Method Modifier: public      
Comment:/**
 * Called by a ViewGroup subclass to remove child views from itself,
 * when it must first know its size on screen before it can calculate how many
 * child views it will render. An example is a Gallery or a ListView, which
 * may "have" 50 children, but actually only render the number of children
 * that can currently fit inside the object on screen. Do not call
 * this method unless you are extending ViewGroup and understand the
 * view measuring and layout pipeline.
 *
 * <p><strong>Note:</strong> do not invoke this method from
 * {@link #draw(android.graphics.Canvas)}, {@link #onDraw(android.graphics.Canvas)},
 * {@link #dispatchDraw(android.graphics.Canvas)} or any related method.</p>
 */

Body of Frist Method:
{
    final int count = mChildrenCount;
    if (count <= 0) {
        return;
    }
    final View[] children = mChildren;
    mChildrenCount = 0;
    final View focused = mFocused;
    final boolean detach = mAttachInfo != null;
    boolean clearChildFocus = false;
    needGlobalAttributesUpdate(false);
    for (int i = count - 1; i >= 0; i--) {
        final View view = children[i];
        if (mTransition != null) {
            mTransition.removeChild(this, view);
        }
        if (view == focused) {
            view.unFocus();
            clearChildFocus = true;
        }
        if (view.isAccessibilityFocused()) {
            view.clearAccessibilityFocus();
        }
        cancelTouchTarget(view);
        cancelHoverTarget(view);
        if (view.getAnimation() != null || (mTransitioningViews != null && mTransitioningViews.contains(view))) {
            addDisappearingView(view);
        } else if (detach) {
            view.dispatchDetachedFromWindow();
        }
        if (view.hasTransientState()) {
            childHasTransientStateChanged(view, false);
        }
        onViewRemoved(view);
        view.mParent = null;
        children[i] = null;
    }
    if (clearChildFocus) {
        clearChildFocus(focused);
        if (!rootViewRequestFocus()) {
            notifyGlobalFocusCleared(focused);
        }
    }
}
Body of Second Method:
{
    final int count = mChildrenCount;
    if (count <= 0) {
        return;
    }
    final View[] children = mChildren;
    mChildrenCount = 0;
    final View focused = mFocused;
    final boolean detach = mAttachInfo != null;
    boolean clearChildFocus = false;
    needGlobalAttributesUpdate(false);
    for (int i = count - 1; i >= 0; i--) {
        final View view = children[i];
        if (mTransition != null) {
            mTransition.removeChild(this, view);
        }
        if (view == focused) {
            view.unFocus(null);
            clearChildFocus = true;
        }
        if (view.isAccessibilityFocused()) {
            view.clearAccessibilityFocus();
        }
        cancelTouchTarget(view);
        cancelHoverTarget(view);
        if (view.getAnimation() != null || (mTransitioningViews != null && mTransitioningViews.contains(view))) {
            addDisappearingView(view);
        } else if (detach) {
            view.dispatchDetachedFromWindow();
        }
        if (view.hasTransientState()) {
            childHasTransientStateChanged(view, false);
        }
        onViewRemoved(view);
        view.mParent = null;
        children[i] = null;
    }
    if (clearChildFocus) {
        clearChildFocus(focused);
        if (!rootViewRequestFocus()) {
            notifyGlobalFocusCleared(focused);
        }
    }
}
------------------------
Find a silently evolved API code:android.net.nsd.NsdServiceInfo.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Implement the Parcelable interface
 */

Body of Frist Method:
{
    dest.writeString(mServiceName);
    dest.writeString(mServiceType);
    dest.writeParcelable(mTxtRecord, flags);
    if (mHost != null) {
        dest.writeByte((byte) 1);
        dest.writeByteArray(mHost.getAddress());
    } else {
        dest.writeByte((byte) 0);
    }
    dest.writeInt(mPort);
}
Body of Second Method:
{
    dest.writeString(mServiceName);
    dest.writeString(mServiceType);
    if (mHost != null) {
        dest.writeInt(1);
        dest.writeByteArray(mHost.getAddress());
    } else {
        dest.writeInt(0);
    }
    dest.writeInt(mPort);
    // TXT record key/value pairs.
    dest.writeInt(mTxtRecord.size());
    for (String key : mTxtRecord.keySet()) {
        byte[] value = mTxtRecord.get(key);
        if (value != null) {
            dest.writeInt(1);
            dest.writeInt(value.length);
            dest.writeByteArray(value);
        } else {
            dest.writeInt(0);
        }
        dest.writeString(key);
    }
}
------------------------
Find a silently evolved API code:android.appwidget.AppWidgetProvider.onReceive:COMMENT
Method Modifier: public      
Comment:// BEGIN_INCLUDE(onReceive)

Body of Frist Method:
{
    // Protect against rogue update broadcasts (not really a security issue,
    // just filter bad broacasts out so subclasses are less likely to crash).
    String action = intent.getAction();
    if (AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)) {
        Bundle extras = intent.getExtras();
        if (extras != null) {
            int[] appWidgetIds = extras.getIntArray(AppWidgetManager.EXTRA_APPWIDGET_IDS);
            if (appWidgetIds != null && appWidgetIds.length > 0) {
                this.onUpdate(context, AppWidgetManager.getInstance(context), appWidgetIds);
            }
        }
    } else if (AppWidgetManager.ACTION_APPWIDGET_DELETED.equals(action)) {
        Bundle extras = intent.getExtras();
        if (extras != null && extras.containsKey(AppWidgetManager.EXTRA_APPWIDGET_ID)) {
            final int appWidgetId = extras.getInt(AppWidgetManager.EXTRA_APPWIDGET_ID);
            this.onDeleted(context, new int[] { appWidgetId });
        }
    } else if (AppWidgetManager.ACTION_APPWIDGET_OPTIONS_CHANGED.equals(action)) {
        Bundle extras = intent.getExtras();
        if (extras != null && extras.containsKey(AppWidgetManager.EXTRA_APPWIDGET_ID) && extras.containsKey(AppWidgetManager.EXTRA_APPWIDGET_OPTIONS)) {
            int appWidgetId = extras.getInt(AppWidgetManager.EXTRA_APPWIDGET_ID);
            Bundle widgetExtras = extras.getBundle(AppWidgetManager.EXTRA_APPWIDGET_OPTIONS);
            this.onAppWidgetOptionsChanged(context, AppWidgetManager.getInstance(context), appWidgetId, widgetExtras);
        }
    } else if (AppWidgetManager.ACTION_APPWIDGET_ENABLED.equals(action)) {
        this.onEnabled(context);
    } else if (AppWidgetManager.ACTION_APPWIDGET_DISABLED.equals(action)) {
        this.onDisabled(context);
    }
}
Body of Second Method:
{
    // Protect against rogue update broadcasts (not really a security issue,
    // just filter bad broacasts out so subclasses are less likely to crash).
    String action = intent.getAction();
    if (AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)) {
        Bundle extras = intent.getExtras();
        if (extras != null) {
            int[] appWidgetIds = extras.getIntArray(AppWidgetManager.EXTRA_APPWIDGET_IDS);
            if (appWidgetIds != null && appWidgetIds.length > 0) {
                this.onUpdate(context, AppWidgetManager.getInstance(context), appWidgetIds);
            }
        }
    } else if (AppWidgetManager.ACTION_APPWIDGET_DELETED.equals(action)) {
        Bundle extras = intent.getExtras();
        if (extras != null && extras.containsKey(AppWidgetManager.EXTRA_APPWIDGET_ID)) {
            final int appWidgetId = extras.getInt(AppWidgetManager.EXTRA_APPWIDGET_ID);
            this.onDeleted(context, new int[] { appWidgetId });
        }
    } else if (AppWidgetManager.ACTION_APPWIDGET_OPTIONS_CHANGED.equals(action)) {
        Bundle extras = intent.getExtras();
        if (extras != null && extras.containsKey(AppWidgetManager.EXTRA_APPWIDGET_ID) && extras.containsKey(AppWidgetManager.EXTRA_APPWIDGET_OPTIONS)) {
            int appWidgetId = extras.getInt(AppWidgetManager.EXTRA_APPWIDGET_ID);
            Bundle widgetExtras = extras.getBundle(AppWidgetManager.EXTRA_APPWIDGET_OPTIONS);
            this.onAppWidgetOptionsChanged(context, AppWidgetManager.getInstance(context), appWidgetId, widgetExtras);
        }
    } else if (AppWidgetManager.ACTION_APPWIDGET_ENABLED.equals(action)) {
        this.onEnabled(context);
    } else if (AppWidgetManager.ACTION_APPWIDGET_DISABLED.equals(action)) {
        this.onDisabled(context);
    } else if (AppWidgetManager.ACTION_APPWIDGET_RESTORED.equals(action)) {
        Bundle extras = intent.getExtras();
        if (extras != null) {
            int[] oldIds = extras.getIntArray(AppWidgetManager.EXTRA_APPWIDGET_OLD_IDS);
            int[] newIds = extras.getIntArray(AppWidgetManager.EXTRA_APPWIDGET_IDS);
            if (oldIds != null && oldIds.length > 0) {
                this.onRestored(context, oldIds, newIds);
                this.onUpdate(context, AppWidgetManager.getInstance(context), newIds);
            }
        }
    }
}
------------------------
Find a silently evolved API code:android.content.res.BridgeTypedArray.getDimensionPixelSize:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve a dimensional unit attribute at <var>index</var> for use
 * as a size in raw pixels.  This is the same as
 * {@link #getDimension}, except the returned value is converted to
 * integer pixels for use as a size.  A size conversion involves
 * rounding the base value, and ensuring that a non-zero base value
 * is at least one pixel in size.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute dimension value multiplied by the appropriate
 * metric and truncated to integer pixels, or defValue if not defined.
 *
 * @see #getDimension
 * @see #getDimensionPixelOffset
 */

Body of Frist Method:
{
    try {
        return getDimension(index);
    } catch (RuntimeException e) {
        if (mResourceData[index] != null) {
            String s = mResourceData[index].getValue();
            if (s != null) {
                // looks like we were unable to resolve the dimension value
                Bridge.getLog().warning(LayoutLog.TAG_RESOURCES_FORMAT, String.format("\"%1$s\" in attribute \"%2$s\" is not a valid format.", s, mNames[index]), null);
            }
        }
        return defValue;
    }
}
Body of Second Method:
{
    try {
        return getDimension(index);
    } catch (RuntimeException e) {
        String s = getString(index);
        if (s != null) {
            // looks like we were unable to resolve the dimension value
            Bridge.getLog().warning(LayoutLog.TAG_RESOURCES_FORMAT, String.format("\"%1$s\" in attribute \"%2$s\" is not a valid format.", s, mNames[index]), null);
        }
        return defValue;
    }
}
------------------------
Find a silently evolved API code:android.view.LayoutInflater.setFactory2:COMMENT
Method Modifier: public      
Comment:/**
 * Like {@link #setFactory}, but allows you to set a {@link Factory2}
 * interface.
 */

Body of Frist Method:
{
    if (mFactorySet) {
        throw new IllegalStateException("A factory has already been set on this LayoutInflater");
    }
    if (factory == null) {
        throw new NullPointerException("Given factory can not be null");
    }
    mFactorySet = true;
    if (mFactory == null) {
        mFactory = mFactory2 = factory;
    } else {
        mFactory = new FactoryMerger(factory, factory, mFactory, mFactory2);
    }
}
Body of Second Method:
{
    if (mFactorySet) {
        throw new IllegalStateException("A factory has already been set on this LayoutInflater");
    }
    if (factory == null) {
        throw new NullPointerException("Given factory can not be null");
    }
    mFactorySet = true;
    if (mFactory == null) {
        mFactory = mFactory2 = factory;
    } else {
        mFactory = mFactory2 = new FactoryMerger(factory, factory, mFactory, mFactory2);
    }
}
------------------------
Find a silently evolved API code:android.graphics.Canvas.drawArc:COMMENT
Method Modifier: public      
Comment:/**
 * <p>Draw the specified arc, which will be scaled to fit inside the
 * specified oval.</p>
 *
 * <p>If the start angle is negative or >= 360, the start angle is treated
 * as start angle modulo 360.</p>
 *
 * <p>If the sweep angle is >= 360, then the oval is drawn
 * completely. Note that this differs slightly from SkPath::arcTo, which
 * treats the sweep angle modulo 360. If the sweep angle is negative,
 * the sweep angle is treated as sweep angle modulo 360</p>
 *
 * <p>The arc is drawn clockwise. An angle of 0 degrees correspond to the
 * geometric angle of 0 degrees (3 o'clock on a watch.)</p>
 *
 * @param oval       The bounds of oval used to define the shape and size
 * of the arc
 * @param startAngle Starting angle (in degrees) where the arc begins
 * @param sweepAngle Sweep angle (in degrees) measured clockwise
 * @param useCenter If true, include the center of the oval in the arc, and
 * close it if it is being stroked. This will draw a wedge
 * @param paint      The paint used to draw the arc
 */

Body of Frist Method:
{
    if (oval == null) {
        throw new NullPointerException();
    }
    native_drawArc(mNativeCanvas, oval, startAngle, sweepAngle, useCenter, paint.mNativePaint);
}
Body of Second Method:
{
    drawArc(oval.left, oval.top, oval.right, oval.bottom, startAngle, sweepAngle, useCenter, paint);
}
------------------------
Find a silently evolved API code:android.media.MediaFocusControl.dumpRCDList:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Helper function:
 * Display in the log the current entries in the list of remote control displays
 */

Body of Frist Method:
{
    pw.println("\nRemote Control Display list entries:");
    synchronized (mRCStack) {
        final Iterator<DisplayInfoForServer> displayIterator = mRcDisplays.iterator();
        while (displayIterator.hasNext()) {
            final DisplayInfoForServer di = (DisplayInfoForServer) displayIterator.next();
            pw.println("  IRCD: " + di.mRcDisplay + "  -- w:" + di.mArtworkExpectedWidth + "  -- h:" + di.mArtworkExpectedHeight + "  -- wantsPosSync:" + di.mWantsPositionSync + "  -- " + (di.mEnabled ? "enabled" : "disabled"));
        }
    }
}
Body of Second Method:
{
    pw.println("\nRemote Control Display list entries:");
    synchronized (mPRStack) {
        final Iterator<DisplayInfoForServer> displayIterator = mRcDisplays.iterator();
        while (displayIterator.hasNext()) {
            final DisplayInfoForServer di = displayIterator.next();
            pw.println("  IRCD: " + di.mRcDisplay + "  -- w:" + di.mArtworkExpectedWidth + "  -- h:" + di.mArtworkExpectedHeight + "  -- wantsPosSync:" + di.mWantsPositionSync + "  -- " + (di.mEnabled ? "enabled" : "disabled"));
        }
    }
}
------------------------
Find a silently evolved API code:android.os.Bundle.putFloatArray:COMMENT
Method Modifier: public      
Comment:/**
 * Inserts a float array value into the mapping of this Bundle, replacing
 * any existing value for the given key.  Either key or value may be null.
 *
 * @param key a String, or null
 * @param value a float array object, or null
 */

Body of Frist Method:
{
    unparcel();
    mMap.put(key, value);
}
Body of Second Method:
{
    super.putFloatArray(key, value);
}
------------------------
Find a silently evolved API code:android.media.AudioRecord.audioParamCheck:COMMENT
Method Modifier: private     
Comment:// mSampleRate is valid

Body of Frist Method:
{
    // audio source
    if ((audioSource < MediaRecorder.AudioSource.DEFAULT) || ((audioSource > MediaRecorder.getAudioSourceMax()) && (audioSource != MediaRecorder.AudioSource.HOTWORD))) {
        throw new IllegalArgumentException("Invalid audio source.");
    }
    mRecordSource = audioSource;
    // sample rate
    if ((sampleRateInHz < 4000) || (sampleRateInHz > 48000)) {
        throw new IllegalArgumentException(sampleRateInHz + "Hz is not a supported sample rate.");
    }
    mSampleRate = sampleRateInHz;
    // channel config
    switch(channelConfig) {
        // AudioFormat.CHANNEL_CONFIGURATION_DEFAULT
        case AudioFormat.CHANNEL_IN_DEFAULT:
        case AudioFormat.CHANNEL_IN_MONO:
        case AudioFormat.CHANNEL_CONFIGURATION_MONO:
            mChannelCount = 1;
            mChannelMask = AudioFormat.CHANNEL_IN_MONO;
            break;
        case AudioFormat.CHANNEL_IN_STEREO:
        case AudioFormat.CHANNEL_CONFIGURATION_STEREO:
            mChannelCount = 2;
            mChannelMask = AudioFormat.CHANNEL_IN_STEREO;
            break;
        case (AudioFormat.CHANNEL_IN_FRONT | AudioFormat.CHANNEL_IN_BACK):
            mChannelCount = 2;
            mChannelMask = channelConfig;
            break;
        default:
            throw new IllegalArgumentException("Unsupported channel configuration.");
    }
    // audio format
    switch(audioFormat) {
        case AudioFormat.ENCODING_DEFAULT:
            mAudioFormat = AudioFormat.ENCODING_PCM_16BIT;
            break;
        case AudioFormat.ENCODING_PCM_16BIT:
        case AudioFormat.ENCODING_PCM_8BIT:
            mAudioFormat = audioFormat;
            break;
        default:
            throw new IllegalArgumentException("Unsupported sample encoding." + " Should be ENCODING_PCM_8BIT or ENCODING_PCM_16BIT.");
    }
}
Body of Second Method:
{
    // audio source
    if ((audioSource < MediaRecorder.AudioSource.DEFAULT) || ((audioSource > MediaRecorder.getAudioSourceMax()) && (audioSource != MediaRecorder.AudioSource.HOTWORD))) {
        throw new IllegalArgumentException("Invalid audio source.");
    }
    mRecordSource = audioSource;
    // sample rate
    if ((sampleRateInHz < 4000) || (sampleRateInHz > 48000)) {
        throw new IllegalArgumentException(sampleRateInHz + "Hz is not a supported sample rate.");
    }
    mSampleRate = sampleRateInHz;
    // audio format
    switch(audioFormat) {
        case AudioFormat.ENCODING_DEFAULT:
            mAudioFormat = AudioFormat.ENCODING_PCM_16BIT;
            break;
        case AudioFormat.ENCODING_PCM_16BIT:
        case AudioFormat.ENCODING_PCM_8BIT:
            mAudioFormat = audioFormat;
            break;
        default:
            throw new IllegalArgumentException("Unsupported sample encoding." + " Should be ENCODING_PCM_8BIT or ENCODING_PCM_16BIT.");
    }
}
------------------------
Find a silently evolved API code:android.app.Activity.finish:COMMENT
Method Modifier: public      
Comment:/**
 * Call this when your activity is done and should be closed.  The
 * ActivityResult is propagated back to whoever launched you via
 * onActivityResult().
 */

Body of Frist Method:
{
    if (mParent == null) {
        int resultCode;
        Intent resultData;
        synchronized (this) {
            resultCode = mResultCode;
            resultData = mResultData;
        }
        if (false)
            Log.v(TAG, "Finishing self: token=" + mToken);
        try {
            if (resultData != null) {
                resultData.prepareToLeaveProcess();
            }
            if (ActivityManagerNative.getDefault().finishActivity(mToken, resultCode, resultData)) {
                mFinished = true;
            }
        } catch (RemoteException e) {
        // Empty
        }
    } else {
        mParent.finishFromChild(this);
    }
}
Body of Second Method:
{
    finish(false);
}
------------------------
Find a silently evolved API code:android.content.res.ColorStateList.inflate:COMMENT
Method Modifier: private     
Comment:/**
 * Fill in this object based on the contents of an XML "selector" element.
 */

Body of Frist Method:
{
    int type;
    final int innerDepth = parser.getDepth() + 1;
    int depth;
    int listAllocated = 20;
    int listSize = 0;
    int[] colorList = new int[listAllocated];
    int[][] stateSpecList = new int[listAllocated][];
    while ((type = parser.next()) != XmlPullParser.END_DOCUMENT && ((depth = parser.getDepth()) >= innerDepth || type != XmlPullParser.END_TAG)) {
        if (type != XmlPullParser.START_TAG) {
            continue;
        }
        if (depth > innerDepth || !parser.getName().equals("item")) {
            continue;
        }
        int colorRes = 0;
        int color = 0xffff0000;
        boolean haveColor = false;
        int i;
        int j = 0;
        final int numAttrs = attrs.getAttributeCount();
        int[] stateSpec = new int[numAttrs];
        for (i = 0; i < numAttrs; i++) {
            final int stateResId = attrs.getAttributeNameResource(i);
            if (stateResId == 0)
                break;
            if (stateResId == com.android.internal.R.attr.color) {
                colorRes = attrs.getAttributeResourceValue(i, 0);
                if (colorRes == 0) {
                    color = attrs.getAttributeIntValue(i, color);
                    haveColor = true;
                }
            } else {
                stateSpec[j++] = attrs.getAttributeBooleanValue(i, false) ? stateResId : -stateResId;
            }
        }
        stateSpec = StateSet.trimStateSet(stateSpec, j);
        if (colorRes != 0) {
            color = r.getColor(colorRes);
        } else if (!haveColor) {
            throw new XmlPullParserException(parser.getPositionDescription() + ": <item> tag requires a 'android:color' attribute.");
        }
        if (listSize == 0 || stateSpec.length == 0) {
            mDefaultColor = color;
        }
        if (listSize + 1 >= listAllocated) {
            listAllocated = ArrayUtils.idealIntArraySize(listSize + 1);
            int[] ncolor = new int[listAllocated];
            System.arraycopy(colorList, 0, ncolor, 0, listSize);
            int[][] nstate = new int[listAllocated][];
            System.arraycopy(stateSpecList, 0, nstate, 0, listSize);
            colorList = ncolor;
            stateSpecList = nstate;
        }
        colorList[listSize] = color;
        stateSpecList[listSize] = stateSpec;
        listSize++;
    }
    mColors = new int[listSize];
    mStateSpecs = new int[listSize][];
    System.arraycopy(colorList, 0, mColors, 0, listSize);
    System.arraycopy(stateSpecList, 0, mStateSpecs, 0, listSize);
}
Body of Second Method:
{
    int type;
    final int innerDepth = parser.getDepth() + 1;
    int depth;
    int[][] stateSpecList = ArrayUtils.newUnpaddedArray(int[].class, 20);
    int[] colorList = new int[stateSpecList.length];
    int listSize = 0;
    while ((type = parser.next()) != XmlPullParser.END_DOCUMENT && ((depth = parser.getDepth()) >= innerDepth || type != XmlPullParser.END_TAG)) {
        if (type != XmlPullParser.START_TAG) {
            continue;
        }
        if (depth > innerDepth || !parser.getName().equals("item")) {
            continue;
        }
        int alphaRes = 0;
        float alpha = 1.0f;
        int colorRes = 0;
        int color = 0xffff0000;
        boolean haveColor = false;
        int i;
        int j = 0;
        final int numAttrs = attrs.getAttributeCount();
        int[] stateSpec = new int[numAttrs];
        for (i = 0; i < numAttrs; i++) {
            final int stateResId = attrs.getAttributeNameResource(i);
            if (stateResId == 0)
                break;
            if (stateResId == com.android.internal.R.attr.alpha) {
                alphaRes = attrs.getAttributeResourceValue(i, 0);
                if (alphaRes == 0) {
                    alpha = attrs.getAttributeFloatValue(i, 1.0f);
                }
            } else if (stateResId == com.android.internal.R.attr.color) {
                colorRes = attrs.getAttributeResourceValue(i, 0);
                if (colorRes == 0) {
                    color = attrs.getAttributeIntValue(i, color);
                    haveColor = true;
                }
            } else {
                stateSpec[j++] = attrs.getAttributeBooleanValue(i, false) ? stateResId : -stateResId;
            }
        }
        stateSpec = StateSet.trimStateSet(stateSpec, j);
        if (colorRes != 0) {
            color = r.getColor(colorRes);
        } else if (!haveColor) {
            throw new XmlPullParserException(parser.getPositionDescription() + ": <item> tag requires a 'android:color' attribute.");
        }
        if (alphaRes != 0) {
            alpha = r.getFloat(alphaRes);
        }
        // Apply alpha modulation.
        final int alphaMod = MathUtils.constrain((int) (Color.alpha(color) * alpha), 0, 255);
        color = (color & 0xFFFFFF) | (alphaMod << 24);
        if (listSize == 0 || stateSpec.length == 0) {
            mDefaultColor = color;
        }
        colorList = GrowingArrayUtils.append(colorList, listSize, color);
        stateSpecList = GrowingArrayUtils.append(stateSpecList, listSize, stateSpec);
        listSize++;
    }
    mColors = new int[listSize];
    mStateSpecs = new int[listSize][];
    System.arraycopy(colorList, 0, mColors, 0, listSize);
    System.arraycopy(stateSpecList, 0, mStateSpecs, 0, listSize);
}
------------------------
Find a silently evolved API code:android.service.dreams.DreamService.dispatchTrackballEvent:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (!mInteractive) {
        if (mDebug)
            Slog.v(TAG, "Finishing on trackballEvent");
        safelyFinish();
        return true;
    }
    return mWindow.superDispatchTrackballEvent(event);
}
Body of Second Method:
{
    if (!mInteractive) {
        if (mDebug)
            Slog.v(TAG, "Waking up on trackballEvent");
        wakeUp();
        return true;
    }
    return mWindow.superDispatchTrackballEvent(event);
}
------------------------
Find a silently evolved API code:android.app.Notification.Builder.buildUnstyled:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Apply the unstyled operations and return a new {@link Notification} object.
 * @hide
 */

Body of Frist Method:
{
    Notification n = new Notification();
    n.when = mWhen;
    n.icon = mSmallIcon;
    n.iconLevel = mSmallIconLevel;
    n.number = mNumber;
    n.contentView = makeContentView();
    n.contentIntent = mContentIntent;
    n.deleteIntent = mDeleteIntent;
    n.fullScreenIntent = mFullScreenIntent;
    n.tickerText = mTickerText;
    n.tickerView = makeTickerView();
    n.largeIcon = mLargeIcon;
    n.sound = mSound;
    n.audioStreamType = mAudioStreamType;
    n.vibrate = mVibrate;
    n.ledARGB = mLedArgb;
    n.ledOnMS = mLedOnMs;
    n.ledOffMS = mLedOffMs;
    n.defaults = mDefaults;
    n.flags = mFlags;
    n.bigContentView = makeBigContentView();
    if (mLedOnMs != 0 || mLedOffMs != 0) {
        n.flags |= FLAG_SHOW_LIGHTS;
    }
    if ((mDefaults & DEFAULT_LIGHTS) != 0) {
        n.flags |= FLAG_SHOW_LIGHTS;
    }
    if (mKindList.size() > 0) {
        n.kind = new String[mKindList.size()];
        mKindList.toArray(n.kind);
    } else {
        n.kind = null;
    }
    n.priority = mPriority;
    if (mActions.size() > 0) {
        n.actions = new Action[mActions.size()];
        mActions.toArray(n.actions);
    }
    return n;
}
Body of Second Method:
{
    Notification n = new Notification();
    n.when = mWhen;
    n.icon = mSmallIcon;
    n.iconLevel = mSmallIconLevel;
    n.number = mNumber;
    n.color = sanitizeColor();
    setBuilderContentView(n, makeContentView());
    n.contentIntent = mContentIntent;
    n.deleteIntent = mDeleteIntent;
    n.fullScreenIntent = mFullScreenIntent;
    n.tickerText = mTickerText;
    n.tickerView = makeTickerView();
    n.largeIcon = mLargeIcon;
    n.sound = mSound;
    n.audioStreamType = mAudioStreamType;
    n.audioAttributes = mAudioAttributes;
    n.vibrate = mVibrate;
    n.ledARGB = mLedArgb;
    n.ledOnMS = mLedOnMs;
    n.ledOffMS = mLedOffMs;
    n.defaults = mDefaults;
    n.flags = mFlags;
    setBuilderBigContentView(n, makeBigContentView());
    setBuilderHeadsUpContentView(n, makeHeadsUpContentView());
    if (mLedOnMs != 0 || mLedOffMs != 0) {
        n.flags |= FLAG_SHOW_LIGHTS;
    }
    if ((mDefaults & DEFAULT_LIGHTS) != 0) {
        n.flags |= FLAG_SHOW_LIGHTS;
    }
    n.category = mCategory;
    n.mGroupKey = mGroupKey;
    n.mSortKey = mSortKey;
    n.priority = mPriority;
    if (mActions.size() > 0) {
        n.actions = new Action[mActions.size()];
        mActions.toArray(n.actions);
    }
    n.visibility = mVisibility;
    if (mPublicVersion != null) {
        n.publicVersion = new Notification();
        mPublicVersion.cloneInto(n.publicVersion, true);
    }
    // Note: If you're adding new fields, also update restoreFromNotitification().
    return n;
}
------------------------
Find a silently evolved API code:android.view.HardwareLayer.setTransform:COMMENT
<android.view.HardwareLayer: void setTransform(Matrix)>
default     abstract    ->public      hidden      
Method Modifier: public      default     abstract    hidden      
Method Modifier: No          Yes         Yes         No          
Method Updated:  Yes         No          No          Yes         
Comment:/**
 * Sets an optional transform on this layer.
 *
 * @param matrix The transform to apply to the layer.
 */

Body of Frist Method:

Body of Second Method:
{
    nSetTransform(mFinalizer.get(), matrix.native_instance);
    mRenderer.pushLayerUpdate(this);
}
------------------------
Find a silently evolved API code:android.graphics.Bitmap.getPixels:COMMENT
Method Modifier: public      
Comment:/**
 * Returns in pixels[] a copy of the data in the bitmap. Each value is
 * a packed int representing a {@link Color}. The stride parameter allows
 * the caller to allow for gaps in the returned pixels array between
 * rows. For normal packed results, just pass width for the stride value.
 * The returned colors are non-premultiplied ARGB values.
 *
 * @param pixels   The array to receive the bitmap's colors
 * @param offset   The first index to write into pixels[]
 * @param stride   The number of entries in pixels[] to skip between
 * rows (must be >= bitmap's width). Can be negative.
 * @param x        The x coordinate of the first pixel to read from
 * the bitmap
 * @param y        The y coordinate of the first pixel to read from
 * the bitmap
 * @param width    The number of pixels to read from each row
 * @param height   The number of rows to read
 *
 * @throws IllegalArgumentException if x, y, width, height exceed the
 * bounds of the bitmap, or if abs(stride) < width.
 * @throws ArrayIndexOutOfBoundsException if the pixels array is too small
 * to receive the specified number of pixels.
 */

Body of Frist Method:
{
    checkRecycled("Can't call getPixels() on a recycled bitmap");
    if (width == 0 || height == 0) {
        // nothing to do
        return;
    }
    checkPixelsAccess(x, y, width, height, offset, stride, pixels);
    nativeGetPixels(mNativeBitmap, pixels, offset, stride, x, y, width, height, mIsPremultiplied);
}
Body of Second Method:
{
    checkRecycled("Can't call getPixels() on a recycled bitmap");
    if (width == 0 || height == 0) {
        // nothing to do
        return;
    }
    checkPixelsAccess(x, y, width, height, offset, stride, pixels);
    nativeGetPixels(mNativeBitmap, pixels, offset, stride, x, y, width, height);
}
------------------------
Find a silently evolved API code:android.media.MediaCodecInfo.isEncoder:COMMENT
Method Modifier: public      final       
Comment:/**
 * Query if the codec is an encoder.
 */

Body of Frist Method:
{
    return MediaCodecList.isEncoder(mIndex);
}
Body of Second Method:
{
    return mIsEncoder;
}
------------------------
Find a silently evolved API code:android.provider.DocumentsProvider.query:COMMENT
Method Modifier: public      final       
Comment:/**
 * Implementation is provided by the parent class. Cannot be overriden.
 *
 * @see #queryRoots(String[])
 * @see #queryRecentDocuments(String, String[])
 * @see #queryDocument(String, String[])
 * @see #queryChildDocuments(String, String[], String)
 * @see #querySearchDocuments(String, String, String[])
 */

Body of Frist Method:
{
    try {
        switch(mMatcher.match(uri)) {
            case MATCH_ROOTS:
                return queryRoots(projection);
            case MATCH_RECENT:
                return queryRecentDocuments(getRootId(uri), projection);
            case MATCH_SEARCH:
                return querySearchDocuments(getRootId(uri), getSearchDocumentsQuery(uri), projection);
            case MATCH_DOCUMENT:
                return queryDocument(getDocumentId(uri), projection);
            case MATCH_CHILDREN:
                if (DocumentsContract.isManageMode(uri)) {
                    return queryChildDocumentsForManage(getDocumentId(uri), projection, sortOrder);
                } else {
                    return queryChildDocuments(getDocumentId(uri), projection, sortOrder);
                }
            default:
                throw new UnsupportedOperationException("Unsupported Uri " + uri);
        }
    } catch (FileNotFoundException e) {
        Log.w(TAG, "Failed during query", e);
        return null;
    }
}
Body of Second Method:
{
    try {
        switch(mMatcher.match(uri)) {
            case MATCH_ROOTS:
                return queryRoots(projection);
            case MATCH_RECENT:
                return queryRecentDocuments(getRootId(uri), projection);
            case MATCH_SEARCH:
                return querySearchDocuments(getRootId(uri), getSearchDocumentsQuery(uri), projection);
            case MATCH_DOCUMENT:
            case MATCH_DOCUMENT_TREE:
                enforceTree(uri);
                return queryDocument(getDocumentId(uri), projection);
            case MATCH_CHILDREN:
            case MATCH_CHILDREN_TREE:
                enforceTree(uri);
                if (DocumentsContract.isManageMode(uri)) {
                    return queryChildDocumentsForManage(getDocumentId(uri), projection, sortOrder);
                } else {
                    return queryChildDocuments(getDocumentId(uri), projection, sortOrder);
                }
            default:
                throw new UnsupportedOperationException("Unsupported Uri " + uri);
        }
    } catch (FileNotFoundException e) {
        Log.w(TAG, "Failed during query", e);
        return null;
    }
}
------------------------
Find a silently evolved API code:android.content.RestrictionEntry.setSelectedState:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the current selected state for an entry of type {@link #TYPE_BOOLEAN}. This value will
 * be persisted by the system for later use by the application.
 * @param state the current selected state
 */

Body of Frist Method:
{
    currentValue = Boolean.toString(state);
}
Body of Second Method:
{
    mCurrentValue = Boolean.toString(state);
}
------------------------
Find a silently evolved API code:android.view.accessibility.AccessibilityManager.getAccessibilityServiceList:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * Returns the {@link ServiceInfo}s of the installed accessibility services.
 *
 * @return An unmodifiable list with {@link ServiceInfo}s.
 *
 * @deprecated Use {@link #getInstalledAccessibilityServiceList()}
 */

Body of Frist Method:
{
    List<AccessibilityServiceInfo> infos = getInstalledAccessibilityServiceList();
    List<ServiceInfo> services = new ArrayList<ServiceInfo>();
    final int infoCount = infos.size();
    for (int i = 0; i < infoCount; i++) {
        AccessibilityServiceInfo info = infos.get(i);
        services.add(info.getResolveInfo().serviceInfo);
    }
    return Collections.unmodifiableList(services);
}
Body of Second Method:
{
    List<AccessibilityServiceInfo> infos = getInstalledAccessibilityServiceList();
    List<ServiceInfo> services = new ArrayList<>();
    final int infoCount = infos.size();
    for (int i = 0; i < infoCount; i++) {
        AccessibilityServiceInfo info = infos.get(i);
        services.add(info.getResolveInfo().serviceInfo);
    }
    return Collections.unmodifiableList(services);
}
------------------------
Find a silently evolved API code:android.content.res.BridgeAssetManager.initSystem:COMMENT
Method Modifier: public      static      
Comment:/**
 * This initializes the static field {@link AssetManager#mSystem} which is used
 * by methods who get a global asset manager using {@link AssetManager#getSystem()}.
 * <p/>
 * They will end up using our bridge asset manager.
 * <p/>
 * {@link Bridge} calls this method after setting up a new bridge.
 */

Body of Frist Method:
{
    if (!(AssetManager.sSystem instanceof BridgeAssetManager)) {
        // Note that AssetManager() creates a system AssetManager and we override it
        // with our BridgeAssetManager.
        AssetManager.sSystem = new BridgeAssetManager();
        AssetManager.sSystem.makeStringBlocks(false);
    }
    return AssetManager.sSystem;
}
Body of Second Method:
{
    if (!(AssetManager.sSystem instanceof BridgeAssetManager)) {
        // Note that AssetManager() creates a system AssetManager and we override it
        // with our BridgeAssetManager.
        AssetManager.sSystem = new BridgeAssetManager();
        AssetManager.sSystem.makeStringBlocks(null);
    }
    return AssetManager.sSystem;
}
------------------------
Find a silently evolved API code:android.widget.AbsSeekBar.setThumb:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the thumb that will be drawn at the end of the progress meter within the SeekBar.
 * <p>
 * If the thumb is a valid drawable (i.e. not null), half its width will be
 * used as the new thumb offset (@see #setThumbOffset(int)).
 *
 * @param thumb Drawable representing the thumb
 */

Body of Frist Method:
{
    boolean needUpdate;
    // drawable changed)
    if (mThumb != null && thumb != mThumb) {
        mThumb.setCallback(null);
        needUpdate = true;
    } else {
        needUpdate = false;
    }
    if (thumb != null) {
        thumb.setCallback(this);
        if (canResolveLayoutDirection()) {
            thumb.setLayoutDirection(getLayoutDirection());
        }
        // Assuming the thumb drawable is symmetric, set the thumb offset
        // such that the thumb will hang halfway off either edge of the
        // progress bar.
        mThumbOffset = thumb.getIntrinsicWidth() / 2;
        // If we're updating get the new states
        if (needUpdate && (thumb.getIntrinsicWidth() != mThumb.getIntrinsicWidth() || thumb.getIntrinsicHeight() != mThumb.getIntrinsicHeight())) {
            requestLayout();
        }
    }
    mThumb = thumb;
    invalidate();
    if (needUpdate) {
        updateThumbPos(getWidth(), getHeight());
        if (thumb != null && thumb.isStateful()) {
            // Note that if the states are different this won't work.
            // For now, let's consider that an app bug.
            int[] state = getDrawableState();
            thumb.setState(state);
        }
    }
}
Body of Second Method:
{
    final boolean needUpdate;
    // drawable changed)
    if (mThumb != null && thumb != mThumb) {
        mThumb.setCallback(null);
        needUpdate = true;
    } else {
        needUpdate = false;
    }
    if (thumb != null) {
        thumb.setCallback(this);
        if (canResolveLayoutDirection()) {
            thumb.setLayoutDirection(getLayoutDirection());
        }
        // Assuming the thumb drawable is symmetric, set the thumb offset
        // such that the thumb will hang halfway off either edge of the
        // progress bar.
        mThumbOffset = thumb.getIntrinsicWidth() / 2;
        // If we're updating get the new states
        if (needUpdate && (thumb.getIntrinsicWidth() != mThumb.getIntrinsicWidth() || thumb.getIntrinsicHeight() != mThumb.getIntrinsicHeight())) {
            requestLayout();
        }
    }
    mThumb = thumb;
    applyThumbTint();
    invalidate();
    if (needUpdate) {
        updateThumbAndTrackPos(getWidth(), getHeight());
        if (thumb != null && thumb.isStateful()) {
            // Note that if the states are different this won't work.
            // For now, let's consider that an app bug.
            int[] state = getDrawableState();
            thumb.setState(state);
        }
    }
}
------------------------
Find a silently evolved API code:android.transition.TransitionManager.changeScene:COMMENT
Method Modifier: private     static      
Comment:/**
 * This is where all of the work of a transition/scene-change is
 * orchestrated. This method captures the start values for the given
 * transition, exits the current Scene, enters the new scene, captures
 * the end values for the transition, and finally plays the
 * resulting values-populated transition.
 *
 * @param scene The scene being entered
 * @param transition The transition to play for this scene change
 */

Body of Frist Method:
{
    final ViewGroup sceneRoot = scene.getSceneRoot();
    Transition transitionClone = transition.clone();
    transitionClone.setSceneRoot(sceneRoot);
    Scene oldScene = Scene.getCurrentScene(sceneRoot);
    if (oldScene != null && oldScene.isCreatedFromLayoutResource()) {
        transitionClone.setCanRemoveViews(true);
    }
    sceneChangeSetup(sceneRoot, transitionClone);
    scene.enter();
    sceneChangeRunTransition(sceneRoot, transitionClone);
}
Body of Second Method:
{
    final ViewGroup sceneRoot = scene.getSceneRoot();
    Transition transitionClone = null;
    if (transition != null) {
        transitionClone = transition.clone();
        transitionClone.setSceneRoot(sceneRoot);
    }
    Scene oldScene = Scene.getCurrentScene(sceneRoot);
    if (oldScene != null && transitionClone != null && oldScene.isCreatedFromLayoutResource()) {
        transitionClone.setCanRemoveViews(true);
    }
    sceneChangeSetup(sceneRoot, transitionClone);
    scene.enter();
    sceneChangeRunTransition(sceneRoot, transitionClone);
}
------------------------
Find a silently evolved API code:android.telephony.ServiceState.setFromNotifierBundle:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Set ServiceState based on intent notifier map.
 *
 * @param m intent notifier map
 * @hide
 */

Body of Frist Method:
{
    mVoiceRegState = m.getInt("voiceRegState");
    mDataRegState = m.getInt("dataRegState");
    mRoaming = m.getBoolean("roaming");
    mOperatorAlphaLong = m.getString("operator-alpha-long");
    mOperatorAlphaShort = m.getString("operator-alpha-short");
    mOperatorNumeric = m.getString("operator-numeric");
    mIsManualNetworkSelection = m.getBoolean("manual");
    mRilVoiceRadioTechnology = m.getInt("radioTechnology");
    mRilVoiceRadioTechnology = m.getInt("dataRadioTechnology");
    mCssIndicator = m.getBoolean("cssIndicator");
    mNetworkId = m.getInt("networkId");
    mSystemId = m.getInt("systemId");
    mCdmaRoamingIndicator = m.getInt("cdmaRoamingIndicator");
    mCdmaDefaultRoamingIndicator = m.getInt("cdmaDefaultRoamingIndicator");
    mIsEmergencyOnly = m.getBoolean("emergencyOnly");
}
Body of Second Method:
{
    mVoiceRegState = m.getInt("voiceRegState");
    mDataRegState = m.getInt("dataRegState");
    mRoaming = m.getBoolean("roaming");
    mOperatorAlphaLong = m.getString("operator-alpha-long");
    mOperatorAlphaShort = m.getString("operator-alpha-short");
    mOperatorNumeric = m.getString("operator-numeric");
    mIsManualNetworkSelection = m.getBoolean("manual");
    mRilVoiceRadioTechnology = m.getInt("radioTechnology");
    mRilDataRadioTechnology = m.getInt("dataRadioTechnology");
    mCssIndicator = m.getBoolean("cssIndicator");
    mNetworkId = m.getInt("networkId");
    mSystemId = m.getInt("systemId");
    mCdmaRoamingIndicator = m.getInt("cdmaRoamingIndicator");
    mCdmaDefaultRoamingIndicator = m.getInt("cdmaDefaultRoamingIndicator");
    mIsEmergencyOnly = m.getBoolean("emergencyOnly");
}
------------------------
Find a silently evolved API code:android.graphics.Path.reset:COMMENT
Method Modifier: public      
Comment:/**
 * Clear any lines and curves from the path, making it empty.
 * This does NOT change the fill-type setting.
 */

Body of Frist Method:
{
    isSimplePath = true;
    if (mDetectSimplePaths) {
        mLastDirection = null;
        if (rects != null)
            rects.setEmpty();
    }
    // We promised not to change this, so preserve it around the native
    // call, which does now reset fill type.
    final FillType fillType = getFillType();
    native_reset(mNativePath);
    setFillType(fillType);
}
Body of Second Method:
{
    isSimplePath = true;
    mLastDirection = null;
    if (rects != null)
        rects.setEmpty();
    // We promised not to change this, so preserve it around the native
    // call, which does now reset fill type.
    final FillType fillType = getFillType();
    native_reset(mNativePath);
    setFillType(fillType);
}
------------------------
Find a silently evolved API code:android.widget.CalendarView.setMinDate:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the minimal date supported by this {@link CalendarView} in milliseconds
 * since January 1, 1970 00:00:00 in {@link TimeZone#getDefault()} time
 * zone.
 *
 * @param minDate The minimal supported date.
 *
 * @attr ref android.R.styleable#CalendarView_minDate
 */

Body of Frist Method:
{
    mTempDate.setTimeInMillis(minDate);
    if (isSameDate(mTempDate, mMinDate)) {
        return;
    }
    mMinDate.setTimeInMillis(minDate);
    // make sure the current date is not earlier than
    // the new min date since the latter is used for
    // calculating the indices in the adapter thus
    // avoiding out of bounds error
    Calendar date = mAdapter.mSelectedDate;
    if (date.before(mMinDate)) {
        mAdapter.setSelectedDay(mMinDate);
    }
    // reinitialize the adapter since its range depends on min date
    mAdapter.init();
    if (date.before(mMinDate)) {
        setDate(mTempDate.getTimeInMillis());
    } else {
        // we go to the current date to force the ListView to query its
        // adapter for the shown views since we have changed the adapter
        // range and the base from which the later calculates item indices
        // note that calling setDate will not work since the date is the same
        goTo(date, false, true, false);
    }
}
Body of Second Method:
{
    mDelegate.setMinDate(minDate);
}
------------------------
Find a silently evolved API code:android.media.AudioService.loadSoundEffects:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Loads samples into the soundpool.
 * This method must be called at first when sound effects are enabled
 */

Body of Frist Method:
{
    int attempts = 3;
    LoadSoundEffectReply reply = new LoadSoundEffectReply();
    synchronized (reply) {
        sendMsg(mAudioHandler, MSG_LOAD_SOUND_EFFECTS, SENDMSG_QUEUE, 0, 0, reply, 0);
        while ((reply.mStatus == 1) && (attempts-- > 0)) {
            try {
                reply.wait(SOUND_EFECTS_LOAD_TIMEOUT_MS);
            } catch (InterruptedException e) {
                Log.w(TAG, "loadSoundEffects Interrupted while waiting sound pool loaded.");
            }
        }
    }
    return (reply.mStatus == 0);
}
Body of Second Method:
{
    int attempts = 3;
    LoadSoundEffectReply reply = new LoadSoundEffectReply();
    synchronized (reply) {
        sendMsg(mAudioHandler, MSG_LOAD_SOUND_EFFECTS, SENDMSG_QUEUE, 0, 0, reply, 0);
        while ((reply.mStatus == 1) && (attempts-- > 0)) {
            try {
                reply.wait(SOUND_EFFECTS_LOAD_TIMEOUT_MS);
            } catch (InterruptedException e) {
                Log.w(TAG, "loadSoundEffects Interrupted while waiting sound pool loaded.");
            }
        }
    }
    return (reply.mStatus == 0);
}
------------------------
Find a silently evolved API code:android.widget.RelativeLayout.LayoutParams.resolveRules:COMMENT
Method Modifier: private     
Comment:// only the "left"/"right" rules at the end.

Body of Frist Method:
{
    final boolean isLayoutRtl = (layoutDirection == View.LAYOUT_DIRECTION_RTL);
    // Reset to initial state
    System.arraycopy(mInitialRules, LEFT_OF, mRules, LEFT_OF, VERB_COUNT);
    // Apply rules depending on direction and if we are in RTL compatibility mode
    if (mIsRtlCompatibilityMode) {
        if (mRules[ALIGN_START] != 0) {
            if (mRules[ALIGN_LEFT] == 0) {
                // "left" rule is not defined but "start" rule is: use the "start" rule as
                // the "left" rule
                mRules[ALIGN_LEFT] = mRules[ALIGN_START];
            }
            mRules[ALIGN_START] = 0;
        }
        if (mRules[ALIGN_END] != 0) {
            if (mRules[ALIGN_RIGHT] == 0) {
                // "right" rule is not defined but "end" rule is: use the "end" rule as the
                // "right" rule
                mRules[ALIGN_RIGHT] = mRules[ALIGN_END];
            }
            mRules[ALIGN_END] = 0;
        }
        if (mRules[START_OF] != 0) {
            if (mRules[LEFT_OF] == 0) {
                // "left" rule is not defined but "start" rule is: use the "start" rule as
                // the "left" rule
                mRules[LEFT_OF] = mRules[START_OF];
            }
            mRules[START_OF] = 0;
        }
        if (mRules[END_OF] != 0) {
            if (mRules[RIGHT_OF] == 0) {
                // "right" rule is not defined but "end" rule is: use the "end" rule as the
                // "right" rule
                mRules[RIGHT_OF] = mRules[END_OF];
            }
            mRules[END_OF] = 0;
        }
        if (mRules[ALIGN_PARENT_START] != 0) {
            if (mRules[ALIGN_PARENT_LEFT] == 0) {
                // "left" rule is not defined but "start" rule is: use the "start" rule as
                // the "left" rule
                mRules[ALIGN_PARENT_LEFT] = mRules[ALIGN_PARENT_START];
            }
            mRules[ALIGN_PARENT_START] = 0;
        }
        if (mRules[ALIGN_PARENT_RIGHT] == 0) {
            if (mRules[ALIGN_PARENT_RIGHT] == 0) {
                // "right" rule is not defined but "end" rule is: use the "end" rule as the
                // "right" rule
                mRules[ALIGN_PARENT_RIGHT] = mRules[ALIGN_PARENT_END];
            }
            mRules[ALIGN_PARENT_END] = 0;
        }
    } else {
        // JB MR1+ case
        if ((mRules[ALIGN_START] != 0 || mRules[ALIGN_END] != 0) && (mRules[ALIGN_LEFT] != 0 || mRules[ALIGN_RIGHT] != 0)) {
            // "start"/"end" rules take precedence over "left"/"right" rules
            mRules[ALIGN_LEFT] = 0;
            mRules[ALIGN_RIGHT] = 0;
        }
        if (mRules[ALIGN_START] != 0) {
            // "start" rule resolved to "left" or "right" depending on the direction
            mRules[isLayoutRtl ? ALIGN_RIGHT : ALIGN_LEFT] = mRules[ALIGN_START];
            mRules[ALIGN_START] = 0;
        }
        if (mRules[ALIGN_END] != 0) {
            // "end" rule resolved to "left" or "right" depending on the direction
            mRules[isLayoutRtl ? ALIGN_LEFT : ALIGN_RIGHT] = mRules[ALIGN_END];
            mRules[ALIGN_END] = 0;
        }
        if ((mRules[START_OF] != 0 || mRules[END_OF] != 0) && (mRules[LEFT_OF] != 0 || mRules[RIGHT_OF] != 0)) {
            // "start"/"end" rules take precedence over "left"/"right" rules
            mRules[LEFT_OF] = 0;
            mRules[RIGHT_OF] = 0;
        }
        if (mRules[START_OF] != 0) {
            // "start" rule resolved to "left" or "right" depending on the direction
            mRules[isLayoutRtl ? RIGHT_OF : LEFT_OF] = mRules[START_OF];
            mRules[START_OF] = 0;
        }
        if (mRules[END_OF] != 0) {
            // "end" rule resolved to "left" or "right" depending on the direction
            mRules[isLayoutRtl ? LEFT_OF : RIGHT_OF] = mRules[END_OF];
            mRules[END_OF] = 0;
        }
        if ((mRules[ALIGN_PARENT_START] != 0 || mRules[ALIGN_PARENT_END] != 0) && (mRules[ALIGN_PARENT_LEFT] != 0 || mRules[ALIGN_PARENT_RIGHT] != 0)) {
            // "start"/"end" rules take precedence over "left"/"right" rules
            mRules[ALIGN_PARENT_LEFT] = 0;
            mRules[ALIGN_PARENT_RIGHT] = 0;
        }
        if (mRules[ALIGN_PARENT_START] != 0) {
            // "start" rule resolved to "left" or "right" depending on the direction
            mRules[isLayoutRtl ? ALIGN_PARENT_RIGHT : ALIGN_PARENT_LEFT] = mRules[ALIGN_PARENT_START];
            mRules[ALIGN_PARENT_START] = 0;
        }
        if (mRules[ALIGN_PARENT_END] != 0) {
            // "end" rule resolved to "left" or "right" depending on the direction
            mRules[isLayoutRtl ? ALIGN_PARENT_LEFT : ALIGN_PARENT_RIGHT] = mRules[ALIGN_PARENT_END];
            mRules[ALIGN_PARENT_END] = 0;
        }
    }
    mRulesChanged = false;
}
Body of Second Method:
{
    final boolean isLayoutRtl = (layoutDirection == View.LAYOUT_DIRECTION_RTL);
    // Reset to initial state
    System.arraycopy(mInitialRules, LEFT_OF, mRules, LEFT_OF, VERB_COUNT);
    // Apply rules depending on direction and if we are in RTL compatibility mode
    if (mIsRtlCompatibilityMode) {
        if (mRules[ALIGN_START] != 0) {
            if (mRules[ALIGN_LEFT] == 0) {
                // "left" rule is not defined but "start" rule is: use the "start" rule as
                // the "left" rule
                mRules[ALIGN_LEFT] = mRules[ALIGN_START];
            }
            mRules[ALIGN_START] = 0;
        }
        if (mRules[ALIGN_END] != 0) {
            if (mRules[ALIGN_RIGHT] == 0) {
                // "right" rule is not defined but "end" rule is: use the "end" rule as the
                // "right" rule
                mRules[ALIGN_RIGHT] = mRules[ALIGN_END];
            }
            mRules[ALIGN_END] = 0;
        }
        if (mRules[START_OF] != 0) {
            if (mRules[LEFT_OF] == 0) {
                // "left" rule is not defined but "start" rule is: use the "start" rule as
                // the "left" rule
                mRules[LEFT_OF] = mRules[START_OF];
            }
            mRules[START_OF] = 0;
        }
        if (mRules[END_OF] != 0) {
            if (mRules[RIGHT_OF] == 0) {
                // "right" rule is not defined but "end" rule is: use the "end" rule as the
                // "right" rule
                mRules[RIGHT_OF] = mRules[END_OF];
            }
            mRules[END_OF] = 0;
        }
        if (mRules[ALIGN_PARENT_START] != 0) {
            if (mRules[ALIGN_PARENT_LEFT] == 0) {
                // "left" rule is not defined but "start" rule is: use the "start" rule as
                // the "left" rule
                mRules[ALIGN_PARENT_LEFT] = mRules[ALIGN_PARENT_START];
            }
            mRules[ALIGN_PARENT_START] = 0;
        }
        if (mRules[ALIGN_PARENT_END] != 0) {
            if (mRules[ALIGN_PARENT_RIGHT] == 0) {
                // "right" rule is not defined but "end" rule is: use the "end" rule as the
                // "right" rule
                mRules[ALIGN_PARENT_RIGHT] = mRules[ALIGN_PARENT_END];
            }
            mRules[ALIGN_PARENT_END] = 0;
        }
    } else {
        // JB MR1+ case
        if ((mRules[ALIGN_START] != 0 || mRules[ALIGN_END] != 0) && (mRules[ALIGN_LEFT] != 0 || mRules[ALIGN_RIGHT] != 0)) {
            // "start"/"end" rules take precedence over "left"/"right" rules
            mRules[ALIGN_LEFT] = 0;
            mRules[ALIGN_RIGHT] = 0;
        }
        if (mRules[ALIGN_START] != 0) {
            // "start" rule resolved to "left" or "right" depending on the direction
            mRules[isLayoutRtl ? ALIGN_RIGHT : ALIGN_LEFT] = mRules[ALIGN_START];
            mRules[ALIGN_START] = 0;
        }
        if (mRules[ALIGN_END] != 0) {
            // "end" rule resolved to "left" or "right" depending on the direction
            mRules[isLayoutRtl ? ALIGN_LEFT : ALIGN_RIGHT] = mRules[ALIGN_END];
            mRules[ALIGN_END] = 0;
        }
        if ((mRules[START_OF] != 0 || mRules[END_OF] != 0) && (mRules[LEFT_OF] != 0 || mRules[RIGHT_OF] != 0)) {
            // "start"/"end" rules take precedence over "left"/"right" rules
            mRules[LEFT_OF] = 0;
            mRules[RIGHT_OF] = 0;
        }
        if (mRules[START_OF] != 0) {
            // "start" rule resolved to "left" or "right" depending on the direction
            mRules[isLayoutRtl ? RIGHT_OF : LEFT_OF] = mRules[START_OF];
            mRules[START_OF] = 0;
        }
        if (mRules[END_OF] != 0) {
            // "end" rule resolved to "left" or "right" depending on the direction
            mRules[isLayoutRtl ? LEFT_OF : RIGHT_OF] = mRules[END_OF];
            mRules[END_OF] = 0;
        }
        if ((mRules[ALIGN_PARENT_START] != 0 || mRules[ALIGN_PARENT_END] != 0) && (mRules[ALIGN_PARENT_LEFT] != 0 || mRules[ALIGN_PARENT_RIGHT] != 0)) {
            // "start"/"end" rules take precedence over "left"/"right" rules
            mRules[ALIGN_PARENT_LEFT] = 0;
            mRules[ALIGN_PARENT_RIGHT] = 0;
        }
        if (mRules[ALIGN_PARENT_START] != 0) {
            // "start" rule resolved to "left" or "right" depending on the direction
            mRules[isLayoutRtl ? ALIGN_PARENT_RIGHT : ALIGN_PARENT_LEFT] = mRules[ALIGN_PARENT_START];
            mRules[ALIGN_PARENT_START] = 0;
        }
        if (mRules[ALIGN_PARENT_END] != 0) {
            // "end" rule resolved to "left" or "right" depending on the direction
            mRules[isLayoutRtl ? ALIGN_PARENT_LEFT : ALIGN_PARENT_RIGHT] = mRules[ALIGN_PARENT_END];
            mRules[ALIGN_PARENT_END] = 0;
        }
    }
    mRulesChanged = false;
}
------------------------
Find a silently evolved API code:android.hardware.SystemSensorManager.TriggerEventQueue.dispatchSensorEvent:COMMENT
Method Modifier: protected   
Comment:// Called from native code.

Body of Frist Method:
{
    final Sensor sensor = sHandleToSensor.get(handle);
    TriggerEvent t = mTriggerEvents.get(handle);
    if (t == null) {
        Log.e(TAG, "Error: Trigger Event is null for Sensor: " + sensor);
        return;
    }
    // Copy from the values array.
    System.arraycopy(values, 0, t.values, 0, t.values.length);
    t.timestamp = timestamp;
    t.sensor = sensor;
    // A trigger sensor is auto disabled. So just clean up and don't call native
    // disable.
    mManager.cancelTriggerSensorImpl(mListener, sensor, false);
    mListener.onTrigger(t);
}
Body of Second Method:
{
    final Sensor sensor = sHandleToSensor.get(handle);
    TriggerEvent t = null;
    synchronized (mTriggerEvents) {
        t = mTriggerEvents.get(handle);
    }
    if (t == null) {
        Log.e(TAG, "Error: Trigger Event is null for Sensor: " + sensor);
        return;
    }
    // Copy from the values array.
    System.arraycopy(values, 0, t.values, 0, t.values.length);
    t.timestamp = timestamp;
    t.sensor = sensor;
    // A trigger sensor is auto disabled. So just clean up and don't call native
    // disable.
    mManager.cancelTriggerSensorImpl(mListener, sensor, false);
    mListener.onTrigger(t);
}
------------------------
Find a silently evolved API code:android.app.Notification.Style.buildStyled:COMMENT
<android.app.Notification.Style: Notification buildStyled(Notification)>
public      abstract    hidden      ->public      hidden      
Method Modifier: public      abstract    hidden      
Method Modifier: Yes         Yes         Yes         
Method Updated:  Yes         No          Yes         
Comment:/**
 * @hide
 */

Body of Frist Method:

Body of Second Method:
{
    populateTickerView(wip);
    populateContentView(wip);
    populateBigContentView(wip);
    populateHeadsUpContentView(wip);
    return wip;
}
------------------------
Find a silently evolved API code:android.text.TextLine.set:COMMENT
Method Modifier: default     hidden      
Comment:/**
 * Initializes a TextLine and prepares it for use.
 *
 * @param paint the base paint for the line
 * @param text the text, can be Styled
 * @param start the start of the line relative to the text
 * @param limit the limit of the line relative to the text
 * @param dir the paragraph direction of this line
 * @param directions the directions information of this line
 * @param hasTabs true if the line might contain tabs or emoji
 * @param tabStops the tabStops. Can be null.
 */

Body of Frist Method:
{
    mPaint = paint;
    mText = text;
    mStart = start;
    mLen = limit - start;
    mDir = dir;
    mDirections = directions;
    if (mDirections == null) {
        throw new IllegalArgumentException("Directions cannot be null");
    }
    mHasTabs = hasTabs;
    mSpanned = null;
    boolean hasReplacement = false;
    if (text instanceof Spanned) {
        mSpanned = (Spanned) text;
        mReplacementSpanSpanSet.init(mSpanned, start, limit);
        hasReplacement = mReplacementSpanSpanSet.numberOfSpans > 0;
    }
    mCharsValid = hasReplacement || hasTabs || directions != Layout.DIRS_ALL_LEFT_TO_RIGHT;
    if (mCharsValid) {
        if (mChars == null || mChars.length < mLen) {
            mChars = new char[ArrayUtils.idealCharArraySize(mLen)];
        }
        TextUtils.getChars(text, start, limit, mChars, 0);
        if (hasReplacement) {
            // Handle these all at once so we don't have to do it as we go.
            // Replace the first character of each replacement run with the
            // object-replacement character and the remainder with zero width
            // non-break space aka BOM.  Cursor movement code skips these
            // zero-width characters.
            char[] chars = mChars;
            for (int i = start, inext; i < limit; i = inext) {
                inext = mReplacementSpanSpanSet.getNextTransition(i, limit);
                if (mReplacementSpanSpanSet.hasSpansIntersecting(i, inext)) {
                    // transition into a span
                    chars[i - start] = '\ufffc';
                    for (int j = i - start + 1, e = inext - start; j < e; ++j) {
                        // used as ZWNBS, marks positions to skip
                        chars[j] = '\ufeff';
                    }
                }
            }
        }
    }
    mTabs = tabStops;
}
Body of Second Method:
{
    mPaint = paint;
    mText = text;
    mStart = start;
    mLen = limit - start;
    mDir = dir;
    mDirections = directions;
    if (mDirections == null) {
        throw new IllegalArgumentException("Directions cannot be null");
    }
    mHasTabs = hasTabs;
    mSpanned = null;
    boolean hasReplacement = false;
    if (text instanceof Spanned) {
        mSpanned = (Spanned) text;
        mReplacementSpanSpanSet.init(mSpanned, start, limit);
        hasReplacement = mReplacementSpanSpanSet.numberOfSpans > 0;
    }
    mCharsValid = hasReplacement || hasTabs || directions != Layout.DIRS_ALL_LEFT_TO_RIGHT;
    if (mCharsValid) {
        if (mChars == null || mChars.length < mLen) {
            mChars = ArrayUtils.newUnpaddedCharArray(mLen);
        }
        TextUtils.getChars(text, start, limit, mChars, 0);
        if (hasReplacement) {
            // Handle these all at once so we don't have to do it as we go.
            // Replace the first character of each replacement run with the
            // object-replacement character and the remainder with zero width
            // non-break space aka BOM.  Cursor movement code skips these
            // zero-width characters.
            char[] chars = mChars;
            for (int i = start, inext; i < limit; i = inext) {
                inext = mReplacementSpanSpanSet.getNextTransition(i, limit);
                if (mReplacementSpanSpanSet.hasSpansIntersecting(i, inext)) {
                    // transition into a span
                    chars[i - start] = '\ufffc';
                    for (int j = i - start + 1, e = inext - start; j < e; ++j) {
                        // used as ZWNBS, marks positions to skip
                        chars[j] = '\ufeff';
                    }
                }
            }
        }
    }
    mTabs = tabStops;
}
------------------------
Find a silently evolved API code:android.graphics.drawable.GradientDrawable.setGradientCenter:COMMENT
Method Modifier: public      
Comment:/**
 * <p>Sets the center location of the gradient. The radius is honored only when
 * the gradient type is set to {@link #RADIAL_GRADIENT} or {@link #SWEEP_GRADIENT}.</p>
 * <p><strong>Note</strong>: changing this property will affect all instances
 * of a drawable loaded from a resource. It is recommended to invoke
 * {@link #mutate()} before changing this property.</p>
 *
 * @param x The x coordinate of the gradient's center
 * @param y The y coordinate of the gradient's center
 *
 * @see #mutate()
 * @see #setGradientType(int)
 */

Body of Frist Method:
{
    mGradientState.setGradientCenter(x, y);
    mRectIsDirty = true;
    invalidateSelf();
}
Body of Second Method:
{
    mGradientState.setGradientCenter(x, y);
    mGradientIsDirty = true;
    invalidateSelf();
}
------------------------
Find a silently evolved API code:android.app.ActivityOptions.update:COMMENT
Method Modifier: public      
Comment:/**
 * Update the current values in this ActivityOptions from those supplied
 * in <var>otherOptions</var>.  Any values
 * defined in <var>otherOptions</var> replace those in the base options.
 */

Body of Frist Method:
{
    if (otherOptions.mPackageName != null) {
        mPackageName = otherOptions.mPackageName;
    }
    switch(otherOptions.mAnimationType) {
        case ANIM_CUSTOM:
            mAnimationType = otherOptions.mAnimationType;
            mCustomEnterResId = otherOptions.mCustomEnterResId;
            mCustomExitResId = otherOptions.mCustomExitResId;
            mThumbnail = null;
            if (otherOptions.mAnimationStartedListener != null) {
                try {
                    otherOptions.mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = otherOptions.mAnimationStartedListener;
            break;
        case ANIM_SCALE_UP:
            mAnimationType = otherOptions.mAnimationType;
            mStartX = otherOptions.mStartX;
            mStartY = otherOptions.mStartY;
            mStartWidth = otherOptions.mStartWidth;
            mStartHeight = otherOptions.mStartHeight;
            if (otherOptions.mAnimationStartedListener != null) {
                try {
                    otherOptions.mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = null;
            break;
        case ANIM_THUMBNAIL_SCALE_UP:
        case ANIM_THUMBNAIL_SCALE_DOWN:
            mAnimationType = otherOptions.mAnimationType;
            mThumbnail = otherOptions.mThumbnail;
            mStartX = otherOptions.mStartX;
            mStartY = otherOptions.mStartY;
            if (otherOptions.mAnimationStartedListener != null) {
                try {
                    otherOptions.mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = otherOptions.mAnimationStartedListener;
            break;
    }
}
Body of Second Method:
{
    if (otherOptions.mPackageName != null) {
        mPackageName = otherOptions.mPackageName;
    }
    mTransitionReceiver = null;
    mSharedElementNames = null;
    mIsReturning = false;
    mResultData = null;
    mResultCode = 0;
    mExitCoordinatorIndex = 0;
    mAnimationType = otherOptions.mAnimationType;
    switch(otherOptions.mAnimationType) {
        case ANIM_CUSTOM:
            mCustomEnterResId = otherOptions.mCustomEnterResId;
            mCustomExitResId = otherOptions.mCustomExitResId;
            mThumbnail = null;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = otherOptions.mAnimationStartedListener;
            break;
        case ANIM_SCALE_UP:
            mStartX = otherOptions.mStartX;
            mStartY = otherOptions.mStartY;
            mWidth = otherOptions.mWidth;
            mHeight = otherOptions.mHeight;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = null;
            break;
        case ANIM_THUMBNAIL_SCALE_UP:
        case ANIM_THUMBNAIL_SCALE_DOWN:
        case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
        case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
            mThumbnail = otherOptions.mThumbnail;
            mStartX = otherOptions.mStartX;
            mStartY = otherOptions.mStartY;
            mWidth = otherOptions.mWidth;
            mHeight = otherOptions.mHeight;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = otherOptions.mAnimationStartedListener;
            break;
        case ANIM_SCENE_TRANSITION:
            mTransitionReceiver = otherOptions.mTransitionReceiver;
            mSharedElementNames = otherOptions.mSharedElementNames;
            mIsReturning = otherOptions.mIsReturning;
            mThumbnail = null;
            mAnimationStartedListener = null;
            mResultData = otherOptions.mResultData;
            mResultCode = otherOptions.mResultCode;
            mExitCoordinatorIndex = otherOptions.mExitCoordinatorIndex;
            break;
    }
}
------------------------
Find a silently evolved API code:javax.obex.ClientOperation.startProcessing:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * This method starts the processing thread results. It will send the
 * initial request. If the response takes more then one packet, a thread
 * will be started to handle additional requests
 * @throws IOException if an IO error occurs
 */

Body of Frist Method:
{
    if (mPrivateInput == null) {
        mPrivateInput = new PrivateInputStream(this);
    }
    boolean more = true;
    if (mGetOperation) {
        if (!mOperationDone) {
            mReplyHeader.responseCode = ResponseCodes.OBEX_HTTP_CONTINUE;
            while ((more) && (mReplyHeader.responseCode == ResponseCodes.OBEX_HTTP_CONTINUE)) {
                more = sendRequest(0x03);
            }
            if (mReplyHeader.responseCode == ResponseCodes.OBEX_HTTP_CONTINUE) {
                mParent.sendRequest(0x83, null, mReplyHeader, mPrivateInput);
            }
            if (mReplyHeader.responseCode != ResponseCodes.OBEX_HTTP_CONTINUE) {
                mOperationDone = true;
            }
        }
    } else {
        if (!mOperationDone) {
            mReplyHeader.responseCode = ResponseCodes.OBEX_HTTP_CONTINUE;
            while ((more) && (mReplyHeader.responseCode == ResponseCodes.OBEX_HTTP_CONTINUE)) {
                more = sendRequest(0x02);
            }
        }
        if (mReplyHeader.responseCode == ResponseCodes.OBEX_HTTP_CONTINUE) {
            mParent.sendRequest(0x82, null, mReplyHeader, mPrivateInput);
        }
        if (mReplyHeader.responseCode != ResponseCodes.OBEX_HTTP_CONTINUE) {
            mOperationDone = true;
        }
    }
}
Body of Second Method:
{
    if (mPrivateInput == null) {
        mPrivateInput = new PrivateInputStream(this);
    }
    boolean more = true;
    if (mGetOperation) {
        if (!mOperationDone) {
            if (!mGetFinalFlag) {
                mReplyHeader.responseCode = ResponseCodes.OBEX_HTTP_CONTINUE;
                while ((more) && (mReplyHeader.responseCode == ResponseCodes.OBEX_HTTP_CONTINUE)) {
                    more = sendRequest(0x03);
                }
                if (mReplyHeader.responseCode == ResponseCodes.OBEX_HTTP_CONTINUE) {
                    mParent.sendRequest(0x83, null, mReplyHeader, mPrivateInput);
                }
                if (mReplyHeader.responseCode != ResponseCodes.OBEX_HTTP_CONTINUE) {
                    mOperationDone = true;
                }
            } else {
                more = sendRequest(0x83);
                if (more) {
                    throw new IOException("FINAL_GET forced but data did not fit into single packet!");
                }
                mOperationDone = true;
            }
        }
    } else {
        if (!mOperationDone) {
            mReplyHeader.responseCode = ResponseCodes.OBEX_HTTP_CONTINUE;
            while ((more) && (mReplyHeader.responseCode == ResponseCodes.OBEX_HTTP_CONTINUE)) {
                more = sendRequest(0x02);
            }
        }
        if (mReplyHeader.responseCode == ResponseCodes.OBEX_HTTP_CONTINUE) {
            mParent.sendRequest(0x82, null, mReplyHeader, mPrivateInput);
        }
        if (mReplyHeader.responseCode != ResponseCodes.OBEX_HTTP_CONTINUE) {
            mOperationDone = true;
        }
    }
}
------------------------
Find a silently evolved API code:android.content.res.TypedArray.getColor:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the color value for the attribute at <var>index</var>.  If
 * the attribute references a color resource holding a complex
 * {@link android.content.res.ColorStateList}, then the default color from
 * the set is returned.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute color value, or defValue if not defined.
 */

Body of Frist Method:
{
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + AssetManager.STYLE_DATA];
    } else if (type == TypedValue.TYPE_STRING) {
        final TypedValue value = mValue;
        if (getValueAt(index, value)) {
            ColorStateList csl = mResources.loadColorStateList(value, value.resourceId);
            return csl.getDefaultColor();
        }
        return defValue;
    }
    throw new UnsupportedOperationException("Can't convert to color: type=0x" + Integer.toHexString(type));
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + AssetManager.STYLE_DATA];
    } else if (type == TypedValue.TYPE_STRING) {
        final TypedValue value = mValue;
        if (getValueAt(index, value)) {
            ColorStateList csl = mResources.loadColorStateList(value, value.resourceId);
            return csl.getDefaultColor();
        }
        return defValue;
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        throw new RuntimeException("Failed to resolve attribute at index " + index);
    }
    throw new UnsupportedOperationException("Can't convert to color: type=0x" + Integer.toHexString(type));
}
------------------------
Find a silently evolved API code:android.content.RestrictionEntry.getDescription:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the provided user-visible description of the entry, if any.
 * @return the user-visible description, null if none was set earlier.
 */

Body of Frist Method:
{
    return description;
}
Body of Second Method:
{
    return mDescription;
}
------------------------
Find a silently evolved API code:android.content.Intent.toShortString:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    boolean first = true;
    if (mAction != null) {
        b.append("act=").append(mAction);
        first = false;
    }
    if (mCategories != null) {
        if (!first) {
            b.append(' ');
        }
        first = false;
        b.append("cat=[");
        for (int i = 0; i < mCategories.size(); i++) {
            if (i > 0)
                b.append(',');
            b.append(mCategories.valueAt(i));
        }
        b.append("]");
    }
    if (mData != null) {
        if (!first) {
            b.append(' ');
        }
        first = false;
        b.append("dat=");
        if (secure) {
            b.append(mData.toSafeString());
        } else {
            b.append(mData);
        }
    }
    if (mType != null) {
        if (!first) {
            b.append(' ');
        }
        first = false;
        b.append("typ=").append(mType);
    }
    if (mFlags != 0) {
        if (!first) {
            b.append(' ');
        }
        first = false;
        b.append("flg=0x").append(Integer.toHexString(mFlags));
    }
    if (mPackage != null) {
        if (!first) {
            b.append(' ');
        }
        first = false;
        b.append("pkg=").append(mPackage);
    }
    if (comp && mComponent != null) {
        if (!first) {
            b.append(' ');
        }
        first = false;
        b.append("cmp=").append(mComponent.flattenToShortString());
    }
    if (mSourceBounds != null) {
        if (!first) {
            b.append(' ');
        }
        first = false;
        b.append("bnds=").append(mSourceBounds.toShortString());
    }
    if (mClipData != null) {
        if (!first) {
            b.append(' ');
        }
        first = false;
        if (clip) {
            b.append("clip={");
            mClipData.toShortString(b);
            b.append('}');
        } else {
            b.append("(has clip)");
        }
    }
    if (extras && mExtras != null) {
        if (!first) {
            b.append(' ');
        }
        first = false;
        b.append("(has extras)");
    }
    if (mSelector != null) {
        b.append(" sel={");
        mSelector.toShortString(b, secure, comp, extras, clip);
        b.append("}");
    }
}
Body of Second Method:
{
    boolean first = true;
    if (mAction != null) {
        b.append("act=").append(mAction);
        first = false;
    }
    if (mCategories != null) {
        if (!first) {
            b.append(' ');
        }
        first = false;
        b.append("cat=[");
        for (int i = 0; i < mCategories.size(); i++) {
            if (i > 0)
                b.append(',');
            b.append(mCategories.valueAt(i));
        }
        b.append("]");
    }
    if (mData != null) {
        if (!first) {
            b.append(' ');
        }
        first = false;
        b.append("dat=");
        if (secure) {
            b.append(mData.toSafeString());
        } else {
            b.append(mData);
        }
    }
    if (mType != null) {
        if (!first) {
            b.append(' ');
        }
        first = false;
        b.append("typ=").append(mType);
    }
    if (mFlags != 0) {
        if (!first) {
            b.append(' ');
        }
        first = false;
        b.append("flg=0x").append(Integer.toHexString(mFlags));
    }
    if (mPackage != null) {
        if (!first) {
            b.append(' ');
        }
        first = false;
        b.append("pkg=").append(mPackage);
    }
    if (comp && mComponent != null) {
        if (!first) {
            b.append(' ');
        }
        first = false;
        b.append("cmp=").append(mComponent.flattenToShortString());
    }
    if (mSourceBounds != null) {
        if (!first) {
            b.append(' ');
        }
        first = false;
        b.append("bnds=").append(mSourceBounds.toShortString());
    }
    if (mClipData != null) {
        if (!first) {
            b.append(' ');
        }
        first = false;
        if (clip) {
            b.append("clip={");
            mClipData.toShortString(b);
            b.append('}');
        } else {
            b.append("(has clip)");
        }
    }
    if (extras && mExtras != null) {
        if (!first) {
            b.append(' ');
        }
        first = false;
        b.append("(has extras)");
    }
    if (mContentUserHint != UserHandle.USER_CURRENT) {
        if (!first) {
            b.append(' ');
        }
        first = false;
        b.append("u=").append(mContentUserHint);
    }
    if (mSelector != null) {
        b.append(" sel=");
        mSelector.toShortString(b, secure, comp, extras, clip);
        b.append("}");
    }
}
------------------------
Find a silently evolved API code:android.widget.SuggestionsAdapter.newView:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Tags the view with cached child view look-ups.
 */

Body of Frist Method:
{
    View v = super.newView(context, cursor, parent);
    v.setTag(new ChildViewCache(v));
    return v;
}
Body of Second Method:
{
    final View v = super.newView(context, cursor, parent);
    v.setTag(new ChildViewCache(v));
    // Set up icon.
    final ImageView iconRefine = (ImageView) v.findViewById(R.id.edit_query);
    iconRefine.setImageResource(mCommitIconResId);
    return v;
}
------------------------
Find a silently evolved API code:android.media.RemoteControlClient.MetadataEditor.putString:COMMENT
<android.media.RemoteControlClient.MetadataEditor: MetadataEditor putString(int,String)>
public      ->public      deprecated  
Method Modifier: public      deprecated  
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Adds textual information to be displayed.
 * Note that none of the information added after {@link #apply()} has been called,
 * will be displayed.
 * @param key The identifier of a the metadata field to set. Valid values are
 * {@link android.media.MediaMetadataRetriever#METADATA_KEY_ALBUM},
 * {@link android.media.MediaMetadataRetriever#METADATA_KEY_ALBUMARTIST},
 * {@link android.media.MediaMetadataRetriever#METADATA_KEY_TITLE},
 * {@link android.media.MediaMetadataRetriever#METADATA_KEY_ARTIST},
 * {@link android.media.MediaMetadataRetriever#METADATA_KEY_AUTHOR},
 * {@link android.media.MediaMetadataRetriever#METADATA_KEY_COMPILATION},
 * {@link android.media.MediaMetadataRetriever#METADATA_KEY_COMPOSER},
 * {@link android.media.MediaMetadataRetriever#METADATA_KEY_DATE},
 * {@link android.media.MediaMetadataRetriever#METADATA_KEY_GENRE},
 * {@link android.media.MediaMetadataRetriever#METADATA_KEY_TITLE},
 * {@link android.media.MediaMetadataRetriever#METADATA_KEY_WRITER}.
 * @param value The text for the given key, or {@code null} to signify there is no valid
 * information for the field.
 * @return Returns a reference to the same MetadataEditor object, so you can chain put
 * calls together.
 */

Body of Frist Method:
{
    super.putString(key, value);
    return this;
}
Body of Second Method:
{
    super.putString(key, value);
    if (mMetadataBuilder != null) {
        // MediaMetadata supports all the same fields as MetadataEditor
        String metadataKey = MediaMetadata.getKeyFromMetadataEditorKey(key);
        // But just in case, don't add things we don't understand
        if (metadataKey != null) {
            mMetadataBuilder.putText(metadataKey, value);
        }
    }
    return this;
}
------------------------
Find a silently evolved API code:android.animation.PropertyValuesHolder.setupStartValue:COMMENT
Method Modifier: default     
Comment:/**
 * This function is called by ObjectAnimator when setting the start values for an animation.
 * The start values are set according to the current values in the target object. The
 * property whose value is extracted is whatever is specified by the propertyName of this
 * PropertyValuesHolder object.
 *
 * @param target The object which holds the start values that should be set.
 */

Body of Frist Method:
{
    setupValue(target, mKeyframeSet.mKeyframes.get(0));
}
Body of Second Method:
{
    ArrayList<Keyframe> keyframes = mKeyframes.getKeyframes();
    if (!keyframes.isEmpty()) {
        setupValue(target, keyframes.get(0));
    }
}
------------------------
Find a silently evolved API code:android.media.RemoteController.MetadataEditor.apply:COMMENT
Method Modifier: public      
Comment:/**
 * Applies all of the metadata changes that have been set since the MediaMetadataEditor
 * instance was created with {@link RemoteController#editMetadata()}
 * or since {@link #clear()} was called.
 */

Body of Frist Method:
{
    // editable key we support: RATING_KEY_BY_USER
    if (!mMetadataChanged) {
        return;
    }
    final int genId;
    synchronized (mGenLock) {
        genId = mClientGenerationIdCurrent;
    }
    synchronized (mInfoLock) {
        if (mEditorMetadata.containsKey(String.valueOf(MediaMetadataEditor.RATING_KEY_BY_USER))) {
            Rating rating = (Rating) getObject(MediaMetadataEditor.RATING_KEY_BY_USER, null);
            mAudioManager.updateRemoteControlClientMetadata(genId, MediaMetadataEditor.RATING_KEY_BY_USER, rating);
        } else {
            Log.e(TAG, "no metadata to apply");
        }
        // NOT setting mApplied to true as this type of MetadataEditor will be applied
        // multiple times, whenever the user of a RemoteController needs to change the
        // metadata (e.g. user changes the rating of a song more than once during playback)
        mApplied = false;
    }
}
Body of Second Method:
{
    // editable key we support: RATING_KEY_BY_USER
    if (!mMetadataChanged) {
        return;
    }
    synchronized (mInfoLock) {
        if (mCurrentSession != null) {
            if (mEditorMetadata.containsKey(String.valueOf(MediaMetadataEditor.RATING_KEY_BY_USER))) {
                Rating rating = (Rating) getObject(MediaMetadataEditor.RATING_KEY_BY_USER, null);
                if (rating != null) {
                    mCurrentSession.getTransportControls().setRating(rating);
                }
            }
        }
    }
    // NOT setting mApplied to true as this type of MetadataEditor will be applied
    // multiple times, whenever the user of a RemoteController needs to change the
    // metadata (e.g. user changes the rating of a song more than once during playback)
    mApplied = false;
}
------------------------
Find a silently evolved API code:android.content.res.BridgeTypedArray.getBoolean:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the boolean value for the attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined.
 *
 * @return Attribute boolean value, or defValue if not defined.
 */

Body of Frist Method:
{
    if (index < 0 || index >= mResourceData.length) {
        return defValue;
    }
    if (mResourceData[index] == null) {
        return defValue;
    }
    String s = mResourceData[index].getValue();
    if (s != null) {
        return XmlUtils.convertValueToBoolean(s, defValue);
    }
    return defValue;
}
Body of Second Method:
{
    String s = getString(index);
    return s == null ? defValue : XmlUtils.convertValueToBoolean(s, defValue);
}
------------------------
Find a silently evolved API code:android.app.Notification.lightenPayload:COMMENT
Method Modifier: public      final       hidden      
Comment:/**
 * Removes heavyweight parts of the Notification object for archival or for sending to
 * listeners when the full contents are not necessary.
 * @hide
 */

Body of Frist Method:
{
    tickerView = null;
    contentView = null;
    bigContentView = null;
    largeIcon = null;
    if (extras != null) {
        extras.remove(Notification.EXTRA_LARGE_ICON);
        extras.remove(Notification.EXTRA_LARGE_ICON_BIG);
        extras.remove(Notification.EXTRA_PICTURE);
    }
}
Body of Second Method:
{
    tickerView = null;
    contentView = null;
    bigContentView = null;
    headsUpContentView = null;
    largeIcon = null;
    if (extras != null) {
        extras.remove(Notification.EXTRA_LARGE_ICON);
        extras.remove(Notification.EXTRA_LARGE_ICON_BIG);
        extras.remove(Notification.EXTRA_PICTURE);
        extras.remove(Notification.EXTRA_BIG_TEXT);
        // Prevent light notifications from being rebuilt.
        extras.remove(Builder.EXTRA_NEEDS_REBUILD);
    }
}
------------------------
Find a silently evolved API code:android.app.SharedPreferencesImpl.writeToFile:COMMENT
Method Modifier: private     
Comment:// Note: must hold mWritingToDiskLock

Body of Frist Method:
{
    // Rename the current file so it may be used as a backup during the next read
    if (mFile.exists()) {
        if (!mcr.changesMade) {
            // If the file already exists, but no changes were
            // made to the underlying map, it's wasteful to
            // re-write the file.  Return as if we wrote it
            // out.
            mcr.setDiskWriteResult(true);
            return;
        }
        if (!mBackupFile.exists()) {
            if (!mFile.renameTo(mBackupFile)) {
                Log.e(TAG, "Couldn't rename file " + mFile + " to backup file " + mBackupFile);
                mcr.setDiskWriteResult(false);
                return;
            }
        } else {
            mFile.delete();
        }
    }
    // from the backup.
    try {
        FileOutputStream str = createFileOutputStream(mFile);
        if (str == null) {
            mcr.setDiskWriteResult(false);
            return;
        }
        XmlUtils.writeMapXml(mcr.mapToWriteToDisk, str);
        FileUtils.sync(str);
        str.close();
        ContextImpl.setFilePermissionsFromMode(mFile.getPath(), mMode, 0);
        try {
            final StructStat stat = Libcore.os.stat(mFile.getPath());
            synchronized (this) {
                mStatTimestamp = stat.st_mtime;
                mStatSize = stat.st_size;
            }
        } catch (ErrnoException e) {
        // Do nothing
        }
        // Writing was successful, delete the backup file if there is one.
        mBackupFile.delete();
        mcr.setDiskWriteResult(true);
        return;
    } catch (XmlPullParserException e) {
        Log.w(TAG, "writeToFile: Got exception:", e);
    } catch (IOException e) {
        Log.w(TAG, "writeToFile: Got exception:", e);
    }
    // Clean up an unsuccessfully written file
    if (mFile.exists()) {
        if (!mFile.delete()) {
            Log.e(TAG, "Couldn't clean up partially-written file " + mFile);
        }
    }
    mcr.setDiskWriteResult(false);
}
Body of Second Method:
{
    // Rename the current file so it may be used as a backup during the next read
    if (mFile.exists()) {
        if (!mcr.changesMade) {
            // If the file already exists, but no changes were
            // made to the underlying map, it's wasteful to
            // re-write the file.  Return as if we wrote it
            // out.
            mcr.setDiskWriteResult(true);
            return;
        }
        if (!mBackupFile.exists()) {
            if (!mFile.renameTo(mBackupFile)) {
                Log.e(TAG, "Couldn't rename file " + mFile + " to backup file " + mBackupFile);
                mcr.setDiskWriteResult(false);
                return;
            }
        } else {
            mFile.delete();
        }
    }
    // from the backup.
    try {
        FileOutputStream str = createFileOutputStream(mFile);
        if (str == null) {
            mcr.setDiskWriteResult(false);
            return;
        }
        XmlUtils.writeMapXml(mcr.mapToWriteToDisk, str);
        FileUtils.sync(str);
        str.close();
        ContextImpl.setFilePermissionsFromMode(mFile.getPath(), mMode, 0);
        try {
            final StructStat stat = Os.stat(mFile.getPath());
            synchronized (this) {
                mStatTimestamp = stat.st_mtime;
                mStatSize = stat.st_size;
            }
        } catch (ErrnoException e) {
        // Do nothing
        }
        // Writing was successful, delete the backup file if there is one.
        mBackupFile.delete();
        mcr.setDiskWriteResult(true);
        return;
    } catch (XmlPullParserException e) {
        Log.w(TAG, "writeToFile: Got exception:", e);
    } catch (IOException e) {
        Log.w(TAG, "writeToFile: Got exception:", e);
    }
    // Clean up an unsuccessfully written file
    if (mFile.exists()) {
        if (!mFile.delete()) {
            Log.e(TAG, "Couldn't clean up partially-written file " + mFile);
        }
    }
    mcr.setDiskWriteResult(false);
}
------------------------
Find a silently evolved API code:android.media.AudioService.sendMasterVolumeUpdate:COMMENT
Method Modifier: private     hidden      
Comment:// UI update and Broadcast Intent

Body of Frist Method:
{
    mVolumePanel.postMasterVolumeChanged(flags);
    Intent intent = new Intent(AudioManager.MASTER_VOLUME_CHANGED_ACTION);
    intent.putExtra(AudioManager.EXTRA_PREV_MASTER_VOLUME_VALUE, oldVolume);
    intent.putExtra(AudioManager.EXTRA_MASTER_VOLUME_VALUE, newVolume);
    sendBroadcastToAll(intent);
}
Body of Second Method:
{
    mVolumeController.postMasterVolumeChanged(flags);
    Intent intent = new Intent(AudioManager.MASTER_VOLUME_CHANGED_ACTION);
    intent.putExtra(AudioManager.EXTRA_PREV_MASTER_VOLUME_VALUE, oldVolume);
    intent.putExtra(AudioManager.EXTRA_MASTER_VOLUME_VALUE, newVolume);
    sendBroadcastToAll(intent);
}
------------------------
Find a silently evolved API code:android.os.Bundle.getByte:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the value associated with the given key, or (byte) 0 if
 * no mapping of the desired type exists for the given key.
 *
 * @param key a String
 * @return a byte value
 */

Body of Frist Method:
{
    unparcel();
    return getByte(key, (byte) 0);
}
Body of Second Method:
{
    return super.getByte(key);
}
------------------------
Find a silently evolved API code:android.view.Window.setGravity:COMMENT
Method Modifier: public      
Comment:/**
 * Set the gravity of the window, as per the Gravity constants.  This
 * controls how the window manager is positioned in the overall window; it
 * is only useful when using WRAP_CONTENT for the layout width or height.
 *
 * @param gravity The desired gravity constant.
 *
 * @see Gravity
 * @see #setLayout
 */

Body of Frist Method:
{
    final WindowManager.LayoutParams attrs = getAttributes();
    attrs.gravity = gravity;
    if (mCallback != null) {
        mCallback.onWindowAttributesChanged(attrs);
    }
}
Body of Second Method:
{
    final WindowManager.LayoutParams attrs = getAttributes();
    attrs.gravity = gravity;
    dispatchWindowAttributesChanged(attrs);
}
------------------------
Find a silently evolved API code:android.widget.ActivityChooserView.Callbacks.onItemClick:COMMENT
Method Modifier: public      
Comment:// AdapterView#OnItemClickListener

Body of Frist Method:
{
    ActivityChooserViewAdapter adapter = (ActivityChooserViewAdapter) parent.getAdapter();
    final int itemViewType = adapter.getItemViewType(position);
    switch(itemViewType) {
        case ActivityChooserViewAdapter.ITEM_VIEW_TYPE_FOOTER:
            {
                showPopupUnchecked(ActivityChooserViewAdapter.MAX_ACTIVITY_COUNT_UNLIMITED);
            }
            break;
        case ActivityChooserViewAdapter.ITEM_VIEW_TYPE_ACTIVITY:
            {
                dismissPopup();
                if (mIsSelectingDefaultActivity) {
                    // The item at position zero is the default already.
                    if (position > 0) {
                        mAdapter.getDataModel().setDefaultActivity(position);
                    }
                } else {
                    // If the default target is not shown in the list, the first
                    // item in the model is default action => adjust index
                    position = mAdapter.getShowDefaultActivity() ? position : position + 1;
                    Intent launchIntent = mAdapter.getDataModel().chooseActivity(position);
                    if (launchIntent != null) {
                        launchIntent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
                        mContext.startActivity(launchIntent);
                    }
                }
            }
            break;
        default:
            throw new IllegalArgumentException();
    }
}
Body of Second Method:
{
    ActivityChooserViewAdapter adapter = (ActivityChooserViewAdapter) parent.getAdapter();
    final int itemViewType = adapter.getItemViewType(position);
    switch(itemViewType) {
        case ActivityChooserViewAdapter.ITEM_VIEW_TYPE_FOOTER:
            {
                showPopupUnchecked(ActivityChooserViewAdapter.MAX_ACTIVITY_COUNT_UNLIMITED);
            }
            break;
        case ActivityChooserViewAdapter.ITEM_VIEW_TYPE_ACTIVITY:
            {
                dismissPopup();
                if (mIsSelectingDefaultActivity) {
                    // The item at position zero is the default already.
                    if (position > 0) {
                        mAdapter.getDataModel().setDefaultActivity(position);
                    }
                } else {
                    // If the default target is not shown in the list, the first
                    // item in the model is default action => adjust index
                    position = mAdapter.getShowDefaultActivity() ? position : position + 1;
                    Intent launchIntent = mAdapter.getDataModel().chooseActivity(position);
                    if (launchIntent != null) {
                        launchIntent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
                        ResolveInfo resolveInfo = mAdapter.getDataModel().getActivity(position);
                        startActivity(launchIntent, resolveInfo);
                    }
                }
            }
            break;
        default:
            throw new IllegalArgumentException();
    }
}
------------------------
Find a silently evolved API code:android.widget.ProgressBar.tileify:COMMENT
Method Modifier: private     
Comment:/**
 * Converts a drawable to a tiled version of itself. It will recursively
 * traverse layer and state list drawables.
 */

Body of Frist Method:
{
    if (drawable instanceof LayerDrawable) {
        LayerDrawable background = (LayerDrawable) drawable;
        final int N = background.getNumberOfLayers();
        Drawable[] outDrawables = new Drawable[N];
        for (int i = 0; i < N; i++) {
            int id = background.getId(i);
            outDrawables[i] = tileify(background.getDrawable(i), (id == R.id.progress || id == R.id.secondaryProgress));
        }
        LayerDrawable newBg = new LayerDrawable(outDrawables);
        for (int i = 0; i < N; i++) {
            newBg.setId(i, background.getId(i));
        }
        return newBg;
    } else if (drawable instanceof StateListDrawable) {
        StateListDrawable in = (StateListDrawable) drawable;
        StateListDrawable out = new StateListDrawable();
        int numStates = in.getStateCount();
        for (int i = 0; i < numStates; i++) {
            out.addState(in.getStateSet(i), tileify(in.getStateDrawable(i), clip));
        }
        return out;
    } else if (drawable instanceof BitmapDrawable) {
        final Bitmap tileBitmap = ((BitmapDrawable) drawable).getBitmap();
        if (mSampleTile == null) {
            mSampleTile = tileBitmap;
        }
        final ShapeDrawable shapeDrawable = new ShapeDrawable(getDrawableShape());
        final BitmapShader bitmapShader = new BitmapShader(tileBitmap, Shader.TileMode.REPEAT, Shader.TileMode.CLAMP);
        shapeDrawable.getPaint().setShader(bitmapShader);
        return (clip) ? new ClipDrawable(shapeDrawable, Gravity.LEFT, ClipDrawable.HORIZONTAL) : shapeDrawable;
    }
    return drawable;
}
Body of Second Method:
{
    if (drawable instanceof LayerDrawable) {
        LayerDrawable background = (LayerDrawable) drawable;
        final int N = background.getNumberOfLayers();
        Drawable[] outDrawables = new Drawable[N];
        for (int i = 0; i < N; i++) {
            int id = background.getId(i);
            outDrawables[i] = tileify(background.getDrawable(i), (id == R.id.progress || id == R.id.secondaryProgress));
        }
        LayerDrawable newBg = new LayerDrawable(outDrawables);
        for (int i = 0; i < N; i++) {
            newBg.setId(i, background.getId(i));
        }
        return newBg;
    } else if (drawable instanceof StateListDrawable) {
        StateListDrawable in = (StateListDrawable) drawable;
        StateListDrawable out = new StateListDrawable();
        int numStates = in.getStateCount();
        for (int i = 0; i < numStates; i++) {
            out.addState(in.getStateSet(i), tileify(in.getStateDrawable(i), clip));
        }
        return out;
    } else if (drawable instanceof BitmapDrawable) {
        final BitmapDrawable bitmap = (BitmapDrawable) drawable;
        final Bitmap tileBitmap = bitmap.getBitmap();
        if (mSampleTile == null) {
            mSampleTile = tileBitmap;
        }
        final ShapeDrawable shapeDrawable = new ShapeDrawable(getDrawableShape());
        final BitmapShader bitmapShader = new BitmapShader(tileBitmap, Shader.TileMode.REPEAT, Shader.TileMode.CLAMP);
        shapeDrawable.getPaint().setShader(bitmapShader);
        // Ensure the tint and filter are propagated in the correct order.
        shapeDrawable.setTintList(bitmap.getTint());
        shapeDrawable.setTintMode(bitmap.getTintMode());
        shapeDrawable.setColorFilter(bitmap.getColorFilter());
        return clip ? new ClipDrawable(shapeDrawable, Gravity.LEFT, ClipDrawable.HORIZONTAL) : shapeDrawable;
    }
    return drawable;
}
------------------------
Find a silently evolved API code:android.widget.ActivityChooserView.Callbacks.onClick:COMMENT
Method Modifier: public      
Comment:// View.OnClickListener

Body of Frist Method:
{
    if (view == mDefaultActivityButton) {
        dismissPopup();
        ResolveInfo defaultActivity = mAdapter.getDefaultActivity();
        final int index = mAdapter.getDataModel().getActivityIndex(defaultActivity);
        Intent launchIntent = mAdapter.getDataModel().chooseActivity(index);
        if (launchIntent != null) {
            launchIntent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
            mContext.startActivity(launchIntent);
        }
    } else if (view == mExpandActivityOverflowButton) {
        mIsSelectingDefaultActivity = false;
        showPopupUnchecked(mInitialActivityCount);
    } else {
        throw new IllegalArgumentException();
    }
}
Body of Second Method:
{
    if (view == mDefaultActivityButton) {
        dismissPopup();
        ResolveInfo defaultActivity = mAdapter.getDefaultActivity();
        final int index = mAdapter.getDataModel().getActivityIndex(defaultActivity);
        Intent launchIntent = mAdapter.getDataModel().chooseActivity(index);
        if (launchIntent != null) {
            launchIntent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);
            startActivity(launchIntent, defaultActivity);
        }
    } else if (view == mExpandActivityOverflowButton) {
        mIsSelectingDefaultActivity = false;
        showPopupUnchecked(mInitialActivityCount);
    } else {
        throw new IllegalArgumentException();
    }
}
------------------------
Find a silently evolved API code:android.graphics.Picture.beginRecording:COMMENT
Method Modifier: public      
Comment:/**
 * To record a picture, call beginRecording() and then draw into the Canvas
 * that is returned. Nothing we appear on screen, but all of the draw
 * commands (e.g. {@link Canvas#drawRect(Rect, Paint)}) will be recorded.
 * To stop recording, call endRecording(). After endRecording() the Canvas
 * that was returned must no longer be used, and nothing should be drawn
 * into it.
 */

Body of Frist Method:
{
    int ni = nativeBeginRecording(mNativePicture, width, height);
    mRecordingCanvas = new RecordingCanvas(this, ni);
    return mRecordingCanvas;
}
Body of Second Method:
{
    long ni = nativeBeginRecording(mNativePicture, width, height);
    mRecordingCanvas = new RecordingCanvas(this, ni);
    return mRecordingCanvas;
}
------------------------
Find a silently evolved API code:android.media.RemoteController.getRemoteControlClientPackageName:COMMENT
<android.media.RemoteController: String getRemoteControlClientPackageName()>
public      hidden      ->public      hidden      deprecated  
Method Modifier: public      hidden      deprecated  
Method Modifier: Yes         Yes         No          
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return mClientPendingIntentCurrent != null ? mClientPendingIntentCurrent.getCreatorPackage() : null;
}
Body of Second Method:
{
    if (USE_SESSIONS) {
        synchronized (mInfoLock) {
            return mCurrentSession != null ? mCurrentSession.getPackageName() : null;
        }
    } else {
        return mClientPendingIntentCurrent != null ? mClientPendingIntentCurrent.getCreatorPackage() : null;
    }
}
------------------------
Find a silently evolved API code:android.hardware.SensorManager.getQuaternionFromVector:COMMENT
Method Modifier: public      static      
Comment:/**
 * Helper function to convert a rotation vector to a normalized quaternion.
 * Given a rotation vector (presumably from a ROTATION_VECTOR sensor), returns a normalized
 * quaternion in the array Q.  The quaternion is stored as [w, x, y, z]
 * @param rv the rotation vector to convert
 * @param Q an array of floats in which to store the computed quaternion
 */

Body of Frist Method:
{
    if (rv.length == 4) {
        Q[0] = rv[3];
    } else {
        Q[0] = 1 - rv[0] * rv[0] - rv[1] * rv[1] - rv[2] * rv[2];
        Q[0] = (Q[0] > 0) ? (float) Math.sqrt(Q[0]) : 0;
    }
    Q[1] = rv[0];
    Q[2] = rv[1];
    Q[3] = rv[2];
}
Body of Second Method:
{
    if (rv.length >= 4) {
        Q[0] = rv[3];
    } else {
        Q[0] = 1 - rv[0] * rv[0] - rv[1] * rv[1] - rv[2] * rv[2];
        Q[0] = (Q[0] > 0) ? (float) Math.sqrt(Q[0]) : 0;
    }
    Q[1] = rv[0];
    Q[2] = rv[1];
    Q[3] = rv[2];
}
------------------------
Find a silently evolved API code:android.content.res.BridgeTypedArray.hasValue:COMMENT
Method Modifier: public      
Comment:/**
 * Determines whether there is an attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return True if the attribute has a value, false otherwise.
 */

Body of Frist Method:
{
    if (index < 0 || index >= mResourceData.length) {
        return false;
    }
    return mResourceData[index] != null;
}
Body of Second Method:
{
    return index >= 0 && index < mResourceData.length && mResourceData[index] != null;
}
------------------------
Find a silently evolved API code:android.service.dreams.DreamService.dispatchKeyShortcutEvent:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (!mInteractive) {
        if (mDebug)
            Slog.v(TAG, "Finishing on keyShortcutEvent");
        safelyFinish();
        return true;
    }
    return mWindow.superDispatchKeyShortcutEvent(event);
}
Body of Second Method:
{
    if (!mInteractive) {
        if (mDebug)
            Slog.v(TAG, "Waking up on keyShortcutEvent");
        wakeUp();
        return true;
    }
    return mWindow.superDispatchKeyShortcutEvent(event);
}
------------------------
Find a silently evolved API code:android.widget.TextView.sendAfterTextChanged:COMMENT
Method Modifier: default     
Comment:/**
 * Not private so it can be called from an inner class without going
 * through a thunk.
 */

Body of Frist Method:
{
    if (mListeners != null) {
        final ArrayList<TextWatcher> list = mListeners;
        final int count = list.size();
        for (int i = 0; i < count; i++) {
            list.get(i).afterTextChanged(text);
        }
    }
}
Body of Second Method:
{
    if (mListeners != null) {
        final ArrayList<TextWatcher> list = mListeners;
        final int count = list.size();
        for (int i = 0; i < count; i++) {
            list.get(i).afterTextChanged(text);
        }
    }
    hideErrorIfUnchanged();
}
------------------------
Find a silently evolved API code:android.media.AudioService.setMode:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @see AudioManager#setMode(int)
 */

Body of Frist Method:
{
    if (!checkAudioSettingsPermission("setMode()")) {
        return;
    }
    if (mode < AudioSystem.MODE_CURRENT || mode >= AudioSystem.NUM_MODES) {
        return;
    }
    int newModeOwnerPid = 0;
    synchronized (mSetModeDeathHandlers) {
        if (mode == AudioSystem.MODE_CURRENT) {
            mode = mMode;
        }
        newModeOwnerPid = setModeInt(mode, cb, Binder.getCallingPid());
    }
    // SCO connections not started by the application changing the mode
    if (newModeOwnerPid != 0) {
        disconnectBluetoothSco(newModeOwnerPid);
    }
}
Body of Second Method:
{
    if (DEBUG_MODE) {
        Log.v(TAG, "setMode(mode=" + mode + ")");
    }
    if (!checkAudioSettingsPermission("setMode()")) {
        return;
    }
    if ((mode == AudioSystem.MODE_IN_CALL) && (mContext.checkCallingOrSelfPermission(android.Manifest.permission.MODIFY_PHONE_STATE) != PackageManager.PERMISSION_GRANTED)) {
        Log.w(TAG, "MODIFY_PHONE_STATE Permission Denial: setMode(MODE_IN_CALL) from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid());
        return;
    }
    if (mode < AudioSystem.MODE_CURRENT || mode >= AudioSystem.NUM_MODES) {
        return;
    }
    int newModeOwnerPid = 0;
    synchronized (mSetModeDeathHandlers) {
        if (mode == AudioSystem.MODE_CURRENT) {
            mode = mMode;
        }
        newModeOwnerPid = setModeInt(mode, cb, Binder.getCallingPid());
    }
    // SCO connections not started by the application changing the mode
    if (newModeOwnerPid != 0) {
        disconnectBluetoothSco(newModeOwnerPid);
    }
}
------------------------
Find a silently evolved API code:android.media.MediaRouter.UserRouteInfo.setVolumeHandling:COMMENT
Method Modifier: public      
Comment:/**
 * Defines whether volume for the playback associated with this route is fixed
 * ({@link RouteInfo#PLAYBACK_VOLUME_FIXED}) or can modified
 * ({@link RouteInfo#PLAYBACK_VOLUME_VARIABLE}).
 * @param volumeHandling
 */

Body of Frist Method:
{
    if (mVolumeHandling != volumeHandling) {
        mVolumeHandling = volumeHandling;
        setPlaybackInfoOnRcc(RemoteControlClient.PLAYBACKINFO_VOLUME_HANDLING, volumeHandling);
    }
}
Body of Second Method:
{
    if (mVolumeHandling != volumeHandling) {
        mVolumeHandling = volumeHandling;
        configureSessionVolume();
    }
}
------------------------
Find a silently evolved API code:android.content.res.TypedArray.getDimension:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve a dimensional unit attribute at <var>index</var>.  Unit
 * conversions are based on the current {@link DisplayMetrics}
 * associated with the resources this {@link TypedArray} object
 * came from.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute dimension value multiplied by the appropriate
 * metric, or defValue if not defined.
 *
 * @see #getDimensionPixelOffset
 * @see #getDimensionPixelSize
 */

Body of Frist Method:
{
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimension(data[index + AssetManager.STYLE_DATA], mResources.mMetrics);
    }
    throw new UnsupportedOperationException("Can't convert to dimension: type=0x" + Integer.toHexString(type));
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimension(data[index + AssetManager.STYLE_DATA], mMetrics);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        throw new RuntimeException("Failed to resolve attribute at index " + index);
    }
    throw new UnsupportedOperationException("Can't convert to dimension: type=0x" + Integer.toHexString(type));
}
------------------------
Find a silently evolved API code:android.os.ParcelFileDescriptor.createPipe:COMMENT
Method Modifier: public      static      
Comment:/**
 * Create two ParcelFileDescriptors structured as a data pipe.  The first
 * ParcelFileDescriptor in the returned array is the read side; the second
 * is the write side.
 */

Body of Frist Method:
{
    try {
        final FileDescriptor[] fds = Libcore.os.pipe();
        return new ParcelFileDescriptor[] { new ParcelFileDescriptor(fds[0]), new ParcelFileDescriptor(fds[1]) };
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
}
Body of Second Method:
{
    try {
        final FileDescriptor[] fds = Os.pipe();
        return new ParcelFileDescriptor[] { new ParcelFileDescriptor(fds[0]), new ParcelFileDescriptor(fds[1]) };
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
}
------------------------
Find a silently evolved API code:android.hardware.SystemSensorManager.registerListenerImpl:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (listener == null || sensor == null) {
        Log.e(TAG, "sensor or listener is null");
        return false;
    }
    // Trigger Sensors should use the requestTriggerSensor call.
    if (Sensor.getReportingMode(sensor) == Sensor.REPORTING_MODE_ONE_SHOT) {
        Log.e(TAG, "Trigger Sensors should use the requestTriggerSensor.");
        return false;
    }
    if (maxBatchReportLatencyUs < 0 || delayUs < 0) {
        Log.e(TAG, "maxBatchReportLatencyUs and delayUs should be non-negative");
        return false;
    }
    // We map SensorEventListener to a SensorEventQueue, which holds the looper
    synchronized (mSensorListeners) {
        SensorEventQueue queue = mSensorListeners.get(listener);
        if (queue == null) {
            Looper looper = (handler != null) ? handler.getLooper() : mMainLooper;
            queue = new SensorEventQueue(listener, looper, this);
            if (!queue.addSensor(sensor, delayUs, maxBatchReportLatencyUs, reservedFlags)) {
                queue.dispose();
                return false;
            }
            mSensorListeners.put(listener, queue);
            return true;
        } else {
            return queue.addSensor(sensor, delayUs, maxBatchReportLatencyUs, reservedFlags);
        }
    }
}
Body of Second Method:
{
    if (listener == null || sensor == null) {
        Log.e(TAG, "sensor or listener is null");
        return false;
    }
    // Trigger Sensors should use the requestTriggerSensor call.
    if (sensor.getReportingMode() == Sensor.REPORTING_MODE_ONE_SHOT) {
        Log.e(TAG, "Trigger Sensors should use the requestTriggerSensor.");
        return false;
    }
    if (maxBatchReportLatencyUs < 0 || delayUs < 0) {
        Log.e(TAG, "maxBatchReportLatencyUs and delayUs should be non-negative");
        return false;
    }
    // We map SensorEventListener to a SensorEventQueue, which holds the looper
    synchronized (mSensorListeners) {
        SensorEventQueue queue = mSensorListeners.get(listener);
        if (queue == null) {
            Looper looper = (handler != null) ? handler.getLooper() : mMainLooper;
            queue = new SensorEventQueue(listener, looper, this);
            if (!queue.addSensor(sensor, delayUs, maxBatchReportLatencyUs, reservedFlags)) {
                queue.dispose();
                return false;
            }
            mSensorListeners.put(listener, queue);
            return true;
        } else {
            return queue.addSensor(sensor, delayUs, maxBatchReportLatencyUs, reservedFlags);
        }
    }
}
------------------------
Find a silently evolved API code:android.provider.Browser.deleteHistoryWhere:COMMENT
Method Modifier: private     static      final       
Comment:/**
 * Helper function to delete all history items and release the icons for them in the
 * {@link WebIconDatabase}.
 *
 * Requires {@link android.Manifest.permission#READ_HISTORY_BOOKMARKS}
 * Requires {@link android.Manifest.permission#WRITE_HISTORY_BOOKMARKS}
 *
 * @param cr   The ContentResolver used to access the database.
 * @param whereClause   String to limit the items affected.
 * null means all items.
 */

Body of Frist Method:
{
    Cursor cursor = null;
    try {
        cursor = cr.query(History.CONTENT_URI, new String[] { History.URL }, whereClause, null, null);
        if (cursor.moveToFirst()) {
            final WebIconDatabase iconDb = WebIconDatabase.getInstance();
            do {
                // Delete favicons
                // TODO don't release if the URL is bookmarked
                iconDb.releaseIconForPageUrl(cursor.getString(0));
            } while (cursor.moveToNext());
            cr.delete(History.CONTENT_URI, whereClause, null);
        }
    } catch (IllegalStateException e) {
        Log.e(LOGTAG, "deleteHistoryWhere", e);
        return;
    } finally {
        if (cursor != null)
            cursor.close();
    }
}
Body of Second Method:
{
    Cursor cursor = null;
    try {
        cursor = cr.query(History.CONTENT_URI, new String[] { History.URL }, whereClause, null, null);
        if (cursor.moveToFirst()) {
            cr.delete(History.CONTENT_URI, whereClause, null);
        }
    } catch (IllegalStateException e) {
        Log.e(LOGTAG, "deleteHistoryWhere", e);
        return;
    } finally {
        if (cursor != null)
            cursor.close();
    }
}
------------------------
Find a silently evolved API code:android.util.SparseBooleanArray.put:COMMENT
Method Modifier: public      
Comment:/**
 * Adds a mapping from the specified key to the specified value,
 * replacing the previous mapping from the specified key if there
 * was one.
 */

Body of Frist Method:
{
    int i = ContainerHelpers.binarySearch(mKeys, mSize, key);
    if (i >= 0) {
        mValues[i] = value;
    } else {
        i = ~i;
        if (mSize >= mKeys.length) {
            int n = ArrayUtils.idealIntArraySize(mSize + 1);
            int[] nkeys = new int[n];
            boolean[] nvalues = new boolean[n];
            // Log.e("SparseBooleanArray", "grow " + mKeys.length + " to " + n);
            System.arraycopy(mKeys, 0, nkeys, 0, mKeys.length);
            System.arraycopy(mValues, 0, nvalues, 0, mValues.length);
            mKeys = nkeys;
            mValues = nvalues;
        }
        if (mSize - i != 0) {
            // Log.e("SparseBooleanArray", "move " + (mSize - i));
            System.arraycopy(mKeys, i, mKeys, i + 1, mSize - i);
            System.arraycopy(mValues, i, mValues, i + 1, mSize - i);
        }
        mKeys[i] = key;
        mValues[i] = value;
        mSize++;
    }
}
Body of Second Method:
{
    int i = ContainerHelpers.binarySearch(mKeys, mSize, key);
    if (i >= 0) {
        mValues[i] = value;
    } else {
        i = ~i;
        mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);
        mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);
        mSize++;
    }
}
------------------------
Find a silently evolved API code:android.ddm.DdmHandleProfiling.handleMPSS:COMMENT
Method Modifier: private     
Comment:/*
     * Handle a "Method Profiling w/Streaming Start" request.
     */

Body of Frist Method:
{
    ByteBuffer in = wrapChunk(request);
    int bufferSize = in.getInt();
    int flags = in.getInt();
    if (false) {
        Log.v("ddm-heap", "Method prof stream start: size=" + bufferSize + ", flags=" + flags);
    }
    try {
        Debug.startMethodTracingDdms(bufferSize, flags, false, 0);
        // empty response
        return null;
    } catch (RuntimeException re) {
        return createFailChunk(1, re.getMessage());
    }
}
Body of Second Method:
{
    ByteBuffer in = wrapChunk(request);
    int bufferSize = in.getInt();
    int flags = in.getInt();
    if (DEBUG) {
        Log.v("ddm-heap", "Method prof stream start: size=" + bufferSize + ", flags=" + flags);
    }
    try {
        Debug.startMethodTracingDdms(bufferSize, flags, false, 0);
        // empty response
        return null;
    } catch (RuntimeException re) {
        return createFailChunk(1, re.getMessage());
    }
}
------------------------
Find a silently evolved API code:android.media.RemoteControlClient.setOnGetPlaybackPositionListener:COMMENT
<android.media.RemoteControlClient: void setOnGetPlaybackPositionListener(OnGetPlaybackPositionListener)>
public      ->public      deprecated  
Method Modifier: public      deprecated  
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Sets the listener to be called whenever the media current playback position is needed.
 * Queries will be received in the same thread as the one in which RemoteControlClient
 * was created.
 * @param l the listener to be called to retrieve the playback position
 */

Body of Frist Method:
{
    synchronized (mCacheLock) {
        int oldCapa = mPlaybackPositionCapabilities;
        if (l != null) {
            mPlaybackPositionCapabilities |= MEDIA_POSITION_READABLE;
        } else {
            mPlaybackPositionCapabilities &= ~MEDIA_POSITION_READABLE;
        }
        mPositionProvider = l;
        if (oldCapa != mPlaybackPositionCapabilities) {
            // tell RCDs that this RCC's playback position capabilities have changed
            sendTransportControlInfo_syncCacheLock(null);
        }
        if ((mPositionProvider != null) && (mEventHandler != null) && playbackPositionShouldMove(mPlaybackState)) {
            // playback position is already moving, but now we have a position provider,
            // so schedule a drift check right now
            mEventHandler.sendMessageDelayed(mEventHandler.obtainMessage(MSG_POSITION_DRIFT_CHECK), 0);
        }
    }
}
Body of Second Method:
{
    synchronized (mCacheLock) {
        mPositionProvider = l;
        if ((mPositionProvider != null) && (mEventHandler != null) && playbackPositionShouldMove(mPlaybackState)) {
            // playback position is already moving, but now we have a position provider,
            // so schedule a drift check right now
            mEventHandler.sendMessageDelayed(mEventHandler.obtainMessage(MSG_POSITION_DRIFT_CHECK), 0);
        }
    }
}
------------------------
Find a silently evolved API code:android.os.RecoverySystem.verifyPackage:COMMENT
Method Modifier: public      static      
Comment:/**
 * Verify the cryptographic signature of a system update package
 * before installing it.  Note that the package is also verified
 * separately by the installer once the device is rebooted into
 * the recovery system.  This function will return only if the
 * package was successfully verified; otherwise it will throw an
 * exception.
 *
 * Verification of a package can take significant time, so this
 * function should not be called from a UI thread.  Interrupting
 * the thread while this function is in progress will result in a
 * SecurityException being thrown (and the thread's interrupt flag
 * will be cleared).
 *
 * @param packageFile  the package to be verified
 * @param listener     an object to receive periodic progress
 * updates as verification proceeds.  May be null.
 * @param deviceCertsZipFile  the zip file of certificates whose
 * public keys we will accept.  Verification succeeds if the
 * package is signed by the private key corresponding to any
 * public key in this file.  May be null to use the system default
 * file (currently "/system/etc/security/otacerts.zip").
 *
 * @throws IOException if there were any errors reading the
 * package or certs files.
 * @throws GeneralSecurityException if verification failed
 */

Body of Frist Method:
{
    long fileLen = packageFile.length();
    RandomAccessFile raf = new RandomAccessFile(packageFile, "r");
    try {
        int lastPercent = 0;
        long lastPublishTime = System.currentTimeMillis();
        if (listener != null) {
            listener.onProgress(lastPercent);
        }
        raf.seek(fileLen - 6);
        byte[] footer = new byte[6];
        raf.readFully(footer);
        if (footer[2] != (byte) 0xff || footer[3] != (byte) 0xff) {
            throw new SignatureException("no signature in file (no footer)");
        }
        int commentSize = (footer[4] & 0xff) | ((footer[5] & 0xff) << 8);
        int signatureStart = (footer[0] & 0xff) | ((footer[1] & 0xff) << 8);
        byte[] eocd = new byte[commentSize + 22];
        raf.seek(fileLen - (commentSize + 22));
        raf.readFully(eocd);
        // end-of-central-directory record.
        if (eocd[0] != (byte) 0x50 || eocd[1] != (byte) 0x4b || eocd[2] != (byte) 0x05 || eocd[3] != (byte) 0x06) {
            throw new SignatureException("no signature in file (bad footer)");
        }
        for (int i = 4; i < eocd.length - 3; ++i) {
            if (eocd[i] == (byte) 0x50 && eocd[i + 1] == (byte) 0x4b && eocd[i + 2] == (byte) 0x05 && eocd[i + 3] == (byte) 0x06) {
                throw new SignatureException("EOCD marker found after start of EOCD");
            }
        }
        // The following code is largely copied from
        // JarUtils.verifySignature().  We could just *call* that
        // method here if that function didn't read the entire
        // input (ie, the whole OTA package) into memory just to
        // compute its message digest.
        BerInputStream bis = new BerInputStream(new ByteArrayInputStream(eocd, commentSize + 22 - signatureStart, signatureStart));
        ContentInfo info = (ContentInfo) ContentInfo.ASN1.decode(bis);
        SignedData signedData = info.getSignedData();
        if (signedData == null) {
            throw new IOException("signedData is null");
        }
        Collection encCerts = signedData.getCertificates();
        if (encCerts.isEmpty()) {
            throw new IOException("encCerts is empty");
        }
        // Take the first certificate from the signature (packages
        // should contain only one).
        Iterator it = encCerts.iterator();
        X509Certificate cert = null;
        if (it.hasNext()) {
            cert = new X509CertImpl((org.apache.harmony.security.x509.Certificate) it.next());
        } else {
            throw new SignatureException("signature contains no certificates");
        }
        List sigInfos = signedData.getSignerInfos();
        SignerInfo sigInfo;
        if (!sigInfos.isEmpty()) {
            sigInfo = (SignerInfo) sigInfos.get(0);
        } else {
            throw new IOException("no signer infos!");
        }
        // Check that the public key of the certificate contained
        // in the package equals one of our trusted public keys.
        HashSet<Certificate> trusted = getTrustedCerts(deviceCertsZipFile == null ? DEFAULT_KEYSTORE : deviceCertsZipFile);
        PublicKey signatureKey = cert.getPublicKey();
        boolean verified = false;
        for (Certificate c : trusted) {
            if (c.getPublicKey().equals(signatureKey)) {
                verified = true;
                break;
            }
        }
        if (!verified) {
            throw new SignatureException("signature doesn't match any trusted key");
        }
        // The signature cert matches a trusted key.  Now verify that
        // the digest in the cert matches the actual file data.
        // The verifier in recovery only handles SHA1withRSA and
        // SHA256withRSA signatures.  SignApk chooses which to use
        // based on the signature algorithm of the cert:
        // 
        // "SHA256withRSA" cert -> "SHA256withRSA" signature
        // "SHA1withRSA" cert   -> "SHA1withRSA" signature
        // "MD5withRSA" cert    -> "SHA1withRSA" signature (for backwards compatibility)
        // any other cert       -> SignApk fails
        // 
        // Here we ignore whatever the cert says, and instead use
        // whatever algorithm is used by the signature.
        String da = sigInfo.getDigestAlgorithm();
        String dea = sigInfo.getDigestEncryptionAlgorithm();
        String alg = null;
        if (da == null || dea == null) {
            // fall back to the cert algorithm if the sig one
            // doesn't look right.
            alg = cert.getSigAlgName();
        } else {
            alg = da + "with" + dea;
        }
        Signature sig = Signature.getInstance(alg);
        sig.initVerify(cert);
        // The signature covers all of the OTA package except the
        // archive comment and its 2-byte length.
        long toRead = fileLen - commentSize - 2;
        long soFar = 0;
        raf.seek(0);
        byte[] buffer = new byte[4096];
        boolean interrupted = false;
        while (soFar < toRead) {
            interrupted = Thread.interrupted();
            if (interrupted)
                break;
            int size = buffer.length;
            if (soFar + size > toRead) {
                size = (int) (toRead - soFar);
            }
            int read = raf.read(buffer, 0, size);
            sig.update(buffer, 0, read);
            soFar += read;
            if (listener != null) {
                long now = System.currentTimeMillis();
                int p = (int) (soFar * 100 / toRead);
                if (p > lastPercent && now - lastPublishTime > PUBLISH_PROGRESS_INTERVAL_MS) {
                    lastPercent = p;
                    lastPublishTime = now;
                    listener.onProgress(lastPercent);
                }
            }
        }
        if (listener != null) {
            listener.onProgress(100);
        }
        if (interrupted) {
            throw new SignatureException("verification was interrupted");
        }
        if (!sig.verify(sigInfo.getEncryptedDigest())) {
            throw new SignatureException("signature digest verification failed");
        }
    } finally {
        raf.close();
    }
}
Body of Second Method:
{
    long fileLen = packageFile.length();
    RandomAccessFile raf = new RandomAccessFile(packageFile, "r");
    try {
        int lastPercent = 0;
        long lastPublishTime = System.currentTimeMillis();
        if (listener != null) {
            listener.onProgress(lastPercent);
        }
        raf.seek(fileLen - 6);
        byte[] footer = new byte[6];
        raf.readFully(footer);
        if (footer[2] != (byte) 0xff || footer[3] != (byte) 0xff) {
            throw new SignatureException("no signature in file (no footer)");
        }
        int commentSize = (footer[4] & 0xff) | ((footer[5] & 0xff) << 8);
        int signatureStart = (footer[0] & 0xff) | ((footer[1] & 0xff) << 8);
        byte[] eocd = new byte[commentSize + 22];
        raf.seek(fileLen - (commentSize + 22));
        raf.readFully(eocd);
        // end-of-central-directory record.
        if (eocd[0] != (byte) 0x50 || eocd[1] != (byte) 0x4b || eocd[2] != (byte) 0x05 || eocd[3] != (byte) 0x06) {
            throw new SignatureException("no signature in file (bad footer)");
        }
        for (int i = 4; i < eocd.length - 3; ++i) {
            if (eocd[i] == (byte) 0x50 && eocd[i + 1] == (byte) 0x4b && eocd[i + 2] == (byte) 0x05 && eocd[i + 3] == (byte) 0x06) {
                throw new SignatureException("EOCD marker found after start of EOCD");
            }
        }
        // The following code is largely copied from
        // JarUtils.verifySignature().  We could just *call* that
        // method here if that function didn't read the entire
        // input (ie, the whole OTA package) into memory just to
        // compute its message digest.
        BerInputStream bis = new BerInputStream(new ByteArrayInputStream(eocd, commentSize + 22 - signatureStart, signatureStart));
        ContentInfo info = (ContentInfo) ContentInfo.ASN1.decode(bis);
        SignedData signedData = info.getSignedData();
        if (signedData == null) {
            throw new IOException("signedData is null");
        }
        List<Certificate> encCerts = signedData.getCertificates();
        if (encCerts.isEmpty()) {
            throw new IOException("encCerts is empty");
        }
        // Take the first certificate from the signature (packages
        // should contain only one).
        Iterator<Certificate> it = encCerts.iterator();
        X509Certificate cert = null;
        if (it.hasNext()) {
            CertificateFactory cf = CertificateFactory.getInstance("X.509");
            InputStream is = new ByteArrayInputStream(it.next().getEncoded());
            cert = (X509Certificate) cf.generateCertificate(is);
        } else {
            throw new SignatureException("signature contains no certificates");
        }
        List<SignerInfo> sigInfos = signedData.getSignerInfos();
        SignerInfo sigInfo;
        if (!sigInfos.isEmpty()) {
            sigInfo = (SignerInfo) sigInfos.get(0);
        } else {
            throw new IOException("no signer infos!");
        }
        // Check that the public key of the certificate contained
        // in the package equals one of our trusted public keys.
        HashSet<X509Certificate> trusted = getTrustedCerts(deviceCertsZipFile == null ? DEFAULT_KEYSTORE : deviceCertsZipFile);
        PublicKey signatureKey = cert.getPublicKey();
        boolean verified = false;
        for (X509Certificate c : trusted) {
            if (c.getPublicKey().equals(signatureKey)) {
                verified = true;
                break;
            }
        }
        if (!verified) {
            throw new SignatureException("signature doesn't match any trusted key");
        }
        // The signature cert matches a trusted key.  Now verify that
        // the digest in the cert matches the actual file data.
        // The verifier in recovery only handles SHA1withRSA and
        // SHA256withRSA signatures.  SignApk chooses which to use
        // based on the signature algorithm of the cert:
        // 
        // "SHA256withRSA" cert -> "SHA256withRSA" signature
        // "SHA1withRSA" cert   -> "SHA1withRSA" signature
        // "MD5withRSA" cert    -> "SHA1withRSA" signature (for backwards compatibility)
        // any other cert       -> SignApk fails
        // 
        // Here we ignore whatever the cert says, and instead use
        // whatever algorithm is used by the signature.
        String da = sigInfo.getDigestAlgorithm();
        String dea = sigInfo.getDigestEncryptionAlgorithm();
        String alg = null;
        if (da == null || dea == null) {
            // fall back to the cert algorithm if the sig one
            // doesn't look right.
            alg = cert.getSigAlgName();
        } else {
            alg = da + "with" + dea;
        }
        Signature sig = Signature.getInstance(alg);
        sig.initVerify(cert);
        // The signature covers all of the OTA package except the
        // archive comment and its 2-byte length.
        long toRead = fileLen - commentSize - 2;
        long soFar = 0;
        raf.seek(0);
        byte[] buffer = new byte[4096];
        boolean interrupted = false;
        while (soFar < toRead) {
            interrupted = Thread.interrupted();
            if (interrupted)
                break;
            int size = buffer.length;
            if (soFar + size > toRead) {
                size = (int) (toRead - soFar);
            }
            int read = raf.read(buffer, 0, size);
            sig.update(buffer, 0, read);
            soFar += read;
            if (listener != null) {
                long now = System.currentTimeMillis();
                int p = (int) (soFar * 100 / toRead);
                if (p > lastPercent && now - lastPublishTime > PUBLISH_PROGRESS_INTERVAL_MS) {
                    lastPercent = p;
                    lastPublishTime = now;
                    listener.onProgress(lastPercent);
                }
            }
        }
        if (listener != null) {
            listener.onProgress(100);
        }
        if (interrupted) {
            throw new SignatureException("verification was interrupted");
        }
        if (!sig.verify(sigInfo.getEncryptedDigest())) {
            throw new SignatureException("signature digest verification failed");
        }
    } finally {
        raf.close();
    }
}
------------------------
Find a silently evolved API code:android.widget.DatePicker.setMaxDate:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the maximal date supported by this {@link DatePicker} in
 * milliseconds since January 1, 1970 00:00:00 in
 * {@link TimeZone#getDefault()} time zone.
 *
 * @param maxDate The maximal supported date.
 */

Body of Frist Method:
{
    mTempDate.setTimeInMillis(maxDate);
    if (mTempDate.get(Calendar.YEAR) == mMaxDate.get(Calendar.YEAR) && mTempDate.get(Calendar.DAY_OF_YEAR) != mMaxDate.get(Calendar.DAY_OF_YEAR)) {
        return;
    }
    mMaxDate.setTimeInMillis(maxDate);
    mCalendarView.setMaxDate(maxDate);
    if (mCurrentDate.after(mMaxDate)) {
        mCurrentDate.setTimeInMillis(mMaxDate.getTimeInMillis());
        updateCalendarView();
    }
    updateSpinners();
}
Body of Second Method:
{
    mDelegate.setMaxDate(maxDate);
}
------------------------
Find a silently evolved API code:android.ddm.DdmHandleProfiling.handleMPRS:COMMENT
Method Modifier: private     
Comment:/*
     * Handle a "Method PRofiling Start" request.
     */

Body of Frist Method:
{
    ByteBuffer in = wrapChunk(request);
    int bufferSize = in.getInt();
    int flags = in.getInt();
    int len = in.getInt();
    String fileName = getString(in, len);
    if (false)
        Log.v("ddm-heap", "Method profiling start: filename='" + fileName + "', size=" + bufferSize + ", flags=" + flags);
    try {
        Debug.startMethodTracing(fileName, bufferSize, flags);
        // empty response
        return null;
    } catch (RuntimeException re) {
        return createFailChunk(1, re.getMessage());
    }
}
Body of Second Method:
{
    ByteBuffer in = wrapChunk(request);
    int bufferSize = in.getInt();
    int flags = in.getInt();
    int len = in.getInt();
    String fileName = getString(in, len);
    if (DEBUG)
        Log.v("ddm-heap", "Method profiling start: filename='" + fileName + "', size=" + bufferSize + ", flags=" + flags);
    try {
        Debug.startMethodTracing(fileName, bufferSize, flags);
        // empty response
        return null;
    } catch (RuntimeException re) {
        return createFailChunk(1, re.getMessage());
    }
}
------------------------
Find a silently evolved API code:android.animation.PropertyValuesHolder.setupSetter:COMMENT
Method Modifier: default     
Comment:/**
 * Utility function to get the setter from targetClass
 * @param targetClass The Class on which the requested method should exist.
 */

Body of Frist Method:
{
    mSetter = setupSetterOrGetter(targetClass, sSetterPropertyMap, "set", mValueType);
}
Body of Second Method:
{
    Class<?> propertyType = mConverter == null ? mValueType : mConverter.getTargetType();
    mSetter = setupSetterOrGetter(targetClass, sSetterPropertyMap, "set", propertyType);
}
------------------------
Find a silently evolved API code:android.app.ContextImpl.startActivityAsUser:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    startActivityAsUser(intent, null, user);
}
Body of Second Method:
{
    try {
        ActivityManagerNative.getDefault().startActivityAsUser(mMainThread.getApplicationThread(), getBasePackageName(), intent, intent.resolveTypeIfNeeded(getContentResolver()), null, null, 0, Intent.FLAG_ACTIVITY_NEW_TASK, null, options, user.getIdentifier());
    } catch (RemoteException re) {
    }
}
------------------------
Find a silently evolved API code:android.graphics.Canvas.drawLine:COMMENT
Method Modifier: public      
Comment:/**
 * Draw a line segment with the specified start and stop x,y coordinates,
 * using the specified paint.
 *
 * <p>Note that since a line is always "framed", the Style is ignored in the paint.</p>
 *
 * <p>Degenerate lines (length is 0) will not be drawn.</p>
 *
 * @param startX The x-coordinate of the start point of the line
 * @param startY The y-coordinate of the start point of the line
 * @param paint  The paint used to draw the line
 */

Body of Frist Method:
{
    native_drawLine(mNativeCanvas, startX, startY, stopX, stopY, paint.mNativePaint);
}
Body of Second Method:
{
    native_drawLine(mNativeCanvasWrapper, startX, startY, stopX, stopY, paint.mNativePaint);
}
------------------------
Find a silently evolved API code:android.content.ContentResolver.isSyncPending:COMMENT
Method Modifier: public      static      
Comment:/**
 * Return true if the pending status is true of any matching authorities.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#READ_SYNC_STATS}.
 * @param account the account whose setting we are querying
 * @param authority the provider whose behavior is being queried
 * @return true if there is a pending sync with the matching account and authority
 */

Body of Frist Method:
{
    try {
        return getContentService().isSyncPending(account, authority);
    } catch (RemoteException e) {
        throw new RuntimeException("the ContentService should always be reachable", e);
    }
}
Body of Second Method:
{
    return isSyncPendingAsUser(account, authority, UserHandle.myUserId());
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothGattServer.sendResponse:COMMENT
Method Modifier: public      
Comment:/**
 * Send a response to a read or write request to a remote device.
 *
 * <p>This function must be invoked in when a remote read/write request
 * is received by one of these callback methods:
 *
 * <ul>
 * <li>{@link BluetoothGattServerCallback#onCharacteristicReadRequest}
 * <li>{@link BluetoothGattServerCallback#onCharacteristicWriteRequest}
 * <li>{@link BluetoothGattServerCallback#onDescriptorReadRequest}
 * <li>{@link BluetoothGattServerCallback#onDescriptorWriteRequest}
 * </ul>
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param device The remote device to send this response to
 * @param requestId The ID of the request that was received with the callback
 * @param status The status of the request to be sent to the remote devices
 * @param offset Value offset for partial read/write response
 * @param value The value of the attribute that was read/written (optional)
 */

Body of Frist Method:
{
    if (DBG)
        Log.d(TAG, "sendResponse() - device: " + device.getAddress());
    if (mService == null || mServerIf == 0)
        return false;
    try {
        mService.sendResponse(mServerIf, device.getAddress(), requestId, status, offset, value);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        return false;
    }
    return true;
}
Body of Second Method:
{
    if (VDBG)
        Log.d(TAG, "sendResponse() - device: " + device.getAddress());
    if (mService == null || mServerIf == 0)
        return false;
    try {
        mService.sendResponse(mServerIf, device.getAddress(), requestId, status, offset, value);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        return false;
    }
    return true;
}
------------------------
Find a silently evolved API code:android.media.AudioService.sendVolumeUpdate:COMMENT
Method Modifier: private     hidden      
Comment:// UI update and Broadcast Intent

Body of Frist Method:
{
    if (!mVoiceCapable && (streamType == AudioSystem.STREAM_RING)) {
        streamType = AudioSystem.STREAM_NOTIFICATION;
    }
    mVolumePanel.postVolumeChanged(streamType, flags);
    if ((flags & AudioManager.FLAG_FIXED_VOLUME) == 0) {
        oldIndex = (oldIndex + 5) / 10;
        index = (index + 5) / 10;
        Intent intent = new Intent(AudioManager.VOLUME_CHANGED_ACTION);
        intent.putExtra(AudioManager.EXTRA_VOLUME_STREAM_TYPE, streamType);
        intent.putExtra(AudioManager.EXTRA_VOLUME_STREAM_VALUE, index);
        intent.putExtra(AudioManager.EXTRA_PREV_VOLUME_STREAM_VALUE, oldIndex);
        sendBroadcastToAll(intent);
    }
}
Body of Second Method:
{
    if (!isPlatformVoice() && (streamType == AudioSystem.STREAM_RING)) {
        streamType = AudioSystem.STREAM_NOTIFICATION;
    }
    // only when TV receives volume notification from Audio Receiver.
    if (mHdmiTvClient != null && streamType == AudioSystem.STREAM_MUSIC) {
        synchronized (mHdmiTvClient) {
            if (mHdmiSystemAudioSupported && ((flags & AudioManager.FLAG_HDMI_SYSTEM_AUDIO_VOLUME) == 0)) {
                flags &= ~AudioManager.FLAG_SHOW_UI;
            }
        }
    }
    mVolumeController.postVolumeChanged(streamType, flags);
    if ((flags & AudioManager.FLAG_FIXED_VOLUME) == 0) {
        oldIndex = (oldIndex + 5) / 10;
        index = (index + 5) / 10;
        Intent intent = new Intent(AudioManager.VOLUME_CHANGED_ACTION);
        intent.putExtra(AudioManager.EXTRA_VOLUME_STREAM_TYPE, streamType);
        intent.putExtra(AudioManager.EXTRA_VOLUME_STREAM_VALUE, index);
        intent.putExtra(AudioManager.EXTRA_PREV_VOLUME_STREAM_VALUE, oldIndex);
        sendBroadcastToAll(intent);
    }
}
------------------------
Find a silently evolved API code:android.graphics.Picture.getWidth:COMMENT
<android.graphics.Picture: int getWidth()>
public      native      ->public      
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * Get the width of the picture as passed to beginRecording. This
 * does not reflect (per se) the content of the picture.
 */

Body of Frist Method:

Body of Second Method:
{
    return nativeGetWidth(mNativePicture);
}
------------------------
Find a silently evolved API code:android.media.MediaFocusControl.registerMediaButtonEventReceiverForCalls:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * see AudioManager.registerMediaButtonEventReceiverForCalls(ComponentName c)
 * precondition: c != null
 */

Body of Frist Method:
{
    if (mContext.checkCallingPermission("android.permission.MODIFY_PHONE_STATE") != PackageManager.PERMISSION_GRANTED) {
        Log.e(TAG, "Invalid permissions to register media button receiver for calls");
        return;
    }
    synchronized (mRCStack) {
        mMediaReceiverForCalls = c;
    }
}
Body of Second Method:
{
    if (mContext.checkCallingPermission("android.permission.MODIFY_PHONE_STATE") != PackageManager.PERMISSION_GRANTED) {
        Log.e(TAG, "Invalid permissions to register media button receiver for calls");
        return;
    }
    synchronized (mPRStack) {
        mMediaReceiverForCalls = c;
    }
}
------------------------
Find a silently evolved API code:android.media.MediaRouter.RouteInfo.requestUpdateVolume:COMMENT
Method Modifier: public      
Comment:/**
 * Request an incremental volume update for this route.
 * @param direction Delta to apply to the current volume
 */

Body of Frist Method:
{
    if (mPlaybackType == PLAYBACK_TYPE_LOCAL) {
        try {
            final int volume = Math.max(0, Math.min(getVolume() + direction, getVolumeMax()));
            sStatic.mAudioService.setStreamVolume(mPlaybackStream, volume, 0, ActivityThread.currentPackageName());
        } catch (RemoteException e) {
            Log.e(TAG, "Error setting local stream volume", e);
        }
    } else {
        Log.e(TAG, getClass().getSimpleName() + ".requestChangeVolume(): " + "Non-local volume playback on system route? " + "Could not request volume change.");
    }
}
Body of Second Method:
{
    if (mPlaybackType == PLAYBACK_TYPE_LOCAL) {
        try {
            final int volume = Math.max(0, Math.min(getVolume() + direction, getVolumeMax()));
            sStatic.mAudioService.setStreamVolume(mPlaybackStream, volume, 0, ActivityThread.currentPackageName());
        } catch (RemoteException e) {
            Log.e(TAG, "Error setting local stream volume", e);
        }
    } else {
        sStatic.requestUpdateVolume(this, direction);
    }
}
------------------------
Find a silently evolved API code:android.view.ViewGroup.offsetChildrenTopAndBottom:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Offset the vertical location of all children of this view by the specified number of pixels.
 *
 * @param offset the number of pixels to offset
 *
 * @hide
 */

Body of Frist Method:
{
    final int count = mChildrenCount;
    final View[] children = mChildren;
    boolean invalidate = false;
    for (int i = 0; i < count; i++) {
        final View v = children[i];
        v.mTop += offset;
        v.mBottom += offset;
        if (v.mDisplayList != null) {
            invalidate = true;
            v.mDisplayList.offsetTopAndBottom(offset);
        }
    }
    if (invalidate) {
        invalidateViewProperty(false, false);
    }
}
Body of Second Method:
{
    final int count = mChildrenCount;
    final View[] children = mChildren;
    boolean invalidate = false;
    for (int i = 0; i < count; i++) {
        final View v = children[i];
        v.mTop += offset;
        v.mBottom += offset;
        if (v.mRenderNode != null) {
            invalidate = true;
            v.mRenderNode.offsetTopAndBottom(offset);
        }
    }
    if (invalidate) {
        invalidateViewProperty(false, false);
    }
    notifySubtreeAccessibilityStateChangedIfNeeded();
}
------------------------
Find a silently evolved API code:android.graphics.Canvas.isOpaque:COMMENT
<android.graphics.Canvas: boolean isOpaque()>
public      native      ->public      
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * Return true if the device that the current layer draws into is opaque
 * (i.e. does not support per-pixel alpha).
 *
 * @return true if the device that the current layer draws into is opaque
 */

Body of Frist Method:

Body of Second Method:
{
    return native_isOpaque(mNativeCanvasWrapper);
}
------------------------
Find a silently evolved API code:android.content.res.TypedArray.getLayoutDimension:COMMENT
Method Modifier: public      
Comment:/**
 * Special version of {@link #getDimensionPixelSize} for retrieving
 * {@link android.view.ViewGroup}'s layout_width and layout_height
 * attributes.  This is only here for performance reasons; applications
 * should use {@link #getDimensionPixelSize}.
 *
 * @param index Index of the attribute to retrieve.
 * @param defValue The default value to return if this attribute is not
 * default or contains the wrong type of data.
 *
 * @return Attribute dimension value multiplied by the appropriate
 * metric and truncated to integer pixels.
 */

Body of Frist Method:
{
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + AssetManager.STYLE_DATA];
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimensionPixelSize(data[index + AssetManager.STYLE_DATA], mResources.mMetrics);
    }
    return defValue;
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + AssetManager.STYLE_DATA];
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimensionPixelSize(data[index + AssetManager.STYLE_DATA], mMetrics);
    }
    return defValue;
}
------------------------
Find a silently evolved API code:android.view.ViewGroup.dispatchDetachedFromWindow:COMMENT
Method Modifier: default     
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    // If we still have a touch target, we are still in the process of
    // dispatching motion events to a child; we need to get rid of that
    // child to avoid dispatching events to it after the window is torn
    // down. To make sure we keep the child in a consistent state, we
    // first send it an ACTION_CANCEL motion event.
    cancelAndClearTouchTargets(null);
    // Similarly, set ACTION_EXIT to all hover targets and clear them.
    exitHoverTargets();
    // In case view is detached while transition is running
    mLayoutCalledWhileSuppressed = false;
    // Tear down our drag tracking
    mDragNotifiedChildren = null;
    if (mCurrentDrag != null) {
        mCurrentDrag.recycle();
        mCurrentDrag = null;
    }
    final int count = mChildrenCount;
    final View[] children = mChildren;
    for (int i = 0; i < count; i++) {
        children[i].dispatchDetachedFromWindow();
    }
    super.dispatchDetachedFromWindow();
}
Body of Second Method:
{
    // If we still have a touch target, we are still in the process of
    // dispatching motion events to a child; we need to get rid of that
    // child to avoid dispatching events to it after the window is torn
    // down. To make sure we keep the child in a consistent state, we
    // first send it an ACTION_CANCEL motion event.
    cancelAndClearTouchTargets(null);
    // Similarly, set ACTION_EXIT to all hover targets and clear them.
    exitHoverTargets();
    // In case view is detached while transition is running
    mLayoutCalledWhileSuppressed = false;
    // Tear down our drag tracking
    mDragNotifiedChildren = null;
    if (mCurrentDrag != null) {
        mCurrentDrag.recycle();
        mCurrentDrag = null;
    }
    final int count = mChildrenCount;
    final View[] children = mChildren;
    for (int i = 0; i < count; i++) {
        children[i].dispatchDetachedFromWindow();
    }
    clearDisappearingChildren();
    super.dispatchDetachedFromWindow();
}
------------------------
Find a silently evolved API code:android.text.SpannableStringInternal.setSpan:COMMENT
Method Modifier: default     
Comment:/* package */

Body of Frist Method:
{
    int nstart = start;
    int nend = end;
    checkRange("setSpan", start, end);
    if ((flags & Spannable.SPAN_PARAGRAPH) == Spannable.SPAN_PARAGRAPH) {
        if (start != 0 && start != length()) {
            char c = charAt(start - 1);
            if (c != '\n')
                throw new RuntimeException("PARAGRAPH span must start at paragraph boundary" + " (" + start + " follows " + c + ")");
        }
        if (end != 0 && end != length()) {
            char c = charAt(end - 1);
            if (c != '\n')
                throw new RuntimeException("PARAGRAPH span must end at paragraph boundary" + " (" + end + " follows " + c + ")");
        }
    }
    int count = mSpanCount;
    Object[] spans = mSpans;
    int[] data = mSpanData;
    for (int i = 0; i < count; i++) {
        if (spans[i] == what) {
            int ostart = data[i * COLUMNS + START];
            int oend = data[i * COLUMNS + END];
            data[i * COLUMNS + START] = start;
            data[i * COLUMNS + END] = end;
            data[i * COLUMNS + FLAGS] = flags;
            sendSpanChanged(what, ostart, oend, nstart, nend);
            return;
        }
    }
    if (mSpanCount + 1 >= mSpans.length) {
        int newsize = ArrayUtils.idealIntArraySize(mSpanCount + 1);
        Object[] newtags = new Object[newsize];
        int[] newdata = new int[newsize * 3];
        System.arraycopy(mSpans, 0, newtags, 0, mSpanCount);
        System.arraycopy(mSpanData, 0, newdata, 0, mSpanCount * 3);
        mSpans = newtags;
        mSpanData = newdata;
    }
    mSpans[mSpanCount] = what;
    mSpanData[mSpanCount * COLUMNS + START] = start;
    mSpanData[mSpanCount * COLUMNS + END] = end;
    mSpanData[mSpanCount * COLUMNS + FLAGS] = flags;
    mSpanCount++;
    if (this instanceof Spannable)
        sendSpanAdded(what, nstart, nend);
}
Body of Second Method:
{
    int nstart = start;
    int nend = end;
    checkRange("setSpan", start, end);
    if ((flags & Spannable.SPAN_PARAGRAPH) == Spannable.SPAN_PARAGRAPH) {
        if (start != 0 && start != length()) {
            char c = charAt(start - 1);
            if (c != '\n')
                throw new RuntimeException("PARAGRAPH span must start at paragraph boundary" + " (" + start + " follows " + c + ")");
        }
        if (end != 0 && end != length()) {
            char c = charAt(end - 1);
            if (c != '\n')
                throw new RuntimeException("PARAGRAPH span must end at paragraph boundary" + " (" + end + " follows " + c + ")");
        }
    }
    int count = mSpanCount;
    Object[] spans = mSpans;
    int[] data = mSpanData;
    for (int i = 0; i < count; i++) {
        if (spans[i] == what) {
            int ostart = data[i * COLUMNS + START];
            int oend = data[i * COLUMNS + END];
            data[i * COLUMNS + START] = start;
            data[i * COLUMNS + END] = end;
            data[i * COLUMNS + FLAGS] = flags;
            sendSpanChanged(what, ostart, oend, nstart, nend);
            return;
        }
    }
    if (mSpanCount + 1 >= mSpans.length) {
        Object[] newtags = ArrayUtils.newUnpaddedObjectArray(GrowingArrayUtils.growSize(mSpanCount));
        int[] newdata = new int[newtags.length * 3];
        System.arraycopy(mSpans, 0, newtags, 0, mSpanCount);
        System.arraycopy(mSpanData, 0, newdata, 0, mSpanCount * 3);
        mSpans = newtags;
        mSpanData = newdata;
    }
    mSpans[mSpanCount] = what;
    mSpanData[mSpanCount * COLUMNS + START] = start;
    mSpanData[mSpanCount * COLUMNS + END] = end;
    mSpanData[mSpanCount * COLUMNS + FLAGS] = flags;
    mSpanCount++;
    if (this instanceof Spannable)
        sendSpanAdded(what, nstart, nend);
}
------------------------
Find a silently evolved API code:android.graphics.drawable.GradientDrawable.setStroke:COMMENT
Method Modifier: public      
Comment:/**
 * <p>Set the stroke width and color for the drawable. If width is zero,
 * then no stroke is drawn. This method can also be used to dash the stroke.</p>
 * <p><strong>Note</strong>: changing this property will affect all instances
 * of a drawable loaded from a resource. It is recommended to invoke
 * {@link #mutate()} before changing this property.</p>
 *
 * @param width The width in pixels of the stroke
 * @param color The color of the stroke
 * @param dashWidth The length in pixels of the dashes, set to 0 to disable dashes
 * @param dashGap The gap in pixels between dashes
 *
 * @see #mutate()
 * @see #setStroke(int, int)
 */

Body of Frist Method:
{
    mGradientState.setStroke(width, color, dashWidth, dashGap);
    if (mStrokePaint == null) {
        mStrokePaint = new Paint(Paint.ANTI_ALIAS_FLAG);
        mStrokePaint.setStyle(Paint.Style.STROKE);
    }
    mStrokePaint.setStrokeWidth(width);
    mStrokePaint.setColor(color);
    DashPathEffect e = null;
    if (dashWidth > 0) {
        e = new DashPathEffect(new float[] { dashWidth, dashGap }, 0);
    }
    mStrokePaint.setPathEffect(e);
    invalidateSelf();
}
Body of Second Method:
{
    mGradientState.setStroke(width, ColorStateList.valueOf(color), dashWidth, dashGap);
    setStrokeInternal(width, color, dashWidth, dashGap);
}
------------------------
Find a silently evolved API code:javax.obex.HeaderSet.setHeader:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets the value of the header identifier to the value provided. The type
 * of object must correspond to the Java type defined in the description of
 * this interface. If <code>null</code> is passed as the
 * <code>headerValue</code> then the header will be removed from the set of
 * headers to include in the next request.
 * @param headerID the identifier to include in the message
 * @param headerValue the value of the header identifier
 * @throws IllegalArgumentException if the header identifier provided is not
 * one defined in this interface or a user-defined header; if the
 * type of <code>headerValue</code> is not the correct Java type as
 * defined in the description of this interface\
 */

Body of Frist Method:
{
    long temp = -1;
    switch(headerID) {
        case COUNT:
            if (!(headerValue instanceof Long)) {
                if (headerValue == null) {
                    mCount = null;
                    break;
                }
                throw new IllegalArgumentException("Count must be a Long");
            }
            temp = ((Long) headerValue).longValue();
            if ((temp < 0L) || (temp > 0xFFFFFFFFL)) {
                throw new IllegalArgumentException("Count must be between 0 and 0xFFFFFFFF");
            }
            mCount = (Long) headerValue;
            break;
        case NAME:
            if ((headerValue != null) && (!(headerValue instanceof String))) {
                throw new IllegalArgumentException("Name must be a String");
            }
            mName = (String) headerValue;
            break;
        case TYPE:
            if ((headerValue != null) && (!(headerValue instanceof String))) {
                throw new IllegalArgumentException("Type must be a String");
            }
            mType = (String) headerValue;
            break;
        case LENGTH:
            if (!(headerValue instanceof Long)) {
                if (headerValue == null) {
                    mLength = null;
                    break;
                }
                throw new IllegalArgumentException("Length must be a Long");
            }
            temp = ((Long) headerValue).longValue();
            if ((temp < 0L) || (temp > 0xFFFFFFFFL)) {
                throw new IllegalArgumentException("Length must be between 0 and 0xFFFFFFFF");
            }
            mLength = (Long) headerValue;
            break;
        case TIME_ISO_8601:
            if ((headerValue != null) && (!(headerValue instanceof Calendar))) {
                throw new IllegalArgumentException("Time ISO 8601 must be a Calendar");
            }
            mIsoTime = (Calendar) headerValue;
            break;
        case TIME_4_BYTE:
            if ((headerValue != null) && (!(headerValue instanceof Calendar))) {
                throw new IllegalArgumentException("Time 4 Byte must be a Calendar");
            }
            mByteTime = (Calendar) headerValue;
            break;
        case DESCRIPTION:
            if ((headerValue != null) && (!(headerValue instanceof String))) {
                throw new IllegalArgumentException("Description must be a String");
            }
            mDescription = (String) headerValue;
            break;
        case TARGET:
            if (headerValue == null) {
                mTarget = null;
            } else {
                if (!(headerValue instanceof byte[])) {
                    throw new IllegalArgumentException("Target must be a byte array");
                } else {
                    mTarget = new byte[((byte[]) headerValue).length];
                    System.arraycopy(headerValue, 0, mTarget, 0, mTarget.length);
                }
            }
            break;
        case HTTP:
            if (headerValue == null) {
                mHttpHeader = null;
            } else {
                if (!(headerValue instanceof byte[])) {
                    throw new IllegalArgumentException("HTTP must be a byte array");
                } else {
                    mHttpHeader = new byte[((byte[]) headerValue).length];
                    System.arraycopy(headerValue, 0, mHttpHeader, 0, mHttpHeader.length);
                }
            }
            break;
        case WHO:
            if (headerValue == null) {
                mWho = null;
            } else {
                if (!(headerValue instanceof byte[])) {
                    throw new IllegalArgumentException("WHO must be a byte array");
                } else {
                    mWho = new byte[((byte[]) headerValue).length];
                    System.arraycopy(headerValue, 0, mWho, 0, mWho.length);
                }
            }
            break;
        case OBJECT_CLASS:
            if (headerValue == null) {
                mObjectClass = null;
            } else {
                if (!(headerValue instanceof byte[])) {
                    throw new IllegalArgumentException("Object Class must be a byte array");
                } else {
                    mObjectClass = new byte[((byte[]) headerValue).length];
                    System.arraycopy(headerValue, 0, mObjectClass, 0, mObjectClass.length);
                }
            }
            break;
        case APPLICATION_PARAMETER:
            if (headerValue == null) {
                mAppParam = null;
            } else {
                if (!(headerValue instanceof byte[])) {
                    throw new IllegalArgumentException("Application Parameter must be a byte array");
                } else {
                    mAppParam = new byte[((byte[]) headerValue).length];
                    System.arraycopy(headerValue, 0, mAppParam, 0, mAppParam.length);
                }
            }
            break;
        default:
            // Verify that it was not a Unicode String user Defined
            if ((headerID >= 0x30) && (headerID <= 0x3F)) {
                if ((headerValue != null) && (!(headerValue instanceof String))) {
                    throw new IllegalArgumentException("Unicode String User Defined must be a String");
                }
                mUnicodeUserDefined[headerID - 0x30] = (String) headerValue;
                break;
            }
            // Verify that it was not a byte sequence user defined value
            if ((headerID >= 0x70) && (headerID <= 0x7F)) {
                if (headerValue == null) {
                    mSequenceUserDefined[headerID - 0x70] = null;
                } else {
                    if (!(headerValue instanceof byte[])) {
                        throw new IllegalArgumentException("Byte Sequence User Defined must be a byte array");
                    } else {
                        mSequenceUserDefined[headerID - 0x70] = new byte[((byte[]) headerValue).length];
                        System.arraycopy(headerValue, 0, mSequenceUserDefined[headerID - 0x70], 0, mSequenceUserDefined[headerID - 0x70].length);
                    }
                }
                break;
            }
            // Verify that it was not a Byte user Defined
            if ((headerID >= 0xB0) && (headerID <= 0xBF)) {
                if ((headerValue != null) && (!(headerValue instanceof Byte))) {
                    throw new IllegalArgumentException("ByteUser Defined must be a Byte");
                }
                mByteUserDefined[headerID - 0xB0] = (Byte) headerValue;
                break;
            }
            // defined header
            if ((headerID >= 0xF0) && (headerID <= 0xFF)) {
                if (!(headerValue instanceof Long)) {
                    if (headerValue == null) {
                        mIntegerUserDefined[headerID - 0xF0] = null;
                        break;
                    }
                    throw new IllegalArgumentException("Integer User Defined must be a Long");
                }
                temp = ((Long) headerValue).longValue();
                if ((temp < 0L) || (temp > 0xFFFFFFFFL)) {
                    throw new IllegalArgumentException("Integer User Defined must be between 0 and 0xFFFFFFFF");
                }
                mIntegerUserDefined[headerID - 0xF0] = (Long) headerValue;
                break;
            }
            throw new IllegalArgumentException("Invalid Header Identifier");
    }
}
Body of Second Method:
{
    long temp = -1;
    switch(headerID) {
        case COUNT:
            if (!(headerValue instanceof Long)) {
                if (headerValue == null) {
                    mCount = null;
                    break;
                }
                throw new IllegalArgumentException("Count must be a Long");
            }
            temp = ((Long) headerValue).longValue();
            if ((temp < 0L) || (temp > 0xFFFFFFFFL)) {
                throw new IllegalArgumentException("Count must be between 0 and 0xFFFFFFFF");
            }
            mCount = (Long) headerValue;
            break;
        case NAME:
            if ((headerValue != null) && (!(headerValue instanceof String))) {
                throw new IllegalArgumentException("Name must be a String");
            }
            mEmptyName = false;
            mName = (String) headerValue;
            break;
        case TYPE:
            if ((headerValue != null) && (!(headerValue instanceof String))) {
                throw new IllegalArgumentException("Type must be a String");
            }
            mType = (String) headerValue;
            break;
        case LENGTH:
            if (!(headerValue instanceof Long)) {
                if (headerValue == null) {
                    mLength = null;
                    break;
                }
                throw new IllegalArgumentException("Length must be a Long");
            }
            temp = ((Long) headerValue).longValue();
            if ((temp < 0L) || (temp > 0xFFFFFFFFL)) {
                throw new IllegalArgumentException("Length must be between 0 and 0xFFFFFFFF");
            }
            mLength = (Long) headerValue;
            break;
        case TIME_ISO_8601:
            if ((headerValue != null) && (!(headerValue instanceof Calendar))) {
                throw new IllegalArgumentException("Time ISO 8601 must be a Calendar");
            }
            mIsoTime = (Calendar) headerValue;
            break;
        case TIME_4_BYTE:
            if ((headerValue != null) && (!(headerValue instanceof Calendar))) {
                throw new IllegalArgumentException("Time 4 Byte must be a Calendar");
            }
            mByteTime = (Calendar) headerValue;
            break;
        case DESCRIPTION:
            if ((headerValue != null) && (!(headerValue instanceof String))) {
                throw new IllegalArgumentException("Description must be a String");
            }
            mDescription = (String) headerValue;
            break;
        case TARGET:
            if (headerValue == null) {
                mTarget = null;
            } else {
                if (!(headerValue instanceof byte[])) {
                    throw new IllegalArgumentException("Target must be a byte array");
                } else {
                    mTarget = new byte[((byte[]) headerValue).length];
                    System.arraycopy(headerValue, 0, mTarget, 0, mTarget.length);
                }
            }
            break;
        case HTTP:
            if (headerValue == null) {
                mHttpHeader = null;
            } else {
                if (!(headerValue instanceof byte[])) {
                    throw new IllegalArgumentException("HTTP must be a byte array");
                } else {
                    mHttpHeader = new byte[((byte[]) headerValue).length];
                    System.arraycopy(headerValue, 0, mHttpHeader, 0, mHttpHeader.length);
                }
            }
            break;
        case WHO:
            if (headerValue == null) {
                mWho = null;
            } else {
                if (!(headerValue instanceof byte[])) {
                    throw new IllegalArgumentException("WHO must be a byte array");
                } else {
                    mWho = new byte[((byte[]) headerValue).length];
                    System.arraycopy(headerValue, 0, mWho, 0, mWho.length);
                }
            }
            break;
        case OBJECT_CLASS:
            if (headerValue == null) {
                mObjectClass = null;
            } else {
                if (!(headerValue instanceof byte[])) {
                    throw new IllegalArgumentException("Object Class must be a byte array");
                } else {
                    mObjectClass = new byte[((byte[]) headerValue).length];
                    System.arraycopy(headerValue, 0, mObjectClass, 0, mObjectClass.length);
                }
            }
            break;
        case APPLICATION_PARAMETER:
            if (headerValue == null) {
                mAppParam = null;
            } else {
                if (!(headerValue instanceof byte[])) {
                    throw new IllegalArgumentException("Application Parameter must be a byte array");
                } else {
                    mAppParam = new byte[((byte[]) headerValue).length];
                    System.arraycopy(headerValue, 0, mAppParam, 0, mAppParam.length);
                }
            }
            break;
        default:
            // Verify that it was not a Unicode String user Defined
            if ((headerID >= 0x30) && (headerID <= 0x3F)) {
                if ((headerValue != null) && (!(headerValue instanceof String))) {
                    throw new IllegalArgumentException("Unicode String User Defined must be a String");
                }
                mUnicodeUserDefined[headerID - 0x30] = (String) headerValue;
                break;
            }
            // Verify that it was not a byte sequence user defined value
            if ((headerID >= 0x70) && (headerID <= 0x7F)) {
                if (headerValue == null) {
                    mSequenceUserDefined[headerID - 0x70] = null;
                } else {
                    if (!(headerValue instanceof byte[])) {
                        throw new IllegalArgumentException("Byte Sequence User Defined must be a byte array");
                    } else {
                        mSequenceUserDefined[headerID - 0x70] = new byte[((byte[]) headerValue).length];
                        System.arraycopy(headerValue, 0, mSequenceUserDefined[headerID - 0x70], 0, mSequenceUserDefined[headerID - 0x70].length);
                    }
                }
                break;
            }
            // Verify that it was not a Byte user Defined
            if ((headerID >= 0xB0) && (headerID <= 0xBF)) {
                if ((headerValue != null) && (!(headerValue instanceof Byte))) {
                    throw new IllegalArgumentException("ByteUser Defined must be a Byte");
                }
                mByteUserDefined[headerID - 0xB0] = (Byte) headerValue;
                break;
            }
            // defined header
            if ((headerID >= 0xF0) && (headerID <= 0xFF)) {
                if (!(headerValue instanceof Long)) {
                    if (headerValue == null) {
                        mIntegerUserDefined[headerID - 0xF0] = null;
                        break;
                    }
                    throw new IllegalArgumentException("Integer User Defined must be a Long");
                }
                temp = ((Long) headerValue).longValue();
                if ((temp < 0L) || (temp > 0xFFFFFFFFL)) {
                    throw new IllegalArgumentException("Integer User Defined must be between 0 and 0xFFFFFFFF");
                }
                mIntegerUserDefined[headerID - 0xF0] = (Long) headerValue;
                break;
            }
            throw new IllegalArgumentException("Invalid Header Identifier");
    }
}
------------------------
Find a silently evolved API code:android.widget.RemoteViews.reapply:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    RemoteViews rvToApply = getRemoteViewsToApply(context);
    // we throw an exception, since the layouts may be completely unrelated.
    if (hasLandscapeAndPortraitLayouts()) {
        if (v.getId() != rvToApply.getLayoutId()) {
            throw new RuntimeException("Attempting to re-apply RemoteViews to a view that" + " that does not share the same root layout id.");
        }
    }
    prepareContext(context);
    rvToApply.performApply(v, (ViewGroup) v.getParent(), handler);
}
Body of Second Method:
{
    RemoteViews rvToApply = getRemoteViewsToApply(context);
    // we throw an exception, since the layouts may be completely unrelated.
    if (hasLandscapeAndPortraitLayouts()) {
        if (v.getId() != rvToApply.getLayoutId()) {
            throw new RuntimeException("Attempting to re-apply RemoteViews to a view that" + " that does not share the same root layout id.");
        }
    }
    rvToApply.performApply(v, (ViewGroup) v.getParent(), handler);
}
------------------------
Find a silently evolved API code:android.widget.TextView.getShadowColor:COMMENT
Method Modifier: public      
Comment:/**
 * @return the color of the shadow layer
 *
 * @see #setShadowLayer(float, float, float, int)
 *
 * @attr ref android.R.styleable#TextView_shadowColor
 */

Body of Frist Method:
{
    return mTextPaint.shadowColor;
}
Body of Second Method:
{
    return mShadowColor;
}
------------------------
Find a silently evolved API code:android.hardware.camera2.CameraMetadata.getKeysStatic:COMMENT
Method Modifier: default     static      
Comment:/*package*/

Body of Frist Method:
{
    ArrayList<Key<?>> keyList = new ArrayList<Key<?>>();
    Field[] fields = type.getDeclaredFields();
    for (Field field : fields) {
        // Filter for Keys that are public
        if (field.getType().isAssignableFrom(Key.class) && (field.getModifiers() & Modifier.PUBLIC) != 0) {
            Key<?> key;
            try {
                key = (Key<?>) field.get(instance);
            } catch (IllegalAccessException e) {
                throw new AssertionError("Can't get IllegalAccessException", e);
            } catch (IllegalArgumentException e) {
                throw new AssertionError("Can't get IllegalArgumentException", e);
            }
            if (instance == null || instance.get(key) != null) {
                keyList.add(key);
            }
        }
    }
    return keyList;
}
Body of Second Method:
{
    if (VERBOSE)
        Log.v(TAG, "getKeysStatic for " + type);
    // TotalCaptureResult does not have any of the keys on it, use CaptureResult instead
    if (type.equals(TotalCaptureResult.class)) {
        type = CaptureResult.class;
    }
    if (filterTags != null) {
        Arrays.sort(filterTags);
    }
    ArrayList<TKey> keyList = new ArrayList<TKey>();
    Field[] fields = type.getDeclaredFields();
    for (Field field : fields) {
        // Filter for Keys that are public
        if (field.getType().isAssignableFrom(keyClass) && (field.getModifiers() & Modifier.PUBLIC) != 0) {
            TKey key;
            try {
                key = (TKey) field.get(instance);
            } catch (IllegalAccessException e) {
                throw new AssertionError("Can't get IllegalAccessException", e);
            } catch (IllegalArgumentException e) {
                throw new AssertionError("Can't get IllegalArgumentException", e);
            }
            if (instance == null || instance.getProtected(key) != null) {
                if (shouldKeyBeAdded(key, field, filterTags)) {
                    keyList.add(key);
                    if (VERBOSE) {
                        Log.v(TAG, "getKeysStatic - key was added - " + key);
                    }
                } else if (VERBOSE) {
                    Log.v(TAG, "getKeysStatic - key was filtered - " + key);
                }
            }
        }
    }
    return keyList;
}
------------------------
Find a silently evolved API code:android.hardware.camera2.CameraCharacteristics.getAvailableCaptureResultKeys:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the list of keys supported by this {@link CameraDevice} for querying
 * with a {@link CaptureResult}.
 *
 * <p>The list returned is not modifiable, so any attempts to modify it will throw
 * a {@code UnsupportedOperationException}.</p>
 *
 * <p>Each key is only listed once in the list. The order of the keys is undefined.</p>
 *
 * <p>Note that there is no {@code getAvailableCameraCharacteristicsKeys()} -- use
 * {@link #getKeys()} instead.</p>
 *
 * @return List of keys supported by this CameraDevice for CaptureResults.
 */

Body of Frist Method:
{
    if (mAvailableResultKeys == null) {
        mAvailableResultKeys = getAvailableKeyList(CaptureResult.class);
    }
    return mAvailableResultKeys;
}
Body of Second Method:
{
    if (mAvailableResultKeys == null) {
        Object crKey = CaptureResult.Key.class;
        Class<CaptureResult.Key<?>> crKeyTyped = (Class<CaptureResult.Key<?>>) crKey;
        int[] filterTags = get(REQUEST_AVAILABLE_RESULT_KEYS);
        if (filterTags == null) {
            throw new AssertionError("android.request.availableResultKeys must be non-null " + "in the characteristics");
        }
        mAvailableResultKeys = getAvailableKeyList(CaptureResult.class, crKeyTyped, filterTags);
    }
    return mAvailableResultKeys;
}
------------------------
Find a silently evolved API code:android.animation.AnimatorSet.start:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 *
 * <p>Starting this <code>AnimatorSet</code> will, in turn, start the animations for which
 * it is responsible. The details of when exactly those animations are started depends on
 * the dependency relationships that have been set up between the animations.
 */

Body of Frist Method:
{
    mTerminated = false;
    mStarted = true;
    mPaused = false;
    if (mDuration >= 0) {
        // If the duration was set on this AnimatorSet, pass it along to all child animations
        for (Node node : mNodes) {
            // TODO: don't set the duration of the timing-only nodes created by AnimatorSet to
            // insert "play-after" delays
            node.animation.setDuration(mDuration);
        }
    }
    if (mInterpolator != null) {
        for (Node node : mNodes) {
            node.animation.setInterpolator(mInterpolator);
        }
    }
    // First, sort the nodes (if necessary). This will ensure that sortedNodes
    // contains the animation nodes in the correct order.
    sortNodes();
    int numSortedNodes = mSortedNodes.size();
    for (int i = 0; i < numSortedNodes; ++i) {
        Node node = mSortedNodes.get(i);
        // First, clear out the old listeners
        ArrayList<AnimatorListener> oldListeners = node.animation.getListeners();
        if (oldListeners != null && oldListeners.size() > 0) {
            final ArrayList<AnimatorListener> clonedListeners = new ArrayList<AnimatorListener>(oldListeners);
            for (AnimatorListener listener : clonedListeners) {
                if (listener instanceof DependencyListener || listener instanceof AnimatorSetListener) {
                    node.animation.removeListener(listener);
                }
            }
        }
    }
    // nodesToStart holds the list of nodes to be started immediately. We don't want to
    // start the animations in the loop directly because we first need to set up
    // dependencies on all of the nodes. For example, we don't want to start an animation
    // when some other animation also wants to start when the first animation begins.
    final ArrayList<Node> nodesToStart = new ArrayList<Node>();
    for (int i = 0; i < numSortedNodes; ++i) {
        Node node = mSortedNodes.get(i);
        if (mSetListener == null) {
            mSetListener = new AnimatorSetListener(this);
        }
        if (node.dependencies == null || node.dependencies.size() == 0) {
            nodesToStart.add(node);
        } else {
            int numDependencies = node.dependencies.size();
            for (int j = 0; j < numDependencies; ++j) {
                Dependency dependency = node.dependencies.get(j);
                dependency.node.animation.addListener(new DependencyListener(this, node, dependency.rule));
            }
            node.tmpDependencies = (ArrayList<Dependency>) node.dependencies.clone();
        }
        node.animation.addListener(mSetListener);
    }
    // Now that all dependencies are set up, start the animations that should be started.
    if (mStartDelay <= 0) {
        for (Node node : nodesToStart) {
            node.animation.start();
            mPlayingSet.add(node.animation);
        }
    } else {
        mDelayAnim = ValueAnimator.ofFloat(0f, 1f);
        mDelayAnim.setDuration(mStartDelay);
        mDelayAnim.addListener(new AnimatorListenerAdapter() {

            boolean canceled = false;

            public void onAnimationCancel(Animator anim) {
                canceled = true;
            }

            public void onAnimationEnd(Animator anim) {
                if (!canceled) {
                    int numNodes = nodesToStart.size();
                    for (int i = 0; i < numNodes; ++i) {
                        Node node = nodesToStart.get(i);
                        node.animation.start();
                        mPlayingSet.add(node.animation);
                    }
                }
                mDelayAnim = null;
            }
        });
        mDelayAnim.start();
    }
    if (mListeners != null) {
        ArrayList<AnimatorListener> tmpListeners = (ArrayList<AnimatorListener>) mListeners.clone();
        int numListeners = tmpListeners.size();
        for (int i = 0; i < numListeners; ++i) {
            tmpListeners.get(i).onAnimationStart(this);
        }
    }
    if (mNodes.size() == 0 && mStartDelay == 0) {
        // Handle unusual case where empty AnimatorSet is started - should send out
        // end event immediately since the event will not be sent out at all otherwise
        mStarted = false;
        if (mListeners != null) {
            ArrayList<AnimatorListener> tmpListeners = (ArrayList<AnimatorListener>) mListeners.clone();
            int numListeners = tmpListeners.size();
            for (int i = 0; i < numListeners; ++i) {
                tmpListeners.get(i).onAnimationEnd(this);
            }
        }
    }
}
Body of Second Method:
{
    mTerminated = false;
    mStarted = true;
    mPaused = false;
    for (Node node : mNodes) {
        node.animation.setAllowRunningAsynchronously(false);
    }
    if (mDuration >= 0) {
        // If the duration was set on this AnimatorSet, pass it along to all child animations
        for (Node node : mNodes) {
            // TODO: don't set the duration of the timing-only nodes created by AnimatorSet to
            // insert "play-after" delays
            node.animation.setDuration(mDuration);
        }
    }
    if (mInterpolator != null) {
        for (Node node : mNodes) {
            node.animation.setInterpolator(mInterpolator);
        }
    }
    // First, sort the nodes (if necessary). This will ensure that sortedNodes
    // contains the animation nodes in the correct order.
    sortNodes();
    int numSortedNodes = mSortedNodes.size();
    for (int i = 0; i < numSortedNodes; ++i) {
        Node node = mSortedNodes.get(i);
        // First, clear out the old listeners
        ArrayList<AnimatorListener> oldListeners = node.animation.getListeners();
        if (oldListeners != null && oldListeners.size() > 0) {
            final ArrayList<AnimatorListener> clonedListeners = new ArrayList<AnimatorListener>(oldListeners);
            for (AnimatorListener listener : clonedListeners) {
                if (listener instanceof DependencyListener || listener instanceof AnimatorSetListener) {
                    node.animation.removeListener(listener);
                }
            }
        }
    }
    // nodesToStart holds the list of nodes to be started immediately. We don't want to
    // start the animations in the loop directly because we first need to set up
    // dependencies on all of the nodes. For example, we don't want to start an animation
    // when some other animation also wants to start when the first animation begins.
    final ArrayList<Node> nodesToStart = new ArrayList<Node>();
    for (int i = 0; i < numSortedNodes; ++i) {
        Node node = mSortedNodes.get(i);
        if (mSetListener == null) {
            mSetListener = new AnimatorSetListener(this);
        }
        if (node.dependencies == null || node.dependencies.size() == 0) {
            nodesToStart.add(node);
        } else {
            int numDependencies = node.dependencies.size();
            for (int j = 0; j < numDependencies; ++j) {
                Dependency dependency = node.dependencies.get(j);
                dependency.node.animation.addListener(new DependencyListener(this, node, dependency.rule));
            }
            node.tmpDependencies = (ArrayList<Dependency>) node.dependencies.clone();
        }
        node.animation.addListener(mSetListener);
    }
    // Now that all dependencies are set up, start the animations that should be started.
    if (mStartDelay <= 0) {
        for (Node node : nodesToStart) {
            node.animation.start();
            mPlayingSet.add(node.animation);
        }
    } else {
        mDelayAnim = ValueAnimator.ofFloat(0f, 1f);
        mDelayAnim.setDuration(mStartDelay);
        mDelayAnim.addListener(new AnimatorListenerAdapter() {

            boolean canceled = false;

            public void onAnimationCancel(Animator anim) {
                canceled = true;
            }

            public void onAnimationEnd(Animator anim) {
                if (!canceled) {
                    int numNodes = nodesToStart.size();
                    for (int i = 0; i < numNodes; ++i) {
                        Node node = nodesToStart.get(i);
                        node.animation.start();
                        mPlayingSet.add(node.animation);
                    }
                }
                mDelayAnim = null;
            }
        });
        mDelayAnim.start();
    }
    if (mListeners != null) {
        ArrayList<AnimatorListener> tmpListeners = (ArrayList<AnimatorListener>) mListeners.clone();
        int numListeners = tmpListeners.size();
        for (int i = 0; i < numListeners; ++i) {
            tmpListeners.get(i).onAnimationStart(this);
        }
    }
    if (mNodes.size() == 0 && mStartDelay == 0) {
        // Handle unusual case where empty AnimatorSet is started - should send out
        // end event immediately since the event will not be sent out at all otherwise
        mStarted = false;
        if (mListeners != null) {
            ArrayList<AnimatorListener> tmpListeners = (ArrayList<AnimatorListener>) mListeners.clone();
            int numListeners = tmpListeners.size();
            for (int i = 0; i < numListeners; ++i) {
                tmpListeners.get(i).onAnimationEnd(this);
            }
        }
    }
}
------------------------
Find a silently evolved API code:android.view.accessibility.AccessibilityRecord.clear:COMMENT
Method Modifier: default     
Comment:/**
 * Clears the state of this instance.
 */

Body of Frist Method:
{
    mSealed = false;
    mBooleanProperties = PROPERTY_IMPORTANT_FOR_ACCESSIBILITY;
    mCurrentItemIndex = UNDEFINED;
    mItemCount = UNDEFINED;
    mFromIndex = UNDEFINED;
    mToIndex = UNDEFINED;
    mScrollX = UNDEFINED;
    mScrollY = UNDEFINED;
    mMaxScrollX = UNDEFINED;
    mMaxScrollY = UNDEFINED;
    mAddedCount = UNDEFINED;
    mRemovedCount = UNDEFINED;
    mClassName = null;
    mContentDescription = null;
    mBeforeText = null;
    mParcelableData = null;
    mText.clear();
    mSourceNodeId = AccessibilityNodeInfo.makeNodeId(UNDEFINED, UNDEFINED);
    mSourceWindowId = UNDEFINED;
    mConnectionId = UNDEFINED;
}
Body of Second Method:
{
    mSealed = false;
    mBooleanProperties = 0;
    mCurrentItemIndex = UNDEFINED;
    mItemCount = UNDEFINED;
    mFromIndex = UNDEFINED;
    mToIndex = UNDEFINED;
    mScrollX = UNDEFINED;
    mScrollY = UNDEFINED;
    mMaxScrollX = UNDEFINED;
    mMaxScrollY = UNDEFINED;
    mAddedCount = UNDEFINED;
    mRemovedCount = UNDEFINED;
    mClassName = null;
    mContentDescription = null;
    mBeforeText = null;
    mParcelableData = null;
    mText.clear();
    mSourceNodeId = AccessibilityNodeInfo.makeNodeId(UNDEFINED, UNDEFINED);
    mSourceWindowId = UNDEFINED;
    mConnectionId = UNDEFINED;
}
------------------------
Find a silently evolved API code:android.widget.ActivityChooserModel.loadActivitiesIfNeeded:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Loads the activities for the current intent if needed which is
 * if they are not already loaded for the current intent.
 *
 * @return Whether loading was performed.
 */

Body of Frist Method:
{
    if (mReloadActivities && mIntent != null) {
        mReloadActivities = false;
        mActivities.clear();
        List<ResolveInfo> resolveInfos = mContext.getPackageManager().queryIntentActivities(mIntent, 0);
        final int resolveInfoCount = resolveInfos.size();
        for (int i = 0; i < resolveInfoCount; i++) {
            ResolveInfo resolveInfo = resolveInfos.get(i);
            mActivities.add(new ActivityResolveInfo(resolveInfo));
        }
        return true;
    }
    return false;
}
Body of Second Method:
{
    if (mReloadActivities && mIntent != null) {
        mReloadActivities = false;
        mActivities.clear();
        List<ResolveInfo> resolveInfos = mContext.getPackageManager().queryIntentActivities(mIntent, 0);
        final int resolveInfoCount = resolveInfos.size();
        for (int i = 0; i < resolveInfoCount; i++) {
            ResolveInfo resolveInfo = resolveInfos.get(i);
            ActivityInfo activityInfo = resolveInfo.activityInfo;
            if (ActivityManager.checkComponentPermission(activityInfo.permission, android.os.Process.myUid(), activityInfo.applicationInfo.uid, activityInfo.exported) == PackageManager.PERMISSION_GRANTED) {
                mActivities.add(new ActivityResolveInfo(resolveInfo));
            }
        }
        return true;
    }
    return false;
}
------------------------
Find a silently evolved API code:android.widget.FastScroller.setAlwaysShow:COMMENT
Method Modifier: public      
Comment:/**
 * @param alwaysShow Whether the fast scroll thumb should always be shown
 */

Body of Frist Method:
{
    if (mAlwaysShow != alwaysShow) {
        mAlwaysShow = alwaysShow;
        onStateDependencyChanged();
    }
}
Body of Second Method:
{
    if (mAlwaysShow != alwaysShow) {
        mAlwaysShow = alwaysShow;
        onStateDependencyChanged(false);
    }
}
------------------------
Find a silently evolved API code:android.media.MediaFocusControl.dispatchMediaKeyEvent:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Handles the dispatching of the media button events to one of the registered listeners,
 * or if there was none, broadcast an ACTION_MEDIA_BUTTON intent to the rest of the system.
 * @param keyEvent a non-null KeyEvent whose key code is one of the supported media buttons
 * @param needWakeLock true if a PARTIAL_WAKE_LOCK needs to be held while this key event
 * is dispatched.
 */

Body of Frist Method:
{
    if (needWakeLock) {
        mMediaEventWakeLock.acquire();
    }
    Intent keyIntent = new Intent(Intent.ACTION_MEDIA_BUTTON, null);
    keyIntent.putExtra(Intent.EXTRA_KEY_EVENT, keyEvent);
    synchronized (mRCStack) {
        if (!mRCStack.empty()) {
            // send the intent that was registered by the client
            try {
                mRCStack.peek().mMediaIntent.send(mContext, needWakeLock ? WAKELOCK_RELEASE_ON_FINISHED : 0, /*code*/
                keyIntent, this, mEventHandler);
            } catch (CanceledException e) {
                Log.e(TAG, "Error sending pending intent " + mRCStack.peek());
                e.printStackTrace();
            }
        } else {
            // through AudioManager
            if (needWakeLock) {
                keyIntent.putExtra(EXTRA_WAKELOCK_ACQUIRED, WAKELOCK_RELEASE_ON_FINISHED);
            }
            final long ident = Binder.clearCallingIdentity();
            try {
                mContext.sendOrderedBroadcastAsUser(keyIntent, UserHandle.ALL, null, mKeyEventDone, mEventHandler, Activity.RESULT_OK, null, null);
            } finally {
                Binder.restoreCallingIdentity(ident);
            }
        }
    }
}
Body of Second Method:
{
    if (needWakeLock) {
        mMediaEventWakeLock.acquire();
    }
    Intent keyIntent = new Intent(Intent.ACTION_MEDIA_BUTTON, null);
    keyIntent.putExtra(Intent.EXTRA_KEY_EVENT, keyEvent);
    synchronized (mPRStack) {
        if (!mPRStack.empty()) {
            // send the intent that was registered by the client
            try {
                mPRStack.peek().getMediaButtonIntent().send(mContext, needWakeLock ? WAKELOCK_RELEASE_ON_FINISHED : 0, /*code*/
                keyIntent, this, mEventHandler);
            } catch (CanceledException e) {
                Log.e(TAG, "Error sending pending intent " + mPRStack.peek());
                e.printStackTrace();
            }
        } else {
            // through AudioManager
            if (needWakeLock) {
                keyIntent.putExtra(EXTRA_WAKELOCK_ACQUIRED, WAKELOCK_RELEASE_ON_FINISHED);
            }
            final long ident = Binder.clearCallingIdentity();
            try {
                mContext.sendOrderedBroadcastAsUser(keyIntent, UserHandle.ALL, null, mKeyEventDone, mEventHandler, Activity.RESULT_OK, null, null);
            } finally {
                Binder.restoreCallingIdentity(ident);
            }
        }
    }
}
------------------------
Find a silently evolved API code:android.widget.EdgeEffect.onRelease:COMMENT
Method Modifier: public      
Comment:/**
 * Call when the object is released after being pulled.
 * This will begin the "decay" phase of the effect. After calling this method
 * the host view should {@link android.view.View#invalidate()} and thereby
 * draw the results accordingly.
 */

Body of Frist Method:
{
    mPullDistance = 0;
    if (mState != STATE_PULL && mState != STATE_PULL_DECAY) {
        return;
    }
    mState = STATE_RECEDE;
    mEdgeAlphaStart = mEdgeAlpha;
    mEdgeScaleYStart = mEdgeScaleY;
    mGlowAlphaStart = mGlowAlpha;
    mGlowScaleYStart = mGlowScaleY;
    mEdgeAlphaFinish = 0.f;
    mEdgeScaleYFinish = 0.f;
    mGlowAlphaFinish = 0.f;
    mGlowScaleYFinish = 0.f;
    mStartTime = AnimationUtils.currentAnimationTimeMillis();
    mDuration = RECEDE_TIME;
}
Body of Second Method:
{
    mPullDistance = 0;
    if (mState != STATE_PULL && mState != STATE_PULL_DECAY) {
        return;
    }
    mState = STATE_RECEDE;
    mGlowAlphaStart = mGlowAlpha;
    mGlowScaleYStart = mGlowScaleY;
    mGlowAlphaFinish = 0.f;
    mGlowScaleYFinish = 0.f;
    mStartTime = AnimationUtils.currentAnimationTimeMillis();
    mDuration = RECEDE_TIME;
}
------------------------
Find a silently evolved API code:android.widget.CalendarView.getFirstDayOfWeek:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the first day of week.
 *
 * @return The first day of the week conforming to the {@link CalendarView}
 * APIs.
 * @see Calendar#MONDAY
 * @see Calendar#TUESDAY
 * @see Calendar#WEDNESDAY
 * @see Calendar#THURSDAY
 * @see Calendar#FRIDAY
 * @see Calendar#SATURDAY
 * @see Calendar#SUNDAY
 *
 * @attr ref android.R.styleable#CalendarView_firstDayOfWeek
 */

Body of Frist Method:
{
    return mFirstDayOfWeek;
}
Body of Second Method:
{
    return mDelegate.getFirstDayOfWeek();
}
------------------------
Find a silently evolved API code:android.widget.FastScroller.isPointInside:COMMENT
Method Modifier: private     
Comment:/**
 * Returns whether a coordinate is inside the scroller's activation area. If
 * there is a track image, touching anywhere within the thumb-width of the
 * track activates scrolling. Otherwise, the user has to touch inside thumb
 * itself.
 *
 * @param x The x-coordinate.
 * @param y The y-coordinate.
 * @return Whether the coordinate is inside the scroller's activation area.
 */

Body of Frist Method:
{
    return isPointInsideX(x) && (mHasTrackImage || isPointInsideY(y));
}
Body of Second Method:
{
    return isPointInsideX(x) && (mTrackDrawable != null || isPointInsideY(y));
}
------------------------
Find a silently evolved API code:android.media.RemoteController.setArtworkConfiguration:COMMENT
<android.media.RemoteController: boolean setArtworkConfiguration(boolean,int,int)>
public      hidden      ->public      hidden      deprecated  
Method Modifier: public      hidden      deprecated  
Method Modifier: Yes         Yes         No          
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * @hide
 * @param wantBitmap
 * @param width
 * @param height
 * @return true if successful
 * @throws IllegalArgumentException
 */

Body of Frist Method:
{
    synchronized (mInfoLock) {
        if (wantBitmap) {
            if ((width > 0) && (height > 0)) {
                if (width > mMaxBitmapDimension) {
                    width = mMaxBitmapDimension;
                }
                if (height > mMaxBitmapDimension) {
                    height = mMaxBitmapDimension;
                }
                mArtworkWidth = width;
                mArtworkHeight = height;
            } else {
                throw new IllegalArgumentException("Invalid dimensions");
            }
        } else {
            mArtworkWidth = -1;
            mArtworkHeight = -1;
        }
        if (mIsRegistered) {
            mAudioManager.remoteControlDisplayUsesBitmapSize(mRcd, mArtworkWidth, mArtworkHeight);
        }
    // else new values have been stored, and will be read by AudioManager with
    // RemoteController.getArtworkSize() when AudioManager.registerRemoteController()
    // is called.
    }
    return true;
}
Body of Second Method:
{
    synchronized (mInfoLock) {
        if (wantBitmap) {
            if ((width > 0) && (height > 0)) {
                if (width > mMaxBitmapDimension) {
                    width = mMaxBitmapDimension;
                }
                if (height > mMaxBitmapDimension) {
                    height = mMaxBitmapDimension;
                }
                mArtworkWidth = width;
                mArtworkHeight = height;
            } else {
                throw new IllegalArgumentException("Invalid dimensions");
            }
        } else {
            mArtworkWidth = -1;
            mArtworkHeight = -1;
        }
    }
    return true;
}
------------------------
Find a silently evolved API code:android.media.MediaFocusControl.setNewRcClientOnDisplays_syncRcsCurrc:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Update the remote control displays with the new "focused" client generation
 */

Body of Frist Method:
{
    synchronized (mRCStack) {
        if (mRcDisplays.size() > 0) {
            final Iterator<DisplayInfoForServer> displayIterator = mRcDisplays.iterator();
            while (displayIterator.hasNext()) {
                final DisplayInfoForServer di = displayIterator.next();
                try {
                    di.mRcDisplay.setCurrentClientId(newClientGeneration, newMediaIntent, clearing);
                } catch (RemoteException e) {
                    Log.e(TAG, "Dead display in setNewRcClientOnDisplays_syncRcsCurrc()", e);
                    di.release();
                    displayIterator.remove();
                }
            }
        }
    }
}
Body of Second Method:
{
    synchronized (mPRStack) {
        if (mRcDisplays.size() > 0) {
            final Iterator<DisplayInfoForServer> displayIterator = mRcDisplays.iterator();
            while (displayIterator.hasNext()) {
                final DisplayInfoForServer di = displayIterator.next();
                try {
                    di.mRcDisplay.setCurrentClientId(newClientGeneration, newMediaIntent, clearing);
                } catch (RemoteException e) {
                    Log.e(TAG, "Dead display in setNewRcClientOnDisplays_syncRcsCurrc()", e);
                    di.release();
                    displayIterator.remove();
                }
            }
        }
    }
}
------------------------
Find a silently evolved API code:android.view.LayoutInflater.createView:COMMENT
Method Modifier: public      final       
Comment:/**
 * Low-level function for instantiating a view by name. This attempts to
 * instantiate a view class of the given <var>name</var> found in this
 * LayoutInflater's ClassLoader.
 *
 * <p>
 * There are two things that can happen in an error case: either the
 * exception describing the error will be thrown, or a null will be
 * returned. You must deal with both possibilities -- the former will happen
 * the first time createView() is called for a class of a particular name,
 * the latter every time there-after for that class name.
 *
 * @param name The full name of the class to be instantiated.
 * @param attrs The XML attributes supplied for this instance.
 *
 * @return View The newly instantiated view, or null.
 */

Body of Frist Method:
{
    Constructor<? extends View> constructor = sConstructorMap.get(name);
    Class<? extends View> clazz = null;
    try {
        Trace.traceBegin(Trace.TRACE_TAG_VIEW, name);
        if (constructor == null) {
            // Class not found in the cache, see if it's real, and try to add it
            clazz = mContext.getClassLoader().loadClass(prefix != null ? (prefix + name) : name).asSubclass(View.class);
            if (mFilter != null && clazz != null) {
                boolean allowed = mFilter.onLoadClass(clazz);
                if (!allowed) {
                    failNotAllowed(name, prefix, attrs);
                }
            }
            constructor = clazz.getConstructor(mConstructorSignature);
            sConstructorMap.put(name, constructor);
        } else {
            // If we have a filter, apply it to cached constructor
            if (mFilter != null) {
                // Have we seen this name before?
                Boolean allowedState = mFilterMap.get(name);
                if (allowedState == null) {
                    // New class -- remember whether it is allowed
                    clazz = mContext.getClassLoader().loadClass(prefix != null ? (prefix + name) : name).asSubclass(View.class);
                    boolean allowed = clazz != null && mFilter.onLoadClass(clazz);
                    mFilterMap.put(name, allowed);
                    if (!allowed) {
                        failNotAllowed(name, prefix, attrs);
                    }
                } else if (allowedState.equals(Boolean.FALSE)) {
                    failNotAllowed(name, prefix, attrs);
                }
            }
        }
        Object[] args = mConstructorArgs;
        args[1] = attrs;
        final View view = constructor.newInstance(args);
        if (view instanceof ViewStub) {
            // always use ourselves when inflating ViewStub later
            final ViewStub viewStub = (ViewStub) view;
            viewStub.setLayoutInflater(this);
        }
        return view;
    } catch (NoSuchMethodException e) {
        InflateException ie = new InflateException(attrs.getPositionDescription() + ": Error inflating class " + (prefix != null ? (prefix + name) : name));
        ie.initCause(e);
        throw ie;
    } catch (ClassCastException e) {
        // If loaded class is not a View subclass
        InflateException ie = new InflateException(attrs.getPositionDescription() + ": Class is not a View " + (prefix != null ? (prefix + name) : name));
        ie.initCause(e);
        throw ie;
    } catch (ClassNotFoundException e) {
        // If loadClass fails, we should propagate the exception.
        throw e;
    } catch (Exception e) {
        InflateException ie = new InflateException(attrs.getPositionDescription() + ": Error inflating class " + (clazz == null ? "<unknown>" : clazz.getName()));
        ie.initCause(e);
        throw ie;
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_VIEW);
    }
}
Body of Second Method:
{
    Constructor<? extends View> constructor = sConstructorMap.get(name);
    Class<? extends View> clazz = null;
    try {
        Trace.traceBegin(Trace.TRACE_TAG_VIEW, name);
        if (constructor == null) {
            // Class not found in the cache, see if it's real, and try to add it
            clazz = mContext.getClassLoader().loadClass(prefix != null ? (prefix + name) : name).asSubclass(View.class);
            if (mFilter != null && clazz != null) {
                boolean allowed = mFilter.onLoadClass(clazz);
                if (!allowed) {
                    failNotAllowed(name, prefix, attrs);
                }
            }
            constructor = clazz.getConstructor(mConstructorSignature);
            sConstructorMap.put(name, constructor);
        } else {
            // If we have a filter, apply it to cached constructor
            if (mFilter != null) {
                // Have we seen this name before?
                Boolean allowedState = mFilterMap.get(name);
                if (allowedState == null) {
                    // New class -- remember whether it is allowed
                    clazz = mContext.getClassLoader().loadClass(prefix != null ? (prefix + name) : name).asSubclass(View.class);
                    boolean allowed = clazz != null && mFilter.onLoadClass(clazz);
                    mFilterMap.put(name, allowed);
                    if (!allowed) {
                        failNotAllowed(name, prefix, attrs);
                    }
                } else if (allowedState.equals(Boolean.FALSE)) {
                    failNotAllowed(name, prefix, attrs);
                }
            }
        }
        Object[] args = mConstructorArgs;
        args[1] = attrs;
        constructor.setAccessible(true);
        final View view = constructor.newInstance(args);
        if (view instanceof ViewStub) {
            // Use the same context when inflating ViewStub later.
            final ViewStub viewStub = (ViewStub) view;
            viewStub.setLayoutInflater(cloneInContext((Context) args[0]));
        }
        return view;
    } catch (NoSuchMethodException e) {
        InflateException ie = new InflateException(attrs.getPositionDescription() + ": Error inflating class " + (prefix != null ? (prefix + name) : name));
        ie.initCause(e);
        throw ie;
    } catch (ClassCastException e) {
        // If loaded class is not a View subclass
        InflateException ie = new InflateException(attrs.getPositionDescription() + ": Class is not a View " + (prefix != null ? (prefix + name) : name));
        ie.initCause(e);
        throw ie;
    } catch (ClassNotFoundException e) {
        // If loadClass fails, we should propagate the exception.
        throw e;
    } catch (Exception e) {
        InflateException ie = new InflateException(attrs.getPositionDescription() + ": Error inflating class " + (clazz == null ? "<unknown>" : clazz.getName()));
        ie.initCause(e);
        throw ie;
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_VIEW);
    }
}
------------------------
Find a silently evolved API code:android.content.res.TypedArray.length:COMMENT
Method Modifier: public      
Comment:/**
 * Return the number of values in this array.
 */

Body of Frist Method:
{
    return mLength;
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    return mLength;
}
------------------------
Find a silently evolved API code:android.print.PrintManager.getGlobalPrintManagerForUser:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Creates an instance that can access all print jobs.
 *
 * @param userId The user id for which to get all print jobs.
 * @return An instance if the caller has the permission to access all print
 * jobs, null otherwise.
 * @hide
 */

Body of Frist Method:
{
    return new PrintManager(mContext, mService, userId, APP_ID_ANY);
}
Body of Second Method:
{
    if (mService == null) {
        Log.w(LOG_TAG, "Feature android.software.print not available");
        return null;
    }
    return new PrintManager(mContext, mService, userId, APP_ID_ANY);
}
------------------------
Find a silently evolved API code:android.widget.Switch.setThumbResource:COMMENT
Method Modifier: public      
Comment:/**
 * Set the drawable used for the switch "thumb" - the piece that the user
 * can physically touch and drag along the track.
 *
 * @param resId Resource ID of a thumb drawable
 *
 * @attr ref android.R.styleable#Switch_thumb
 */

Body of Frist Method:
{
    setThumbDrawable(getContext().getResources().getDrawable(resId));
}
Body of Second Method:
{
    setThumbDrawable(getContext().getDrawable(resId));
}
------------------------
Find a silently evolved API code:android.content.res.ColorStateList.withAlpha:COMMENT
Method Modifier: public      
Comment:/**
 * Creates a new ColorStateList that has the same states and
 * colors as this one but where each color has the specified alpha value
 * (0-255).
 */

Body of Frist Method:
{
    int[] colors = new int[mColors.length];
    int len = colors.length;
    for (int i = 0; i < len; i++) {
        colors[i] = (mColors[i] & 0xFFFFFF) | (alpha << 24);
    }
    return new ColorStateList(mStateSpecs, colors);
}
Body of Second Method:
{
    final int[] colors = new int[mColors.length];
    final int len = colors.length;
    for (int i = 0; i < len; i++) {
        colors[i] = (mColors[i] & 0xFFFFFF) | (alpha << 24);
    }
    return new ColorStateList(mStateSpecs, colors);
}
------------------------
Find a silently evolved API code:android.content.Intent.parseIntent:COMMENT
Method Modifier: public      static      
Comment:/**
 * Parses the "intent" element (and its children) from XML and instantiates
 * an Intent object.  The given XML parser should be located at the tag
 * where parsing should start (often named "intent"), from which the
 * basic action, data, type, and package and class name will be
 * retrieved.  The function will then parse in to any child elements,
 * looking for <category android:name="xxx"> tags to add categories and
 * <extra android:name="xxx" android:value="yyy"> to attach extra data
 * to the intent.
 *
 * @param resources The Resources to use when inflating resources.
 * @param parser The XML parser pointing at an "intent" tag.
 * @param attrs The AttributeSet interface for retrieving extended
 * attribute data at the current <var>parser</var> location.
 * @return An Intent object matching the XML data.
 * @throws XmlPullParserException If there was an XML parsing error.
 * @throws IOException If there was an I/O error.
 */

Body of Frist Method:
{
    Intent intent = new Intent();
    TypedArray sa = resources.obtainAttributes(attrs, com.android.internal.R.styleable.Intent);
    intent.setAction(sa.getString(com.android.internal.R.styleable.Intent_action));
    String data = sa.getString(com.android.internal.R.styleable.Intent_data);
    String mimeType = sa.getString(com.android.internal.R.styleable.Intent_mimeType);
    intent.setDataAndType(data != null ? Uri.parse(data) : null, mimeType);
    String packageName = sa.getString(com.android.internal.R.styleable.Intent_targetPackage);
    String className = sa.getString(com.android.internal.R.styleable.Intent_targetClass);
    if (packageName != null && className != null) {
        intent.setComponent(new ComponentName(packageName, className));
    }
    sa.recycle();
    int outerDepth = parser.getDepth();
    int type;
    while ((type = parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
        if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
            continue;
        }
        String nodeName = parser.getName();
        if (nodeName.equals("category")) {
            sa = resources.obtainAttributes(attrs, com.android.internal.R.styleable.IntentCategory);
            String cat = sa.getString(com.android.internal.R.styleable.IntentCategory_name);
            sa.recycle();
            if (cat != null) {
                intent.addCategory(cat);
            }
            XmlUtils.skipCurrentTag(parser);
        } else if (nodeName.equals("extra")) {
            if (intent.mExtras == null) {
                intent.mExtras = new Bundle();
            }
            resources.parseBundleExtra("extra", attrs, intent.mExtras);
            XmlUtils.skipCurrentTag(parser);
        } else {
            XmlUtils.skipCurrentTag(parser);
        }
    }
    return intent;
}
Body of Second Method:
{
    Intent intent = new Intent();
    TypedArray sa = resources.obtainAttributes(attrs, com.android.internal.R.styleable.Intent);
    intent.setAction(sa.getString(com.android.internal.R.styleable.Intent_action));
    String data = sa.getString(com.android.internal.R.styleable.Intent_data);
    String mimeType = sa.getString(com.android.internal.R.styleable.Intent_mimeType);
    intent.setDataAndType(data != null ? Uri.parse(data) : null, mimeType);
    String packageName = sa.getString(com.android.internal.R.styleable.Intent_targetPackage);
    String className = sa.getString(com.android.internal.R.styleable.Intent_targetClass);
    if (packageName != null && className != null) {
        intent.setComponent(new ComponentName(packageName, className));
    }
    sa.recycle();
    int outerDepth = parser.getDepth();
    int type;
    while ((type = parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
        if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
            continue;
        }
        String nodeName = parser.getName();
        if (nodeName.equals(TAG_CATEGORIES)) {
            sa = resources.obtainAttributes(attrs, com.android.internal.R.styleable.IntentCategory);
            String cat = sa.getString(com.android.internal.R.styleable.IntentCategory_name);
            sa.recycle();
            if (cat != null) {
                intent.addCategory(cat);
            }
            XmlUtils.skipCurrentTag(parser);
        } else if (nodeName.equals(TAG_EXTRA)) {
            if (intent.mExtras == null) {
                intent.mExtras = new Bundle();
            }
            resources.parseBundleExtra(TAG_EXTRA, attrs, intent.mExtras);
            XmlUtils.skipCurrentTag(parser);
        } else {
            XmlUtils.skipCurrentTag(parser);
        }
    }
    return intent;
}
------------------------
Find a silently evolved API code:android.widget.DatePicker.getMaxDate:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the maximal date supported by this {@link DatePicker} in
 * milliseconds since January 1, 1970 00:00:00 in
 * {@link TimeZone#getDefault()} time zone.
 * <p>
 * Note: The default maximal date is 12/31/2100.
 * <p>
 *
 * @return The maximal supported date.
 */

Body of Frist Method:
{
    return mCalendarView.getMaxDate();
}
Body of Second Method:
{
    return mDelegate.getMaxDate().getTimeInMillis();
}
------------------------
Find a silently evolved API code:android.view.Window.setDimAmount:COMMENT
Method Modifier: public      
Comment:/**
 * Set the amount of dim behind the window when using
 * {@link WindowManager.LayoutParams#FLAG_DIM_BEHIND}.  This overrides
 * the default dim amount of that is selected by the Window based on
 * its theme.
 *
 * @param amount The new dim amount, from 0 for no dim to 1 for full dim.
 */

Body of Frist Method:
{
    final WindowManager.LayoutParams attrs = getAttributes();
    attrs.dimAmount = amount;
    mHaveDimAmount = true;
    if (mCallback != null) {
        mCallback.onWindowAttributesChanged(attrs);
    }
}
Body of Second Method:
{
    final WindowManager.LayoutParams attrs = getAttributes();
    attrs.dimAmount = amount;
    mHaveDimAmount = true;
    dispatchWindowAttributesChanged(attrs);
}
------------------------
Find a silently evolved API code:android.appwidget.AppWidgetHostView.updateAppWidget:COMMENT
Method Modifier: public      
Comment:/**
 * Process a set of {@link RemoteViews} coming in as an update from the
 * AppWidget provider. Will animate into these new views as needed
 */

Body of Frist Method:
{
    if (LOGD)
        Log.d(TAG, "updateAppWidget called mOld=" + mOld);
    boolean recycled = false;
    View content = null;
    Exception exception = null;
    // Capture the old view into a bitmap so we can do the crossfade.
    if (CROSSFADE) {
        if (mFadeStartTime < 0) {
            if (mView != null) {
                final int width = mView.getWidth();
                final int height = mView.getHeight();
                try {
                    mOld = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
                } catch (OutOfMemoryError e) {
                    // we just won't do the fade
                    mOld = null;
                }
                if (mOld != null) {
                // mView.drawIntoBitmap(mOld);
                }
            }
        }
    }
    if (remoteViews == null) {
        if (mViewMode == VIEW_MODE_DEFAULT) {
            // We've already done this -- nothing to do.
            return;
        }
        content = getDefaultView();
        mLayoutId = -1;
        mViewMode = VIEW_MODE_DEFAULT;
    } else {
        // Prepare a local reference to the remote Context so we're ready to
        // inflate any requested LayoutParams.
        mRemoteContext = getRemoteContext(remoteViews);
        int layoutId = remoteViews.getLayoutId();
        // layout matches, try recycling it
        if (content == null && layoutId == mLayoutId) {
            try {
                remoteViews.reapply(mContext, mView, mOnClickHandler);
                content = mView;
                recycled = true;
                if (LOGD)
                    Log.d(TAG, "was able to recycled existing layout");
            } catch (RuntimeException e) {
                exception = e;
            }
        }
        // Try normal RemoteView inflation
        if (content == null) {
            try {
                content = remoteViews.apply(mContext, this, mOnClickHandler);
                if (LOGD)
                    Log.d(TAG, "had to inflate new layout");
            } catch (RuntimeException e) {
                exception = e;
            }
        }
        mLayoutId = layoutId;
        mViewMode = VIEW_MODE_CONTENT;
    }
    if (content == null) {
        if (mViewMode == VIEW_MODE_ERROR) {
            // We've already done this -- nothing to do.
            return;
        }
        Log.w(TAG, "updateAppWidget couldn't find any view, using error view", exception);
        content = getErrorView();
        mViewMode = VIEW_MODE_ERROR;
    }
    if (!recycled) {
        prepareView(content);
        addView(content);
    }
    if (mView != content) {
        removeView(mView);
        mView = content;
    }
    if (CROSSFADE) {
        if (mFadeStartTime < 0) {
            // if there is already an animation in progress, don't do anything --
            // the new view will pop in on top of the old one during the cross fade,
            // and that looks okay.
            mFadeStartTime = SystemClock.uptimeMillis();
            invalidate();
        }
    }
}
Body of Second Method:
{
    if (LOGD)
        Log.d(TAG, "updateAppWidget called mOld=" + mOld);
    boolean recycled = false;
    View content = null;
    Exception exception = null;
    // Capture the old view into a bitmap so we can do the crossfade.
    if (CROSSFADE) {
        if (mFadeStartTime < 0) {
            if (mView != null) {
                final int width = mView.getWidth();
                final int height = mView.getHeight();
                try {
                    mOld = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
                } catch (OutOfMemoryError e) {
                    // we just won't do the fade
                    mOld = null;
                }
                if (mOld != null) {
                // mView.drawIntoBitmap(mOld);
                }
            }
        }
    }
    if (remoteViews == null) {
        if (mViewMode == VIEW_MODE_DEFAULT) {
            // We've already done this -- nothing to do.
            return;
        }
        content = getDefaultView();
        mLayoutId = -1;
        mViewMode = VIEW_MODE_DEFAULT;
    } else {
        // Prepare a local reference to the remote Context so we're ready to
        // inflate any requested LayoutParams.
        mRemoteContext = getRemoteContext();
        int layoutId = remoteViews.getLayoutId();
        // layout matches, try recycling it
        if (content == null && layoutId == mLayoutId) {
            try {
                remoteViews.reapply(mContext, mView, mOnClickHandler);
                content = mView;
                recycled = true;
                if (LOGD)
                    Log.d(TAG, "was able to recycled existing layout");
            } catch (RuntimeException e) {
                exception = e;
            }
        }
        // Try normal RemoteView inflation
        if (content == null) {
            try {
                content = remoteViews.apply(mContext, this, mOnClickHandler);
                if (LOGD)
                    Log.d(TAG, "had to inflate new layout");
            } catch (RuntimeException e) {
                exception = e;
            }
        }
        mLayoutId = layoutId;
        mViewMode = VIEW_MODE_CONTENT;
    }
    if (content == null) {
        if (mViewMode == VIEW_MODE_ERROR) {
            // We've already done this -- nothing to do.
            return;
        }
        Log.w(TAG, "updateAppWidget couldn't find any view, using error view", exception);
        content = getErrorView();
        mViewMode = VIEW_MODE_ERROR;
    }
    if (!recycled) {
        prepareView(content);
        addView(content);
    }
    if (mView != content) {
        removeView(mView);
        mView = content;
    }
    if (CROSSFADE) {
        if (mFadeStartTime < 0) {
            // if there is already an animation in progress, don't do anything --
            // the new view will pop in on top of the old one during the cross fade,
            // and that looks okay.
            mFadeStartTime = SystemClock.uptimeMillis();
            invalidate();
        }
    }
}
------------------------
Find a silently evolved API code:android.content.res.TypedArray.getIndexCount:COMMENT
Method Modifier: public      
Comment:/**
 * Return the number of indices in the array that actually have data.
 */

Body of Frist Method:
{
    return mIndices[0];
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    return mIndices[0];
}
------------------------
Find a silently evolved API code:android.util.EventLog.Event.getData:COMMENT
Method Modifier: public      
Comment:/**
 * @return one of Integer, Long, String, null, or Object[] of same.
 */

Body of Frist Method:
{
    try {
        mBuffer.limit(PAYLOAD_START + mBuffer.getShort(LENGTH_OFFSET));
        // Just after the tag.
        mBuffer.position(DATA_START);
        return decodeObject();
    } catch (IllegalArgumentException e) {
        Log.wtf(TAG, "Illegal entry payload: tag=" + getTag(), e);
        return null;
    } catch (BufferUnderflowException e) {
        Log.wtf(TAG, "Truncated entry payload: tag=" + getTag(), e);
        return null;
    }
}
Body of Second Method:
{
    try {
        int offset = mBuffer.getShort(HEADER_SIZE_OFFSET);
        if (offset == 0) {
            offset = V1_PAYLOAD_START;
        }
        mBuffer.limit(offset + mBuffer.getShort(LENGTH_OFFSET));
        // Just after the tag.
        mBuffer.position(offset + DATA_OFFSET);
        return decodeObject();
    } catch (IllegalArgumentException e) {
        Log.wtf(TAG, "Illegal entry payload: tag=" + getTag(), e);
        return null;
    } catch (BufferUnderflowException e) {
        Log.wtf(TAG, "Truncated entry payload: tag=" + getTag(), e);
        return null;
    }
}
------------------------
Find a silently evolved API code:android.app.SearchDialog.updateSearchBadge:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Setup the search "Badge" if requested by mode flags.
 */

Body of Frist Method:
{
    // assume both hidden
    int visibility = View.GONE;
    Drawable icon = null;
    CharSequence text = null;
    // optionally show one or the other.
    if (mSearchable.useBadgeIcon()) {
        icon = mActivityContext.getResources().getDrawable(mSearchable.getIconId());
        visibility = View.VISIBLE;
        if (DBG)
            Log.d(LOG_TAG, "Using badge icon: " + mSearchable.getIconId());
    } else if (mSearchable.useBadgeLabel()) {
        text = mActivityContext.getResources().getText(mSearchable.getLabelId()).toString();
        visibility = View.VISIBLE;
        if (DBG)
            Log.d(LOG_TAG, "Using badge label: " + mSearchable.getLabelId());
    }
    mBadgeLabel.setCompoundDrawablesWithIntrinsicBounds(icon, null, null, null);
    mBadgeLabel.setText(text);
    mBadgeLabel.setVisibility(visibility);
}
Body of Second Method:
{
    // assume both hidden
    int visibility = View.GONE;
    Drawable icon = null;
    CharSequence text = null;
    // optionally show one or the other.
    if (mSearchable.useBadgeIcon()) {
        icon = mActivityContext.getDrawable(mSearchable.getIconId());
        visibility = View.VISIBLE;
        if (DBG)
            Log.d(LOG_TAG, "Using badge icon: " + mSearchable.getIconId());
    } else if (mSearchable.useBadgeLabel()) {
        text = mActivityContext.getResources().getText(mSearchable.getLabelId()).toString();
        visibility = View.VISIBLE;
        if (DBG)
            Log.d(LOG_TAG, "Using badge label: " + mSearchable.getLabelId());
    }
    mBadgeLabel.setCompoundDrawablesWithIntrinsicBounds(icon, null, null, null);
    mBadgeLabel.setText(text);
    mBadgeLabel.setVisibility(visibility);
}
------------------------
Find a silently evolved API code:android.content.Intent.migrateExtraStreamToClipData:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Migrate any {@link #EXTRA_STREAM} in {@link #ACTION_SEND} and
 * {@link #ACTION_SEND_MULTIPLE} to {@link ClipData}. Also inspects nested
 * intents in {@link #ACTION_CHOOSER}.
 *
 * @return Whether any contents were migrated.
 * @hide
 */

Body of Frist Method:
{
    // Refuse to touch if extras already parcelled
    if (mExtras != null && mExtras.isParcelled())
        return false;
    // Bail when someone already gave us ClipData
    if (getClipData() != null)
        return false;
    final String action = getAction();
    if (ACTION_CHOOSER.equals(action)) {
        try {
            // Inspect target intent to see if we need to migrate
            final Intent target = getParcelableExtra(EXTRA_INTENT);
            if (target != null && target.migrateExtraStreamToClipData()) {
                // Since we migrated in child, we need to promote ClipData
                // and flags to ourselves to grant.
                setClipData(target.getClipData());
                addFlags(target.getFlags() & (FLAG_GRANT_READ_URI_PERMISSION | FLAG_GRANT_WRITE_URI_PERMISSION | FLAG_GRANT_PERSISTABLE_URI_PERMISSION));
                return true;
            } else {
                return false;
            }
        } catch (ClassCastException e) {
        }
    } else if (ACTION_SEND.equals(action)) {
        try {
            final Uri stream = getParcelableExtra(EXTRA_STREAM);
            final CharSequence text = getCharSequenceExtra(EXTRA_TEXT);
            final String htmlText = getStringExtra(EXTRA_HTML_TEXT);
            if (stream != null || text != null || htmlText != null) {
                final ClipData clipData = new ClipData(null, new String[] { getType() }, new ClipData.Item(text, htmlText, null, stream));
                setClipData(clipData);
                addFlags(FLAG_GRANT_READ_URI_PERMISSION);
                return true;
            }
        } catch (ClassCastException e) {
        }
    } else if (ACTION_SEND_MULTIPLE.equals(action)) {
        try {
            final ArrayList<Uri> streams = getParcelableArrayListExtra(EXTRA_STREAM);
            final ArrayList<CharSequence> texts = getCharSequenceArrayListExtra(EXTRA_TEXT);
            final ArrayList<String> htmlTexts = getStringArrayListExtra(EXTRA_HTML_TEXT);
            int num = -1;
            if (streams != null) {
                num = streams.size();
            }
            if (texts != null) {
                if (num >= 0 && num != texts.size()) {
                    // Wha...!  F- you.
                    return false;
                }
                num = texts.size();
            }
            if (htmlTexts != null) {
                if (num >= 0 && num != htmlTexts.size()) {
                    // Wha...!  F- you.
                    return false;
                }
                num = htmlTexts.size();
            }
            if (num > 0) {
                final ClipData clipData = new ClipData(null, new String[] { getType() }, makeClipItem(streams, texts, htmlTexts, 0));
                for (int i = 1; i < num; i++) {
                    clipData.addItem(makeClipItem(streams, texts, htmlTexts, i));
                }
                setClipData(clipData);
                addFlags(FLAG_GRANT_READ_URI_PERMISSION);
                return true;
            }
        } catch (ClassCastException e) {
        }
    }
    return false;
}
Body of Second Method:
{
    // Refuse to touch if extras already parcelled
    if (mExtras != null && mExtras.isParcelled())
        return false;
    // Bail when someone already gave us ClipData
    if (getClipData() != null)
        return false;
    final String action = getAction();
    if (ACTION_CHOOSER.equals(action)) {
        // Inspect contained intents to see if we need to migrate extras. We
        // don't promote ClipData to the parent, since ChooserActivity will
        // already start the picked item as the caller, and we can't combine
        // the flags in a safe way.
        boolean migrated = false;
        try {
            final Intent intent = getParcelableExtra(EXTRA_INTENT);
            if (intent != null) {
                migrated |= intent.migrateExtraStreamToClipData();
            }
        } catch (ClassCastException e) {
        }
        try {
            final Parcelable[] intents = getParcelableArrayExtra(EXTRA_INITIAL_INTENTS);
            if (intents != null) {
                for (int i = 0; i < intents.length; i++) {
                    final Intent intent = (Intent) intents[i];
                    if (intent != null) {
                        migrated |= intent.migrateExtraStreamToClipData();
                    }
                }
            }
        } catch (ClassCastException e) {
        }
        return migrated;
    } else if (ACTION_SEND.equals(action)) {
        try {
            final Uri stream = getParcelableExtra(EXTRA_STREAM);
            final CharSequence text = getCharSequenceExtra(EXTRA_TEXT);
            final String htmlText = getStringExtra(EXTRA_HTML_TEXT);
            if (stream != null || text != null || htmlText != null) {
                final ClipData clipData = new ClipData(null, new String[] { getType() }, new ClipData.Item(text, htmlText, null, stream));
                setClipData(clipData);
                addFlags(FLAG_GRANT_READ_URI_PERMISSION);
                return true;
            }
        } catch (ClassCastException e) {
        }
    } else if (ACTION_SEND_MULTIPLE.equals(action)) {
        try {
            final ArrayList<Uri> streams = getParcelableArrayListExtra(EXTRA_STREAM);
            final ArrayList<CharSequence> texts = getCharSequenceArrayListExtra(EXTRA_TEXT);
            final ArrayList<String> htmlTexts = getStringArrayListExtra(EXTRA_HTML_TEXT);
            int num = -1;
            if (streams != null) {
                num = streams.size();
            }
            if (texts != null) {
                if (num >= 0 && num != texts.size()) {
                    // Wha...!  F- you.
                    return false;
                }
                num = texts.size();
            }
            if (htmlTexts != null) {
                if (num >= 0 && num != htmlTexts.size()) {
                    // Wha...!  F- you.
                    return false;
                }
                num = htmlTexts.size();
            }
            if (num > 0) {
                final ClipData clipData = new ClipData(null, new String[] { getType() }, makeClipItem(streams, texts, htmlTexts, 0));
                for (int i = 1; i < num; i++) {
                    clipData.addItem(makeClipItem(streams, texts, htmlTexts, i));
                }
                setClipData(clipData);
                addFlags(FLAG_GRANT_READ_URI_PERMISSION);
                return true;
            }
        } catch (ClassCastException e) {
        }
    } else if (MediaStore.ACTION_IMAGE_CAPTURE.equals(action) || MediaStore.ACTION_IMAGE_CAPTURE_SECURE.equals(action) || MediaStore.ACTION_VIDEO_CAPTURE.equals(action)) {
        final Uri output;
        try {
            output = getParcelableExtra(MediaStore.EXTRA_OUTPUT);
        } catch (ClassCastException e) {
            return false;
        }
        if (output != null) {
            setClipData(ClipData.newRawUri("", output));
            addFlags(FLAG_GRANT_WRITE_URI_PERMISSION | FLAG_GRANT_READ_URI_PERMISSION);
            return true;
        }
    }
    return false;
}
------------------------
Find a silently evolved API code:android.service.dreams.DreamService.setScreenBright:COMMENT
Method Modifier: public      
Comment:/**
 * Marks this dream as keeping the screen bright while dreaming.
 *
 * @param screenBright True to keep the screen bright while dreaming.
 */

Body of Frist Method:
{
    mScreenBright = screenBright;
    int flag = WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON;
    applyWindowFlags(mScreenBright ? flag : 0, flag);
}
Body of Second Method:
{
    if (mScreenBright != screenBright) {
        mScreenBright = screenBright;
        int flag = WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON;
        applyWindowFlags(mScreenBright ? flag : 0, flag);
    }
}
------------------------
Find a silently evolved API code:android.service.dreams.DreamService.dispatchTouchEvent:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    // but finish()es on any other kind of activity
    if (!mInteractive) {
        if (mDebug)
            Slog.v(TAG, "Finishing on touchEvent");
        safelyFinish();
        return true;
    }
    return mWindow.superDispatchTouchEvent(event);
}
Body of Second Method:
{
    // but finish()es on any other kind of activity
    if (!mInteractive) {
        if (mDebug)
            Slog.v(TAG, "Waking up on touchEvent");
        wakeUp();
        return true;
    }
    return mWindow.superDispatchTouchEvent(event);
}
------------------------
Find a silently evolved API code:android.os.Parcel.readValue:COMMENT
Method Modifier: public      final       
Comment:/**
 * Read a typed object from a parcel.  The given class loader will be
 * used to load any enclosed Parcelables.  If it is null, the default class
 * loader will be used.
 */

Body of Frist Method:
{
    int type = readInt();
    switch(type) {
        case VAL_NULL:
            return null;
        case VAL_STRING:
            return readString();
        case VAL_INTEGER:
            return readInt();
        case VAL_MAP:
            return readHashMap(loader);
        case VAL_PARCELABLE:
            return readParcelable(loader);
        case VAL_SHORT:
            return (short) readInt();
        case VAL_LONG:
            return readLong();
        case VAL_FLOAT:
            return readFloat();
        case VAL_DOUBLE:
            return readDouble();
        case VAL_BOOLEAN:
            return readInt() == 1;
        case VAL_CHARSEQUENCE:
            return readCharSequence();
        case VAL_LIST:
            return readArrayList(loader);
        case VAL_BOOLEANARRAY:
            return createBooleanArray();
        case VAL_BYTEARRAY:
            return createByteArray();
        case VAL_STRINGARRAY:
            return readStringArray();
        case VAL_CHARSEQUENCEARRAY:
            return readCharSequenceArray();
        case VAL_IBINDER:
            return readStrongBinder();
        case VAL_OBJECTARRAY:
            return readArray(loader);
        case VAL_INTARRAY:
            return createIntArray();
        case VAL_LONGARRAY:
            return createLongArray();
        case VAL_BYTE:
            return readByte();
        case VAL_SERIALIZABLE:
            return readSerializable();
        case VAL_PARCELABLEARRAY:
            return readParcelableArray(loader);
        case VAL_SPARSEARRAY:
            return readSparseArray(loader);
        case VAL_SPARSEBOOLEANARRAY:
            return readSparseBooleanArray();
        case VAL_BUNDLE:
            // loading will be deferred
            return readBundle(loader);
        default:
            int off = dataPosition() - 4;
            throw new RuntimeException("Parcel " + this + ": Unmarshalling unknown type code " + type + " at offset " + off);
    }
}
Body of Second Method:
{
    int type = readInt();
    switch(type) {
        case VAL_NULL:
            return null;
        case VAL_STRING:
            return readString();
        case VAL_INTEGER:
            return readInt();
        case VAL_MAP:
            return readHashMap(loader);
        case VAL_PARCELABLE:
            return readParcelable(loader);
        case VAL_SHORT:
            return (short) readInt();
        case VAL_LONG:
            return readLong();
        case VAL_FLOAT:
            return readFloat();
        case VAL_DOUBLE:
            return readDouble();
        case VAL_BOOLEAN:
            return readInt() == 1;
        case VAL_CHARSEQUENCE:
            return readCharSequence();
        case VAL_LIST:
            return readArrayList(loader);
        case VAL_BOOLEANARRAY:
            return createBooleanArray();
        case VAL_BYTEARRAY:
            return createByteArray();
        case VAL_STRINGARRAY:
            return readStringArray();
        case VAL_CHARSEQUENCEARRAY:
            return readCharSequenceArray();
        case VAL_IBINDER:
            return readStrongBinder();
        case VAL_OBJECTARRAY:
            return readArray(loader);
        case VAL_INTARRAY:
            return createIntArray();
        case VAL_LONGARRAY:
            return createLongArray();
        case VAL_BYTE:
            return readByte();
        case VAL_SERIALIZABLE:
            return readSerializable(loader);
        case VAL_PARCELABLEARRAY:
            return readParcelableArray(loader);
        case VAL_SPARSEARRAY:
            return readSparseArray(loader);
        case VAL_SPARSEBOOLEANARRAY:
            return readSparseBooleanArray();
        case VAL_BUNDLE:
            // loading will be deferred
            return readBundle(loader);
        case VAL_PERSISTABLEBUNDLE:
            return readPersistableBundle(loader);
        case VAL_SIZE:
            return readSize();
        case VAL_SIZEF:
            return readSizeF();
        default:
            int off = dataPosition() - 4;
            throw new RuntimeException("Parcel " + this + ": Unmarshalling unknown type code " + type + " at offset " + off);
    }
}
------------------------
Find a silently evolved API code:android.view.accessibility.AccessibilityNodeInfo.setLabelFor:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the view for which the view represented by this info serves as a
 * label for accessibility purposes. If <code>virtualDescendantId</code>
 * is {@link View#NO_ID} the root is set as the labeled.
 * <p>
 * A virtual descendant is an imaginary View that is reported as a part of the view
 * hierarchy for accessibility purposes. This enables custom views that draw complex
 * content to report themselves as a tree of virtual views, thus conveying their
 * logical structure.
 * </p>
 * <p>
 * <strong>Note:</strong> Cannot be called from an
 * {@link android.accessibilityservice.AccessibilityService}.
 * This class is made immutable before being delivered to an AccessibilityService.
 * </p>
 *
 * @param root The root whose virtual descendant serves as a label.
 * @param virtualDescendantId The id of the virtual descendant.
 */

Body of Frist Method:
{
    enforceNotSealed();
    final int rootAccessibilityViewId = (root != null) ? root.getAccessibilityViewId() : UNDEFINED;
    mLabelForId = makeNodeId(rootAccessibilityViewId, virtualDescendantId);
}
Body of Second Method:
{
    enforceNotSealed();
    final int rootAccessibilityViewId = (root != null) ? root.getAccessibilityViewId() : UNDEFINED_ITEM_ID;
    mLabelForId = makeNodeId(rootAccessibilityViewId, virtualDescendantId);
}
------------------------
Find a silently evolved API code:android.text.Layout.drawBackground:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    // They are evaluated at each line.
    if (mSpannedText) {
        if (mLineBackgroundSpans == null) {
            mLineBackgroundSpans = new SpanSet<LineBackgroundSpan>(LineBackgroundSpan.class);
        }
        Spanned buffer = (Spanned) mText;
        int textLength = buffer.length();
        mLineBackgroundSpans.init(buffer, 0, textLength);
        if (mLineBackgroundSpans.numberOfSpans > 0) {
            int previousLineBottom = getLineTop(firstLine);
            int previousLineEnd = getLineStart(firstLine);
            ParagraphStyle[] spans = NO_PARA_SPANS;
            int spansLength = 0;
            TextPaint paint = mPaint;
            int spanEnd = 0;
            final int width = mWidth;
            for (int i = firstLine; i <= lastLine; i++) {
                int start = previousLineEnd;
                int end = getLineStart(i + 1);
                previousLineEnd = end;
                int ltop = previousLineBottom;
                int lbottom = getLineTop(i + 1);
                previousLineBottom = lbottom;
                int lbaseline = lbottom - getLineDescent(i);
                if (start >= spanEnd) {
                    // These should be infrequent, so we'll use this so that
                    // we don't have to check as often.
                    spanEnd = mLineBackgroundSpans.getNextTransition(start, textLength);
                    // All LineBackgroundSpans on a line contribute to its background.
                    spansLength = 0;
                    // Duplication of the logic of getParagraphSpans
                    if (start != end || start == 0) {
                        // array instead to reduce memory allocation
                        for (int j = 0; j < mLineBackgroundSpans.numberOfSpans; j++) {
                            // construction
                            if (mLineBackgroundSpans.spanStarts[j] >= end || mLineBackgroundSpans.spanEnds[j] <= start)
                                continue;
                            if (spansLength == spans.length) {
                                // The spans array needs to be expanded
                                int newSize = ArrayUtils.idealObjectArraySize(2 * spansLength);
                                ParagraphStyle[] newSpans = new ParagraphStyle[newSize];
                                System.arraycopy(spans, 0, newSpans, 0, spansLength);
                                spans = newSpans;
                            }
                            spans[spansLength++] = mLineBackgroundSpans.spans[j];
                        }
                    }
                }
                for (int n = 0; n < spansLength; n++) {
                    LineBackgroundSpan lineBackgroundSpan = (LineBackgroundSpan) spans[n];
                    lineBackgroundSpan.drawBackground(canvas, paint, 0, width, ltop, lbaseline, lbottom, buffer, start, end, i);
                }
            }
        }
        mLineBackgroundSpans.recycle();
    }
    // a non-spanned transformation of a spanned editing buffer.
    if (highlight != null) {
        if (cursorOffsetVertical != 0)
            canvas.translate(0, cursorOffsetVertical);
        canvas.drawPath(highlight, highlightPaint);
        if (cursorOffsetVertical != 0)
            canvas.translate(0, -cursorOffsetVertical);
    }
}
Body of Second Method:
{
    // They are evaluated at each line.
    if (mSpannedText) {
        if (mLineBackgroundSpans == null) {
            mLineBackgroundSpans = new SpanSet<LineBackgroundSpan>(LineBackgroundSpan.class);
        }
        Spanned buffer = (Spanned) mText;
        int textLength = buffer.length();
        mLineBackgroundSpans.init(buffer, 0, textLength);
        if (mLineBackgroundSpans.numberOfSpans > 0) {
            int previousLineBottom = getLineTop(firstLine);
            int previousLineEnd = getLineStart(firstLine);
            ParagraphStyle[] spans = NO_PARA_SPANS;
            int spansLength = 0;
            TextPaint paint = mPaint;
            int spanEnd = 0;
            final int width = mWidth;
            for (int i = firstLine; i <= lastLine; i++) {
                int start = previousLineEnd;
                int end = getLineStart(i + 1);
                previousLineEnd = end;
                int ltop = previousLineBottom;
                int lbottom = getLineTop(i + 1);
                previousLineBottom = lbottom;
                int lbaseline = lbottom - getLineDescent(i);
                if (start >= spanEnd) {
                    // These should be infrequent, so we'll use this so that
                    // we don't have to check as often.
                    spanEnd = mLineBackgroundSpans.getNextTransition(start, textLength);
                    // All LineBackgroundSpans on a line contribute to its background.
                    spansLength = 0;
                    // Duplication of the logic of getParagraphSpans
                    if (start != end || start == 0) {
                        // array instead to reduce memory allocation
                        for (int j = 0; j < mLineBackgroundSpans.numberOfSpans; j++) {
                            // construction
                            if (mLineBackgroundSpans.spanStarts[j] >= end || mLineBackgroundSpans.spanEnds[j] <= start)
                                continue;
                            spans = GrowingArrayUtils.append(spans, spansLength, mLineBackgroundSpans.spans[j]);
                            spansLength++;
                        }
                    }
                }
                for (int n = 0; n < spansLength; n++) {
                    LineBackgroundSpan lineBackgroundSpan = (LineBackgroundSpan) spans[n];
                    lineBackgroundSpan.drawBackground(canvas, paint, 0, width, ltop, lbaseline, lbottom, buffer, start, end, i);
                }
            }
        }
        mLineBackgroundSpans.recycle();
    }
    // a non-spanned transformation of a spanned editing buffer.
    if (highlight != null) {
        if (cursorOffsetVertical != 0)
            canvas.translate(0, cursorOffsetVertical);
        canvas.drawPath(highlight, highlightPaint);
        if (cursorOffsetVertical != 0)
            canvas.translate(0, -cursorOffsetVertical);
    }
}
------------------------
Find a silently evolved API code:android.widget.ShareActionProvider.setActivityChooserPolicyIfNeeded:COMMENT
Method Modifier: private     
Comment:/**
 * Set the activity chooser policy of the model backed by the current
 * share history file if needed which is if there is a registered callback.
 */

Body of Frist Method:
{
    if (mOnShareTargetSelectedListener == null) {
        return;
    }
    if (mOnChooseActivityListener == null) {
        mOnChooseActivityListener = new ShareAcitivityChooserModelPolicy();
    }
    ActivityChooserModel dataModel = ActivityChooserModel.get(mContext, mShareHistoryFileName);
    dataModel.setOnChooseActivityListener(mOnChooseActivityListener);
}
Body of Second Method:
{
    if (mOnShareTargetSelectedListener == null) {
        return;
    }
    if (mOnChooseActivityListener == null) {
        mOnChooseActivityListener = new ShareActivityChooserModelPolicy();
    }
    ActivityChooserModel dataModel = ActivityChooserModel.get(mContext, mShareHistoryFileName);
    dataModel.setOnChooseActivityListener(mOnChooseActivityListener);
}
------------------------
Find a silently evolved API code:android.util.SparseLongArray.put:COMMENT
Method Modifier: public      
Comment:/**
 * Adds a mapping from the specified key to the specified value,
 * replacing the previous mapping from the specified key if there
 * was one.
 */

Body of Frist Method:
{
    int i = ContainerHelpers.binarySearch(mKeys, mSize, key);
    if (i >= 0) {
        mValues[i] = value;
    } else {
        i = ~i;
        if (mSize >= mKeys.length) {
            growKeyAndValueArrays(mSize + 1);
        }
        if (mSize - i != 0) {
            System.arraycopy(mKeys, i, mKeys, i + 1, mSize - i);
            System.arraycopy(mValues, i, mValues, i + 1, mSize - i);
        }
        mKeys[i] = key;
        mValues[i] = value;
        mSize++;
    }
}
Body of Second Method:
{
    int i = ContainerHelpers.binarySearch(mKeys, mSize, key);
    if (i >= 0) {
        mValues[i] = value;
    } else {
        i = ~i;
        mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);
        mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);
        mSize++;
    }
}
------------------------
Find a silently evolved API code:android.widget.ListView.addFooterView:COMMENT
Method Modifier: public      
Comment:/**
 * Add a fixed view to appear at the bottom of the list. If addFooterView is
 * called more than once, the views will appear in the order they were
 * added. Views added using this call can take focus if they want.
 * <p>
 * Note: When first introduced, this method could only be called before
 * setting the adapter with {@link #setAdapter(ListAdapter)}. Starting with
 * {@link android.os.Build.VERSION_CODES#KITKAT}, this method may be
 * called at any time. If the ListView's adapter does not extend
 * {@link HeaderViewListAdapter}, it will be wrapped with a supporting
 * instance of {@link WrapperListAdapter}.
 *
 * @param v The view to add.
 * @param data Data to associate with this view
 * @param isSelectable true if the footer view can be selected
 */

Body of Frist Method:
{
    final FixedViewInfo info = new FixedViewInfo();
    info.view = v;
    info.data = data;
    info.isSelectable = isSelectable;
    mFooterViewInfos.add(info);
    // Wrap the adapter if it wasn't already wrapped.
    if (mAdapter != null) {
        if (!(mAdapter instanceof HeaderViewListAdapter)) {
            mAdapter = new HeaderViewListAdapter(mHeaderViewInfos, mFooterViewInfos, mAdapter);
        }
        // we need to notify the observer.
        if (mDataSetObserver != null) {
            mDataSetObserver.onChanged();
        }
    }
}
Body of Second Method:
{
    final FixedViewInfo info = new FixedViewInfo();
    info.view = v;
    info.data = data;
    info.isSelectable = isSelectable;
    mFooterViewInfos.add(info);
    mAreAllItemsSelectable &= isSelectable;
    // Wrap the adapter if it wasn't already wrapped.
    if (mAdapter != null) {
        if (!(mAdapter instanceof HeaderViewListAdapter)) {
            mAdapter = new HeaderViewListAdapter(mHeaderViewInfos, mFooterViewInfos, mAdapter);
        }
        // we need to notify the observer.
        if (mDataSetObserver != null) {
            mDataSetObserver.onChanged();
        }
    }
}
------------------------
Find a silently evolved API code:android.text.Layout.drawText:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    int previousLineBottom = getLineTop(firstLine);
    int previousLineEnd = getLineStart(firstLine);
    ParagraphStyle[] spans = NO_PARA_SPANS;
    int spanEnd = 0;
    TextPaint paint = mPaint;
    CharSequence buf = mText;
    Alignment paraAlign = mAlignment;
    TabStops tabStops = null;
    boolean tabStopsIsInitialized = false;
    TextLine tl = TextLine.obtain();
    // The baseline is the top of the following line minus the current line's descent.
    for (int i = firstLine; i <= lastLine; i++) {
        int start = previousLineEnd;
        previousLineEnd = getLineStart(i + 1);
        int end = getLineVisibleEnd(i, start, previousLineEnd);
        int ltop = previousLineBottom;
        int lbottom = getLineTop(i + 1);
        previousLineBottom = lbottom;
        int lbaseline = lbottom - getLineDescent(i);
        int dir = getParagraphDirection(i);
        int left = 0;
        int right = mWidth;
        if (mSpannedText) {
            Spanned sp = (Spanned) buf;
            int textLength = buf.length();
            boolean isFirstParaLine = (start == 0 || buf.charAt(start - 1) == '\n');
            // our problem.
            if (start >= spanEnd && (i == firstLine || isFirstParaLine)) {
                spanEnd = sp.nextSpanTransition(start, textLength, ParagraphStyle.class);
                spans = getParagraphSpans(sp, start, spanEnd, ParagraphStyle.class);
                paraAlign = mAlignment;
                for (int n = spans.length - 1; n >= 0; n--) {
                    if (spans[n] instanceof AlignmentSpan) {
                        paraAlign = ((AlignmentSpan) spans[n]).getAlignment();
                        break;
                    }
                }
                tabStopsIsInitialized = false;
            }
            // Draw all leading margin spans.  Adjust left or right according
            // to the paragraph direction of the line.
            final int length = spans.length;
            for (int n = 0; n < length; n++) {
                if (spans[n] instanceof LeadingMarginSpan) {
                    LeadingMarginSpan margin = (LeadingMarginSpan) spans[n];
                    boolean useFirstLineMargin = isFirstParaLine;
                    if (margin instanceof LeadingMarginSpan2) {
                        int count = ((LeadingMarginSpan2) margin).getLeadingMarginLineCount();
                        int startLine = getLineForOffset(sp.getSpanStart(margin));
                        useFirstLineMargin = i < startLine + count;
                    }
                    if (dir == DIR_RIGHT_TO_LEFT) {
                        margin.drawLeadingMargin(canvas, paint, right, dir, ltop, lbaseline, lbottom, buf, start, end, isFirstParaLine, this);
                        right -= margin.getLeadingMargin(useFirstLineMargin);
                    } else {
                        margin.drawLeadingMargin(canvas, paint, left, dir, ltop, lbaseline, lbottom, buf, start, end, isFirstParaLine, this);
                        left += margin.getLeadingMargin(useFirstLineMargin);
                    }
                }
            }
        }
        boolean hasTabOrEmoji = getLineContainsTab(i);
        // Can't tell if we have tabs for sure, currently
        if (hasTabOrEmoji && !tabStopsIsInitialized) {
            if (tabStops == null) {
                tabStops = new TabStops(TAB_INCREMENT, spans);
            } else {
                tabStops.reset(TAB_INCREMENT, spans);
            }
            tabStopsIsInitialized = true;
        }
        // Determine whether the line aligns to normal, opposite, or center.
        Alignment align = paraAlign;
        if (align == Alignment.ALIGN_LEFT) {
            align = (dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_NORMAL : Alignment.ALIGN_OPPOSITE;
        } else if (align == Alignment.ALIGN_RIGHT) {
            align = (dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_OPPOSITE : Alignment.ALIGN_NORMAL;
        }
        int x;
        if (align == Alignment.ALIGN_NORMAL) {
            if (dir == DIR_LEFT_TO_RIGHT) {
                x = left;
            } else {
                x = right;
            }
        } else {
            int max = (int) getLineExtent(i, tabStops, false);
            if (align == Alignment.ALIGN_OPPOSITE) {
                if (dir == DIR_LEFT_TO_RIGHT) {
                    x = right - max;
                } else {
                    x = left - max;
                }
            } else {
                // Alignment.ALIGN_CENTER
                max = max & ~1;
                x = (right + left - max) >> 1;
            }
        }
        Directions directions = getLineDirections(i);
        if (directions == DIRS_ALL_LEFT_TO_RIGHT && !mSpannedText && !hasTabOrEmoji) {
            // XXX: assumes there's nothing additional to be done
            canvas.drawText(buf, start, end, x, lbaseline, paint);
        } else {
            tl.set(paint, buf, start, end, dir, directions, hasTabOrEmoji, tabStops);
            tl.draw(canvas, x, ltop, lbaseline, lbottom);
        }
    }
    TextLine.recycle(tl);
}
Body of Second Method:
{
    int previousLineBottom = getLineTop(firstLine);
    int previousLineEnd = getLineStart(firstLine);
    ParagraphStyle[] spans = NO_PARA_SPANS;
    int spanEnd = 0;
    TextPaint paint = mPaint;
    CharSequence buf = mText;
    Alignment paraAlign = mAlignment;
    TabStops tabStops = null;
    boolean tabStopsIsInitialized = false;
    TextLine tl = TextLine.obtain();
    // The baseline is the top of the following line minus the current line's descent.
    for (int i = firstLine; i <= lastLine; i++) {
        int start = previousLineEnd;
        previousLineEnd = getLineStart(i + 1);
        int end = getLineVisibleEnd(i, start, previousLineEnd);
        int ltop = previousLineBottom;
        int lbottom = getLineTop(i + 1);
        previousLineBottom = lbottom;
        int lbaseline = lbottom - getLineDescent(i);
        int dir = getParagraphDirection(i);
        int left = 0;
        int right = mWidth;
        if (mSpannedText) {
            Spanned sp = (Spanned) buf;
            int textLength = buf.length();
            boolean isFirstParaLine = (start == 0 || buf.charAt(start - 1) == '\n');
            // our problem.
            if (start >= spanEnd && (i == firstLine || isFirstParaLine)) {
                spanEnd = sp.nextSpanTransition(start, textLength, ParagraphStyle.class);
                spans = getParagraphSpans(sp, start, spanEnd, ParagraphStyle.class);
                paraAlign = mAlignment;
                for (int n = spans.length - 1; n >= 0; n--) {
                    if (spans[n] instanceof AlignmentSpan) {
                        paraAlign = ((AlignmentSpan) spans[n]).getAlignment();
                        break;
                    }
                }
                tabStopsIsInitialized = false;
            }
            // Draw all leading margin spans.  Adjust left or right according
            // to the paragraph direction of the line.
            final int length = spans.length;
            boolean useFirstLineMargin = isFirstParaLine;
            for (int n = 0; n < length; n++) {
                if (spans[n] instanceof LeadingMarginSpan2) {
                    int count = ((LeadingMarginSpan2) spans[n]).getLeadingMarginLineCount();
                    int startLine = getLineForOffset(sp.getSpanStart(spans[n]));
                    // the count that is greatest
                    if (i < startLine + count) {
                        useFirstLineMargin = true;
                        break;
                    }
                }
            }
            for (int n = 0; n < length; n++) {
                if (spans[n] instanceof LeadingMarginSpan) {
                    LeadingMarginSpan margin = (LeadingMarginSpan) spans[n];
                    if (dir == DIR_RIGHT_TO_LEFT) {
                        margin.drawLeadingMargin(canvas, paint, right, dir, ltop, lbaseline, lbottom, buf, start, end, isFirstParaLine, this);
                        right -= margin.getLeadingMargin(useFirstLineMargin);
                    } else {
                        margin.drawLeadingMargin(canvas, paint, left, dir, ltop, lbaseline, lbottom, buf, start, end, isFirstParaLine, this);
                        left += margin.getLeadingMargin(useFirstLineMargin);
                    }
                }
            }
        }
        boolean hasTabOrEmoji = getLineContainsTab(i);
        // Can't tell if we have tabs for sure, currently
        if (hasTabOrEmoji && !tabStopsIsInitialized) {
            if (tabStops == null) {
                tabStops = new TabStops(TAB_INCREMENT, spans);
            } else {
                tabStops.reset(TAB_INCREMENT, spans);
            }
            tabStopsIsInitialized = true;
        }
        // Determine whether the line aligns to normal, opposite, or center.
        Alignment align = paraAlign;
        if (align == Alignment.ALIGN_LEFT) {
            align = (dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_NORMAL : Alignment.ALIGN_OPPOSITE;
        } else if (align == Alignment.ALIGN_RIGHT) {
            align = (dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_OPPOSITE : Alignment.ALIGN_NORMAL;
        }
        int x;
        if (align == Alignment.ALIGN_NORMAL) {
            if (dir == DIR_LEFT_TO_RIGHT) {
                x = left;
            } else {
                x = right;
            }
        } else {
            int max = (int) getLineExtent(i, tabStops, false);
            if (align == Alignment.ALIGN_OPPOSITE) {
                if (dir == DIR_LEFT_TO_RIGHT) {
                    x = right - max;
                } else {
                    x = left - max;
                }
            } else {
                // Alignment.ALIGN_CENTER
                max = max & ~1;
                x = (right + left - max) >> 1;
            }
        }
        Directions directions = getLineDirections(i);
        if (directions == DIRS_ALL_LEFT_TO_RIGHT && !mSpannedText && !hasTabOrEmoji) {
            // XXX: assumes there's nothing additional to be done
            canvas.drawText(buf, start, end, x, lbaseline, paint);
        } else {
            tl.set(paint, buf, start, end, dir, directions, hasTabOrEmoji, tabStops);
            tl.draw(canvas, x, ltop, lbaseline, lbottom);
        }
    }
    TextLine.recycle(tl);
}
------------------------
Find a silently evolved API code:android.view.Window.setBackgroundDrawableResource:COMMENT
Method Modifier: public      
Comment:/**
 * Change the background of this window to a Drawable resource. Setting the
 * background to null will make the window be opaque. To make the window
 * transparent, you can use an empty drawable (for instance a ColorDrawable
 * with the color 0 or the system drawable android:drawable/empty.)
 *
 * @param resid The resource identifier of a drawable resource which will be
 * installed as the new background.
 */

Body of Frist Method:
{
    setBackgroundDrawable(mContext.getResources().getDrawable(resid));
}
Body of Second Method:
{
    setBackgroundDrawable(mContext.getDrawable(resid));
}
------------------------
Find a silently evolved API code:android.service.dreams.DreamService.setFullscreen:COMMENT
Method Modifier: public      
Comment:/**
 * Controls {@link android.view.WindowManager.LayoutParams#FLAG_FULLSCREEN}
 * on the dream's window.
 *
 * @param fullscreen If true, the fullscreen flag will be set; else it
 * will be cleared.
 */

Body of Frist Method:
{
    mFullscreen = fullscreen;
    int flag = WindowManager.LayoutParams.FLAG_FULLSCREEN;
    applyWindowFlags(mFullscreen ? flag : 0, flag);
}
Body of Second Method:
{
    if (mFullscreen != fullscreen) {
        mFullscreen = fullscreen;
        int flag = WindowManager.LayoutParams.FLAG_FULLSCREEN;
        applyWindowFlags(mFullscreen ? flag : 0, flag);
    }
}
------------------------
Find a silently evolved API code:android.text.Layout.getLineWidth:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the unsigned horizontal extent of the specified line, including
 * leading margin indent and trailing whitespace.
 */

Body of Frist Method:
{
    float margin = getParagraphLeadingMargin(line);
    float signedExtent = getLineExtent(line, true);
    return margin + signedExtent >= 0 ? signedExtent : -signedExtent;
}
Body of Second Method:
{
    float margin = getParagraphLeadingMargin(line);
    float signedExtent = getLineExtent(line, true);
    return margin + (signedExtent >= 0 ? signedExtent : -signedExtent);
}
------------------------
Find a silently evolved API code:android.widget.CalendarView.getUnfocusedMonthDateColor:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the color for the dates in a not focused month.
 *
 * @return A not focused month date color.
 *
 * @attr ref android.R.styleable#CalendarView_unfocusedMonthDateColor
 */

Body of Frist Method:
{
    return mFocusedMonthDateColor;
}
Body of Second Method:
{
    return mDelegate.getUnfocusedMonthDateColor();
}
------------------------
Find a silently evolved API code:android.print.PrintManager.getInstalledPrintServices:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Gets the list of installed print services.
 *
 * @return The installed service list or an empty list.
 * @hide
 */

Body of Frist Method:
{
    try {
        List<PrintServiceInfo> installedServices = mService.getInstalledPrintServices(mUserId);
        if (installedServices != null) {
            return installedServices;
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, "Error getting the installed print services", re);
    }
    return Collections.emptyList();
}
Body of Second Method:
{
    if (mService == null) {
        Log.w(LOG_TAG, "Feature android.software.print not available");
        return Collections.emptyList();
    }
    try {
        List<PrintServiceInfo> installedServices = mService.getInstalledPrintServices(mUserId);
        if (installedServices != null) {
            return installedServices;
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, "Error getting the installed print services", re);
    }
    return Collections.emptyList();
}
------------------------
Find a silently evolved API code:android.media.MediaRouter.UserRouteInfo.setVolume:COMMENT
Method Modifier: public      
Comment:/**
 * Defines at what volume the playback associated with this route is performed (for user
 * feedback purposes). This information is only used when the playback is not local.
 * @param volume
 */

Body of Frist Method:
{
    volume = Math.max(0, Math.min(volume, getVolumeMax()));
    if (mVolume != volume) {
        mVolume = volume;
        setPlaybackInfoOnRcc(RemoteControlClient.PLAYBACKINFO_VOLUME, volume);
        dispatchRouteVolumeChanged(this);
        if (mGroup != null) {
            mGroup.memberVolumeChanged(this);
        }
    }
}
Body of Second Method:
{
    volume = Math.max(0, Math.min(volume, getVolumeMax()));
    if (mVolume != volume) {
        mVolume = volume;
        if (mSvp != null) {
            mSvp.setCurrentVolume(mVolume);
        }
        dispatchRouteVolumeChanged(this);
        if (mGroup != null) {
            mGroup.memberVolumeChanged(this);
        }
    }
}
------------------------
Find a silently evolved API code:android.media.MediaFocusControl.unregisterRemoteControlDisplay:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * Unregister an IRemoteControlDisplay.
 * No effect if the IRemoteControlDisplay hasn't been successfully registered.
 * @see android.media.IAudioService#unregisterRemoteControlDisplay(android.media.IRemoteControlDisplay)
 * @param rcd the IRemoteControlDisplay to unregister. No effect if null.
 */

Body of Frist Method:
{
    if (DEBUG_RC)
        Log.d(TAG, "<<< unregisterRemoteControlDisplay(" + rcd + ")");
    synchronized (mRCStack) {
        if (rcd == null) {
            return;
        }
        boolean displayWasPluggedIn = false;
        final Iterator<DisplayInfoForServer> displayIterator = mRcDisplays.iterator();
        while (displayIterator.hasNext() && !displayWasPluggedIn) {
            final DisplayInfoForServer di = (DisplayInfoForServer) displayIterator.next();
            if (di.mRcDisplay.asBinder().equals(rcd.asBinder())) {
                displayWasPluggedIn = true;
                di.release();
                displayIterator.remove();
            }
        }
        if (displayWasPluggedIn) {
            // disconnect this remote control display from all the clients, so the remote
            // control stack traversal order doesn't matter
            final Iterator<RemoteControlStackEntry> stackIterator = mRCStack.iterator();
            while (stackIterator.hasNext()) {
                final RemoteControlStackEntry rcse = stackIterator.next();
                if (rcse.mRcClient != null) {
                    try {
                        rcse.mRcClient.unplugRemoteControlDisplay(rcd);
                    } catch (RemoteException e) {
                        Log.e(TAG, "Error disconnecting remote control display to client: ", e);
                    }
                }
            }
        } else {
            if (DEBUG_RC)
                Log.w(TAG, "  trying to unregister unregistered RCD");
        }
    }
}
Body of Second Method:
{
    if (DEBUG_RC)
        Log.d(TAG, "<<< unregisterRemoteControlDisplay(" + rcd + ")");
    synchronized (mPRStack) {
        if (rcd == null) {
            return;
        }
        boolean displayWasPluggedIn = false;
        final Iterator<DisplayInfoForServer> displayIterator = mRcDisplays.iterator();
        while (displayIterator.hasNext() && !displayWasPluggedIn) {
            final DisplayInfoForServer di = displayIterator.next();
            if (di.mRcDisplay.asBinder().equals(rcd.asBinder())) {
                displayWasPluggedIn = true;
                di.release();
                displayIterator.remove();
            }
        }
        if (displayWasPluggedIn) {
            // disconnect this remote control display from all the clients, so the remote
            // control stack traversal order doesn't matter
            final Iterator<PlayerRecord> stackIterator = mPRStack.iterator();
            while (stackIterator.hasNext()) {
                final PlayerRecord prse = stackIterator.next();
                if (prse.getRcc() != null) {
                    try {
                        prse.getRcc().unplugRemoteControlDisplay(rcd);
                    } catch (RemoteException e) {
                        Log.e(TAG, "Error disconnecting remote control display to client: ", e);
                    }
                }
            }
        } else {
            if (DEBUG_RC)
                Log.w(TAG, "  trying to unregister unregistered RCD");
        }
    }
}
------------------------
Find a silently evolved API code:android.graphics.Bitmap.copy:COMMENT
Method Modifier: public      
Comment:/**
 * Tries to make a new bitmap based on the dimensions of this bitmap,
 * setting the new bitmap's config to the one specified, and then copying
 * this bitmap's pixels into the new bitmap. If the conversion is not
 * supported, or the allocator fails, then this returns NULL.  The returned
 * bitmap initially has the same density as the original.
 *
 * @param config    The desired config for the resulting bitmap
 * @param isMutable True if the resulting bitmap should be mutable (i.e.
 * its pixels can be modified)
 * @return the new bitmap, or null if the copy could not be made.
 */

Body of Frist Method:
{
    checkRecycled("Can't copy a recycled bitmap");
    Bitmap b = nativeCopy(mNativeBitmap, config.nativeInt, isMutable);
    if (b != null) {
        b.mIsPremultiplied = mIsPremultiplied;
        b.mDensity = mDensity;
    }
    return b;
}
Body of Second Method:
{
    checkRecycled("Can't copy a recycled bitmap");
    Bitmap b = nativeCopy(mNativeBitmap, config.nativeInt, isMutable);
    if (b != null) {
        b.setPremultiplied(mRequestPremultiplied);
        b.mDensity = mDensity;
    }
    return b;
}
------------------------
Find a silently evolved API code:android.text.format.Time.compare:COMMENT
Method Modifier: public      static      
Comment:/**
 * Compare two {@code Time} objects and return a negative number if {@code
 * a} is less than {@code b}, a positive number if {@code a} is greater than
 * {@code b}, or 0 if they are equal.
 *
 * @param a first {@code Time} instance to compare
 * @param b second {@code Time} instance to compare
 * @throws NullPointerException if either argument is {@code null}
 * @throws IllegalArgumentException if {@link #allDay} is true but {@code
 * hour}, {@code minute}, and {@code second} are not 0.
 * @return a negative result if {@code a} is earlier, a positive result if
 * {@code a} is earlier, or 0 if they are equal.
 */

Body of Frist Method:
{
    if (a == null) {
        throw new NullPointerException("a == null");
    } else if (b == null) {
        throw new NullPointerException("b == null");
    }
    return nativeCompare(a, b);
}
Body of Second Method:
{
    if (a == null) {
        throw new NullPointerException("a == null");
    } else if (b == null) {
        throw new NullPointerException("b == null");
    }
    a.calculator.copyFieldsFromTime(a);
    b.calculator.copyFieldsFromTime(b);
    return TimeCalculator.compare(a.calculator, b.calculator);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothGatt.writeDescriptor:COMMENT
Method Modifier: public      
Comment:/**
 * Write the value of a given descriptor to the associated remote device.
 *
 * <p>A {@link BluetoothGattCallback#onDescriptorWrite} callback is
 * triggered to report the result of the write operation.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param descriptor Descriptor to write to the associated remote device
 * @return true, if the write operation was initiated successfully
 */

Body of Frist Method:
{
    if (DBG)
        Log.d(TAG, "writeDescriptor() - uuid: " + descriptor.getUuid());
    if (mService == null || mClientIf == 0)
        return false;
    BluetoothGattCharacteristic characteristic = descriptor.getCharacteristic();
    if (characteristic == null)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    try {
        mService.writeDescriptor(mClientIf, device.getAddress(), service.getType(), service.getInstanceId(), new ParcelUuid(service.getUuid()), characteristic.getInstanceId(), new ParcelUuid(characteristic.getUuid()), descriptor.getInstanceId(), new ParcelUuid(descriptor.getUuid()), characteristic.getWriteType(), AUTHENTICATION_NONE, descriptor.getValue());
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        return false;
    }
    return true;
}
Body of Second Method:
{
    if (VDBG)
        Log.d(TAG, "writeDescriptor() - uuid: " + descriptor.getUuid());
    if (mService == null || mClientIf == 0)
        return false;
    BluetoothGattCharacteristic characteristic = descriptor.getCharacteristic();
    if (characteristic == null)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusy) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.writeDescriptor(mClientIf, device.getAddress(), service.getType(), service.getInstanceId(), new ParcelUuid(service.getUuid()), characteristic.getInstanceId(), new ParcelUuid(characteristic.getUuid()), descriptor.getInstanceId(), new ParcelUuid(descriptor.getUuid()), characteristic.getWriteType(), AUTHENTICATION_NONE, descriptor.getValue());
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}
------------------------
Find a silently evolved API code:android.media.RemoteController.sendMediaKeyEvent:COMMENT
<android.media.RemoteController: boolean sendMediaKeyEvent(KeyEvent)>
public      ->public      deprecated  
Method Modifier: public      deprecated  
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Send a simulated key event for a media button to be received by the current client.
 * To simulate a key press, you must first send a KeyEvent built with
 * a {@link KeyEvent#ACTION_DOWN} action, then another event with the {@link KeyEvent#ACTION_UP}
 * action.
 * <p>The key event will be sent to the registered receiver
 * (see {@link AudioManager#registerMediaButtonEventReceiver(PendingIntent)}) whose associated
 * {@link RemoteControlClient}'s metadata and playback state is published (there may be
 * none under some circumstances).
 * @param keyEvent a {@link KeyEvent} instance whose key code is one of
 * {@link KeyEvent#KEYCODE_MUTE},
 * {@link KeyEvent#KEYCODE_HEADSETHOOK},
 * {@link KeyEvent#KEYCODE_MEDIA_PLAY},
 * {@link KeyEvent#KEYCODE_MEDIA_PAUSE},
 * {@link KeyEvent#KEYCODE_MEDIA_PLAY_PAUSE},
 * {@link KeyEvent#KEYCODE_MEDIA_STOP},
 * {@link KeyEvent#KEYCODE_MEDIA_NEXT},
 * {@link KeyEvent#KEYCODE_MEDIA_PREVIOUS},
 * {@link KeyEvent#KEYCODE_MEDIA_REWIND},
 * {@link KeyEvent#KEYCODE_MEDIA_RECORD},
 * {@link KeyEvent#KEYCODE_MEDIA_FAST_FORWARD},
 * {@link KeyEvent#KEYCODE_MEDIA_CLOSE},
 * {@link KeyEvent#KEYCODE_MEDIA_EJECT},
 * or {@link KeyEvent#KEYCODE_MEDIA_AUDIO_TRACK}.
 * @return true if the event was successfully sent, false otherwise.
 * @throws IllegalArgumentException
 */

Body of Frist Method:
{
    if (!MediaFocusControl.isMediaKeyCode(keyEvent.getKeyCode())) {
        throw new IllegalArgumentException("not a media key event");
    }
    final PendingIntent pi;
    synchronized (mInfoLock) {
        if (!mIsRegistered) {
            Log.e(TAG, "Cannot use sendMediaKeyEvent() from an unregistered RemoteController");
            return false;
        }
        if (!mEnabled) {
            Log.e(TAG, "Cannot use sendMediaKeyEvent() from a disabled RemoteController");
            return false;
        }
        pi = mClientPendingIntentCurrent;
    }
    if (pi != null) {
        Intent intent = new Intent(Intent.ACTION_MEDIA_BUTTON);
        intent.putExtra(Intent.EXTRA_KEY_EVENT, keyEvent);
        try {
            pi.send(mContext, 0, intent);
        } catch (CanceledException e) {
            Log.e(TAG, "Error sending intent for media button down: ", e);
            return false;
        }
    } else {
        Log.i(TAG, "No-op when sending key click, no receiver right now");
        return false;
    }
    return true;
}
Body of Second Method:
{
    if (!KeyEvent.isMediaKey(keyEvent.getKeyCode())) {
        throw new IllegalArgumentException("not a media key event");
    }
    if (USE_SESSIONS) {
        synchronized (mInfoLock) {
            if (mCurrentSession != null) {
                return mCurrentSession.dispatchMediaButtonEvent(keyEvent);
            }
            return false;
        }
    } else {
        final PendingIntent pi;
        synchronized (mInfoLock) {
            if (!mIsRegistered) {
                Log.e(TAG, "Cannot use sendMediaKeyEvent() from an unregistered RemoteController");
                return false;
            }
            if (!mEnabled) {
                Log.e(TAG, "Cannot use sendMediaKeyEvent() from a disabled RemoteController");
                return false;
            }
            pi = mClientPendingIntentCurrent;
        }
        if (pi != null) {
            Intent intent = new Intent(Intent.ACTION_MEDIA_BUTTON);
            intent.putExtra(Intent.EXTRA_KEY_EVENT, keyEvent);
            try {
                pi.send(mContext, 0, intent);
            } catch (CanceledException e) {
                Log.e(TAG, "Error sending intent for media button down: ", e);
                return false;
            }
        } else {
            Log.i(TAG, "No-op when sending key click, no receiver right now");
            return false;
        }
    }
    return true;
}
------------------------
Find a silently evolved API code:android.widget.CalendarView.getWeekSeparatorLineColor:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the color for the separator line between weeks.
 *
 * @return The week separator color.
 *
 * @attr ref android.R.styleable#CalendarView_weekSeparatorLineColor
 */

Body of Frist Method:
{
    return mWeekSeparatorLineColor;
}
Body of Second Method:
{
    return mDelegate.getWeekSeparatorLineColor();
}
------------------------
Find a silently evolved API code:android.graphics.Canvas.drawVertices:COMMENT
Method Modifier: public      
Comment:/**
 * Draw the array of vertices, interpreted as triangles (based on mode). The
 * verts array is required, and specifies the x,y pairs for each vertex. If
 * texs is non-null, then it is used to specify the coordinate in shader
 * coordinates to use at each vertex (the paint must have a shader in this
 * case). If there is no texs array, but there is a color array, then each
 * color is interpolated across its corresponding triangle in a gradient. If
 * both texs and colors arrays are present, then they behave as before, but
 * the resulting color at each pixels is the result of multiplying the
 * colors from the shader and the color-gradient together. The indices array
 * is optional, but if it is present, then it is used to specify the index
 * of each triangle, rather than just walking through the arrays in order.
 *
 * @param mode How to interpret the array of vertices
 * @param vertexCount The number of values in the vertices array (and
 * corresponding texs and colors arrays if non-null). Each logical
 * vertex is two values (x, y), vertexCount must be a multiple of 2.
 * @param verts Array of vertices for the mesh
 * @param vertOffset Number of values in the verts to skip before drawing.
 * @param texs May be null. If not null, specifies the coordinates to sample
 * into the current shader (e.g. bitmap tile or gradient)
 * @param texOffset Number of values in texs to skip before drawing.
 * @param colors May be null. If not null, specifies a color for each
 * vertex, to be interpolated across the triangle.
 * @param colorOffset Number of values in colors to skip before drawing.
 * @param indices If not null, array of indices to reference into the
 * vertex (texs, colors) array.
 * @param indexCount number of entries in the indices array (if not null).
 * @param paint Specifies the shader to use if the texs array is non-null.
 */

Body of Frist Method:
{
    checkRange(verts.length, vertOffset, vertexCount);
    if (texs != null) {
        checkRange(texs.length, texOffset, vertexCount);
    }
    if (colors != null) {
        checkRange(colors.length, colorOffset, vertexCount / 2);
    }
    if (indices != null) {
        checkRange(indices.length, indexOffset, indexCount);
    }
    nativeDrawVertices(mNativeCanvas, mode.nativeInt, vertexCount, verts, vertOffset, texs, texOffset, colors, colorOffset, indices, indexOffset, indexCount, paint.mNativePaint);
}
Body of Second Method:
{
    checkRange(verts.length, vertOffset, vertexCount);
    if (texs != null) {
        checkRange(texs.length, texOffset, vertexCount);
    }
    if (colors != null) {
        checkRange(colors.length, colorOffset, vertexCount / 2);
    }
    if (indices != null) {
        checkRange(indices.length, indexOffset, indexCount);
    }
    nativeDrawVertices(mNativeCanvasWrapper, mode.nativeInt, vertexCount, verts, vertOffset, texs, texOffset, colors, colorOffset, indices, indexOffset, indexCount, paint.mNativePaint);
}
------------------------
Find a silently evolved API code:android.widget.FastScroller.measurePreview:COMMENT
Method Modifier: private     
Comment:/**
 * Measures the preview text bounds, taking preview image padding into
 * account. This method should only be called after {@link #layoutThumb()}
 * and {@link #layoutTrack()} have both been called at least once.
 *
 * @param v The preview text view to measure.
 * @param out Rectangle into which measured bounds are placed.
 */

Body of Frist Method:
{
    // Apply the preview image's padding as layout margins.
    final Rect margins = mTempMargins;
    margins.left = mPreviewImage.getPaddingLeft();
    margins.top = mPreviewImage.getPaddingTop();
    margins.right = mPreviewImage.getPaddingRight();
    margins.bottom = mPreviewImage.getPaddingBottom();
    if (mOverlayPosition == OVERLAY_AT_THUMB) {
        measureViewToSide(v, mThumbImage, margins, out);
    } else {
        measureFloating(v, margins, out);
    }
}
Body of Second Method:
{
    // Apply the preview image's padding as layout margins.
    final Rect margins = mTempMargins;
    margins.left = mPreviewImage.getPaddingLeft();
    margins.top = mPreviewImage.getPaddingTop();
    margins.right = mPreviewImage.getPaddingRight();
    margins.bottom = mPreviewImage.getPaddingBottom();
    if (mOverlayPosition == OVERLAY_FLOATING) {
        measureFloating(v, margins, out);
    } else {
        measureViewToSide(v, mThumbImage, margins, out);
    }
}
------------------------
Find a silently evolved API code:android.net.NetworkStats.addValues:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Add new stats entry, copying from given {@link Entry}. The {@link Entry}
 * object can be recycled across multiple calls.
 */

Body of Frist Method:
{
    if (size >= this.iface.length) {
        final int newLength = Math.max(iface.length, 10) * 3 / 2;
        iface = Arrays.copyOf(iface, newLength);
        uid = Arrays.copyOf(uid, newLength);
        set = Arrays.copyOf(set, newLength);
        tag = Arrays.copyOf(tag, newLength);
        rxBytes = Arrays.copyOf(rxBytes, newLength);
        rxPackets = Arrays.copyOf(rxPackets, newLength);
        txBytes = Arrays.copyOf(txBytes, newLength);
        txPackets = Arrays.copyOf(txPackets, newLength);
        operations = Arrays.copyOf(operations, newLength);
    }
    iface[size] = entry.iface;
    uid[size] = entry.uid;
    set[size] = entry.set;
    tag[size] = entry.tag;
    rxBytes[size] = entry.rxBytes;
    rxPackets[size] = entry.rxPackets;
    txBytes[size] = entry.txBytes;
    txPackets[size] = entry.txPackets;
    operations[size] = entry.operations;
    size++;
    return this;
}
Body of Second Method:
{
    if (size >= capacity) {
        final int newLength = Math.max(size, 10) * 3 / 2;
        iface = Arrays.copyOf(iface, newLength);
        uid = Arrays.copyOf(uid, newLength);
        set = Arrays.copyOf(set, newLength);
        tag = Arrays.copyOf(tag, newLength);
        rxBytes = Arrays.copyOf(rxBytes, newLength);
        rxPackets = Arrays.copyOf(rxPackets, newLength);
        txBytes = Arrays.copyOf(txBytes, newLength);
        txPackets = Arrays.copyOf(txPackets, newLength);
        operations = Arrays.copyOf(operations, newLength);
        capacity = newLength;
    }
    iface[size] = entry.iface;
    uid[size] = entry.uid;
    set[size] = entry.set;
    tag[size] = entry.tag;
    rxBytes[size] = entry.rxBytes;
    rxPackets[size] = entry.rxPackets;
    txBytes[size] = entry.txBytes;
    txPackets[size] = entry.txPackets;
    operations[size] = entry.operations;
    size++;
    return this;
}
------------------------
Find a silently evolved API code:android.content.res.TypedArray.getValue:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the raw TypedValue for the attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 * @param outValue TypedValue object in which to place the attribute's
 * data.
 *
 * @return Returns true if the value was retrieved, else false.
 */

Body of Frist Method:
{
    return getValueAt(index * AssetManager.STYLE_NUM_ENTRIES, outValue);
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    return getValueAt(index * AssetManager.STYLE_NUM_ENTRIES, outValue);
}
------------------------
Find a silently evolved API code:android.content.res.Resources.Theme.obtainStyledAttributes:COMMENT
Method Modifier: public      
Comment:/**
 * Return a TypedArray holding the attribute values in
 * <var>set</var>
 * that are listed in <var>attrs</var>.  In addition, if the given
 * AttributeSet specifies a style class (through the "style" attribute),
 * that style will be applied on top of the base attributes it defines.
 *
 * <p>Be sure to call {@link TypedArray#recycle() TypedArray.recycle()} when you are done
 * with the array.
 *
 * <p>When determining the final value of a particular attribute, there
 * are four inputs that come into play:</p>
 *
 * <ol>
 * <li> Any attribute values in the given AttributeSet.
 * <li> The style resource specified in the AttributeSet (named
 * "style").
 * <li> The default style specified by <var>defStyleAttr</var> and
 * <var>defStyleRes</var>
 * <li> The base values in this theme.
 * </ol>
 *
 * <p>Each of these inputs is considered in-order, with the first listed
 * taking precedence over the following ones.  In other words, if in the
 * AttributeSet you have supplied <code>&lt;Button
 * textColor="#ff000000"&gt;</code>, then the button's text will
 * <em>always</em> be black, regardless of what is specified in any of
 * the styles.
 *
 * @param set The base set of attribute values.  May be null.
 * @param attrs The desired attributes to be retrieved.
 * @param defStyleAttr An attribute in the current theme that contains a
 * reference to a style resource that supplies
 * defaults values for the TypedArray.  Can be
 * 0 to not look for defaults.
 * @param defStyleRes A resource identifier of a style resource that
 * supplies default values for the TypedArray,
 * used only if defStyleAttr is 0 or can not be found
 * in the theme.  Can be 0 to not look for defaults.
 *
 * @return Returns a TypedArray holding an array of the attribute values.
 * Be sure to call {@link TypedArray#recycle() TypedArray.recycle()}
 * when done with it.
 *
 * @see Resources#obtainAttributes
 * @see #obtainStyledAttributes(int[])
 * @see #obtainStyledAttributes(int, int[])
 */

Body of Frist Method:
{
    int len = attrs.length;
    TypedArray array = getCachedStyledAttributes(len);
    // XXX note that for now we only work with compiled XML files.
    // To support generic XML files we will need to manually parse
    // out the attributes from the XML file (applying type information
    // contained in the resources and such).
    XmlBlock.Parser parser = (XmlBlock.Parser) set;
    AssetManager.applyStyle(mTheme, defStyleAttr, defStyleRes, parser != null ? parser.mParseState : 0, attrs, array.mData, array.mIndices);
    array.mRsrcs = attrs;
    array.mXml = parser;
    if (false) {
        int[] data = array.mData;
        System.out.println("Attributes:");
        String s = "  Attrs:";
        int i;
        for (i = 0; i < set.getAttributeCount(); i++) {
            s = s + " " + set.getAttributeName(i);
            int id = set.getAttributeNameResource(i);
            if (id != 0) {
                s = s + "(0x" + Integer.toHexString(id) + ")";
            }
            s = s + "=" + set.getAttributeValue(i);
        }
        System.out.println(s);
        s = "  Found:";
        TypedValue value = new TypedValue();
        for (i = 0; i < attrs.length; i++) {
            int d = i * AssetManager.STYLE_NUM_ENTRIES;
            value.type = data[d + AssetManager.STYLE_TYPE];
            value.data = data[d + AssetManager.STYLE_DATA];
            value.assetCookie = data[d + AssetManager.STYLE_ASSET_COOKIE];
            value.resourceId = data[d + AssetManager.STYLE_RESOURCE_ID];
            s = s + " 0x" + Integer.toHexString(attrs[i]) + "=" + value;
        }
        System.out.println(s);
    }
    return array;
}
Body of Second Method:
{
    final int len = attrs.length;
    final TypedArray array = TypedArray.obtain(Resources.this, len);
    // XXX note that for now we only work with compiled XML files.
    // To support generic XML files we will need to manually parse
    // out the attributes from the XML file (applying type information
    // contained in the resources and such).
    final XmlBlock.Parser parser = (XmlBlock.Parser) set;
    AssetManager.applyStyle(mTheme, defStyleAttr, defStyleRes, parser != null ? parser.mParseState : 0, attrs, array.mData, array.mIndices);
    array.mTheme = this;
    array.mXml = parser;
    if (false) {
        int[] data = array.mData;
        System.out.println("Attributes:");
        String s = "  Attrs:";
        int i;
        for (i = 0; i < set.getAttributeCount(); i++) {
            s = s + " " + set.getAttributeName(i);
            int id = set.getAttributeNameResource(i);
            if (id != 0) {
                s = s + "(0x" + Integer.toHexString(id) + ")";
            }
            s = s + "=" + set.getAttributeValue(i);
        }
        System.out.println(s);
        s = "  Found:";
        TypedValue value = new TypedValue();
        for (i = 0; i < attrs.length; i++) {
            int d = i * AssetManager.STYLE_NUM_ENTRIES;
            value.type = data[d + AssetManager.STYLE_TYPE];
            value.data = data[d + AssetManager.STYLE_DATA];
            value.assetCookie = data[d + AssetManager.STYLE_ASSET_COOKIE];
            value.resourceId = data[d + AssetManager.STYLE_RESOURCE_ID];
            s = s + " 0x" + Integer.toHexString(attrs[i]) + "=" + value;
        }
        System.out.println(s);
    }
    return array;
}
------------------------
Find a silently evolved API code:android.media.MediaFocusControl.onRcDisplayInitInfo:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Called when processing MSG_RCDISPLAY_INIT_INFO event
 * Causes the current RemoteControlClient to send its info (metadata, playstate...) to
 * a single RemoteControlDisplay, NOT all of them, as with MSG_RCDISPLAY_UPDATE.
 */

Body of Frist Method:
{
    synchronized (mRCStack) {
        synchronized (mCurrentRcLock) {
            if (mCurrentRcClient != null) {
                if (DEBUG_RC) {
                    Log.i(TAG, "Init RCD with current info");
                }
                try {
                    // synchronously update the new RCD with the current client generation
                    // and matching PendingIntent
                    newRcd.setCurrentClientId(mCurrentRcClientGen, mCurrentRcClientIntent, false);
                    // tell the current RCC that it needs to send info, but only to the new RCD
                    try {
                        mCurrentRcClient.informationRequestForDisplay(newRcd, w, h);
                    } catch (RemoteException e) {
                        Log.e(TAG, "Current valid remote client is dead: ", e);
                        mCurrentRcClient = null;
                    }
                } catch (RemoteException e) {
                    Log.e(TAG, "Dead display in onRcDisplayInitInfo()", e);
                }
            }
        }
    }
}
Body of Second Method:
{
    synchronized (mPRStack) {
        synchronized (mCurrentRcLock) {
            if (mCurrentRcClient != null) {
                if (DEBUG_RC) {
                    Log.i(TAG, "Init RCD with current info");
                }
                try {
                    // synchronously update the new RCD with the current client generation
                    // and matching PendingIntent
                    newRcd.setCurrentClientId(mCurrentRcClientGen, mCurrentRcClientIntent, false);
                    // tell the current RCC that it needs to send info, but only to the new RCD
                    try {
                        mCurrentRcClient.informationRequestForDisplay(newRcd, w, h);
                    } catch (RemoteException e) {
                        Log.e(TAG, "Current valid remote client is dead: ", e);
                        mCurrentRcClient = null;
                    }
                } catch (RemoteException e) {
                    Log.e(TAG, "Dead display in onRcDisplayInitInfo()", e);
                }
            }
        }
    }
}
------------------------
Find a silently evolved API code:android.speech.tts.FileSynthesisCallback.closeFile:COMMENT
Method Modifier: private     
Comment:/**
 * Must be called while holding the monitor on {@link #mStateLock}.
 */

Body of Frist Method:
{
    try {
        if (mFileChannel != null) {
            mFileChannel.close();
            mFileChannel = null;
        }
    } catch (IOException ex) {
        Log.e(TAG, "Failed to close output file descriptor", ex);
    }
}
Body of Second Method:
{
    // File will be closed by the SpeechItem in the speech service.
    mFileChannel = null;
}
------------------------
Find a silently evolved API code:android.provider.DocumentsContract.getDocumentThumbnail:COMMENT
Method Modifier: public      static      
Comment:/**
 * Return thumbnail representing the document at the given URI. Callers are
 * responsible for their own in-memory caching.
 *
 * @param documentUri document to return thumbnail for, which must have
 * {@link Document#FLAG_SUPPORTS_THUMBNAIL} set.
 * @param size optimal thumbnail size desired. A provider may return a
 * thumbnail of a different size, but never more than double the
 * requested size.
 * @param signal signal used to indicate if caller is no longer interested
 * in the thumbnail.
 * @return decoded thumbnail, or {@code null} if problem was encountered.
 * @see DocumentsProvider#openDocumentThumbnail(String, Point,
 * android.os.CancellationSignal)
 */

Body of Frist Method:
{
    final ContentProviderClient client = resolver.acquireUnstableContentProviderClient(documentUri.getAuthority());
    try {
        return getDocumentThumbnail(client, documentUri, size, signal);
    } catch (Exception e) {
        Log.w(TAG, "Failed to load thumbnail for " + documentUri + ": " + e);
        return null;
    } finally {
        ContentProviderClient.releaseQuietly(client);
    }
}
Body of Second Method:
{
    final ContentProviderClient client = resolver.acquireUnstableContentProviderClient(documentUri.getAuthority());
    try {
        return getDocumentThumbnail(client, documentUri, size, signal);
    } catch (Exception e) {
        if (!(e instanceof OperationCanceledException)) {
            Log.w(TAG, "Failed to load thumbnail for " + documentUri + ": " + e);
        }
        return null;
    } finally {
        ContentProviderClient.releaseQuietly(client);
    }
}
------------------------
Find a silently evolved API code:android.text.BoringLayout.init:COMMENT
Method Modifier: default     
Comment:/* package */

Body of Frist Method:
{
    int spacing;
    if (source instanceof String && align == Layout.Alignment.ALIGN_NORMAL) {
        mDirect = source.toString();
    } else {
        mDirect = null;
    }
    mPaint = paint;
    if (includepad) {
        spacing = metrics.bottom - metrics.top;
    } else {
        spacing = metrics.descent - metrics.ascent;
    }
    if (spacingmult != 1 || spacingadd != 0) {
        spacing = (int) (spacing * spacingmult + spacingadd + 0.5f);
    }
    mBottom = spacing;
    if (includepad) {
        mDesc = spacing + metrics.top;
    } else {
        mDesc = spacing + metrics.ascent;
    }
    if (trustWidth) {
        mMax = metrics.width;
    } else {
        /*
             * If we have ellipsized, we have to actually calculate the
             * width because the width that was passed in was for the
             * full text, not the ellipsized form.
             */
        TextLine line = TextLine.obtain();
        line.set(paint, source, 0, source.length(), Layout.DIR_LEFT_TO_RIGHT, Layout.DIRS_ALL_LEFT_TO_RIGHT, false, null);
        mMax = (int) FloatMath.ceil(line.metrics(null));
        TextLine.recycle(line);
    }
    if (includepad) {
        mTopPadding = metrics.top - metrics.ascent;
        mBottomPadding = metrics.bottom - metrics.descent;
    }
}
Body of Second Method:
{
    int spacing;
    if (source instanceof String && align == Layout.Alignment.ALIGN_NORMAL) {
        mDirect = source.toString();
    } else {
        mDirect = null;
    }
    mPaint = paint;
    if (includepad) {
        spacing = metrics.bottom - metrics.top;
    } else {
        spacing = metrics.descent - metrics.ascent;
    }
    mBottom = spacing;
    if (includepad) {
        mDesc = spacing + metrics.top;
    } else {
        mDesc = spacing + metrics.ascent;
    }
    if (trustWidth) {
        mMax = metrics.width;
    } else {
        /*
             * If we have ellipsized, we have to actually calculate the
             * width because the width that was passed in was for the
             * full text, not the ellipsized form.
             */
        TextLine line = TextLine.obtain();
        line.set(paint, source, 0, source.length(), Layout.DIR_LEFT_TO_RIGHT, Layout.DIRS_ALL_LEFT_TO_RIGHT, false, null);
        mMax = (int) FloatMath.ceil(line.metrics(null));
        TextLine.recycle(line);
    }
    if (includepad) {
        mTopPadding = metrics.top - metrics.ascent;
        mBottomPadding = metrics.bottom - metrics.descent;
    }
}
------------------------
Find a silently evolved API code:android.graphics.Canvas.clipRect:COMMENT
<android.graphics.Canvas: boolean clipRect(Rect)>
public      native      ->public      
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * Intersect the current clip with the specified rectangle, which is
 * expressed in local coordinates.
 *
 * @param rect The rectangle to intersect with the current clip.
 * @return true if the resulting clip is non-empty
 */

Body of Frist Method:

Body of Second Method:
{
    return native_clipRect(mNativeCanvasWrapper, rect.left, rect.top, rect.right, rect.bottom, Region.Op.INTERSECT.nativeInt);
}
------------------------
Find a silently evolved API code:android.media.AudioService.stopBluetoothSco:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @see AudioManager#stopBluetoothSco()
 */

Body of Frist Method:
{
    if (!checkAudioSettingsPermission("stopBluetoothSco()") || !mBootCompleted) {
        return;
    }
    ScoClient client = getScoClient(cb, false);
    // The calling identity must be cleared before calling ScoClient.decCount().
    // decCount() calls requestScoState() which in turn can call BluetoothHeadset APIs
    // and this must be done on behalf of system server to make sure permissions are granted.
    final long ident = Binder.clearCallingIdentity();
    if (client != null) {
        client.decCount();
    }
    Binder.restoreCallingIdentity(ident);
}
Body of Second Method:
{
    if (!checkAudioSettingsPermission("stopBluetoothSco()") || !mSystemReady) {
        return;
    }
    ScoClient client = getScoClient(cb, false);
    // The calling identity must be cleared before calling ScoClient.decCount().
    // decCount() calls requestScoState() which in turn can call BluetoothHeadset APIs
    // and this must be done on behalf of system server to make sure permissions are granted.
    final long ident = Binder.clearCallingIdentity();
    if (client != null) {
        client.decCount();
    }
    Binder.restoreCallingIdentity(ident);
}
------------------------
Find a silently evolved API code:android.widget.AbsListView.RecycleBin.clear:COMMENT
Method Modifier: default     
Comment:/**
 * Clears the scrap heap.
 */

Body of Frist Method:
{
    if (mViewTypeCount == 1) {
        final ArrayList<View> scrap = mCurrentScrap;
        final int scrapCount = scrap.size();
        for (int i = 0; i < scrapCount; i++) {
            removeDetachedView(scrap.remove(scrapCount - 1 - i), false);
        }
    } else {
        final int typeCount = mViewTypeCount;
        for (int i = 0; i < typeCount; i++) {
            final ArrayList<View> scrap = mScrapViews[i];
            final int scrapCount = scrap.size();
            for (int j = 0; j < scrapCount; j++) {
                removeDetachedView(scrap.remove(scrapCount - 1 - j), false);
            }
        }
    }
    if (mTransientStateViews != null) {
        mTransientStateViews.clear();
    }
    if (mTransientStateViewsById != null) {
        mTransientStateViewsById.clear();
    }
}
Body of Second Method:
{
    if (mViewTypeCount == 1) {
        final ArrayList<View> scrap = mCurrentScrap;
        clearScrap(scrap);
    } else {
        final int typeCount = mViewTypeCount;
        for (int i = 0; i < typeCount; i++) {
            final ArrayList<View> scrap = mScrapViews[i];
            clearScrap(scrap);
        }
    }
    clearTransientStateViews();
}
------------------------
Find a silently evolved API code:android.animation.AnimatorSet.setStartDelay:COMMENT
Method Modifier: public      
Comment:/**
 * The amount of time, in milliseconds, to delay starting the animation after
 * {@link #start()} is called.
 *
 * @param startDelay The amount of the delay, in milliseconds
 */

Body of Frist Method:
{
    mStartDelay = startDelay;
}
Body of Second Method:
{
    if (mStartDelay > 0) {
        mReversible = false;
    }
    mStartDelay = startDelay;
}
------------------------
Find a silently evolved API code:android.net.nsd.NsdServiceInfo.getTxtRecord:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return mTxtRecord;
}
Body of Second Method:
{
    int txtRecordSize = getTxtRecordSize();
    if (txtRecordSize == 0) {
        return null;
    }
    byte[] txtRecord = new byte[txtRecordSize];
    int ptr = 0;
    for (Map.Entry<String, byte[]> entry : mTxtRecord.entrySet()) {
        String key = entry.getKey();
        byte[] value = entry.getValue();
        // One byte to record the length of this key/value pair.
        txtRecord[ptr++] = (byte) (key.length() + (value == null ? 0 : value.length) + 1);
        // The key, in US-ASCII.
        // Note: use the StandardCharsets const here because it doesn't raise exceptions and we
        // already know the key is ASCII at this point.
        System.arraycopy(key.getBytes(StandardCharsets.US_ASCII), 0, txtRecord, ptr, key.length());
        ptr += key.length();
        // US-ASCII '=' character.
        txtRecord[ptr++] = (byte) '=';
        // The value, as any raw bytes.
        if (value != null) {
            System.arraycopy(value, 0, txtRecord, ptr, value.length);
            ptr += value.length;
        }
    }
    return txtRecord;
}
------------------------
Find a silently evolved API code:android.os.Environment.initForCurrentUser:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * {@hide}
 */

Body of Frist Method:
{
    final int userId = UserHandle.myUserId();
    sCurrentUser = new UserEnvironment(userId);
    synchronized (sLock) {
        sPrimaryVolume = null;
    }
}
Body of Second Method:
{
    final int userId = UserHandle.myUserId();
    sCurrentUser = new UserEnvironment(userId);
}
------------------------
Find a silently evolved API code:android.app.Activity.onResume:COMMENT
Method Modifier: protected   
Comment:/**
 * Called after {@link #onRestoreInstanceState}, {@link #onRestart}, or
 * {@link #onPause}, for your activity to start interacting with the user.
 * This is a good place to begin animations, open exclusive-access devices
 * (such as the camera), etc.
 *
 * <p>Keep in mind that onResume is not the best indicator that your activity
 * is visible to the user; a system window such as the keyguard may be in
 * front.  Use {@link #onWindowFocusChanged} to know for certain that your
 * activity is visible to the user (for example, to resume a game).
 *
 * <p><em>Derived classes must call through to the super class's
 * implementation of this method.  If they do not, an exception will be
 * thrown.</em></p>
 *
 * @see #onRestoreInstanceState
 * @see #onRestart
 * @see #onPostResume
 * @see #onPause
 */

Body of Frist Method:
{
    if (DEBUG_LIFECYCLE)
        Slog.v(TAG, "onResume " + this);
    getApplication().dispatchActivityResumed(this);
    mCalled = true;
}
Body of Second Method:
{
    if (DEBUG_LIFECYCLE)
        Slog.v(TAG, "onResume " + this);
    getApplication().dispatchActivityResumed(this);
    mActivityTransitionState.onResume();
    mCalled = true;
}
------------------------
Find a silently evolved API code:android.graphics.drawable.BitmapDrawable.setGravity:COMMENT
Method Modifier: public      
Comment:/**
 * Set the gravity used to position/stretch the bitmap within its bounds.
 * See android.view.Gravity
 * @param gravity the gravity
 */

Body of Frist Method:
{
    if (mBitmapState.mGravity != gravity) {
        mBitmapState.mGravity = gravity;
        mApplyGravity = true;
        invalidateSelf();
    }
}
Body of Second Method:
{
    if (mBitmapState.mGravity != gravity) {
        mBitmapState.mGravity = gravity;
        mDstRectAndInsetsDirty = true;
        invalidateSelf();
    }
}
------------------------
Find a silently evolved API code:android.database.sqlite.SQLiteConnection.dumpUnsafe:COMMENT
Method Modifier: default     hidden      
Comment:/**
 * Dumps debugging information about this connection, in the case where the
 * caller might not actually own the connection.
 *
 * This function is written so that it may be called by a thread that does not
 * own the connection.  We need to be very careful because the connection state is
 * not synchronized.
 *
 * At worst, the method may return stale or slightly wrong data, however
 * it should not crash.  This is ok as it is only used for diagnostic purposes.
 *
 * @param printer The printer to receive the dump, not null.
 * @param verbose True to dump more verbose information.
 */

Body of Frist Method:
{
    printer.println("Connection #" + mConnectionId + ":");
    if (verbose) {
        printer.println("  connectionPtr: 0x" + Integer.toHexString(mConnectionPtr));
    }
    printer.println("  isPrimaryConnection: " + mIsPrimaryConnection);
    printer.println("  onlyAllowReadOnlyOperations: " + mOnlyAllowReadOnlyOperations);
    mRecentOperations.dump(printer, verbose);
    if (verbose) {
        mPreparedStatementCache.dump(printer);
    }
}
Body of Second Method:
{
    printer.println("Connection #" + mConnectionId + ":");
    if (verbose) {
        printer.println("  connectionPtr: 0x" + Long.toHexString(mConnectionPtr));
    }
    printer.println("  isPrimaryConnection: " + mIsPrimaryConnection);
    printer.println("  onlyAllowReadOnlyOperations: " + mOnlyAllowReadOnlyOperations);
    mRecentOperations.dump(printer, verbose);
    if (verbose) {
        mPreparedStatementCache.dump(printer);
    }
}
------------------------
Find a silently evolved API code:android.widget.LinearLayout.measureHorizontal:COMMENT
Method Modifier: default     
Comment:/**
 * Measures the children when the orientation of this LinearLayout is set
 * to {@link #HORIZONTAL}.
 *
 * @param widthMeasureSpec Horizontal space requirements as imposed by the parent.
 * @param heightMeasureSpec Vertical space requirements as imposed by the parent.
 *
 * @see #getOrientation()
 * @see #setOrientation(int)
 * @see #onMeasure(int, int)
 */

Body of Frist Method:
{
    mTotalLength = 0;
    int maxHeight = 0;
    int childState = 0;
    int alternativeMaxHeight = 0;
    int weightedMaxHeight = 0;
    boolean allFillParent = true;
    float totalWeight = 0;
    final int count = getVirtualChildCount();
    final int widthMode = MeasureSpec.getMode(widthMeasureSpec);
    final int heightMode = MeasureSpec.getMode(heightMeasureSpec);
    boolean matchHeight = false;
    if (mMaxAscent == null || mMaxDescent == null) {
        mMaxAscent = new int[VERTICAL_GRAVITY_COUNT];
        mMaxDescent = new int[VERTICAL_GRAVITY_COUNT];
    }
    final int[] maxAscent = mMaxAscent;
    final int[] maxDescent = mMaxDescent;
    maxAscent[0] = maxAscent[1] = maxAscent[2] = maxAscent[3] = -1;
    maxDescent[0] = maxDescent[1] = maxDescent[2] = maxDescent[3] = -1;
    final boolean baselineAligned = mBaselineAligned;
    final boolean useLargestChild = mUseLargestChild;
    final boolean isExactly = widthMode == MeasureSpec.EXACTLY;
    int largestChildWidth = Integer.MIN_VALUE;
    // See how wide everyone is. Also remember max height.
    for (int i = 0; i < count; ++i) {
        final View child = getVirtualChildAt(i);
        if (child == null) {
            mTotalLength += measureNullChild(i);
            continue;
        }
        if (child.getVisibility() == GONE) {
            i += getChildrenSkipCount(child, i);
            continue;
        }
        if (hasDividerBeforeChildAt(i)) {
            mTotalLength += mDividerWidth;
        }
        final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
        totalWeight += lp.weight;
        if (widthMode == MeasureSpec.EXACTLY && lp.width == 0 && lp.weight > 0) {
            // there is any leftover space.
            if (isExactly) {
                mTotalLength += lp.leftMargin + lp.rightMargin;
            } else {
                final int totalLength = mTotalLength;
                mTotalLength = Math.max(totalLength, totalLength + lp.leftMargin + lp.rightMargin);
            }
            // later (and re-measure).
            if (baselineAligned) {
                final int freeSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);
                child.measure(freeSpec, freeSpec);
            }
        } else {
            int oldWidth = Integer.MIN_VALUE;
            if (lp.width == 0 && lp.weight > 0) {
                // widthMode is either UNSPECIFIED or AT_MOST, and this
                // child
                // wanted to stretch to fill available space. Translate that to
                // WRAP_CONTENT so that it does not end up with a width of 0
                oldWidth = 0;
                lp.width = LayoutParams.WRAP_CONTENT;
            }
            // Determine how big this child would like to be. If this or
            // previous children have given a weight, then we allow it to
            // use all available space (and we will shrink things later
            // if needed).
            measureChildBeforeLayout(child, i, widthMeasureSpec, totalWeight == 0 ? mTotalLength : 0, heightMeasureSpec, 0);
            if (oldWidth != Integer.MIN_VALUE) {
                lp.width = oldWidth;
            }
            final int childWidth = child.getMeasuredWidth();
            if (isExactly) {
                mTotalLength += childWidth + lp.leftMargin + lp.rightMargin + getNextLocationOffset(child);
            } else {
                final int totalLength = mTotalLength;
                mTotalLength = Math.max(totalLength, totalLength + childWidth + lp.leftMargin + lp.rightMargin + getNextLocationOffset(child));
            }
            if (useLargestChild) {
                largestChildWidth = Math.max(childWidth, largestChildWidth);
            }
        }
        boolean matchHeightLocally = false;
        if (heightMode != MeasureSpec.EXACTLY && lp.height == LayoutParams.MATCH_PARENT) {
            // The height of the linear layout will scale, and at least one
            // child said it wanted to match our height. Set a flag indicating that
            // we need to remeasure at least that view when we know our height.
            matchHeight = true;
            matchHeightLocally = true;
        }
        final int margin = lp.topMargin + lp.bottomMargin;
        final int childHeight = child.getMeasuredHeight() + margin;
        childState = combineMeasuredStates(childState, child.getMeasuredState());
        if (baselineAligned) {
            final int childBaseline = child.getBaseline();
            if (childBaseline != -1) {
                // Translates the child's vertical gravity into an index
                // in the range 0..VERTICAL_GRAVITY_COUNT
                final int gravity = (lp.gravity < 0 ? mGravity : lp.gravity) & Gravity.VERTICAL_GRAVITY_MASK;
                final int index = ((gravity >> Gravity.AXIS_Y_SHIFT) & ~Gravity.AXIS_SPECIFIED) >> 1;
                maxAscent[index] = Math.max(maxAscent[index], childBaseline);
                maxDescent[index] = Math.max(maxDescent[index], childHeight - childBaseline);
            }
        }
        maxHeight = Math.max(maxHeight, childHeight);
        allFillParent = allFillParent && lp.height == LayoutParams.MATCH_PARENT;
        if (lp.weight > 0) {
            /*
                 * Heights of weighted Views are bogus if we end up
                 * remeasuring, so keep them separate.
                 */
            weightedMaxHeight = Math.max(weightedMaxHeight, matchHeightLocally ? margin : childHeight);
        } else {
            alternativeMaxHeight = Math.max(alternativeMaxHeight, matchHeightLocally ? margin : childHeight);
        }
        i += getChildrenSkipCount(child, i);
    }
    if (mTotalLength > 0 && hasDividerBeforeChildAt(count)) {
        mTotalLength += mDividerWidth;
    }
    // the most common case
    if (maxAscent[INDEX_TOP] != -1 || maxAscent[INDEX_CENTER_VERTICAL] != -1 || maxAscent[INDEX_BOTTOM] != -1 || maxAscent[INDEX_FILL] != -1) {
        final int ascent = Math.max(maxAscent[INDEX_FILL], Math.max(maxAscent[INDEX_CENTER_VERTICAL], Math.max(maxAscent[INDEX_TOP], maxAscent[INDEX_BOTTOM])));
        final int descent = Math.max(maxDescent[INDEX_FILL], Math.max(maxDescent[INDEX_CENTER_VERTICAL], Math.max(maxDescent[INDEX_TOP], maxDescent[INDEX_BOTTOM])));
        maxHeight = Math.max(maxHeight, ascent + descent);
    }
    if (useLargestChild && (widthMode == MeasureSpec.AT_MOST || widthMode == MeasureSpec.UNSPECIFIED)) {
        mTotalLength = 0;
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child == null) {
                mTotalLength += measureNullChild(i);
                continue;
            }
            if (child.getVisibility() == GONE) {
                i += getChildrenSkipCount(child, i);
                continue;
            }
            final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
            if (isExactly) {
                mTotalLength += largestChildWidth + lp.leftMargin + lp.rightMargin + getNextLocationOffset(child);
            } else {
                final int totalLength = mTotalLength;
                mTotalLength = Math.max(totalLength, totalLength + largestChildWidth + lp.leftMargin + lp.rightMargin + getNextLocationOffset(child));
            }
        }
    }
    // Add in our padding
    mTotalLength += mPaddingLeft + mPaddingRight;
    int widthSize = mTotalLength;
    // Check against our minimum width
    widthSize = Math.max(widthSize, getSuggestedMinimumWidth());
    // Reconcile our calculated size with the widthMeasureSpec
    int widthSizeAndState = resolveSizeAndState(widthSize, widthMeasureSpec, 0);
    widthSize = widthSizeAndState & MEASURED_SIZE_MASK;
    // Either expand children with weight to take up available space or
    // shrink them if they extend beyond our current bounds
    int delta = widthSize - mTotalLength;
    if (delta != 0 && totalWeight > 0.0f) {
        float weightSum = mWeightSum > 0.0f ? mWeightSum : totalWeight;
        maxAscent[0] = maxAscent[1] = maxAscent[2] = maxAscent[3] = -1;
        maxDescent[0] = maxDescent[1] = maxDescent[2] = maxDescent[3] = -1;
        maxHeight = -1;
        mTotalLength = 0;
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child == null || child.getVisibility() == View.GONE) {
                continue;
            }
            final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
            float childExtra = lp.weight;
            if (childExtra > 0) {
                // Child said it could absorb extra space -- give him his share
                int share = (int) (childExtra * delta / weightSum);
                weightSum -= childExtra;
                delta -= share;
                final int childHeightMeasureSpec = getChildMeasureSpec(heightMeasureSpec, mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin, lp.height);
                // child has been previously measured
                if ((lp.width != 0) || (widthMode != MeasureSpec.EXACTLY)) {
                    // child was measured once already above ... base new measurement
                    // on stored values
                    int childWidth = child.getMeasuredWidth() + share;
                    if (childWidth < 0) {
                        childWidth = 0;
                    }
                    child.measure(MeasureSpec.makeMeasureSpec(childWidth, MeasureSpec.EXACTLY), childHeightMeasureSpec);
                } else {
                    // child was skipped in the loop above. Measure for this first time here
                    child.measure(MeasureSpec.makeMeasureSpec(share > 0 ? share : 0, MeasureSpec.EXACTLY), childHeightMeasureSpec);
                }
                // Child may now not fit in horizontal dimension.
                childState = combineMeasuredStates(childState, child.getMeasuredState() & MEASURED_STATE_MASK);
            }
            if (isExactly) {
                mTotalLength += child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin + getNextLocationOffset(child);
            } else {
                final int totalLength = mTotalLength;
                mTotalLength = Math.max(totalLength, totalLength + child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin + getNextLocationOffset(child));
            }
            boolean matchHeightLocally = heightMode != MeasureSpec.EXACTLY && lp.height == LayoutParams.MATCH_PARENT;
            final int margin = lp.topMargin + lp.bottomMargin;
            int childHeight = child.getMeasuredHeight() + margin;
            maxHeight = Math.max(maxHeight, childHeight);
            alternativeMaxHeight = Math.max(alternativeMaxHeight, matchHeightLocally ? margin : childHeight);
            allFillParent = allFillParent && lp.height == LayoutParams.MATCH_PARENT;
            if (baselineAligned) {
                final int childBaseline = child.getBaseline();
                if (childBaseline != -1) {
                    // Translates the child's vertical gravity into an index in the range 0..2
                    final int gravity = (lp.gravity < 0 ? mGravity : lp.gravity) & Gravity.VERTICAL_GRAVITY_MASK;
                    final int index = ((gravity >> Gravity.AXIS_Y_SHIFT) & ~Gravity.AXIS_SPECIFIED) >> 1;
                    maxAscent[index] = Math.max(maxAscent[index], childBaseline);
                    maxDescent[index] = Math.max(maxDescent[index], childHeight - childBaseline);
                }
            }
        }
        // Add in our padding
        mTotalLength += mPaddingLeft + mPaddingRight;
        // the most common case
        if (maxAscent[INDEX_TOP] != -1 || maxAscent[INDEX_CENTER_VERTICAL] != -1 || maxAscent[INDEX_BOTTOM] != -1 || maxAscent[INDEX_FILL] != -1) {
            final int ascent = Math.max(maxAscent[INDEX_FILL], Math.max(maxAscent[INDEX_CENTER_VERTICAL], Math.max(maxAscent[INDEX_TOP], maxAscent[INDEX_BOTTOM])));
            final int descent = Math.max(maxDescent[INDEX_FILL], Math.max(maxDescent[INDEX_CENTER_VERTICAL], Math.max(maxDescent[INDEX_TOP], maxDescent[INDEX_BOTTOM])));
            maxHeight = Math.max(maxHeight, ascent + descent);
        }
    } else {
        alternativeMaxHeight = Math.max(alternativeMaxHeight, weightedMaxHeight);
        // Children will have already been measured once.
        if (useLargestChild && widthMode != MeasureSpec.EXACTLY) {
            for (int i = 0; i < count; i++) {
                final View child = getVirtualChildAt(i);
                if (child == null || child.getVisibility() == View.GONE) {
                    continue;
                }
                final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
                float childExtra = lp.weight;
                if (childExtra > 0) {
                    child.measure(MeasureSpec.makeMeasureSpec(largestChildWidth, MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(child.getMeasuredHeight(), MeasureSpec.EXACTLY));
                }
            }
        }
    }
    if (!allFillParent && heightMode != MeasureSpec.EXACTLY) {
        maxHeight = alternativeMaxHeight;
    }
    maxHeight += mPaddingTop + mPaddingBottom;
    // Check against our minimum height
    maxHeight = Math.max(maxHeight, getSuggestedMinimumHeight());
    setMeasuredDimension(widthSizeAndState | (childState & MEASURED_STATE_MASK), resolveSizeAndState(maxHeight, heightMeasureSpec, (childState << MEASURED_HEIGHT_STATE_SHIFT)));
    if (matchHeight) {
        forceUniformHeight(count, widthMeasureSpec);
    }
}
Body of Second Method:
{
    mTotalLength = 0;
    int maxHeight = 0;
    int childState = 0;
    int alternativeMaxHeight = 0;
    int weightedMaxHeight = 0;
    boolean allFillParent = true;
    float totalWeight = 0;
    final int count = getVirtualChildCount();
    final int widthMode = MeasureSpec.getMode(widthMeasureSpec);
    final int heightMode = MeasureSpec.getMode(heightMeasureSpec);
    boolean matchHeight = false;
    boolean skippedMeasure = false;
    if (mMaxAscent == null || mMaxDescent == null) {
        mMaxAscent = new int[VERTICAL_GRAVITY_COUNT];
        mMaxDescent = new int[VERTICAL_GRAVITY_COUNT];
    }
    final int[] maxAscent = mMaxAscent;
    final int[] maxDescent = mMaxDescent;
    maxAscent[0] = maxAscent[1] = maxAscent[2] = maxAscent[3] = -1;
    maxDescent[0] = maxDescent[1] = maxDescent[2] = maxDescent[3] = -1;
    final boolean baselineAligned = mBaselineAligned;
    final boolean useLargestChild = mUseLargestChild;
    final boolean isExactly = widthMode == MeasureSpec.EXACTLY;
    int largestChildWidth = Integer.MIN_VALUE;
    // See how wide everyone is. Also remember max height.
    for (int i = 0; i < count; ++i) {
        final View child = getVirtualChildAt(i);
        if (child == null) {
            mTotalLength += measureNullChild(i);
            continue;
        }
        if (child.getVisibility() == GONE) {
            i += getChildrenSkipCount(child, i);
            continue;
        }
        if (hasDividerBeforeChildAt(i)) {
            mTotalLength += mDividerWidth;
        }
        final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
        totalWeight += lp.weight;
        if (widthMode == MeasureSpec.EXACTLY && lp.width == 0 && lp.weight > 0) {
            // there is any leftover space.
            if (isExactly) {
                mTotalLength += lp.leftMargin + lp.rightMargin;
            } else {
                final int totalLength = mTotalLength;
                mTotalLength = Math.max(totalLength, totalLength + lp.leftMargin + lp.rightMargin);
            }
            // later (and re-measure).
            if (baselineAligned) {
                final int freeSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);
                child.measure(freeSpec, freeSpec);
            } else {
                skippedMeasure = true;
            }
        } else {
            int oldWidth = Integer.MIN_VALUE;
            if (lp.width == 0 && lp.weight > 0) {
                // widthMode is either UNSPECIFIED or AT_MOST, and this
                // child
                // wanted to stretch to fill available space. Translate that to
                // WRAP_CONTENT so that it does not end up with a width of 0
                oldWidth = 0;
                lp.width = LayoutParams.WRAP_CONTENT;
            }
            // Determine how big this child would like to be. If this or
            // previous children have given a weight, then we allow it to
            // use all available space (and we will shrink things later
            // if needed).
            measureChildBeforeLayout(child, i, widthMeasureSpec, totalWeight == 0 ? mTotalLength : 0, heightMeasureSpec, 0);
            if (oldWidth != Integer.MIN_VALUE) {
                lp.width = oldWidth;
            }
            final int childWidth = child.getMeasuredWidth();
            if (isExactly) {
                mTotalLength += childWidth + lp.leftMargin + lp.rightMargin + getNextLocationOffset(child);
            } else {
                final int totalLength = mTotalLength;
                mTotalLength = Math.max(totalLength, totalLength + childWidth + lp.leftMargin + lp.rightMargin + getNextLocationOffset(child));
            }
            if (useLargestChild) {
                largestChildWidth = Math.max(childWidth, largestChildWidth);
            }
        }
        boolean matchHeightLocally = false;
        if (heightMode != MeasureSpec.EXACTLY && lp.height == LayoutParams.MATCH_PARENT) {
            // The height of the linear layout will scale, and at least one
            // child said it wanted to match our height. Set a flag indicating that
            // we need to remeasure at least that view when we know our height.
            matchHeight = true;
            matchHeightLocally = true;
        }
        final int margin = lp.topMargin + lp.bottomMargin;
        final int childHeight = child.getMeasuredHeight() + margin;
        childState = combineMeasuredStates(childState, child.getMeasuredState());
        if (baselineAligned) {
            final int childBaseline = child.getBaseline();
            if (childBaseline != -1) {
                // Translates the child's vertical gravity into an index
                // in the range 0..VERTICAL_GRAVITY_COUNT
                final int gravity = (lp.gravity < 0 ? mGravity : lp.gravity) & Gravity.VERTICAL_GRAVITY_MASK;
                final int index = ((gravity >> Gravity.AXIS_Y_SHIFT) & ~Gravity.AXIS_SPECIFIED) >> 1;
                maxAscent[index] = Math.max(maxAscent[index], childBaseline);
                maxDescent[index] = Math.max(maxDescent[index], childHeight - childBaseline);
            }
        }
        maxHeight = Math.max(maxHeight, childHeight);
        allFillParent = allFillParent && lp.height == LayoutParams.MATCH_PARENT;
        if (lp.weight > 0) {
            /*
                 * Heights of weighted Views are bogus if we end up
                 * remeasuring, so keep them separate.
                 */
            weightedMaxHeight = Math.max(weightedMaxHeight, matchHeightLocally ? margin : childHeight);
        } else {
            alternativeMaxHeight = Math.max(alternativeMaxHeight, matchHeightLocally ? margin : childHeight);
        }
        i += getChildrenSkipCount(child, i);
    }
    if (mTotalLength > 0 && hasDividerBeforeChildAt(count)) {
        mTotalLength += mDividerWidth;
    }
    // the most common case
    if (maxAscent[INDEX_TOP] != -1 || maxAscent[INDEX_CENTER_VERTICAL] != -1 || maxAscent[INDEX_BOTTOM] != -1 || maxAscent[INDEX_FILL] != -1) {
        final int ascent = Math.max(maxAscent[INDEX_FILL], Math.max(maxAscent[INDEX_CENTER_VERTICAL], Math.max(maxAscent[INDEX_TOP], maxAscent[INDEX_BOTTOM])));
        final int descent = Math.max(maxDescent[INDEX_FILL], Math.max(maxDescent[INDEX_CENTER_VERTICAL], Math.max(maxDescent[INDEX_TOP], maxDescent[INDEX_BOTTOM])));
        maxHeight = Math.max(maxHeight, ascent + descent);
    }
    if (useLargestChild && (widthMode == MeasureSpec.AT_MOST || widthMode == MeasureSpec.UNSPECIFIED)) {
        mTotalLength = 0;
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child == null) {
                mTotalLength += measureNullChild(i);
                continue;
            }
            if (child.getVisibility() == GONE) {
                i += getChildrenSkipCount(child, i);
                continue;
            }
            final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
            if (isExactly) {
                mTotalLength += largestChildWidth + lp.leftMargin + lp.rightMargin + getNextLocationOffset(child);
            } else {
                final int totalLength = mTotalLength;
                mTotalLength = Math.max(totalLength, totalLength + largestChildWidth + lp.leftMargin + lp.rightMargin + getNextLocationOffset(child));
            }
        }
    }
    // Add in our padding
    mTotalLength += mPaddingLeft + mPaddingRight;
    int widthSize = mTotalLength;
    // Check against our minimum width
    widthSize = Math.max(widthSize, getSuggestedMinimumWidth());
    // Reconcile our calculated size with the widthMeasureSpec
    int widthSizeAndState = resolveSizeAndState(widthSize, widthMeasureSpec, 0);
    widthSize = widthSizeAndState & MEASURED_SIZE_MASK;
    // Either expand children with weight to take up available space or
    // shrink them if they extend beyond our current bounds. If we skipped
    // measurement on any children, we need to measure them now.
    int delta = widthSize - mTotalLength;
    if (skippedMeasure || delta != 0 && totalWeight > 0.0f) {
        float weightSum = mWeightSum > 0.0f ? mWeightSum : totalWeight;
        maxAscent[0] = maxAscent[1] = maxAscent[2] = maxAscent[3] = -1;
        maxDescent[0] = maxDescent[1] = maxDescent[2] = maxDescent[3] = -1;
        maxHeight = -1;
        mTotalLength = 0;
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child == null || child.getVisibility() == View.GONE) {
                continue;
            }
            final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
            float childExtra = lp.weight;
            if (childExtra > 0) {
                // Child said it could absorb extra space -- give him his share
                int share = (int) (childExtra * delta / weightSum);
                weightSum -= childExtra;
                delta -= share;
                final int childHeightMeasureSpec = getChildMeasureSpec(heightMeasureSpec, mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin, lp.height);
                // child has been previously measured
                if ((lp.width != 0) || (widthMode != MeasureSpec.EXACTLY)) {
                    // child was measured once already above ... base new measurement
                    // on stored values
                    int childWidth = child.getMeasuredWidth() + share;
                    if (childWidth < 0) {
                        childWidth = 0;
                    }
                    child.measure(MeasureSpec.makeMeasureSpec(childWidth, MeasureSpec.EXACTLY), childHeightMeasureSpec);
                } else {
                    // child was skipped in the loop above. Measure for this first time here
                    child.measure(MeasureSpec.makeMeasureSpec(share > 0 ? share : 0, MeasureSpec.EXACTLY), childHeightMeasureSpec);
                }
                // Child may now not fit in horizontal dimension.
                childState = combineMeasuredStates(childState, child.getMeasuredState() & MEASURED_STATE_MASK);
            }
            if (isExactly) {
                mTotalLength += child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin + getNextLocationOffset(child);
            } else {
                final int totalLength = mTotalLength;
                mTotalLength = Math.max(totalLength, totalLength + child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin + getNextLocationOffset(child));
            }
            boolean matchHeightLocally = heightMode != MeasureSpec.EXACTLY && lp.height == LayoutParams.MATCH_PARENT;
            final int margin = lp.topMargin + lp.bottomMargin;
            int childHeight = child.getMeasuredHeight() + margin;
            maxHeight = Math.max(maxHeight, childHeight);
            alternativeMaxHeight = Math.max(alternativeMaxHeight, matchHeightLocally ? margin : childHeight);
            allFillParent = allFillParent && lp.height == LayoutParams.MATCH_PARENT;
            if (baselineAligned) {
                final int childBaseline = child.getBaseline();
                if (childBaseline != -1) {
                    // Translates the child's vertical gravity into an index in the range 0..2
                    final int gravity = (lp.gravity < 0 ? mGravity : lp.gravity) & Gravity.VERTICAL_GRAVITY_MASK;
                    final int index = ((gravity >> Gravity.AXIS_Y_SHIFT) & ~Gravity.AXIS_SPECIFIED) >> 1;
                    maxAscent[index] = Math.max(maxAscent[index], childBaseline);
                    maxDescent[index] = Math.max(maxDescent[index], childHeight - childBaseline);
                }
            }
        }
        // Add in our padding
        mTotalLength += mPaddingLeft + mPaddingRight;
        // the most common case
        if (maxAscent[INDEX_TOP] != -1 || maxAscent[INDEX_CENTER_VERTICAL] != -1 || maxAscent[INDEX_BOTTOM] != -1 || maxAscent[INDEX_FILL] != -1) {
            final int ascent = Math.max(maxAscent[INDEX_FILL], Math.max(maxAscent[INDEX_CENTER_VERTICAL], Math.max(maxAscent[INDEX_TOP], maxAscent[INDEX_BOTTOM])));
            final int descent = Math.max(maxDescent[INDEX_FILL], Math.max(maxDescent[INDEX_CENTER_VERTICAL], Math.max(maxDescent[INDEX_TOP], maxDescent[INDEX_BOTTOM])));
            maxHeight = Math.max(maxHeight, ascent + descent);
        }
    } else {
        alternativeMaxHeight = Math.max(alternativeMaxHeight, weightedMaxHeight);
        // Children will have already been measured once.
        if (useLargestChild && widthMode != MeasureSpec.EXACTLY) {
            for (int i = 0; i < count; i++) {
                final View child = getVirtualChildAt(i);
                if (child == null || child.getVisibility() == View.GONE) {
                    continue;
                }
                final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
                float childExtra = lp.weight;
                if (childExtra > 0) {
                    child.measure(MeasureSpec.makeMeasureSpec(largestChildWidth, MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(child.getMeasuredHeight(), MeasureSpec.EXACTLY));
                }
            }
        }
    }
    if (!allFillParent && heightMode != MeasureSpec.EXACTLY) {
        maxHeight = alternativeMaxHeight;
    }
    maxHeight += mPaddingTop + mPaddingBottom;
    // Check against our minimum height
    maxHeight = Math.max(maxHeight, getSuggestedMinimumHeight());
    setMeasuredDimension(widthSizeAndState | (childState & MEASURED_STATE_MASK), resolveSizeAndState(maxHeight, heightMeasureSpec, (childState << MEASURED_HEIGHT_STATE_SHIFT)));
    if (matchHeight) {
        forceUniformHeight(count, widthMeasureSpec);
    }
}
------------------------
Find a silently evolved API code:android.nfc.cardemulation.CardEmulation.getInstance:COMMENT
Method Modifier: public      static      
Comment:/**
 * Helper to get an instance of this class.
 *
 * @param adapter A reference to an NfcAdapter object.
 * @return
 */

Body of Frist Method:
{
    if (adapter == null)
        throw new NullPointerException("NfcAdapter is null");
    Context context = adapter.getContext();
    if (context == null) {
        Log.e(TAG, "NfcAdapter context is null.");
        throw new UnsupportedOperationException();
    }
    if (!sIsInitialized) {
        IPackageManager pm = ActivityThread.getPackageManager();
        if (pm == null) {
            Log.e(TAG, "Cannot get PackageManager");
            throw new UnsupportedOperationException();
        }
        try {
            if (!pm.hasSystemFeature(PackageManager.FEATURE_NFC_HOST_CARD_EMULATION)) {
                Log.e(TAG, "This device does not support card emulation");
                throw new UnsupportedOperationException();
            }
        } catch (RemoteException e) {
            Log.e(TAG, "PackageManager query failed.");
            throw new UnsupportedOperationException();
        }
        sIsInitialized = true;
    }
    CardEmulation manager = sCardEmus.get(context);
    if (manager == null) {
        // Get card emu service
        INfcCardEmulation service = adapter.getCardEmulationService();
        manager = new CardEmulation(context, service);
        sCardEmus.put(context, manager);
    }
    return manager;
}
Body of Second Method:
{
    if (adapter == null)
        throw new NullPointerException("NfcAdapter is null");
    Context context = adapter.getContext();
    if (context == null) {
        Log.e(TAG, "NfcAdapter context is null.");
        throw new UnsupportedOperationException();
    }
    if (!sIsInitialized) {
        IPackageManager pm = ActivityThread.getPackageManager();
        if (pm == null) {
            Log.e(TAG, "Cannot get PackageManager");
            throw new UnsupportedOperationException();
        }
        try {
            if (!pm.hasSystemFeature(PackageManager.FEATURE_NFC_HOST_CARD_EMULATION)) {
                Log.e(TAG, "This device does not support card emulation");
                throw new UnsupportedOperationException();
            }
        } catch (RemoteException e) {
            Log.e(TAG, "PackageManager query failed.");
            throw new UnsupportedOperationException();
        }
        sIsInitialized = true;
    }
    CardEmulation manager = sCardEmus.get(context);
    if (manager == null) {
        // Get card emu service
        INfcCardEmulation service = adapter.getCardEmulationService();
        if (service == null) {
            Log.e(TAG, "This device does not implement the INfcCardEmulation interface.");
            throw new UnsupportedOperationException();
        }
        manager = new CardEmulation(context, service);
        sCardEmus.put(context, manager);
    }
    return manager;
}
------------------------
Find a silently evolved API code:android.widget.DatePicker.init:COMMENT
Method Modifier: public      
Comment:/**
 * Initialize the state. If the provided values designate an inconsistent
 * date the values are normalized before updating the spinners.
 *
 * @param year The initial year.
 * @param monthOfYear The initial month <strong>starting from zero</strong>.
 * @param dayOfMonth The initial day of the month.
 * @param onDateChangedListener How user is notified date is changed by
 * user, can be null.
 */

Body of Frist Method:
{
    setDate(year, monthOfYear, dayOfMonth);
    updateSpinners();
    updateCalendarView();
    mOnDateChangedListener = onDateChangedListener;
}
Body of Second Method:
{
    mDelegate.init(year, monthOfYear, dayOfMonth, onDateChangedListener);
}
------------------------
Find a silently evolved API code:android.app.Activity.onCreate:COMMENT
Method Modifier: protected   
Comment:/**
 * Called when the activity is starting.  This is where most initialization
 * should go: calling {@link #setContentView(int)} to inflate the
 * activity's UI, using {@link #findViewById} to programmatically interact
 * with widgets in the UI, calling
 * {@link #managedQuery(android.net.Uri , String[], String, String[], String)} to retrieve
 * cursors for data being displayed, etc.
 *
 * <p>You can call {@link #finish} from within this function, in
 * which case onDestroy() will be immediately called without any of the rest
 * of the activity lifecycle ({@link #onStart}, {@link #onResume},
 * {@link #onPause}, etc) executing.
 *
 * <p><em>Derived classes must call through to the super class's
 * implementation of this method.  If they do not, an exception will be
 * thrown.</em></p>
 *
 * @param savedInstanceState If the activity is being re-initialized after
 * previously being shut down then this Bundle contains the data it most
 * recently supplied in {@link #onSaveInstanceState}.  <b><i>Note: Otherwise it is null.</i></b>
 *
 * @see #onStart
 * @see #onSaveInstanceState
 * @see #onRestoreInstanceState
 * @see #onPostCreate
 */

Body of Frist Method:
{
    if (DEBUG_LIFECYCLE)
        Slog.v(TAG, "onCreate " + this + ": " + savedInstanceState);
    if (mLastNonConfigurationInstances != null) {
        mAllLoaderManagers = mLastNonConfigurationInstances.loaders;
    }
    if (mActivityInfo.parentActivityName != null) {
        if (mActionBar == null) {
            mEnableDefaultActionBarUp = true;
        } else {
            mActionBar.setDefaultDisplayHomeAsUpEnabled(true);
        }
    }
    if (savedInstanceState != null) {
        Parcelable p = savedInstanceState.getParcelable(FRAGMENTS_TAG);
        mFragments.restoreAllState(p, mLastNonConfigurationInstances != null ? mLastNonConfigurationInstances.fragments : null);
    }
    mFragments.dispatchCreate();
    getApplication().dispatchActivityCreated(this, savedInstanceState);
    mCalled = true;
}
Body of Second Method:
{
    if (DEBUG_LIFECYCLE)
        Slog.v(TAG, "onCreate " + this + ": " + savedInstanceState);
    if (mLastNonConfigurationInstances != null) {
        mAllLoaderManagers = mLastNonConfigurationInstances.loaders;
    }
    if (mActivityInfo.parentActivityName != null) {
        if (mActionBar == null) {
            mEnableDefaultActionBarUp = true;
        } else {
            mActionBar.setDefaultDisplayHomeAsUpEnabled(true);
        }
    }
    if (savedInstanceState != null) {
        Parcelable p = savedInstanceState.getParcelable(FRAGMENTS_TAG);
        mFragments.restoreAllState(p, mLastNonConfigurationInstances != null ? mLastNonConfigurationInstances.fragments : null);
    }
    mFragments.dispatchCreate();
    getApplication().dispatchActivityCreated(this, savedInstanceState);
    if (mVoiceInteractor != null) {
        mVoiceInteractor.attachActivity(this);
    }
    mCalled = true;
}
------------------------
Find a silently evolved API code:android.util.SparseLongArray.append:COMMENT
Method Modifier: public      
Comment:/**
 * Puts a key/value pair into the array, optimizing for the case where
 * the key is greater than all existing keys in the array.
 */

Body of Frist Method:
{
    if (mSize != 0 && key <= mKeys[mSize - 1]) {
        put(key, value);
        return;
    }
    int pos = mSize;
    if (pos >= mKeys.length) {
        growKeyAndValueArrays(pos + 1);
    }
    mKeys[pos] = key;
    mValues[pos] = value;
    mSize = pos + 1;
}
Body of Second Method:
{
    if (mSize != 0 && key <= mKeys[mSize - 1]) {
        put(key, value);
        return;
    }
    mKeys = GrowingArrayUtils.append(mKeys, mSize, key);
    mValues = GrowingArrayUtils.append(mValues, mSize, value);
    mSize++;
}
------------------------
Find a silently evolved API code:android.content.res.ColorStateList.valueOf:COMMENT
Method Modifier: public      static      
Comment:/**
 * Creates or retrieves a ColorStateList that always returns a single color.
 */

Body of Frist Method:
{
    // TODO: should we collect these eventually?
    synchronized (sCache) {
        WeakReference<ColorStateList> ref = sCache.get(color);
        ColorStateList csl = ref != null ? ref.get() : null;
        if (csl != null) {
            return csl;
        }
        csl = new ColorStateList(EMPTY, new int[] { color });
        sCache.put(color, new WeakReference<ColorStateList>(csl));
        return csl;
    }
}
Body of Second Method:
{
    // TODO: should we collect these eventually?
    synchronized (sCache) {
        final WeakReference<ColorStateList> ref = sCache.get(color);
        ColorStateList csl = ref != null ? ref.get() : null;
        if (csl != null) {
            return csl;
        }
        csl = new ColorStateList(EMPTY, new int[] { color });
        sCache.put(color, new WeakReference<ColorStateList>(csl));
        return csl;
    }
}
------------------------
Find a silently evolved API code:android.view.inputmethod.BaseInputConnection.commitText:COMMENT
Method Modifier: public      
Comment:/**
 * Default implementation replaces any existing composing text with
 * the given text.  In addition, only if dummy mode, a key event is
 * sent for the new text and the current editable buffer cleared.
 */

Body of Frist Method:
{
    if (DEBUG)
        Log.v(TAG, "commitText " + text);
    replaceText(text, newCursorPosition, false);
    sendCurrentText();
    return true;
}
Body of Second Method:
{
    if (DEBUG)
        Log.v(TAG, "commitText " + text);
    replaceText(text, newCursorPosition, false);
    mIMM.notifyUserAction();
    sendCurrentText();
    return true;
}
------------------------
Find a silently evolved API code:android.transition.Transition.getTransitionValues:COMMENT
Method Modifier: public      
Comment:/**
 * This method can be called by transitions to get the TransitionValues for
 * any particular view during the transition-playing process. This might be
 * necessary, for example, to query the before/after state of related views
 * for a given transition.
 */

Body of Frist Method:
{
    if (mParent != null) {
        return mParent.getTransitionValues(view, start);
    }
    TransitionValuesMaps valuesMaps = start ? mStartValues : mEndValues;
    TransitionValues values = valuesMaps.viewValues.get(view);
    if (values == null) {
        int id = view.getId();
        if (id >= 0) {
            values = valuesMaps.idValues.get(id);
        }
        if (values == null && view.getParent() instanceof ListView) {
            ListView listview = (ListView) view.getParent();
            int position = listview.getPositionForView(view);
            long itemId = listview.getItemIdAtPosition(position);
            values = valuesMaps.itemIdValues.get(itemId);
        }
    // TODO: Doesn't handle the case where a view was parented to a
    // ListView (with an itemId), but no longer is
    }
    return values;
}
Body of Second Method:
{
    if (mParent != null) {
        return mParent.getTransitionValues(view, start);
    }
    TransitionValuesMaps valuesMaps = start ? mStartValues : mEndValues;
    return valuesMaps.viewValues.get(view);
}
------------------------
Find a silently evolved API code:android.graphics.Path.addArc:COMMENT
Method Modifier: public      
Comment:/**
 * Add the specified arc to the path as a new contour.
 *
 * @param oval The bounds of oval defining the shape and size of the arc
 * @param startAngle Starting angle (in degrees) where the arc begins
 * @param sweepAngle Sweep angle (in degrees) measured clockwise
 */

Body of Frist Method:
{
    if (oval == null) {
        throw new NullPointerException("need oval parameter");
    }
    isSimplePath = false;
    native_addArc(mNativePath, oval, startAngle, sweepAngle);
}
Body of Second Method:
{
    addArc(oval.left, oval.top, oval.right, oval.bottom, startAngle, sweepAngle);
}
------------------------
Find a silently evolved API code:android.preference.Preference.onBindView:COMMENT
Method Modifier: protected   
Comment:/**
 * Binds the created View to the data for this Preference.
 * <p>
 * This is a good place to grab references to custom Views in the layout and
 * set properties on them.
 * <p>
 * Make sure to call through to the superclass's implementation.
 *
 * @param view The View that shows this Preference.
 * @see #onCreateView(ViewGroup)
 */

Body of Frist Method:
{
    final TextView titleView = (TextView) view.findViewById(com.android.internal.R.id.title);
    if (titleView != null) {
        final CharSequence title = getTitle();
        if (!TextUtils.isEmpty(title)) {
            titleView.setText(title);
            titleView.setVisibility(View.VISIBLE);
        } else {
            titleView.setVisibility(View.GONE);
        }
    }
    final TextView summaryView = (TextView) view.findViewById(com.android.internal.R.id.summary);
    if (summaryView != null) {
        final CharSequence summary = getSummary();
        if (!TextUtils.isEmpty(summary)) {
            summaryView.setText(summary);
            summaryView.setVisibility(View.VISIBLE);
        } else {
            summaryView.setVisibility(View.GONE);
        }
    }
    ImageView imageView = (ImageView) view.findViewById(com.android.internal.R.id.icon);
    if (imageView != null) {
        if (mIconResId != 0 || mIcon != null) {
            if (mIcon == null) {
                mIcon = getContext().getResources().getDrawable(mIconResId);
            }
            if (mIcon != null) {
                imageView.setImageDrawable(mIcon);
            }
        }
        imageView.setVisibility(mIcon != null ? View.VISIBLE : View.GONE);
    }
    if (mShouldDisableView) {
        setEnabledStateOnViews(view, isEnabled());
    }
}
Body of Second Method:
{
    final TextView titleView = (TextView) view.findViewById(com.android.internal.R.id.title);
    if (titleView != null) {
        final CharSequence title = getTitle();
        if (!TextUtils.isEmpty(title)) {
            titleView.setText(title);
            titleView.setVisibility(View.VISIBLE);
        } else {
            titleView.setVisibility(View.GONE);
        }
    }
    final TextView summaryView = (TextView) view.findViewById(com.android.internal.R.id.summary);
    if (summaryView != null) {
        final CharSequence summary = getSummary();
        if (!TextUtils.isEmpty(summary)) {
            summaryView.setText(summary);
            summaryView.setVisibility(View.VISIBLE);
        } else {
            summaryView.setVisibility(View.GONE);
        }
    }
    final ImageView imageView = (ImageView) view.findViewById(com.android.internal.R.id.icon);
    if (imageView != null) {
        if (mIconResId != 0 || mIcon != null) {
            if (mIcon == null) {
                mIcon = getContext().getDrawable(mIconResId);
            }
            if (mIcon != null) {
                imageView.setImageDrawable(mIcon);
            }
        }
        imageView.setVisibility(mIcon != null ? View.VISIBLE : View.GONE);
    }
    final View imageFrame = view.findViewById(com.android.internal.R.id.icon_frame);
    if (imageFrame != null) {
        imageFrame.setVisibility(mIcon != null ? View.VISIBLE : View.GONE);
    }
    if (mShouldDisableView) {
        setEnabledStateOnViews(view, isEnabled());
    }
}
------------------------
Find a silently evolved API code:android.app.Activity.shouldUpRecreateTask:COMMENT
Method Modifier: public      
Comment:/**
 * Returns true if the app should recreate the task when navigating 'up' from this activity
 * by using targetIntent.
 *
 * <p>If this method returns false the app can trivially call
 * {@link #navigateUpTo(Intent)} using the same parameters to correctly perform
 * up navigation. If this method returns false, the app should synthesize a new task stack
 * by using {@link TaskStackBuilder} or another similar mechanism to perform up navigation.</p>
 *
 * @param targetIntent An intent representing the target destination for up navigation
 * @return true if navigating up should recreate a new task stack, false if the same task
 * should be used for the destination
 */

Body of Frist Method:
{
    try {
        PackageManager pm = getPackageManager();
        ComponentName cn = targetIntent.getComponent();
        if (cn == null) {
            cn = targetIntent.resolveActivity(pm);
        }
        ActivityInfo info = pm.getActivityInfo(cn, 0);
        if (info.taskAffinity == null) {
            return false;
        }
        return !ActivityManagerNative.getDefault().targetTaskAffinityMatchesActivity(mToken, info.taskAffinity);
    } catch (RemoteException e) {
        return false;
    } catch (NameNotFoundException e) {
        return false;
    }
}
Body of Second Method:
{
    try {
        PackageManager pm = getPackageManager();
        ComponentName cn = targetIntent.getComponent();
        if (cn == null) {
            cn = targetIntent.resolveActivity(pm);
        }
        ActivityInfo info = pm.getActivityInfo(cn, 0);
        if (info.taskAffinity == null) {
            return false;
        }
        return ActivityManagerNative.getDefault().shouldUpRecreateTask(mToken, info.taskAffinity);
    } catch (RemoteException e) {
        return false;
    } catch (NameNotFoundException e) {
        return false;
    }
}
------------------------
Find a silently evolved API code:android.os.Bundle.getIntegerArrayList:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return an ArrayList<String> value, or null
 */

Body of Frist Method:
{
    unparcel();
    Object o = mMap.get(key);
    if (o == null) {
        return null;
    }
    try {
        return (ArrayList<Integer>) o;
    } catch (ClassCastException e) {
        typeWarning(key, o, "ArrayList<Integer>", e);
        return null;
    }
}
Body of Second Method:
{
    return super.getIntegerArrayList(key);
}
------------------------
Find a silently evolved API code:android.content.ContentResolver.takePersistableUriPermission:COMMENT
Method Modifier: public      
Comment:/**
 * Take a persistable URI permission grant that has been offered. Once
 * taken, the permission grant will be remembered across device reboots.
 * Only URI permissions granted with
 * {@link Intent#FLAG_GRANT_PERSISTABLE_URI_PERMISSION} can be persisted. If
 * the grant has already been persisted, taking it again will touch
 * {@link UriPermission#getPersistedTime()}.
 *
 * @see #getPersistedUriPermissions()
 */

Body of Frist Method:
{
    try {
        ActivityManagerNative.getDefault().takePersistableUriPermission(uri, modeFlags);
    } catch (RemoteException e) {
    }
}
Body of Second Method:
{
    try {
        ActivityManagerNative.getDefault().takePersistableUriPermission(ContentProvider.getUriWithoutUserId(uri), modeFlags, resolveUserId(uri));
    } catch (RemoteException e) {
    }
}
------------------------
Find a silently evolved API code:android.os.CountDownTimer.cancel:COMMENT
Method Modifier: public      final       
Comment:/**
 * Cancel the countdown.
 */

Body of Frist Method:
{
    mHandler.removeMessages(MSG);
}
Body of Second Method:
{
    mCancelled = true;
    mHandler.removeMessages(MSG);
}
------------------------
Find a silently evolved API code:android.graphics.Canvas.drawText:COMMENT
Method Modifier: public      
Comment:/**
 * Draw the text, with origin at (x,y), using the specified paint.
 * The origin is interpreted based on the Align setting in the paint.
 *
 * @param text  The text to be drawn
 * @param start The index of the first character in text to draw
 * @param end   (end - 1) is the index of the last character in text to draw
 * @param x     The x-coordinate of the origin of the text being drawn
 * @param y     The y-coordinate of the origin of the text being drawn
 * @param paint The paint used for the text (e.g. color, size, style)
 */

Body of Frist Method:
{
    if ((start | end | (end - start) | (text.length() - end)) < 0) {
        throw new IndexOutOfBoundsException();
    }
    native_drawText(mNativeCanvas, text, start, end, x, y, paint.mBidiFlags, paint.mNativePaint);
}
Body of Second Method:
{
    if ((start | end | (end - start) | (text.length() - end)) < 0) {
        throw new IndexOutOfBoundsException();
    }
    native_drawText(mNativeCanvasWrapper, text, start, end, x, y, paint.mBidiFlags, paint.mNativePaint, paint.mNativeTypeface);
}
------------------------
Find a silently evolved API code:android.widget.DatePicker.getCalendarViewShown:COMMENT
Method Modifier: public      
Comment:/**
 * Gets whether the {@link CalendarView} is shown.
 *
 * @return True if the calendar view is shown.
 * @see #getCalendarView()
 */

Body of Frist Method:
{
    return (mCalendarView.getVisibility() == View.VISIBLE);
}
Body of Second Method:
{
    return mDelegate.getCalendarViewShown();
}
------------------------
Find a silently evolved API code:android.media.AudioService.checkForRingerModeChange:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Checks if the adjustment should change ringer mode instead of just
 * adjusting volume. If so, this will set the proper ringer mode and volume
 * indices on the stream states.
 */

Body of Frist Method:
{
    boolean adjustVolumeIndex = true;
    int ringerMode = getRingerMode();
    switch(ringerMode) {
        case RINGER_MODE_NORMAL:
            if (direction == AudioManager.ADJUST_LOWER) {
                if (mHasVibrator) {
                    // (step <= oldIndex < 2 * step) is equivalent to: (old UI index == 1)
                    if (step <= oldIndex && oldIndex < 2 * step) {
                        ringerMode = RINGER_MODE_VIBRATE;
                    }
                } else {
                    // (oldIndex < step) is equivalent to (old UI index == 0)
                    if ((oldIndex < step) && mPrevVolDirection != AudioManager.ADJUST_LOWER) {
                        ringerMode = RINGER_MODE_SILENT;
                    }
                }
            }
            break;
        case RINGER_MODE_VIBRATE:
            if (!mHasVibrator) {
                Log.e(TAG, "checkForRingerModeChange() current ringer mode is vibrate" + "but no vibrator is present");
                break;
            }
            if ((direction == AudioManager.ADJUST_LOWER)) {
                if (mPrevVolDirection != AudioManager.ADJUST_LOWER) {
                    ringerMode = RINGER_MODE_SILENT;
                }
            } else if (direction == AudioManager.ADJUST_RAISE) {
                ringerMode = RINGER_MODE_NORMAL;
            }
            adjustVolumeIndex = false;
            break;
        case RINGER_MODE_SILENT:
            if (direction == AudioManager.ADJUST_RAISE) {
                if (mHasVibrator) {
                    ringerMode = RINGER_MODE_VIBRATE;
                } else {
                    ringerMode = RINGER_MODE_NORMAL;
                }
            }
            adjustVolumeIndex = false;
            break;
        default:
            Log.e(TAG, "checkForRingerModeChange() wrong ringer mode: " + ringerMode);
            break;
    }
    setRingerMode(ringerMode);
    mPrevVolDirection = direction;
    return adjustVolumeIndex;
}
Body of Second Method:
{
    int result = FLAG_ADJUST_VOLUME;
    int ringerMode = getRingerMode();
    switch(ringerMode) {
        case RINGER_MODE_NORMAL:
            if (direction == AudioManager.ADJUST_LOWER) {
                if (mHasVibrator) {
                    // (step <= oldIndex < 2 * step) is equivalent to: (old UI index == 1)
                    if (step <= oldIndex && oldIndex < 2 * step) {
                        ringerMode = RINGER_MODE_VIBRATE;
                    }
                } else {
                    // (oldIndex < step) is equivalent to (old UI index == 0)
                    if ((oldIndex < step) && VOLUME_SETS_RINGER_MODE_SILENT && mPrevVolDirection != AudioManager.ADJUST_LOWER) {
                        ringerMode = RINGER_MODE_SILENT;
                    }
                }
            }
            break;
        case RINGER_MODE_VIBRATE:
            if (!mHasVibrator) {
                Log.e(TAG, "checkForRingerModeChange() current ringer mode is vibrate" + "but no vibrator is present");
                break;
            }
            if ((direction == AudioManager.ADJUST_LOWER)) {
                if (VOLUME_SETS_RINGER_MODE_SILENT && mPrevVolDirection != AudioManager.ADJUST_LOWER) {
                    ringerMode = RINGER_MODE_SILENT;
                }
            } else if (direction == AudioManager.ADJUST_RAISE) {
                ringerMode = RINGER_MODE_NORMAL;
            }
            result &= ~FLAG_ADJUST_VOLUME;
            break;
        case RINGER_MODE_SILENT:
            if (direction == AudioManager.ADJUST_RAISE) {
                if (PREVENT_VOLUME_ADJUSTMENT_IF_SILENT) {
                    result |= AudioManager.FLAG_SHOW_SILENT_HINT;
                } else {
                    if (mHasVibrator) {
                        ringerMode = RINGER_MODE_VIBRATE;
                    } else {
                        ringerMode = RINGER_MODE_NORMAL;
                    }
                }
            }
            result &= ~FLAG_ADJUST_VOLUME;
            break;
        default:
            Log.e(TAG, "checkForRingerModeChange() wrong ringer mode: " + ringerMode);
            break;
    }
    setRingerMode(ringerMode, false);
    mPrevVolDirection = direction;
    return result;
}
------------------------
Find a silently evolved API code:android.media.MediaFocusControl.onRcDisplayUpdate:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Called when processing MSG_RCDISPLAY_UPDATE event
 */

Body of Frist Method:
/* USED ?*/
{
    synchronized (mRCStack) {
        synchronized (mCurrentRcLock) {
            if ((mCurrentRcClient != null) && (mCurrentRcClient.equals(rcse.mRcClient))) {
                if (DEBUG_RC)
                    Log.i(TAG, "Display/update remote control ");
                mCurrentRcClientGen++;
                // synchronously update the displays and clients with
                // the new client generation
                setNewRcClient_syncRcsCurrc(mCurrentRcClientGen, rcse.mMediaIntent, /*newMediaIntent*/
                false);
                // tell the current client that it needs to send info
                try {
                    // TODO change name to informationRequestForAllDisplays()
                    mCurrentRcClient.onInformationRequested(mCurrentRcClientGen, flags);
                } catch (RemoteException e) {
                    Log.e(TAG, "Current valid remote client is dead: " + e);
                    mCurrentRcClient = null;
                }
            } else {
            // the remote control display owner has changed between the
            // the message to update the display was sent, and the time it
            // gets to be processed (now)
            }
        }
    }
}
Body of Second Method:
/* USED ?*/
{
    synchronized (mPRStack) {
        synchronized (mCurrentRcLock) {
            if ((mCurrentRcClient != null) && (mCurrentRcClient.equals(prse.getRcc()))) {
                if (DEBUG_RC)
                    Log.i(TAG, "Display/update remote control ");
                mCurrentRcClientGen++;
                // synchronously update the displays and clients with
                // the new client generation
                setNewRcClient_syncRcsCurrc(mCurrentRcClientGen, prse.getMediaButtonIntent(), /*newMediaIntent*/
                false);
                // tell the current client that it needs to send info
                try {
                    // TODO change name to informationRequestForAllDisplays()
                    mCurrentRcClient.onInformationRequested(mCurrentRcClientGen, flags);
                } catch (RemoteException e) {
                    Log.e(TAG, "Current valid remote client is dead: " + e);
                    mCurrentRcClient = null;
                }
            } else {
            // the remote control display owner has changed between the
            // the message to update the display was sent, and the time it
            // gets to be processed (now)
            }
        }
    }
}
------------------------
Find a silently evolved API code:android.widget.CalendarView.getDateTextAppearance:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the text appearance for the calendar dates.
 *
 * @return The text appearance resource id.
 *
 * @attr ref android.R.styleable#CalendarView_dateTextAppearance
 */

Body of Frist Method:
{
    return mDateTextAppearanceResId;
}
Body of Second Method:
{
    return mDelegate.getDateTextAppearance();
}
------------------------
Find a silently evolved API code:android.graphics.drawable.DrawableContainer.getOpticalInsets:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return (mCurrDrawable == null) ? Insets.NONE : mCurrDrawable.getOpticalInsets();
}
Body of Second Method:
{
    if (mCurrDrawable != null) {
        return mCurrDrawable.getOpticalInsets();
    }
    return Insets.NONE;
}
------------------------
Find a silently evolved API code:android.widget.FastScroller.measureViewToSide:COMMENT
Method Modifier: private     
Comment:/**
 * Measures the bounds for a view that should be laid out against the edge
 * of an adjacent view. If no adjacent view is provided, lays out against
 * the list edge.
 *
 * @param view The view to measure for layout.
 * @param adjacent (Optional) The adjacent view, may be null to align to the
 * list edge.
 * @param margins Layout margins to apply to the view.
 * @param out Rectangle into which measured bounds are placed.
 */

Body of Frist Method:
{
    final int marginLeft;
    final int marginTop;
    final int marginRight;
    if (margins == null) {
        marginLeft = 0;
        marginTop = 0;
        marginRight = 0;
    } else {
        marginLeft = margins.left;
        marginTop = margins.top;
        marginRight = margins.right;
    }
    final Rect container = mContainerRect;
    final int containerWidth = container.width();
    final int maxWidth;
    if (adjacent == null) {
        maxWidth = containerWidth;
    } else if (mLayoutFromRight) {
        maxWidth = adjacent.getLeft();
    } else {
        maxWidth = containerWidth - adjacent.getRight();
    }
    final int adjMaxWidth = maxWidth - marginLeft - marginRight;
    final int widthMeasureSpec = MeasureSpec.makeMeasureSpec(adjMaxWidth, MeasureSpec.AT_MOST);
    final int heightMeasureSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);
    view.measure(widthMeasureSpec, heightMeasureSpec);
    // Align to the left or right.
    final int width = view.getMeasuredWidth();
    final int left;
    final int right;
    if (mLayoutFromRight) {
        right = (adjacent == null ? container.right : adjacent.getLeft()) - marginRight;
        left = right - width;
    } else {
        left = (adjacent == null ? container.left : adjacent.getRight()) + marginLeft;
        right = left + width;
    }
    // Don't adjust the vertical position.
    final int top = marginTop;
    final int bottom = top + view.getMeasuredHeight();
    out.set(left, top, right, bottom);
}
Body of Second Method:
{
    final int marginLeft;
    final int marginTop;
    final int marginRight;
    if (margins == null) {
        marginLeft = 0;
        marginTop = 0;
        marginRight = 0;
    } else {
        marginLeft = margins.left;
        marginTop = margins.top;
        marginRight = margins.right;
    }
    final Rect container = mContainerRect;
    final int containerWidth = container.width();
    final int maxWidth;
    if (adjacent == null) {
        maxWidth = containerWidth;
    } else if (mLayoutFromRight) {
        maxWidth = adjacent.getLeft();
    } else {
        maxWidth = containerWidth - adjacent.getRight();
    }
    final int adjMaxWidth = maxWidth - marginLeft - marginRight;
    final int widthMeasureSpec = MeasureSpec.makeMeasureSpec(adjMaxWidth, MeasureSpec.AT_MOST);
    final int heightMeasureSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);
    view.measure(widthMeasureSpec, heightMeasureSpec);
    // Align to the left or right.
    final int width = Math.min(adjMaxWidth, view.getMeasuredWidth());
    final int left;
    final int right;
    if (mLayoutFromRight) {
        right = (adjacent == null ? container.right : adjacent.getLeft()) - marginRight;
        left = right - width;
    } else {
        left = (adjacent == null ? container.left : adjacent.getRight()) + marginLeft;
        right = left + width;
    }
    // Don't adjust the vertical position.
    final int top = marginTop;
    final int bottom = top + view.getMeasuredHeight();
    out.set(left, top, right, bottom);
}
------------------------
Find a silently evolved API code:android.app.Fragment.initState:COMMENT
Method Modifier: default     
Comment:/**
 * Called by the fragment manager once this fragment has been removed,
 * so that we don't have any left-over state if the application decides
 * to re-use the instance.  This only clears state that the framework
 * internally manages, not things the application sets.
 */

Body of Frist Method:
{
    mIndex = -1;
    mWho = null;
    mAdded = false;
    mRemoving = false;
    mResumed = false;
    mFromLayout = false;
    mInLayout = false;
    mRestored = false;
    mBackStackNesting = 0;
    mFragmentManager = null;
    mActivity = null;
    mFragmentId = 0;
    mContainerId = 0;
    mTag = null;
    mHidden = false;
    mDetached = false;
    mRetaining = false;
    mLoaderManager = null;
    mLoadersStarted = false;
    mCheckedForLoaderManager = false;
}
Body of Second Method:
{
    mIndex = -1;
    mWho = null;
    mAdded = false;
    mRemoving = false;
    mResumed = false;
    mFromLayout = false;
    mInLayout = false;
    mRestored = false;
    mBackStackNesting = 0;
    mFragmentManager = null;
    mChildFragmentManager = null;
    mActivity = null;
    mFragmentId = 0;
    mContainerId = 0;
    mTag = null;
    mHidden = false;
    mDetached = false;
    mRetaining = false;
    mLoaderManager = null;
    mLoadersStarted = false;
    mCheckedForLoaderManager = false;
}
------------------------
Find a silently evolved API code:android.os.Bundle.putCharSequence:COMMENT
Method Modifier: public      
Comment:/**
 * Inserts a CharSequence value into the mapping of this Bundle, replacing
 * any existing value for the given key.  Either key or value may be null.
 *
 * @param key a String, or null
 * @param value a CharSequence, or null
 */

Body of Frist Method:
{
    unparcel();
    mMap.put(key, value);
}
Body of Second Method:
{
    super.putCharSequence(key, value);
}
------------------------
Find a silently evolved API code:android.appwidget.AppWidgetHost.allocateAppWidgetId:COMMENT
Method Modifier: public      
Comment:/**
 * Get a appWidgetId for a host in the calling process.
 *
 * @return a appWidgetId
 */

Body of Frist Method:
{
    try {
        if (mPackageName == null) {
            mPackageName = mContext.getPackageName();
        }
        return sService.allocateAppWidgetId(mPackageName, mHostId, mContext.getUserId());
    } catch (RemoteException e) {
        throw new RuntimeException("system server dead?", e);
    }
}
Body of Second Method:
{
    try {
        return sService.allocateAppWidgetId(mContext.getOpPackageName(), mHostId);
    } catch (RemoteException e) {
        throw new RuntimeException("system server dead?", e);
    }
}
------------------------
Find a silently evolved API code:android.widget.DatePicker.getDayOfMonth:COMMENT
Method Modifier: public      
Comment:/**
 * @return The selected day of month.
 */

Body of Frist Method:
{
    return mCurrentDate.get(Calendar.DAY_OF_MONTH);
}
Body of Second Method:
{
    return mDelegate.getDayOfMonth();
}
------------------------
Find a silently evolved API code:android.graphics.Canvas.drawCircle:COMMENT
Method Modifier: public      
Comment:/**
 * Draw the specified circle using the specified paint. If radius is <= 0,
 * then nothing will be drawn. The circle will be filled or framed based
 * on the Style in the paint.
 *
 * @param cx     The x-coordinate of the center of the cirle to be drawn
 * @param cy     The y-coordinate of the center of the cirle to be drawn
 * @param radius The radius of the cirle to be drawn
 * @param paint  The paint used to draw the circle
 */

Body of Frist Method:
{
    native_drawCircle(mNativeCanvas, cx, cy, radius, paint.mNativePaint);
}
Body of Second Method:
{
    native_drawCircle(mNativeCanvasWrapper, cx, cy, radius, paint.mNativePaint);
}
------------------------
Find a silently evolved API code:android.transition.Fade.createAnimation:COMMENT
Method Modifier: private     
Comment:/**
 * Utility method to handle creating and running the Animator.
 */

Body of Frist Method:
{
    if (startAlpha == endAlpha) {
        // run listener if we're noop'ing the animation, to get the end-state results now
        if (listener != null) {
            listener.onAnimationEnd(null);
        }
        return null;
    }
    final ObjectAnimator anim = ObjectAnimator.ofFloat(view, "transitionAlpha", startAlpha, endAlpha);
    if (DBG) {
        Log.d(LOG_TAG, "Created animator " + anim);
    }
    if (listener != null) {
        anim.addListener(listener);
        anim.addPauseListener(listener);
    }
    return anim;
}
Body of Second Method:
{
    if (startAlpha == endAlpha) {
        return null;
    }
    view.setTransitionAlpha(startAlpha);
    final ObjectAnimator anim = ObjectAnimator.ofFloat(view, "transitionAlpha", endAlpha);
    if (DBG) {
        Log.d(LOG_TAG, "Created animator " + anim);
    }
    FadeAnimatorListener listener = new FadeAnimatorListener(view);
    anim.addListener(listener);
    anim.addPauseListener(listener);
    return anim;
}
------------------------
Find a silently evolved API code:android.widget.TimePicker.setCurrentHour:COMMENT
Method Modifier: public      
Comment:/**
 * Set the current hour.
 */

Body of Frist Method:
{
    setCurrentHour(currentHour, true);
}
Body of Second Method:
{
    mDelegate.setCurrentHour(currentHour);
}
------------------------
Find a silently evolved API code:android.graphics.Paint.setPathEffect:COMMENT
Method Modifier: public      
Comment:/**
 * Set or clear the patheffect object.
 * <p />
 * Pass null to clear any previous patheffect.
 * As a convenience, the parameter passed is also returned.
 *
 * @param effect May be null. The patheffect to be installed in the paint
 * @return       effect
 */

Body of Frist Method:
{
    int effectNative = 0;
    if (effect != null) {
        effectNative = effect.native_instance;
    }
    native_setPathEffect(mNativePaint, effectNative);
    mPathEffect = effect;
    return effect;
}
Body of Second Method:
{
    long effectNative = 0;
    if (effect != null) {
        effectNative = effect.native_instance;
    }
    native_setPathEffect(mNativePaint, effectNative);
    mPathEffect = effect;
    return effect;
}
------------------------
Find a silently evolved API code:android.transition.Transition.pause:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Pauses this transition, sending out calls to {@link
 * TransitionListener#onTransitionPause(Transition)} to all listeners
 * and pausing all running animators started by this transition.
 *
 * @hide
 */

Body of Frist Method:
{
    if (!mEnded) {
        ArrayMap<Animator, AnimationInfo> runningAnimators = getRunningAnimators();
        int numOldAnims = runningAnimators.size();
        for (int i = numOldAnims - 1; i >= 0; i--) {
            Animator anim = runningAnimators.keyAt(i);
            anim.pause();
        }
        if (mListeners != null && mListeners.size() > 0) {
            ArrayList<TransitionListener> tmpListeners = (ArrayList<TransitionListener>) mListeners.clone();
            int numListeners = tmpListeners.size();
            for (int i = 0; i < numListeners; ++i) {
                tmpListeners.get(i).onTransitionPause(this);
            }
        }
        mPaused = true;
    }
}
Body of Second Method:
{
    if (!mEnded) {
        ArrayMap<Animator, AnimationInfo> runningAnimators = getRunningAnimators();
        int numOldAnims = runningAnimators.size();
        if (sceneRoot != null) {
            WindowId windowId = sceneRoot.getWindowId();
            for (int i = numOldAnims - 1; i >= 0; i--) {
                AnimationInfo info = runningAnimators.valueAt(i);
                if (info.view != null && windowId != null && windowId.equals(info.windowId)) {
                    Animator anim = runningAnimators.keyAt(i);
                    anim.pause();
                }
            }
        }
        if (mListeners != null && mListeners.size() > 0) {
            ArrayList<TransitionListener> tmpListeners = (ArrayList<TransitionListener>) mListeners.clone();
            int numListeners = tmpListeners.size();
            for (int i = 0; i < numListeners; ++i) {
                tmpListeners.get(i).onTransitionPause(this);
            }
        }
        mPaused = true;
    }
}
------------------------
Find a silently evolved API code:android.content.res.BridgeTypedArray.getString:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the string value for the attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return String holding string data.  Any styling information is
 * removed.  Returns null if the attribute is not defined.
 */

Body of Frist Method:
{
    if (index < 0 || index >= mResourceData.length) {
        return null;
    }
    if (mResourceData[index] != null) {
        return mResourceData[index].getValue();
    }
    return null;
}
Body of Second Method:
{
    if (!hasValue(index)) {
        return null;
    }
    // As unfortunate as it is, it's possible to use enums with all attribute formats,
    // not just integers/enums. So, we need to search the enums always. In case
    // enums are used, the returned value is an integer.
    Integer v = resolveEnumAttribute(index);
    return v == null ? mResourceData[index].getValue() : String.valueOf((int) v);
}
------------------------
Find a silently evolved API code:android.view.Window.setLayout:COMMENT
Method Modifier: public      
Comment:/**
 * Set the width and height layout parameters of the window.  The default
 * for both of these is MATCH_PARENT; you can change them to WRAP_CONTENT
 * or an absolute value to make a window that is not full-screen.
 *
 * @param width The desired layout width of the window.
 * @param height The desired layout height of the window.
 *
 * @see ViewGroup.LayoutParams#height
 * @see ViewGroup.LayoutParams#width
 */

Body of Frist Method:
{
    final WindowManager.LayoutParams attrs = getAttributes();
    attrs.width = width;
    attrs.height = height;
    if (mCallback != null) {
        mCallback.onWindowAttributesChanged(attrs);
    }
}
Body of Second Method:
{
    final WindowManager.LayoutParams attrs = getAttributes();
    attrs.width = width;
    attrs.height = height;
    dispatchWindowAttributesChanged(attrs);
}
------------------------
Find a silently evolved API code:android.app.ApplicationPackageManager.getResourcesForApplicationAsUser:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (userId < 0) {
        throw new IllegalArgumentException("Call does not support special user #" + userId);
    }
    if ("system".equals(appPackageName)) {
        return mContext.mMainThread.getSystemContext().getResources();
    }
    try {
        ApplicationInfo ai = mPM.getApplicationInfo(appPackageName, 0, userId);
        if (ai != null) {
            return getResourcesForApplication(ai);
        }
    } catch (RemoteException e) {
        throw new RuntimeException("Package manager has died", e);
    }
    throw new NameNotFoundException("Package " + appPackageName + " doesn't exist");
}
Body of Second Method:
{
    if (userId < 0) {
        throw new IllegalArgumentException("Call does not support special user #" + userId);
    }
    if ("system".equals(appPackageName)) {
        return mContext.mMainThread.getSystemContext().getResources();
    }
    try {
        ApplicationInfo ai = mPM.getApplicationInfo(appPackageName, sDefaultFlags, userId);
        if (ai != null) {
            return getResourcesForApplication(ai);
        }
    } catch (RemoteException e) {
        throw new RuntimeException("Package manager has died", e);
    }
    throw new NameNotFoundException("Package " + appPackageName + " doesn't exist");
}
------------------------
Find a silently evolved API code:android.animation.ObjectAnimator.getTarget:COMMENT
Method Modifier: public      
Comment:/**
 * The target object whose property will be animated by this animation
 *
 * @return The object being animated
 */

Body of Frist Method:
{
    return mTarget;
}
Body of Second Method:
{
    return mTarget == null ? null : mTarget.get();
}
------------------------
Find a silently evolved API code:android.graphics.pdf.PdfDocument.startPage:COMMENT
Method Modifier: public      
Comment:/**
 * Starts a page using the provided {@link PageInfo}. After the page
 * is created you can draw arbitrary content on the page's canvas which
 * you can get by calling {@link Page#getCanvas()}. After you are done
 * drawing the content you should finish the page by calling
 * {@link #finishPage(Page)}. After the page is finished you should
 * no longer access the page or its canvas.
 * <p>
 * <strong>Note:</strong> Do not call this method after {@link #close()}.
 * Also do not call this method if the last page returned by this method
 * is not finished by calling {@link #finishPage(Page)}.
 * </p>
 *
 * @param pageInfo The page info. Cannot be null.
 * @return A blank page.
 *
 * @see #finishPage(Page)
 */

Body of Frist Method:
{
    throwIfClosed();
    throwIfCurrentPageNotFinished();
    if (pageInfo == null) {
        throw new IllegalArgumentException("page cannot be null");
    }
    Canvas canvas = new PdfCanvas(nativeCreatePage(pageInfo.mPageWidth, pageInfo.mPageHeight, pageInfo.mContentRect.left, pageInfo.mContentRect.top, pageInfo.mContentRect.right, pageInfo.mContentRect.bottom));
    mCurrentPage = new Page(canvas, pageInfo);
    return mCurrentPage;
}
Body of Second Method:
{
    throwIfClosed();
    throwIfCurrentPageNotFinished();
    if (pageInfo == null) {
        throw new IllegalArgumentException("page cannot be null");
    }
    Canvas canvas = new PdfCanvas(nativeStartPage(mNativeDocument, pageInfo.mPageWidth, pageInfo.mPageHeight, pageInfo.mContentRect.left, pageInfo.mContentRect.top, pageInfo.mContentRect.right, pageInfo.mContentRect.bottom));
    mCurrentPage = new Page(canvas, pageInfo);
    return mCurrentPage;
}
------------------------
Find a silently evolved API code:android.transition.Transition.isValidTarget:COMMENT
Method Modifier: default     
Comment:/**
 * Internal utility method for checking whether a given view/id
 * is valid for this transition, where "valid" means that either
 * the Transition has no target/targetId list (the default, in which
 * cause the transition should act on all views in the hiearchy), or
 * the given view is in the target list or the view id is in the
 * targetId list. If the target parameter is null, then the target list
 * is not checked (this is in the case of ListView items, where the
 * views are ignored and only the ids are used).
 */

Body of Frist Method:
{
    if (mTargetIdExcludes != null && mTargetIdExcludes.contains(targetId)) {
        return false;
    }
    if (mTargetExcludes != null && mTargetExcludes.contains(target)) {
        return false;
    }
    if (mTargetTypeExcludes != null && target != null) {
        int numTypes = mTargetTypeExcludes.size();
        for (int i = 0; i < numTypes; ++i) {
            Class type = mTargetTypeExcludes.get(i);
            if (type.isInstance(target)) {
                return false;
            }
        }
    }
    if (mTargetIds.size() == 0 && mTargets.size() == 0) {
        return true;
    }
    if (mTargetIds.size() > 0) {
        for (int i = 0; i < mTargetIds.size(); ++i) {
            if (mTargetIds.get(i) == targetId) {
                return true;
            }
        }
    }
    if (target != null && mTargets.size() > 0) {
        for (int i = 0; i < mTargets.size(); ++i) {
            if (mTargets.get(i) == target) {
                return true;
            }
        }
    }
    return false;
}
Body of Second Method:
{
    int targetId = target.getId();
    if (mTargetIdExcludes != null && mTargetIdExcludes.contains(targetId)) {
        return false;
    }
    if (mTargetExcludes != null && mTargetExcludes.contains(target)) {
        return false;
    }
    if (mTargetTypeExcludes != null && target != null) {
        int numTypes = mTargetTypeExcludes.size();
        for (int i = 0; i < numTypes; ++i) {
            Class type = mTargetTypeExcludes.get(i);
            if (type.isInstance(target)) {
                return false;
            }
        }
    }
    if (mTargetNameExcludes != null && target != null && target.getTransitionName() != null) {
        if (mTargetNameExcludes.contains(target.getTransitionName())) {
            return false;
        }
    }
    if (mTargetIds.size() == 0 && mTargets.size() == 0 && (mTargetTypes == null || mTargetTypes.isEmpty()) && (mTargetNames == null || mTargetNames.isEmpty())) {
        return true;
    }
    if (mTargetIds.contains(targetId) || mTargets.contains(target)) {
        return true;
    }
    if (mTargetNames != null && mTargetNames.contains(target.getTransitionName())) {
        return true;
    }
    if (mTargetTypes != null) {
        for (int i = 0; i < mTargetTypes.size(); ++i) {
            if (mTargetTypes.get(i).isInstance(target)) {
                return true;
            }
        }
    }
    return false;
}
------------------------
Find a silently evolved API code:android.view.ViewGroup.addFocusables:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    final int focusableCount = views.size();
    final int descendantFocusability = getDescendantFocusability();
    if (descendantFocusability != FOCUS_BLOCK_DESCENDANTS) {
        final int count = mChildrenCount;
        final View[] children = mChildren;
        for (int i = 0; i < count; i++) {
            final View child = children[i];
            if ((child.mViewFlags & VISIBILITY_MASK) == VISIBLE) {
                child.addFocusables(views, direction, focusableMode);
            }
        }
    }
    // among the focusable children would be more interesting.
    if (descendantFocusability != FOCUS_AFTER_DESCENDANTS || // No focusable descendants
    (focusableCount == views.size())) {
        super.addFocusables(views, direction, focusableMode);
    }
}
Body of Second Method:
{
    final int focusableCount = views.size();
    final int descendantFocusability = getDescendantFocusability();
    if (descendantFocusability != FOCUS_BLOCK_DESCENDANTS) {
        if (shouldBlockFocusForTouchscreen()) {
            focusableMode |= FOCUSABLES_TOUCH_MODE;
        }
        final int count = mChildrenCount;
        final View[] children = mChildren;
        for (int i = 0; i < count; i++) {
            final View child = children[i];
            if ((child.mViewFlags & VISIBILITY_MASK) == VISIBLE) {
                child.addFocusables(views, direction, focusableMode);
            }
        }
    }
    // among the focusable children would be more interesting.
    if ((descendantFocusability != FOCUS_AFTER_DESCENDANTS || // No focusable descendants
    (focusableCount == views.size())) && (isFocusableInTouchMode() || !shouldBlockFocusForTouchscreen())) {
        super.addFocusables(views, direction, focusableMode);
    }
}
------------------------
Find a silently evolved API code:android.util.ArrayMap.clear:COMMENT
Method Modifier: public      
Comment:/**
 * Make the array map empty.  All storage is released.
 */

Body of Frist Method:
{
    if (mSize > 0) {
        freeArrays(mHashes, mArray, mSize);
        mHashes = ContainerHelpers.EMPTY_INTS;
        mArray = ContainerHelpers.EMPTY_OBJECTS;
        mSize = 0;
    }
}
Body of Second Method:
{
    if (mSize > 0) {
        freeArrays(mHashes, mArray, mSize);
        mHashes = EmptyArray.INT;
        mArray = EmptyArray.OBJECT;
        mSize = 0;
    }
}
------------------------
Find a silently evolved API code:android.media.MediaPlayer.availableMimeTypeForExternalSource:COMMENT
Method Modifier: private     static      
Comment:/*
     * A helper function to check if the mime type is supported by media framework.
     */

Body of Frist Method:
{
    if (mimeType == MEDIA_MIMETYPE_TEXT_SUBRIP) {
        return true;
    }
    return false;
}
Body of Second Method:
{
    if (MEDIA_MIMETYPE_TEXT_SUBRIP.equals(mimeType)) {
        return true;
    }
    return false;
}
------------------------
Find a silently evolved API code:android.os.Bundle.putCharSequenceArray:COMMENT
Method Modifier: public      
Comment:/**
 * Inserts a CharSequence array value into the mapping of this Bundle, replacing
 * any existing value for the given key.  Either key or value may be null.
 *
 * @param key a String, or null
 * @param value a CharSequence array object, or null
 */

Body of Frist Method:
{
    unparcel();
    mMap.put(key, value);
}
Body of Second Method:
{
    super.putCharSequenceArray(key, value);
}
------------------------
Find a silently evolved API code:android.widget.Spinner.setPopupBackgroundResource:COMMENT
Method Modifier: public      
Comment:/**
 * Set the background drawable for the spinner's popup window of choices.
 * Only valid in {@link #MODE_DROPDOWN}; this method is a no-op in other modes.
 *
 * @param resId Resource ID of a background drawable
 *
 * @attr ref android.R.styleable#Spinner_popupBackground
 */

Body of Frist Method:
{
    setPopupBackgroundDrawable(getContext().getResources().getDrawable(resId));
}
Body of Second Method:
{
    setPopupBackgroundDrawable(getContext().getDrawable(resId));
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothAdapter.closeProfileProxy:COMMENT
Method Modifier: public      
Comment:/**
 * Close the connection of the profile proxy to the Service.
 *
 * <p> Clients should call this when they are no longer using
 * the proxy obtained from {@link #getProfileProxy}.
 * Profile can be one of  {@link BluetoothProfile#HEALTH}, {@link BluetoothProfile#HEADSET} or
 * {@link BluetoothProfile#A2DP}
 *
 * @param profile
 * @param proxy Profile proxy object
 */

Body of Frist Method:
{
    if (proxy == null)
        return;
    switch(profile) {
        case BluetoothProfile.HEADSET:
            BluetoothHeadset headset = (BluetoothHeadset) proxy;
            headset.close();
            break;
        case BluetoothProfile.A2DP:
            BluetoothA2dp a2dp = (BluetoothA2dp) proxy;
            a2dp.close();
            break;
        case BluetoothProfile.INPUT_DEVICE:
            BluetoothInputDevice iDev = (BluetoothInputDevice) proxy;
            iDev.close();
            break;
        case BluetoothProfile.PAN:
            BluetoothPan pan = (BluetoothPan) proxy;
            pan.close();
            break;
        case BluetoothProfile.HEALTH:
            BluetoothHealth health = (BluetoothHealth) proxy;
            health.close();
            break;
        case BluetoothProfile.GATT:
            BluetoothGatt gatt = (BluetoothGatt) proxy;
            gatt.close();
            break;
        case BluetoothProfile.GATT_SERVER:
            BluetoothGattServer gattServer = (BluetoothGattServer) proxy;
            gattServer.close();
            break;
        case BluetoothProfile.MAP:
            BluetoothMap map = (BluetoothMap) proxy;
            map.close();
            break;
    }
}
Body of Second Method:
{
    if (proxy == null)
        return;
    switch(profile) {
        case BluetoothProfile.HEADSET:
            BluetoothHeadset headset = (BluetoothHeadset) proxy;
            headset.close();
            break;
        case BluetoothProfile.A2DP:
            BluetoothA2dp a2dp = (BluetoothA2dp) proxy;
            a2dp.close();
            break;
        case BluetoothProfile.A2DP_SINK:
            BluetoothA2dpSink a2dpSink = (BluetoothA2dpSink) proxy;
            a2dpSink.close();
            break;
        case BluetoothProfile.AVRCP_CONTROLLER:
            BluetoothAvrcpController avrcp = (BluetoothAvrcpController) proxy;
            avrcp.close();
            break;
        case BluetoothProfile.INPUT_DEVICE:
            BluetoothInputDevice iDev = (BluetoothInputDevice) proxy;
            iDev.close();
            break;
        case BluetoothProfile.PAN:
            BluetoothPan pan = (BluetoothPan) proxy;
            pan.close();
            break;
        case BluetoothProfile.HEALTH:
            BluetoothHealth health = (BluetoothHealth) proxy;
            health.close();
            break;
        case BluetoothProfile.GATT:
            BluetoothGatt gatt = (BluetoothGatt) proxy;
            gatt.close();
            break;
        case BluetoothProfile.GATT_SERVER:
            BluetoothGattServer gattServer = (BluetoothGattServer) proxy;
            gattServer.close();
            break;
        case BluetoothProfile.MAP:
            BluetoothMap map = (BluetoothMap) proxy;
            map.close();
            break;
        case BluetoothProfile.HEADSET_CLIENT:
            BluetoothHeadsetClient headsetClient = (BluetoothHeadsetClient) proxy;
            headsetClient.close();
            break;
    }
}
------------------------
Find a silently evolved API code:android.content.RestrictionEntry.getType:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the type for this restriction.
 * @return the type for this restriction
 */

Body of Frist Method:
{
    return type;
}
Body of Second Method:
{
    return mType;
}
------------------------
Find a silently evolved API code:android.graphics.ImageFormat.getBitsPerPixel:COMMENT
Method Modifier: public      static      
Comment:/**
 * Use this function to retrieve the number of bits per pixel of an
 * ImageFormat.
 *
 * @param format
 * @return the number of bits per pixel of the given format or -1 if the
 * format doesn't exist or is not supported.
 */

Body of Frist Method:
{
    switch(format) {
        case RGB_565:
            return 16;
        case NV16:
            return 16;
        case YUY2:
            return 16;
        case YV12:
            return 12;
        case Y8:
            return 8;
        case Y16:
            return 16;
        case NV21:
            return 12;
        case YUV_420_888:
            return 12;
        case RAW_SENSOR:
            return 16;
        case BAYER_RGGB:
            return 16;
    }
    return -1;
}
Body of Second Method:
{
    switch(format) {
        case RGB_565:
            return 16;
        case NV16:
            return 16;
        case YUY2:
            return 16;
        case YV12:
            return 12;
        case Y8:
            return 8;
        case Y16:
            return 16;
        case NV21:
            return 12;
        case YUV_420_888:
            return 12;
        case RAW_SENSOR:
            return 16;
        case RAW10:
            return 10;
    }
    return -1;
}
------------------------
Find a silently evolved API code:android.app.Activity.onWindowStartingActionMode:COMMENT
Method Modifier: public      
Comment:/**
 * Give the Activity a chance to control the UI for an action mode requested
 * by the system.
 *
 * <p>Note: If you are looking for a notification callback that an action mode
 * has been started for this activity, see {@link #onActionModeStarted(ActionMode)}.</p>
 *
 * @param callback The callback that should control the new action mode
 * @return The new action mode, or <code>null</code> if the activity does not want to
 * provide special handling for this action mode. (It will be handled by the system.)
 */

Body of Frist Method:
{
    initActionBar();
    if (mActionBar != null) {
        return mActionBar.startActionMode(callback);
    }
    return null;
}
Body of Second Method:
{
    initWindowDecorActionBar();
    if (mActionBar != null) {
        return mActionBar.startActionMode(callback);
    }
    return null;
}
------------------------
Find a silently evolved API code:android.media.MediaFocusControl.requestAudioFocus:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * @see AudioManager#requestAudioFocus(AudioManager.OnAudioFocusChangeListener, int, int)
 */

Body of Frist Method:
{
    Log.i(TAG, " AudioFocus  requestAudioFocus() from " + clientId);
    // we need a valid binder callback for clients
    if (!cb.pingBinder()) {
        Log.e(TAG, " AudioFocus DOA client for requestAudioFocus(), aborting.");
        return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
    }
    if (mAppOps.noteOp(AppOpsManager.OP_TAKE_AUDIO_FOCUS, Binder.getCallingUid(), callingPackageName) != AppOpsManager.MODE_ALLOWED) {
        return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
    }
    synchronized (mAudioFocusLock) {
        if (!canReassignAudioFocus()) {
            return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
        }
        // handle the potential premature death of the new holder of the focus
        // (premature death == death before abandoning focus)
        // Register for client death notification
        AudioFocusDeathHandler afdh = new AudioFocusDeathHandler(cb);
        try {
            cb.linkToDeath(afdh, 0);
        } catch (RemoteException e) {
            // client has already died!
            Log.w(TAG, "AudioFocus  requestAudioFocus() could not link to " + cb + " binder death");
            return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
        }
        if (!mFocusStack.empty() && mFocusStack.peek().hasSameClient(clientId)) {
            // hasn't changed, don't do anything
            if (mFocusStack.peek().getGainRequest() == focusChangeHint) {
                // unlink death handler so it can be gc'ed.
                // linkToDeath() creates a JNI global reference preventing collection.
                cb.unlinkToDeath(afdh, 0);
                return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
            }
            // the reason for the audio focus request has changed: remove the current top of
            // stack and respond as if we had a new focus owner
            FocusRequester fr = mFocusStack.pop();
            fr.release();
        }
        // focus requester might already be somewhere below in the stack, remove it
        removeFocusStackEntry(clientId, false);
        // propagate the focus change through the stack
        if (!mFocusStack.empty()) {
            propagateFocusLossFromGain_syncAf(focusChangeHint);
        }
        // push focus requester at the top of the audio focus stack
        mFocusStack.push(new FocusRequester(mainStreamType, focusChangeHint, fd, cb, clientId, afdh, callingPackageName, Binder.getCallingUid()));
        // there's a new top of the stack, let the remote control know
        synchronized (mRCStack) {
            checkUpdateRemoteControlDisplay_syncAfRcs(RC_INFO_ALL);
        }
    }
    return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}
Body of Second Method:
{
    Log.i(TAG, " AudioFocus  requestAudioFocus() from " + clientId);
    // we need a valid binder callback for clients
    if (!cb.pingBinder()) {
        Log.e(TAG, " AudioFocus DOA client for requestAudioFocus(), aborting.");
        return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
    }
    if (mAppOps.noteOp(AppOpsManager.OP_TAKE_AUDIO_FOCUS, Binder.getCallingUid(), callingPackageName) != AppOpsManager.MODE_ALLOWED) {
        return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
    }
    synchronized (mAudioFocusLock) {
        if (!canReassignAudioFocus()) {
            return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
        }
        // handle the potential premature death of the new holder of the focus
        // (premature death == death before abandoning focus)
        // Register for client death notification
        AudioFocusDeathHandler afdh = new AudioFocusDeathHandler(cb);
        try {
            cb.linkToDeath(afdh, 0);
        } catch (RemoteException e) {
            // client has already died!
            Log.w(TAG, "AudioFocus  requestAudioFocus() could not link to " + cb + " binder death");
            return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
        }
        if (!mFocusStack.empty() && mFocusStack.peek().hasSameClient(clientId)) {
            // hasn't changed, don't do anything
            if (mFocusStack.peek().getGainRequest() == focusChangeHint) {
                // unlink death handler so it can be gc'ed.
                // linkToDeath() creates a JNI global reference preventing collection.
                cb.unlinkToDeath(afdh, 0);
                return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
            }
            // the reason for the audio focus request has changed: remove the current top of
            // stack and respond as if we had a new focus owner
            FocusRequester fr = mFocusStack.pop();
            fr.release();
        }
        // focus requester might already be somewhere below in the stack, remove it
        removeFocusStackEntry(clientId, false);
        // propagate the focus change through the stack
        if (!mFocusStack.empty()) {
            propagateFocusLossFromGain_syncAf(focusChangeHint);
        }
        // push focus requester at the top of the audio focus stack
        mFocusStack.push(new FocusRequester(mainStreamType, focusChangeHint, fd, cb, clientId, afdh, callingPackageName, Binder.getCallingUid()));
    }
    return AudioManager.AUDIOFOCUS_REQUEST_GRANTED;
}
------------------------
Find a silently evolved API code:android.widget.CalendarView.setShownWeekCount:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the number of weeks to be shown.
 *
 * @param count The shown week count.
 *
 * @attr ref android.R.styleable#CalendarView_shownWeekCount
 */

Body of Frist Method:
{
    if (mShownWeekCount != count) {
        mShownWeekCount = count;
        invalidate();
    }
}
Body of Second Method:
{
    mDelegate.setShownWeekCount(count);
}
------------------------
Find a silently evolved API code:android.app.Activity.openOptionsMenu:COMMENT
Method Modifier: public      
Comment:/**
 * Programmatically opens the options menu. If the options menu is already
 * open, this method does nothing.
 */

Body of Frist Method:
{
    mWindow.openPanel(Window.FEATURE_OPTIONS_PANEL, null);
}
Body of Second Method:
{
    if (mActionBar == null || !mActionBar.openOptionsMenu()) {
        mWindow.openPanel(Window.FEATURE_OPTIONS_PANEL, null);
    }
}
------------------------
Find a silently evolved API code:android.print.PrinterCapabilitiesInfo.getMediaSizes:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the supported media sizes.
 *
 * @return The media sizes.
 */

Body of Frist Method:
{
    return mMediaSizes;
}
Body of Second Method:
{
    return Collections.unmodifiableList(mMediaSizes);
}
------------------------
Find a silently evolved API code:android.widget.CalendarView.getShownWeekCount:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the number of weeks to be shown.
 *
 * @return The shown week count.
 *
 * @attr ref android.R.styleable#CalendarView_shownWeekCount
 */

Body of Frist Method:
{
    return mShownWeekCount;
}
Body of Second Method:
{
    return mDelegate.getShownWeekCount();
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothDevice.createBond:COMMENT
Method Modifier: public      
Comment:/**
 * Start the bonding (pairing) process with the remote device.
 * <p>This is an asynchronous call, it will return immediately. Register
 * for {@link #ACTION_BOND_STATE_CHANGED} intents to be notified when
 * the bonding process completes, and its result.
 * <p>Android system services will handle the necessary user interactions
 * to confirm and complete the bonding process.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}.
 *
 * @return false on immediate error, true if bonding will begin
 */

Body of Frist Method:
{
    if (sService == null) {
        Log.e(TAG, "BT not enabled. Cannot create bond to Remote Device");
        return false;
    }
    try {
        return sService.createBond(this);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
Body of Second Method:
{
    if (sService == null) {
        Log.e(TAG, "BT not enabled. Cannot create bond to Remote Device");
        return false;
    }
    try {
        return sService.createBond(this, TRANSPORT_AUTO);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
------------------------
Find a silently evolved API code:android.graphics.Canvas.drawPath:COMMENT
Method Modifier: public      
Comment:/**
 * Draw the specified path using the specified paint. The path will be
 * filled or framed based on the Style in the paint.
 *
 * @param path  The path to be drawn
 * @param paint The paint used to draw the path
 */

Body of Frist Method:
{
    native_drawPath(mNativeCanvas, path.ni(), paint.mNativePaint);
}
Body of Second Method:
{
    native_drawPath(mNativeCanvasWrapper, path.ni(), paint.mNativePaint);
}
------------------------
Find a silently evolved API code:android.graphics.Bitmap.getAllocationByteCount:COMMENT
Method Modifier: public      final       
Comment:/**
 * Returns the size of the allocated memory used to store this bitmap's pixels.
 *
 * <p>This can be larger than the result of {@link #getByteCount()} if a bitmap is reused to
 * decode other bitmaps of smaller size, or by manual reconfiguration. See {@link
 * #reconfigure(int, int, Config)}, {@link #setWidth(int)}, {@link #setHeight(int)}, {@link
 * #setConfig(Bitmap.Config)}, and {@link BitmapFactory.Options#inBitmap
 * BitmapFactory.Options.inBitmap}. If a bitmap is not modified in this way, this value will be
 * the same as that returned by {@link #getByteCount()}.</p>
 *
 * <p>This value will not change over the lifetime of a Bitmap.</p>
 *
 * @see #reconfigure(int, int, Config)
 */

Body of Frist Method:
{
    return mBuffer.length;
}
Body of Second Method:
{
    if (mBuffer == null) {
        // so alloc size is always content size
        return getByteCount();
    }
    return mBuffer.length;
}
------------------------
Find a silently evolved API code:android.nfc.tech.Ndef.getNdefMessage:COMMENT
Method Modifier: public      
Comment:/**
 * Read the current {@link android.nfc.NdefMessage} on this tag.
 *
 * <p>This always reads the current NDEF Message stored on the tag.
 *
 * <p>Note that this method may return null if the tag was in the
 * INITIALIZED state as defined by NFC Forum, as in that state the
 * tag is formatted to support NDEF but does not contain a message yet.
 *
 * <p>This is an I/O operation and will block until complete. It must
 * not be called from the main application thread. A blocked call will be canceled with
 * {@link IOException} if {@link #close} is called from another thread.
 *
 * <p class="note">Requires the {@link android.Manifest.permission#NFC} permission.
 *
 * @return the NDEF Message, can be null
 * @throws TagLostException if the tag leaves the field
 * @throws IOException if there is an I/O failure, or the operation is canceled
 * @throws FormatException if the NDEF Message on the tag is malformed
 */

Body of Frist Method:
{
    checkConnected();
    try {
        INfcTag tagService = mTag.getTagService();
        if (tagService == null) {
            throw new IOException("Mock tags don't support this operation.");
        }
        int serviceHandle = mTag.getServiceHandle();
        if (tagService.isNdef(serviceHandle)) {
            NdefMessage msg = tagService.ndefRead(serviceHandle);
            if (msg == null && !tagService.isPresent(serviceHandle)) {
                throw new TagLostException();
            }
            return msg;
        } else {
            return null;
        }
    } catch (RemoteException e) {
        Log.e(TAG, "NFC service dead", e);
        return null;
    }
}
Body of Second Method:
{
    checkConnected();
    try {
        INfcTag tagService = mTag.getTagService();
        if (tagService == null) {
            throw new IOException("Mock tags don't support this operation.");
        }
        int serviceHandle = mTag.getServiceHandle();
        if (tagService.isNdef(serviceHandle)) {
            NdefMessage msg = tagService.ndefRead(serviceHandle);
            if (msg == null && !tagService.isPresent(serviceHandle)) {
                throw new TagLostException();
            }
            return msg;
        } else if (!tagService.isPresent(serviceHandle)) {
            throw new TagLostException();
        } else {
            return null;
        }
    } catch (RemoteException e) {
        Log.e(TAG, "NFC service dead", e);
        return null;
    }
}
------------------------
Find a silently evolved API code:android.widget.AbsListView.isFastScrollEnabled:COMMENT
Method Modifier: public      
Comment:/**
 * Returns true if the fast scroller is enabled.
 *
 * @see #setFastScrollEnabled(boolean)
 * @return true if fast scroll is enabled, false otherwise
 */

Body of Frist Method:
{
    if (mFastScroller == null) {
        return mFastScrollEnabled;
    } else {
        return mFastScroller.isEnabled();
    }
}
Body of Second Method:
{
    if (mFastScroll == null) {
        return mFastScrollEnabled;
    } else {
        return mFastScroll.isEnabled();
    }
}
------------------------
Find a silently evolved API code:android.graphics.Paint.getTextBounds:COMMENT
Method Modifier: public      
Comment:/**
 * Return in bounds (allocated by the caller) the smallest rectangle that
 * encloses all of the characters, with an implied origin at (0,0).
 *
 * @param text  Array of chars to measure and return their unioned bounds
 * @param index Index of the first char in the array to measure
 * @param count The number of chars, beginning at index, to measure
 * @param bounds Returns the unioned bounds of all the text. Must be
 * allocated by the caller.
 */

Body of Frist Method:
{
    if ((index | count) < 0 || index + count > text.length) {
        throw new ArrayIndexOutOfBoundsException();
    }
    if (bounds == null) {
        throw new NullPointerException("need bounds Rect");
    }
    nativeGetCharArrayBounds(mNativePaint, text, index, count, mBidiFlags, bounds);
}
Body of Second Method:
{
    if ((index | count) < 0 || index + count > text.length) {
        throw new ArrayIndexOutOfBoundsException();
    }
    if (bounds == null) {
        throw new NullPointerException("need bounds Rect");
    }
    nativeGetCharArrayBounds(mNativePaint, mNativeTypeface, text, index, count, mBidiFlags, bounds);
}
------------------------
Find a silently evolved API code:android.app.ActivityManager.dumpPackageStateStatic:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    FileOutputStream fout = new FileOutputStream(fd);
    PrintWriter pw = new FastPrintWriter(fout);
    dumpService(pw, fd, Context.ACTIVITY_SERVICE, new String[] { "package", packageName });
    pw.println();
    dumpService(pw, fd, ProcessStats.SERVICE_NAME, new String[] { packageName });
    pw.println();
    dumpService(pw, fd, "usagestats", new String[] { "--packages", packageName });
    pw.println();
    dumpService(pw, fd, "package", new String[] { packageName });
    pw.println();
    dumpService(pw, fd, BatteryStats.SERVICE_NAME, new String[] { packageName });
    pw.flush();
}
Body of Second Method:
{
    FileOutputStream fout = new FileOutputStream(fd);
    PrintWriter pw = new FastPrintWriter(fout);
    dumpService(pw, fd, "package", new String[] { packageName });
    pw.println();
    dumpService(pw, fd, Context.ACTIVITY_SERVICE, new String[] { "-a", "package", packageName });
    pw.println();
    dumpService(pw, fd, "meminfo", new String[] { "--local", "--package", packageName });
    pw.println();
    dumpService(pw, fd, ProcessStats.SERVICE_NAME, new String[] { packageName });
    pw.println();
    dumpService(pw, fd, "usagestats", new String[] { "--packages", packageName });
    pw.println();
    dumpService(pw, fd, BatteryStats.SERVICE_NAME, new String[] { packageName });
    pw.flush();
}
------------------------
Find a silently evolved API code:android.app.Notification.Style.addExtras:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (mSummaryTextSet) {
        extras.putCharSequence(EXTRA_SUMMARY_TEXT, mSummaryText);
    }
    if (mBigContentTitle != null) {
        extras.putCharSequence(EXTRA_TITLE_BIG, mBigContentTitle);
    }
}
Body of Second Method:
{
    if (mSummaryTextSet) {
        extras.putCharSequence(EXTRA_SUMMARY_TEXT, mSummaryText);
    }
    if (mBigContentTitle != null) {
        extras.putCharSequence(EXTRA_TITLE_BIG, mBigContentTitle);
    }
    extras.putString(EXTRA_TEMPLATE, this.getClass().getName());
}
------------------------
Find a silently evolved API code:android.view.HardwareLayer.isValid:COMMENT
<android.view.HardwareLayer: boolean isValid()>
default     abstract    ->public      hidden      
Method Modifier: public      default     abstract    hidden      
Method Modifier: No          Yes         Yes         No          
Method Updated:  Yes         No          No          Yes         
Comment:/**
 * Indicates whether this layer can be rendered.
 *
 * @return True if the layer can be rendered into, false otherwise
 */

Body of Frist Method:

Body of Second Method:
{
    return mFinalizer != null && mFinalizer.get() != 0;
}
------------------------
Find a silently evolved API code:android.content.res.TypedArray.getResourceId:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the resource identifier for the attribute at
 * <var>index</var>.  Note that attribute resource as resolved when
 * the overall {@link TypedArray} object is retrieved.  As a
 * result, this function will return the resource identifier of the
 * final resource value that was found, <em>not</em> necessarily the
 * original resource that was specified by the attribute.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute resource identifier, or defValue if not defined.
 */

Body of Frist Method:
{
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    if (data[index + AssetManager.STYLE_TYPE] != TypedValue.TYPE_NULL) {
        final int resid = data[index + AssetManager.STYLE_RESOURCE_ID];
        if (resid != 0) {
            return resid;
        }
    }
    return defValue;
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    if (data[index + AssetManager.STYLE_TYPE] != TypedValue.TYPE_NULL) {
        final int resid = data[index + AssetManager.STYLE_RESOURCE_ID];
        if (resid != 0) {
            return resid;
        }
    }
    return defValue;
}
------------------------
Find a silently evolved API code:android.graphics.Canvas.translate:COMMENT
<android.graphics.Canvas: void translate(float,float)>
public      native      ->public      
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * Preconcat the current matrix with the specified translation
 *
 * @param dx The distance to translate in X
 * @param dy The distance to translate in Y
 */

Body of Frist Method:

Body of Second Method:
{
    native_translate(mNativeCanvasWrapper, dx, dy);
}
------------------------
Find a silently evolved API code:android.content.res.TypedArray.getResources:COMMENT
Method Modifier: public      
Comment:/**
 * Return the Resources object this array was loaded from.
 */

Body of Frist Method:
{
    return mResources;
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    return mResources;
}
------------------------
Find a silently evolved API code:android.view.SurfaceControl.PhysicalDisplayInfo.toString:COMMENT
Method Modifier: public      
Comment:// For debugging purposes

Body of Frist Method:
{
    return "PhysicalDisplayInfo{" + width + " x " + height + ", " + refreshRate + " fps, " + "density " + density + ", " + xDpi + " x " + yDpi + " dpi, secure " + secure + "}";
}
Body of Second Method:
{
    return "PhysicalDisplayInfo{" + width + " x " + height + ", " + refreshRate + " fps, " + "density " + density + ", " + xDpi + " x " + yDpi + " dpi, secure " + secure + ", appVsyncOffset " + appVsyncOffsetNanos + ", bufferDeadline " + presentationDeadlineNanos + "}";
}
------------------------
Find a silently evolved API code:android.content.res.TypedArray.getColorStateList:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the ColorStateList for the attribute at <var>index</var>.
 * The value may be either a single solid color or a reference to
 * a color or complex {@link android.content.res.ColorStateList} description.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return ColorStateList for the attribute, or null if not defined.
 */

Body of Frist Method:
{
    final TypedValue value = mValue;
    if (getValueAt(index * AssetManager.STYLE_NUM_ENTRIES, value)) {
        return mResources.loadColorStateList(value, value.resourceId);
    }
    return null;
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    final TypedValue value = mValue;
    if (getValueAt(index * AssetManager.STYLE_NUM_ENTRIES, value)) {
        if (value.type == TypedValue.TYPE_ATTRIBUTE) {
            throw new RuntimeException("Failed to resolve attribute at index " + index);
        }
        return mResources.loadColorStateList(value, value.resourceId);
    }
    return null;
}
------------------------
Find a silently evolved API code:android.media.MediaPlayer.setAuxEffectSendLevel:COMMENT
<android.media.MediaPlayer: void setAuxEffectSendLevel(float)>
public      native      ->public      
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * Sets the send level of the player to the attached auxiliary effect
 * {@see #attachAuxEffect(int)}. The level value range is 0 to 1.0.
 * <p>By default the send level is 0, so even if an effect is attached to the player
 * this method must be called for the effect to be applied.
 * <p>Note that the passed level value is a raw scalar. UI controls should be scaled
 * logarithmically: the gain applied by audio framework ranges from -72dB to 0dB,
 * so an appropriate conversion from linear UI input x to level is:
 * x == 0 -> level = 0
 * 0 < x <= R -> level = 10^(72*(x-R)/20/R)
 * @param level send level scalar
 */

Body of Frist Method:

Body of Second Method:
{
    if (isRestricted()) {
        return;
    }
    _setAuxEffectSendLevel(level);
}
------------------------
Find a silently evolved API code:android.widget.CalendarView.setWeekSeparatorLineColor:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the color for the separator line between weeks.
 *
 * @param color The week separator color.
 *
 * @attr ref android.R.styleable#CalendarView_weekSeparatorLineColor
 */

Body of Frist Method:
{
    if (mWeekSeparatorLineColor != color) {
        mWeekSeparatorLineColor = color;
        invalidateAllWeekViews();
    }
}
Body of Second Method:
{
    mDelegate.setWeekSeparatorLineColor(color);
}
------------------------
Find a silently evolved API code:android.content.SyncInfo.writeToParcel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    parcel.writeInt(authorityId);
    account.writeToParcel(parcel, 0);
    parcel.writeString(authority);
    parcel.writeLong(startTime);
}
Body of Second Method:
{
    parcel.writeInt(authorityId);
    parcel.writeParcelable(account, flags);
    parcel.writeString(authority);
    parcel.writeLong(startTime);
}
------------------------
Find a silently evolved API code:android.view.HardwareLayer.destroy:COMMENT
<android.view.HardwareLayer: void destroy()>
default     abstract    ->public      hidden      
Method Modifier: public      default     abstract    hidden      
Method Modifier: No          Yes         Yes         No          
Method Updated:  Yes         No          No          Yes         
Comment:/**
 * Destroys resources without waiting for a GC.
 */

Body of Frist Method:

Body of Second Method:
{
    if (!isValid()) {
        // Already destroyed
        return;
    }
    mRenderer.onLayerDestroyed(this);
    mRenderer = null;
    mFinalizer.release();
    mFinalizer = null;
}
------------------------
Find a silently evolved API code:android.app.SharedPreferencesImpl.EditorImpl.commitToMemory:COMMENT
Method Modifier: private     
Comment:// Returns true if any changes were made

Body of Frist Method:
{
    MemoryCommitResult mcr = new MemoryCommitResult();
    synchronized (SharedPreferencesImpl.this) {
        // writing to disk.
        if (mDiskWritesInFlight > 0) {
            // We can't modify our mMap as a currently
            // in-flight write owns it.  Clone it before
            // modifying it.
            // noinspection unchecked
            mMap = new HashMap<String, Object>(mMap);
        }
        mcr.mapToWriteToDisk = mMap;
        mDiskWritesInFlight++;
        boolean hasListeners = mListeners.size() > 0;
        if (hasListeners) {
            mcr.keysModified = new ArrayList<String>();
            mcr.listeners = new HashSet<OnSharedPreferenceChangeListener>(mListeners.keySet());
        }
        synchronized (this) {
            if (mClear) {
                if (!mMap.isEmpty()) {
                    mcr.changesMade = true;
                    mMap.clear();
                }
                mClear = false;
            }
            for (Map.Entry<String, Object> e : mModified.entrySet()) {
                String k = e.getKey();
                Object v = e.getValue();
                if (v == this) {
                    // magic value for a removal mutation
                    if (!mMap.containsKey(k)) {
                        continue;
                    }
                    mMap.remove(k);
                } else {
                    boolean isSame = false;
                    if (mMap.containsKey(k)) {
                        Object existingValue = mMap.get(k);
                        if (existingValue != null && existingValue.equals(v)) {
                            continue;
                        }
                    }
                    mMap.put(k, v);
                }
                mcr.changesMade = true;
                if (hasListeners) {
                    mcr.keysModified.add(k);
                }
            }
            mModified.clear();
        }
    }
    return mcr;
}
Body of Second Method:
{
    MemoryCommitResult mcr = new MemoryCommitResult();
    synchronized (SharedPreferencesImpl.this) {
        // writing to disk.
        if (mDiskWritesInFlight > 0) {
            // We can't modify our mMap as a currently
            // in-flight write owns it.  Clone it before
            // modifying it.
            // noinspection unchecked
            mMap = new HashMap<String, Object>(mMap);
        }
        mcr.mapToWriteToDisk = mMap;
        mDiskWritesInFlight++;
        boolean hasListeners = mListeners.size() > 0;
        if (hasListeners) {
            mcr.keysModified = new ArrayList<String>();
            mcr.listeners = new HashSet<OnSharedPreferenceChangeListener>(mListeners.keySet());
        }
        synchronized (this) {
            if (mClear) {
                if (!mMap.isEmpty()) {
                    mcr.changesMade = true;
                    mMap.clear();
                }
                mClear = false;
            }
            for (Map.Entry<String, Object> e : mModified.entrySet()) {
                String k = e.getKey();
                Object v = e.getValue();
                // equivalent to calling remove on that key.
                if (v == this || v == null) {
                    if (!mMap.containsKey(k)) {
                        continue;
                    }
                    mMap.remove(k);
                } else {
                    if (mMap.containsKey(k)) {
                        Object existingValue = mMap.get(k);
                        if (existingValue != null && existingValue.equals(v)) {
                            continue;
                        }
                    }
                    mMap.put(k, v);
                }
                mcr.changesMade = true;
                if (hasListeners) {
                    mcr.keysModified.add(k);
                }
            }
            mModified.clear();
        }
    }
    return mcr;
}
------------------------
Find a silently evolved API code:android.widget.ShareActionProvider.onCreateActionView:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    // Create the view and set its data model.
    ActivityChooserModel dataModel = ActivityChooserModel.get(mContext, mShareHistoryFileName);
    ActivityChooserView activityChooserView = new ActivityChooserView(mContext);
    activityChooserView.setActivityChooserModel(dataModel);
    // Lookup and set the expand action icon.
    TypedValue outTypedValue = new TypedValue();
    mContext.getTheme().resolveAttribute(R.attr.actionModeShareDrawable, outTypedValue, true);
    Drawable drawable = mContext.getResources().getDrawable(outTypedValue.resourceId);
    activityChooserView.setExpandActivityOverflowButtonDrawable(drawable);
    activityChooserView.setProvider(this);
    // Set content description.
    activityChooserView.setDefaultActionButtonContentDescription(R.string.shareactionprovider_share_with_application);
    activityChooserView.setExpandActivityOverflowButtonContentDescription(R.string.shareactionprovider_share_with);
    return activityChooserView;
}
Body of Second Method:
{
    // Create the view and set its data model.
    ActivityChooserView activityChooserView = new ActivityChooserView(mContext);
    if (!activityChooserView.isInEditMode()) {
        ActivityChooserModel dataModel = ActivityChooserModel.get(mContext, mShareHistoryFileName);
        activityChooserView.setActivityChooserModel(dataModel);
    }
    // Lookup and set the expand action icon.
    TypedValue outTypedValue = new TypedValue();
    mContext.getTheme().resolveAttribute(R.attr.actionModeShareDrawable, outTypedValue, true);
    Drawable drawable = mContext.getDrawable(outTypedValue.resourceId);
    activityChooserView.setExpandActivityOverflowButtonDrawable(drawable);
    activityChooserView.setProvider(this);
    // Set content description.
    activityChooserView.setDefaultActionButtonContentDescription(R.string.shareactionprovider_share_with_application);
    activityChooserView.setExpandActivityOverflowButtonContentDescription(R.string.shareactionprovider_share_with);
    return activityChooserView;
}
------------------------
Find a silently evolved API code:android.net.Proxy.setHttpProxySystemProperty:COMMENT
Method Modifier: public      static      final       hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (exclList != null)
        exclList = exclList.replace(",", "|");
    if (false)
        Log.d(TAG, "setHttpProxySystemProperty :" + host + ":" + port + " - " + exclList);
    if (host != null) {
        System.setProperty("http.proxyHost", host);
        System.setProperty("https.proxyHost", host);
    } else {
        System.clearProperty("http.proxyHost");
        System.clearProperty("https.proxyHost");
    }
    if (port != null) {
        System.setProperty("http.proxyPort", port);
        System.setProperty("https.proxyPort", port);
    } else {
        System.clearProperty("http.proxyPort");
        System.clearProperty("https.proxyPort");
    }
    if (exclList != null) {
        System.setProperty("http.nonProxyHosts", exclList);
        System.setProperty("https.nonProxyHosts", exclList);
    } else {
        System.clearProperty("http.nonProxyHosts");
        System.clearProperty("https.nonProxyHosts");
    }
    if (!TextUtils.isEmpty(pacFileUrl)) {
        ProxySelector.setDefault(new PacProxySelector());
    } else {
        ProxySelector.setDefault(sDefaultProxySelector);
    }
}
Body of Second Method:
{
    if (exclList != null)
        exclList = exclList.replace(",", "|");
    if (false)
        Log.d(TAG, "setHttpProxySystemProperty :" + host + ":" + port + " - " + exclList);
    if (host != null) {
        System.setProperty("http.proxyHost", host);
        System.setProperty("https.proxyHost", host);
    } else {
        System.clearProperty("http.proxyHost");
        System.clearProperty("https.proxyHost");
    }
    if (port != null) {
        System.setProperty("http.proxyPort", port);
        System.setProperty("https.proxyPort", port);
    } else {
        System.clearProperty("http.proxyPort");
        System.clearProperty("https.proxyPort");
    }
    if (exclList != null) {
        System.setProperty("http.nonProxyHosts", exclList);
        System.setProperty("https.nonProxyHosts", exclList);
    } else {
        System.clearProperty("http.nonProxyHosts");
        System.clearProperty("https.nonProxyHosts");
    }
    if (!Uri.EMPTY.equals(pacFileUrl)) {
        ProxySelector.setDefault(new PacProxySelector());
    } else {
        ProxySelector.setDefault(sDefaultProxySelector);
    }
}
------------------------
Find a silently evolved API code:android.util.EventLog.Event.getTag:COMMENT
Method Modifier: public      
Comment:/**
 * @return the type tag code of the entry
 */

Body of Frist Method:
{
    return mBuffer.getInt(TAG_OFFSET);
}
Body of Second Method:
{
    int offset = mBuffer.getShort(HEADER_SIZE_OFFSET);
    if (offset == 0) {
        offset = V1_PAYLOAD_START;
    }
    return mBuffer.getInt(offset);
}
------------------------
Find a silently evolved API code:android.animation.ValueAnimator.delayedAnimationFrame:COMMENT
Method Modifier: private     
Comment:/**
 * Internal function called to process an animation frame on an animation that is currently
 * sleeping through its <code>startDelay</code> phase. The return value indicates whether it
 * should be woken up and put on the active animations queue.
 *
 * @param currentTime The current animation time, used to calculate whether the animation
 * has exceeded its <code>startDelay</code> and should be started.
 * @return True if the animation's <code>startDelay</code> has been exceeded and the animation
 * should be added to the set of active animations.
 */

Body of Frist Method:
{
    if (!mStartedDelay) {
        mStartedDelay = true;
        mDelayStartTime = currentTime;
    } else {
        if (mPaused) {
            if (mPauseTime < 0) {
                mPauseTime = currentTime;
            }
            return false;
        } else if (mResumed) {
            mResumed = false;
            if (mPauseTime > 0) {
                // Offset by the duration that the animation was paused
                mDelayStartTime += (currentTime - mPauseTime);
            }
        }
        long deltaTime = currentTime - mDelayStartTime;
        if (deltaTime > mStartDelay) {
            // startDelay ended - start the anim and record the
            // mStartTime appropriately
            mStartTime = currentTime - (deltaTime - mStartDelay);
            mPlayingState = RUNNING;
            return true;
        }
    }
    return false;
}
Body of Second Method:
{
    if (!mStartedDelay) {
        mStartedDelay = true;
        mDelayStartTime = currentTime;
    }
    if (mPaused) {
        if (mPauseTime < 0) {
            mPauseTime = currentTime;
        }
        return false;
    } else if (mResumed) {
        mResumed = false;
        if (mPauseTime > 0) {
            // Offset by the duration that the animation was paused
            mDelayStartTime += (currentTime - mPauseTime);
        }
    }
    long deltaTime = currentTime - mDelayStartTime;
    if (deltaTime > mStartDelay) {
        // startDelay ended - start the anim and record the
        // mStartTime appropriately
        mStartTime = currentTime - (deltaTime - mStartDelay);
        mPlayingState = RUNNING;
        return true;
    }
    return false;
}
------------------------
Find a silently evolved API code:android.animation.PropertyValuesHolder.setupEndValue:COMMENT
Method Modifier: default     
Comment:/**
 * This function is called by ObjectAnimator when setting the end values for an animation.
 * The end values are set according to the current values in the target object. The
 * property whose value is extracted is whatever is specified by the propertyName of this
 * PropertyValuesHolder object.
 *
 * @param target The object which holds the start values that should be set.
 */

Body of Frist Method:
{
    setupValue(target, mKeyframeSet.mKeyframes.get(mKeyframeSet.mKeyframes.size() - 1));
}
Body of Second Method:
{
    ArrayList<Keyframe> keyframes = mKeyframes.getKeyframes();
    if (!keyframes.isEmpty()) {
        setupValue(target, keyframes.get(keyframes.size() - 1));
    }
}
------------------------
Find a silently evolved API code:android.app.ActivityThread.handleCreateBackupAgent:COMMENT
Method Modifier: private     hidden      
Comment:// Instantiate a BackupAgent and tell it that it's alive

Body of Frist Method:
{
    if (DEBUG_BACKUP)
        Slog.v(TAG, "handleCreateBackupAgent: " + data);
    // Sanity check the requested target package's uid against ours
    try {
        PackageInfo requestedPackage = getPackageManager().getPackageInfo(data.appInfo.packageName, 0, UserHandle.myUserId());
        if (requestedPackage.applicationInfo.uid != Process.myUid()) {
            Slog.w(TAG, "Asked to instantiate non-matching package " + data.appInfo.packageName);
            return;
        }
    } catch (RemoteException e) {
        Slog.e(TAG, "Can't reach package manager", e);
        return;
    }
    // no longer idle; we have backup work to do
    unscheduleGcIdler();
    // instantiate the BackupAgent class named in the manifest
    LoadedApk packageInfo = getPackageInfoNoCheck(data.appInfo, data.compatInfo);
    String packageName = packageInfo.mPackageName;
    if (packageName == null) {
        Slog.d(TAG, "Asked to create backup agent for nonexistent package");
        return;
    }
    if (mBackupAgents.get(packageName) != null) {
        Slog.d(TAG, "BackupAgent " + "  for " + packageName + " already exists");
        return;
    }
    BackupAgent agent = null;
    String classname = data.appInfo.backupAgentName;
    // full backup operation but no app-supplied agent?  use the default implementation
    if (classname == null && (data.backupMode == IApplicationThread.BACKUP_MODE_FULL || data.backupMode == IApplicationThread.BACKUP_MODE_RESTORE_FULL)) {
        classname = "android.app.backup.FullBackupAgent";
    }
    try {
        IBinder binder = null;
        try {
            if (DEBUG_BACKUP)
                Slog.v(TAG, "Initializing agent class " + classname);
            java.lang.ClassLoader cl = packageInfo.getClassLoader();
            agent = (BackupAgent) cl.loadClass(classname).newInstance();
            // set up the agent's context
            ContextImpl context = new ContextImpl();
            context.init(packageInfo, null, this);
            context.setOuterContext(agent);
            agent.attach(context);
            agent.onCreate();
            binder = agent.onBind();
            mBackupAgents.put(packageName, agent);
        } catch (Exception e) {
            // If this is during restore, fail silently; otherwise go
            // ahead and let the user see the crash.
            Slog.e(TAG, "Agent threw during creation: " + e);
            if (data.backupMode != IApplicationThread.BACKUP_MODE_RESTORE && data.backupMode != IApplicationThread.BACKUP_MODE_RESTORE_FULL) {
                throw e;
            }
        // falling through with 'binder' still null
        }
        // tell the OS that we're live now
        try {
            ActivityManagerNative.getDefault().backupAgentCreated(packageName, binder);
        } catch (RemoteException e) {
        // nothing to do.
        }
    } catch (Exception e) {
        throw new RuntimeException("Unable to create BackupAgent " + classname + ": " + e.toString(), e);
    }
}
Body of Second Method:
{
    if (DEBUG_BACKUP)
        Slog.v(TAG, "handleCreateBackupAgent: " + data);
    // Sanity check the requested target package's uid against ours
    try {
        PackageInfo requestedPackage = getPackageManager().getPackageInfo(data.appInfo.packageName, 0, UserHandle.myUserId());
        if (requestedPackage.applicationInfo.uid != Process.myUid()) {
            Slog.w(TAG, "Asked to instantiate non-matching package " + data.appInfo.packageName);
            return;
        }
    } catch (RemoteException e) {
        Slog.e(TAG, "Can't reach package manager", e);
        return;
    }
    // no longer idle; we have backup work to do
    unscheduleGcIdler();
    // instantiate the BackupAgent class named in the manifest
    LoadedApk packageInfo = getPackageInfoNoCheck(data.appInfo, data.compatInfo);
    String packageName = packageInfo.mPackageName;
    if (packageName == null) {
        Slog.d(TAG, "Asked to create backup agent for nonexistent package");
        return;
    }
    String classname = data.appInfo.backupAgentName;
    // full backup operation but no app-supplied agent?  use the default implementation
    if (classname == null && (data.backupMode == IApplicationThread.BACKUP_MODE_FULL || data.backupMode == IApplicationThread.BACKUP_MODE_RESTORE_FULL)) {
        classname = "android.app.backup.FullBackupAgent";
    }
    try {
        IBinder binder = null;
        BackupAgent agent = mBackupAgents.get(packageName);
        if (agent != null) {
            // reusing the existing instance
            if (DEBUG_BACKUP) {
                Slog.v(TAG, "Reusing existing agent instance");
            }
            binder = agent.onBind();
        } else {
            try {
                if (DEBUG_BACKUP)
                    Slog.v(TAG, "Initializing agent class " + classname);
                java.lang.ClassLoader cl = packageInfo.getClassLoader();
                agent = (BackupAgent) cl.loadClass(classname).newInstance();
                // set up the agent's context
                ContextImpl context = ContextImpl.createAppContext(this, packageInfo);
                context.setOuterContext(agent);
                agent.attach(context);
                agent.onCreate();
                binder = agent.onBind();
                mBackupAgents.put(packageName, agent);
            } catch (Exception e) {
                // If this is during restore, fail silently; otherwise go
                // ahead and let the user see the crash.
                Slog.e(TAG, "Agent threw during creation: " + e);
                if (data.backupMode != IApplicationThread.BACKUP_MODE_RESTORE && data.backupMode != IApplicationThread.BACKUP_MODE_RESTORE_FULL) {
                    throw e;
                }
            // falling through with 'binder' still null
            }
        }
        // tell the OS that we're live now
        try {
            ActivityManagerNative.getDefault().backupAgentCreated(packageName, binder);
        } catch (RemoteException e) {
        // nothing to do.
        }
    } catch (Exception e) {
        throw new RuntimeException("Unable to create BackupAgent " + classname + ": " + e.toString(), e);
    }
}
------------------------
Find a silently evolved API code:android.net.LocalSocketImpl.create:COMMENT
Method Modifier: public      
Comment:/**
 * Creates a socket in the underlying OS.
 *
 * @param sockType either {@link LocalSocket#SOCKET_DGRAM}, {@link LocalSocket#SOCKET_STREAM}
 * or {@link LocalSocket#SOCKET_SEQPACKET}
 * @throws IOException
 */

Body of Frist Method:
{
    // need this for LocalServerSocket.accept()
    if (fd == null) {
        int osType;
        switch(sockType) {
            case LocalSocket.SOCKET_DGRAM:
                osType = OsConstants.SOCK_DGRAM;
                break;
            case LocalSocket.SOCKET_STREAM:
                osType = OsConstants.SOCK_STREAM;
                break;
            case LocalSocket.SOCKET_SEQPACKET:
                osType = OsConstants.SOCK_SEQPACKET;
                break;
            default:
                throw new IllegalStateException("unknown sockType");
        }
        try {
            fd = Libcore.os.socket(OsConstants.AF_UNIX, osType, 0);
            mFdCreatedInternally = true;
        } catch (ErrnoException e) {
            e.rethrowAsIOException();
        }
    }
}
Body of Second Method:
{
    // need this for LocalServerSocket.accept()
    if (fd == null) {
        int osType;
        switch(sockType) {
            case LocalSocket.SOCKET_DGRAM:
                osType = OsConstants.SOCK_DGRAM;
                break;
            case LocalSocket.SOCKET_STREAM:
                osType = OsConstants.SOCK_STREAM;
                break;
            case LocalSocket.SOCKET_SEQPACKET:
                osType = OsConstants.SOCK_SEQPACKET;
                break;
            default:
                throw new IllegalStateException("unknown sockType");
        }
        try {
            fd = Os.socket(OsConstants.AF_UNIX, osType, 0);
            mFdCreatedInternally = true;
        } catch (ErrnoException e) {
            e.rethrowAsIOException();
        }
    }
}
------------------------
Find a silently evolved API code:android.os.ParcelFileDescriptor.fromFd:COMMENT
Method Modifier: public      static      
Comment:/**
 * Create a new ParcelFileDescriptor from a raw native fd.  The new
 * ParcelFileDescriptor holds a dup of the original fd passed in here,
 * so you must still close that fd as well as the new ParcelFileDescriptor.
 *
 * @param fd The native fd that the ParcelFileDescriptor should dup.
 *
 * @return Returns a new ParcelFileDescriptor holding a FileDescriptor
 * for a dup of the given fd.
 */

Body of Frist Method:
{
    final FileDescriptor original = new FileDescriptor();
    original.setInt$(fd);
    try {
        final FileDescriptor dup = Libcore.os.dup(original);
        return new ParcelFileDescriptor(dup);
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
}
Body of Second Method:
{
    final FileDescriptor original = new FileDescriptor();
    original.setInt$(fd);
    try {
        final FileDescriptor dup = Os.dup(original);
        return new ParcelFileDescriptor(dup);
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
}
------------------------
Find a silently evolved API code:android.animation.ObjectAnimator.setTarget:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the target object whose property will be animated by this animation
 *
 * @param target The object being animated
 */

Body of Frist Method:
{
    if (mTarget != target) {
        final Object oldTarget = mTarget;
        mTarget = target;
        if (oldTarget != null && target != null && oldTarget.getClass() == target.getClass()) {
            return;
        }
        // New target type should cause re-initialization prior to starting
        mInitialized = false;
    }
}
Body of Second Method:
{
    final Object oldTarget = getTarget();
    if (oldTarget != target) {
        mTarget = target == null ? null : new WeakReference<Object>(target);
        // New target should cause re-initialization prior to starting
        mInitialized = false;
    }
}
------------------------
Find a silently evolved API code:android.graphics.drawable.NinePatchDrawable.getOpticalInsets:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (needsMirroring()) {
        return Insets.of(mOpticalInsets.right, mOpticalInsets.top, mOpticalInsets.right, mOpticalInsets.bottom);
    } else {
        return mOpticalInsets;
    }
}
Body of Second Method:
{
    if (needsMirroring()) {
        return Insets.of(mOpticalInsets.right, mOpticalInsets.top, mOpticalInsets.left, mOpticalInsets.bottom);
    } else {
        return mOpticalInsets;
    }
}
------------------------
Find a silently evolved API code:android.graphics.drawable.GradientDrawable.setOrientation:COMMENT
Method Modifier: public      
Comment:/**
 * <p>Changes the orientation of the gradient defined in this drawable.</p>
 * <p><strong>Note</strong>: changing orientation will affect all instances
 * of a drawable loaded from a resource. It is recommended to invoke
 * {@link #mutate()} before changing the orientation.</p>
 *
 * @param orientation The desired orientation (angle) of the gradient
 *
 * @see #mutate()
 */

Body of Frist Method:
{
    mGradientState.mOrientation = orientation;
    mRectIsDirty = true;
    invalidateSelf();
}
Body of Second Method:
{
    mGradientState.mOrientation = orientation;
    mGradientIsDirty = true;
    invalidateSelf();
}
------------------------
Find a silently evolved API code:android.preference.Preference.compareTo:COMMENT
Method Modifier: public      
Comment:/**
 * Compares Preference objects based on order (if set), otherwise alphabetically on the titles.
 *
 * @param another The Preference to compare to this one.
 * @return 0 if the same; less than 0 if this Preference sorts ahead of <var>another</var>;
 * greater than 0 if this Preference sorts after <var>another</var>.
 */

Body of Frist Method:
{
    if (mOrder != DEFAULT_ORDER || (mOrder == DEFAULT_ORDER && another.mOrder != DEFAULT_ORDER)) {
        // Do order comparison
        return mOrder - another.mOrder;
    } else if (mTitle == another.mTitle) {
        // If titles are null or share same object comparison
        return 0;
    } else if (mTitle == null) {
        return 1;
    } else if (another.mTitle == null) {
        return -1;
    } else {
        // Do name comparison
        return CharSequences.compareToIgnoreCase(mTitle, another.mTitle);
    }
}
Body of Second Method:
{
    if (mOrder != another.mOrder) {
        // Do order comparison
        return mOrder - another.mOrder;
    } else if (mTitle == another.mTitle) {
        // If titles are null or share same object comparison
        return 0;
    } else if (mTitle == null) {
        return 1;
    } else if (another.mTitle == null) {
        return -1;
    } else {
        // Do name comparison
        return CharSequences.compareToIgnoreCase(mTitle, another.mTitle);
    }
}
------------------------
Find a silently evolved API code:android.animation.PropertyValuesHolder.setIntValues:COMMENT
Method Modifier: public      
Comment:/**
 * Set the animated values for this object to this set of ints.
 * If there is only one value, it is assumed to be the end value of an animation,
 * and an initial value will be derived, if possible, by calling a getter function
 * on the object. Also, if any value is null, the value will be filled in when the animation
 * starts in the same way. This mechanism of automatically getting null values only works
 * if the PropertyValuesHolder object is used in conjunction
 * {@link ObjectAnimator}, and with a getter function
 * derived automatically from <code>propertyName</code>, since otherwise PropertyValuesHolder has
 * no way of determining what the value should be.
 *
 * @param values One or more values that the animation will animate between.
 */

Body of Frist Method:
{
    mValueType = int.class;
    mKeyframeSet = KeyframeSet.ofInt(values);
}
Body of Second Method:
{
    mValueType = int.class;
    mKeyframes = KeyframeSet.ofInt(values);
}
------------------------
Find a silently evolved API code:android.content.ContentResolver.releasePersistableUriPermission:COMMENT
Method Modifier: public      
Comment:/**
 * Relinquish a persisted URI permission grant. The URI must have been
 * previously made persistent with
 * {@link #takePersistableUriPermission(Uri, int)}. Any non-persistent
 * grants to the calling package will remain intact.
 *
 * @see #getPersistedUriPermissions()
 */

Body of Frist Method:
{
    try {
        ActivityManagerNative.getDefault().releasePersistableUriPermission(uri, modeFlags);
    } catch (RemoteException e) {
    }
}
Body of Second Method:
{
    try {
        ActivityManagerNative.getDefault().releasePersistableUriPermission(ContentProvider.getUriWithoutUserId(uri), modeFlags, resolveUserId(uri));
    } catch (RemoteException e) {
    }
}
------------------------
Find a silently evolved API code:android.widget.AbsListView.isFastScrollAlwaysVisible:COMMENT
Method Modifier: public      
Comment:/**
 * Returns true if the fast scroller is set to always show on this view.
 *
 * @return true if the fast scroller will always show
 * @see #setFastScrollAlwaysVisible(boolean)
 */

Body of Frist Method:
{
    if (mFastScroller == null) {
        return mFastScrollEnabled && mFastScrollAlwaysVisible;
    } else {
        return mFastScroller.isEnabled() && mFastScroller.isAlwaysShowEnabled();
    }
}
Body of Second Method:
{
    if (mFastScroll == null) {
        return mFastScrollEnabled && mFastScrollAlwaysVisible;
    } else {
        return mFastScroll.isEnabled() && mFastScroll.isAlwaysShowEnabled();
    }
}
------------------------
Find a silently evolved API code:android.content.res.BridgeTypedArray.getText:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the styled string value for the attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return CharSequence holding string data.  May be styled.  Returns
 * null if the attribute is not defined.
 */

Body of Frist Method:
{
    if (index < 0 || index >= mResourceData.length) {
        return null;
    }
    if (mResourceData[index] != null) {
        // FIXME: handle styled strings!
        return mResourceData[index].getValue();
    }
    return null;
}
Body of Second Method:
{
    // FIXME: handle styled strings!
    return getString(index);
}
------------------------
Find a silently evolved API code:android.graphics.Canvas.concat:COMMENT
Method Modifier: public      
Comment:/**
 * Preconcat the current matrix with the specified matrix. If the specified
 * matrix is null, this method does nothing.
 *
 * @param matrix The matrix to preconcatenate with the current matrix
 */

Body of Frist Method:
{
    if (matrix != null)
        native_concat(mNativeCanvas, matrix.native_instance);
}
Body of Second Method:
{
    if (matrix != null)
        native_concat(mNativeCanvasWrapper, matrix.native_instance);
}
------------------------
Find a silently evolved API code:android.os.Process.myPid:COMMENT
Method Modifier: public      static      final       
Comment:/**
 * Returns the identifier of this process, which can be used with
 * {@link #killProcess} and {@link #sendSignal}.
 */

Body of Frist Method:
{
    return Libcore.os.getpid();
}
Body of Second Method:
{
    return Os.getpid();
}
------------------------
Find a silently evolved API code:android.os.Bundle.putStringArrayList:COMMENT
Method Modifier: public      
Comment:/**
 * Inserts an ArrayList<String> value into the mapping of this Bundle, replacing
 * any existing value for the given key.  Either key or value may be null.
 *
 * @param key a String, or null
 * @param value an ArrayList<String> object, or null
 */

Body of Frist Method:
{
    unparcel();
    mMap.put(key, value);
}
Body of Second Method:
{
    super.putStringArrayList(key, value);
}
------------------------
Find a silently evolved API code:android.webkit.WebSyncManager.stopSync:COMMENT
<android.webkit.WebSyncManager: void stopSync()>
public      ->public      deprecated  
Method Modifier: public      deprecated  
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * stopSync() requests sync manager to stop sync. remove any SYNC_MESSAGE in
 * the queue to break the sync loop
 */

Body of Frist Method:
{
    if (DebugFlags.WEB_SYNC_MANAGER) {
        Log.v(LOGTAG, "*** WebSyncManager stopSync ***, Ref count:" + mStartSyncRefCount);
    }
    if (mHandler == null) {
        return;
    }
    if (--mStartSyncRefCount == 0) {
        mHandler.removeMessages(SYNC_MESSAGE);
    }
}
Body of Second Method:
{
}
------------------------
Find a silently evolved API code:android.app.Activity.onCreateView:COMMENT
Method Modifier: public      
Comment:/**
 * Standard implementation of
 * {@link android.view.LayoutInflater.Factory2#onCreateView(View, String, Context, AttributeSet)}
 * used when inflating with the LayoutInflater returned by {@link #getSystemService}.
 * This implementation handles <fragment> tags to embed fragments inside
 * of the activity.
 *
 * @see android.view.LayoutInflater#createView
 * @see android.view.Window#getLayoutInflater
 */

Body of Frist Method:
{
    if (!"fragment".equals(name)) {
        return onCreateView(name, context, attrs);
    }
    String fname = attrs.getAttributeValue(null, "class");
    TypedArray a = context.obtainStyledAttributes(attrs, com.android.internal.R.styleable.Fragment);
    if (fname == null) {
        fname = a.getString(com.android.internal.R.styleable.Fragment_name);
    }
    int id = a.getResourceId(com.android.internal.R.styleable.Fragment_id, View.NO_ID);
    String tag = a.getString(com.android.internal.R.styleable.Fragment_tag);
    a.recycle();
    int containerId = parent != null ? parent.getId() : 0;
    if (containerId == View.NO_ID && id == View.NO_ID && tag == null) {
        throw new IllegalArgumentException(attrs.getPositionDescription() + ": Must specify unique android:id, android:tag, or have a parent with an id for " + fname);
    }
    // If we restored from a previous state, we may already have
    // instantiated this fragment from the state and should use
    // that instance instead of making a new one.
    Fragment fragment = id != View.NO_ID ? mFragments.findFragmentById(id) : null;
    if (fragment == null && tag != null) {
        fragment = mFragments.findFragmentByTag(tag);
    }
    if (fragment == null && containerId != View.NO_ID) {
        fragment = mFragments.findFragmentById(containerId);
    }
    if (FragmentManagerImpl.DEBUG)
        Log.v(TAG, "onCreateView: id=0x" + Integer.toHexString(id) + " fname=" + fname + " existing=" + fragment);
    if (fragment == null) {
        fragment = Fragment.instantiate(this, fname);
        fragment.mFromLayout = true;
        fragment.mFragmentId = id != 0 ? id : containerId;
        fragment.mContainerId = containerId;
        fragment.mTag = tag;
        fragment.mInLayout = true;
        fragment.mFragmentManager = mFragments;
        fragment.onInflate(this, attrs, fragment.mSavedFragmentState);
        mFragments.addFragment(fragment, true);
    } else if (fragment.mInLayout) {
        // previous state.
        throw new IllegalArgumentException(attrs.getPositionDescription() + ": Duplicate id 0x" + Integer.toHexString(id) + ", tag " + tag + ", or parent id 0x" + Integer.toHexString(containerId) + " with another fragment for " + fname);
    } else {
        // This fragment was retained from a previous instance; get it
        // going now.
        fragment.mInLayout = true;
        // initialize itself.
        if (!fragment.mRetaining) {
            fragment.onInflate(this, attrs, fragment.mSavedFragmentState);
        }
        mFragments.moveToState(fragment);
    }
    if (fragment.mView == null) {
        throw new IllegalStateException("Fragment " + fname + " did not create a view.");
    }
    if (id != 0) {
        fragment.mView.setId(id);
    }
    if (fragment.mView.getTag() == null) {
        fragment.mView.setTag(tag);
    }
    return fragment.mView;
}
Body of Second Method:
{
    if (!"fragment".equals(name)) {
        return onCreateView(name, context, attrs);
    }
    return mFragments.onCreateView(parent, name, context, attrs);
}
------------------------
Find a silently evolved API code:android.appwidget.AppWidgetHost.stopListening:COMMENT
Method Modifier: public      
Comment:/**
 * Stop receiving onAppWidgetChanged calls for your AppWidgets.  Call this when your activity is
 * no longer visible, i.e. from onStop() in your Activity.
 */

Body of Frist Method:
{
    try {
        sService.stopListening(mHostId, mContext.getUserId());
    } catch (RemoteException e) {
        throw new RuntimeException("system server dead?", e);
    }
    // This is here because keyguard needs it since it'll be switching users after this call.
    // If it turns out other apps need to call this often, we should re-think how this works.
    clearViews();
}
Body of Second Method:
{
    try {
        sService.stopListening(mContext.getOpPackageName(), mHostId);
    } catch (RemoteException e) {
        throw new RuntimeException("system server dead?", e);
    }
    // This is here because keyguard needs it since it'll be switching users after this call.
    // If it turns out other apps need to call this often, we should re-think how this works.
    clearViews();
}
------------------------
Find a silently evolved API code:android.os.RecoverySystem.getTrustedCerts:COMMENT
Method Modifier: private     static      
Comment:/**
 * @return the set of certs that can be used to sign an OTA package.
 */

Body of Frist Method:
{
    HashSet<Certificate> trusted = new HashSet<Certificate>();
    if (keystore == null) {
        keystore = DEFAULT_KEYSTORE;
    }
    ZipFile zip = new ZipFile(keystore);
    try {
        CertificateFactory cf = CertificateFactory.getInstance("X.509");
        Enumeration<? extends ZipEntry> entries = zip.entries();
        while (entries.hasMoreElements()) {
            ZipEntry entry = entries.nextElement();
            InputStream is = zip.getInputStream(entry);
            try {
                trusted.add(cf.generateCertificate(is));
            } finally {
                is.close();
            }
        }
    } finally {
        zip.close();
    }
    return trusted;
}
Body of Second Method:
{
    HashSet<X509Certificate> trusted = new HashSet<X509Certificate>();
    if (keystore == null) {
        keystore = DEFAULT_KEYSTORE;
    }
    ZipFile zip = new ZipFile(keystore);
    try {
        CertificateFactory cf = CertificateFactory.getInstance("X.509");
        Enumeration<? extends ZipEntry> entries = zip.entries();
        while (entries.hasMoreElements()) {
            ZipEntry entry = entries.nextElement();
            InputStream is = zip.getInputStream(entry);
            try {
                trusted.add((X509Certificate) cf.generateCertificate(is));
            } finally {
                is.close();
            }
        }
    } finally {
        zip.close();
    }
    return trusted;
}
------------------------
Find a silently evolved API code:android.accounts.AccountManager.getAuthenticatorTypes:COMMENT
Method Modifier: public      
Comment:/**
 * Lists the currently registered authenticators.
 *
 * <p>It is safe to call this method from the main thread.
 *
 * <p>No permission is required to call this method.
 *
 * @return An array of {@link AuthenticatorDescription} for every
 * authenticator known to the AccountManager service.  Empty (never
 * null) if no authenticators are known.
 */

Body of Frist Method:
{
    try {
        return mService.getAuthenticatorTypes();
    } catch (RemoteException e) {
        // will never happen
        throw new RuntimeException(e);
    }
}
Body of Second Method:
{
    try {
        return mService.getAuthenticatorTypes(UserHandle.getCallingUserId());
    } catch (RemoteException e) {
        // will never happen
        throw new RuntimeException(e);
    }
}
------------------------
Find a silently evolved API code:android.view.HardwareLayer.setLayerPaint:COMMENT
<android.view.HardwareLayer: void setLayerPaint(Paint)>
default     ->public      hidden      
Method Modifier: public      default     hidden      
Method Modifier: No          Yes         No          
Method Updated:  Yes         No          Yes         
Comment:/**
 * Update the paint used when drawing this layer.
 *
 * @param paint The paint used when the layer is drawn into the destination canvas.
 * @see View#setLayerPaint(android.graphics.Paint)
 */

Body of Frist Method:
{
}
Body of Second Method:
{
    nSetLayerPaint(mFinalizer.get(), paint.mNativePaint);
    mRenderer.pushLayerUpdate(this);
}
------------------------
Find a silently evolved API code:android.os.SystemVibrator.vibrate:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (mService == null) {
        Log.w(TAG, "Failed to vibrate; no vibrator service.");
        return;
    }
    // anyway
    if (repeat < pattern.length) {
        try {
            mService.vibratePattern(owningUid, owningPackage, pattern, repeat, mToken);
        } catch (RemoteException e) {
            Log.w(TAG, "Failed to vibrate.", e);
        }
    } else {
        throw new ArrayIndexOutOfBoundsException();
    }
}
Body of Second Method:
{
    if (mService == null) {
        Log.w(TAG, "Failed to vibrate; no vibrator service.");
        return;
    }
    try {
        mService.vibrate(uid, opPkg, milliseconds, usageForAttributes(attributes), mToken);
    } catch (RemoteException e) {
        Log.w(TAG, "Failed to vibrate.", e);
    }
}
------------------------
Find a silently evolved API code:android.widget.TimePicker.getCurrentHour:COMMENT
Method Modifier: public      
Comment:/**
 * @return The current hour in the range (0-23).
 */

Body of Frist Method:
{
    int currentHour = mHourSpinner.getValue();
    if (is24HourView()) {
        return currentHour;
    } else if (mIsAm) {
        return currentHour % HOURS_IN_HALF_DAY;
    } else {
        return (currentHour % HOURS_IN_HALF_DAY) + HOURS_IN_HALF_DAY;
    }
}
Body of Second Method:
{
    return mDelegate.getCurrentHour();
}
------------------------
Find a silently evolved API code:android.widget.AbsListView.RecycleBin.addScrapView:COMMENT
Method Modifier: default     
Comment:/**
 * Puts a view into the list of scrap views.
 * <p>
 * If the list data hasn't changed or the adapter has stable IDs, views
 * with transient state will be preserved for later retrieval.
 *
 * @param scrap The view to add
 * @param position The view's position within its parent
 */

Body of Frist Method:
{
    final AbsListView.LayoutParams lp = (AbsListView.LayoutParams) scrap.getLayoutParams();
    if (lp == null) {
        return;
    }
    lp.scrappedFromPosition = position;
    // Remove but don't scrap header or footer views, or views that
    // should otherwise not be recycled.
    final int viewType = lp.viewType;
    if (!shouldRecycleViewType(viewType)) {
        return;
    }
    scrap.dispatchStartTemporaryDetach();
    // Don't scrap views that have transient state.
    final boolean scrapHasTransientState = scrap.hasTransientState();
    if (scrapHasTransientState) {
        if (mAdapter != null && mAdapterHasStableIds) {
            // the same data.
            if (mTransientStateViewsById == null) {
                mTransientStateViewsById = new LongSparseArray<View>();
            }
            mTransientStateViewsById.put(lp.itemId, scrap);
        } else if (!mDataChanged) {
            // their old positions.
            if (mTransientStateViews == null) {
                mTransientStateViews = new SparseArray<View>();
            }
            mTransientStateViews.put(position, scrap);
        } else {
            // Otherwise, we'll have to remove the view and start over.
            if (mSkippedScrap == null) {
                mSkippedScrap = new ArrayList<View>();
            }
            mSkippedScrap.add(scrap);
        }
    } else {
        if (mViewTypeCount == 1) {
            mCurrentScrap.add(scrap);
        } else {
            mScrapViews[viewType].add(scrap);
        }
        // Clear any system-managed transient state.
        if (scrap.isAccessibilityFocused()) {
            scrap.clearAccessibilityFocus();
        }
        scrap.setAccessibilityDelegate(null);
        if (mRecyclerListener != null) {
            mRecyclerListener.onMovedToScrapHeap(scrap);
        }
    }
}
Body of Second Method:
{
    final AbsListView.LayoutParams lp = (AbsListView.LayoutParams) scrap.getLayoutParams();
    if (lp == null) {
        return;
    }
    lp.scrappedFromPosition = position;
    // Remove but don't scrap header or footer views, or views that
    // should otherwise not be recycled.
    final int viewType = lp.viewType;
    if (!shouldRecycleViewType(viewType)) {
        return;
    }
    scrap.dispatchStartTemporaryDetach();
    // The the accessibility state of the view may change while temporary
    // detached and we do not allow detached views to fire accessibility
    // events. So we are announcing that the subtree changed giving a chance
    // to clients holding on to a view in this subtree to refresh it.
    notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_SUBTREE);
    // Don't scrap views that have transient state.
    final boolean scrapHasTransientState = scrap.hasTransientState();
    if (scrapHasTransientState) {
        if (mAdapter != null && mAdapterHasStableIds) {
            // the same data.
            if (mTransientStateViewsById == null) {
                mTransientStateViewsById = new LongSparseArray<View>();
            }
            mTransientStateViewsById.put(lp.itemId, scrap);
        } else if (!mDataChanged) {
            // their old positions.
            if (mTransientStateViews == null) {
                mTransientStateViews = new SparseArray<View>();
            }
            mTransientStateViews.put(position, scrap);
        } else {
            // Otherwise, we'll have to remove the view and start over.
            if (mSkippedScrap == null) {
                mSkippedScrap = new ArrayList<View>();
            }
            mSkippedScrap.add(scrap);
        }
    } else {
        if (mViewTypeCount == 1) {
            mCurrentScrap.add(scrap);
        } else {
            mScrapViews[viewType].add(scrap);
        }
        if (mRecyclerListener != null) {
            mRecyclerListener.onMovedToScrapHeap(scrap);
        }
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothInputDevice.setReport:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Send Set_Report command to the connected HID input device.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN} permission.
 *
 * @param device Remote Bluetooth Device
 * @param reportType Report type
 * @param report Report receiving buffer size
 * @return false on immediate error,
 * true otherwise
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("setReport(" + device + "), reportType=" + reportType + " report=" + report);
    if (mService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mService.setReport(device, reportType, report);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (VDBG)
        log("setReport(" + device + "), reportType=" + reportType + " report=" + report);
    if (mService != null && isEnabled() && isValidDevice(device)) {
        try {
            return mService.setReport(device, reportType, report);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (mService == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.content.Intent.filterEquals:COMMENT
Method Modifier: public      
Comment:/**
 * Determine if two intents are the same for the purposes of intent
 * resolution (filtering). That is, if their action, data, type,
 * class, and categories are the same.  This does <em>not</em> compare
 * any extra data included in the intents.
 *
 * @param other The other Intent to compare against.
 *
 * @return Returns true if action, data, type, class, and categories
 * are the same.
 */

Body of Frist Method:
{
    if (other == null) {
        return false;
    }
    if (mAction != other.mAction) {
        if (mAction != null) {
            if (!mAction.equals(other.mAction)) {
                return false;
            }
        } else {
            if (!other.mAction.equals(mAction)) {
                return false;
            }
        }
    }
    if (mData != other.mData) {
        if (mData != null) {
            if (!mData.equals(other.mData)) {
                return false;
            }
        } else {
            if (!other.mData.equals(mData)) {
                return false;
            }
        }
    }
    if (mType != other.mType) {
        if (mType != null) {
            if (!mType.equals(other.mType)) {
                return false;
            }
        } else {
            if (!other.mType.equals(mType)) {
                return false;
            }
        }
    }
    if (mPackage != other.mPackage) {
        if (mPackage != null) {
            if (!mPackage.equals(other.mPackage)) {
                return false;
            }
        } else {
            if (!other.mPackage.equals(mPackage)) {
                return false;
            }
        }
    }
    if (mComponent != other.mComponent) {
        if (mComponent != null) {
            if (!mComponent.equals(other.mComponent)) {
                return false;
            }
        } else {
            if (!other.mComponent.equals(mComponent)) {
                return false;
            }
        }
    }
    if (mCategories != other.mCategories) {
        if (mCategories != null) {
            if (!mCategories.equals(other.mCategories)) {
                return false;
            }
        } else {
            if (!other.mCategories.equals(mCategories)) {
                return false;
            }
        }
    }
    return true;
}
Body of Second Method:
{
    if (other == null) {
        return false;
    }
    if (!Objects.equals(this.mAction, other.mAction))
        return false;
    if (!Objects.equals(this.mData, other.mData))
        return false;
    if (!Objects.equals(this.mType, other.mType))
        return false;
    if (!Objects.equals(this.mPackage, other.mPackage))
        return false;
    if (!Objects.equals(this.mComponent, other.mComponent))
        return false;
    if (!Objects.equals(this.mCategories, other.mCategories))
        return false;
    return true;
}
------------------------
Find a silently evolved API code:android.text.format.Time.toString:COMMENT
<android.text.format.Time: String toString()>
public      native      ->public      
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * Return the current time in YYYYMMDDTHHMMSS<tz> format
 */

Body of Frist Method:

Body of Second Method:
{
    // toString() uses its own TimeCalculator rather than the shared one. Otherwise crazy stuff
    // happens during debugging when the debugger calls toString().
    TimeCalculator calculator = new TimeCalculator(this.timezone);
    calculator.copyFieldsFromTime(this);
    return calculator.toStringInternal();
}
------------------------
Find a silently evolved API code:android.graphics.Path_Delegate.lineTo:COMMENT
Method Modifier: private     
Comment:/**
 * Add a line from the last point to the specified point (x,y).
 * If no moveTo() call has been made for this contour, the first point is
 * automatically set to (0,0).
 *
 * @param x The x-coordinate of the end of a line
 * @param y The y-coordinate of the end of a line
 */

Body of Frist Method:
{
    mPath.lineTo(mLastX = x, mLastY = y);
}
Body of Second Method:
{
    if (isEmpty()) {
        mPath.moveTo(mLastX = 0, mLastY = 0);
    }
    mPath.lineTo(mLastX = x, mLastY = y);
}
------------------------
Find a silently evolved API code:android.telephony.ServiceState.isGsm:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return radioTechnology == RIL_RADIO_TECHNOLOGY_GPRS || radioTechnology == RIL_RADIO_TECHNOLOGY_EDGE || radioTechnology == RIL_RADIO_TECHNOLOGY_UMTS || radioTechnology == RIL_RADIO_TECHNOLOGY_HSDPA || radioTechnology == RIL_RADIO_TECHNOLOGY_HSUPA || radioTechnology == RIL_RADIO_TECHNOLOGY_HSPA || radioTechnology == RIL_RADIO_TECHNOLOGY_LTE || radioTechnology == RIL_RADIO_TECHNOLOGY_HSPAP || radioTechnology == RIL_RADIO_TECHNOLOGY_GSM;
}
Body of Second Method:
{
    return radioTechnology == RIL_RADIO_TECHNOLOGY_GPRS || radioTechnology == RIL_RADIO_TECHNOLOGY_EDGE || radioTechnology == RIL_RADIO_TECHNOLOGY_UMTS || radioTechnology == RIL_RADIO_TECHNOLOGY_HSDPA || radioTechnology == RIL_RADIO_TECHNOLOGY_HSUPA || radioTechnology == RIL_RADIO_TECHNOLOGY_HSPA || radioTechnology == RIL_RADIO_TECHNOLOGY_LTE || radioTechnology == RIL_RADIO_TECHNOLOGY_HSPAP || radioTechnology == RIL_RADIO_TECHNOLOGY_GSM || radioTechnology == RIL_RADIO_TECHNOLOGY_TD_SCDMA;
}
------------------------
Find a silently evolved API code:android.media.AudioService.handleConfigurationChanged:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Handles device configuration changes that may map to a change in the orientation
 * or orientation.
 * Monitoring orientation and rotation is optional, and is defined by the definition and value
 * of the "ro.audio.monitorOrientation" and "ro.audio.monitorRotation" system properties.
 */

Body of Frist Method:
{
    try {
        // reading new orientation "safely" (i.e. under try catch) in case anything
        // goes wrong when obtaining resources and configuration
        Configuration config = context.getResources().getConfiguration();
        // TODO merge rotation and orientation
        if (mMonitorOrientation) {
            int newOrientation = config.orientation;
            if (newOrientation != mDeviceOrientation) {
                mDeviceOrientation = newOrientation;
                setOrientationForAudioSystem();
            }
        }
        if (mMonitorRotation) {
            int newRotation = ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay().getRotation();
            if (newRotation != mDeviceRotation) {
                mDeviceRotation = newRotation;
                setRotationForAudioSystem();
            }
        }
        sendMsg(mAudioHandler, MSG_CONFIGURE_SAFE_MEDIA_VOLUME, SENDMSG_REPLACE, 0, 0, null, 0);
        boolean cameraSoundForced = mContext.getResources().getBoolean(com.android.internal.R.bool.config_camera_sound_forced);
        synchronized (mSettingsLock) {
            synchronized (mCameraSoundForced) {
                if (cameraSoundForced != mCameraSoundForced) {
                    mCameraSoundForced = cameraSoundForced;
                    VolumeStreamState s = mStreamStates[AudioSystem.STREAM_SYSTEM_ENFORCED];
                    if (cameraSoundForced) {
                        s.setAllIndexesToMax();
                        mRingerModeAffectedStreams &= ~(1 << AudioSystem.STREAM_SYSTEM_ENFORCED);
                    } else {
                        s.setAllIndexes(mStreamStates[AudioSystem.STREAM_SYSTEM]);
                        mRingerModeAffectedStreams |= (1 << AudioSystem.STREAM_SYSTEM_ENFORCED);
                    }
                    // take new state into account for streams muted by ringer mode
                    setRingerModeInt(getRingerMode(), false);
                    sendMsg(mAudioHandler, MSG_SET_FORCE_USE, SENDMSG_QUEUE, AudioSystem.FOR_SYSTEM, cameraSoundForced ? AudioSystem.FORCE_SYSTEM_ENFORCED : AudioSystem.FORCE_NONE, null, 0);
                    sendMsg(mAudioHandler, MSG_SET_ALL_VOLUMES, SENDMSG_QUEUE, 0, 0, mStreamStates[AudioSystem.STREAM_SYSTEM_ENFORCED], 0);
                }
            }
        }
        mVolumePanel.setLayoutDirection(config.getLayoutDirection());
    } catch (Exception e) {
        Log.e(TAG, "Error handling configuration change: ", e);
    }
}
Body of Second Method:
{
    try {
        // reading new orientation "safely" (i.e. under try catch) in case anything
        // goes wrong when obtaining resources and configuration
        Configuration config = context.getResources().getConfiguration();
        // TODO merge rotation and orientation
        if (mMonitorOrientation) {
            int newOrientation = config.orientation;
            if (newOrientation != mDeviceOrientation) {
                mDeviceOrientation = newOrientation;
                setOrientationForAudioSystem();
            }
        }
        sendMsg(mAudioHandler, MSG_CONFIGURE_SAFE_MEDIA_VOLUME, SENDMSG_REPLACE, 0, 0, null, 0);
        boolean cameraSoundForced = mContext.getResources().getBoolean(com.android.internal.R.bool.config_camera_sound_forced);
        synchronized (mSettingsLock) {
            synchronized (mCameraSoundForced) {
                if (cameraSoundForced != mCameraSoundForced) {
                    mCameraSoundForced = cameraSoundForced;
                    if (!isPlatformTelevision()) {
                        VolumeStreamState s = mStreamStates[AudioSystem.STREAM_SYSTEM_ENFORCED];
                        if (cameraSoundForced) {
                            s.setAllIndexesToMax();
                            mRingerModeAffectedStreams &= ~(1 << AudioSystem.STREAM_SYSTEM_ENFORCED);
                        } else {
                            s.setAllIndexes(mStreamStates[AudioSystem.STREAM_SYSTEM]);
                            mRingerModeAffectedStreams |= (1 << AudioSystem.STREAM_SYSTEM_ENFORCED);
                        }
                        // take new state into account for streams muted by ringer mode
                        setRingerModeInt(getRingerMode(), false);
                    }
                    sendMsg(mAudioHandler, MSG_SET_FORCE_USE, SENDMSG_QUEUE, AudioSystem.FOR_SYSTEM, cameraSoundForced ? AudioSystem.FORCE_SYSTEM_ENFORCED : AudioSystem.FORCE_NONE, null, 0);
                    sendMsg(mAudioHandler, MSG_SET_ALL_VOLUMES, SENDMSG_QUEUE, 0, 0, mStreamStates[AudioSystem.STREAM_SYSTEM_ENFORCED], 0);
                }
            }
        }
        mVolumeController.setLayoutDirection(config.getLayoutDirection());
    } catch (Exception e) {
        Log.e(TAG, "Error handling configuration change: ", e);
    }
}
------------------------
Find a silently evolved API code:android.media.MediaFocusControl.remoteControlDisplayWantsPlaybackPositionSync:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * Controls whether a remote control display needs periodic checks of the RemoteControlClient
 * playback position to verify that the estimated position has not drifted from the actual
 * position. By default the check is not performed.
 * The IRemoteControlDisplay must have been previously registered for this to have any effect.
 * @param rcd the IRemoteControlDisplay for which the anti-drift mechanism will be enabled
 * or disabled. Not null.
 * @param wantsSync if true, RemoteControlClient instances which expose their playback position
 * to the framework will regularly compare the estimated playback position with the actual
 * position, and will update the IRemoteControlDisplay implementation whenever a drift is
 * detected.
 */

Body of Frist Method:
{
    synchronized (mRCStack) {
        boolean rcdRegistered = false;
        // store the information about this display
        // (display stack traversal order doesn't matter).
        final Iterator<DisplayInfoForServer> displayIterator = mRcDisplays.iterator();
        while (displayIterator.hasNext()) {
            final DisplayInfoForServer di = (DisplayInfoForServer) displayIterator.next();
            if (di.mRcDisplay.asBinder().equals(rcd.asBinder())) {
                di.mWantsPositionSync = wantsSync;
                rcdRegistered = true;
                break;
            }
        }
        if (!rcdRegistered) {
            return;
        }
        // notify all current RemoteControlClients
        // (stack traversal order doesn't matter as we notify all RCCs)
        final Iterator<RemoteControlStackEntry> stackIterator = mRCStack.iterator();
        while (stackIterator.hasNext()) {
            final RemoteControlStackEntry rcse = stackIterator.next();
            if (rcse.mRcClient != null) {
                try {
                    rcse.mRcClient.setWantsSyncForDisplay(rcd, wantsSync);
                } catch (RemoteException e) {
                    Log.e(TAG, "Error setting position sync flag for RCD on RCC: ", e);
                }
            }
        }
    }
}
Body of Second Method:
{
    synchronized (mPRStack) {
        boolean rcdRegistered = false;
        // store the information about this display
        // (display stack traversal order doesn't matter).
        final Iterator<DisplayInfoForServer> displayIterator = mRcDisplays.iterator();
        while (displayIterator.hasNext()) {
            final DisplayInfoForServer di = displayIterator.next();
            if (di.mRcDisplay.asBinder().equals(rcd.asBinder())) {
                di.mWantsPositionSync = wantsSync;
                rcdRegistered = true;
                break;
            }
        }
        if (!rcdRegistered) {
            return;
        }
        // notify all current RemoteControlClients
        // (stack traversal order doesn't matter as we notify all RCCs)
        final Iterator<PlayerRecord> stackIterator = mPRStack.iterator();
        while (stackIterator.hasNext()) {
            final PlayerRecord prse = stackIterator.next();
            if (prse.getRcc() != null) {
                try {
                    prse.getRcc().setWantsSyncForDisplay(rcd, wantsSync);
                } catch (RemoteException e) {
                    Log.e(TAG, "Error setting position sync flag for RCD on RCC: ", e);
                }
            }
        }
    }
}
------------------------
Find a silently evolved API code:android.view.ViewGroup.dispatchTouchEvent:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(ev, 1);
    }
    boolean handled = false;
    if (onFilterTouchEventForSecurity(ev)) {
        final int action = ev.getAction();
        final int actionMasked = action & MotionEvent.ACTION_MASK;
        // Handle an initial down.
        if (actionMasked == MotionEvent.ACTION_DOWN) {
            // Throw away all previous state when starting a new touch gesture.
            // The framework may have dropped the up or cancel event for the previous gesture
            // due to an app switch, ANR, or some other state change.
            cancelAndClearTouchTargets(ev);
            resetTouchState();
        }
        // Check for interception.
        final boolean intercepted;
        if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) {
            final boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;
            if (!disallowIntercept) {
                intercepted = onInterceptTouchEvent(ev);
                // restore action in case it was changed
                ev.setAction(action);
            } else {
                intercepted = false;
            }
        } else {
            // There are no touch targets and this action is not an initial down
            // so this view group continues to intercept touches.
            intercepted = true;
        }
        // Check for cancelation.
        final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL;
        // Update list of touch targets for pointer down, if needed.
        final boolean split = (mGroupFlags & FLAG_SPLIT_MOTION_EVENTS) != 0;
        TouchTarget newTouchTarget = null;
        boolean alreadyDispatchedToNewTouchTarget = false;
        if (!canceled && !intercepted) {
            if (actionMasked == MotionEvent.ACTION_DOWN || (split && actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
                // always 0 for down
                final int actionIndex = ev.getActionIndex();
                final int idBitsToAssign = split ? 1 << ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS;
                // Clean up earlier touch targets for this pointer id in case they
                // have become out of sync.
                removePointersFromTouchTargets(idBitsToAssign);
                final int childrenCount = mChildrenCount;
                if (newTouchTarget == null && childrenCount != 0) {
                    final float x = ev.getX(actionIndex);
                    final float y = ev.getY(actionIndex);
                    // Find a child that can receive the event.
                    // Scan children from front to back.
                    final View[] children = mChildren;
                    final boolean customOrder = isChildrenDrawingOrderEnabled();
                    for (int i = childrenCount - 1; i >= 0; i--) {
                        final int childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i;
                        final View child = children[childIndex];
                        if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) {
                            continue;
                        }
                        newTouchTarget = getTouchTarget(child);
                        if (newTouchTarget != null) {
                            // Child is already receiving touch within its bounds.
                            // Give it the new pointer in addition to the ones it is handling.
                            newTouchTarget.pointerIdBits |= idBitsToAssign;
                            break;
                        }
                        resetCancelNextUpFlag(child);
                        if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
                            // Child wants to receive touch within its bounds.
                            mLastTouchDownTime = ev.getDownTime();
                            mLastTouchDownIndex = childIndex;
                            mLastTouchDownX = ev.getX();
                            mLastTouchDownY = ev.getY();
                            newTouchTarget = addTouchTarget(child, idBitsToAssign);
                            alreadyDispatchedToNewTouchTarget = true;
                            break;
                        }
                    }
                }
                if (newTouchTarget == null && mFirstTouchTarget != null) {
                    // Did not find a child to receive the event.
                    // Assign the pointer to the least recently added target.
                    newTouchTarget = mFirstTouchTarget;
                    while (newTouchTarget.next != null) {
                        newTouchTarget = newTouchTarget.next;
                    }
                    newTouchTarget.pointerIdBits |= idBitsToAssign;
                }
            }
        }
        // Dispatch to touch targets.
        if (mFirstTouchTarget == null) {
            // No touch targets so treat this as an ordinary view.
            handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS);
        } else {
            // Dispatch to touch targets, excluding the new touch target if we already
            // dispatched to it.  Cancel touch targets if necessary.
            TouchTarget predecessor = null;
            TouchTarget target = mFirstTouchTarget;
            while (target != null) {
                final TouchTarget next = target.next;
                if (alreadyDispatchedToNewTouchTarget && target == newTouchTarget) {
                    handled = true;
                } else {
                    final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted;
                    if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) {
                        handled = true;
                    }
                    if (cancelChild) {
                        if (predecessor == null) {
                            mFirstTouchTarget = next;
                        } else {
                            predecessor.next = next;
                        }
                        target.recycle();
                        target = next;
                        continue;
                    }
                }
                predecessor = target;
                target = next;
            }
        }
        // Update list of touch targets for pointer up or cancel, if needed.
        if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
            resetTouchState();
        } else if (split && actionMasked == MotionEvent.ACTION_POINTER_UP) {
            final int actionIndex = ev.getActionIndex();
            final int idBitsToRemove = 1 << ev.getPointerId(actionIndex);
            removePointersFromTouchTargets(idBitsToRemove);
        }
    }
    if (!handled && mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);
    }
    return handled;
}
Body of Second Method:
{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(ev, 1);
    }
    boolean handled = false;
    if (onFilterTouchEventForSecurity(ev)) {
        final int action = ev.getAction();
        final int actionMasked = action & MotionEvent.ACTION_MASK;
        // Handle an initial down.
        if (actionMasked == MotionEvent.ACTION_DOWN) {
            // Throw away all previous state when starting a new touch gesture.
            // The framework may have dropped the up or cancel event for the previous gesture
            // due to an app switch, ANR, or some other state change.
            cancelAndClearTouchTargets(ev);
            resetTouchState();
        }
        // Check for interception.
        final boolean intercepted;
        if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) {
            final boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;
            if (!disallowIntercept) {
                intercepted = onInterceptTouchEvent(ev);
                // restore action in case it was changed
                ev.setAction(action);
            } else {
                intercepted = false;
            }
        } else {
            // There are no touch targets and this action is not an initial down
            // so this view group continues to intercept touches.
            intercepted = true;
        }
        // Check for cancelation.
        final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL;
        // Update list of touch targets for pointer down, if needed.
        final boolean split = (mGroupFlags & FLAG_SPLIT_MOTION_EVENTS) != 0;
        TouchTarget newTouchTarget = null;
        boolean alreadyDispatchedToNewTouchTarget = false;
        if (!canceled && !intercepted) {
            if (actionMasked == MotionEvent.ACTION_DOWN || (split && actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
                // always 0 for down
                final int actionIndex = ev.getActionIndex();
                final int idBitsToAssign = split ? 1 << ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS;
                // Clean up earlier touch targets for this pointer id in case they
                // have become out of sync.
                removePointersFromTouchTargets(idBitsToAssign);
                final int childrenCount = mChildrenCount;
                if (newTouchTarget == null && childrenCount != 0) {
                    final float x = ev.getX(actionIndex);
                    final float y = ev.getY(actionIndex);
                    // Find a child that can receive the event.
                    // Scan children from front to back.
                    final ArrayList<View> preorderedList = buildOrderedChildList();
                    final boolean customOrder = preorderedList == null && isChildrenDrawingOrderEnabled();
                    final View[] children = mChildren;
                    for (int i = childrenCount - 1; i >= 0; i--) {
                        final int childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i;
                        final View child = (preorderedList == null) ? children[childIndex] : preorderedList.get(childIndex);
                        if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) {
                            continue;
                        }
                        newTouchTarget = getTouchTarget(child);
                        if (newTouchTarget != null) {
                            // Child is already receiving touch within its bounds.
                            // Give it the new pointer in addition to the ones it is handling.
                            newTouchTarget.pointerIdBits |= idBitsToAssign;
                            break;
                        }
                        resetCancelNextUpFlag(child);
                        if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
                            // Child wants to receive touch within its bounds.
                            mLastTouchDownTime = ev.getDownTime();
                            if (preorderedList != null) {
                                // childIndex points into presorted list, find original index
                                for (int j = 0; j < childrenCount; j++) {
                                    if (children[childIndex] == mChildren[j]) {
                                        mLastTouchDownIndex = j;
                                        break;
                                    }
                                }
                            } else {
                                mLastTouchDownIndex = childIndex;
                            }
                            mLastTouchDownX = ev.getX();
                            mLastTouchDownY = ev.getY();
                            newTouchTarget = addTouchTarget(child, idBitsToAssign);
                            alreadyDispatchedToNewTouchTarget = true;
                            break;
                        }
                    }
                    if (preorderedList != null)
                        preorderedList.clear();
                }
                if (newTouchTarget == null && mFirstTouchTarget != null) {
                    // Did not find a child to receive the event.
                    // Assign the pointer to the least recently added target.
                    newTouchTarget = mFirstTouchTarget;
                    while (newTouchTarget.next != null) {
                        newTouchTarget = newTouchTarget.next;
                    }
                    newTouchTarget.pointerIdBits |= idBitsToAssign;
                }
            }
        }
        // Dispatch to touch targets.
        if (mFirstTouchTarget == null) {
            // No touch targets so treat this as an ordinary view.
            handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS);
        } else {
            // Dispatch to touch targets, excluding the new touch target if we already
            // dispatched to it.  Cancel touch targets if necessary.
            TouchTarget predecessor = null;
            TouchTarget target = mFirstTouchTarget;
            while (target != null) {
                final TouchTarget next = target.next;
                if (alreadyDispatchedToNewTouchTarget && target == newTouchTarget) {
                    handled = true;
                } else {
                    final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted;
                    if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) {
                        handled = true;
                    }
                    if (cancelChild) {
                        if (predecessor == null) {
                            mFirstTouchTarget = next;
                        } else {
                            predecessor.next = next;
                        }
                        target.recycle();
                        target = next;
                        continue;
                    }
                }
                predecessor = target;
                target = next;
            }
        }
        // Update list of touch targets for pointer up or cancel, if needed.
        if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
            resetTouchState();
        } else if (split && actionMasked == MotionEvent.ACTION_POINTER_UP) {
            final int actionIndex = ev.getActionIndex();
            final int idBitsToRemove = 1 << ev.getPointerId(actionIndex);
            removePointersFromTouchTargets(idBitsToRemove);
        }
    }
    if (!handled && mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);
    }
    return handled;
}
------------------------
Find a silently evolved API code:android.print.PrintManager.removePrintJobStateChangeListener:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Removes a listener for observing the state of print jobs.
 *
 * @param listener The listener to remove.
 * @hide
 */

Body of Frist Method:
{
    if (mPrintJobStateChangeListeners == null) {
        return;
    }
    PrintJobStateChangeListenerWrapper wrappedListener = mPrintJobStateChangeListeners.remove(listener);
    if (wrappedListener == null) {
        return;
    }
    if (mPrintJobStateChangeListeners.isEmpty()) {
        mPrintJobStateChangeListeners = null;
    }
    wrappedListener.destroy();
    try {
        mService.removePrintJobStateChangeListener(wrappedListener, mUserId);
    } catch (RemoteException re) {
        Log.e(LOG_TAG, "Error removing print job state change listener", re);
    }
}
Body of Second Method:
{
    if (mService == null) {
        Log.w(LOG_TAG, "Feature android.software.print not available");
        return;
    }
    if (mPrintJobStateChangeListeners == null) {
        return;
    }
    PrintJobStateChangeListenerWrapper wrappedListener = mPrintJobStateChangeListeners.remove(listener);
    if (wrappedListener == null) {
        return;
    }
    if (mPrintJobStateChangeListeners.isEmpty()) {
        mPrintJobStateChangeListeners = null;
    }
    wrappedListener.destroy();
    try {
        mService.removePrintJobStateChangeListener(wrappedListener, mUserId);
    } catch (RemoteException re) {
        Log.e(LOG_TAG, "Error removing print job state change listener", re);
    }
}
------------------------
Find a silently evolved API code:android.media.AudioRecord.stop:COMMENT
Method Modifier: public      
Comment:/**
 * Stops recording.
 * @throws IllegalStateException
 */

Body of Frist Method:
{
    if (mState != STATE_INITIALIZED) {
        throw new IllegalStateException("stop() called on an uninitialized AudioRecord.");
    }
    // stop recording
    synchronized (mRecordingStateLock) {
        native_stop();
        mRecordingState = RECORDSTATE_STOPPED;
    }
}
Body of Second Method:
{
    if (mState != STATE_INITIALIZED) {
        throw new IllegalStateException("stop() called on an uninitialized AudioRecord.");
    }
    // stop recording
    synchronized (mRecordingStateLock) {
        handleFullVolumeRec(false);
        native_stop();
        mRecordingState = RECORDSTATE_STOPPED;
    }
}
------------------------
Find a silently evolved API code:android.widget.CalendarView.setMaxDate:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the maximal date supported by this {@link CalendarView} in milliseconds
 * since January 1, 1970 00:00:00 in {@link TimeZone#getDefault()} time
 * zone.
 *
 * @param maxDate The maximal supported date.
 *
 * @attr ref android.R.styleable#CalendarView_maxDate
 */

Body of Frist Method:
{
    mTempDate.setTimeInMillis(maxDate);
    if (isSameDate(mTempDate, mMaxDate)) {
        return;
    }
    mMaxDate.setTimeInMillis(maxDate);
    // reinitialize the adapter since its range depends on max date
    mAdapter.init();
    Calendar date = mAdapter.mSelectedDate;
    if (date.after(mMaxDate)) {
        setDate(mMaxDate.getTimeInMillis());
    } else {
        // we go to the current date to force the ListView to query its
        // adapter for the shown views since we have changed the adapter
        // range and the base from which the later calculates item indices
        // note that calling setDate will not work since the date is the same
        goTo(date, false, true, false);
    }
}
Body of Second Method:
{
    mDelegate.setMaxDate(maxDate);
}
------------------------
Find a silently evolved API code:android.os.Bundle.getStringArrayList:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return an ArrayList<String> value, or null
 */

Body of Frist Method:
{
    unparcel();
    Object o = mMap.get(key);
    if (o == null) {
        return null;
    }
    try {
        return (ArrayList<String>) o;
    } catch (ClassCastException e) {
        typeWarning(key, o, "ArrayList<String>", e);
        return null;
    }
}
Body of Second Method:
{
    return super.getStringArrayList(key);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothGattServer.connect:COMMENT
Method Modifier: public      
Comment:/**
 * Initiate a connection to a Bluetooth GATT capable device.
 *
 * <p>The connection may not be established right away, but will be
 * completed when the remote device is available. A
 * {@link BluetoothGattServerCallback#onConnectionStateChange} callback will be
 * invoked when the connection state changes as a result of this function.
 *
 * <p>The autoConnect paramter determines whether to actively connect to
 * the remote device, or rather passively scan and finalize the connection
 * when the remote device is in range/available. Generally, the first ever
 * connection to a device should be direct (autoConnect set to false) and
 * subsequent connections to known devices should be invoked with the
 * autoConnect parameter set to true.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param autoConnect Whether to directly connect to the remote device (false)
 * or to automatically connect as soon as the remote
 * device becomes available (true).
 * @return true, if the connection attempt was initiated successfully
 */

Body of Frist Method:
{
    if (DBG)
        Log.d(TAG, "connect() - device: " + device.getAddress() + ", auto: " + autoConnect);
    if (mService == null || mServerIf == 0)
        return false;
    try {
        mService.serverConnect(mServerIf, device.getAddress(), // autoConnect is inverse of "isDirect"
        autoConnect ? false : true);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        return false;
    }
    return true;
}
Body of Second Method:
{
    if (DBG)
        Log.d(TAG, "connect() - device: " + device.getAddress() + ", auto: " + autoConnect);
    if (mService == null || mServerIf == 0)
        return false;
    try {
        mService.serverConnect(mServerIf, device.getAddress(), autoConnect ? false : true, // autoConnect is inverse of "isDirect"
        mTransport);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        return false;
    }
    return true;
}
------------------------
Find a silently evolved API code:android.os.Bundle.putChar:COMMENT
Method Modifier: public      
Comment:/**
 * Inserts a char value into the mapping of this Bundle, replacing
 * any existing value for the given key.
 *
 * @param key a String, or null
 * @param value a char, or null
 */

Body of Frist Method:
{
    unparcel();
    mMap.put(key, value);
}
Body of Second Method:
{
    super.putChar(key, value);
}
------------------------
Find a silently evolved API code:android.content.res.TypedArray.getString:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the string value for the attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return String holding string data.  Any styling information is
 * removed.  Returns null if the attribute is not defined.
 */

Body of Frist Method:
{
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return null;
    } else if (type == TypedValue.TYPE_STRING) {
        return loadStringValueAt(index).toString();
    }
    TypedValue v = mValue;
    if (getValueAt(index, v)) {
        Log.w(Resources.TAG, "Converting to string: " + v);
        CharSequence cs = v.coerceToString();
        return cs != null ? cs.toString() : null;
    }
    Log.w(Resources.TAG, "getString of bad type: 0x" + Integer.toHexString(type));
    return null;
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return null;
    } else if (type == TypedValue.TYPE_STRING) {
        return loadStringValueAt(index).toString();
    }
    TypedValue v = mValue;
    if (getValueAt(index, v)) {
        Log.w(Resources.TAG, "Converting to string: " + v);
        CharSequence cs = v.coerceToString();
        return cs != null ? cs.toString() : null;
    }
    Log.w(Resources.TAG, "getString of bad type: 0x" + Integer.toHexString(type));
    return null;
}
------------------------
Find a silently evolved API code:android.app.Fragment.getLayoutInflater:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide Hack so that DialogFragment can make its Dialog before creating
 * its views, and the view construction can use the dialog's context for
 * inflation.  Maybe this should become a public API. Note sure.
 */

Body of Frist Method:
{
    return mActivity.getLayoutInflater();
}
Body of Second Method:
{
    // Newer platform versions use the child fragment manager's LayoutInflaterFactory.
    if (mActivity.getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.LOLLIPOP) {
        LayoutInflater result = mActivity.getLayoutInflater().cloneInContext(mActivity);
        // Init if needed; use raw implementation below.
        getChildFragmentManager();
        result.setPrivateFactory(mChildFragmentManager.getLayoutInflaterFactory());
        return result;
    } else {
        return mActivity.getLayoutInflater();
    }
}
------------------------
Find a silently evolved API code:android.widget.TextView.setTextAppearance:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the text color, size, style, hint color, and highlight color
 * from the specified TextAppearance resource.
 */

Body of Frist Method:
{
    TypedArray appearance = context.obtainStyledAttributes(resid, com.android.internal.R.styleable.TextAppearance);
    int color;
    ColorStateList colors;
    int ts;
    color = appearance.getColor(com.android.internal.R.styleable.TextAppearance_textColorHighlight, 0);
    if (color != 0) {
        setHighlightColor(color);
    }
    colors = appearance.getColorStateList(com.android.internal.R.styleable.TextAppearance_textColor);
    if (colors != null) {
        setTextColor(colors);
    }
    ts = appearance.getDimensionPixelSize(com.android.internal.R.styleable.TextAppearance_textSize, 0);
    if (ts != 0) {
        setRawTextSize(ts);
    }
    colors = appearance.getColorStateList(com.android.internal.R.styleable.TextAppearance_textColorHint);
    if (colors != null) {
        setHintTextColor(colors);
    }
    colors = appearance.getColorStateList(com.android.internal.R.styleable.TextAppearance_textColorLink);
    if (colors != null) {
        setLinkTextColor(colors);
    }
    String familyName;
    int typefaceIndex, styleIndex;
    familyName = appearance.getString(com.android.internal.R.styleable.TextAppearance_fontFamily);
    typefaceIndex = appearance.getInt(com.android.internal.R.styleable.TextAppearance_typeface, -1);
    styleIndex = appearance.getInt(com.android.internal.R.styleable.TextAppearance_textStyle, -1);
    setTypefaceFromAttrs(familyName, typefaceIndex, styleIndex);
    final int shadowcolor = appearance.getInt(com.android.internal.R.styleable.TextAppearance_shadowColor, 0);
    if (shadowcolor != 0) {
        final float dx = appearance.getFloat(com.android.internal.R.styleable.TextAppearance_shadowDx, 0);
        final float dy = appearance.getFloat(com.android.internal.R.styleable.TextAppearance_shadowDy, 0);
        final float r = appearance.getFloat(com.android.internal.R.styleable.TextAppearance_shadowRadius, 0);
        setShadowLayer(r, dx, dy, shadowcolor);
    }
    if (appearance.getBoolean(com.android.internal.R.styleable.TextAppearance_textAllCaps, false)) {
        setTransformationMethod(new AllCapsTransformationMethod(getContext()));
    }
    appearance.recycle();
}
Body of Second Method:
{
    TypedArray appearance = context.obtainStyledAttributes(resid, com.android.internal.R.styleable.TextAppearance);
    int color;
    ColorStateList colors;
    int ts;
    color = appearance.getColor(com.android.internal.R.styleable.TextAppearance_textColorHighlight, 0);
    if (color != 0) {
        setHighlightColor(color);
    }
    colors = appearance.getColorStateList(com.android.internal.R.styleable.TextAppearance_textColor);
    if (colors != null) {
        setTextColor(colors);
    }
    ts = appearance.getDimensionPixelSize(com.android.internal.R.styleable.TextAppearance_textSize, 0);
    if (ts != 0) {
        setRawTextSize(ts);
    }
    colors = appearance.getColorStateList(com.android.internal.R.styleable.TextAppearance_textColorHint);
    if (colors != null) {
        setHintTextColor(colors);
    }
    colors = appearance.getColorStateList(com.android.internal.R.styleable.TextAppearance_textColorLink);
    if (colors != null) {
        setLinkTextColor(colors);
    }
    String familyName;
    int typefaceIndex, styleIndex;
    familyName = appearance.getString(com.android.internal.R.styleable.TextAppearance_fontFamily);
    typefaceIndex = appearance.getInt(com.android.internal.R.styleable.TextAppearance_typeface, -1);
    styleIndex = appearance.getInt(com.android.internal.R.styleable.TextAppearance_textStyle, -1);
    setTypefaceFromAttrs(familyName, typefaceIndex, styleIndex);
    final int shadowcolor = appearance.getInt(com.android.internal.R.styleable.TextAppearance_shadowColor, 0);
    if (shadowcolor != 0) {
        final float dx = appearance.getFloat(com.android.internal.R.styleable.TextAppearance_shadowDx, 0);
        final float dy = appearance.getFloat(com.android.internal.R.styleable.TextAppearance_shadowDy, 0);
        final float r = appearance.getFloat(com.android.internal.R.styleable.TextAppearance_shadowRadius, 0);
        setShadowLayer(r, dx, dy, shadowcolor);
    }
    if (appearance.getBoolean(com.android.internal.R.styleable.TextAppearance_textAllCaps, false)) {
        setTransformationMethod(new AllCapsTransformationMethod(getContext()));
    }
    if (appearance.hasValue(com.android.internal.R.styleable.TextAppearance_elegantTextHeight)) {
        setElegantTextHeight(appearance.getBoolean(com.android.internal.R.styleable.TextAppearance_elegantTextHeight, false));
    }
    if (appearance.hasValue(com.android.internal.R.styleable.TextAppearance_letterSpacing)) {
        setLetterSpacing(appearance.getFloat(com.android.internal.R.styleable.TextAppearance_letterSpacing, 0));
    }
    if (appearance.hasValue(com.android.internal.R.styleable.TextAppearance_fontFeatureSettings)) {
        setFontFeatureSettings(appearance.getString(com.android.internal.R.styleable.TextAppearance_fontFeatureSettings));
    }
    appearance.recycle();
}
------------------------
Find a silently evolved API code:android.content.res.TypedArray.getInt:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the integer value for the attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined.
 *
 * @return Attribute int value, or defValue if not defined.
 */

Body of Frist Method:
{
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + AssetManager.STYLE_DATA];
    }
    TypedValue v = mValue;
    if (getValueAt(index, v)) {
        Log.w(Resources.TAG, "Converting to int: " + v);
        return XmlUtils.convertValueToInt(v.coerceToString(), defValue);
    }
    Log.w(Resources.TAG, "getInt of bad type: 0x" + Integer.toHexString(type));
    return defValue;
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + AssetManager.STYLE_DATA];
    }
    TypedValue v = mValue;
    if (getValueAt(index, v)) {
        Log.w(Resources.TAG, "Converting to int: " + v);
        return XmlUtils.convertValueToInt(v.coerceToString(), defValue);
    }
    Log.w(Resources.TAG, "getInt of bad type: 0x" + Integer.toHexString(type));
    return defValue;
}
------------------------
Find a silently evolved API code:android.app.Activity.onBackPressed:COMMENT
Method Modifier: public      
Comment:/**
 * Called when the activity has detected the user's press of the back
 * key.  The default implementation simply finishes the current activity,
 * but you can override this to do whatever you want.
 */

Body of Frist Method:
{
    if (!mFragments.popBackStackImmediate()) {
        finish();
    }
}
Body of Second Method:
{
    if (mActionBar != null && mActionBar.collapseActionView()) {
        return;
    }
    if (!mFragments.popBackStackImmediate()) {
        finishAfterTransition();
    }
}
------------------------
Find a silently evolved API code:android.text.TextLine.getOffsetBeforeAfter:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Returns the next valid offset within this directional run, skipping
 * conjuncts and zero-width characters.  This should not be called to walk
 * off the end of the line, since the returned values might not be valid
 * on neighboring lines.  If the returned offset is less than zero or
 * greater than the line length, the offset should be recomputed on the
 * preceding or following line, respectively.
 *
 * @param runIndex the run index
 * @param runStart the start of the run
 * @param runLimit the limit of the run
 * @param runIsRtl true if the run is right-to-left
 * @param offset the offset
 * @param after true if the new offset should logically follow the provided
 * offset
 * @return the new offset
 */

Body of Frist Method:
{
    if (runIndex < 0 || offset == (after ? mLen : 0)) {
        // return accurate values.  These are a guess.
        if (after) {
            return TextUtils.getOffsetAfter(mText, offset + mStart) - mStart;
        }
        return TextUtils.getOffsetBefore(mText, offset + mStart) - mStart;
    }
    TextPaint wp = mWorkPaint;
    wp.set(mPaint);
    int spanStart = runStart;
    int spanLimit;
    if (mSpanned == null) {
        spanLimit = runLimit;
    } else {
        int target = after ? offset + 1 : offset;
        int limit = mStart + runLimit;
        while (true) {
            spanLimit = mSpanned.nextSpanTransition(mStart + spanStart, limit, MetricAffectingSpan.class) - mStart;
            if (spanLimit >= target) {
                break;
            }
            spanStart = spanLimit;
        }
        MetricAffectingSpan[] spans = mSpanned.getSpans(mStart + spanStart, mStart + spanLimit, MetricAffectingSpan.class);
        spans = TextUtils.removeEmptySpans(spans, mSpanned, MetricAffectingSpan.class);
        if (spans.length > 0) {
            ReplacementSpan replacement = null;
            for (int j = 0; j < spans.length; j++) {
                MetricAffectingSpan span = spans[j];
                if (span instanceof ReplacementSpan) {
                    replacement = (ReplacementSpan) span;
                } else {
                    span.updateMeasureState(wp);
                }
            }
            if (replacement != null) {
                // the start or end of this span.
                return after ? spanLimit : spanStart;
            }
        }
    }
    int flags = runIsRtl ? Paint.DIRECTION_RTL : Paint.DIRECTION_LTR;
    int cursorOpt = after ? Paint.CURSOR_AFTER : Paint.CURSOR_BEFORE;
    if (mCharsValid) {
        return wp.getTextRunCursor(mChars, spanStart, spanLimit - spanStart, flags, offset, cursorOpt);
    } else {
        return wp.getTextRunCursor(mText, mStart + spanStart, mStart + spanLimit, flags, mStart + offset, cursorOpt) - mStart;
    }
}
Body of Second Method:
{
    if (runIndex < 0 || offset == (after ? mLen : 0)) {
        // return accurate values.  These are a guess.
        if (after) {
            return TextUtils.getOffsetAfter(mText, offset + mStart) - mStart;
        }
        return TextUtils.getOffsetBefore(mText, offset + mStart) - mStart;
    }
    TextPaint wp = mWorkPaint;
    wp.set(mPaint);
    int spanStart = runStart;
    int spanLimit;
    if (mSpanned == null) {
        spanLimit = runLimit;
    } else {
        int target = after ? offset + 1 : offset;
        int limit = mStart + runLimit;
        while (true) {
            spanLimit = mSpanned.nextSpanTransition(mStart + spanStart, limit, MetricAffectingSpan.class) - mStart;
            if (spanLimit >= target) {
                break;
            }
            spanStart = spanLimit;
        }
        MetricAffectingSpan[] spans = mSpanned.getSpans(mStart + spanStart, mStart + spanLimit, MetricAffectingSpan.class);
        spans = TextUtils.removeEmptySpans(spans, mSpanned, MetricAffectingSpan.class);
        if (spans.length > 0) {
            ReplacementSpan replacement = null;
            for (int j = 0; j < spans.length; j++) {
                MetricAffectingSpan span = spans[j];
                if (span instanceof ReplacementSpan) {
                    replacement = (ReplacementSpan) span;
                } else {
                    span.updateMeasureState(wp);
                }
            }
            if (replacement != null) {
                // the start or end of this span.
                return after ? spanLimit : spanStart;
            }
        }
    }
    int dir = runIsRtl ? Paint.DIRECTION_RTL : Paint.DIRECTION_LTR;
    int cursorOpt = after ? Paint.CURSOR_AFTER : Paint.CURSOR_BEFORE;
    if (mCharsValid) {
        return wp.getTextRunCursor(mChars, spanStart, spanLimit - spanStart, dir, offset, cursorOpt);
    } else {
        return wp.getTextRunCursor(mText, mStart + spanStart, mStart + spanLimit, dir, mStart + offset, cursorOpt) - mStart;
    }
}
------------------------
Find a silently evolved API code:android.security.KeyChain.createInstallIntent:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns an {@code Intent} that can be used for credential
 * installation. The intent may be used without any extras, in
 * which case the user will be able to install credentials from
 * their own source.
 *
 * <p>Alternatively, {@link #EXTRA_CERTIFICATE} or {@link
 * #EXTRA_PKCS12} maybe used to specify the bytes of an X.509
 * certificate or a PKCS#12 key store for installation. These
 * extras may be combined with {@link #EXTRA_NAME} to provide a
 * default alias name for credentials being installed.
 *
 * <p>When used with {@link Activity#startActivityForResult},
 * {@link Activity#RESULT_OK} will be returned if a credential was
 * successfully installed, otherwise {@link
 * Activity#RESULT_CANCELED} will be returned.
 */

Body of Frist Method:
{
    Intent intent = new Intent(ACTION_INSTALL);
    intent.setClassName("com.android.certinstaller", "com.android.certinstaller.CertInstallerMain");
    return intent;
}
Body of Second Method:
{
    Intent intent = new Intent(ACTION_INSTALL);
    intent.setClassName(CERT_INSTALLER_PACKAGE, "com.android.certinstaller.CertInstallerMain");
    return intent;
}
------------------------
Find a silently evolved API code:android.net.wifi.p2p.WifiP2pManager.initialize:COMMENT
Method Modifier: public      
Comment:/**
 * Registers the application with the Wi-Fi framework. This function
 * must be the first to be called before any p2p operations are performed.
 *
 * @param srcContext is the context of the source
 * @param srcLooper is the Looper on which the callbacks are receivied
 * @param listener for callback at loss of framework communication. Can be null.
 * @return Channel instance that is necessary for performing any further p2p operations
 */

Body of Frist Method:
{
    Messenger messenger = getMessenger();
    if (messenger == null)
        return null;
    Channel c = new Channel(srcContext, srcLooper, listener);
    if (c.mAsyncChannel.connectSync(srcContext, c.mHandler, messenger) == AsyncChannel.STATUS_SUCCESSFUL) {
        return c;
    } else {
        return null;
    }
}
Body of Second Method:
{
    return initalizeChannel(srcContext, srcLooper, listener, getMessenger());
}
------------------------
Find a silently evolved API code:android.content.AsyncTaskLoader.LoadTask.onCancelled:COMMENT
Method Modifier: protected   
Comment:/* Runs on the UI thread */

Body of Frist Method:
{
    if (DEBUG)
        Slog.v(TAG, this + " onCancelled");
    try {
        AsyncTaskLoader.this.dispatchOnCancelled(this, data);
    } finally {
        mDone.countDown();
    }
}
Body of Second Method:
{
    if (DEBUG)
        Log.v(TAG, this + " onCancelled");
    try {
        AsyncTaskLoader.this.dispatchOnCancelled(this, data);
    } finally {
        mDone.countDown();
    }
}
------------------------
Find a silently evolved API code:android.print.PrinterCapabilitiesInfo.getResolutions:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the supported resolutions.
 *
 * @return The resolutions.
 */

Body of Frist Method:
{
    return mResolutions;
}
Body of Second Method:
{
    return Collections.unmodifiableList(mResolutions);
}
------------------------
Find a silently evolved API code:android.os.Bundle.getFloat:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the value associated with the given key, or defaultValue if
 * no mapping of the desired type exists for the given key.
 *
 * @param key a String
 * @param defaultValue Value to return if key does not exist
 * @return a float value
 */

Body of Frist Method:
{
    unparcel();
    Object o = mMap.get(key);
    if (o == null) {
        return defaultValue;
    }
    try {
        return (Float) o;
    } catch (ClassCastException e) {
        typeWarning(key, o, "Float", defaultValue, e);
        return defaultValue;
    }
}
Body of Second Method:
{
    return super.getFloat(key, defaultValue);
}
------------------------
Find a silently evolved API code:android.os.Message.copyFrom:COMMENT
Method Modifier: public      
Comment:/**
 * Make this message like o.  Performs a shallow copy of the data field.
 * Does not copy the linked list fields, nor the timestamp or
 * target/callback of the original message.
 */

Body of Frist Method:
{
    this.flags = o.flags & ~FLAGS_TO_CLEAR_ON_COPY_FROM;
    this.what = o.what;
    this.arg1 = o.arg1;
    this.arg2 = o.arg2;
    this.obj = o.obj;
    this.replyTo = o.replyTo;
    if (o.data != null) {
        this.data = (Bundle) o.data.clone();
    } else {
        this.data = null;
    }
}
Body of Second Method:
{
    this.flags = o.flags & ~FLAGS_TO_CLEAR_ON_COPY_FROM;
    this.what = o.what;
    this.arg1 = o.arg1;
    this.arg2 = o.arg2;
    this.obj = o.obj;
    this.replyTo = o.replyTo;
    this.sendingUid = o.sendingUid;
    if (o.data != null) {
        this.data = (Bundle) o.data.clone();
    } else {
        this.data = null;
    }
}
------------------------
Find a silently evolved API code:android.content.res.TypedArray.getNonResourceString:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the string value for the attribute at <var>index</var>, but
 * only if that string comes from an immediate value in an XML file.  That
 * is, this does not allow references to string resources, string
 * attributes, or conversions from other types.  As such, this method
 * will only return strings for TypedArray objects that come from
 * attributes in an XML file.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return String holding string data.  Any styling information is
 * removed.  Returns null if the attribute is not defined or is not
 * an immediate string value.
 */

Body of Frist Method:
{
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_STRING) {
        final int cookie = data[index + AssetManager.STYLE_ASSET_COOKIE];
        if (cookie < 0) {
            return mXml.getPooledString(data[index + AssetManager.STYLE_DATA]).toString();
        }
    }
    return null;
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_STRING) {
        final int cookie = data[index + AssetManager.STYLE_ASSET_COOKIE];
        if (cookie < 0) {
            return mXml.getPooledString(data[index + AssetManager.STYLE_DATA]).toString();
        }
    }
    return null;
}
------------------------
Find a silently evolved API code:android.media.MediaFocusControl.registerRemoteControlDisplay_int:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Register an IRemoteControlDisplay.
 * Notify all IRemoteControlClient of the new display and cause the RemoteControlClient
 * at the top of the stack to update the new display with its information.
 * @see android.media.IAudioService#registerRemoteControlDisplay(android.media.IRemoteControlDisplay, int, int)
 * @param rcd the IRemoteControlDisplay to register. No effect if null.
 * @param w the maximum width of the expected bitmap. Negative or zero values indicate this
 * display doesn't need to receive artwork.
 * @param h the maximum height of the expected bitmap. Negative or zero values indicate this
 * display doesn't need to receive artwork.
 * @param listenerComp the component for the listener interface, may be null if it's not needed
 * to verify it belongs to one of the enabled notification listeners
 */

Body of Frist Method:
{
    if (DEBUG_RC)
        Log.d(TAG, ">>> registerRemoteControlDisplay(" + rcd + ")");
    synchronized (mAudioFocusLock) {
        synchronized (mRCStack) {
            if ((rcd == null) || rcDisplayIsPluggedIn_syncRcStack(rcd)) {
                return;
            }
            DisplayInfoForServer di = new DisplayInfoForServer(rcd, w, h);
            di.mEnabled = true;
            di.mClientNotifListComp = listenerComp;
            if (!di.init()) {
                if (DEBUG_RC)
                    Log.e(TAG, " error registering RCD");
                return;
            }
            // add RCD to list of displays
            mRcDisplays.add(di);
            // let all the remote control clients know there is a new display (so the remote
            // control stack traversal order doesn't matter).
            Iterator<RemoteControlStackEntry> stackIterator = mRCStack.iterator();
            while (stackIterator.hasNext()) {
                RemoteControlStackEntry rcse = stackIterator.next();
                if (rcse.mRcClient != null) {
                    try {
                        rcse.mRcClient.plugRemoteControlDisplay(rcd, w, h);
                    } catch (RemoteException e) {
                        Log.e(TAG, "Error connecting RCD to client: ", e);
                    }
                }
            }
            // we have a new display, of which all the clients are now aware: have it be
            // initialized wih the current gen ID and the current client info, do not
            // reset the information for the other (existing) displays
            sendMsg(mEventHandler, MSG_RCDISPLAY_INIT_INFO, SENDMSG_QUEUE, w, /*arg1*/
            h, /*arg2*/
            rcd, /*obj*/
            0);
        }
    }
}
Body of Second Method:
{
    if (DEBUG_RC)
        Log.d(TAG, ">>> registerRemoteControlDisplay(" + rcd + ")");
    synchronized (mAudioFocusLock) {
        synchronized (mPRStack) {
            if ((rcd == null) || rcDisplayIsPluggedIn_syncRcStack(rcd)) {
                return;
            }
            DisplayInfoForServer di = new DisplayInfoForServer(rcd, w, h);
            di.mEnabled = true;
            di.mClientNotifListComp = listenerComp;
            if (!di.init()) {
                if (DEBUG_RC)
                    Log.e(TAG, " error registering RCD");
                return;
            }
            // add RCD to list of displays
            mRcDisplays.add(di);
            // let all the remote control clients know there is a new display (so the remote
            // control stack traversal order doesn't matter).
            Iterator<PlayerRecord> stackIterator = mPRStack.iterator();
            while (stackIterator.hasNext()) {
                PlayerRecord prse = stackIterator.next();
                if (prse.getRcc() != null) {
                    try {
                        prse.getRcc().plugRemoteControlDisplay(rcd, w, h);
                    } catch (RemoteException e) {
                        Log.e(TAG, "Error connecting RCD to client: ", e);
                    }
                }
            }
            // we have a new display, of which all the clients are now aware: have it be
            // initialized wih the current gen ID and the current client info, do not
            // reset the information for the other (existing) displays
            sendMsg(mEventHandler, MSG_RCDISPLAY_INIT_INFO, SENDMSG_QUEUE, w, /*arg1*/
            h, /*arg2*/
            rcd, /*obj*/
            0);
        }
    }
}
------------------------
Find a silently evolved API code:android.ddm.DdmHandleProfiling.handleSPSS:COMMENT
Method Modifier: private     
Comment:/*
     * Handle a "Sample Profiling w/Streaming Start" request.
     */

Body of Frist Method:
{
    ByteBuffer in = wrapChunk(request);
    int bufferSize = in.getInt();
    int flags = in.getInt();
    int interval = in.getInt();
    if (false) {
        Log.v("ddm-heap", "Sample prof stream start: size=" + bufferSize + ", flags=" + flags + ", interval=" + interval);
    }
    try {
        Debug.startMethodTracingDdms(bufferSize, flags, true, interval);
        // empty response
        return null;
    } catch (RuntimeException re) {
        return createFailChunk(1, re.getMessage());
    }
}
Body of Second Method:
{
    ByteBuffer in = wrapChunk(request);
    int bufferSize = in.getInt();
    int flags = in.getInt();
    int interval = in.getInt();
    if (DEBUG) {
        Log.v("ddm-heap", "Sample prof stream start: size=" + bufferSize + ", flags=" + flags + ", interval=" + interval);
    }
    try {
        Debug.startMethodTracingDdms(bufferSize, flags, true, interval);
        // empty response
        return null;
    } catch (RuntimeException re) {
        return createFailChunk(1, re.getMessage());
    }
}
------------------------
Find a silently evolved API code:android.widget.CheckedTextView.internalSetPadding:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    super.internalSetPadding(left, top, right, bottom);
    setBasePadding(isLayoutRtl());
}
Body of Second Method:
{
    super.internalSetPadding(left, top, right, bottom);
    setBasePadding(isCheckMarkAtStart());
}
------------------------
Find a silently evolved API code:android.view.Window.setAttributes:COMMENT
Method Modifier: public      
Comment:/**
 * Specify custom window attributes.  <strong>PLEASE NOTE:</strong> the
 * layout params you give here should generally be from values previously
 * retrieved with {@link #getAttributes()}; you probably do not want to
 * blindly create and apply your own, since this will blow away any values
 * set by the framework that you are not interested in.
 *
 * @param a The new window attributes, which will completely override any
 * current values.
 */

Body of Frist Method:
{
    mWindowAttributes.copyFrom(a);
    if (mCallback != null) {
        mCallback.onWindowAttributesChanged(mWindowAttributes);
    }
}
Body of Second Method:
{
    mWindowAttributes.copyFrom(a);
    dispatchWindowAttributesChanged(mWindowAttributes);
}
------------------------
Find a silently evolved API code:android.appwidget.AppWidgetHost.startListening:COMMENT
Method Modifier: public      
Comment:/**
 * Start receiving onAppWidgetChanged calls for your AppWidgets.  Call this when your activity
 * becomes visible, i.e. from onStart() in your Activity.
 */

Body of Frist Method:
{
    int[] updatedIds;
    ArrayList<RemoteViews> updatedViews = new ArrayList<RemoteViews>();
    final int userId = mContext.getUserId();
    try {
        if (mPackageName == null) {
            mPackageName = mContext.getPackageName();
        }
        updatedIds = sService.startListening(mCallbacks, mPackageName, mHostId, updatedViews, userId);
    } catch (RemoteException e) {
        throw new RuntimeException("system server dead?", e);
    }
    final int N = updatedIds.length;
    for (int i = 0; i < N; i++) {
        if (updatedViews.get(i) != null) {
            updatedViews.get(i).setUser(new UserHandle(userId));
        }
        updateAppWidgetView(updatedIds[i], updatedViews.get(i), userId);
    }
}
Body of Second Method:
{
    int[] updatedIds;
    ArrayList<RemoteViews> updatedViews = new ArrayList<RemoteViews>();
    try {
        updatedIds = sService.startListening(mCallbacks, mContext.getOpPackageName(), mHostId, updatedViews);
    } catch (RemoteException e) {
        throw new RuntimeException("system server dead?", e);
    }
    final int N = updatedIds.length;
    for (int i = 0; i < N; i++) {
        updateAppWidgetView(updatedIds[i], updatedViews.get(i));
    }
}
------------------------
Find a silently evolved API code:android.widget.FastScroller.transitionToHidden:COMMENT
Method Modifier: private     
Comment:/**
 * Shows nothing.
 */

Body of Frist Method:
{
    if (mDecorAnimation != null) {
        mDecorAnimation.cancel();
    }
    final Animator fadeOut = groupAnimatorOfFloat(View.ALPHA, 0f, mThumbImage, mTrackImage, mPreviewImage, mPrimaryText, mSecondaryText).setDuration(DURATION_FADE_OUT);
    // Push the thumb and track outside the list bounds.
    final float offset = mLayoutFromRight ? mThumbImage.getWidth() : -mThumbImage.getWidth();
    final Animator slideOut = groupAnimatorOfFloat(View.TRANSLATION_X, offset, mThumbImage, mTrackImage).setDuration(DURATION_FADE_OUT);
    mDecorAnimation = new AnimatorSet();
    mDecorAnimation.playTogether(fadeOut, slideOut);
    mDecorAnimation.start();
}
Body of Second Method:
{
    if (mDecorAnimation != null) {
        mDecorAnimation.cancel();
    }
    final Animator fadeOut = groupAnimatorOfFloat(View.ALPHA, 0f, mThumbImage, mTrackImage, mPreviewImage, mPrimaryText, mSecondaryText).setDuration(DURATION_FADE_OUT);
    // Push the thumb and track outside the list bounds.
    final float offset = mLayoutFromRight ? mThumbImage.getWidth() : -mThumbImage.getWidth();
    final Animator slideOut = groupAnimatorOfFloat(View.TRANSLATION_X, offset, mThumbImage, mTrackImage).setDuration(DURATION_FADE_OUT);
    mDecorAnimation = new AnimatorSet();
    mDecorAnimation.playTogether(fadeOut, slideOut);
    mDecorAnimation.start();
    mShowingPreview = false;
}
------------------------
Find a silently evolved API code:android.app.Activity.invalidateOptionsMenu:COMMENT
Method Modifier: public      
Comment:/**
 * Declare that the options menu has changed, so should be recreated.
 * The {@link #onCreateOptionsMenu(Menu)} method will be called the next
 * time it needs to be displayed.
 */

Body of Frist Method:
{
    mWindow.invalidatePanelMenu(Window.FEATURE_OPTIONS_PANEL);
}
Body of Second Method:
{
    if (mActionBar == null || !mActionBar.invalidateOptionsMenu()) {
        mWindow.invalidatePanelMenu(Window.FEATURE_OPTIONS_PANEL);
    }
}
------------------------
Find a silently evolved API code:android.app.SearchDialog.createContentView:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * We recreate the dialog view each time it becomes visible so as to limit
 * the scope of any problems with the contained resources.
 */

Body of Frist Method:
{
    setContentView(com.android.internal.R.layout.search_bar);
    // get the view elements for local access
    SearchBar searchBar = (SearchBar) findViewById(com.android.internal.R.id.search_bar);
    searchBar.setSearchDialog(this);
    mSearchView = (SearchView) findViewById(com.android.internal.R.id.search_view);
    mSearchView.setIconified(false);
    mSearchView.setOnCloseListener(mOnCloseListener);
    mSearchView.setOnQueryTextListener(mOnQueryChangeListener);
    mSearchView.setOnSuggestionListener(mOnSuggestionSelectionListener);
    mSearchView.onActionViewExpanded();
    mCloseSearch = findViewById(com.android.internal.R.id.closeButton);
    mCloseSearch.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            dismiss();
        }
    });
    // TODO: Move the badge logic to SearchView or move the badge to search_bar.xml
    mBadgeLabel = (TextView) mSearchView.findViewById(com.android.internal.R.id.search_badge);
    mSearchAutoComplete = (AutoCompleteTextView) mSearchView.findViewById(com.android.internal.R.id.search_src_text);
    mAppIcon = (ImageView) findViewById(com.android.internal.R.id.search_app_icon);
    mSearchPlate = mSearchView.findViewById(com.android.internal.R.id.search_plate);
    mWorkingSpinner = getContext().getResources().getDrawable(com.android.internal.R.drawable.search_spinner);
    // TODO: Restore the spinner for slow suggestion lookups
    // mSearchAutoComplete.setCompoundDrawablesWithIntrinsicBounds(
    // null, null, mWorkingSpinner, null);
    setWorking(false);
    // pre-hide all the extraneous elements
    mBadgeLabel.setVisibility(View.GONE);
    // Additional adjustments to make Dialog work for Search
    mSearchAutoCompleteImeOptions = mSearchAutoComplete.getImeOptions();
}
Body of Second Method:
{
    setContentView(com.android.internal.R.layout.search_bar);
    // get the view elements for local access
    SearchBar searchBar = (SearchBar) findViewById(com.android.internal.R.id.search_bar);
    searchBar.setSearchDialog(this);
    mSearchView = (SearchView) findViewById(com.android.internal.R.id.search_view);
    mSearchView.setIconified(false);
    mSearchView.setOnCloseListener(mOnCloseListener);
    mSearchView.setOnQueryTextListener(mOnQueryChangeListener);
    mSearchView.setOnSuggestionListener(mOnSuggestionSelectionListener);
    mSearchView.onActionViewExpanded();
    mCloseSearch = findViewById(com.android.internal.R.id.closeButton);
    mCloseSearch.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            dismiss();
        }
    });
    // TODO: Move the badge logic to SearchView or move the badge to search_bar.xml
    mBadgeLabel = (TextView) mSearchView.findViewById(com.android.internal.R.id.search_badge);
    mSearchAutoComplete = (AutoCompleteTextView) mSearchView.findViewById(com.android.internal.R.id.search_src_text);
    mAppIcon = (ImageView) findViewById(com.android.internal.R.id.search_app_icon);
    mSearchPlate = mSearchView.findViewById(com.android.internal.R.id.search_plate);
    mWorkingSpinner = getContext().getDrawable(com.android.internal.R.drawable.search_spinner);
    // TODO: Restore the spinner for slow suggestion lookups
    // mSearchAutoComplete.setCompoundDrawablesWithIntrinsicBounds(
    // null, null, mWorkingSpinner, null);
    setWorking(false);
    // pre-hide all the extraneous elements
    mBadgeLabel.setVisibility(View.GONE);
    // Additional adjustments to make Dialog work for Search
    mSearchAutoCompleteImeOptions = mSearchAutoComplete.getImeOptions();
}
------------------------
Find a silently evolved API code:android.printservice.PrintJob.getAdvancedIntOption:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the value of an advanced (printer specific) print option.
 *
 * @param key The option key.
 * @return The option value.
 */

Body of Frist Method:
{
    PrintService.throwIfNotCalledOnMainThread();
    return 0;
}
Body of Second Method:
{
    PrintService.throwIfNotCalledOnMainThread();
    return getInfo().getAdvancedIntOption(key);
}
------------------------
Find a silently evolved API code:android.os.StrictMode.writeGatheredViolationsToParcel:COMMENT
Method Modifier: default     static      
Comment:/* package */

Body of Frist Method:
{
    ArrayList<ViolationInfo> violations = gatheredViolations.get();
    if (violations == null) {
        p.writeInt(0);
    } else {
        p.writeInt(violations.size());
        for (int i = 0; i < violations.size(); ++i) {
            violations.get(i).writeToParcel(p, 0);
        }
        if (LOG_V)
            Log.d(TAG, "wrote violations to response parcel; num=" + violations.size());
        // somewhat redundant, as we're about to null the threadlocal
        violations.clear();
    }
    gatheredViolations.set(null);
}
Body of Second Method:
{
    ArrayList<ViolationInfo> violations = gatheredViolations.get();
    if (violations == null) {
        p.writeInt(0);
    } else {
        p.writeInt(violations.size());
        for (int i = 0; i < violations.size(); ++i) {
            int start = p.dataPosition();
            violations.get(i).writeToParcel(p, 0);
            int size = p.dataPosition() - start;
            if (size > 10 * 1024) {
                Slog.d(TAG, "Wrote violation #" + i + " of " + violations.size() + ": " + (p.dataPosition() - start) + " bytes");
            }
        }
        if (LOG_V)
            Log.d(TAG, "wrote violations to response parcel; num=" + violations.size());
        // somewhat redundant, as we're about to null the threadlocal
        violations.clear();
    }
    gatheredViolations.set(null);
}
------------------------
Find a silently evolved API code:android.content.RestrictionEntry.getKey:COMMENT
Method Modifier: public      
Comment:/**
 * This is the unique key for the restriction entry.
 * @return the key for the restriction.
 */

Body of Frist Method:
{
    return key;
}
Body of Second Method:
{
    return mKey;
}
------------------------
Find a silently evolved API code:android.media.MediaRouter.removeRouteInt:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide internal use only
 */

Body of Frist Method:
{
    removeRoute(info);
}
Body of Second Method:
{
    removeRouteStatic(info);
}
------------------------
Find a silently evolved API code:android.media.AudioService.adjustStreamVolume:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @see AudioManager#adjustStreamVolume(int, int, int)
 */

Body of Frist Method:
{
    if (mUseFixedVolume) {
        return;
    }
    if (DEBUG_VOL)
        Log.d(TAG, "adjustStreamVolume() stream=" + streamType + ", dir=" + direction);
    ensureValidDirection(direction);
    ensureValidStreamType(streamType);
    // use stream type alias here so that streams with same alias have the same behavior,
    // including with regard to silent mode control (e.g the use of STREAM_RING below and in
    // checkForRingerModeChange() in place of STREAM_RING or STREAM_NOTIFICATION)
    int streamTypeAlias = mStreamVolumeAlias[streamType];
    VolumeStreamState streamState = mStreamStates[streamTypeAlias];
    final int device = getDeviceForStream(streamTypeAlias);
    int aliasIndex = streamState.getIndex(device);
    boolean adjustVolume = true;
    int step;
    // is not an a2dp device
    if ((device & AudioSystem.DEVICE_OUT_ALL_A2DP) == 0 && (flags & AudioManager.FLAG_BLUETOOTH_ABS_VOLUME) != 0) {
        return;
    }
    if (mAppOps.noteOp(STEAM_VOLUME_OPS[streamTypeAlias], Binder.getCallingUid(), callingPackage) != AppOpsManager.MODE_ALLOWED) {
        return;
    }
    // reset any pending volume command
    synchronized (mSafeMediaVolumeState) {
        mPendingVolumeCommand = null;
    }
    flags &= ~AudioManager.FLAG_FIXED_VOLUME;
    if ((streamTypeAlias == AudioSystem.STREAM_MUSIC) && ((device & mFixedVolumeDevices) != 0)) {
        flags |= AudioManager.FLAG_FIXED_VOLUME;
        // This is simulated by stepping by the full allowed volume range
        if (mSafeMediaVolumeState == SAFE_MEDIA_VOLUME_ACTIVE && (device & mSafeMediaVolumeDevices) != 0) {
            step = mSafeMediaVolumeIndex;
        } else {
            step = streamState.getMaxIndex();
        }
        if (aliasIndex != 0) {
            aliasIndex = step;
        }
    } else {
        // convert one UI step (+/-1) into a number of internal units on the stream alias
        step = rescaleIndex(10, streamType, streamTypeAlias);
    }
    // or the stream type is one that is affected by ringer modes
    if (((flags & AudioManager.FLAG_ALLOW_RINGER_MODES) != 0) || (streamTypeAlias == getMasterStreamType())) {
        int ringerMode = getRingerMode();
        // do not vibrate if already in vibrate mode
        if (ringerMode == AudioManager.RINGER_MODE_VIBRATE) {
            flags &= ~AudioManager.FLAG_VIBRATE;
        }
        // Check if the ringer mode changes with this volume adjustment. If
        // it does, it will handle adjusting the volume, so we won't below
        adjustVolume = checkForRingerModeChange(aliasIndex, direction, step);
    }
    int oldIndex = mStreamStates[streamType].getIndex(device);
    if (adjustVolume && (direction != AudioManager.ADJUST_SAME)) {
        // Check if volume update should be send to AVRCP
        if (streamTypeAlias == AudioSystem.STREAM_MUSIC && (device & AudioSystem.DEVICE_OUT_ALL_A2DP) != 0 && (flags & AudioManager.FLAG_BLUETOOTH_ABS_VOLUME) == 0) {
            synchronized (mA2dpAvrcpLock) {
                if (mA2dp != null && mAvrcpAbsVolSupported) {
                    mA2dp.adjustAvrcpAbsoluteVolume(direction);
                }
            }
        }
        if ((direction == AudioManager.ADJUST_RAISE) && !checkSafeMediaVolume(streamTypeAlias, aliasIndex + step, device)) {
            Log.e(TAG, "adjustStreamVolume() safe volume index = " + oldIndex);
            mVolumePanel.postDisplaySafeVolumeWarning(flags);
        } else if (streamState.adjustIndex(direction * step, device)) {
            // Post message to set system volume (it in turn will post a message
            // to persist). Do not change volume if stream is muted.
            sendMsg(mAudioHandler, MSG_SET_DEVICE_VOLUME, SENDMSG_QUEUE, device, 0, streamState, 0);
        }
    }
    int index = mStreamStates[streamType].getIndex(device);
    sendVolumeUpdate(streamType, oldIndex, index, flags);
}
Body of Second Method:
{
    adjustStreamVolume(streamType, direction, flags, callingPackage, Binder.getCallingUid());
}
------------------------
Find a silently evolved API code:android.content.res.Resources.obtainTypedArray:COMMENT
Method Modifier: public      
Comment:/**
 * Return an array of heterogeneous values.
 *
 * @param id The desired resource identifier, as generated by the aapt
 * tool. This integer encodes the package, type, and resource
 * entry. The value 0 is an invalid identifier.
 *
 * @throws NotFoundException Throws NotFoundException if the given ID does not exist.
 *
 * @return Returns a TypedArray holding an array of the array values.
 * Be sure to call {@link TypedArray#recycle() TypedArray.recycle()}
 * when done with it.
 */

Body of Frist Method:
{
    int len = mAssets.getArraySize(id);
    if (len < 0) {
        throw new NotFoundException("Array resource ID #0x" + Integer.toHexString(id));
    }
    TypedArray array = getCachedStyledAttributes(len);
    array.mLength = mAssets.retrieveArray(id, array.mData);
    array.mIndices[0] = 0;
    return array;
}
Body of Second Method:
{
    int len = mAssets.getArraySize(id);
    if (len < 0) {
        throw new NotFoundException("Array resource ID #0x" + Integer.toHexString(id));
    }
    TypedArray array = TypedArray.obtain(this, len);
    array.mLength = mAssets.retrieveArray(id, array.mData);
    array.mIndices[0] = 0;
    return array;
}
------------------------
Find a silently evolved API code:android.net.LinkProperties.writeToParcel:COMMENT
<android.net.LinkProperties: void writeToParcel(Parcel,int)>
public      hidden      ->public      
Method Modifier: public      hidden      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * Implement the Parcelable interface.
 */

Body of Frist Method:
{
    dest.writeString(getInterfaceName());
    dest.writeInt(mLinkAddresses.size());
    for (LinkAddress linkAddress : mLinkAddresses) {
        dest.writeParcelable(linkAddress, flags);
    }
    dest.writeInt(mDnses.size());
    for (InetAddress d : mDnses) {
        dest.writeByteArray(d.getAddress());
    }
    dest.writeString(mDomains);
    dest.writeInt(mMtu);
    dest.writeInt(mRoutes.size());
    for (RouteInfo route : mRoutes) {
        dest.writeParcelable(route, flags);
    }
    if (mHttpProxy != null) {
        dest.writeByte((byte) 1);
        dest.writeParcelable(mHttpProxy, flags);
    } else {
        dest.writeByte((byte) 0);
    }
    ArrayList<LinkProperties> stackedLinks = new ArrayList(mStackedLinks.values());
    dest.writeList(stackedLinks);
}
Body of Second Method:
{
    dest.writeString(getInterfaceName());
    dest.writeInt(mLinkAddresses.size());
    for (LinkAddress linkAddress : mLinkAddresses) {
        dest.writeParcelable(linkAddress, flags);
    }
    dest.writeInt(mDnses.size());
    for (InetAddress d : mDnses) {
        dest.writeByteArray(d.getAddress());
    }
    dest.writeString(mDomains);
    dest.writeInt(mMtu);
    dest.writeString(mTcpBufferSizes);
    dest.writeInt(mRoutes.size());
    for (RouteInfo route : mRoutes) {
        dest.writeParcelable(route, flags);
    }
    if (mHttpProxy != null) {
        dest.writeByte((byte) 1);
        dest.writeParcelable(mHttpProxy, flags);
    } else {
        dest.writeByte((byte) 0);
    }
    ArrayList<LinkProperties> stackedLinks = new ArrayList(mStackedLinks.values());
    dest.writeList(stackedLinks);
}
------------------------
Find a silently evolved API code:android.media.MediaFocusControl.rcDisplayIsPluggedIn_syncRcStack:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Is the remote control display interface already registered
 * @param rcd
 * @return true if the IRemoteControlDisplay is already in the list of displays
 */

Body of Frist Method:
{
    final Iterator<DisplayInfoForServer> displayIterator = mRcDisplays.iterator();
    while (displayIterator.hasNext()) {
        final DisplayInfoForServer di = (DisplayInfoForServer) displayIterator.next();
        if (di.mRcDisplay.asBinder().equals(rcd.asBinder())) {
            return true;
        }
    }
    return false;
}
Body of Second Method:
{
    final Iterator<DisplayInfoForServer> displayIterator = mRcDisplays.iterator();
    while (displayIterator.hasNext()) {
        final DisplayInfoForServer di = displayIterator.next();
        if (di.mRcDisplay.asBinder().equals(rcd.asBinder())) {
            return true;
        }
    }
    return false;
}
------------------------
Find a silently evolved API code:android.ddm.DdmHandleHello.handleHELO:COMMENT
Method Modifier: private     
Comment:/*
     * Handle introductory packet. This is called during JNI_CreateJavaVM
     * before frameworks native methods are registered, so be careful not
     * to call any APIs that depend on frameworks native code.
     */

Body of Frist Method:
{
    if (false)
        return createFailChunk(123, "This is a test");
    /*
         * Process the request.
         */
    ByteBuffer in = wrapChunk(request);
    int serverProtoVers = in.getInt();
    if (false)
        Log.v("ddm-hello", "Server version is " + serverProtoVers);
    /*
         * Create a response.
         */
    String vmName = System.getProperty("java.vm.name", "?");
    String vmVersion = System.getProperty("java.vm.version", "?");
    String vmIdent = vmName + " v" + vmVersion;
    // String appName = android.app.ActivityThread.currentPackageName();
    // if (appName == null)
    // appName = "unknown";
    String appName = DdmHandleAppName.getAppName();
    ByteBuffer out = ByteBuffer.allocate(20 + vmIdent.length() * 2 + appName.length() * 2);
    out.order(ChunkHandler.CHUNK_ORDER);
    out.putInt(DdmServer.CLIENT_PROTOCOL_VERSION);
    out.putInt(android.os.Process.myPid());
    out.putInt(vmIdent.length());
    out.putInt(appName.length());
    putString(out, vmIdent);
    putString(out, appName);
    out.putInt(UserHandle.myUserId());
    Chunk reply = new Chunk(CHUNK_HELO, out);
    /*
         * Take the opportunity to inform DDMS if we are waiting for a
         * debugger to attach.
         */
    if (Debug.waitingForDebugger())
        sendWAIT(0);
    return reply;
}
Body of Second Method:
{
    if (false)
        return createFailChunk(123, "This is a test");
    /*
         * Process the request.
         */
    ByteBuffer in = wrapChunk(request);
    int serverProtoVers = in.getInt();
    if (false)
        Log.v("ddm-hello", "Server version is " + serverProtoVers);
    /*
         * Create a response.
         */
    String vmName = System.getProperty("java.vm.name", "?");
    String vmVersion = System.getProperty("java.vm.version", "?");
    String vmIdent = vmName + " v" + vmVersion;
    // String appName = android.app.ActivityThread.currentPackageName();
    // if (appName == null)
    // appName = "unknown";
    String appName = DdmHandleAppName.getAppName();
    VMRuntime vmRuntime = VMRuntime.getRuntime();
    String instructionSetDescription = vmRuntime.is64Bit() ? "64-bit" : "32-bit";
    String vmInstructionSet = vmRuntime.vmInstructionSet();
    if (vmInstructionSet != null && vmInstructionSet.length() > 0) {
        instructionSetDescription += " (" + vmInstructionSet + ")";
    }
    String vmFlags = "CheckJNI=" + (vmRuntime.isCheckJniEnabled() ? "true" : "false");
    ByteBuffer out = ByteBuffer.allocate(28 + vmIdent.length() * 2 + appName.length() * 2 + instructionSetDescription.length() * 2 + vmFlags.length() * 2);
    out.order(ChunkHandler.CHUNK_ORDER);
    out.putInt(DdmServer.CLIENT_PROTOCOL_VERSION);
    out.putInt(android.os.Process.myPid());
    out.putInt(vmIdent.length());
    out.putInt(appName.length());
    putString(out, vmIdent);
    putString(out, appName);
    out.putInt(UserHandle.myUserId());
    out.putInt(instructionSetDescription.length());
    putString(out, instructionSetDescription);
    out.putInt(vmFlags.length());
    putString(out, vmFlags);
    Chunk reply = new Chunk(CHUNK_HELO, out);
    /*
         * Take the opportunity to inform DDMS if we are waiting for a
         * debugger to attach.
         */
    if (Debug.waitingForDebugger())
        sendWAIT(0);
    return reply;
}
------------------------
Find a silently evolved API code:android.widget.ActivityChooserView.updateAppearance:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Updates the buttons state.
 */

Body of Frist Method:
{
    // Expand overflow button.
    if (mAdapter.getCount() > 0) {
        mExpandActivityOverflowButton.setEnabled(true);
    } else {
        mExpandActivityOverflowButton.setEnabled(false);
    }
    // Default activity button.
    final int activityCount = mAdapter.getActivityCount();
    final int historySize = mAdapter.getHistorySize();
    if (activityCount == 1 || activityCount > 1 && historySize > 0) {
        mDefaultActivityButton.setVisibility(VISIBLE);
        ResolveInfo activity = mAdapter.getDefaultActivity();
        PackageManager packageManager = mContext.getPackageManager();
        mDefaultActivityButtonImage.setImageDrawable(activity.loadIcon(packageManager));
        if (mDefaultActionButtonContentDescription != 0) {
            CharSequence label = activity.loadLabel(packageManager);
            String contentDescription = mContext.getString(mDefaultActionButtonContentDescription, label);
            mDefaultActivityButton.setContentDescription(contentDescription);
        }
    } else {
        mDefaultActivityButton.setVisibility(View.GONE);
    }
    // Activity chooser content.
    if (mDefaultActivityButton.getVisibility() == VISIBLE) {
        mActivityChooserContent.setBackgroundDrawable(mActivityChooserContentBackground);
    } else {
        mActivityChooserContent.setBackgroundDrawable(null);
    }
}
Body of Second Method:
{
    // Expand overflow button.
    if (mAdapter.getCount() > 0) {
        mExpandActivityOverflowButton.setEnabled(true);
    } else {
        mExpandActivityOverflowButton.setEnabled(false);
    }
    // Default activity button.
    final int activityCount = mAdapter.getActivityCount();
    final int historySize = mAdapter.getHistorySize();
    if (activityCount == 1 || activityCount > 1 && historySize > 0) {
        mDefaultActivityButton.setVisibility(VISIBLE);
        ResolveInfo activity = mAdapter.getDefaultActivity();
        PackageManager packageManager = mContext.getPackageManager();
        mDefaultActivityButtonImage.setImageDrawable(activity.loadIcon(packageManager));
        if (mDefaultActionButtonContentDescription != 0) {
            CharSequence label = activity.loadLabel(packageManager);
            String contentDescription = mContext.getString(mDefaultActionButtonContentDescription, label);
            mDefaultActivityButton.setContentDescription(contentDescription);
        }
    } else {
        mDefaultActivityButton.setVisibility(View.GONE);
    }
    // Activity chooser content.
    if (mDefaultActivityButton.getVisibility() == VISIBLE) {
        mActivityChooserContent.setBackground(mActivityChooserContentBackground);
    } else {
        mActivityChooserContent.setBackground(null);
    }
}
------------------------
Find a silently evolved API code:android.view.KeyEvent.keyCodeToString:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns a string that represents the symbolic name of the specified keycode
 * such as "KEYCODE_A", "KEYCODE_DPAD_UP", or an equivalent numeric constant
 * such as "1001" if unknown.
 *
 * @param keyCode The key code.
 * @return The symbolic name of the specified keycode.
 *
 * @see KeyCharacterMap#getDisplayLabel
 */

Body of Frist Method:
{
    String symbolicName = KEYCODE_SYMBOLIC_NAMES.get(keyCode);
    return symbolicName != null ? symbolicName : Integer.toString(keyCode);
}
Body of Second Method:
{
    String symbolicName = nativeKeyCodeToString(keyCode);
    return symbolicName != null ? LABEL_PREFIX + symbolicName : Integer.toString(keyCode);
}
------------------------
Find a silently evolved API code:android.widget.RelativeLayout.getChildMeasureSpec:COMMENT
Method Modifier: private     
Comment:/**
 * Get a measure spec that accounts for all of the constraints on this view.
 * This includes size constraints imposed by the RelativeLayout as well as
 * the View's desired dimension.
 *
 * @param childStart The left or top field of the child's layout params
 * @param childEnd The right or bottom field of the child's layout params
 * @param childSize The child's desired size (the width or height field of
 * the child's layout params)
 * @param startMargin The left or top margin
 * @param endMargin The right or bottom margin
 * @param startPadding mPaddingLeft or mPaddingTop
 * @param endPadding mPaddingRight or mPaddingBottom
 * @param mySize The width or height of this view (the RelativeLayout)
 * @return MeasureSpec for the child
 */

Body of Frist Method:
{
    if (mySize < 0 && !mAllowBrokenMeasureSpecs) {
        if (childSize >= 0) {
            return MeasureSpec.makeMeasureSpec(childSize, MeasureSpec.EXACTLY);
        }
        // Carry it forward.
        return MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);
    }
    int childSpecMode = 0;
    int childSpecSize = 0;
    // Figure out start and end bounds.
    int tempStart = childStart;
    int tempEnd = childEnd;
    // view's margins and our padding
    if (tempStart < 0) {
        tempStart = startPadding + startMargin;
    }
    if (tempEnd < 0) {
        tempEnd = mySize - endPadding - endMargin;
    }
    // Figure out maximum size available to this view
    int maxAvailable = tempEnd - tempStart;
    if (childStart >= 0 && childEnd >= 0) {
        // Constraints fixed both edges, so child must be an exact size
        childSpecMode = MeasureSpec.EXACTLY;
        childSpecSize = maxAvailable;
    } else {
        if (childSize >= 0) {
            // Child wanted an exact size. Give as much as possible
            childSpecMode = MeasureSpec.EXACTLY;
            if (maxAvailable >= 0) {
                // We have a maxmum size in this dimension.
                childSpecSize = Math.min(maxAvailable, childSize);
            } else {
                // We can grow in this dimension.
                childSpecSize = childSize;
            }
        } else if (childSize == LayoutParams.MATCH_PARENT) {
            // Child wanted to be as big as possible. Give all available
            // space
            childSpecMode = MeasureSpec.EXACTLY;
            childSpecSize = maxAvailable;
        } else if (childSize == LayoutParams.WRAP_CONTENT) {
            // our max size
            if (maxAvailable >= 0) {
                // We have a maximum size in this dimension.
                childSpecMode = MeasureSpec.AT_MOST;
                childSpecSize = maxAvailable;
            } else {
                // We can grow in this dimension. Child can be as big as it
                // wants
                childSpecMode = MeasureSpec.UNSPECIFIED;
                childSpecSize = 0;
            }
        }
    }
    return MeasureSpec.makeMeasureSpec(childSpecSize, childSpecMode);
}
Body of Second Method:
{
    int childSpecMode = 0;
    int childSpecSize = 0;
    // RelativeLayout's measure spec."
    if (mySize < 0 && !mAllowBrokenMeasureSpecs) {
        if (childStart != VALUE_NOT_SET && childEnd != VALUE_NOT_SET) {
            // Constraints fixed both edges, so child has an exact size.
            childSpecSize = Math.max(0, childEnd - childStart);
            childSpecMode = MeasureSpec.EXACTLY;
        } else if (childSize >= 0) {
            // The child specified an exact size.
            childSpecSize = childSize;
            childSpecMode = MeasureSpec.EXACTLY;
        } else {
            // Allow the child to be whatever size it wants.
            childSpecSize = 0;
            childSpecMode = MeasureSpec.UNSPECIFIED;
        }
        return MeasureSpec.makeMeasureSpec(childSpecSize, childSpecMode);
    }
    // Figure out start and end bounds.
    int tempStart = childStart;
    int tempEnd = childEnd;
    // view's margins and our padding
    if (tempStart == VALUE_NOT_SET) {
        tempStart = startPadding + startMargin;
    }
    if (tempEnd == VALUE_NOT_SET) {
        tempEnd = mySize - endPadding - endMargin;
    }
    // Figure out maximum size available to this view
    int maxAvailable = tempEnd - tempStart;
    if (childStart != VALUE_NOT_SET && childEnd != VALUE_NOT_SET) {
        // Constraints fixed both edges, so child must be an exact size
        childSpecMode = MeasureSpec.EXACTLY;
        childSpecSize = maxAvailable;
    } else {
        if (childSize >= 0) {
            // Child wanted an exact size. Give as much as possible
            childSpecMode = MeasureSpec.EXACTLY;
            if (maxAvailable >= 0) {
                // We have a maxmum size in this dimension.
                childSpecSize = Math.min(maxAvailable, childSize);
            } else {
                // We can grow in this dimension.
                childSpecSize = childSize;
            }
        } else if (childSize == LayoutParams.MATCH_PARENT) {
            // Child wanted to be as big as possible. Give all available
            // space
            childSpecMode = MeasureSpec.EXACTLY;
            childSpecSize = maxAvailable;
        } else if (childSize == LayoutParams.WRAP_CONTENT) {
            // our max size
            if (maxAvailable >= 0) {
                // We have a maximum size in this dimension.
                childSpecMode = MeasureSpec.AT_MOST;
                childSpecSize = maxAvailable;
            } else {
                // We can grow in this dimension. Child can be as big as it
                // wants
                childSpecMode = MeasureSpec.UNSPECIFIED;
                childSpecSize = 0;
            }
        }
    }
    return MeasureSpec.makeMeasureSpec(childSpecSize, childSpecMode);
}
------------------------
Find a silently evolved API code:android.view.textservice.TextInfo.getSequence:COMMENT
Method Modifier: public      
Comment:/**
 * @return the sequence of TextInfo
 */

Body of Frist Method:
{
    return mSequence;
}
Body of Second Method:
{
    return mSequenceNumber;
}
------------------------
Find a silently evolved API code:android.view.ViewGroup.dispatchHoverEvent:COMMENT
Method Modifier: protected   
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    final int action = event.getAction();
    // First check whether the view group wants to intercept the hover event.
    final boolean interceptHover = onInterceptHoverEvent(event);
    // restore action in case it was changed
    event.setAction(action);
    MotionEvent eventNoHistory = event;
    boolean handled = false;
    // Send events to the hovered children and build a new list of hover targets until
    // one is found that handles the event.
    HoverTarget firstOldHoverTarget = mFirstHoverTarget;
    mFirstHoverTarget = null;
    if (!interceptHover && action != MotionEvent.ACTION_HOVER_EXIT) {
        final float x = event.getX();
        final float y = event.getY();
        final int childrenCount = mChildrenCount;
        if (childrenCount != 0) {
            final boolean customChildOrder = isChildrenDrawingOrderEnabled();
            final View[] children = mChildren;
            HoverTarget lastHoverTarget = null;
            for (int i = childrenCount - 1; i >= 0; i--) {
                final int childIndex = customChildOrder ? getChildDrawingOrder(childrenCount, i) : i;
                final View child = children[childIndex];
                if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) {
                    continue;
                }
                // Obtain a hover target for this child.  Dequeue it from the
                // old hover target list if the child was previously hovered.
                HoverTarget hoverTarget = firstOldHoverTarget;
                final boolean wasHovered;
                for (HoverTarget predecessor = null; ; ) {
                    if (hoverTarget == null) {
                        hoverTarget = HoverTarget.obtain(child);
                        wasHovered = false;
                        break;
                    }
                    if (hoverTarget.child == child) {
                        if (predecessor != null) {
                            predecessor.next = hoverTarget.next;
                        } else {
                            firstOldHoverTarget = hoverTarget.next;
                        }
                        hoverTarget.next = null;
                        wasHovered = true;
                        break;
                    }
                    predecessor = hoverTarget;
                    hoverTarget = hoverTarget.next;
                }
                // Enqueue the hover target onto the new hover target list.
                if (lastHoverTarget != null) {
                    lastHoverTarget.next = hoverTarget;
                } else {
                    mFirstHoverTarget = hoverTarget;
                }
                lastHoverTarget = hoverTarget;
                // Dispatch the event to the child.
                if (action == MotionEvent.ACTION_HOVER_ENTER) {
                    if (!wasHovered) {
                        // Send the enter as is.
                        handled |= dispatchTransformedGenericPointerEvent(event, // enter
                        child);
                    }
                } else if (action == MotionEvent.ACTION_HOVER_MOVE) {
                    if (!wasHovered) {
                        // Synthesize an enter from a move.
                        eventNoHistory = obtainMotionEventNoHistoryOrSelf(eventNoHistory);
                        eventNoHistory.setAction(MotionEvent.ACTION_HOVER_ENTER);
                        handled |= dispatchTransformedGenericPointerEvent(eventNoHistory, // enter
                        child);
                        eventNoHistory.setAction(action);
                        handled |= dispatchTransformedGenericPointerEvent(eventNoHistory, // move
                        child);
                    } else {
                        // Send the move as is.
                        handled |= dispatchTransformedGenericPointerEvent(event, child);
                    }
                }
                if (handled) {
                    break;
                }
            }
        }
    }
    // Send exit events to all previously hovered children that are no longer hovered.
    while (firstOldHoverTarget != null) {
        final View child = firstOldHoverTarget.child;
        // Exit the old hovered child.
        if (action == MotionEvent.ACTION_HOVER_EXIT) {
            // Send the exit as is.
            handled |= dispatchTransformedGenericPointerEvent(event, // exit
            child);
        } else {
            // Ignore the result because hover focus has moved to a different view.
            if (action == MotionEvent.ACTION_HOVER_MOVE) {
                dispatchTransformedGenericPointerEvent(event, // move
                child);
            }
            eventNoHistory = obtainMotionEventNoHistoryOrSelf(eventNoHistory);
            eventNoHistory.setAction(MotionEvent.ACTION_HOVER_EXIT);
            dispatchTransformedGenericPointerEvent(eventNoHistory, // exit
            child);
            eventNoHistory.setAction(action);
        }
        final HoverTarget nextOldHoverTarget = firstOldHoverTarget.next;
        firstOldHoverTarget.recycle();
        firstOldHoverTarget = nextOldHoverTarget;
    }
    // Send events to the view group itself if no children have handled it.
    boolean newHoveredSelf = !handled;
    if (newHoveredSelf == mHoveredSelf) {
        if (newHoveredSelf) {
            // Send event to the view group as before.
            handled |= super.dispatchHoverEvent(event);
        }
    } else {
        if (mHoveredSelf) {
            // Exit the view group.
            if (action == MotionEvent.ACTION_HOVER_EXIT) {
                // Send the exit as is.
                // exit
                handled |= super.dispatchHoverEvent(event);
            } else {
                // Ignore the result because hover focus is moving to a different view.
                if (action == MotionEvent.ACTION_HOVER_MOVE) {
                    // move
                    super.dispatchHoverEvent(event);
                }
                eventNoHistory = obtainMotionEventNoHistoryOrSelf(eventNoHistory);
                eventNoHistory.setAction(MotionEvent.ACTION_HOVER_EXIT);
                // exit
                super.dispatchHoverEvent(eventNoHistory);
                eventNoHistory.setAction(action);
            }
            mHoveredSelf = false;
        }
        if (newHoveredSelf) {
            // Enter the view group.
            if (action == MotionEvent.ACTION_HOVER_ENTER) {
                // Send the enter as is.
                // enter
                handled |= super.dispatchHoverEvent(event);
                mHoveredSelf = true;
            } else if (action == MotionEvent.ACTION_HOVER_MOVE) {
                // Synthesize an enter from a move.
                eventNoHistory = obtainMotionEventNoHistoryOrSelf(eventNoHistory);
                eventNoHistory.setAction(MotionEvent.ACTION_HOVER_ENTER);
                // enter
                handled |= super.dispatchHoverEvent(eventNoHistory);
                eventNoHistory.setAction(action);
                // move
                handled |= super.dispatchHoverEvent(eventNoHistory);
                mHoveredSelf = true;
            }
        }
    }
    // Recycle the copy of the event that we made.
    if (eventNoHistory != event) {
        eventNoHistory.recycle();
    }
    // Done.
    return handled;
}
Body of Second Method:
{
    final int action = event.getAction();
    // First check whether the view group wants to intercept the hover event.
    final boolean interceptHover = onInterceptHoverEvent(event);
    // restore action in case it was changed
    event.setAction(action);
    MotionEvent eventNoHistory = event;
    boolean handled = false;
    // Send events to the hovered children and build a new list of hover targets until
    // one is found that handles the event.
    HoverTarget firstOldHoverTarget = mFirstHoverTarget;
    mFirstHoverTarget = null;
    if (!interceptHover && action != MotionEvent.ACTION_HOVER_EXIT) {
        final float x = event.getX();
        final float y = event.getY();
        final int childrenCount = mChildrenCount;
        if (childrenCount != 0) {
            final ArrayList<View> preorderedList = buildOrderedChildList();
            final boolean customOrder = preorderedList == null && isChildrenDrawingOrderEnabled();
            final View[] children = mChildren;
            HoverTarget lastHoverTarget = null;
            for (int i = childrenCount - 1; i >= 0; i--) {
                int childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i;
                final View child = (preorderedList == null) ? children[childIndex] : preorderedList.get(childIndex);
                if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) {
                    continue;
                }
                // Obtain a hover target for this child.  Dequeue it from the
                // old hover target list if the child was previously hovered.
                HoverTarget hoverTarget = firstOldHoverTarget;
                final boolean wasHovered;
                for (HoverTarget predecessor = null; ; ) {
                    if (hoverTarget == null) {
                        hoverTarget = HoverTarget.obtain(child);
                        wasHovered = false;
                        break;
                    }
                    if (hoverTarget.child == child) {
                        if (predecessor != null) {
                            predecessor.next = hoverTarget.next;
                        } else {
                            firstOldHoverTarget = hoverTarget.next;
                        }
                        hoverTarget.next = null;
                        wasHovered = true;
                        break;
                    }
                    predecessor = hoverTarget;
                    hoverTarget = hoverTarget.next;
                }
                // Enqueue the hover target onto the new hover target list.
                if (lastHoverTarget != null) {
                    lastHoverTarget.next = hoverTarget;
                } else {
                    mFirstHoverTarget = hoverTarget;
                }
                lastHoverTarget = hoverTarget;
                // Dispatch the event to the child.
                if (action == MotionEvent.ACTION_HOVER_ENTER) {
                    if (!wasHovered) {
                        // Send the enter as is.
                        handled |= dispatchTransformedGenericPointerEvent(event, // enter
                        child);
                    }
                } else if (action == MotionEvent.ACTION_HOVER_MOVE) {
                    if (!wasHovered) {
                        // Synthesize an enter from a move.
                        eventNoHistory = obtainMotionEventNoHistoryOrSelf(eventNoHistory);
                        eventNoHistory.setAction(MotionEvent.ACTION_HOVER_ENTER);
                        handled |= dispatchTransformedGenericPointerEvent(eventNoHistory, // enter
                        child);
                        eventNoHistory.setAction(action);
                        handled |= dispatchTransformedGenericPointerEvent(eventNoHistory, // move
                        child);
                    } else {
                        // Send the move as is.
                        handled |= dispatchTransformedGenericPointerEvent(event, child);
                    }
                }
                if (handled) {
                    break;
                }
            }
            if (preorderedList != null)
                preorderedList.clear();
        }
    }
    // Send exit events to all previously hovered children that are no longer hovered.
    while (firstOldHoverTarget != null) {
        final View child = firstOldHoverTarget.child;
        // Exit the old hovered child.
        if (action == MotionEvent.ACTION_HOVER_EXIT) {
            // Send the exit as is.
            handled |= dispatchTransformedGenericPointerEvent(event, // exit
            child);
        } else {
            // Ignore the result because hover focus has moved to a different view.
            if (action == MotionEvent.ACTION_HOVER_MOVE) {
                dispatchTransformedGenericPointerEvent(event, // move
                child);
            }
            eventNoHistory = obtainMotionEventNoHistoryOrSelf(eventNoHistory);
            eventNoHistory.setAction(MotionEvent.ACTION_HOVER_EXIT);
            dispatchTransformedGenericPointerEvent(eventNoHistory, // exit
            child);
            eventNoHistory.setAction(action);
        }
        final HoverTarget nextOldHoverTarget = firstOldHoverTarget.next;
        firstOldHoverTarget.recycle();
        firstOldHoverTarget = nextOldHoverTarget;
    }
    // Send events to the view group itself if no children have handled it.
    boolean newHoveredSelf = !handled;
    if (newHoveredSelf == mHoveredSelf) {
        if (newHoveredSelf) {
            // Send event to the view group as before.
            handled |= super.dispatchHoverEvent(event);
        }
    } else {
        if (mHoveredSelf) {
            // Exit the view group.
            if (action == MotionEvent.ACTION_HOVER_EXIT) {
                // Send the exit as is.
                // exit
                handled |= super.dispatchHoverEvent(event);
            } else {
                // Ignore the result because hover focus is moving to a different view.
                if (action == MotionEvent.ACTION_HOVER_MOVE) {
                    // move
                    super.dispatchHoverEvent(event);
                }
                eventNoHistory = obtainMotionEventNoHistoryOrSelf(eventNoHistory);
                eventNoHistory.setAction(MotionEvent.ACTION_HOVER_EXIT);
                // exit
                super.dispatchHoverEvent(eventNoHistory);
                eventNoHistory.setAction(action);
            }
            mHoveredSelf = false;
        }
        if (newHoveredSelf) {
            // Enter the view group.
            if (action == MotionEvent.ACTION_HOVER_ENTER) {
                // Send the enter as is.
                // enter
                handled |= super.dispatchHoverEvent(event);
                mHoveredSelf = true;
            } else if (action == MotionEvent.ACTION_HOVER_MOVE) {
                // Synthesize an enter from a move.
                eventNoHistory = obtainMotionEventNoHistoryOrSelf(eventNoHistory);
                eventNoHistory.setAction(MotionEvent.ACTION_HOVER_ENTER);
                // enter
                handled |= super.dispatchHoverEvent(eventNoHistory);
                eventNoHistory.setAction(action);
                // move
                handled |= super.dispatchHoverEvent(eventNoHistory);
                mHoveredSelf = true;
            }
        }
    }
    // Recycle the copy of the event that we made.
    if (eventNoHistory != event) {
        eventNoHistory.recycle();
    }
    // Done.
    return handled;
}
------------------------
Find a silently evolved API code:android.view.Surface.lockCanvas:COMMENT
Method Modifier: public      
Comment:/**
 * Gets a {@link Canvas} for drawing into this surface.
 *
 * After drawing into the provided {@link Canvas}, the caller must
 * invoke {@link #unlockCanvasAndPost} to post the new contents to the surface.
 *
 * @param inOutDirty A rectangle that represents the dirty region that the caller wants
 * to redraw.  This function may choose to expand the dirty rectangle if for example
 * the surface has been resized or if the previous contents of the surface were
 * not available.  The caller must redraw the entire dirty region as represented
 * by the contents of the inOutDirty rectangle upon return from this function.
 * The caller may also pass <code>null</code> instead, in the case where the
 * entire surface should be redrawn.
 * @return A canvas for drawing into the surface.
 *
 * @throws IllegalArgumentException If the inOutDirty rectangle is not valid.
 * @throws OutOfResourcesException If the canvas cannot be locked.
 */

Body of Frist Method:
{
    synchronized (mLock) {
        checkNotReleasedLocked();
        if (mLockedObject != 0) {
            // we just refuse to re-lock the Surface.
            throw new IllegalStateException("Surface was already locked");
        }
        mLockedObject = nativeLockCanvas(mNativeObject, mCanvas, inOutDirty);
        return mCanvas;
    }
}
Body of Second Method:
{
    synchronized (mLock) {
        checkNotReleasedLocked();
        if (mLockedObject != 0) {
            // we just refuse to re-lock the Surface.
            throw new IllegalArgumentException("Surface was already locked");
        }
        mLockedObject = nativeLockCanvas(mNativeObject, mCanvas, inOutDirty);
        return mCanvas;
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothSocket.bindListen:COMMENT
Method Modifier: default     
Comment:/*package*/

Body of Frist Method:
{
    int ret;
    if (mSocketState == SocketState.CLOSED)
        return EBADFD;
    IBluetooth bluetoothProxy = BluetoothAdapter.getDefaultAdapter().getBluetoothService(null);
    if (bluetoothProxy == null) {
        Log.e(TAG, "bindListen fail, reason: bluetooth is off");
        return -1;
    }
    try {
        mPfd = bluetoothProxy.createSocketChannel(mType, mServiceName, mUuid, mPort, getSecurityFlags());
    } catch (RemoteException e) {
        Log.e(TAG, Log.getStackTraceString(new Throwable()));
        return -1;
    }
    // read out port number
    try {
        synchronized (this) {
            if (VDBG)
                Log.d(TAG, "bindListen(), SocketState: " + mSocketState + ", mPfd: " + mPfd);
            if (mSocketState != SocketState.INIT)
                return EBADFD;
            if (mPfd == null)
                return -1;
            FileDescriptor fd = mPfd.getFileDescriptor();
            if (VDBG)
                Log.d(TAG, "bindListen(), new LocalSocket ");
            mSocket = new LocalSocket(fd);
            if (VDBG)
                Log.d(TAG, "bindListen(), new LocalSocket.getInputStream() ");
            mSocketIS = mSocket.getInputStream();
            mSocketOS = mSocket.getOutputStream();
        }
        if (VDBG)
            Log.d(TAG, "bindListen(), readInt mSocketIS: " + mSocketIS);
        int channel = readInt(mSocketIS);
        synchronized (this) {
            if (mSocketState == SocketState.INIT)
                mSocketState = SocketState.LISTENING;
        }
        if (VDBG)
            Log.d(TAG, "channel: " + channel);
        if (mPort == -1) {
            mPort = channel;
        }
        // else ASSERT(mPort == channel)
        ret = 0;
    } catch (IOException e) {
        Log.e(TAG, "bindListen, fail to get port number, exception: " + e);
        return -1;
    }
    return ret;
}
Body of Second Method:
{
    int ret;
    if (mSocketState == SocketState.CLOSED)
        return EBADFD;
    IBluetooth bluetoothProxy = BluetoothAdapter.getDefaultAdapter().getBluetoothService(null);
    if (bluetoothProxy == null) {
        Log.e(TAG, "bindListen fail, reason: bluetooth is off");
        return -1;
    }
    try {
        mPfd = bluetoothProxy.createSocketChannel(mType, mServiceName, mUuid, mPort, getSecurityFlags());
    } catch (RemoteException e) {
        Log.e(TAG, Log.getStackTraceString(new Throwable()));
        return -1;
    }
    // read out port number
    try {
        synchronized (this) {
            if (DBG)
                Log.d(TAG, "bindListen(), SocketState: " + mSocketState + ", mPfd: " + mPfd);
            if (mSocketState != SocketState.INIT)
                return EBADFD;
            if (mPfd == null)
                return -1;
            FileDescriptor fd = mPfd.getFileDescriptor();
            if (DBG)
                Log.d(TAG, "bindListen(), new LocalSocket ");
            mSocket = new LocalSocket(fd);
            if (DBG)
                Log.d(TAG, "bindListen(), new LocalSocket.getInputStream() ");
            mSocketIS = mSocket.getInputStream();
            mSocketOS = mSocket.getOutputStream();
        }
        if (DBG)
            Log.d(TAG, "bindListen(), readInt mSocketIS: " + mSocketIS);
        int channel = readInt(mSocketIS);
        synchronized (this) {
            if (mSocketState == SocketState.INIT)
                mSocketState = SocketState.LISTENING;
        }
        if (DBG)
            Log.d(TAG, "channel: " + channel);
        if (mPort == -1) {
            mPort = channel;
        }
        // else ASSERT(mPort == channel)
        ret = 0;
    } catch (IOException e) {
        if (mPfd != null) {
            try {
                mPfd.close();
            } catch (IOException e1) {
                Log.e(TAG, "bindListen, close mPfd: " + e1);
            }
            mPfd = null;
        }
        Log.e(TAG, "bindListen, fail to get port number, exception: " + e);
        return -1;
    }
    return ret;
}
------------------------
Find a silently evolved API code:android.appwidget.AppWidgetManager.getAppWidgetInfo:COMMENT
Method Modifier: public      
Comment:/**
 * Get the available info about the AppWidget.
 *
 * @return A appWidgetId.  If the appWidgetId has not been bound to a provider yet, or
 * you don't have access to that appWidgetId, null is returned.
 */

Body of Frist Method:
{
    try {
        AppWidgetProviderInfo info = sService.getAppWidgetInfo(appWidgetId, mContext.getUserId());
        if (info != null) {
            // Converting complex to dp.
            info.minWidth = TypedValue.complexToDimensionPixelSize(info.minWidth, mDisplayMetrics);
            info.minHeight = TypedValue.complexToDimensionPixelSize(info.minHeight, mDisplayMetrics);
            info.minResizeWidth = TypedValue.complexToDimensionPixelSize(info.minResizeWidth, mDisplayMetrics);
            info.minResizeHeight = TypedValue.complexToDimensionPixelSize(info.minResizeHeight, mDisplayMetrics);
        }
        return info;
    } catch (RemoteException e) {
        throw new RuntimeException("system server dead?", e);
    }
}
Body of Second Method:
{
    if (mService == null) {
        return null;
    }
    try {
        AppWidgetProviderInfo info = mService.getAppWidgetInfo(mPackageName, appWidgetId);
        if (info != null) {
            // Converting complex to dp.
            convertSizesToPixels(info);
        }
        return info;
    } catch (RemoteException e) {
        throw new RuntimeException("system server dead?", e);
    }
}
------------------------
Find a silently evolved API code:android.view.Window.setType:COMMENT
Method Modifier: public      
Comment:/**
 * Set the type of the window, as per the WindowManager.LayoutParams
 * types.
 *
 * @param type The new window type (see WindowManager.LayoutParams).
 */

Body of Frist Method:
{
    final WindowManager.LayoutParams attrs = getAttributes();
    attrs.type = type;
    if (mCallback != null) {
        mCallback.onWindowAttributesChanged(attrs);
    }
}
Body of Second Method:
{
    final WindowManager.LayoutParams attrs = getAttributes();
    attrs.type = type;
    dispatchWindowAttributesChanged(attrs);
}
------------------------
Find a silently evolved API code:android.print.PrintDocumentInfo.Builder.setPageCount:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the total number of pages.
 * <p>
 * <strong>Default: </strong> {@link #PAGE_COUNT_UNKNOWN}
 * </p>
 *
 * @param pageCount The number of pages. Must be greater than
 * or equal to zero or {@link PrintDocumentInfo#PAGE_COUNT_UNKNOWN}.
 */

Body of Frist Method:
{
    if (pageCount < 0 && pageCount != PAGE_COUNT_UNKNOWN) {
        throw new IllegalArgumentException("pageCount" + " must be greater than or euqal to zero or" + " DocumentInfo#PAGE_COUNT_UNKNOWN");
    }
    mPrototype.mPageCount = pageCount;
    return this;
}
Body of Second Method:
{
    if (pageCount < 0 && pageCount != PAGE_COUNT_UNKNOWN) {
        throw new IllegalArgumentException("pageCount" + " must be greater than or equal to zero or" + " DocumentInfo#PAGE_COUNT_UNKNOWN");
    }
    mPrototype.mPageCount = pageCount;
    return this;
}
------------------------
Find a silently evolved API code:android.os.Bundle.setClassLoader:COMMENT
Method Modifier: public      
Comment:/**
 * Changes the ClassLoader this Bundle uses when instantiating objects.
 *
 * @param loader An explicit ClassLoader to use when instantiating objects
 * inside of the Bundle.
 */

Body of Frist Method:
{
    mClassLoader = loader;
}
Body of Second Method:
{
    super.setClassLoader(loader);
}
------------------------
Find a silently evolved API code:android.text.format.Time.parse3339:COMMENT
Method Modifier: public      
Comment:/**
 * Parse a time in RFC 3339 format.  This method also parses simple dates
 * (that is, strings that contain no time or time offset).  For example,
 * all of the following strings are valid:
 *
 * <ul>
 * <li>"2008-10-13T16:00:00.000Z"</li>
 * <li>"2008-10-13T16:00:00.000+07:00"</li>
 * <li>"2008-10-13T16:00:00.000-07:00"</li>
 * <li>"2008-10-13"</li>
 * </ul>
 *
 * <p>
 * If the string contains a time and time offset, then the time offset will
 * be used to convert the time value to UTC.
 * </p>
 *
 * <p>
 * If the given string contains just a date (with no time field), then
 * the {@link #allDay} field is set to true and the {@link #hour},
 * {@link #minute}, and  {@link #second} fields are set to zero.
 * </p>
 *
 * <p>
 * Returns true if the resulting time value is in UTC time.
 * </p>
 *
 * @param s the string to parse
 * @return true if the resulting time value is in UTC time
 * @throws android.util.TimeFormatException if s cannot be parsed.
 */

Body of Frist Method:
{
    if (s == null) {
        throw new NullPointerException("time string is null");
    }
    if (nativeParse3339(s)) {
        timezone = TIMEZONE_UTC;
        return true;
    }
    return false;
}
Body of Second Method:
{
    if (s == null) {
        throw new NullPointerException("time string is null");
    }
    if (parse3339Internal(s)) {
        timezone = TIMEZONE_UTC;
        return true;
    }
    return false;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothSocket.read:COMMENT
Method Modifier: default     
Comment:/*package*/

Body of Frist Method:
{
    if (VDBG)
        Log.d(TAG, "read in:  " + mSocketIS + " len: " + length);
    int ret = mSocketIS.read(b, offset, length);
    if (ret < 0)
        throw new IOException("bt socket closed, read return: " + ret);
    if (VDBG)
        Log.d(TAG, "read out:  " + mSocketIS + " ret: " + ret);
    return ret;
}
Body of Second Method:
{
    if (mSocketIS == null)
        throw new IOException("read is called on null InputStream");
    if (VDBG)
        Log.d(TAG, "read in:  " + mSocketIS + " len: " + length);
    int ret = mSocketIS.read(b, offset, length);
    if (ret < 0)
        throw new IOException("bt socket closed, read return: " + ret);
    if (VDBG)
        Log.d(TAG, "read out:  " + mSocketIS + " ret: " + ret);
    return ret;
}
------------------------
Find a silently evolved API code:android.os.Bundle.putBoolean:COMMENT
Method Modifier: public      
Comment:/**
 * Inserts a Boolean value into the mapping of this Bundle, replacing
 * any existing value for the given key.  Either key or value may be null.
 *
 * @param key a String, or null
 * @param value a Boolean, or null
 */

Body of Frist Method:
{
    unparcel();
    mMap.put(key, value);
}
Body of Second Method:
{
    super.putBoolean(key, value);
}
------------------------
Find a silently evolved API code:android.content.res.TypedArray.getNonConfigurationString:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 * Retrieve the string value for the attribute at <var>index</var> that is
 * not allowed to change with the given configurations.
 *
 * @param index Index of attribute to retrieve.
 * @param allowedChangingConfigs Bit mask of configurations from
 * {@link Configuration}.NATIVE_CONFIG_* that are allowed to change.
 *
 * @return String holding string data.  Any styling information is
 * removed.  Returns null if the attribute is not defined.
 */

Body of Frist Method:
{
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if ((data[index + AssetManager.STYLE_CHANGING_CONFIGURATIONS] & ~allowedChangingConfigs) != 0) {
        return null;
    }
    if (type == TypedValue.TYPE_NULL) {
        return null;
    } else if (type == TypedValue.TYPE_STRING) {
        return loadStringValueAt(index).toString();
    }
    TypedValue v = mValue;
    if (getValueAt(index, v)) {
        Log.w(Resources.TAG, "Converting to string: " + v);
        CharSequence cs = v.coerceToString();
        return cs != null ? cs.toString() : null;
    }
    Log.w(Resources.TAG, "getString of bad type: 0x" + Integer.toHexString(type));
    return null;
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if ((data[index + AssetManager.STYLE_CHANGING_CONFIGURATIONS] & ~allowedChangingConfigs) != 0) {
        return null;
    }
    if (type == TypedValue.TYPE_NULL) {
        return null;
    } else if (type == TypedValue.TYPE_STRING) {
        return loadStringValueAt(index).toString();
    }
    TypedValue v = mValue;
    if (getValueAt(index, v)) {
        Log.w(Resources.TAG, "Converting to string: " + v);
        CharSequence cs = v.coerceToString();
        return cs != null ? cs.toString() : null;
    }
    Log.w(Resources.TAG, "getString of bad type: 0x" + Integer.toHexString(type));
    return null;
}
------------------------
Find a silently evolved API code:android.widget.EdgeEffect.onAbsorb:COMMENT
Method Modifier: public      
Comment:/**
 * Call when the effect absorbs an impact at the given velocity.
 * Used when a fling reaches the scroll boundary.
 *
 * <p>When using a {@link android.widget.Scroller} or {@link android.widget.OverScroller},
 * the method <code>getCurrVelocity</code> will provide a reasonable approximation
 * to use here.</p>
 *
 * @param velocity Velocity at impact in pixels per second.
 */

Body of Frist Method:
{
    mState = STATE_ABSORB;
    velocity = Math.min(Math.max(MIN_VELOCITY, Math.abs(velocity)), MAX_VELOCITY);
    mStartTime = AnimationUtils.currentAnimationTimeMillis();
    mDuration = 0.15f + (velocity * 0.02f);
    // The edge should always be at least partially visible, regardless
    // of velocity.
    mEdgeAlphaStart = 0.f;
    mEdgeScaleY = mEdgeScaleYStart = 0.f;
    // The glow depends more on the velocity, and therefore starts out
    // nearly invisible.
    mGlowAlphaStart = 0.3f;
    mGlowScaleYStart = 0.f;
    // Factor the velocity by 8. Testing on device shows this works best to
    // reflect the strength of the user's scrolling.
    mEdgeAlphaFinish = Math.max(0, Math.min(velocity * VELOCITY_EDGE_FACTOR, 1));
    // Edge should never get larger than the size of its asset.
    mEdgeScaleYFinish = Math.max(HELD_EDGE_SCALE_Y, Math.min(velocity * VELOCITY_EDGE_FACTOR, 1.f));
    // Growth for the size of the glow should be quadratic to properly
    // respond
    // to a user's scrolling speed. The faster the scrolling speed, the more
    // intense the effect should be for both the size and the saturation.
    mGlowScaleYFinish = Math.min(0.025f + (velocity * (velocity / 100) * 0.00015f), 1.75f);
    // Alpha should change for the glow as well as size.
    mGlowAlphaFinish = Math.max(mGlowAlphaStart, Math.min(velocity * VELOCITY_GLOW_FACTOR * .00001f, MAX_ALPHA));
}
Body of Second Method:
{
    mState = STATE_ABSORB;
    velocity = Math.min(Math.max(MIN_VELOCITY, Math.abs(velocity)), MAX_VELOCITY);
    mStartTime = AnimationUtils.currentAnimationTimeMillis();
    mDuration = 0.15f + (velocity * 0.02f);
    // The glow depends more on the velocity, and therefore starts out
    // nearly invisible.
    mGlowAlphaStart = 0.3f;
    mGlowScaleYStart = Math.max(mGlowScaleY, 0.f);
    // Growth for the size of the glow should be quadratic to properly
    // respond
    // to a user's scrolling speed. The faster the scrolling speed, the more
    // intense the effect should be for both the size and the saturation.
    mGlowScaleYFinish = Math.min(0.025f + (velocity * (velocity / 100) * 0.00015f) / 2, 1.f);
    // Alpha should change for the glow as well as size.
    mGlowAlphaFinish = Math.max(mGlowAlphaStart, Math.min(velocity * VELOCITY_GLOW_FACTOR * .00001f, MAX_ALPHA));
    mTargetDisplacement = 0.5f;
}
------------------------
Find a silently evolved API code:android.media.AudioTrack.isMultichannelConfigSupported:COMMENT
Method Modifier: private     static      
Comment:/**
 * Convenience method to check that the channel configuration (a.k.a channel mask) is supported
 * @param channelConfig the mask to validate
 * @return false if the AudioTrack can't be used with such a mask
 */

Body of Frist Method:
{
    // check for unsupported channels
    if ((channelConfig & SUPPORTED_OUT_CHANNELS) != channelConfig) {
        loge("Channel configuration features unsupported channels");
        return false;
    }
    // check for unsupported multichannel combinations:
    // - FL/FR must be present
    // - L/R channels must be paired (e.g. no single L channel)
    final int frontPair = AudioFormat.CHANNEL_OUT_FRONT_LEFT | AudioFormat.CHANNEL_OUT_FRONT_RIGHT;
    if ((channelConfig & frontPair) != frontPair) {
        loge("Front channels must be present in multichannel configurations");
        return false;
    }
    final int backPair = AudioFormat.CHANNEL_OUT_BACK_LEFT | AudioFormat.CHANNEL_OUT_BACK_RIGHT;
    if ((channelConfig & backPair) != 0) {
        if ((channelConfig & backPair) != backPair) {
            loge("Rear channels can't be used independently");
            return false;
        }
    }
    return true;
}
Body of Second Method:
{
    // check for unsupported channels
    if ((channelConfig & SUPPORTED_OUT_CHANNELS) != channelConfig) {
        loge("Channel configuration features unsupported channels");
        return false;
    }
    final int channelCount = Integer.bitCount(channelConfig);
    if (channelCount > CHANNEL_COUNT_MAX) {
        loge("Channel configuration contains too many channels " + channelCount + ">" + CHANNEL_COUNT_MAX);
        return false;
    }
    // check for unsupported multichannel combinations:
    // - FL/FR must be present
    // - L/R channels must be paired (e.g. no single L channel)
    final int frontPair = AudioFormat.CHANNEL_OUT_FRONT_LEFT | AudioFormat.CHANNEL_OUT_FRONT_RIGHT;
    if ((channelConfig & frontPair) != frontPair) {
        loge("Front channels must be present in multichannel configurations");
        return false;
    }
    final int backPair = AudioFormat.CHANNEL_OUT_BACK_LEFT | AudioFormat.CHANNEL_OUT_BACK_RIGHT;
    if ((channelConfig & backPair) != 0) {
        if ((channelConfig & backPair) != backPair) {
            loge("Rear channels can't be used independently");
            return false;
        }
    }
    final int sidePair = AudioFormat.CHANNEL_OUT_SIDE_LEFT | AudioFormat.CHANNEL_OUT_SIDE_RIGHT;
    if ((channelConfig & sidePair) != 0 && (channelConfig & sidePair) != sidePair) {
        loge("Side channels can't be used independently");
        return false;
    }
    return true;
}
------------------------
Find a silently evolved API code:android.graphics.Canvas.drawRGB:COMMENT
Method Modifier: public      
Comment:/**
 * Fill the entire canvas' bitmap (restricted to the current clip) with the
 * specified RGB color, using srcover porterduff mode.
 *
 * @param r red component (0..255) of the color to draw onto the canvas
 * @param g green component (0..255) of the color to draw onto the canvas
 * @param b blue component (0..255) of the color to draw onto the canvas
 */

Body of Frist Method:
{
    native_drawRGB(mNativeCanvas, r, g, b);
}
Body of Second Method:
{
    drawColor(Color.rgb(r, g, b));
}
------------------------
Find a silently evolved API code:android.app.Activity.onStop:COMMENT
Method Modifier: protected   
Comment:/**
 * Called when you are no longer visible to the user.  You will next
 * receive either {@link #onRestart}, {@link #onDestroy}, or nothing,
 * depending on later user activity.
 *
 * <p>Note that this method may never be called, in low memory situations
 * where the system does not have enough memory to keep your activity's
 * process running after its {@link #onPause} method is called.
 *
 * <p><em>Derived classes must call through to the super class's
 * implementation of this method.  If they do not, an exception will be
 * thrown.</em></p>
 *
 * @see #onRestart
 * @see #onResume
 * @see #onSaveInstanceState
 * @see #onDestroy
 */

Body of Frist Method:
{
    if (DEBUG_LIFECYCLE)
        Slog.v(TAG, "onStop " + this);
    if (mActionBar != null)
        mActionBar.setShowHideAnimationEnabled(false);
    getApplication().dispatchActivityStopped(this);
    mTranslucentCallback = null;
    mCalled = true;
}
Body of Second Method:
{
    if (DEBUG_LIFECYCLE)
        Slog.v(TAG, "onStop " + this);
    if (mActionBar != null)
        mActionBar.setShowHideAnimationEnabled(false);
    mActivityTransitionState.onStop();
    getApplication().dispatchActivityStopped(this);
    mTranslucentCallback = null;
    mCalled = true;
}
------------------------
Find a silently evolved API code:android.speech.SpeechRecognizer.destroy:COMMENT
Method Modifier: public      
Comment:/**
 * Destroys the {@code SpeechRecognizer} object.
 */

Body of Frist Method:
{
    if (mConnection != null) {
        mContext.unbindService(mConnection);
    }
    mPendingTasks.clear();
    mService = null;
    mConnection = null;
    mListener.mInternalListener = null;
}
Body of Second Method:
{
    if (mService != null) {
        try {
            mService.cancel(mListener);
        } catch (final RemoteException e) {
        // Not important
        }
    }
    if (mConnection != null) {
        mContext.unbindService(mConnection);
    }
    mPendingTasks.clear();
    mService = null;
    mConnection = null;
    mListener.mInternalListener = null;
}
------------------------
Find a silently evolved API code:android.view.GraphicBuffer.create:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Creates new <code>GraphicBuffer</code> instance. This method will return null
 * if the buffer cannot be created.
 *
 * @param width The width in pixels of the buffer
 * @param height The height in pixels of the buffer
 * @param format The format of each pixel as specified in {@link PixelFormat}
 * @param usage Hint indicating how the buffer will be used
 *
 * @return A <code>GraphicBuffer</code> instance or null
 */

Body of Frist Method:
{
    int nativeObject = nCreateGraphicBuffer(width, height, format, usage);
    if (nativeObject != 0) {
        return new GraphicBuffer(width, height, format, usage, nativeObject);
    }
    return null;
}
Body of Second Method:
{
    long nativeObject = nCreateGraphicBuffer(width, height, format, usage);
    if (nativeObject != 0) {
        return new GraphicBuffer(width, height, format, usage, nativeObject);
    }
    return null;
}
------------------------
Find a silently evolved API code:android.text.DynamicLayout.addBlockAtOffset:COMMENT
Method Modifier: private     
Comment:/**
 * Create a new block, ending at the specified character offset.
 * A block will actually be created only if has at least one line, i.e. this offset is
 * not on the end line of the previous block.
 */

Body of Frist Method:
{
    final int line = getLineForOffset(offset);
    if (mBlockEndLines == null) {
        // Initial creation of the array, no test on previous block ending line
        mBlockEndLines = new int[ArrayUtils.idealIntArraySize(1)];
        mBlockEndLines[mNumberOfBlocks] = line;
        mNumberOfBlocks++;
        return;
    }
    final int previousBlockEndLine = mBlockEndLines[mNumberOfBlocks - 1];
    if (line > previousBlockEndLine) {
        if (mNumberOfBlocks == mBlockEndLines.length) {
            // Grow the array if needed
            int[] blockEndLines = new int[ArrayUtils.idealIntArraySize(mNumberOfBlocks + 1)];
            System.arraycopy(mBlockEndLines, 0, blockEndLines, 0, mNumberOfBlocks);
            mBlockEndLines = blockEndLines;
        }
        mBlockEndLines[mNumberOfBlocks] = line;
        mNumberOfBlocks++;
    }
}
Body of Second Method:
{
    final int line = getLineForOffset(offset);
    if (mBlockEndLines == null) {
        // Initial creation of the array, no test on previous block ending line
        mBlockEndLines = ArrayUtils.newUnpaddedIntArray(1);
        mBlockEndLines[mNumberOfBlocks] = line;
        mNumberOfBlocks++;
        return;
    }
    final int previousBlockEndLine = mBlockEndLines[mNumberOfBlocks - 1];
    if (line > previousBlockEndLine) {
        mBlockEndLines = GrowingArrayUtils.append(mBlockEndLines, mNumberOfBlocks, line);
        mNumberOfBlocks++;
    }
}
------------------------
Find a silently evolved API code:android.net.DnsPinger.getDnsList:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns a list of DNS addresses, coming from either the link properties of the
 * specified connection or the default system DNS if the link properties has no dnses.
 * @return a non-empty non-null list
 */

Body of Frist Method:
{
    LinkProperties curLinkProps = getCurrentLinkProperties();
    if (curLinkProps == null) {
        loge("getCurLinkProperties:: LP for type" + mConnectionType + " is null!");
        return mDefaultDns;
    }
    Collection<InetAddress> dnses = curLinkProps.getDnses();
    if (dnses == null || dnses.size() == 0) {
        loge("getDns::LinkProps has null dns - returning default");
        return mDefaultDns;
    }
    return new ArrayList<InetAddress>(dnses);
}
Body of Second Method:
{
    LinkProperties curLinkProps = getCurrentLinkProperties();
    if (curLinkProps == null) {
        loge("getCurLinkProperties:: LP for type" + mConnectionType + " is null!");
        return mDefaultDns;
    }
    Collection<InetAddress> dnses = curLinkProps.getDnsServers();
    if (dnses == null || dnses.size() == 0) {
        loge("getDns::LinkProps has null dns - returning default");
        return mDefaultDns;
    }
    return new ArrayList<InetAddress>(dnses);
}
------------------------
Find a silently evolved API code:android.print.PrintManager.getPrintJob:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Gets a print job given its id.
 *
 * @return The print job list.
 * @see PrintJob
 * @hide
 */

Body of Frist Method:
{
    try {
        PrintJobInfo printJob = mService.getPrintJobInfo(printJobId, mAppId, mUserId);
        if (printJob != null) {
            return new PrintJob(printJob, this);
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, "Error getting print job", re);
    }
    return null;
}
Body of Second Method:
{
    if (mService == null) {
        Log.w(LOG_TAG, "Feature android.software.print not available");
        return null;
    }
    try {
        PrintJobInfo printJob = mService.getPrintJobInfo(printJobId, mAppId, mUserId);
        if (printJob != null) {
            return new PrintJob(printJob, this);
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, "Error getting print job", re);
    }
    return null;
}
------------------------
Find a silently evolved API code:android.media.RemoteControlClient.setPlaybackPositionUpdateListener:COMMENT
<android.media.RemoteControlClient: void setPlaybackPositionUpdateListener(OnPlaybackPositionUpdateListener)>
public      ->public      deprecated  
Method Modifier: public      deprecated  
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Sets the listener to be called whenever the media playback position is requested
 * to be updated.
 * Notifications will be received in the same thread as the one in which RemoteControlClient
 * was created.
 * @param l the position update listener to be called
 */

Body of Frist Method:
{
    synchronized (mCacheLock) {
        int oldCapa = mPlaybackPositionCapabilities;
        if (l != null) {
            mPlaybackPositionCapabilities |= MEDIA_POSITION_WRITABLE;
        } else {
            mPlaybackPositionCapabilities &= ~MEDIA_POSITION_WRITABLE;
        }
        mPositionUpdateListener = l;
        if (oldCapa != mPlaybackPositionCapabilities) {
            // tell RCDs that this RCC's playback position capabilities have changed
            sendTransportControlInfo_syncCacheLock(null);
        }
    }
}
Body of Second Method:
{
    synchronized (mCacheLock) {
        mPositionUpdateListener = l;
    }
}
------------------------
Find a silently evolved API code:android.media.AudioService.setMasterMute:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @see AudioManager#setMasterMute(boolean, int)
 */

Body of Frist Method:
{
    if (mUseFixedVolume) {
        return;
    }
    if (state != AudioSystem.getMasterMute()) {
        AudioSystem.setMasterMute(state);
        // Post a persist master volume msg
        sendMsg(mAudioHandler, MSG_PERSIST_MASTER_VOLUME_MUTE, SENDMSG_REPLACE, state ? 1 : 0, 0, null, PERSIST_DELAY);
        sendMasterMuteUpdate(state, flags);
    }
}
Body of Second Method:
{
    if (mUseFixedVolume) {
        return;
    }
    if (mAppOps.noteOp(AppOpsManager.OP_AUDIO_MASTER_VOLUME, Binder.getCallingUid(), callingPackage) != AppOpsManager.MODE_ALLOWED) {
        return;
    }
    if (state != AudioSystem.getMasterMute()) {
        AudioSystem.setMasterMute(state);
        // Post a persist master volume msg
        sendMsg(mAudioHandler, MSG_PERSIST_MASTER_VOLUME_MUTE, SENDMSG_REPLACE, state ? 1 : 0, UserHandle.getCallingUserId(), null, PERSIST_DELAY);
        sendMasterMuteUpdate(state, flags);
    }
}
------------------------
Find a silently evolved API code:android.widget.FastScroller.transitionPreviewLayout:COMMENT
Method Modifier: private     
Comment:/**
 * Transitions the preview text to a new section. Handles animation,
 * measurement, and layout. If the new preview text is empty, returns false.
 *
 * @param sectionIndex The section index to which the preview should
 * transition.
 * @return False if the new preview text is empty.
 */

Body of Frist Method:
{
    final Object[] sections = mSections;
    String text = null;
    if (sections != null && sectionIndex >= 0 && sectionIndex < sections.length) {
        final Object section = sections[sectionIndex];
        if (section != null) {
            text = section.toString();
        }
    }
    final Rect bounds = mTempBounds;
    final ImageView preview = mPreviewImage;
    final TextView showing;
    final TextView target;
    if (mShowingPrimary) {
        showing = mPrimaryText;
        target = mSecondaryText;
    } else {
        showing = mSecondaryText;
        target = mPrimaryText;
    }
    // Set and layout target immediately.
    target.setText(text);
    measurePreview(target, bounds);
    applyLayout(target, bounds);
    if (mPreviewAnimation != null) {
        mPreviewAnimation.cancel();
    }
    // Cross-fade preview text.
    final Animator showTarget = animateAlpha(target, 1f).setDuration(DURATION_CROSS_FADE);
    final Animator hideShowing = animateAlpha(showing, 0f).setDuration(DURATION_CROSS_FADE);
    hideShowing.addListener(mSwitchPrimaryListener);
    // Apply preview image padding and animate bounds, if necessary.
    bounds.left -= mPreviewImage.getPaddingLeft();
    bounds.top -= mPreviewImage.getPaddingTop();
    bounds.right += mPreviewImage.getPaddingRight();
    bounds.bottom += mPreviewImage.getPaddingBottom();
    final Animator resizePreview = animateBounds(preview, bounds);
    resizePreview.setDuration(DURATION_RESIZE);
    mPreviewAnimation = new AnimatorSet();
    final AnimatorSet.Builder builder = mPreviewAnimation.play(hideShowing).with(showTarget);
    builder.with(resizePreview);
    // The current preview size is unaffected by hidden or showing. It's
    // used to set starting scales for things that need to be scaled down.
    final int previewWidth = preview.getWidth() - preview.getPaddingLeft() - preview.getPaddingRight();
    // If target is too large, shrink it immediately to fit and expand to
    // target size. Otherwise, start at target size.
    final int targetWidth = target.getWidth();
    if (targetWidth > previewWidth) {
        target.setScaleX((float) previewWidth / targetWidth);
        final Animator scaleAnim = animateScaleX(target, 1f).setDuration(DURATION_RESIZE);
        builder.with(scaleAnim);
    } else {
        target.setScaleX(1f);
    }
    // If showing is larger than target, shrink to target size.
    final int showingWidth = showing.getWidth();
    if (showingWidth > targetWidth) {
        final float scale = (float) targetWidth / showingWidth;
        final Animator scaleAnim = animateScaleX(showing, scale).setDuration(DURATION_RESIZE);
        builder.with(scaleAnim);
    }
    mPreviewAnimation.start();
    return (text != null && text.length() > 0);
}
Body of Second Method:
{
    final Object[] sections = mSections;
    String text = null;
    if (sections != null && sectionIndex >= 0 && sectionIndex < sections.length) {
        final Object section = sections[sectionIndex];
        if (section != null) {
            text = section.toString();
        }
    }
    final Rect bounds = mTempBounds;
    final View preview = mPreviewImage;
    final TextView showing;
    final TextView target;
    if (mShowingPrimary) {
        showing = mPrimaryText;
        target = mSecondaryText;
    } else {
        showing = mSecondaryText;
        target = mPrimaryText;
    }
    // Set and layout target immediately.
    target.setText(text);
    measurePreview(target, bounds);
    applyLayout(target, bounds);
    if (mPreviewAnimation != null) {
        mPreviewAnimation.cancel();
    }
    // Cross-fade preview text.
    final Animator showTarget = animateAlpha(target, 1f).setDuration(DURATION_CROSS_FADE);
    final Animator hideShowing = animateAlpha(showing, 0f).setDuration(DURATION_CROSS_FADE);
    hideShowing.addListener(mSwitchPrimaryListener);
    // Apply preview image padding and animate bounds, if necessary.
    bounds.left -= preview.getPaddingLeft();
    bounds.top -= preview.getPaddingTop();
    bounds.right += preview.getPaddingRight();
    bounds.bottom += preview.getPaddingBottom();
    final Animator resizePreview = animateBounds(preview, bounds);
    resizePreview.setDuration(DURATION_RESIZE);
    mPreviewAnimation = new AnimatorSet();
    final AnimatorSet.Builder builder = mPreviewAnimation.play(hideShowing).with(showTarget);
    builder.with(resizePreview);
    // The current preview size is unaffected by hidden or showing. It's
    // used to set starting scales for things that need to be scaled down.
    final int previewWidth = preview.getWidth() - preview.getPaddingLeft() - preview.getPaddingRight();
    // If target is too large, shrink it immediately to fit and expand to
    // target size. Otherwise, start at target size.
    final int targetWidth = target.getWidth();
    if (targetWidth > previewWidth) {
        target.setScaleX((float) previewWidth / targetWidth);
        final Animator scaleAnim = animateScaleX(target, 1f).setDuration(DURATION_RESIZE);
        builder.with(scaleAnim);
    } else {
        target.setScaleX(1f);
    }
    // If showing is larger than target, shrink to target size.
    final int showingWidth = showing.getWidth();
    if (showingWidth > targetWidth) {
        final float scale = (float) targetWidth / showingWidth;
        final Animator scaleAnim = animateScaleX(showing, scale).setDuration(DURATION_RESIZE);
        builder.with(scaleAnim);
    }
    mPreviewAnimation.start();
    return !TextUtils.isEmpty(text);
}
------------------------
Find a silently evolved API code:android.view.ViewRootImpl.InputStage.deliver:COMMENT
Method Modifier: public      final       
Comment:/**
 * Delivers an event to be processed.
 */

Body of Frist Method:
{
    if ((q.mFlags & QueuedInputEvent.FLAG_FINISHED) != 0) {
        forward(q);
    } else if (mView == null || !mAdded) {
        Slog.w(TAG, "Dropping event due to root view being removed: " + q.mEvent);
        finish(q, false);
    } else if (!mAttachInfo.mHasWindowFocus && !q.mEvent.isFromSource(InputDevice.SOURCE_CLASS_POINTER) && !isTerminalInputEvent(q.mEvent)) {
        // If this is a focused event and the window doesn't currently have input focus,
        // then drop this event.  This could be an event that came back from the previous
        // stage but the window has lost focus in the meantime.
        Slog.w(TAG, "Dropping event due to no window focus: " + q.mEvent);
        finish(q, false);
    } else {
        apply(q, onProcess(q));
    }
}
Body of Second Method:
{
    if ((q.mFlags & QueuedInputEvent.FLAG_FINISHED) != 0) {
        forward(q);
    } else if (shouldDropInputEvent(q)) {
        finish(q, false);
    } else {
        apply(q, onProcess(q));
    }
}
------------------------
Find a silently evolved API code:android.transition.Transition.playTransition:COMMENT
Method Modifier: default     
Comment:/**
 * Called by TransitionManager to play the transition. This calls
 * createAnimators() to set things up and create all of the animations and then
 * runAnimations() to actually start the animations.
 */

Body of Frist Method:
{
    ArrayMap<Animator, AnimationInfo> runningAnimators = getRunningAnimators();
    int numOldAnims = runningAnimators.size();
    for (int i = numOldAnims - 1; i >= 0; i--) {
        Animator anim = runningAnimators.keyAt(i);
        if (anim != null) {
            AnimationInfo oldInfo = runningAnimators.get(anim);
            if (oldInfo != null) {
                boolean cancel = false;
                TransitionValues oldValues = oldInfo.values;
                View oldView = oldInfo.view;
                TransitionValues newValues = mEndValues.viewValues != null ? mEndValues.viewValues.get(oldView) : null;
                if (newValues == null) {
                    newValues = mEndValues.idValues.get(oldView.getId());
                }
                if (oldValues != null) {
                    // and won't get canceled
                    if (newValues != null) {
                        for (String key : oldValues.values.keySet()) {
                            Object oldValue = oldValues.values.get(key);
                            Object newValue = newValues.values.get(key);
                            if (oldValue != null && newValue != null && !oldValue.equals(newValue)) {
                                cancel = true;
                                if (DBG) {
                                    Log.d(LOG_TAG, "Transition.playTransition: " + "oldValue != newValue for " + key + ": old, new = " + oldValue + ", " + newValue);
                                }
                                break;
                            }
                        }
                    }
                }
                if (cancel) {
                    if (anim.isRunning() || anim.isStarted()) {
                        if (DBG) {
                            Log.d(LOG_TAG, "Canceling anim " + anim);
                        }
                        anim.cancel();
                    } else {
                        if (DBG) {
                            Log.d(LOG_TAG, "removing anim from info list: " + anim);
                        }
                        runningAnimators.remove(anim);
                    }
                }
            }
        }
    }
    createAnimators(sceneRoot, mStartValues, mEndValues);
    runAnimators();
}
Body of Second Method:
{
    mStartValuesList = new ArrayList<TransitionValues>();
    mEndValuesList = new ArrayList<TransitionValues>();
    matchStartAndEnd(mStartValues, mEndValues);
    ArrayMap<Animator, AnimationInfo> runningAnimators = getRunningAnimators();
    int numOldAnims = runningAnimators.size();
    WindowId windowId = sceneRoot.getWindowId();
    for (int i = numOldAnims - 1; i >= 0; i--) {
        Animator anim = runningAnimators.keyAt(i);
        if (anim != null) {
            AnimationInfo oldInfo = runningAnimators.get(anim);
            if (oldInfo != null && oldInfo.view != null && oldInfo.windowId == windowId) {
                TransitionValues oldValues = oldInfo.values;
                View oldView = oldInfo.view;
                TransitionValues startValues = getTransitionValues(oldView, true);
                TransitionValues endValues = getMatchedTransitionValues(oldView, true);
                boolean cancel = (startValues != null || endValues != null) && oldInfo.transition.areValuesChanged(oldValues, endValues);
                if (cancel) {
                    if (anim.isRunning() || anim.isStarted()) {
                        if (DBG) {
                            Log.d(LOG_TAG, "Canceling anim " + anim);
                        }
                        anim.cancel();
                    } else {
                        if (DBG) {
                            Log.d(LOG_TAG, "removing anim from info list: " + anim);
                        }
                        runningAnimators.remove(anim);
                    }
                }
            }
        }
    }
    createAnimators(sceneRoot, mStartValues, mEndValues, mStartValuesList, mEndValuesList);
    runAnimators();
}
------------------------
Find a silently evolved API code:android.graphics.Matrix.postTranslate:COMMENT
Method Modifier: public      
Comment:/**
 * Postconcats the matrix with the specified translation.
 * M' = T(dx, dy) * M
 */

Body of Frist Method:
{
    return native_postTranslate(native_instance, dx, dy);
}
Body of Second Method:
{
    native_postTranslate(native_instance, dx, dy);
    return true;
}
------------------------
Find a silently evolved API code:android.view.ViewGroup.setClipToPadding:COMMENT
Method Modifier: public      
Comment:/**
 * By default, children are clipped to the padding of the ViewGroup. This
 * allows view groups to override this behavior
 *
 * @param clipToPadding true to clip children to the padding of the
 * group, false otherwise
 * @attr ref android.R.styleable#ViewGroup_clipToPadding
 */

Body of Frist Method:
{
    setBooleanFlag(FLAG_CLIP_TO_PADDING, clipToPadding);
}
Body of Second Method:
{
    if (hasBooleanFlag(FLAG_CLIP_TO_PADDING) != clipToPadding) {
        setBooleanFlag(FLAG_CLIP_TO_PADDING, clipToPadding);
        invalidate(true);
    }
}
------------------------
Find a silently evolved API code:android.animation.PropertyValuesHolder.setupValue:COMMENT
Method Modifier: private     
Comment:/**
 * Utility function to set the value stored in a particular Keyframe. The value used is
 * whatever the value is for the property name specified in the keyframe on the target object.
 *
 * @param target The target object from which the current value should be extracted.
 * @param kf The keyframe which holds the property name and value.
 */

Body of Frist Method:
{
    if (mProperty != null) {
        kf.setValue(mProperty.get(target));
    }
    try {
        if (mGetter == null) {
            Class targetClass = target.getClass();
            setupGetter(targetClass);
            if (mGetter == null) {
                // Already logged the error - just return to avoid NPE
                return;
            }
        }
        kf.setValue(mGetter.invoke(target));
    } catch (InvocationTargetException e) {
        Log.e("PropertyValuesHolder", e.toString());
    } catch (IllegalAccessException e) {
        Log.e("PropertyValuesHolder", e.toString());
    }
}
Body of Second Method:
{
    if (mProperty != null) {
        Object value = convertBack(mProperty.get(target));
        kf.setValue(value);
    }
    try {
        if (mGetter == null) {
            Class targetClass = target.getClass();
            setupGetter(targetClass);
            if (mGetter == null) {
                // Already logged the error - just return to avoid NPE
                return;
            }
        }
        Object value = convertBack(mGetter.invoke(target));
        kf.setValue(value);
    } catch (InvocationTargetException e) {
        Log.e("PropertyValuesHolder", e.toString());
    } catch (IllegalAccessException e) {
        Log.e("PropertyValuesHolder", e.toString());
    }
}
------------------------
Find a silently evolved API code:android.graphics.Matrix.preTranslate:COMMENT
Method Modifier: public      
Comment:/**
 * Preconcats the matrix with the specified translation.
 * M' = M * T(dx, dy)
 */

Body of Frist Method:
{
    return native_preTranslate(native_instance, dx, dy);
}
Body of Second Method:
{
    native_preTranslate(native_instance, dx, dy);
    return true;
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiManager.startScan:COMMENT
Method Modifier: public      
Comment:/**
 * Request a scan for access points. Returns immediately. The availability
 * of the results is made known later by means of an asynchronous event sent
 * on completion of the scan.
 * @return {@code true} if the operation succeeded, i.e., the scan was initiated
 */

Body of Frist Method:
{
    try {
        final WorkSource workSource = null;
        mService.startScan(workSource);
        return true;
    } catch (RemoteException e) {
        return false;
    }
}
Body of Second Method:
{
    try {
        mService.startScan(null, null);
        return true;
    } catch (RemoteException e) {
        return false;
    }
}
------------------------
Find a silently evolved API code:javax.obex.ClientOperation.continueOperation:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Continues the operation since there is no data to read.
 * @param sendEmpty <code>true</code> if the operation should send an empty
 * packet or not send anything if there is no data to send
 * @param inStream <code>true</code> if the stream is input stream or is
 * output stream
 * @throws IOException if an IO error occurs
 */

Body of Frist Method:
{
    if (mGetOperation) {
        if ((inStream) && (!mOperationDone)) {
            // to deal with inputstream in get operation
            mParent.sendRequest(0x83, null, mReplyHeader, mPrivateInput);
            /*
                  * Determine if that was not the last packet in the operation
                  */
            if (mReplyHeader.responseCode != ResponseCodes.OBEX_HTTP_CONTINUE) {
                mOperationDone = true;
            }
            return true;
        } else if ((!inStream) && (!mOperationDone)) {
            if (mPrivateInput == null) {
                mPrivateInput = new PrivateInputStream(this);
            }
            sendRequest(0x03);
            return true;
        } else if (mOperationDone) {
            return false;
        }
    } else {
        if ((!inStream) && (!mOperationDone)) {
            // to deal with outputstream in put operation
            if (mReplyHeader.responseCode == -1) {
                mReplyHeader.responseCode = ResponseCodes.OBEX_HTTP_CONTINUE;
            }
            sendRequest(0x02);
            return true;
        } else if ((inStream) && (!mOperationDone)) {
            // How to deal with inputstream  in put operation ?
            return false;
        } else if (mOperationDone) {
            return false;
        }
    }
    return false;
}
Body of Second Method:
{
    if (mGetOperation) {
        if ((inStream) && (!mOperationDone)) {
            // to deal with inputstream in get operation
            mParent.sendRequest(0x83, null, mReplyHeader, mPrivateInput);
            /*
                  * Determine if that was not the last packet in the operation
                  */
            if (mReplyHeader.responseCode != ResponseCodes.OBEX_HTTP_CONTINUE) {
                mOperationDone = true;
            }
            return true;
        } else if ((!inStream) && (!mOperationDone)) {
            if (mPrivateInput == null) {
                mPrivateInput = new PrivateInputStream(this);
            }
            if (!mGetFinalFlag) {
                sendRequest(0x03);
            } else {
                sendRequest(0x83);
                if (mReplyHeader.responseCode != ResponseCodes.OBEX_HTTP_CONTINUE) {
                    mOperationDone = true;
                }
            }
            return true;
        } else if (mOperationDone) {
            return false;
        }
    } else {
        if ((!inStream) && (!mOperationDone)) {
            // to deal with outputstream in put operation
            if (mReplyHeader.responseCode == -1) {
                mReplyHeader.responseCode = ResponseCodes.OBEX_HTTP_CONTINUE;
            }
            sendRequest(0x02);
            return true;
        } else if ((inStream) && (!mOperationDone)) {
            // How to deal with inputstream  in put operation ?
            return false;
        } else if (mOperationDone) {
            return false;
        }
    }
    return false;
}
------------------------
Find a silently evolved API code:android.view.ViewGroup.dispatchGetDisplayList:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * This method is used to cause children of this ViewGroup to restore or recreate their
 * display lists. It is called by getDisplayList() when the parent ViewGroup does not need
 * to recreate its own display list, which would happen if it went through the normal
 * draw/dispatchDraw mechanisms.
 *
 * @hide
 */

Body of Frist Method:
{
    final int count = mChildrenCount;
    final View[] children = mChildren;
    for (int i = 0; i < count; i++) {
        final View child = children[i];
        if (((child.mViewFlags & VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) && child.hasStaticLayer()) {
            child.mRecreateDisplayList = (child.mPrivateFlags & PFLAG_INVALIDATED) == PFLAG_INVALIDATED;
            child.mPrivateFlags &= ~PFLAG_INVALIDATED;
            child.getDisplayList();
            child.mRecreateDisplayList = false;
        }
    }
    if (mOverlay != null) {
        View overlayView = mOverlay.getOverlayView();
        overlayView.mRecreateDisplayList = (overlayView.mPrivateFlags & PFLAG_INVALIDATED) == PFLAG_INVALIDATED;
        overlayView.mPrivateFlags &= ~PFLAG_INVALIDATED;
        overlayView.getDisplayList();
        overlayView.mRecreateDisplayList = false;
    }
}
Body of Second Method:
{
    final int count = mChildrenCount;
    final View[] children = mChildren;
    for (int i = 0; i < count; i++) {
        final View child = children[i];
        if (((child.mViewFlags & VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) && child.hasStaticLayer()) {
            recreateChildDisplayList(child);
        }
    }
    if (mOverlay != null) {
        View overlayView = mOverlay.getOverlayView();
        recreateChildDisplayList(overlayView);
    }
    if (mDisappearingChildren != null) {
        final ArrayList<View> disappearingChildren = mDisappearingChildren;
        final int disappearingCount = disappearingChildren.size();
        for (int i = 0; i < disappearingCount; ++i) {
            final View child = disappearingChildren.get(i);
            recreateChildDisplayList(child);
        }
    }
}
------------------------
Find a silently evolved API code:android.view.ViewRootImpl.InputStage.onDeliverToNext:COMMENT
Method Modifier: protected   
Comment:/**
 * Called when an event is being delivered to the next stage.
 */

Body of Frist Method:
{
    if (mNext != null) {
        mNext.deliver(q);
    } else {
        finishInputEvent(q);
    }
}
Body of Second Method:
{
    if (DEBUG_INPUT_STAGES) {
        Log.v(TAG, "Done with " + getClass().getSimpleName() + ". " + q);
    }
    if (mNext != null) {
        mNext.deliver(q);
    } else {
        finishInputEvent(q);
    }
}
------------------------
Find a silently evolved API code:android.view.accessibility.AccessibilityNodeInfo.makeNodeId:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Makes a node id by shifting the <code>virtualDescendantId</code>
 * by {@link #VIRTUAL_DESCENDANT_ID_SHIFT} and taking
 * the bitwise or with the <code>accessibilityViewId</code>.
 *
 * @param accessibilityViewId A View accessibility id.
 * @param virtualDescendantId A virtual descendant id.
 * @return The node id.
 *
 * @hide
 */

Body of Frist Method:
{
    return (((long) virtualDescendantId) << VIRTUAL_DESCENDANT_ID_SHIFT) | accessibilityViewId;
}
Body of Second Method:
{
    // remap it here.
    if (virtualDescendantId == AccessibilityNodeProvider.HOST_VIEW_ID) {
        virtualDescendantId = UNDEFINED_ITEM_ID;
    }
    return (((long) virtualDescendantId) << VIRTUAL_DESCENDANT_ID_SHIFT) | accessibilityViewId;
}
------------------------
Find a silently evolved API code:android.graphics.drawable.GradientDrawable.setUseLevel:COMMENT
Method Modifier: public      
Comment:/**
 * <p>Sets whether or not this drawable will honor its <code>level</code>
 * property.</p>
 * <p><strong>Note</strong>: changing this property will affect all instances
 * of a drawable loaded from a resource. It is recommended to invoke
 * {@link #mutate()} before changing this property.</p>
 *
 * @param useLevel True if this drawable should honor its level, false otherwise
 *
 * @see #mutate()
 * @see #setLevel(int)
 * @see #getLevel()
 */

Body of Frist Method:
{
    mGradientState.mUseLevel = useLevel;
    mRectIsDirty = true;
    invalidateSelf();
}
Body of Second Method:
{
    mGradientState.mUseLevel = useLevel;
    mGradientIsDirty = true;
    invalidateSelf();
}
------------------------
Find a silently evolved API code:android.graphics.Canvas.getHeight:COMMENT
<android.graphics.Canvas: int getHeight()>
public      native      ->public      
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * Returns the height of the current drawing layer
 *
 * @return the height of the current drawing layer
 */

Body of Frist Method:

Body of Second Method:
{
    return native_getHeight(mNativeCanvasWrapper);
}
------------------------
Find a silently evolved API code:android.text.TextUtils.obtain:COMMENT
Method Modifier: default     static      
Comment:/* package */

Body of Frist Method:
{
    char[] buf;
    synchronized (sLock) {
        buf = sTemp;
        sTemp = null;
    }
    if (buf == null || buf.length < len)
        buf = new char[ArrayUtils.idealCharArraySize(len)];
    return buf;
}
Body of Second Method:
{
    char[] buf;
    synchronized (sLock) {
        buf = sTemp;
        sTemp = null;
    }
    if (buf == null || buf.length < len)
        buf = ArrayUtils.newUnpaddedCharArray(len);
    return buf;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothGatt.writeCharacteristic:COMMENT
Method Modifier: public      
Comment:/**
 * Writes a given characteristic and its values to the associated remote device.
 *
 * <p>Once the write operation has been completed, the
 * {@link BluetoothGattCallback#onCharacteristicWrite} callback is invoked,
 * reporting the result of the operation.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param characteristic Characteristic to write on the remote device
 * @return true, if the write operation was initiated successfully
 */

Body of Frist Method:
{
    if ((characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_WRITE) == 0 && (characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE) == 0)
        return false;
    if (DBG)
        Log.d(TAG, "writeCharacteristic() - uuid: " + characteristic.getUuid());
    if (mService == null || mClientIf == 0)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    try {
        mService.writeCharacteristic(mClientIf, device.getAddress(), service.getType(), service.getInstanceId(), new ParcelUuid(service.getUuid()), characteristic.getInstanceId(), new ParcelUuid(characteristic.getUuid()), characteristic.getWriteType(), AUTHENTICATION_NONE, characteristic.getValue());
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        return false;
    }
    return true;
}
Body of Second Method:
{
    if ((characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_WRITE) == 0 && (characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE) == 0)
        return false;
    if (VDBG)
        Log.d(TAG, "writeCharacteristic() - uuid: " + characteristic.getUuid());
    if (mService == null || mClientIf == 0)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusy) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.writeCharacteristic(mClientIf, device.getAddress(), service.getType(), service.getInstanceId(), new ParcelUuid(service.getUuid()), characteristic.getInstanceId(), new ParcelUuid(characteristic.getUuid()), characteristic.getWriteType(), AUTHENTICATION_NONE, characteristic.getValue());
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}
------------------------
Find a silently evolved API code:android.view.ViewPropertyAnimator.setStartDelay:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the startDelay for the underlying animator that animates the requested properties.
 * By default, the animator uses the default value for ValueAnimator. Calling this method
 * will cause the declared value to be used instead.
 * @param startDelay The delay of ensuing property animations, in milliseconds. The value
 * cannot be negative.
 * @return This object, allowing calls to methods in this class to be chained.
 */

Body of Frist Method:
{
    if (startDelay < 0) {
        throw new IllegalArgumentException("Animators cannot have negative duration: " + startDelay);
    }
    mStartDelaySet = true;
    mStartDelay = startDelay;
    return this;
}
Body of Second Method:
{
    if (startDelay < 0) {
        throw new IllegalArgumentException("Animators cannot have negative start " + "delay: " + startDelay);
    }
    mStartDelaySet = true;
    mStartDelay = startDelay;
    return this;
}
------------------------
Find a silently evolved API code:android.printservice.PrintJob.getAdvancedStringOption:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the value of an advanced (printer specific) print option.
 *
 * @param key The option key.
 * @return The option value.
 */

Body of Frist Method:
{
    PrintService.throwIfNotCalledOnMainThread();
    return null;
}
Body of Second Method:
{
    PrintService.throwIfNotCalledOnMainThread();
    return getInfo().getAdvancedStringOption(key);
}
------------------------
Find a silently evolved API code:android.media.AudioService.adjustSuggestedStreamVolume:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @see AudioManager#adjustVolume(int, int)
 */

Body of Frist Method:
{
    if (DEBUG_VOL)
        Log.d(TAG, "adjustSuggestedStreamVolume() stream=" + suggestedStreamType);
    int streamType;
    if (mVolumeControlStream != -1) {
        streamType = mVolumeControlStream;
    } else {
        streamType = getActiveStreamType(suggestedStreamType);
    }
    // Play sounds on STREAM_RING only and if lock screen is not on.
    if ((streamType != STREAM_REMOTE_MUSIC) && (flags & AudioManager.FLAG_PLAY_SOUND) != 0 && ((mStreamVolumeAlias[streamType] != AudioSystem.STREAM_RING) || (mKeyguardManager != null && mKeyguardManager.isKeyguardLocked()))) {
        flags &= ~AudioManager.FLAG_PLAY_SOUND;
    }
    if (streamType == STREAM_REMOTE_MUSIC) {
        // don't play sounds for remote
        flags &= ~(AudioManager.FLAG_PLAY_SOUND | AudioManager.FLAG_FIXED_VOLUME);
        // if (DEBUG_VOL) Log.i(TAG, "Need to adjust remote volume: calling adjustRemoteVolume()");
        mMediaFocusControl.adjustRemoteVolume(AudioSystem.STREAM_MUSIC, direction, flags);
    } else {
        adjustStreamVolume(streamType, direction, flags, callingPackage);
    }
}
Body of Second Method:
{
    adjustSuggestedStreamVolume(direction, suggestedStreamType, flags, callingPackage, Binder.getCallingUid());
}
------------------------
Find a silently evolved API code:android.widget.ImageView.setColorFilter:COMMENT
Method Modifier: public      
Comment:/**
 * Apply an arbitrary colorfilter to the image.
 *
 * @param cf the colorfilter to apply (may be null)
 *
 * @see #getColorFilter()
 */

Body of Frist Method:
{
    if (mColorFilter != cf) {
        mColorFilter = cf;
        mColorMod = true;
        applyColorMod();
        invalidate();
    }
}
Body of Second Method:
{
    if (mColorFilter != cf) {
        mColorFilter = cf;
        mHasColorFilter = true;
        mColorMod = true;
        applyColorMod();
        invalidate();
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiConfiguration.isValid:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * indicates whether the configuration is valid
 * @return true if valid, false otherwise
 * @hide
 */

Body of Frist Method:
{
    if (allowedKeyManagement.cardinality() > 1) {
        if (allowedKeyManagement.cardinality() != 2) {
            return false;
        }
        if (allowedKeyManagement.get(KeyMgmt.WPA_EAP) == false) {
            return false;
        }
        if ((allowedKeyManagement.get(KeyMgmt.IEEE8021X) == false) && (allowedKeyManagement.get(KeyMgmt.WPA_PSK) == false)) {
            return false;
        }
    }
    // TODO: Add more checks
    return true;
}
Body of Second Method:
{
    if (allowedKeyManagement == null)
        return false;
    if (allowedKeyManagement.cardinality() > 1) {
        if (allowedKeyManagement.cardinality() != 2) {
            return false;
        }
        if (allowedKeyManagement.get(KeyMgmt.WPA_EAP) == false) {
            return false;
        }
        if ((allowedKeyManagement.get(KeyMgmt.IEEE8021X) == false) && (allowedKeyManagement.get(KeyMgmt.WPA_PSK) == false)) {
            return false;
        }
    }
    // TODO: Add more checks
    return true;
}
------------------------
Find a silently evolved API code:android.os.Bundle.putCharArray:COMMENT
Method Modifier: public      
Comment:/**
 * Inserts a char array value into the mapping of this Bundle, replacing
 * any existing value for the given key.  Either key or value may be null.
 *
 * @param key a String, or null
 * @param value a char array object, or null
 */

Body of Frist Method:
{
    unparcel();
    mMap.put(key, value);
}
Body of Second Method:
{
    super.putCharArray(key, value);
}
------------------------
Find a silently evolved API code:android.text.format.Time.setToNow:COMMENT
<android.text.format.Time: void setToNow()>
public      native      ->public      
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * Sets the time of the given Time object to the current time.
 */

Body of Frist Method:

Body of Second Method:
{
    set(System.currentTimeMillis());
}
------------------------
Find a silently evolved API code:android.media.MediaPlayer.TrackInfo.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    dest.writeInt(mTrackType);
    dest.writeString(getLanguage());
    if (mTrackType == MEDIA_TRACK_TYPE_SUBTITLE) {
        dest.writeInt(mFormat.getInteger(MediaFormat.KEY_IS_AUTOSELECT));
        dest.writeInt(mFormat.getInteger(MediaFormat.KEY_IS_DEFAULT));
        dest.writeInt(mFormat.getInteger(MediaFormat.KEY_IS_FORCED_SUBTITLE));
    }
}
Body of Second Method:
{
    dest.writeInt(mTrackType);
    dest.writeString(getLanguage());
    if (mTrackType == MEDIA_TRACK_TYPE_SUBTITLE) {
        dest.writeString(mFormat.getString(MediaFormat.KEY_MIME));
        dest.writeInt(mFormat.getInteger(MediaFormat.KEY_IS_AUTOSELECT));
        dest.writeInt(mFormat.getInteger(MediaFormat.KEY_IS_DEFAULT));
        dest.writeInt(mFormat.getInteger(MediaFormat.KEY_IS_FORCED_SUBTITLE));
    }
}
------------------------
Find a silently evolved API code:android.os.ParcelFileDescriptor.seekTo:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * This is needed for implementing AssetFileDescriptor.AutoCloseOutputStream,
 * and I really don't think we want it to be public.
 * @hide
 */

Body of Frist Method:
{
    if (mWrapped != null) {
        return mWrapped.seekTo(pos);
    } else {
        try {
            return Libcore.os.lseek(mFd, pos, SEEK_SET);
        } catch (ErrnoException e) {
            throw e.rethrowAsIOException();
        }
    }
}
Body of Second Method:
{
    if (mWrapped != null) {
        return mWrapped.seekTo(pos);
    } else {
        try {
            return Os.lseek(mFd, pos, SEEK_SET);
        } catch (ErrnoException e) {
            throw e.rethrowAsIOException();
        }
    }
}
------------------------
Find a silently evolved API code:android.text.format.DateFormat.getBestDateTimePattern:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns the best possible localized form of the given skeleton for the given
 * locale. A skeleton is similar to, and uses the same format characters as, a Unicode
 * <a href="http://www.unicode.org/reports/tr35/#Date_Format_Patterns">UTS #35</a>
 * pattern.
 *
 * <p>One difference is that order is irrelevant. For example, "MMMMd" will return
 * "MMMM d" in the {@code en_US} locale, but "d. MMMM" in the {@code de_CH} locale.
 *
 * <p>Note also in that second example that the necessary punctuation for German was
 * added. For the same input in {@code es_ES}, we'd have even more extra text:
 * "d 'de' MMMM".
 *
 * <p>This method will automatically correct for grammatical necessity. Given the
 * same "MMMMd" input, this method will return "d LLLL" in the {@code fa_IR} locale,
 * where stand-alone months are necessary. Lengths are preserved where meaningful,
 * so "Md" would give a different result to "MMMd", say, except in a locale such as
 * {@code ja_JP} where there is only one length of month.
 *
 * <p>This method will only return patterns that are in CLDR, and is useful whenever
 * you know what elements you want in your format string but don't want to make your
 * code specific to any one locale.
 *
 * @param locale the locale into which the skeleton should be localized
 * @param skeleton a skeleton as described above
 * @return a string pattern suitable for use with {@link java.text.SimpleDateFormat}.
 */

Body of Frist Method:
{
    return ICU.getBestDateTimePattern(skeleton, locale.toString());
}
Body of Second Method:
{
    return ICU.getBestDateTimePattern(skeleton, locale);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothGatt.readCharacteristic:COMMENT
Method Modifier: public      
Comment:/**
 * Reads the requested characteristic from the associated remote device.
 *
 * <p>This is an asynchronous operation. The result of the read operation
 * is reported by the {@link BluetoothGattCallback#onCharacteristicRead}
 * callback.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param characteristic Characteristic to read from the remote device
 * @return true, if the read operation was initiated successfully
 */

Body of Frist Method:
{
    if ((characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_READ) == 0)
        return false;
    if (DBG)
        Log.d(TAG, "readCharacteristic() - uuid: " + characteristic.getUuid());
    if (mService == null || mClientIf == 0)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    try {
        mService.readCharacteristic(mClientIf, device.getAddress(), service.getType(), service.getInstanceId(), new ParcelUuid(service.getUuid()), characteristic.getInstanceId(), new ParcelUuid(characteristic.getUuid()), AUTHENTICATION_NONE);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        return false;
    }
    return true;
}
Body of Second Method:
{
    if ((characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_READ) == 0)
        return false;
    if (VDBG)
        Log.d(TAG, "readCharacteristic() - uuid: " + characteristic.getUuid());
    if (mService == null || mClientIf == 0)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusy) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.readCharacteristic(mClientIf, device.getAddress(), service.getType(), service.getInstanceId(), new ParcelUuid(service.getUuid()), characteristic.getInstanceId(), new ParcelUuid(characteristic.getUuid()), AUTHENTICATION_NONE);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}
------------------------
Find a silently evolved API code:android.graphics.Bitmap.reinit:COMMENT
Method Modifier: default     
Comment:/**
 * Native bitmap has been reconfigured, so set premult and cached
 * width/height values
 */

Body of Frist Method:
{
    mWidth = width;
    mHeight = height;
    mIsPremultiplied = isPremultiplied;
}
Body of Second Method:
{
    mWidth = width;
    mHeight = height;
    mRequestPremultiplied = requestPremultiplied;
}
------------------------
Find a silently evolved API code:android.text.DynamicLayout.updateBlocks:COMMENT
Method Modifier: default     hidden      
Comment:/**
 * This method is called every time the layout is reflowed after an edition.
 * It updates the internal block data structure. The text is split in blocks
 * of contiguous lines, with at least one block for the entire text.
 * When a range of lines is edited, new blocks (from 0 to 3 depending on the
 * overlap structure) will replace the set of overlapping blocks.
 * Blocks are listed in order and are represented by their ending line number.
 * An index is associated to each block (which will be used by display lists),
 * this class simply invalidates the index of blocks overlapping a modification.
 *
 * This method is package private and not private so that it can be tested.
 *
 * @param startLine the first line of the range of modified lines
 * @param endLine the last line of the range, possibly equal to startLine, lower
 * than getLineCount()
 * @param newLineCount the number of lines that will replace the range, possibly 0
 *
 * @hide
 */

Body of Frist Method:
{
    if (mBlockEndLines == null) {
        createBlocks();
        return;
    }
    int firstBlock = -1;
    int lastBlock = -1;
    for (int i = 0; i < mNumberOfBlocks; i++) {
        if (mBlockEndLines[i] >= startLine) {
            firstBlock = i;
            break;
        }
    }
    for (int i = firstBlock; i < mNumberOfBlocks; i++) {
        if (mBlockEndLines[i] >= endLine) {
            lastBlock = i;
            break;
        }
    }
    final int lastBlockEndLine = mBlockEndLines[lastBlock];
    boolean createBlockBefore = startLine > (firstBlock == 0 ? 0 : mBlockEndLines[firstBlock - 1] + 1);
    boolean createBlock = newLineCount > 0;
    boolean createBlockAfter = endLine < mBlockEndLines[lastBlock];
    int numAddedBlocks = 0;
    if (createBlockBefore)
        numAddedBlocks++;
    if (createBlock)
        numAddedBlocks++;
    if (createBlockAfter)
        numAddedBlocks++;
    final int numRemovedBlocks = lastBlock - firstBlock + 1;
    final int newNumberOfBlocks = mNumberOfBlocks + numAddedBlocks - numRemovedBlocks;
    if (newNumberOfBlocks == 0) {
        // Even when text is empty, there is actually one line and hence one block
        mBlockEndLines[0] = 0;
        mBlockIndices[0] = INVALID_BLOCK_INDEX;
        mNumberOfBlocks = 1;
        return;
    }
    if (newNumberOfBlocks > mBlockEndLines.length) {
        final int newSize = ArrayUtils.idealIntArraySize(newNumberOfBlocks);
        int[] blockEndLines = new int[newSize];
        int[] blockIndices = new int[newSize];
        System.arraycopy(mBlockEndLines, 0, blockEndLines, 0, firstBlock);
        System.arraycopy(mBlockIndices, 0, blockIndices, 0, firstBlock);
        System.arraycopy(mBlockEndLines, lastBlock + 1, blockEndLines, firstBlock + numAddedBlocks, mNumberOfBlocks - lastBlock - 1);
        System.arraycopy(mBlockIndices, lastBlock + 1, blockIndices, firstBlock + numAddedBlocks, mNumberOfBlocks - lastBlock - 1);
        mBlockEndLines = blockEndLines;
        mBlockIndices = blockIndices;
    } else {
        System.arraycopy(mBlockEndLines, lastBlock + 1, mBlockEndLines, firstBlock + numAddedBlocks, mNumberOfBlocks - lastBlock - 1);
        System.arraycopy(mBlockIndices, lastBlock + 1, mBlockIndices, firstBlock + numAddedBlocks, mNumberOfBlocks - lastBlock - 1);
    }
    mNumberOfBlocks = newNumberOfBlocks;
    int newFirstChangedBlock;
    final int deltaLines = newLineCount - (endLine - startLine + 1);
    if (deltaLines != 0) {
        // Display list whose index is >= mIndexFirstChangedBlock is valid
        // but it needs to update its drawing location.
        newFirstChangedBlock = firstBlock + numAddedBlocks;
        for (int i = newFirstChangedBlock; i < mNumberOfBlocks; i++) {
            mBlockEndLines[i] += deltaLines;
        }
    } else {
        newFirstChangedBlock = mNumberOfBlocks;
    }
    mIndexFirstChangedBlock = Math.min(mIndexFirstChangedBlock, newFirstChangedBlock);
    int blockIndex = firstBlock;
    if (createBlockBefore) {
        mBlockEndLines[blockIndex] = startLine - 1;
        mBlockIndices[blockIndex] = INVALID_BLOCK_INDEX;
        blockIndex++;
    }
    if (createBlock) {
        mBlockEndLines[blockIndex] = startLine + newLineCount - 1;
        mBlockIndices[blockIndex] = INVALID_BLOCK_INDEX;
        blockIndex++;
    }
    if (createBlockAfter) {
        mBlockEndLines[blockIndex] = lastBlockEndLine + deltaLines;
        mBlockIndices[blockIndex] = INVALID_BLOCK_INDEX;
    }
}
Body of Second Method:
{
    if (mBlockEndLines == null) {
        createBlocks();
        return;
    }
    int firstBlock = -1;
    int lastBlock = -1;
    for (int i = 0; i < mNumberOfBlocks; i++) {
        if (mBlockEndLines[i] >= startLine) {
            firstBlock = i;
            break;
        }
    }
    for (int i = firstBlock; i < mNumberOfBlocks; i++) {
        if (mBlockEndLines[i] >= endLine) {
            lastBlock = i;
            break;
        }
    }
    final int lastBlockEndLine = mBlockEndLines[lastBlock];
    boolean createBlockBefore = startLine > (firstBlock == 0 ? 0 : mBlockEndLines[firstBlock - 1] + 1);
    boolean createBlock = newLineCount > 0;
    boolean createBlockAfter = endLine < mBlockEndLines[lastBlock];
    int numAddedBlocks = 0;
    if (createBlockBefore)
        numAddedBlocks++;
    if (createBlock)
        numAddedBlocks++;
    if (createBlockAfter)
        numAddedBlocks++;
    final int numRemovedBlocks = lastBlock - firstBlock + 1;
    final int newNumberOfBlocks = mNumberOfBlocks + numAddedBlocks - numRemovedBlocks;
    if (newNumberOfBlocks == 0) {
        // Even when text is empty, there is actually one line and hence one block
        mBlockEndLines[0] = 0;
        mBlockIndices[0] = INVALID_BLOCK_INDEX;
        mNumberOfBlocks = 1;
        return;
    }
    if (newNumberOfBlocks > mBlockEndLines.length) {
        int[] blockEndLines = ArrayUtils.newUnpaddedIntArray(Math.max(mBlockEndLines.length * 2, newNumberOfBlocks));
        int[] blockIndices = new int[blockEndLines.length];
        System.arraycopy(mBlockEndLines, 0, blockEndLines, 0, firstBlock);
        System.arraycopy(mBlockIndices, 0, blockIndices, 0, firstBlock);
        System.arraycopy(mBlockEndLines, lastBlock + 1, blockEndLines, firstBlock + numAddedBlocks, mNumberOfBlocks - lastBlock - 1);
        System.arraycopy(mBlockIndices, lastBlock + 1, blockIndices, firstBlock + numAddedBlocks, mNumberOfBlocks - lastBlock - 1);
        mBlockEndLines = blockEndLines;
        mBlockIndices = blockIndices;
    } else {
        System.arraycopy(mBlockEndLines, lastBlock + 1, mBlockEndLines, firstBlock + numAddedBlocks, mNumberOfBlocks - lastBlock - 1);
        System.arraycopy(mBlockIndices, lastBlock + 1, mBlockIndices, firstBlock + numAddedBlocks, mNumberOfBlocks - lastBlock - 1);
    }
    mNumberOfBlocks = newNumberOfBlocks;
    int newFirstChangedBlock;
    final int deltaLines = newLineCount - (endLine - startLine + 1);
    if (deltaLines != 0) {
        // Display list whose index is >= mIndexFirstChangedBlock is valid
        // but it needs to update its drawing location.
        newFirstChangedBlock = firstBlock + numAddedBlocks;
        for (int i = newFirstChangedBlock; i < mNumberOfBlocks; i++) {
            mBlockEndLines[i] += deltaLines;
        }
    } else {
        newFirstChangedBlock = mNumberOfBlocks;
    }
    mIndexFirstChangedBlock = Math.min(mIndexFirstChangedBlock, newFirstChangedBlock);
    int blockIndex = firstBlock;
    if (createBlockBefore) {
        mBlockEndLines[blockIndex] = startLine - 1;
        mBlockIndices[blockIndex] = INVALID_BLOCK_INDEX;
        blockIndex++;
    }
    if (createBlock) {
        mBlockEndLines[blockIndex] = startLine + newLineCount - 1;
        mBlockIndices[blockIndex] = INVALID_BLOCK_INDEX;
        blockIndex++;
    }
    if (createBlockAfter) {
        mBlockEndLines[blockIndex] = lastBlockEndLine + deltaLines;
        mBlockIndices[blockIndex] = INVALID_BLOCK_INDEX;
    }
}
------------------------
Find a silently evolved API code:android.graphics.Canvas.drawColor:COMMENT
Method Modifier: public      
Comment:/**
 * Fill the entire canvas' bitmap (restricted to the current clip) with the
 * specified color, using srcover porterduff mode.
 *
 * @param color the color to draw onto the canvas
 */

Body of Frist Method:
{
    native_drawColor(mNativeCanvas, color);
}
Body of Second Method:
{
    native_drawColor(mNativeCanvasWrapper, color, PorterDuff.Mode.SRC_OVER.nativeInt);
}
------------------------
Find a silently evolved API code:android.widget.CalendarView.setWeekNumberColor:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the color for the week numbers.
 *
 * @param color The week number color.
 *
 * @attr ref android.R.styleable#CalendarView_weekNumberColor
 */

Body of Frist Method:
{
    if (mWeekNumberColor != color) {
        mWeekNumberColor = color;
        if (mShowWeekNumber) {
            invalidateAllWeekViews();
        }
    }
}
Body of Second Method:
{
    mDelegate.setWeekNumberColor(color);
}
------------------------
Find a silently evolved API code:android.content.res.Resources.selectSystemTheme:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (curTheme != 0) {
        return curTheme;
    }
    if (targetSdkVersion < Build.VERSION_CODES.HONEYCOMB) {
        return orig;
    }
    if (targetSdkVersion < Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
        return holo;
    }
    return deviceDefault;
}
Body of Second Method:
{
    if (curTheme != 0) {
        return curTheme;
    }
    if (targetSdkVersion < Build.VERSION_CODES.HONEYCOMB) {
        return orig;
    }
    if (targetSdkVersion < Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
        return holo;
    }
    if (targetSdkVersion < Build.VERSION_CODES.CUR_DEVELOPMENT) {
        return dark;
    }
    return deviceDefault;
}
------------------------
Find a silently evolved API code:android.app.Activity.onPanelClosed:COMMENT
Method Modifier: public      
Comment:/**
 * Default implementation of
 * {@link android.view.Window.Callback#onPanelClosed(int, Menu)} for
 * activities. This calls through to {@link #onOptionsMenuClosed(Menu)}
 * method for the {@link android.view.Window#FEATURE_OPTIONS_PANEL} panel,
 * so that subclasses of Activity don't need to deal with feature codes.
 * For context menus ({@link Window#FEATURE_CONTEXT_MENU}), the
 * {@link #onContextMenuClosed(Menu)} will be called.
 */

Body of Frist Method:
{
    switch(featureId) {
        case Window.FEATURE_OPTIONS_PANEL:
            mFragments.dispatchOptionsMenuClosed(menu);
            onOptionsMenuClosed(menu);
            break;
        case Window.FEATURE_CONTEXT_MENU:
            onContextMenuClosed(menu);
            break;
        case Window.FEATURE_ACTION_BAR:
            initActionBar();
            mActionBar.dispatchMenuVisibilityChanged(false);
            break;
    }
}
Body of Second Method:
{
    switch(featureId) {
        case Window.FEATURE_OPTIONS_PANEL:
            mFragments.dispatchOptionsMenuClosed(menu);
            onOptionsMenuClosed(menu);
            break;
        case Window.FEATURE_CONTEXT_MENU:
            onContextMenuClosed(menu);
            break;
        case Window.FEATURE_ACTION_BAR:
            initWindowDecorActionBar();
            mActionBar.dispatchMenuVisibilityChanged(false);
            break;
    }
}
------------------------
Find a silently evolved API code:android.graphics.Camera.applyToCanvas:COMMENT
Method Modifier: public      
Comment:/**
 * Computes the matrix corresponding to the current transformation
 * and applies it to the specified Canvas.
 *
 * @param canvas The Canvas to set the transform matrix onto
 */

Body of Frist Method:
{
    if (canvas.isHardwareAccelerated()) {
        if (mMatrix == null)
            mMatrix = new Matrix();
        getMatrix(mMatrix);
        canvas.concat(mMatrix);
    } else {
        nativeApplyToCanvas(canvas.mNativeCanvas);
    }
}
Body of Second Method:
{
    if (canvas.isHardwareAccelerated()) {
        if (mMatrix == null)
            mMatrix = new Matrix();
        getMatrix(mMatrix);
        canvas.concat(mMatrix);
    } else {
        nativeApplyToCanvas(canvas.getNativeCanvasWrapper());
    }
}
------------------------
Find a silently evolved API code:android.graphics.drawable.GradientDrawable.setGradientType:COMMENT
Method Modifier: public      
Comment:/**
 * <p>Sets the type of gradient used by this drawable..</p>
 * <p><strong>Note</strong>: changing this property will affect all instances
 * of a drawable loaded from a resource. It is recommended to invoke
 * {@link #mutate()} before changing this property.</p>
 *
 * @param gradient The type of the gradient: {@link #LINEAR_GRADIENT},
 * {@link #RADIAL_GRADIENT} or {@link #SWEEP_GRADIENT}
 *
 * @see #mutate()
 */

Body of Frist Method:
{
    mGradientState.setGradientType(gradient);
    mRectIsDirty = true;
    invalidateSelf();
}
Body of Second Method:
{
    mGradientState.setGradientType(gradient);
    mGradientIsDirty = true;
    invalidateSelf();
}
------------------------
Find a silently evolved API code:android.widget.ImageView.setImageResource:COMMENT
Method Modifier: public      
Comment:/**
 * Sets a drawable as the content of this ImageView.
 *
 * <p class="note">This does Bitmap reading and decoding on the UI
 * thread, which can cause a latency hiccup.  If that's a concern,
 * consider using {@link #setImageDrawable(android.graphics.drawable.Drawable)} or
 * {@link #setImageBitmap(android.graphics.Bitmap)} and
 * {@link android.graphics.BitmapFactory} instead.</p>
 *
 * @param resId the resource identifier of the drawable
 *
 * @attr ref android.R.styleable#ImageView_src
 */

Body of Frist Method:
{
    if (mUri != null || mResource != resId) {
        updateDrawable(null);
        mResource = resId;
        mUri = null;
        final int oldWidth = mDrawableWidth;
        final int oldHeight = mDrawableHeight;
        resolveUri();
        if (oldWidth != mDrawableWidth || oldHeight != mDrawableHeight) {
            requestLayout();
        }
        invalidate();
    }
}
Body of Second Method:
{
    if (mUri != null || mResource != resId) {
        final int oldWidth = mDrawableWidth;
        final int oldHeight = mDrawableHeight;
        updateDrawable(null);
        mResource = resId;
        mUri = null;
        resolveUri();
        if (oldWidth != mDrawableWidth || oldHeight != mDrawableHeight) {
            requestLayout();
        }
        invalidate();
    }
}
------------------------
Find a silently evolved API code:android.content.res.AssetManager.makeStringBlocks:COMMENT
Method Modifier: default     final       
Comment:/*package*/

Body of Frist Method:
{
    final int sysNum = copyFromSystem ? sSystem.mStringBlocks.length : 0;
    final int num = getStringBlockCount();
    mStringBlocks = new StringBlock[num];
    if (localLOGV)
        Log.v(TAG, "Making string blocks for " + this + ": " + num);
    for (int i = 0; i < num; i++) {
        if (i < sysNum) {
            mStringBlocks[i] = sSystem.mStringBlocks[i];
        } else {
            mStringBlocks[i] = new StringBlock(getNativeStringBlock(i), true);
        }
    }
}
Body of Second Method:
{
    final int seedNum = (seed != null) ? seed.length : 0;
    final int num = getStringBlockCount();
    mStringBlocks = new StringBlock[num];
    if (localLOGV)
        Log.v(TAG, "Making string blocks for " + this + ": " + num);
    for (int i = 0; i < num; i++) {
        if (i < seedNum) {
            mStringBlocks[i] = seed[i];
        } else {
            mStringBlocks[i] = new StringBlock(getNativeStringBlock(i), true);
        }
    }
}
------------------------
Find a silently evolved API code:android.media.MediaPlayer.TimeProvider.onNewPlayer:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (mRefresh) {
        synchronized (this) {
            scheduleNotification(NOTIFY_SEEK, 0);
        }
    }
}
Body of Second Method:
{
    if (mRefresh) {
        synchronized (this) {
            mStopped = false;
            mSeeking = true;
            scheduleNotification(NOTIFY_SEEK, 0);
        }
    }
}
------------------------
Find a silently evolved API code:android.util.ArrayMap.get:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve a value from the array.
 * @param key The key of the value to retrieve.
 * @return Returns the value associated with the given key,
 * or null if there is no such key.
 */

Body of Frist Method:
{
    final int index = key == null ? indexOfNull() : indexOf(key, key.hashCode());
    return index >= 0 ? (V) mArray[(index << 1) + 1] : null;
}
Body of Second Method:
{
    final int index = indexOfKey(key);
    return index >= 0 ? (V) mArray[(index << 1) + 1] : null;
}
------------------------
Find a silently evolved API code:android.net.Proxy.validate:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Validate syntax of hostname, port and exclusion list entries
 * {@hide}
 */

Body of Frist Method:
{
    Matcher match = HOSTNAME_PATTERN.matcher(hostname);
    Matcher listMatch = EXCLLIST_PATTERN.matcher(exclList);
    if (!match.matches()) {
        throw new IllegalArgumentException();
    }
    if (!listMatch.matches()) {
        throw new IllegalArgumentException();
    }
    if (hostname.length() > 0 && port.length() == 0) {
        throw new IllegalArgumentException();
    }
    if (port.length() > 0) {
        if (hostname.length() == 0) {
            throw new IllegalArgumentException();
        }
        int portVal = -1;
        try {
            portVal = Integer.parseInt(port);
        } catch (NumberFormatException ex) {
            throw new IllegalArgumentException();
        }
        if (portVal <= 0 || portVal > 0xFFFF) {
            throw new IllegalArgumentException();
        }
    }
}
Body of Second Method:
{
    Matcher match = HOSTNAME_PATTERN.matcher(hostname);
    Matcher listMatch = EXCLLIST_PATTERN.matcher(exclList);
    if (!match.matches())
        return PROXY_HOSTNAME_INVALID;
    if (!listMatch.matches())
        return PROXY_EXCLLIST_INVALID;
    if (hostname.length() > 0 && port.length() == 0)
        return PROXY_PORT_EMPTY;
    if (port.length() > 0) {
        if (hostname.length() == 0)
            return PROXY_HOSTNAME_EMPTY;
        int portVal = -1;
        try {
            portVal = Integer.parseInt(port);
        } catch (NumberFormatException ex) {
            return PROXY_PORT_INVALID;
        }
        if (portVal <= 0 || portVal > 0xFFFF)
            return PROXY_PORT_INVALID;
    }
    return PROXY_VALID;
}
------------------------
Find a silently evolved API code:android.media.MediaPlayer.setVolume:COMMENT
<android.media.MediaPlayer: void setVolume(float,float)>
public      native      hidden      ->public      hidden      
Method Modifier: public      native      hidden      
Method Modifier: Yes         Yes         Yes         
Method Updated:  Yes         No          Yes         
Comment:/*
     * FIXME: Merge this into javadoc comment above when setVolume(float) is not @hide.
     * The single parameter form below is preferred if the channel volumes don't need
     * to be set independently.
     */

Body of Frist Method:

Body of Second Method:
{
    if (isRestricted()) {
        return;
    }
    _setVolume(leftVolume, rightVolume);
}
------------------------
Find a silently evolved API code:android.view.inputmethod.BaseInputConnection.sendKeyEvent:COMMENT
Method Modifier: public      
Comment:/**
 * Provides standard implementation for sending a key event to the window
 * attached to the input connection's view.
 */

Body of Frist Method:
{
    synchronized (mIMM.mH) {
        ViewRootImpl viewRootImpl = mTargetView != null ? mTargetView.getViewRootImpl() : null;
        if (viewRootImpl == null) {
            if (mIMM.mServedView != null) {
                viewRootImpl = mIMM.mServedView.getViewRootImpl();
            }
        }
        if (viewRootImpl != null) {
            viewRootImpl.dispatchKeyFromIme(event);
        }
    }
    return false;
}
Body of Second Method:
{
    synchronized (mIMM.mH) {
        ViewRootImpl viewRootImpl = mTargetView != null ? mTargetView.getViewRootImpl() : null;
        if (viewRootImpl == null) {
            if (mIMM.mServedView != null) {
                viewRootImpl = mIMM.mServedView.getViewRootImpl();
            }
        }
        if (viewRootImpl != null) {
            viewRootImpl.dispatchKeyFromIme(event);
        }
    }
    mIMM.notifyUserAction();
    return false;
}
------------------------
Find a silently evolved API code:android.os.Process.openZygoteSocketIfNeeded:COMMENT
Method Modifier: private     static      
Comment:/**
 * Tries to open socket to Zygote process if not already open. If
 * already open, does nothing.  May block and retry.
 */

Body of Frist Method:
{
    int retryCount;
    if (sPreviousZygoteOpenFailed) {
        /*
             * If we've failed before, expect that we'll fail again and
             * don't pause for retries.
             */
        retryCount = 0;
    } else {
        retryCount = 10;
    }
    /*
         * See bug #811181: Sometimes runtime can make it up before zygote.
         * Really, we'd like to do something better to avoid this condition,
         * but for now just wait a bit...
         */
    for (int retry = 0; (sZygoteSocket == null) && (retry < (retryCount + 1)); retry++) {
        if (retry > 0) {
            try {
                Log.i("Zygote", "Zygote not up yet, sleeping...");
                Thread.sleep(ZYGOTE_RETRY_MILLIS);
            } catch (InterruptedException ex) {
            // should never happen
            }
        }
        try {
            sZygoteSocket = new LocalSocket();
            sZygoteSocket.connect(new LocalSocketAddress(ZYGOTE_SOCKET, LocalSocketAddress.Namespace.RESERVED));
            sZygoteInputStream = new DataInputStream(sZygoteSocket.getInputStream());
            sZygoteWriter = new BufferedWriter(new OutputStreamWriter(sZygoteSocket.getOutputStream()), 256);
            Log.i("Zygote", "Process: zygote socket opened");
            sPreviousZygoteOpenFailed = false;
            break;
        } catch (IOException ex) {
            if (sZygoteSocket != null) {
                try {
                    sZygoteSocket.close();
                } catch (IOException ex2) {
                    Log.e(LOG_TAG, "I/O exception on close after exception", ex2);
                }
            }
            sZygoteSocket = null;
        }
    }
    if (sZygoteSocket == null) {
        sPreviousZygoteOpenFailed = true;
        throw new ZygoteStartFailedEx("connect failed");
    }
}
Body of Second Method:
{
    if (primaryZygoteState == null || primaryZygoteState.isClosed()) {
        try {
            primaryZygoteState = ZygoteState.connect(ZYGOTE_SOCKET);
        } catch (IOException ioe) {
            throw new ZygoteStartFailedEx("Error connecting to primary zygote", ioe);
        }
    }
    if (primaryZygoteState.matches(abi)) {
        return primaryZygoteState;
    }
    // The primary zygote didn't match. Try the secondary.
    if (secondaryZygoteState == null || secondaryZygoteState.isClosed()) {
        try {
            secondaryZygoteState = ZygoteState.connect(SECONDARY_ZYGOTE_SOCKET);
        } catch (IOException ioe) {
            throw new ZygoteStartFailedEx("Error connecting to secondary zygote", ioe);
        }
    }
    if (secondaryZygoteState.matches(abi)) {
        return secondaryZygoteState;
    }
    throw new ZygoteStartFailedEx("Unsupported zygote ABI: " + abi);
}
------------------------
Find a silently evolved API code:android.app.ActivityManager.getLauncherLargeIconSize:COMMENT
Method Modifier: public      
Comment:/**
 * Get the preferred launcher icon size. This is used when custom drawables
 * are created (e.g., for shortcuts).
 *
 * @return dimensions of square icons in terms of pixels
 */

Body of Frist Method:
{
    final Resources res = mContext.getResources();
    final int size = res.getDimensionPixelSize(android.R.dimen.app_icon_size);
    final int sw = res.getConfiguration().smallestScreenWidthDp;
    if (sw < 600) {
        // Smaller than approx 7" tablets, use the regular icon size.
        return size;
    }
    final int density = res.getDisplayMetrics().densityDpi;
    switch(density) {
        case DisplayMetrics.DENSITY_LOW:
            return (size * DisplayMetrics.DENSITY_MEDIUM) / DisplayMetrics.DENSITY_LOW;
        case DisplayMetrics.DENSITY_MEDIUM:
            return (size * DisplayMetrics.DENSITY_HIGH) / DisplayMetrics.DENSITY_MEDIUM;
        case DisplayMetrics.DENSITY_TV:
            return (size * DisplayMetrics.DENSITY_XHIGH) / DisplayMetrics.DENSITY_HIGH;
        case DisplayMetrics.DENSITY_HIGH:
            return (size * DisplayMetrics.DENSITY_XHIGH) / DisplayMetrics.DENSITY_HIGH;
        case DisplayMetrics.DENSITY_XHIGH:
            return (size * DisplayMetrics.DENSITY_XXHIGH) / DisplayMetrics.DENSITY_XHIGH;
        case DisplayMetrics.DENSITY_XXHIGH:
            return (size * DisplayMetrics.DENSITY_XHIGH * 2) / DisplayMetrics.DENSITY_XXHIGH;
        default:
            // abnormal value that is a reasonable scaling of it.
            return (int) ((size * 1.5f) + .5f);
    }
}
Body of Second Method:
{
    return getLauncherLargeIconSizeInner(mContext);
}
------------------------
Find a silently evolved API code:android.text.Layout.isRtlCharAt:COMMENT
Method Modifier: public      
Comment:/**
 * Returns true if the character at offset is right to left (RTL).
 * @param offset the offset
 * @return true if the character is RTL, false if it is LTR
 */

Body of Frist Method:
{
    int line = getLineForOffset(offset);
    Directions dirs = getLineDirections(line);
    if (dirs == DIRS_ALL_LEFT_TO_RIGHT) {
        return false;
    }
    if (dirs == DIRS_ALL_RIGHT_TO_LEFT) {
        return true;
    }
    int[] runs = dirs.mDirections;
    int lineStart = getLineStart(line);
    for (int i = 0; i < runs.length; i += 2) {
        int start = lineStart + (runs[i] & RUN_LENGTH_MASK);
        // corresponding of the last run
        if (offset >= start) {
            int level = (runs[i + 1] >>> RUN_LEVEL_SHIFT) & RUN_LEVEL_MASK;
            return ((level & 1) != 0);
        }
    }
    // Should happen only if the offset is "out of bounds"
    return false;
}
Body of Second Method:
{
    int line = getLineForOffset(offset);
    Directions dirs = getLineDirections(line);
    if (dirs == DIRS_ALL_LEFT_TO_RIGHT) {
        return false;
    }
    if (dirs == DIRS_ALL_RIGHT_TO_LEFT) {
        return true;
    }
    int[] runs = dirs.mDirections;
    int lineStart = getLineStart(line);
    for (int i = 0; i < runs.length; i += 2) {
        int start = lineStart + runs[i];
        int limit = start + (runs[i + 1] & RUN_LENGTH_MASK);
        if (offset >= start && offset < limit) {
            int level = (runs[i + 1] >>> RUN_LEVEL_SHIFT) & RUN_LEVEL_MASK;
            return ((level & 1) != 0);
        }
    }
    // Should happen only if the offset is "out of bounds"
    return false;
}
------------------------
Find a silently evolved API code:android.app.admin.DevicePolicyManager.setGlobalProxy:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Called by an application that is administering the device to set the
 * global proxy and exclusion list.
 * <p>
 * The calling device admin must have requested
 * {@link DeviceAdminInfo#USES_POLICY_SETS_GLOBAL_PROXY} to be able to call
 * this method; if it has not, a security exception will be thrown.
 * Only the first device admin can set the proxy. If a second admin attempts
 * to set the proxy, the {@link ComponentName} of the admin originally setting the
 * proxy will be returned. If successful in setting the proxy, null will
 * be returned.
 * The method can be called repeatedly by the device admin alrady setting the
 * proxy to update the proxy and exclusion list.
 *
 * @param admin Which {@link DeviceAdminReceiver} this request is associated
 * with.
 * @param proxySpec the global proxy desired. Must be an HTTP Proxy.
 * Pass Proxy.NO_PROXY to reset the proxy.
 * @param exclusionList a list of domains to be excluded from the global proxy.
 * @return returns null if the proxy was successfully set, or a {@link ComponentName}
 * of the device admin that sets thew proxy otherwise.
 * @hide
 */

Body of Frist Method:
{
    if (proxySpec == null) {
        throw new NullPointerException();
    }
    if (mService != null) {
        try {
            String hostSpec;
            String exclSpec;
            if (proxySpec.equals(Proxy.NO_PROXY)) {
                hostSpec = null;
                exclSpec = null;
            } else {
                if (!proxySpec.type().equals(Proxy.Type.HTTP)) {
                    throw new IllegalArgumentException();
                }
                InetSocketAddress sa = (InetSocketAddress) proxySpec.address();
                String hostName = sa.getHostName();
                int port = sa.getPort();
                StringBuilder hostBuilder = new StringBuilder();
                hostSpec = hostBuilder.append(hostName).append(":").append(Integer.toString(port)).toString();
                if (exclusionList == null) {
                    exclSpec = "";
                } else {
                    StringBuilder listBuilder = new StringBuilder();
                    boolean firstDomain = true;
                    for (String exclDomain : exclusionList) {
                        if (!firstDomain) {
                            listBuilder = listBuilder.append(",");
                        } else {
                            firstDomain = false;
                        }
                        listBuilder = listBuilder.append(exclDomain.trim());
                    }
                    exclSpec = listBuilder.toString();
                }
                android.net.Proxy.validate(hostName, Integer.toString(port), exclSpec);
            }
            return mService.setGlobalProxy(admin, hostSpec, exclSpec, UserHandle.myUserId());
        } catch (RemoteException e) {
            Log.w(TAG, "Failed talking with device policy service", e);
        }
    }
    return null;
}
Body of Second Method:
{
    if (proxySpec == null) {
        throw new NullPointerException();
    }
    if (mService != null) {
        try {
            String hostSpec;
            String exclSpec;
            if (proxySpec.equals(Proxy.NO_PROXY)) {
                hostSpec = null;
                exclSpec = null;
            } else {
                if (!proxySpec.type().equals(Proxy.Type.HTTP)) {
                    throw new IllegalArgumentException();
                }
                InetSocketAddress sa = (InetSocketAddress) proxySpec.address();
                String hostName = sa.getHostName();
                int port = sa.getPort();
                StringBuilder hostBuilder = new StringBuilder();
                hostSpec = hostBuilder.append(hostName).append(":").append(Integer.toString(port)).toString();
                if (exclusionList == null) {
                    exclSpec = "";
                } else {
                    StringBuilder listBuilder = new StringBuilder();
                    boolean firstDomain = true;
                    for (String exclDomain : exclusionList) {
                        if (!firstDomain) {
                            listBuilder = listBuilder.append(",");
                        } else {
                            firstDomain = false;
                        }
                        listBuilder = listBuilder.append(exclDomain.trim());
                    }
                    exclSpec = listBuilder.toString();
                }
                if (android.net.Proxy.validate(hostName, Integer.toString(port), exclSpec) != android.net.Proxy.PROXY_VALID)
                    throw new IllegalArgumentException();
            }
            return mService.setGlobalProxy(admin, hostSpec, exclSpec, UserHandle.myUserId());
        } catch (RemoteException e) {
            Log.w(TAG, "Failed talking with device policy service", e);
        }
    }
    return null;
}
------------------------
Find a silently evolved API code:android.graphics.Matrix.preRotate:COMMENT
Method Modifier: public      
Comment:/**
 * Preconcats the matrix with the specified rotation.
 * M' = M * R(degrees)
 */

Body of Frist Method:
{
    return native_preRotate(native_instance, degrees);
}
Body of Second Method:
{
    native_preRotate(native_instance, degrees);
    return true;
}
------------------------
Find a silently evolved API code:android.graphics.Bitmap.setPixel:COMMENT
Method Modifier: public      
Comment:/**
 * <p>Write the specified {@link Color} into the bitmap (assuming it is
 * mutable) at the x,y coordinate. The color must be a
 * non-premultiplied ARGB value.</p>
 *
 * @param x     The x coordinate of the pixel to replace (0...width-1)
 * @param y     The y coordinate of the pixel to replace (0...height-1)
 * @param color The ARGB color to write into the bitmap
 *
 * @throws IllegalStateException if the bitmap is not mutable
 * @throws IllegalArgumentException if x, y are outside of the bitmap's
 * bounds.
 */

Body of Frist Method:
{
    checkRecycled("Can't call setPixel() on a recycled bitmap");
    if (!isMutable()) {
        throw new IllegalStateException();
    }
    checkPixelAccess(x, y);
    nativeSetPixel(mNativeBitmap, x, y, color, mIsPremultiplied);
}
Body of Second Method:
{
    checkRecycled("Can't call setPixel() on a recycled bitmap");
    if (!isMutable()) {
        throw new IllegalStateException();
    }
    checkPixelAccess(x, y);
    nativeSetPixel(mNativeBitmap, x, y, color);
}
------------------------
Find a silently evolved API code:android.os.Bundle.getCharArray:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return a char[] value, or null
 */

Body of Frist Method:
{
    unparcel();
    Object o = mMap.get(key);
    if (o == null) {
        return null;
    }
    try {
        return (char[]) o;
    } catch (ClassCastException e) {
        typeWarning(key, o, "char[]", e);
        return null;
    }
}
Body of Second Method:
{
    return super.getCharArray(key);
}
------------------------
Find a silently evolved API code:android.widget.TextView.getExtendedPaddingTop:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the extended top padding of the view, including both the
 * top Drawable if any and any extra space to keep more than maxLines
 * of text from showing.  It is only valid to call this after measuring.
 */

Body of Frist Method:
{
    if (mMaxMode != LINES) {
        return getCompoundPaddingTop();
    }
    if (mLayout.getLineCount() <= mMaximum) {
        return getCompoundPaddingTop();
    }
    int top = getCompoundPaddingTop();
    int bottom = getCompoundPaddingBottom();
    int viewht = getHeight() - top - bottom;
    int layoutht = mLayout.getLineTop(mMaximum);
    if (layoutht >= viewht) {
        return top;
    }
    final int gravity = mGravity & Gravity.VERTICAL_GRAVITY_MASK;
    if (gravity == Gravity.TOP) {
        return top;
    } else if (gravity == Gravity.BOTTOM) {
        return top + viewht - layoutht;
    } else {
        // (gravity == Gravity.CENTER_VERTICAL)
        return top + (viewht - layoutht) / 2;
    }
}
Body of Second Method:
{
    if (mMaxMode != LINES) {
        return getCompoundPaddingTop();
    }
    if (mLayout == null) {
        assumeLayout();
    }
    if (mLayout.getLineCount() <= mMaximum) {
        return getCompoundPaddingTop();
    }
    int top = getCompoundPaddingTop();
    int bottom = getCompoundPaddingBottom();
    int viewht = getHeight() - top - bottom;
    int layoutht = mLayout.getLineTop(mMaximum);
    if (layoutht >= viewht) {
        return top;
    }
    final int gravity = mGravity & Gravity.VERTICAL_GRAVITY_MASK;
    if (gravity == Gravity.TOP) {
        return top;
    } else if (gravity == Gravity.BOTTOM) {
        return top + viewht - layoutht;
    } else {
        // (gravity == Gravity.CENTER_VERTICAL)
        return top + (viewht - layoutht) / 2;
    }
}
------------------------
Find a silently evolved API code:android.view.ViewGroup.clearDisappearingChildren:COMMENT
Method Modifier: public      
Comment:/**
 * Removes any pending animations for views that have been removed. Call
 * this if you don't want animations for exiting views to stack up.
 */

Body of Frist Method:
{
    if (mDisappearingChildren != null) {
        mDisappearingChildren.clear();
        invalidate();
    }
}
Body of Second Method:
{
    final ArrayList<View> disappearingChildren = mDisappearingChildren;
    if (disappearingChildren != null) {
        final int count = disappearingChildren.size();
        for (int i = 0; i < count; i++) {
            final View view = disappearingChildren.get(i);
            if (view.mAttachInfo != null) {
                view.dispatchDetachedFromWindow();
            }
            view.clearAnimation();
        }
        disappearingChildren.clear();
        invalidate();
    }
}
------------------------
Find a silently evolved API code:android.media.MediaRouter.RouteInfo.isConnecting:COMMENT
Method Modifier: public      
Comment:/**
 * Returns true if the route is in the process of connecting and is not
 * yet ready for use.
 *
 * @return True if this route is in the process of connecting.
 */

Body of Frist Method:
{
    return mStatusCode == STATUS_CONNECTING;
}
Body of Second Method:
{
    return mResolvedStatusCode == STATUS_CONNECTING;
}
------------------------
Find a silently evolved API code:android.widget.FastScroller.cancelPendingDrag:COMMENT
Method Modifier: private     
Comment:/**
 * Cancels a pending drag.
 *
 * @see #startPendingDrag()
 */

Body of Frist Method:
{
    mList.removeCallbacks(mDeferStartDrag);
    mHasPendingDrag = false;
}
Body of Second Method:
{
    mPendingDrag = -1;
}
------------------------
Find a silently evolved API code:android.net.MobileDataStateTracker.setEnableApn:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Internal method supporting the ENABLE_MMS feature.
 * @param apnType the type of APN to be enabled or disabled (e.g., mms)
 * @param enable {@code true} to enable the specified APN type,
 * {@code false} to disable it.
 * @return an integer value representing the outcome of the request.
 */

Body of Frist Method:
{
    getPhoneService(false);
    /*
         * If the phone process has crashed in the past, we'll get a
         * RemoteException and need to re-reference the service.
         */
    for (int retry = 0; retry < 2; retry++) {
        if (mPhoneService == null) {
            loge("Ignoring feature request because could not acquire PhoneService");
            break;
        }
        try {
            if (enable) {
                return mPhoneService.enableApnType(apnType);
            } else {
                return mPhoneService.disableApnType(apnType);
            }
        } catch (RemoteException e) {
            if (retry == 0)
                getPhoneService(true);
        }
    }
    loge("Could not " + (enable ? "enable" : "disable") + " APN type \"" + apnType + "\"");
    return PhoneConstants.APN_REQUEST_FAILED;
}
Body of Second Method:
{
    getPhoneService(false);
    /*
         * If the phone process has crashed in the past, we'll get a
         * RemoteException and need to re-reference the service.
         */
    for (int retry = 0; retry < 2; retry++) {
        if (mPhoneService == null) {
            loge("Ignoring feature request because could not acquire PhoneService");
            break;
        }
    // try {
    // if (enable) {
    // return mPhoneService.enableApnType(apnType);
    // } else {
    // return mPhoneService.disableApnType(apnType);
    // }
    // } catch (RemoteException e) {
    // if (retry == 0) getPhoneService(true);
    // }
    }
    loge("Could not " + (enable ? "enable" : "disable") + " APN type \"" + apnType + "\"");
    return PhoneConstants.APN_REQUEST_FAILED;
}
------------------------
Find a silently evolved API code:android.view.accessibility.AccessibilityManager.addAccessibilityStateChangeListener:COMMENT
Method Modifier: public      
Comment:/**
 * Registers an {@link AccessibilityStateChangeListener} for changes in
 * the global accessibility state of the system.
 *
 * @param listener The listener.
 * @return True if successfully registered.
 */

Body of Frist Method:
{
    return mAccessibilityStateChangeListeners.add(listener);
}
Body of Second Method:
{
    // Final CopyOnArrayList - no lock needed.
    return mAccessibilityStateChangeListeners.add(listener);
}
------------------------
Find a silently evolved API code:android.widget.AbsListView.invokeOnItemScrollListener:COMMENT
Method Modifier: default     
Comment:/**
 * Notify our scroll listener (if there is one) of a change in scroll state
 */

Body of Frist Method:
{
    if (mFastScroller != null) {
        mFastScroller.onScroll(mFirstPosition, getChildCount(), mItemCount);
    }
    if (mOnScrollListener != null) {
        mOnScrollListener.onScroll(this, mFirstPosition, getChildCount(), mItemCount);
    }
    // dummy values, View's implementation does not use these.
    onScrollChanged(0, 0, 0, 0);
}
Body of Second Method:
{
    if (mFastScroll != null) {
        mFastScroll.onScroll(mFirstPosition, getChildCount(), mItemCount);
    }
    if (mOnScrollListener != null) {
        mOnScrollListener.onScroll(this, mFirstPosition, getChildCount(), mItemCount);
    }
    // dummy values, View's implementation does not use these.
    onScrollChanged(0, 0, 0, 0);
}
------------------------
Find a silently evolved API code:android.widget.Toast.show:COMMENT
Method Modifier: public      
Comment:/**
 * Show the view for the specified duration.
 */

Body of Frist Method:
{
    if (mNextView == null) {
        throw new RuntimeException("setView must have been called");
    }
    INotificationManager service = getService();
    String pkg = mContext.getPackageName();
    TN tn = mTN;
    tn.mNextView = mNextView;
    try {
        service.enqueueToast(pkg, tn, mDuration);
    } catch (RemoteException e) {
    // Empty
    }
}
Body of Second Method:
{
    if (mNextView == null) {
        throw new RuntimeException("setView must have been called");
    }
    INotificationManager service = getService();
    String pkg = mContext.getOpPackageName();
    TN tn = mTN;
    tn.mNextView = mNextView;
    try {
        service.enqueueToast(pkg, tn, mDuration);
    } catch (RemoteException e) {
    // Empty
    }
}
------------------------
Find a silently evolved API code:android.util.SparseIntArray.append:COMMENT
Method Modifier: public      
Comment:/**
 * Puts a key/value pair into the array, optimizing for the case where
 * the key is greater than all existing keys in the array.
 */

Body of Frist Method:
{
    if (mSize != 0 && key <= mKeys[mSize - 1]) {
        put(key, value);
        return;
    }
    int pos = mSize;
    if (pos >= mKeys.length) {
        int n = ArrayUtils.idealIntArraySize(pos + 1);
        int[] nkeys = new int[n];
        int[] nvalues = new int[n];
        // Log.e("SparseIntArray", "grow " + mKeys.length + " to " + n);
        System.arraycopy(mKeys, 0, nkeys, 0, mKeys.length);
        System.arraycopy(mValues, 0, nvalues, 0, mValues.length);
        mKeys = nkeys;
        mValues = nvalues;
    }
    mKeys[pos] = key;
    mValues[pos] = value;
    mSize = pos + 1;
}
Body of Second Method:
{
    if (mSize != 0 && key <= mKeys[mSize - 1]) {
        put(key, value);
        return;
    }
    mKeys = GrowingArrayUtils.append(mKeys, mSize, key);
    mValues = GrowingArrayUtils.append(mValues, mSize, value);
    mSize++;
}
------------------------
Find a silently evolved API code:android.widget.FastScroller.transitionToDragging:COMMENT
Method Modifier: private     
Comment:/**
 * Shows the thumb, preview, and track.
 */

Body of Frist Method:
{
    if (mDecorAnimation != null) {
        mDecorAnimation.cancel();
    }
    final Animator fadeIn = groupAnimatorOfFloat(View.ALPHA, 1f, mThumbImage, mTrackImage, mPreviewImage).setDuration(DURATION_FADE_IN);
    final Animator slideIn = groupAnimatorOfFloat(View.TRANSLATION_X, 0f, mThumbImage, mTrackImage).setDuration(DURATION_FADE_IN);
    mDecorAnimation = new AnimatorSet();
    mDecorAnimation.playTogether(fadeIn, slideIn);
    mDecorAnimation.start();
}
Body of Second Method:
{
    if (mDecorAnimation != null) {
        mDecorAnimation.cancel();
    }
    final Animator fadeIn = groupAnimatorOfFloat(View.ALPHA, 1f, mThumbImage, mTrackImage, mPreviewImage).setDuration(DURATION_FADE_IN);
    final Animator slideIn = groupAnimatorOfFloat(View.TRANSLATION_X, 0f, mThumbImage, mTrackImage).setDuration(DURATION_FADE_IN);
    mDecorAnimation = new AnimatorSet();
    mDecorAnimation.playTogether(fadeIn, slideIn);
    mDecorAnimation.start();
    mShowingPreview = true;
}
------------------------
Find a silently evolved API code:android.graphics.Canvas.skew:COMMENT
<android.graphics.Canvas: void skew(float,float)>
public      native      ->public      
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * Preconcat the current matrix with the specified skew.
 *
 * @param sx The amount to skew in X
 * @param sy The amount to skew in Y
 */

Body of Frist Method:

Body of Second Method:
{
    native_skew(mNativeCanvasWrapper, sx, sy);
}
------------------------
Find a silently evolved API code:android.appwidget.AppWidgetManager.getAppWidgetIds:COMMENT
Method Modifier: public      
Comment:/**
 * Get the list of appWidgetIds that have been bound to the given AppWidget
 * provider.
 *
 * @param provider The {@link android.content.BroadcastReceiver} that is the
 * AppWidget provider to find appWidgetIds for.
 */

Body of Frist Method:
{
    try {
        return sService.getAppWidgetIds(provider, mContext.getUserId());
    } catch (RemoteException e) {
        throw new RuntimeException("system server dead?", e);
    }
}
Body of Second Method:
{
    if (mService == null) {
        return new int[0];
    }
    try {
        return mService.getAppWidgetIds(provider);
    } catch (RemoteException e) {
        throw new RuntimeException("system server dead?", e);
    }
}
------------------------
Find a silently evolved API code:android.view.accessibility.AccessibilityEvent.eventTypeToString:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns the string representation of an event type. For example,
 * {@link #TYPE_VIEW_CLICKED} is represented by the string TYPE_VIEW_CLICKED.
 *
 * @param eventType The event type
 * @return The string representation.
 */

Body of Frist Method:
{
    if (eventType == TYPES_ALL_MASK) {
        return "TYPES_ALL_MASK";
    }
    StringBuilder builder = new StringBuilder();
    int eventTypeCount = 0;
    while (eventType != 0) {
        final int eventTypeFlag = 1 << Integer.numberOfTrailingZeros(eventType);
        eventType &= ~eventTypeFlag;
        switch(eventTypeFlag) {
            case TYPE_VIEW_CLICKED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_VIEW_CLICKED");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_LONG_CLICKED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_VIEW_LONG_CLICKED");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_SELECTED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_VIEW_SELECTED");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_FOCUSED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_VIEW_FOCUSED");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_TEXT_CHANGED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_VIEW_TEXT_CHANGED");
                    eventTypeCount++;
                }
                break;
            case TYPE_WINDOW_STATE_CHANGED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_WINDOW_STATE_CHANGED");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_HOVER_ENTER:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_VIEW_HOVER_ENTER");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_HOVER_EXIT:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_VIEW_HOVER_EXIT");
                    eventTypeCount++;
                }
                break;
            case TYPE_NOTIFICATION_STATE_CHANGED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_NOTIFICATION_STATE_CHANGED");
                    eventTypeCount++;
                }
                break;
            case TYPE_TOUCH_EXPLORATION_GESTURE_START:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_TOUCH_EXPLORATION_GESTURE_START");
                    eventTypeCount++;
                }
                break;
            case TYPE_TOUCH_EXPLORATION_GESTURE_END:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_TOUCH_EXPLORATION_GESTURE_END");
                    eventTypeCount++;
                }
                break;
            case TYPE_WINDOW_CONTENT_CHANGED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_WINDOW_CONTENT_CHANGED");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_TEXT_SELECTION_CHANGED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_VIEW_TEXT_SELECTION_CHANGED");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_SCROLLED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_VIEW_SCROLLED");
                    eventTypeCount++;
                }
                break;
            case TYPE_ANNOUNCEMENT:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_ANNOUNCEMENT");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_ACCESSIBILITY_FOCUSED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_VIEW_ACCESSIBILITY_FOCUSED");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_TEXT_TRAVERSED_AT_MOVEMENT_GRANULARITY:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_VIEW_TEXT_TRAVERSED_AT_MOVEMENT_GRANULARITY");
                    eventTypeCount++;
                }
                break;
            case TYPE_GESTURE_DETECTION_START:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_GESTURE_DETECTION_START");
                    eventTypeCount++;
                }
                break;
            case TYPE_GESTURE_DETECTION_END:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_GESTURE_DETECTION_END");
                    eventTypeCount++;
                }
                break;
            case TYPE_TOUCH_INTERACTION_START:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_TOUCH_INTERACTION_START");
                    eventTypeCount++;
                }
                break;
            case TYPE_TOUCH_INTERACTION_END:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_TOUCH_INTERACTION_END");
                    eventTypeCount++;
                }
                break;
        }
    }
    if (eventTypeCount > 1) {
        builder.insert(0, '[');
        builder.append(']');
    }
    return builder.toString();
}
Body of Second Method:
{
    if (eventType == TYPES_ALL_MASK) {
        return "TYPES_ALL_MASK";
    }
    StringBuilder builder = new StringBuilder();
    int eventTypeCount = 0;
    while (eventType != 0) {
        final int eventTypeFlag = 1 << Integer.numberOfTrailingZeros(eventType);
        eventType &= ~eventTypeFlag;
        switch(eventTypeFlag) {
            case TYPE_VIEW_CLICKED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_VIEW_CLICKED");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_LONG_CLICKED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_VIEW_LONG_CLICKED");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_SELECTED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_VIEW_SELECTED");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_FOCUSED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_VIEW_FOCUSED");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_TEXT_CHANGED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_VIEW_TEXT_CHANGED");
                    eventTypeCount++;
                }
                break;
            case TYPE_WINDOW_STATE_CHANGED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_WINDOW_STATE_CHANGED");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_HOVER_ENTER:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_VIEW_HOVER_ENTER");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_HOVER_EXIT:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_VIEW_HOVER_EXIT");
                    eventTypeCount++;
                }
                break;
            case TYPE_NOTIFICATION_STATE_CHANGED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_NOTIFICATION_STATE_CHANGED");
                    eventTypeCount++;
                }
                break;
            case TYPE_TOUCH_EXPLORATION_GESTURE_START:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_TOUCH_EXPLORATION_GESTURE_START");
                    eventTypeCount++;
                }
                break;
            case TYPE_TOUCH_EXPLORATION_GESTURE_END:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_TOUCH_EXPLORATION_GESTURE_END");
                    eventTypeCount++;
                }
                break;
            case TYPE_WINDOW_CONTENT_CHANGED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_WINDOW_CONTENT_CHANGED");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_TEXT_SELECTION_CHANGED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_VIEW_TEXT_SELECTION_CHANGED");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_SCROLLED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_VIEW_SCROLLED");
                    eventTypeCount++;
                }
                break;
            case TYPE_ANNOUNCEMENT:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_ANNOUNCEMENT");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_ACCESSIBILITY_FOCUSED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_VIEW_ACCESSIBILITY_FOCUSED");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_TEXT_TRAVERSED_AT_MOVEMENT_GRANULARITY:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_VIEW_TEXT_TRAVERSED_AT_MOVEMENT_GRANULARITY");
                    eventTypeCount++;
                }
                break;
            case TYPE_GESTURE_DETECTION_START:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_GESTURE_DETECTION_START");
                    eventTypeCount++;
                }
                break;
            case TYPE_GESTURE_DETECTION_END:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_GESTURE_DETECTION_END");
                    eventTypeCount++;
                }
                break;
            case TYPE_TOUCH_INTERACTION_START:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_TOUCH_INTERACTION_START");
                    eventTypeCount++;
                }
                break;
            case TYPE_TOUCH_INTERACTION_END:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_TOUCH_INTERACTION_END");
                    eventTypeCount++;
                }
                break;
            case TYPE_WINDOWS_CHANGED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_WINDOWS_CHANGED");
                    eventTypeCount++;
                }
                break;
        }
    }
    if (eventTypeCount > 1) {
        builder.insert(0, '[');
        builder.append(']');
    }
    return builder.toString();
}
------------------------
Find a silently evolved API code:android.text.MeasuredText.setPara:COMMENT
Method Modifier: default     hidden      
Comment:/**
 * Analyzes text for bidirectional runs.  Allocates working buffers.
 */

Body of Frist Method:
{
    mText = text;
    mTextStart = start;
    int len = end - start;
    mLen = len;
    mPos = 0;
    if (mWidths == null || mWidths.length < len) {
        mWidths = new float[ArrayUtils.idealFloatArraySize(len)];
    }
    if (mChars == null || mChars.length < len) {
        mChars = new char[ArrayUtils.idealCharArraySize(len)];
    }
    TextUtils.getChars(text, start, end, mChars, 0);
    if (text instanceof Spanned) {
        Spanned spanned = (Spanned) text;
        ReplacementSpan[] spans = spanned.getSpans(start, end, ReplacementSpan.class);
        for (int i = 0; i < spans.length; i++) {
            int startInPara = spanned.getSpanStart(spans[i]) - start;
            int endInPara = spanned.getSpanEnd(spans[i]) - start;
            // The span interval may be larger and must be restricted to [start, end[
            if (startInPara < 0)
                startInPara = 0;
            if (endInPara > len)
                endInPara = len;
            for (int j = startInPara; j < endInPara; j++) {
                // object replacement character
                mChars[j] = '\uFFFC';
            }
        }
    }
    if ((textDir == TextDirectionHeuristics.LTR || textDir == TextDirectionHeuristics.FIRSTSTRONG_LTR || textDir == TextDirectionHeuristics.ANYRTL_LTR) && TextUtils.doesNotNeedBidi(mChars, 0, len)) {
        mDir = Layout.DIR_LEFT_TO_RIGHT;
        mEasy = true;
    } else {
        if (mLevels == null || mLevels.length < len) {
            mLevels = new byte[ArrayUtils.idealByteArraySize(len)];
        }
        int bidiRequest;
        if (textDir == TextDirectionHeuristics.LTR) {
            bidiRequest = Layout.DIR_REQUEST_LTR;
        } else if (textDir == TextDirectionHeuristics.RTL) {
            bidiRequest = Layout.DIR_REQUEST_RTL;
        } else if (textDir == TextDirectionHeuristics.FIRSTSTRONG_LTR) {
            bidiRequest = Layout.DIR_REQUEST_DEFAULT_LTR;
        } else if (textDir == TextDirectionHeuristics.FIRSTSTRONG_RTL) {
            bidiRequest = Layout.DIR_REQUEST_DEFAULT_RTL;
        } else {
            boolean isRtl = textDir.isRtl(mChars, 0, len);
            bidiRequest = isRtl ? Layout.DIR_REQUEST_RTL : Layout.DIR_REQUEST_LTR;
        }
        mDir = AndroidBidi.bidi(bidiRequest, mChars, mLevels, len, false);
        mEasy = false;
    }
}
Body of Second Method:
{
    mText = text;
    mTextStart = start;
    int len = end - start;
    mLen = len;
    mPos = 0;
    if (mWidths == null || mWidths.length < len) {
        mWidths = ArrayUtils.newUnpaddedFloatArray(len);
    }
    if (mChars == null || mChars.length < len) {
        mChars = ArrayUtils.newUnpaddedCharArray(len);
    }
    TextUtils.getChars(text, start, end, mChars, 0);
    if (text instanceof Spanned) {
        Spanned spanned = (Spanned) text;
        ReplacementSpan[] spans = spanned.getSpans(start, end, ReplacementSpan.class);
        for (int i = 0; i < spans.length; i++) {
            int startInPara = spanned.getSpanStart(spans[i]) - start;
            int endInPara = spanned.getSpanEnd(spans[i]) - start;
            // The span interval may be larger and must be restricted to [start, end[
            if (startInPara < 0)
                startInPara = 0;
            if (endInPara > len)
                endInPara = len;
            for (int j = startInPara; j < endInPara; j++) {
                // object replacement character
                mChars[j] = '\uFFFC';
            }
        }
    }
    if ((textDir == TextDirectionHeuristics.LTR || textDir == TextDirectionHeuristics.FIRSTSTRONG_LTR || textDir == TextDirectionHeuristics.ANYRTL_LTR) && TextUtils.doesNotNeedBidi(mChars, 0, len)) {
        mDir = Layout.DIR_LEFT_TO_RIGHT;
        mEasy = true;
    } else {
        if (mLevels == null || mLevels.length < len) {
            mLevels = ArrayUtils.newUnpaddedByteArray(len);
        }
        int bidiRequest;
        if (textDir == TextDirectionHeuristics.LTR) {
            bidiRequest = Layout.DIR_REQUEST_LTR;
        } else if (textDir == TextDirectionHeuristics.RTL) {
            bidiRequest = Layout.DIR_REQUEST_RTL;
        } else if (textDir == TextDirectionHeuristics.FIRSTSTRONG_LTR) {
            bidiRequest = Layout.DIR_REQUEST_DEFAULT_LTR;
        } else if (textDir == TextDirectionHeuristics.FIRSTSTRONG_RTL) {
            bidiRequest = Layout.DIR_REQUEST_DEFAULT_RTL;
        } else {
            boolean isRtl = textDir.isRtl(mChars, 0, len);
            bidiRequest = isRtl ? Layout.DIR_REQUEST_RTL : Layout.DIR_REQUEST_LTR;
        }
        mDir = AndroidBidi.bidi(bidiRequest, mChars, mLevels, len, false);
        mEasy = false;
    }
}
------------------------
Find a silently evolved API code:android.telephony.PhoneNumberUtils.isPotentialLocalEmergencyNumber:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Checks if a given number might *potentially* result in a call to an
 * emergency service, for the country that the user is in. The current
 * country is determined using the CountryDetector.
 *
 * Specifically, this method will return true if the specified number
 * is an emergency number in the current country, *or* if the number
 * simply starts with the same digits as any emergency number for the
 * current country.
 *
 * This method is intended for internal use by the phone app when
 * deciding whether to allow ACTION_CALL intents from 3rd party apps
 * (where we're required to *not* allow emergency calls to be placed.)
 *
 * @param number the number to look up.
 * @param context the specific context which the number should be checked against
 * @return true if the specified number is an emergency number for a local country, based on the
 * CountryDetector.
 *
 * @see android.location.CountryDetector
 * @hide
 */

Body of Frist Method:
{
    return isLocalEmergencyNumberInternal(number, context, false);
}
Body of Second Method:
{
    return isPotentialLocalEmergencyNumber(context, getDefaultVoiceSubId(), number);
}
------------------------
Find a silently evolved API code:android.widget.AbsListView.RecycleBin.getScrapView:COMMENT
Method Modifier: default     
Comment:/**
 * @return A view from the ScrapViews collection. These are unordered.
 */

Body of Frist Method:
{
    if (mViewTypeCount == 1) {
        return retrieveFromScrap(mCurrentScrap, position);
    } else {
        int whichScrap = mAdapter.getItemViewType(position);
        if (whichScrap >= 0 && whichScrap < mScrapViews.length) {
            return retrieveFromScrap(mScrapViews[whichScrap], position);
        }
    }
    return null;
}
Body of Second Method:
{
    if (mViewTypeCount == 1) {
        return retrieveFromScrap(mCurrentScrap, position);
    } else {
        final int whichScrap = mAdapter.getItemViewType(position);
        if (whichScrap >= 0 && whichScrap < mScrapViews.length) {
            return retrieveFromScrap(mScrapViews[whichScrap], position);
        }
    }
    return null;
}
------------------------
Find a silently evolved API code:android.text.StaticLayout.generate:COMMENT
Method Modifier: default     
Comment:/* package */

Body of Frist Method:
{
    mLineCount = 0;
    int v = 0;
    boolean needMultiply = (spacingmult != 1 || spacingadd != 0);
    Paint.FontMetricsInt fm = mFontMetricsInt;
    int[] chooseHtv = null;
    MeasuredText measured = mMeasured;
    Spanned spanned = null;
    if (source instanceof Spanned)
        spanned = (Spanned) source;
    // XXX
    int DEFAULT_DIR = DIR_LEFT_TO_RIGHT;
    int paraEnd;
    for (int paraStart = bufStart; paraStart <= bufEnd; paraStart = paraEnd) {
        paraEnd = TextUtils.indexOf(source, CHAR_NEW_LINE, paraStart, bufEnd);
        if (paraEnd < 0)
            paraEnd = bufEnd;
        else
            paraEnd++;
        int firstWidthLineLimit = mLineCount + 1;
        int firstWidth = outerWidth;
        int restWidth = outerWidth;
        LineHeightSpan[] chooseHt = null;
        if (spanned != null) {
            LeadingMarginSpan[] sp = getParagraphSpans(spanned, paraStart, paraEnd, LeadingMarginSpan.class);
            for (int i = 0; i < sp.length; i++) {
                LeadingMarginSpan lms = sp[i];
                firstWidth -= sp[i].getLeadingMargin(true);
                restWidth -= sp[i].getLeadingMargin(false);
                // paragraph.
                if (lms instanceof LeadingMarginSpan2) {
                    LeadingMarginSpan2 lms2 = (LeadingMarginSpan2) lms;
                    int lmsFirstLine = getLineForOffset(spanned.getSpanStart(lms2));
                    firstWidthLineLimit = lmsFirstLine + lms2.getLeadingMarginLineCount();
                }
            }
            chooseHt = getParagraphSpans(spanned, paraStart, paraEnd, LineHeightSpan.class);
            if (chooseHt.length != 0) {
                if (chooseHtv == null || chooseHtv.length < chooseHt.length) {
                    chooseHtv = new int[ArrayUtils.idealIntArraySize(chooseHt.length)];
                }
                for (int i = 0; i < chooseHt.length; i++) {
                    int o = spanned.getSpanStart(chooseHt[i]);
                    if (o < paraStart) {
                        // starts in this layout, before the
                        // current paragraph
                        chooseHtv[i] = getLineTop(getLineForOffset(o));
                    } else {
                        // starts in this paragraph
                        chooseHtv[i] = v;
                    }
                }
            }
        }
        measured.setPara(source, paraStart, paraEnd, textDir);
        char[] chs = measured.mChars;
        float[] widths = measured.mWidths;
        byte[] chdirs = measured.mLevels;
        int dir = measured.mDir;
        boolean easy = measured.mEasy;
        int width = firstWidth;
        float w = 0;
        // here is the offset of the starting character of the line we are currently measuring
        int here = paraStart;
        // ok is a character offset located after a word separator (space, tab, number...) where
        // we would prefer to cut the current line. Equals to here when no such break was found.
        int ok = paraStart;
        float okWidth = w;
        int okAscent = 0, okDescent = 0, okTop = 0, okBottom = 0;
        // fit is a character offset such that the [here, fit[ range fits in the allowed width.
        // We will cut the line there if no ok position is found.
        int fit = paraStart;
        float fitWidth = w;
        int fitAscent = 0, fitDescent = 0, fitTop = 0, fitBottom = 0;
        boolean hasTabOrEmoji = false;
        boolean hasTab = false;
        TabStops tabStops = null;
        for (int spanStart = paraStart, spanEnd; spanStart < paraEnd; spanStart = spanEnd) {
            if (spanned == null) {
                spanEnd = paraEnd;
                int spanLen = spanEnd - spanStart;
                measured.addStyleRun(paint, spanLen, fm);
            } else {
                spanEnd = spanned.nextSpanTransition(spanStart, paraEnd, MetricAffectingSpan.class);
                int spanLen = spanEnd - spanStart;
                MetricAffectingSpan[] spans = spanned.getSpans(spanStart, spanEnd, MetricAffectingSpan.class);
                spans = TextUtils.removeEmptySpans(spans, spanned, MetricAffectingSpan.class);
                measured.addStyleRun(paint, spans, spanLen, fm);
            }
            int fmTop = fm.top;
            int fmBottom = fm.bottom;
            int fmAscent = fm.ascent;
            int fmDescent = fm.descent;
            for (int j = spanStart; j < spanEnd; j++) {
                char c = chs[j - paraStart];
                if (c == CHAR_NEW_LINE) {
                // intentionally left empty
                } else if (c == CHAR_TAB) {
                    if (hasTab == false) {
                        hasTab = true;
                        hasTabOrEmoji = true;
                        if (spanned != null) {
                            // First tab this para, check for tabstops
                            TabStopSpan[] spans = getParagraphSpans(spanned, paraStart, paraEnd, TabStopSpan.class);
                            if (spans.length > 0) {
                                tabStops = new TabStops(TAB_INCREMENT, spans);
                            }
                        }
                    }
                    if (tabStops != null) {
                        w = tabStops.nextTab(w);
                    } else {
                        w = TabStops.nextDefaultStop(w, TAB_INCREMENT);
                    }
                } else if (c >= CHAR_FIRST_HIGH_SURROGATE && c <= CHAR_LAST_LOW_SURROGATE && j + 1 < spanEnd) {
                    int emoji = Character.codePointAt(chs, j - paraStart);
                    if (emoji >= MIN_EMOJI && emoji <= MAX_EMOJI) {
                        Bitmap bm = EMOJI_FACTORY.getBitmapFromAndroidPua(emoji);
                        if (bm != null) {
                            Paint whichPaint;
                            if (spanned == null) {
                                whichPaint = paint;
                            } else {
                                whichPaint = mWorkPaint;
                            }
                            float wid = bm.getWidth() * -whichPaint.ascent() / bm.getHeight();
                            w += wid;
                            hasTabOrEmoji = true;
                            j++;
                        } else {
                            w += widths[j - paraStart];
                        }
                    } else {
                        w += widths[j - paraStart];
                    }
                } else {
                    w += widths[j - paraStart];
                }
                boolean isSpaceOrTab = c == CHAR_SPACE || c == CHAR_TAB || c == CHAR_ZWSP;
                if (w <= width || isSpaceOrTab) {
                    fitWidth = w;
                    fit = j + 1;
                    if (fmTop < fitTop)
                        fitTop = fmTop;
                    if (fmAscent < fitAscent)
                        fitAscent = fmAscent;
                    if (fmDescent > fitDescent)
                        fitDescent = fmDescent;
                    if (fmBottom > fitBottom)
                        fitBottom = fmBottom;
                    // From the Unicode Line Breaking Algorithm (at least approximately)
                    boolean isLineBreak = isSpaceOrTab || // / is class SY and - is class HY, except when followed by a digit
                    ((c == CHAR_SLASH || c == CHAR_HYPHEN) && (j + 1 >= spanEnd || !Character.isDigit(chs[j + 1 - paraStart]))) || // (non-starters), which can be broken after but not before
                    (c >= CHAR_FIRST_CJK && isIdeographic(c, true) && j + 1 < spanEnd && isIdeographic(chs[j + 1 - paraStart], false));
                    if (isLineBreak) {
                        okWidth = w;
                        ok = j + 1;
                        if (fitTop < okTop)
                            okTop = fitTop;
                        if (fitAscent < okAscent)
                            okAscent = fitAscent;
                        if (fitDescent > okDescent)
                            okDescent = fitDescent;
                        if (fitBottom > okBottom)
                            okBottom = fitBottom;
                    }
                } else {
                    final boolean moreChars = (j + 1 < spanEnd);
                    int endPos;
                    int above, below, top, bottom;
                    float currentTextWidth;
                    if (ok != here) {
                        endPos = ok;
                        above = okAscent;
                        below = okDescent;
                        top = okTop;
                        bottom = okBottom;
                        currentTextWidth = okWidth;
                    } else if (fit != here) {
                        endPos = fit;
                        above = fitAscent;
                        below = fitDescent;
                        top = fitTop;
                        bottom = fitBottom;
                        currentTextWidth = fitWidth;
                    } else {
                        endPos = here + 1;
                        above = fm.ascent;
                        below = fm.descent;
                        top = fm.top;
                        bottom = fm.bottom;
                        currentTextWidth = widths[here - paraStart];
                    }
                    v = out(source, here, endPos, above, below, top, bottom, v, spacingmult, spacingadd, chooseHt, chooseHtv, fm, hasTabOrEmoji, needMultiply, chdirs, dir, easy, bufEnd, includepad, trackpad, chs, widths, paraStart, ellipsize, ellipsizedWidth, currentTextWidth, paint, moreChars);
                    here = endPos;
                    // restart j-span loop from here, compensating for the j++
                    j = here - 1;
                    ok = fit = here;
                    w = 0;
                    fitAscent = fitDescent = fitTop = fitBottom = 0;
                    okAscent = okDescent = okTop = okBottom = 0;
                    if (--firstWidthLineLimit <= 0) {
                        width = restWidth;
                    }
                    if (here < spanStart) {
                        // The text was cut before the beginning of the current span range.
                        // Exit the span loop, and get spanStart to start over from here.
                        measured.setPos(here);
                        spanEnd = here;
                        break;
                    }
                    if (mLineCount >= mMaximumVisibleLineCount) {
                        break;
                    }
                }
            }
        }
        if (paraEnd != here && mLineCount < mMaximumVisibleLineCount) {
            if ((fitTop | fitBottom | fitDescent | fitAscent) == 0) {
                paint.getFontMetricsInt(fm);
                fitTop = fm.top;
                fitBottom = fm.bottom;
                fitAscent = fm.ascent;
                fitDescent = fm.descent;
            }
            // Log.e("text", "output rest " + here + " to " + end);
            v = out(source, here, paraEnd, fitAscent, fitDescent, fitTop, fitBottom, v, spacingmult, spacingadd, chooseHt, chooseHtv, fm, hasTabOrEmoji, needMultiply, chdirs, dir, easy, bufEnd, includepad, trackpad, chs, widths, paraStart, ellipsize, ellipsizedWidth, w, paint, paraEnd != bufEnd);
        }
        paraStart = paraEnd;
        if (paraEnd == bufEnd)
            break;
    }
    if ((bufEnd == bufStart || source.charAt(bufEnd - 1) == CHAR_NEW_LINE) && mLineCount < mMaximumVisibleLineCount) {
        // Log.e("text", "output last " + bufEnd);
        measured.setPara(source, bufStart, bufEnd, textDir);
        paint.getFontMetricsInt(fm);
        v = out(source, bufEnd, bufEnd, fm.ascent, fm.descent, fm.top, fm.bottom, v, spacingmult, spacingadd, null, null, fm, false, needMultiply, measured.mLevels, measured.mDir, measured.mEasy, bufEnd, includepad, trackpad, null, null, bufStart, ellipsize, ellipsizedWidth, 0, paint, false);
    }
}
Body of Second Method:
{
    int[] breakOpp = null;
    final String localeLanguageTag = paint.getTextLocale().toLanguageTag();
    mLineCount = 0;
    int v = 0;
    boolean needMultiply = (spacingmult != 1 || spacingadd != 0);
    Paint.FontMetricsInt fm = mFontMetricsInt;
    int[] chooseHtv = null;
    MeasuredText measured = mMeasured;
    Spanned spanned = null;
    if (source instanceof Spanned)
        spanned = (Spanned) source;
    int paraEnd;
    for (int paraStart = bufStart; paraStart <= bufEnd; paraStart = paraEnd) {
        paraEnd = TextUtils.indexOf(source, CHAR_NEW_LINE, paraStart, bufEnd);
        if (paraEnd < 0)
            paraEnd = bufEnd;
        else
            paraEnd++;
        int firstWidthLineLimit = mLineCount + 1;
        int firstWidth = outerWidth;
        int restWidth = outerWidth;
        LineHeightSpan[] chooseHt = null;
        if (spanned != null) {
            LeadingMarginSpan[] sp = getParagraphSpans(spanned, paraStart, paraEnd, LeadingMarginSpan.class);
            for (int i = 0; i < sp.length; i++) {
                LeadingMarginSpan lms = sp[i];
                firstWidth -= sp[i].getLeadingMargin(true);
                restWidth -= sp[i].getLeadingMargin(false);
                // leading margin spans, not just this particular one
                if (lms instanceof LeadingMarginSpan2) {
                    LeadingMarginSpan2 lms2 = (LeadingMarginSpan2) lms;
                    int lmsFirstLine = getLineForOffset(spanned.getSpanStart(lms2));
                    firstWidthLineLimit = Math.max(firstWidthLineLimit, lmsFirstLine + lms2.getLeadingMarginLineCount());
                }
            }
            chooseHt = getParagraphSpans(spanned, paraStart, paraEnd, LineHeightSpan.class);
            if (chooseHt.length != 0) {
                if (chooseHtv == null || chooseHtv.length < chooseHt.length) {
                    chooseHtv = ArrayUtils.newUnpaddedIntArray(chooseHt.length);
                }
                for (int i = 0; i < chooseHt.length; i++) {
                    int o = spanned.getSpanStart(chooseHt[i]);
                    if (o < paraStart) {
                        // starts in this layout, before the
                        // current paragraph
                        chooseHtv[i] = getLineTop(getLineForOffset(o));
                    } else {
                        // starts in this paragraph
                        chooseHtv[i] = v;
                    }
                }
            }
        }
        measured.setPara(source, paraStart, paraEnd, textDir);
        char[] chs = measured.mChars;
        float[] widths = measured.mWidths;
        byte[] chdirs = measured.mLevels;
        int dir = measured.mDir;
        boolean easy = measured.mEasy;
        breakOpp = nLineBreakOpportunities(localeLanguageTag, chs, paraEnd - paraStart, breakOpp);
        int breakOppIndex = 0;
        int width = firstWidth;
        float w = 0;
        // here is the offset of the starting character of the line we are currently measuring
        int here = paraStart;
        // ok is a character offset located after a word separator (space, tab, number...) where
        // we would prefer to cut the current line. Equals to here when no such break was found.
        int ok = paraStart;
        float okWidth = w;
        int okAscent = 0, okDescent = 0, okTop = 0, okBottom = 0;
        // fit is a character offset such that the [here, fit[ range fits in the allowed width.
        // We will cut the line there if no ok position is found.
        int fit = paraStart;
        float fitWidth = w;
        int fitAscent = 0, fitDescent = 0, fitTop = 0, fitBottom = 0;
        // same as fitWidth but not including any trailing whitespace
        float fitWidthGraphing = w;
        boolean hasTabOrEmoji = false;
        boolean hasTab = false;
        TabStops tabStops = null;
        for (int spanStart = paraStart, spanEnd; spanStart < paraEnd; spanStart = spanEnd) {
            if (spanned == null) {
                spanEnd = paraEnd;
                int spanLen = spanEnd - spanStart;
                measured.addStyleRun(paint, spanLen, fm);
            } else {
                spanEnd = spanned.nextSpanTransition(spanStart, paraEnd, MetricAffectingSpan.class);
                int spanLen = spanEnd - spanStart;
                MetricAffectingSpan[] spans = spanned.getSpans(spanStart, spanEnd, MetricAffectingSpan.class);
                spans = TextUtils.removeEmptySpans(spans, spanned, MetricAffectingSpan.class);
                measured.addStyleRun(paint, spans, spanLen, fm);
            }
            int fmTop = fm.top;
            int fmBottom = fm.bottom;
            int fmAscent = fm.ascent;
            int fmDescent = fm.descent;
            for (int j = spanStart; j < spanEnd; j++) {
                char c = chs[j - paraStart];
                if (c == CHAR_NEW_LINE) {
                // intentionally left empty
                } else if (c == CHAR_TAB) {
                    if (hasTab == false) {
                        hasTab = true;
                        hasTabOrEmoji = true;
                        if (spanned != null) {
                            // First tab this para, check for tabstops
                            TabStopSpan[] spans = getParagraphSpans(spanned, paraStart, paraEnd, TabStopSpan.class);
                            if (spans.length > 0) {
                                tabStops = new TabStops(TAB_INCREMENT, spans);
                            }
                        }
                    }
                    if (tabStops != null) {
                        w = tabStops.nextTab(w);
                    } else {
                        w = TabStops.nextDefaultStop(w, TAB_INCREMENT);
                    }
                } else if (c >= CHAR_FIRST_HIGH_SURROGATE && c <= CHAR_LAST_LOW_SURROGATE && j + 1 < spanEnd) {
                    int emoji = Character.codePointAt(chs, j - paraStart);
                    if (emoji >= MIN_EMOJI && emoji <= MAX_EMOJI) {
                        Bitmap bm = EMOJI_FACTORY.getBitmapFromAndroidPua(emoji);
                        if (bm != null) {
                            Paint whichPaint;
                            if (spanned == null) {
                                whichPaint = paint;
                            } else {
                                whichPaint = mWorkPaint;
                            }
                            float wid = bm.getWidth() * -whichPaint.ascent() / bm.getHeight();
                            w += wid;
                            hasTabOrEmoji = true;
                            j++;
                        } else {
                            w += widths[j - paraStart];
                        }
                    } else {
                        w += widths[j - paraStart];
                    }
                } else {
                    w += widths[j - paraStart];
                }
                boolean isSpaceOrTab = c == CHAR_SPACE || c == CHAR_TAB || c == CHAR_ZWSP;
                if (w <= width || isSpaceOrTab) {
                    fitWidth = w;
                    if (!isSpaceOrTab) {
                        fitWidthGraphing = w;
                    }
                    fit = j + 1;
                    if (fmTop < fitTop)
                        fitTop = fmTop;
                    if (fmAscent < fitAscent)
                        fitAscent = fmAscent;
                    if (fmDescent > fitDescent)
                        fitDescent = fmDescent;
                    if (fmBottom > fitBottom)
                        fitBottom = fmBottom;
                    while (breakOpp[breakOppIndex] != -1 && breakOpp[breakOppIndex] < j - paraStart + 1) {
                        breakOppIndex++;
                    }
                    boolean isLineBreak = breakOppIndex < breakOpp.length && breakOpp[breakOppIndex] == j - paraStart + 1;
                    if (isLineBreak) {
                        okWidth = fitWidthGraphing;
                        ok = j + 1;
                        if (fitTop < okTop)
                            okTop = fitTop;
                        if (fitAscent < okAscent)
                            okAscent = fitAscent;
                        if (fitDescent > okDescent)
                            okDescent = fitDescent;
                        if (fitBottom > okBottom)
                            okBottom = fitBottom;
                    }
                } else {
                    final boolean moreChars;
                    int endPos;
                    int above, below, top, bottom;
                    float currentTextWidth;
                    if (ok != here) {
                        endPos = ok;
                        above = okAscent;
                        below = okDescent;
                        top = okTop;
                        bottom = okBottom;
                        currentTextWidth = okWidth;
                        moreChars = (j + 1 < spanEnd);
                    } else if (fit != here) {
                        endPos = fit;
                        above = fitAscent;
                        below = fitDescent;
                        top = fitTop;
                        bottom = fitBottom;
                        currentTextWidth = fitWidth;
                        moreChars = (j + 1 < spanEnd);
                    } else {
                        // must make progress, so take next character
                        endPos = here + 1;
                        // take all zero width characters following that
                        while (endPos < spanEnd && widths[endPos - paraStart] == 0) {
                            endPos++;
                        }
                        above = fmAscent;
                        below = fmDescent;
                        top = fmTop;
                        bottom = fmBottom;
                        currentTextWidth = widths[here - paraStart];
                        moreChars = (endPos < spanEnd);
                    }
                    v = out(source, here, endPos, above, below, top, bottom, v, spacingmult, spacingadd, chooseHt, chooseHtv, fm, hasTabOrEmoji, needMultiply, chdirs, dir, easy, bufEnd, includepad, trackpad, chs, widths, paraStart, ellipsize, ellipsizedWidth, currentTextWidth, paint, moreChars);
                    here = endPos;
                    // restart j-span loop from here, compensating for the j++
                    j = here - 1;
                    ok = fit = here;
                    w = 0;
                    fitWidthGraphing = w;
                    fitAscent = fitDescent = fitTop = fitBottom = 0;
                    okAscent = okDescent = okTop = okBottom = 0;
                    if (--firstWidthLineLimit <= 0) {
                        width = restWidth;
                    }
                    if (here < spanStart) {
                        // The text was cut before the beginning of the current span range.
                        // Exit the span loop, and get spanStart to start over from here.
                        measured.setPos(here);
                        spanEnd = here;
                        break;
                    }
                    if (mLineCount >= mMaximumVisibleLineCount) {
                        return;
                    }
                }
            }
        }
        if (paraEnd != here && mLineCount < mMaximumVisibleLineCount) {
            if ((fitTop | fitBottom | fitDescent | fitAscent) == 0) {
                paint.getFontMetricsInt(fm);
                fitTop = fm.top;
                fitBottom = fm.bottom;
                fitAscent = fm.ascent;
                fitDescent = fm.descent;
            }
            // Log.e("text", "output rest " + here + " to " + end);
            v = out(source, here, paraEnd, fitAscent, fitDescent, fitTop, fitBottom, v, spacingmult, spacingadd, chooseHt, chooseHtv, fm, hasTabOrEmoji, needMultiply, chdirs, dir, easy, bufEnd, includepad, trackpad, chs, widths, paraStart, ellipsize, ellipsizedWidth, w, paint, paraEnd != bufEnd);
        }
        paraStart = paraEnd;
        if (paraEnd == bufEnd)
            break;
    }
    if ((bufEnd == bufStart || source.charAt(bufEnd - 1) == CHAR_NEW_LINE) && mLineCount < mMaximumVisibleLineCount) {
        // Log.e("text", "output last " + bufEnd);
        measured.setPara(source, bufStart, bufEnd, textDir);
        paint.getFontMetricsInt(fm);
        v = out(source, bufEnd, bufEnd, fm.ascent, fm.descent, fm.top, fm.bottom, v, spacingmult, spacingadd, null, null, fm, false, needMultiply, measured.mLevels, measured.mDir, measured.mEasy, bufEnd, includepad, trackpad, null, null, bufStart, ellipsize, ellipsizedWidth, 0, paint, false);
    }
}
------------------------
Find a silently evolved API code:android.widget.DatePicker.getMonth:COMMENT
Method Modifier: public      
Comment:/**
 * @return The selected month.
 */

Body of Frist Method:
{
    return mCurrentDate.get(Calendar.MONTH);
}
Body of Second Method:
{
    return mDelegate.getMonth();
}
------------------------
Find a silently evolved API code:android.view.accessibility.AccessibilityEvent.initFromParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Creates a new instance from a {@link Parcel}.
 *
 * @param parcel A parcel containing the state of a {@link AccessibilityEvent}.
 */

Body of Frist Method:
{
    mSealed = (parcel.readInt() == 1);
    mEventType = parcel.readInt();
    mMovementGranularity = parcel.readInt();
    mAction = parcel.readInt();
    mContentChangeTypes = parcel.readInt();
    mPackageName = TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(parcel);
    mEventTime = parcel.readLong();
    mConnectionId = parcel.readInt();
    readAccessibilityRecordFromParcel(this, parcel);
    // Read the records.
    final int recordCount = parcel.readInt();
    for (int i = 0; i < recordCount; i++) {
        AccessibilityRecord record = AccessibilityRecord.obtain();
        readAccessibilityRecordFromParcel(record, parcel);
        record.mConnectionId = mConnectionId;
        mRecords.add(record);
    }
}
Body of Second Method:
{
    mSealed = (parcel.readInt() == 1);
    mEventType = parcel.readInt();
    mMovementGranularity = parcel.readInt();
    mAction = parcel.readInt();
    mContentChangeTypes = parcel.readInt();
    mPackageName = TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(parcel);
    mEventTime = parcel.readLong();
    mConnectionId = parcel.readInt();
    readAccessibilityRecordFromParcel(this, parcel);
    // Read the records.
    final int recordCount = parcel.readInt();
    if (recordCount > 0) {
        mRecords = new ArrayList<AccessibilityRecord>(recordCount);
        for (int i = 0; i < recordCount; i++) {
            AccessibilityRecord record = AccessibilityRecord.obtain();
            readAccessibilityRecordFromParcel(record, parcel);
            record.mConnectionId = mConnectionId;
            mRecords.add(record);
        }
    }
}
------------------------
Find a silently evolved API code:android.text.format.Time.normalize:COMMENT
<android.text.format.Time: long normalize(boolean)>
public      native      ->public      
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * Ensures the values in each field are in range. For example if the
 * current value of this calendar is March 32, normalize() will convert it
 * to April 1. It also fills in weekDay, yearDay, isDst and gmtoff.
 *
 * <p>
 * If "ignoreDst" is true, then this method sets the "isDst" field to -1
 * (the "unknown" value) before normalizing.  It then computes the
 * correct value for "isDst".
 *
 * <p>
 * See {@link #toMillis(boolean)} for more information about when to
 * use <tt>true</tt> or <tt>false</tt> for "ignoreDst".
 *
 * @return the UTC milliseconds since the epoch
 */

Body of Frist Method:

Body of Second Method:
{
    calculator.copyFieldsFromTime(this);
    long timeInMillis = calculator.toMillis(ignoreDst);
    calculator.copyFieldsToTime(this);
    return timeInMillis;
}
------------------------
Find a silently evolved API code:android.app.admin.DeviceAdminReceiver.onReceive:COMMENT
Method Modifier: public      
Comment:/**
 * Intercept standard device administrator broadcasts.  Implementations
 * should not override this method; it is better to implement the
 * convenience callbacks for each action.
 */

Body of Frist Method:
{
    String action = intent.getAction();
    if (ACTION_PASSWORD_CHANGED.equals(action)) {
        onPasswordChanged(context, intent);
    } else if (ACTION_PASSWORD_FAILED.equals(action)) {
        onPasswordFailed(context, intent);
    } else if (ACTION_PASSWORD_SUCCEEDED.equals(action)) {
        onPasswordSucceeded(context, intent);
    } else if (ACTION_DEVICE_ADMIN_ENABLED.equals(action)) {
        onEnabled(context, intent);
    } else if (ACTION_DEVICE_ADMIN_DISABLE_REQUESTED.equals(action)) {
        CharSequence res = onDisableRequested(context, intent);
        if (res != null) {
            Bundle extras = getResultExtras(true);
            extras.putCharSequence(EXTRA_DISABLE_WARNING, res);
        }
    } else if (ACTION_DEVICE_ADMIN_DISABLED.equals(action)) {
        onDisabled(context, intent);
    } else if (ACTION_PASSWORD_EXPIRING.equals(action)) {
        onPasswordExpiring(context, intent);
    }
}
Body of Second Method:
{
    String action = intent.getAction();
    if (ACTION_PASSWORD_CHANGED.equals(action)) {
        onPasswordChanged(context, intent);
    } else if (ACTION_PASSWORD_FAILED.equals(action)) {
        onPasswordFailed(context, intent);
    } else if (ACTION_PASSWORD_SUCCEEDED.equals(action)) {
        onPasswordSucceeded(context, intent);
    } else if (ACTION_DEVICE_ADMIN_ENABLED.equals(action)) {
        onEnabled(context, intent);
    } else if (ACTION_DEVICE_ADMIN_DISABLE_REQUESTED.equals(action)) {
        CharSequence res = onDisableRequested(context, intent);
        if (res != null) {
            Bundle extras = getResultExtras(true);
            extras.putCharSequence(EXTRA_DISABLE_WARNING, res);
        }
    } else if (ACTION_DEVICE_ADMIN_DISABLED.equals(action)) {
        onDisabled(context, intent);
    } else if (ACTION_PASSWORD_EXPIRING.equals(action)) {
        onPasswordExpiring(context, intent);
    } else if (ACTION_PROFILE_PROVISIONING_COMPLETE.equals(action)) {
        onProfileProvisioningComplete(context, intent);
    } else if (ACTION_LOCK_TASK_ENTERING.equals(action)) {
        String pkg = intent.getStringExtra(EXTRA_LOCK_TASK_PACKAGE);
        onLockTaskModeEntering(context, intent, pkg);
    } else if (ACTION_LOCK_TASK_EXITING.equals(action)) {
        onLockTaskModeExiting(context, intent);
    }
}
------------------------
Find a silently evolved API code:android.view.animation.AnimationUtils.loadInterpolator:COMMENT
Method Modifier: public      static      
Comment:/**
 * Loads an {@link Interpolator} object from a resource
 *
 * @param context Application context used to access resources
 * @param id The resource id of the animation to load
 * @return The animation object reference by the specified id
 * @throws NotFoundException
 */

Body of Frist Method:
{
    XmlResourceParser parser = null;
    try {
        parser = context.getResources().getAnimation(id);
        return createInterpolatorFromXml(context, parser);
    } catch (XmlPullParserException ex) {
        NotFoundException rnf = new NotFoundException("Can't load animation resource ID #0x" + Integer.toHexString(id));
        rnf.initCause(ex);
        throw rnf;
    } catch (IOException ex) {
        NotFoundException rnf = new NotFoundException("Can't load animation resource ID #0x" + Integer.toHexString(id));
        rnf.initCause(ex);
        throw rnf;
    } finally {
        if (parser != null)
            parser.close();
    }
}
Body of Second Method:
{
    XmlResourceParser parser = null;
    try {
        parser = context.getResources().getAnimation(id);
        return createInterpolatorFromXml(context.getResources(), context.getTheme(), parser);
    } catch (XmlPullParserException ex) {
        NotFoundException rnf = new NotFoundException("Can't load animation resource ID #0x" + Integer.toHexString(id));
        rnf.initCause(ex);
        throw rnf;
    } catch (IOException ex) {
        NotFoundException rnf = new NotFoundException("Can't load animation resource ID #0x" + Integer.toHexString(id));
        rnf.initCause(ex);
        throw rnf;
    } finally {
        if (parser != null)
            parser.close();
    }
}
------------------------
Find a silently evolved API code:android.content.res.Resources.obtainAttributes:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve a set of basic attribute values from an AttributeSet, not
 * performing styling of them using a theme and/or style resources.
 *
 * @param set The current attribute values to retrieve.
 * @param attrs The specific attributes to be retrieved.
 * @return Returns a TypedArray holding an array of the attribute values.
 * Be sure to call {@link TypedArray#recycle() TypedArray.recycle()}
 * when done with it.
 *
 * @see Theme#obtainStyledAttributes(AttributeSet, int[], int, int)
 */

Body of Frist Method:
{
    int len = attrs.length;
    TypedArray array = getCachedStyledAttributes(len);
    // XXX note that for now we only work with compiled XML files.
    // To support generic XML files we will need to manually parse
    // out the attributes from the XML file (applying type information
    // contained in the resources and such).
    XmlBlock.Parser parser = (XmlBlock.Parser) set;
    mAssets.retrieveAttributes(parser.mParseState, attrs, array.mData, array.mIndices);
    array.mRsrcs = attrs;
    array.mXml = parser;
    return array;
}
Body of Second Method:
{
    int len = attrs.length;
    TypedArray array = TypedArray.obtain(this, len);
    // XXX note that for now we only work with compiled XML files.
    // To support generic XML files we will need to manually parse
    // out the attributes from the XML file (applying type information
    // contained in the resources and such).
    XmlBlock.Parser parser = (XmlBlock.Parser) set;
    mAssets.retrieveAttributes(parser.mParseState, attrs, array.mData, array.mIndices);
    array.mXml = parser;
    return array;
}
------------------------
Find a silently evolved API code:android.content.res.TypedArray.getTextArray:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the CharSequence[] for the attribute at <var>index</var>.
 * This gets the resource ID of the selected attribute, and uses
 * {@link Resources#getTextArray Resources.getTextArray} of the owning
 * Resources object to retrieve its String[].
 *
 * @param index Index of attribute to retrieve.
 *
 * @return CharSequence[] for the attribute, or null if not defined.
 */

Body of Frist Method:
{
    final TypedValue value = mValue;
    if (getValueAt(index * AssetManager.STYLE_NUM_ENTRIES, value)) {
        if (false) {
            System.out.println("******************************************************************");
            System.out.println("Got drawable resource: type=" + value.type + " str=" + value.string + " int=0x" + Integer.toHexString(value.data) + " cookie=" + value.assetCookie);
            System.out.println("******************************************************************");
        }
        return mResources.getTextArray(value.resourceId);
    }
    return null;
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    final TypedValue value = mValue;
    if (getValueAt(index * AssetManager.STYLE_NUM_ENTRIES, value)) {
        return mResources.getTextArray(value.resourceId);
    }
    return null;
}
------------------------
Find a silently evolved API code:android.media.MediaCodecInfo.getName:COMMENT
Method Modifier: public      final       
Comment:/**
 * Retrieve the codec name.
 */

Body of Frist Method:
{
    return MediaCodecList.getCodecName(mIndex);
}
Body of Second Method:
{
    return mName;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothGatt.executeReliableWrite:COMMENT
Method Modifier: public      
Comment:/**
 * Executes a reliable write transaction for a given remote device.
 *
 * <p>This function will commit all queued up characteristic write
 * operations for a given remote device.
 *
 * <p>A {@link BluetoothGattCallback#onReliableWriteCompleted} callback is
 * invoked to indicate whether the transaction has been executed correctly.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @return true, if the request to execute the transaction has been sent
 */

Body of Frist Method:
{
    if (DBG)
        Log.d(TAG, "executeReliableWrite() - device: " + mDevice.getAddress());
    if (mService == null || mClientIf == 0)
        return false;
    try {
        mService.endReliableWrite(mClientIf, mDevice.getAddress(), true);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        return false;
    }
    return true;
}
Body of Second Method:
{
    if (VDBG)
        Log.d(TAG, "executeReliableWrite() - device: " + mDevice.getAddress());
    if (mService == null || mClientIf == 0)
        return false;
    synchronized (mDeviceBusy) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.endReliableWrite(mClientIf, mDevice.getAddress(), true);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}
------------------------
Find a silently evolved API code:android.os.Bundle.putShortArray:COMMENT
Method Modifier: public      
Comment:/**
 * Inserts a short array value into the mapping of this Bundle, replacing
 * any existing value for the given key.  Either key or value may be null.
 *
 * @param key a String, or null
 * @param value a short array object, or null
 */

Body of Frist Method:
{
    unparcel();
    mMap.put(key, value);
}
Body of Second Method:
{
    super.putShortArray(key, value);
}
------------------------
Find a silently evolved API code:android.media.RemoteController.setSynchronizationMode:COMMENT
<android.media.RemoteController: boolean setSynchronizationMode(int)>
public      ->public      deprecated  
Method Modifier: public      deprecated  
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Set the playback position synchronization mode.
 * Must be called on a registered RemoteController.
 * @param sync {@link #POSITION_SYNCHRONIZATION_NONE} or {@link #POSITION_SYNCHRONIZATION_CHECK}
 * @return true if the synchronization mode was successfully set.
 * @throws IllegalArgumentException
 */

Body of Frist Method:
{
    if ((sync != POSITION_SYNCHRONIZATION_NONE) || (sync != POSITION_SYNCHRONIZATION_CHECK)) {
        throw new IllegalArgumentException("Unknown synchronization mode " + sync);
    }
    if (!mIsRegistered) {
        Log.e(TAG, "Cannot set synchronization mode on an unregistered RemoteController");
        return false;
    }
    mAudioManager.remoteControlDisplayWantsPlaybackPositionSync(mRcd, POSITION_SYNCHRONIZATION_CHECK == sync);
    return true;
}
Body of Second Method:
{
    if ((sync != POSITION_SYNCHRONIZATION_NONE) && (sync != POSITION_SYNCHRONIZATION_CHECK)) {
        throw new IllegalArgumentException("Unknown synchronization mode " + sync);
    }
    if (!mIsRegistered) {
        Log.e(TAG, "Cannot set synchronization mode on an unregistered RemoteController");
        return false;
    }
    mAudioManager.remoteControlDisplayWantsPlaybackPositionSync(mRcd, POSITION_SYNCHRONIZATION_CHECK == sync);
    return true;
}
------------------------
Find a silently evolved API code:android.content.RestrictionEntry.getSelectedString:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the currently selected string value.
 * @return the currently selected value, which can be null for types that aren't for holding
 * single string values.
 */

Body of Frist Method:
{
    return currentValue;
}
Body of Second Method:
{
    return mCurrentValue;
}
------------------------
Find a silently evolved API code:android.content.ContentResolver.getPeriodicSyncs:COMMENT
Method Modifier: public      static      
Comment:/**
 * Get the list of information about the periodic syncs for the given account and authority.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#READ_SYNC_SETTINGS}.
 *
 * @param account the account whose periodic syncs we are querying
 * @param authority the provider whose periodic syncs we are querying
 * @return a list of PeriodicSync objects. This list may be empty but will never be null.
 */

Body of Frist Method:
{
    try {
        return getContentService().getPeriodicSyncs(account, authority);
    } catch (RemoteException e) {
        throw new RuntimeException("the ContentService should always be reachable", e);
    }
}
Body of Second Method:
{
    try {
        return getContentService().getPeriodicSyncs(account, authority, null);
    } catch (RemoteException e) {
        throw new RuntimeException("the ContentService should always be reachable", e);
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothGatt.beginReliableWrite:COMMENT
Method Modifier: public      
Comment:/**
 * Initiates a reliable write transaction for a given remote device.
 *
 * <p>Once a reliable write transaction has been initiated, all calls
 * to {@link #writeCharacteristic} are sent to the remote device for
 * verification and queued up for atomic execution. The application will
 * receive an {@link BluetoothGattCallback#onCharacteristicWrite} callback
 * in response to every {@link #writeCharacteristic} call and is responsible
 * for verifying if the value has been transmitted accurately.
 *
 * <p>After all characteristics have been queued up and verified,
 * {@link #executeReliableWrite} will execute all writes. If a characteristic
 * was not written correctly, calling {@link #abortReliableWrite} will
 * cancel the current transaction without commiting any values on the
 * remote device.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @return true, if the reliable write transaction has been initiated
 */

Body of Frist Method:
{
    if (DBG)
        Log.d(TAG, "beginReliableWrite() - device: " + mDevice.getAddress());
    if (mService == null || mClientIf == 0)
        return false;
    try {
        mService.beginReliableWrite(mClientIf, mDevice.getAddress());
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        return false;
    }
    return true;
}
Body of Second Method:
{
    if (VDBG)
        Log.d(TAG, "beginReliableWrite() - device: " + mDevice.getAddress());
    if (mService == null || mClientIf == 0)
        return false;
    try {
        mService.beginReliableWrite(mClientIf, mDevice.getAddress());
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        return false;
    }
    return true;
}
------------------------
Find a silently evolved API code:android.content.RestrictionEntry.setSelectedString:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the string value to use as the selected value for this restriction. This value will
 * be persisted by the system for later use by the application.
 * @param selectedString the string value to select.
 */

Body of Frist Method:
{
    currentValue = selectedString;
}
Body of Second Method:
{
    mCurrentValue = selectedString;
}
------------------------
Find a silently evolved API code:android.text.format.Time.parse:COMMENT
Method Modifier: public      
Comment:/**
 * Parses a date-time string in either the RFC 2445 format or an abbreviated
 * format that does not include the "time" field.  For example, all of the
 * following strings are valid:
 *
 * <ul>
 * <li>"20081013T160000Z"</li>
 * <li>"20081013T160000"</li>
 * <li>"20081013"</li>
 * </ul>
 *
 * Returns whether or not the time is in UTC (ends with Z).  If the string
 * ends with "Z" then the timezone is set to UTC.  If the date-time string
 * included only a date and no time field, then the <code>allDay</code>
 * field of this Time class is set to true and the <code>hour</code>,
 * <code>minute</code>, and <code>second</code> fields are set to zero;
 * otherwise (a time field was included in the date-time string)
 * <code>allDay</code> is set to false. The fields <code>weekDay</code>,
 * <code>yearDay</code>, and <code>gmtoff</code> are always set to zero,
 * and the field <code>isDst</code> is set to -1 (unknown).  To set those
 * fields, call {@link #normalize(boolean)} after parsing.
 *
 * To parse a date-time string and convert it to UTC milliseconds, do
 * something like this:
 *
 * <pre>
 * Time time = new Time();
 * String date = "20081013T160000Z";
 * time.parse(date);
 * long millis = time.normalize(false);
 * </pre>
 *
 * @param s the string to parse
 * @return true if the resulting time value is in UTC time
 * @throws android.util.TimeFormatException if s cannot be parsed.
 */

Body of Frist Method:
{
    if (s == null) {
        throw new NullPointerException("time string is null");
    }
    if (nativeParse(s)) {
        timezone = TIMEZONE_UTC;
        return true;
    }
    return false;
}
Body of Second Method:
{
    if (s == null) {
        throw new NullPointerException("time string is null");
    }
    if (parseInternal(s)) {
        timezone = TIMEZONE_UTC;
        return true;
    }
    return false;
}
------------------------
Find a silently evolved API code:android.appwidget.AppWidgetHost.deleteHost:COMMENT
Method Modifier: public      
Comment:/**
 * Remove all records about this host from the AppWidget manager.
 * <ul>
 * <li>Call this when initializing your database, as it might be because of a data wipe.</li>
 * <li>Call this to have the AppWidget manager release all resources associated with your
 * host.  Any future calls about this host will cause the records to be re-allocated.</li>
 * </ul>
 */

Body of Frist Method:
{
    try {
        sService.deleteHost(mHostId, mContext.getUserId());
    } catch (RemoteException e) {
        throw new RuntimeException("system server dead?", e);
    }
}
Body of Second Method:
{
    try {
        sService.deleteHost(mContext.getOpPackageName(), mHostId);
    } catch (RemoteException e) {
        throw new RuntimeException("system server dead?", e);
    }
}
------------------------
Find a silently evolved API code:android.app.Activity.addContentView:COMMENT
Method Modifier: public      
Comment:/**
 * Add an additional content view to the activity.  Added after any existing
 * ones in the activity -- existing views are NOT removed.
 *
 * @param view The desired content to display.
 * @param params Layout parameters for the view.
 */

Body of Frist Method:
{
    getWindow().addContentView(view, params);
    initActionBar();
}
Body of Second Method:
{
    getWindow().addContentView(view, params);
    initWindowDecorActionBar();
}
------------------------
Find a silently evolved API code:android.widget.AdapterView.performItemClick:COMMENT
Method Modifier: public      
Comment:/**
 * Call the OnItemClickListener, if it is defined. Performs all normal
 * actions associated with clicking: reporting accessibility event, playing
 * a sound, etc.
 *
 * @param view The view within the AdapterView that was clicked.
 * @param position The position of the view in the adapter.
 * @param id The row id of the item that was clicked.
 * @return True if there was an assigned OnItemClickListener that was
 * called, false otherwise is returned.
 */

Body of Frist Method:
{
    if (mOnItemClickListener != null) {
        playSoundEffect(SoundEffectConstants.CLICK);
        if (view != null) {
            view.sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);
        }
        mOnItemClickListener.onItemClick(this, view, position, id);
        return true;
    }
    return false;
}
Body of Second Method:
{
    if (mOnItemClickListener != null) {
        playSoundEffect(SoundEffectConstants.CLICK);
        mOnItemClickListener.onItemClick(this, view, position, id);
        if (view != null) {
            view.sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);
        }
        return true;
    }
    return false;
}
------------------------
Find a silently evolved API code:android.content.res.Resources.Theme.setTo:COMMENT
Method Modifier: public      
Comment:/**
 * Set this theme to hold the same contents as the theme
 * <var>other</var>.  If both of these themes are from the same
 * Resources object, they will be identical after this function
 * returns.  If they are from different Resources, only the resources
 * they have in common will be set in this theme.
 *
 * @param other The existing Theme to copy from.
 */

Body of Frist Method:
{
    AssetManager.copyTheme(mTheme, other.mTheme);
}
Body of Second Method:
{
    AssetManager.copyTheme(mTheme, other.mTheme);
    mThemeResId = other.mThemeResId;
    mKey = other.mKey;
}
------------------------
Find a silently evolved API code:android.view.animation.Transformation.set:COMMENT
Method Modifier: public      
Comment:/**
 * Clones the specified transformation.
 *
 * @param t The transformation to clone.
 */

Body of Frist Method:
{
    mAlpha = t.getAlpha();
    mMatrix.set(t.getMatrix());
    mTransformationType = t.getTransformationType();
}
Body of Second Method:
{
    mAlpha = t.getAlpha();
    mMatrix.set(t.getMatrix());
    if (t.mHasClipRect) {
        setClipRect(t.getClipRect());
    } else {
        mHasClipRect = false;
        mClipRect.setEmpty();
    }
    mTransformationType = t.getTransformationType();
}
------------------------
Find a silently evolved API code:android.util.LongSparseArray.put:COMMENT
Method Modifier: public      
Comment:/**
 * Adds a mapping from the specified key to the specified value,
 * replacing the previous mapping from the specified key if there
 * was one.
 */

Body of Frist Method:
{
    int i = ContainerHelpers.binarySearch(mKeys, mSize, key);
    if (i >= 0) {
        mValues[i] = value;
    } else {
        i = ~i;
        if (i < mSize && mValues[i] == DELETED) {
            mKeys[i] = key;
            mValues[i] = value;
            return;
        }
        if (mGarbage && mSize >= mKeys.length) {
            gc();
            // Search again because indices may have changed.
            i = ~ContainerHelpers.binarySearch(mKeys, mSize, key);
        }
        if (mSize >= mKeys.length) {
            int n = ArrayUtils.idealLongArraySize(mSize + 1);
            long[] nkeys = new long[n];
            Object[] nvalues = new Object[n];
            // Log.e("SparseArray", "grow " + mKeys.length + " to " + n);
            System.arraycopy(mKeys, 0, nkeys, 0, mKeys.length);
            System.arraycopy(mValues, 0, nvalues, 0, mValues.length);
            mKeys = nkeys;
            mValues = nvalues;
        }
        if (mSize - i != 0) {
            // Log.e("SparseArray", "move " + (mSize - i));
            System.arraycopy(mKeys, i, mKeys, i + 1, mSize - i);
            System.arraycopy(mValues, i, mValues, i + 1, mSize - i);
        }
        mKeys[i] = key;
        mValues[i] = value;
        mSize++;
    }
}
Body of Second Method:
{
    int i = ContainerHelpers.binarySearch(mKeys, mSize, key);
    if (i >= 0) {
        mValues[i] = value;
    } else {
        i = ~i;
        if (i < mSize && mValues[i] == DELETED) {
            mKeys[i] = key;
            mValues[i] = value;
            return;
        }
        if (mGarbage && mSize >= mKeys.length) {
            gc();
            // Search again because indices may have changed.
            i = ~ContainerHelpers.binarySearch(mKeys, mSize, key);
        }
        mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);
        mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);
        mSize++;
    }
}
------------------------
Find a silently evolved API code:android.transition.Transition.end:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * This method is called automatically by the Transition and
 * TransitionSet classes when a transition finishes, either because
 * a transition did nothing (returned a null Animator from
 * {@link Transition#createAnimator(ViewGroup, TransitionValues,
 * TransitionValues)}) or because the transition returned a valid
 * Animator and end() was called in the onAnimationEnd()
 * callback of the AnimatorListener.
 *
 * @hide
 */

Body of Frist Method:
{
    --mNumInstances;
    if (mNumInstances == 0) {
        if (mListeners != null && mListeners.size() > 0) {
            ArrayList<TransitionListener> tmpListeners = (ArrayList<TransitionListener>) mListeners.clone();
            int numListeners = tmpListeners.size();
            for (int i = 0; i < numListeners; ++i) {
                tmpListeners.get(i).onTransitionEnd(this);
            }
        }
        for (int i = 0; i < mStartValues.itemIdValues.size(); ++i) {
            TransitionValues tv = mStartValues.itemIdValues.valueAt(i);
            View v = tv.view;
            if (v.hasTransientState()) {
                v.setHasTransientState(false);
            }
        }
        for (int i = 0; i < mEndValues.itemIdValues.size(); ++i) {
            TransitionValues tv = mEndValues.itemIdValues.valueAt(i);
            View v = tv.view;
            if (v.hasTransientState()) {
                v.setHasTransientState(false);
            }
        }
        mEnded = true;
    }
}
Body of Second Method:
{
    --mNumInstances;
    if (mNumInstances == 0) {
        if (mListeners != null && mListeners.size() > 0) {
            ArrayList<TransitionListener> tmpListeners = (ArrayList<TransitionListener>) mListeners.clone();
            int numListeners = tmpListeners.size();
            for (int i = 0; i < numListeners; ++i) {
                tmpListeners.get(i).onTransitionEnd(this);
            }
        }
        for (int i = 0; i < mStartValues.itemIdValues.size(); ++i) {
            View view = mStartValues.itemIdValues.valueAt(i);
            if (view != null) {
                view.setHasTransientState(false);
            }
        }
        for (int i = 0; i < mEndValues.itemIdValues.size(); ++i) {
            View view = mEndValues.itemIdValues.valueAt(i);
            if (view != null) {
                view.setHasTransientState(false);
            }
        }
        mEnded = true;
    }
}
------------------------
Find a silently evolved API code:android.os.PowerManager.validateWakeLockParameters:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    switch(levelAndFlags & WAKE_LOCK_LEVEL_MASK) {
        case PARTIAL_WAKE_LOCK:
        case SCREEN_DIM_WAKE_LOCK:
        case SCREEN_BRIGHT_WAKE_LOCK:
        case FULL_WAKE_LOCK:
        case PROXIMITY_SCREEN_OFF_WAKE_LOCK:
            break;
        default:
            throw new IllegalArgumentException("Must specify a valid wake lock level.");
    }
    if (tag == null) {
        throw new IllegalArgumentException("The tag must not be null.");
    }
}
Body of Second Method:
{
    switch(levelAndFlags & WAKE_LOCK_LEVEL_MASK) {
        case PARTIAL_WAKE_LOCK:
        case SCREEN_DIM_WAKE_LOCK:
        case SCREEN_BRIGHT_WAKE_LOCK:
        case FULL_WAKE_LOCK:
        case PROXIMITY_SCREEN_OFF_WAKE_LOCK:
        case DOZE_WAKE_LOCK:
            break;
        default:
            throw new IllegalArgumentException("Must specify a valid wake lock level.");
    }
    if (tag == null) {
        throw new IllegalArgumentException("The tag must not be null.");
    }
}
------------------------
Find a silently evolved API code:android.speech.tts.TextToSpeechService.SynthHandler.enqueueSpeechItem:COMMENT
Method Modifier: public      
Comment:/**
 * Adds a speech item to the queue.
 *
 * Called on a service binder thread.
 */

Body of Frist Method:
{
    UtteranceProgressDispatcher utterenceProgress = null;
    if (speechItem instanceof UtteranceProgressDispatcher) {
        utterenceProgress = (UtteranceProgressDispatcher) speechItem;
    }
    if (!speechItem.isValid()) {
        if (utterenceProgress != null) {
            utterenceProgress.dispatchOnError();
        }
        return TextToSpeech.ERROR;
    }
    if (queueMode == TextToSpeech.QUEUE_FLUSH) {
        stopForApp(speechItem.getCallerIdentity());
    } else if (queueMode == TextToSpeech.QUEUE_DESTROY) {
        stopAll();
    }
    Runnable runnable = new Runnable() {

        @Override
        public void run() {
            setCurrentSpeechItem(speechItem);
            speechItem.play();
            setCurrentSpeechItem(null);
        }
    };
    Message msg = Message.obtain(this, runnable);
    // The obj is used to remove all callbacks from the given app in
    // stopForApp(String).
    // 
    // Note that this string is interned, so the == comparison works.
    msg.obj = speechItem.getCallerIdentity();
    if (sendMessage(msg)) {
        return TextToSpeech.SUCCESS;
    } else {
        Log.w(TAG, "SynthThread has quit");
        if (utterenceProgress != null) {
            utterenceProgress.dispatchOnError();
        }
        return TextToSpeech.ERROR;
    }
}
Body of Second Method:
{
    UtteranceProgressDispatcher utterenceProgress = null;
    if (speechItem instanceof UtteranceProgressDispatcher) {
        utterenceProgress = (UtteranceProgressDispatcher) speechItem;
    }
    if (!speechItem.isValid()) {
        if (utterenceProgress != null) {
            utterenceProgress.dispatchOnError(TextToSpeech.ERROR_INVALID_REQUEST);
        }
        return TextToSpeech.ERROR;
    }
    if (queueMode == TextToSpeech.QUEUE_FLUSH) {
        stopForApp(speechItem.getCallerIdentity());
    } else if (queueMode == TextToSpeech.QUEUE_DESTROY) {
        stopAll();
    }
    Runnable runnable = new Runnable() {

        @Override
        public void run() {
            setCurrentSpeechItem(speechItem);
            speechItem.play();
            setCurrentSpeechItem(null);
        }
    };
    Message msg = Message.obtain(this, runnable);
    // The obj is used to remove all callbacks from the given app in
    // stopForApp(String).
    // 
    // Note that this string is interned, so the == comparison works.
    msg.obj = speechItem.getCallerIdentity();
    if (sendMessage(msg)) {
        return TextToSpeech.SUCCESS;
    } else {
        Log.w(TAG, "SynthThread has quit");
        if (utterenceProgress != null) {
            utterenceProgress.dispatchOnError(TextToSpeech.ERROR_SERVICE);
        }
        return TextToSpeech.ERROR;
    }
}
------------------------
Find a silently evolved API code:android.media.Ringtone.play:COMMENT
Method Modifier: public      
Comment:/**
 * Plays the ringtone.
 */

Body of Frist Method:
{
    if (mLocalPlayer != null) {
        // (typically because ringer mode is silent).
        if (mAudioManager.getStreamVolume(mStreamType) != 0) {
            mLocalPlayer.start();
        }
    } else if (mAllowRemote) {
        final Uri canonicalUri = mUri.getCanonicalUri();
        try {
            mRemotePlayer.play(mRemoteToken, canonicalUri, mStreamType);
        } catch (RemoteException e) {
            if (!playFallbackRingtone()) {
                Log.w(TAG, "Problem playing ringtone: " + e);
            }
        }
    } else {
        if (!playFallbackRingtone()) {
            Log.w(TAG, "Neither local nor remote playback available");
        }
    }
}
Body of Second Method:
{
    if (mLocalPlayer != null) {
        // (typically because ringer mode is silent).
        if (mAudioManager.getStreamVolume(AudioAttributes.toLegacyStreamType(mAudioAttributes)) != 0) {
            mLocalPlayer.start();
        }
    } else if (mAllowRemote && (mRemotePlayer != null)) {
        final Uri canonicalUri = mUri.getCanonicalUri();
        try {
            mRemotePlayer.play(mRemoteToken, canonicalUri, mAudioAttributes);
        } catch (RemoteException e) {
            if (!playFallbackRingtone()) {
                Log.w(TAG, "Problem playing ringtone: " + e);
            }
        }
    } else {
        if (!playFallbackRingtone()) {
            Log.w(TAG, "Neither local nor remote playback available");
        }
    }
}
------------------------
Find a silently evolved API code:android.content.res.BridgeTypedArray.getFloat:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the float value for the attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return Attribute float value, or defValue if not defined..
 */

Body of Frist Method:
{
    if (index < 0 || index >= mResourceData.length) {
        return defValue;
    }
    if (mResourceData[index] == null) {
        return defValue;
    }
    String s = mResourceData[index].getValue();
    if (s != null) {
        try {
            return Float.parseFloat(s);
        } catch (NumberFormatException e) {
            Bridge.getLog().warning(LayoutLog.TAG_RESOURCES_FORMAT, String.format("\"%s\" in attribute \"%2$s\" cannot be converted to float.", s, mNames[index]), null);
        // we'll return the default value below.
        }
    }
    return defValue;
}
Body of Second Method:
{
    String s = getString(index);
    try {
        if (s != null) {
            return Float.parseFloat(s);
        }
    } catch (NumberFormatException e) {
        Bridge.getLog().warning(LayoutLog.TAG_RESOURCES_FORMAT, String.format("\"%1$s\" in attribute \"%2$s\" cannot be converted to float.", s, mNames[index]), null);
    }
    return defValue;
}
------------------------
Find a silently evolved API code:android.content.res.BridgeTypedArray.getInt:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the integer value for the attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined.
 *
 * @return Attribute int value, or defValue if not defined.
 */

Body of Frist Method:
{
    if (index < 0 || index >= mResourceData.length) {
        return defValue;
    }
    if (mResourceData[index] == null) {
        return defValue;
    }
    String s = mResourceData[index].getValue();
    if (RenderResources.REFERENCE_NULL.equals(s)) {
        return defValue;
    }
    if (s == null || s.length() == 0) {
        return defValue;
    }
    try {
        return XmlUtils.convertValueToInt(s, defValue);
    } catch (NumberFormatException e) {
    // pass
    }
    // Field is not null and is not an integer.
    // Check for possible constants and try to find them.
    // Get the map of attribute-constant -> IntegerValue
    Map<String, Integer> map = null;
    if (mIsFramework[index]) {
        map = Bridge.getEnumValues(mNames[index]);
    } else {
        // get the styleable matching the resolved name
        RenderResources res = mContext.getRenderResources();
        ResourceValue attr = res.getProjectResource(ResourceType.ATTR, mNames[index]);
        if (attr instanceof AttrResourceValue) {
            map = ((AttrResourceValue) attr).getAttributeValues();
        }
    }
    if (map != null) {
        // accumulator to store the value of the 1+ constants.
        int result = 0;
        // split the value in case this is a mix of several flags.
        String[] keywords = s.split("\\|");
        for (String keyword : keywords) {
            Integer i = map.get(keyword.trim());
            if (i != null) {
                result |= i.intValue();
            } else {
                Bridge.getLog().warning(LayoutLog.TAG_RESOURCES_FORMAT, String.format("\"%s\" in attribute \"%2$s\" is not a valid value", keyword, mNames[index]), null);
            }
        }
        return result;
    }
    return defValue;
}
Body of Second Method:
{
    String s = getString(index);
    try {
        if (s != null) {
            return XmlUtils.convertValueToInt(s, defValue);
        }
    } catch (NumberFormatException e) {
        Bridge.getLog().warning(LayoutLog.TAG_RESOURCES_FORMAT, String.format("\"%1$s\" in attribute \"%2$s\" is not a valid integer", s, mNames[index]), null);
        return defValue;
    }
    return defValue;
}
------------------------
Find a silently evolved API code:android.widget.TextView.getExtendedPaddingBottom:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the extended bottom padding of the view, including both the
 * bottom Drawable if any and any extra space to keep more than maxLines
 * of text from showing.  It is only valid to call this after measuring.
 */

Body of Frist Method:
{
    if (mMaxMode != LINES) {
        return getCompoundPaddingBottom();
    }
    if (mLayout.getLineCount() <= mMaximum) {
        return getCompoundPaddingBottom();
    }
    int top = getCompoundPaddingTop();
    int bottom = getCompoundPaddingBottom();
    int viewht = getHeight() - top - bottom;
    int layoutht = mLayout.getLineTop(mMaximum);
    if (layoutht >= viewht) {
        return bottom;
    }
    final int gravity = mGravity & Gravity.VERTICAL_GRAVITY_MASK;
    if (gravity == Gravity.TOP) {
        return bottom + viewht - layoutht;
    } else if (gravity == Gravity.BOTTOM) {
        return bottom;
    } else {
        // (gravity == Gravity.CENTER_VERTICAL)
        return bottom + (viewht - layoutht) / 2;
    }
}
Body of Second Method:
{
    if (mMaxMode != LINES) {
        return getCompoundPaddingBottom();
    }
    if (mLayout == null) {
        assumeLayout();
    }
    if (mLayout.getLineCount() <= mMaximum) {
        return getCompoundPaddingBottom();
    }
    int top = getCompoundPaddingTop();
    int bottom = getCompoundPaddingBottom();
    int viewht = getHeight() - top - bottom;
    int layoutht = mLayout.getLineTop(mMaximum);
    if (layoutht >= viewht) {
        return bottom;
    }
    final int gravity = mGravity & Gravity.VERTICAL_GRAVITY_MASK;
    if (gravity == Gravity.TOP) {
        return bottom + viewht - layoutht;
    } else if (gravity == Gravity.BOTTOM) {
        return bottom;
    } else {
        // (gravity == Gravity.CENTER_VERTICAL)
        return bottom + (viewht - layoutht) / 2;
    }
}
------------------------
Find a silently evolved API code:android.media.AudioService.setModeInt:COMMENT
<android.media.AudioService: int setModeInt(int,IBinder,int)>
default     hidden      ->private     hidden      
Method Modifier: private     default     hidden      
Method Modifier: No          Yes         Yes         
Method Updated:  Yes         No          Yes         
Comment:// any mode other than NORMAL.

Body of Frist Method:
{
    int newModeOwnerPid = 0;
    if (cb == null) {
        Log.e(TAG, "setModeInt() called with null binder");
        return newModeOwnerPid;
    }
    SetModeDeathHandler hdlr = null;
    Iterator iter = mSetModeDeathHandlers.iterator();
    while (iter.hasNext()) {
        SetModeDeathHandler h = (SetModeDeathHandler) iter.next();
        if (h.getPid() == pid) {
            hdlr = h;
            // Remove from client list so that it is re-inserted at top of list
            iter.remove();
            hdlr.getBinder().unlinkToDeath(hdlr, 0);
            break;
        }
    }
    int status = AudioSystem.AUDIO_STATUS_OK;
    do {
        if (mode == AudioSystem.MODE_NORMAL) {
            // get new mode from client at top the list if any
            if (!mSetModeDeathHandlers.isEmpty()) {
                hdlr = mSetModeDeathHandlers.get(0);
                cb = hdlr.getBinder();
                mode = hdlr.getMode();
            }
        } else {
            if (hdlr == null) {
                hdlr = new SetModeDeathHandler(cb, pid);
            }
            // Register for client death notification
            try {
                cb.linkToDeath(hdlr, 0);
            } catch (RemoteException e) {
                // Client has died!
                Log.w(TAG, "setMode() could not link to " + cb + " binder death");
            }
            // Last client to call setMode() is always at top of client list
            // as required by SetModeDeathHandler.binderDied()
            mSetModeDeathHandlers.add(0, hdlr);
            hdlr.setMode(mode);
        }
        if (mode != mMode) {
            status = AudioSystem.setPhoneState(mode);
            if (status == AudioSystem.AUDIO_STATUS_OK) {
                mMode = mode;
            } else {
                if (hdlr != null) {
                    mSetModeDeathHandlers.remove(hdlr);
                    cb.unlinkToDeath(hdlr, 0);
                }
                // force reading new top of mSetModeDeathHandlers stack
                mode = AudioSystem.MODE_NORMAL;
            }
        } else {
            status = AudioSystem.AUDIO_STATUS_OK;
        }
    } while (status != AudioSystem.AUDIO_STATUS_OK && !mSetModeDeathHandlers.isEmpty());
    if (status == AudioSystem.AUDIO_STATUS_OK) {
        if (mode != AudioSystem.MODE_NORMAL) {
            if (mSetModeDeathHandlers.isEmpty()) {
                Log.e(TAG, "setMode() different from MODE_NORMAL with empty mode client stack");
            } else {
                newModeOwnerPid = mSetModeDeathHandlers.get(0).getPid();
            }
        }
        int streamType = getActiveStreamType(AudioManager.USE_DEFAULT_STREAM_TYPE);
        if (streamType == STREAM_REMOTE_MUSIC) {
            // here handle remote media playback the same way as local playback
            streamType = AudioManager.STREAM_MUSIC;
        }
        int device = getDeviceForStream(streamType);
        int index = mStreamStates[mStreamVolumeAlias[streamType]].getIndex(device);
        setStreamVolumeInt(mStreamVolumeAlias[streamType], index, device, true);
        updateStreamVolumeAlias(true);
    }
    return newModeOwnerPid;
}
Body of Second Method:
{
    if (DEBUG_MODE) {
        Log.v(TAG, "setModeInt(mode=" + mode + ", pid=" + pid + ")");
    }
    int newModeOwnerPid = 0;
    if (cb == null) {
        Log.e(TAG, "setModeInt() called with null binder");
        return newModeOwnerPid;
    }
    SetModeDeathHandler hdlr = null;
    Iterator iter = mSetModeDeathHandlers.iterator();
    while (iter.hasNext()) {
        SetModeDeathHandler h = (SetModeDeathHandler) iter.next();
        if (h.getPid() == pid) {
            hdlr = h;
            // Remove from client list so that it is re-inserted at top of list
            iter.remove();
            hdlr.getBinder().unlinkToDeath(hdlr, 0);
            break;
        }
    }
    int status = AudioSystem.AUDIO_STATUS_OK;
    do {
        if (mode == AudioSystem.MODE_NORMAL) {
            // get new mode from client at top the list if any
            if (!mSetModeDeathHandlers.isEmpty()) {
                hdlr = mSetModeDeathHandlers.get(0);
                cb = hdlr.getBinder();
                mode = hdlr.getMode();
                if (DEBUG_MODE) {
                    Log.w(TAG, " using mode=" + mode + " instead due to death hdlr at pid=" + hdlr.mPid);
                }
            }
        } else {
            if (hdlr == null) {
                hdlr = new SetModeDeathHandler(cb, pid);
            }
            // Register for client death notification
            try {
                cb.linkToDeath(hdlr, 0);
            } catch (RemoteException e) {
                // Client has died!
                Log.w(TAG, "setMode() could not link to " + cb + " binder death");
            }
            // Last client to call setMode() is always at top of client list
            // as required by SetModeDeathHandler.binderDied()
            mSetModeDeathHandlers.add(0, hdlr);
            hdlr.setMode(mode);
        }
        if (mode != mMode) {
            status = AudioSystem.setPhoneState(mode);
            if (status == AudioSystem.AUDIO_STATUS_OK) {
                if (DEBUG_MODE) {
                    Log.v(TAG, " mode successfully set to " + mode);
                }
                mMode = mode;
            } else {
                if (hdlr != null) {
                    mSetModeDeathHandlers.remove(hdlr);
                    cb.unlinkToDeath(hdlr, 0);
                }
                // force reading new top of mSetModeDeathHandlers stack
                if (DEBUG_MODE) {
                    Log.w(TAG, " mode set to MODE_NORMAL after phoneState pb");
                }
                mode = AudioSystem.MODE_NORMAL;
            }
        } else {
            status = AudioSystem.AUDIO_STATUS_OK;
        }
    } while (status != AudioSystem.AUDIO_STATUS_OK && !mSetModeDeathHandlers.isEmpty());
    if (status == AudioSystem.AUDIO_STATUS_OK) {
        if (mode != AudioSystem.MODE_NORMAL) {
            if (mSetModeDeathHandlers.isEmpty()) {
                Log.e(TAG, "setMode() different from MODE_NORMAL with empty mode client stack");
            } else {
                newModeOwnerPid = mSetModeDeathHandlers.get(0).getPid();
            }
        }
        int streamType = getActiveStreamType(AudioManager.USE_DEFAULT_STREAM_TYPE);
        int device = getDeviceForStream(streamType);
        int index = mStreamStates[mStreamVolumeAlias[streamType]].getIndex(device);
        setStreamVolumeInt(mStreamVolumeAlias[streamType], index, device, true);
        updateStreamVolumeAlias(true);
    }
    return newModeOwnerPid;
}
------------------------
Find a silently evolved API code:android.appwidget.AppWidgetHost.getAppWidgetIds:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Gets a list of all the appWidgetIds that are bound to the current host
 *
 * @hide
 */

Body of Frist Method:
{
    try {
        if (sService == null) {
            bindService();
        }
        return sService.getAppWidgetIdsForHost(mHostId, mContext.getUserId());
    } catch (RemoteException e) {
        throw new RuntimeException("system server dead?", e);
    }
}
Body of Second Method:
{
    try {
        if (sService == null) {
            bindService();
        }
        return sService.getAppWidgetIdsForHost(mContext.getOpPackageName(), mHostId);
    } catch (RemoteException e) {
        throw new RuntimeException("system server dead?", e);
    }
}
------------------------
Find a silently evolved API code:android.app.Notification.safeCharSequence:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Make sure this CharSequence is safe to put into a bundle, which basically
 * means it had better not be some custom Parcelable implementation.
 * @hide
 */

Body of Frist Method:
{
    if (cs instanceof Parcelable) {
        Log.e(TAG, "warning: " + cs.getClass().getCanonicalName() + " instance is a custom Parcelable and not allowed in Notification");
        return cs.toString();
    }
    return cs;
}
Body of Second Method:
{
    if (cs == null)
        return cs;
    if (cs.length() > MAX_CHARSEQUENCE_LENGTH) {
        cs = cs.subSequence(0, MAX_CHARSEQUENCE_LENGTH);
    }
    if (cs instanceof Parcelable) {
        Log.e(TAG, "warning: " + cs.getClass().getCanonicalName() + " instance is a custom Parcelable and not allowed in Notification");
        return cs.toString();
    }
    return cs;
}
------------------------
Find a silently evolved API code:android.util.SparseIntArray.put:COMMENT
Method Modifier: public      
Comment:/**
 * Adds a mapping from the specified key to the specified value,
 * replacing the previous mapping from the specified key if there
 * was one.
 */

Body of Frist Method:
{
    int i = ContainerHelpers.binarySearch(mKeys, mSize, key);
    if (i >= 0) {
        mValues[i] = value;
    } else {
        i = ~i;
        if (mSize >= mKeys.length) {
            int n = ArrayUtils.idealIntArraySize(mSize + 1);
            int[] nkeys = new int[n];
            int[] nvalues = new int[n];
            // Log.e("SparseIntArray", "grow " + mKeys.length + " to " + n);
            System.arraycopy(mKeys, 0, nkeys, 0, mKeys.length);
            System.arraycopy(mValues, 0, nvalues, 0, mValues.length);
            mKeys = nkeys;
            mValues = nvalues;
        }
        if (mSize - i != 0) {
            // Log.e("SparseIntArray", "move " + (mSize - i));
            System.arraycopy(mKeys, i, mKeys, i + 1, mSize - i);
            System.arraycopy(mValues, i, mValues, i + 1, mSize - i);
        }
        mKeys[i] = key;
        mValues[i] = value;
        mSize++;
    }
}
Body of Second Method:
{
    int i = ContainerHelpers.binarySearch(mKeys, mSize, key);
    if (i >= 0) {
        mValues[i] = value;
    } else {
        i = ~i;
        mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);
        mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);
        mSize++;
    }
}
------------------------
Find a silently evolved API code:android.widget.FastScroller.setThumbPos:COMMENT
Method Modifier: private     
Comment:/**
 * Positions the thumb and preview widgets.
 *
 * @param position The position, between 0 and 1, along the track at which
 * to place the thumb.
 */

Body of Frist Method:
{
    final Rect container = mContainerRect;
    final int top = container.top;
    final int bottom = container.bottom;
    final ImageView trackImage = mTrackImage;
    final ImageView thumbImage = mThumbImage;
    final float min = trackImage.getTop();
    final float max = trackImage.getBottom();
    final float offset = min;
    final float range = max - min;
    final float thumbMiddle = position * range + offset;
    thumbImage.setTranslationY(thumbMiddle - thumbImage.getHeight() / 2);
    final float previewPos = mOverlayPosition == OVERLAY_AT_THUMB ? thumbMiddle : 0;
    // Center the preview on the thumb, constrained to the list bounds.
    final ImageView previewImage = mPreviewImage;
    final float previewHalfHeight = previewImage.getHeight() / 2f;
    final float minP = top + previewHalfHeight;
    final float maxP = bottom - previewHalfHeight;
    final float previewMiddle = MathUtils.constrain(previewPos, minP, maxP);
    final float previewTop = previewMiddle - previewHalfHeight;
    previewImage.setTranslationY(previewTop);
    mPrimaryText.setTranslationY(previewTop);
    mSecondaryText.setTranslationY(previewTop);
}
Body of Second Method:
{
    final Rect container = mContainerRect;
    final int top = container.top;
    final int bottom = container.bottom;
    final View trackImage = mTrackImage;
    final View thumbImage = mThumbImage;
    final float min = trackImage.getTop();
    final float max = trackImage.getBottom();
    final float offset = min;
    final float range = max - min;
    final float thumbMiddle = position * range + offset;
    thumbImage.setTranslationY(thumbMiddle - thumbImage.getHeight() / 2);
    final View previewImage = mPreviewImage;
    final float previewHalfHeight = previewImage.getHeight() / 2f;
    final float previewPos;
    switch(mOverlayPosition) {
        case OVERLAY_AT_THUMB:
            previewPos = thumbMiddle;
            break;
        case OVERLAY_ABOVE_THUMB:
            previewPos = thumbMiddle - previewHalfHeight;
            break;
        case OVERLAY_FLOATING:
        default:
            previewPos = 0;
            break;
    }
    // Center the preview on the thumb, constrained to the list bounds.
    final float minP = top + previewHalfHeight;
    final float maxP = bottom - previewHalfHeight;
    final float previewMiddle = MathUtils.constrain(previewPos, minP, maxP);
    final float previewTop = previewMiddle - previewHalfHeight;
    previewImage.setTranslationY(previewTop);
    mPrimaryText.setTranslationY(previewTop);
    mSecondaryText.setTranslationY(previewTop);
}
------------------------
Find a silently evolved API code:android.view.ViewGroup.setClipChildren:COMMENT
Method Modifier: public      
Comment:/**
 * By default, children are clipped to their bounds before drawing. This
 * allows view groups to override this behavior for animations, etc.
 *
 * @param clipChildren true to clip children to their bounds,
 * false otherwise
 * @attr ref android.R.styleable#ViewGroup_clipChildren
 */

Body of Frist Method:
{
    boolean previousValue = (mGroupFlags & FLAG_CLIP_CHILDREN) == FLAG_CLIP_CHILDREN;
    if (clipChildren != previousValue) {
        setBooleanFlag(FLAG_CLIP_CHILDREN, clipChildren);
        for (int i = 0; i < mChildrenCount; ++i) {
            View child = getChildAt(i);
            if (child.mDisplayList != null) {
                child.mDisplayList.setClipToBounds(clipChildren);
            }
        }
    }
}
Body of Second Method:
{
    boolean previousValue = (mGroupFlags & FLAG_CLIP_CHILDREN) == FLAG_CLIP_CHILDREN;
    if (clipChildren != previousValue) {
        setBooleanFlag(FLAG_CLIP_CHILDREN, clipChildren);
        for (int i = 0; i < mChildrenCount; ++i) {
            View child = getChildAt(i);
            if (child.mRenderNode != null) {
                child.mRenderNode.setClipToBounds(clipChildren);
            }
        }
        invalidate(true);
    }
}
------------------------
Find a silently evolved API code:android.widget.ListPopupWindow.ForwardingListener.onTouchObserved:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Observes motion events and determines when to start forwarding.
 *
 * @param srcEvent motion event in source view coordinates
 * @return true to start forwarding motion events, false otherwise
 */

Body of Frist Method:
{
    final View src = mSrc;
    if (!src.isEnabled()) {
        return false;
    }
    final int actionMasked = srcEvent.getActionMasked();
    switch(actionMasked) {
        case MotionEvent.ACTION_DOWN:
            mActivePointerId = srcEvent.getPointerId(0);
            if (mDisallowIntercept == null) {
                mDisallowIntercept = new DisallowIntercept();
            }
            src.postDelayed(mDisallowIntercept, mTapTimeout);
            break;
        case MotionEvent.ACTION_MOVE:
            final int activePointerIndex = srcEvent.findPointerIndex(mActivePointerId);
            if (activePointerIndex >= 0) {
                final float x = srcEvent.getX(activePointerIndex);
                final float y = srcEvent.getY(activePointerIndex);
                if (!src.pointInView(x, y, mScaledTouchSlop)) {
                    // The pointer has moved outside of the view.
                    if (mDisallowIntercept != null) {
                        src.removeCallbacks(mDisallowIntercept);
                    }
                    src.getParent().requestDisallowInterceptTouchEvent(true);
                    return true;
                }
            }
            break;
        case MotionEvent.ACTION_CANCEL:
        case MotionEvent.ACTION_UP:
            if (mDisallowIntercept != null) {
                src.removeCallbacks(mDisallowIntercept);
            }
            break;
    }
    return false;
}
Body of Second Method:
{
    final View src = mSrc;
    if (!src.isEnabled()) {
        return false;
    }
    final int actionMasked = srcEvent.getActionMasked();
    switch(actionMasked) {
        case MotionEvent.ACTION_DOWN:
            mActivePointerId = srcEvent.getPointerId(0);
            mWasLongPress = false;
            if (mDisallowIntercept == null) {
                mDisallowIntercept = new DisallowIntercept();
            }
            src.postDelayed(mDisallowIntercept, mTapTimeout);
            if (mTriggerLongPress == null) {
                mTriggerLongPress = new TriggerLongPress();
            }
            src.postDelayed(mTriggerLongPress, mLongPressTimeout);
            break;
        case MotionEvent.ACTION_MOVE:
            final int activePointerIndex = srcEvent.findPointerIndex(mActivePointerId);
            if (activePointerIndex >= 0) {
                final float x = srcEvent.getX(activePointerIndex);
                final float y = srcEvent.getY(activePointerIndex);
                // Has the pointer has moved outside of the view?
                if (!src.pointInView(x, y, mScaledTouchSlop)) {
                    clearCallbacks();
                    // Don't let the parent intercept our events.
                    src.getParent().requestDisallowInterceptTouchEvent(true);
                    return true;
                }
            }
            break;
        case MotionEvent.ACTION_CANCEL:
        case MotionEvent.ACTION_UP:
            clearCallbacks();
            break;
    }
    return false;
}
------------------------
Find a silently evolved API code:android.os.Bundle.getChar:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the value associated with the given key, or (char) 0 if
 * no mapping of the desired type exists for the given key.
 *
 * @param key a String
 * @return a char value
 */

Body of Frist Method:
{
    unparcel();
    return getChar(key, (char) 0);
}
Body of Second Method:
{
    return super.getChar(key);
}
------------------------
Find a silently evolved API code:android.os.ParcelFileDescriptor.createReliablePipe:COMMENT
Method Modifier: public      static      
Comment:/**
 * Create two ParcelFileDescriptors structured as a data pipe. The first
 * ParcelFileDescriptor in the returned array is the read side; the second
 * is the write side.
 * <p>
 * The write end has the ability to deliver an error message through
 * {@link #closeWithError(String)} which can be handled by the read end
 * calling {@link #checkError()}, usually after detecting an EOF.
 * This can also be used to detect remote crashes.
 */

Body of Frist Method:
{
    try {
        final FileDescriptor[] comm = createCommSocketPair(false);
        final FileDescriptor[] fds = Libcore.os.pipe();
        return new ParcelFileDescriptor[] { new ParcelFileDescriptor(fds[0], comm[0]), new ParcelFileDescriptor(fds[1], comm[1]) };
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
}
Body of Second Method:
{
    try {
        final FileDescriptor[] comm = createCommSocketPair();
        final FileDescriptor[] fds = Os.pipe();
        return new ParcelFileDescriptor[] { new ParcelFileDescriptor(fds[0], comm[0]), new ParcelFileDescriptor(fds[1], comm[1]) };
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
}
------------------------
Find a silently evolved API code:android.view.ViewGroup.invalidateChild:COMMENT
Method Modifier: public      final       
Comment:/**
 * Don't call or override this method. It is used for the implementation of
 * the view hierarchy.
 */

Body of Frist Method:
{
    ViewParent parent = this;
    final AttachInfo attachInfo = mAttachInfo;
    if (attachInfo != null) {
        // If the child is drawing an animation, we want to copy this flag onto
        // ourselves and the parent to make sure the invalidate request goes
        // through
        final boolean drawAnimation = (child.mPrivateFlags & PFLAG_DRAW_ANIMATION) == PFLAG_DRAW_ANIMATION;
        // Check whether the child that requests the invalidate is fully opaque
        // Views being animated or transformed are not considered opaque because we may
        // be invalidating their old position and need the parent to paint behind them.
        Matrix childMatrix = child.getMatrix();
        final boolean isOpaque = child.isOpaque() && !drawAnimation && child.getAnimation() == null && childMatrix.isIdentity();
        // Mark the child as dirty, using the appropriate flag
        // Make sure we do not set both flags at the same time
        int opaqueFlag = isOpaque ? PFLAG_DIRTY_OPAQUE : PFLAG_DIRTY;
        if (child.mLayerType != LAYER_TYPE_NONE) {
            mPrivateFlags |= PFLAG_INVALIDATED;
            mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
            child.mLocalDirtyRect.union(dirty);
        }
        final int[] location = attachInfo.mInvalidateChildLocation;
        location[CHILD_LEFT_INDEX] = child.mLeft;
        location[CHILD_TOP_INDEX] = child.mTop;
        if (!childMatrix.isIdentity() || (mGroupFlags & ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) != 0) {
            RectF boundingRect = attachInfo.mTmpTransformRect;
            boundingRect.set(dirty);
            Matrix transformMatrix;
            if ((mGroupFlags & ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) != 0) {
                Transformation t = attachInfo.mTmpTransformation;
                boolean transformed = getChildStaticTransformation(child, t);
                if (transformed) {
                    transformMatrix = attachInfo.mTmpMatrix;
                    transformMatrix.set(t.getMatrix());
                    if (!childMatrix.isIdentity()) {
                        transformMatrix.preConcat(childMatrix);
                    }
                } else {
                    transformMatrix = childMatrix;
                }
            } else {
                transformMatrix = childMatrix;
            }
            transformMatrix.mapRect(boundingRect);
            dirty.set((int) (boundingRect.left - 0.5f), (int) (boundingRect.top - 0.5f), (int) (boundingRect.right + 0.5f), (int) (boundingRect.bottom + 0.5f));
        }
        do {
            View view = null;
            if (parent instanceof View) {
                view = (View) parent;
            }
            if (drawAnimation) {
                if (view != null) {
                    view.mPrivateFlags |= PFLAG_DRAW_ANIMATION;
                } else if (parent instanceof ViewRootImpl) {
                    ((ViewRootImpl) parent).mIsAnimating = true;
                }
            }
            // flag coming from the child that initiated the invalidate
            if (view != null) {
                if ((view.mViewFlags & FADING_EDGE_MASK) != 0 && view.getSolidColor() == 0) {
                    opaqueFlag = PFLAG_DIRTY;
                }
                if ((view.mPrivateFlags & PFLAG_DIRTY_MASK) != PFLAG_DIRTY) {
                    view.mPrivateFlags = (view.mPrivateFlags & ~PFLAG_DIRTY_MASK) | opaqueFlag;
                }
            }
            parent = parent.invalidateChildInParent(location, dirty);
            if (view != null) {
                // Account for transform on current parent
                Matrix m = view.getMatrix();
                if (!m.isIdentity()) {
                    RectF boundingRect = attachInfo.mTmpTransformRect;
                    boundingRect.set(dirty);
                    m.mapRect(boundingRect);
                    dirty.set((int) (boundingRect.left - 0.5f), (int) (boundingRect.top - 0.5f), (int) (boundingRect.right + 0.5f), (int) (boundingRect.bottom + 0.5f));
                }
            }
        } while (parent != null);
    }
}
Body of Second Method:
{
    ViewParent parent = this;
    final AttachInfo attachInfo = mAttachInfo;
    if (attachInfo != null) {
        // If the child is drawing an animation, we want to copy this flag onto
        // ourselves and the parent to make sure the invalidate request goes
        // through
        final boolean drawAnimation = (child.mPrivateFlags & PFLAG_DRAW_ANIMATION) == PFLAG_DRAW_ANIMATION;
        // Check whether the child that requests the invalidate is fully opaque
        // Views being animated or transformed are not considered opaque because we may
        // be invalidating their old position and need the parent to paint behind them.
        Matrix childMatrix = child.getMatrix();
        final boolean isOpaque = child.isOpaque() && !drawAnimation && child.getAnimation() == null && childMatrix.isIdentity();
        // Mark the child as dirty, using the appropriate flag
        // Make sure we do not set both flags at the same time
        int opaqueFlag = isOpaque ? PFLAG_DIRTY_OPAQUE : PFLAG_DIRTY;
        if (child.mLayerType != LAYER_TYPE_NONE) {
            mPrivateFlags |= PFLAG_INVALIDATED;
            mPrivateFlags &= ~PFLAG_DRAWING_CACHE_VALID;
        }
        final int[] location = attachInfo.mInvalidateChildLocation;
        location[CHILD_LEFT_INDEX] = child.mLeft;
        location[CHILD_TOP_INDEX] = child.mTop;
        if (!childMatrix.isIdentity() || (mGroupFlags & ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) != 0) {
            RectF boundingRect = attachInfo.mTmpTransformRect;
            boundingRect.set(dirty);
            Matrix transformMatrix;
            if ((mGroupFlags & ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) != 0) {
                Transformation t = attachInfo.mTmpTransformation;
                boolean transformed = getChildStaticTransformation(child, t);
                if (transformed) {
                    transformMatrix = attachInfo.mTmpMatrix;
                    transformMatrix.set(t.getMatrix());
                    if (!childMatrix.isIdentity()) {
                        transformMatrix.preConcat(childMatrix);
                    }
                } else {
                    transformMatrix = childMatrix;
                }
            } else {
                transformMatrix = childMatrix;
            }
            transformMatrix.mapRect(boundingRect);
            dirty.set((int) (boundingRect.left - 0.5f), (int) (boundingRect.top - 0.5f), (int) (boundingRect.right + 0.5f), (int) (boundingRect.bottom + 0.5f));
        }
        do {
            View view = null;
            if (parent instanceof View) {
                view = (View) parent;
            }
            if (drawAnimation) {
                if (view != null) {
                    view.mPrivateFlags |= PFLAG_DRAW_ANIMATION;
                } else if (parent instanceof ViewRootImpl) {
                    ((ViewRootImpl) parent).mIsAnimating = true;
                }
            }
            // flag coming from the child that initiated the invalidate
            if (view != null) {
                if ((view.mViewFlags & FADING_EDGE_MASK) != 0 && view.getSolidColor() == 0) {
                    opaqueFlag = PFLAG_DIRTY;
                }
                if ((view.mPrivateFlags & PFLAG_DIRTY_MASK) != PFLAG_DIRTY) {
                    view.mPrivateFlags = (view.mPrivateFlags & ~PFLAG_DIRTY_MASK) | opaqueFlag;
                }
            }
            parent = parent.invalidateChildInParent(location, dirty);
            if (view != null) {
                // Account for transform on current parent
                Matrix m = view.getMatrix();
                if (!m.isIdentity()) {
                    RectF boundingRect = attachInfo.mTmpTransformRect;
                    boundingRect.set(dirty);
                    m.mapRect(boundingRect);
                    dirty.set((int) (boundingRect.left - 0.5f), (int) (boundingRect.top - 0.5f), (int) (boundingRect.right + 0.5f), (int) (boundingRect.bottom + 0.5f));
                }
            }
        } while (parent != null);
    }
}
------------------------
Find a silently evolved API code:android.net.http.CertificateChainValidator.handleTrustStorageUpdate:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Handles updates to credential storage.
 */

Body of Frist Method:
{
    try {
        X509TrustManager x509TrustManager = SSLParametersImpl.getDefaultTrustManager();
        if (x509TrustManager instanceof TrustManagerImpl) {
            TrustManagerImpl trustManager = (TrustManagerImpl) x509TrustManager;
            trustManager.handleTrustStorageUpdate();
        }
    } catch (KeyManagementException ignored) {
    }
}
Body of Second Method:
{
    TrustManagerFactory tmf;
    try {
        tmf = TrustManagerFactory.getInstance("X.509");
        tmf.init((KeyStore) null);
    } catch (NoSuchAlgorithmException e) {
        Slog.w(TAG, "Couldn't find default X.509 TrustManagerFactory");
        return;
    } catch (KeyStoreException e) {
        Slog.w(TAG, "Couldn't initialize default X.509 TrustManagerFactory", e);
        return;
    }
    TrustManager[] tms = tmf.getTrustManagers();
    boolean sentUpdate = false;
    for (TrustManager tm : tms) {
        try {
            Method updateMethod = tm.getClass().getDeclaredMethod("handleTrustStorageUpdate");
            updateMethod.setAccessible(true);
            updateMethod.invoke(tm);
            sentUpdate = true;
        } catch (Exception e) {
        }
    }
    if (!sentUpdate) {
        Slog.w(TAG, "Didn't find a TrustManager to handle CA list update");
    }
}
------------------------
Find a silently evolved API code:android.transition.Transition.createAnimators:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * This method, essentially a wrapper around all calls to createAnimator for all
 * possible target views, is called with the entire set of start/end
 * values. The implementation in Transition iterates through these lists
 * and calls {@link #createAnimator(ViewGroup, TransitionValues, TransitionValues)}
 * with each set of start/end values on this transition. The
 * TransitionSet subclass overrides this method and delegates it to
 * each of its children in succession.
 *
 * @hide
 */

Body of Frist Method:
{
    if (DBG) {
        Log.d(LOG_TAG, "createAnimators() for " + this);
    }
    ArrayMap<View, TransitionValues> endCopy = new ArrayMap<View, TransitionValues>(endValues.viewValues);
    SparseArray<TransitionValues> endIdCopy = new SparseArray<TransitionValues>(endValues.idValues.size());
    for (int i = 0; i < endValues.idValues.size(); ++i) {
        int id = endValues.idValues.keyAt(i);
        endIdCopy.put(id, endValues.idValues.valueAt(i));
    }
    LongSparseArray<TransitionValues> endItemIdCopy = new LongSparseArray<TransitionValues>(endValues.itemIdValues.size());
    for (int i = 0; i < endValues.itemIdValues.size(); ++i) {
        long id = endValues.itemIdValues.keyAt(i);
        endItemIdCopy.put(id, endValues.itemIdValues.valueAt(i));
    }
    // Walk through the start values, playing everything we find
    // Remove from the end set as we go
    ArrayList<TransitionValues> startValuesList = new ArrayList<TransitionValues>();
    ArrayList<TransitionValues> endValuesList = new ArrayList<TransitionValues>();
    for (View view : startValues.viewValues.keySet()) {
        TransitionValues start = null;
        TransitionValues end = null;
        boolean isInListView = false;
        if (view.getParent() instanceof ListView) {
            isInListView = true;
        }
        if (!isInListView) {
            int id = view.getId();
            start = startValues.viewValues.get(view) != null ? startValues.viewValues.get(view) : startValues.idValues.get(id);
            if (endValues.viewValues.get(view) != null) {
                end = endValues.viewValues.get(view);
                endCopy.remove(view);
            } else if (id != View.NO_ID) {
                end = endValues.idValues.get(id);
                View removeView = null;
                for (View viewToRemove : endCopy.keySet()) {
                    if (viewToRemove.getId() == id) {
                        removeView = viewToRemove;
                    }
                }
                if (removeView != null) {
                    endCopy.remove(removeView);
                }
            }
            endIdCopy.remove(id);
            if (isValidTarget(view, id)) {
                startValuesList.add(start);
                endValuesList.add(end);
            }
        } else {
            ListView parent = (ListView) view.getParent();
            if (parent.getAdapter().hasStableIds()) {
                int position = parent.getPositionForView(view);
                long itemId = parent.getItemIdAtPosition(position);
                start = startValues.itemIdValues.get(itemId);
                endItemIdCopy.remove(itemId);
                // TODO: deal with targetIDs for itemIDs for ListView items
                startValuesList.add(start);
                endValuesList.add(end);
            }
        }
    }
    int startItemIdCopySize = startValues.itemIdValues.size();
    for (int i = 0; i < startItemIdCopySize; ++i) {
        long id = startValues.itemIdValues.keyAt(i);
        if (isValidTarget(null, id)) {
            TransitionValues start = startValues.itemIdValues.get(id);
            TransitionValues end = endValues.itemIdValues.get(id);
            endItemIdCopy.remove(id);
            startValuesList.add(start);
            endValuesList.add(end);
        }
    }
    // Now walk through the remains of the end set
    for (View view : endCopy.keySet()) {
        int id = view.getId();
        if (isValidTarget(view, id)) {
            TransitionValues start = startValues.viewValues.get(view) != null ? startValues.viewValues.get(view) : startValues.idValues.get(id);
            TransitionValues end = endCopy.get(view);
            endIdCopy.remove(id);
            startValuesList.add(start);
            endValuesList.add(end);
        }
    }
    int endIdCopySize = endIdCopy.size();
    for (int i = 0; i < endIdCopySize; ++i) {
        int id = endIdCopy.keyAt(i);
        if (isValidTarget(null, id)) {
            TransitionValues start = startValues.idValues.get(id);
            TransitionValues end = endIdCopy.get(id);
            startValuesList.add(start);
            endValuesList.add(end);
        }
    }
    int endItemIdCopySize = endItemIdCopy.size();
    for (int i = 0; i < endItemIdCopySize; ++i) {
        long id = endItemIdCopy.keyAt(i);
        // TODO: Deal with targetIDs and itemIDs
        TransitionValues start = startValues.itemIdValues.get(id);
        TransitionValues end = endItemIdCopy.get(id);
        startValuesList.add(start);
        endValuesList.add(end);
    }
    ArrayMap<Animator, AnimationInfo> runningAnimators = getRunningAnimators();
    for (int i = 0; i < startValuesList.size(); ++i) {
        TransitionValues start = startValuesList.get(i);
        TransitionValues end = endValuesList.get(i);
        // Only bother trying to animate with values that differ between start/end
        if (start != null || end != null) {
            if (start == null || !start.equals(end)) {
                if (DBG) {
                    View view = (end != null) ? end.view : start.view;
                    Log.d(LOG_TAG, "  differing start/end values for view " + view);
                    if (start == null || end == null) {
                        Log.d(LOG_TAG, "    " + ((start == null) ? "start null, end non-null" : "start non-null, end null"));
                    } else {
                        for (String key : start.values.keySet()) {
                            Object startValue = start.values.get(key);
                            Object endValue = end.values.get(key);
                            if (startValue != endValue && !startValue.equals(endValue)) {
                                Log.d(LOG_TAG, "    " + key + ": start(" + startValue + "), end(" + endValue + ")");
                            }
                        }
                    }
                }
                // TODO: what to do about targetIds and itemIds?
                Animator animator = createAnimator(sceneRoot, start, end);
                if (animator != null) {
                    // Save animation info for future cancellation purposes
                    View view = null;
                    TransitionValues infoValues = null;
                    if (end != null) {
                        view = end.view;
                        String[] properties = getTransitionProperties();
                        if (view != null && properties != null && properties.length > 0) {
                            infoValues = new TransitionValues();
                            infoValues.view = view;
                            TransitionValues newValues = endValues.viewValues.get(view);
                            if (newValues != null) {
                                for (int j = 0; j < properties.length; ++j) {
                                    infoValues.values.put(properties[j], newValues.values.get(properties[j]));
                                }
                            }
                            int numExistingAnims = runningAnimators.size();
                            for (int j = 0; j < numExistingAnims; ++j) {
                                Animator anim = runningAnimators.keyAt(j);
                                AnimationInfo info = runningAnimators.get(anim);
                                if (info.values != null && info.view == view && ((info.name == null && getName() == null) || info.name.equals(getName()))) {
                                    if (info.values.equals(infoValues)) {
                                        // Favor the old animator
                                        animator = null;
                                        break;
                                    }
                                }
                            }
                        }
                    } else {
                        view = (start != null) ? start.view : null;
                    }
                    if (animator != null) {
                        AnimationInfo info = new AnimationInfo(view, getName(), infoValues);
                        runningAnimators.put(animator, info);
                        mAnimators.add(animator);
                    }
                }
            }
        }
    }
}
Body of Second Method:
{
    if (DBG) {
        Log.d(LOG_TAG, "createAnimators() for " + this);
    }
    ArrayMap<Animator, AnimationInfo> runningAnimators = getRunningAnimators();
    long minStartDelay = Long.MAX_VALUE;
    int minAnimator = mAnimators.size();
    SparseLongArray startDelays = new SparseLongArray();
    int startValuesListCount = startValuesList.size();
    for (int i = 0; i < startValuesListCount; ++i) {
        TransitionValues start = startValuesList.get(i);
        TransitionValues end = endValuesList.get(i);
        if (start != null && !start.targetedTransitions.contains(this)) {
            start = null;
        }
        if (end != null && !end.targetedTransitions.contains(this)) {
            end = null;
        }
        if (start == null && end == null) {
            continue;
        }
        // Only bother trying to animate with values that differ between start/end
        boolean isChanged = start == null || end == null || areValuesChanged(start, end);
        if (isChanged) {
            if (DBG) {
                View view = (end != null) ? end.view : start.view;
                Log.d(LOG_TAG, "  differing start/end values for view " + view);
                if (start == null || end == null) {
                    Log.d(LOG_TAG, "    " + ((start == null) ? "start null, end non-null" : "start non-null, end null"));
                } else {
                    for (String key : start.values.keySet()) {
                        Object startValue = start.values.get(key);
                        Object endValue = end.values.get(key);
                        if (startValue != endValue && !startValue.equals(endValue)) {
                            Log.d(LOG_TAG, "    " + key + ": start(" + startValue + "), end(" + endValue + ")");
                        }
                    }
                }
            }
            // TODO: what to do about targetIds and itemIds?
            Animator animator = createAnimator(sceneRoot, start, end);
            if (animator != null) {
                // Save animation info for future cancellation purposes
                View view = null;
                TransitionValues infoValues = null;
                if (end != null) {
                    view = end.view;
                    String[] properties = getTransitionProperties();
                    if (view != null && properties != null && properties.length > 0) {
                        infoValues = new TransitionValues();
                        infoValues.view = view;
                        TransitionValues newValues = endValues.viewValues.get(view);
                        if (newValues != null) {
                            for (int j = 0; j < properties.length; ++j) {
                                infoValues.values.put(properties[j], newValues.values.get(properties[j]));
                            }
                        }
                        int numExistingAnims = runningAnimators.size();
                        for (int j = 0; j < numExistingAnims; ++j) {
                            Animator anim = runningAnimators.keyAt(j);
                            AnimationInfo info = runningAnimators.get(anim);
                            if (info.values != null && info.view == view && ((info.name == null && getName() == null) || info.name.equals(getName()))) {
                                if (info.values.equals(infoValues)) {
                                    // Favor the old animator
                                    animator = null;
                                    break;
                                }
                            }
                        }
                    }
                } else {
                    view = (start != null) ? start.view : null;
                }
                if (animator != null) {
                    if (mPropagation != null) {
                        long delay = mPropagation.getStartDelay(sceneRoot, this, start, end);
                        startDelays.put(mAnimators.size(), delay);
                        minStartDelay = Math.min(delay, minStartDelay);
                    }
                    AnimationInfo info = new AnimationInfo(view, getName(), this, sceneRoot.getWindowId(), infoValues);
                    runningAnimators.put(animator, info);
                    mAnimators.add(animator);
                }
            }
        }
    }
    if (minStartDelay != 0) {
        for (int i = 0; i < startDelays.size(); i++) {
            int index = startDelays.keyAt(i);
            Animator animator = mAnimators.get(index);
            long delay = startDelays.valueAt(i) - minStartDelay + animator.getStartDelay();
            animator.setStartDelay(delay);
        }
    }
}
------------------------
Find a silently evolved API code:android.widget.DatePicker.setMinDate:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the minimal date supported by this {@link NumberPicker} in
 * milliseconds since January 1, 1970 00:00:00 in
 * {@link TimeZone#getDefault()} time zone.
 *
 * @param minDate The minimal supported date.
 */

Body of Frist Method:
{
    mTempDate.setTimeInMillis(minDate);
    if (mTempDate.get(Calendar.YEAR) == mMinDate.get(Calendar.YEAR) && mTempDate.get(Calendar.DAY_OF_YEAR) != mMinDate.get(Calendar.DAY_OF_YEAR)) {
        return;
    }
    mMinDate.setTimeInMillis(minDate);
    mCalendarView.setMinDate(minDate);
    if (mCurrentDate.before(mMinDate)) {
        mCurrentDate.setTimeInMillis(mMinDate.getTimeInMillis());
        updateCalendarView();
    }
    updateSpinners();
}
Body of Second Method:
{
    mDelegate.setMinDate(minDate);
}
------------------------
Find a silently evolved API code:android.preference.PreferenceActivity.loadHeadersFromResource:COMMENT
Method Modifier: public      
Comment:/**
 * Parse the given XML file as a header description, adding each
 * parsed Header into the target list.
 *
 * @param resid The XML resource to load and parse.
 * @param target The list in which the parsed headers should be placed.
 */

Body of Frist Method:
{
    XmlResourceParser parser = null;
    try {
        parser = getResources().getXml(resid);
        AttributeSet attrs = Xml.asAttributeSet(parser);
        int type;
        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT && type != XmlPullParser.START_TAG) {
        // Parse next until start tag is found
        }
        String nodeName = parser.getName();
        if (!"preference-headers".equals(nodeName)) {
            throw new RuntimeException("XML document must start with <preference-headers> tag; found" + nodeName + " at " + parser.getPositionDescription());
        }
        Bundle curBundle = null;
        final int outerDepth = parser.getDepth();
        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
            if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
                continue;
            }
            nodeName = parser.getName();
            if ("header".equals(nodeName)) {
                Header header = new Header();
                TypedArray sa = getResources().obtainAttributes(attrs, com.android.internal.R.styleable.PreferenceHeader);
                header.id = sa.getResourceId(com.android.internal.R.styleable.PreferenceHeader_id, (int) HEADER_ID_UNDEFINED);
                TypedValue tv = sa.peekValue(com.android.internal.R.styleable.PreferenceHeader_title);
                if (tv != null && tv.type == TypedValue.TYPE_STRING) {
                    if (tv.resourceId != 0) {
                        header.titleRes = tv.resourceId;
                    } else {
                        header.title = tv.string;
                    }
                }
                tv = sa.peekValue(com.android.internal.R.styleable.PreferenceHeader_summary);
                if (tv != null && tv.type == TypedValue.TYPE_STRING) {
                    if (tv.resourceId != 0) {
                        header.summaryRes = tv.resourceId;
                    } else {
                        header.summary = tv.string;
                    }
                }
                tv = sa.peekValue(com.android.internal.R.styleable.PreferenceHeader_breadCrumbTitle);
                if (tv != null && tv.type == TypedValue.TYPE_STRING) {
                    if (tv.resourceId != 0) {
                        header.breadCrumbTitleRes = tv.resourceId;
                    } else {
                        header.breadCrumbTitle = tv.string;
                    }
                }
                tv = sa.peekValue(com.android.internal.R.styleable.PreferenceHeader_breadCrumbShortTitle);
                if (tv != null && tv.type == TypedValue.TYPE_STRING) {
                    if (tv.resourceId != 0) {
                        header.breadCrumbShortTitleRes = tv.resourceId;
                    } else {
                        header.breadCrumbShortTitle = tv.string;
                    }
                }
                header.iconRes = sa.getResourceId(com.android.internal.R.styleable.PreferenceHeader_icon, 0);
                header.fragment = sa.getString(com.android.internal.R.styleable.PreferenceHeader_fragment);
                sa.recycle();
                if (curBundle == null) {
                    curBundle = new Bundle();
                }
                final int innerDepth = parser.getDepth();
                while ((type = parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > innerDepth)) {
                    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
                        continue;
                    }
                    String innerNodeName = parser.getName();
                    if (innerNodeName.equals("extra")) {
                        getResources().parseBundleExtra("extra", attrs, curBundle);
                        XmlUtils.skipCurrentTag(parser);
                    } else if (innerNodeName.equals("intent")) {
                        header.intent = Intent.parseIntent(getResources(), parser, attrs);
                    } else {
                        XmlUtils.skipCurrentTag(parser);
                    }
                }
                if (curBundle.size() > 0) {
                    header.fragmentArguments = curBundle;
                    curBundle = null;
                }
                target.add(header);
            } else {
                XmlUtils.skipCurrentTag(parser);
            }
        }
    } catch (XmlPullParserException e) {
        throw new RuntimeException("Error parsing headers", e);
    } catch (IOException e) {
        throw new RuntimeException("Error parsing headers", e);
    } finally {
        if (parser != null)
            parser.close();
    }
}
Body of Second Method:
{
    XmlResourceParser parser = null;
    try {
        parser = getResources().getXml(resid);
        AttributeSet attrs = Xml.asAttributeSet(parser);
        int type;
        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT && type != XmlPullParser.START_TAG) {
        // Parse next until start tag is found
        }
        String nodeName = parser.getName();
        if (!"preference-headers".equals(nodeName)) {
            throw new RuntimeException("XML document must start with <preference-headers> tag; found" + nodeName + " at " + parser.getPositionDescription());
        }
        Bundle curBundle = null;
        final int outerDepth = parser.getDepth();
        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
            if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
                continue;
            }
            nodeName = parser.getName();
            if ("header".equals(nodeName)) {
                Header header = new Header();
                TypedArray sa = obtainStyledAttributes(attrs, com.android.internal.R.styleable.PreferenceHeader);
                header.id = sa.getResourceId(com.android.internal.R.styleable.PreferenceHeader_id, (int) HEADER_ID_UNDEFINED);
                TypedValue tv = sa.peekValue(com.android.internal.R.styleable.PreferenceHeader_title);
                if (tv != null && tv.type == TypedValue.TYPE_STRING) {
                    if (tv.resourceId != 0) {
                        header.titleRes = tv.resourceId;
                    } else {
                        header.title = tv.string;
                    }
                }
                tv = sa.peekValue(com.android.internal.R.styleable.PreferenceHeader_summary);
                if (tv != null && tv.type == TypedValue.TYPE_STRING) {
                    if (tv.resourceId != 0) {
                        header.summaryRes = tv.resourceId;
                    } else {
                        header.summary = tv.string;
                    }
                }
                tv = sa.peekValue(com.android.internal.R.styleable.PreferenceHeader_breadCrumbTitle);
                if (tv != null && tv.type == TypedValue.TYPE_STRING) {
                    if (tv.resourceId != 0) {
                        header.breadCrumbTitleRes = tv.resourceId;
                    } else {
                        header.breadCrumbTitle = tv.string;
                    }
                }
                tv = sa.peekValue(com.android.internal.R.styleable.PreferenceHeader_breadCrumbShortTitle);
                if (tv != null && tv.type == TypedValue.TYPE_STRING) {
                    if (tv.resourceId != 0) {
                        header.breadCrumbShortTitleRes = tv.resourceId;
                    } else {
                        header.breadCrumbShortTitle = tv.string;
                    }
                }
                header.iconRes = sa.getResourceId(com.android.internal.R.styleable.PreferenceHeader_icon, 0);
                header.fragment = sa.getString(com.android.internal.R.styleable.PreferenceHeader_fragment);
                sa.recycle();
                if (curBundle == null) {
                    curBundle = new Bundle();
                }
                final int innerDepth = parser.getDepth();
                while ((type = parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() > innerDepth)) {
                    if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
                        continue;
                    }
                    String innerNodeName = parser.getName();
                    if (innerNodeName.equals("extra")) {
                        getResources().parseBundleExtra("extra", attrs, curBundle);
                        XmlUtils.skipCurrentTag(parser);
                    } else if (innerNodeName.equals("intent")) {
                        header.intent = Intent.parseIntent(getResources(), parser, attrs);
                    } else {
                        XmlUtils.skipCurrentTag(parser);
                    }
                }
                if (curBundle.size() > 0) {
                    header.fragmentArguments = curBundle;
                    curBundle = null;
                }
                target.add(header);
            } else {
                XmlUtils.skipCurrentTag(parser);
            }
        }
    } catch (XmlPullParserException e) {
        throw new RuntimeException("Error parsing headers", e);
    } catch (IOException e) {
        throw new RuntimeException("Error parsing headers", e);
    } finally {
        if (parser != null)
            parser.close();
    }
}
------------------------
Find a silently evolved API code:android.provider.DocumentsProvider.getType:COMMENT
Method Modifier: public      final       
Comment:/**
 * Implementation is provided by the parent class. Cannot be overriden.
 *
 * @see #getDocumentType(String)
 */

Body of Frist Method:
{
    try {
        switch(mMatcher.match(uri)) {
            case MATCH_ROOT:
                return DocumentsContract.Root.MIME_TYPE_ITEM;
            case MATCH_DOCUMENT:
                return getDocumentType(getDocumentId(uri));
            default:
                return null;
        }
    } catch (FileNotFoundException e) {
        Log.w(TAG, "Failed during getType", e);
        return null;
    }
}
Body of Second Method:
{
    try {
        switch(mMatcher.match(uri)) {
            case MATCH_ROOT:
                return DocumentsContract.Root.MIME_TYPE_ITEM;
            case MATCH_DOCUMENT:
            case MATCH_DOCUMENT_TREE:
                enforceTree(uri);
                return getDocumentType(getDocumentId(uri));
            default:
                return null;
        }
    } catch (FileNotFoundException e) {
        Log.w(TAG, "Failed during getType", e);
        return null;
    }
}
------------------------
Find a silently evolved API code:android.view.animation.Transformation.compose:COMMENT
Method Modifier: public      
Comment:/**
 * Apply this Transformation to an existing Transformation, e.g. apply
 * a scale effect to something that has already been rotated.
 * @param t
 */

Body of Frist Method:
{
    mAlpha *= t.getAlpha();
    mMatrix.preConcat(t.getMatrix());
}
Body of Second Method:
{
    mAlpha *= t.getAlpha();
    mMatrix.preConcat(t.getMatrix());
    if (t.mHasClipRect) {
        setClipRect(t.getClipRect());
    }
}
------------------------
Find a silently evolved API code:android.net.LocalSocketImpl.SocketInputStream.available:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    return available_native(fd);
}
Body of Second Method:
{
    FileDescriptor myFd = fd;
    if (myFd == null)
        throw new IOException("socket closed");
    return available_native(myFd);
}
------------------------
Find a silently evolved API code:android.text.Layout.getParagraphLeadingMargin:COMMENT
Method Modifier: private     
Comment:/**
 * Returns the effective leading margin (unsigned) for this line,
 * taking into account LeadingMarginSpan and LeadingMarginSpan2.
 * @param line the line index
 * @return the leading margin of this line
 */

Body of Frist Method:
{
    if (!mSpannedText) {
        return 0;
    }
    Spanned spanned = (Spanned) mText;
    int lineStart = getLineStart(line);
    int lineEnd = getLineEnd(line);
    int spanEnd = spanned.nextSpanTransition(lineStart, lineEnd, LeadingMarginSpan.class);
    LeadingMarginSpan[] spans = getParagraphSpans(spanned, lineStart, spanEnd, LeadingMarginSpan.class);
    if (spans.length == 0) {
        // no leading margin span;
        return 0;
    }
    int margin = 0;
    boolean isFirstParaLine = lineStart == 0 || spanned.charAt(lineStart - 1) == '\n';
    for (int i = 0; i < spans.length; i++) {
        LeadingMarginSpan span = spans[i];
        boolean useFirstLineMargin = isFirstParaLine;
        if (span instanceof LeadingMarginSpan2) {
            int spStart = spanned.getSpanStart(span);
            int spanLine = getLineForOffset(spStart);
            int count = ((LeadingMarginSpan2) span).getLeadingMarginLineCount();
            useFirstLineMargin = line < spanLine + count;
        }
        margin += span.getLeadingMargin(useFirstLineMargin);
    }
    return margin;
}
Body of Second Method:
{
    if (!mSpannedText) {
        return 0;
    }
    Spanned spanned = (Spanned) mText;
    int lineStart = getLineStart(line);
    int lineEnd = getLineEnd(line);
    int spanEnd = spanned.nextSpanTransition(lineStart, lineEnd, LeadingMarginSpan.class);
    LeadingMarginSpan[] spans = getParagraphSpans(spanned, lineStart, spanEnd, LeadingMarginSpan.class);
    if (spans.length == 0) {
        // no leading margin span;
        return 0;
    }
    int margin = 0;
    boolean isFirstParaLine = lineStart == 0 || spanned.charAt(lineStart - 1) == '\n';
    boolean useFirstLineMargin = isFirstParaLine;
    for (int i = 0; i < spans.length; i++) {
        if (spans[i] instanceof LeadingMarginSpan2) {
            int spStart = spanned.getSpanStart(spans[i]);
            int spanLine = getLineForOffset(spStart);
            int count = ((LeadingMarginSpan2) spans[i]).getLeadingMarginLineCount();
            // if there is more than one LeadingMarginSpan2, use the count that is greatest
            useFirstLineMargin |= line < spanLine + count;
        }
    }
    for (int i = 0; i < spans.length; i++) {
        LeadingMarginSpan span = spans[i];
        margin += span.getLeadingMargin(useFirstLineMargin);
    }
    return margin;
}
------------------------
Find a silently evolved API code:android.content.res.AssetManager.createTheme:COMMENT
Method Modifier: default     final       
Comment:/*package*/

Body of Frist Method:
{
    synchronized (this) {
        if (!mOpen) {
            throw new RuntimeException("Assetmanager has been closed");
        }
        int res = newTheme();
        incRefsLocked(res);
        return res;
    }
}
Body of Second Method:
{
    synchronized (this) {
        if (!mOpen) {
            throw new RuntimeException("Assetmanager has been closed");
        }
        long res = newTheme();
        incRefsLocked(res);
        return res;
    }
}
------------------------
Find a silently evolved API code:android.app.Activity.dispatchKeyEvent:COMMENT
Method Modifier: public      
Comment:/**
 * Called to process key events.  You can override this to intercept all
 * key events before they are dispatched to the window.  Be sure to call
 * this implementation for key events that should be handled normally.
 *
 * @param event The key event.
 *
 * @return boolean Return true if this event was consumed.
 */

Body of Frist Method:
{
    onUserInteraction();
    Window win = getWindow();
    if (win.superDispatchKeyEvent(event)) {
        return true;
    }
    View decor = mDecor;
    if (decor == null)
        decor = win.getDecorView();
    return event.dispatch(this, decor != null ? decor.getKeyDispatcherState() : null, this);
}
Body of Second Method:
{
    onUserInteraction();
    // the window handling it
    if (event.getKeyCode() == KeyEvent.KEYCODE_MENU && mActionBar != null && mActionBar.onMenuKeyEvent(event)) {
        return true;
    }
    Window win = getWindow();
    if (win.superDispatchKeyEvent(event)) {
        return true;
    }
    View decor = mDecor;
    if (decor == null)
        decor = win.getDecorView();
    return event.dispatch(this, decor != null ? decor.getKeyDispatcherState() : null, this);
}
------------------------
Find a silently evolved API code:android.graphics.Canvas.quickReject:COMMENT
Method Modifier: public      
Comment:/**
 * Return true if the specified path, after being transformed by the
 * current matrix, would lie completely outside of the current clip. Call
 * this to check if an area you intend to draw into is clipped out (and
 * therefore you can skip making the draw calls). Note: for speed it may
 * return false even if the path itself might not intersect the clip
 * (i.e. the bounds of the path intersects, but the path does not).
 *
 * @param path        The path to compare with the current clip
 * @param type        {@link Canvas.EdgeType#AA} if the path should be considered antialiased,
 * since that means it may affect a larger area (more pixels) than
 * non-antialiased ({@link Canvas.EdgeType#BW}).
 * @return            true if the path (transformed by the canvas' matrix)
 * does not intersect with the canvas' clip
 */

Body of Frist Method:
{
    return native_quickReject(mNativeCanvas, path.ni());
}
Body of Second Method:
{
    return native_quickReject(mNativeCanvasWrapper, path.ni());
}
------------------------
Find a silently evolved API code:android.graphics.Typeface.createFromAsset:COMMENT
Method Modifier: public      static      
Comment:/**
 * Create a new typeface from the specified font data.
 * @param mgr The application's asset manager
 * @param path  The file name of the font data in the assets directory
 * @return The new typeface.
 */

Body of Frist Method:
{
    return new Typeface(nativeCreateFromAsset(mgr, path));
}
Body of Second Method:
{
    if (sFallbackFonts != null) {
        FontFamily fontFamily = new FontFamily();
        if (fontFamily.addFontFromAsset(mgr, path)) {
            FontFamily[] families = { fontFamily };
            return createFromFamiliesWithDefault(families);
        }
    }
    throw new RuntimeException("Font asset not found " + path);
}
------------------------
Find a silently evolved API code:android.widget.CalendarView.getWeekNumberColor:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the color for the week numbers.
 *
 * @return The week number color.
 *
 * @attr ref android.R.styleable#CalendarView_weekNumberColor
 */

Body of Frist Method:
{
    return mWeekNumberColor;
}
Body of Second Method:
{
    return mDelegate.getWeekNumberColor();
}
------------------------
Find a silently evolved API code:android.graphics.drawable.ColorDrawable.setAlpha:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the color's alpha value.
 *
 * @param alpha The alpha value to set, between 0 and 255.
 */

Body of Frist Method:
{
    // make it 0..256
    alpha += alpha >> 7;
    int baseAlpha = mState.mBaseColor >>> 24;
    int useAlpha = baseAlpha * alpha >> 8;
    int oldUseColor = mState.mUseColor;
    mState.mUseColor = (mState.mBaseColor << 8 >>> 8) | (useAlpha << 24);
    if (oldUseColor != mState.mUseColor) {
        invalidateSelf();
    }
}
Body of Second Method:
{
    // make it 0..256
    alpha += alpha >> 7;
    final int baseAlpha = mColorState.mBaseColor >>> 24;
    final int useAlpha = baseAlpha * alpha >> 8;
    final int useColor = (mColorState.mBaseColor << 8 >>> 8) | (useAlpha << 24);
    if (mColorState.mUseColor != useColor) {
        mColorState.mUseColor = useColor;
        invalidateSelf();
    }
}
------------------------
Find a silently evolved API code:android.provider.DocumentsContract.getRootId:COMMENT
Method Modifier: public      static      
Comment:/**
 * Extract the {@link Root#COLUMN_ROOT_ID} from the given URI.
 */

Body of Frist Method:
{
    final List<String> paths = rootUri.getPathSegments();
    if (paths.size() < 2) {
        throw new IllegalArgumentException("Not a root: " + rootUri);
    }
    if (!PATH_ROOT.equals(paths.get(0))) {
        throw new IllegalArgumentException("Not a root: " + rootUri);
    }
    return paths.get(1);
}
Body of Second Method:
{
    final List<String> paths = rootUri.getPathSegments();
    if (paths.size() >= 2 && PATH_ROOT.equals(paths.get(0))) {
        return paths.get(1);
    }
    throw new IllegalArgumentException("Invalid URI: " + rootUri);
}
------------------------
Find a silently evolved API code:android.app.backup.BackupAgent.fullBackupFileTree:COMMENT
Method Modifier: protected   final       hidden      
Comment:/**
 * Scan the dir tree (if it actually exists) and process each entry we find.  If the
 * 'excludes' parameter is non-null, it is consulted each time a new file system entity
 * is visited to see whether that entity (and its subtree, if appropriate) should be
 * omitted from the backup process.
 *
 * @hide
 */

Body of Frist Method:
{
    File rootFile = new File(rootPath);
    if (rootFile.exists()) {
        LinkedList<File> scanQueue = new LinkedList<File>();
        scanQueue.add(rootFile);
        while (scanQueue.size() > 0) {
            File file = scanQueue.remove(0);
            String filePath;
            try {
                filePath = file.getCanonicalPath();
                // prune this subtree?
                if (excludes != null && excludes.contains(filePath)) {
                    continue;
                }
                // If it's a directory, enqueue its contents for scanning.
                StructStat stat = Libcore.os.lstat(filePath);
                if (OsConstants.S_ISLNK(stat.st_mode)) {
                    if (DEBUG)
                        Log.i(TAG, "Symlink (skipping)!: " + file);
                    continue;
                } else if (OsConstants.S_ISDIR(stat.st_mode)) {
                    File[] contents = file.listFiles();
                    if (contents != null) {
                        for (File entry : contents) {
                            scanQueue.add(0, entry);
                        }
                    }
                }
            } catch (IOException e) {
                if (DEBUG)
                    Log.w(TAG, "Error canonicalizing path of " + file);
                continue;
            } catch (ErrnoException e) {
                if (DEBUG)
                    Log.w(TAG, "Error scanning file " + file + " : " + e);
                continue;
            }
            // Finally, back this file up before proceeding
            FullBackup.backupToTar(packageName, domain, null, rootPath, filePath, output.getData());
        }
    }
}
Body of Second Method:
{
    File rootFile = new File(rootPath);
    if (rootFile.exists()) {
        LinkedList<File> scanQueue = new LinkedList<File>();
        scanQueue.add(rootFile);
        while (scanQueue.size() > 0) {
            File file = scanQueue.remove(0);
            String filePath;
            try {
                filePath = file.getCanonicalPath();
                // prune this subtree?
                if (excludes != null && excludes.contains(filePath)) {
                    continue;
                }
                // If it's a directory, enqueue its contents for scanning.
                StructStat stat = Os.lstat(filePath);
                if (OsConstants.S_ISLNK(stat.st_mode)) {
                    if (DEBUG)
                        Log.i(TAG, "Symlink (skipping)!: " + file);
                    continue;
                } else if (OsConstants.S_ISDIR(stat.st_mode)) {
                    File[] contents = file.listFiles();
                    if (contents != null) {
                        for (File entry : contents) {
                            scanQueue.add(0, entry);
                        }
                    }
                }
            } catch (IOException e) {
                if (DEBUG)
                    Log.w(TAG, "Error canonicalizing path of " + file);
                continue;
            } catch (ErrnoException e) {
                if (DEBUG)
                    Log.w(TAG, "Error scanning file " + file + " : " + e);
                continue;
            }
            // Finally, back this file up before proceeding
            FullBackup.backupToTar(packageName, domain, null, rootPath, filePath, output.getData());
        }
    }
}
------------------------
Find a silently evolved API code:android.media.RemoteController.getEstimatedMediaPosition:COMMENT
<android.media.RemoteController: long getEstimatedMediaPosition()>
public      ->public      deprecated  
Method Modifier: public      deprecated  
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Return the estimated playback position of the current media track or a negative value
 * if not available.
 *
 * <p>The value returned is estimated by the current process and may not be perfect.
 * The time returned by this method is calculated from the last state change time based
 * on the current play position at that time and the last known playback speed.
 * An application may call {@link #setSynchronizationMode(int)} to apply
 * a synchronization policy that will periodically re-sync the estimated position
 * with the RemoteControlClient.</p>
 *
 * @return the current estimated playback position in milliseconds or a negative value
 * if not available
 *
 * @see OnClientUpdateListener#onClientPlaybackStateUpdate(int, long, long, float)
 */

Body of Frist Method:
{
    if (mLastPlaybackInfo != null) {
        if (!RemoteControlClient.playbackPositionShouldMove(mLastPlaybackInfo.mState)) {
            return mLastPlaybackInfo.mCurrentPosMs;
        }
        // Take the current position at the time of state change and estimate.
        final long thenPos = mLastPlaybackInfo.mCurrentPosMs;
        if (thenPos < 0) {
            return -1;
        }
        final long now = SystemClock.elapsedRealtime();
        final long then = mLastPlaybackInfo.mStateChangeTimeMs;
        final long sinceThen = now - then;
        final long scaledSinceThen = (long) (sinceThen * mLastPlaybackInfo.mSpeed);
        return thenPos + scaledSinceThen;
    }
    return -1;
}
Body of Second Method:
{
    if (USE_SESSIONS) {
        synchronized (mInfoLock) {
            if (mCurrentSession != null) {
                PlaybackState state = mCurrentSession.getPlaybackState();
                if (state != null) {
                    return state.getPosition();
                }
            }
        }
    } else {
        final PlaybackInfo lastPlaybackInfo;
        synchronized (mInfoLock) {
            lastPlaybackInfo = mLastPlaybackInfo;
        }
        if (lastPlaybackInfo != null) {
            if (!RemoteControlClient.playbackPositionShouldMove(lastPlaybackInfo.mState)) {
                return lastPlaybackInfo.mCurrentPosMs;
            }
            // Take the current position at the time of state change and
            // estimate.
            final long thenPos = lastPlaybackInfo.mCurrentPosMs;
            if (thenPos < 0) {
                return -1;
            }
            final long now = SystemClock.elapsedRealtime();
            final long then = lastPlaybackInfo.mStateChangeTimeMs;
            final long sinceThen = now - then;
            final long scaledSinceThen = (long) (sinceThen * lastPlaybackInfo.mSpeed);
            return thenPos + scaledSinceThen;
        }
    }
    return -1;
}
------------------------
Find a silently evolved API code:android.media.AudioService.setRingerMode:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @see AudioManager#setRingerMode(int)
 */

Body of Frist Method:
{
    if (mUseFixedVolume) {
        return;
    }
    if ((ringerMode == AudioManager.RINGER_MODE_VIBRATE) && !mHasVibrator) {
        ringerMode = AudioManager.RINGER_MODE_SILENT;
    }
    if (ringerMode != getRingerMode()) {
        setRingerModeInt(ringerMode, true);
        // Send sticky broadcast
        broadcastRingerMode(ringerMode);
    }
}
Body of Second Method:
{
    if (mUseFixedVolume || isPlatformTelevision()) {
        return;
    }
    if ((ringerMode == AudioManager.RINGER_MODE_VIBRATE) && !mHasVibrator) {
        ringerMode = AudioManager.RINGER_MODE_SILENT;
    }
    if (checkZen) {
        checkZen(ringerMode);
    }
    if (ringerMode != getRingerMode()) {
        setRingerModeInt(ringerMode, true);
        // Send sticky broadcast
        broadcastRingerMode(ringerMode);
    }
}
------------------------
Find a silently evolved API code:android.widget.OverScroller.computeScrollOffset:COMMENT
Method Modifier: public      
Comment:/**
 * Call this when you want to know the new location. If it returns true, the
 * animation is not yet finished.
 */

Body of Frist Method:
{
    if (isFinished()) {
        return false;
    }
    switch(mMode) {
        case SCROLL_MODE:
            long time = AnimationUtils.currentAnimationTimeMillis();
            // Any scroller can be used for time, since they were started
            // together in scroll mode. We use X here.
            final long elapsedTime = time - mScrollerX.mStartTime;
            final int duration = mScrollerX.mDuration;
            if (elapsedTime < duration) {
                float q = (float) (elapsedTime) / duration;
                if (mInterpolator == null) {
                    q = Scroller.viscousFluid(q);
                } else {
                    q = mInterpolator.getInterpolation(q);
                }
                mScrollerX.updateScroll(q);
                mScrollerY.updateScroll(q);
            } else {
                abortAnimation();
            }
            break;
        case FLING_MODE:
            if (!mScrollerX.mFinished) {
                if (!mScrollerX.update()) {
                    if (!mScrollerX.continueWhenFinished()) {
                        mScrollerX.finish();
                    }
                }
            }
            if (!mScrollerY.mFinished) {
                if (!mScrollerY.update()) {
                    if (!mScrollerY.continueWhenFinished()) {
                        mScrollerY.finish();
                    }
                }
            }
            break;
    }
    return true;
}
Body of Second Method:
{
    if (isFinished()) {
        return false;
    }
    switch(mMode) {
        case SCROLL_MODE:
            long time = AnimationUtils.currentAnimationTimeMillis();
            // Any scroller can be used for time, since they were started
            // together in scroll mode. We use X here.
            final long elapsedTime = time - mScrollerX.mStartTime;
            final int duration = mScrollerX.mDuration;
            if (elapsedTime < duration) {
                final float q = mInterpolator.getInterpolation(elapsedTime / (float) duration);
                mScrollerX.updateScroll(q);
                mScrollerY.updateScroll(q);
            } else {
                abortAnimation();
            }
            break;
        case FLING_MODE:
            if (!mScrollerX.mFinished) {
                if (!mScrollerX.update()) {
                    if (!mScrollerX.continueWhenFinished()) {
                        mScrollerX.finish();
                    }
                }
            }
            if (!mScrollerY.mFinished) {
                if (!mScrollerY.update()) {
                    if (!mScrollerY.continueWhenFinished()) {
                        mScrollerY.finish();
                    }
                }
            }
            break;
    }
    return true;
}
------------------------
Find a silently evolved API code:android.graphics.Canvas.drawOval:COMMENT
Method Modifier: public      
Comment:/**
 * Draw the specified oval using the specified paint. The oval will be
 * filled or framed based on the Style in the paint.
 *
 * @param oval The rectangle bounds of the oval to be drawn
 */

Body of Frist Method:
{
    if (oval == null) {
        throw new NullPointerException();
    }
    native_drawOval(mNativeCanvas, oval, paint.mNativePaint);
}
Body of Second Method:
{
    if (oval == null) {
        throw new NullPointerException();
    }
    drawOval(oval.left, oval.top, oval.right, oval.bottom, paint);
}
------------------------
Find a silently evolved API code:android.view.accessibility.AccessibilityNodeInfo.setSource:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the source.
 * <p>
 * <strong>Note:</strong> Cannot be called from an
 * {@link android.accessibilityservice.AccessibilityService}.
 * This class is made immutable before being delivered to an AccessibilityService.
 * </p>
 *
 * @param source The info source.
 */

Body of Frist Method:
{
    setSource(source, UNDEFINED);
}
Body of Second Method:
{
    setSource(source, UNDEFINED_ITEM_ID);
}
------------------------
Find a silently evolved API code:android.widget.DatePicker.getSpinnersShown:COMMENT
Method Modifier: public      
Comment:/**
 * Gets whether the spinners are shown.
 *
 * @return True if the spinners are shown.
 */

Body of Frist Method:
{
    return mSpinners.isShown();
}
Body of Second Method:
{
    return mDelegate.getSpinnersShown();
}
------------------------
Find a silently evolved API code:android.app.Activity.onMenuOpened:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 *
 * @return The default implementation returns true.
 */

Body of Frist Method:
{
    if (featureId == Window.FEATURE_ACTION_BAR) {
        initActionBar();
        if (mActionBar != null) {
            mActionBar.dispatchMenuVisibilityChanged(true);
        } else {
            Log.e(TAG, "Tried to open action bar menu with no action bar");
        }
    }
    return true;
}
Body of Second Method:
{
    if (featureId == Window.FEATURE_ACTION_BAR) {
        initWindowDecorActionBar();
        if (mActionBar != null) {
            mActionBar.dispatchMenuVisibilityChanged(true);
        } else {
            Log.e(TAG, "Tried to open action bar menu with no action bar");
        }
    }
    return true;
}
------------------------
Find a silently evolved API code:android.widget.CalendarView.getFocusedMonthDateColor:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the color for the dates in the focused month.
 *
 * @return The focused month date color.
 *
 * @attr ref android.R.styleable#CalendarView_focusedMonthDateColor
 */

Body of Frist Method:
{
    return mFocusedMonthDateColor;
}
Body of Second Method:
{
    return mDelegate.getFocusedMonthDateColor();
}
------------------------
Find a silently evolved API code:android.service.notification.StatusBarNotification.cloneLight:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    final Notification no = new Notification();
    // light copy
    this.notification.cloneInto(no, false);
    return new StatusBarNotification(this.pkg, this.basePkg, this.id, this.tag, this.uid, this.initialPid, this.score, no, this.user, this.postTime);
}
Body of Second Method:
{
    final Notification no = new Notification();
    // light copy
    this.notification.cloneInto(no, false);
    return new StatusBarNotification(this.pkg, this.opPkg, this.id, this.tag, this.uid, this.initialPid, this.score, no, this.user, this.postTime);
}
------------------------
Find a silently evolved API code:android.graphics.drawable.BitmapDrawable.getBitmap:COMMENT
Method Modifier: public      final       
Comment:/**
 * Returns the bitmap used by this drawable to render. May be null.
 */

Body of Frist Method:
{
    return mBitmap;
}
Body of Second Method:
{
    return mBitmapState.mBitmap;
}
------------------------
Find a silently evolved API code:android.graphics.Canvas.getWidth:COMMENT
<android.graphics.Canvas: int getWidth()>
public      native      ->public      
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * Returns the width of the current drawing layer
 *
 * @return the width of the current drawing layer
 */

Body of Frist Method:

Body of Second Method:
{
    return native_getWidth(mNativeCanvasWrapper);
}
------------------------
Find a silently evolved API code:android.os.UserManager.getMaxSupportedUsers:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Returns the maximum number of users that can be created on this device. A return value
 * of 1 means that it is a single user device.
 * @hide
 * @return a value greater than or equal to 1
 */

Body of Frist Method:
{
    // Don't allow multiple users on certain builds
    if (android.os.Build.ID.startsWith("JVP"))
        return 1;
    return SystemProperties.getInt("fw.max_users", Resources.getSystem().getInteger(R.integer.config_multiuserMaximumUsers));
}
Body of Second Method:
{
    // Don't allow multiple users on certain builds
    if (android.os.Build.ID.startsWith("JVP"))
        return 1;
    // Svelte devices don't get multi-user.
    if (ActivityManager.isLowRamDeviceStatic())
        return 1;
    return SystemProperties.getInt("fw.max_users", Resources.getSystem().getInteger(R.integer.config_multiuserMaximumUsers));
}
------------------------
Find a silently evolved API code:android.widget.FastScroller.transitionToVisible:COMMENT
Method Modifier: private     
Comment:/**
 * Shows the thumb and track.
 */

Body of Frist Method:
{
    if (mDecorAnimation != null) {
        mDecorAnimation.cancel();
    }
    final Animator fadeIn = groupAnimatorOfFloat(View.ALPHA, 1f, mThumbImage, mTrackImage).setDuration(DURATION_FADE_IN);
    final Animator fadeOut = groupAnimatorOfFloat(View.ALPHA, 0f, mPreviewImage, mPrimaryText, mSecondaryText).setDuration(DURATION_FADE_OUT);
    final Animator slideIn = groupAnimatorOfFloat(View.TRANSLATION_X, 0f, mThumbImage, mTrackImage).setDuration(DURATION_FADE_IN);
    mDecorAnimation = new AnimatorSet();
    mDecorAnimation.playTogether(fadeIn, fadeOut, slideIn);
    mDecorAnimation.start();
}
Body of Second Method:
{
    if (mDecorAnimation != null) {
        mDecorAnimation.cancel();
    }
    final Animator fadeIn = groupAnimatorOfFloat(View.ALPHA, 1f, mThumbImage, mTrackImage).setDuration(DURATION_FADE_IN);
    final Animator fadeOut = groupAnimatorOfFloat(View.ALPHA, 0f, mPreviewImage, mPrimaryText, mSecondaryText).setDuration(DURATION_FADE_OUT);
    final Animator slideIn = groupAnimatorOfFloat(View.TRANSLATION_X, 0f, mThumbImage, mTrackImage).setDuration(DURATION_FADE_IN);
    mDecorAnimation = new AnimatorSet();
    mDecorAnimation.playTogether(fadeIn, fadeOut, slideIn);
    mDecorAnimation.start();
    mShowingPreview = false;
}
------------------------
Find a silently evolved API code:android.widget.CalendarView.getDate:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the selected date in milliseconds since January 1, 1970 00:00:00 in
 * {@link TimeZone#getDefault()} time zone.
 *
 * @return The selected date.
 */

Body of Frist Method:
{
    return mAdapter.mSelectedDate.getTimeInMillis();
}
Body of Second Method:
{
    return mDelegate.getDate();
}
------------------------
Find a silently evolved API code:android.widget.CalendarView.setOnDateChangeListener:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the listener to be notified upon selected date change.
 *
 * @param listener The listener to be notified.
 */

Body of Frist Method:
{
    mOnDateChangeListener = listener;
}
Body of Second Method:
{
    mDelegate.setOnDateChangeListener(listener);
}
------------------------
Find a silently evolved API code:android.text.Layout.measurePara:COMMENT
Method Modifier: default     static      
Comment:/* package */

Body of Frist Method:
{
    MeasuredText mt = MeasuredText.obtain();
    TextLine tl = TextLine.obtain();
    try {
        mt.setPara(text, start, end, TextDirectionHeuristics.LTR);
        Directions directions;
        int dir;
        if (mt.mEasy) {
            directions = DIRS_ALL_LEFT_TO_RIGHT;
            dir = Layout.DIR_LEFT_TO_RIGHT;
        } else {
            directions = AndroidBidi.directions(mt.mDir, mt.mLevels, 0, mt.mChars, 0, mt.mLen);
            dir = mt.mDir;
        }
        char[] chars = mt.mChars;
        int len = mt.mLen;
        boolean hasTabs = false;
        TabStops tabStops = null;
        for (int i = 0; i < len; ++i) {
            if (chars[i] == '\t') {
                hasTabs = true;
                if (text instanceof Spanned) {
                    Spanned spanned = (Spanned) text;
                    int spanEnd = spanned.nextSpanTransition(start, end, TabStopSpan.class);
                    TabStopSpan[] spans = getParagraphSpans(spanned, start, spanEnd, TabStopSpan.class);
                    if (spans.length > 0) {
                        tabStops = new TabStops(TAB_INCREMENT, spans);
                    }
                }
                break;
            }
        }
        tl.set(paint, text, start, end, dir, directions, hasTabs, tabStops);
        return tl.metrics(null);
    } finally {
        TextLine.recycle(tl);
        MeasuredText.recycle(mt);
    }
}
Body of Second Method:
{
    MeasuredText mt = MeasuredText.obtain();
    TextLine tl = TextLine.obtain();
    try {
        mt.setPara(text, start, end, TextDirectionHeuristics.LTR);
        Directions directions;
        int dir;
        if (mt.mEasy) {
            directions = DIRS_ALL_LEFT_TO_RIGHT;
            dir = Layout.DIR_LEFT_TO_RIGHT;
        } else {
            directions = AndroidBidi.directions(mt.mDir, mt.mLevels, 0, mt.mChars, 0, mt.mLen);
            dir = mt.mDir;
        }
        char[] chars = mt.mChars;
        int len = mt.mLen;
        boolean hasTabs = false;
        TabStops tabStops = null;
        // leading margins should be taken into account when measuring a paragraph
        int margin = 0;
        if (text instanceof Spanned) {
            Spanned spanned = (Spanned) text;
            LeadingMarginSpan[] spans = getParagraphSpans(spanned, start, end, LeadingMarginSpan.class);
            for (LeadingMarginSpan lms : spans) {
                margin += lms.getLeadingMargin(true);
            }
        }
        for (int i = 0; i < len; ++i) {
            if (chars[i] == '\t') {
                hasTabs = true;
                if (text instanceof Spanned) {
                    Spanned spanned = (Spanned) text;
                    int spanEnd = spanned.nextSpanTransition(start, end, TabStopSpan.class);
                    TabStopSpan[] spans = getParagraphSpans(spanned, start, spanEnd, TabStopSpan.class);
                    if (spans.length > 0) {
                        tabStops = new TabStops(TAB_INCREMENT, spans);
                    }
                }
                break;
            }
        }
        tl.set(paint, text, start, end, dir, directions, hasTabs, tabStops);
        return margin + tl.metrics(null);
    } finally {
        TextLine.recycle(tl);
        MeasuredText.recycle(mt);
    }
}
------------------------
Find a silently evolved API code:android.content.ContentResolver.setSyncAutomatically:COMMENT
Method Modifier: public      static      
Comment:/**
 * Set whether or not the provider is synced when it receives a network tickle.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#WRITE_SYNC_SETTINGS}.
 *
 * @param account the account whose setting we are querying
 * @param authority the provider whose behavior is being controlled
 * @param sync true if the provider should be synced when tickles are received for it
 */

Body of Frist Method:
{
    try {
        getContentService().setSyncAutomatically(account, authority, sync);
    } catch (RemoteException e) {
    // exception ignored; if this is thrown then it means the runtime is in the midst of
    // being restarted
    }
}
Body of Second Method:
{
    setSyncAutomaticallyAsUser(account, authority, sync, UserHandle.myUserId());
}
------------------------
Find a silently evolved API code:android.widget.AbsListView.RecycleBin.scrapActiveViews:COMMENT
Method Modifier: default     
Comment:/**
 * Move all views remaining in mActiveViews to mScrapViews.
 */

Body of Frist Method:
{
    final View[] activeViews = mActiveViews;
    final boolean hasListener = mRecyclerListener != null;
    final boolean multipleScraps = mViewTypeCount > 1;
    ArrayList<View> scrapViews = mCurrentScrap;
    final int count = activeViews.length;
    for (int i = count - 1; i >= 0; i--) {
        final View victim = activeViews[i];
        if (victim != null) {
            final AbsListView.LayoutParams lp = (AbsListView.LayoutParams) victim.getLayoutParams();
            int whichScrap = lp.viewType;
            activeViews[i] = null;
            final boolean scrapHasTransientState = victim.hasTransientState();
            if (!shouldRecycleViewType(whichScrap) || scrapHasTransientState) {
                // Do not move views that should be ignored
                if (whichScrap != ITEM_VIEW_TYPE_HEADER_OR_FOOTER && scrapHasTransientState) {
                    removeDetachedView(victim, false);
                }
                if (scrapHasTransientState) {
                    if (mAdapter != null && mAdapterHasStableIds) {
                        if (mTransientStateViewsById == null) {
                            mTransientStateViewsById = new LongSparseArray<View>();
                        }
                        long id = mAdapter.getItemId(mFirstActivePosition + i);
                        mTransientStateViewsById.put(id, victim);
                    } else {
                        if (mTransientStateViews == null) {
                            mTransientStateViews = new SparseArray<View>();
                        }
                        mTransientStateViews.put(mFirstActivePosition + i, victim);
                    }
                }
                continue;
            }
            if (multipleScraps) {
                scrapViews = mScrapViews[whichScrap];
            }
            victim.dispatchStartTemporaryDetach();
            lp.scrappedFromPosition = mFirstActivePosition + i;
            scrapViews.add(victim);
            victim.setAccessibilityDelegate(null);
            if (hasListener) {
                mRecyclerListener.onMovedToScrapHeap(victim);
            }
        }
    }
    pruneScrapViews();
}
Body of Second Method:
{
    final View[] activeViews = mActiveViews;
    final boolean hasListener = mRecyclerListener != null;
    final boolean multipleScraps = mViewTypeCount > 1;
    ArrayList<View> scrapViews = mCurrentScrap;
    final int count = activeViews.length;
    for (int i = count - 1; i >= 0; i--) {
        final View victim = activeViews[i];
        if (victim != null) {
            final AbsListView.LayoutParams lp = (AbsListView.LayoutParams) victim.getLayoutParams();
            final int whichScrap = lp.viewType;
            activeViews[i] = null;
            if (victim.hasTransientState()) {
                // Store views with transient state for later use.
                victim.dispatchStartTemporaryDetach();
                if (mAdapter != null && mAdapterHasStableIds) {
                    if (mTransientStateViewsById == null) {
                        mTransientStateViewsById = new LongSparseArray<View>();
                    }
                    long id = mAdapter.getItemId(mFirstActivePosition + i);
                    mTransientStateViewsById.put(id, victim);
                } else if (!mDataChanged) {
                    if (mTransientStateViews == null) {
                        mTransientStateViews = new SparseArray<View>();
                    }
                    mTransientStateViews.put(mFirstActivePosition + i, victim);
                } else if (whichScrap != ITEM_VIEW_TYPE_HEADER_OR_FOOTER) {
                    // The data has changed, we can't keep this view.
                    removeDetachedView(victim, false);
                }
            } else if (!shouldRecycleViewType(whichScrap)) {
                // Discard non-recyclable views except headers/footers.
                if (whichScrap != ITEM_VIEW_TYPE_HEADER_OR_FOOTER) {
                    removeDetachedView(victim, false);
                }
            } else {
                // Store everything else on the appropriate scrap heap.
                if (multipleScraps) {
                    scrapViews = mScrapViews[whichScrap];
                }
                victim.dispatchStartTemporaryDetach();
                lp.scrappedFromPosition = mFirstActivePosition + i;
                scrapViews.add(victim);
                if (hasListener) {
                    mRecyclerListener.onMovedToScrapHeap(victim);
                }
            }
        }
    }
    pruneScrapViews();
}
------------------------
Find a silently evolved API code:android.view.MenuInflater.parseMenu:COMMENT
Method Modifier: private     
Comment:/**
 * Called internally to fill the given menu. If a sub menu is seen, it will
 * call this recursively.
 */

Body of Frist Method:
{
    MenuState menuState = new MenuState(menu);
    int eventType = parser.getEventType();
    String tagName;
    boolean lookingForEndOfUnknownTag = false;
    String unknownTagName = null;
    // This loop will skip to the menu start tag
    do {
        if (eventType == XmlPullParser.START_TAG) {
            tagName = parser.getName();
            if (tagName.equals(XML_MENU)) {
                // Go to next tag
                eventType = parser.next();
                break;
            }
            throw new RuntimeException("Expecting menu, got " + tagName);
        }
        eventType = parser.next();
    } while (eventType != XmlPullParser.END_DOCUMENT);
    boolean reachedEndOfMenu = false;
    while (!reachedEndOfMenu) {
        switch(eventType) {
            case XmlPullParser.START_TAG:
                if (lookingForEndOfUnknownTag) {
                    break;
                }
                tagName = parser.getName();
                if (tagName.equals(XML_GROUP)) {
                    menuState.readGroup(attrs);
                } else if (tagName.equals(XML_ITEM)) {
                    menuState.readItem(attrs);
                } else if (tagName.equals(XML_MENU)) {
                    // A menu start tag denotes a submenu for an item
                    SubMenu subMenu = menuState.addSubMenuItem();
                    // Parse the submenu into returned SubMenu
                    parseMenu(parser, attrs, subMenu);
                } else {
                    lookingForEndOfUnknownTag = true;
                    unknownTagName = tagName;
                }
                break;
            case XmlPullParser.END_TAG:
                tagName = parser.getName();
                if (lookingForEndOfUnknownTag && tagName.equals(unknownTagName)) {
                    lookingForEndOfUnknownTag = false;
                    unknownTagName = null;
                } else if (tagName.equals(XML_GROUP)) {
                    menuState.resetGroup();
                } else if (tagName.equals(XML_ITEM)) {
                    // a submenu, it would have been added already)
                    if (!menuState.hasAddedItem()) {
                        if (menuState.itemActionProvider != null && menuState.itemActionProvider.hasSubMenu()) {
                            menuState.addSubMenuItem();
                        } else {
                            menuState.addItem();
                        }
                    }
                } else if (tagName.equals(XML_MENU)) {
                    reachedEndOfMenu = true;
                }
                break;
            case XmlPullParser.END_DOCUMENT:
                throw new RuntimeException("Unexpected end of document");
        }
        eventType = parser.next();
    }
}
Body of Second Method:
{
    MenuState menuState = new MenuState(menu);
    int eventType = parser.getEventType();
    String tagName;
    boolean lookingForEndOfUnknownTag = false;
    String unknownTagName = null;
    // This loop will skip to the menu start tag
    do {
        if (eventType == XmlPullParser.START_TAG) {
            tagName = parser.getName();
            if (tagName.equals(XML_MENU)) {
                // Go to next tag
                eventType = parser.next();
                break;
            }
            throw new RuntimeException("Expecting menu, got " + tagName);
        }
        eventType = parser.next();
    } while (eventType != XmlPullParser.END_DOCUMENT);
    boolean reachedEndOfMenu = false;
    while (!reachedEndOfMenu) {
        switch(eventType) {
            case XmlPullParser.START_TAG:
                if (lookingForEndOfUnknownTag) {
                    break;
                }
                tagName = parser.getName();
                if (tagName.equals(XML_GROUP)) {
                    menuState.readGroup(attrs);
                } else if (tagName.equals(XML_ITEM)) {
                    menuState.readItem(attrs);
                } else if (tagName.equals(XML_MENU)) {
                    // A menu start tag denotes a submenu for an item
                    SubMenu subMenu = menuState.addSubMenuItem();
                    registerMenu(subMenu, attrs);
                    // Parse the submenu into returned SubMenu
                    parseMenu(parser, attrs, subMenu);
                } else {
                    lookingForEndOfUnknownTag = true;
                    unknownTagName = tagName;
                }
                break;
            case XmlPullParser.END_TAG:
                tagName = parser.getName();
                if (lookingForEndOfUnknownTag && tagName.equals(unknownTagName)) {
                    lookingForEndOfUnknownTag = false;
                    unknownTagName = null;
                } else if (tagName.equals(XML_GROUP)) {
                    menuState.resetGroup();
                } else if (tagName.equals(XML_ITEM)) {
                    // a submenu, it would have been added already)
                    if (!menuState.hasAddedItem()) {
                        if (menuState.itemActionProvider != null && menuState.itemActionProvider.hasSubMenu()) {
                            registerMenu(menuState.addSubMenuItem(), attrs);
                        } else {
                            registerMenu(menuState.addItem(), attrs);
                        }
                    }
                } else if (tagName.equals(XML_MENU)) {
                    reachedEndOfMenu = true;
                }
                break;
            case XmlPullParser.END_DOCUMENT:
                throw new RuntimeException("Unexpected end of document");
        }
        eventType = parser.next();
    }
}
------------------------
Find a silently evolved API code:android.app.backup.FullBackup.restoreFile:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Copy data from a socket to the given File location on permanent storage.  The
 * modification time and access mode of the resulting file will be set if desired,
 * although group/all rwx modes will be stripped: the restored file will not be
 * accessible from outside the target application even if the original file was.
 * If the {@code type} parameter indicates that the result should be a directory,
 * the socket parameter may be {@code null}; even if it is valid, no data will be
 * read from it in this case.
 * <p>
 * If the {@code mode} argument is negative, then the resulting output file will not
 * have its access mode or last modification time reset as part of this operation.
 *
 * @param data Socket supplying the data to be copied to the output file.  If the
 * output is a directory, this may be {@code null}.
 * @param size Number of bytes of data to copy from the socket to the file.  At least
 * this much data must be available through the {@code data} parameter.
 * @param type Must be either {@link BackupAgent#TYPE_FILE} for ordinary file data
 * or {@link BackupAgent#TYPE_DIRECTORY} for a directory.
 * @param mode Unix-style file mode (as used by the chmod(2) syscall) to be set on
 * the output file or directory.  group/all rwx modes are stripped even if set
 * in this parameter.  If this parameter is negative then neither
 * the mode nor the mtime values will be applied to the restored file.
 * @param mtime A timestamp in the standard Unix epoch that will be imposed as the
 * last modification time of the output file.  if the {@code mode} parameter is
 * negative then this parameter will be ignored.
 * @param outFile Location within the filesystem to place the data.  This must point
 * to a location that is writeable by the caller, preferably using an absolute path.
 * @throws IOException
 */

Body of Frist Method:
{
    if (type == BackupAgent.TYPE_DIRECTORY) {
        // drop down to the final metadata adjustment.
        if (outFile != null)
            outFile.mkdirs();
    } else {
        FileOutputStream out = null;
        // Pull the data from the pipe, copying it to the output file, until we're done
        try {
            if (outFile != null) {
                File parent = outFile.getParentFile();
                if (!parent.exists()) {
                    // in practice this will only be for the default semantic directories,
                    // and using the default mode for those is appropriate.
                    parent.mkdirs();
                }
                out = new FileOutputStream(outFile);
            }
        } catch (IOException e) {
            Log.e(TAG, "Unable to create/open file " + outFile.getPath(), e);
        }
        byte[] buffer = new byte[32 * 1024];
        final long origSize = size;
        FileInputStream in = new FileInputStream(data.getFileDescriptor());
        while (size > 0) {
            int toRead = (size > buffer.length) ? buffer.length : (int) size;
            int got = in.read(buffer, 0, toRead);
            if (got <= 0) {
                Log.w(TAG, "Incomplete read: expected " + size + " but got " + (origSize - size));
                break;
            }
            if (out != null) {
                try {
                    out.write(buffer, 0, got);
                } catch (IOException e) {
                    // Problem writing to the file.  Quit copying data and delete
                    // the file, but of course keep consuming the input stream.
                    Log.e(TAG, "Unable to write to file " + outFile.getPath(), e);
                    out.close();
                    out = null;
                    outFile.delete();
                }
            }
            size -= got;
        }
        if (out != null)
            out.close();
    }
    // Now twiddle the state to match the backup, assuming all went well
    if (mode >= 0 && outFile != null) {
        try {
            // explicitly prevent emplacement of files accessible by outside apps
            mode &= 0700;
            Libcore.os.chmod(outFile.getPath(), (int) mode);
        } catch (ErrnoException e) {
            e.rethrowAsIOException();
        }
        outFile.setLastModified(mtime);
    }
}
Body of Second Method:
{
    if (type == BackupAgent.TYPE_DIRECTORY) {
        // drop down to the final metadata adjustment.
        if (outFile != null)
            outFile.mkdirs();
    } else {
        FileOutputStream out = null;
        // Pull the data from the pipe, copying it to the output file, until we're done
        try {
            if (outFile != null) {
                File parent = outFile.getParentFile();
                if (!parent.exists()) {
                    // in practice this will only be for the default semantic directories,
                    // and using the default mode for those is appropriate.
                    parent.mkdirs();
                }
                out = new FileOutputStream(outFile);
            }
        } catch (IOException e) {
            Log.e(TAG, "Unable to create/open file " + outFile.getPath(), e);
        }
        byte[] buffer = new byte[32 * 1024];
        final long origSize = size;
        FileInputStream in = new FileInputStream(data.getFileDescriptor());
        while (size > 0) {
            int toRead = (size > buffer.length) ? buffer.length : (int) size;
            int got = in.read(buffer, 0, toRead);
            if (got <= 0) {
                Log.w(TAG, "Incomplete read: expected " + size + " but got " + (origSize - size));
                break;
            }
            if (out != null) {
                try {
                    out.write(buffer, 0, got);
                } catch (IOException e) {
                    // Problem writing to the file.  Quit copying data and delete
                    // the file, but of course keep consuming the input stream.
                    Log.e(TAG, "Unable to write to file " + outFile.getPath(), e);
                    out.close();
                    out = null;
                    outFile.delete();
                }
            }
            size -= got;
        }
        if (out != null)
            out.close();
    }
    // Now twiddle the state to match the backup, assuming all went well
    if (mode >= 0 && outFile != null) {
        try {
            // explicitly prevent emplacement of files accessible by outside apps
            mode &= 0700;
            Os.chmod(outFile.getPath(), (int) mode);
        } catch (ErrnoException e) {
            e.rethrowAsIOException();
        }
        outFile.setLastModified(mtime);
    }
}
------------------------
Find a silently evolved API code:android.graphics.Paint_Delegate.measureText:COMMENT
Method Modifier: default     
Comment:/*package*/

Body of Frist Method:
{
    return new BidiRenderer(null, this, text).renderText(index, index + count, isRtl, null, 0, false, 0, 0);
}
Body of Second Method:
{
    return new BidiRenderer(null, this, text).renderText(index, index + count, isRtl, advances, advancesIndex, false);
}
------------------------
Find a silently evolved API code:android.animation.PropertyValuesHolder.setFloatValues:COMMENT
Method Modifier: public      
Comment:/**
 * Set the animated values for this object to this set of floats.
 * If there is only one value, it is assumed to be the end value of an animation,
 * and an initial value will be derived, if possible, by calling a getter function
 * on the object. Also, if any value is null, the value will be filled in when the animation
 * starts in the same way. This mechanism of automatically getting null values only works
 * if the PropertyValuesHolder object is used in conjunction
 * {@link ObjectAnimator}, and with a getter function
 * derived automatically from <code>propertyName</code>, since otherwise PropertyValuesHolder has
 * no way of determining what the value should be.
 *
 * @param values One or more values that the animation will animate between.
 */

Body of Frist Method:
{
    mValueType = float.class;
    mKeyframeSet = KeyframeSet.ofFloat(values);
}
Body of Second Method:
{
    mValueType = float.class;
    mKeyframes = KeyframeSet.ofFloat(values);
}
------------------------
Find a silently evolved API code:android.content.RestrictionEntry.getAllSelectedStrings:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the list of currently selected values.
 * @return the list of current selections, if type is {@link #TYPE_MULTI_SELECT},
 * null otherwise.
 */

Body of Frist Method:
{
    return currentValues;
}
Body of Second Method:
{
    return mCurrentValues;
}
------------------------
Find a silently evolved API code:android.transition.Transition.captureHierarchy:COMMENT
Method Modifier: private     
Comment:/**
 * Recursive method which captures values for an entire view hierarchy,
 * starting at some root view. Transitions without targetIDs will use this
 * method to capture values for all possible views.
 *
 * @param view The view for which to capture values. Children of this View
 * will also be captured, recursively down to the leaf nodes.
 * @param start true if values are being captured in the start scene, false
 * otherwise.
 */

Body of Frist Method:
{
    if (view == null) {
        return;
    }
    boolean isListViewItem = false;
    if (view.getParent() instanceof ListView) {
        isListViewItem = true;
    }
    if (isListViewItem && !((ListView) view.getParent()).getAdapter().hasStableIds()) {
        // ignore listview children unless we can track them with stable IDs
        return;
    }
    int id = View.NO_ID;
    long itemId = View.NO_ID;
    if (!isListViewItem) {
        id = view.getId();
    } else {
        ListView listview = (ListView) view.getParent();
        int position = listview.getPositionForView(view);
        itemId = listview.getItemIdAtPosition(position);
        view.setHasTransientState(true);
    }
    if (mTargetIdExcludes != null && mTargetIdExcludes.contains(id)) {
        return;
    }
    if (mTargetExcludes != null && mTargetExcludes.contains(view)) {
        return;
    }
    if (mTargetTypeExcludes != null && view != null) {
        int numTypes = mTargetTypeExcludes.size();
        for (int i = 0; i < numTypes; ++i) {
            if (mTargetTypeExcludes.get(i).isInstance(view)) {
                return;
            }
        }
    }
    TransitionValues values = new TransitionValues();
    values.view = view;
    if (start) {
        captureStartValues(values);
    } else {
        captureEndValues(values);
    }
    if (start) {
        if (!isListViewItem) {
            mStartValues.viewValues.put(view, values);
            if (id >= 0) {
                mStartValues.idValues.put((int) id, values);
            }
        } else {
            mStartValues.itemIdValues.put(itemId, values);
        }
    } else {
        if (!isListViewItem) {
            mEndValues.viewValues.put(view, values);
            if (id >= 0) {
                mEndValues.idValues.put((int) id, values);
            }
        } else {
            mEndValues.itemIdValues.put(itemId, values);
        }
    }
    if (view instanceof ViewGroup) {
        // Don't traverse child hierarchy if there are any child-excludes on this view
        if (mTargetIdChildExcludes != null && mTargetIdChildExcludes.contains(id)) {
            return;
        }
        if (mTargetChildExcludes != null && mTargetChildExcludes.contains(view)) {
            return;
        }
        if (mTargetTypeChildExcludes != null && view != null) {
            int numTypes = mTargetTypeChildExcludes.size();
            for (int i = 0; i < numTypes; ++i) {
                if (mTargetTypeChildExcludes.get(i).isInstance(view)) {
                    return;
                }
            }
        }
        ViewGroup parent = (ViewGroup) view;
        for (int i = 0; i < parent.getChildCount(); ++i) {
            captureHierarchy(parent.getChildAt(i), start);
        }
    }
}
Body of Second Method:
{
    if (view == null) {
        return;
    }
    int id = view.getId();
    if (mTargetIdExcludes != null && mTargetIdExcludes.contains(id)) {
        return;
    }
    if (mTargetExcludes != null && mTargetExcludes.contains(view)) {
        return;
    }
    if (mTargetTypeExcludes != null && view != null) {
        int numTypes = mTargetTypeExcludes.size();
        for (int i = 0; i < numTypes; ++i) {
            if (mTargetTypeExcludes.get(i).isInstance(view)) {
                return;
            }
        }
    }
    if (view.getParent() instanceof ViewGroup) {
        TransitionValues values = new TransitionValues();
        values.view = view;
        if (start) {
            captureStartValues(values);
        } else {
            captureEndValues(values);
        }
        values.targetedTransitions.add(this);
        capturePropagationValues(values);
        if (start) {
            addViewValues(mStartValues, view, values);
        } else {
            addViewValues(mEndValues, view, values);
        }
    }
    if (view instanceof ViewGroup) {
        // Don't traverse child hierarchy if there are any child-excludes on this view
        if (mTargetIdChildExcludes != null && mTargetIdChildExcludes.contains(id)) {
            return;
        }
        if (mTargetChildExcludes != null && mTargetChildExcludes.contains(view)) {
            return;
        }
        if (mTargetTypeChildExcludes != null) {
            int numTypes = mTargetTypeChildExcludes.size();
            for (int i = 0; i < numTypes; ++i) {
                if (mTargetTypeChildExcludes.get(i).isInstance(view)) {
                    return;
                }
            }
        }
        ViewGroup parent = (ViewGroup) view;
        for (int i = 0; i < parent.getChildCount(); ++i) {
            captureHierarchy(parent.getChildAt(i), start);
        }
    }
}
------------------------
Find a silently evolved API code:android.os.StrictMode.readAndHandleBinderCallViolations:COMMENT
Method Modifier: default     static      
Comment:/* package */

Body of Frist Method:
{
    // Our own stack trace to append
    StringWriter sw = new StringWriter();
    PrintWriter pw = new FastPrintWriter(sw, false, 256);
    new LogStackTrace().printStackTrace(pw);
    pw.flush();
    String ourStack = sw.toString();
    int policyMask = getThreadPolicyMask();
    boolean currentlyGathering = (policyMask & PENALTY_GATHER) != 0;
    int numViolations = p.readInt();
    for (int i = 0; i < numViolations; ++i) {
        if (LOG_V)
            Log.d(TAG, "strict mode violation stacks read from binder call.  i=" + i);
        ViolationInfo info = new ViolationInfo(p, !currentlyGathering);
        info.crashInfo.stackTrace += "# via Binder call with stack:\n" + ourStack;
        BlockGuard.Policy policy = BlockGuard.getThreadPolicy();
        if (policy instanceof AndroidBlockGuardPolicy) {
            ((AndroidBlockGuardPolicy) policy).handleViolationWithTimingAttempt(info);
        }
    }
}
Body of Second Method:
{
    // Our own stack trace to append
    StringWriter sw = new StringWriter();
    PrintWriter pw = new FastPrintWriter(sw, false, 256);
    new LogStackTrace().printStackTrace(pw);
    pw.flush();
    String ourStack = sw.toString();
    int policyMask = getThreadPolicyMask();
    boolean currentlyGathering = (policyMask & PENALTY_GATHER) != 0;
    int numViolations = p.readInt();
    for (int i = 0; i < numViolations; ++i) {
        if (LOG_V)
            Log.d(TAG, "strict mode violation stacks read from binder call.  i=" + i);
        ViolationInfo info = new ViolationInfo(p, !currentlyGathering);
        if (info.crashInfo.stackTrace != null && info.crashInfo.stackTrace.length() > 10000) {
            String front = info.crashInfo.stackTrace.substring(256);
            // First, drain the remaining violations from the parcel.
            while (i < numViolations) {
                info = new ViolationInfo(p, !currentlyGathering);
                i++;
            }
            // Next clear out all gathered violations.
            clearGatheredViolations();
            // Now report the problem.
            Slog.wtfStack(TAG, "Stack is too large: numViolations=" + numViolations + " policy=#" + Integer.toHexString(policyMask) + " front=" + front);
            return;
        }
        info.crashInfo.stackTrace += "# via Binder call with stack:\n" + ourStack;
        BlockGuard.Policy policy = BlockGuard.getThreadPolicy();
        if (policy instanceof AndroidBlockGuardPolicy) {
            ((AndroidBlockGuardPolicy) policy).handleViolationWithTimingAttempt(info);
        }
    }
}
------------------------
Find a silently evolved API code:android.media.MediaPlayer.setAudioStreamType:COMMENT
<android.media.MediaPlayer: void setAudioStreamType(int)>
public      native      ->public      
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * Sets the audio stream type for this MediaPlayer. See {@link AudioManager}
 * for a list of stream types. Must call this method before prepare() or
 * prepareAsync() in order for the target stream type to become effective
 * thereafter.
 *
 * @param streamtype the audio stream type
 * @see android.media.AudioManager
 */

Body of Frist Method:

Body of Second Method:
{
    _setAudioStreamType(streamtype);
    mStreamType = streamtype;
}
------------------------
Find a silently evolved API code:android.os.Bundle.getByteArray:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return a byte[] value, or null
 */

Body of Frist Method:
{
    unparcel();
    Object o = mMap.get(key);
    if (o == null) {
        return null;
    }
    try {
        return (byte[]) o;
    } catch (ClassCastException e) {
        typeWarning(key, o, "byte[]", e);
        return null;
    }
}
Body of Second Method:
{
    return super.getByteArray(key);
}
------------------------
Find a silently evolved API code:android.service.dreams.DreamService.detach:COMMENT
Method Modifier: private     final       
Comment:/**
 * Called by DreamController.stopDream() when the Dream is about to be unbound and destroyed.
 *
 * Must run on mHandler.
 */

Body of Frist Method:
{
    if (mWindow == null) {
        // already detached!
        return;
    }
    try {
        onDreamingStopped();
    } catch (Throwable t) {
        Slog.w(TAG, "Crashed in onDreamingStopped()", t);
    // we were going to stop anyway
    }
    if (mDebug)
        Slog.v(TAG, "detach(): Removing window from window manager");
    try {
        // force our window to be removed synchronously
        mWindowManager.removeViewImmediate(mWindow.getDecorView());
        // the following will print a log message if it finds any other leaked windows
        WindowManagerGlobal.getInstance().closeAll(mWindowToken, this.getClass().getName(), "Dream");
    } catch (Throwable t) {
        Slog.w(TAG, "Crashed removing window view", t);
    }
    mWindow = null;
    mWindowToken = null;
}
Body of Second Method:
{
    if (mStarted) {
        if (mDebug)
            Slog.v(TAG, "detach(): Calling onDreamingStopped()");
        mStarted = false;
        onDreamingStopped();
    }
    if (mWindow != null) {
        // force our window to be removed synchronously
        if (mDebug)
            Slog.v(TAG, "detach(): Removing window from window manager");
        mWindow.getWindowManager().removeViewImmediate(mWindow.getDecorView());
        mWindow = null;
    }
    if (mWindowToken != null) {
        // the following will print a log message if it finds any other leaked windows
        WindowManagerGlobal.getInstance().closeAll(mWindowToken, this.getClass().getName(), "Dream");
        mWindowToken = null;
        mCanDoze = false;
    }
}
------------------------
Find a silently evolved API code:android.widget.TimePicker.getCurrentMinute:COMMENT
Method Modifier: public      
Comment:/**
 * @return The current minute.
 */

Body of Frist Method:
{
    return mMinuteSpinner.getValue();
}
Body of Second Method:
{
    return mDelegate.getCurrentMinute();
}
------------------------
Find a silently evolved API code:android.widget.Switch.hitThumb:COMMENT
Method Modifier: private     
Comment:/**
 * @return true if (x, y) is within the target area of the switch thumb
 */

Body of Frist Method:
{
    mThumbDrawable.getPadding(mTempRect);
    final int thumbTop = mSwitchTop - mTouchSlop;
    final int thumbLeft = mSwitchLeft + (int) (mThumbPosition + 0.5f) - mTouchSlop;
    final int thumbRight = thumbLeft + mThumbWidth + mTempRect.left + mTempRect.right + mTouchSlop;
    final int thumbBottom = mSwitchBottom + mTouchSlop;
    return x > thumbLeft && x < thumbRight && y > thumbTop && y < thumbBottom;
}
Body of Second Method:
{
    // Relies on mTempRect, MUST be called first!
    final int thumbOffset = getThumbOffset();
    mThumbDrawable.getPadding(mTempRect);
    final int thumbTop = mSwitchTop - mTouchSlop;
    final int thumbLeft = mSwitchLeft + thumbOffset - mTouchSlop;
    final int thumbRight = thumbLeft + mThumbWidth + mTempRect.left + mTempRect.right + mTouchSlop;
    final int thumbBottom = mSwitchBottom + mTouchSlop;
    return x > thumbLeft && x < thumbRight && y > thumbTop && y < thumbBottom;
}
------------------------
Find a silently evolved API code:android.text.method.Touch.onTouchEvent:COMMENT
Method Modifier: public      static      
Comment:/**
 * Handles touch events for dragging.  You may want to do other actions
 * like moving the cursor on touch as well.
 */

Body of Frist Method:
{
    DragState[] ds;
    switch(event.getActionMasked()) {
        case MotionEvent.ACTION_DOWN:
            ds = buffer.getSpans(0, buffer.length(), DragState.class);
            for (int i = 0; i < ds.length; i++) {
                buffer.removeSpan(ds[i]);
            }
            buffer.setSpan(new DragState(event.getX(), event.getY(), widget.getScrollX(), widget.getScrollY()), 0, 0, Spannable.SPAN_MARK_MARK);
            return true;
        case MotionEvent.ACTION_UP:
            ds = buffer.getSpans(0, buffer.length(), DragState.class);
            for (int i = 0; i < ds.length; i++) {
                buffer.removeSpan(ds[i]);
            }
            if (ds.length > 0 && ds[0].mUsed) {
                return true;
            } else {
                return false;
            }
        case MotionEvent.ACTION_MOVE:
            ds = buffer.getSpans(0, buffer.length(), DragState.class);
            if (ds.length > 0) {
                if (ds[0].mFarEnough == false) {
                    int slop = ViewConfiguration.get(widget.getContext()).getScaledTouchSlop();
                    if (Math.abs(event.getX() - ds[0].mX) >= slop || Math.abs(event.getY() - ds[0].mY) >= slop) {
                        ds[0].mFarEnough = true;
                    }
                }
                if (ds[0].mFarEnough) {
                    ds[0].mUsed = true;
                    boolean cap = (event.getMetaState() & KeyEvent.META_SHIFT_ON) != 0 || MetaKeyKeyListener.getMetaState(buffer, MetaKeyKeyListener.META_SHIFT_ON) == 1 || MetaKeyKeyListener.getMetaState(buffer, MetaKeyKeyListener.META_SELECTING) != 0;
                    float dx;
                    float dy;
                    if (cap) {
                        // if we're selecting, we want the scroll to go in
                        // the direction of the drag
                        dx = event.getX() - ds[0].mX;
                        dy = event.getY() - ds[0].mY;
                    } else {
                        dx = ds[0].mX - event.getX();
                        dy = ds[0].mY - event.getY();
                    }
                    ds[0].mX = event.getX();
                    ds[0].mY = event.getY();
                    int nx = widget.getScrollX() + (int) dx;
                    int ny = widget.getScrollY() + (int) dy;
                    int padding = widget.getTotalPaddingTop() + widget.getTotalPaddingBottom();
                    Layout layout = widget.getLayout();
                    ny = Math.min(ny, layout.getHeight() - (widget.getHeight() - padding));
                    ny = Math.max(ny, 0);
                    int oldX = widget.getScrollX();
                    int oldY = widget.getScrollY();
                    scrollTo(widget, layout, nx, ny);
                    // If we actually scrolled, then cancel the up action.
                    if (oldX != widget.getScrollX() || oldY != widget.getScrollY()) {
                        widget.cancelLongPress();
                    }
                    return true;
                }
            }
    }
    return false;
}
Body of Second Method:
{
    DragState[] ds;
    switch(event.getActionMasked()) {
        case MotionEvent.ACTION_DOWN:
            ds = buffer.getSpans(0, buffer.length(), DragState.class);
            for (int i = 0; i < ds.length; i++) {
                buffer.removeSpan(ds[i]);
            }
            buffer.setSpan(new DragState(event.getX(), event.getY(), widget.getScrollX(), widget.getScrollY()), 0, 0, Spannable.SPAN_MARK_MARK);
            return true;
        case MotionEvent.ACTION_UP:
            ds = buffer.getSpans(0, buffer.length(), DragState.class);
            for (int i = 0; i < ds.length; i++) {
                buffer.removeSpan(ds[i]);
            }
            if (ds.length > 0 && ds[0].mUsed) {
                return true;
            } else {
                return false;
            }
        case MotionEvent.ACTION_MOVE:
            ds = buffer.getSpans(0, buffer.length(), DragState.class);
            if (ds.length > 0) {
                ds[0].mIsSelectionStarted = false;
                if (ds[0].mFarEnough == false) {
                    int slop = ViewConfiguration.get(widget.getContext()).getScaledTouchSlop();
                    if (Math.abs(event.getX() - ds[0].mX) >= slop || Math.abs(event.getY() - ds[0].mY) >= slop) {
                        ds[0].mFarEnough = true;
                        if (event.isButtonPressed(MotionEvent.BUTTON_PRIMARY)) {
                            ds[0].mIsActivelySelecting = true;
                            ds[0].mIsSelectionStarted = true;
                        }
                    }
                }
                if (ds[0].mFarEnough) {
                    ds[0].mUsed = true;
                    boolean cap = (event.getMetaState() & KeyEvent.META_SHIFT_ON) != 0 || MetaKeyKeyListener.getMetaState(buffer, MetaKeyKeyListener.META_SHIFT_ON) == 1 || MetaKeyKeyListener.getMetaState(buffer, MetaKeyKeyListener.META_SELECTING) != 0;
                    if (!event.isButtonPressed(MotionEvent.BUTTON_PRIMARY)) {
                        ds[0].mIsActivelySelecting = false;
                    }
                    float dx;
                    float dy;
                    if (cap && event.isButtonPressed(MotionEvent.BUTTON_PRIMARY)) {
                        // if we're selecting, we want the scroll to go in
                        // the direction of the drag
                        dx = event.getX() - ds[0].mX;
                        dy = event.getY() - ds[0].mY;
                    } else {
                        dx = ds[0].mX - event.getX();
                        dy = ds[0].mY - event.getY();
                    }
                    ds[0].mX = event.getX();
                    ds[0].mY = event.getY();
                    int nx = widget.getScrollX() + (int) dx;
                    int ny = widget.getScrollY() + (int) dy;
                    int padding = widget.getTotalPaddingTop() + widget.getTotalPaddingBottom();
                    Layout layout = widget.getLayout();
                    ny = Math.min(ny, layout.getHeight() - (widget.getHeight() - padding));
                    ny = Math.max(ny, 0);
                    int oldX = widget.getScrollX();
                    int oldY = widget.getScrollY();
                    if (!event.isButtonPressed(MotionEvent.BUTTON_PRIMARY)) {
                        scrollTo(widget, layout, nx, ny);
                    }
                    // If we actually scrolled, then cancel the up action.
                    if (oldX != widget.getScrollX() || oldY != widget.getScrollY()) {
                        widget.cancelLongPress();
                    }
                    return true;
                }
            }
    }
    return false;
}
------------------------
Find a silently evolved API code:android.view.Surface.transferFrom:COMMENT
Method Modifier: public      hidden      deprecated  
Comment:/**
 * This is intended to be used by {@link SurfaceView#updateWindow} only.
 * @param other access is not thread safe
 * @hide
 * @deprecated
 */

Body of Frist Method:
{
    if (other == null) {
        throw new IllegalArgumentException("other must not be null");
    }
    if (other != this) {
        final int newPtr;
        synchronized (other.mLock) {
            newPtr = other.mNativeObject;
            other.setNativeObjectLocked(0);
        }
        synchronized (mLock) {
            if (mNativeObject != 0) {
                nativeRelease(mNativeObject);
            }
            setNativeObjectLocked(newPtr);
        }
    }
}
Body of Second Method:
{
    if (other == null) {
        throw new IllegalArgumentException("other must not be null");
    }
    if (other != this) {
        final long newPtr;
        synchronized (other.mLock) {
            newPtr = other.mNativeObject;
            other.setNativeObjectLocked(0);
        }
        synchronized (mLock) {
            if (mNativeObject != 0) {
                nativeRelease(mNativeObject);
            }
            setNativeObjectLocked(newPtr);
        }
    }
}
------------------------
Find a silently evolved API code:android.view.accessibility.AccessibilityEvent.getRecordCount:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the number of records contained in the event.
 *
 * @return The number of records.
 */

Body of Frist Method:
{
    return mRecords.size();
}
Body of Second Method:
{
    return mRecords == null ? 0 : mRecords.size();
}
------------------------
Find a silently evolved API code:android.graphics.drawable.AnimationDrawable.isRunning:COMMENT
Method Modifier: public      
Comment:/**
 * <p>Indicates whether the animation is currently running or not.</p>
 *
 * @return true if the animation is running, false otherwise
 */

Body of Frist Method:
{
    return mCurFrame > -1;
}
Body of Second Method:
{
    return mRunning;
}
------------------------
Find a silently evolved API code:android.os.Bundle.getCharSequenceArrayList:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return an ArrayList<CharSequence> value, or null
 */

Body of Frist Method:
{
    unparcel();
    Object o = mMap.get(key);
    if (o == null) {
        return null;
    }
    try {
        return (ArrayList<CharSequence>) o;
    } catch (ClassCastException e) {
        typeWarning(key, o, "ArrayList<CharSequence>", e);
        return null;
    }
}
Body of Second Method:
{
    return super.getCharSequenceArrayList(key);
}
------------------------
Find a silently evolved API code:android.content.res.TypedArray.peekValue:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the raw TypedValue for the attribute at <var>index</var>
 * and return a temporary object holding its data.  This object is only
 * valid until the next call on to {@link TypedArray}.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return Returns a TypedValue object if the attribute is defined,
 * containing its data; otherwise returns null.  (You will not
 * receive a TypedValue whose type is TYPE_NULL.)
 */

Body of Frist Method:
{
    final TypedValue value = mValue;
    if (getValueAt(index * AssetManager.STYLE_NUM_ENTRIES, value)) {
        return value;
    }
    return null;
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    final TypedValue value = mValue;
    if (getValueAt(index * AssetManager.STYLE_NUM_ENTRIES, value)) {
        return value;
    }
    return null;
}
------------------------
Find a silently evolved API code:android.os.Bundle.getBooleanArray:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return a boolean[] value, or null
 */

Body of Frist Method:
{
    unparcel();
    Object o = mMap.get(key);
    if (o == null) {
        return null;
    }
    try {
        return (boolean[]) o;
    } catch (ClassCastException e) {
        typeWarning(key, o, "byte[]", e);
        return null;
    }
}
Body of Second Method:
{
    return super.getBooleanArray(key);
}
------------------------
Find a silently evolved API code:android.widget.FastScroller.scrollTo:COMMENT
Method Modifier: private     
Comment:/**
 * Scrolls to a specific position within the section
 * @param position
 */

Body of Frist Method:
{
    mScrollCompleted = false;
    final int count = mList.getCount();
    final Object[] sections = mSections;
    final int sectionCount = sections == null ? 0 : sections.length;
    int sectionIndex;
    if (sections != null && sectionCount > 1) {
        final int exactSection = MathUtils.constrain((int) (position * sectionCount), 0, sectionCount - 1);
        int targetSection = exactSection;
        int targetIndex = mSectionIndexer.getPositionForSection(targetSection);
        sectionIndex = targetSection;
        // Given the expected section and index, the following code will
        // try to account for missing sections (no names starting with..)
        // It will compute the scroll space of surrounding empty sections
        // and interpolate the currently visible letter's range across the
        // available space, so that there is always some list movement while
        // the user moves the thumb.
        int nextIndex = count;
        int prevIndex = targetIndex;
        int prevSection = targetSection;
        int nextSection = targetSection + 1;
        // Assume the next section is unique
        if (targetSection < sectionCount - 1) {
            nextIndex = mSectionIndexer.getPositionForSection(targetSection + 1);
        }
        // Find the previous index if we're slicing the previous section
        if (nextIndex == targetIndex) {
            // Non-existent letter
            while (targetSection > 0) {
                targetSection--;
                prevIndex = mSectionIndexer.getPositionForSection(targetSection);
                if (prevIndex != targetIndex) {
                    prevSection = targetSection;
                    sectionIndex = targetSection;
                    break;
                } else if (targetSection == 0) {
                    // When section reaches 0 here, sectionIndex must follow it.
                    // Assuming mSectionIndexer.getPositionForSection(0) == 0.
                    sectionIndex = 0;
                    break;
                }
            }
        }
        // Find the next index, in case the assumed next index is not
        // unique. For instance, if there is no P, then request for P's
        // position actually returns Q's. So we need to look ahead to make
        // sure that there is really a Q at Q's position. If not, move
        // further down...
        int nextNextSection = nextSection + 1;
        while (nextNextSection < sectionCount && mSectionIndexer.getPositionForSection(nextNextSection) == nextIndex) {
            nextNextSection++;
            nextSection++;
        }
        // Compute the beginning and ending scroll range percentage of the
        // currently visible section. This could be equal to or greater than
        // (1 / nSections). If the target position is near the previous
        // position, snap to the previous position.
        final float prevPosition = (float) prevSection / sectionCount;
        final float nextPosition = (float) nextSection / sectionCount;
        final float snapThreshold = (count == 0) ? Float.MAX_VALUE : .125f / count;
        if (prevSection == exactSection && position - prevPosition < snapThreshold) {
            targetIndex = prevIndex;
        } else {
            targetIndex = prevIndex + (int) ((nextIndex - prevIndex) * (position - prevPosition) / (nextPosition - prevPosition));
        }
        // Clamp to valid positions.
        targetIndex = MathUtils.constrain(targetIndex, 0, count - 1);
        if (mList instanceof ExpandableListView) {
            final ExpandableListView expList = (ExpandableListView) mList;
            expList.setSelectionFromTop(expList.getFlatListPosition(ExpandableListView.getPackedPositionForGroup(targetIndex + mHeaderCount)), 0);
        } else if (mList instanceof ListView) {
            ((ListView) mList).setSelectionFromTop(targetIndex + mHeaderCount, 0);
        } else {
            mList.setSelection(targetIndex + mHeaderCount);
        }
    } else {
        final int index = MathUtils.constrain((int) (position * count), 0, count - 1);
        if (mList instanceof ExpandableListView) {
            ExpandableListView expList = (ExpandableListView) mList;
            expList.setSelectionFromTop(expList.getFlatListPosition(ExpandableListView.getPackedPositionForGroup(index + mHeaderCount)), 0);
        } else if (mList instanceof ListView) {
            ((ListView) mList).setSelectionFromTop(index + mHeaderCount, 0);
        } else {
            mList.setSelection(index + mHeaderCount);
        }
        sectionIndex = -1;
    }
    if (mCurrentSection != sectionIndex) {
        mCurrentSection = sectionIndex;
        if (transitionPreviewLayout(sectionIndex)) {
            transitionToDragging();
        } else {
            transitionToVisible();
        }
    }
}
Body of Second Method:
{
    mScrollCompleted = false;
    final int count = mList.getCount();
    final Object[] sections = mSections;
    final int sectionCount = sections == null ? 0 : sections.length;
    int sectionIndex;
    if (sections != null && sectionCount > 1) {
        final int exactSection = MathUtils.constrain((int) (position * sectionCount), 0, sectionCount - 1);
        int targetSection = exactSection;
        int targetIndex = mSectionIndexer.getPositionForSection(targetSection);
        sectionIndex = targetSection;
        // Given the expected section and index, the following code will
        // try to account for missing sections (no names starting with..)
        // It will compute the scroll space of surrounding empty sections
        // and interpolate the currently visible letter's range across the
        // available space, so that there is always some list movement while
        // the user moves the thumb.
        int nextIndex = count;
        int prevIndex = targetIndex;
        int prevSection = targetSection;
        int nextSection = targetSection + 1;
        // Assume the next section is unique
        if (targetSection < sectionCount - 1) {
            nextIndex = mSectionIndexer.getPositionForSection(targetSection + 1);
        }
        // Find the previous index if we're slicing the previous section
        if (nextIndex == targetIndex) {
            // Non-existent letter
            while (targetSection > 0) {
                targetSection--;
                prevIndex = mSectionIndexer.getPositionForSection(targetSection);
                if (prevIndex != targetIndex) {
                    prevSection = targetSection;
                    sectionIndex = targetSection;
                    break;
                } else if (targetSection == 0) {
                    // When section reaches 0 here, sectionIndex must follow it.
                    // Assuming mSectionIndexer.getPositionForSection(0) == 0.
                    sectionIndex = 0;
                    break;
                }
            }
        }
        // Find the next index, in case the assumed next index is not
        // unique. For instance, if there is no P, then request for P's
        // position actually returns Q's. So we need to look ahead to make
        // sure that there is really a Q at Q's position. If not, move
        // further down...
        int nextNextSection = nextSection + 1;
        while (nextNextSection < sectionCount && mSectionIndexer.getPositionForSection(nextNextSection) == nextIndex) {
            nextNextSection++;
            nextSection++;
        }
        // Compute the beginning and ending scroll range percentage of the
        // currently visible section. This could be equal to or greater than
        // (1 / nSections). If the target position is near the previous
        // position, snap to the previous position.
        final float prevPosition = (float) prevSection / sectionCount;
        final float nextPosition = (float) nextSection / sectionCount;
        final float snapThreshold = (count == 0) ? Float.MAX_VALUE : .125f / count;
        if (prevSection == exactSection && position - prevPosition < snapThreshold) {
            targetIndex = prevIndex;
        } else {
            targetIndex = prevIndex + (int) ((nextIndex - prevIndex) * (position - prevPosition) / (nextPosition - prevPosition));
        }
        // Clamp to valid positions.
        targetIndex = MathUtils.constrain(targetIndex, 0, count - 1);
        if (mList instanceof ExpandableListView) {
            final ExpandableListView expList = (ExpandableListView) mList;
            expList.setSelectionFromTop(expList.getFlatListPosition(ExpandableListView.getPackedPositionForGroup(targetIndex + mHeaderCount)), 0);
        } else if (mList instanceof ListView) {
            ((ListView) mList).setSelectionFromTop(targetIndex + mHeaderCount, 0);
        } else {
            mList.setSelection(targetIndex + mHeaderCount);
        }
    } else {
        final int index = MathUtils.constrain((int) (position * count), 0, count - 1);
        if (mList instanceof ExpandableListView) {
            ExpandableListView expList = (ExpandableListView) mList;
            expList.setSelectionFromTop(expList.getFlatListPosition(ExpandableListView.getPackedPositionForGroup(index + mHeaderCount)), 0);
        } else if (mList instanceof ListView) {
            ((ListView) mList).setSelectionFromTop(index + mHeaderCount, 0);
        } else {
            mList.setSelection(index + mHeaderCount);
        }
        sectionIndex = -1;
    }
    if (mCurrentSection != sectionIndex) {
        mCurrentSection = sectionIndex;
        final boolean hasPreview = transitionPreviewLayout(sectionIndex);
        if (!mShowingPreview && hasPreview) {
            transitionToDragging();
        } else if (mShowingPreview && !hasPreview) {
            transitionToVisible();
        }
    }
}
------------------------
Find a silently evolved API code:android.widget.ListView.arrowScrollImpl:COMMENT
Method Modifier: private     
Comment:/**
 * Handle an arrow scroll going up or down.  Take into account whether items are selectable,
 * whether there are focusable items etc.
 *
 * @param direction Either {@link android.view.View#FOCUS_UP} or {@link android.view.View#FOCUS_DOWN}.
 * @return Whether any scrolling, selection or focus change occured.
 */

Body of Frist Method:
{
    if (getChildCount() <= 0) {
        return false;
    }
    View selectedView = getSelectedView();
    int selectedPos = mSelectedPosition;
    int nextSelectedPosition = nextSelectedPositionForDirection(selectedView, selectedPos, direction);
    int amountToScroll = amountToScroll(direction, nextSelectedPosition);
    // if we are moving focus, we may OVERRIDE the default behavior
    final ArrowScrollFocusResult focusResult = mItemsCanFocus ? arrowScrollFocused(direction) : null;
    if (focusResult != null) {
        nextSelectedPosition = focusResult.getSelectedPosition();
        amountToScroll = focusResult.getAmountToScroll();
    }
    boolean needToRedraw = focusResult != null;
    if (nextSelectedPosition != INVALID_POSITION) {
        handleNewSelectionChange(selectedView, direction, nextSelectedPosition, focusResult != null);
        setSelectedPositionInt(nextSelectedPosition);
        setNextSelectedPositionInt(nextSelectedPosition);
        selectedView = getSelectedView();
        selectedPos = nextSelectedPosition;
        if (mItemsCanFocus && focusResult == null) {
            // there was no new view found to take focus, make sure we
            // don't leave focus with the old selection
            final View focused = getFocusedChild();
            if (focused != null) {
                focused.clearFocus();
            }
        }
        needToRedraw = true;
        checkSelectionChanged();
    }
    if (amountToScroll > 0) {
        scrollListItemsBy((direction == View.FOCUS_UP) ? amountToScroll : -amountToScroll);
        needToRedraw = true;
    }
    // item that was panned off screen gives up focus.
    if (mItemsCanFocus && (focusResult == null) && selectedView != null && selectedView.hasFocus()) {
        final View focused = selectedView.findFocus();
        if (!isViewAncestorOf(focused, this) || distanceToView(focused) > 0) {
            focused.clearFocus();
        }
    }
    // if  the current selection is panned off, we need to remove the selection
    if (nextSelectedPosition == INVALID_POSITION && selectedView != null && !isViewAncestorOf(selectedView, this)) {
        selectedView = null;
        hideSelector();
        // but we don't want to set the ressurect position (that would make subsequent
        // unhandled key events bring back the item we just scrolled off!)
        mResurrectToPosition = INVALID_POSITION;
    }
    if (needToRedraw) {
        if (selectedView != null) {
            positionSelector(selectedPos, selectedView);
            mSelectedTop = selectedView.getTop();
        }
        if (!awakenScrollBars()) {
            invalidate();
        }
        invokeOnItemScrollListener();
        return true;
    }
    return false;
}
Body of Second Method:
{
    if (getChildCount() <= 0) {
        return false;
    }
    View selectedView = getSelectedView();
    int selectedPos = mSelectedPosition;
    int nextSelectedPosition = nextSelectedPositionForDirection(selectedView, selectedPos, direction);
    int amountToScroll = amountToScroll(direction, nextSelectedPosition);
    // if we are moving focus, we may OVERRIDE the default behavior
    final ArrowScrollFocusResult focusResult = mItemsCanFocus ? arrowScrollFocused(direction) : null;
    if (focusResult != null) {
        nextSelectedPosition = focusResult.getSelectedPosition();
        amountToScroll = focusResult.getAmountToScroll();
    }
    boolean needToRedraw = focusResult != null;
    if (nextSelectedPosition != INVALID_POSITION) {
        handleNewSelectionChange(selectedView, direction, nextSelectedPosition, focusResult != null);
        setSelectedPositionInt(nextSelectedPosition);
        setNextSelectedPositionInt(nextSelectedPosition);
        selectedView = getSelectedView();
        selectedPos = nextSelectedPosition;
        if (mItemsCanFocus && focusResult == null) {
            // there was no new view found to take focus, make sure we
            // don't leave focus with the old selection
            final View focused = getFocusedChild();
            if (focused != null) {
                focused.clearFocus();
            }
        }
        needToRedraw = true;
        checkSelectionChanged();
    }
    if (amountToScroll > 0) {
        scrollListItemsBy((direction == View.FOCUS_UP) ? amountToScroll : -amountToScroll);
        needToRedraw = true;
    }
    // item that was panned off screen gives up focus.
    if (mItemsCanFocus && (focusResult == null) && selectedView != null && selectedView.hasFocus()) {
        final View focused = selectedView.findFocus();
        if (!isViewAncestorOf(focused, this) || distanceToView(focused) > 0) {
            focused.clearFocus();
        }
    }
    // if  the current selection is panned off, we need to remove the selection
    if (nextSelectedPosition == INVALID_POSITION && selectedView != null && !isViewAncestorOf(selectedView, this)) {
        selectedView = null;
        hideSelector();
        // but we don't want to set the ressurect position (that would make subsequent
        // unhandled key events bring back the item we just scrolled off!)
        mResurrectToPosition = INVALID_POSITION;
    }
    if (needToRedraw) {
        if (selectedView != null) {
            positionSelectorLikeFocus(selectedPos, selectedView);
            mSelectedTop = selectedView.getTop();
        }
        if (!awakenScrollBars()) {
            invalidate();
        }
        invokeOnItemScrollListener();
        return true;
    }
    return false;
}
------------------------
Find a silently evolved API code:android.content.RestrictionEntry.setDescription:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the user-visible description of the entry, as a possible sub-text for the title.
 * You can use this to describe the entry in more detail or to display the current state of
 * the restriction.
 * @param description the user-visible description string.
 */

Body of Frist Method:
{
    this.description = description;
}
Body of Second Method:
{
    this.mDescription = description;
}
------------------------
Find a silently evolved API code:android.media.MediaFocusControl.registerMediaButtonIntent:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * see AudioManager.registerMediaButtonIntent(PendingIntent pi, ComponentName c)
 * precondition: mediaIntent != null
 */

Body of Frist Method:
{
    Log.i(TAG, "  Remote Control   registerMediaButtonIntent() for " + mediaIntent);
    synchronized (mAudioFocusLock) {
        synchronized (mRCStack) {
            pushMediaButtonReceiver_syncAfRcs(mediaIntent, eventReceiver, token);
            // new RC client, assume every type of information shall be queried
            checkUpdateRemoteControlDisplay_syncAfRcs(RC_INFO_ALL);
        }
    }
}
Body of Second Method:
{
    Log.i(TAG, "  Remote Control   registerMediaButtonIntent() for " + mediaIntent);
    synchronized (mPRStack) {
        if (pushMediaButtonReceiver_syncPrs(mediaIntent, eventReceiver, token)) {
            // new RC client, assume every type of information shall be queried
            checkUpdateRemoteControlDisplay_syncPrs(RC_INFO_ALL);
        }
    }
}
------------------------
Find a silently evolved API code:android.view.LayoutInflater_Delegate.rInflate:COMMENT
Method Modifier: default     static      
Comment:/**
 * Recursive method used to descend down the xml hierarchy and instantiate
 * views, instantiate their children, and then call onFinishInflate().
 *
 * This implementation just records the merge status before calling the default implementation.
 */

Body of Frist Method:
{
    if (finishInflate == false) {
        // this is a merge rInflate!
        if (thisInflater instanceof BridgeInflater) {
            ((BridgeInflater) thisInflater).setIsInMerge(true);
        }
    }
    // ---- START DEFAULT IMPLEMENTATION.
    thisInflater.rInflate_Original(parser, parent, attrs, finishInflate);
    if (finishInflate == false) {
        // this is a merge rInflate!
        if (thisInflater instanceof BridgeInflater) {
            ((BridgeInflater) thisInflater).setIsInMerge(false);
        }
    }
}
Body of Second Method:
{
    if (finishInflate == false) {
        // this is a merge rInflate!
        if (thisInflater instanceof BridgeInflater) {
            ((BridgeInflater) thisInflater).setIsInMerge(true);
        }
    }
    // ---- START DEFAULT IMPLEMENTATION.
    thisInflater.rInflate_Original(parser, parent, attrs, finishInflate, inheritContext);
    if (finishInflate == false) {
        // this is a merge rInflate!
        if (thisInflater instanceof BridgeInflater) {
            ((BridgeInflater) thisInflater).setIsInMerge(false);
        }
    }
}
------------------------
Find a silently evolved API code:android.graphics.Canvas.drawPaint:COMMENT
Method Modifier: public      
Comment:/**
 * Fill the entire canvas' bitmap (restricted to the current clip) with
 * the specified paint. This is equivalent (but faster) to drawing an
 * infinitely large rectangle with the specified paint.
 *
 * @param paint The paint used to draw onto the canvas
 */

Body of Frist Method:
{
    native_drawPaint(mNativeCanvas, paint.mNativePaint);
}
Body of Second Method:
{
    native_drawPaint(mNativeCanvasWrapper, paint.mNativePaint);
}
------------------------
Find a silently evolved API code:android.util.ArraySet.removeAt:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Remove the key/value mapping at the given index.
 * @param index The desired index, must be between 0 and {@link #size()}-1.
 * @return Returns the value that was stored at this index.
 */

Body of Frist Method:
{
    final Object old = mArray[index];
    if (mSize <= 1) {
        // Now empty.
        if (DEBUG)
            Log.d(TAG, "remove: shrink from " + mHashes.length + " to 0");
        freeArrays(mHashes, mArray, mSize);
        mHashes = ContainerHelpers.EMPTY_INTS;
        mArray = ContainerHelpers.EMPTY_OBJECTS;
        mSize = 0;
    } else {
        if (mHashes.length > (BASE_SIZE * 2) && mSize < mHashes.length / 3) {
            // Shrunk enough to reduce size of arrays.  We don't allow it to
            // shrink smaller than (BASE_SIZE*2) to avoid flapping between
            // that and BASE_SIZE.
            final int n = mSize > (BASE_SIZE * 2) ? (mSize + (mSize >> 1)) : (BASE_SIZE * 2);
            if (DEBUG)
                Log.d(TAG, "remove: shrink from " + mHashes.length + " to " + n);
            final int[] ohashes = mHashes;
            final Object[] oarray = mArray;
            allocArrays(n);
            mSize--;
            if (index > 0) {
                if (DEBUG)
                    Log.d(TAG, "remove: copy from 0-" + index + " to 0");
                System.arraycopy(ohashes, 0, mHashes, 0, index);
                System.arraycopy(oarray, 0, mArray, 0, index);
            }
            if (index < mSize) {
                if (DEBUG)
                    Log.d(TAG, "remove: copy from " + (index + 1) + "-" + mSize + " to " + index);
                System.arraycopy(ohashes, index + 1, mHashes, index, mSize - index);
                System.arraycopy(oarray, index + 1, mArray, index, mSize - index);
            }
        } else {
            mSize--;
            if (index < mSize) {
                if (DEBUG)
                    Log.d(TAG, "remove: move " + (index + 1) + "-" + mSize + " to " + index);
                System.arraycopy(mHashes, index + 1, mHashes, index, mSize - index);
                System.arraycopy(mArray, index + 1, mArray, index, mSize - index);
            }
            mArray[mSize] = null;
        }
    }
    return (E) old;
}
Body of Second Method:
{
    final Object old = mArray[index];
    if (mSize <= 1) {
        // Now empty.
        if (DEBUG)
            Log.d(TAG, "remove: shrink from " + mHashes.length + " to 0");
        freeArrays(mHashes, mArray, mSize);
        mHashes = EmptyArray.INT;
        mArray = EmptyArray.OBJECT;
        mSize = 0;
    } else {
        if (mHashes.length > (BASE_SIZE * 2) && mSize < mHashes.length / 3) {
            // Shrunk enough to reduce size of arrays.  We don't allow it to
            // shrink smaller than (BASE_SIZE*2) to avoid flapping between
            // that and BASE_SIZE.
            final int n = mSize > (BASE_SIZE * 2) ? (mSize + (mSize >> 1)) : (BASE_SIZE * 2);
            if (DEBUG)
                Log.d(TAG, "remove: shrink from " + mHashes.length + " to " + n);
            final int[] ohashes = mHashes;
            final Object[] oarray = mArray;
            allocArrays(n);
            mSize--;
            if (index > 0) {
                if (DEBUG)
                    Log.d(TAG, "remove: copy from 0-" + index + " to 0");
                System.arraycopy(ohashes, 0, mHashes, 0, index);
                System.arraycopy(oarray, 0, mArray, 0, index);
            }
            if (index < mSize) {
                if (DEBUG)
                    Log.d(TAG, "remove: copy from " + (index + 1) + "-" + mSize + " to " + index);
                System.arraycopy(ohashes, index + 1, mHashes, index, mSize - index);
                System.arraycopy(oarray, index + 1, mArray, index, mSize - index);
            }
        } else {
            mSize--;
            if (index < mSize) {
                if (DEBUG)
                    Log.d(TAG, "remove: move " + (index + 1) + "-" + mSize + " to " + index);
                System.arraycopy(mHashes, index + 1, mHashes, index, mSize - index);
                System.arraycopy(mArray, index + 1, mArray, index, mSize - index);
            }
            mArray[mSize] = null;
        }
    }
    return (E) old;
}
------------------------
Find a silently evolved API code:android.view.animation.Transformation.clear:COMMENT
Method Modifier: public      
Comment:/**
 * Reset the transformation to a state that leaves the object
 * being animated in an unmodified state. The transformation type is
 * {@link #TYPE_BOTH} by default.
 */

Body of Frist Method:
{
    if (mMatrix == null) {
        mMatrix = new Matrix();
    } else {
        mMatrix.reset();
    }
    mAlpha = 1.0f;
    mTransformationType = TYPE_BOTH;
}
Body of Second Method:
{
    if (mMatrix == null) {
        mMatrix = new Matrix();
    } else {
        mMatrix.reset();
    }
    mClipRect.setEmpty();
    mHasClipRect = false;
    mAlpha = 1.0f;
    mTransformationType = TYPE_BOTH;
}
------------------------
Find a silently evolved API code:android.os.Process.myPpid:COMMENT
Method Modifier: public      static      final       hidden      
Comment:/**
 * Returns the identifier of this process' parent.
 * @hide
 */

Body of Frist Method:
{
    return Libcore.os.getppid();
}
Body of Second Method:
{
    return Os.getppid();
}
------------------------
Find a silently evolved API code:android.graphics.Picture.createFromStream:COMMENT
Method Modifier: public      static      deprecated  
Comment:/**
 * Create a new picture (already recorded) from the data in the stream. This
 * data was generated by a previous call to writeToStream(). Pictures that
 * have been persisted across device restarts are not guaranteed to decode
 * properly and are highly discouraged.
 *
 * <p>
 * <strong>Note:</strong> a picture created from an input stream cannot be
 * replayed on a hardware accelerated canvas.
 *
 * @see #writeToStream(java.io.OutputStream)
 * @deprecated The recommended alternative is to not use writeToStream and
 * instead draw the picture into a Bitmap from which you can persist it as
 * raw or compressed pixels.
 */

Body of Frist Method:
{
    return new Picture(nativeCreateFromStream(stream, new byte[WORKING_STREAM_STORAGE]), true);
}
Body of Second Method:
{
    return new Picture(nativeCreateFromStream(stream, new byte[WORKING_STREAM_STORAGE]));
}
------------------------
Find a silently evolved API code:android.ddm.DdmHandleHeap.handleHPGC:COMMENT
Method Modifier: private     
Comment:/*
     * Handle a "HeaP Garbage Collection" request.
     */

Body of Frist Method:
{
    if (false)
        Log.d("ddm-heap", "Heap GC request");
    System.gc();
    // empty response
    return null;
}
Body of Second Method:
{
    if (false)
        Log.d("ddm-heap", "Heap GC request");
    Runtime.getRuntime().gc();
    // empty response
    return null;
}
------------------------
Find a silently evolved API code:android.text.format.Time.format:COMMENT
Method Modifier: public      
Comment:/**
 * Print the current value given the format string provided. See man
 * strftime for what means what. The final string must be less than 256
 * characters.
 * @param format a string containing the desired format.
 * @return a String containing the current time expressed in the current locale.
 */

Body of Frist Method:
{
    synchronized (Time.class) {
        Locale locale = Locale.getDefault();
        if (sLocale == null || locale == null || !(locale.equals(sLocale))) {
            LocaleData localeData = LocaleData.get(locale);
            sAm = localeData.amPm[0];
            sPm = localeData.amPm[1];
            sZeroDigit = localeData.zeroDigit;
            sShortMonths = localeData.shortMonthNames;
            sLongMonths = localeData.longMonthNames;
            sLongStandaloneMonths = localeData.longStandAloneMonthNames;
            sShortWeekdays = localeData.shortWeekdayNames;
            sLongWeekdays = localeData.longWeekdayNames;
            Resources r = Resources.getSystem();
            sTimeOnlyFormat = r.getString(com.android.internal.R.string.time_of_day);
            sDateOnlyFormat = r.getString(com.android.internal.R.string.month_day_year);
            sDateTimeFormat = r.getString(com.android.internal.R.string.date_and_time);
            sLocale = locale;
        }
        String result = format1(format);
        if (sZeroDigit != '0') {
            result = localizeDigits(result);
        }
        return result;
    }
}
Body of Second Method:
{
    calculator.copyFieldsFromTime(this);
    return calculator.format(format);
}
------------------------
Find a silently evolved API code:android.util.SparseArray.put:COMMENT
Method Modifier: public      
Comment:/**
 * Adds a mapping from the specified key to the specified value,
 * replacing the previous mapping from the specified key if there
 * was one.
 */

Body of Frist Method:
{
    int i = ContainerHelpers.binarySearch(mKeys, mSize, key);
    if (i >= 0) {
        mValues[i] = value;
    } else {
        i = ~i;
        if (i < mSize && mValues[i] == DELETED) {
            mKeys[i] = key;
            mValues[i] = value;
            return;
        }
        if (mGarbage && mSize >= mKeys.length) {
            gc();
            // Search again because indices may have changed.
            i = ~ContainerHelpers.binarySearch(mKeys, mSize, key);
        }
        if (mSize >= mKeys.length) {
            int n = ArrayUtils.idealIntArraySize(mSize + 1);
            int[] nkeys = new int[n];
            Object[] nvalues = new Object[n];
            // Log.e("SparseArray", "grow " + mKeys.length + " to " + n);
            System.arraycopy(mKeys, 0, nkeys, 0, mKeys.length);
            System.arraycopy(mValues, 0, nvalues, 0, mValues.length);
            mKeys = nkeys;
            mValues = nvalues;
        }
        if (mSize - i != 0) {
            // Log.e("SparseArray", "move " + (mSize - i));
            System.arraycopy(mKeys, i, mKeys, i + 1, mSize - i);
            System.arraycopy(mValues, i, mValues, i + 1, mSize - i);
        }
        mKeys[i] = key;
        mValues[i] = value;
        mSize++;
    }
}
Body of Second Method:
{
    int i = ContainerHelpers.binarySearch(mKeys, mSize, key);
    if (i >= 0) {
        mValues[i] = value;
    } else {
        i = ~i;
        if (i < mSize && mValues[i] == DELETED) {
            mKeys[i] = key;
            mValues[i] = value;
            return;
        }
        if (mGarbage && mSize >= mKeys.length) {
            gc();
            // Search again because indices may have changed.
            i = ~ContainerHelpers.binarySearch(mKeys, mSize, key);
        }
        mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);
        mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);
        mSize++;
    }
}
------------------------
Find a silently evolved API code:android.widget.CalendarView.setFocusedMonthDateColor:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the color for the dates of the focused month.
 *
 * @param color The focused month date color.
 *
 * @attr ref android.R.styleable#CalendarView_focusedMonthDateColor
 */

Body of Frist Method:
{
    if (mFocusedMonthDateColor != color) {
        mFocusedMonthDateColor = color;
        final int childCount = mListView.getChildCount();
        for (int i = 0; i < childCount; i++) {
            WeekView weekView = (WeekView) mListView.getChildAt(i);
            if (weekView.mHasFocusedDay) {
                weekView.invalidate();
            }
        }
    }
}
Body of Second Method:
{
    mDelegate.setFocusedMonthDateColor(color);
}
------------------------
Find a silently evolved API code:android.provider.Settings.Secure.putIntForUser:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (LOCATION_MODE.equals(name)) {
        // TODO: once b/10491283 fixed, remove this hack
        return setLocationModeForUser(cr, value, userHandle);
    }
    return putStringForUser(cr, name, Integer.toString(value), userHandle);
}
Body of Second Method:
{
    return putStringForUser(cr, name, Integer.toString(value), userHandle);
}
------------------------
Find a silently evolved API code:android.content.res.TypedArray.getDimensionPixelOffset:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve a dimensional unit attribute at <var>index</var> for use
 * as an offset in raw pixels.  This is the same as
 * {@link #getDimension}, except the returned value is converted to
 * integer pixels for you.  An offset conversion involves simply
 * truncating the base value to an integer.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute dimension value multiplied by the appropriate
 * metric and truncated to integer pixels, or defValue if not defined.
 *
 * @see #getDimension
 * @see #getDimensionPixelSize
 */

Body of Frist Method:
{
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimensionPixelOffset(data[index + AssetManager.STYLE_DATA], mResources.mMetrics);
    }
    throw new UnsupportedOperationException("Can't convert to dimension: type=0x" + Integer.toHexString(type));
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimensionPixelOffset(data[index + AssetManager.STYLE_DATA], mMetrics);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        throw new RuntimeException("Failed to resolve attribute at index " + index);
    }
    throw new UnsupportedOperationException("Can't convert to dimension: type=0x" + Integer.toHexString(type));
}
------------------------
Find a silently evolved API code:android.view.inputmethod.InputMethodManager.clearBindingLocked:COMMENT
Method Modifier: default     
Comment:/**
 * Reset all of the state associated with being bound to an input method.
 */

Body of Frist Method:
{
    clearConnectionLocked();
    setInputChannelLocked(null);
    mBindSequence = -1;
    mCurId = null;
    mCurMethod = null;
}
Body of Second Method:
{
    if (DEBUG)
        Log.v(TAG, "Clearing binding!");
    clearConnectionLocked();
    setInputChannelLocked(null);
    mBindSequence = -1;
    mCurId = null;
    mCurMethod = null;
}
------------------------
Find a silently evolved API code:android.hardware.camera2.CameraCharacteristics.getAvailableCaptureRequestKeys:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the list of keys supported by this {@link CameraDevice} for querying
 * with a {@link CaptureRequest}.
 *
 * <p>The list returned is not modifiable, so any attempts to modify it will throw
 * a {@code UnsupportedOperationException}.</p>
 *
 * <p>Each key is only listed once in the list. The order of the keys is undefined.</p>
 *
 * <p>Note that there is no {@code getAvailableCameraCharacteristicsKeys()} -- use
 * {@link #getKeys()} instead.</p>
 *
 * @return List of keys supported by this CameraDevice for CaptureRequests.
 */

Body of Frist Method:
{
    if (mAvailableRequestKeys == null) {
        mAvailableRequestKeys = getAvailableKeyList(CaptureRequest.class);
    }
    return mAvailableRequestKeys;
}
Body of Second Method:
{
    if (mAvailableRequestKeys == null) {
        Object crKey = CaptureRequest.Key.class;
        Class<CaptureRequest.Key<?>> crKeyTyped = (Class<CaptureRequest.Key<?>>) crKey;
        int[] filterTags = get(REQUEST_AVAILABLE_REQUEST_KEYS);
        if (filterTags == null) {
            throw new AssertionError("android.request.availableRequestKeys must be non-null " + "in the characteristics");
        }
        mAvailableRequestKeys = getAvailableKeyList(CaptureRequest.class, crKeyTyped, filterTags);
    }
    return mAvailableRequestKeys;
}
------------------------
Find a silently evolved API code:android.widget.TextView.setError:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the right-hand compound drawable of the TextView to the "error"
 * icon and sets an error message that will be displayed in a popup when
 * the TextView has focus.  The icon and error message will be reset to
 * null when any key events cause changes to the TextView's text.  If the
 * <code>error</code> is <code>null</code>, the error message and icon
 * will be cleared.
 */

Body of Frist Method:
{
    if (error == null) {
        setError(null, null);
    } else {
        Drawable dr = getContext().getResources().getDrawable(com.android.internal.R.drawable.indicator_input_error);
        dr.setBounds(0, 0, dr.getIntrinsicWidth(), dr.getIntrinsicHeight());
        setError(error, dr);
    }
}
Body of Second Method:
{
    if (error == null) {
        setError(null, null);
    } else {
        Drawable dr = getContext().getDrawable(com.android.internal.R.drawable.indicator_input_error);
        dr.setBounds(0, 0, dr.getIntrinsicWidth(), dr.getIntrinsicHeight());
        setError(error, dr);
    }
}
------------------------
Find a silently evolved API code:android.animation.PropertyValuesHolder.init:COMMENT
Method Modifier: default     
Comment:/**
 * Internal function, called by ValueAnimator, to set up the TypeEvaluator that will be used
 * to calculate animated values.
 */

Body of Frist Method:
{
    if (mEvaluator == null) {
        // We already handle int and float automatically, but not their Object
        // equivalents
        mEvaluator = (mValueType == Integer.class) ? sIntEvaluator : (mValueType == Float.class) ? sFloatEvaluator : null;
    }
    if (mEvaluator != null) {
        // KeyframeSet knows how to evaluate the common types - only give it a custom
        // evaluator if one has been set on this class
        mKeyframeSet.setEvaluator(mEvaluator);
    }
}
Body of Second Method:
{
    if (mEvaluator == null) {
        // We already handle int and float automatically, but not their Object
        // equivalents
        mEvaluator = (mValueType == Integer.class) ? sIntEvaluator : (mValueType == Float.class) ? sFloatEvaluator : null;
    }
    if (mEvaluator != null) {
        // KeyframeSet knows how to evaluate the common types - only give it a custom
        // evaluator if one has been set on this class
        mKeyframes.setEvaluator(mEvaluator);
    }
}
------------------------
Find a silently evolved API code:android.app.KeyguardManager.exitKeyguardSecurely:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * @deprecated Use {@link android.view.WindowManager.LayoutParams#FLAG_DISMISS_KEYGUARD}
 * and/or {@link android.view.WindowManager.LayoutParams#FLAG_SHOW_WHEN_LOCKED}
 * instead; this allows you to seamlessly hide the keyguard as your application
 * moves in and out of the foreground and does not require that any special
 * permissions be requested.
 *
 * Exit the keyguard securely.  The use case for this api is that, after
 * disabling the keyguard, your app, which was granted permission to
 * disable the keyguard and show a limited amount of information deemed
 * safe without the user getting past the keyguard, needs to navigate to
 * something that is not safe to view without getting past the keyguard.
 *
 * This will, if the keyguard is secure, bring up the unlock screen of
 * the keyguard.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#DISABLE_KEYGUARD}.
 *
 * @param callback Let's you know whether the operation was succesful and
 * it is safe to launch anything that would normally be considered safe
 * once the user has gotten past the keyguard.
 */

Body of Frist Method:
{
    try {
        mWM.exitKeyguardSecurely(new IOnKeyguardExitResult.Stub() {

            public void onKeyguardExitResult(boolean success) throws RemoteException {
                callback.onKeyguardExitResult(success);
            }
        });
    } catch (RemoteException e) {
    }
}
Body of Second Method:
{
    try {
        mWM.exitKeyguardSecurely(new IOnKeyguardExitResult.Stub() {

            public void onKeyguardExitResult(boolean success) throws RemoteException {
                if (callback != null) {
                    callback.onKeyguardExitResult(success);
                }
            }
        });
    } catch (RemoteException e) {
    }
}
------------------------
Find a silently evolved API code:android.content.pm.PackageItemInfo.loadIcon:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the current graphical icon associated with this item.  This
 * will call back on the given PackageManager to load the icon from
 * the application.
 *
 * @param pm A PackageManager from which the icon can be loaded; usually
 * the PackageManager from which you originally retrieved this item.
 *
 * @return Returns a Drawable containing the item's icon.  If the
 * item does not have an icon, the item's default icon is returned
 * such as the default activity icon.
 */

Body of Frist Method:
{
    if (icon != 0) {
        Drawable dr = pm.getDrawable(packageName, icon, getApplicationInfo());
        if (dr != null) {
            return dr;
        }
    }
    return loadDefaultIcon(pm);
}
Body of Second Method:
{
    return pm.loadItemIcon(this, getApplicationInfo());
}
------------------------
Find a silently evolved API code:android.animation.LayoutTransition.setupChangeAnimation:COMMENT
Method Modifier: private     
Comment:/**
 * Utility function called by runChangingTransition for both the children and the parent
 * hierarchy.
 */

Body of Frist Method:
{
    // changes for the existing children in the container.
    if (layoutChangeListenerMap.get(child) != null) {
        return;
    }
    // on these views
    if (child.getWidth() == 0 && child.getHeight() == 0) {
        return;
    }
    // Make a copy of the appropriate animation
    final Animator anim = baseAnimator.clone();
    // Set the target object for the animation
    anim.setTarget(child);
    // A ObjectAnimator (or AnimatorSet of them) can extract start values from
    // its target object
    anim.setupStartValues();
    // If there's an animation running on this view already, cancel it
    Animator currentAnimation = pendingAnimations.get(child);
    if (currentAnimation != null) {
        currentAnimation.cancel();
        pendingAnimations.remove(child);
    }
    // Cache the animation in case we need to cancel it later
    pendingAnimations.put(child, anim);
    // For the animations which don't get started, we have to have a means of
    // removing them from the cache, lest we leak them and their target objects.
    // We run an animator for the default duration+100 (an arbitrary time, but one
    // which should far surpass the delay between setting them up here and
    // handling layout events which start them.
    ValueAnimator pendingAnimRemover = ValueAnimator.ofFloat(0f, 1f).setDuration(duration + 100);
    pendingAnimRemover.addListener(new AnimatorListenerAdapter() {

        @Override
        public void onAnimationEnd(Animator animation) {
            pendingAnimations.remove(child);
        }
    });
    pendingAnimRemover.start();
    // Add a listener to track layout changes on this view. If we don't get a callback,
    // then there's nothing to animate.
    final View.OnLayoutChangeListener listener = new View.OnLayoutChangeListener() {

        public void onLayoutChange(View v, int left, int top, int right, int bottom, int oldLeft, int oldTop, int oldRight, int oldBottom) {
            // Tell the animation to extract end values from the changed object
            anim.setupEndValues();
            if (anim instanceof ValueAnimator) {
                boolean valuesDiffer = false;
                ValueAnimator valueAnim = (ValueAnimator) anim;
                PropertyValuesHolder[] oldValues = valueAnim.getValues();
                for (int i = 0; i < oldValues.length; ++i) {
                    PropertyValuesHolder pvh = oldValues[i];
                    KeyframeSet keyframeSet = pvh.mKeyframeSet;
                    if (keyframeSet.mFirstKeyframe == null || keyframeSet.mLastKeyframe == null || !keyframeSet.mFirstKeyframe.getValue().equals(keyframeSet.mLastKeyframe.getValue())) {
                        valuesDiffer = true;
                    }
                }
                if (!valuesDiffer) {
                    return;
                }
            }
            long startDelay = 0;
            switch(changeReason) {
                case APPEARING:
                    startDelay = mChangingAppearingDelay + staggerDelay;
                    staggerDelay += mChangingAppearingStagger;
                    if (mChangingAppearingInterpolator != sChangingAppearingInterpolator) {
                        anim.setInterpolator(mChangingAppearingInterpolator);
                    }
                    break;
                case DISAPPEARING:
                    startDelay = mChangingDisappearingDelay + staggerDelay;
                    staggerDelay += mChangingDisappearingStagger;
                    if (mChangingDisappearingInterpolator != sChangingDisappearingInterpolator) {
                        anim.setInterpolator(mChangingDisappearingInterpolator);
                    }
                    break;
                case CHANGING:
                    startDelay = mChangingDelay + staggerDelay;
                    staggerDelay += mChangingStagger;
                    if (mChangingInterpolator != sChangingInterpolator) {
                        anim.setInterpolator(mChangingInterpolator);
                    }
                    break;
            }
            anim.setStartDelay(startDelay);
            anim.setDuration(duration);
            Animator prevAnimation = currentChangingAnimations.get(child);
            if (prevAnimation != null) {
                prevAnimation.cancel();
            }
            Animator pendingAnimation = pendingAnimations.get(child);
            if (pendingAnimation != null) {
                pendingAnimations.remove(child);
            }
            // Cache the animation in case we need to cancel it later
            currentChangingAnimations.put(child, anim);
            parent.requestTransitionStart(LayoutTransition.this);
            // this only removes listeners whose views changed - must clear the
            // other listeners later
            child.removeOnLayoutChangeListener(this);
            layoutChangeListenerMap.remove(child);
        }
    };
    // Remove the animation from the cache when it ends
    anim.addListener(new AnimatorListenerAdapter() {

        @Override
        public void onAnimationStart(Animator animator) {
            if (hasListeners()) {
                ArrayList<TransitionListener> listeners = (ArrayList<TransitionListener>) mListeners.clone();
                for (TransitionListener listener : listeners) {
                    listener.startTransition(LayoutTransition.this, parent, child, changeReason == APPEARING ? CHANGE_APPEARING : changeReason == DISAPPEARING ? CHANGE_DISAPPEARING : CHANGING);
                }
            }
        }

        @Override
        public void onAnimationCancel(Animator animator) {
            child.removeOnLayoutChangeListener(listener);
            layoutChangeListenerMap.remove(child);
        }

        @Override
        public void onAnimationEnd(Animator animator) {
            currentChangingAnimations.remove(child);
            if (hasListeners()) {
                ArrayList<TransitionListener> listeners = (ArrayList<TransitionListener>) mListeners.clone();
                for (TransitionListener listener : listeners) {
                    listener.endTransition(LayoutTransition.this, parent, child, changeReason == APPEARING ? CHANGE_APPEARING : changeReason == DISAPPEARING ? CHANGE_DISAPPEARING : CHANGING);
                }
            }
        }
    });
    child.addOnLayoutChangeListener(listener);
    // cache the listener for later removal
    layoutChangeListenerMap.put(child, listener);
}
Body of Second Method:
{
    // changes for the existing children in the container.
    if (layoutChangeListenerMap.get(child) != null) {
        return;
    }
    // on these views
    if (child.getWidth() == 0 && child.getHeight() == 0) {
        return;
    }
    // Make a copy of the appropriate animation
    final Animator anim = baseAnimator.clone();
    // Set the target object for the animation
    anim.setTarget(child);
    // A ObjectAnimator (or AnimatorSet of them) can extract start values from
    // its target object
    anim.setupStartValues();
    // If there's an animation running on this view already, cancel it
    Animator currentAnimation = pendingAnimations.get(child);
    if (currentAnimation != null) {
        currentAnimation.cancel();
        pendingAnimations.remove(child);
    }
    // Cache the animation in case we need to cancel it later
    pendingAnimations.put(child, anim);
    // For the animations which don't get started, we have to have a means of
    // removing them from the cache, lest we leak them and their target objects.
    // We run an animator for the default duration+100 (an arbitrary time, but one
    // which should far surpass the delay between setting them up here and
    // handling layout events which start them.
    ValueAnimator pendingAnimRemover = ValueAnimator.ofFloat(0f, 1f).setDuration(duration + 100);
    pendingAnimRemover.addListener(new AnimatorListenerAdapter() {

        @Override
        public void onAnimationEnd(Animator animation) {
            pendingAnimations.remove(child);
        }
    });
    pendingAnimRemover.start();
    // Add a listener to track layout changes on this view. If we don't get a callback,
    // then there's nothing to animate.
    final View.OnLayoutChangeListener listener = new View.OnLayoutChangeListener() {

        public void onLayoutChange(View v, int left, int top, int right, int bottom, int oldLeft, int oldTop, int oldRight, int oldBottom) {
            // Tell the animation to extract end values from the changed object
            anim.setupEndValues();
            if (anim instanceof ValueAnimator) {
                boolean valuesDiffer = false;
                ValueAnimator valueAnim = (ValueAnimator) anim;
                PropertyValuesHolder[] oldValues = valueAnim.getValues();
                for (int i = 0; i < oldValues.length; ++i) {
                    PropertyValuesHolder pvh = oldValues[i];
                    if (pvh.mKeyframes instanceof KeyframeSet) {
                        KeyframeSet keyframeSet = (KeyframeSet) pvh.mKeyframes;
                        if (keyframeSet.mFirstKeyframe == null || keyframeSet.mLastKeyframe == null || !keyframeSet.mFirstKeyframe.getValue().equals(keyframeSet.mLastKeyframe.getValue())) {
                            valuesDiffer = true;
                        }
                    } else if (!pvh.mKeyframes.getValue(0).equals(pvh.mKeyframes.getValue(1))) {
                        valuesDiffer = true;
                    }
                }
                if (!valuesDiffer) {
                    return;
                }
            }
            long startDelay = 0;
            switch(changeReason) {
                case APPEARING:
                    startDelay = mChangingAppearingDelay + staggerDelay;
                    staggerDelay += mChangingAppearingStagger;
                    if (mChangingAppearingInterpolator != sChangingAppearingInterpolator) {
                        anim.setInterpolator(mChangingAppearingInterpolator);
                    }
                    break;
                case DISAPPEARING:
                    startDelay = mChangingDisappearingDelay + staggerDelay;
                    staggerDelay += mChangingDisappearingStagger;
                    if (mChangingDisappearingInterpolator != sChangingDisappearingInterpolator) {
                        anim.setInterpolator(mChangingDisappearingInterpolator);
                    }
                    break;
                case CHANGING:
                    startDelay = mChangingDelay + staggerDelay;
                    staggerDelay += mChangingStagger;
                    if (mChangingInterpolator != sChangingInterpolator) {
                        anim.setInterpolator(mChangingInterpolator);
                    }
                    break;
            }
            anim.setStartDelay(startDelay);
            anim.setDuration(duration);
            Animator prevAnimation = currentChangingAnimations.get(child);
            if (prevAnimation != null) {
                prevAnimation.cancel();
            }
            Animator pendingAnimation = pendingAnimations.get(child);
            if (pendingAnimation != null) {
                pendingAnimations.remove(child);
            }
            // Cache the animation in case we need to cancel it later
            currentChangingAnimations.put(child, anim);
            parent.requestTransitionStart(LayoutTransition.this);
            // this only removes listeners whose views changed - must clear the
            // other listeners later
            child.removeOnLayoutChangeListener(this);
            layoutChangeListenerMap.remove(child);
        }
    };
    // Remove the animation from the cache when it ends
    anim.addListener(new AnimatorListenerAdapter() {

        @Override
        public void onAnimationStart(Animator animator) {
            if (hasListeners()) {
                ArrayList<TransitionListener> listeners = (ArrayList<TransitionListener>) mListeners.clone();
                for (TransitionListener listener : listeners) {
                    listener.startTransition(LayoutTransition.this, parent, child, changeReason == APPEARING ? CHANGE_APPEARING : changeReason == DISAPPEARING ? CHANGE_DISAPPEARING : CHANGING);
                }
            }
        }

        @Override
        public void onAnimationCancel(Animator animator) {
            child.removeOnLayoutChangeListener(listener);
            layoutChangeListenerMap.remove(child);
        }

        @Override
        public void onAnimationEnd(Animator animator) {
            currentChangingAnimations.remove(child);
            if (hasListeners()) {
                ArrayList<TransitionListener> listeners = (ArrayList<TransitionListener>) mListeners.clone();
                for (TransitionListener listener : listeners) {
                    listener.endTransition(LayoutTransition.this, parent, child, changeReason == APPEARING ? CHANGE_APPEARING : changeReason == DISAPPEARING ? CHANGE_DISAPPEARING : CHANGING);
                }
            }
        }
    });
    child.addOnLayoutChangeListener(listener);
    // cache the listener for later removal
    layoutChangeListenerMap.put(child, listener);
}
------------------------
Find a silently evolved API code:android.graphics.Bitmap.setPixels:COMMENT
Method Modifier: public      
Comment:/**
 * <p>Replace pixels in the bitmap with the colors in the array. Each element
 * in the array is a packed int prepresenting a non-premultiplied ARGB
 * {@link Color}.</p>
 *
 * @param pixels   The colors to write to the bitmap
 * @param offset   The index of the first color to read from pixels[]
 * @param stride   The number of colors in pixels[] to skip between rows.
 * Normally this value will be the same as the width of
 * the bitmap, but it can be larger (or negative).
 * @param x        The x coordinate of the first pixel to write to in
 * the bitmap.
 * @param y        The y coordinate of the first pixel to write to in
 * the bitmap.
 * @param width    The number of colors to copy from pixels[] per row
 * @param height   The number of rows to write to the bitmap
 *
 * @throws IllegalStateException if the bitmap is not mutable
 * @throws IllegalArgumentException if x, y, width, height are outside of
 * the bitmap's bounds.
 * @throws ArrayIndexOutOfBoundsException if the pixels array is too small
 * to receive the specified number of pixels.
 */

Body of Frist Method:
{
    checkRecycled("Can't call setPixels() on a recycled bitmap");
    if (!isMutable()) {
        throw new IllegalStateException();
    }
    if (width == 0 || height == 0) {
        // nothing to do
        return;
    }
    checkPixelsAccess(x, y, width, height, offset, stride, pixels);
    nativeSetPixels(mNativeBitmap, pixels, offset, stride, x, y, width, height, mIsPremultiplied);
}
Body of Second Method:
{
    checkRecycled("Can't call setPixels() on a recycled bitmap");
    if (!isMutable()) {
        throw new IllegalStateException();
    }
    if (width == 0 || height == 0) {
        // nothing to do
        return;
    }
    checkPixelsAccess(x, y, width, height, offset, stride, pixels);
    nativeSetPixels(mNativeBitmap, pixels, offset, stride, x, y, width, height);
}
------------------------
Find a silently evolved API code:android.util.Spline.interpolate:COMMENT
<android.util.Spline: float interpolate(float)>
public      hidden      ->public      abstract    hidden      
Method Modifier: public      abstract    hidden      
Method Modifier: Yes         No          Yes         
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * Interpolates the value of Y = f(X) for given X.
 * Clamps X to the domain of the spline.
 *
 * @param x The X value.
 * @return The interpolated Y = f(X) value.
 */

Body of Frist Method:
{
    // Handle the boundary cases.
    final int n = mX.length;
    if (Float.isNaN(x)) {
        return x;
    }
    if (x <= mX[0]) {
        return mY[0];
    }
    if (x >= mX[n - 1]) {
        return mY[n - 1];
    }
    // Find the index 'i' of the last point with smaller X.
    // We know this will be within the spline due to the boundary tests.
    int i = 0;
    while (x >= mX[i + 1]) {
        i += 1;
        if (x == mX[i]) {
            return mY[i];
        }
    }
    // Perform cubic Hermite spline interpolation.
    float h = mX[i + 1] - mX[i];
    float t = (x - mX[i]) / h;
    return (mY[i] * (1 + 2 * t) + h * mM[i] * t) * (1 - t) * (1 - t) + (mY[i + 1] * (3 - 2 * t) + h * mM[i + 1] * (t - 1)) * t * t;
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.media.Ringtone.stop:COMMENT
Method Modifier: public      
Comment:/**
 * Stops a playing ringtone.
 */

Body of Frist Method:
{
    if (mLocalPlayer != null) {
        destroyLocalPlayer();
    } else if (mAllowRemote) {
        try {
            mRemotePlayer.stop(mRemoteToken);
        } catch (RemoteException e) {
            Log.w(TAG, "Problem stopping ringtone: " + e);
        }
    }
}
Body of Second Method:
{
    if (mLocalPlayer != null) {
        destroyLocalPlayer();
    } else if (mAllowRemote && (mRemotePlayer != null)) {
        try {
            mRemotePlayer.stop(mRemoteToken);
        } catch (RemoteException e) {
            Log.w(TAG, "Problem stopping ringtone: " + e);
        }
    }
}
------------------------
Find a silently evolved API code:android.widget.ListPopupWindow.ForwardingListener.onTouchForwarded:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Handled forwarded motion events and determines when to stop
 * forwarding.
 *
 * @param srcEvent motion event in source view coordinates
 * @return true to continue forwarding motion events, false to cancel
 */

Body of Frist Method:
{
    final View src = mSrc;
    final ListPopupWindow popup = getPopup();
    if (popup == null || !popup.isShowing()) {
        return false;
    }
    final DropDownListView dst = popup.mDropDownList;
    if (dst == null || !dst.isShown()) {
        return false;
    }
    // Convert event to destination-local coordinates.
    final MotionEvent dstEvent = MotionEvent.obtainNoHistory(srcEvent);
    src.toGlobalMotionEvent(dstEvent);
    dst.toLocalMotionEvent(dstEvent);
    // Forward converted event to destination view, then recycle it.
    final boolean handled = dst.onForwardedEvent(dstEvent, mActivePointerId);
    dstEvent.recycle();
    return handled;
}
Body of Second Method:
{
    final View src = mSrc;
    final ListPopupWindow popup = getPopup();
    if (popup == null || !popup.isShowing()) {
        return false;
    }
    final DropDownListView dst = popup.mDropDownList;
    if (dst == null || !dst.isShown()) {
        return false;
    }
    // Convert event to destination-local coordinates.
    final MotionEvent dstEvent = MotionEvent.obtainNoHistory(srcEvent);
    src.toGlobalMotionEvent(dstEvent);
    dst.toLocalMotionEvent(dstEvent);
    // Forward converted event to destination view, then recycle it.
    final boolean handled = dst.onForwardedEvent(dstEvent, mActivePointerId);
    dstEvent.recycle();
    // Always cancel forwarding when the touch stream ends.
    final int action = srcEvent.getActionMasked();
    final boolean keepForwarding = action != MotionEvent.ACTION_UP && action != MotionEvent.ACTION_CANCEL;
    return handled && keepForwarding;
}
------------------------
Find a silently evolved API code:android.content.SyncRequest.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Performs validation over the request and throws the runtime exception
 * <code>IllegalArgumentException</code> if this validation fails.
 *
 * @return a SyncRequest with the information contained within this
 * builder.
 */

Body of Frist Method:
{
    if (mCustomExtras == null) {
        mCustomExtras = new Bundle();
    }
    // Validate the extras bundle
    ContentResolver.validateSyncExtrasBundle(mCustomExtras);
    // Combine builder extra flags into the config bundle.
    mSyncConfigExtras = new Bundle();
    if (mIgnoreBackoff) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_IGNORE_BACKOFF, true);
    }
    if (mDisallowMetered) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_DISALLOW_METERED, true);
    }
    if (mIgnoreSettings) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_IGNORE_SETTINGS, true);
    }
    if (mNoRetry) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_DO_NOT_RETRY, true);
    }
    if (mExpedited) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_EXPEDITED, true);
    }
    if (mIsManual) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_MANUAL, true);
    }
    mSyncConfigExtras.putLong(ContentResolver.SYNC_EXTRAS_EXPECTED_UPLOAD, mTxBytes);
    mSyncConfigExtras.putLong(ContentResolver.SYNC_EXTRAS_EXPECTED_DOWNLOAD, mRxBytes);
    mSyncConfigExtras.putInt(ContentResolver.SYNC_EXTRAS_PRIORITY, mPriority);
    if (mSyncType == SYNC_TYPE_PERIODIC) {
        // If this is a periodic sync ensure than invalid extras were not set.
        validatePeriodicExtras(mCustomExtras);
        validatePeriodicExtras(mSyncConfigExtras);
        // Verify that account and provider are not null.
        if (mAccount == null) {
            throw new IllegalArgumentException("Account must not be null for periodic" + " sync.");
        }
        if (mAuthority == null) {
            throw new IllegalArgumentException("Authority must not be null for periodic" + " sync.");
        }
    } else if (mSyncType == SYNC_TYPE_UNKNOWN) {
        throw new IllegalArgumentException("Must call either syncOnce() or syncPeriodic()");
    }
    // Ensure that a target for the sync has been set.
    if (mSyncTarget == SYNC_TARGET_UNKNOWN) {
        throw new IllegalArgumentException("Must specify an adapter with " + "setSyncAdapter(Account, String");
    }
    return new SyncRequest(this);
}
Body of Second Method:
{
    // Validate the extras bundle
    ContentResolver.validateSyncExtrasBundle(mCustomExtras);
    if (mCustomExtras == null) {
        mCustomExtras = new Bundle();
    }
    // Combine builder extra flags into the config bundle.
    mSyncConfigExtras = new Bundle();
    if (mIgnoreBackoff) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_IGNORE_BACKOFF, true);
    }
    if (mDisallowMetered) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_DISALLOW_METERED, true);
    }
    if (mIgnoreSettings) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_IGNORE_SETTINGS, true);
    }
    if (mNoRetry) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_DO_NOT_RETRY, true);
    }
    if (mExpedited) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_EXPEDITED, true);
    }
    if (mIsManual) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_IGNORE_BACKOFF, true);
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_IGNORE_SETTINGS, true);
    }
    if (mSyncType == SYNC_TYPE_PERIODIC) {
        // If this is a periodic sync ensure than invalid extras were not set.
        if (ContentResolver.invalidPeriodicExtras(mCustomExtras) || ContentResolver.invalidPeriodicExtras(mSyncConfigExtras)) {
            throw new IllegalArgumentException("Illegal extras were set");
        }
    }
    // Ensure that a target for the sync has been set.
    if (mSyncTarget == SYNC_TARGET_UNKNOWN) {
        throw new IllegalArgumentException("Must specify an adapter with" + " setSyncAdapter(Account, String");
    }
    return new SyncRequest(this);
}
------------------------
Find a silently evolved API code:android.media.MediaCodecInfo.getSupportedTypes:COMMENT
Method Modifier: public      final       
Comment:/**
 * Query the media types supported by the codec.
 */

Body of Frist Method:
{
    return MediaCodecList.getSupportedTypes(mIndex);
}
Body of Second Method:
{
    Set<String> typeSet = mCaps.keySet();
    String[] types = typeSet.toArray(new String[typeSet.size()]);
    Arrays.sort(types);
    return types;
}
------------------------
Find a silently evolved API code:android.media.MediaFocusControl.dumpRCStack:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Helper function:
 * Display in the log the current entries in the remote control focus stack
 */

Body of Frist Method:
{
    pw.println("\nRemote Control stack entries (last is top of stack):");
    synchronized (mRCStack) {
        Iterator<RemoteControlStackEntry> stackIterator = mRCStack.iterator();
        while (stackIterator.hasNext()) {
            RemoteControlStackEntry rcse = stackIterator.next();
            pw.println("  pi: " + rcse.mMediaIntent + " -- pack: " + rcse.mCallingPackageName + "  -- ercvr: " + rcse.mReceiverComponent + "  -- client: " + rcse.mRcClient + "  -- uid: " + rcse.mCallingUid + "  -- type: " + rcse.mPlaybackType + "  state: " + rcse.mPlaybackState);
        }
    }
}
Body of Second Method:
{
    pw.println("\nRemote Control stack entries (last is top of stack):");
    synchronized (mPRStack) {
        Iterator<PlayerRecord> stackIterator = mPRStack.iterator();
        while (stackIterator.hasNext()) {
            stackIterator.next().dump(pw, true);
        }
    }
}
------------------------
Find a silently evolved API code:android.text.TextLine.drawTextRun:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Render a text run with the set-up paint.
 *
 * @param c the canvas
 * @param wp the paint used to render the text
 * @param start the start of the run
 * @param end the end of the run
 * @param contextStart the start of context for the run
 * @param contextEnd the end of the context for the run
 * @param runIsRtl true if the run is right-to-left
 * @param x the x position of the left edge of the run
 * @param y the baseline of the run
 */

Body of Frist Method:
{
    int flags = runIsRtl ? Canvas.DIRECTION_RTL : Canvas.DIRECTION_LTR;
    if (mCharsValid) {
        int count = end - start;
        int contextCount = contextEnd - contextStart;
        c.drawTextRun(mChars, start, count, contextStart, contextCount, x, y, flags, wp);
    } else {
        int delta = mStart;
        c.drawTextRun(mText, delta + start, delta + end, delta + contextStart, delta + contextEnd, x, y, flags, wp);
    }
}
Body of Second Method:
{
    if (mCharsValid) {
        int count = end - start;
        int contextCount = contextEnd - contextStart;
        c.drawTextRun(mChars, start, count, contextStart, contextCount, x, y, runIsRtl, wp);
    } else {
        int delta = mStart;
        c.drawTextRun(mText, delta + start, delta + end, delta + contextStart, delta + contextEnd, x, y, runIsRtl, wp);
    }
}
------------------------
Find a silently evolved API code:android.widget.TextView.paste:COMMENT
Method Modifier: private     
Comment:/**
 * Paste clipboard content between min and max positions.
 */

Body of Frist Method:
{
    ClipboardManager clipboard = (ClipboardManager) getContext().getSystemService(Context.CLIPBOARD_SERVICE);
    ClipData clip = clipboard.getPrimaryClip();
    if (clip != null) {
        boolean didFirst = false;
        for (int i = 0; i < clip.getItemCount(); i++) {
            CharSequence paste = clip.getItemAt(i).coerceToStyledText(getContext());
            if (paste != null) {
                if (!didFirst) {
                    long minMax = prepareSpacesAroundPaste(min, max, paste);
                    min = TextUtils.unpackRangeStartFromLong(minMax);
                    max = TextUtils.unpackRangeEndFromLong(minMax);
                    Selection.setSelection((Spannable) mText, max);
                    ((Editable) mText).replace(min, max, paste);
                    didFirst = true;
                } else {
                    ((Editable) mText).insert(getSelectionEnd(), "\n");
                    ((Editable) mText).insert(getSelectionEnd(), paste);
                }
            }
        }
        stopSelectionActionMode();
        LAST_CUT_OR_COPY_TIME = 0;
    }
}
Body of Second Method:
{
    ClipboardManager clipboard = (ClipboardManager) getContext().getSystemService(Context.CLIPBOARD_SERVICE);
    ClipData clip = clipboard.getPrimaryClip();
    if (clip != null) {
        boolean didFirst = false;
        for (int i = 0; i < clip.getItemCount(); i++) {
            CharSequence paste = clip.getItemAt(i).coerceToStyledText(getContext());
            if (paste != null) {
                if (!didFirst) {
                    Selection.setSelection((Spannable) mText, max);
                    ((Editable) mText).replace(min, max, paste);
                    didFirst = true;
                } else {
                    ((Editable) mText).insert(getSelectionEnd(), "\n");
                    ((Editable) mText).insert(getSelectionEnd(), paste);
                }
            }
        }
        stopSelectionActionMode();
        LAST_CUT_OR_COPY_TIME = 0;
    }
}
------------------------
Find a silently evolved API code:android.view.accessibility.AccessibilityNodeInfo.init:COMMENT
Method Modifier: private     
Comment:/**
 * Initializes this instance from another one.
 *
 * @param other The other instance.
 */

Body of Frist Method:
{
    mSealed = other.mSealed;
    mSourceNodeId = other.mSourceNodeId;
    mParentNodeId = other.mParentNodeId;
    mLabelForId = other.mLabelForId;
    mLabeledById = other.mLabeledById;
    mWindowId = other.mWindowId;
    mConnectionId = other.mConnectionId;
    mBoundsInParent.set(other.mBoundsInParent);
    mBoundsInScreen.set(other.mBoundsInScreen);
    mPackageName = other.mPackageName;
    mClassName = other.mClassName;
    mText = other.mText;
    mContentDescription = other.mContentDescription;
    mViewIdResourceName = other.mViewIdResourceName;
    mActions = other.mActions;
    mBooleanProperties = other.mBooleanProperties;
    mMovementGranularities = other.mMovementGranularities;
    final int otherChildIdCount = other.mChildNodeIds.size();
    for (int i = 0; i < otherChildIdCount; i++) {
        mChildNodeIds.put(i, other.mChildNodeIds.valueAt(i));
    }
    mTextSelectionStart = other.mTextSelectionStart;
    mTextSelectionEnd = other.mTextSelectionEnd;
    mInputType = other.mInputType;
    mLiveRegion = other.mLiveRegion;
    if (other.mExtras != null && !other.mExtras.isEmpty()) {
        getExtras().putAll(other.mExtras);
    }
    mRangeInfo = (other.mRangeInfo != null) ? RangeInfo.obtain(other.mRangeInfo) : null;
    mCollectionInfo = (other.mCollectionInfo != null) ? CollectionInfo.obtain(other.mCollectionInfo) : null;
    mCollectionItemInfo = (other.mCollectionItemInfo != null) ? CollectionItemInfo.obtain(other.mCollectionItemInfo) : null;
}
Body of Second Method:
{
    mSealed = other.mSealed;
    mSourceNodeId = other.mSourceNodeId;
    mParentNodeId = other.mParentNodeId;
    mLabelForId = other.mLabelForId;
    mLabeledById = other.mLabeledById;
    mWindowId = other.mWindowId;
    mConnectionId = other.mConnectionId;
    mBoundsInParent.set(other.mBoundsInParent);
    mBoundsInScreen.set(other.mBoundsInScreen);
    mPackageName = other.mPackageName;
    mClassName = other.mClassName;
    mText = other.mText;
    mError = other.mError;
    mContentDescription = other.mContentDescription;
    mViewIdResourceName = other.mViewIdResourceName;
    final ArrayList<AccessibilityAction> otherActions = other.mActions;
    if (otherActions != null && otherActions.size() > 0) {
        if (mActions == null) {
            mActions = new ArrayList(otherActions);
        } else {
            mActions.clear();
            mActions.addAll(other.mActions);
        }
    }
    mBooleanProperties = other.mBooleanProperties;
    mMaxTextLength = other.mMaxTextLength;
    mMovementGranularities = other.mMovementGranularities;
    final LongArray otherChildNodeIds = other.mChildNodeIds;
    if (otherChildNodeIds != null && otherChildNodeIds.size() > 0) {
        if (mChildNodeIds == null) {
            mChildNodeIds = otherChildNodeIds.clone();
        } else {
            mChildNodeIds.clear();
            mChildNodeIds.addAll(otherChildNodeIds);
        }
    }
    mTextSelectionStart = other.mTextSelectionStart;
    mTextSelectionEnd = other.mTextSelectionEnd;
    mInputType = other.mInputType;
    mLiveRegion = other.mLiveRegion;
    if (other.mExtras != null && !other.mExtras.isEmpty()) {
        getExtras().putAll(other.mExtras);
    }
    mRangeInfo = (other.mRangeInfo != null) ? RangeInfo.obtain(other.mRangeInfo) : null;
    mCollectionInfo = (other.mCollectionInfo != null) ? CollectionInfo.obtain(other.mCollectionInfo) : null;
    mCollectionItemInfo = (other.mCollectionItemInfo != null) ? CollectionItemInfo.obtain(other.mCollectionItemInfo) : null;
}
------------------------
Find a silently evolved API code:android.widget.TimePicker.setCurrentMinute:COMMENT
Method Modifier: public      
Comment:/**
 * Set the current minute (0-59).
 */

Body of Frist Method:
{
    if (currentMinute == getCurrentMinute()) {
        return;
    }
    mMinuteSpinner.setValue(currentMinute);
    onTimeChanged();
}
Body of Second Method:
{
    mDelegate.setCurrentMinute(currentMinute);
}
------------------------
Find a silently evolved API code:android.content.pm.PackageManager.getPackageArchiveInfo:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve overall information about an application package defined
 * in a package archive file
 *
 * @param archiveFilePath The path to the archive file
 * @param flags Additional option flags. Use any combination of
 * {@link #GET_ACTIVITIES},
 * {@link #GET_GIDS},
 * {@link #GET_CONFIGURATIONS},
 * {@link #GET_INSTRUMENTATION},
 * {@link #GET_PERMISSIONS},
 * {@link #GET_PROVIDERS},
 * {@link #GET_RECEIVERS},
 * {@link #GET_SERVICES},
 * {@link #GET_SIGNATURES}, to modify the data returned.
 *
 * @return Returns the information about the package. Returns
 * null if the package could not be successfully parsed.
 *
 * @see #GET_ACTIVITIES
 * @see #GET_GIDS
 * @see #GET_CONFIGURATIONS
 * @see #GET_INSTRUMENTATION
 * @see #GET_PERMISSIONS
 * @see #GET_PROVIDERS
 * @see #GET_RECEIVERS
 * @see #GET_SERVICES
 * @see #GET_SIGNATURES
 */

Body of Frist Method:
{
    PackageParser packageParser = new PackageParser(archiveFilePath);
    DisplayMetrics metrics = new DisplayMetrics();
    metrics.setToDefaults();
    final File sourceFile = new File(archiveFilePath);
    PackageParser.Package pkg = packageParser.parsePackage(sourceFile, archiveFilePath, metrics, 0);
    if (pkg == null) {
        return null;
    }
    if ((flags & GET_SIGNATURES) != 0) {
        packageParser.collectCertificates(pkg, 0);
    }
    PackageUserState state = new PackageUserState();
    return PackageParser.generatePackageInfo(pkg, null, flags, 0, 0, null, state);
}
Body of Second Method:
{
    final PackageParser parser = new PackageParser();
    final File apkFile = new File(archiveFilePath);
    try {
        PackageParser.Package pkg = parser.parseMonolithicPackage(apkFile, 0);
        if ((flags & GET_SIGNATURES) != 0) {
            parser.collectCertificates(pkg, 0);
            parser.collectManifestDigest(pkg);
        }
        PackageUserState state = new PackageUserState();
        return PackageParser.generatePackageInfo(pkg, null, flags, 0, 0, null, state);
    } catch (PackageParserException e) {
        return null;
    }
}
------------------------
Find a silently evolved API code:android.app.Activity.performSaveInstanceState:COMMENT
Method Modifier: default     final       
Comment:/**
 * The hook for {@link ActivityThread} to save the state of this activity.
 *
 * Calls {@link #onSaveInstanceState(android.os.Bundle)}
 * and {@link #saveManagedDialogs(android.os.Bundle)}.
 *
 * @param outState The bundle to save the state to.
 */

Body of Frist Method:
{
    onSaveInstanceState(outState);
    saveManagedDialogs(outState);
    if (DEBUG_LIFECYCLE)
        Slog.v(TAG, "onSaveInstanceState " + this + ": " + outState);
}
Body of Second Method:
{
    onSaveInstanceState(outState);
    saveManagedDialogs(outState);
    mActivityTransitionState.saveState(outState);
    if (DEBUG_LIFECYCLE)
        Slog.v(TAG, "onSaveInstanceState " + this + ": " + outState);
}
------------------------
Find a silently evolved API code:android.graphics.BidiRenderer.setScriptFont:COMMENT
Method Modifier: private     static      
Comment:// TODO: Replace this method with one which returns the font based on the scriptCode.

Body of Frist Method:
{
    for (FontInfo fontInfo : fonts) {
        if (fontInfo.mFont.canDisplayUpTo(text, run.start, run.limit) == -1) {
            run.font = fontInfo;
            return;
        }
    }
    run.font = fonts.get(0);
}
Body of Second Method:
{
    for (Font font : fonts) {
        if (font == null) {
            logFontWarning();
            continue;
        }
        if (font.canDisplayUpTo(text, run.start, run.limit) == -1) {
            run.font = font;
            return;
        }
    }
    run.font = fonts.get(0);
}
------------------------
Find a silently evolved API code:android.media.AudioManager.preDispatchKeyEvent:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    /*
         * If the user hits another key within the play sound delay, then
         * cancel the sound
         */
    int keyCode = event.getKeyCode();
    if (keyCode != KeyEvent.KEYCODE_VOLUME_DOWN && keyCode != KeyEvent.KEYCODE_VOLUME_UP && keyCode != KeyEvent.KEYCODE_VOLUME_MUTE && mVolumeKeyUpTime + VolumePanel.PLAY_SOUND_DELAY > SystemClock.uptimeMillis()) {
        /*
             * The user has hit another key during the delay (e.g., 300ms)
             * since the last volume key up, so cancel any sounds.
             */
        if (mUseMasterVolume) {
            adjustMasterVolume(ADJUST_SAME, AudioManager.FLAG_REMOVE_SOUND_AND_VIBRATE);
        } else {
            adjustSuggestedStreamVolume(ADJUST_SAME, stream, AudioManager.FLAG_REMOVE_SOUND_AND_VIBRATE);
        }
    }
}
Body of Second Method:
{
    /*
         * If the user hits another key within the play sound delay, then
         * cancel the sound
         */
    int keyCode = event.getKeyCode();
    if (keyCode != KeyEvent.KEYCODE_VOLUME_DOWN && keyCode != KeyEvent.KEYCODE_VOLUME_UP && keyCode != KeyEvent.KEYCODE_VOLUME_MUTE && mVolumeKeyUpTime + AudioService.PLAY_SOUND_DELAY > SystemClock.uptimeMillis()) {
        /*
             * The user has hit another key during the delay (e.g., 300ms)
             * since the last volume key up, so cancel any sounds.
             */
        if (mUseMasterVolume) {
            adjustMasterVolume(ADJUST_SAME, AudioManager.FLAG_REMOVE_SOUND_AND_VIBRATE);
        } else {
            adjustSuggestedStreamVolume(ADJUST_SAME, stream, AudioManager.FLAG_REMOVE_SOUND_AND_VIBRATE);
        }
    }
}
------------------------
Find a silently evolved API code:android.content.pm.PermissionInfo.protectionToString:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    String protLevel = "????";
    switch(level & PROTECTION_MASK_BASE) {
        case PermissionInfo.PROTECTION_DANGEROUS:
            protLevel = "dangerous";
            break;
        case PermissionInfo.PROTECTION_NORMAL:
            protLevel = "normal";
            break;
        case PermissionInfo.PROTECTION_SIGNATURE:
            protLevel = "signature";
            break;
        case PermissionInfo.PROTECTION_SIGNATURE_OR_SYSTEM:
            protLevel = "signatureOrSystem";
            break;
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_SYSTEM) != 0) {
        protLevel += "|system";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_DEVELOPMENT) != 0) {
        protLevel += "|development";
    }
    return protLevel;
}
Body of Second Method:
{
    String protLevel = "????";
    switch(level & PROTECTION_MASK_BASE) {
        case PermissionInfo.PROTECTION_DANGEROUS:
            protLevel = "dangerous";
            break;
        case PermissionInfo.PROTECTION_NORMAL:
            protLevel = "normal";
            break;
        case PermissionInfo.PROTECTION_SIGNATURE:
            protLevel = "signature";
            break;
        case PermissionInfo.PROTECTION_SIGNATURE_OR_SYSTEM:
            protLevel = "signatureOrSystem";
            break;
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_SYSTEM) != 0) {
        protLevel += "|system";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_DEVELOPMENT) != 0) {
        protLevel += "|development";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_APPOP) != 0) {
        protLevel += "|appop";
    }
    return protLevel;
}
------------------------
Find a silently evolved API code:android.graphics.drawable.ColorDrawable.mutate:COMMENT
Method Modifier: public      
Comment:/**
 * A mutable BitmapDrawable still shares its Bitmap with any other Drawable
 * that comes from the same resource.
 *
 * @return This drawable.
 */

Body of Frist Method:
{
    if (!mMutated && super.mutate() == this) {
        mState = new ColorState(mState);
        mMutated = true;
    }
    return this;
}
Body of Second Method:
{
    if (!mMutated && super.mutate() == this) {
        mColorState = new ColorState(mColorState);
        mMutated = true;
    }
    return this;
}
------------------------
Find a silently evolved API code:android.view.Surface.copyFrom:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Copy another surface to this one.  This surface now holds a reference
 * to the same data as the original surface, and is -not- the owner.
 * This is for use by the window manager when returning a window surface
 * back from a client, converting it from the representation being managed
 * by the window manager to the representation the client uses to draw
 * in to it.
 * @hide
 */

Body of Frist Method:
{
    if (other == null) {
        throw new IllegalArgumentException("other must not be null");
    }
    int surfaceControlPtr = other.mNativeObject;
    if (surfaceControlPtr == 0) {
        throw new NullPointerException("SurfaceControl native object is null. Are you using a released SurfaceControl?");
    }
    int newNativeObject = nativeCreateFromSurfaceControl(surfaceControlPtr);
    synchronized (mLock) {
        if (mNativeObject != 0) {
            nativeRelease(mNativeObject);
        }
        setNativeObjectLocked(newNativeObject);
    }
}
Body of Second Method:
{
    if (other == null) {
        throw new IllegalArgumentException("other must not be null");
    }
    long surfaceControlPtr = other.mNativeObject;
    if (surfaceControlPtr == 0) {
        throw new NullPointerException("SurfaceControl native object is null. Are you using a released SurfaceControl?");
    }
    long newNativeObject = nativeCreateFromSurfaceControl(surfaceControlPtr);
    synchronized (mLock) {
        if (mNativeObject != 0) {
            nativeRelease(mNativeObject);
        }
        setNativeObjectLocked(newNativeObject);
    }
}
------------------------
Find a silently evolved API code:android.animation.PropertyValuesHolder.setupSetterAndGetter:COMMENT
Method Modifier: default     
Comment:/**
 * Internal function (called from ObjectAnimator) to set up the setter and getter
 * prior to running the animation. If the setter has not been manually set for this
 * object, it will be derived automatically given the property name, target object, and
 * types of values supplied. If no getter has been set, it will be supplied iff any of the
 * supplied values was null. If there is a null value, then the getter (supplied or derived)
 * will be called to set those null values to the current value of the property
 * on the target object.
 * @param target The object on which the setter (and possibly getter) exist.
 */

Body of Frist Method:
{
    if (mProperty != null) {
        // check to make sure that mProperty is on the class of target
        try {
            Object testValue = mProperty.get(target);
            for (Keyframe kf : mKeyframeSet.mKeyframes) {
                if (!kf.hasValue()) {
                    kf.setValue(mProperty.get(target));
                }
            }
            return;
        } catch (ClassCastException e) {
            Log.w("PropertyValuesHolder", "No such property (" + mProperty.getName() + ") on target object " + target + ". Trying reflection instead");
            mProperty = null;
        }
    }
    Class targetClass = target.getClass();
    if (mSetter == null) {
        setupSetter(targetClass);
    }
    for (Keyframe kf : mKeyframeSet.mKeyframes) {
        if (!kf.hasValue()) {
            if (mGetter == null) {
                setupGetter(targetClass);
                if (mGetter == null) {
                    // Already logged the error - just return to avoid NPE
                    return;
                }
            }
            try {
                kf.setValue(mGetter.invoke(target));
            } catch (InvocationTargetException e) {
                Log.e("PropertyValuesHolder", e.toString());
            } catch (IllegalAccessException e) {
                Log.e("PropertyValuesHolder", e.toString());
            }
        }
    }
}
Body of Second Method:
{
    mKeyframes.invalidateCache();
    if (mProperty != null) {
        // check to make sure that mProperty is on the class of target
        try {
            Object testValue = null;
            ArrayList<Keyframe> keyframes = mKeyframes.getKeyframes();
            int keyframeCount = keyframes == null ? 0 : keyframes.size();
            for (int i = 0; i < keyframeCount; i++) {
                Keyframe kf = keyframes.get(i);
                if (!kf.hasValue() || kf.valueWasSetOnStart()) {
                    if (testValue == null) {
                        testValue = convertBack(mProperty.get(target));
                    }
                    kf.setValue(testValue);
                    kf.setValueWasSetOnStart(true);
                }
            }
            return;
        } catch (ClassCastException e) {
            Log.w("PropertyValuesHolder", "No such property (" + mProperty.getName() + ") on target object " + target + ". Trying reflection instead");
            mProperty = null;
        }
    }
    Class targetClass = target.getClass();
    if (mSetter == null) {
        setupSetter(targetClass);
    }
    ArrayList<Keyframe> keyframes = mKeyframes.getKeyframes();
    int keyframeCount = keyframes == null ? 0 : keyframes.size();
    for (int i = 0; i < keyframeCount; i++) {
        Keyframe kf = keyframes.get(i);
        if (!kf.hasValue() || kf.valueWasSetOnStart()) {
            if (mGetter == null) {
                setupGetter(targetClass);
                if (mGetter == null) {
                    // Already logged the error - just return to avoid NPE
                    return;
                }
            }
            try {
                Object value = convertBack(mGetter.invoke(target));
                kf.setValue(value);
                kf.setValueWasSetOnStart(true);
            } catch (InvocationTargetException e) {
                Log.e("PropertyValuesHolder", e.toString());
            } catch (IllegalAccessException e) {
                Log.e("PropertyValuesHolder", e.toString());
            }
        }
    }
}
------------------------
Find a silently evolved API code:android.content.res.TypedArray.getInteger:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the integer value for the attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute integer value, or defValue if not defined.
 */

Body of Frist Method:
{
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + AssetManager.STYLE_DATA];
    }
    throw new UnsupportedOperationException("Can't convert to integer: type=0x" + Integer.toHexString(type));
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + AssetManager.STYLE_DATA];
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        throw new RuntimeException("Failed to resolve attribute at index " + index);
    }
    throw new UnsupportedOperationException("Can't convert to integer: type=0x" + Integer.toHexString(type));
}
------------------------
Find a silently evolved API code:android.os.Bundle.putShort:COMMENT
Method Modifier: public      
Comment:/**
 * Inserts a short value into the mapping of this Bundle, replacing
 * any existing value for the given key.
 *
 * @param key a String, or null
 * @param value a short
 */

Body of Frist Method:
{
    unparcel();
    mMap.put(key, value);
}
Body of Second Method:
{
    super.putShort(key, value);
}
------------------------
Find a silently evolved API code:android.net.ConnectivityManager.getNetworkTypeName:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Returns a non-localized string representing a given network type.
 * ONLY used for debugging output.
 * @param type the type needing naming
 * @return a String for the given type, or a string version of the type ("87")
 * if no name is known.
 * {@hide}
 */

Body of Frist Method:
{
    switch(type) {
        case TYPE_MOBILE:
            return "MOBILE";
        case TYPE_WIFI:
            return "WIFI";
        case TYPE_MOBILE_MMS:
            return "MOBILE_MMS";
        case TYPE_MOBILE_SUPL:
            return "MOBILE_SUPL";
        case TYPE_MOBILE_DUN:
            return "MOBILE_DUN";
        case TYPE_MOBILE_HIPRI:
            return "MOBILE_HIPRI";
        case TYPE_WIMAX:
            return "WIMAX";
        case TYPE_BLUETOOTH:
            return "BLUETOOTH";
        case TYPE_DUMMY:
            return "DUMMY";
        case TYPE_ETHERNET:
            return "ETHERNET";
        case TYPE_MOBILE_FOTA:
            return "MOBILE_FOTA";
        case TYPE_MOBILE_IMS:
            return "MOBILE_IMS";
        case TYPE_MOBILE_CBS:
            return "MOBILE_CBS";
        case TYPE_WIFI_P2P:
            return "WIFI_P2P";
        case TYPE_MOBILE_IA:
            return "MOBILE_IA";
        default:
            return Integer.toString(type);
    }
}
Body of Second Method:
{
    switch(type) {
        case TYPE_MOBILE:
            return "MOBILE";
        case TYPE_WIFI:
            return "WIFI";
        case TYPE_MOBILE_MMS:
            return "MOBILE_MMS";
        case TYPE_MOBILE_SUPL:
            return "MOBILE_SUPL";
        case TYPE_MOBILE_DUN:
            return "MOBILE_DUN";
        case TYPE_MOBILE_HIPRI:
            return "MOBILE_HIPRI";
        case TYPE_WIMAX:
            return "WIMAX";
        case TYPE_BLUETOOTH:
            return "BLUETOOTH";
        case TYPE_DUMMY:
            return "DUMMY";
        case TYPE_ETHERNET:
            return "ETHERNET";
        case TYPE_MOBILE_FOTA:
            return "MOBILE_FOTA";
        case TYPE_MOBILE_IMS:
            return "MOBILE_IMS";
        case TYPE_MOBILE_CBS:
            return "MOBILE_CBS";
        case TYPE_WIFI_P2P:
            return "WIFI_P2P";
        case TYPE_MOBILE_IA:
            return "MOBILE_IA";
        case TYPE_MOBILE_EMERGENCY:
            return "MOBILE_EMERGENCY";
        case TYPE_PROXY:
            return "PROXY";
        default:
            return Integer.toString(type);
    }
}
------------------------
Find a silently evolved API code:android.view.Window.setDefaultWindowFormat:COMMENT
Method Modifier: protected   
Comment:/**
 * Set the default format of window, as per the PixelFormat types.  This
 * is the format that will be used unless the client specifies in explicit
 * format with setFormat();
 *
 * @param format The new window format (see PixelFormat).
 *
 * @see #setFormat
 * @see PixelFormat
 */

Body of Frist Method:
{
    mDefaultWindowFormat = format;
    if (!mHaveWindowFormat) {
        final WindowManager.LayoutParams attrs = getAttributes();
        attrs.format = format;
        if (mCallback != null) {
            mCallback.onWindowAttributesChanged(attrs);
        }
    }
}
Body of Second Method:
{
    mDefaultWindowFormat = format;
    if (!mHaveWindowFormat) {
        final WindowManager.LayoutParams attrs = getAttributes();
        attrs.format = format;
        dispatchWindowAttributesChanged(attrs);
    }
}
------------------------
Find a silently evolved API code:android.content.ContentResolver.getSyncStatus:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Returns the status that matches the authority.
 * @param account the account whose setting we are querying
 * @param authority the provider whose behavior is being queried
 * @return the SyncStatusInfo for the authority, or null if none exists
 * @hide
 */

Body of Frist Method:
{
    try {
        return getContentService().getSyncStatus(account, authority);
    } catch (RemoteException e) {
        throw new RuntimeException("the ContentService should always be reachable", e);
    }
}
Body of Second Method:
{
    try {
        return getContentService().getSyncStatus(account, authority, null);
    } catch (RemoteException e) {
        throw new RuntimeException("the ContentService should always be reachable", e);
    }
}
------------------------
Find a silently evolved API code:android.view.MotionEvent.axisToString:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns a string that represents the symbolic name of the specified axis
 * such as "AXIS_X" or an equivalent numeric constant such as "42" if unknown.
 *
 * @param axis The axis.
 * @return The symbolic name of the specified axis.
 */

Body of Frist Method:
{
    String symbolicName = AXIS_SYMBOLIC_NAMES.get(axis);
    return symbolicName != null ? symbolicName : Integer.toString(axis);
}
Body of Second Method:
{
    String symbolicName = nativeAxisToString(axis);
    return symbolicName != null ? LABEL_PREFIX + symbolicName : Integer.toString(axis);
}
------------------------
Find a silently evolved API code:android.graphics.Canvas.drawTextOnPath:COMMENT
Method Modifier: public      
Comment:/**
 * Draw the text, with origin at (x,y), using the specified paint, along
 * the specified path. The paint's Align setting determins where along the
 * path to start the text.
 *
 * @param text     The text to be drawn
 * @param path     The path the text should follow for its baseline
 * @param hOffset  The distance along the path to add to the text's
 * starting position
 * @param vOffset  The distance above(-) or below(+) the path to position
 * the text
 * @param paint    The paint used for the text (e.g. color, size, style)
 */

Body of Frist Method:
{
    if (index < 0 || index + count > text.length) {
        throw new ArrayIndexOutOfBoundsException();
    }
    native_drawTextOnPath(mNativeCanvas, text, index, count, path.ni(), hOffset, vOffset, paint.mBidiFlags, paint.mNativePaint);
}
Body of Second Method:
{
    if (text.length() > 0) {
        native_drawTextOnPath(mNativeCanvasWrapper, text, path.ni(), hOffset, vOffset, paint.mBidiFlags, paint.mNativePaint, paint.mNativeTypeface);
    }
}
------------------------
Find a silently evolved API code:android.widget.TimePicker.is24HourView:COMMENT
Method Modifier: public      
Comment:/**
 * @return true if this is in 24 hour view else false.
 */

Body of Frist Method:
{
    return mIs24HourView;
}
Body of Second Method:
{
    return mDelegate.is24HourView();
}
------------------------
Find a silently evolved API code:android.provider.DocumentsProvider.attachInfo:COMMENT
Method Modifier: public      
Comment:/**
 * Implementation is provided by the parent class.
 */

Body of Frist Method:
{
    mAuthority = info.authority;
    mMatcher = new UriMatcher(UriMatcher.NO_MATCH);
    mMatcher.addURI(mAuthority, "root", MATCH_ROOTS);
    mMatcher.addURI(mAuthority, "root/*", MATCH_ROOT);
    mMatcher.addURI(mAuthority, "root/*/recent", MATCH_RECENT);
    mMatcher.addURI(mAuthority, "root/*/search", MATCH_SEARCH);
    mMatcher.addURI(mAuthority, "document/*", MATCH_DOCUMENT);
    mMatcher.addURI(mAuthority, "document/*/children", MATCH_CHILDREN);
    // Sanity check our setup
    if (!info.exported) {
        throw new SecurityException("Provider must be exported");
    }
    if (!info.grantUriPermissions) {
        throw new SecurityException("Provider must grantUriPermissions");
    }
    if (!android.Manifest.permission.MANAGE_DOCUMENTS.equals(info.readPermission) || !android.Manifest.permission.MANAGE_DOCUMENTS.equals(info.writePermission)) {
        throw new SecurityException("Provider must be protected by MANAGE_DOCUMENTS");
    }
    super.attachInfo(context, info);
}
Body of Second Method:
{
    mAuthority = info.authority;
    mMatcher = new UriMatcher(UriMatcher.NO_MATCH);
    mMatcher.addURI(mAuthority, "root", MATCH_ROOTS);
    mMatcher.addURI(mAuthority, "root/*", MATCH_ROOT);
    mMatcher.addURI(mAuthority, "root/*/recent", MATCH_RECENT);
    mMatcher.addURI(mAuthority, "root/*/search", MATCH_SEARCH);
    mMatcher.addURI(mAuthority, "document/*", MATCH_DOCUMENT);
    mMatcher.addURI(mAuthority, "document/*/children", MATCH_CHILDREN);
    mMatcher.addURI(mAuthority, "tree/*/document/*", MATCH_DOCUMENT_TREE);
    mMatcher.addURI(mAuthority, "tree/*/document/*/children", MATCH_CHILDREN_TREE);
    // Sanity check our setup
    if (!info.exported) {
        throw new SecurityException("Provider must be exported");
    }
    if (!info.grantUriPermissions) {
        throw new SecurityException("Provider must grantUriPermissions");
    }
    if (!android.Manifest.permission.MANAGE_DOCUMENTS.equals(info.readPermission) || !android.Manifest.permission.MANAGE_DOCUMENTS.equals(info.writePermission)) {
        throw new SecurityException("Provider must be protected by MANAGE_DOCUMENTS");
    }
    super.attachInfo(context, info);
}
------------------------
Find a silently evolved API code:android.media.MediaMetadataEditor.clear:COMMENT
<android.media.MediaMetadataEditor: void clear()>
public      ->public      deprecated  
Method Modifier: public      deprecated  
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Clears all the pending metadata changes set since the MediaMetadataEditor instance was
 * created or since this method was last called.
 * Note that clearing the metadata doesn't reset the editable keys
 * (use {@link #removeEditableKeys()} instead).
 */

Body of Frist Method:
{
    if (mApplied) {
        Log.e(TAG, "Can't clear a previously applied MediaMetadataEditor");
        return;
    }
    mEditorMetadata.clear();
    mEditorArtwork = null;
}
Body of Second Method:
{
    if (mApplied) {
        Log.e(TAG, "Can't clear a previously applied MediaMetadataEditor");
        return;
    }
    mEditorMetadata.clear();
    mEditorArtwork = null;
    mMetadataBuilder = new MediaMetadata.Builder();
}
------------------------
Find a silently evolved API code:android.widget.SuggestionsAdapter.getDrawableFromResourceValue:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Gets a drawable given a value provided by a suggestion provider.
 *
 * This value could be just the string value of a resource id
 * (e.g., "2130837524"), in which case we will try to retrieve a drawable from
 * the provider's resources. If the value is not an integer, it is
 * treated as a Uri and opened with
 * {@link ContentResolver#openOutputStream(android.net.Uri, String)}.
 *
 * All resources and URIs are read using the suggestion provider's context.
 *
 * If the string is not formatted as expected, or no drawable can be found for
 * the provided value, this method returns null.
 *
 * @param drawableId a string like "2130837524",
 * "android.resource://com.android.alarmclock/2130837524",
 * or "content://contacts/photos/253".
 * @return a Drawable, or null if none found
 */

Body of Frist Method:
{
    if (drawableId == null || drawableId.length() == 0 || "0".equals(drawableId)) {
        return null;
    }
    try {
        // First, see if it's just an integer
        int resourceId = Integer.parseInt(drawableId);
        // It's an int, look for it in the cache
        String drawableUri = ContentResolver.SCHEME_ANDROID_RESOURCE + "://" + mProviderContext.getPackageName() + "/" + resourceId;
        // Must use URI as cache key, since ints are app-specific
        Drawable drawable = checkIconCache(drawableUri);
        if (drawable != null) {
            return drawable;
        }
        // Not cached, find it by resource ID
        drawable = mProviderContext.getResources().getDrawable(resourceId);
        // Stick it in the cache, using the URI as key
        storeInIconCache(drawableUri, drawable);
        return drawable;
    } catch (NumberFormatException nfe) {
        // It's not an integer, use it as a URI
        Drawable drawable = checkIconCache(drawableId);
        if (drawable != null) {
            return drawable;
        }
        Uri uri = Uri.parse(drawableId);
        drawable = getDrawable(uri);
        storeInIconCache(drawableId, drawable);
        return drawable;
    } catch (Resources.NotFoundException nfe) {
        // It was an integer, but it couldn't be found, bail out
        Log.w(LOG_TAG, "Icon resource not found: " + drawableId);
        return null;
    }
}
Body of Second Method:
{
    if (drawableId == null || drawableId.length() == 0 || "0".equals(drawableId)) {
        return null;
    }
    try {
        // First, see if it's just an integer
        int resourceId = Integer.parseInt(drawableId);
        // It's an int, look for it in the cache
        String drawableUri = ContentResolver.SCHEME_ANDROID_RESOURCE + "://" + mProviderContext.getPackageName() + "/" + resourceId;
        // Must use URI as cache key, since ints are app-specific
        Drawable drawable = checkIconCache(drawableUri);
        if (drawable != null) {
            return drawable;
        }
        // Not cached, find it by resource ID
        drawable = mProviderContext.getDrawable(resourceId);
        // Stick it in the cache, using the URI as key
        storeInIconCache(drawableUri, drawable);
        return drawable;
    } catch (NumberFormatException nfe) {
        // It's not an integer, use it as a URI
        Drawable drawable = checkIconCache(drawableId);
        if (drawable != null) {
            return drawable;
        }
        Uri uri = Uri.parse(drawableId);
        drawable = getDrawable(uri);
        storeInIconCache(drawableId, drawable);
        return drawable;
    } catch (Resources.NotFoundException nfe) {
        // It was an integer, but it couldn't be found, bail out
        Log.w(LOG_TAG, "Icon resource not found: " + drawableId);
        return null;
    }
}
------------------------
Find a silently evolved API code:android.app.ActivityThread.getTopLevelResources:COMMENT
Method Modifier: default     hidden      
Comment:/**
 * Creates the top level resources for the given package.
 */

Body of Frist Method:
{
    return mResourcesManager.getTopLevelResources(resDir, displayId, overrideConfiguration, pkgInfo.getCompatibilityInfo(), null);
}
Body of Second Method:
{
    return mResourcesManager.getTopLevelResources(resDir, splitResDirs, overlayDirs, libDirs, displayId, overrideConfiguration, pkgInfo.getCompatibilityInfo(), null);
}
------------------------
Find a silently evolved API code:android.util.LongSparseLongArray.append:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Puts a key/value pair into the array, optimizing for the case where
 * the key is greater than all existing keys in the array.
 */

Body of Frist Method:
{
    if (mSize != 0 && key <= mKeys[mSize - 1]) {
        put(key, value);
        return;
    }
    int pos = mSize;
    if (pos >= mKeys.length) {
        growKeyAndValueArrays(pos + 1);
    }
    mKeys[pos] = key;
    mValues[pos] = value;
    mSize = pos + 1;
}
Body of Second Method:
{
    if (mSize != 0 && key <= mKeys[mSize - 1]) {
        put(key, value);
        return;
    }
    mKeys = GrowingArrayUtils.append(mKeys, mSize, key);
    mValues = GrowingArrayUtils.append(mValues, mSize, value);
    mSize++;
}
------------------------
Find a silently evolved API code:android.security.KeyChain.choosePrivateKeyAlias:COMMENT
Method Modifier: public      static      
Comment:/**
 * Launches an {@code Activity} for the user to select the alias
 * for a private key and certificate pair for authentication. The
 * selected alias or null will be returned via the
 * KeyChainAliasCallback callback.
 *
 * <p>{@code keyTypes} and {@code issuers} may be used to
 * highlight suggested choices to the user, although to cope with
 * sometimes erroneous values provided by servers, the user may be
 * able to override these suggestions.
 *
 * <p>{@code host} and {@code port} may be used to give the user
 * more context about the server requesting the credentials.
 *
 * <p>{@code alias} allows the chooser to preselect an existing
 * alias which will still be subject to user confirmation.
 *
 * @param activity The {@link Activity} context to use for
 * launching the new sub-Activity to prompt the user to select
 * a private key; used only to call startActivity(); must not
 * be null.
 * @param response Callback to invoke when the request completes;
 * must not be null
 * @param keyTypes The acceptable types of asymmetric keys such as
 * "RSA" or "DSA", or a null array.
 * @param issuers The acceptable certificate issuers for the
 * certificate matching the private key, or null.
 * @param host The host name of the server requesting the
 * certificate, or null if unavailable.
 * @param port The port number of the server requesting the
 * certificate, or -1 if unavailable.
 * @param alias The alias to preselect if available, or null if
 * unavailable.
 */

Body of Frist Method:
{
    /*
         * TODO currently keyTypes, issuers are unused. They are meant
         * to follow the semantics and purpose of X509KeyManager
         * method arguments.
         *
         * keyTypes would allow the list to be filtered and typically
         * will be set correctly by the server. In practice today,
         * most all users will want only RSA, rarely DSA, and usually
         * only a small number of certs will be available.
         *
         * issuers is typically not useful. Some servers historically
         * will send the entire list of public CAs known to the
         * server. Others will send none. If this is used, if there
         * are no matches after applying the constraint, it should be
         * ignored.
         */
    if (activity == null) {
        throw new NullPointerException("activity == null");
    }
    if (response == null) {
        throw new NullPointerException("response == null");
    }
    Intent intent = new Intent(ACTION_CHOOSER);
    intent.putExtra(EXTRA_RESPONSE, new AliasResponse(response));
    intent.putExtra(EXTRA_HOST, host);
    intent.putExtra(EXTRA_PORT, port);
    intent.putExtra(EXTRA_ALIAS, alias);
    // the PendingIntent is used to get calling package name
    intent.putExtra(EXTRA_SENDER, PendingIntent.getActivity(activity, 0, new Intent(), 0));
    activity.startActivity(intent);
}
Body of Second Method:
{
    /*
         * TODO currently keyTypes, issuers are unused. They are meant
         * to follow the semantics and purpose of X509KeyManager
         * method arguments.
         *
         * keyTypes would allow the list to be filtered and typically
         * will be set correctly by the server. In practice today,
         * most all users will want only RSA, rarely DSA, and usually
         * only a small number of certs will be available.
         *
         * issuers is typically not useful. Some servers historically
         * will send the entire list of public CAs known to the
         * server. Others will send none. If this is used, if there
         * are no matches after applying the constraint, it should be
         * ignored.
         */
    if (activity == null) {
        throw new NullPointerException("activity == null");
    }
    if (response == null) {
        throw new NullPointerException("response == null");
    }
    Intent intent = new Intent(ACTION_CHOOSER);
    intent.setPackage(KEYCHAIN_PACKAGE);
    intent.putExtra(EXTRA_RESPONSE, new AliasResponse(response));
    intent.putExtra(EXTRA_HOST, host);
    intent.putExtra(EXTRA_PORT, port);
    intent.putExtra(EXTRA_ALIAS, alias);
    // the PendingIntent is used to get calling package name
    intent.putExtra(EXTRA_SENDER, PendingIntent.getActivity(activity, 0, new Intent(), 0));
    activity.startActivity(intent);
}
------------------------
Find a silently evolved API code:android.view.ViewPropertyAnimator.getValue:COMMENT
Method Modifier: private     
Comment:/**
 * This method gets the value of the named property from the View object.
 *
 * @param propertyConstant The property whose value should be returned
 * @return float The value of the named property
 */

Body of Frist Method:
{
    final View.TransformationInfo info = mView.mTransformationInfo;
    switch(propertyConstant) {
        case TRANSLATION_X:
            return info.mTranslationX;
        case TRANSLATION_Y:
            return info.mTranslationY;
        case ROTATION:
            return info.mRotation;
        case ROTATION_X:
            return info.mRotationX;
        case ROTATION_Y:
            return info.mRotationY;
        case SCALE_X:
            return info.mScaleX;
        case SCALE_Y:
            return info.mScaleY;
        case X:
            return mView.mLeft + info.mTranslationX;
        case Y:
            return mView.mTop + info.mTranslationY;
        case ALPHA:
            return info.mAlpha;
    }
    return 0;
}
Body of Second Method:
{
    final RenderNode node = mView.mRenderNode;
    switch(propertyConstant) {
        case TRANSLATION_X:
            return node.getTranslationX();
        case TRANSLATION_Y:
            return node.getTranslationY();
        case TRANSLATION_Z:
            return node.getTranslationZ();
        case ROTATION:
            return node.getRotation();
        case ROTATION_X:
            return node.getRotationX();
        case ROTATION_Y:
            return node.getRotationY();
        case SCALE_X:
            return node.getScaleX();
        case SCALE_Y:
            return node.getScaleY();
        case X:
            return mView.mLeft + node.getTranslationX();
        case Y:
            return mView.mTop + node.getTranslationY();
        case Z:
            return node.getElevation() + node.getTranslationZ();
        case ALPHA:
            return mView.mTransformationInfo.mAlpha;
    }
    return 0;
}
------------------------
Find a silently evolved API code:android.widget.Switch.setTrackDrawable:COMMENT
Method Modifier: public      
Comment:/**
 * Set the drawable used for the track that the switch slides within.
 *
 * @param track Track drawable
 *
 * @attr ref android.R.styleable#Switch_track
 */

Body of Frist Method:
{
    mTrackDrawable = track;
    requestLayout();
}
Body of Second Method:
{
    if (mTrackDrawable != null) {
        mTrackDrawable.setCallback(null);
    }
    mTrackDrawable = track;
    if (track != null) {
        track.setCallback(this);
    }
    requestLayout();
}
------------------------
Find a silently evolved API code:android.app.ActivityThread.ApplicationThread.scheduleLaunchActivity:COMMENT
Method Modifier: public      final       
Comment:// activity itself back to the activity manager. (matters more with ipc)

Body of Frist Method:
{
    updateProcessState(procState, false);
    ActivityClientRecord r = new ActivityClientRecord();
    r.token = token;
    r.ident = ident;
    r.intent = intent;
    r.activityInfo = info;
    r.compatInfo = compatInfo;
    r.state = state;
    r.pendingResults = pendingResults;
    r.pendingIntents = pendingNewIntents;
    r.startsNotResumed = notResumed;
    r.isForward = isForward;
    r.profileFile = profileName;
    r.profileFd = profileFd;
    r.autoStopProfiler = autoStopProfiler;
    updatePendingConfiguration(curConfig);
    queueOrSendMessage(H.LAUNCH_ACTIVITY, r);
}
Body of Second Method:
{
    updateProcessState(procState, false);
    ActivityClientRecord r = new ActivityClientRecord();
    r.token = token;
    r.ident = ident;
    r.intent = intent;
    r.voiceInteractor = voiceInteractor;
    r.activityInfo = info;
    r.compatInfo = compatInfo;
    r.state = state;
    r.persistentState = persistentState;
    r.pendingResults = pendingResults;
    r.pendingIntents = pendingNewIntents;
    r.startsNotResumed = notResumed;
    r.isForward = isForward;
    r.profilerInfo = profilerInfo;
    updatePendingConfiguration(curConfig);
    sendMessage(H.LAUNCH_ACTIVITY, r);
}
------------------------
Find a silently evolved API code:android.graphics.Canvas.setMatrix:COMMENT
Method Modifier: public      
Comment:/**
 * Completely replace the current matrix with the specified matrix. If the
 * matrix parameter is null, then the current matrix is reset to identity.
 *
 * <strong>Note:</strong> it is recommended to use {@link #concat(Matrix)},
 * {@link #scale(float, float)}, {@link #translate(float, float)} and
 * {@link #rotate(float)} instead of this method.
 *
 * @param matrix The matrix to replace the current matrix with. If it is
 * null, set the current matrix to identity.
 *
 * @see #concat(Matrix)
 */

Body of Frist Method:
{
    native_setMatrix(mNativeCanvas, matrix == null ? 0 : matrix.native_instance);
}
Body of Second Method:
{
    native_setMatrix(mNativeCanvasWrapper, matrix == null ? 0 : matrix.native_instance);
}
------------------------
Find a silently evolved API code:android.media.MediaRouter.UserRouteInfo.setVolumeMax:COMMENT
Method Modifier: public      
Comment:/**
 * Defines the maximum volume at which the playback associated with this route is performed
 * (for user feedback purposes). This information is only used when the playback is not
 * local.
 * @param volumeMax
 */

Body of Frist Method:
{
    if (mVolumeMax != volumeMax) {
        mVolumeMax = volumeMax;
        setPlaybackInfoOnRcc(RemoteControlClient.PLAYBACKINFO_VOLUME_MAX, volumeMax);
    }
}
Body of Second Method:
{
    if (mVolumeMax != volumeMax) {
        mVolumeMax = volumeMax;
        configureSessionVolume();
    }
}
------------------------
Find a silently evolved API code:android.app.backup.BackupAgent.waitForSharedPrefs:COMMENT
Method Modifier: private     
Comment:// Syncing shared preferences deferred writes needs to happen on the main looper thread

Body of Frist Method:
{
    if (mHandler == null) {
        mHandler = new Handler(Looper.getMainLooper());
    }
    final SharedPrefsSynchronizer s = new SharedPrefsSynchronizer();
    mHandler.postAtFrontOfQueue(s);
    try {
        s.mLatch.await();
    } catch (InterruptedException e) {
    /* ignored */
    }
}
Body of Second Method:
{
    Handler h = getHandler();
    final SharedPrefsSynchronizer s = new SharedPrefsSynchronizer();
    h.postAtFrontOfQueue(s);
    try {
        s.mLatch.await();
    } catch (InterruptedException e) {
    /* ignored */
    }
}
------------------------
Find a silently evolved API code:android.telephony.SignalStrength.getDbm:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the signal strength as dBm
 *
 * @hide
 */

Body of Frist Method:
{
    int dBm;
    if (isGsm()) {
        if (getLteLevel() == SIGNAL_STRENGTH_NONE_OR_UNKNOWN) {
            dBm = getGsmDbm();
        } else {
            dBm = getLteDbm();
        }
    } else {
        int cdmaDbm = getCdmaDbm();
        int evdoDbm = getEvdoDbm();
        return (evdoDbm == -120) ? cdmaDbm : ((cdmaDbm == -120) ? evdoDbm : (cdmaDbm < evdoDbm ? cdmaDbm : evdoDbm));
    }
    if (DBG)
        log("getDbm=" + dBm);
    return dBm;
}
Body of Second Method:
{
    int dBm;
    if (isGsm()) {
        dBm = getLteDbm();
        if (dBm == INVALID) {
            dBm = getGsmDbm();
        }
    } else {
        int cdmaDbm = getCdmaDbm();
        int evdoDbm = getEvdoDbm();
        return (evdoDbm == -120) ? cdmaDbm : ((cdmaDbm == -120) ? evdoDbm : (cdmaDbm < evdoDbm ? cdmaDbm : evdoDbm));
    }
    if (DBG)
        log("getDbm=" + dBm);
    return dBm;
}
------------------------
Find a silently evolved API code:android.view.ViewGroup.requestChildFocus:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (DBG) {
        System.out.println(this + " requestChildFocus()");
    }
    if (getDescendantFocusability() == FOCUS_BLOCK_DESCENDANTS) {
        return;
    }
    // Unfocus us, if necessary
    super.unFocus();
    // We had a previous notion of who had focus. Clear it.
    if (mFocused != child) {
        if (mFocused != null) {
            mFocused.unFocus();
        }
        mFocused = child;
    }
    if (mParent != null) {
        mParent.requestChildFocus(this, focused);
    }
}
Body of Second Method:
{
    if (DBG) {
        System.out.println(this + " requestChildFocus()");
    }
    if (getDescendantFocusability() == FOCUS_BLOCK_DESCENDANTS) {
        return;
    }
    // Unfocus us, if necessary
    super.unFocus(focused);
    // We had a previous notion of who had focus. Clear it.
    if (mFocused != child) {
        if (mFocused != null) {
            mFocused.unFocus(focused);
        }
        mFocused = child;
    }
    if (mParent != null) {
        mParent.requestChildFocus(this, focused);
    }
}
------------------------
Find a silently evolved API code:android.view.accessibility.AccessibilityNodeInfo.setLabeledBy:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the view which serves as the label of the view represented by
 * this info for accessibility purposes.
 *
 * @param label The view that labels this node's source.
 */

Body of Frist Method:
{
    setLabeledBy(label, UNDEFINED);
}
Body of Second Method:
{
    setLabeledBy(label, UNDEFINED_ITEM_ID);
}
------------------------
Find a silently evolved API code:android.app.admin.DevicePolicyManager.setActiveAdmin:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (mService != null) {
        try {
            mService.setActiveAdmin(policyReceiver, refreshing, UserHandle.myUserId());
        } catch (RemoteException e) {
            Log.w(TAG, "Failed talking with device policy service", e);
        }
    }
}
Body of Second Method:
{
    if (mService != null) {
        try {
            mService.setActiveAdmin(policyReceiver, refreshing, userHandle);
        } catch (RemoteException e) {
            Log.w(TAG, "Failed talking with device policy service", e);
        }
    }
}
------------------------
Find a silently evolved API code:android.util.ArraySet.clear:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Make the array map empty.  All storage is released.
 */

Body of Frist Method:
{
    if (mSize != 0) {
        freeArrays(mHashes, mArray, mSize);
        mHashes = ContainerHelpers.EMPTY_INTS;
        mArray = ContainerHelpers.EMPTY_OBJECTS;
        mSize = 0;
    }
}
Body of Second Method:
{
    if (mSize != 0) {
        freeArrays(mHashes, mArray, mSize);
        mHashes = EmptyArray.INT;
        mArray = EmptyArray.OBJECT;
        mSize = 0;
    }
}
------------------------
Find a silently evolved API code:android.os.Bundle.putSerializable:COMMENT
Method Modifier: public      
Comment:/**
 * Inserts a Serializable value into the mapping of this Bundle, replacing
 * any existing value for the given key.  Either key or value may be null.
 *
 * @param key a String, or null
 * @param value a Serializable object, or null
 */

Body of Frist Method:
{
    unparcel();
    mMap.put(key, value);
}
Body of Second Method:
{
    super.putSerializable(key, value);
}
------------------------
Find a silently evolved API code:android.hardware.SystemSensorManager.unregisterListenerImpl:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    // Trigger Sensors should use the cancelTriggerSensor call.
    if (sensor != null && Sensor.getReportingMode(sensor) == Sensor.REPORTING_MODE_ONE_SHOT) {
        return;
    }
    synchronized (mSensorListeners) {
        SensorEventQueue queue = mSensorListeners.get(listener);
        if (queue != null) {
            boolean result;
            if (sensor == null) {
                result = queue.removeAllSensors();
            } else {
                result = queue.removeSensor(sensor, true);
            }
            if (result && !queue.hasSensors()) {
                mSensorListeners.remove(listener);
                queue.dispose();
            }
        }
    }
}
Body of Second Method:
{
    // Trigger Sensors should use the cancelTriggerSensor call.
    if (sensor != null && sensor.getReportingMode() == Sensor.REPORTING_MODE_ONE_SHOT) {
        return;
    }
    synchronized (mSensorListeners) {
        SensorEventQueue queue = mSensorListeners.get(listener);
        if (queue != null) {
            boolean result;
            if (sensor == null) {
                result = queue.removeAllSensors();
            } else {
                result = queue.removeSensor(sensor, true);
            }
            if (result && !queue.hasSensors()) {
                mSensorListeners.remove(listener);
                queue.dispose();
            }
        }
    }
}
------------------------
Find a silently evolved API code:android.media.MediaFocusControl.setNewRcClientGenerationOnClients_syncRcsCurrc:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Update the remote control clients with the new "focused" client generation
 */

Body of Frist Method:
{
    // (using an iterator on the stack so we can safely remove an entry if needed,
    // traversal order doesn't matter here as we update all entries)
    Iterator<RemoteControlStackEntry> stackIterator = mRCStack.iterator();
    while (stackIterator.hasNext()) {
        RemoteControlStackEntry se = stackIterator.next();
        if ((se != null) && (se.mRcClient != null)) {
            try {
                se.mRcClient.setCurrentClientGenerationId(newClientGeneration);
            } catch (RemoteException e) {
                Log.w(TAG, "Dead client in setNewRcClientGenerationOnClients_syncRcsCurrc()", e);
                stackIterator.remove();
                se.unlinkToRcClientDeath();
            }
        }
    }
}
Body of Second Method:
{
    // (using an iterator on the stack so we can safely remove an entry if needed,
    // traversal order doesn't matter here as we update all entries)
    Iterator<PlayerRecord> stackIterator = mPRStack.iterator();
    while (stackIterator.hasNext()) {
        PlayerRecord se = stackIterator.next();
        if ((se != null) && (se.getRcc() != null)) {
            try {
                se.getRcc().setCurrentClientGenerationId(newClientGeneration);
            } catch (RemoteException e) {
                Log.w(TAG, "Dead client in setNewRcClientGenerationOnClients_syncRcsCurrc()", e);
                stackIterator.remove();
                se.unlinkToRcClientDeath();
            }
        }
    }
}
------------------------
Find a silently evolved API code:android.media.RemoteControlClient.MetadataEditor.putBitmap:COMMENT
<android.media.RemoteControlClient.MetadataEditor: MetadataEditor putBitmap(int,Bitmap)>
public      ->public      deprecated  
Method Modifier: public      deprecated  
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Sets the album / artwork picture to be displayed on the remote control.
 * @param key the identifier of the bitmap to set. The only valid value is
 * {@link #BITMAP_KEY_ARTWORK}
 * @param bitmap The bitmap for the artwork, or null if there isn't any.
 * @return Returns a reference to the same MetadataEditor object, so you can chain put
 * calls together.
 * @throws IllegalArgumentException
 * @see android.graphics.Bitmap
 */

Body of Frist Method:
{
    super.putBitmap(key, bitmap);
    return this;
}
Body of Second Method:
{
    super.putBitmap(key, bitmap);
    if (mMetadataBuilder != null) {
        // MediaMetadata supports all the same fields as MetadataEditor
        String metadataKey = MediaMetadata.getKeyFromMetadataEditorKey(key);
        // But just in case, don't add things we don't understand
        if (metadataKey != null) {
            mMetadataBuilder.putBitmap(metadataKey, bitmap);
        }
    }
    return this;
}
------------------------
Find a silently evolved API code:android.provider.Settings.Global.putStringForUser:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (LOCAL_LOGV) {
        Log.v(TAG, "Global.putString(name=" + name + ", value=" + value + " for " + userHandle);
    }
    return sNameValueCache.putStringForUser(resolver, name, value, userHandle);
}
Body of Second Method:
{
    if (LOCAL_LOGV) {
        Log.v(TAG, "Global.putString(name=" + name + ", value=" + value + " for " + userHandle);
    }
    // Global and Secure have the same access policy so we can forward writes
    if (MOVED_TO_SECURE.contains(name)) {
        Log.w(TAG, "Setting " + name + " has moved from android.provider.Settings.Global" + " to android.provider.Settings.Secure, value is unchanged.");
        return Secure.putStringForUser(resolver, name, value, userHandle);
    }
    return sNameValueCache.putStringForUser(resolver, name, value, userHandle);
}
------------------------
Find a silently evolved API code:android.util.ArraySet.remove:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Removes the specified object from this set.
 *
 * @param object the object to remove.
 * @return {@code true} if this set was modified, {@code false} otherwise.
 */

Body of Frist Method:
{
    int index = object == null ? indexOfNull() : indexOf(object, object.hashCode());
    if (index >= 0) {
        removeAt(index);
        return true;
    }
    return false;
}
Body of Second Method:
{
    final int index = indexOf(object);
    if (index >= 0) {
        removeAt(index);
        return true;
    }
    return false;
}
------------------------
Find a silently evolved API code:android.view.accessibility.AccessibilityManager.sendAccessibilityEvent:COMMENT
Method Modifier: public      
Comment:/**
 * Sends an {@link AccessibilityEvent}.
 *
 * @param event The event to send.
 *
 * @throws IllegalStateException if accessibility is not enabled.
 *
 * <strong>Note:</strong> The preferred mechanism for sending custom accessibility
 * events is through calling
 * {@link android.view.ViewParent#requestSendAccessibilityEvent(View, AccessibilityEvent)}
 * instead of this method to allow predecessors to augment/filter events sent by
 * their descendants.
 */

Body of Frist Method:
{
    if (!mIsEnabled) {
        throw new IllegalStateException("Accessibility off. Did you forget to check that?");
    }
    boolean doRecycle = false;
    try {
        event.setEventTime(SystemClock.uptimeMillis());
        // it is possible that this manager is in the same process as the service but
        // client using it is called through Binder from another process. Example: MMS
        // app adds a SMS notification and the NotificationManagerService calls this method
        long identityToken = Binder.clearCallingIdentity();
        doRecycle = mService.sendAccessibilityEvent(event, mUserId);
        Binder.restoreCallingIdentity(identityToken);
        if (DEBUG) {
            Log.i(LOG_TAG, event + " sent");
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, "Error during sending " + event + " ", re);
    } finally {
        if (doRecycle) {
            event.recycle();
        }
    }
}
Body of Second Method:
{
    final IAccessibilityManager service;
    final int userId;
    synchronized (mLock) {
        service = getServiceLocked();
        if (service == null) {
            return;
        }
        if (!mIsEnabled) {
            throw new IllegalStateException("Accessibility off. Did you forget to check that?");
        }
        userId = mUserId;
    }
    boolean doRecycle = false;
    try {
        event.setEventTime(SystemClock.uptimeMillis());
        // it is possible that this manager is in the same process as the service but
        // client using it is called through Binder from another process. Example: MMS
        // app adds a SMS notification and the NotificationManagerService calls this method
        long identityToken = Binder.clearCallingIdentity();
        doRecycle = service.sendAccessibilityEvent(event, userId);
        Binder.restoreCallingIdentity(identityToken);
        if (DEBUG) {
            Log.i(LOG_TAG, event + " sent");
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, "Error during sending " + event + " ", re);
    } finally {
        if (doRecycle) {
            event.recycle();
        }
    }
}
------------------------
Find a silently evolved API code:android.media.AudioService.playSoundEffectVolume:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @see AudioManager#playSoundEffect(int, float)
 */

Body of Frist Method:
{
    sendMsg(mAudioHandler, MSG_PLAY_SOUND_EFFECT, SENDMSG_QUEUE, effectType, (int) (volume * 1000), null, 0);
}
Body of Second Method:
{
    if (effectType >= AudioManager.NUM_SOUND_EFFECTS || effectType < 0) {
        Log.w(TAG, "AudioService effectType value " + effectType + " out of range");
        return;
    }
    sendMsg(mAudioHandler, MSG_PLAY_SOUND_EFFECT, SENDMSG_QUEUE, effectType, (int) (volume * 1000), null, 0);
}
------------------------
Find a silently evolved API code:android.graphics.Paint.reset:COMMENT
Method Modifier: public      
Comment:/**
 * Restores the paint to its default settings.
 */

Body of Frist Method:
{
    native_reset(mNativePaint);
    setFlags(DEFAULT_PAINT_FLAGS);
    // TODO: Turning off hinting has undesirable side effects, we need to
    // revisit hinting once we add support for subpixel positioning
    // setHinting(DisplayMetrics.DENSITY_DEVICE >= DisplayMetrics.DENSITY_TV
    // ? HINTING_OFF : HINTING_ON);
    mColorFilter = null;
    mMaskFilter = null;
    mPathEffect = null;
    mRasterizer = null;
    mShader = null;
    mTypeface = null;
    mXfermode = null;
    mHasCompatScaling = false;
    mCompatScaling = 1;
    mInvCompatScaling = 1;
    hasShadow = false;
    shadowDx = 0;
    shadowDy = 0;
    shadowRadius = 0;
    shadowColor = 0;
    mBidiFlags = BIDI_DEFAULT_LTR;
    setTextLocale(Locale.getDefault());
}
Body of Second Method:
{
    native_reset(mNativePaint);
    setFlags(DEFAULT_PAINT_FLAGS);
    // TODO: Turning off hinting has undesirable side effects, we need to
    // revisit hinting once we add support for subpixel positioning
    // setHinting(DisplayMetrics.DENSITY_DEVICE >= DisplayMetrics.DENSITY_TV
    // ? HINTING_OFF : HINTING_ON);
    mColorFilter = null;
    mMaskFilter = null;
    mPathEffect = null;
    mRasterizer = null;
    mShader = null;
    mTypeface = null;
    mNativeTypeface = 0;
    mXfermode = null;
    mHasCompatScaling = false;
    mCompatScaling = 1;
    mInvCompatScaling = 1;
    mBidiFlags = BIDI_DEFAULT_LTR;
    setTextLocale(Locale.getDefault());
    setElegantTextHeight(false);
    mFontFeatureSettings = null;
}
------------------------
Find a silently evolved API code:android.view.ViewGroup.unFocus:COMMENT
Method Modifier: default     
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (DBG) {
        System.out.println(this + " unFocus()");
    }
    if (mFocused == null) {
        super.unFocus();
    } else {
        mFocused.unFocus();
        mFocused = null;
    }
}
Body of Second Method:
{
    if (DBG) {
        System.out.println(this + " unFocus()");
    }
    if (mFocused == null) {
        super.unFocus(focused);
    } else {
        mFocused.unFocus(focused);
        mFocused = null;
    }
}
------------------------
Find a silently evolved API code:android.media.RemoteControlClient.MetadataEditor.putLong:COMMENT
<android.media.RemoteControlClient.MetadataEditor: MetadataEditor putLong(int,long)>
public      ->public      deprecated  
Method Modifier: public      deprecated  
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Adds numerical information to be displayed.
 * Note that none of the information added after {@link #apply()} has been called,
 * will be displayed.
 * @param key the identifier of a the metadata field to set. Valid values are
 * {@link android.media.MediaMetadataRetriever#METADATA_KEY_CD_TRACK_NUMBER},
 * {@link android.media.MediaMetadataRetriever#METADATA_KEY_DISC_NUMBER},
 * {@link android.media.MediaMetadataRetriever#METADATA_KEY_DURATION} (with a value
 * expressed in milliseconds),
 * {@link android.media.MediaMetadataRetriever#METADATA_KEY_YEAR}.
 * @param value The long value for the given key
 * @return Returns a reference to the same MetadataEditor object, so you can chain put
 * calls together.
 * @throws IllegalArgumentException
 */

Body of Frist Method:
{
    super.putLong(key, value);
    return this;
}
Body of Second Method:
{
    super.putLong(key, value);
    if (mMetadataBuilder != null) {
        // MediaMetadata supports all the same fields as MetadataEditor
        String metadataKey = MediaMetadata.getKeyFromMetadataEditorKey(key);
        // But just in case, don't add things we don't understand
        if (metadataKey != null) {
            mMetadataBuilder.putLong(metadataKey, value);
        }
    }
    return this;
}
------------------------
Find a silently evolved API code:android.view.ViewPropertyAnimator.startAnimation:COMMENT
Method Modifier: private     
Comment:/**
 * Starts the underlying Animator for a set of properties. We use a single animator that
 * simply runs from 0 to 1, and then use that fractional value to set each property
 * value accordingly.
 */

Body of Frist Method:
{
    mView.setHasTransientState(true);
    ValueAnimator animator = ValueAnimator.ofFloat(1.0f);
    ArrayList<NameValuesHolder> nameValueList = (ArrayList<NameValuesHolder>) mPendingAnimations.clone();
    mPendingAnimations.clear();
    int propertyMask = 0;
    int propertyCount = nameValueList.size();
    for (int i = 0; i < propertyCount; ++i) {
        NameValuesHolder nameValuesHolder = nameValueList.get(i);
        propertyMask |= nameValuesHolder.mNameConstant;
    }
    mAnimatorMap.put(animator, new PropertyBundle(propertyMask, nameValueList));
    if (mPendingSetupAction != null) {
        mAnimatorSetupMap.put(animator, mPendingSetupAction);
        mPendingSetupAction = null;
    }
    if (mPendingCleanupAction != null) {
        mAnimatorCleanupMap.put(animator, mPendingCleanupAction);
        mPendingCleanupAction = null;
    }
    if (mPendingOnStartAction != null) {
        mAnimatorOnStartMap.put(animator, mPendingOnStartAction);
        mPendingOnStartAction = null;
    }
    if (mPendingOnEndAction != null) {
        mAnimatorOnEndMap.put(animator, mPendingOnEndAction);
        mPendingOnEndAction = null;
    }
    animator.addUpdateListener(mAnimatorEventListener);
    animator.addListener(mAnimatorEventListener);
    if (mStartDelaySet) {
        animator.setStartDelay(mStartDelay);
    }
    if (mDurationSet) {
        animator.setDuration(mDuration);
    }
    if (mInterpolatorSet) {
        animator.setInterpolator(mInterpolator);
    }
    animator.start();
}
Body of Second Method:
{
    if (mRTBackend != null && mRTBackend.startAnimation(this)) {
        return;
    }
    mView.setHasTransientState(true);
    ValueAnimator animator = ValueAnimator.ofFloat(1.0f);
    ArrayList<NameValuesHolder> nameValueList = (ArrayList<NameValuesHolder>) mPendingAnimations.clone();
    mPendingAnimations.clear();
    int propertyMask = 0;
    int propertyCount = nameValueList.size();
    for (int i = 0; i < propertyCount; ++i) {
        NameValuesHolder nameValuesHolder = nameValueList.get(i);
        propertyMask |= nameValuesHolder.mNameConstant;
    }
    mAnimatorMap.put(animator, new PropertyBundle(propertyMask, nameValueList));
    if (mPendingSetupAction != null) {
        mAnimatorSetupMap.put(animator, mPendingSetupAction);
        mPendingSetupAction = null;
    }
    if (mPendingCleanupAction != null) {
        mAnimatorCleanupMap.put(animator, mPendingCleanupAction);
        mPendingCleanupAction = null;
    }
    if (mPendingOnStartAction != null) {
        mAnimatorOnStartMap.put(animator, mPendingOnStartAction);
        mPendingOnStartAction = null;
    }
    if (mPendingOnEndAction != null) {
        mAnimatorOnEndMap.put(animator, mPendingOnEndAction);
        mPendingOnEndAction = null;
    }
    animator.addUpdateListener(mAnimatorEventListener);
    animator.addListener(mAnimatorEventListener);
    if (mStartDelaySet) {
        animator.setStartDelay(mStartDelay);
    }
    if (mDurationSet) {
        animator.setDuration(mDuration);
    }
    if (mInterpolatorSet) {
        animator.setInterpolator(mInterpolator);
    }
    animator.start();
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothDevice.fetchUuidsWithSdp:COMMENT
Method Modifier: public      
Comment:/**
 * Perform a service discovery on the remote device to get the UUIDs supported.
 *
 * <p>This API is asynchronous and {@link #ACTION_UUID} intent is sent,
 * with the UUIDs supported by the remote end. If there is an error
 * in getting the SDP records or if the process takes a long time,
 * {@link #ACTION_UUID} intent is sent with the UUIDs that is currently
 * present in the cache. Clients should use the {@link #getUuids} to get UUIDs
 * if service discovery is not to be performed.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}.
 *
 * @return False if the sanity check fails, True if the process
 * of initiating an ACL connection to the remote device
 * was started.
 */

Body of Frist Method:
{
    try {
        return sService.fetchRemoteUuids(this);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
Body of Second Method:
{
    IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, "BT not enabled. Cannot fetchUuidsWithSdp");
        return false;
    }
    try {
        return service.fetchRemoteUuids(this);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
------------------------
Find a silently evolved API code:android.widget.ListPopupWindow.setModal:COMMENT
Method Modifier: public      
Comment:/**
 * Set whether this window should be modal when shown.
 *
 * <p>If a popup window is modal, it will receive all touch and key input.
 * If the user touches outside the popup window's content area the popup window
 * will be dismissed.
 *
 * @param modal {@code true} if the popup window should be modal, {@code false} otherwise.
 */

Body of Frist Method:
{
    mModal = true;
    mPopup.setFocusable(modal);
}
Body of Second Method:
{
    mModal = modal;
    mPopup.setFocusable(modal);
}
------------------------
Find a silently evolved API code:android.media.MediaFocusControl.unregisterRemoteControlClient:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * see AudioManager.unregisterRemoteControlClient(PendingIntent pi, ...)
 * rcClient is guaranteed non-null
 */

Body of Frist Method:
{
    if (DEBUG_RC)
        Log.i(TAG, "Unregister remote control client rcClient=" + rcClient);
    synchronized (mAudioFocusLock) {
        synchronized (mRCStack) {
            boolean topRccChange = false;
            try {
                for (int index = mRCStack.size() - 1; index >= 0; index--) {
                    final RemoteControlStackEntry rcse = mRCStack.elementAt(index);
                    if ((rcse.mMediaIntent.equals(mediaIntent)) && rcClient.equals(rcse.mRcClient)) {
                        // we found the IRemoteControlClient to unregister
                        // stop monitoring its death
                        rcse.unlinkToRcClientDeath();
                        // reset the client-related fields
                        rcse.mRcClient = null;
                        rcse.mCallingPackageName = null;
                        topRccChange = (index == mRCStack.size() - 1);
                        // there can only be one matching RCC in the RC stack, we're done
                        break;
                    }
                }
            } catch (ArrayIndexOutOfBoundsException e) {
                // not expected to happen, indicates improper concurrent modification
                Log.e(TAG, "Wrong index accessing RC stack, lock error? ", e);
            }
            if (topRccChange) {
                // no more RCC for the RCD, check for potential refresh of the remote controls
                checkUpdateRemoteControlDisplay_syncAfRcs(RC_INFO_ALL);
            }
        }
    }
}
Body of Second Method:
{
    if (DEBUG_RC)
        Log.i(TAG, "Unregister remote control client rcClient=" + rcClient);
    synchronized (mPRStack) {
        boolean topRccChange = false;
        try {
            for (int index = mPRStack.size() - 1; index >= 0; index--) {
                final PlayerRecord prse = mPRStack.elementAt(index);
                if ((prse.hasMatchingMediaButtonIntent(mediaIntent)) && rcClient.equals(prse.getRcc())) {
                    // we found the IRemoteControlClient to unregister
                    prse.resetControllerInfoForNoRcc();
                    topRccChange = (index == mPRStack.size() - 1);
                    // there can only be one matching RCC in the RC stack, we're done
                    break;
                }
            }
        } catch (ArrayIndexOutOfBoundsException e) {
            // not expected to happen, indicates improper concurrent modification
            Log.e(TAG, "Wrong index accessing RC stack, lock error? ", e);
        }
        if (topRccChange) {
            // no more RCC for the RCD, check for potential refresh of the remote controls
            checkUpdateRemoteControlDisplay_syncPrs(RC_INFO_ALL);
        }
    }
}
------------------------
Find a silently evolved API code:android.graphics.drawable.GradientDrawable.setColors:COMMENT
Method Modifier: public      
Comment:/**
 * <p>Sets the colors used to draw the gradient. Each color is specified as an
 * ARGB integer and the array must contain at least 2 colors.</p>
 * <p><strong>Note</strong>: changing orientation will affect all instances
 * of a drawable loaded from a resource. It is recommended to invoke
 * {@link #mutate()} before changing the orientation.</p>
 *
 * @param colors 2 or more ARGB colors
 *
 * @see #mutate()
 * @see #setColor(int)
 */

Body of Frist Method:
{
    mGradientState.setColors(colors);
    mRectIsDirty = true;
    invalidateSelf();
}
Body of Second Method:
{
    mGradientState.setColors(colors);
    mGradientIsDirty = true;
    invalidateSelf();
}
------------------------
Find a silently evolved API code:android.view.textservice.TextInfo.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Used to package this object into a {@link Parcel}.
 *
 * @param dest The {@link Parcel} to be written.
 * @param flags The flags used for parceling.
 */

Body of Frist Method:
{
    dest.writeString(mText);
    dest.writeInt(mCookie);
    dest.writeInt(mSequence);
}
Body of Second Method:
{
    TextUtils.writeToParcel(mCharSequence, dest, flags);
    dest.writeInt(mCookie);
    dest.writeInt(mSequenceNumber);
}
------------------------
Find a silently evolved API code:android.app.ApplicationErrorReport.CrashInfo.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Save a CrashInfo instance to a parcel.
 */

Body of Frist Method:
{
    dest.writeString(exceptionClassName);
    dest.writeString(exceptionMessage);
    dest.writeString(throwFileName);
    dest.writeString(throwClassName);
    dest.writeString(throwMethodName);
    dest.writeInt(throwLineNumber);
    dest.writeString(stackTrace);
}
Body of Second Method:
{
    int start = dest.dataPosition();
    dest.writeString(exceptionClassName);
    dest.writeString(exceptionMessage);
    dest.writeString(throwFileName);
    dest.writeString(throwClassName);
    dest.writeString(throwMethodName);
    dest.writeInt(throwLineNumber);
    dest.writeString(stackTrace);
    int total = dest.dataPosition() - start;
    if (total > 20 * 1024) {
        Slog.d("Error", "ERR: exClass=" + exceptionClassName);
        Slog.d("Error", "ERR: exMsg=" + exceptionMessage);
        Slog.d("Error", "ERR: file=" + throwFileName);
        Slog.d("Error", "ERR: class=" + throwClassName);
        Slog.d("Error", "ERR: method=" + throwMethodName + " line=" + throwLineNumber);
        Slog.d("Error", "ERR: stack=" + stackTrace);
        Slog.d("Error", "ERR: TOTAL BYTES WRITTEN: " + (dest.dataPosition() - start));
    }
}
------------------------
Find a silently evolved API code:android.app.Notification.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Flatten this notification from a parcel.
 */

Body of Frist Method:
{
    parcel.writeInt(1);
    parcel.writeLong(when);
    parcel.writeInt(icon);
    parcel.writeInt(number);
    if (contentIntent != null) {
        parcel.writeInt(1);
        contentIntent.writeToParcel(parcel, 0);
    } else {
        parcel.writeInt(0);
    }
    if (deleteIntent != null) {
        parcel.writeInt(1);
        deleteIntent.writeToParcel(parcel, 0);
    } else {
        parcel.writeInt(0);
    }
    if (tickerText != null) {
        parcel.writeInt(1);
        TextUtils.writeToParcel(tickerText, parcel, flags);
    } else {
        parcel.writeInt(0);
    }
    if (tickerView != null) {
        parcel.writeInt(1);
        tickerView.writeToParcel(parcel, 0);
    } else {
        parcel.writeInt(0);
    }
    if (contentView != null) {
        parcel.writeInt(1);
        contentView.writeToParcel(parcel, 0);
    } else {
        parcel.writeInt(0);
    }
    if (largeIcon != null) {
        parcel.writeInt(1);
        largeIcon.writeToParcel(parcel, 0);
    } else {
        parcel.writeInt(0);
    }
    parcel.writeInt(defaults);
    parcel.writeInt(this.flags);
    if (sound != null) {
        parcel.writeInt(1);
        sound.writeToParcel(parcel, 0);
    } else {
        parcel.writeInt(0);
    }
    parcel.writeInt(audioStreamType);
    parcel.writeLongArray(vibrate);
    parcel.writeInt(ledARGB);
    parcel.writeInt(ledOnMS);
    parcel.writeInt(ledOffMS);
    parcel.writeInt(iconLevel);
    if (fullScreenIntent != null) {
        parcel.writeInt(1);
        fullScreenIntent.writeToParcel(parcel, 0);
    } else {
        parcel.writeInt(0);
    }
    parcel.writeInt(priority);
    // ok for null
    parcel.writeStringArray(kind);
    // null ok
    parcel.writeBundle(extras);
    // null ok
    parcel.writeTypedArray(actions, 0);
    if (bigContentView != null) {
        parcel.writeInt(1);
        bigContentView.writeToParcel(parcel, 0);
    } else {
        parcel.writeInt(0);
    }
}
Body of Second Method:
{
    parcel.writeInt(1);
    parcel.writeLong(when);
    parcel.writeInt(icon);
    parcel.writeInt(number);
    if (contentIntent != null) {
        parcel.writeInt(1);
        contentIntent.writeToParcel(parcel, 0);
    } else {
        parcel.writeInt(0);
    }
    if (deleteIntent != null) {
        parcel.writeInt(1);
        deleteIntent.writeToParcel(parcel, 0);
    } else {
        parcel.writeInt(0);
    }
    if (tickerText != null) {
        parcel.writeInt(1);
        TextUtils.writeToParcel(tickerText, parcel, flags);
    } else {
        parcel.writeInt(0);
    }
    if (tickerView != null) {
        parcel.writeInt(1);
        tickerView.writeToParcel(parcel, 0);
    } else {
        parcel.writeInt(0);
    }
    if (contentView != null) {
        parcel.writeInt(1);
        contentView.writeToParcel(parcel, 0);
    } else {
        parcel.writeInt(0);
    }
    if (largeIcon != null) {
        parcel.writeInt(1);
        largeIcon.writeToParcel(parcel, 0);
    } else {
        parcel.writeInt(0);
    }
    parcel.writeInt(defaults);
    parcel.writeInt(this.flags);
    if (sound != null) {
        parcel.writeInt(1);
        sound.writeToParcel(parcel, 0);
    } else {
        parcel.writeInt(0);
    }
    parcel.writeInt(audioStreamType);
    if (audioAttributes != null) {
        parcel.writeInt(1);
        audioAttributes.writeToParcel(parcel, 0);
    } else {
        parcel.writeInt(0);
    }
    parcel.writeLongArray(vibrate);
    parcel.writeInt(ledARGB);
    parcel.writeInt(ledOnMS);
    parcel.writeInt(ledOffMS);
    parcel.writeInt(iconLevel);
    if (fullScreenIntent != null) {
        parcel.writeInt(1);
        fullScreenIntent.writeToParcel(parcel, 0);
    } else {
        parcel.writeInt(0);
    }
    parcel.writeInt(priority);
    parcel.writeString(category);
    parcel.writeString(mGroupKey);
    parcel.writeString(mSortKey);
    // null ok
    parcel.writeBundle(extras);
    // null ok
    parcel.writeTypedArray(actions, 0);
    if (bigContentView != null) {
        parcel.writeInt(1);
        bigContentView.writeToParcel(parcel, 0);
    } else {
        parcel.writeInt(0);
    }
    if (headsUpContentView != null) {
        parcel.writeInt(1);
        headsUpContentView.writeToParcel(parcel, 0);
    } else {
        parcel.writeInt(0);
    }
    parcel.writeInt(visibility);
    if (publicVersion != null) {
        parcel.writeInt(1);
        publicVersion.writeToParcel(parcel, 0);
    } else {
        parcel.writeInt(0);
    }
    parcel.writeInt(color);
}
------------------------
Find a silently evolved API code:android.graphics.Paint.setTypeface:COMMENT
Method Modifier: public      
Comment:/**
 * Set or clear the typeface object.
 * <p />
 * Pass null to clear any previous typeface.
 * As a convenience, the parameter passed is also returned.
 *
 * @param typeface May be null. The typeface to be installed in the paint
 * @return         typeface
 */

Body of Frist Method:
{
    int typefaceNative = 0;
    if (typeface != null) {
        typefaceNative = typeface.native_instance;
    }
    native_setTypeface(mNativePaint, typefaceNative);
    mTypeface = typeface;
    return typeface;
}
Body of Second Method:
{
    long typefaceNative = 0;
    if (typeface != null) {
        typefaceNative = typeface.native_instance;
    }
    native_setTypeface(mNativePaint, typefaceNative);
    mTypeface = typeface;
    mNativeTypeface = typefaceNative;
    return typeface;
}
------------------------
Find a silently evolved API code:android.graphics.Canvas.drawBitmapMesh:COMMENT
Method Modifier: public      
Comment:/**
 * Draw the bitmap through the mesh, where mesh vertices are evenly
 * distributed across the bitmap. There are meshWidth+1 vertices across, and
 * meshHeight+1 vertices down. The verts array is accessed in row-major
 * order, so that the first meshWidth+1 vertices are distributed across the
 * top of the bitmap from left to right. A more general version of this
 * method is drawVertices().
 *
 * @param bitmap The bitmap to draw using the mesh
 * @param meshWidth The number of columns in the mesh. Nothing is drawn if
 * this is 0
 * @param meshHeight The number of rows in the mesh. Nothing is drawn if
 * this is 0
 * @param verts Array of x,y pairs, specifying where the mesh should be
 * drawn. There must be at least
 * (meshWidth+1) * (meshHeight+1) * 2 + vertOffset values
 * in the array
 * @param vertOffset Number of verts elements to skip before drawing
 * @param colors May be null. Specifies a color at each vertex, which is
 * interpolated across the cell, and whose values are
 * multiplied by the corresponding bitmap colors. If not null,
 * there must be at least (meshWidth+1) * (meshHeight+1) +
 * colorOffset values in the array.
 * @param colorOffset Number of color elements to skip before drawing
 * @param paint  May be null. The paint used to draw the bitmap
 */

Body of Frist Method:
{
    if ((meshWidth | meshHeight | vertOffset | colorOffset) < 0) {
        throw new ArrayIndexOutOfBoundsException();
    }
    if (meshWidth == 0 || meshHeight == 0) {
        return;
    }
    int count = (meshWidth + 1) * (meshHeight + 1);
    // we mul by 2 since we need two floats per vertex
    checkRange(verts.length, vertOffset, count * 2);
    if (colors != null) {
        // no mul by 2, since we need only 1 color per vertex
        checkRange(colors.length, colorOffset, count);
    }
    nativeDrawBitmapMesh(mNativeCanvas, bitmap.ni(), meshWidth, meshHeight, verts, vertOffset, colors, colorOffset, paint != null ? paint.mNativePaint : 0);
}
Body of Second Method:
{
    if ((meshWidth | meshHeight | vertOffset | colorOffset) < 0) {
        throw new ArrayIndexOutOfBoundsException();
    }
    if (meshWidth == 0 || meshHeight == 0) {
        return;
    }
    int count = (meshWidth + 1) * (meshHeight + 1);
    // we mul by 2 since we need two floats per vertex
    checkRange(verts.length, vertOffset, count * 2);
    if (colors != null) {
        // no mul by 2, since we need only 1 color per vertex
        checkRange(colors.length, colorOffset, count);
    }
    nativeDrawBitmapMesh(mNativeCanvasWrapper, bitmap.ni(), meshWidth, meshHeight, verts, vertOffset, colors, colorOffset, paint != null ? paint.mNativePaint : 0);
}
------------------------
Find a silently evolved API code:android.os.Bundle.getFloatArray:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return a float[] value, or null
 */

Body of Frist Method:
{
    unparcel();
    Object o = mMap.get(key);
    if (o == null) {
        return null;
    }
    try {
        return (float[]) o;
    } catch (ClassCastException e) {
        typeWarning(key, o, "float[]", e);
        return null;
    }
}
Body of Second Method:
{
    return super.getFloatArray(key);
}
------------------------
Find a silently evolved API code:android.util.LongSparseLongArray.put:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Adds a mapping from the specified key to the specified value,
 * replacing the previous mapping from the specified key if there
 * was one.
 */

Body of Frist Method:
{
    int i = ContainerHelpers.binarySearch(mKeys, mSize, key);
    if (i >= 0) {
        mValues[i] = value;
    } else {
        i = ~i;
        if (mSize >= mKeys.length) {
            growKeyAndValueArrays(mSize + 1);
        }
        if (mSize - i != 0) {
            System.arraycopy(mKeys, i, mKeys, i + 1, mSize - i);
            System.arraycopy(mValues, i, mValues, i + 1, mSize - i);
        }
        mKeys[i] = key;
        mValues[i] = value;
        mSize++;
    }
}
Body of Second Method:
{
    int i = ContainerHelpers.binarySearch(mKeys, mSize, key);
    if (i >= 0) {
        mValues[i] = value;
    } else {
        i = ~i;
        mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);
        mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);
        mSize++;
    }
}
------------------------
Find a silently evolved API code:android.service.dreams.DreamService.onCreate:COMMENT
Method Modifier: public      
Comment:/**
 * Called when this Dream is constructed.
 */

Body of Frist Method:
{
    if (mDebug)
        Slog.v(TAG, "onCreate() on thread " + Thread.currentThread().getId());
    super.onCreate();
}
Body of Second Method:
{
    if (mDebug)
        Slog.v(TAG, "onCreate()");
    super.onCreate();
}
------------------------
Find a silently evolved API code:android.app.Notification.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Combine all of the options that have been set and return a new {@link Notification}
 * object.
 */

Body of Frist Method:
{
    Notification n = buildUnstyled();
    if (mStyle != null) {
        n = mStyle.buildStyled(n);
    }
    n.extras = mExtras != null ? new Bundle(mExtras) : new Bundle();
    addExtras(n.extras);
    if (mStyle != null) {
        mStyle.addExtras(n.extras);
    }
    return n;
}
Body of Second Method:
{
    mOriginatingUserId = mContext.getUserId();
    mHasThreeLines = hasThreeLines();
    Notification n = buildUnstyled();
    if (mStyle != null) {
        n = mStyle.buildStyled(n);
    }
    if (mExtras != null) {
        n.extras.putAll(mExtras);
    }
    if (mRebuildBundle.size() > 0) {
        n.extras.putAll(mRebuildBundle);
        mRebuildBundle.clear();
    }
    populateExtras(n.extras);
    if (mStyle != null) {
        mStyle.addExtras(n.extras);
    }
    mHasThreeLines = false;
    return n;
}
------------------------
Find a silently evolved API code:android.graphics.NinePatch.getTransparentRegion:COMMENT
Method Modifier: public      final       
Comment:/**
 * Returns a {@link Region} representing the parts of the NinePatch that are
 * completely transparent.
 *
 * @param bounds The location and size of the NinePatch.
 *
 * @return null if the NinePatch has no transparent region to
 * report, else a {@link Region} holding the parts of the specified bounds
 * that are transparent.
 */

Body of Frist Method:
{
    int r = nativeGetTransparentRegion(mBitmap.ni(), mNativeChunk, bounds);
    return r != 0 ? new Region(r) : null;
}
Body of Second Method:
{
    long r = nativeGetTransparentRegion(mBitmap.ni(), mNativeChunk, bounds);
    return r != 0 ? new Region(r) : null;
}
------------------------
Find a silently evolved API code:android.media.MediaPlayer.start:COMMENT
Method Modifier: public      
Comment:/**
 * Starts or resumes playback. If playback had previously been paused,
 * playback will continue from where it was paused. If playback had
 * been stopped, or never started before, playback will start at the
 * beginning.
 *
 * @throws IllegalStateException if it is called in an invalid state
 */

Body of Frist Method:
{
    stayAwake(true);
    _start();
}
Body of Second Method:
{
    if (isRestricted()) {
        _setVolume(0, 0);
    }
    stayAwake(true);
    _start();
}
------------------------
Find a silently evolved API code:android.util.SparseArray.append:COMMENT
Method Modifier: public      
Comment:/**
 * Puts a key/value pair into the array, optimizing for the case where
 * the key is greater than all existing keys in the array.
 */

Body of Frist Method:
{
    if (mSize != 0 && key <= mKeys[mSize - 1]) {
        put(key, value);
        return;
    }
    if (mGarbage && mSize >= mKeys.length) {
        gc();
    }
    int pos = mSize;
    if (pos >= mKeys.length) {
        int n = ArrayUtils.idealIntArraySize(pos + 1);
        int[] nkeys = new int[n];
        Object[] nvalues = new Object[n];
        // Log.e("SparseArray", "grow " + mKeys.length + " to " + n);
        System.arraycopy(mKeys, 0, nkeys, 0, mKeys.length);
        System.arraycopy(mValues, 0, nvalues, 0, mValues.length);
        mKeys = nkeys;
        mValues = nvalues;
    }
    mKeys[pos] = key;
    mValues[pos] = value;
    mSize = pos + 1;
}
Body of Second Method:
{
    if (mSize != 0 && key <= mKeys[mSize - 1]) {
        put(key, value);
        return;
    }
    if (mGarbage && mSize >= mKeys.length) {
        gc();
    }
    mKeys = GrowingArrayUtils.append(mKeys, mSize, key);
    mValues = GrowingArrayUtils.append(mValues, mSize, value);
    mSize++;
}
------------------------
Find a silently evolved API code:android.graphics.drawable.ColorDrawable.getAlpha:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the alpha value of this drawable's color.
 *
 * @return A value between 0 and 255.
 */

Body of Frist Method:
{
    return mState.mUseColor >>> 24;
}
Body of Second Method:
{
    return mColorState.mUseColor >>> 24;
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiInfo.writeToParcel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Implement the Parcelable interface {@hide}
 */

Body of Frist Method:
{
    dest.writeInt(mNetworkId);
    dest.writeInt(mRssi);
    dest.writeInt(mLinkSpeed);
    if (mIpAddress != null) {
        dest.writeByte((byte) 1);
        dest.writeByteArray(mIpAddress.getAddress());
    } else {
        dest.writeByte((byte) 0);
    }
    if (mWifiSsid != null) {
        dest.writeInt(1);
        mWifiSsid.writeToParcel(dest, flags);
    } else {
        dest.writeInt(0);
    }
    dest.writeString(mBSSID);
    dest.writeString(mMacAddress);
    dest.writeInt(mMeteredHint ? 1 : 0);
    mSupplicantState.writeToParcel(dest, flags);
}
Body of Second Method:
{
    dest.writeInt(mNetworkId);
    dest.writeInt(mRssi);
    dest.writeInt(mLinkSpeed);
    dest.writeInt(mFrequency);
    if (mIpAddress != null) {
        dest.writeByte((byte) 1);
        dest.writeByteArray(mIpAddress.getAddress());
    } else {
        dest.writeByte((byte) 0);
    }
    if (mWifiSsid != null) {
        dest.writeInt(1);
        mWifiSsid.writeToParcel(dest, flags);
    } else {
        dest.writeInt(0);
    }
    dest.writeString(mBSSID);
    dest.writeString(mMacAddress);
    dest.writeInt(mMeteredHint ? 1 : 0);
    dest.writeInt(score);
    dest.writeDouble(txSuccessRate);
    dest.writeDouble(txRetriesRate);
    dest.writeDouble(txBadRate);
    dest.writeDouble(rxSuccessRate);
    dest.writeInt(badRssiCount);
    dest.writeInt(lowRssiCount);
    mSupplicantState.writeToParcel(dest, flags);
}
------------------------
Find a silently evolved API code:android.transition.Transition.resume:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Resumes this transition, sending out calls to {@link
 * TransitionListener#onTransitionPause(Transition)} to all listeners
 * and pausing all running animators started by this transition.
 *
 * @hide
 */

Body of Frist Method:
{
    if (mPaused) {
        if (!mEnded) {
            ArrayMap<Animator, AnimationInfo> runningAnimators = getRunningAnimators();
            int numOldAnims = runningAnimators.size();
            for (int i = numOldAnims - 1; i >= 0; i--) {
                Animator anim = runningAnimators.keyAt(i);
                anim.resume();
            }
            if (mListeners != null && mListeners.size() > 0) {
                ArrayList<TransitionListener> tmpListeners = (ArrayList<TransitionListener>) mListeners.clone();
                int numListeners = tmpListeners.size();
                for (int i = 0; i < numListeners; ++i) {
                    tmpListeners.get(i).onTransitionResume(this);
                }
            }
        }
        mPaused = false;
    }
}
Body of Second Method:
{
    if (mPaused) {
        if (!mEnded) {
            ArrayMap<Animator, AnimationInfo> runningAnimators = getRunningAnimators();
            int numOldAnims = runningAnimators.size();
            WindowId windowId = sceneRoot.getWindowId();
            for (int i = numOldAnims - 1; i >= 0; i--) {
                AnimationInfo info = runningAnimators.valueAt(i);
                if (info.view != null && windowId != null && windowId.equals(info.windowId)) {
                    Animator anim = runningAnimators.keyAt(i);
                    anim.resume();
                }
            }
            if (mListeners != null && mListeners.size() > 0) {
                ArrayList<TransitionListener> tmpListeners = (ArrayList<TransitionListener>) mListeners.clone();
                int numListeners = tmpListeners.size();
                for (int i = 0; i < numListeners; ++i) {
                    tmpListeners.get(i).onTransitionResume(this);
                }
            }
        }
        mPaused = false;
    }
}
------------------------
Find a silently evolved API code:android.widget.Switch.stopDrag:COMMENT
Method Modifier: private     
Comment:/**
 * Called from onTouchEvent to end a drag operation.
 *
 * @param ev Event that triggered the end of drag mode - ACTION_UP or ACTION_CANCEL
 */

Body of Frist Method:
{
    mTouchMode = TOUCH_MODE_IDLE;
    // Up and not canceled, also checks the switch has not been disabled during the drag
    boolean commitChange = ev.getAction() == MotionEvent.ACTION_UP && isEnabled();
    cancelSuperTouch(ev);
    if (commitChange) {
        boolean newState;
        mVelocityTracker.computeCurrentVelocity(1000);
        float xvel = mVelocityTracker.getXVelocity();
        if (Math.abs(xvel) > mMinFlingVelocity) {
            newState = isLayoutRtl() ? (xvel < 0) : (xvel > 0);
        } else {
            newState = getTargetCheckedState();
        }
        animateThumbToCheckedState(newState);
    } else {
        animateThumbToCheckedState(isChecked());
    }
}
Body of Second Method:
{
    mTouchMode = TOUCH_MODE_IDLE;
    // Commit the change if the event is up and not canceled and the switch
    // has not been disabled during the drag.
    final boolean commitChange = ev.getAction() == MotionEvent.ACTION_UP && isEnabled();
    final boolean newState;
    if (commitChange) {
        mVelocityTracker.computeCurrentVelocity(1000);
        final float xvel = mVelocityTracker.getXVelocity();
        if (Math.abs(xvel) > mMinFlingVelocity) {
            newState = isLayoutRtl() ? (xvel < 0) : (xvel > 0);
        } else {
            newState = getTargetCheckedState();
        }
    } else {
        newState = isChecked();
    }
    setChecked(newState);
    cancelSuperTouch(ev);
}
------------------------
Find a silently evolved API code:android.util.SparseBooleanArray.append:COMMENT
Method Modifier: public      
Comment:/**
 * Puts a key/value pair into the array, optimizing for the case where
 * the key is greater than all existing keys in the array.
 */

Body of Frist Method:
{
    if (mSize != 0 && key <= mKeys[mSize - 1]) {
        put(key, value);
        return;
    }
    int pos = mSize;
    if (pos >= mKeys.length) {
        int n = ArrayUtils.idealIntArraySize(pos + 1);
        int[] nkeys = new int[n];
        boolean[] nvalues = new boolean[n];
        // Log.e("SparseBooleanArray", "grow " + mKeys.length + " to " + n);
        System.arraycopy(mKeys, 0, nkeys, 0, mKeys.length);
        System.arraycopy(mValues, 0, nvalues, 0, mValues.length);
        mKeys = nkeys;
        mValues = nvalues;
    }
    mKeys[pos] = key;
    mValues[pos] = value;
    mSize = pos + 1;
}
Body of Second Method:
{
    if (mSize != 0 && key <= mKeys[mSize - 1]) {
        put(key, value);
        return;
    }
    mKeys = GrowingArrayUtils.append(mKeys, mSize, key);
    mValues = GrowingArrayUtils.append(mValues, mSize, value);
    mSize++;
}
------------------------
Find a silently evolved API code:android.widget.Switch.setTrackResource:COMMENT
Method Modifier: public      
Comment:/**
 * Set the drawable used for the track that the switch slides within.
 *
 * @param resId Resource ID of a track drawable
 *
 * @attr ref android.R.styleable#Switch_track
 */

Body of Frist Method:
{
    setTrackDrawable(getContext().getResources().getDrawable(resId));
}
Body of Second Method:
{
    setTrackDrawable(getContext().getDrawable(resId));
}
------------------------
Find a silently evolved API code:android.content.res.AssetManager.ensureStringBlocks:COMMENT
Method Modifier: default     final       
Comment:/*package*/

Body of Frist Method:
{
    if (mStringBlocks == null) {
        synchronized (this) {
            if (mStringBlocks == null) {
                makeStringBlocks(true);
            }
        }
    }
}
Body of Second Method:
{
    if (mStringBlocks == null) {
        synchronized (this) {
            if (mStringBlocks == null) {
                makeStringBlocks(sSystem.mStringBlocks);
            }
        }
    }
}
------------------------
Find a silently evolved API code:android.animation.PropertyValuesHolder.calculateValue:COMMENT
Method Modifier: default     
Comment:/**
 * Function used to calculate the value according to the evaluator set up for
 * this PropertyValuesHolder object. This function is called by ValueAnimator.animateValue().
 *
 * @param fraction The elapsed, interpolated fraction of the animation.
 */

Body of Frist Method:
{
    mAnimatedValue = mKeyframeSet.getValue(fraction);
}
Body of Second Method:
{
    Object value = mKeyframes.getValue(fraction);
    mAnimatedValue = mConverter == null ? value : mConverter.convert(value);
}
------------------------
Find a silently evolved API code:android.graphics.Canvas.getSaveCount:COMMENT
<android.graphics.Canvas: int getSaveCount()>
public      native      ->public      
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * Returns the number of matrix/clip states on the Canvas' private stack.
 * This will equal # save() calls - # restore() calls.
 */

Body of Frist Method:

Body of Second Method:
{
    return native_getSaveCount(mNativeCanvasWrapper);
}
------------------------
Find a silently evolved API code:android.view.inputmethod.BaseInputConnection.setComposingText:COMMENT
Method Modifier: public      
Comment:/**
 * The default implementation places the given text into the editable,
 * replacing any existing composing text.  The new text is marked as
 * in a composing state with the composing style.
 */

Body of Frist Method:
{
    if (DEBUG)
        Log.v(TAG, "setComposingText " + text);
    replaceText(text, newCursorPosition, true);
    return true;
}
Body of Second Method:
{
    if (DEBUG)
        Log.v(TAG, "setComposingText " + text);
    replaceText(text, newCursorPosition, true);
    mIMM.notifyUserAction();
    return true;
}
------------------------
Find a silently evolved API code:android.view.HardwareRenderer.trimMemory:COMMENT
Method Modifier: default     static      hidden      
Comment:/**
 * Invoke this method when the system is running out of memory. This
 * method will attempt to recover as much memory as possible, based on
 * the specified hint.
 *
 * @param level Hint about the amount of memory that should be trimmed,
 * see {@link android.content.ComponentCallbacks}
 */

Body of Frist Method:
{
    startTrimMemory(level);
    endTrimMemory();
}
Body of Second Method:
{
    ThreadedRenderer.trimMemory(level);
}
------------------------
Find a silently evolved API code:android.media.AudioService.sendMasterMuteUpdate:COMMENT
Method Modifier: private     hidden      
Comment:// UI update and Broadcast Intent

Body of Frist Method:
{
    mVolumePanel.postMasterMuteChanged(flags);
    broadcastMasterMuteStatus(muted);
}
Body of Second Method:
{
    mVolumeController.postMasterMuteChanged(flags);
    broadcastMasterMuteStatus(muted);
}
------------------------
Find a silently evolved API code:android.widget.AutoCompleteTextView.setAdapter:COMMENT
Method Modifier: public      
Comment:/**
 * <p>Changes the list of data used for auto completion. The provided list
 * must be a filterable list adapter.</p>
 *
 * <p>The caller is still responsible for managing any resources used by the adapter.
 * Notably, when the AutoCompleteTextView is closed or released, the adapter is not notified.
 * A common case is the use of {@link android.widget.CursorAdapter}, which
 * contains a {@link android.database.Cursor} that must be closed.  This can be done
 * automatically (see
 * {@link android.app.Activity#startManagingCursor(android.database.Cursor)
 * startManagingCursor()}),
 * or by manually closing the cursor when the AutoCompleteTextView is dismissed.</p>
 *
 * @param adapter the adapter holding the auto completion data
 *
 * @see #getAdapter()
 * @see android.widget.Filterable
 * @see android.widget.ListAdapter
 */

Body of Frist Method:
{
    if (mObserver == null) {
        mObserver = new PopupDataSetObserver();
    } else if (mAdapter != null) {
        mAdapter.unregisterDataSetObserver(mObserver);
    }
    mAdapter = adapter;
    if (mAdapter != null) {
        // noinspection unchecked
        mFilter = ((Filterable) mAdapter).getFilter();
        adapter.registerDataSetObserver(mObserver);
    } else {
        mFilter = null;
    }
    mPopup.setAdapter(mAdapter);
}
Body of Second Method:
{
    if (mObserver == null) {
        mObserver = new PopupDataSetObserver(this);
    } else if (mAdapter != null) {
        mAdapter.unregisterDataSetObserver(mObserver);
    }
    mAdapter = adapter;
    if (mAdapter != null) {
        // noinspection unchecked
        mFilter = ((Filterable) mAdapter).getFilter();
        adapter.registerDataSetObserver(mObserver);
    } else {
        mFilter = null;
    }
    mPopup.setAdapter(mAdapter);
}
------------------------
Find a silently evolved API code:android.content.res.TypedArray.getFraction:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve a fractional unit attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 * @param base The base value of this fraction.  In other words, a
 * standard fraction is multiplied by this value.
 * @param pbase The parent base value of this fraction.  In other
 * words, a parent fraction (nn%p) is multiplied by this
 * value.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute fractional value multiplied by the appropriate
 * base value, or defValue if not defined.
 */

Body of Frist Method:
{
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_FRACTION) {
        return TypedValue.complexToFraction(data[index + AssetManager.STYLE_DATA], base, pbase);
    }
    throw new UnsupportedOperationException("Can't convert to fraction: type=0x" + Integer.toHexString(type));
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_FRACTION) {
        return TypedValue.complexToFraction(data[index + AssetManager.STYLE_DATA], base, pbase);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        throw new RuntimeException("Failed to resolve attribute at index " + index);
    }
    throw new UnsupportedOperationException("Can't convert to fraction: type=0x" + Integer.toHexString(type));
}
------------------------
Find a silently evolved API code:android.media.MediaRouter.removeCallback:COMMENT
Method Modifier: public      
Comment:/**
 * Remove the specified callback. It will no longer receive events about media routing.
 *
 * @param cb Callback to remove
 */

Body of Frist Method:
{
    int index = findCallbackInfo(cb);
    if (index >= 0) {
        CallbackInfo info = sStatic.mCallbacks.remove(index);
        if ((info.flags & CALLBACK_FLAG_PERFORM_ACTIVE_SCAN) != 0) {
            sStatic.updateActiveScan();
        }
    } else {
        Log.w(TAG, "removeCallback(" + cb + "): callback not registered");
    }
}
Body of Second Method:
{
    int index = findCallbackInfo(cb);
    if (index >= 0) {
        sStatic.mCallbacks.remove(index);
        sStatic.updateDiscoveryRequest();
    } else {
        Log.w(TAG, "removeCallback(" + cb + "): callback not registered");
    }
}
------------------------
Find a silently evolved API code:android.app.Activity.getActionBar:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve a reference to this activity's ActionBar.
 *
 * @return The Activity's ActionBar, or null if it does not have one.
 */

Body of Frist Method:
{
    initActionBar();
    return mActionBar;
}
Body of Second Method:
{
    initWindowDecorActionBar();
    return mActionBar;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothGatt.readDescriptor:COMMENT
Method Modifier: public      
Comment:/**
 * Reads the value for a given descriptor from the associated remote device.
 *
 * <p>Once the read operation has been completed, the
 * {@link BluetoothGattCallback#onDescriptorRead} callback is
 * triggered, signaling the result of the operation.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param descriptor Descriptor value to read from the remote device
 * @return true, if the read operation was initiated successfully
 */

Body of Frist Method:
{
    if (DBG)
        Log.d(TAG, "readDescriptor() - uuid: " + descriptor.getUuid());
    if (mService == null || mClientIf == 0)
        return false;
    BluetoothGattCharacteristic characteristic = descriptor.getCharacteristic();
    if (characteristic == null)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    try {
        mService.readDescriptor(mClientIf, device.getAddress(), service.getType(), service.getInstanceId(), new ParcelUuid(service.getUuid()), characteristic.getInstanceId(), new ParcelUuid(characteristic.getUuid()), descriptor.getInstanceId(), new ParcelUuid(descriptor.getUuid()), AUTHENTICATION_NONE);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        return false;
    }
    return true;
}
Body of Second Method:
{
    if (VDBG)
        Log.d(TAG, "readDescriptor() - uuid: " + descriptor.getUuid());
    if (mService == null || mClientIf == 0)
        return false;
    BluetoothGattCharacteristic characteristic = descriptor.getCharacteristic();
    if (characteristic == null)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusy) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.readDescriptor(mClientIf, device.getAddress(), service.getType(), service.getInstanceId(), new ParcelUuid(service.getUuid()), characteristic.getInstanceId(), new ParcelUuid(characteristic.getUuid()), descriptor.getInstanceId(), new ParcelUuid(descriptor.getUuid()), AUTHENTICATION_NONE);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}
------------------------
Find a silently evolved API code:android.widget.FastScroller.startPendingDrag:COMMENT
Method Modifier: private     
Comment:/**
 * Delays dragging until after the framework has determined that the user is
 * scrolling, rather than tapping.
 */

Body of Frist Method:
{
    mHasPendingDrag = true;
    mList.postDelayed(mDeferStartDrag, TAP_TIMEOUT);
}
Body of Second Method:
{
    mPendingDrag = SystemClock.uptimeMillis() + TAP_TIMEOUT;
}
------------------------
Find a silently evolved API code:android.view.accessibility.AccessibilityManager.getInstalledAccessibilityServiceList:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the {@link AccessibilityServiceInfo}s of the installed accessibility services.
 *
 * @return An unmodifiable list with {@link AccessibilityServiceInfo}s.
 */

Body of Frist Method:
{
    List<AccessibilityServiceInfo> services = null;
    try {
        services = mService.getInstalledAccessibilityServiceList(mUserId);
        if (DEBUG) {
            Log.i(LOG_TAG, "Installed AccessibilityServices " + services);
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, "Error while obtaining the installed AccessibilityServices. ", re);
    }
    return Collections.unmodifiableList(services);
}
Body of Second Method:
{
    final IAccessibilityManager service;
    final int userId;
    synchronized (mLock) {
        service = getServiceLocked();
        if (service == null) {
            return Collections.emptyList();
        }
        userId = mUserId;
    }
    List<AccessibilityServiceInfo> services = null;
    try {
        services = service.getInstalledAccessibilityServiceList(userId);
        if (DEBUG) {
            Log.i(LOG_TAG, "Installed AccessibilityServices " + services);
        }
    } catch (RemoteException re) {
        Log.e(LOG_TAG, "Error while obtaining the installed AccessibilityServices. ", re);
    }
    if (services != null) {
        return Collections.unmodifiableList(services);
    } else {
        return Collections.emptyList();
    }
}
------------------------
Find a silently evolved API code:android.widget.CalendarView.setFirstDayOfWeek:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the first day of week.
 *
 * @param firstDayOfWeek The first day of the week conforming to the
 * {@link CalendarView} APIs.
 * @see Calendar#MONDAY
 * @see Calendar#TUESDAY
 * @see Calendar#WEDNESDAY
 * @see Calendar#THURSDAY
 * @see Calendar#FRIDAY
 * @see Calendar#SATURDAY
 * @see Calendar#SUNDAY
 *
 * @attr ref android.R.styleable#CalendarView_firstDayOfWeek
 */

Body of Frist Method:
{
    if (mFirstDayOfWeek == firstDayOfWeek) {
        return;
    }
    mFirstDayOfWeek = firstDayOfWeek;
    mAdapter.init();
    setUpHeader();
}
Body of Second Method:
{
    mDelegate.setFirstDayOfWeek(firstDayOfWeek);
}
------------------------
Find a silently evolved API code:android.content.res.AssetManager.openXmlBlockAsset:COMMENT
Method Modifier: default     final       
Comment:/*package*/

Body of Frist Method:
{
    return openXmlBlockAsset(0, fileName);
}
Body of Second Method:
{
    synchronized (this) {
        if (!mOpen) {
            throw new RuntimeException("Assetmanager has been closed");
        }
        long xmlBlock = openXmlAssetNative(cookie, fileName);
        if (xmlBlock != 0) {
            XmlBlock res = new XmlBlock(this, xmlBlock);
            incRefsLocked(res.hashCode());
            return res;
        }
    }
    throw new FileNotFoundException("Asset XML file: " + fileName);
}
------------------------
Find a silently evolved API code:android.view.HardwareLayer.copyInto:COMMENT
<android.view.HardwareLayer: boolean copyInto(Bitmap)>
default     abstract    ->public      hidden      
Method Modifier: public      default     abstract    hidden      
Method Modifier: No          Yes         Yes         No          
Method Updated:  Yes         No          No          Yes         
Comment:/**
 * Copies this layer into the specified bitmap.
 *
 * @param bitmap The bitmap to copy they layer into
 *
 * @return True if the copy was successful, false otherwise
 */

Body of Frist Method:

Body of Second Method:
{
    return mRenderer.copyLayerInto(this, bitmap);
}
------------------------
Find a silently evolved API code:android.service.dreams.DreamService.dispatchKeyEvent:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    // TODO: create more flexible version of mInteractive that allows use of KEYCODE_BACK
    if (!mInteractive) {
        if (mDebug)
            Slog.v(TAG, "Finishing on keyEvent");
        safelyFinish();
        return true;
    } else if (event.getKeyCode() == KeyEvent.KEYCODE_BACK) {
        if (mDebug)
            Slog.v(TAG, "Finishing on back key");
        safelyFinish();
        return true;
    }
    return mWindow.superDispatchKeyEvent(event);
}
Body of Second Method:
{
    // TODO: create more flexible version of mInteractive that allows use of KEYCODE_BACK
    if (!mInteractive) {
        if (mDebug)
            Slog.v(TAG, "Waking up on keyEvent");
        wakeUp();
        return true;
    } else if (event.getKeyCode() == KeyEvent.KEYCODE_BACK) {
        if (mDebug)
            Slog.v(TAG, "Waking up on back key");
        wakeUp();
        return true;
    }
    return mWindow.superDispatchKeyEvent(event);
}
------------------------
Find a silently evolved API code:android.media.RemoteControlClient.editMetadata:COMMENT
<android.media.RemoteControlClient: MetadataEditor editMetadata(boolean)>
public      ->public      deprecated  
Method Modifier: public      deprecated  
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Creates a {@link MetadataEditor}.
 * @param startEmpty Set to false if you want the MetadataEditor to contain the metadata that
 * was previously applied to the RemoteControlClient, or true if it is to be created empty.
 * @return a new MetadataEditor instance.
 */

Body of Frist Method:
{
    MetadataEditor editor = new MetadataEditor();
    if (startEmpty) {
        editor.mEditorMetadata = new Bundle();
        editor.mEditorArtwork = null;
        editor.mMetadataChanged = true;
        editor.mArtworkChanged = true;
        editor.mEditableKeys = 0;
    } else {
        editor.mEditorMetadata = new Bundle(mMetadata);
        editor.mEditorArtwork = mOriginalArtwork;
        editor.mMetadataChanged = false;
        editor.mArtworkChanged = false;
    }
    return editor;
}
Body of Second Method:
{
    MetadataEditor editor = new MetadataEditor();
    if (startEmpty) {
        editor.mEditorMetadata = new Bundle();
        editor.mEditorArtwork = null;
        editor.mMetadataChanged = true;
        editor.mArtworkChanged = true;
        editor.mEditableKeys = 0;
    } else {
        editor.mEditorMetadata = new Bundle(mMetadata);
        editor.mEditorArtwork = mOriginalArtwork;
        editor.mMetadataChanged = false;
        editor.mArtworkChanged = false;
    }
    // USE_SESSIONS
    if (startEmpty || mMediaMetadata == null) {
        editor.mMetadataBuilder = new MediaMetadata.Builder();
    } else {
        editor.mMetadataBuilder = new MediaMetadata.Builder(mMediaMetadata);
    }
    return editor;
}
------------------------
Find a silently evolved API code:android.content.RestrictionEntry.setTitle:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the user-visible title for the entry.
 * @param title the user-visible title for the entry.
 */

Body of Frist Method:
{
    this.title = title;
}
Body of Second Method:
{
    this.mTitle = title;
}
------------------------
Find a silently evolved API code:android.telephony.PhoneNumberUtils.getNumberFromIntent:COMMENT
Method Modifier: public      static      
Comment:/**
 * Extracts the phone number from an Intent.
 *
 * @param intent the intent to get the number of
 * @param context a context to use for database access
 *
 * @return the phone number that would be called by the intent, or
 * <code>null</code> if the number cannot be found.
 */

Body of Frist Method:
{
    String number = null;
    Uri uri = intent.getData();
    if (uri == null) {
        return null;
    }
    String scheme = uri.getScheme();
    if (scheme.equals("tel") || scheme.equals("sip")) {
        return uri.getSchemeSpecificPart();
    }
    // CALL_PRIVILEGED permission).
    if (scheme.equals("voicemail")) {
        return TelephonyManager.getDefault().getCompleteVoiceMailNumber();
    }
    if (context == null) {
        return null;
    }
    String type = intent.resolveType(context);
    String phoneColumn = null;
    // Correctly read out the phone entry based on requested provider
    final String authority = uri.getAuthority();
    if (Contacts.AUTHORITY.equals(authority)) {
        phoneColumn = Contacts.People.Phones.NUMBER;
    } else if (ContactsContract.AUTHORITY.equals(authority)) {
        phoneColumn = ContactsContract.CommonDataKinds.Phone.NUMBER;
    }
    final Cursor c = context.getContentResolver().query(uri, new String[] { phoneColumn }, null, null, null);
    if (c != null) {
        try {
            if (c.moveToFirst()) {
                number = c.getString(c.getColumnIndex(phoneColumn));
            }
        } finally {
            c.close();
        }
    }
    return number;
}
Body of Second Method:
{
    String number = null;
    Uri uri = intent.getData();
    if (uri == null) {
        return null;
    }
    String scheme = uri.getScheme();
    if (scheme.equals("tel") || scheme.equals("sip")) {
        return uri.getSchemeSpecificPart();
    }
    if (context == null) {
        return null;
    }
    String type = intent.resolveType(context);
    String phoneColumn = null;
    // Correctly read out the phone entry based on requested provider
    final String authority = uri.getAuthority();
    if (Contacts.AUTHORITY.equals(authority)) {
        phoneColumn = Contacts.People.Phones.NUMBER;
    } else if (ContactsContract.AUTHORITY.equals(authority)) {
        phoneColumn = ContactsContract.CommonDataKinds.Phone.NUMBER;
    }
    final Cursor c = context.getContentResolver().query(uri, new String[] { phoneColumn }, null, null, null);
    if (c != null) {
        try {
            if (c.moveToFirst()) {
                number = c.getString(c.getColumnIndex(phoneColumn));
            }
        } finally {
            c.close();
        }
    }
    return number;
}
------------------------
Find a silently evolved API code:android.security.KeyChain.bind:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide for reuse by CertInstaller and Settings.
 *
 * Caller should call unbindService on the result when finished.
 */

Body of Frist Method:
{
    if (context == null) {
        throw new NullPointerException("context == null");
    }
    ensureNotOnMainThread(context);
    final BlockingQueue<IKeyChainService> q = new LinkedBlockingQueue<IKeyChainService>(1);
    ServiceConnection keyChainServiceConnection = new ServiceConnection() {

        volatile boolean mConnectedAtLeastOnce = false;

        @Override
        public void onServiceConnected(ComponentName name, IBinder service) {
            if (!mConnectedAtLeastOnce) {
                mConnectedAtLeastOnce = true;
                try {
                    q.put(IKeyChainService.Stub.asInterface(service));
                } catch (InterruptedException e) {
                // will never happen, since the queue starts with one available slot
                }
            }
        }

        @Override
        public void onServiceDisconnected(ComponentName name) {
        }
    };
    Intent intent = new Intent(IKeyChainService.class.getName());
    ComponentName comp = intent.resolveSystemService(context.getPackageManager(), 0);
    intent.setComponent(comp);
    boolean isBound = context.bindService(intent, keyChainServiceConnection, Context.BIND_AUTO_CREATE);
    if (!isBound) {
        throw new AssertionError("could not bind to KeyChainService");
    }
    return new KeyChainConnection(context, keyChainServiceConnection, q.take());
}
Body of Second Method:
{
    return bindAsUser(context, Process.myUserHandle());
}
------------------------
Find a silently evolved API code:android.graphics.Path.toggleInverseFillType:COMMENT
Method Modifier: public      
Comment:/**
 * Toggles the INVERSE state of the filltype
 */

Body of Frist Method:
{
    int ft = native_getFillType(mNativePath);
    ft ^= 2;
    native_setFillType(mNativePath, ft);
}
Body of Second Method:
{
    int ft = native_getFillType(mNativePath);
    ft ^= FillType.INVERSE_WINDING.nativeInt;
    native_setFillType(mNativePath, ft);
}
------------------------
Find a silently evolved API code:android.content.RestrictionEntry.getChoiceEntries:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the list of strings, set earlier, that will be presented as choices to the user.
 * @return the list of choices presented to the user.
 */

Body of Frist Method:
{
    return choices;
}
Body of Second Method:
{
    return mChoiceEntries;
}
------------------------
Find a silently evolved API code:android.media.ImageReader.getNumPlanesFromFormat:COMMENT
Method Modifier: private     
Comment:/**
 * Only a subset of the formats defined in
 * {@link android.graphics.ImageFormat ImageFormat} and
 * {@link android.graphics.PixelFormat PixelFormat} are supported by
 * ImageReader. When reading RGB data from a surface, the formats defined in
 * {@link android.graphics.PixelFormat PixelFormat} can be used, when
 * reading YUV, JPEG or raw sensor data (for example, from camera or video
 * decoder), formats from {@link android.graphics.ImageFormat ImageFormat}
 * are used.
 */

Body of Frist Method:
{
    switch(mFormat) {
        case ImageFormat.YV12:
        case ImageFormat.YUV_420_888:
        case ImageFormat.NV21:
            return 3;
        case ImageFormat.NV16:
            return 2;
        case PixelFormat.RGB_565:
        case PixelFormat.RGBA_8888:
        case PixelFormat.RGBX_8888:
        case PixelFormat.RGB_888:
        case ImageFormat.JPEG:
        case ImageFormat.YUY2:
        case ImageFormat.Y8:
        case ImageFormat.Y16:
        case ImageFormat.RAW_SENSOR:
            return 1;
        default:
            throw new UnsupportedOperationException(String.format("Invalid format specified %d", mFormat));
    }
}
Body of Second Method:
{
    switch(mFormat) {
        case ImageFormat.YV12:
        case ImageFormat.YUV_420_888:
        case ImageFormat.NV21:
            return 3;
        case ImageFormat.NV16:
            return 2;
        case PixelFormat.RGB_565:
        case PixelFormat.RGBA_8888:
        case PixelFormat.RGBX_8888:
        case PixelFormat.RGB_888:
        case ImageFormat.JPEG:
        case ImageFormat.YUY2:
        case ImageFormat.Y8:
        case ImageFormat.Y16:
        case ImageFormat.RAW_SENSOR:
        case ImageFormat.RAW10:
            return 1;
        default:
            throw new UnsupportedOperationException(String.format("Invalid format specified %d", mFormat));
    }
}
------------------------
Find a silently evolved API code:android.graphics.Typeface.createFromFile:COMMENT
Method Modifier: public      static      
Comment:/**
 * Create a new typeface from the specified font file.
 *
 * @param path The full path to the font data.
 * @return The new typeface.
 */

Body of Frist Method:
{
    return new Typeface(nativeCreateFromFile(path));
}
Body of Second Method:
{
    if (sFallbackFonts != null) {
        FontFamily fontFamily = new FontFamily();
        if (fontFamily.addFont(path)) {
            FontFamily[] families = { fontFamily };
            return createFromFamiliesWithDefault(families);
        }
    }
    throw new RuntimeException("Font not found " + path);
}
------------------------
Find a silently evolved API code:android.media.AudioManager.setMicrophoneMute:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the microphone mute on or off.
 * <p>
 * This method should only be used by applications that replace the platform-wide
 * management of audio settings or the main telephony application.
 *
 * @param on set <var>true</var> to mute the microphone;
 * <var>false</var> to turn mute off
 */

Body of Frist Method:
{
    AudioSystem.muteMicrophone(on);
}
Body of Second Method:
{
    IAudioService service = getService();
    try {
        service.setMicrophoneMute(on, mContext.getOpPackageName());
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in setMicrophoneMute", e);
    }
}
------------------------
Find a silently evolved API code:android.widget.TimePicker.setIs24HourView:COMMENT
Method Modifier: public      
Comment:/**
 * Set whether in 24 hour or AM/PM mode.
 *
 * @param is24HourView True = 24 hour mode. False = AM/PM.
 */

Body of Frist Method:
{
    if (mIs24HourView == is24HourView) {
        return;
    }
    // cache the current hour since spinner range changes and BEFORE changing mIs24HourView!!
    int currentHour = getCurrentHour();
    // Order is important here.
    mIs24HourView = is24HourView;
    getHourFormatData();
    updateHourControl();
    // set value after spinner range is updated - be aware that because mIs24HourView has
    // changed then getCurrentHour() is not equal to the currentHour we cached before so
    // explicitly ask for *not* propagating any onTimeChanged()
    setCurrentHour(currentHour, false);
    updateMinuteControl();
    updateAmPmControl();
}
Body of Second Method:
{
    mDelegate.setIs24HourView(is24HourView);
}
------------------------
Find a silently evolved API code:android.printservice.PrintServiceInfo.create:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Creates a new instance.
 *
 * @param resolveInfo The service resolve info.
 * @param context Context for accessing resources.
 * @throws XmlPullParserException If a XML parsing error occurs.
 * @throws IOException If a I/O error occurs.
 */

Body of Frist Method:
{
    String settingsActivityName = null;
    String addPrintersActivityName = null;
    XmlResourceParser parser = null;
    PackageManager packageManager = context.getPackageManager();
    parser = resolveInfo.serviceInfo.loadXmlMetaData(packageManager, PrintService.SERVICE_META_DATA);
    if (parser != null) {
        try {
            int type = 0;
            while (type != XmlPullParser.END_DOCUMENT && type != XmlPullParser.START_TAG) {
                type = parser.next();
            }
            String nodeName = parser.getName();
            if (!TAG_PRINT_SERVICE.equals(nodeName)) {
                Log.e(LOG_TAG, "Ignoring meta-data that does not start with " + TAG_PRINT_SERVICE + " tag");
            } else {
                Resources resources = packageManager.getResourcesForApplication(resolveInfo.serviceInfo.applicationInfo);
                AttributeSet allAttributes = Xml.asAttributeSet(parser);
                TypedArray attributes = resources.obtainAttributes(allAttributes, com.android.internal.R.styleable.PrintService);
                settingsActivityName = attributes.getString(com.android.internal.R.styleable.PrintService_settingsActivity);
                addPrintersActivityName = attributes.getString(com.android.internal.R.styleable.PrintService_addPrintersActivity);
                attributes.recycle();
            }
        } catch (IOException ioe) {
            Log.w(LOG_TAG, "Error reading meta-data:" + ioe);
        } catch (XmlPullParserException xppe) {
            Log.w(LOG_TAG, "Error reading meta-data:" + xppe);
        } catch (NameNotFoundException e) {
            Log.e(LOG_TAG, "Unable to load resources for: " + resolveInfo.serviceInfo.packageName);
        } finally {
            if (parser != null) {
                parser.close();
            }
        }
    }
    return new PrintServiceInfo(resolveInfo, settingsActivityName, addPrintersActivityName);
}
Body of Second Method:
{
    String settingsActivityName = null;
    String addPrintersActivityName = null;
    String advancedPrintOptionsActivityName = null;
    XmlResourceParser parser = null;
    PackageManager packageManager = context.getPackageManager();
    parser = resolveInfo.serviceInfo.loadXmlMetaData(packageManager, PrintService.SERVICE_META_DATA);
    if (parser != null) {
        try {
            int type = 0;
            while (type != XmlPullParser.END_DOCUMENT && type != XmlPullParser.START_TAG) {
                type = parser.next();
            }
            String nodeName = parser.getName();
            if (!TAG_PRINT_SERVICE.equals(nodeName)) {
                Log.e(LOG_TAG, "Ignoring meta-data that does not start with " + TAG_PRINT_SERVICE + " tag");
            } else {
                Resources resources = packageManager.getResourcesForApplication(resolveInfo.serviceInfo.applicationInfo);
                AttributeSet allAttributes = Xml.asAttributeSet(parser);
                TypedArray attributes = resources.obtainAttributes(allAttributes, com.android.internal.R.styleable.PrintService);
                settingsActivityName = attributes.getString(com.android.internal.R.styleable.PrintService_settingsActivity);
                addPrintersActivityName = attributes.getString(com.android.internal.R.styleable.PrintService_addPrintersActivity);
                advancedPrintOptionsActivityName = attributes.getString(com.android.internal.R.styleable.PrintService_advancedPrintOptionsActivity);
                attributes.recycle();
            }
        } catch (IOException ioe) {
            Log.w(LOG_TAG, "Error reading meta-data:" + ioe);
        } catch (XmlPullParserException xppe) {
            Log.w(LOG_TAG, "Error reading meta-data:" + xppe);
        } catch (NameNotFoundException e) {
            Log.e(LOG_TAG, "Unable to load resources for: " + resolveInfo.serviceInfo.packageName);
        } finally {
            if (parser != null) {
                parser.close();
            }
        }
    }
    return new PrintServiceInfo(resolveInfo, settingsActivityName, addPrintersActivityName, advancedPrintOptionsActivityName);
}
------------------------
Find a silently evolved API code:android.view.ViewPropertyAnimator.AnimatorEventListener.onAnimationUpdate:COMMENT
Method Modifier: public      
Comment:/**
 * Calculate the current value for each property and set it on the view. Invalidate
 * the view object appropriately, depending on which properties are being animated.
 *
 * @param animation The animator associated with the properties that need to be
 * set. This animator holds the animation fraction which we will use to calculate
 * the current value of each property.
 */

Body of Frist Method:
{
    PropertyBundle propertyBundle = mAnimatorMap.get(animation);
    if (propertyBundle == null) {
        // Shouldn't happen, but just to play it safe
        return;
    }
    boolean useDisplayListProperties = mView.mDisplayList != null;
    // alpha requires slightly different treatment than the other (transform) properties.
    // The logic in setAlpha() is not simply setting mAlpha, plus the invalidation
    // logic is dependent on how the view handles an internal call to onSetAlpha().
    // We track what kinds of properties are set, and how alpha is handled when it is
    // set, and perform the invalidation steps appropriately.
    boolean alphaHandled = false;
    if (!useDisplayListProperties) {
        mView.invalidateParentCaches();
    }
    float fraction = animation.getAnimatedFraction();
    int propertyMask = propertyBundle.mPropertyMask;
    if ((propertyMask & TRANSFORM_MASK) != 0) {
        mView.invalidateViewProperty(false, false);
    }
    ArrayList<NameValuesHolder> valueList = propertyBundle.mNameValuesHolder;
    if (valueList != null) {
        int count = valueList.size();
        for (int i = 0; i < count; ++i) {
            NameValuesHolder values = valueList.get(i);
            float value = values.mFromValue + fraction * values.mDeltaValue;
            if (values.mNameConstant == ALPHA) {
                alphaHandled = mView.setAlphaNoInvalidation(value);
            } else {
                setValue(values.mNameConstant, value);
            }
        }
    }
    if ((propertyMask & TRANSFORM_MASK) != 0) {
        mView.mTransformationInfo.mMatrixDirty = true;
        if (!useDisplayListProperties) {
            // force another invalidation
            mView.mPrivateFlags |= View.PFLAG_DRAWN;
        }
    }
    // via the call to setAlphaNoInvalidation(), above
    if (alphaHandled) {
        mView.invalidate(true);
    } else {
        mView.invalidateViewProperty(false, false);
    }
    if (mUpdateListener != null) {
        mUpdateListener.onAnimationUpdate(animation);
    }
}
Body of Second Method:
{
    PropertyBundle propertyBundle = mAnimatorMap.get(animation);
    if (propertyBundle == null) {
        // Shouldn't happen, but just to play it safe
        return;
    }
    boolean hardwareAccelerated = mView.isHardwareAccelerated();
    // alpha requires slightly different treatment than the other (transform) properties.
    // The logic in setAlpha() is not simply setting mAlpha, plus the invalidation
    // logic is dependent on how the view handles an internal call to onSetAlpha().
    // We track what kinds of properties are set, and how alpha is handled when it is
    // set, and perform the invalidation steps appropriately.
    boolean alphaHandled = false;
    if (!hardwareAccelerated) {
        mView.invalidateParentCaches();
    }
    float fraction = animation.getAnimatedFraction();
    int propertyMask = propertyBundle.mPropertyMask;
    if ((propertyMask & TRANSFORM_MASK) != 0) {
        mView.invalidateViewProperty(hardwareAccelerated, false);
    }
    ArrayList<NameValuesHolder> valueList = propertyBundle.mNameValuesHolder;
    if (valueList != null) {
        int count = valueList.size();
        for (int i = 0; i < count; ++i) {
            NameValuesHolder values = valueList.get(i);
            float value = values.mFromValue + fraction * values.mDeltaValue;
            if (values.mNameConstant == ALPHA) {
                alphaHandled = mView.setAlphaNoInvalidation(value);
            } else {
                setValue(values.mNameConstant, value);
            }
        }
    }
    if ((propertyMask & TRANSFORM_MASK) != 0) {
        if (!hardwareAccelerated) {
            // force another invalidation
            mView.mPrivateFlags |= View.PFLAG_DRAWN;
        }
    }
    // via the call to setAlphaNoInvalidation(), above
    if (alphaHandled) {
        mView.invalidate(true);
    } else {
        mView.invalidateViewProperty(false, false);
    }
    if (mUpdateListener != null) {
        mUpdateListener.onAnimationUpdate(animation);
    }
}
------------------------
Find a silently evolved API code:android.view.PointerIcon.loadCustomIcon:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Loads a custom pointer icon from an XML resource.
 * <p>
 * The XML resource should have the following form:
 * <code>
 * &lt;?xml version="1.0" encoding="utf-8"?&gt;
 * &lt;pointer-icon xmlns:android="http://schemas.android.com/apk/res/android"
 * android:bitmap="@drawable/my_pointer_bitmap"
 * android:hotSpotX="24"
 * android:hotSpotY="24" /&gt;
 * </code>
 * </p>
 *
 * @param resources The resources object.
 * @param resourceId The resource id.
 * @return The pointer icon.
 *
 * @throws IllegalArgumentException if resources is null.
 * @throws Resources.NotFoundException if the resource was not found or the drawable
 * linked in the resource was not found.
 */

Body of Frist Method:
{
    if (resources == null) {
        throw new IllegalArgumentException("resources must not be null");
    }
    PointerIcon icon = new PointerIcon(STYLE_CUSTOM);
    icon.loadResource(resources, resourceId);
    return icon;
}
Body of Second Method:
{
    if (resources == null) {
        throw new IllegalArgumentException("resources must not be null");
    }
    PointerIcon icon = new PointerIcon(STYLE_CUSTOM);
    icon.loadResource(null, resources, resourceId);
    return icon;
}
------------------------
Find a silently evolved API code:android.media.MediaFocusControl.dumpRCCStack:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Helper function:
 * Display in the log the current entries in the remote control stack, focusing
 * on RemoteControlClient data
 */

Body of Frist Method:
{
    pw.println("\nRemote Control Client stack entries (last is top of stack):");
    synchronized (mRCStack) {
        Iterator<RemoteControlStackEntry> stackIterator = mRCStack.iterator();
        while (stackIterator.hasNext()) {
            RemoteControlStackEntry rcse = stackIterator.next();
            pw.println("  uid: " + rcse.mCallingUid + "  -- id: " + rcse.mRccId + "  -- type: " + rcse.mPlaybackType + "  -- state: " + rcse.mPlaybackState + "  -- vol handling: " + rcse.mPlaybackVolumeHandling + "  -- vol: " + rcse.mPlaybackVolume + "  -- volMax: " + rcse.mPlaybackVolumeMax + "  -- volObs: " + rcse.mRemoteVolumeObs);
        }
        synchronized (mCurrentRcLock) {
            pw.println("\nCurrent remote control generation ID = " + mCurrentRcClientGen);
        }
    }
    synchronized (mMainRemote) {
        pw.println("\nRemote Volume State:");
        pw.println("  has remote: " + mHasRemotePlayback);
        pw.println("  is remote active: " + mMainRemoteIsActive);
        pw.println("  rccId: " + mMainRemote.mRccId);
        pw.println("  volume handling: " + ((mMainRemote.mVolumeHandling == RemoteControlClient.PLAYBACK_VOLUME_FIXED) ? "PLAYBACK_VOLUME_FIXED(0)" : "PLAYBACK_VOLUME_VARIABLE(1)"));
        pw.println("  volume: " + mMainRemote.mVolume);
        pw.println("  volume steps: " + mMainRemote.mVolumeMax);
    }
}
Body of Second Method:
{
    pw.println("\nRemote Control Client stack entries (last is top of stack):");
    synchronized (mPRStack) {
        Iterator<PlayerRecord> stackIterator = mPRStack.iterator();
        while (stackIterator.hasNext()) {
            stackIterator.next().dump(pw, false);
        }
        synchronized (mCurrentRcLock) {
            pw.println("\nCurrent remote control generation ID = " + mCurrentRcClientGen);
        }
    }
    synchronized (mMainRemote) {
        pw.println("\nRemote Volume State:");
        pw.println("  has remote: " + mHasRemotePlayback);
        pw.println("  is remote active: " + mMainRemoteIsActive);
        pw.println("  rccId: " + mMainRemote.mRccId);
        pw.println("  volume handling: " + ((mMainRemote.mVolumeHandling == RemoteControlClient.PLAYBACK_VOLUME_FIXED) ? "PLAYBACK_VOLUME_FIXED(0)" : "PLAYBACK_VOLUME_VARIABLE(1)"));
        pw.println("  volume: " + mMainRemote.mVolume);
        pw.println("  volume steps: " + mMainRemote.mVolumeMax);
    }
}
------------------------
Find a silently evolved API code:android.appwidget.AppWidgetHostView.getDefaultView:COMMENT
Method Modifier: protected   
Comment:/**
 * Inflate and return the default layout requested by AppWidget provider.
 */

Body of Frist Method:
{
    if (LOGD) {
        Log.d(TAG, "getDefaultView");
    }
    View defaultView = null;
    Exception exception = null;
    try {
        if (mInfo != null) {
            Context theirContext = mContext.createPackageContextAsUser(mInfo.provider.getPackageName(), Context.CONTEXT_RESTRICTED, mUser);
            mRemoteContext = theirContext;
            LayoutInflater inflater = (LayoutInflater) theirContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
            inflater = inflater.cloneInContext(theirContext);
            inflater.setFilter(sInflaterFilter);
            AppWidgetManager manager = AppWidgetManager.getInstance(mContext);
            Bundle options = manager.getAppWidgetOptions(mAppWidgetId);
            int layoutId = mInfo.initialLayout;
            if (options.containsKey(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY)) {
                int category = options.getInt(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY);
                if (category == AppWidgetProviderInfo.WIDGET_CATEGORY_KEYGUARD) {
                    int kgLayoutId = mInfo.initialKeyguardLayout;
                    // If a default keyguard layout is not specified, use the standard
                    // default layout.
                    layoutId = kgLayoutId == 0 ? layoutId : kgLayoutId;
                }
            }
            defaultView = inflater.inflate(layoutId, this, false);
        } else {
            Log.w(TAG, "can't inflate defaultView because mInfo is missing");
        }
    } catch (PackageManager.NameNotFoundException e) {
        exception = e;
    } catch (RuntimeException e) {
        exception = e;
    }
    if (exception != null) {
        Log.w(TAG, "Error inflating AppWidget " + mInfo + ": " + exception.toString());
    }
    if (defaultView == null) {
        if (LOGD)
            Log.d(TAG, "getDefaultView couldn't find any view, so inflating error");
        defaultView = getErrorView();
    }
    return defaultView;
}
Body of Second Method:
{
    if (LOGD) {
        Log.d(TAG, "getDefaultView");
    }
    View defaultView = null;
    Exception exception = null;
    try {
        if (mInfo != null) {
            Context theirContext = getRemoteContext();
            mRemoteContext = theirContext;
            LayoutInflater inflater = (LayoutInflater) theirContext.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
            inflater = inflater.cloneInContext(theirContext);
            inflater.setFilter(sInflaterFilter);
            AppWidgetManager manager = AppWidgetManager.getInstance(mContext);
            Bundle options = manager.getAppWidgetOptions(mAppWidgetId);
            int layoutId = mInfo.initialLayout;
            if (options.containsKey(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY)) {
                int category = options.getInt(AppWidgetManager.OPTION_APPWIDGET_HOST_CATEGORY);
                if (category == AppWidgetProviderInfo.WIDGET_CATEGORY_KEYGUARD) {
                    int kgLayoutId = mInfo.initialKeyguardLayout;
                    // If a default keyguard layout is not specified, use the standard
                    // default layout.
                    layoutId = kgLayoutId == 0 ? layoutId : kgLayoutId;
                }
            }
            defaultView = inflater.inflate(layoutId, this, false);
        } else {
            Log.w(TAG, "can't inflate defaultView because mInfo is missing");
        }
    } catch (RuntimeException e) {
        exception = e;
    }
    if (exception != null) {
        Log.w(TAG, "Error inflating AppWidget " + mInfo + ": " + exception.toString());
    }
    if (defaultView == null) {
        if (LOGD)
            Log.d(TAG, "getDefaultView couldn't find any view, so inflating error");
        defaultView = getErrorView();
    }
    return defaultView;
}
------------------------
Find a silently evolved API code:android.graphics.RadialGradient.copy:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    final RadialGradient copy;
    switch(mType) {
        case TYPE_COLORS_AND_POSITIONS:
            copy = new RadialGradient(mX, mY, mRadius, mColors.clone(), mPositions != null ? mPositions.clone() : null, mTileMode);
            break;
        case TYPE_COLOR_CENTER_AND_COLOR_EDGE:
            copy = new RadialGradient(mX, mY, mRadius, mColor0, mColor1, mTileMode);
            break;
        default:
            throw new IllegalArgumentException("RadialGradient should be created with either " + "colors and positions or center color and edge color");
    }
    copyLocalMatrix(copy);
    return copy;
}
Body of Second Method:
{
    final RadialGradient copy;
    switch(mType) {
        case TYPE_COLORS_AND_POSITIONS:
            copy = new RadialGradient(mX, mY, mRadius, mColors.clone(), mPositions != null ? mPositions.clone() : null, mTileMode);
            break;
        case TYPE_COLOR_CENTER_AND_COLOR_EDGE:
            copy = new RadialGradient(mX, mY, mRadius, mCenterColor, mEdgeColor, mTileMode);
            break;
        default:
            throw new IllegalArgumentException("RadialGradient should be created with either " + "colors and positions or center color and edge color");
    }
    copyLocalMatrix(copy);
    return copy;
}
------------------------
Find a silently evolved API code:android.os.StrictMode.ViolationInfo.writeToParcel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Save a ViolationInfo instance to a parcel.
 */

Body of Frist Method:
{
    crashInfo.writeToParcel(dest, flags);
    dest.writeInt(policy);
    dest.writeInt(durationMillis);
    dest.writeInt(violationNumThisLoop);
    dest.writeInt(numAnimationsRunning);
    dest.writeLong(violationUptimeMillis);
    dest.writeLong(numInstances);
    dest.writeString(broadcastIntentAction);
    dest.writeStringArray(tags);
}
Body of Second Method:
{
    crashInfo.writeToParcel(dest, flags);
    int start = dest.dataPosition();
    dest.writeInt(policy);
    dest.writeInt(durationMillis);
    dest.writeInt(violationNumThisLoop);
    dest.writeInt(numAnimationsRunning);
    dest.writeLong(violationUptimeMillis);
    dest.writeLong(numInstances);
    dest.writeString(broadcastIntentAction);
    dest.writeStringArray(tags);
    int total = dest.dataPosition() - start;
    if (total > 10 * 1024) {
        Slog.d(TAG, "VIO: policy=" + policy + " dur=" + durationMillis + " numLoop=" + violationNumThisLoop + " anim=" + numAnimationsRunning + " uptime=" + violationUptimeMillis + " numInst=" + numInstances);
        Slog.d(TAG, "VIO: action=" + broadcastIntentAction);
        Slog.d(TAG, "VIO: tags=" + Arrays.toString(tags));
        Slog.d(TAG, "VIO: TOTAL BYTES WRITTEN: " + (dest.dataPosition() - start));
    }
}
------------------------
Find a silently evolved API code:android.os.Parcel.readArrayMapInternal:COMMENT
Method Modifier: default     
Comment:/* package */

Body of Frist Method:
{
    if (DEBUG_ARRAY_MAP) {
        RuntimeException here = new RuntimeException("here");
        here.fillInStackTrace();
        Log.d(TAG, "Reading " + N + " ArrayMap entries", here);
    }
    while (N > 0) {
        Object key = readValue(loader);
        if (DEBUG_ARRAY_MAP)
            Log.d(TAG, "  Read #" + (N - 1) + ": key=0x" + (key != null ? key.hashCode() : 0) + " " + key);
        Object value = readValue(loader);
        outVal.append(key, value);
        N--;
    }
}
Body of Second Method:
{
    if (DEBUG_ARRAY_MAP) {
        RuntimeException here = new RuntimeException("here");
        here.fillInStackTrace();
        Log.d(TAG, "Reading " + N + " ArrayMap entries", here);
    }
    int startPos;
    while (N > 0) {
        if (DEBUG_ARRAY_MAP)
            startPos = dataPosition();
        String key = readString();
        Object value = readValue(loader);
        if (DEBUG_ARRAY_MAP)
            Log.d(TAG, "  Read #" + (N - 1) + " " + (dataPosition() - startPos) + " bytes: key=0x" + Integer.toHexString((key != null ? key.hashCode() : 0)) + " " + key);
        outVal.append(key, value);
        N--;
    }
    outVal.validate();
}
------------------------
Find a silently evolved API code:android.view.ViewGroup.handleFocusGainInternal:COMMENT
Method Modifier: default     
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (mFocused != null) {
        mFocused.unFocus();
        mFocused = null;
    }
    super.handleFocusGainInternal(direction, previouslyFocusedRect);
}
Body of Second Method:
{
    if (mFocused != null) {
        mFocused.unFocus(this);
        mFocused = null;
    }
    super.handleFocusGainInternal(direction, previouslyFocusedRect);
}
------------------------
Find a silently evolved API code:android.media.MediaFocusControl.unregisterMediaButtonIntent:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * see AudioManager.unregisterMediaButtonIntent(PendingIntent mediaIntent)
 * precondition: mediaIntent != null, eventReceiver != null
 */

Body of Frist Method:
{
    Log.i(TAG, "  Remote Control   unregisterMediaButtonIntent() for " + mediaIntent);
    synchronized (mAudioFocusLock) {
        synchronized (mRCStack) {
            boolean topOfStackWillChange = isCurrentRcController(mediaIntent);
            removeMediaButtonReceiver_syncAfRcs(mediaIntent);
            if (topOfStackWillChange) {
                // current RC client will change, assume every type of info needs to be queried
                checkUpdateRemoteControlDisplay_syncAfRcs(RC_INFO_ALL);
            }
        }
    }
}
Body of Second Method:
{
    Log.i(TAG, "  Remote Control   unregisterMediaButtonIntent() for " + mediaIntent);
    synchronized (mPRStack) {
        boolean topOfStackWillChange = isCurrentRcController(mediaIntent);
        removeMediaButtonReceiver_syncPrs(mediaIntent);
        if (topOfStackWillChange) {
            // current RC client will change, assume every type of info needs to be queried
            checkUpdateRemoteControlDisplay_syncPrs(RC_INFO_ALL);
        }
    }
}
------------------------
Find a silently evolved API code:android.content.res.Resources.loadColorStateList:COMMENT
Method Modifier: default     
Comment:/*package*/

Body of Frist Method:
{
    if (TRACE_FOR_PRELOAD) {
        // Log only framework resources
        if ((id >>> 24) == 0x1) {
            final String name = getResourceName(id);
            if (name != null)
                android.util.Log.d("PreloadColorStateList", name);
        }
    }
    final long key = (((long) value.assetCookie) << 32) | value.data;
    ColorStateList csl;
    if (value.type >= TypedValue.TYPE_FIRST_COLOR_INT && value.type <= TypedValue.TYPE_LAST_COLOR_INT) {
        csl = sPreloadedColorStateLists.get(key);
        if (csl != null) {
            return csl;
        }
        csl = ColorStateList.valueOf(value.data);
        if (mPreloading) {
            if (verifyPreloadConfig(value.changingConfigurations, 0, value.resourceId, "color")) {
                sPreloadedColorStateLists.put(key, csl);
            }
        }
        return csl;
    }
    csl = getCachedColorStateList(key);
    if (csl != null) {
        return csl;
    }
    csl = sPreloadedColorStateLists.get(key);
    if (csl != null) {
        return csl;
    }
    if (value.string == null) {
        throw new NotFoundException("Resource is not a ColorStateList (color or path): " + value);
    }
    String file = value.string.toString();
    if (file.endsWith(".xml")) {
        Trace.traceBegin(Trace.TRACE_TAG_RESOURCES, file);
        try {
            XmlResourceParser rp = loadXmlResourceParser(file, id, value.assetCookie, "colorstatelist");
            csl = ColorStateList.createFromXml(this, rp);
            rp.close();
        } catch (Exception e) {
            Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
            NotFoundException rnf = new NotFoundException("File " + file + " from color state list resource ID #0x" + Integer.toHexString(id));
            rnf.initCause(e);
            throw rnf;
        }
        Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
    } else {
        throw new NotFoundException("File " + file + " from drawable resource ID #0x" + Integer.toHexString(id) + ": .xml extension required");
    }
    if (csl != null) {
        if (mPreloading) {
            if (verifyPreloadConfig(value.changingConfigurations, 0, value.resourceId, "color")) {
                sPreloadedColorStateLists.put(key, csl);
            }
        } else {
            synchronized (mAccessLock) {
                // Log.i(TAG, "Saving cached color state list @ #" +
                // Integer.toHexString(key.intValue())
                // + " in " + this + ": " + csl);
                mColorStateListCache.put(key, new WeakReference<ColorStateList>(csl));
            }
        }
    }
    return csl;
}
Body of Second Method:
{
    if (TRACE_FOR_PRELOAD) {
        // Log only framework resources
        if ((id >>> 24) == 0x1) {
            final String name = getResourceName(id);
            if (name != null)
                android.util.Log.d("PreloadColorStateList", name);
        }
    }
    final long key = (((long) value.assetCookie) << 32) | value.data;
    ColorStateList csl;
    if (value.type >= TypedValue.TYPE_FIRST_COLOR_INT && value.type <= TypedValue.TYPE_LAST_COLOR_INT) {
        csl = sPreloadedColorStateLists.get(key);
        if (csl != null) {
            return csl;
        }
        csl = ColorStateList.valueOf(value.data);
        if (mPreloading) {
            if (verifyPreloadConfig(value.changingConfigurations, 0, value.resourceId, "color")) {
                sPreloadedColorStateLists.put(key, csl);
            }
        }
        return csl;
    }
    csl = getCachedColorStateList(key);
    if (csl != null) {
        return csl;
    }
    csl = sPreloadedColorStateLists.get(key);
    if (csl != null) {
        return csl;
    }
    if (value.string == null) {
        throw new NotFoundException("Resource is not a ColorStateList (color or path): " + value);
    }
    final String file = value.string.toString();
    if (file.endsWith(".xml")) {
        Trace.traceBegin(Trace.TRACE_TAG_RESOURCES, file);
        try {
            final XmlResourceParser rp = loadXmlResourceParser(file, id, value.assetCookie, "colorstatelist");
            csl = ColorStateList.createFromXml(this, rp);
            rp.close();
        } catch (Exception e) {
            Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
            NotFoundException rnf = new NotFoundException("File " + file + " from color state list resource ID #0x" + Integer.toHexString(id));
            rnf.initCause(e);
            throw rnf;
        }
        Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
    } else {
        throw new NotFoundException("File " + file + " from drawable resource ID #0x" + Integer.toHexString(id) + ": .xml extension required");
    }
    if (csl != null) {
        if (mPreloading) {
            if (verifyPreloadConfig(value.changingConfigurations, 0, value.resourceId, "color")) {
                sPreloadedColorStateLists.put(key, csl);
            }
        } else {
            synchronized (mAccessLock) {
                // Log.i(TAG, "Saving cached color state list @ #" +
                // Integer.toHexString(key.intValue())
                // + " in " + this + ": " + csl);
                mColorStateListCache.put(key, new WeakReference<ColorStateList>(csl));
            }
        }
    }
    return csl;
}
------------------------
Find a silently evolved API code:android.widget.DatePicker.setCalendarViewShown:COMMENT
Method Modifier: public      
Comment:/**
 * Sets whether the {@link CalendarView} is shown.
 *
 * @param shown True if the calendar view is to be shown.
 */

Body of Frist Method:
{
    mCalendarView.setVisibility(shown ? VISIBLE : GONE);
}
Body of Second Method:
{
    mDelegate.setCalendarViewShown(shown);
}
------------------------
Find a silently evolved API code:android.text.SpannableStringBuilder.drawTextRun:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Don't call this yourself -- exists for Canvas to use internally.
 * {@hide}
 */

Body of Frist Method:
{
    checkRange("drawTextRun", start, end);
    int contextLen = contextEnd - contextStart;
    int len = end - start;
    if (contextEnd <= mGapStart) {
        c.drawTextRun(mText, start, len, contextStart, contextLen, x, y, flags, p);
    } else if (contextStart >= mGapStart) {
        c.drawTextRun(mText, start + mGapLength, len, contextStart + mGapLength, contextLen, x, y, flags, p);
    } else {
        char[] buf = TextUtils.obtain(contextLen);
        getChars(contextStart, contextEnd, buf, 0);
        c.drawTextRun(buf, start - contextStart, len, 0, contextLen, x, y, flags, p);
        TextUtils.recycle(buf);
    }
}
Body of Second Method:
{
    checkRange("drawTextRun", start, end);
    int contextLen = contextEnd - contextStart;
    int len = end - start;
    if (contextEnd <= mGapStart) {
        c.drawTextRun(mText, start, len, contextStart, contextLen, x, y, isRtl, p);
    } else if (contextStart >= mGapStart) {
        c.drawTextRun(mText, start + mGapLength, len, contextStart + mGapLength, contextLen, x, y, isRtl, p);
    } else {
        char[] buf = TextUtils.obtain(contextLen);
        getChars(contextStart, contextEnd, buf, 0);
        c.drawTextRun(buf, start - contextStart, len, 0, contextLen, x, y, isRtl, p);
        TextUtils.recycle(buf);
    }
}
------------------------
Find a silently evolved API code:android.provider.Browser.truncateHistory:COMMENT
Method Modifier: public      static      final       
Comment:/**
 * If there are more than MAX_HISTORY_COUNT non-bookmark history
 * items in the bookmark/history table, delete TRUNCATE_N_OLDEST
 * of them.  This is used to keep our history table to a
 * reasonable size.  Note: it does not prune bookmarks.  If the
 * user wants 1000 bookmarks, the user gets 1000 bookmarks.
 * Requires {@link android.Manifest.permission#READ_HISTORY_BOOKMARKS}
 * Requires {@link android.Manifest.permission#WRITE_HISTORY_BOOKMARKS}
 *
 * @param cr The ContentResolver used to access the database.
 */

Body of Frist Method:
{
    // TODO make a single request to the provider to do this in a single transaction
    Cursor cursor = null;
    try {
        // Select non-bookmark history, ordered by date
        cursor = cr.query(History.CONTENT_URI, new String[] { History._ID, History.URL, History.DATE_LAST_VISITED }, null, null, History.DATE_LAST_VISITED + " ASC");
        if (cursor.moveToFirst() && cursor.getCount() >= MAX_HISTORY_COUNT) {
            final WebIconDatabase iconDb = WebIconDatabase.getInstance();
            /* eliminate oldest history items */
            for (int i = 0; i < TRUNCATE_N_OLDEST; i++) {
                cr.delete(ContentUris.withAppendedId(History.CONTENT_URI, cursor.getLong(0)), null, null);
                iconDb.releaseIconForPageUrl(cursor.getString(1));
                if (!cursor.moveToNext())
                    break;
            }
        }
    } catch (IllegalStateException e) {
        Log.e(LOGTAG, "truncateHistory", e);
    } finally {
        if (cursor != null)
            cursor.close();
    }
}
Body of Second Method:
{
    // TODO make a single request to the provider to do this in a single transaction
    Cursor cursor = null;
    try {
        // Select non-bookmark history, ordered by date
        cursor = cr.query(History.CONTENT_URI, new String[] { History._ID, History.URL, History.DATE_LAST_VISITED }, null, null, History.DATE_LAST_VISITED + " ASC");
        if (cursor.moveToFirst() && cursor.getCount() >= MAX_HISTORY_COUNT) {
            /* eliminate oldest history items */
            for (int i = 0; i < TRUNCATE_N_OLDEST; i++) {
                cr.delete(ContentUris.withAppendedId(History.CONTENT_URI, cursor.getLong(0)), null, null);
                if (!cursor.moveToNext())
                    break;
            }
        }
    } catch (IllegalStateException e) {
        Log.e(LOGTAG, "truncateHistory", e);
    } finally {
        if (cursor != null)
            cursor.close();
    }
}
------------------------
Find a silently evolved API code:android.os.RecoverySystem.installPackage:COMMENT
Method Modifier: public      static      
Comment:/**
 * Reboots the device in order to install the given update
 * package.
 * Requires the {@link android.Manifest.permission#REBOOT} permission.
 *
 * @param context      the Context to use
 * @param packageFile  the update package to install.  Must be on
 * a partition mountable by recovery.  (The set of partitions
 * known to recovery may vary from device to device.  Generally,
 * /cache and /data are safe.)
 *
 * @throws IOException  if writing the recovery command file
 * fails, or if the reboot itself fails.
 */

Body of Frist Method:
{
    String filename = packageFile.getCanonicalPath();
    Log.w(TAG, "!!! REBOOTING TO INSTALL " + filename + " !!!");
    String arg = "--update_package=" + filename + "\n--locale=" + Locale.getDefault().toString();
    bootCommand(context, arg);
}
Body of Second Method:
{
    String filename = packageFile.getCanonicalPath();
    Log.w(TAG, "!!! REBOOTING TO INSTALL " + filename + " !!!");
    final String filenameArg = "--update_package=" + filename;
    final String localeArg = "--locale=" + Locale.getDefault().toString();
    bootCommand(context, filenameArg, localeArg);
}
------------------------
Find a silently evolved API code:android.graphics.Canvas.drawPoint:COMMENT
<android.graphics.Canvas: void drawPoint(float,float,Paint)>
public      native      ->public      
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * Helper for drawPoints() for drawing a single point.
 */

Body of Frist Method:

Body of Second Method:
{
    native_drawPoint(mNativeCanvasWrapper, x, y, paint.mNativePaint);
}
------------------------
Find a silently evolved API code:android.view.accessibility.CaptioningManager.addCaptioningChangeListener:COMMENT
Method Modifier: public      
Comment:/**
 * Adds a listener for changes in the user's preferred captioning enabled
 * state and visual properties.
 *
 * @param listener the listener to add
 */

Body of Frist Method:
{
    synchronized (mListeners) {
        if (mListeners.isEmpty()) {
            registerObserver(Secure.ACCESSIBILITY_CAPTIONING_ENABLED);
            registerObserver(Secure.ACCESSIBILITY_CAPTIONING_FOREGROUND_COLOR);
            registerObserver(Secure.ACCESSIBILITY_CAPTIONING_BACKGROUND_COLOR);
            registerObserver(Secure.ACCESSIBILITY_CAPTIONING_EDGE_TYPE);
            registerObserver(Secure.ACCESSIBILITY_CAPTIONING_EDGE_COLOR);
            registerObserver(Secure.ACCESSIBILITY_CAPTIONING_TYPEFACE);
            registerObserver(Secure.ACCESSIBILITY_CAPTIONING_FONT_SCALE);
            registerObserver(Secure.ACCESSIBILITY_CAPTIONING_LOCALE);
        }
        mListeners.add(listener);
    }
}
Body of Second Method:
{
    synchronized (mListeners) {
        if (mListeners.isEmpty()) {
            registerObserver(Secure.ACCESSIBILITY_CAPTIONING_ENABLED);
            registerObserver(Secure.ACCESSIBILITY_CAPTIONING_FOREGROUND_COLOR);
            registerObserver(Secure.ACCESSIBILITY_CAPTIONING_BACKGROUND_COLOR);
            registerObserver(Secure.ACCESSIBILITY_CAPTIONING_WINDOW_COLOR);
            registerObserver(Secure.ACCESSIBILITY_CAPTIONING_EDGE_TYPE);
            registerObserver(Secure.ACCESSIBILITY_CAPTIONING_EDGE_COLOR);
            registerObserver(Secure.ACCESSIBILITY_CAPTIONING_TYPEFACE);
            registerObserver(Secure.ACCESSIBILITY_CAPTIONING_FONT_SCALE);
            registerObserver(Secure.ACCESSIBILITY_CAPTIONING_LOCALE);
            registerObserver(Secure.ACCESSIBILITY_CAPTIONING_PRESET);
        }
        mListeners.add(listener);
    }
}
------------------------
Find a silently evolved API code:android.webkit.CookieManager.flushCookieStore:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * Flushes all cookies managed by the Chrome HTTP stack to flash.
 *
 * @hide Package level api, called from CookieSyncManager
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:
{
}
------------------------
Find a silently evolved API code:android.print.PrintManager.createPrinterDiscoverySession:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return new PrinterDiscoverySession(mService, mContext, mUserId);
}
Body of Second Method:
{
    if (mService == null) {
        Log.w(LOG_TAG, "Feature android.software.print not available");
        return null;
    }
    return new PrinterDiscoverySession(mService, mContext, mUserId);
}
------------------------
Find a silently evolved API code:android.print.PrintManager.getPrintJobs:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the print jobs for this application.
 *
 * @return The print job list.
 * @see PrintJob
 */

Body of Frist Method:
{
    try {
        List<PrintJobInfo> printJobInfos = mService.getPrintJobInfos(mAppId, mUserId);
        if (printJobInfos == null) {
            return Collections.emptyList();
        }
        final int printJobCount = printJobInfos.size();
        List<PrintJob> printJobs = new ArrayList<PrintJob>(printJobCount);
        for (int i = 0; i < printJobCount; i++) {
            printJobs.add(new PrintJob(printJobInfos.get(i), this));
        }
        return printJobs;
    } catch (RemoteException re) {
        Log.e(LOG_TAG, "Error getting print jobs", re);
    }
    return Collections.emptyList();
}
Body of Second Method:
{
    if (mService == null) {
        Log.w(LOG_TAG, "Feature android.software.print not available");
        return Collections.emptyList();
    }
    try {
        List<PrintJobInfo> printJobInfos = mService.getPrintJobInfos(mAppId, mUserId);
        if (printJobInfos == null) {
            return Collections.emptyList();
        }
        final int printJobCount = printJobInfos.size();
        List<PrintJob> printJobs = new ArrayList<PrintJob>(printJobCount);
        for (int i = 0; i < printJobCount; i++) {
            printJobs.add(new PrintJob(printJobInfos.get(i), this));
        }
        return printJobs;
    } catch (RemoteException re) {
        Log.e(LOG_TAG, "Error getting print jobs", re);
    }
    return Collections.emptyList();
}
------------------------
Find a silently evolved API code:android.os.StrictMode.decrementExpectedActivityCount:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (klass == null) {
        return;
    }
    final int limit;
    synchronized (StrictMode.class) {
        if ((sVmPolicy.mask & DETECT_VM_ACTIVITY_LEAKS) == 0) {
            return;
        }
        Integer expected = sExpectedActivityInstanceCount.get(klass);
        int newExpected = (expected == null || expected == 0) ? 0 : expected - 1;
        if (newExpected == 0) {
            sExpectedActivityInstanceCount.remove(klass);
        } else {
            sExpectedActivityInstanceCount.put(klass, newExpected);
        }
        // Note: adding 1 here to give some breathing room during
        // orientation changes.  (shouldn't be necessary, though?)
        limit = newExpected + 1;
    }
    // Quick check.
    int actual = InstanceTracker.getInstanceCount(klass);
    if (actual <= limit) {
        return;
    }
    // Do a GC and explicit count to double-check.
    // This is the work that we are trying to avoid by tracking the object instances
    // explicity.  Running an explicit GC can be expensive (80ms) and so can walking
    // the heap to count instance (30ms).  This extra work can make the system feel
    // noticeably less responsive during orientation changes when activities are
    // being restarted.  Granted, it is only a problem when StrictMode is enabled
    // but it is annoying.
    Runtime.getRuntime().gc();
    long instances = VMDebug.countInstancesOfClass(klass, false);
    if (instances > limit) {
        Throwable tr = new InstanceCountViolation(klass, instances, limit);
        onVmPolicyViolation(tr.getMessage(), tr);
    }
}
Body of Second Method:
{
    if (klass == null) {
        return;
    }
    final int limit;
    synchronized (StrictMode.class) {
        if ((sVmPolicy.mask & DETECT_VM_ACTIVITY_LEAKS) == 0) {
            return;
        }
        Integer expected = sExpectedActivityInstanceCount.get(klass);
        int newExpected = (expected == null || expected == 0) ? 0 : expected - 1;
        if (newExpected == 0) {
            sExpectedActivityInstanceCount.remove(klass);
        } else {
            sExpectedActivityInstanceCount.put(klass, newExpected);
        }
        // Note: adding 1 here to give some breathing room during
        // orientation changes.  (shouldn't be necessary, though?)
        limit = newExpected + 1;
    }
    // Quick check.
    int actual = InstanceTracker.getInstanceCount(klass);
    if (actual <= limit) {
        return;
    }
    // Do a GC and explicit count to double-check.
    // This is the work that we are trying to avoid by tracking the object instances
    // explicity.  Running an explicit GC can be expensive (80ms) and so can walking
    // the heap to count instance (30ms).  This extra work can make the system feel
    // noticeably less responsive during orientation changes when activities are
    // being restarted.  Granted, it is only a problem when StrictMode is enabled
    // but it is annoying.
    System.gc();
    System.runFinalization();
    System.gc();
    long instances = VMDebug.countInstancesOfClass(klass, false);
    if (instances > limit) {
        Throwable tr = new InstanceCountViolation(klass, instances, limit);
        onVmPolicyViolation(tr.getMessage(), tr);
    }
}
------------------------
Find a silently evolved API code:android.content.res.TypedArray.getFloat:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the float value for the attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return Attribute float value, or defValue if not defined..
 */

Body of Frist Method:
{
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_FLOAT) {
        return Float.intBitsToFloat(data[index + AssetManager.STYLE_DATA]);
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + AssetManager.STYLE_DATA];
    }
    TypedValue v = mValue;
    if (getValueAt(index, v)) {
        Log.w(Resources.TAG, "Converting to float: " + v);
        CharSequence str = v.coerceToString();
        if (str != null) {
            return Float.parseFloat(str.toString());
        }
    }
    Log.w(Resources.TAG, "getFloat of bad type: 0x" + Integer.toHexString(type));
    return defValue;
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    index *= AssetManager.STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + AssetManager.STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_FLOAT) {
        return Float.intBitsToFloat(data[index + AssetManager.STYLE_DATA]);
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + AssetManager.STYLE_DATA];
    }
    TypedValue v = mValue;
    if (getValueAt(index, v)) {
        Log.w(Resources.TAG, "Converting to float: " + v);
        CharSequence str = v.coerceToString();
        if (str != null) {
            return Float.parseFloat(str.toString());
        }
    }
    Log.w(Resources.TAG, "getFloat of bad type: 0x" + Integer.toHexString(type));
    return defValue;
}
------------------------
Find a silently evolved API code:android.app.Notification.cloneInto:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Copy all (or if heavy is false, all except Bitmaps and RemoteViews) members
 * of this into that.
 * @hide
 */

Body of Frist Method:
{
    that.when = this.when;
    that.icon = this.icon;
    that.number = this.number;
    // PendingIntents are global, so there's no reason (or way) to clone them.
    that.contentIntent = this.contentIntent;
    that.deleteIntent = this.deleteIntent;
    that.fullScreenIntent = this.fullScreenIntent;
    if (this.tickerText != null) {
        that.tickerText = this.tickerText.toString();
    }
    if (heavy && this.tickerView != null) {
        that.tickerView = this.tickerView.clone();
    }
    if (heavy && this.contentView != null) {
        that.contentView = this.contentView.clone();
    }
    if (heavy && this.largeIcon != null) {
        that.largeIcon = Bitmap.createBitmap(this.largeIcon);
    }
    that.iconLevel = this.iconLevel;
    // android.net.Uri is immutable
    that.sound = this.sound;
    that.audioStreamType = this.audioStreamType;
    final long[] vibrate = this.vibrate;
    if (vibrate != null) {
        final int N = vibrate.length;
        final long[] vib = that.vibrate = new long[N];
        System.arraycopy(vibrate, 0, vib, 0, N);
    }
    that.ledARGB = this.ledARGB;
    that.ledOnMS = this.ledOnMS;
    that.ledOffMS = this.ledOffMS;
    that.defaults = this.defaults;
    that.flags = this.flags;
    that.priority = this.priority;
    final String[] thiskind = this.kind;
    if (thiskind != null) {
        final int N = thiskind.length;
        final String[] thatkind = that.kind = new String[N];
        System.arraycopy(thiskind, 0, thatkind, 0, N);
    }
    if (this.extras != null) {
        try {
            that.extras = new Bundle(this.extras);
            // will unparcel
            that.extras.size();
        } catch (BadParcelableException e) {
            Log.e(TAG, "could not unparcel extras from notification: " + this, e);
            that.extras = null;
        }
    }
    if (this.actions != null) {
        that.actions = new Action[this.actions.length];
        for (int i = 0; i < this.actions.length; i++) {
            that.actions[i] = this.actions[i].clone();
        }
    }
    if (heavy && this.bigContentView != null) {
        that.bigContentView = this.bigContentView.clone();
    }
    if (!heavy) {
        // will clean out extras
        that.lightenPayload();
    }
}
Body of Second Method:
{
    that.when = this.when;
    that.icon = this.icon;
    that.number = this.number;
    // PendingIntents are global, so there's no reason (or way) to clone them.
    that.contentIntent = this.contentIntent;
    that.deleteIntent = this.deleteIntent;
    that.fullScreenIntent = this.fullScreenIntent;
    if (this.tickerText != null) {
        that.tickerText = this.tickerText.toString();
    }
    if (heavy && this.tickerView != null) {
        that.tickerView = this.tickerView.clone();
    }
    if (heavy && this.contentView != null) {
        that.contentView = this.contentView.clone();
    }
    if (heavy && this.largeIcon != null) {
        that.largeIcon = Bitmap.createBitmap(this.largeIcon);
    }
    that.iconLevel = this.iconLevel;
    // android.net.Uri is immutable
    that.sound = this.sound;
    that.audioStreamType = this.audioStreamType;
    if (this.audioAttributes != null) {
        that.audioAttributes = new AudioAttributes.Builder(this.audioAttributes).build();
    }
    final long[] vibrate = this.vibrate;
    if (vibrate != null) {
        final int N = vibrate.length;
        final long[] vib = that.vibrate = new long[N];
        System.arraycopy(vibrate, 0, vib, 0, N);
    }
    that.ledARGB = this.ledARGB;
    that.ledOnMS = this.ledOnMS;
    that.ledOffMS = this.ledOffMS;
    that.defaults = this.defaults;
    that.flags = this.flags;
    that.priority = this.priority;
    that.category = this.category;
    that.mGroupKey = this.mGroupKey;
    that.mSortKey = this.mSortKey;
    if (this.extras != null) {
        try {
            that.extras = new Bundle(this.extras);
            // will unparcel
            that.extras.size();
        } catch (BadParcelableException e) {
            Log.e(TAG, "could not unparcel extras from notification: " + this, e);
            that.extras = null;
        }
    }
    if (this.actions != null) {
        that.actions = new Action[this.actions.length];
        for (int i = 0; i < this.actions.length; i++) {
            that.actions[i] = this.actions[i].clone();
        }
    }
    if (heavy && this.bigContentView != null) {
        that.bigContentView = this.bigContentView.clone();
    }
    if (heavy && this.headsUpContentView != null) {
        that.headsUpContentView = this.headsUpContentView.clone();
    }
    that.visibility = this.visibility;
    if (this.publicVersion != null) {
        that.publicVersion = new Notification();
        this.publicVersion.cloneInto(that.publicVersion, heavy);
    }
    that.color = this.color;
    if (!heavy) {
        // will clean out extras
        that.lightenPayload();
    }
}
------------------------
Find a silently evolved API code:android.appwidget.AppWidgetHost.createView:COMMENT
Method Modifier: public      final       
Comment:/**
 * Create the AppWidgetHostView for the given widget.
 * The AppWidgetHost retains a pointer to the newly-created View.
 */

Body of Frist Method:
{
    final int userId = mContext.getUserId();
    AppWidgetHostView view = onCreateView(mContext, appWidgetId, appWidget);
    view.setUserId(userId);
    view.setOnClickHandler(mOnClickHandler);
    view.setAppWidget(appWidgetId, appWidget);
    synchronized (mViews) {
        mViews.put(appWidgetId, view);
    }
    RemoteViews views;
    try {
        views = sService.getAppWidgetViews(appWidgetId, userId);
        if (views != null) {
            views.setUser(new UserHandle(mContext.getUserId()));
        }
    } catch (RemoteException e) {
        throw new RuntimeException("system server dead?", e);
    }
    view.updateAppWidget(views);
    return view;
}
Body of Second Method:
{
    AppWidgetHostView view = onCreateView(mContext, appWidgetId, appWidget);
    view.setOnClickHandler(mOnClickHandler);
    view.setAppWidget(appWidgetId, appWidget);
    synchronized (mViews) {
        mViews.put(appWidgetId, view);
    }
    RemoteViews views;
    try {
        views = sService.getAppWidgetViews(mContext.getOpPackageName(), appWidgetId);
    } catch (RemoteException e) {
        throw new RuntimeException("system server dead?", e);
    }
    view.updateAppWidget(views);
    return view;
}
------------------------
Find a silently evolved API code:android.content.res.BridgeTypedArray.getFraction:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve a fractional unit attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 * @param base The base value of this fraction.  In other words, a
 * standard fraction is multiplied by this value.
 * @param pbase The parent base value of this fraction.  In other
 * words, a parent fraction (nn%p) is multiplied by this
 * value.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute fractional value multiplied by the appropriate
 * base value, or defValue if not defined.
 */

Body of Frist Method:
{
    if (index < 0 || index >= mResourceData.length) {
        return defValue;
    }
    if (mResourceData[index] == null) {
        return defValue;
    }
    String value = mResourceData[index].getValue();
    if (value == null) {
        return defValue;
    }
    if (ResourceHelper.parseFloatAttribute(mNames[index], value, mValue, false)) {
        return mValue.getFraction(base, pbase);
    }
    // looks like we were unable to resolve the fraction value
    Bridge.getLog().warning(LayoutLog.TAG_RESOURCES_FORMAT, String.format("\"%1$s\" in attribute \"%2$s\" cannot be converted to a fraction.", value, mNames[index]), null);
    return defValue;
}
Body of Second Method:
{
    String value = getString(index);
    if (value == null) {
        return defValue;
    }
    if (ResourceHelper.parseFloatAttribute(mNames[index], value, mValue, false)) {
        return mValue.getFraction(base, pbase);
    }
    // looks like we were unable to resolve the fraction value
    Bridge.getLog().warning(LayoutLog.TAG_RESOURCES_FORMAT, String.format("\"%1$s\" in attribute \"%2$s\" cannot be converted to a fraction.", value, mNames[index]), null);
    return defValue;
}
------------------------
Find a silently evolved API code:android.os.Bundle.getSerializable:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the value associated with the given key, or null if
 * no mapping of the desired type exists for the given key or a null
 * value is explicitly associated with the key.
 *
 * @param key a String, or null
 * @return a Serializable value, or null
 */

Body of Frist Method:
{
    unparcel();
    Object o = mMap.get(key);
    if (o == null) {
        return null;
    }
    try {
        return (Serializable) o;
    } catch (ClassCastException e) {
        typeWarning(key, o, "Serializable", e);
        return null;
    }
}
Body of Second Method:
{
    return super.getSerializable(key);
}
------------------------
Find a silently evolved API code:android.os.SELinux.restorecon:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Restores a file to its default SELinux security context.
 * If the system is not compiled with SELinux, then {@code true}
 * is automatically returned.
 * If SELinux is compiled in, but disabled, then {@code true} is
 * returned.
 *
 * @param pathname The pathname of the file to be relabeled.
 * @return a boolean indicating whether the relabeling succeeded.
 * @exception NullPointerException if the pathname is a null object.
 */

Body of Frist Method:
{
    if (pathname == null) {
        throw new NullPointerException();
    }
    return native_restorecon(pathname);
}
Body of Second Method:
{
    if (pathname == null) {
        throw new NullPointerException();
    }
    return native_restorecon(pathname, 0);
}
------------------------
Find a silently evolved API code:android.view.MotionEvent.PointerCoords.setAxisValue:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the value associated with the specified axis.
 *
 * @param axis The axis identifier for the axis value to assign.
 * @param value The value to set.
 *
 * @see MotionEvent#AXIS_X
 * @see MotionEvent#AXIS_Y
 */

Body of Frist Method:
{
    switch(axis) {
        case AXIS_X:
            x = value;
            break;
        case AXIS_Y:
            y = value;
            break;
        case AXIS_PRESSURE:
            pressure = value;
            break;
        case AXIS_SIZE:
            size = value;
            break;
        case AXIS_TOUCH_MAJOR:
            touchMajor = value;
            break;
        case AXIS_TOUCH_MINOR:
            touchMinor = value;
            break;
        case AXIS_TOOL_MAJOR:
            toolMajor = value;
            break;
        case AXIS_TOOL_MINOR:
            toolMinor = value;
            break;
        case AXIS_ORIENTATION:
            orientation = value;
            break;
        default:
            {
                if (axis < 0 || axis > 63) {
                    throw new IllegalArgumentException("Axis out of range.");
                }
                final long bits = mPackedAxisBits;
                final long axisBit = 1L << axis;
                final int index = Long.bitCount(bits & (axisBit - 1L));
                float[] values = mPackedAxisValues;
                if ((bits & axisBit) == 0) {
                    if (values == null) {
                        values = new float[INITIAL_PACKED_AXIS_VALUES];
                        mPackedAxisValues = values;
                    } else {
                        final int count = Long.bitCount(bits);
                        if (count < values.length) {
                            if (index != count) {
                                System.arraycopy(values, index, values, index + 1, count - index);
                            }
                        } else {
                            float[] newValues = new float[count * 2];
                            System.arraycopy(values, 0, newValues, 0, index);
                            System.arraycopy(values, index, newValues, index + 1, count - index);
                            values = newValues;
                            mPackedAxisValues = values;
                        }
                    }
                    mPackedAxisBits = bits | axisBit;
                }
                values[index] = value;
            }
    }
}
Body of Second Method:
{
    switch(axis) {
        case AXIS_X:
            x = value;
            break;
        case AXIS_Y:
            y = value;
            break;
        case AXIS_PRESSURE:
            pressure = value;
            break;
        case AXIS_SIZE:
            size = value;
            break;
        case AXIS_TOUCH_MAJOR:
            touchMajor = value;
            break;
        case AXIS_TOUCH_MINOR:
            touchMinor = value;
            break;
        case AXIS_TOOL_MAJOR:
            toolMajor = value;
            break;
        case AXIS_TOOL_MINOR:
            toolMinor = value;
            break;
        case AXIS_ORIENTATION:
            orientation = value;
            break;
        default:
            {
                if (axis < 0 || axis > 63) {
                    throw new IllegalArgumentException("Axis out of range.");
                }
                final long bits = mPackedAxisBits;
                final long axisBit = 0x8000000000000000L >>> axis;
                final int index = Long.bitCount(bits & ~(0xFFFFFFFFFFFFFFFFL >>> axis));
                float[] values = mPackedAxisValues;
                if ((bits & axisBit) == 0) {
                    if (values == null) {
                        values = new float[INITIAL_PACKED_AXIS_VALUES];
                        mPackedAxisValues = values;
                    } else {
                        final int count = Long.bitCount(bits);
                        if (count < values.length) {
                            if (index != count) {
                                System.arraycopy(values, index, values, index + 1, count - index);
                            }
                        } else {
                            float[] newValues = new float[count * 2];
                            System.arraycopy(values, 0, newValues, 0, index);
                            System.arraycopy(values, index, newValues, index + 1, count - index);
                            values = newValues;
                            mPackedAxisValues = values;
                        }
                    }
                    mPackedAxisBits = bits | axisBit;
                }
                values[index] = value;
            }
    }
}
------------------------
Find a silently evolved API code:android.util.Log.wtfStack:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Like {@link #wtf(String, String)}, but also writes to the log the full
 * call stack.
 * @hide
 */

Body of Frist Method:
{
    return wtf(LOG_ID_MAIN, tag, msg, null, true);
}
Body of Second Method:
{
    return wtf(LOG_ID_MAIN, tag, msg, null, true, false);
}
------------------------
Find a silently evolved API code:android.os.Bundle.putBooleanArray:COMMENT
Method Modifier: public      
Comment:/**
 * Inserts a boolean array value into the mapping of this Bundle, replacing
 * any existing value for the given key.  Either key or value may be null.
 *
 * @param key a String, or null
 * @param value a boolean array object, or null
 */

Body of Frist Method:
{
    unparcel();
    mMap.put(key, value);
}
Body of Second Method:
{
    super.putBooleanArray(key, value);
}
------------------------
Find a silently evolved API code:android.graphics.drawable.ColorDrawable.getColor:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the drawable's color value.
 *
 * @return int The color to draw.
 */

Body of Frist Method:
{
    return mState.mUseColor;
}
Body of Second Method:
{
    return mColorState.mUseColor;
}
------------------------
Find a silently evolved API code:android.transition.Transition.animate:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * This is a utility method used by subclasses to handle standard parts of
 * setting up and running an Animator: it sets the {@link #getDuration()
 * duration} and the {@link #getStartDelay() startDelay}, starts the
 * animation, and, when the animator ends, calls {@link #end()}.
 *
 * @param animator The Animator to be run during this transition.
 *
 * @hide
 */

Body of Frist Method:
{
    // TODO: maybe pass auto-end as a boolean parameter?
    if (animator == null) {
        end();
    } else {
        if (getDuration() >= 0) {
            animator.setDuration(getDuration());
        }
        if (getStartDelay() >= 0) {
            animator.setStartDelay(getStartDelay());
        }
        if (getInterpolator() != null) {
            animator.setInterpolator(getInterpolator());
        }
        animator.addListener(new AnimatorListenerAdapter() {

            @Override
            public void onAnimationEnd(Animator animation) {
                end();
                animation.removeListener(this);
            }
        });
        animator.start();
    }
}
Body of Second Method:
{
    // TODO: maybe pass auto-end as a boolean parameter?
    if (animator == null) {
        end();
    } else {
        if (getDuration() >= 0) {
            animator.setDuration(getDuration());
        }
        if (getStartDelay() >= 0) {
            animator.setStartDelay(getStartDelay() + animator.getStartDelay());
        }
        if (getInterpolator() != null) {
            animator.setInterpolator(getInterpolator());
        }
        animator.addListener(new AnimatorListenerAdapter() {

            @Override
            public void onAnimationEnd(Animator animation) {
                end();
                animation.removeListener(this);
            }
        });
        animator.start();
    }
}
------------------------
Find a silently evolved API code:android.content.res.BridgeTypedArray.getResourceId:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the resource identifier for the attribute at
 * <var>index</var>.  Note that attribute resource as resolved when
 * the overall {@link TypedArray} object is retrieved.  As a
 * result, this function will return the resource identifier of the
 * final resource value that was found, <em>not</em> necessarily the
 * original resource that was specified by the attribute.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute resource identifier, or defValue if not defined.
 */

Body of Frist Method:
{
    if (index < 0 || index >= mResourceData.length) {
        return defValue;
    }
    // get the Resource for this index
    ResourceValue resValue = mResourceData[index];
    // no data, return the default value.
    if (resValue == null) {
        return defValue;
    }
    // check if this is a style resource
    if (resValue instanceof StyleResourceValue) {
        // get the id that will represent this style.
        return mContext.getDynamicIdByStyle((StyleResourceValue) resValue);
    }
    if (RenderResources.REFERENCE_NULL.equals(resValue.getValue())) {
        return defValue;
    }
    // (and getValue() returning null!). We need to handle this!
    if (resValue.getResourceType() != null) {
        // if this is a framework id
        if (mPlatformFile || resValue.isFramework()) {
            // look for idName in the android R classes
            return mContext.getFrameworkResourceValue(resValue.getResourceType(), resValue.getName(), defValue);
        }
        // look for idName in the project R class.
        return mContext.getProjectResourceValue(resValue.getResourceType(), resValue.getName(), defValue);
    }
    // else, try to get the value, and resolve it somehow.
    String value = resValue.getValue();
    if (value == null) {
        return defValue;
    }
    // if the value is just an integer, return it.
    try {
        int i = Integer.parseInt(value);
        if (Integer.toString(i).equals(value)) {
            return i;
        }
    } catch (NumberFormatException e) {
    // pass
    }
    // if this is a reference to an id, find it.
    if (value.startsWith("@id/") || value.startsWith("@+") || value.startsWith("@android:id/")) {
        int pos = value.indexOf('/');
        String idName = value.substring(pos + 1);
        // if this is a framework id
        if (mPlatformFile || value.startsWith("@android") || value.startsWith("@+android")) {
            // look for idName in the android R classes
            return mContext.getFrameworkResourceValue(ResourceType.ID, idName, defValue);
        }
        // look for idName in the project R class.
        return mContext.getProjectResourceValue(ResourceType.ID, idName, defValue);
    }
    // not a direct id valid reference? resolve it
    Integer idValue = null;
    if (resValue.isFramework()) {
        idValue = Bridge.getResourceId(resValue.getResourceType(), resValue.getName());
    } else {
        idValue = mContext.getProjectCallback().getResourceId(resValue.getResourceType(), resValue.getName());
    }
    if (idValue != null) {
        return idValue.intValue();
    }
    Bridge.getLog().warning(LayoutLog.TAG_RESOURCES_RESOLVE, String.format("Unable to resolve id \"%1$s\" for attribute \"%2$s\"", value, mNames[index]), resValue);
    return defValue;
}
Body of Second Method:
{
    if (index < 0 || index >= mResourceData.length) {
        return defValue;
    }
    // get the Resource for this index
    ResourceValue resValue = mResourceData[index];
    // no data, return the default value.
    if (resValue == null) {
        return defValue;
    }
    // check if this is a style resource
    if (resValue instanceof StyleResourceValue) {
        // get the id that will represent this style.
        return mContext.getDynamicIdByStyle((StyleResourceValue) resValue);
    }
    // (and getValue() returning null!). We need to handle this!
    if (resValue.getResourceType() != null) {
        // if this is a framework id
        if (mPlatformFile || resValue.isFramework()) {
            // look for idName in the android R classes
            return mContext.getFrameworkResourceValue(resValue.getResourceType(), resValue.getName(), defValue);
        }
        // look for idName in the project R class.
        return mContext.getProjectResourceValue(resValue.getResourceType(), resValue.getName(), defValue);
    }
    // else, try to get the value, and resolve it somehow.
    String value = resValue.getValue();
    if (value == null) {
        return defValue;
    }
    // if the value is just an integer, return it.
    try {
        int i = Integer.parseInt(value);
        if (Integer.toString(i).equals(value)) {
            return i;
        }
    } catch (NumberFormatException e) {
    // pass
    }
    // if this is a reference to an id, find it.
    if (value.startsWith("@id/") || value.startsWith("@+") || value.startsWith("@android:id/")) {
        int pos = value.indexOf('/');
        String idName = value.substring(pos + 1);
        // if this is a framework id
        if (mPlatformFile || value.startsWith("@android") || value.startsWith("@+android")) {
            // look for idName in the android R classes
            return mContext.getFrameworkResourceValue(ResourceType.ID, idName, defValue);
        }
        // look for idName in the project R class.
        return mContext.getProjectResourceValue(ResourceType.ID, idName, defValue);
    }
    // not a direct id valid reference? resolve it
    Integer idValue;
    if (resValue.isFramework()) {
        idValue = Bridge.getResourceId(resValue.getResourceType(), resValue.getName());
    } else {
        idValue = mContext.getProjectCallback().getResourceId(resValue.getResourceType(), resValue.getName());
    }
    if (idValue != null) {
        return idValue;
    }
    Bridge.getLog().warning(LayoutLog.TAG_RESOURCES_RESOLVE, String.format("Unable to resolve id \"%1$s\" for attribute \"%2$s\"", value, mNames[index]), resValue);
    return defValue;
}
------------------------
Find a silently evolved API code:android.media.MediaDrm.getProvisionRequest:COMMENT
<android.media.MediaDrm: ProvisionRequest getProvisionRequest()>
public      native      ->public      
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * A provision request/response exchange occurs between the app and a provisioning
 * server to retrieve a device certificate.  If provisionining is required, the
 * EVENT_PROVISION_REQUIRED event will be sent to the event handler.
 * getProvisionRequest is used to obtain the opaque provision request byte array that
 * should be delivered to the provisioning server. The provision request byte array
 * is returned in ProvisionRequest.data. The recommended URL to deliver the provision
 * request to is returned in ProvisionRequest.defaultUrl.
 */

Body of Frist Method:

Body of Second Method:
{
    return getProvisionRequestNative(CERTIFICATE_TYPE_NONE, "");
}
------------------------
Find a silently evolved API code:android.view.KeyEvent.keyCodeFromString:COMMENT
Method Modifier: public      static      
Comment:/**
 * Gets a keycode by its symbolic name such as "KEYCODE_A" or an equivalent
 * numeric constant such as "1001".
 *
 * @param symbolicName The symbolic name of the keycode.
 * @return The keycode or {@link #KEYCODE_UNKNOWN} if not found.
 * @see #keycodeToString(int)
 */

Body of Frist Method:
{
    if (symbolicName == null) {
        throw new IllegalArgumentException("symbolicName must not be null");
    }
    final int count = KEYCODE_SYMBOLIC_NAMES.size();
    for (int i = 0; i < count; i++) {
        if (symbolicName.equals(KEYCODE_SYMBOLIC_NAMES.valueAt(i))) {
            return i;
        }
    }
    try {
        return Integer.parseInt(symbolicName, 10);
    } catch (NumberFormatException ex) {
        return KEYCODE_UNKNOWN;
    }
}
Body of Second Method:
{
    if (symbolicName.startsWith(LABEL_PREFIX)) {
        symbolicName = symbolicName.substring(LABEL_PREFIX.length());
        int keyCode = nativeKeyCodeFromString(symbolicName);
        if (keyCode > 0) {
            return keyCode;
        }
    }
    try {
        return Integer.parseInt(symbolicName, 10);
    } catch (NumberFormatException ex) {
        return KEYCODE_UNKNOWN;
    }
}
------------------------
Find a silently evolved API code:android.widget.CheckedTextView.setCheckMarkDrawable:COMMENT
Method Modifier: public      
Comment:/**
 * Set the checkmark to a given Drawable. This will be drawn when {@link #isChecked()} is true.
 *
 * @param d The Drawable to use for the checkmark.
 *
 * @see #setCheckMarkDrawable(int)
 * @see #getCheckMarkDrawable()
 *
 * @attr ref android.R.styleable#CheckedTextView_checkMark
 */

Body of Frist Method:
{
    if (mCheckMarkDrawable != null) {
        mCheckMarkDrawable.setCallback(null);
        unscheduleDrawable(mCheckMarkDrawable);
    }
    mNeedRequestlayout = (d != mCheckMarkDrawable);
    if (d != null) {
        d.setCallback(this);
        d.setVisible(getVisibility() == VISIBLE, false);
        d.setState(CHECKED_STATE_SET);
        setMinHeight(d.getIntrinsicHeight());
        mCheckMarkWidth = d.getIntrinsicWidth();
        d.setState(getDrawableState());
    } else {
        mCheckMarkWidth = 0;
    }
    mCheckMarkDrawable = d;
    // Do padding resolution. This will call internalSetPadding() and do a requestLayout() if needed.
    resolvePadding();
}
Body of Second Method:
{
    if (mCheckMarkDrawable != null) {
        mCheckMarkDrawable.setCallback(null);
        unscheduleDrawable(mCheckMarkDrawable);
    }
    mNeedRequestlayout = (d != mCheckMarkDrawable);
    if (d != null) {
        d.setCallback(this);
        d.setVisible(getVisibility() == VISIBLE, false);
        d.setState(CHECKED_STATE_SET);
        setMinHeight(d.getIntrinsicHeight());
        mCheckMarkWidth = d.getIntrinsicWidth();
        d.setState(getDrawableState());
        applyCheckMarkTint();
    } else {
        mCheckMarkWidth = 0;
    }
    mCheckMarkDrawable = d;
    // Do padding resolution. This will call internalSetPadding() and do a
    // requestLayout() if needed.
    resolvePadding();
}
------------------------
Find a silently evolved API code:android.app.backup.BackupManager.requestRestore:COMMENT
Method Modifier: public      
Comment:/**
 * Restore the calling application from backup.  The data will be restored from the
 * current backup dataset if the application has stored data there, or from
 * the dataset used during the last full device setup operation if the current
 * backup dataset has no matching data.  If no backup data exists for this application
 * in either source, a nonzero value will be returned.
 *
 * <p>If this method returns zero (meaning success), the OS will attempt to retrieve
 * a backed-up dataset from the remote transport, instantiate the application's
 * backup agent, and pass the dataset to the agent's
 * {@link android.app.backup.BackupAgent#onRestore(BackupDataInput, int, android.os.ParcelFileDescriptor) onRestore()}
 * method.
 *
 * @param observer The {@link RestoreObserver} to receive callbacks during the restore
 * operation. This must not be null.
 *
 * @return Zero on success; nonzero on error.
 */

Body of Frist Method:
{
    int result = -1;
    checkServiceBinder();
    if (sService != null) {
        RestoreSession session = null;
        try {
            IRestoreSession binder = sService.beginRestoreSession(mContext.getPackageName(), null);
            if (binder != null) {
                session = new RestoreSession(mContext, binder);
                result = session.restorePackage(mContext.getPackageName(), observer);
            }
        } catch (RemoteException e) {
            Log.w(TAG, "restoreSelf() unable to contact service");
        } finally {
            if (session != null) {
                session.endRestoreSession();
            }
        }
    }
    return result;
}
Body of Second Method:
{
    int result = -1;
    checkServiceBinder();
    if (sService != null) {
        RestoreSession session = null;
        try {
            IRestoreSession binder = sService.beginRestoreSession(mContext.getPackageName(), null);
            if (binder != null) {
                session = new RestoreSession(mContext, binder);
                result = session.restorePackage(mContext.getPackageName(), observer);
            }
        } catch (RemoteException e) {
            Log.e(TAG, "restoreSelf() unable to contact service");
        } finally {
            if (session != null) {
                session.endRestoreSession();
            }
        }
    }
    return result;
}
------------------------
Find a silently evolved API code:android.graphics.drawable.AnimationDrawable.start:COMMENT
Method Modifier: public      
Comment:/**
 * <p>Starts the animation, looping if necessary. This method has no effect
 * if the animation is running. Do not call this in the {@link android.app.Activity#onCreate}
 * method of your activity, because the {@link android.graphics.drawable.AnimationDrawable} is
 * not yet fully attached to the window. If you want to play
 * the animation immediately, without requiring interaction, then you might want to call it
 * from the {@link android.app.Activity#onWindowFocusChanged} method in your activity,
 * which will get called when Android brings your window into focus.</p>
 *
 * @see #isRunning()
 * @see #stop()
 */

Body of Frist Method:
{
    if (!isRunning()) {
        run();
    }
}
Body of Second Method:
{
    mAnimating = true;
    if (!isRunning()) {
        run();
    }
}
------------------------
Find a silently evolved API code:android.graphics.Picture.getHeight:COMMENT
<android.graphics.Picture: int getHeight()>
public      native      ->public      
Method Modifier: public      native      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * Get the height of the picture as passed to beginRecording. This
 * does not reflect (per se) the content of the picture.
 */

Body of Frist Method:

Body of Second Method:
{
    return nativeGetHeight(mNativePicture);
}
------------------------
Find a silently evolved API code:android.media.MediaRouter.clearUserRoutes:COMMENT
Method Modifier: public      
Comment:/**
 * Remove all app-specified routes from the MediaRouter.
 *
 * @see #removeUserRoute(UserRouteInfo)
 */

Body of Frist Method:
{
    for (int i = 0; i < sStatic.mRoutes.size(); i++) {
        final RouteInfo info = sStatic.mRoutes.get(i);
        // The code below will need to change if this assumption does.
        if (info instanceof UserRouteInfo || info instanceof RouteGroup) {
            removeRouteAt(i);
            i--;
        }
    }
}
Body of Second Method:
{
    for (int i = 0; i < sStatic.mRoutes.size(); i++) {
        final RouteInfo info = sStatic.mRoutes.get(i);
        // The code below will need to change if this assumption does.
        if (info instanceof UserRouteInfo || info instanceof RouteGroup) {
            removeRouteStatic(info);
            i--;
        }
    }
}
------------------------
Find a silently evolved API code:android.media.AudioTrack.play:COMMENT
Method Modifier: public      
Comment:/**
 * Starts playing an AudioTrack.
 * If track's creation mode is {@link #MODE_STATIC}, you must have called write() prior.
 *
 * @throws IllegalStateException
 */

Body of Frist Method:
{
    if (mState != STATE_INITIALIZED) {
        throw new IllegalStateException("play() called on uninitialized AudioTrack.");
    }
    synchronized (mPlayStateLock) {
        native_start();
        mPlayState = PLAYSTATE_PLAYING;
    }
}
Body of Second Method:
{
    if (mState != STATE_INITIALIZED) {
        throw new IllegalStateException("play() called on uninitialized AudioTrack.");
    }
    if (isRestricted()) {
        setVolume(0);
    }
    synchronized (mPlayStateLock) {
        native_start();
        mPlayState = PLAYSTATE_PLAYING;
    }
}
------------------------

