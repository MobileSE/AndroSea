Find a silently evolved API code:android.content.pm.PackageItemInfo.loadLabel:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the current textual label associated with this item.  This
 * will call back on the given PackageManager to load the label from
 * the application.
 *
 * @param pm A PackageManager from which the label can be loaded; usually
 * the PackageManager from which you originally retrieved this item.
 *
 * @return Returns a CharSequence containing the item's label.  If the
 * item does not have a label, its name is returned.
 */

Body of Frist Method:
{
    if (sForceSafeLabels) {
        return loadSafeLabel(pm);
    } else {
        return loadUnsafeLabel(pm);
    }
}
Body of Second Method:
{
    if (sForceSafeLabels) {
        return loadSafeLabel(pm, DEFAULT_MAX_LABEL_SIZE_PX, SAFE_STRING_FLAG_TRIM | SAFE_STRING_FLAG_FIRST_LINE);
    } else {
        return loadUnsafeLabel(pm);
    }
}
------------------------
Find a silently evolved API code:android.net.http.HttpResponseCache.getHitCount:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the number of HTTP requests whose response was provided by the
 * cache. This may include conditional {@code GET} requests that were
 * validated over the network.
 */

Body of Frist Method:
{
    return delegate.getHitCount();
}
Body of Second Method:
{
    return mDelegate.getHitCount();
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothAvrcpController.getDevicesMatchingConnectionStates:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (VDBG)
        log("getDevicesMatchingStates()");
    final IBluetoothAvrcpController service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.getDevicesMatchingConnectionStates(states);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
Body of Second Method:
{
    if (VDBG)
        log("getDevicesMatchingStates()");
    final IBluetoothAvrcpController service = getService();
    if (service != null && isEnabled()) {
        try {
            return service.getDevicesMatchingConnectionStates(states);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothAvrcpController.getConnectionState:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (VDBG)
        log("getState(" + device + ")");
    final IBluetoothAvrcpController service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getConnectionState(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.STATE_DISCONNECTED;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return BluetoothProfile.STATE_DISCONNECTED;
}
Body of Second Method:
{
    if (VDBG)
        log("getState(" + device + ")");
    final IBluetoothAvrcpController service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getConnectionState(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.STATE_DISCONNECTED;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return BluetoothProfile.STATE_DISCONNECTED;
}
------------------------
Find a silently evolved API code:android.hardware.usb.UsbDevice.getConfiguration:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the {@link UsbConfiguration} at the given index.
 *
 * @return the configuration
 */

Body of Frist Method:
{
    return (UsbConfiguration) mConfigurations[index];
}
Body of Second Method:
{
    return mConfigurations[index];
}
------------------------
Find a silently evolved API code:android.widget.ProgressBar.getIndeterminateTintMode:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the blending mode used to apply the tint to the indeterminate
 * drawable, if specified.
 *
 * @return the blending mode used to apply the tint to the indeterminate
 * drawable
 * @attr ref android.R.styleable#ProgressBar_indeterminateTintMode
 * @see #setIndeterminateTintMode(PorterDuff.Mode)
 */

Body of Frist Method:
{
    return mProgressTintInfo != null ? mProgressTintInfo.mIndeterminateTintMode : null;
}
Body of Second Method:
{
    BlendMode mode = getIndeterminateTintBlendMode();
    return mode != null ? BlendMode.blendModeToPorterDuffMode(mode) : null;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothA2dp.enableDisableOptionalCodecs:COMMENT
Method Modifier: private     
Comment:/**
 * Enables or disables the optional codecs.
 *
 * @param device the remote Bluetooth device. If null, use the currect
 * active A2DP Bluetooth device.
 * @param enable if true, enable the optional codecs, other disable them
 */

Body of Frist Method:
{
    try {
        mServiceLock.readLock().lock();
        if (mService != null && isEnabled()) {
            if (enable) {
                mService.enableOptionalCodecs(device);
            } else {
                mService.disableOptionalCodecs(device);
            }
        }
        if (mService == null)
            Log.w(TAG, "Proxy not attached to service");
        return;
    } catch (RemoteException e) {
        Log.e(TAG, "Error talking to BT service in enableDisableOptionalCodecs()", e);
        return;
    } finally {
        mServiceLock.readLock().unlock();
    }
}
Body of Second Method:
{
    try {
        final IBluetoothA2dp service = getService();
        if (service != null && isEnabled()) {
            if (enable) {
                service.enableOptionalCodecs(device);
            } else {
                service.disableOptionalCodecs(device);
            }
        }
        if (service == null)
            Log.w(TAG, "Proxy not attached to service");
        return;
    } catch (RemoteException e) {
        Log.e(TAG, "Error talking to BT service in enableDisableOptionalCodecs()", e);
        return;
    }
}
------------------------
Find a silently evolved API code:android.telecom.ConferenceParticipant.toString:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Builds a string representation of this instance.
 *
 * @return String representing the conference participant.
 */

Body of Frist Method:
{
    StringBuilder sb = new StringBuilder();
    sb.append("[ConferenceParticipant Handle: ");
    sb.append(Log.pii(mHandle));
    sb.append(" DisplayName: ");
    sb.append(Log.pii(mDisplayName));
    sb.append(" Endpoint: ");
    sb.append(Log.pii(mEndpoint));
    sb.append(" State: ");
    sb.append(Connection.stateToString(mState));
    sb.append("]");
    return sb.toString();
}
Body of Second Method:
{
    StringBuilder sb = new StringBuilder();
    sb.append("[ConferenceParticipant Handle: ");
    sb.append(Log.pii(mHandle));
    sb.append(" DisplayName: ");
    sb.append(Log.pii(mDisplayName));
    sb.append(" Endpoint: ");
    sb.append(Log.pii(mEndpoint));
    sb.append(" State: ");
    sb.append(Connection.stateToString(mState));
    sb.append(" ConnectTime: ");
    sb.append(getConnectTime());
    sb.append(" ConnectElapsedTime: ");
    sb.append(getConnectElapsedTime());
    sb.append(" Direction: ");
    sb.append(getCallDirection() == Call.Details.DIRECTION_INCOMING ? "Incoming" : "Outgoing");
    sb.append("]");
    return sb.toString();
}
------------------------
Find a silently evolved API code:android.database.sqlite.SQLiteConnectionPool.reconfigure:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Reconfigures the database configuration of the connection pool and all of its
 * connections.
 * <p>
 * Configuration changes are propagated down to connections immediately if
 * they are available or as soon as they are released.  This includes changes
 * that affect the size of the pool.
 * </p>
 *
 * @param configuration The new configuration.
 *
 * @throws IllegalStateException if the pool has been closed.
 */

Body of Frist Method:
{
    if (configuration == null) {
        throw new IllegalArgumentException("configuration must not be null.");
    }
    synchronized (mLock) {
        throwIfClosedLocked();
        boolean walModeChanged = ((configuration.openFlags ^ mConfiguration.openFlags) & SQLiteDatabase.ENABLE_WRITE_AHEAD_LOGGING) != 0;
        if (walModeChanged) {
            // because we need to close all but the primary connection first.
            if (!mAcquiredConnections.isEmpty()) {
                throw new IllegalStateException("Write Ahead Logging (WAL) mode cannot " + "be enabled or disabled while there are transactions in " + "progress.  Finish all transactions and release all active " + "database connections first.");
            }
            // Close all non-primary connections.  This should happen immediately
            // because none of them are in use.
            closeAvailableNonPrimaryConnectionsAndLogExceptionsLocked();
            assert mAvailableNonPrimaryConnections.isEmpty();
        }
        boolean foreignKeyModeChanged = configuration.foreignKeyConstraintsEnabled != mConfiguration.foreignKeyConstraintsEnabled;
        if (foreignKeyModeChanged) {
            // any acquired connections.
            if (!mAcquiredConnections.isEmpty()) {
                throw new IllegalStateException("Foreign Key Constraints cannot " + "be enabled or disabled while there are transactions in " + "progress.  Finish all transactions and release all active " + "database connections first.");
            }
        }
        // We should do in-place switching when transitioning from compatibility WAL
        // to rollback journal. Otherwise transient connection state will be lost
        boolean onlyCompatWalChanged = (mConfiguration.openFlags ^ configuration.openFlags) == SQLiteDatabase.DISABLE_COMPATIBILITY_WAL;
        if (!onlyCompatWalChanged && mConfiguration.openFlags != configuration.openFlags) {
            // because there can only be one connection open when we change WAL mode.
            if (walModeChanged) {
                closeAvailableConnectionsAndLogExceptionsLocked();
            }
            // Try to reopen the primary connection using the new open flags then
            // close and discard all existing connections.
            // This might throw if the database is corrupt or cannot be opened in
            // the new mode in which case existing connections will remain untouched.
            SQLiteConnection newPrimaryConnection = openConnectionLocked(configuration, true);
            closeAvailableConnectionsAndLogExceptionsLocked();
            discardAcquiredConnectionsLocked();
            mAvailablePrimaryConnection = newPrimaryConnection;
            mConfiguration.updateParametersFrom(configuration);
            setMaxConnectionPoolSizeLocked();
        } else {
            // Reconfigure the database connections in place.
            mConfiguration.updateParametersFrom(configuration);
            setMaxConnectionPoolSizeLocked();
            closeExcessConnectionsAndLogExceptionsLocked();
            reconfigureAllConnectionsLocked();
        }
        wakeConnectionWaitersLocked();
    }
}
Body of Second Method:
{
    if (configuration == null) {
        throw new IllegalArgumentException("configuration must not be null.");
    }
    synchronized (mLock) {
        throwIfClosedLocked();
        boolean walModeChanged = ((configuration.openFlags ^ mConfiguration.openFlags) & SQLiteDatabase.ENABLE_WRITE_AHEAD_LOGGING) != 0;
        if (walModeChanged) {
            // because we need to close all but the primary connection first.
            if (!mAcquiredConnections.isEmpty()) {
                throw new IllegalStateException("Write Ahead Logging (WAL) mode cannot " + "be enabled or disabled while there are transactions in " + "progress.  Finish all transactions and release all active " + "database connections first.");
            }
            // Close all non-primary connections.  This should happen immediately
            // because none of them are in use.
            closeAvailableNonPrimaryConnectionsAndLogExceptionsLocked();
            assert mAvailableNonPrimaryConnections.isEmpty();
        }
        boolean foreignKeyModeChanged = configuration.foreignKeyConstraintsEnabled != mConfiguration.foreignKeyConstraintsEnabled;
        if (foreignKeyModeChanged) {
            // any acquired connections.
            if (!mAcquiredConnections.isEmpty()) {
                throw new IllegalStateException("Foreign Key Constraints cannot " + "be enabled or disabled while there are transactions in " + "progress.  Finish all transactions and release all active " + "database connections first.");
            }
        }
        // We should do in-place switching when transitioning from compatibility WAL
        // to rollback journal. Otherwise transient connection state will be lost
        boolean onlyCompatWalChanged = (mConfiguration.openFlags ^ configuration.openFlags) == SQLiteDatabase.ENABLE_LEGACY_COMPATIBILITY_WAL;
        if (!onlyCompatWalChanged && mConfiguration.openFlags != configuration.openFlags) {
            // because there can only be one connection open when we change WAL mode.
            if (walModeChanged) {
                closeAvailableConnectionsAndLogExceptionsLocked();
            }
            // Try to reopen the primary connection using the new open flags then
            // close and discard all existing connections.
            // This might throw if the database is corrupt or cannot be opened in
            // the new mode in which case existing connections will remain untouched.
            SQLiteConnection newPrimaryConnection = openConnectionLocked(configuration, true);
            closeAvailableConnectionsAndLogExceptionsLocked();
            discardAcquiredConnectionsLocked();
            mAvailablePrimaryConnection = newPrimaryConnection;
            mConfiguration.updateParametersFrom(configuration);
            setMaxConnectionPoolSizeLocked();
        } else {
            // Reconfigure the database connections in place.
            mConfiguration.updateParametersFrom(configuration);
            setMaxConnectionPoolSizeLocked();
            closeExcessConnectionsAndLogExceptionsLocked();
            reconfigureAllConnectionsLocked();
        }
        wakeConnectionWaitersLocked();
    }
}
------------------------
Find a silently evolved API code:android.location.SettingInjectorService.sendStatus:COMMENT
Method Modifier: private     
Comment:/**
 * Send the enabled values back to the caller via the messenger encoded in the
 * intent.
 */

Body of Frist Method:
{
    Message message = Message.obtain();
    Bundle bundle = new Bundle();
    bundle.putBoolean(ENABLED_KEY, enabled);
    message.setData(bundle);
    if (Log.isLoggable(TAG, Log.DEBUG)) {
        Log.d(TAG, mName + ": received " + intent + ", enabled=" + enabled + ", sending message: " + message);
    }
    Messenger messenger = intent.getParcelableExtra(MESSENGER_KEY);
    try {
        messenger.send(message);
    } catch (RemoteException e) {
        Log.e(TAG, mName + ": sending dynamic status failed", e);
    }
}
Body of Second Method:
{
    Messenger messenger = intent.getParcelableExtra(MESSENGER_KEY);
    // Bail out to avoid crashing GmsCore with incoming malicious Intent.
    if (messenger == null) {
        return;
    }
    Message message = Message.obtain();
    Bundle bundle = new Bundle();
    bundle.putString(SUMMARY_KEY, summary);
    bundle.putBoolean(ENABLED_KEY, enabled);
    message.setData(bundle);
    if (Log.isLoggable(TAG, Log.DEBUG)) {
        Log.d(TAG, mName + ": received " + intent + ", summary=" + summary + ", enabled=" + enabled + ", sending message: " + message);
    }
    try {
        messenger.send(message);
    } catch (RemoteException e) {
        Log.e(TAG, mName + ": sending dynamic status failed", e);
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothSap.getPriority:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the priority of the profile.
 *
 * @param device Bluetooth device
 * @return priority of the device
 * @hide
 */

Body of Frist Method:
{
    if (VDBG)
        log("getPriority(" + device + ")");
    final IBluetoothSap service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getPriority(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return PRIORITY_OFF;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return PRIORITY_OFF;
}
Body of Second Method:
{
    if (VDBG)
        log("getPriority(" + device + ")");
    final IBluetoothSap service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getPriority(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return PRIORITY_OFF;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return PRIORITY_OFF;
}
------------------------
Find a silently evolved API code:android.os.Looper.loop:COMMENT
Method Modifier: public      static      
Comment:/**
 * Run the message queue in this thread. Be sure to call
 * {@link #quit()} to end the loop.
 */

Body of Frist Method:
{
    final Looper me = myLooper();
    if (me == null) {
        throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread.");
    }
    final MessageQueue queue = me.mQueue;
    // Make sure the identity of this thread is that of the local process,
    // and keep track of what that identity token actually is.
    Binder.clearCallingIdentity();
    final long ident = Binder.clearCallingIdentity();
    // Allow overriding a threshold with a system prop. e.g.
    // adb shell 'setprop log.looper.1000.main.slow 1 && stop && start'
    final int thresholdOverride = SystemProperties.getInt("log.looper." + Process.myUid() + "." + Thread.currentThread().getName() + ".slow", 0);
    boolean slowDeliveryDetected = false;
    for (; ; ) {
        // might block
        Message msg = queue.next();
        if (msg == null) {
            // No message indicates that the message queue is quitting.
            return;
        }
        // This must be in a local variable, in case a UI event sets the logger
        final Printer logging = me.mLogging;
        if (logging != null) {
            logging.println(">>>>> Dispatching to " + msg.target + " " + msg.callback + ": " + msg.what);
        }
        final long traceTag = me.mTraceTag;
        long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;
        long slowDeliveryThresholdMs = me.mSlowDeliveryThresholdMs;
        if (thresholdOverride > 0) {
            slowDispatchThresholdMs = thresholdOverride;
            slowDeliveryThresholdMs = thresholdOverride;
        }
        final boolean logSlowDelivery = (slowDeliveryThresholdMs > 0) && (msg.when > 0);
        final boolean logSlowDispatch = (slowDispatchThresholdMs > 0);
        final boolean needStartTime = logSlowDelivery || logSlowDispatch;
        final boolean needEndTime = logSlowDispatch;
        if (traceTag != 0 && Trace.isTagEnabled(traceTag)) {
            Trace.traceBegin(traceTag, msg.target.getTraceName(msg));
        }
        final long dispatchStart = needStartTime ? SystemClock.uptimeMillis() : 0;
        final long dispatchEnd;
        try {
            msg.target.dispatchMessage(msg);
            dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0;
        } finally {
            if (traceTag != 0) {
                Trace.traceEnd(traceTag);
            }
        }
        if (logSlowDelivery) {
            if (slowDeliveryDetected) {
                if ((dispatchStart - msg.when) <= 10) {
                    Slog.w(TAG, "Drained");
                    slowDeliveryDetected = false;
                }
            } else {
                if (showSlowLog(slowDeliveryThresholdMs, msg.when, dispatchStart, "delivery", msg)) {
                    // Once we write a slow delivery log, suppress until the queue drains.
                    slowDeliveryDetected = true;
                }
            }
        }
        if (logSlowDispatch) {
            showSlowLog(slowDispatchThresholdMs, dispatchStart, dispatchEnd, "dispatch", msg);
        }
        if (logging != null) {
            logging.println("<<<<< Finished to " + msg.target + " " + msg.callback);
        }
        // Make sure that during the course of dispatching the
        // identity of the thread wasn't corrupted.
        final long newIdent = Binder.clearCallingIdentity();
        if (ident != newIdent) {
            Log.wtf(TAG, "Thread identity changed from 0x" + Long.toHexString(ident) + " to 0x" + Long.toHexString(newIdent) + " while dispatching to " + msg.target.getClass().getName() + " " + msg.callback + " what=" + msg.what);
        }
        msg.recycleUnchecked();
    }
}
Body of Second Method:
{
    final Looper me = myLooper();
    if (me == null) {
        throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread.");
    }
    final MessageQueue queue = me.mQueue;
    // Make sure the identity of this thread is that of the local process,
    // and keep track of what that identity token actually is.
    Binder.clearCallingIdentity();
    final long ident = Binder.clearCallingIdentity();
    // Allow overriding a threshold with a system prop. e.g.
    // adb shell 'setprop log.looper.1000.main.slow 1 && stop && start'
    final int thresholdOverride = SystemProperties.getInt("log.looper." + Process.myUid() + "." + Thread.currentThread().getName() + ".slow", 0);
    boolean slowDeliveryDetected = false;
    for (; ; ) {
        // might block
        Message msg = queue.next();
        if (msg == null) {
            // No message indicates that the message queue is quitting.
            return;
        }
        // This must be in a local variable, in case a UI event sets the logger
        final Printer logging = me.mLogging;
        if (logging != null) {
            logging.println(">>>>> Dispatching to " + msg.target + " " + msg.callback + ": " + msg.what);
        }
        // Make sure the observer won't change while processing a transaction.
        final Observer observer = sObserver;
        final long traceTag = me.mTraceTag;
        long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;
        long slowDeliveryThresholdMs = me.mSlowDeliveryThresholdMs;
        if (thresholdOverride > 0) {
            slowDispatchThresholdMs = thresholdOverride;
            slowDeliveryThresholdMs = thresholdOverride;
        }
        final boolean logSlowDelivery = (slowDeliveryThresholdMs > 0) && (msg.when > 0);
        final boolean logSlowDispatch = (slowDispatchThresholdMs > 0);
        final boolean needStartTime = logSlowDelivery || logSlowDispatch;
        final boolean needEndTime = logSlowDispatch;
        if (traceTag != 0 && Trace.isTagEnabled(traceTag)) {
            Trace.traceBegin(traceTag, msg.target.getTraceName(msg));
        }
        final long dispatchStart = needStartTime ? SystemClock.uptimeMillis() : 0;
        final long dispatchEnd;
        Object token = null;
        if (observer != null) {
            token = observer.messageDispatchStarting();
        }
        long origWorkSource = ThreadLocalWorkSource.setUid(msg.workSourceUid);
        try {
            msg.target.dispatchMessage(msg);
            if (observer != null) {
                observer.messageDispatched(token, msg);
            }
            dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0;
        } catch (Exception exception) {
            if (observer != null) {
                observer.dispatchingThrewException(token, msg, exception);
            }
            throw exception;
        } finally {
            ThreadLocalWorkSource.restore(origWorkSource);
            if (traceTag != 0) {
                Trace.traceEnd(traceTag);
            }
        }
        if (logSlowDelivery) {
            if (slowDeliveryDetected) {
                if ((dispatchStart - msg.when) <= 10) {
                    Slog.w(TAG, "Drained");
                    slowDeliveryDetected = false;
                }
            } else {
                if (showSlowLog(slowDeliveryThresholdMs, msg.when, dispatchStart, "delivery", msg)) {
                    // Once we write a slow delivery log, suppress until the queue drains.
                    slowDeliveryDetected = true;
                }
            }
        }
        if (logSlowDispatch) {
            showSlowLog(slowDispatchThresholdMs, dispatchStart, dispatchEnd, "dispatch", msg);
        }
        if (logging != null) {
            logging.println("<<<<< Finished to " + msg.target + " " + msg.callback);
        }
        // Make sure that during the course of dispatching the
        // identity of the thread wasn't corrupted.
        final long newIdent = Binder.clearCallingIdentity();
        if (ident != newIdent) {
            Log.wtf(TAG, "Thread identity changed from 0x" + Long.toHexString(ident) + " to 0x" + Long.toHexString(newIdent) + " while dispatching to " + msg.target.getClass().getName() + " " + msg.callback + " what=" + msg.what);
        }
        msg.recycleUnchecked();
    }
}
------------------------
Find a silently evolved API code:android.util.DebugUtils.flagsToString:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Use prefixed constants (static final values) on given class to turn flags
 * into human-readable string.
 *
 * @hide
 */

Body of Frist Method:
{
    final StringBuilder res = new StringBuilder();
    boolean flagsWasZero = flags == 0;
    for (Field field : clazz.getDeclaredFields()) {
        final int modifiers = field.getModifiers();
        if (Modifier.isStatic(modifiers) && Modifier.isFinal(modifiers) && field.getType().equals(int.class) && field.getName().startsWith(prefix)) {
            try {
                final int value = field.getInt(null);
                if (value == 0 && flagsWasZero) {
                    return constNameWithoutPrefix(prefix, field);
                }
                if ((flags & value) != 0) {
                    flags &= ~value;
                    res.append(constNameWithoutPrefix(prefix, field)).append('|');
                }
            } catch (IllegalAccessException ignored) {
            }
        }
    }
    if (flags != 0 || res.length() == 0) {
        res.append(Integer.toHexString(flags));
    } else {
        res.deleteCharAt(res.length() - 1);
    }
    return res.toString();
}
Body of Second Method:
{
    final StringBuilder res = new StringBuilder();
    boolean flagsWasZero = flags == 0;
    for (Field field : clazz.getDeclaredFields()) {
        final int modifiers = field.getModifiers();
        if (Modifier.isStatic(modifiers) && Modifier.isFinal(modifiers) && field.getType().equals(int.class) && field.getName().startsWith(prefix)) {
            try {
                final int value = field.getInt(null);
                if (value == 0 && flagsWasZero) {
                    return constNameWithoutPrefix(prefix, field);
                }
                if ((flags & value) == value) {
                    flags &= ~value;
                    res.append(constNameWithoutPrefix(prefix, field)).append('|');
                }
            } catch (IllegalAccessException ignored) {
            }
        }
    }
    if (flags != 0 || res.length() == 0) {
        res.append(Integer.toHexString(flags));
    } else {
        res.deleteCharAt(res.length() - 1);
    }
    return res.toString();
}
------------------------
Find a silently evolved API code:android.media.AudioFormat.Builder.setEncoding:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the data encoding format.
 * @param encoding the specified encoding or default.
 * @return the same Builder instance.
 * @throws java.lang.IllegalArgumentException
 */

Body of Frist Method:
{
    switch(encoding) {
        case ENCODING_DEFAULT:
            mEncoding = ENCODING_PCM_16BIT;
            break;
        case ENCODING_PCM_8BIT:
        case ENCODING_PCM_16BIT:
        case ENCODING_PCM_FLOAT:
        case ENCODING_AC3:
        case ENCODING_E_AC3:
        case ENCODING_E_AC3_JOC:
        case ENCODING_DTS:
        case ENCODING_DTS_HD:
        case ENCODING_IEC61937:
        case ENCODING_MP3:
        case ENCODING_AAC_LC:
        case ENCODING_AAC_HE_V1:
        case ENCODING_AAC_HE_V2:
        case ENCODING_AAC_ELD:
        case ENCODING_AAC_XHE:
        case ENCODING_AC4:
            mEncoding = encoding;
            break;
        case ENCODING_INVALID:
        default:
            throw new IllegalArgumentException("Invalid encoding " + encoding);
    }
    mPropertySetMask |= AUDIO_FORMAT_HAS_PROPERTY_ENCODING;
    return this;
}
Body of Second Method:
{
    switch(encoding) {
        case ENCODING_DEFAULT:
            mEncoding = ENCODING_PCM_16BIT;
            break;
        case ENCODING_PCM_16BIT:
        case ENCODING_PCM_8BIT:
        case ENCODING_PCM_FLOAT:
        case ENCODING_AC3:
        case ENCODING_E_AC3:
        case ENCODING_DTS:
        case ENCODING_DTS_HD:
        case ENCODING_MP3:
        case ENCODING_AAC_LC:
        case ENCODING_AAC_HE_V1:
        case ENCODING_AAC_HE_V2:
        case ENCODING_IEC61937:
        case ENCODING_DOLBY_TRUEHD:
        case ENCODING_AAC_ELD:
        case ENCODING_AAC_XHE:
        case ENCODING_AC4:
        case ENCODING_E_AC3_JOC:
        case ENCODING_DOLBY_MAT:
            mEncoding = encoding;
            break;
        case ENCODING_INVALID:
        default:
            throw new IllegalArgumentException("Invalid encoding " + encoding);
    }
    mPropertySetMask |= AUDIO_FORMAT_HAS_PROPERTY_ENCODING;
    return this;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.acceptCall:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Accepts a call
 *
 * @param device remote device
 * @param flag action policy while accepting a call. Possible values {@link #CALL_ACCEPT_NONE},
 * {@link #CALL_ACCEPT_HOLD}, {@link #CALL_ACCEPT_TERMINATE}
 * @return <code>true</code> if command has been issued successfully; <code>false</code>
 * otherwise; upon completion HFP sends {@link #ACTION_CALL_CHANGED} intent.
 */

Body of Frist Method:
{
    if (DBG)
        log("acceptCall()");
    final IBluetoothHeadsetClient service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.acceptCall(device, flag);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("acceptCall()");
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.acceptCall(device, flag);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.media.AudioFormat.getChannelMask:COMMENT
Method Modifier: public      
Comment:/**
 * Return the channel mask.
 * See the section on <a href="#channelMask">channel masks</a> for more information about
 * the difference between index-based masks(as returned by {@link #getChannelIndexMask()}) and
 * the position-based mask returned by this function.
 * @return one of the values that can be set in {@link Builder#setChannelMask(int)} or
 * {@link AudioFormat#CHANNEL_INVALID} if not set.
 */

Body of Frist Method:
{
    if ((mPropertySetMask & AUDIO_FORMAT_HAS_PROPERTY_CHANNEL_MASK) == 0) {
        return CHANNEL_INVALID;
    }
    return mChannelMask;
}
Body of Second Method:
{
    return mChannelMask;
}
------------------------
Find a silently evolved API code:android.view.textservice.SpellCheckerSubtype.getLocaleObject:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @return {@link Locale} constructed from {@link #getLanguageTag()}. If the Language Tag is not
 * specified, then try to construct from {@link #getLocale()}
 *
 * <p>TODO: Consider to make this a public API, or move this to support lib.</p>
 * @hide
 */

Body of Frist Method:
{
    if (!TextUtils.isEmpty(mSubtypeLanguageTag)) {
        return Locale.forLanguageTag(mSubtypeLanguageTag);
    }
    return InputMethodUtils.constructLocaleFromString(mSubtypeLocale);
}
Body of Second Method:
{
    if (!TextUtils.isEmpty(mSubtypeLanguageTag)) {
        return Locale.forLanguageTag(mSubtypeLanguageTag);
    }
    return SubtypeLocaleUtils.constructLocaleFromString(mSubtypeLocale);
}
------------------------
Find a silently evolved API code:android.media.session.MediaController.getPlaybackInfo:COMMENT
Method Modifier: public      
Comment:/**
 * Get the current playback info for this session.
 *
 * @return The current playback info or null.
 */

Body of Frist Method:
{
    try {
        ParcelableVolumeInfo result = mSessionBinder.getVolumeAttributes();
        return new PlaybackInfo(result.volumeType, result.audioAttrs, result.controlType, result.maxVolume, result.currentVolume);
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling getAudioInfo.", e);
    }
    return null;
}
Body of Second Method:
{
    try {
        return mSessionBinder.getVolumeAttributes();
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling getAudioInfo.", e);
    }
    return null;
}
------------------------
Find a silently evolved API code:android.telephony.ims.feature.MmTelFeature.notifyCapabilitiesStatusChanged:COMMENT
Method Modifier: public      final       hidden      
Comment:/**
 * Notify the framework that the status of the Capabilities has changed. Even though the
 * MmTelFeature capability may be enabled by the framework, the status may be disabled due to
 * the feature being unavailable from the network.
 * @param c The current capability status of the MmTelFeature. If a capability is disabled, then
 * the status of that capability is disabled. This can happen if the network does not currently
 * support the capability that is enabled. A capability that is disabled by the framework (via
 * {@link #changeEnabledCapabilities}) should also show the status as disabled.
 */

Body of Frist Method:
{
    super.notifyCapabilitiesStatusChanged(c);
}
Body of Second Method:
{
    if (c == null) {
        throw new IllegalArgumentException("MmTelCapabilities must be non-null!");
    }
    super.notifyCapabilitiesStatusChanged(c);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothA2dpSink.getDevicesMatchingConnectionStates:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (VDBG)
        log("getDevicesMatchingStates()");
    final IBluetoothA2dpSink service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.getDevicesMatchingConnectionStates(states);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
Body of Second Method:
{
    if (VDBG)
        log("getDevicesMatchingStates()");
    final IBluetoothA2dpSink service = getService();
    if (service != null && isEnabled()) {
        try {
            return service.getDevicesMatchingConnectionStates(states);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.terminateCall:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Terminates a specified call.
 *
 * Works only when Extended Call Control is supported by Audio Gateway.
 *
 * @param device remote device
 * @param call Handle of call obtained in {@link #dial(BluetoothDevice, String)} or obtained via
 * {@link #ACTION_CALL_CHANGED}. {@code call} may be null in which case we will hangup all active
 * calls.
 * @return <code>true</code> if command has been issued successfully; <code>false</code>
 * otherwise; upon completion HFP sends {@link #ACTION_CALL_CHANGED} intent.
 *
 * <p>Feature required for successful execution is being reported by: {@link
 * #EXTRA_AG_FEATURE_ECC}. This method invocation will fail silently when feature is not
 * supported.</p>
 */

Body of Frist Method:
{
    if (DBG)
        log("terminateCall()");
    final IBluetoothHeadsetClient service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.terminateCall(device, call);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("terminateCall()");
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.terminateCall(device, call);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.os.UserHandle.formatUid:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Generate a text representation of the uid, breaking out its individual
 * components -- user, app, isolated, etc.
 * @hide
 */

Body of Frist Method:
{
    StringBuilder sb = new StringBuilder();
    formatUid(sb, uid);
    return sb.toString();
}
Body of Second Method:
{
    if (uid < Process.FIRST_APPLICATION_UID) {
        sb.append(uid);
    } else {
        sb.append('u');
        sb.append(getUserId(uid));
        final int appId = getAppId(uid);
        if (isIsolated(appId)) {
            if (appId > Process.FIRST_ISOLATED_UID) {
                sb.append('i');
                sb.append(appId - Process.FIRST_ISOLATED_UID);
            } else {
                sb.append("ai");
                sb.append(appId - Process.FIRST_APP_ZYGOTE_ISOLATED_UID);
            }
        } else if (appId >= Process.FIRST_APPLICATION_UID) {
            sb.append('a');
            sb.append(appId - Process.FIRST_APPLICATION_UID);
        } else {
            sb.append('s');
            sb.append(appId);
        }
    }
}
------------------------
Find a silently evolved API code:android.view.inputmethod.CursorAnchorInfo.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * @return {@link CursorAnchorInfo} using parameters in this {@link Builder}.
 * @throws IllegalArgumentException if one or more positional parameters are specified but
 * the coordinate transformation matrix is not provided via {@link #setMatrix(Matrix)}.
 */

Body of Frist Method:
{
    if (!mMatrixInitialized) {
        // Coordinate transformation matrix is mandatory when at least one positional
        // parameter is specified.
        final boolean hasCharacterBounds = (mCharacterBoundsArrayBuilder != null && !mCharacterBoundsArrayBuilder.isEmpty());
        if (hasCharacterBounds || !Float.isNaN(mInsertionMarkerHorizontal) || !Float.isNaN(mInsertionMarkerTop) || !Float.isNaN(mInsertionMarkerBaseline) || !Float.isNaN(mInsertionMarkerBottom)) {
            throw new IllegalArgumentException("Coordinate transformation matrix is " + "required when positional parameters are specified.");
        }
    }
    return new CursorAnchorInfo(this);
}
Body of Second Method:
{
    if (!mMatrixInitialized) {
        // Coordinate transformation matrix is mandatory when at least one positional
        // parameter is specified.
        final boolean hasCharacterBounds = (mCharacterBoundsArrayBuilder != null && !mCharacterBoundsArrayBuilder.isEmpty());
        if (hasCharacterBounds || !Float.isNaN(mInsertionMarkerHorizontal) || !Float.isNaN(mInsertionMarkerTop) || !Float.isNaN(mInsertionMarkerBaseline) || !Float.isNaN(mInsertionMarkerBottom)) {
            throw new IllegalArgumentException("Coordinate transformation matrix is " + "required when positional parameters are specified.");
        }
    }
    return CursorAnchorInfo.create(this);
}
------------------------
Find a silently evolved API code:android.app.NotificationChannel.writeToProto:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    final long token = proto.start(fieldId);
    proto.write(NotificationChannelProto.ID, mId);
    proto.write(NotificationChannelProto.NAME, mName);
    proto.write(NotificationChannelProto.DESCRIPTION, mDesc);
    proto.write(NotificationChannelProto.IMPORTANCE, mImportance);
    proto.write(NotificationChannelProto.CAN_BYPASS_DND, mBypassDnd);
    proto.write(NotificationChannelProto.LOCKSCREEN_VISIBILITY, mLockscreenVisibility);
    if (mSound != null) {
        proto.write(NotificationChannelProto.SOUND, mSound.toString());
    }
    proto.write(NotificationChannelProto.USE_LIGHTS, mLights);
    proto.write(NotificationChannelProto.LIGHT_COLOR, mLightColor);
    if (mVibration != null) {
        for (long v : mVibration) {
            proto.write(NotificationChannelProto.VIBRATION, v);
        }
    }
    proto.write(NotificationChannelProto.USER_LOCKED_FIELDS, mUserLockedFields);
    proto.write(NotificationChannelProto.FG_SERVICE_SHOWN, mFgServiceShown);
    proto.write(NotificationChannelProto.IS_VIBRATION_ENABLED, mVibrationEnabled);
    proto.write(NotificationChannelProto.SHOW_BADGE, mShowBadge);
    proto.write(NotificationChannelProto.IS_DELETED, mDeleted);
    proto.write(NotificationChannelProto.GROUP, mGroup);
    if (mAudioAttributes != null) {
        mAudioAttributes.writeToProto(proto, NotificationChannelProto.AUDIO_ATTRIBUTES);
    }
    proto.write(NotificationChannelProto.IS_BLOCKABLE_SYSTEM, mBlockableSystem);
    proto.end(token);
}
Body of Second Method:
{
    final long token = proto.start(fieldId);
    proto.write(NotificationChannelProto.ID, mId);
    proto.write(NotificationChannelProto.NAME, mName);
    proto.write(NotificationChannelProto.DESCRIPTION, mDesc);
    proto.write(NotificationChannelProto.IMPORTANCE, mImportance);
    proto.write(NotificationChannelProto.CAN_BYPASS_DND, mBypassDnd);
    proto.write(NotificationChannelProto.LOCKSCREEN_VISIBILITY, mLockscreenVisibility);
    if (mSound != null) {
        proto.write(NotificationChannelProto.SOUND, mSound.toString());
    }
    proto.write(NotificationChannelProto.USE_LIGHTS, mLights);
    proto.write(NotificationChannelProto.LIGHT_COLOR, mLightColor);
    if (mVibration != null) {
        for (long v : mVibration) {
            proto.write(NotificationChannelProto.VIBRATION, v);
        }
    }
    proto.write(NotificationChannelProto.USER_LOCKED_FIELDS, mUserLockedFields);
    proto.write(NotificationChannelProto.FG_SERVICE_SHOWN, mFgServiceShown);
    proto.write(NotificationChannelProto.IS_VIBRATION_ENABLED, mVibrationEnabled);
    proto.write(NotificationChannelProto.SHOW_BADGE, mShowBadge);
    proto.write(NotificationChannelProto.IS_DELETED, mDeleted);
    proto.write(NotificationChannelProto.GROUP, mGroup);
    if (mAudioAttributes != null) {
        mAudioAttributes.writeToProto(proto, NotificationChannelProto.AUDIO_ATTRIBUTES);
    }
    proto.write(NotificationChannelProto.IS_BLOCKABLE_SYSTEM, mBlockableSystem);
    proto.write(NotificationChannelProto.ALLOW_APP_OVERLAY, mAllowBubbles);
    proto.end(token);
}
------------------------
Find a silently evolved API code:android.view.textclassifier.SelectionSessionLogger.writeEvent:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Emits a selection event to the logs.
 */

Body of Frist Method:
{
    Preconditions.checkNotNull(event);
    final LogMaker log = new LogMaker(MetricsEvent.TEXT_SELECTION_SESSION).setType(getLogType(event)).setSubtype(getLogSubType(event)).setPackageName(event.getPackageName()).addTaggedData(START_EVENT_DELTA, event.getDurationSinceSessionStart()).addTaggedData(PREV_EVENT_DELTA, event.getDurationSincePreviousEvent()).addTaggedData(INDEX, event.getEventIndex()).addTaggedData(WIDGET_TYPE, event.getWidgetType()).addTaggedData(WIDGET_VERSION, event.getWidgetVersion()).addTaggedData(MODEL_NAME, SignatureParser.getModelName(event.getResultId())).addTaggedData(ENTITY_TYPE, event.getEntityType()).addTaggedData(SMART_START, event.getSmartStart()).addTaggedData(SMART_END, event.getSmartEnd()).addTaggedData(EVENT_START, event.getStart()).addTaggedData(EVENT_END, event.getEnd());
    if (event.getSessionId() != null) {
        log.addTaggedData(SESSION_ID, event.getSessionId().flattenToString());
    }
    mMetricsLogger.write(log);
    debugLog(log);
}
Body of Second Method:
{
    Preconditions.checkNotNull(event);
    final LogMaker log = new LogMaker(MetricsEvent.TEXT_SELECTION_SESSION).setType(getLogType(event)).setSubtype(getLogSubType(event)).setPackageName(event.getPackageName()).addTaggedData(START_EVENT_DELTA, event.getDurationSinceSessionStart()).addTaggedData(PREV_EVENT_DELTA, event.getDurationSincePreviousEvent()).addTaggedData(INDEX, event.getEventIndex()).addTaggedData(WIDGET_TYPE, event.getWidgetType()).addTaggedData(WIDGET_VERSION, event.getWidgetVersion()).addTaggedData(ENTITY_TYPE, event.getEntityType()).addTaggedData(EVENT_START, event.getStart()).addTaggedData(EVENT_END, event.getEnd());
    if (isPlatformLocalTextClassifierSmartSelection(event.getResultId())) {
        // Ensure result id and smart indices are only set for events with smart selection from
        // the platform's textclassifier.
        log.addTaggedData(MODEL_NAME, SignatureParser.getModelName(event.getResultId())).addTaggedData(SMART_START, event.getSmartStart()).addTaggedData(SMART_END, event.getSmartEnd());
    }
    if (event.getSessionId() != null) {
        log.addTaggedData(SESSION_ID, event.getSessionId().flattenToString());
    }
    mMetricsLogger.write(log);
    debugLog(log);
}
------------------------
Find a silently evolved API code:android.app.usage.NetworkStatsManager.queryDetailsForUidTagState:COMMENT
Method Modifier: public      
Comment:/**
 * Query network usage statistics details for a given uid, tag, and state. Only usable for uids
 * belonging to calling user. Result is not aggregated over time. This means buckets' start and
 * end timestamps are going to be between 'startTime' and 'endTime' parameters. The uid is going
 * to be the same as the 'uid' parameter, the tag the same as the 'tag' parameter, and the state
 * the same as the 'state' parameter.
 * defaultNetwork is going to be {@link NetworkStats.Bucket#DEFAULT_NETWORK_ALL},
 * metered is going to be {@link NetworkStats.Bucket#METERED_ALL}, and
 * roaming is going to be {@link NetworkStats.Bucket#ROAMING_ALL}.
 * <p>Only includes buckets that atomically occur in the inclusive time range. Doesn't
 * interpolate across partial buckets. Since bucket length is in the order of hours, this
 * method cannot be used to measure data usage on a fine grained time scale.
 *
 * @param networkType As defined in {@link ConnectivityManager}, e.g.
 * {@link ConnectivityManager#TYPE_MOBILE}, {@link ConnectivityManager#TYPE_WIFI}
 * etc.
 * @param subscriberId If applicable, the subscriber id of the network interface.
 * @param startTime Start of period. Defined in terms of "Unix time", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param endTime End of period. Defined in terms of "Unix time", see
 * {@link java.lang.System#currentTimeMillis}.
 * @param uid UID of app
 * @param tag TAG of interest. Use {@link NetworkStats.Bucket#TAG_NONE} for no tags.
 * @param state state of interest. Use {@link NetworkStats.Bucket#STATE_ALL} to aggregate
 * traffic from all states.
 * @return Statistics object or null if an error happened during statistics collection.
 * @throws SecurityException if permissions are insufficient to read network statistics.
 */

Body of Frist Method:
{
    NetworkTemplate template;
    template = createTemplate(networkType, subscriberId);
    NetworkStats result;
    try {
        result = new NetworkStats(mContext, template, mFlags, startTime, endTime, mService);
        result.startHistoryEnumeration(uid, tag, state);
    } catch (RemoteException e) {
        Log.e(TAG, "Error while querying stats for uid=" + uid + " tag=" + tag + " state=" + state, e);
        return null;
    }
    return result;
}
Body of Second Method:
{
    NetworkTemplate template;
    template = createTemplate(networkType, subscriberId);
    return queryDetailsForUidTagState(template, startTime, endTime, uid, tag, state);
}
------------------------
Find a silently evolved API code:android.preference.DialogPreference.showDialog:COMMENT
<android.preference.DialogPreference: void showDialog(Bundle)>
protected   ->protected   deprecated  
Method Modifier: protected   deprecated  
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Shows the dialog associated with this Preference. This is normally initiated
 * automatically on clicking on the preference. Call this method if you need to
 * show the dialog on some other event.
 *
 * @param state Optional instance state to restore on the dialog
 */

Body of Frist Method:
{
    Context context = getContext();
    mWhichButtonClicked = DialogInterface.BUTTON_NEGATIVE;
    mBuilder = new AlertDialog.Builder(context).setTitle(mDialogTitle).setIcon(mDialogIcon).setPositiveButton(mPositiveButtonText, this).setNegativeButton(mNegativeButtonText, this);
    View contentView = onCreateDialogView();
    if (contentView != null) {
        onBindDialogView(contentView);
        mBuilder.setView(contentView);
    } else {
        mBuilder.setMessage(mDialogMessage);
    }
    onPrepareDialogBuilder(mBuilder);
    getPreferenceManager().registerOnActivityDestroyListener(this);
    // Create the dialog
    final Dialog dialog = mDialog = mBuilder.create();
    if (state != null) {
        dialog.onRestoreInstanceState(state);
    }
    if (needInputMethod()) {
        requestInputMethod(dialog);
    }
    dialog.setOnDismissListener(this);
    dialog.show();
}
Body of Second Method:
{
    Context context = getContext();
    mWhichButtonClicked = DialogInterface.BUTTON_NEGATIVE;
    mBuilder = new AlertDialog.Builder(context).setTitle(mDialogTitle).setIcon(mDialogIcon).setPositiveButton(mPositiveButtonText, this).setNegativeButton(mNegativeButtonText, this);
    View contentView = onCreateDialogView();
    if (contentView != null) {
        onBindDialogView(contentView);
        mBuilder.setView(contentView);
    } else {
        mBuilder.setMessage(mDialogMessage);
    }
    onPrepareDialogBuilder(mBuilder);
    getPreferenceManager().registerOnActivityDestroyListener(this);
    // Create the dialog
    final Dialog dialog = mDialog = mBuilder.create();
    if (state != null) {
        dialog.onRestoreInstanceState(state);
    }
    if (needInputMethod()) {
        requestInputMethod(dialog);
    }
    dialog.setOnShowListener(new DialogInterface.OnShowListener() {

        @Override
        public void onShow(DialogInterface dialog) {
            removeDismissCallbacks();
        }
    });
    dialog.setOnDismissListener(this);
    dialog.show();
}
------------------------
Find a silently evolved API code:android.widget.Switch.getThumbTintMode:COMMENT
Method Modifier: public      
Comment:/**
 * @return the blending mode used to apply the tint to the thumb
 * drawable
 * @attr ref android.R.styleable#Switch_thumbTintMode
 * @see #setThumbTintMode(PorterDuff.Mode)
 */

Body of Frist Method:
{
    return mThumbTintMode;
}
Body of Second Method:
{
    BlendMode mode = getThumbTintBlendMode();
    return mode != null ? BlendMode.blendModeToPorterDuffMode(mode) : null;
}
------------------------
Find a silently evolved API code:android.transition.Transition.captureValues:COMMENT
Method Modifier: default     
Comment:/**
 * Recursive method that captures values for the given view and the
 * hierarchy underneath it.
 * @param sceneRoot The root of the view hierarchy being captured
 * @param start true if this capture is happening before the scene change,
 * false otherwise
 */

Body of Frist Method:
{
    clearValues(start);
    if ((mTargetIds.size() > 0 || mTargets.size() > 0) && (mTargetNames == null || mTargetNames.isEmpty()) && (mTargetTypes == null || mTargetTypes.isEmpty())) {
        for (int i = 0; i < mTargetIds.size(); ++i) {
            int id = mTargetIds.get(i);
            View view = sceneRoot.findViewById(id);
            if (view != null) {
                TransitionValues values = new TransitionValues();
                values.view = view;
                if (start) {
                    captureStartValues(values);
                } else {
                    captureEndValues(values);
                }
                values.targetedTransitions.add(this);
                capturePropagationValues(values);
                if (start) {
                    addViewValues(mStartValues, view, values);
                } else {
                    addViewValues(mEndValues, view, values);
                }
            }
        }
        for (int i = 0; i < mTargets.size(); ++i) {
            View view = mTargets.get(i);
            TransitionValues values = new TransitionValues();
            values.view = view;
            if (start) {
                captureStartValues(values);
            } else {
                captureEndValues(values);
            }
            values.targetedTransitions.add(this);
            capturePropagationValues(values);
            if (start) {
                addViewValues(mStartValues, view, values);
            } else {
                addViewValues(mEndValues, view, values);
            }
        }
    } else {
        captureHierarchy(sceneRoot, start);
    }
    if (!start && mNameOverrides != null) {
        int numOverrides = mNameOverrides.size();
        ArrayList<View> overriddenViews = new ArrayList<View>(numOverrides);
        for (int i = 0; i < numOverrides; i++) {
            String fromName = mNameOverrides.keyAt(i);
            overriddenViews.add(mStartValues.nameValues.remove(fromName));
        }
        for (int i = 0; i < numOverrides; i++) {
            View view = overriddenViews.get(i);
            if (view != null) {
                String toName = mNameOverrides.valueAt(i);
                mStartValues.nameValues.put(toName, view);
            }
        }
    }
}
Body of Second Method:
{
    clearValues(start);
    if ((mTargetIds.size() > 0 || mTargets.size() > 0) && (mTargetNames == null || mTargetNames.isEmpty()) && (mTargetTypes == null || mTargetTypes.isEmpty())) {
        for (int i = 0; i < mTargetIds.size(); ++i) {
            int id = mTargetIds.get(i);
            View view = sceneRoot.findViewById(id);
            if (view != null) {
                TransitionValues values = new TransitionValues(view);
                if (start) {
                    captureStartValues(values);
                } else {
                    captureEndValues(values);
                }
                values.targetedTransitions.add(this);
                capturePropagationValues(values);
                if (start) {
                    addViewValues(mStartValues, view, values);
                } else {
                    addViewValues(mEndValues, view, values);
                }
            }
        }
        for (int i = 0; i < mTargets.size(); ++i) {
            View view = mTargets.get(i);
            TransitionValues values = new TransitionValues(view);
            if (start) {
                captureStartValues(values);
            } else {
                captureEndValues(values);
            }
            values.targetedTransitions.add(this);
            capturePropagationValues(values);
            if (start) {
                addViewValues(mStartValues, view, values);
            } else {
                addViewValues(mEndValues, view, values);
            }
        }
    } else {
        captureHierarchy(sceneRoot, start);
    }
    if (!start && mNameOverrides != null) {
        int numOverrides = mNameOverrides.size();
        ArrayList<View> overriddenViews = new ArrayList<View>(numOverrides);
        for (int i = 0; i < numOverrides; i++) {
            String fromName = mNameOverrides.keyAt(i);
            overriddenViews.add(mStartValues.nameValues.remove(fromName));
        }
        for (int i = 0; i < numOverrides; i++) {
            View view = overriddenViews.get(i);
            if (view != null) {
                String toName = mNameOverrides.valueAt(i);
                mStartValues.nameValues.put(toName, view);
            }
        }
    }
}
------------------------
Find a silently evolved API code:android.widget.ProgressBar.getProgressTintMode:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the blending mode used to apply the tint to the progress
 * drawable, if specified.
 *
 * @return the blending mode used to apply the tint to the progress
 * drawable
 * @attr ref android.R.styleable#ProgressBar_progressTintMode
 * @see #setProgressTintMode(PorterDuff.Mode)
 */

Body of Frist Method:
{
    return mProgressTintInfo != null ? mProgressTintInfo.mProgressTintMode : null;
}
Body of Second Method:
{
    BlendMode mode = getProgressTintBlendMode();
    return mode != null ? BlendMode.blendModeToPorterDuffMode(mode) : null;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHidHost.getIdleTime:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Send Get_Idle_Time command to the connected HID input device.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN} permission.
 *
 * @param device Remote Bluetooth Device
 * @return false on immediate error, true otherwise
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("getIdletime(" + device + ")");
    final IBluetoothHidHost service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getIdleTime(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("getIdletime(" + device + ")");
    final IBluetoothHidHost service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getIdleTime(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.app.WindowConfiguration.updateFrom:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Copies the fields from delta into this Configuration object, keeping
 * track of which ones have changed. Any undefined fields in {@code delta}
 * are ignored and not copied in to the current Configuration.
 *
 * @return a bit mask of the changed fields, as per {@link #diff}
 * @hide
 */

Body of Frist Method:
{
    int changed = 0;
    // Only allow override if bounds is not empty
    if (!delta.mBounds.isEmpty() && !delta.mBounds.equals(mBounds)) {
        changed |= WINDOW_CONFIG_BOUNDS;
        setBounds(delta.mBounds);
    }
    if (delta.mAppBounds != null && !delta.mAppBounds.equals(mAppBounds)) {
        changed |= WINDOW_CONFIG_APP_BOUNDS;
        setAppBounds(delta.mAppBounds);
    }
    if (delta.mWindowingMode != WINDOWING_MODE_UNDEFINED && mWindowingMode != delta.mWindowingMode) {
        changed |= WINDOW_CONFIG_WINDOWING_MODE;
        setWindowingMode(delta.mWindowingMode);
    }
    if (delta.mActivityType != ACTIVITY_TYPE_UNDEFINED && mActivityType != delta.mActivityType) {
        changed |= WINDOW_CONFIG_ACTIVITY_TYPE;
        setActivityType(delta.mActivityType);
    }
    return changed;
}
Body of Second Method:
{
    int changed = 0;
    // Only allow override if bounds is not empty
    if (!delta.mBounds.isEmpty() && !delta.mBounds.equals(mBounds)) {
        changed |= WINDOW_CONFIG_BOUNDS;
        setBounds(delta.mBounds);
    }
    if (delta.mAppBounds != null && !delta.mAppBounds.equals(mAppBounds)) {
        changed |= WINDOW_CONFIG_APP_BOUNDS;
        setAppBounds(delta.mAppBounds);
    }
    if (delta.mWindowingMode != WINDOWING_MODE_UNDEFINED && mWindowingMode != delta.mWindowingMode) {
        changed |= WINDOW_CONFIG_WINDOWING_MODE;
        setWindowingMode(delta.mWindowingMode);
    }
    if (delta.mActivityType != ACTIVITY_TYPE_UNDEFINED && mActivityType != delta.mActivityType) {
        changed |= WINDOW_CONFIG_ACTIVITY_TYPE;
        setActivityType(delta.mActivityType);
    }
    if (delta.mAlwaysOnTop != ALWAYS_ON_TOP_UNDEFINED && mAlwaysOnTop != delta.mAlwaysOnTop) {
        changed |= WINDOW_CONFIG_ALWAYS_ON_TOP;
        setAlwaysOnTop(delta.mAlwaysOnTop);
    }
    if (delta.mRotation != ROTATION_UNDEFINED && delta.mRotation != mRotation) {
        changed |= WINDOW_CONFIG_ROTATION;
        setRotation(delta.mRotation);
    }
    if (delta.mDisplayWindowingMode != WINDOWING_MODE_UNDEFINED && mDisplayWindowingMode != delta.mDisplayWindowingMode) {
        changed |= WINDOW_CONFIG_DISPLAY_WINDOWING_MODE;
        setDisplayWindowingMode(delta.mDisplayWindowingMode);
    }
    return changed;
}
------------------------
Find a silently evolved API code:android.accessibilityservice.AccessibilityServiceInfo.flagToString:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns the string representation of a flag. For example,
 * {@link #DEFAULT} is represented by the string DEFAULT.
 *
 * @param flag The flag.
 * @return The string representation.
 */

Body of Frist Method:
{
    switch(flag) {
        case DEFAULT:
            return "DEFAULT";
        case FLAG_INCLUDE_NOT_IMPORTANT_VIEWS:
            return "FLAG_INCLUDE_NOT_IMPORTANT_VIEWS";
        case FLAG_REQUEST_TOUCH_EXPLORATION_MODE:
            return "FLAG_REQUEST_TOUCH_EXPLORATION_MODE";
        case FLAG_REQUEST_ENHANCED_WEB_ACCESSIBILITY:
            return "FLAG_REQUEST_ENHANCED_WEB_ACCESSIBILITY";
        case FLAG_REPORT_VIEW_IDS:
            return "FLAG_REPORT_VIEW_IDS";
        case FLAG_REQUEST_FILTER_KEY_EVENTS:
            return "FLAG_REQUEST_FILTER_KEY_EVENTS";
        case FLAG_RETRIEVE_INTERACTIVE_WINDOWS:
            return "FLAG_RETRIEVE_INTERACTIVE_WINDOWS";
        case FLAG_ENABLE_ACCESSIBILITY_VOLUME:
            return "FLAG_ENABLE_ACCESSIBILITY_VOLUME";
        case FLAG_REQUEST_ACCESSIBILITY_BUTTON:
            return "FLAG_REQUEST_ACCESSIBILITY_BUTTON";
        case FLAG_REQUEST_FINGERPRINT_GESTURES:
            return "FLAG_REQUEST_FINGERPRINT_GESTURES";
        default:
            return null;
    }
}
Body of Second Method:
{
    switch(flag) {
        case DEFAULT:
            return "DEFAULT";
        case FLAG_INCLUDE_NOT_IMPORTANT_VIEWS:
            return "FLAG_INCLUDE_NOT_IMPORTANT_VIEWS";
        case FLAG_REQUEST_TOUCH_EXPLORATION_MODE:
            return "FLAG_REQUEST_TOUCH_EXPLORATION_MODE";
        case FLAG_REQUEST_ENHANCED_WEB_ACCESSIBILITY:
            return "FLAG_REQUEST_ENHANCED_WEB_ACCESSIBILITY";
        case FLAG_REPORT_VIEW_IDS:
            return "FLAG_REPORT_VIEW_IDS";
        case FLAG_REQUEST_FILTER_KEY_EVENTS:
            return "FLAG_REQUEST_FILTER_KEY_EVENTS";
        case FLAG_RETRIEVE_INTERACTIVE_WINDOWS:
            return "FLAG_RETRIEVE_INTERACTIVE_WINDOWS";
        case FLAG_ENABLE_ACCESSIBILITY_VOLUME:
            return "FLAG_ENABLE_ACCESSIBILITY_VOLUME";
        case FLAG_REQUEST_ACCESSIBILITY_BUTTON:
            return "FLAG_REQUEST_ACCESSIBILITY_BUTTON";
        case FLAG_REQUEST_FINGERPRINT_GESTURES:
            return "FLAG_REQUEST_FINGERPRINT_GESTURES";
        case FLAG_REQUEST_SHORTCUT_WARNING_DIALOG_SPOKEN_FEEDBACK:
            return "FLAG_REQUEST_SHORTCUT_WARNING_DIALOG_SPOKEN_FEEDBACK";
        default:
            return null;
    }
}
------------------------
Find a silently evolved API code:android.view.WindowInsets.hasStableInsets:COMMENT
Method Modifier: public      
Comment:/**
 * Returns true if this WindowInsets has nonzero stable insets.
 *
 * <p>The stable inset represents the area of a full-screen window that <b>may</b> be
 * partially or fully obscured by the system UI elements.  This value does not change
 * based on the visibility state of those elements; for example, if the status bar is
 * normally shown, but temporarily hidden, the stable inset will still provide the inset
 * associated with the status bar being shown.</p>
 *
 * @return true if any of the stable inset values are nonzero
 */

Body of Frist Method:
{
    return mStableInsets.top != 0 || mStableInsets.left != 0 || mStableInsets.right != 0 || mStableInsets.bottom != 0;
}
Body of Second Method:
{
    return !getStableInsets().equals(Insets.NONE);
}
------------------------
Find a silently evolved API code:android.hardware.display.DisplayViewport.toString:COMMENT
Method Modifier: public      hidden      
Comment:// For debugging purposes.

Body of Frist Method:
{
    return "DisplayViewport{valid=" + valid + ", displayId=" + displayId + ", uniqueId='" + uniqueId + "'" + ", orientation=" + orientation + ", logicalFrame=" + logicalFrame + ", physicalFrame=" + physicalFrame + ", deviceWidth=" + deviceWidth + ", deviceHeight=" + deviceHeight + "}";
}
Body of Second Method:
{
    return "DisplayViewport{type=" + typeToString(type) + ", valid=" + valid + ", displayId=" + displayId + ", uniqueId='" + uniqueId + "'" + ", physicalPort=" + physicalPort + ", orientation=" + orientation + ", logicalFrame=" + logicalFrame + ", physicalFrame=" + physicalFrame + ", deviceWidth=" + deviceWidth + ", deviceHeight=" + deviceHeight + "}";
}
------------------------
Find a silently evolved API code:android.util.IntArray.get:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns the value at the specified position in this array.
 */

Body of Frist Method:
{
    checkBounds(index);
    return mValues[index];
}
Body of Second Method:
{
    ArrayUtils.checkBounds(mSize, index);
    return mValues[index];
}
------------------------
Find a silently evolved API code:android.renderscript.ScriptIntrinsicBlur.setInput:COMMENT
Method Modifier: public      
Comment:/**
 * Set the input of the blur.
 * Must match the element type supplied during create.
 *
 * @param ain The input allocation
 */

Body of Frist Method:
{
    if (ain.getType().getY() == 0) {
        throw new RSIllegalArgumentException("Input set to a 1D Allocation");
    }
    mInput = ain;
    setVar(1, ain);
}
Body of Second Method:
{
    if (ain.getType().getY() == 0) {
        throw new RSIllegalArgumentException("Input set to a 1D Allocation");
    }
    Element e = ain.getElement();
    if ((!e.isCompatible(Element.U8_4(mRS))) && (!e.isCompatible(Element.U8(mRS)))) {
        throw new RSIllegalArgumentException("Unsupported element type.");
    }
    mInput = ain;
    setVar(1, ain);
}
------------------------
Find a silently evolved API code:android.hardware.soundtrigger.SoundTrigger.listModules:COMMENT
<android.hardware.soundtrigger.SoundTrigger: int listModules(ArrayList<ModuleProperties>)>
public      static      native      hidden      ->public      static      hidden      
Method Modifier: public      static      native      hidden      
Method Modifier: Yes         Yes         Yes         Yes         
Method Updated:  Yes         Yes         No          Yes         
Comment:/**
 * Returns a list of descriptors for all hardware modules loaded.
 * @param modules A ModuleProperties array where the list will be returned.
 * @return - {@link #STATUS_OK} in case of success
 * - {@link #STATUS_ERROR} in case of unspecified error
 * - {@link #STATUS_PERMISSION_DENIED} if the caller does not have system permission
 * - {@link #STATUS_NO_INIT} if the native service cannot be reached
 * - {@link #STATUS_BAD_VALUE} if modules is null
 * - {@link #STATUS_DEAD_OBJECT} if the binder transaction to the native service fails
 *
 * @hide
 */

Body of Frist Method:

Body of Second Method:
{
    return listModules(getCurrentOpPackageName(), modules);
}
------------------------
Find a silently evolved API code:android.os.SELinux.restoreconRecursive:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Recursively restores all files under the given path to their default
 * SELinux security context. If the system is not compiled with SELinux,
 * then {@code true} is automatically returned. If SELinux is compiled in,
 * but disabled, then {@code true} is returned.
 *
 * @return a boolean indicating whether the relabeling succeeded.
 */

Body of Frist Method:
{
    try {
        return native_restorecon(file.getCanonicalPath(), SELINUX_ANDROID_RESTORECON_RECURSE);
    } catch (IOException e) {
        Slog.e(TAG, "Error getting canonical path. Restorecon failed for " + file.getPath(), e);
        return false;
    }
}
Body of Second Method:
{
    try {
        return native_restorecon(file.getCanonicalPath(), SELINUX_ANDROID_RESTORECON_RECURSE | SELINUX_ANDROID_RESTORECON_SKIP_SEHASH);
    } catch (IOException e) {
        Slog.e(TAG, "Error getting canonical path. Restorecon failed for " + file.getPath(), e);
        return false;
    }
}
------------------------
Find a silently evolved API code:android.telephony.euicc.EuiccManager.getDefaultDownloadableSubscriptionList:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Gets metadata for subscription which are available for download on this device.
 *
 * <p>Subscriptions returned here may be passed to {@link #downloadSubscription}. They may have
 * been pre-assigned to this particular device, for example. The callback will be triggered with
 * an Intent with {@link #EXTRA_EMBEDDED_SUBSCRIPTION_DOWNLOADABLE_SUBSCRIPTIONS} set to the
 * list of available subscriptions upon success.
 *
 * <p>Requires that the calling app has the
 * {@link android.Manifest.permission#WRITE_EMBEDDED_SUBSCRIPTIONS} permission. This is for
 * internal system use only.
 *
 * @param callbackIntent a PendingIntent to launch when the operation completes.
 * @hide
 */

Body of Frist Method:
{
    if (!isEnabled()) {
        sendUnavailableError(callbackIntent);
        return;
    }
    try {
        getIEuiccController().getDefaultDownloadableSubscriptionList(mContext.getOpPackageName(), callbackIntent);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    if (!isEnabled()) {
        sendUnavailableError(callbackIntent);
        return;
    }
    try {
        getIEuiccController().getDefaultDownloadableSubscriptionList(mCardId, mContext.getOpPackageName(), callbackIntent);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.view.GestureDetector.onTouchEvent:COMMENT
Method Modifier: public      
Comment:/**
 * Analyzes the given motion event and if applicable triggers the
 * appropriate callbacks on the {@link OnGestureListener} supplied.
 *
 * @param ev The current motion event.
 * @return true if the {@link OnGestureListener} consumed the event,
 * else false.
 */

Body of Frist Method:
{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(ev, 0);
    }
    final int action = ev.getAction();
    if (mVelocityTracker == null) {
        mVelocityTracker = VelocityTracker.obtain();
    }
    mVelocityTracker.addMovement(ev);
    final boolean pointerUp = (action & MotionEvent.ACTION_MASK) == MotionEvent.ACTION_POINTER_UP;
    final int skipIndex = pointerUp ? ev.getActionIndex() : -1;
    final boolean isGeneratedGesture = (ev.getFlags() & MotionEvent.FLAG_IS_GENERATED_GESTURE) != 0;
    // Determine focal point
    float sumX = 0, sumY = 0;
    final int count = ev.getPointerCount();
    for (int i = 0; i < count; i++) {
        if (skipIndex == i)
            continue;
        sumX += ev.getX(i);
        sumY += ev.getY(i);
    }
    final int div = pointerUp ? count - 1 : count;
    final float focusX = sumX / div;
    final float focusY = sumY / div;
    boolean handled = false;
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_POINTER_DOWN:
            mDownFocusX = mLastFocusX = focusX;
            mDownFocusY = mLastFocusY = focusY;
            // Cancel long press and taps
            cancelTaps();
            break;
        case MotionEvent.ACTION_POINTER_UP:
            mDownFocusX = mLastFocusX = focusX;
            mDownFocusY = mLastFocusY = focusY;
            // Check the dot product of current velocities.
            // If the pointer that left was opposing another velocity vector, clear.
            mVelocityTracker.computeCurrentVelocity(1000, mMaximumFlingVelocity);
            final int upIndex = ev.getActionIndex();
            final int id1 = ev.getPointerId(upIndex);
            final float x1 = mVelocityTracker.getXVelocity(id1);
            final float y1 = mVelocityTracker.getYVelocity(id1);
            for (int i = 0; i < count; i++) {
                if (i == upIndex)
                    continue;
                final int id2 = ev.getPointerId(i);
                final float x = x1 * mVelocityTracker.getXVelocity(id2);
                final float y = y1 * mVelocityTracker.getYVelocity(id2);
                final float dot = x + y;
                if (dot < 0) {
                    mVelocityTracker.clear();
                    break;
                }
            }
            break;
        case MotionEvent.ACTION_DOWN:
            if (mDoubleTapListener != null) {
                boolean hadTapMessage = mHandler.hasMessages(TAP);
                if (hadTapMessage)
                    mHandler.removeMessages(TAP);
                if ((mCurrentDownEvent != null) && (mPreviousUpEvent != null) && hadTapMessage && isConsideredDoubleTap(mCurrentDownEvent, mPreviousUpEvent, ev)) {
                    // This is a second tap
                    mIsDoubleTapping = true;
                    // Give a callback with the first tap of the double-tap
                    handled |= mDoubleTapListener.onDoubleTap(mCurrentDownEvent);
                    // Give a callback with down event of the double-tap
                    handled |= mDoubleTapListener.onDoubleTapEvent(ev);
                } else {
                    // This is a first tap
                    mHandler.sendEmptyMessageDelayed(TAP, DOUBLE_TAP_TIMEOUT);
                }
            }
            mDownFocusX = mLastFocusX = focusX;
            mDownFocusY = mLastFocusY = focusY;
            if (mCurrentDownEvent != null) {
                mCurrentDownEvent.recycle();
            }
            mCurrentDownEvent = MotionEvent.obtain(ev);
            mAlwaysInTapRegion = true;
            mAlwaysInBiggerTapRegion = true;
            mStillDown = true;
            mInLongPress = false;
            mDeferConfirmSingleTap = false;
            if (mIsLongpressEnabled) {
                mHandler.removeMessages(LONG_PRESS);
                mHandler.sendEmptyMessageAtTime(LONG_PRESS, mCurrentDownEvent.getDownTime() + LONGPRESS_TIMEOUT);
            }
            mHandler.sendEmptyMessageAtTime(SHOW_PRESS, mCurrentDownEvent.getDownTime() + TAP_TIMEOUT);
            handled |= mListener.onDown(ev);
            break;
        case MotionEvent.ACTION_MOVE:
            if (mInLongPress || mInContextClick) {
                break;
            }
            final float scrollX = mLastFocusX - focusX;
            final float scrollY = mLastFocusY - focusY;
            if (mIsDoubleTapping) {
                // Give the move events of the double-tap
                handled |= mDoubleTapListener.onDoubleTapEvent(ev);
            } else if (mAlwaysInTapRegion) {
                final int deltaX = (int) (focusX - mDownFocusX);
                final int deltaY = (int) (focusY - mDownFocusY);
                int distance = (deltaX * deltaX) + (deltaY * deltaY);
                int slopSquare = isGeneratedGesture ? 0 : mTouchSlopSquare;
                if (distance > slopSquare) {
                    handled = mListener.onScroll(mCurrentDownEvent, ev, scrollX, scrollY);
                    mLastFocusX = focusX;
                    mLastFocusY = focusY;
                    mAlwaysInTapRegion = false;
                    mHandler.removeMessages(TAP);
                    mHandler.removeMessages(SHOW_PRESS);
                    mHandler.removeMessages(LONG_PRESS);
                }
                int doubleTapSlopSquare = isGeneratedGesture ? 0 : mDoubleTapTouchSlopSquare;
                if (distance > doubleTapSlopSquare) {
                    mAlwaysInBiggerTapRegion = false;
                }
            } else if ((Math.abs(scrollX) >= 1) || (Math.abs(scrollY) >= 1)) {
                handled = mListener.onScroll(mCurrentDownEvent, ev, scrollX, scrollY);
                mLastFocusX = focusX;
                mLastFocusY = focusY;
            }
            break;
        case MotionEvent.ACTION_UP:
            mStillDown = false;
            MotionEvent currentUpEvent = MotionEvent.obtain(ev);
            if (mIsDoubleTapping) {
                // Finally, give the up event of the double-tap
                handled |= mDoubleTapListener.onDoubleTapEvent(ev);
            } else if (mInLongPress) {
                mHandler.removeMessages(TAP);
                mInLongPress = false;
            } else if (mAlwaysInTapRegion && !mIgnoreNextUpEvent) {
                handled = mListener.onSingleTapUp(ev);
                if (mDeferConfirmSingleTap && mDoubleTapListener != null) {
                    mDoubleTapListener.onSingleTapConfirmed(ev);
                }
            } else if (!mIgnoreNextUpEvent) {
                // A fling must travel the minimum tap distance
                final VelocityTracker velocityTracker = mVelocityTracker;
                final int pointerId = ev.getPointerId(0);
                velocityTracker.computeCurrentVelocity(1000, mMaximumFlingVelocity);
                final float velocityY = velocityTracker.getYVelocity(pointerId);
                final float velocityX = velocityTracker.getXVelocity(pointerId);
                if ((Math.abs(velocityY) > mMinimumFlingVelocity) || (Math.abs(velocityX) > mMinimumFlingVelocity)) {
                    handled = mListener.onFling(mCurrentDownEvent, ev, velocityX, velocityY);
                }
            }
            if (mPreviousUpEvent != null) {
                mPreviousUpEvent.recycle();
            }
            // Hold the event we obtained above - listeners may have changed the original.
            mPreviousUpEvent = currentUpEvent;
            if (mVelocityTracker != null) {
                // This may have been cleared when we called out to the
                // application above.
                mVelocityTracker.recycle();
                mVelocityTracker = null;
            }
            mIsDoubleTapping = false;
            mDeferConfirmSingleTap = false;
            mIgnoreNextUpEvent = false;
            mHandler.removeMessages(SHOW_PRESS);
            mHandler.removeMessages(LONG_PRESS);
            break;
        case MotionEvent.ACTION_CANCEL:
            cancel();
            break;
    }
    if (!handled && mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(ev, 0);
    }
    return handled;
}
Body of Second Method:
{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(ev, 0);
    }
    final int action = ev.getAction();
    if (mCurrentMotionEvent != null) {
        mCurrentMotionEvent.recycle();
    }
    mCurrentMotionEvent = MotionEvent.obtain(ev);
    if (mVelocityTracker == null) {
        mVelocityTracker = VelocityTracker.obtain();
    }
    mVelocityTracker.addMovement(ev);
    final boolean pointerUp = (action & MotionEvent.ACTION_MASK) == MotionEvent.ACTION_POINTER_UP;
    final int skipIndex = pointerUp ? ev.getActionIndex() : -1;
    final boolean isGeneratedGesture = (ev.getFlags() & MotionEvent.FLAG_IS_GENERATED_GESTURE) != 0;
    // Determine focal point
    float sumX = 0, sumY = 0;
    final int count = ev.getPointerCount();
    for (int i = 0; i < count; i++) {
        if (skipIndex == i)
            continue;
        sumX += ev.getX(i);
        sumY += ev.getY(i);
    }
    final int div = pointerUp ? count - 1 : count;
    final float focusX = sumX / div;
    final float focusY = sumY / div;
    boolean handled = false;
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_POINTER_DOWN:
            mDownFocusX = mLastFocusX = focusX;
            mDownFocusY = mLastFocusY = focusY;
            // Cancel long press and taps
            cancelTaps();
            break;
        case MotionEvent.ACTION_POINTER_UP:
            mDownFocusX = mLastFocusX = focusX;
            mDownFocusY = mLastFocusY = focusY;
            // Check the dot product of current velocities.
            // If the pointer that left was opposing another velocity vector, clear.
            mVelocityTracker.computeCurrentVelocity(1000, mMaximumFlingVelocity);
            final int upIndex = ev.getActionIndex();
            final int id1 = ev.getPointerId(upIndex);
            final float x1 = mVelocityTracker.getXVelocity(id1);
            final float y1 = mVelocityTracker.getYVelocity(id1);
            for (int i = 0; i < count; i++) {
                if (i == upIndex)
                    continue;
                final int id2 = ev.getPointerId(i);
                final float x = x1 * mVelocityTracker.getXVelocity(id2);
                final float y = y1 * mVelocityTracker.getYVelocity(id2);
                final float dot = x + y;
                if (dot < 0) {
                    mVelocityTracker.clear();
                    break;
                }
            }
            break;
        case MotionEvent.ACTION_DOWN:
            if (mDoubleTapListener != null) {
                boolean hadTapMessage = mHandler.hasMessages(TAP);
                if (hadTapMessage)
                    mHandler.removeMessages(TAP);
                if ((mCurrentDownEvent != null) && (mPreviousUpEvent != null) && hadTapMessage && isConsideredDoubleTap(mCurrentDownEvent, mPreviousUpEvent, ev)) {
                    // This is a second tap
                    mIsDoubleTapping = true;
                    recordGestureClassification(TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__DOUBLE_TAP);
                    // Give a callback with the first tap of the double-tap
                    handled |= mDoubleTapListener.onDoubleTap(mCurrentDownEvent);
                    // Give a callback with down event of the double-tap
                    handled |= mDoubleTapListener.onDoubleTapEvent(ev);
                } else {
                    // This is a first tap
                    mHandler.sendEmptyMessageDelayed(TAP, DOUBLE_TAP_TIMEOUT);
                }
            }
            mDownFocusX = mLastFocusX = focusX;
            mDownFocusY = mLastFocusY = focusY;
            if (mCurrentDownEvent != null) {
                mCurrentDownEvent.recycle();
            }
            mCurrentDownEvent = MotionEvent.obtain(ev);
            mAlwaysInTapRegion = true;
            mAlwaysInBiggerTapRegion = true;
            mStillDown = true;
            mInLongPress = false;
            mDeferConfirmSingleTap = false;
            mHasRecordedClassification = false;
            if (mIsLongpressEnabled) {
                mHandler.removeMessages(LONG_PRESS);
                mHandler.sendMessageAtTime(mHandler.obtainMessage(LONG_PRESS, TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__LONG_PRESS, 0), mCurrentDownEvent.getDownTime() + ViewConfiguration.getLongPressTimeout());
            }
            mHandler.sendEmptyMessageAtTime(SHOW_PRESS, mCurrentDownEvent.getDownTime() + TAP_TIMEOUT);
            handled |= mListener.onDown(ev);
            break;
        case MotionEvent.ACTION_MOVE:
            if (mInLongPress || mInContextClick) {
                break;
            }
            final int motionClassification = ev.getClassification();
            final boolean hasPendingLongPress = mHandler.hasMessages(LONG_PRESS);
            final float scrollX = mLastFocusX - focusX;
            final float scrollY = mLastFocusY - focusY;
            if (mIsDoubleTapping) {
                // Give the move events of the double-tap
                recordGestureClassification(TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__DOUBLE_TAP);
                handled |= mDoubleTapListener.onDoubleTapEvent(ev);
            } else if (mAlwaysInTapRegion) {
                final int deltaX = (int) (focusX - mDownFocusX);
                final int deltaY = (int) (focusY - mDownFocusY);
                int distance = (deltaX * deltaX) + (deltaY * deltaY);
                int slopSquare = isGeneratedGesture ? 0 : mTouchSlopSquare;
                final boolean ambiguousGesture = motionClassification == MotionEvent.CLASSIFICATION_AMBIGUOUS_GESTURE;
                final boolean shouldInhibitDefaultAction = hasPendingLongPress && ambiguousGesture;
                if (shouldInhibitDefaultAction) {
                    // Inhibit default long press
                    final float multiplier = ViewConfiguration.getAmbiguousGestureMultiplier();
                    if (distance > slopSquare) {
                        // The default action here is to remove long press. But if the touch
                        // slop below gets increased, and we never exceed the modified touch
                        // slop while still receiving AMBIGUOUS_GESTURE, we risk that *nothing*
                        // will happen in response to user input. To prevent this,
                        // reschedule long press with a modified timeout.
                        mHandler.removeMessages(LONG_PRESS);
                        final long longPressTimeout = ViewConfiguration.getLongPressTimeout();
                        mHandler.sendMessageAtTime(mHandler.obtainMessage(LONG_PRESS, TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__LONG_PRESS, 0), ev.getDownTime() + (long) (longPressTimeout * multiplier));
                    }
                    // Inhibit default scroll. If a gesture is ambiguous, we prevent scroll
                    // until the gesture is resolved.
                    // However, for safety, simply increase the touch slop in case the
                    // classification is erroneous. Since the value is squared, multiply twice.
                    slopSquare *= multiplier * multiplier;
                }
                if (distance > slopSquare) {
                    recordGestureClassification(TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__SCROLL);
                    handled = mListener.onScroll(mCurrentDownEvent, ev, scrollX, scrollY);
                    mLastFocusX = focusX;
                    mLastFocusY = focusY;
                    mAlwaysInTapRegion = false;
                    mHandler.removeMessages(TAP);
                    mHandler.removeMessages(SHOW_PRESS);
                    mHandler.removeMessages(LONG_PRESS);
                }
                int doubleTapSlopSquare = isGeneratedGesture ? 0 : mDoubleTapTouchSlopSquare;
                if (distance > doubleTapSlopSquare) {
                    mAlwaysInBiggerTapRegion = false;
                }
            } else if ((Math.abs(scrollX) >= 1) || (Math.abs(scrollY) >= 1)) {
                recordGestureClassification(TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__SCROLL);
                handled = mListener.onScroll(mCurrentDownEvent, ev, scrollX, scrollY);
                mLastFocusX = focusX;
                mLastFocusY = focusY;
            }
            final boolean deepPress = motionClassification == MotionEvent.CLASSIFICATION_DEEP_PRESS;
            if (deepPress && hasPendingLongPress) {
                mHandler.removeMessages(LONG_PRESS);
                mHandler.sendMessage(mHandler.obtainMessage(LONG_PRESS, TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__DEEP_PRESS, 0));
            }
            break;
        case MotionEvent.ACTION_UP:
            mStillDown = false;
            MotionEvent currentUpEvent = MotionEvent.obtain(ev);
            if (mIsDoubleTapping) {
                // Finally, give the up event of the double-tap
                recordGestureClassification(TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__DOUBLE_TAP);
                handled |= mDoubleTapListener.onDoubleTapEvent(ev);
            } else if (mInLongPress) {
                mHandler.removeMessages(TAP);
                mInLongPress = false;
            } else if (mAlwaysInTapRegion && !mIgnoreNextUpEvent) {
                recordGestureClassification(TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__SINGLE_TAP);
                handled = mListener.onSingleTapUp(ev);
                if (mDeferConfirmSingleTap && mDoubleTapListener != null) {
                    mDoubleTapListener.onSingleTapConfirmed(ev);
                }
            } else if (!mIgnoreNextUpEvent) {
                // A fling must travel the minimum tap distance
                final VelocityTracker velocityTracker = mVelocityTracker;
                final int pointerId = ev.getPointerId(0);
                velocityTracker.computeCurrentVelocity(1000, mMaximumFlingVelocity);
                final float velocityY = velocityTracker.getYVelocity(pointerId);
                final float velocityX = velocityTracker.getXVelocity(pointerId);
                if ((Math.abs(velocityY) > mMinimumFlingVelocity) || (Math.abs(velocityX) > mMinimumFlingVelocity)) {
                    handled = mListener.onFling(mCurrentDownEvent, ev, velocityX, velocityY);
                }
            }
            if (mPreviousUpEvent != null) {
                mPreviousUpEvent.recycle();
            }
            // Hold the event we obtained above - listeners may have changed the original.
            mPreviousUpEvent = currentUpEvent;
            if (mVelocityTracker != null) {
                // This may have been cleared when we called out to the
                // application above.
                mVelocityTracker.recycle();
                mVelocityTracker = null;
            }
            mIsDoubleTapping = false;
            mDeferConfirmSingleTap = false;
            mIgnoreNextUpEvent = false;
            mHandler.removeMessages(SHOW_PRESS);
            mHandler.removeMessages(LONG_PRESS);
            break;
        case MotionEvent.ACTION_CANCEL:
            cancel();
            break;
    }
    if (!handled && mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(ev, 0);
    }
    return handled;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothMap.getPriority:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the priority of the profile.
 *
 * <p> The priority can be any of:
 * {@link #PRIORITY_AUTO_CONNECT}, {@link #PRIORITY_OFF},
 * {@link #PRIORITY_ON}, {@link #PRIORITY_UNDEFINED}
 *
 * @param device Bluetooth device
 * @return priority of the device
 */

Body of Frist Method:
{
    if (VDBG)
        log("getPriority(" + device + ")");
    final IBluetoothMap service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getPriority(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return PRIORITY_OFF;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return PRIORITY_OFF;
}
Body of Second Method:
{
    if (VDBG)
        log("getPriority(" + device + ")");
    final IBluetoothMap service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getPriority(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return PRIORITY_OFF;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return PRIORITY_OFF;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.getAudioState:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns current audio state of Audio Gateway.
 *
 * Note: This is an internal function and shouldn't be exposed
 */

Body of Frist Method:
{
    if (VDBG)
        log("getAudioState");
    final IBluetoothHeadsetClient service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.getAudioState(device);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return BluetoothHeadsetClient.STATE_AUDIO_DISCONNECTED;
}
Body of Second Method:
{
    if (VDBG)
        log("getAudioState");
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled()) {
        try {
            return service.getAudioState(device);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return BluetoothHeadsetClient.STATE_AUDIO_DISCONNECTED;
}
------------------------
Find a silently evolved API code:android.net.wifi.aware.WifiAwareNetworkSpecifier.toString:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    StringBuilder sb = new StringBuilder("WifiAwareNetworkSpecifier [");
    sb.append("type=").append(type).append(", role=").append(role).append(", clientId=").append(clientId).append(", sessionId=").append(sessionId).append(", peerId=").append(peerId).append(", peerMac=").append((peerMac == null) ? "<null>" : "<non-null>").append(", pmk=").append((pmk == null) ? "<null>" : "<non-null>").append(", passphrase=").append((passphrase == null) ? "<null>" : "<non-null>").append(", requestorUid=").append(requestorUid).append("]");
    return sb.toString();
}
Body of Second Method:
{
    StringBuilder sb = new StringBuilder("WifiAwareNetworkSpecifier [");
    sb.append("type=").append(type).append(", role=").append(role).append(", clientId=").append(clientId).append(", sessionId=").append(sessionId).append(", peerId=").append(peerId).append(", peerMac=").append((peerMac == null) ? "<null>" : "<non-null>").append(", pmk=").append((pmk == null) ? "<null>" : "<non-null>").append(", passphrase=").append((passphrase == null) ? "<null>" : "<non-null>").append(", port=").append(port).append(", transportProtocol=").append(transportProtocol).append(", requestorUid=").append(requestorUid).append("]");
    return sb.toString();
}
------------------------
Find a silently evolved API code:android.view.textservice.TextServicesManager.getCurrentSpellChecker:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    try {
        // Passing null as a locale for ICS
        return mService.getCurrentSpellChecker(null);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    try {
        // Passing null as a locale for ICS
        return mService.getCurrentSpellChecker(mUserId, null);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.database.sqlite.SQLiteDebug.dump:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Dumps detailed information about all databases used by the process.
 * @param printer The printer for dumping database state.
 * @param args Command-line arguments supplied to dumpsys dbinfo
 */

Body of Frist Method:
{
    boolean verbose = false;
    for (String arg : args) {
        if (arg.equals("-v")) {
            verbose = true;
        }
    }
    SQLiteDatabase.dumpAll(printer, verbose);
}
Body of Second Method:
{
    dump(printer, args, false);
}
------------------------
Find a silently evolved API code:android.media.AudioFormat.isEncodingLinearPcm:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    switch(audioFormat) {
        case ENCODING_PCM_8BIT:
        case ENCODING_PCM_16BIT:
        case ENCODING_PCM_FLOAT:
        case ENCODING_DEFAULT:
            return true;
        case ENCODING_AC3:
        case ENCODING_E_AC3:
        case ENCODING_E_AC3_JOC:
        case ENCODING_DTS:
        case ENCODING_DTS_HD:
        case ENCODING_MP3:
        case ENCODING_AAC_LC:
        case ENCODING_AAC_HE_V1:
        case ENCODING_AAC_HE_V2:
        // wrapped in PCM but compressed
        case ENCODING_IEC61937:
        case ENCODING_AAC_ELD:
        case ENCODING_AAC_XHE:
        case ENCODING_AC4:
            return false;
        case ENCODING_INVALID:
        default:
            throw new IllegalArgumentException("Bad audio format " + audioFormat);
    }
}
Body of Second Method:
{
    switch(audioFormat) {
        case ENCODING_PCM_16BIT:
        case ENCODING_PCM_8BIT:
        case ENCODING_PCM_FLOAT:
        case ENCODING_DEFAULT:
            return true;
        case ENCODING_AC3:
        case ENCODING_E_AC3:
        case ENCODING_DTS:
        case ENCODING_DTS_HD:
        case ENCODING_MP3:
        case ENCODING_AAC_LC:
        case ENCODING_AAC_HE_V1:
        case ENCODING_AAC_HE_V2:
        // wrapped in PCM but compressed
        case ENCODING_IEC61937:
        case ENCODING_DOLBY_TRUEHD:
        case ENCODING_AAC_ELD:
        case ENCODING_AAC_XHE:
        case ENCODING_AC4:
        case ENCODING_E_AC3_JOC:
        case ENCODING_DOLBY_MAT:
            return false;
        case ENCODING_INVALID:
        default:
            throw new IllegalArgumentException("Bad audio format " + audioFormat);
    }
}
------------------------
Find a silently evolved API code:android.view.textclassifier.TextClassificationSession.SelectionEventHelper.sanitizeEvent:COMMENT
Method Modifier: default     
Comment:/**
 * Updates the necessary fields in the event for the current session.
 *
 * @return true if the event should be reported. false if the event should be ignored
 */

Body of Frist Method:
{
    updateInvocationMethod(event);
    modifyAutoSelectionEventType(event);
    if (event.getEventType() != SelectionEvent.EVENT_SELECTION_STARTED && mStartEvent == null) {
        if (DEBUG_LOG_ENABLED) {
            Log.d(LOG_TAG, "Selection session not yet started. Ignoring event");
        }
        return false;
    }
    final long now = System.currentTimeMillis();
    switch(event.getEventType()) {
        case SelectionEvent.EVENT_SELECTION_STARTED:
            Preconditions.checkArgument(event.getAbsoluteEnd() == event.getAbsoluteStart() + 1);
            event.setSessionId(mSessionId);
            mStartEvent = event;
            break;
        // fall through
        case SelectionEvent.EVENT_SMART_SELECTION_SINGLE:
        case SelectionEvent.EVENT_SMART_SELECTION_MULTI:
            mSmartEvent = event;
            break;
        // fall through
        case SelectionEvent.EVENT_SELECTION_MODIFIED:
        case SelectionEvent.EVENT_AUTO_SELECTION:
            if (mPrevEvent != null && mPrevEvent.getAbsoluteStart() == event.getAbsoluteStart() && mPrevEvent.getAbsoluteEnd() == event.getAbsoluteEnd()) {
                // Selection did not change. Ignore event.
                return false;
            }
            break;
        default:
    }
    event.setEventTime(now);
    if (mStartEvent != null) {
        event.setSessionId(mStartEvent.getSessionId()).setDurationSinceSessionStart(now - mStartEvent.getEventTime()).setStart(event.getAbsoluteStart() - mStartEvent.getAbsoluteStart()).setEnd(event.getAbsoluteEnd() - mStartEvent.getAbsoluteStart());
    }
    if (mSmartEvent != null) {
        event.setResultId(mSmartEvent.getResultId()).setSmartStart(mSmartEvent.getAbsoluteStart() - mStartEvent.getAbsoluteStart()).setSmartEnd(mSmartEvent.getAbsoluteEnd() - mStartEvent.getAbsoluteStart());
    }
    if (mPrevEvent != null) {
        event.setDurationSincePreviousEvent(now - mPrevEvent.getEventTime()).setEventIndex(mPrevEvent.getEventIndex() + 1);
    }
    mPrevEvent = event;
    return true;
}
Body of Second Method:
{
    updateInvocationMethod(event);
    modifyAutoSelectionEventType(event);
    if (event.getEventType() != SelectionEvent.EVENT_SELECTION_STARTED && mStartEvent == null) {
        Log.d(LOG_TAG, "Selection session not yet started. Ignoring event");
        return false;
    }
    final long now = System.currentTimeMillis();
    switch(event.getEventType()) {
        case SelectionEvent.EVENT_SELECTION_STARTED:
            Preconditions.checkArgument(event.getAbsoluteEnd() == event.getAbsoluteStart() + 1);
            event.setSessionId(mSessionId);
            mStartEvent = event;
            break;
        // fall through
        case SelectionEvent.EVENT_SMART_SELECTION_SINGLE:
        // fall through
        case SelectionEvent.EVENT_SMART_SELECTION_MULTI:
        case SelectionEvent.EVENT_AUTO_SELECTION:
            mSmartEvent = event;
            break;
        case SelectionEvent.EVENT_SELECTION_MODIFIED:
            if (mPrevEvent != null && mPrevEvent.getAbsoluteStart() == event.getAbsoluteStart() && mPrevEvent.getAbsoluteEnd() == event.getAbsoluteEnd()) {
                // Selection did not change. Ignore event.
                return false;
            }
            break;
        default:
    }
    event.setEventTime(now);
    if (mStartEvent != null) {
        event.setSessionId(mStartEvent.getSessionId()).setDurationSinceSessionStart(now - mStartEvent.getEventTime()).setStart(event.getAbsoluteStart() - mStartEvent.getAbsoluteStart()).setEnd(event.getAbsoluteEnd() - mStartEvent.getAbsoluteStart());
    }
    if (mSmartEvent != null) {
        event.setResultId(mSmartEvent.getResultId()).setSmartStart(mSmartEvent.getAbsoluteStart() - mStartEvent.getAbsoluteStart()).setSmartEnd(mSmartEvent.getAbsoluteEnd() - mStartEvent.getAbsoluteStart());
    }
    if (mPrevEvent != null) {
        event.setDurationSincePreviousEvent(now - mPrevEvent.getEventTime()).setEventIndex(mPrevEvent.getEventIndex() + 1);
    }
    mPrevEvent = event;
    return true;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.stopVoiceRecognition:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Stops voice recognition.
 *
 * @param device remote device
 * @return <code>true</code> if command has been issued successfully; <code>false</code>
 * otherwise; upon completion HFP sends {@link #ACTION_AG_EVENT} intent.
 *
 * <p>Feature required for successful execution is being reported by: {@link
 * #EXTRA_AG_FEATURE_VOICE_RECOGNITION}. This method invocation will fail silently when feature
 * is not supported.</p>
 */

Body of Frist Method:
{
    if (DBG)
        log("stopVoiceRecognition()");
    final IBluetoothHeadsetClient service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.stopVoiceRecognition(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("stopVoiceRecognition()");
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.stopVoiceRecognition(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.view.ThreadedRenderer.setup:COMMENT
Method Modifier: default     hidden      
Comment:/**
 * Sets up the renderer for drawing.
 *
 * @param width The width of the drawing surface.
 * @param height The height of the drawing surface.
 * @param attachInfo Information about the window.
 * @param surfaceInsets The drawing surface insets to apply
 */

Body of Frist Method:
{
    mWidth = width;
    mHeight = height;
    if (surfaceInsets != null && (surfaceInsets.left != 0 || surfaceInsets.right != 0 || surfaceInsets.top != 0 || surfaceInsets.bottom != 0)) {
        mHasInsets = true;
        mInsetLeft = surfaceInsets.left;
        mInsetTop = surfaceInsets.top;
        mSurfaceWidth = width + mInsetLeft + surfaceInsets.right;
        mSurfaceHeight = height + mInsetTop + surfaceInsets.bottom;
        // If the surface has insets, it can't be opaque.
        setOpaque(false);
    } else {
        mHasInsets = false;
        mInsetLeft = 0;
        mInsetTop = 0;
        mSurfaceWidth = width;
        mSurfaceHeight = height;
    }
    mRootNode.setLeftTopRightBottom(-mInsetLeft, -mInsetTop, mSurfaceWidth, mSurfaceHeight);
    nSetup(mNativeProxy, mLightRadius, mAmbientShadowAlpha, mSpotShadowAlpha);
    setLightCenter(attachInfo);
}
Body of Second Method:
{
    mWidth = width;
    mHeight = height;
    if (surfaceInsets != null && (surfaceInsets.left != 0 || surfaceInsets.right != 0 || surfaceInsets.top != 0 || surfaceInsets.bottom != 0)) {
        mHasInsets = true;
        mInsetLeft = surfaceInsets.left;
        mInsetTop = surfaceInsets.top;
        mSurfaceWidth = width + mInsetLeft + surfaceInsets.right;
        mSurfaceHeight = height + mInsetTop + surfaceInsets.bottom;
        // If the surface has insets, it can't be opaque.
        setOpaque(false);
    } else {
        mHasInsets = false;
        mInsetLeft = 0;
        mInsetTop = 0;
        mSurfaceWidth = width;
        mSurfaceHeight = height;
    }
    mRootNode.setLeftTopRightBottom(-mInsetLeft, -mInsetTop, mSurfaceWidth, mSurfaceHeight);
    setLightCenter(attachInfo);
}
------------------------
Find a silently evolved API code:android.view.textservice.TextServicesManager.newSpellCheckerSession:COMMENT
Method Modifier: public      
Comment:/**
 * Get a spell checker session for the specified spell checker
 * @param locale the locale for the spell checker. If {@code locale} is null and
 * referToSpellCheckerLanguageSettings is true, the locale specified in Settings will be
 * returned. If {@code locale} is not null and referToSpellCheckerLanguageSettings is true,
 * the locale specified in Settings will be returned only when it is same as {@code locale}.
 * Exceptionally, when referToSpellCheckerLanguageSettings is true and {@code locale} is
 * only language (e.g. "en"), the specified locale in Settings (e.g. "en_US") will be
 * selected.
 * @param listener a spell checker session lister for getting results from a spell checker.
 * @param referToSpellCheckerLanguageSettings if true, the session for one of enabled
 * languages in settings will be returned.
 * @return the spell checker session of the spell checker
 */

Body of Frist Method:
{
    if (listener == null) {
        throw new NullPointerException();
    }
    if (!referToSpellCheckerLanguageSettings && locale == null) {
        throw new IllegalArgumentException("Locale should not be null if you don't refer" + " settings.");
    }
    if (referToSpellCheckerLanguageSettings && !isSpellCheckerEnabled()) {
        return null;
    }
    final SpellCheckerInfo sci;
    try {
        sci = mService.getCurrentSpellChecker(null);
    } catch (RemoteException e) {
        return null;
    }
    if (sci == null) {
        return null;
    }
    SpellCheckerSubtype subtypeInUse = null;
    if (referToSpellCheckerLanguageSettings) {
        subtypeInUse = getCurrentSpellCheckerSubtype(true);
        if (subtypeInUse == null) {
            return null;
        }
        if (locale != null) {
            final String subtypeLocale = subtypeInUse.getLocale();
            final String subtypeLanguage = parseLanguageFromLocaleString(subtypeLocale);
            if (subtypeLanguage.length() < 2 || !locale.getLanguage().equals(subtypeLanguage)) {
                return null;
            }
        }
    } else {
        final String localeStr = locale.toString();
        for (int i = 0; i < sci.getSubtypeCount(); ++i) {
            final SpellCheckerSubtype subtype = sci.getSubtypeAt(i);
            final String tempSubtypeLocale = subtype.getLocale();
            final String tempSubtypeLanguage = parseLanguageFromLocaleString(tempSubtypeLocale);
            if (tempSubtypeLocale.equals(localeStr)) {
                subtypeInUse = subtype;
                break;
            } else if (tempSubtypeLanguage.length() >= 2 && locale.getLanguage().equals(tempSubtypeLanguage)) {
                subtypeInUse = subtype;
            }
        }
    }
    if (subtypeInUse == null) {
        return null;
    }
    final SpellCheckerSession session = new SpellCheckerSession(sci, mService, listener);
    try {
        mService.getSpellCheckerService(sci.getId(), subtypeInUse.getLocale(), session.getTextServicesSessionListener(), session.getSpellCheckerSessionListener(), bundle);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
    return session;
}
Body of Second Method:
{
    if (listener == null) {
        throw new NullPointerException();
    }
    if (!referToSpellCheckerLanguageSettings && locale == null) {
        throw new IllegalArgumentException("Locale should not be null if you don't refer" + " settings.");
    }
    if (referToSpellCheckerLanguageSettings && !isSpellCheckerEnabled()) {
        return null;
    }
    final SpellCheckerInfo sci;
    try {
        sci = mService.getCurrentSpellChecker(mUserId, null);
    } catch (RemoteException e) {
        return null;
    }
    if (sci == null) {
        return null;
    }
    SpellCheckerSubtype subtypeInUse = null;
    if (referToSpellCheckerLanguageSettings) {
        subtypeInUse = getCurrentSpellCheckerSubtype(true);
        if (subtypeInUse == null) {
            return null;
        }
        if (locale != null) {
            final String subtypeLocale = subtypeInUse.getLocale();
            final String subtypeLanguage = parseLanguageFromLocaleString(subtypeLocale);
            if (subtypeLanguage.length() < 2 || !locale.getLanguage().equals(subtypeLanguage)) {
                return null;
            }
        }
    } else {
        final String localeStr = locale.toString();
        for (int i = 0; i < sci.getSubtypeCount(); ++i) {
            final SpellCheckerSubtype subtype = sci.getSubtypeAt(i);
            final String tempSubtypeLocale = subtype.getLocale();
            final String tempSubtypeLanguage = parseLanguageFromLocaleString(tempSubtypeLocale);
            if (tempSubtypeLocale.equals(localeStr)) {
                subtypeInUse = subtype;
                break;
            } else if (tempSubtypeLanguage.length() >= 2 && locale.getLanguage().equals(tempSubtypeLanguage)) {
                subtypeInUse = subtype;
            }
        }
    }
    if (subtypeInUse == null) {
        return null;
    }
    final SpellCheckerSession session = new SpellCheckerSession(sci, this, listener);
    try {
        mService.getSpellCheckerService(mUserId, sci.getId(), subtypeInUse.getLocale(), session.getTextServicesSessionListener(), session.getSpellCheckerSessionListener(), bundle);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
    return session;
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiConfiguration.writeToParcel:COMMENT
<android.net.wifi.WifiConfiguration: void writeToParcel(Parcel,int)>
public      hidden      ->public      hidden      deprecated  
Method Modifier: public      hidden      deprecated  
Method Modifier: Yes         Yes         No          
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * Implement the Parcelable interface {@hide}
 */

Body of Frist Method:
{
    dest.writeInt(networkId);
    dest.writeInt(status);
    mNetworkSelectionStatus.writeToParcel(dest);
    dest.writeString(SSID);
    dest.writeString(BSSID);
    dest.writeInt(apBand);
    dest.writeInt(apChannel);
    dest.writeString(FQDN);
    dest.writeString(providerFriendlyName);
    dest.writeInt(isHomeProviderNetwork ? 1 : 0);
    dest.writeInt(roamingConsortiumIds.length);
    for (long roamingConsortiumId : roamingConsortiumIds) {
        dest.writeLong(roamingConsortiumId);
    }
    dest.writeString(preSharedKey);
    for (String wepKey : wepKeys) {
        dest.writeString(wepKey);
    }
    dest.writeInt(wepTxKeyIndex);
    dest.writeInt(priority);
    dest.writeInt(hiddenSSID ? 1 : 0);
    dest.writeInt(requirePMF ? 1 : 0);
    dest.writeString(updateIdentifier);
    writeBitSet(dest, allowedKeyManagement);
    writeBitSet(dest, allowedProtocols);
    writeBitSet(dest, allowedAuthAlgorithms);
    writeBitSet(dest, allowedPairwiseCiphers);
    writeBitSet(dest, allowedGroupCiphers);
    dest.writeParcelable(enterpriseConfig, flags);
    dest.writeParcelable(mIpConfiguration, flags);
    dest.writeString(dhcpServer);
    dest.writeString(defaultGwMacAddress);
    dest.writeInt(selfAdded ? 1 : 0);
    dest.writeInt(didSelfAdd ? 1 : 0);
    dest.writeInt(validatedInternetAccess ? 1 : 0);
    dest.writeInt(isLegacyPasspointConfig ? 1 : 0);
    dest.writeInt(ephemeral ? 1 : 0);
    dest.writeInt(meteredHint ? 1 : 0);
    dest.writeInt(meteredOverride);
    dest.writeInt(useExternalScores ? 1 : 0);
    dest.writeInt(creatorUid);
    dest.writeInt(lastConnectUid);
    dest.writeInt(lastUpdateUid);
    dest.writeString(creatorName);
    dest.writeString(lastUpdateName);
    dest.writeInt(numScorerOverride);
    dest.writeInt(numScorerOverrideAndSwitchedNetwork);
    dest.writeInt(numAssociation);
    dest.writeInt(userApproved);
    dest.writeInt(numNoInternetAccessReports);
    dest.writeInt(noInternetAccessExpected ? 1 : 0);
    dest.writeInt(shared ? 1 : 0);
    dest.writeString(mPasspointManagementObjectTree);
    dest.writeInt(recentFailure.getAssociationStatus());
    dest.writeParcelable(mRandomizedMacAddress, flags);
}
Body of Second Method:
{
    dest.writeInt(networkId);
    dest.writeInt(status);
    mNetworkSelectionStatus.writeToParcel(dest);
    dest.writeString(SSID);
    dest.writeString(BSSID);
    dest.writeInt(apBand);
    dest.writeInt(apChannel);
    dest.writeString(FQDN);
    dest.writeString(providerFriendlyName);
    dest.writeInt(isHomeProviderNetwork ? 1 : 0);
    dest.writeInt(roamingConsortiumIds.length);
    for (long roamingConsortiumId : roamingConsortiumIds) {
        dest.writeLong(roamingConsortiumId);
    }
    dest.writeString(preSharedKey);
    for (String wepKey : wepKeys) {
        dest.writeString(wepKey);
    }
    dest.writeInt(wepTxKeyIndex);
    dest.writeInt(priority);
    dest.writeInt(hiddenSSID ? 1 : 0);
    dest.writeInt(requirePMF ? 1 : 0);
    dest.writeString(updateIdentifier);
    writeBitSet(dest, allowedKeyManagement);
    writeBitSet(dest, allowedProtocols);
    writeBitSet(dest, allowedAuthAlgorithms);
    writeBitSet(dest, allowedPairwiseCiphers);
    writeBitSet(dest, allowedGroupCiphers);
    writeBitSet(dest, allowedGroupManagementCiphers);
    writeBitSet(dest, allowedSuiteBCiphers);
    dest.writeParcelable(enterpriseConfig, flags);
    dest.writeParcelable(mIpConfiguration, flags);
    dest.writeString(dhcpServer);
    dest.writeString(defaultGwMacAddress);
    dest.writeInt(selfAdded ? 1 : 0);
    dest.writeInt(didSelfAdd ? 1 : 0);
    dest.writeInt(validatedInternetAccess ? 1 : 0);
    dest.writeInt(isLegacyPasspointConfig ? 1 : 0);
    dest.writeInt(ephemeral ? 1 : 0);
    dest.writeInt(trusted ? 1 : 0);
    dest.writeInt(fromWifiNetworkSuggestion ? 1 : 0);
    dest.writeInt(fromWifiNetworkSpecifier ? 1 : 0);
    dest.writeInt(meteredHint ? 1 : 0);
    dest.writeInt(meteredOverride);
    dest.writeInt(useExternalScores ? 1 : 0);
    dest.writeInt(creatorUid);
    dest.writeInt(lastConnectUid);
    dest.writeInt(lastUpdateUid);
    dest.writeString(creatorName);
    dest.writeString(lastUpdateName);
    dest.writeInt(numScorerOverride);
    dest.writeInt(numScorerOverrideAndSwitchedNetwork);
    dest.writeInt(numAssociation);
    dest.writeInt(userApproved);
    dest.writeInt(numNoInternetAccessReports);
    dest.writeInt(noInternetAccessExpected ? 1 : 0);
    dest.writeInt(shared ? 1 : 0);
    dest.writeString(mPasspointManagementObjectTree);
    dest.writeInt(recentFailure.getAssociationStatus());
    dest.writeParcelable(mRandomizedMacAddress, flags);
    dest.writeInt(macRandomizationSetting);
    dest.writeInt(osu ? 1 : 0);
}
------------------------
Find a silently evolved API code:android.telephony.CellSignalStrengthCdma.setDefaultValues:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    mCdmaDbm = Integer.MAX_VALUE;
    mCdmaEcio = Integer.MAX_VALUE;
    mEvdoDbm = Integer.MAX_VALUE;
    mEvdoEcio = Integer.MAX_VALUE;
    mEvdoSnr = Integer.MAX_VALUE;
}
Body of Second Method:
{
    mCdmaDbm = CellInfo.UNAVAILABLE;
    mCdmaEcio = CellInfo.UNAVAILABLE;
    mEvdoDbm = CellInfo.UNAVAILABLE;
    mEvdoEcio = CellInfo.UNAVAILABLE;
    mEvdoSnr = CellInfo.UNAVAILABLE;
    mLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
}
------------------------
Find a silently evolved API code:android.view.inputmethod.EditorInfo.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Used to package this object into a {@link Parcel}.
 *
 * @param dest The {@link Parcel} to be written.
 * @param flags The flags used for parceling.
 */

Body of Frist Method:
{
    dest.writeInt(inputType);
    dest.writeInt(imeOptions);
    dest.writeString(privateImeOptions);
    TextUtils.writeToParcel(actionLabel, dest, flags);
    dest.writeInt(actionId);
    dest.writeInt(initialSelStart);
    dest.writeInt(initialSelEnd);
    dest.writeInt(initialCapsMode);
    TextUtils.writeToParcel(hintText, dest, flags);
    TextUtils.writeToParcel(label, dest, flags);
    dest.writeString(packageName);
    dest.writeInt(fieldId);
    dest.writeString(fieldName);
    dest.writeBundle(extras);
    if (hintLocales != null) {
        hintLocales.writeToParcel(dest, flags);
    } else {
        LocaleList.getEmptyLocaleList().writeToParcel(dest, flags);
    }
    dest.writeStringArray(contentMimeTypes);
}
Body of Second Method:
{
    dest.writeInt(inputType);
    dest.writeInt(imeOptions);
    dest.writeString(privateImeOptions);
    TextUtils.writeToParcel(actionLabel, dest, flags);
    dest.writeInt(actionId);
    dest.writeInt(initialSelStart);
    dest.writeInt(initialSelEnd);
    dest.writeInt(initialCapsMode);
    TextUtils.writeToParcel(hintText, dest, flags);
    TextUtils.writeToParcel(label, dest, flags);
    dest.writeString(packageName);
    dest.writeInt(fieldId);
    dest.writeString(fieldName);
    dest.writeBundle(extras);
    if (hintLocales != null) {
        hintLocales.writeToParcel(dest, flags);
    } else {
        LocaleList.getEmptyLocaleList().writeToParcel(dest, flags);
    }
    dest.writeStringArray(contentMimeTypes);
    UserHandle.writeToParcel(targetInputMethodUser, dest);
}
------------------------
Find a silently evolved API code:android.graphics.Canvas.setBitmap:COMMENT
Method Modifier: public      
Comment:/**
 * Specify a bitmap for the canvas to draw into. All canvas state such as
 * layers, filters, and the save/restore stack are reset. Additionally,
 * the canvas' target density is updated to match that of the bitmap.
 *
 * Prior to API level {@value Build.VERSION_CODES#O} the current matrix and
 * clip stack were preserved.
 *
 * @param bitmap Specifies a mutable bitmap for the canvas to draw into.
 * @see #setDensity(int)
 * @see #getDensity()
 */

Body of Frist Method:
{
    if (isHardwareAccelerated()) {
        throw new RuntimeException("Can't set a bitmap device on a HW accelerated canvas");
    }
    Matrix preservedMatrix = null;
    if (bitmap != null && sCompatibilitySetBitmap) {
        preservedMatrix = getMatrix();
    }
    if (bitmap == null) {
        nSetBitmap(mNativeCanvasWrapper, null);
        mDensity = Bitmap.DENSITY_NONE;
    } else {
        if (!bitmap.isMutable()) {
            throw new IllegalStateException();
        }
        throwIfCannotDraw(bitmap);
        nSetBitmap(mNativeCanvasWrapper, bitmap);
        mDensity = bitmap.mDensity;
    }
    if (preservedMatrix != null) {
        setMatrix(preservedMatrix);
    }
    mBitmap = bitmap;
}
Body of Second Method:
{
    if (isHardwareAccelerated()) {
        throw new RuntimeException("Can't set a bitmap device on a HW accelerated canvas");
    }
    Matrix preservedMatrix = null;
    if (bitmap != null && sCompatibilitySetBitmap) {
        preservedMatrix = getMatrix();
    }
    if (bitmap == null) {
        nSetBitmap(mNativeCanvasWrapper, 0);
        mDensity = Bitmap.DENSITY_NONE;
    } else {
        if (!bitmap.isMutable()) {
            throw new IllegalStateException();
        }
        throwIfCannotDraw(bitmap);
        nSetBitmap(mNativeCanvasWrapper, bitmap.getNativeInstance());
        mDensity = bitmap.mDensity;
    }
    if (preservedMatrix != null) {
        setMatrix(preservedMatrix);
    }
    mBitmap = bitmap;
}
------------------------
Find a silently evolved API code:android.util.LongArray.remove:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Removes the value at the specified index from this array.
 */

Body of Frist Method:
{
    checkBounds(index);
    System.arraycopy(mValues, index + 1, mValues, index, mSize - index - 1);
    mSize--;
}
Body of Second Method:
{
    ArrayUtils.checkBounds(mSize, index);
    System.arraycopy(mValues, index + 1, mValues, index, mSize - index - 1);
    mSize--;
}
------------------------
Find a silently evolved API code:android.view.ThreadedRenderer.SimpleRenderer.draw:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Draw the surface.
 */

Body of Frist Method:
{
    final long vsync = AnimationUtils.currentAnimationTimeMillis() * 1000000L;
    mFrameInfo.setVsync(vsync, vsync);
    mFrameInfo.addFlags(1 << 2);
    if (callback != null) {
        nSetFrameCallback(mNativeProxy, callback);
    }
    nSyncAndDrawFrame(mNativeProxy, mFrameInfo.mFrameInfo, mFrameInfo.mFrameInfo.length);
}
Body of Second Method:
{
    final long vsync = AnimationUtils.currentAnimationTimeMillis() * 1000000L;
    if (callback != null) {
        setFrameCallback(callback);
    }
    createRenderRequest().setVsyncTime(vsync).syncAndDraw();
}
------------------------
Find a silently evolved API code:android.app.servertransaction.TransactionExecutor.execute:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Resolve transaction.
 * First all callbacks will be executed in the order they appear in the list. If a callback
 * requires a certain pre- or post-execution state, the client will be transitioned accordingly.
 * Then the client will cycle to the final lifecycle state if provided. Otherwise, it will
 * either remain in the initial state, or last state needed by a callback.
 */

Body of Frist Method:
{
    final IBinder token = transaction.getActivityToken();
    log("Start resolving transaction for client: " + mTransactionHandler + ", token: " + token);
    executeCallbacks(transaction);
    executeLifecycleState(transaction);
    mPendingActions.clear();
    log("End resolving transaction");
}
Body of Second Method:
{
    if (DEBUG_RESOLVER)
        Slog.d(TAG, tId(transaction) + "Start resolving transaction");
    final IBinder token = transaction.getActivityToken();
    if (token != null) {
        final Map<IBinder, ClientTransactionItem> activitiesToBeDestroyed = mTransactionHandler.getActivitiesToBeDestroyed();
        final ClientTransactionItem destroyItem = activitiesToBeDestroyed.get(token);
        if (destroyItem != null) {
            if (transaction.getLifecycleStateRequest() == destroyItem) {
                // It is going to execute the transaction that will destroy activity with the
                // token, so the corresponding to-be-destroyed record can be removed.
                activitiesToBeDestroyed.remove(token);
            }
            if (mTransactionHandler.getActivityClient(token) == null) {
                // The activity has not been created but has been requested to destroy, so all
                // transactions for the token are just like being cancelled.
                Slog.w(TAG, tId(transaction) + "Skip pre-destroyed transaction:\n" + transactionToString(transaction, mTransactionHandler));
                return;
            }
        }
    }
    if (DEBUG_RESOLVER)
        Slog.d(TAG, transactionToString(transaction, mTransactionHandler));
    executeCallbacks(transaction);
    executeLifecycleState(transaction);
    mPendingActions.clear();
    if (DEBUG_RESOLVER)
        Slog.d(TAG, tId(transaction) + "End resolving transaction");
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothA2dp.getPriority:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the priority of the profile.
 *
 * <p> The priority can be any of:
 * {@link #PRIORITY_AUTO_CONNECT}, {@link #PRIORITY_OFF},
 * {@link #PRIORITY_ON}, {@link #PRIORITY_UNDEFINED}
 *
 * @param device Bluetooth device
 * @return priority of the device
 * @hide
 */

Body of Frist Method:
{
    if (VDBG)
        log("getPriority(" + device + ")");
    try {
        mServiceLock.readLock().lock();
        if (mService != null && isEnabled() && isValidDevice(device)) {
            return mService.getPriority(device);
        }
        if (mService == null)
            Log.w(TAG, "Proxy not attached to service");
        return BluetoothProfile.PRIORITY_OFF;
    } catch (RemoteException e) {
        Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
        return BluetoothProfile.PRIORITY_OFF;
    } finally {
        mServiceLock.readLock().unlock();
    }
}
Body of Second Method:
{
    if (VDBG)
        log("getPriority(" + device + ")");
    try {
        final IBluetoothA2dp service = getService();
        if (service != null && isEnabled() && isValidDevice(device)) {
            return service.getPriority(device);
        }
        if (service == null)
            Log.w(TAG, "Proxy not attached to service");
        return BluetoothProfile.PRIORITY_OFF;
    } catch (RemoteException e) {
        Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
        return BluetoothProfile.PRIORITY_OFF;
    }
}
------------------------
Find a silently evolved API code:android.telephony.euicc.EuiccManager.isEnabled:COMMENT
Method Modifier: public      
Comment:/**
 * Whether embedded subscriptions are currently enabled.
 *
 * <p>Even on devices with the {@link PackageManager#FEATURE_TELEPHONY_EUICC} feature, embedded
 * subscriptions may be turned off, e.g. because of a carrier restriction from an inserted
 * physical SIM. Therefore, this runtime check should be used before accessing embedded
 * subscription APIs.
 *
 * @return true if embedded subscriptions are currently enabled.
 */

Body of Frist Method:
{
    // restrictions.
    return getIEuiccController() != null;
}
Body of Second Method:
{
    // restrictions.
    return getIEuiccController() != null && refreshCardIdIfUninitialized();
}
------------------------
Find a silently evolved API code:android.view.ViewPropertyAnimator.cancel:COMMENT
Method Modifier: public      
Comment:/**
 * Cancels all property animations that are currently running or pending.
 */

Body of Frist Method:
{
    if (mAnimatorMap.size() > 0) {
        HashMap<Animator, PropertyBundle> mAnimatorMapCopy = (HashMap<Animator, PropertyBundle>) mAnimatorMap.clone();
        Set<Animator> animatorSet = mAnimatorMapCopy.keySet();
        for (Animator runningAnim : animatorSet) {
            runningAnim.cancel();
        }
    }
    mPendingAnimations.clear();
    mPendingSetupAction = null;
    mPendingCleanupAction = null;
    mPendingOnStartAction = null;
    mPendingOnEndAction = null;
    mView.removeCallbacks(mAnimationStarter);
    if (mRTBackend != null) {
        mRTBackend.cancelAll();
    }
}
Body of Second Method:
{
    if (mAnimatorMap.size() > 0) {
        HashMap<Animator, PropertyBundle> mAnimatorMapCopy = (HashMap<Animator, PropertyBundle>) mAnimatorMap.clone();
        Set<Animator> animatorSet = mAnimatorMapCopy.keySet();
        for (Animator runningAnim : animatorSet) {
            runningAnim.cancel();
        }
    }
    mPendingAnimations.clear();
    mPendingSetupAction = null;
    mPendingCleanupAction = null;
    mPendingOnStartAction = null;
    mPendingOnEndAction = null;
    mView.removeCallbacks(mAnimationStarter);
}
------------------------
Find a silently evolved API code:android.app.WindowConfiguration.hashCode:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    int result = 0;
    if (mAppBounds != null) {
        result = 31 * result + mAppBounds.hashCode();
    }
    result = 31 * result + mBounds.hashCode();
    result = 31 * result + mWindowingMode;
    result = 31 * result + mActivityType;
    return result;
}
Body of Second Method:
{
    int result = 0;
    if (mAppBounds != null) {
        result = 31 * result + mAppBounds.hashCode();
    }
    result = 31 * result + mBounds.hashCode();
    result = 31 * result + mWindowingMode;
    result = 31 * result + mActivityType;
    result = 31 * result + mAlwaysOnTop;
    result = 31 * result + mRotation;
    result = 31 * result + mDisplayWindowingMode;
    return result;
}
------------------------
Find a silently evolved API code:android.os.ShellCommand.openFileForSystem:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Helper for just system services to ask the shell to open an output file.
 * @hide
 */

Body of Frist Method:
{
    if (DEBUG)
        Slog.d(TAG, "openFileForSystem: " + path + " mode=" + mode);
    try {
        ParcelFileDescriptor pfd = getShellCallback().openFile(path, "u:r:system_server:s0", mode);
        if (pfd != null) {
            if (DEBUG)
                Slog.d(TAG, "Got file: " + pfd);
            return pfd;
        }
    } catch (RuntimeException e) {
        if (DEBUG)
            Slog.d(TAG, "Failure opening file: " + e.getMessage());
        getErrPrintWriter().println("Failure opening file: " + e.getMessage());
    }
    if (DEBUG)
        Slog.d(TAG, "Error: Unable to open file: " + path);
    getErrPrintWriter().println("Error: Unable to open file: " + path);
    getErrPrintWriter().println("Consider using a file under /data/local/tmp/");
    return null;
}
Body of Second Method:
{
    if (DEBUG)
        Slog.d(TAG, "openFileForSystem: " + path + " mode=" + mode);
    try {
        ParcelFileDescriptor pfd = getShellCallback().openFile(path, "u:r:system_server:s0", mode);
        if (pfd != null) {
            if (DEBUG)
                Slog.d(TAG, "Got file: " + pfd);
            return pfd;
        }
    } catch (RuntimeException e) {
        if (DEBUG)
            Slog.d(TAG, "Failure opening file: " + e.getMessage());
        getErrPrintWriter().println("Failure opening file: " + e.getMessage());
    }
    if (DEBUG)
        Slog.d(TAG, "Error: Unable to open file: " + path);
    getErrPrintWriter().println("Error: Unable to open file: " + path);
    String suggestedPath = "/data/local/tmp/";
    if (path == null || !path.startsWith(suggestedPath)) {
        getErrPrintWriter().println("Consider using a file under " + suggestedPath);
    }
    return null;
}
------------------------
Find a silently evolved API code:android.view.WindowInsets.getSystemWindowInsetBottom:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the bottom system window inset in pixels.
 *
 * <p>The system window inset represents the area of a full-screen window that is
 * partially or fully obscured by the status bar, navigation bar, IME or other system windows.
 * </p>
 *
 * @return The bottom system window inset
 */

Body of Frist Method:
{
    return mSystemWindowInsets.bottom;
}
Body of Second Method:
{
    return getSystemWindowInsets().bottom;
}
------------------------
Find a silently evolved API code:android.media.AudioFormat.isValidEncoding:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    switch(audioFormat) {
        case ENCODING_PCM_8BIT:
        case ENCODING_PCM_16BIT:
        case ENCODING_PCM_FLOAT:
        case ENCODING_AC3:
        case ENCODING_E_AC3:
        case ENCODING_E_AC3_JOC:
        case ENCODING_DTS:
        case ENCODING_DTS_HD:
        case ENCODING_MP3:
        case ENCODING_AAC_LC:
        case ENCODING_AAC_HE_V1:
        case ENCODING_AAC_HE_V2:
        case ENCODING_IEC61937:
        case ENCODING_AAC_ELD:
        case ENCODING_AAC_XHE:
        case ENCODING_AC4:
            return true;
        default:
            return false;
    }
}
Body of Second Method:
{
    switch(audioFormat) {
        case ENCODING_PCM_16BIT:
        case ENCODING_PCM_8BIT:
        case ENCODING_PCM_FLOAT:
        case ENCODING_AC3:
        case ENCODING_E_AC3:
        case ENCODING_DTS:
        case ENCODING_DTS_HD:
        case ENCODING_MP3:
        case ENCODING_AAC_LC:
        case ENCODING_AAC_HE_V1:
        case ENCODING_AAC_HE_V2:
        case ENCODING_IEC61937:
        case ENCODING_DOLBY_TRUEHD:
        case ENCODING_AAC_ELD:
        case ENCODING_AAC_XHE:
        case ENCODING_AC4:
        case ENCODING_E_AC3_JOC:
        case ENCODING_DOLBY_MAT:
            return true;
        default:
            return false;
    }
}
------------------------
Find a silently evolved API code:android.view.WindowInsets.getStableInsetRight:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the right stable inset in pixels.
 *
 * <p>The stable inset represents the area of a full-screen window that <b>may</b> be
 * partially or fully obscured by the system UI elements.  This value does not change
 * based on the visibility state of those elements; for example, if the status bar is
 * normally shown, but temporarily hidden, the stable inset will still provide the inset
 * associated with the status bar being shown.</p>
 *
 * @return The right stable inset
 */

Body of Frist Method:
{
    return mStableInsets.right;
}
Body of Second Method:
{
    return getStableInsets().right;
}
------------------------
Find a silently evolved API code:android.hardware.camera2.legacy.SurfaceTextureRenderer.drawIntoSurfaces:COMMENT
Method Modifier: public      
Comment:/**
 * Draw the current buffer in the {@link SurfaceTexture} returned from
 * {@link #getSurfaceTexture()} into the set of target {@link Surface}s
 * in the next request from the given {@link CaptureCollector}, or drop
 * the frame if none is available.
 *
 * <p>
 * Any {@link Surface}s targeted must be a subset of the {@link Surface}s
 * set in the last {@link #configureSurfaces(java.util.Collection)} call.
 * </p>
 *
 * @param targetCollector the surfaces to draw to.
 */

Body of Frist Method:
{
    if ((mSurfaces == null || mSurfaces.size() == 0) && (mConversionSurfaces == null || mConversionSurfaces.size() == 0)) {
        return;
    }
    boolean doTiming = targetCollector.hasPendingPreviewCaptures();
    checkGlError("before updateTexImage");
    if (doTiming) {
        beginGlTiming();
    }
    mSurfaceTexture.updateTexImage();
    long timestamp = mSurfaceTexture.getTimestamp();
    Pair<RequestHolder, Long> captureHolder = targetCollector.previewCaptured(timestamp);
    // No preview request queued, drop frame.
    if (captureHolder == null) {
        if (DEBUG) {
            Log.d(TAG, "Dropping preview frame.");
        }
        if (doTiming) {
            endGlTiming();
        }
        return;
    }
    RequestHolder request = captureHolder.first;
    Collection<Surface> targetSurfaces = request.getHolderTargets();
    if (doTiming) {
        addGlTimestamp(timestamp);
    }
    List<Long> targetSurfaceIds = new ArrayList();
    try {
        targetSurfaceIds = LegacyCameraDevice.getSurfaceIds(targetSurfaces);
    } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
        Log.w(TAG, "Surface abandoned, dropping frame. ", e);
        request.setOutputAbandoned();
    }
    for (EGLSurfaceHolder holder : mSurfaces) {
        if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)) {
            try {
                LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height);
                makeCurrent(holder.eglSurface);
                LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second);
                drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing == CameraCharacteristics.LENS_FACING_FRONT) ? FLIP_TYPE_HORIZONTAL : FLIP_TYPE_NONE);
                swapBuffers(holder.eglSurface);
            } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
                Log.w(TAG, "Surface abandoned, dropping frame. ", e);
                request.setOutputAbandoned();
            }
        }
    }
    for (EGLSurfaceHolder holder : mConversionSurfaces) {
        if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)) {
            makeCurrent(holder.eglSurface);
            // glReadPixels reads from the bottom of the buffer, so add an extra vertical flip
            try {
                drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing == CameraCharacteristics.LENS_FACING_FRONT) ? FLIP_TYPE_BOTH : FLIP_TYPE_VERTICAL);
            } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
                // Should never hit this.
                throw new IllegalStateException("Surface abandoned, skipping drawFrame...", e);
            }
            mPBufferPixels.clear();
            GLES20.glReadPixels(/*x*/
            0, /*y*/
            0, holder.width, holder.height, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, mPBufferPixels);
            checkGlError("glReadPixels");
            try {
                int format = LegacyCameraDevice.detectSurfaceType(holder.surface);
                LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height);
                LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second);
                LegacyCameraDevice.produceFrame(holder.surface, mPBufferPixels.array(), holder.width, holder.height, format);
            } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
                Log.w(TAG, "Surface abandoned, dropping frame. ", e);
                request.setOutputAbandoned();
            }
        }
    }
    targetCollector.previewProduced();
    if (doTiming) {
        endGlTiming();
    }
}
Body of Second Method:
{
    if ((mSurfaces == null || mSurfaces.size() == 0) && (mConversionSurfaces == null || mConversionSurfaces.size() == 0)) {
        return;
    }
    boolean doTiming = targetCollector.hasPendingPreviewCaptures();
    checkGlError("before updateTexImage");
    if (doTiming) {
        beginGlTiming();
    }
    mSurfaceTexture.updateTexImage();
    long timestamp = mSurfaceTexture.getTimestamp();
    Pair<RequestHolder, Long> captureHolder = targetCollector.previewCaptured(timestamp);
    // No preview request queued, drop frame.
    if (captureHolder == null) {
        if (DEBUG) {
            Log.d(TAG, "Dropping preview frame.");
        }
        if (doTiming) {
            endGlTiming();
        }
        return;
    }
    RequestHolder request = captureHolder.first;
    Collection<Surface> targetSurfaces = request.getHolderTargets();
    if (doTiming) {
        addGlTimestamp(timestamp);
    }
    List<Long> targetSurfaceIds = new ArrayList();
    try {
        targetSurfaceIds = LegacyCameraDevice.getSurfaceIds(targetSurfaces);
    } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
        Log.w(TAG, "Surface abandoned, dropping frame. ", e);
        request.setOutputAbandoned();
    }
    for (EGLSurfaceHolder holder : mSurfaces) {
        if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)) {
            try {
                LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height);
                makeCurrent(holder.eglSurface);
                LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second);
                drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing == CameraCharacteristics.LENS_FACING_FRONT) ? FLIP_TYPE_HORIZONTAL : FLIP_TYPE_NONE);
                swapBuffers(holder.eglSurface);
            } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
                Log.w(TAG, "Surface abandoned, dropping frame. ", e);
                request.setOutputAbandoned();
            }
        }
    }
    for (EGLSurfaceHolder holder : mConversionSurfaces) {
        if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)) {
            // glReadPixels reads from the bottom of the buffer, so add an extra vertical flip
            try {
                makeCurrent(holder.eglSurface);
                drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing == CameraCharacteristics.LENS_FACING_FRONT) ? FLIP_TYPE_BOTH : FLIP_TYPE_VERTICAL);
            } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
                // Should never hit this.
                throw new IllegalStateException("Surface abandoned, skipping drawFrame...", e);
            }
            mPBufferPixels.clear();
            GLES20.glReadPixels(/*x*/
            0, /*y*/
            0, holder.width, holder.height, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, mPBufferPixels);
            checkGlError("glReadPixels");
            try {
                int format = LegacyCameraDevice.detectSurfaceType(holder.surface);
                LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height);
                LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second);
                LegacyCameraDevice.produceFrame(holder.surface, mPBufferPixels.array(), holder.width, holder.height, format);
            } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
                Log.w(TAG, "Surface abandoned, dropping frame. ", e);
                request.setOutputAbandoned();
            }
        }
    }
    targetCollector.previewProduced();
    if (doTiming) {
        endGlTiming();
    }
}
------------------------
Find a silently evolved API code:android.view.ThreadedRenderer.updateSurface:COMMENT
Method Modifier: default     hidden      
Comment:/**
 * Updates the threaded renderer for the specified surface.
 *
 * @param surface The surface to render
 */

Body of Frist Method:
{
    updateEnabledState(surface);
    nUpdateSurface(mNativeProxy, surface);
}
Body of Second Method:
{
    updateEnabledState(surface);
    setSurface(surface);
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiConfiguration.configKey:COMMENT
<android.net.wifi.WifiConfiguration: String configKey(boolean)>
public      hidden      ->public      hidden      deprecated  
Method Modifier: public      hidden      deprecated  
Method Modifier: Yes         Yes         No          
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * @hide
 * return the string used to calculate the hash in WifiConfigStore
 * and uniquely identify this WifiConfiguration
 */

Body of Frist Method:
{
    String key;
    if (allowCached && mCachedConfigKey != null) {
        key = mCachedConfigKey;
    } else if (providerFriendlyName != null) {
        key = FQDN + KeyMgmt.strings[KeyMgmt.WPA_EAP];
        if (!shared) {
            key += "-" + Integer.toString(UserHandle.getUserId(creatorUid));
        }
    } else {
        if (allowedKeyManagement.get(KeyMgmt.WPA_PSK)) {
            key = SSID + KeyMgmt.strings[KeyMgmt.WPA_PSK];
        } else if (allowedKeyManagement.get(KeyMgmt.WPA_EAP) || allowedKeyManagement.get(KeyMgmt.IEEE8021X)) {
            key = SSID + KeyMgmt.strings[KeyMgmt.WPA_EAP];
        } else if (wepKeys[0] != null) {
            key = SSID + "WEP";
        } else {
            key = SSID + KeyMgmt.strings[KeyMgmt.NONE];
        }
        if (!shared) {
            key += "-" + Integer.toString(UserHandle.getUserId(creatorUid));
        }
        mCachedConfigKey = key;
    }
    return key;
}
Body of Second Method:
{
    String key;
    if (allowCached && mCachedConfigKey != null) {
        key = mCachedConfigKey;
    } else if (providerFriendlyName != null) {
        key = FQDN + KeyMgmt.strings[KeyMgmt.WPA_EAP];
        if (!shared) {
            key += "-" + Integer.toString(UserHandle.getUserId(creatorUid));
        }
    } else {
        key = getSsidAndSecurityTypeString();
        if (!shared) {
            key += "-" + Integer.toString(UserHandle.getUserId(creatorUid));
        }
        mCachedConfigKey = key;
    }
    return key;
}
------------------------
Find a silently evolved API code:android.widget.Switch.getTrackTintMode:COMMENT
Method Modifier: public      
Comment:/**
 * @return the blending mode used to apply the tint to the track
 * drawable
 * @attr ref android.R.styleable#Switch_trackTintMode
 * @see #setTrackTintMode(PorterDuff.Mode)
 */

Body of Frist Method:
{
    return mTrackTintMode;
}
Body of Second Method:
{
    BlendMode mode = getTrackTintBlendMode();
    return mode != null ? BlendMode.blendModeToPorterDuffMode(mode) : null;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadset.phoneStateChanged:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Notify Headset of phone state change.
 * This is a backdoor for phone app to call BluetoothHeadset since
 * there is currently not a good way to get precise call state change outside
 * of phone app.
 *
 * @hide
 */

Body of Frist Method:
{
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled()) {
        try {
            service.phoneStateChanged(numActive, numHeld, callState, number, type);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
}
Body of Second Method:
{
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled()) {
        try {
            service.phoneStateChanged(numActive, numHeld, callState, number, type, name);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
}
------------------------
Find a silently evolved API code:android.app.backup.BackupManager.beginRestoreSession:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Begin the process of restoring data from backup.  See the
 * {@link android.app.backup.RestoreSession} class for documentation on that process.
 * @hide
 */

Body of Frist Method:
{
    RestoreSession session = null;
    checkServiceBinder();
    if (sService != null) {
        try {
            // All packages, current transport
            IRestoreSession binder = sService.beginRestoreSession(null, null);
            if (binder != null) {
                session = new RestoreSession(mContext, binder);
            }
        } catch (RemoteException e) {
            Log.e(TAG, "beginRestoreSession() couldn't connect");
        }
    }
    return session;
}
Body of Second Method:
{
    RestoreSession session = null;
    checkServiceBinder();
    if (sService != null) {
        try {
            // All packages, current transport
            IRestoreSession binder = sService.beginRestoreSessionForUser(mContext.getUserId(), null, null);
            if (binder != null) {
                session = new RestoreSession(mContext, binder);
            }
        } catch (RemoteException e) {
            Log.e(TAG, "beginRestoreSession() couldn't connect");
        }
    }
    return session;
}
------------------------
Find a silently evolved API code:android.view.ThreadedRenderer.destroyHardwareResources:COMMENT
Method Modifier: default     hidden      
Comment:/**
 * Destroys all hardware rendering resources associated with the specified
 * view hierarchy.
 *
 * @param view The root of the view hierarchy
 */

Body of Frist Method:
{
    destroyResources(view);
    nDestroyHardwareResources(mNativeProxy);
}
Body of Second Method:
{
    destroyResources(view);
    clearContent();
}
------------------------
Find a silently evolved API code:android.telephony.CellSignalStrengthWcdma.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Implement the Parcelable interface
 */

Body of Frist Method:
{
    if (DBG)
        log("writeToParcel(Parcel, int): " + toString());
    dest.writeInt(mSignalStrength);
    dest.writeInt(mBitErrorRate);
}
Body of Second Method:
{
    if (DBG)
        log("writeToParcel(Parcel, int): " + toString());
    dest.writeInt(mRssi);
    dest.writeInt(mBitErrorRate);
    dest.writeInt(mRscp);
    dest.writeInt(mEcNo);
    dest.writeInt(mLevel);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.getLastVoiceTagNumber:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get a number corresponding to last voice tag recorded on AG.
 *
 * @param device remote device
 * @return <code>true</code> if command has been issued successfully; <code>false</code>
 * otherwise; upon completion HFP sends {@link #ACTION_LAST_VTAG} or {@link #ACTION_RESULT}
 * intent;
 *
 * <p>Feature required for successful execution is being reported by: {@link
 * #EXTRA_AG_FEATURE_ATTACH_NUMBER_TO_VT}. This method invocation will fail silently when
 * feature is not supported.</p>
 */

Body of Frist Method:
{
    if (DBG)
        log("getLastVoiceTagNumber()");
    final IBluetoothHeadsetClient service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getLastVoiceTagNumber(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("getLastVoiceTagNumber()");
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getLastVoiceTagNumber(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.telephony.CellSignalStrengthGsm.setDefaultValues:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    mSignalStrength = Integer.MAX_VALUE;
    mBitErrorRate = Integer.MAX_VALUE;
    mTimingAdvance = Integer.MAX_VALUE;
}
Body of Second Method:
{
    mRssi = CellInfo.UNAVAILABLE;
    mBitErrorRate = CellInfo.UNAVAILABLE;
    mTimingAdvance = CellInfo.UNAVAILABLE;
    mLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
}
------------------------
Find a silently evolved API code:android.app.servertransaction.TransactionExecutor.executeCallbacks:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Cycle through all states requested by callbacks and execute them at proper times.
 */

Body of Frist Method:
{
    final List<ClientTransactionItem> callbacks = transaction.getCallbacks();
    if (callbacks == null) {
        // No callbacks to execute, return early.
        return;
    }
    log("Resolving callbacks");
    final IBinder token = transaction.getActivityToken();
    ActivityClientRecord r = mTransactionHandler.getActivityClient(token);
    // In case when post-execution state of the last callback matches the final state requested
    // for the activity in this transaction, we won't do the last transition here and do it when
    // moving to final state instead (because it may contain additional parameters from server).
    final ActivityLifecycleItem finalStateRequest = transaction.getLifecycleStateRequest();
    final int finalState = finalStateRequest != null ? finalStateRequest.getTargetState() : UNDEFINED;
    // Index of the last callback that requests some post-execution state.
    final int lastCallbackRequestingState = lastCallbackRequestingState(transaction);
    final int size = callbacks.size();
    for (int i = 0; i < size; ++i) {
        final ClientTransactionItem item = callbacks.get(i);
        log("Resolving callback: " + item);
        final int postExecutionState = item.getPostExecutionState();
        final int closestPreExecutionState = mHelper.getClosestPreExecutionState(r, item.getPostExecutionState());
        if (closestPreExecutionState != UNDEFINED) {
            cycleToPath(r, closestPreExecutionState);
        }
        item.execute(mTransactionHandler, token, mPendingActions);
        item.postExecute(mTransactionHandler, token, mPendingActions);
        if (r == null) {
            // Launch activity request will create an activity record.
            r = mTransactionHandler.getActivityClient(token);
        }
        if (postExecutionState != UNDEFINED && r != null) {
            // Skip the very last transition and perform it by explicit state request instead.
            final boolean shouldExcludeLastTransition = i == lastCallbackRequestingState && finalState == postExecutionState;
            cycleToPath(r, postExecutionState, shouldExcludeLastTransition);
        }
    }
}
Body of Second Method:
{
    final List<ClientTransactionItem> callbacks = transaction.getCallbacks();
    if (callbacks == null || callbacks.isEmpty()) {
        // No callbacks to execute, return early.
        return;
    }
    if (DEBUG_RESOLVER)
        Slog.d(TAG, tId(transaction) + "Resolving callbacks in transaction");
    final IBinder token = transaction.getActivityToken();
    ActivityClientRecord r = mTransactionHandler.getActivityClient(token);
    // In case when post-execution state of the last callback matches the final state requested
    // for the activity in this transaction, we won't do the last transition here and do it when
    // moving to final state instead (because it may contain additional parameters from server).
    final ActivityLifecycleItem finalStateRequest = transaction.getLifecycleStateRequest();
    final int finalState = finalStateRequest != null ? finalStateRequest.getTargetState() : UNDEFINED;
    // Index of the last callback that requests some post-execution state.
    final int lastCallbackRequestingState = lastCallbackRequestingState(transaction);
    final int size = callbacks.size();
    for (int i = 0; i < size; ++i) {
        final ClientTransactionItem item = callbacks.get(i);
        if (DEBUG_RESOLVER)
            Slog.d(TAG, tId(transaction) + "Resolving callback: " + item);
        final int postExecutionState = item.getPostExecutionState();
        final int closestPreExecutionState = mHelper.getClosestPreExecutionState(r, item.getPostExecutionState());
        if (closestPreExecutionState != UNDEFINED) {
            cycleToPath(r, closestPreExecutionState, transaction);
        }
        item.execute(mTransactionHandler, token, mPendingActions);
        item.postExecute(mTransactionHandler, token, mPendingActions);
        if (r == null) {
            // Launch activity request will create an activity record.
            r = mTransactionHandler.getActivityClient(token);
        }
        if (postExecutionState != UNDEFINED && r != null) {
            // Skip the very last transition and perform it by explicit state request instead.
            final boolean shouldExcludeLastTransition = i == lastCallbackRequestingState && finalState == postExecutionState;
            cycleToPath(r, postExecutionState, shouldExcludeLastTransition, transaction);
        }
    }
}
------------------------
Find a silently evolved API code:android.location.Location.set:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the contents of the location to the values from the given location.
 */

Body of Frist Method:
{
    mProvider = l.mProvider;
    mTime = l.mTime;
    mElapsedRealtimeNanos = l.mElapsedRealtimeNanos;
    mFieldsMask = l.mFieldsMask;
    mLatitude = l.mLatitude;
    mLongitude = l.mLongitude;
    mAltitude = l.mAltitude;
    mSpeed = l.mSpeed;
    mBearing = l.mBearing;
    mHorizontalAccuracyMeters = l.mHorizontalAccuracyMeters;
    mVerticalAccuracyMeters = l.mVerticalAccuracyMeters;
    mSpeedAccuracyMetersPerSecond = l.mSpeedAccuracyMetersPerSecond;
    mBearingAccuracyDegrees = l.mBearingAccuracyDegrees;
    mExtras = (l.mExtras == null) ? null : new Bundle(l.mExtras);
}
Body of Second Method:
{
    mProvider = l.mProvider;
    mTime = l.mTime;
    mElapsedRealtimeNanos = l.mElapsedRealtimeNanos;
    mElapsedRealtimeUncertaintyNanos = l.mElapsedRealtimeUncertaintyNanos;
    mFieldsMask = l.mFieldsMask;
    mLatitude = l.mLatitude;
    mLongitude = l.mLongitude;
    mAltitude = l.mAltitude;
    mSpeed = l.mSpeed;
    mBearing = l.mBearing;
    mHorizontalAccuracyMeters = l.mHorizontalAccuracyMeters;
    mVerticalAccuracyMeters = l.mVerticalAccuracyMeters;
    mSpeedAccuracyMetersPerSecond = l.mSpeedAccuracyMetersPerSecond;
    mBearingAccuracyDegrees = l.mBearingAccuracyDegrees;
    mExtras = (l.mExtras == null) ? null : new Bundle(l.mExtras);
}
------------------------
Find a silently evolved API code:android.graphics.drawable.Icon.hasTint:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return (mTintList != null) || (mTintMode != DEFAULT_TINT_MODE);
}
Body of Second Method:
{
    return (mTintList != null) || (mBlendMode != DEFAULT_BLEND_MODE);
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiSsid.convertToBytes:COMMENT
Method Modifier: private     hidden      
Comment:/* This function is equivalent to printf_decode() at src/utils/common.c in
     * the supplicant */

Body of Frist Method:
{
    int i = 0;
    int val = 0;
    while (i < asciiEncoded.length()) {
        char c = asciiEncoded.charAt(i);
        switch(c) {
            case '\\':
                i++;
                switch(asciiEncoded.charAt(i)) {
                    case '\\':
                        octets.write('\\');
                        i++;
                        break;
                    case '"':
                        octets.write('"');
                        i++;
                        break;
                    case 'n':
                        octets.write('\n');
                        i++;
                        break;
                    case 'r':
                        octets.write('\r');
                        i++;
                        break;
                    case 't':
                        octets.write('\t');
                        i++;
                        break;
                    case 'e':
                        // escape char
                        octets.write(27);
                        i++;
                        break;
                    case 'x':
                        i++;
                        try {
                            val = Integer.parseInt(asciiEncoded.substring(i, i + 2), HEX_RADIX);
                        } catch (NumberFormatException e) {
                            val = -1;
                        }
                        if (val < 0) {
                            val = Character.digit(asciiEncoded.charAt(i), HEX_RADIX);
                            if (val < 0)
                                break;
                            octets.write(val);
                            i++;
                        } else {
                            octets.write(val);
                            i += 2;
                        }
                        break;
                    case '0':
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                    case '5':
                    case '6':
                    case '7':
                        val = asciiEncoded.charAt(i) - '0';
                        i++;
                        if (asciiEncoded.charAt(i) >= '0' && asciiEncoded.charAt(i) <= '7') {
                            val = val * 8 + asciiEncoded.charAt(i) - '0';
                            i++;
                        }
                        if (asciiEncoded.charAt(i) >= '0' && asciiEncoded.charAt(i) <= '7') {
                            val = val * 8 + asciiEncoded.charAt(i) - '0';
                            i++;
                        }
                        octets.write(val);
                        break;
                    default:
                        break;
                }
                break;
            default:
                octets.write(c);
                i++;
                break;
        }
    }
}
Body of Second Method:
{
    int i = 0;
    int val = 0;
    while (i < asciiEncoded.length()) {
        char c = asciiEncoded.charAt(i);
        switch(c) {
            case '\\':
                i++;
                switch(asciiEncoded.charAt(i)) {
                    case '\\':
                        octets.write('\\');
                        i++;
                        break;
                    case '"':
                        octets.write('"');
                        i++;
                        break;
                    case 'n':
                        octets.write('\n');
                        i++;
                        break;
                    case 'r':
                        octets.write('\r');
                        i++;
                        break;
                    case 't':
                        octets.write('\t');
                        i++;
                        break;
                    case 'e':
                        // escape char
                        octets.write(27);
                        i++;
                        break;
                    case 'x':
                        i++;
                        try {
                            val = Integer.parseInt(asciiEncoded.substring(i, i + 2), HEX_RADIX);
                        } catch (NumberFormatException e) {
                            val = -1;
                        } catch (StringIndexOutOfBoundsException e) {
                            val = -1;
                        }
                        if (val < 0) {
                            val = Character.digit(asciiEncoded.charAt(i), HEX_RADIX);
                            if (val < 0)
                                break;
                            octets.write(val);
                            i++;
                        } else {
                            octets.write(val);
                            i += 2;
                        }
                        break;
                    case '0':
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                    case '5':
                    case '6':
                    case '7':
                        val = asciiEncoded.charAt(i) - '0';
                        i++;
                        if (asciiEncoded.charAt(i) >= '0' && asciiEncoded.charAt(i) <= '7') {
                            val = val * 8 + asciiEncoded.charAt(i) - '0';
                            i++;
                        }
                        if (asciiEncoded.charAt(i) >= '0' && asciiEncoded.charAt(i) <= '7') {
                            val = val * 8 + asciiEncoded.charAt(i) - '0';
                            i++;
                        }
                        octets.write(val);
                        break;
                    default:
                        break;
                }
                break;
            default:
                octets.write(c);
                i++;
                break;
        }
    }
}
------------------------
Find a silently evolved API code:android.opengl.GLUtils.getType:COMMENT
Method Modifier: public      static      
Comment:/**
 * Return the type as defined by OpenGL ES of the supplied bitmap, if there
 * is one. If the bitmap is stored in a compressed format, it may not have
 * a valid OpenGL ES type.
 * @throws IllegalArgumentException if the bitmap does not have a type.
 * @param bitmap
 * @return the OpenGL ES type of the bitmap.
 */

Body of Frist Method:
{
    if (bitmap == null) {
        throw new NullPointerException("getType can't be used with a null Bitmap");
    }
    if (bitmap.isRecycled()) {
        throw new IllegalArgumentException("bitmap is recycled");
    }
    int result = native_getType(bitmap);
    if (result < 0) {
        throw new IllegalArgumentException("Unknown type");
    }
    return result;
}
Body of Second Method:
{
    if (bitmap == null) {
        throw new NullPointerException("getType can't be used with a null Bitmap");
    }
    if (bitmap.isRecycled()) {
        throw new IllegalArgumentException("bitmap is recycled");
    }
    int result = native_getType(bitmap.getNativeInstance());
    if (result < 0) {
        throw new IllegalArgumentException("Unknown type");
    }
    return result;
}
------------------------
Find a silently evolved API code:android.app.Instrumentation.startActivitySync:COMMENT
Method Modifier: public      
Comment:/**
 * Start a new activity and wait for it to begin running before returning.
 * In addition to being synchronous, this method as some semantic
 * differences from the standard {@link Context#startActivity} call: the
 * activity component is resolved before talking with the activity manager
 * (its class name is specified in the Intent that this method ultimately
 * starts), and it does not allow you to start activities that run in a
 * different process.  In addition, if the given Intent resolves to
 * multiple activities, instead of displaying a dialog for the user to
 * select an activity, an exception will be thrown.
 *
 * <p>The function returns as soon as the activity goes idle following the
 * call to its {@link Activity#onCreate}.  Generally this means it has gone
 * through the full initialization including {@link Activity#onResume} and
 * drawn and displayed its initial window.
 *
 * @param intent Description of the activity to start.
 * @param options Additional options for how the Activity should be started.
 * May be null if there are no options.  See {@link android.app.ActivityOptions}
 * for how to build the Bundle supplied here; there are no supported definitions
 * for building it manually.
 *
 * @see Context#startActivity(Intent, Bundle)
 */

Body of Frist Method:
{
    validateNotAppThread();
    synchronized (mSync) {
        intent = new Intent(intent);
        ActivityInfo ai = intent.resolveActivityInfo(getTargetContext().getPackageManager(), 0);
        if (ai == null) {
            throw new RuntimeException("Unable to resolve activity for: " + intent);
        }
        String myProc = mThread.getProcessName();
        if (!ai.processName.equals(myProc)) {
            // there is a single match that is in our package.
            throw new RuntimeException("Intent in process " + myProc + " resolved to different process " + ai.processName + ": " + intent);
        }
        intent.setComponent(new ComponentName(ai.applicationInfo.packageName, ai.name));
        final ActivityWaiter aw = new ActivityWaiter(intent);
        if (mWaitingActivities == null) {
            mWaitingActivities = new ArrayList();
        }
        mWaitingActivities.add(aw);
        getTargetContext().startActivity(intent, options);
        do {
            try {
                mSync.wait();
            } catch (InterruptedException e) {
            }
        } while (mWaitingActivities.contains(aw));
        return aw.activity;
    }
}
Body of Second Method:
{
    validateNotAppThread();
    synchronized (mSync) {
        intent = new Intent(intent);
        ActivityInfo ai = intent.resolveActivityInfo(getTargetContext().getPackageManager(), 0);
        if (ai == null) {
            throw new RuntimeException("Unable to resolve activity for: " + intent);
        }
        String myProc = mThread.getProcessName();
        if (!ai.processName.equals(myProc)) {
            // there is a single match that is in our package.
            throw new RuntimeException("Intent in process " + myProc + " resolved to different process " + ai.processName + ": " + intent);
        }
        intent.setComponent(new ComponentName(ai.applicationInfo.packageName, ai.name));
        final ActivityWaiter aw = new ActivityWaiter(intent);
        if (mWaitingActivities == null) {
            mWaitingActivities = new ArrayList();
        }
        mWaitingActivities.add(aw);
        getTargetContext().startActivity(intent, options);
        do {
            try {
                mSync.wait();
            } catch (InterruptedException e) {
            }
        } while (mWaitingActivities.contains(aw));
        waitForEnterAnimationComplete(aw.activity);
        return aw.activity;
    }
}
------------------------
Find a silently evolved API code:android.media.session.MediaController.adjustVolume:COMMENT
Method Modifier: public      
Comment:/**
 * Adjust the volume of the output this session is playing on. The direction
 * must be one of {@link AudioManager#ADJUST_LOWER},
 * {@link AudioManager#ADJUST_RAISE}, or {@link AudioManager#ADJUST_SAME}.
 * The command will be ignored if the session does not support
 * {@link VolumeProvider#VOLUME_CONTROL_RELATIVE} or
 * {@link VolumeProvider#VOLUME_CONTROL_ABSOLUTE}. The flags in
 * {@link AudioManager} may be used to affect the handling.
 *
 * @see #getPlaybackInfo()
 * @param direction The direction to adjust the volume in.
 * @param flags Any flags to pass with the command.
 */

Body of Frist Method:
{
    try {
        mSessionBinder.adjustVolume(mContext.getPackageName(), mCbStub, false, direction, flags);
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling adjustVolumeBy.", e);
    }
}
Body of Second Method:
{
    try {
        // Note: Need both package name and OP package name. Package name is used for
        // RemoteUserInfo, and OP package name is used for AudioService's internal
        // AppOpsManager usages.
        mSessionBinder.adjustVolume(mContext.getPackageName(), mContext.getOpPackageName(), mCbStub, direction, flags);
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling adjustVolumeBy.", e);
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothPbapClient.disconnect:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Initiate disconnect.
 *
 * @param device Remote Bluetooth Device
 * @return false on error, true otherwise
 */

Body of Frist Method:
{
    if (DBG) {
        log("disconnect(" + device + ")" + new Exception());
    }
    final IBluetoothPbapClient service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            service.disconnect(device);
            return true;
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null) {
        Log.w(TAG, "Proxy not attached to service");
    }
    return false;
}
Body of Second Method:
{
    if (DBG) {
        log("disconnect(" + device + ")" + new Exception());
    }
    final IBluetoothPbapClient service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            service.disconnect(device);
            return true;
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null) {
        Log.w(TAG, "Proxy not attached to service");
    }
    return false;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.setPriority:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Set priority of the profile
 *
 * The device should already be paired.
 */

Body of Frist Method:
{
    if (DBG)
        log("setPriority(" + device + ", " + priority + ")");
    final IBluetoothHeadsetClient service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        if (priority != BluetoothProfile.PRIORITY_OFF && priority != BluetoothProfile.PRIORITY_ON) {
            return false;
        }
        try {
            return service.setPriority(device, priority);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("setPriority(" + device + ", " + priority + ")");
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        if (priority != BluetoothProfile.PRIORITY_OFF && priority != BluetoothProfile.PRIORITY_ON) {
            return false;
        }
        try {
            return service.setPriority(device, priority);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.graphics.drawable.Icon.loadDrawable:COMMENT
Method Modifier: public      
Comment:/**
 * Returns a Drawable that can be used to draw the image inside this Icon, constructing it
 * if necessary. Depending on the type of image, this may not be something you want to do on
 * the UI thread, so consider using
 * {@link #loadDrawableAsync(Context, Message) loadDrawableAsync} instead.
 *
 * @param context {@link android.content.Context Context} in which to load the drawable; used
 * to access {@link android.content.res.Resources Resources}, for example.
 * @return A fresh instance of a drawable for this image, yours to keep.
 */

Body of Frist Method:
{
    final Drawable result = loadDrawableInner(context);
    if (result != null && (mTintList != null || mTintMode != DEFAULT_TINT_MODE)) {
        result.mutate();
        result.setTintList(mTintList);
        result.setTintMode(mTintMode);
    }
    return result;
}
Body of Second Method:
{
    final Drawable result = loadDrawableInner(context);
    if (result != null && (mTintList != null || mBlendMode != DEFAULT_BLEND_MODE)) {
        result.mutate();
        result.setTintList(mTintList);
        result.setTintBlendMode(mBlendMode);
    }
    return result;
}
------------------------
Find a silently evolved API code:android.util.IntArray.remove:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Removes the value at the specified index from this array.
 */

Body of Frist Method:
{
    checkBounds(index);
    System.arraycopy(mValues, index + 1, mValues, index, mSize - index - 1);
    mSize--;
}
Body of Second Method:
{
    ArrayUtils.checkBounds(mSize, index);
    System.arraycopy(mValues, index + 1, mValues, index, mSize - index - 1);
    mSize--;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothA2dp.getConnectedDevices:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (VDBG)
        log("getConnectedDevices()");
    try {
        mServiceLock.readLock().lock();
        if (mService != null && isEnabled()) {
            return mService.getConnectedDevices();
        }
        if (mService == null)
            Log.w(TAG, "Proxy not attached to service");
        return new ArrayList<BluetoothDevice>();
    } catch (RemoteException e) {
        Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
        return new ArrayList<BluetoothDevice>();
    } finally {
        mServiceLock.readLock().unlock();
    }
}
Body of Second Method:
{
    if (VDBG)
        log("getConnectedDevices()");
    try {
        final IBluetoothA2dp service = getService();
        if (service != null && isEnabled()) {
            return service.getConnectedDevices();
        }
        if (service == null)
            Log.w(TAG, "Proxy not attached to service");
        return new ArrayList<BluetoothDevice>();
    } catch (RemoteException e) {
        Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
        return new ArrayList<BluetoothDevice>();
    }
}
------------------------
Find a silently evolved API code:android.telephony.CellInfoWcdma.hashCode:COMMENT
Method Modifier: public      
Comment:/**
 * @return hash code
 */

Body of Frist Method:
{
    return super.hashCode() + mCellIdentityWcdma.hashCode() + mCellSignalStrengthWcdma.hashCode();
}
Body of Second Method:
{
    return Objects.hash(super.hashCode(), mCellIdentityWcdma, mCellSignalStrengthWcdma);
}
------------------------
Find a silently evolved API code:android.view.InputEventReceiver.dispatchInputEvent:COMMENT
Method Modifier: private     hidden      
Comment:// Called from native code.

Body of Frist Method:
{
    mSeqMap.put(event.getSequenceNumber(), seq);
    onInputEvent(event, displayId);
}
Body of Second Method:
{
    mSeqMap.put(event.getSequenceNumber(), seq);
    onInputEvent(event);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothA2dpSink.isA2dpPlaying:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Check if A2DP profile is streaming music.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param device BluetoothDevice device
 */

Body of Frist Method:
{
    final IBluetoothA2dpSink service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.isA2dpPlaying(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    final IBluetoothA2dpSink service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.isA2dpPlaying(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothGatt.readUsingCharacteristicUuid:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Reads the characteristic using its UUID from the associated remote device.
 *
 * <p>This is an asynchronous operation. The result of the read operation
 * is reported by the {@link BluetoothGattCallback#onCharacteristicRead}
 * callback.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param uuid UUID of characteristic to read from the remote device
 * @return true, if the read operation was initiated successfully
 * @hide
 */

Body of Frist Method:
{
    if (VDBG)
        Log.d(TAG, "readUsingCharacteristicUuid() - uuid: " + uuid);
    if (mService == null || mClientIf == 0)
        return false;
    synchronized (mDeviceBusy) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.readUsingCharacteristicUuid(mClientIf, mDevice.getAddress(), new ParcelUuid(uuid), startHandle, endHandle, AUTHENTICATION_NONE);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}
Body of Second Method:
{
    if (VDBG)
        Log.d(TAG, "readUsingCharacteristicUuid() - uuid: " + uuid);
    if (mService == null || mClientIf == 0)
        return false;
    synchronized (mDeviceBusyLock) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.readUsingCharacteristicUuid(mClientIf, mDevice.getAddress(), new ParcelUuid(uuid), startHandle, endHandle, AUTHENTICATION_NONE);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}
------------------------
Find a silently evolved API code:android.service.notification.NotifyingApp.compareTo:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sorts notifying apps from newest last notified date to oldest.
 */

Body of Frist Method:
{
    if (getLastNotified() == o.getLastNotified()) {
        if (getUid() == o.getUid()) {
            return getPackage().compareTo(o.getPackage());
        }
        return Integer.compare(getUid(), o.getUid());
    }
    return -Long.compare(getLastNotified(), o.getLastNotified());
}
Body of Second Method:
{
    if (getLastNotified() == o.getLastNotified()) {
        if (getUserId() == o.getUserId()) {
            return getPackage().compareTo(o.getPackage());
        }
        return Integer.compare(getUserId(), o.getUserId());
    }
    return -Long.compare(getLastNotified(), o.getLastNotified());
}
------------------------
Find a silently evolved API code:android.hardware.camera2.params.OutputConfiguration.equals:COMMENT
Method Modifier: public      
Comment:/**
 * Check if this {@link OutputConfiguration} is equal to another {@link OutputConfiguration}.
 *
 * <p>Two output configurations are only equal if and only if the underlying surfaces, surface
 * properties (width, height, format, dataspace) when the output configurations are created,
 * and all other configuration parameters are equal. </p>
 *
 * @return {@code true} if the objects were equal, {@code false} otherwise
 */

Body of Frist Method:
{
    if (obj == null) {
        return false;
    } else if (this == obj) {
        return true;
    } else if (obj instanceof OutputConfiguration) {
        final OutputConfiguration other = (OutputConfiguration) obj;
        if (mRotation != other.mRotation || !mConfiguredSize.equals(other.mConfiguredSize) || mConfiguredFormat != other.mConfiguredFormat || mSurfaceGroupId != other.mSurfaceGroupId || mSurfaceType != other.mSurfaceType || mIsDeferredConfig != other.mIsDeferredConfig || mIsShared != other.mIsShared || mConfiguredFormat != other.mConfiguredFormat || mConfiguredDataspace != other.mConfiguredDataspace || mConfiguredGenerationId != other.mConfiguredGenerationId)
            return false;
        int minLen = Math.min(mSurfaces.size(), other.mSurfaces.size());
        for (int i = 0; i < minLen; i++) {
            if (mSurfaces.get(i) != other.mSurfaces.get(i))
                return false;
        }
        return true;
    }
    return false;
}
Body of Second Method:
{
    if (obj == null) {
        return false;
    } else if (this == obj) {
        return true;
    } else if (obj instanceof OutputConfiguration) {
        final OutputConfiguration other = (OutputConfiguration) obj;
        if (mRotation != other.mRotation || !mConfiguredSize.equals(other.mConfiguredSize) || mConfiguredFormat != other.mConfiguredFormat || mSurfaceGroupId != other.mSurfaceGroupId || mSurfaceType != other.mSurfaceType || mIsDeferredConfig != other.mIsDeferredConfig || mIsShared != other.mIsShared || mConfiguredFormat != other.mConfiguredFormat || mConfiguredDataspace != other.mConfiguredDataspace || mConfiguredGenerationId != other.mConfiguredGenerationId || !Objects.equals(mPhysicalCameraId, other.mPhysicalCameraId))
            return false;
        int minLen = Math.min(mSurfaces.size(), other.mSurfaces.size());
        for (int i = 0; i < minLen; i++) {
            if (mSurfaces.get(i) != other.mSurfaces.get(i))
                return false;
        }
        return true;
    }
    return false;
}
------------------------
Find a silently evolved API code:android.provider.SearchIndexablesProvider.attachInfo:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Implementation is provided by the parent class.
 */

Body of Frist Method:
{
    mAuthority = info.authority;
    mMatcher = new UriMatcher(UriMatcher.NO_MATCH);
    mMatcher.addURI(mAuthority, SearchIndexablesContract.INDEXABLES_XML_RES_PATH, MATCH_RES_CODE);
    mMatcher.addURI(mAuthority, SearchIndexablesContract.INDEXABLES_RAW_PATH, MATCH_RAW_CODE);
    mMatcher.addURI(mAuthority, SearchIndexablesContract.NON_INDEXABLES_KEYS_PATH, MATCH_NON_INDEXABLE_KEYS_CODE);
    mMatcher.addURI(mAuthority, SearchIndexablesContract.SITE_MAP_PAIRS_PATH, MATCH_SITE_MAP_PAIRS_CODE);
    // Sanity check our setup
    if (!info.exported) {
        throw new SecurityException("Provider must be exported");
    }
    if (!info.grantUriPermissions) {
        throw new SecurityException("Provider must grantUriPermissions");
    }
    if (!android.Manifest.permission.READ_SEARCH_INDEXABLES.equals(info.readPermission)) {
        throw new SecurityException("Provider must be protected by READ_SEARCH_INDEXABLES");
    }
    super.attachInfo(context, info);
}
Body of Second Method:
{
    mAuthority = info.authority;
    mMatcher = new UriMatcher(UriMatcher.NO_MATCH);
    mMatcher.addURI(mAuthority, SearchIndexablesContract.INDEXABLES_XML_RES_PATH, MATCH_RES_CODE);
    mMatcher.addURI(mAuthority, SearchIndexablesContract.INDEXABLES_RAW_PATH, MATCH_RAW_CODE);
    mMatcher.addURI(mAuthority, SearchIndexablesContract.NON_INDEXABLES_KEYS_PATH, MATCH_NON_INDEXABLE_KEYS_CODE);
    mMatcher.addURI(mAuthority, SearchIndexablesContract.SITE_MAP_PAIRS_PATH, MATCH_SITE_MAP_PAIRS_CODE);
    mMatcher.addURI(mAuthority, SearchIndexablesContract.SLICE_URI_PAIRS_PATH, MATCH_SLICE_URI_PAIRS_CODE);
    // Sanity check our setup
    if (!info.exported) {
        throw new SecurityException("Provider must be exported");
    }
    if (!info.grantUriPermissions) {
        throw new SecurityException("Provider must grantUriPermissions");
    }
    if (!android.Manifest.permission.READ_SEARCH_INDEXABLES.equals(info.readPermission)) {
        throw new SecurityException("Provider must be protected by READ_SEARCH_INDEXABLES");
    }
    super.attachInfo(context, info);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothMap.setPriority:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Set priority of the profile
 *
 * <p> The device should already be paired.
 * Priority can be one of {@link #PRIORITY_ON} or
 * {@link #PRIORITY_OFF},
 *
 * @param device Paired bluetooth device
 * @param priority
 * @return true if priority is set, false on error
 */

Body of Frist Method:
{
    if (DBG)
        log("setPriority(" + device + ", " + priority + ")");
    final IBluetoothMap service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        if (priority != BluetoothProfile.PRIORITY_OFF && priority != BluetoothProfile.PRIORITY_ON) {
            return false;
        }
        try {
            return service.setPriority(device, priority);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("setPriority(" + device + ", " + priority + ")");
    final IBluetoothMap service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        if (priority != BluetoothProfile.PRIORITY_OFF && priority != BluetoothProfile.PRIORITY_ON) {
            return false;
        }
        try {
            return service.setPriority(device, priority);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.sendDTMF:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sends DTMF code.
 *
 * Possible code values : 0,1,2,3,4,5,6,7,8,9,A,B,C,D,*,#
 *
 * @param device remote device
 * @param code ASCII code
 * @return <code>true</code> if command has been issued successfully; <code>false</code>
 * otherwise; upon completion HFP sends {@link #ACTION_RESULT} intent;
 */

Body of Frist Method:
{
    if (DBG)
        log("sendDTMF()");
    final IBluetoothHeadsetClient service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.sendDTMF(device, code);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("sendDTMF()");
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.sendDTMF(device, code);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothPbapClient.getDevicesMatchingConnectionStates:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the list of devices matching specified states. Currently at most one.
 *
 * @return list of matching devices
 */

Body of Frist Method:
{
    if (DBG) {
        log("getDevicesMatchingStates()");
    }
    final IBluetoothPbapClient service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.getDevicesMatchingConnectionStates(states);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null) {
        Log.w(TAG, "Proxy not attached to service");
    }
    return new ArrayList<BluetoothDevice>();
}
Body of Second Method:
{
    if (DBG) {
        log("getDevicesMatchingStates()");
    }
    final IBluetoothPbapClient service = getService();
    if (service != null && isEnabled()) {
        try {
            return service.getDevicesMatchingConnectionStates(states);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null) {
        Log.w(TAG, "Proxy not attached to service");
    }
    return new ArrayList<BluetoothDevice>();
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHidHost.setIdleTime:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Send Set_Idle_Time command to the connected HID input device.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN} permission.
 *
 * @param device Remote Bluetooth Device
 * @param idleTime Idle time to be set on HID Device
 * @return false on immediate error, true otherwise
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("setIdletime(" + device + "), idleTime=" + idleTime);
    final IBluetoothHidHost service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.setIdleTime(device, idleTime);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("setIdletime(" + device + "), idleTime=" + idleTime);
    final IBluetoothHidHost service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.setIdleTime(device, idleTime);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.view.ThreadedRenderer.SimpleRenderer.setLightCenter:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Set the light center.
 */

Body of Frist Method:
{
    // Adjust light position for window offsets.
    final Point displaySize = new Point();
    display.getRealSize(displaySize);
    final float lightX = displaySize.x / 2f - windowLeft;
    final float lightY = mLightY - windowTop;
    nSetLightCenter(mNativeProxy, lightX, lightY, mLightZ);
}
Body of Second Method:
{
    // Adjust light position for window offsets.
    final Point displaySize = new Point();
    display.getRealSize(displaySize);
    final float lightX = displaySize.x / 2f - windowLeft;
    final float lightY = mLightY - windowTop;
    setLightSourceGeometry(lightX, lightY, mLightZ, mLightRadius);
}
------------------------
Find a silently evolved API code:android.os.Process.startWebView:COMMENT
<android.os.Process: ProcessStartResult startWebView(String,String,int,int,int[],int,int,int,String,String,String,String,String,String[])>
public      static      final       hidden      ->public      static      hidden      
Method Modifier: public      static      final       hidden      
Method Modifier: Yes         Yes         Yes         Yes         
Method Updated:  Yes         Yes         No          Yes         
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return WebViewZygote.getProcess().start(processClass, niceName, uid, gid, gids, runtimeFlags, mountExternal, targetSdkVersion, seInfo, abi, instructionSet, appDataDir, invokeWith, zygoteArgs);
}
Body of Second Method:
{
    return WebViewZygote.getProcess().start(processClass, niceName, uid, gid, gids, runtimeFlags, mountExternal, targetSdkVersion, seInfo, abi, instructionSet, appDataDir, invokeWith, packageName, /*useUsapPool=*/
    false, zygoteArgs);
}
------------------------
Find a silently evolved API code:android.app.WindowConfiguration.hasWindowDecorCaption:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns true if the activities associated with this window configuration display a decor
 * view.
 * @hide
 */

Body of Frist Method:
{
    return mWindowingMode == WINDOWING_MODE_FREEFORM;
}
Body of Second Method:
{
    return mActivityType == ACTIVITY_TYPE_STANDARD && (mWindowingMode == WINDOWING_MODE_FREEFORM || mDisplayWindowingMode == WINDOWING_MODE_FREEFORM);
}
------------------------
Find a silently evolved API code:android.service.notification.ScheduleCalendar.maybeSetNextAlarm:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets next alarm of the schedule if the saved next alarm has passed or is further
 * in the future than given nextAlarm
 * @param now current time in milliseconds
 * @param nextAlarm time of next alarm in milliseconds
 */

Body of Frist Method:
{
    if (mSchedule != null && mSchedule.exitAtAlarm) {
        // alarm canceled
        if (nextAlarm == 0) {
            mSchedule.nextAlarm = 0;
        }
        // only allow alarms in the future
        if (nextAlarm > now) {
            // store earliest alarm
            if (mSchedule.nextAlarm == 0) {
                mSchedule.nextAlarm = nextAlarm;
            } else {
                mSchedule.nextAlarm = Math.min(mSchedule.nextAlarm, nextAlarm);
            }
        } else if (mSchedule.nextAlarm < now) {
            if (DEBUG) {
                Log.d(TAG, "All alarms are in the past " + mSchedule.nextAlarm);
            }
            mSchedule.nextAlarm = 0;
        }
    }
}
Body of Second Method:
{
    if (mSchedule != null && mSchedule.exitAtAlarm) {
        // alarm canceled
        if (nextAlarm == 0) {
            mSchedule.nextAlarm = 0;
        }
        // only allow alarms in the future
        if (nextAlarm > now) {
            if (mSchedule.nextAlarm == 0 || mSchedule.nextAlarm < now) {
                mSchedule.nextAlarm = nextAlarm;
            } else {
                // store earliest alarm
                mSchedule.nextAlarm = Math.min(mSchedule.nextAlarm, nextAlarm);
            }
        } else if (mSchedule.nextAlarm < now) {
            if (DEBUG) {
                Log.d(TAG, "All alarms are in the past " + mSchedule.nextAlarm);
            }
            mSchedule.nextAlarm = 0;
        }
    }
}
------------------------
Find a silently evolved API code:android.media.AudioFormat.isEncodingLinearFrames:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    switch(audioFormat) {
        case ENCODING_PCM_8BIT:
        case ENCODING_PCM_16BIT:
        case ENCODING_PCM_FLOAT:
        // same size as stereo PCM
        case ENCODING_IEC61937:
        case ENCODING_DEFAULT:
            return true;
        case ENCODING_AC3:
        case ENCODING_E_AC3:
        case ENCODING_E_AC3_JOC:
        case ENCODING_DTS:
        case ENCODING_DTS_HD:
        case ENCODING_MP3:
        case ENCODING_AAC_LC:
        case ENCODING_AAC_HE_V1:
        case ENCODING_AAC_HE_V2:
        case ENCODING_AAC_ELD:
        case ENCODING_AAC_XHE:
        case ENCODING_AC4:
            return false;
        case ENCODING_INVALID:
        default:
            throw new IllegalArgumentException("Bad audio format " + audioFormat);
    }
}
Body of Second Method:
{
    switch(audioFormat) {
        case ENCODING_PCM_16BIT:
        case ENCODING_PCM_8BIT:
        case ENCODING_PCM_FLOAT:
        // same size as stereo PCM
        case ENCODING_IEC61937:
        case ENCODING_DEFAULT:
            return true;
        case ENCODING_AC3:
        case ENCODING_E_AC3:
        case ENCODING_DTS:
        case ENCODING_DTS_HD:
        case ENCODING_MP3:
        case ENCODING_AAC_LC:
        case ENCODING_AAC_HE_V1:
        case ENCODING_AAC_HE_V2:
        case ENCODING_DOLBY_TRUEHD:
        case ENCODING_AAC_ELD:
        case ENCODING_AAC_XHE:
        case ENCODING_AC4:
        case ENCODING_E_AC3_JOC:
        case ENCODING_DOLBY_MAT:
            return false;
        case ENCODING_INVALID:
        default:
            throw new IllegalArgumentException("Bad audio format " + audioFormat);
    }
}
------------------------
Find a silently evolved API code:android.net.http.HttpResponseCache.getNetworkCount:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the number of HTTP requests that required the network to either
 * supply a response or validate a locally cached response.
 */

Body of Frist Method:
{
    return delegate.getNetworkCount();
}
Body of Second Method:
{
    return mDelegate.getNetworkCount();
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.connect:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Connects to remote device.
 *
 * Currently, the system supports only 1 connection. So, in case of the
 * second connection, this implementation will disconnect already connected
 * device automatically and will process the new one.
 *
 * @param device a remote device we want connect to
 * @return <code>true</code> if command has been issued successfully; <code>false</code>
 * otherwise; upon completion HFP sends {@link #ACTION_CONNECTION_STATE_CHANGED} intent.
 */

Body of Frist Method:
{
    if (DBG)
        log("connect(" + device + ")");
    final IBluetoothHeadsetClient service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.connect(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("connect(" + device + ")");
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.connect(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.widget.ProgressBar.setIndeterminateTintMode:COMMENT
Method Modifier: public      
Comment:/**
 * Specifies the blending mode used to apply the tint specified by
 * {@link #setIndeterminateTintList(ColorStateList)} to the indeterminate
 * drawable. The default mode is {@link PorterDuff.Mode#SRC_IN}.
 *
 * @param tintMode the blending mode used to apply the tint, may be
 * {@code null} to clear tint
 * @attr ref android.R.styleable#ProgressBar_indeterminateTintMode
 * @see #setIndeterminateTintList(ColorStateList)
 * @see Drawable#setTintMode(PorterDuff.Mode)
 */

Body of Frist Method:
{
    if (mProgressTintInfo == null) {
        mProgressTintInfo = new ProgressTintInfo();
    }
    mProgressTintInfo.mIndeterminateTintMode = tintMode;
    mProgressTintInfo.mHasIndeterminateTintMode = true;
    applyIndeterminateTint();
}
Body of Second Method:
{
    setIndeterminateTintBlendMode(tintMode != null ? BlendMode.fromValue(tintMode.nativeInt) : null);
}
------------------------
Find a silently evolved API code:android.service.notification.NotificationAssistantService.adjustNotifications:COMMENT
Method Modifier: public      final       hidden      
Comment:/**
 * Updates existing notifications. Re-ranking won't occur until all adjustments are applied.
 * N.B. this wont cause an existing notification to alert, but might allow a future update to
 * these notifications to alert.
 *
 * @param adjustments a list of adjustments with explanations
 */

Body of Frist Method:
{
    if (!isBound())
        return;
    try {
        getNotificationInterface().applyAdjustmentsFromAssistant(mWrapper, adjustments);
    } catch (android.os.RemoteException ex) {
        Log.v(TAG, "Unable to contact notification manager", ex);
        throw ex.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    if (!isBound())
        return;
    try {
        for (Adjustment adjustment : adjustments) {
            setAdjustmentIssuer(adjustment);
        }
        getNotificationInterface().applyAdjustmentsFromAssistant(mWrapper, adjustments);
    } catch (android.os.RemoteException ex) {
        Log.v(TAG, "Unable to contact notification manager", ex);
        throw ex.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.app.WindowConfiguration.writeToProto:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Write to a protocol buffer output stream.
 * Protocol buffer message definition at {@link android.app.WindowConfigurationProto}
 *
 * @param protoOutputStream Stream to write the WindowConfiguration object to.
 * @param fieldId           Field Id of the WindowConfiguration as defined in the parent message
 * @hide
 */

Body of Frist Method:
{
    final long token = protoOutputStream.start(fieldId);
    if (mAppBounds != null) {
        mAppBounds.writeToProto(protoOutputStream, APP_BOUNDS);
    }
    protoOutputStream.write(WINDOWING_MODE, mWindowingMode);
    protoOutputStream.write(ACTIVITY_TYPE, mActivityType);
    protoOutputStream.end(token);
}
Body of Second Method:
{
    final long token = protoOutputStream.start(fieldId);
    if (mAppBounds != null) {
        mAppBounds.writeToProto(protoOutputStream, APP_BOUNDS);
    }
    protoOutputStream.write(WINDOWING_MODE, mWindowingMode);
    protoOutputStream.write(ACTIVITY_TYPE, mActivityType);
    if (mBounds != null) {
        mBounds.writeToProto(protoOutputStream, BOUNDS);
    }
    protoOutputStream.end(token);
}
------------------------
Find a silently evolved API code:android.view.DisplayEventReceiver.dispatchHotplug:COMMENT
Method Modifier: private     hidden      
Comment:// Called from native code.

Body of Frist Method:
{
    onHotplug(timestampNanos, builtInDisplayId, connected);
}
Body of Second Method:
{
    onHotplug(timestampNanos, physicalDisplayId, connected);
}
------------------------
Find a silently evolved API code:android.view.animation.AnimationSet.getTransformation:COMMENT
Method Modifier: public      
Comment:/**
 * The transformation of an animation set is the concatenation of all of its
 * component animations.
 *
 * @see android.view.animation.Animation#getTransformation
 */

Body of Frist Method:
{
    final int count = mAnimations.size();
    final ArrayList<Animation> animations = mAnimations;
    final Transformation temp = mTempTransformation;
    boolean more = false;
    boolean started = false;
    boolean ended = true;
    t.clear();
    for (int i = count - 1; i >= 0; --i) {
        final Animation a = animations.get(i);
        temp.clear();
        more = a.getTransformation(currentTime, temp, getScaleFactor()) || more;
        t.compose(temp);
        started = started || a.hasStarted();
        ended = a.hasEnded() && ended;
    }
    if (started && !mStarted) {
        if (mListener != null) {
            mListener.onAnimationStart(this);
        }
        mStarted = true;
    }
    if (ended != mEnded) {
        if (mListener != null) {
            mListener.onAnimationEnd(this);
        }
        mEnded = ended;
    }
    return more;
}
Body of Second Method:
{
    final int count = mAnimations.size();
    final ArrayList<Animation> animations = mAnimations;
    final Transformation temp = mTempTransformation;
    boolean more = false;
    boolean started = false;
    boolean ended = true;
    t.clear();
    for (int i = count - 1; i >= 0; --i) {
        final Animation a = animations.get(i);
        temp.clear();
        more = a.getTransformation(currentTime, temp, getScaleFactor()) || more;
        t.compose(temp);
        started = started || a.hasStarted();
        ended = a.hasEnded() && ended;
    }
    if (started && !mStarted) {
        dispatchAnimationStart();
        mStarted = true;
    }
    if (ended != mEnded) {
        dispatchAnimationEnd();
        mEnded = ended;
    }
    return more;
}
------------------------
Find a silently evolved API code:android.app.WindowConfiguration.setToDefaults:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    setAppBounds(null);
    setBounds(null);
    setWindowingMode(WINDOWING_MODE_UNDEFINED);
    setActivityType(ACTIVITY_TYPE_UNDEFINED);
}
Body of Second Method:
{
    setAppBounds(null);
    setBounds(null);
    setWindowingMode(WINDOWING_MODE_UNDEFINED);
    setActivityType(ACTIVITY_TYPE_UNDEFINED);
    setAlwaysOnTop(ALWAYS_ON_TOP_UNDEFINED);
    setRotation(ROTATION_UNDEFINED);
    setDisplayWindowingMode(WINDOWING_MODE_UNDEFINED);
}
------------------------
Find a silently evolved API code:android.widget.ListPopupWindow.show:COMMENT
Method Modifier: public      
Comment:/**
 * Show the popup list. If the list is already showing, this method
 * will recalculate the popup's size and position.
 */

Body of Frist Method:
{
    int height = buildDropDown();
    final boolean noInputMethod = isInputMethodNotNeeded();
    mPopup.setAllowScrollingAnchorParent(!noInputMethod);
    mPopup.setWindowLayoutType(mDropDownWindowLayoutType);
    if (mPopup.isShowing()) {
        if (!getAnchorView().isAttachedToWindow()) {
            // Don't update position if the anchor view is detached from window.
            return;
        }
        final int widthSpec;
        if (mDropDownWidth == ViewGroup.LayoutParams.MATCH_PARENT) {
            // The call to PopupWindow's update method below can accept -1 for any
            // value you do not want to update.
            widthSpec = -1;
        } else if (mDropDownWidth == ViewGroup.LayoutParams.WRAP_CONTENT) {
            widthSpec = getAnchorView().getWidth();
        } else {
            widthSpec = mDropDownWidth;
        }
        final int heightSpec;
        if (mDropDownHeight == ViewGroup.LayoutParams.MATCH_PARENT) {
            // The call to PopupWindow's update method below can accept -1 for any
            // value you do not want to update.
            heightSpec = noInputMethod ? height : ViewGroup.LayoutParams.MATCH_PARENT;
            if (noInputMethod) {
                mPopup.setWidth(mDropDownWidth == ViewGroup.LayoutParams.MATCH_PARENT ? ViewGroup.LayoutParams.MATCH_PARENT : 0);
                mPopup.setHeight(0);
            } else {
                mPopup.setWidth(mDropDownWidth == ViewGroup.LayoutParams.MATCH_PARENT ? ViewGroup.LayoutParams.MATCH_PARENT : 0);
                mPopup.setHeight(ViewGroup.LayoutParams.MATCH_PARENT);
            }
        } else if (mDropDownHeight == ViewGroup.LayoutParams.WRAP_CONTENT) {
            heightSpec = height;
        } else {
            heightSpec = mDropDownHeight;
        }
        mPopup.setOutsideTouchable(!mForceIgnoreOutsideTouch && !mDropDownAlwaysVisible);
        mPopup.update(getAnchorView(), mDropDownHorizontalOffset, mDropDownVerticalOffset, (widthSpec < 0) ? -1 : widthSpec, (heightSpec < 0) ? -1 : heightSpec);
        mPopup.getContentView().restoreDefaultFocus();
    } else {
        final int widthSpec;
        if (mDropDownWidth == ViewGroup.LayoutParams.MATCH_PARENT) {
            widthSpec = ViewGroup.LayoutParams.MATCH_PARENT;
        } else {
            if (mDropDownWidth == ViewGroup.LayoutParams.WRAP_CONTENT) {
                widthSpec = getAnchorView().getWidth();
            } else {
                widthSpec = mDropDownWidth;
            }
        }
        final int heightSpec;
        if (mDropDownHeight == ViewGroup.LayoutParams.MATCH_PARENT) {
            heightSpec = ViewGroup.LayoutParams.MATCH_PARENT;
        } else {
            if (mDropDownHeight == ViewGroup.LayoutParams.WRAP_CONTENT) {
                heightSpec = height;
            } else {
                heightSpec = mDropDownHeight;
            }
        }
        mPopup.setWidth(widthSpec);
        mPopup.setHeight(heightSpec);
        mPopup.setClipToScreenEnabled(true);
        // use outside touchable to dismiss drop down when touching outside of it, so
        // only set this if the dropdown is not always visible
        mPopup.setOutsideTouchable(!mForceIgnoreOutsideTouch && !mDropDownAlwaysVisible);
        mPopup.setTouchInterceptor(mTouchInterceptor);
        mPopup.setEpicenterBounds(mEpicenterBounds);
        if (mOverlapAnchorSet) {
            mPopup.setOverlapAnchor(mOverlapAnchor);
        }
        mPopup.showAsDropDown(getAnchorView(), mDropDownHorizontalOffset, mDropDownVerticalOffset, mDropDownGravity);
        mDropDownList.setSelection(ListView.INVALID_POSITION);
        mPopup.getContentView().restoreDefaultFocus();
        if (!mModal || mDropDownList.isInTouchMode()) {
            clearListSelection();
        }
        if (!mModal) {
            mHandler.post(mHideSelector);
        }
    }
}
Body of Second Method:
{
    int height = buildDropDown();
    final boolean noInputMethod = isInputMethodNotNeeded();
    mPopup.setAllowScrollingAnchorParent(!noInputMethod);
    mPopup.setWindowLayoutType(mDropDownWindowLayoutType);
    if (mPopup.isShowing()) {
        if (!getAnchorView().isAttachedToWindow()) {
            // Don't update position if the anchor view is detached from window.
            return;
        }
        final int widthSpec;
        if (mDropDownWidth == ViewGroup.LayoutParams.MATCH_PARENT) {
            // The call to PopupWindow's update method below can accept -1 for any
            // value you do not want to update.
            widthSpec = -1;
        } else if (mDropDownWidth == ViewGroup.LayoutParams.WRAP_CONTENT) {
            widthSpec = getAnchorView().getWidth();
        } else {
            widthSpec = mDropDownWidth;
        }
        final int heightSpec;
        if (mDropDownHeight == ViewGroup.LayoutParams.MATCH_PARENT) {
            // The call to PopupWindow's update method below can accept -1 for any
            // value you do not want to update.
            heightSpec = noInputMethod ? height : ViewGroup.LayoutParams.MATCH_PARENT;
            if (noInputMethod) {
                mPopup.setWidth(mDropDownWidth == ViewGroup.LayoutParams.MATCH_PARENT ? ViewGroup.LayoutParams.MATCH_PARENT : 0);
                mPopup.setHeight(0);
            } else {
                mPopup.setWidth(mDropDownWidth == ViewGroup.LayoutParams.MATCH_PARENT ? ViewGroup.LayoutParams.MATCH_PARENT : 0);
                mPopup.setHeight(ViewGroup.LayoutParams.MATCH_PARENT);
            }
        } else if (mDropDownHeight == ViewGroup.LayoutParams.WRAP_CONTENT) {
            heightSpec = height;
        } else {
            heightSpec = mDropDownHeight;
        }
        mPopup.setOutsideTouchable(!mForceIgnoreOutsideTouch && !mDropDownAlwaysVisible);
        mPopup.update(getAnchorView(), mDropDownHorizontalOffset, mDropDownVerticalOffset, (widthSpec < 0) ? -1 : widthSpec, (heightSpec < 0) ? -1 : heightSpec);
        mPopup.getContentView().restoreDefaultFocus();
    } else {
        final int widthSpec;
        if (mDropDownWidth == ViewGroup.LayoutParams.MATCH_PARENT) {
            widthSpec = ViewGroup.LayoutParams.MATCH_PARENT;
        } else {
            if (mDropDownWidth == ViewGroup.LayoutParams.WRAP_CONTENT) {
                widthSpec = getAnchorView().getWidth();
            } else {
                widthSpec = mDropDownWidth;
            }
        }
        final int heightSpec;
        if (mDropDownHeight == ViewGroup.LayoutParams.MATCH_PARENT) {
            heightSpec = ViewGroup.LayoutParams.MATCH_PARENT;
        } else {
            if (mDropDownHeight == ViewGroup.LayoutParams.WRAP_CONTENT) {
                heightSpec = height;
            } else {
                heightSpec = mDropDownHeight;
            }
        }
        mPopup.setWidth(widthSpec);
        mPopup.setHeight(heightSpec);
        mPopup.setIsClippedToScreen(true);
        // use outside touchable to dismiss drop down when touching outside of it, so
        // only set this if the dropdown is not always visible
        mPopup.setOutsideTouchable(!mForceIgnoreOutsideTouch && !mDropDownAlwaysVisible);
        mPopup.setTouchInterceptor(mTouchInterceptor);
        mPopup.setEpicenterBounds(mEpicenterBounds);
        if (mOverlapAnchorSet) {
            mPopup.setOverlapAnchor(mOverlapAnchor);
        }
        mPopup.showAsDropDown(getAnchorView(), mDropDownHorizontalOffset, mDropDownVerticalOffset, mDropDownGravity);
        mDropDownList.setSelection(ListView.INVALID_POSITION);
        mPopup.getContentView().restoreDefaultFocus();
        if (!mModal || mDropDownList.isInTouchMode()) {
            clearListSelection();
        }
        if (!mModal) {
            mHandler.post(mHideSelector);
        }
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothA2dp.setAvrcpAbsoluteVolume:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Tells remote device to set an absolute volume. Only if absolute volume is supported
 *
 * @param volume Absolute volume to be set on AVRCP side
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        Log.d(TAG, "setAvrcpAbsoluteVolume");
    try {
        mServiceLock.readLock().lock();
        if (mService != null && isEnabled()) {
            mService.setAvrcpAbsoluteVolume(volume);
        }
        if (mService == null)
            Log.w(TAG, "Proxy not attached to service");
    } catch (RemoteException e) {
        Log.e(TAG, "Error talking to BT service in setAvrcpAbsoluteVolume()", e);
    } finally {
        mServiceLock.readLock().unlock();
    }
}
Body of Second Method:
{
    if (DBG)
        Log.d(TAG, "setAvrcpAbsoluteVolume");
    try {
        final IBluetoothA2dp service = getService();
        if (service != null && isEnabled()) {
            service.setAvrcpAbsoluteVolume(volume);
        }
        if (service == null)
            Log.w(TAG, "Proxy not attached to service");
    } catch (RemoteException e) {
        Log.e(TAG, "Error talking to BT service in setAvrcpAbsoluteVolume()", e);
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiEnterpriseConfig.setCaCertificate:COMMENT
Method Modifier: public      
Comment:/**
 * Specify a X.509 certificate that identifies the server.
 *
 * <p>A default name is automatically assigned to the certificate and used
 * with this configuration. The framework takes care of installing the
 * certificate when the config is saved and removing the certificate when
 * the config is removed.
 *
 * @param cert X.509 CA certificate
 * @throws IllegalArgumentException if not a CA certificate
 */

Body of Frist Method:
{
    if (cert != null) {
        if (cert.getBasicConstraints() >= 0) {
            mCaCerts = new X509Certificate[] { cert };
        } else {
            throw new IllegalArgumentException("Not a CA certificate");
        }
    } else {
        mCaCerts = null;
    }
}
Body of Second Method:
{
    if (cert != null) {
        if (cert.getBasicConstraints() >= 0) {
            mIsAppInstalledCaCert = true;
            mCaCerts = new X509Certificate[] { cert };
        } else {
            mCaCerts = null;
            throw new IllegalArgumentException("Not a CA certificate");
        }
    } else {
        mCaCerts = null;
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothSap.close:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Close the connection to the backing service.
 * Other public functions of BluetoothSap will return default error
 * results once close() has been called. Multiple invocations of close()
 * are ok.
 *
 * @hide
 */

Body of Frist Method:
{
    IBluetoothManager mgr = mAdapter.getBluetoothManager();
    if (mgr != null) {
        try {
            mgr.unregisterStateChangeCallback(mBluetoothStateChangeCallback);
        } catch (Exception e) {
            Log.e(TAG, "", e);
        }
    }
    synchronized (mConnection) {
        if (mService != null) {
            try {
                mService = null;
                mContext.unbindService(mConnection);
            } catch (Exception re) {
                Log.e(TAG, "", re);
            }
        }
    }
    mServiceListener = null;
}
Body of Second Method:
{
    mProfileConnector.disconnect();
}
------------------------
Find a silently evolved API code:android.media.AudioAttributes.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Combines all of the attributes that have been set and return a new
 * {@link AudioAttributes} object.
 * @return a new {@link AudioAttributes} object
 */

Body of Frist Method:
{
    AudioAttributes aa = new AudioAttributes();
    aa.mContentType = mContentType;
    aa.mUsage = mUsage;
    aa.mSource = mSource;
    aa.mFlags = mFlags;
    aa.mTags = (HashSet<String>) mTags.clone();
    aa.mFormattedTags = TextUtils.join(";", mTags);
    if (mBundle != null) {
        aa.mBundle = new Bundle(mBundle);
    }
    return aa;
}
Body of Second Method:
{
    AudioAttributes aa = new AudioAttributes();
    aa.mContentType = mContentType;
    aa.mUsage = mUsage;
    aa.mSource = mSource;
    aa.mFlags = mFlags;
    if (mMuteHapticChannels) {
        aa.mFlags |= FLAG_MUTE_HAPTIC;
    }
    aa.mTags = (HashSet<String>) mTags.clone();
    aa.mFormattedTags = TextUtils.join(";", mTags);
    if (mBundle != null) {
        aa.mBundle = new Bundle(mBundle);
    }
    return aa;
}
------------------------
Find a silently evolved API code:android.view.ViewPropertyAnimator.setValue:COMMENT
Method Modifier: private     
Comment:/**
 * This method handles setting the property values directly in the View object's fields.
 * propertyConstant tells it which property should be set, value is the value to set
 * the property to.
 *
 * @param propertyConstant The property to be set
 * @param value The value to set the property to
 */

Body of Frist Method:
{
    final View.TransformationInfo info = mView.mTransformationInfo;
    final RenderNode renderNode = mView.mRenderNode;
    switch(propertyConstant) {
        case TRANSLATION_X:
            renderNode.setTranslationX(value);
            break;
        case TRANSLATION_Y:
            renderNode.setTranslationY(value);
            break;
        case TRANSLATION_Z:
            renderNode.setTranslationZ(value);
            break;
        case ROTATION:
            renderNode.setRotation(value);
            break;
        case ROTATION_X:
            renderNode.setRotationX(value);
            break;
        case ROTATION_Y:
            renderNode.setRotationY(value);
            break;
        case SCALE_X:
            renderNode.setScaleX(value);
            break;
        case SCALE_Y:
            renderNode.setScaleY(value);
            break;
        case X:
            renderNode.setTranslationX(value - mView.mLeft);
            break;
        case Y:
            renderNode.setTranslationY(value - mView.mTop);
            break;
        case Z:
            renderNode.setTranslationZ(value - renderNode.getElevation());
            break;
        case ALPHA:
            info.mAlpha = value;
            renderNode.setAlpha(value);
            break;
    }
}
Body of Second Method:
{
    final RenderNode renderNode = mView.mRenderNode;
    switch(propertyConstant) {
        case TRANSLATION_X:
            renderNode.setTranslationX(value);
            break;
        case TRANSLATION_Y:
            renderNode.setTranslationY(value);
            break;
        case TRANSLATION_Z:
            renderNode.setTranslationZ(value);
            break;
        case ROTATION:
            renderNode.setRotationZ(value);
            break;
        case ROTATION_X:
            renderNode.setRotationX(value);
            break;
        case ROTATION_Y:
            renderNode.setRotationY(value);
            break;
        case SCALE_X:
            renderNode.setScaleX(value);
            break;
        case SCALE_Y:
            renderNode.setScaleY(value);
            break;
        case X:
            renderNode.setTranslationX(value - mView.mLeft);
            break;
        case Y:
            renderNode.setTranslationY(value - mView.mTop);
            break;
        case Z:
            renderNode.setTranslationZ(value - renderNode.getElevation());
            break;
        case ALPHA:
            mView.setAlphaInternal(value);
            renderNode.setAlpha(value);
            break;
    }
}
------------------------
Find a silently evolved API code:android.database.sqlite.SQLiteCompatibilityWalFlags.getWALSyncMode:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    initIfNeeded();
    return sWALSyncMode;
}
Body of Second Method:
{
    initIfNeeded();
    // adds an extra layer of checking that we never use it in the wrong place.
    if (!sLegacyCompatibilityWalEnabled) {
        throw new IllegalStateException("isLegacyCompatibilityWalEnabled() == false");
    }
    return sWALSyncMode;
}
------------------------
Find a silently evolved API code:android.view.ScaleGestureDetector.getScaleFactor:COMMENT
Method Modifier: public      
Comment:/**
 * Return the scaling factor from the previous scale event to the current
 * event. This value is defined as
 * ({@link #getCurrentSpan()} / {@link #getPreviousSpan()}).
 *
 * @return The current scaling factor.
 */

Body of Frist Method:
{
    if (inAnchoredScaleMode()) {
        // Drag is moving up; the further away from the gesture
        // start, the smaller the span should be, the closer,
        // the larger the span, and therefore the larger the scale
        final boolean scaleUp = (mEventBeforeOrAboveStartingGestureEvent && (mCurrSpan < mPrevSpan)) || (!mEventBeforeOrAboveStartingGestureEvent && (mCurrSpan > mPrevSpan));
        final float spanDiff = (Math.abs(1 - (mCurrSpan / mPrevSpan)) * SCALE_FACTOR);
        return mPrevSpan <= 0 ? 1 : scaleUp ? (1 + spanDiff) : (1 - spanDiff);
    }
    return mPrevSpan > 0 ? mCurrSpan / mPrevSpan : 1;
}
Body of Second Method:
{
    if (inAnchoredScaleMode()) {
        // Drag is moving up; the further away from the gesture
        // start, the smaller the span should be, the closer,
        // the larger the span, and therefore the larger the scale
        final boolean scaleUp = (mEventBeforeOrAboveStartingGestureEvent && (mCurrSpan < mPrevSpan)) || (!mEventBeforeOrAboveStartingGestureEvent && (mCurrSpan > mPrevSpan));
        final float spanDiff = (Math.abs(1 - (mCurrSpan / mPrevSpan)) * SCALE_FACTOR);
        return mPrevSpan <= mSpanSlop ? 1 : scaleUp ? (1 + spanDiff) : (1 - spanDiff);
    }
    return mPrevSpan > 0 ? mCurrSpan / mPrevSpan : 1;
}
------------------------
Find a silently evolved API code:android.net.NetworkAgent.sendNetworkScore:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Called by the bearer code when it has a new score for this network.
 */

Body of Frist Method:
{
    if (score < 0) {
        throw new IllegalArgumentException("Score must be >= 0");
    }
    queueOrSendMessage(EVENT_NETWORK_SCORE_CHANGED, new Integer(score));
}
Body of Second Method:
{
    if (score < 0) {
        throw new IllegalArgumentException("Score must be >= 0");
    }
    queueOrSendMessage(EVENT_NETWORK_SCORE_CHANGED, score, 0);
}
------------------------
Find a silently evolved API code:android.app.backup.BackupManager.selectBackupTransport:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Specify the current backup transport and get notified when the transport is ready to be used.
 * This method is async because BackupManager might need to bind to the specified transport
 * which is in a separate process.
 *
 * @param transport ComponentName of the service hosting the transport. This is different from
 * the transport's name that is returned by {@link BackupTransport#name()}.
 * @param listener A listener object to get a callback on the transport being selected.
 *
 * @hide
 */

Body of Frist Method:
{
    checkServiceBinder();
    if (sService != null) {
        try {
            SelectTransportListenerWrapper wrapper = listener == null ? null : new SelectTransportListenerWrapper(mContext, listener);
            sService.selectBackupTransportAsync(transport, wrapper);
        } catch (RemoteException e) {
            Log.e(TAG, "selectBackupTransportAsync() couldn't connect");
        }
    }
}
Body of Second Method:
{
    checkServiceBinder();
    if (sService != null) {
        try {
            SelectTransportListenerWrapper wrapper = listener == null ? null : new SelectTransportListenerWrapper(mContext, listener);
            sService.selectBackupTransportAsyncForUser(mContext.getUserId(), transport, wrapper);
        } catch (RemoteException e) {
            Log.e(TAG, "selectBackupTransportAsync() couldn't connect");
        }
    }
}
------------------------
Find a silently evolved API code:android.app.servertransaction.LaunchActivityItem.obtain:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Obtain an instance initialized with provided params.
 */

Body of Frist Method:
{
    LaunchActivityItem instance = ObjectPool.obtain(LaunchActivityItem.class);
    if (instance == null) {
        instance = new LaunchActivityItem();
    }
    setValues(instance, intent, ident, info, curConfig, overrideConfig, compatInfo, referrer, voiceInteractor, procState, state, persistentState, pendingResults, pendingNewIntents, isForward, profilerInfo);
    return instance;
}
Body of Second Method:
{
    LaunchActivityItem instance = ObjectPool.obtain(LaunchActivityItem.class);
    if (instance == null) {
        instance = new LaunchActivityItem();
    }
    setValues(instance, intent, ident, info, curConfig, overrideConfig, compatInfo, referrer, voiceInteractor, procState, state, persistentState, pendingResults, pendingNewIntents, isForward, profilerInfo, assistToken);
    return instance;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.close:COMMENT
Method Modifier: default     hidden      
Comment:/*package*/

Body of Frist Method:
{
    if (VDBG)
        log("close()");
    IBluetoothManager mgr = mAdapter.getBluetoothManager();
    if (mgr != null) {
        try {
            mgr.unregisterStateChangeCallback(mBluetoothStateChangeCallback);
        } catch (Exception e) {
            Log.e(TAG, "", e);
        }
    }
    synchronized (mConnection) {
        if (mService != null) {
            try {
                mService = null;
                mContext.unbindService(mConnection);
            } catch (Exception re) {
                Log.e(TAG, "", re);
            }
        }
    }
    mServiceListener = null;
}
Body of Second Method:
{
    if (VDBG)
        log("close()");
    mProfileConnector.disconnect();
}
------------------------
Find a silently evolved API code:android.text.style.SuggestionSpan.writeToParcelInternal:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    dest.writeStringArray(mSuggestions);
    dest.writeInt(mFlags);
    dest.writeString(mLocaleStringForCompatibility);
    dest.writeString(mLanguageTag);
    dest.writeString(mNotificationTargetClassName);
    dest.writeString(mNotificationTargetPackageName);
    dest.writeInt(mHashCode);
    dest.writeInt(mEasyCorrectUnderlineColor);
    dest.writeFloat(mEasyCorrectUnderlineThickness);
    dest.writeInt(mMisspelledUnderlineColor);
    dest.writeFloat(mMisspelledUnderlineThickness);
    dest.writeInt(mAutoCorrectionUnderlineColor);
    dest.writeFloat(mAutoCorrectionUnderlineThickness);
}
Body of Second Method:
{
    dest.writeStringArray(mSuggestions);
    dest.writeInt(mFlags);
    dest.writeString(mLocaleStringForCompatibility);
    dest.writeString(mLanguageTag);
    dest.writeInt(mHashCode);
    dest.writeInt(mEasyCorrectUnderlineColor);
    dest.writeFloat(mEasyCorrectUnderlineThickness);
    dest.writeInt(mMisspelledUnderlineColor);
    dest.writeFloat(mMisspelledUnderlineThickness);
    dest.writeInt(mAutoCorrectionUnderlineColor);
    dest.writeFloat(mAutoCorrectionUnderlineThickness);
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiEnterpriseConfig.copyFrom:COMMENT
Method Modifier: private     
Comment:/**
 * Copy over the contents of the source WifiEnterpriseConfig object over to this object.
 *
 * @param source Source WifiEnterpriseConfig object.
 * @param ignoreMaskedPassword Set to true to ignore masked password field, false otherwise.
 * @param mask if |ignoreMaskedPassword| is set, check if the incoming password field is set
 * to this value.
 */

Body of Frist Method:
{
    for (String key : source.mFields.keySet()) {
        if (ignoreMaskedPassword && key.equals(PASSWORD_KEY) && TextUtils.equals(source.mFields.get(key), mask)) {
            continue;
        }
        mFields.put(key, source.mFields.get(key));
    }
    if (source.mCaCerts != null) {
        mCaCerts = Arrays.copyOf(source.mCaCerts, source.mCaCerts.length);
    } else {
        mCaCerts = null;
    }
    mClientPrivateKey = source.mClientPrivateKey;
    if (source.mClientCertificateChain != null) {
        mClientCertificateChain = Arrays.copyOf(source.mClientCertificateChain, source.mClientCertificateChain.length);
    } else {
        mClientCertificateChain = null;
    }
    mEapMethod = source.mEapMethod;
    mPhase2Method = source.mPhase2Method;
}
Body of Second Method:
{
    for (String key : source.mFields.keySet()) {
        if (ignoreMaskedPassword && key.equals(PASSWORD_KEY) && TextUtils.equals(source.mFields.get(key), mask)) {
            continue;
        }
        mFields.put(key, source.mFields.get(key));
    }
    if (source.mCaCerts != null) {
        mCaCerts = Arrays.copyOf(source.mCaCerts, source.mCaCerts.length);
    } else {
        mCaCerts = null;
    }
    mClientPrivateKey = source.mClientPrivateKey;
    if (source.mClientCertificateChain != null) {
        mClientCertificateChain = Arrays.copyOf(source.mClientCertificateChain, source.mClientCertificateChain.length);
    } else {
        mClientCertificateChain = null;
    }
    mEapMethod = source.mEapMethod;
    mPhase2Method = source.mPhase2Method;
    mIsAppInstalledDeviceKeyAndCert = source.mIsAppInstalledDeviceKeyAndCert;
    mIsAppInstalledCaCert = source.mIsAppInstalledCaCert;
}
------------------------
Find a silently evolved API code:android.text.TextUtils.getLayoutDirectionFromLocale:COMMENT
Method Modifier: public      static      
Comment:/**
 * Return the layout direction for a given Locale
 *
 * @param locale the Locale for which we want the layout direction. Can be null.
 * @return the layout direction. This may be one of:
 * {@link android.view.View#LAYOUT_DIRECTION_LTR} or
 * {@link android.view.View#LAYOUT_DIRECTION_RTL}.
 *
 * Be careful: this code will need to be updated when vertical scripts will be supported
 */

Body of Frist Method:
{
    return ((locale != null && !locale.equals(Locale.ROOT) && ULocale.forLocale(locale).isRightToLeft()) || // If forcing into RTL layout mode, return RTL as default
    SystemProperties.getBoolean(Settings.Global.DEVELOPMENT_FORCE_RTL, false)) ? View.LAYOUT_DIRECTION_RTL : View.LAYOUT_DIRECTION_LTR;
}
Body of Second Method:
{
    return ((locale != null && !locale.equals(Locale.ROOT) && ULocale.forLocale(locale).isRightToLeft()) || // If forcing into RTL layout mode, return RTL as default
    DisplayProperties.debug_force_rtl().orElse(false)) ? View.LAYOUT_DIRECTION_RTL : View.LAYOUT_DIRECTION_LTR;
}
------------------------
Find a silently evolved API code:android.view.ThreadedRenderer.initialize:COMMENT
Method Modifier: default     hidden      
Comment:/**
 * Initializes the threaded renderer for the specified surface.
 *
 * @param surface The surface to render
 *
 * @return True if the initialization was successful, false otherwise.
 */

Body of Frist Method:
{
    boolean status = !mInitialized;
    mInitialized = true;
    updateEnabledState(surface);
    nInitialize(mNativeProxy, surface);
    return status;
}
Body of Second Method:
{
    boolean status = !mInitialized;
    mInitialized = true;
    updateEnabledState(surface);
    setSurface(surface);
    return status;
}
------------------------
Find a silently evolved API code:android.media.audiopolicy.AudioMixingRule.equals:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (this == o)
        return true;
    if (o == null || getClass() != o.getClass())
        return false;
    final AudioMixingRule that = (AudioMixingRule) o;
    return (this.mTargetMixType == that.mTargetMixType) && (areCriteriaEquivalent(this.mCriteria, that.mCriteria));
}
Body of Second Method:
{
    if (this == o)
        return true;
    if (o == null || getClass() != o.getClass())
        return false;
    final AudioMixingRule that = (AudioMixingRule) o;
    return (this.mTargetMixType == that.mTargetMixType) && (areCriteriaEquivalent(this.mCriteria, that.mCriteria) && this.mAllowPrivilegedPlaybackCapture == that.mAllowPrivilegedPlaybackCapture);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHidHost.getDevicesMatchingConnectionStates:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (VDBG)
        log("getDevicesMatchingStates()");
    final IBluetoothHidHost service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.getDevicesMatchingConnectionStates(states);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
Body of Second Method:
{
    if (VDBG)
        log("getDevicesMatchingStates()");
    final IBluetoothHidHost service = getService();
    if (service != null && isEnabled()) {
        try {
            return service.getDevicesMatchingConnectionStates(states);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothAvrcpController.getConnectedDevices:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (VDBG)
        log("getConnectedDevices()");
    final IBluetoothAvrcpController service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.getConnectedDevices();
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
Body of Second Method:
{
    if (VDBG)
        log("getConnectedDevices()");
    final IBluetoothAvrcpController service = getService();
    if (service != null && isEnabled()) {
        try {
            return service.getConnectedDevices();
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
------------------------
Find a silently evolved API code:android.telephony.CellInfoLte.hashCode:COMMENT
Method Modifier: public      
Comment:/**
 * @return hash code
 */

Body of Frist Method:
{
    return super.hashCode() + mCellIdentityLte.hashCode() + mCellSignalStrengthLte.hashCode();
}
Body of Second Method:
{
    return Objects.hash(super.hashCode(), mCellIdentityLte.hashCode(), mCellSignalStrengthLte.hashCode(), mCellConfig.hashCode());
}
------------------------
Find a silently evolved API code:android.graphics.drawable.ColorDrawable.updateLocalState:COMMENT
Method Modifier: private     
Comment:/**
 * Initializes local dynamic properties from state. This should be called
 * after significant state changes, e.g. from the One True Constructor and
 * after inflating or applying a theme.
 */

Body of Frist Method:
{
    mTintFilter = updateTintFilter(mTintFilter, mColorState.mTint, mColorState.mTintMode);
}
Body of Second Method:
{
    mBlendModeColorFilter = updateBlendModeFilter(mBlendModeColorFilter, mColorState.mTint, mColorState.mBlendMode);
}
------------------------
Find a silently evolved API code:android.net.wifi.aware.WifiAwareNetworkSpecifier.hashCode:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    int result = 17;
    result = 31 * result + type;
    result = 31 * result + role;
    result = 31 * result + clientId;
    result = 31 * result + sessionId;
    result = 31 * result + peerId;
    result = 31 * result + Arrays.hashCode(peerMac);
    result = 31 * result + Arrays.hashCode(pmk);
    result = 31 * result + Objects.hashCode(passphrase);
    result = 31 * result + requestorUid;
    return result;
}
Body of Second Method:
{
    return Objects.hash(type, role, clientId, sessionId, peerId, Arrays.hashCode(peerMac), Arrays.hashCode(pmk), passphrase, port, transportProtocol, requestorUid);
}
------------------------
Find a silently evolved API code:android.media.RemoteControlClient.setTransportControlFlags:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * Sets the flags for the media transport control buttons that this client supports.
 * @param transportControlFlags A combination of the following flags:
 * {@link #FLAG_KEY_MEDIA_PREVIOUS},
 * {@link #FLAG_KEY_MEDIA_REWIND},
 * {@link #FLAG_KEY_MEDIA_PLAY},
 * {@link #FLAG_KEY_MEDIA_PLAY_PAUSE},
 * {@link #FLAG_KEY_MEDIA_PAUSE},
 * {@link #FLAG_KEY_MEDIA_STOP},
 * {@link #FLAG_KEY_MEDIA_FAST_FORWARD},
 * {@link #FLAG_KEY_MEDIA_NEXT},
 * {@link #FLAG_KEY_MEDIA_POSITION_UPDATE},
 * {@link #FLAG_KEY_MEDIA_RATING}.
 */

Body of Frist Method:
{
    synchronized (mCacheLock) {
        // store locally
        mTransportControlFlags = transportControlFlags;
        // USE_SESSIONS
        if (mSession != null) {
            PlaybackState.Builder bob = new PlaybackState.Builder(mSessionPlaybackState);
            bob.setActions(PlaybackState.getActionsFromRccControlFlags(transportControlFlags));
            mSessionPlaybackState = bob.build();
            mSession.setPlaybackState(mSessionPlaybackState);
        }
    }
}
Body of Second Method:
{
    synchronized (mCacheLock) {
        // store locally
        mTransportControlFlags = transportControlFlags;
        // USE_SESSIONS
        if (mSession != null) {
            PlaybackState.Builder bob = new PlaybackState.Builder(mSessionPlaybackState);
            bob.setActions(getActionsFromRccControlFlags(transportControlFlags));
            mSessionPlaybackState = bob.build();
            mSession.setPlaybackState(mSessionPlaybackState);
        }
    }
}
------------------------
Find a silently evolved API code:android.view.WindowInsets.consumeStableInsets:COMMENT
Method Modifier: public      
Comment:/**
 * Returns a copy of this WindowInsets with the stable insets fully consumed.
 *
 * @return A modified copy of this WindowInsets
 */

Body of Frist Method:
{
    final WindowInsets result = new WindowInsets(this);
    result.mStableInsets = EMPTY_RECT;
    result.mStableInsetsConsumed = true;
    return result;
}
Body of Second Method:
{
    return new WindowInsets(mSystemWindowInsetsConsumed ? null : mTypeInsetsMap, null, mTypeVisibilityMap, mIsRound, mAlwaysConsumeSystemBars, displayCutoutCopyConstructorArgument(this));
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothSap.getState:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the current state of the BluetoothSap service.
 *
 * @return One of the STATE_ return codes, or STATE_ERROR if this proxy object is currently not
 * connected to the Sap service.
 * @hide
 */

Body of Frist Method:
{
    if (VDBG)
        log("getState()");
    final IBluetoothSap service = mService;
    if (service != null) {
        try {
            return service.getState();
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            log(Log.getStackTraceString(new Throwable()));
    }
    return BluetoothSap.STATE_ERROR;
}
Body of Second Method:
{
    if (VDBG)
        log("getState()");
    final IBluetoothSap service = getService();
    if (service != null) {
        try {
            return service.getState();
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            log(Log.getStackTraceString(new Throwable()));
    }
    return BluetoothSap.STATE_ERROR;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHidHost.getConnectedDevices:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (VDBG)
        log("getConnectedDevices()");
    final IBluetoothHidHost service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.getConnectedDevices();
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
Body of Second Method:
{
    if (VDBG)
        log("getConnectedDevices()");
    final IBluetoothHidHost service = getService();
    if (service != null && isEnabled()) {
        try {
            return service.getConnectedDevices();
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothA2dp.setOptionalCodecsEnabled:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets a persistent preference for whether a given device should have optional codecs enabled.
 *
 * @param device The device to set this preference for.
 * @param value Whether the optional codecs should be enabled for this device.  This should be
 * one of OPTIONAL_CODECS_PREF_UNKNOWN, OPTIONAL_CODECS_PREF_ENABLED, or
 * OPTIONAL_CODECS_PREF_DISABLED.
 * @hide
 */

Body of Frist Method:
{
    try {
        if (value != BluetoothA2dp.OPTIONAL_CODECS_PREF_UNKNOWN && value != BluetoothA2dp.OPTIONAL_CODECS_PREF_DISABLED && value != BluetoothA2dp.OPTIONAL_CODECS_PREF_ENABLED) {
            Log.e(TAG, "Invalid value passed to setOptionalCodecsEnabled: " + value);
            return;
        }
        mServiceLock.readLock().lock();
        if (mService != null && isEnabled() && isValidDevice(device)) {
            mService.setOptionalCodecsEnabled(device, value);
        }
        if (mService == null)
            Log.w(TAG, "Proxy not attached to service");
        return;
    } catch (RemoteException e) {
        Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
        return;
    } finally {
        mServiceLock.readLock().unlock();
    }
}
Body of Second Method:
{
    try {
        if (value != BluetoothA2dp.OPTIONAL_CODECS_PREF_UNKNOWN && value != BluetoothA2dp.OPTIONAL_CODECS_PREF_DISABLED && value != BluetoothA2dp.OPTIONAL_CODECS_PREF_ENABLED) {
            Log.e(TAG, "Invalid value passed to setOptionalCodecsEnabled: " + value);
            return;
        }
        final IBluetoothA2dp service = getService();
        if (service != null && isEnabled() && isValidDevice(device)) {
            service.setOptionalCodecsEnabled(device, value);
        }
        if (service == null)
            Log.w(TAG, "Proxy not attached to service");
        return;
    } catch (RemoteException e) {
        Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
        return;
    }
}
------------------------
Find a silently evolved API code:android.telephony.CellIdentityWcdma.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Implement the Parcelable interface
 */

Body of Frist Method:
{
    if (DBG)
        log("writeToParcel(Parcel, int): " + toString());
    super.writeToParcel(dest, TYPE_WCDMA);
    dest.writeInt(mLac);
    dest.writeInt(mCid);
    dest.writeInt(mPsc);
    dest.writeInt(mUarfcn);
}
Body of Second Method:
{
    if (DBG)
        log("writeToParcel(Parcel, int): " + toString());
    super.writeToParcel(dest, CellInfo.TYPE_WCDMA);
    dest.writeInt(mLac);
    dest.writeInt(mCid);
    dest.writeInt(mPsc);
    dest.writeInt(mUarfcn);
}
------------------------
Find a silently evolved API code:android.graphics.Picture.endRecording:COMMENT
Method Modifier: public      
Comment:/**
 * Call endRecording when the picture is built. After this call, the picture
 * may be drawn, but the canvas that was returned by beginRecording must not
 * be used anymore. This is automatically called if {@link Picture#draw}
 * or {@link Canvas#drawPicture(Picture)} is called.
 */

Body of Frist Method:
{
    if (mRecordingCanvas != null) {
        mRequiresHwAcceleration = mRecordingCanvas.mHoldsHwBitmap;
        mRecordingCanvas = null;
        nativeEndRecording(mNativePicture);
    }
}
Body of Second Method:
{
    verifyValid();
    if (mRecordingCanvas != null) {
        mRequiresHwAcceleration = mRecordingCanvas.mHoldsHwBitmap;
        mRecordingCanvas = null;
        nativeEndRecording(mNativePicture);
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothA2dp.isA2dpPlaying:COMMENT
Method Modifier: public      
Comment:/**
 * Check if A2DP profile is streaming music.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param device BluetoothDevice device
 */

Body of Frist Method:
{
    try {
        mServiceLock.readLock().lock();
        if (mService != null && isEnabled() && isValidDevice(device)) {
            return mService.isA2dpPlaying(device);
        }
        if (mService == null)
            Log.w(TAG, "Proxy not attached to service");
        return false;
    } catch (RemoteException e) {
        Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
        return false;
    } finally {
        mServiceLock.readLock().unlock();
    }
}
Body of Second Method:
{
    try {
        final IBluetoothA2dp service = getService();
        if (service != null && isEnabled() && isValidDevice(device)) {
            return service.isA2dpPlaying(device);
        }
        if (service == null)
            Log.w(TAG, "Proxy not attached to service");
        return false;
    } catch (RemoteException e) {
        Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
        return false;
    }
}
------------------------
Find a silently evolved API code:android.hardware.camera2.params.StreamConfigurationMap.checkArgumentFormatSupported:COMMENT
Method Modifier: private     
Comment:// Check that the argument is supported by #getOutputFormats or #getInputFormats

Body of Frist Method:
{
    checkArgumentFormat(format);
    int internalFormat = imageFormatToInternal(format);
    int internalDataspace = imageFormatToDataspace(format);
    if (output) {
        if (internalDataspace == HAL_DATASPACE_DEPTH) {
            if (mDepthOutputFormats.indexOfKey(internalFormat) >= 0) {
                return format;
            }
        } else {
            if (mAllOutputFormats.indexOfKey(internalFormat) >= 0) {
                return format;
            }
        }
    } else {
        if (mInputFormats.indexOfKey(internalFormat) >= 0) {
            return format;
        }
    }
    throw new IllegalArgumentException(String.format("format %x is not supported by this stream configuration map", format));
}
Body of Second Method:
{
    checkArgumentFormat(format);
    int internalFormat = imageFormatToInternal(format);
    int internalDataspace = imageFormatToDataspace(format);
    if (output) {
        if (internalDataspace == HAL_DATASPACE_DEPTH) {
            if (mDepthOutputFormats.indexOfKey(internalFormat) >= 0) {
                return format;
            }
        } else if (internalDataspace == HAL_DATASPACE_DYNAMIC_DEPTH) {
            if (mDynamicDepthOutputFormats.indexOfKey(internalFormat) >= 0) {
                return format;
            }
        } else if (internalDataspace == HAL_DATASPACE_HEIF) {
            if (mHeicOutputFormats.indexOfKey(internalFormat) >= 0) {
                return format;
            }
        } else {
            if (mAllOutputFormats.indexOfKey(internalFormat) >= 0) {
                return format;
            }
        }
    } else {
        if (mInputFormats.indexOfKey(internalFormat) >= 0) {
            return format;
        }
    }
    throw new IllegalArgumentException(String.format("format %x is not supported by this stream configuration map", format));
}
------------------------
Find a silently evolved API code:android.media.PlayerBase.isRestricted_sync:COMMENT
Method Modifier: default     hidden      
Comment:/**
 * To be called by the subclass whenever an operation is potentially restricted.
 * As the media player-common behavior are incorporated into this class, the subclass's need
 * to call this method should be removed, and this method could become private.
 * FIXME can this method be private so subclasses don't have to worry about when to check
 * the restrictions.
 * @return
 */

Body of Frist Method:
{
    // check app ops
    if (mHasAppOpsPlayAudio) {
        return false;
    }
    // check bypass flag
    if ((mAttributes.getAllFlags() & AudioAttributes.FLAG_BYPASS_INTERRUPTION_POLICY) != 0) {
        return false;
    }
    // check force audibility flag and camera restriction
    if (((mAttributes.getAllFlags() & AudioAttributes.FLAG_AUDIBILITY_ENFORCED) != 0) && (mAttributes.getUsage() == AudioAttributes.USAGE_ASSISTANCE_SONIFICATION)) {
        boolean cameraSoundForced = false;
        try {
            cameraSoundForced = getService().isCameraSoundForced();
        } catch (RemoteException e) {
            Log.e(TAG, "Cannot access AudioService in isRestricted_sync()");
        } catch (NullPointerException e) {
            Log.e(TAG, "Null AudioService in isRestricted_sync()");
        }
        if (cameraSoundForced) {
            return false;
        }
    }
    return true;
}
Body of Second Method:
{
    if (USE_AUDIOFLINGER_MUTING_FOR_OP) {
        return false;
    }
    // check app ops
    if (mHasAppOpsPlayAudio) {
        return false;
    }
    // check bypass flag
    if ((mAttributes.getAllFlags() & AudioAttributes.FLAG_BYPASS_INTERRUPTION_POLICY) != 0) {
        return false;
    }
    // check force audibility flag and camera restriction
    if (((mAttributes.getAllFlags() & AudioAttributes.FLAG_AUDIBILITY_ENFORCED) != 0) && (mAttributes.getUsage() == AudioAttributes.USAGE_ASSISTANCE_SONIFICATION)) {
        boolean cameraSoundForced = false;
        try {
            cameraSoundForced = getService().isCameraSoundForced();
        } catch (RemoteException e) {
            Log.e(TAG, "Cannot access AudioService in isRestricted_sync()");
        } catch (NullPointerException e) {
            Log.e(TAG, "Null AudioService in isRestricted_sync()");
        }
        if (cameraSoundForced) {
            return false;
        }
    }
    return true;
}
------------------------
Find a silently evolved API code:android.media.session.MediaController.setVolumeTo:COMMENT
Method Modifier: public      
Comment:/**
 * Set the volume of the output this session is playing on. The command will
 * be ignored if it does not support
 * {@link VolumeProvider#VOLUME_CONTROL_ABSOLUTE}. The flags in
 * {@link AudioManager} may be used to affect the handling.
 *
 * @see #getPlaybackInfo()
 * @param value The value to set it to, between 0 and the reported max.
 * @param flags Flags from {@link AudioManager} to include with the volume
 * request.
 */

Body of Frist Method:
{
    try {
        mSessionBinder.setVolumeTo(mContext.getPackageName(), mCbStub, value, flags);
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling setVolumeTo.", e);
    }
}
Body of Second Method:
{
    try {
        // Note: Need both package name and OP package name. Package name is used for
        // RemoteUserInfo, and OP package name is used for AudioService's internal
        // AppOpsManager usages.
        mSessionBinder.setVolumeTo(mContext.getPackageName(), mContext.getOpPackageName(), mCbStub, value, flags);
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling setVolumeTo.", e);
    }
}
------------------------
Find a silently evolved API code:android.util.Xml.newPullParser:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns a new pull parser with namespace support.
 */

Body of Frist Method:
{
    try {
        KXmlParser parser = new KXmlParser();
        parser.setFeature(XmlPullParser.FEATURE_PROCESS_DOCDECL, true);
        parser.setFeature(XmlPullParser.FEATURE_PROCESS_NAMESPACES, true);
        return parser;
    } catch (XmlPullParserException e) {
        throw new AssertionError();
    }
}
Body of Second Method:
{
    try {
        XmlPullParser parser = XmlObjectFactory.newXmlPullParser();
        parser.setFeature(XmlPullParser.FEATURE_PROCESS_DOCDECL, true);
        parser.setFeature(XmlPullParser.FEATURE_PROCESS_NAMESPACES, true);
        return parser;
    } catch (XmlPullParserException e) {
        throw new AssertionError();
    }
}
------------------------
Find a silently evolved API code:android.view.WindowInsets.getStableInsetTop:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the top stable inset in pixels.
 *
 * <p>The stable inset represents the area of a full-screen window that <b>may</b> be
 * partially or fully obscured by the system UI elements.  This value does not change
 * based on the visibility state of those elements; for example, if the status bar is
 * normally shown, but temporarily hidden, the stable inset will still provide the inset
 * associated with the status bar being shown.</p>
 *
 * @return The top stable inset
 */

Body of Frist Method:
{
    return mStableInsets.top;
}
Body of Second Method:
{
    return getStableInsets().top;
}
------------------------
Find a silently evolved API code:android.widget.RelativeLayout.DependencyGraph.findRoots:COMMENT
Method Modifier: private     
Comment:/**
 * Finds the roots of the graph. A root is a node with no dependency and
 * with [0..n] dependents.
 *
 * @param rulesFilter The list of rules to consider when building the
 * dependencies
 *
 * @return A list of node, each being a root of the graph
 */

Body of Frist Method:
{
    final SparseArray<Node> keyNodes = mKeyNodes;
    final ArrayList<Node> nodes = mNodes;
    final int count = nodes.size();
    // all dependents and dependencies before running the algorithm
    for (int i = 0; i < count; i++) {
        final Node node = nodes.get(i);
        node.dependents.clear();
        node.dependencies.clear();
    }
    // Builds up the dependents and dependencies for each node of the graph
    for (int i = 0; i < count; i++) {
        final Node node = nodes.get(i);
        final LayoutParams layoutParams = (LayoutParams) node.view.getLayoutParams();
        final int[] rules = layoutParams.mRules;
        final int rulesCount = rulesFilter.length;
        // dependencies for a specific set of rules
        for (int j = 0; j < rulesCount; j++) {
            final int rule = rules[rulesFilter[j]];
            if (rule > 0) {
                // The node this node depends on
                final Node dependency = keyNodes.get(rule);
                // Skip unknowns and self dependencies
                if (dependency == null || dependency == node) {
                    continue;
                }
                // Add the current node as a dependent
                dependency.dependents.put(node, this);
                // Add a dependency to the current node
                node.dependencies.put(rule, dependency);
            }
        }
    }
    final ArrayDeque<Node> roots = mRoots;
    roots.clear();
    // Finds all the roots in the graph: all nodes with no dependencies
    for (int i = 0; i < count; i++) {
        final Node node = nodes.get(i);
        if (node.dependencies.size() == 0)
            roots.addLast(node);
    }
    return roots;
}
Body of Second Method:
{
    final SparseArray<Node> keyNodes = mKeyNodes;
    final ArrayList<Node> nodes = mNodes;
    final int count = nodes.size();
    // all dependents and dependencies before running the algorithm
    for (int i = 0; i < count; i++) {
        final Node node = nodes.get(i);
        node.dependents.clear();
        node.dependencies.clear();
    }
    // Builds up the dependents and dependencies for each node of the graph
    for (int i = 0; i < count; i++) {
        final Node node = nodes.get(i);
        final LayoutParams layoutParams = (LayoutParams) node.view.getLayoutParams();
        final int[] rules = layoutParams.mRules;
        final int rulesCount = rulesFilter.length;
        // dependencies for a specific set of rules
        for (int j = 0; j < rulesCount; j++) {
            final int rule = rules[rulesFilter[j]];
            if (rule > 0 || ResourceId.isValid(rule)) {
                // The node this node depends on
                final Node dependency = keyNodes.get(rule);
                // Skip unknowns and self dependencies
                if (dependency == null || dependency == node) {
                    continue;
                }
                // Add the current node as a dependent
                dependency.dependents.put(node, this);
                // Add a dependency to the current node
                node.dependencies.put(rule, dependency);
            }
        }
    }
    final ArrayDeque<Node> roots = mRoots;
    roots.clear();
    // Finds all the roots in the graph: all nodes with no dependencies
    for (int i = 0; i < count; i++) {
        final Node node = nodes.get(i);
        if (node.dependencies.size() == 0)
            roots.addLast(node);
    }
    return roots;
}
------------------------
Find a silently evolved API code:android.os.Looper.writeToProto:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    final long looperToken = proto.start(fieldId);
    proto.write(LooperProto.THREAD_NAME, mThread.getName());
    proto.write(LooperProto.THREAD_ID, mThread.getId());
    mQueue.writeToProto(proto, LooperProto.QUEUE);
    proto.end(looperToken);
}
Body of Second Method:
{
    final long looperToken = proto.start(fieldId);
    proto.write(LooperProto.THREAD_NAME, mThread.getName());
    proto.write(LooperProto.THREAD_ID, mThread.getId());
    if (mQueue != null) {
        mQueue.writeToProto(proto, LooperProto.QUEUE);
    }
    proto.end(looperToken);
}
------------------------
Find a silently evolved API code:android.net.wifi.p2p.WifiP2pManager.requestPeers:COMMENT
Method Modifier: public      
Comment:/**
 * Request the current list of peers.
 *
 * @param c is the channel created at {@link #initialize}
 * @param listener for callback when peer list is available. Can be null.
 */

Body of Frist Method:
{
    checkChannel(c);
    Bundle callingPackage = new Bundle();
    callingPackage.putString(CALLING_PACKAGE, c.mContext.getOpPackageName());
    c.mAsyncChannel.sendMessage(REQUEST_PEERS, 0, c.putListener(listener), callingPackage);
}
Body of Second Method:
{
    checkChannel(c);
    c.mAsyncChannel.sendMessage(REQUEST_PEERS, 0, c.putListener(listener));
}
------------------------
Find a silently evolved API code:android.telephony.ims.feature.MmTelFeature.notifyIncomingCall:COMMENT
Method Modifier: public      final       hidden      
Comment:/**
 * Notify the framework of an incoming call.
 * @param c The {@link ImsCallSessionImplBase} of the new incoming call.
 */

Body of Frist Method:
{
    synchronized (mLock) {
        if (mListener == null) {
            throw new IllegalStateException("Session is not available.");
        }
        try {
            mListener.onIncomingCall(c.getServiceImpl(), extras);
        } catch (RemoteException e) {
            throw new RuntimeException(e);
        }
    }
}
Body of Second Method:
{
    if (c == null || extras == null) {
        throw new IllegalArgumentException("ImsCallSessionImplBase and Bundle can not be " + "null.");
    }
    synchronized (mLock) {
        if (mListener == null) {
            throw new IllegalStateException("Session is not available.");
        }
        try {
            mListener.onIncomingCall(c.getServiceImpl(), extras);
        } catch (RemoteException e) {
            throw new RuntimeException(e);
        }
    }
}
------------------------
Find a silently evolved API code:android.app.usage.UsageEvents.writeEventToParcel:COMMENT
Method Modifier: private     
Comment:/**
 * Writes a single event to the parcel. Modify this when updating {@link Event}.
 */

Body of Frist Method:
{
    final int packageIndex;
    if (event.mPackage != null) {
        packageIndex = findStringIndex(event.mPackage);
    } else {
        packageIndex = -1;
    }
    final int classIndex;
    if (event.mClass != null) {
        classIndex = findStringIndex(event.mClass);
    } else {
        classIndex = -1;
    }
    p.writeInt(packageIndex);
    p.writeInt(classIndex);
    p.writeInt(event.mEventType);
    p.writeLong(event.mTimeStamp);
    switch(event.mEventType) {
        case Event.CONFIGURATION_CHANGE:
            event.mConfiguration.writeToParcel(p, flags);
            break;
        case Event.SHORTCUT_INVOCATION:
            p.writeString(event.mShortcutId);
            break;
        case Event.CHOOSER_ACTION:
            p.writeString(event.mAction);
            p.writeString(event.mContentType);
            p.writeStringArray(event.mContentAnnotations);
            break;
        case Event.STANDBY_BUCKET_CHANGED:
            p.writeInt(event.mBucketAndReason);
            break;
        case Event.NOTIFICATION_INTERRUPTION:
            p.writeString(event.mNotificationChannelId);
            break;
    }
}
Body of Second Method:
{
    final int packageIndex;
    if (event.mPackage != null) {
        packageIndex = findStringIndex(event.mPackage);
    } else {
        packageIndex = -1;
    }
    final int classIndex;
    if (event.mClass != null) {
        classIndex = findStringIndex(event.mClass);
    } else {
        classIndex = -1;
    }
    final int taskRootPackageIndex;
    if (mIncludeTaskRoots && event.mTaskRootPackage != null) {
        taskRootPackageIndex = findStringIndex(event.mTaskRootPackage);
    } else {
        taskRootPackageIndex = -1;
    }
    final int taskRootClassIndex;
    if (mIncludeTaskRoots && event.mTaskRootClass != null) {
        taskRootClassIndex = findStringIndex(event.mTaskRootClass);
    } else {
        taskRootClassIndex = -1;
    }
    p.writeInt(packageIndex);
    p.writeInt(classIndex);
    p.writeInt(event.mInstanceId);
    p.writeInt(taskRootPackageIndex);
    p.writeInt(taskRootClassIndex);
    p.writeInt(event.mEventType);
    p.writeLong(event.mTimeStamp);
    switch(event.mEventType) {
        case Event.CONFIGURATION_CHANGE:
            event.mConfiguration.writeToParcel(p, flags);
            break;
        case Event.SHORTCUT_INVOCATION:
            p.writeString(event.mShortcutId);
            break;
        case Event.CHOOSER_ACTION:
            p.writeString(event.mAction);
            p.writeString(event.mContentType);
            p.writeStringArray(event.mContentAnnotations);
            break;
        case Event.STANDBY_BUCKET_CHANGED:
            p.writeInt(event.mBucketAndReason);
            break;
        case Event.NOTIFICATION_INTERRUPTION:
            p.writeString(event.mNotificationChannelId);
            break;
    }
    p.writeInt(event.mFlags);
}
------------------------
Find a silently evolved API code:android.telephony.CellSignalStrengthCdma.toString:COMMENT
Method Modifier: public      
Comment:/**
 * @return string representation.
 */

Body of Frist Method:
{
    return "CellSignalStrengthCdma:" + " cdmaDbm=" + mCdmaDbm + " cdmaEcio=" + mCdmaEcio + " evdoDbm=" + mEvdoDbm + " evdoEcio=" + mEvdoEcio + " evdoSnr=" + mEvdoSnr;
}
Body of Second Method:
{
    return "CellSignalStrengthCdma:" + " cdmaDbm=" + mCdmaDbm + " cdmaEcio=" + mCdmaEcio + " evdoDbm=" + mEvdoDbm + " evdoEcio=" + mEvdoEcio + " evdoSnr=" + mEvdoSnr + " level=" + mLevel;
}
------------------------
Find a silently evolved API code:android.telephony.euicc.EuiccManager.deleteSubscription:COMMENT
Method Modifier: public      
Comment:/**
 * Deletes the given subscription.
 *
 * <p>If this subscription is currently active, the device will first switch away from it onto
 * an "empty" subscription.
 *
 * <p>Requires that the calling app has carrier privileges according to the metadata of the
 * profile to be deleted, or the
 * {@code android.Manifest.permission#WRITE_EMBEDDED_SUBSCRIPTIONS} permission.
 *
 * @param subscriptionId the ID of the subscription to delete.
 * @param callbackIntent a PendingIntent to launch when the operation completes.
 */

Body of Frist Method:
{
    if (!isEnabled()) {
        sendUnavailableError(callbackIntent);
        return;
    }
    try {
        getIEuiccController().deleteSubscription(subscriptionId, mContext.getOpPackageName(), callbackIntent);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    if (!isEnabled()) {
        sendUnavailableError(callbackIntent);
        return;
    }
    try {
        getIEuiccController().deleteSubscription(mCardId, subscriptionId, mContext.getOpPackageName(), callbackIntent);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.p2p.WifiP2pConfig.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Implement the Parcelable interface
 */

Body of Frist Method:
{
    dest.writeString(deviceAddress);
    dest.writeParcelable(wps, flags);
    dest.writeInt(groupOwnerIntent);
    dest.writeInt(netId);
}
Body of Second Method:
{
    dest.writeString(deviceAddress);
    dest.writeParcelable(wps, flags);
    dest.writeInt(groupOwnerIntent);
    dest.writeInt(netId);
    dest.writeString(networkName);
    dest.writeString(passphrase);
    dest.writeInt(groupOwnerBand);
}
------------------------
Find a silently evolved API code:android.nfc.NfcAdapter.disableForegroundNdefPush:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * Disable NDEF message push over P2P.
 *
 * <p>After calling {@link #enableForegroundNdefPush}, an activity
 * must call this method before its {@link Activity#onPause} callback
 * completes.
 *
 * <p>Strongly recommend to use the new {@link #setNdefPushMessage}
 * instead: it automatically hooks into your activity life-cycle,
 * so you do not need to call enable/disable in your onResume/onPause.
 *
 * <p>This method must be called from the main thread.
 *
 * <p class="note">Requires the {@link android.Manifest.permission#NFC} permission.
 *
 * @param activity the Foreground activity
 * @throws IllegalStateException if the Activity has already been paused
 * @throws UnsupportedOperationException if FEATURE_NFC is unavailable.
 * @deprecated use {@link #setNdefPushMessage} instead
 */

Body of Frist Method:
{
    synchronized (NfcAdapter.class) {
        if (!sHasNfcFeature) {
            throw new UnsupportedOperationException();
        }
    }
    if (activity == null) {
        throw new NullPointerException();
    }
    enforceResumed(activity);
    mNfcActivityManager.setNdefPushMessage(activity, null, 0);
    mNfcActivityManager.setNdefPushMessageCallback(activity, null, 0);
    mNfcActivityManager.setOnNdefPushCompleteCallback(activity, null);
}
Body of Second Method:
{
    synchronized (NfcAdapter.class) {
        if (!sHasNfcFeature) {
            throw new UnsupportedOperationException();
        }
        if (!sHasBeamFeature) {
            return;
        }
    }
    if (activity == null) {
        throw new NullPointerException();
    }
    enforceResumed(activity);
    mNfcActivityManager.setNdefPushMessage(activity, null, 0);
    mNfcActivityManager.setNdefPushMessageCallback(activity, null, 0);
    mNfcActivityManager.setOnNdefPushCompleteCallback(activity, null);
}
------------------------
Find a silently evolved API code:android.graphics.drawable.LayerDrawable.isProjected:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (super.isProjected()) {
        return true;
    }
    final ChildDrawable[] layers = mLayerState.mChildren;
    final int N = mLayerState.mNumChildren;
    for (int i = 0; i < N; i++) {
        if (layers[i].mDrawable.isProjected()) {
            return true;
        }
    }
    return false;
}
Body of Second Method:
{
    if (super.isProjected()) {
        return true;
    }
    final ChildDrawable[] layers = mLayerState.mChildren;
    final int N = mLayerState.mNumChildren;
    for (int i = 0; i < N; i++) {
        Drawable childDrawable = layers[i].mDrawable;
        if (childDrawable != null && childDrawable.isProjected()) {
            return true;
        }
    }
    return false;
}
------------------------
Find a silently evolved API code:android.net.IpPrefix.getAddress:COMMENT
Method Modifier: public      
Comment:/**
 * Returns a copy of the first IP address in the prefix. Modifying the returned object does not
 * change this object's contents.
 *
 * @return the address in the form of a byte array.
 */

Body of Frist Method:
{
    try {
        return InetAddress.getByAddress(address);
    } catch (UnknownHostException e) {
        // array is the wrong length, but we check that in the constructor.
        return null;
    }
}
Body of Second Method:
{
    try {
        return InetAddress.getByAddress(address);
    } catch (UnknownHostException e) {
        // array is the wrong length, but we check that in the constructor.
        throw new IllegalArgumentException("Address is invalid");
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHidHost.sendData:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Send Send_Data command to the connected HID input device.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN} permission.
 *
 * @param device Remote Bluetooth Device
 * @param report Report to send
 * @return false on immediate error, true otherwise
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("sendData(" + device + "), report=" + report);
    final IBluetoothHidHost service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.sendData(device, report);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("sendData(" + device + "), report=" + report);
    final IBluetoothHidHost service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.sendData(device, report);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.media.AudioFormat.isPublicEncoding:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    switch(audioFormat) {
        case ENCODING_PCM_8BIT:
        case ENCODING_PCM_16BIT:
        case ENCODING_PCM_FLOAT:
        case ENCODING_AC3:
        case ENCODING_E_AC3:
        case ENCODING_E_AC3_JOC:
        case ENCODING_DTS:
        case ENCODING_DTS_HD:
        case ENCODING_IEC61937:
        case ENCODING_MP3:
        case ENCODING_AAC_LC:
        case ENCODING_AAC_HE_V1:
        case ENCODING_AAC_HE_V2:
        case ENCODING_AAC_ELD:
        case ENCODING_AAC_XHE:
        case ENCODING_AC4:
            return true;
        default:
            return false;
    }
}
Body of Second Method:
{
    switch(audioFormat) {
        case ENCODING_PCM_16BIT:
        case ENCODING_PCM_8BIT:
        case ENCODING_PCM_FLOAT:
        case ENCODING_AC3:
        case ENCODING_E_AC3:
        case ENCODING_DTS:
        case ENCODING_DTS_HD:
        case ENCODING_MP3:
        case ENCODING_AAC_LC:
        case ENCODING_AAC_HE_V1:
        case ENCODING_AAC_HE_V2:
        case ENCODING_IEC61937:
        case ENCODING_DOLBY_TRUEHD:
        case ENCODING_AAC_ELD:
        case ENCODING_AAC_XHE:
        case ENCODING_AC4:
        case ENCODING_E_AC3_JOC:
        case ENCODING_DOLBY_MAT:
            return true;
        default:
            return false;
    }
}
------------------------
Find a silently evolved API code:android.hardware.camera2.params.StreamConfigurationMap.getPublicFormatCount:COMMENT
Method Modifier: private     
Comment:/**
 * Count the number of publicly-visible output formats
 */

Body of Frist Method:
{
    SparseIntArray formatsMap = getFormatsMap(output);
    int size = formatsMap.size();
    if (output) {
        size += mDepthOutputFormats.size();
    }
    return size;
}
Body of Second Method:
{
    SparseIntArray formatsMap = getFormatsMap(output);
    int size = formatsMap.size();
    if (output) {
        size += mDepthOutputFormats.size();
        size += mDynamicDepthOutputFormats.size();
        size += mHeicOutputFormats.size();
    }
    return size;
}
------------------------
Find a silently evolved API code:android.app.servertransaction.TransactionExecutor.executeLifecycleState:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Transition to the final state if requested by the transaction.
 */

Body of Frist Method:
{
    final ActivityLifecycleItem lifecycleItem = transaction.getLifecycleStateRequest();
    if (lifecycleItem == null) {
        // No lifecycle request, return early.
        return;
    }
    log("Resolving lifecycle state: " + lifecycleItem);
    final IBinder token = transaction.getActivityToken();
    final ActivityClientRecord r = mTransactionHandler.getActivityClient(token);
    if (r == null) {
        // Ignore requests for non-existent client records for now.
        return;
    }
    // Cycle to the state right before the final requested state.
    cycleToPath(r, lifecycleItem.getTargetState(), true);
    // Execute the final transition with proper parameters.
    lifecycleItem.execute(mTransactionHandler, token, mPendingActions);
    lifecycleItem.postExecute(mTransactionHandler, token, mPendingActions);
}
Body of Second Method:
{
    final ActivityLifecycleItem lifecycleItem = transaction.getLifecycleStateRequest();
    if (lifecycleItem == null) {
        // No lifecycle request, return early.
        return;
    }
    final IBinder token = transaction.getActivityToken();
    final ActivityClientRecord r = mTransactionHandler.getActivityClient(token);
    if (DEBUG_RESOLVER) {
        Slog.d(TAG, tId(transaction) + "Resolving lifecycle state: " + lifecycleItem + " for activity: " + getShortActivityName(token, mTransactionHandler));
    }
    if (r == null) {
        // Ignore requests for non-existent client records for now.
        return;
    }
    // Cycle to the state right before the final requested state.
    cycleToPath(r, lifecycleItem.getTargetState(), true, /* excludeLastState */
    transaction);
    // Execute the final transition with proper parameters.
    lifecycleItem.execute(mTransactionHandler, token, mPendingActions);
    lifecycleItem.postExecute(mTransactionHandler, token, mPendingActions);
}
------------------------
Find a silently evolved API code:android.content.UriMatcher.addURI:COMMENT
Method Modifier: public      
Comment:/**
 * Add a URI to match, and the code to return when this URI is
 * matched. URI nodes may be exact match string, the token "*"
 * that matches any text, or the token "#" that matches only
 * numbers.
 * <p>
 * Starting from API level {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2},
 * this method will accept a leading slash in the path.
 *
 * @param authority the authority to match
 * @param path the path to match. * may be used as a wild card for
 * any text, and # may be used as a wild card for numbers.
 * @param code the code that is returned when a URI is matched
 * against the given components. Must be positive.
 */

Body of Frist Method:
{
    if (code < 0) {
        throw new IllegalArgumentException("code " + code + " is invalid: it must be positive");
    }
    String[] tokens = null;
    if (path != null) {
        String newPath = path;
        // Strip leading slash if present.
        if (path.length() > 1 && path.charAt(0) == '/') {
            newPath = path.substring(1);
        }
        tokens = newPath.split("/");
    }
    int numTokens = tokens != null ? tokens.length : 0;
    UriMatcher node = this;
    for (int i = -1; i < numTokens; i++) {
        String token = i < 0 ? authority : tokens[i];
        ArrayList<UriMatcher> children = node.mChildren;
        int numChildren = children.size();
        UriMatcher child;
        int j;
        for (j = 0; j < numChildren; j++) {
            child = children.get(j);
            if (token.equals(child.mText)) {
                node = child;
                break;
            }
        }
        if (j == numChildren) {
            // Child not found, create it
            child = new UriMatcher();
            if (token.equals("#")) {
                child.mWhich = NUMBER;
            } else if (token.equals("*")) {
                child.mWhich = TEXT;
            } else {
                child.mWhich = EXACT;
            }
            child.mText = token;
            node.mChildren.add(child);
            node = child;
        }
    }
    node.mCode = code;
}
Body of Second Method:
{
    if (code < 0) {
        throw new IllegalArgumentException("code " + code + " is invalid: it must be positive");
    }
    String[] tokens = null;
    if (path != null) {
        String newPath = path;
        // Strip leading slash if present.
        if (path.length() > 1 && path.charAt(0) == '/') {
            newPath = path.substring(1);
        }
        tokens = newPath.split("/");
    }
    int numTokens = tokens != null ? tokens.length : 0;
    UriMatcher node = this;
    for (int i = -1; i < numTokens; i++) {
        String token = i < 0 ? authority : tokens[i];
        ArrayList<UriMatcher> children = node.mChildren;
        int numChildren = children.size();
        UriMatcher child;
        int j;
        for (j = 0; j < numChildren; j++) {
            child = children.get(j);
            if (token.equals(child.mText)) {
                node = child;
                break;
            }
        }
        if (j == numChildren) {
            // Child not found, create it
            child = createChild(token);
            node.mChildren.add(child);
            node = child;
        }
    }
    node.mCode = code;
}
------------------------
Find a silently evolved API code:android.service.notification.ConditionProviderService.isBound:COMMENT
<android.service.notification.ConditionProviderService: boolean isBound()>
public      hidden      ->public      hidden      deprecated  
Method Modifier: public      hidden      deprecated  
Method Modifier: Yes         Yes         No          
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (mProvider == null) {
        Log.w(TAG, "Condition provider service not yet bound.");
        return false;
    }
    return true;
}
Body of Second Method:
{
    if (!mIsConnected) {
        Log.w(TAG, "Condition provider service not yet bound.");
    }
    return mIsConnected;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.rejectCall:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Rejects a call.
 *
 * @param device remote device
 * @return <code>true</code> if command has been issued successfully; <code>false</code>
 * otherwise; upon completion HFP sends {@link #ACTION_CALL_CHANGED} intent.
 *
 * <p>Feature required for successful execution is being reported by: {@link
 * #EXTRA_AG_FEATURE_REJECT_CALL}. This method invocation will fail silently when feature is not
 * supported.</p>
 */

Body of Frist Method:
{
    if (DBG)
        log("rejectCall()");
    final IBluetoothHeadsetClient service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.rejectCall(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("rejectCall()");
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.rejectCall(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.content.ContentProviderOperation.apply:COMMENT
Method Modifier: public      
Comment:/**
 * Applies this operation using the given provider. The backRefs array is used to resolve any
 * back references that were requested using
 * {@link Builder#withValueBackReferences(ContentValues)} and
 * {@link Builder#withSelectionBackReference}.
 * @param provider the {@link ContentProvider} on which this batch is applied
 * @param backRefs a {@link ContentProviderResult} array that will be consulted
 * to resolve any requested back references.
 * @param numBackRefs the number of valid results on the backRefs array.
 * @return a {@link ContentProviderResult} that contains either the {@link Uri} of the inserted
 * row if this was an insert otherwise the number of rows affected.
 * @throws OperationApplicationException thrown if either the insert fails or
 * if the number of rows affected didn't match the expected count
 */

Body of Frist Method:
{
    ContentValues values = resolveValueBackReferences(backRefs, numBackRefs);
    String[] selectionArgs = resolveSelectionArgsBackReferences(backRefs, numBackRefs);
    if (mType == TYPE_INSERT) {
        Uri newUri = provider.insert(mUri, values);
        if (newUri == null) {
            throw new OperationApplicationException("insert failed");
        }
        return new ContentProviderResult(newUri);
    }
    int numRows;
    if (mType == TYPE_DELETE) {
        numRows = provider.delete(mUri, mSelection, selectionArgs);
    } else if (mType == TYPE_UPDATE) {
        numRows = provider.update(mUri, values, mSelection, selectionArgs);
    } else if (mType == TYPE_ASSERT) {
        // Assert that all rows match expected values
        String[] projection = null;
        if (values != null) {
            // Build projection map from expected values
            final ArrayList<String> projectionList = new ArrayList<String>();
            for (Map.Entry<String, Object> entry : values.valueSet()) {
                projectionList.add(entry.getKey());
            }
            projection = projectionList.toArray(new String[projectionList.size()]);
        }
        final Cursor cursor = provider.query(mUri, projection, mSelection, selectionArgs, null);
        try {
            numRows = cursor.getCount();
            if (projection != null) {
                while (cursor.moveToNext()) {
                    for (int i = 0; i < projection.length; i++) {
                        final String cursorValue = cursor.getString(i);
                        final String expectedValue = values.getAsString(projection[i]);
                        if (!TextUtils.equals(cursorValue, expectedValue)) {
                            // Throw exception when expected values don't match
                            Log.e(TAG, this.toString());
                            throw new OperationApplicationException("Found value " + cursorValue + " when expected " + expectedValue + " for column " + projection[i]);
                        }
                    }
                }
            }
        } finally {
            cursor.close();
        }
    } else {
        Log.e(TAG, this.toString());
        throw new IllegalStateException("bad type, " + mType);
    }
    if (mExpectedCount != null && mExpectedCount != numRows) {
        Log.e(TAG, this.toString());
        throw new OperationApplicationException("wrong number of rows: " + numRows);
    }
    return new ContentProviderResult(numRows);
}
Body of Second Method:
{
    if (mFailureAllowed) {
        try {
            return applyInternal(provider, backRefs, numBackRefs);
        } catch (Exception e) {
            return new ContentProviderResult(e.getMessage());
        }
    } else {
        return applyInternal(provider, backRefs, numBackRefs);
    }
}
------------------------
Find a silently evolved API code:android.media.audiopolicy.AudioMix.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Combines all of the settings and return a new {@link AudioMix} object.
 * @return a new {@link AudioMix} object
 * @throws IllegalArgumentException if no {@link AudioMixingRule} has been set.
 */

Body of Frist Method:
{
    if (mRule == null) {
        throw new IllegalArgumentException("Illegal null AudioMixingRule");
    }
    if (mRouteFlags == 0) {
        // no route flags set, use default as described in Builder.setRouteFlags(int)
        mRouteFlags = ROUTE_FLAG_LOOP_BACK;
    }
    // can't do loop back AND render at same time in this implementation
    if (mRouteFlags == (ROUTE_FLAG_RENDER | ROUTE_FLAG_LOOP_BACK)) {
        throw new IllegalArgumentException("Unsupported route behavior combination 0x" + Integer.toHexString(mRouteFlags));
    }
    if (mFormat == null) {
        // FIXME Can we eliminate this?  Will AudioMix work with an unspecified sample rate?
        int rate = AudioSystem.getPrimaryOutputSamplingRate();
        if (rate <= 0) {
            rate = 44100;
        }
        mFormat = new AudioFormat.Builder().setSampleRate(rate).build();
    }
    if ((mDeviceSystemType != AudioSystem.DEVICE_NONE) && (mDeviceSystemType != AudioSystem.DEVICE_OUT_REMOTE_SUBMIX) && (mDeviceSystemType != AudioSystem.DEVICE_IN_REMOTE_SUBMIX)) {
        if ((mRouteFlags & ROUTE_FLAG_RENDER) == 0) {
            throw new IllegalArgumentException("Can't have audio device without flag ROUTE_FLAG_RENDER");
        }
        if (mRule.getTargetMixType() != AudioMix.MIX_TYPE_PLAYERS) {
            throw new IllegalArgumentException("Unsupported device on non-playback mix");
        }
    } else {
        if ((mRouteFlags & ROUTE_FLAG_RENDER) == ROUTE_FLAG_RENDER) {
            throw new IllegalArgumentException("Can't have flag ROUTE_FLAG_RENDER without an audio device");
        }
        if ((mRouteFlags & ROUTE_FLAG_SUPPORTED) == ROUTE_FLAG_LOOP_BACK) {
            if (mRule.getTargetMixType() == MIX_TYPE_PLAYERS) {
                mDeviceSystemType = AudioSystem.DEVICE_OUT_REMOTE_SUBMIX;
            } else if (mRule.getTargetMixType() == MIX_TYPE_RECORDERS) {
                mDeviceSystemType = AudioSystem.DEVICE_IN_REMOTE_SUBMIX;
            } else {
                throw new IllegalArgumentException("Unknown mixing rule type");
            }
        }
    }
    return new AudioMix(mRule, mFormat, mRouteFlags, mCallbackFlags, mDeviceSystemType, mDeviceAddress);
}
Body of Second Method:
{
    if (mRule == null) {
        throw new IllegalArgumentException("Illegal null AudioMixingRule");
    }
    if (mRouteFlags == 0) {
        // no route flags set, use default as described in Builder.setRouteFlags(int)
        mRouteFlags = ROUTE_FLAG_LOOP_BACK;
    }
    if (mFormat == null) {
        // FIXME Can we eliminate this?  Will AudioMix work with an unspecified sample rate?
        int rate = AudioSystem.getPrimaryOutputSamplingRate();
        if (rate <= 0) {
            rate = 44100;
        }
        mFormat = new AudioFormat.Builder().setSampleRate(rate).build();
    }
    if ((mDeviceSystemType != AudioSystem.DEVICE_NONE) && (mDeviceSystemType != AudioSystem.DEVICE_OUT_REMOTE_SUBMIX) && (mDeviceSystemType != AudioSystem.DEVICE_IN_REMOTE_SUBMIX)) {
        if ((mRouteFlags & ROUTE_FLAG_RENDER) == 0) {
            throw new IllegalArgumentException("Can't have audio device without flag ROUTE_FLAG_RENDER");
        }
        if (mRule.getTargetMixType() != AudioMix.MIX_TYPE_PLAYERS) {
            throw new IllegalArgumentException("Unsupported device on non-playback mix");
        }
    } else {
        if ((mRouteFlags & ROUTE_FLAG_SUPPORTED) == ROUTE_FLAG_RENDER) {
            throw new IllegalArgumentException("Can't have flag ROUTE_FLAG_RENDER without an audio device");
        }
        if ((mRouteFlags & ROUTE_FLAG_LOOP_BACK) == ROUTE_FLAG_LOOP_BACK) {
            if (mRule.getTargetMixType() == MIX_TYPE_PLAYERS) {
                mDeviceSystemType = AudioSystem.DEVICE_OUT_REMOTE_SUBMIX;
            } else if (mRule.getTargetMixType() == MIX_TYPE_RECORDERS) {
                mDeviceSystemType = AudioSystem.DEVICE_IN_REMOTE_SUBMIX;
            } else {
                throw new IllegalArgumentException("Unknown mixing rule type");
            }
        }
    }
    if (mRule.allowPrivilegedPlaybackCapture()) {
        String error = AudioMix.canBeUsedForPrivilegedCapture(mFormat);
        if (error != null) {
            throw new IllegalArgumentException(error);
        }
    }
    return new AudioMix(mRule, mFormat, mRouteFlags, mCallbackFlags, mDeviceSystemType, mDeviceAddress);
}
------------------------
Find a silently evolved API code:android.hardware.camera2.params.StreamConfigurationMap.equals:COMMENT
Method Modifier: public      
Comment:/**
 * Check if this {@link StreamConfigurationMap} is equal to another
 * {@link StreamConfigurationMap}.
 *
 * <p>Two vectors are only equal if and only if each of the respective elements is equal.</p>
 *
 * @return {@code true} if the objects were equal, {@code false} otherwise
 */

Body of Frist Method:
{
    if (obj == null) {
        return false;
    }
    if (this == obj) {
        return true;
    }
    if (obj instanceof StreamConfigurationMap) {
        final StreamConfigurationMap other = (StreamConfigurationMap) obj;
        // XX: do we care about order?
        return Arrays.equals(mConfigurations, other.mConfigurations) && Arrays.equals(mMinFrameDurations, other.mMinFrameDurations) && Arrays.equals(mStallDurations, other.mStallDurations) && Arrays.equals(mDepthConfigurations, other.mDepthConfigurations) && Arrays.equals(mHighSpeedVideoConfigurations, other.mHighSpeedVideoConfigurations);
    }
    return false;
}
Body of Second Method:
{
    if (obj == null) {
        return false;
    }
    if (this == obj) {
        return true;
    }
    if (obj instanceof StreamConfigurationMap) {
        final StreamConfigurationMap other = (StreamConfigurationMap) obj;
        // XX: do we care about order?
        return Arrays.equals(mConfigurations, other.mConfigurations) && Arrays.equals(mMinFrameDurations, other.mMinFrameDurations) && Arrays.equals(mStallDurations, other.mStallDurations) && Arrays.equals(mDepthConfigurations, other.mDepthConfigurations) && Arrays.equals(mDepthMinFrameDurations, other.mDepthMinFrameDurations) && Arrays.equals(mDepthStallDurations, other.mDepthStallDurations) && Arrays.equals(mDynamicDepthConfigurations, other.mDynamicDepthConfigurations) && Arrays.equals(mDynamicDepthMinFrameDurations, other.mDynamicDepthMinFrameDurations) && Arrays.equals(mDynamicDepthStallDurations, other.mDynamicDepthStallDurations) && Arrays.equals(mHeicConfigurations, other.mHeicConfigurations) && Arrays.equals(mHeicMinFrameDurations, other.mHeicMinFrameDurations) && Arrays.equals(mHeicStallDurations, other.mHeicStallDurations) && Arrays.equals(mHighSpeedVideoConfigurations, other.mHighSpeedVideoConfigurations);
    }
    return false;
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiScanner.stopScan:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * stops an ongoing single shot scan; only useful after {@link #startScan} if onResults()
 * hasn't been called on the listener, ignored otherwise
 * @param listener
 */

Body of Frist Method:
{
    Preconditions.checkNotNull(listener, "listener cannot be null");
    int key = removeListener(listener);
    if (key == INVALID_KEY)
        return;
    validateChannel();
    mAsyncChannel.sendMessage(CMD_STOP_SINGLE_SCAN, 0, key);
}
Body of Second Method:
{
    Preconditions.checkNotNull(listener, "listener cannot be null");
    int key = removeListener(listener);
    if (key == INVALID_KEY)
        return;
    validateChannel();
    Bundle scanParams = new Bundle();
    scanParams.putString(REQUEST_PACKAGE_NAME_KEY, mContext.getOpPackageName());
    mAsyncChannel.sendMessage(CMD_STOP_SINGLE_SCAN, 0, key, scanParams);
}
------------------------
Find a silently evolved API code:android.bluetooth.le.ScanFilter.matches:COMMENT
Method Modifier: public      
Comment:/**
 * Check if the scan filter matches a {@code scanResult}. A scan result is considered as a match
 * if it matches all the field filters.
 */

Body of Frist Method:
{
    if (scanResult == null) {
        return false;
    }
    BluetoothDevice device = scanResult.getDevice();
    // Device match.
    if (mDeviceAddress != null && (device == null || !mDeviceAddress.equals(device.getAddress()))) {
        return false;
    }
    ScanRecord scanRecord = scanResult.getScanRecord();
    // Scan record is null but there exist filters on it.
    if (scanRecord == null && (mDeviceName != null || mServiceUuid != null || mManufacturerData != null || mServiceData != null)) {
        return false;
    }
    // Local name match.
    if (mDeviceName != null && !mDeviceName.equals(scanRecord.getDeviceName())) {
        return false;
    }
    // UUID match.
    if (mServiceUuid != null && !matchesServiceUuids(mServiceUuid, mServiceUuidMask, scanRecord.getServiceUuids())) {
        return false;
    }
    // Service data match
    if (mServiceDataUuid != null) {
        if (!matchesPartialData(mServiceData, mServiceDataMask, scanRecord.getServiceData(mServiceDataUuid))) {
            return false;
        }
    }
    // Manufacturer data match.
    if (mManufacturerId >= 0) {
        if (!matchesPartialData(mManufacturerData, mManufacturerDataMask, scanRecord.getManufacturerSpecificData(mManufacturerId))) {
            return false;
        }
    }
    // All filters match.
    return true;
}
Body of Second Method:
{
    if (scanResult == null) {
        return false;
    }
    BluetoothDevice device = scanResult.getDevice();
    // Device match.
    if (mDeviceAddress != null && (device == null || !mDeviceAddress.equals(device.getAddress()))) {
        return false;
    }
    ScanRecord scanRecord = scanResult.getScanRecord();
    // Scan record is null but there exist filters on it.
    if (scanRecord == null && (mDeviceName != null || mServiceUuid != null || mManufacturerData != null || mServiceData != null || mServiceSolicitationUuid != null)) {
        return false;
    }
    // Local name match.
    if (mDeviceName != null && !mDeviceName.equals(scanRecord.getDeviceName())) {
        return false;
    }
    // UUID match.
    if (mServiceUuid != null && !matchesServiceUuids(mServiceUuid, mServiceUuidMask, scanRecord.getServiceUuids())) {
        return false;
    }
    // solicitation UUID match.
    if (mServiceSolicitationUuid != null && !matchesServiceSolicitationUuids(mServiceSolicitationUuid, mServiceSolicitationUuidMask, scanRecord.getServiceSolicitationUuids())) {
        return false;
    }
    // Service data match
    if (mServiceDataUuid != null) {
        if (!matchesPartialData(mServiceData, mServiceDataMask, scanRecord.getServiceData(mServiceDataUuid))) {
            return false;
        }
    }
    // Manufacturer data match.
    if (mManufacturerId >= 0) {
        if (!matchesPartialData(mManufacturerData, mManufacturerDataMask, scanRecord.getManufacturerSpecificData(mManufacturerId))) {
            return false;
        }
    }
    // All filters match.
    return true;
}
------------------------
Find a silently evolved API code:android.hardware.camera2.params.StreamConfigurationMap.getDurations:COMMENT
Method Modifier: private     
Comment:/**
 * Get the durations array for the kind of duration
 *
 * @see #DURATION_MIN_FRAME
 * @see #DURATION_STALL
 */

Body of Frist Method:
{
    switch(duration) {
        case DURATION_MIN_FRAME:
            return (dataspace == HAL_DATASPACE_DEPTH) ? mDepthMinFrameDurations : mMinFrameDurations;
        case DURATION_STALL:
            return (dataspace == HAL_DATASPACE_DEPTH) ? mDepthStallDurations : mStallDurations;
        default:
            throw new IllegalArgumentException("duration was invalid");
    }
}
Body of Second Method:
{
    switch(duration) {
        case DURATION_MIN_FRAME:
            return (dataspace == HAL_DATASPACE_DEPTH) ? mDepthMinFrameDurations : (dataspace == HAL_DATASPACE_DYNAMIC_DEPTH) ? mDynamicDepthMinFrameDurations : (dataspace == HAL_DATASPACE_HEIF) ? mHeicMinFrameDurations : mMinFrameDurations;
        case DURATION_STALL:
            return (dataspace == HAL_DATASPACE_DEPTH) ? mDepthStallDurations : (dataspace == HAL_DATASPACE_DYNAMIC_DEPTH) ? mDynamicDepthStallDurations : (dataspace == HAL_DATASPACE_HEIF) ? mHeicStallDurations : mStallDurations;
        default:
            throw new IllegalArgumentException("duration was invalid");
    }
}
------------------------
Find a silently evolved API code:android.content.ContentProviderClient.applyBatch:COMMENT
Method Modifier: public      
Comment:/**
 * See {@link ContentProvider#applyBatch ContentProvider.applyBatch}
 */

Body of Frist Method:
{
    Preconditions.checkNotNull(operations, "operations");
    beforeRemote();
    try {
        return mContentProvider.applyBatch(mPackageName, operations);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}
Body of Second Method:
{
    Preconditions.checkNotNull(operations, "operations");
    beforeRemote();
    try {
        return mContentProvider.applyBatch(mPackageName, authority, operations);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.le.ScanRecord.parseFromBytes:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Parse scan record bytes to {@link ScanRecord}.
 * <p>
 * The format is defined in Bluetooth 4.1 specification, Volume 3, Part C, Section 11 and 18.
 * <p>
 * All numerical multi-byte entities and values shall use little-endian <strong>byte</strong>
 * order.
 *
 * @param scanRecord The scan record of Bluetooth LE advertisement and/or scan response.
 * @hide
 */

Body of Frist Method:
{
    if (scanRecord == null) {
        return null;
    }
    int currentPos = 0;
    int advertiseFlag = -1;
    List<ParcelUuid> serviceUuids = new ArrayList<ParcelUuid>();
    String localName = null;
    int txPowerLevel = Integer.MIN_VALUE;
    SparseArray<byte[]> manufacturerData = new SparseArray<byte[]>();
    Map<ParcelUuid, byte[]> serviceData = new ArrayMap<ParcelUuid, byte[]>();
    try {
        while (currentPos < scanRecord.length) {
            // length is unsigned int.
            int length = scanRecord[currentPos++] & 0xFF;
            if (length == 0) {
                break;
            }
            // Note the length includes the length of the field type itself.
            int dataLength = length - 1;
            // fieldType is unsigned int.
            int fieldType = scanRecord[currentPos++] & 0xFF;
            switch(fieldType) {
                case DATA_TYPE_FLAGS:
                    advertiseFlag = scanRecord[currentPos] & 0xFF;
                    break;
                case DATA_TYPE_SERVICE_UUIDS_16_BIT_PARTIAL:
                case DATA_TYPE_SERVICE_UUIDS_16_BIT_COMPLETE:
                    parseServiceUuid(scanRecord, currentPos, dataLength, BluetoothUuid.UUID_BYTES_16_BIT, serviceUuids);
                    break;
                case DATA_TYPE_SERVICE_UUIDS_32_BIT_PARTIAL:
                case DATA_TYPE_SERVICE_UUIDS_32_BIT_COMPLETE:
                    parseServiceUuid(scanRecord, currentPos, dataLength, BluetoothUuid.UUID_BYTES_32_BIT, serviceUuids);
                    break;
                case DATA_TYPE_SERVICE_UUIDS_128_BIT_PARTIAL:
                case DATA_TYPE_SERVICE_UUIDS_128_BIT_COMPLETE:
                    parseServiceUuid(scanRecord, currentPos, dataLength, BluetoothUuid.UUID_BYTES_128_BIT, serviceUuids);
                    break;
                case DATA_TYPE_LOCAL_NAME_SHORT:
                case DATA_TYPE_LOCAL_NAME_COMPLETE:
                    localName = new String(extractBytes(scanRecord, currentPos, dataLength));
                    break;
                case DATA_TYPE_TX_POWER_LEVEL:
                    txPowerLevel = scanRecord[currentPos];
                    break;
                case DATA_TYPE_SERVICE_DATA_16_BIT:
                case DATA_TYPE_SERVICE_DATA_32_BIT:
                case DATA_TYPE_SERVICE_DATA_128_BIT:
                    int serviceUuidLength = BluetoothUuid.UUID_BYTES_16_BIT;
                    if (fieldType == DATA_TYPE_SERVICE_DATA_32_BIT) {
                        serviceUuidLength = BluetoothUuid.UUID_BYTES_32_BIT;
                    } else if (fieldType == DATA_TYPE_SERVICE_DATA_128_BIT) {
                        serviceUuidLength = BluetoothUuid.UUID_BYTES_128_BIT;
                    }
                    byte[] serviceDataUuidBytes = extractBytes(scanRecord, currentPos, serviceUuidLength);
                    ParcelUuid serviceDataUuid = BluetoothUuid.parseUuidFrom(serviceDataUuidBytes);
                    byte[] serviceDataArray = extractBytes(scanRecord, currentPos + serviceUuidLength, dataLength - serviceUuidLength);
                    serviceData.put(serviceDataUuid, serviceDataArray);
                    break;
                case DATA_TYPE_MANUFACTURER_SPECIFIC_DATA:
                    // The first two bytes of the manufacturer specific data are
                    // manufacturer ids in little endian.
                    int manufacturerId = ((scanRecord[currentPos + 1] & 0xFF) << 8) + (scanRecord[currentPos] & 0xFF);
                    byte[] manufacturerDataBytes = extractBytes(scanRecord, currentPos + 2, dataLength - 2);
                    manufacturerData.put(manufacturerId, manufacturerDataBytes);
                    break;
                default:
                    // Just ignore, we don't handle such data type.
                    break;
            }
            currentPos += dataLength;
        }
        if (serviceUuids.isEmpty()) {
            serviceUuids = null;
        }
        return new ScanRecord(serviceUuids, manufacturerData, serviceData, advertiseFlag, txPowerLevel, localName, scanRecord);
    } catch (Exception e) {
        Log.e(TAG, "unable to parse scan record: " + Arrays.toString(scanRecord));
        // and return an empty record with raw scanRecord bytes in results
        return new ScanRecord(null, null, null, -1, Integer.MIN_VALUE, null, scanRecord);
    }
}
Body of Second Method:
{
    if (scanRecord == null) {
        return null;
    }
    int currentPos = 0;
    int advertiseFlag = -1;
    List<ParcelUuid> serviceUuids = new ArrayList<ParcelUuid>();
    List<ParcelUuid> serviceSolicitationUuids = new ArrayList<ParcelUuid>();
    String localName = null;
    int txPowerLevel = Integer.MIN_VALUE;
    SparseArray<byte[]> manufacturerData = new SparseArray<byte[]>();
    Map<ParcelUuid, byte[]> serviceData = new ArrayMap<ParcelUuid, byte[]>();
    try {
        while (currentPos < scanRecord.length) {
            // length is unsigned int.
            int length = scanRecord[currentPos++] & 0xFF;
            if (length == 0) {
                break;
            }
            // Note the length includes the length of the field type itself.
            int dataLength = length - 1;
            // fieldType is unsigned int.
            int fieldType = scanRecord[currentPos++] & 0xFF;
            switch(fieldType) {
                case DATA_TYPE_FLAGS:
                    advertiseFlag = scanRecord[currentPos] & 0xFF;
                    break;
                case DATA_TYPE_SERVICE_UUIDS_16_BIT_PARTIAL:
                case DATA_TYPE_SERVICE_UUIDS_16_BIT_COMPLETE:
                    parseServiceUuid(scanRecord, currentPos, dataLength, BluetoothUuid.UUID_BYTES_16_BIT, serviceUuids);
                    break;
                case DATA_TYPE_SERVICE_UUIDS_32_BIT_PARTIAL:
                case DATA_TYPE_SERVICE_UUIDS_32_BIT_COMPLETE:
                    parseServiceUuid(scanRecord, currentPos, dataLength, BluetoothUuid.UUID_BYTES_32_BIT, serviceUuids);
                    break;
                case DATA_TYPE_SERVICE_UUIDS_128_BIT_PARTIAL:
                case DATA_TYPE_SERVICE_UUIDS_128_BIT_COMPLETE:
                    parseServiceUuid(scanRecord, currentPos, dataLength, BluetoothUuid.UUID_BYTES_128_BIT, serviceUuids);
                    break;
                case DATA_TYPE_SERVICE_SOLICITATION_UUIDS_16_BIT:
                    parseServiceSolicitationUuid(scanRecord, currentPos, dataLength, BluetoothUuid.UUID_BYTES_16_BIT, serviceSolicitationUuids);
                    break;
                case DATA_TYPE_SERVICE_SOLICITATION_UUIDS_32_BIT:
                    parseServiceSolicitationUuid(scanRecord, currentPos, dataLength, BluetoothUuid.UUID_BYTES_32_BIT, serviceSolicitationUuids);
                    break;
                case DATA_TYPE_SERVICE_SOLICITATION_UUIDS_128_BIT:
                    parseServiceSolicitationUuid(scanRecord, currentPos, dataLength, BluetoothUuid.UUID_BYTES_128_BIT, serviceSolicitationUuids);
                    break;
                case DATA_TYPE_LOCAL_NAME_SHORT:
                case DATA_TYPE_LOCAL_NAME_COMPLETE:
                    localName = new String(extractBytes(scanRecord, currentPos, dataLength));
                    break;
                case DATA_TYPE_TX_POWER_LEVEL:
                    txPowerLevel = scanRecord[currentPos];
                    break;
                case DATA_TYPE_SERVICE_DATA_16_BIT:
                case DATA_TYPE_SERVICE_DATA_32_BIT:
                case DATA_TYPE_SERVICE_DATA_128_BIT:
                    int serviceUuidLength = BluetoothUuid.UUID_BYTES_16_BIT;
                    if (fieldType == DATA_TYPE_SERVICE_DATA_32_BIT) {
                        serviceUuidLength = BluetoothUuid.UUID_BYTES_32_BIT;
                    } else if (fieldType == DATA_TYPE_SERVICE_DATA_128_BIT) {
                        serviceUuidLength = BluetoothUuid.UUID_BYTES_128_BIT;
                    }
                    byte[] serviceDataUuidBytes = extractBytes(scanRecord, currentPos, serviceUuidLength);
                    ParcelUuid serviceDataUuid = BluetoothUuid.parseUuidFrom(serviceDataUuidBytes);
                    byte[] serviceDataArray = extractBytes(scanRecord, currentPos + serviceUuidLength, dataLength - serviceUuidLength);
                    serviceData.put(serviceDataUuid, serviceDataArray);
                    break;
                case DATA_TYPE_MANUFACTURER_SPECIFIC_DATA:
                    // The first two bytes of the manufacturer specific data are
                    // manufacturer ids in little endian.
                    int manufacturerId = ((scanRecord[currentPos + 1] & 0xFF) << 8) + (scanRecord[currentPos] & 0xFF);
                    byte[] manufacturerDataBytes = extractBytes(scanRecord, currentPos + 2, dataLength - 2);
                    manufacturerData.put(manufacturerId, manufacturerDataBytes);
                    break;
                default:
                    // Just ignore, we don't handle such data type.
                    break;
            }
            currentPos += dataLength;
        }
        if (serviceUuids.isEmpty()) {
            serviceUuids = null;
        }
        return new ScanRecord(serviceUuids, serviceSolicitationUuids, manufacturerData, serviceData, advertiseFlag, txPowerLevel, localName, scanRecord);
    } catch (Exception e) {
        Log.e(TAG, "unable to parse scan record: " + Arrays.toString(scanRecord));
        // and return an empty record with raw scanRecord bytes in results
        return new ScanRecord(null, null, null, null, -1, Integer.MIN_VALUE, null, scanRecord);
    }
}
------------------------
Find a silently evolved API code:android.view.WindowInsets.getSystemWindowInsetLeft:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the left system window inset in pixels.
 *
 * <p>The system window inset represents the area of a full-screen window that is
 * partially or fully obscured by the status bar, navigation bar, IME or other system windows.
 * </p>
 *
 * @return The left system window inset
 */

Body of Frist Method:
{
    return mSystemWindowInsets.left;
}
Body of Second Method:
{
    return getSystemWindowInsets().left;
}
------------------------
Find a silently evolved API code:android.media.AudioFormat.toLogFriendlyString:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return String.format("%dch %dHz %s", getChannelCount(), mSampleRate, toLogFriendlyEncoding(mEncoding));
}
Body of Second Method:
{
    return String.format("%dch %dHz %s", mChannelCount, mSampleRate, toLogFriendlyEncoding(mEncoding));
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothA2dpSink.getConnectionState:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (VDBG)
        log("getState(" + device + ")");
    final IBluetoothA2dpSink service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getConnectionState(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.STATE_DISCONNECTED;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return BluetoothProfile.STATE_DISCONNECTED;
}
Body of Second Method:
{
    if (VDBG)
        log("getState(" + device + ")");
    final IBluetoothA2dpSink service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getConnectionState(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.STATE_DISCONNECTED;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return BluetoothProfile.STATE_DISCONNECTED;
}
------------------------
Find a silently evolved API code:android.content.pm.PackageUserState.isMatch:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Test if the given component is considered installed, enabled and a match
 * for the given flags.
 *
 * <p>
 * Expects at least one of {@link PackageManager#MATCH_DIRECT_BOOT_AWARE} and
 * {@link PackageManager#MATCH_DIRECT_BOOT_UNAWARE} are specified in {@code flags}.
 * </p>
 */

Body of Frist Method:
{
    final boolean isSystemApp = componentInfo.applicationInfo.isSystemApp();
    final boolean matchUninstalled = (flags & PackageManager.MATCH_KNOWN_PACKAGES) != 0;
    if (!isAvailable(flags) && !(isSystemApp && matchUninstalled))
        return false;
    if (!isEnabled(componentInfo, flags))
        return false;
    if ((flags & MATCH_SYSTEM_ONLY) != 0) {
        if (!isSystemApp) {
            return false;
        }
    }
    final boolean matchesUnaware = ((flags & MATCH_DIRECT_BOOT_UNAWARE) != 0) && !componentInfo.directBootAware;
    final boolean matchesAware = ((flags & MATCH_DIRECT_BOOT_AWARE) != 0) && componentInfo.directBootAware;
    return matchesUnaware || matchesAware;
}
Body of Second Method:
{
    final boolean isSystemApp = componentInfo.applicationInfo.isSystemApp();
    final boolean matchUninstalled = (flags & PackageManager.MATCH_KNOWN_PACKAGES) != 0;
    if (!isAvailable(flags) && !(isSystemApp && matchUninstalled))
        return reportIfDebug(false, flags);
    if (!isEnabled(componentInfo, flags))
        return reportIfDebug(false, flags);
    if ((flags & MATCH_SYSTEM_ONLY) != 0) {
        if (!isSystemApp) {
            return reportIfDebug(false, flags);
        }
    }
    final boolean matchesUnaware = ((flags & MATCH_DIRECT_BOOT_UNAWARE) != 0) && !componentInfo.directBootAware;
    final boolean matchesAware = ((flags & MATCH_DIRECT_BOOT_AWARE) != 0) && componentInfo.directBootAware;
    return reportIfDebug(matchesUnaware || matchesAware, flags);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.getCurrentAgEvents:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns list of current values of AG indicators.
 *
 * @param device remote device
 * @return bundle of AG  indicators; null if device is not in CONNECTED state
 */

Body of Frist Method:
{
    if (DBG)
        log("getCurrentCalls()");
    final IBluetoothHeadsetClient service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getCurrentAgEvents(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return null;
}
Body of Second Method:
{
    if (DBG)
        log("getCurrentCalls()");
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getCurrentAgEvents(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return null;
}
------------------------
Find a silently evolved API code:android.app.usage.UsageEvents.readEventFromParcel:COMMENT
Method Modifier: private     
Comment:/**
 * Reads a single event from the parcel. Modify this when updating {@link Event}.
 */

Body of Frist Method:
{
    final int packageIndex = p.readInt();
    if (packageIndex >= 0) {
        eventOut.mPackage = mStringPool[packageIndex];
    } else {
        eventOut.mPackage = null;
    }
    final int classIndex = p.readInt();
    if (classIndex >= 0) {
        eventOut.mClass = mStringPool[classIndex];
    } else {
        eventOut.mClass = null;
    }
    eventOut.mEventType = p.readInt();
    eventOut.mTimeStamp = p.readLong();
    // Fill out the event-dependant fields.
    eventOut.mConfiguration = null;
    eventOut.mShortcutId = null;
    eventOut.mAction = null;
    eventOut.mContentType = null;
    eventOut.mContentAnnotations = null;
    eventOut.mNotificationChannelId = null;
    switch(eventOut.mEventType) {
        case Event.CONFIGURATION_CHANGE:
            // Extract the configuration for configuration change events.
            eventOut.mConfiguration = Configuration.CREATOR.createFromParcel(p);
            break;
        case Event.SHORTCUT_INVOCATION:
            eventOut.mShortcutId = p.readString();
            break;
        case Event.CHOOSER_ACTION:
            eventOut.mAction = p.readString();
            eventOut.mContentType = p.readString();
            eventOut.mContentAnnotations = p.createStringArray();
            break;
        case Event.STANDBY_BUCKET_CHANGED:
            eventOut.mBucketAndReason = p.readInt();
            break;
        case Event.NOTIFICATION_INTERRUPTION:
            eventOut.mNotificationChannelId = p.readString();
            break;
    }
}
Body of Second Method:
{
    final int packageIndex = p.readInt();
    if (packageIndex >= 0) {
        eventOut.mPackage = mStringPool[packageIndex];
    } else {
        eventOut.mPackage = null;
    }
    final int classIndex = p.readInt();
    if (classIndex >= 0) {
        eventOut.mClass = mStringPool[classIndex];
    } else {
        eventOut.mClass = null;
    }
    eventOut.mInstanceId = p.readInt();
    final int taskRootPackageIndex = p.readInt();
    if (taskRootPackageIndex >= 0) {
        eventOut.mTaskRootPackage = mStringPool[taskRootPackageIndex];
    } else {
        eventOut.mTaskRootPackage = null;
    }
    final int taskRootClassIndex = p.readInt();
    if (taskRootClassIndex >= 0) {
        eventOut.mTaskRootClass = mStringPool[taskRootClassIndex];
    } else {
        eventOut.mTaskRootClass = null;
    }
    eventOut.mEventType = p.readInt();
    eventOut.mTimeStamp = p.readLong();
    // Fill out the event-dependant fields.
    eventOut.mConfiguration = null;
    eventOut.mShortcutId = null;
    eventOut.mAction = null;
    eventOut.mContentType = null;
    eventOut.mContentAnnotations = null;
    eventOut.mNotificationChannelId = null;
    switch(eventOut.mEventType) {
        case Event.CONFIGURATION_CHANGE:
            // Extract the configuration for configuration change events.
            eventOut.mConfiguration = Configuration.CREATOR.createFromParcel(p);
            break;
        case Event.SHORTCUT_INVOCATION:
            eventOut.mShortcutId = p.readString();
            break;
        case Event.CHOOSER_ACTION:
            eventOut.mAction = p.readString();
            eventOut.mContentType = p.readString();
            eventOut.mContentAnnotations = p.createStringArray();
            break;
        case Event.STANDBY_BUCKET_CHANGED:
            eventOut.mBucketAndReason = p.readInt();
            break;
        case Event.NOTIFICATION_INTERRUPTION:
            eventOut.mNotificationChannelId = p.readString();
            break;
    }
    eventOut.mFlags = p.readInt();
}
------------------------
Find a silently evolved API code:android.telephony.CellSignalStrengthGsm.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Implement the Parcelable interface
 */

Body of Frist Method:
{
    if (DBG)
        log("writeToParcel(Parcel, int): " + toString());
    dest.writeInt(mSignalStrength);
    dest.writeInt(mBitErrorRate);
    dest.writeInt(mTimingAdvance);
}
Body of Second Method:
{
    if (DBG)
        log("writeToParcel(Parcel, int): " + toString());
    dest.writeInt(mRssi);
    dest.writeInt(mBitErrorRate);
    dest.writeInt(mTimingAdvance);
    dest.writeInt(mLevel);
}
------------------------
Find a silently evolved API code:android.telephony.euicc.EuiccManager.getDownloadableSubscriptionMetadata:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Fills in the metadata for a DownloadableSubscription.
 *
 * <p>May be used in cases that a DownloadableSubscription was constructed to download a
 * profile, but the metadata for the profile is unknown (e.g. we only know the activation code).
 * The callback will be triggered with an Intent with
 * {@link #EXTRA_EMBEDDED_SUBSCRIPTION_DOWNLOADABLE_SUBSCRIPTION} set to the
 * downloadable subscription metadata upon success.
 *
 * <p>Requires that the calling app has the
 * {@link android.Manifest.permission#WRITE_EMBEDDED_SUBSCRIPTIONS} permission. This is for
 * internal system use only.
 *
 * @param subscription the subscription which needs metadata filled in
 * @param callbackIntent a PendingIntent to launch when the operation completes.
 * @hide
 */

Body of Frist Method:
{
    if (!isEnabled()) {
        sendUnavailableError(callbackIntent);
        return;
    }
    try {
        getIEuiccController().getDownloadableSubscriptionMetadata(subscription, mContext.getOpPackageName(), callbackIntent);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    if (!isEnabled()) {
        sendUnavailableError(callbackIntent);
        return;
    }
    try {
        getIEuiccController().getDownloadableSubscriptionMetadata(mCardId, subscription, mContext.getOpPackageName(), callbackIntent);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothMap.getClient:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the currently connected remote Bluetooth device (PCE).
 *
 * @return The remote Bluetooth device, or null if not in connected or connecting state, or if
 * this proxy object is not connected to the Map service.
 */

Body of Frist Method:
{
    if (VDBG)
        log("getClient()");
    final IBluetoothMap service = mService;
    if (service != null) {
        try {
            return service.getClient();
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            log(Log.getStackTraceString(new Throwable()));
    }
    return null;
}
Body of Second Method:
{
    if (VDBG)
        log("getClient()");
    final IBluetoothMap service = getService();
    if (service != null) {
        try {
            return service.getClient();
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            log(Log.getStackTraceString(new Throwable()));
    }
    return null;
}
------------------------
Find a silently evolved API code:android.app.AlarmManager.AlarmClockInfo.writeToProto:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    final long token = proto.start(fieldId);
    proto.write(AlarmClockInfoProto.TRIGGER_TIME_MS, mTriggerTime);
    mShowIntent.writeToProto(proto, AlarmClockInfoProto.SHOW_INTENT);
    proto.end(token);
}
Body of Second Method:
{
    final long token = proto.start(fieldId);
    proto.write(AlarmClockInfoProto.TRIGGER_TIME_MS, mTriggerTime);
    if (mShowIntent != null) {
        mShowIntent.writeToProto(proto, AlarmClockInfoProto.SHOW_INTENT);
    }
    proto.end(token);
}
------------------------
Find a silently evolved API code:android.util.StatsLog.logEvent:COMMENT
Method Modifier: public      static      
Comment:/**
 * Logs an event that does not represent a start or stop boundary.
 *
 * @param label developer-chosen label.
 * @return True if the log request was sent to statsd.
 */

Body of Frist Method:
{
    synchronized (StatsLog.class) {
        try {
            IStatsManager service = getIStatsManagerLocked();
            if (service == null) {
                if (DEBUG)
                    Slog.d(TAG, "Failed to find statsd when logging event");
                return false;
            }
            service.sendAppBreadcrumbAtom(label, StatsLog.APP_BREADCRUMB_REPORTED__STATE__UNSPECIFIED);
            return true;
        } catch (RemoteException e) {
            sService = null;
            if (DEBUG)
                Slog.d(TAG, "Failed to connect to statsd when logging event");
            return false;
        }
    }
}
Body of Second Method:
{
    synchronized (sLogLock) {
        try {
            IStatsManager service = getIStatsManagerLocked();
            if (service == null) {
                if (DEBUG) {
                    Slog.d(TAG, "Failed to find statsd when logging event");
                }
                return false;
            }
            service.sendAppBreadcrumbAtom(label, StatsLog.APP_BREADCRUMB_REPORTED__STATE__UNSPECIFIED);
            return true;
        } catch (RemoteException e) {
            sService = null;
            if (DEBUG) {
                Slog.d(TAG, "Failed to connect to statsd when logging event");
            }
            return false;
        }
    }
}
------------------------
Find a silently evolved API code:android.view.MotionEvent.split:COMMENT
Method Modifier: public      final       hidden      
Comment:/**
 * Splits a motion event such that it includes only a subset of pointer ids.
 * @hide
 */

Body of Frist Method:
{
    MotionEvent ev = obtain();
    synchronized (gSharedTempLock) {
        final int oldPointerCount = nativeGetPointerCount(mNativePtr);
        ensureSharedTempPointerCapacity(oldPointerCount);
        final PointerProperties[] pp = gSharedTempPointerProperties;
        final PointerCoords[] pc = gSharedTempPointerCoords;
        final int[] map = gSharedTempPointerIndexMap;
        final int oldAction = nativeGetAction(mNativePtr);
        final int oldActionMasked = oldAction & ACTION_MASK;
        final int oldActionPointerIndex = (oldAction & ACTION_POINTER_INDEX_MASK) >> ACTION_POINTER_INDEX_SHIFT;
        int newActionPointerIndex = -1;
        int newPointerCount = 0;
        int newIdBits = 0;
        for (int i = 0; i < oldPointerCount; i++) {
            nativeGetPointerProperties(mNativePtr, i, pp[newPointerCount]);
            final int idBit = 1 << pp[newPointerCount].id;
            if ((idBit & idBits) != 0) {
                if (i == oldActionPointerIndex) {
                    newActionPointerIndex = newPointerCount;
                }
                map[newPointerCount] = i;
                newPointerCount += 1;
                newIdBits |= idBit;
            }
        }
        if (newPointerCount == 0) {
            throw new IllegalArgumentException("idBits did not match any ids in the event");
        }
        final int newAction;
        if (oldActionMasked == ACTION_POINTER_DOWN || oldActionMasked == ACTION_POINTER_UP) {
            if (newActionPointerIndex < 0) {
                // An unrelated pointer changed.
                newAction = ACTION_MOVE;
            } else if (newPointerCount == 1) {
                // The first/last pointer went down/up.
                newAction = oldActionMasked == ACTION_POINTER_DOWN ? ACTION_DOWN : ACTION_UP;
            } else {
                // A secondary pointer went down/up.
                newAction = oldActionMasked | (newActionPointerIndex << ACTION_POINTER_INDEX_SHIFT);
            }
        } else {
            // Simple up/down/cancel/move or other motion action.
            newAction = oldAction;
        }
        final int historySize = nativeGetHistorySize(mNativePtr);
        for (int h = 0; h <= historySize; h++) {
            final int historyPos = h == historySize ? HISTORY_CURRENT : h;
            for (int i = 0; i < newPointerCount; i++) {
                nativeGetPointerCoords(mNativePtr, map[i], historyPos, pc[i]);
            }
            final long eventTimeNanos = nativeGetEventTimeNanos(mNativePtr, historyPos);
            if (h == 0) {
                ev.mNativePtr = nativeInitialize(ev.mNativePtr, nativeGetDeviceId(mNativePtr), nativeGetSource(mNativePtr), newAction, nativeGetFlags(mNativePtr), nativeGetEdgeFlags(mNativePtr), nativeGetMetaState(mNativePtr), nativeGetButtonState(mNativePtr), nativeGetXOffset(mNativePtr), nativeGetYOffset(mNativePtr), nativeGetXPrecision(mNativePtr), nativeGetYPrecision(mNativePtr), nativeGetDownTimeNanos(mNativePtr), eventTimeNanos, newPointerCount, pp, pc);
            } else {
                nativeAddBatch(ev.mNativePtr, eventTimeNanos, pc, 0);
            }
        }
        return ev;
    }
}
Body of Second Method:
{
    MotionEvent ev = obtain();
    synchronized (gSharedTempLock) {
        final int oldPointerCount = nativeGetPointerCount(mNativePtr);
        ensureSharedTempPointerCapacity(oldPointerCount);
        final PointerProperties[] pp = gSharedTempPointerProperties;
        final PointerCoords[] pc = gSharedTempPointerCoords;
        final int[] map = gSharedTempPointerIndexMap;
        final int oldAction = nativeGetAction(mNativePtr);
        final int oldActionMasked = oldAction & ACTION_MASK;
        final int oldActionPointerIndex = (oldAction & ACTION_POINTER_INDEX_MASK) >> ACTION_POINTER_INDEX_SHIFT;
        int newActionPointerIndex = -1;
        int newPointerCount = 0;
        for (int i = 0; i < oldPointerCount; i++) {
            nativeGetPointerProperties(mNativePtr, i, pp[newPointerCount]);
            final int idBit = 1 << pp[newPointerCount].id;
            if ((idBit & idBits) != 0) {
                if (i == oldActionPointerIndex) {
                    newActionPointerIndex = newPointerCount;
                }
                map[newPointerCount] = i;
                newPointerCount += 1;
            }
        }
        if (newPointerCount == 0) {
            throw new IllegalArgumentException("idBits did not match any ids in the event");
        }
        final int newAction;
        if (oldActionMasked == ACTION_POINTER_DOWN || oldActionMasked == ACTION_POINTER_UP) {
            if (newActionPointerIndex < 0) {
                // An unrelated pointer changed.
                newAction = ACTION_MOVE;
            } else if (newPointerCount == 1) {
                // The first/last pointer went down/up.
                newAction = oldActionMasked == ACTION_POINTER_DOWN ? ACTION_DOWN : ACTION_UP;
            } else {
                // A secondary pointer went down/up.
                newAction = oldActionMasked | (newActionPointerIndex << ACTION_POINTER_INDEX_SHIFT);
            }
        } else {
            // Simple up/down/cancel/move or other motion action.
            newAction = oldAction;
        }
        final int historySize = nativeGetHistorySize(mNativePtr);
        for (int h = 0; h <= historySize; h++) {
            final int historyPos = h == historySize ? HISTORY_CURRENT : h;
            for (int i = 0; i < newPointerCount; i++) {
                nativeGetPointerCoords(mNativePtr, map[i], historyPos, pc[i]);
            }
            final long eventTimeNanos = nativeGetEventTimeNanos(mNativePtr, historyPos);
            if (h == 0) {
                ev.mNativePtr = nativeInitialize(ev.mNativePtr, nativeGetDeviceId(mNativePtr), nativeGetSource(mNativePtr), nativeGetDisplayId(mNativePtr), newAction, nativeGetFlags(mNativePtr), nativeGetEdgeFlags(mNativePtr), nativeGetMetaState(mNativePtr), nativeGetButtonState(mNativePtr), nativeGetClassification(mNativePtr), nativeGetXOffset(mNativePtr), nativeGetYOffset(mNativePtr), nativeGetXPrecision(mNativePtr), nativeGetYPrecision(mNativePtr), nativeGetDownTimeNanos(mNativePtr), eventTimeNanos, newPointerCount, pp, pc);
            } else {
                nativeAddBatch(ev.mNativePtr, eventTimeNanos, pc, 0);
            }
        }
        return ev;
    }
}
------------------------
Find a silently evolved API code:android.net.http.HttpResponseCache.delete:COMMENT
Method Modifier: public      
Comment:/**
 * Uninstalls the cache and deletes all of its stored contents.
 */

Body of Frist Method:
{
    if (ResponseCache.getDefault() == this) {
        ResponseCache.setDefault(null);
    }
    delegate.delete();
}
Body of Second Method:
{
    if (ResponseCache.getDefault() == this) {
        ResponseCache.setDefault(null);
    }
    mDelegate.delete();
}
------------------------
Find a silently evolved API code:android.util.Half.parseHalf:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns the half-precision float value represented by the specified string.
 * Calling this method is equivalent to calling
 * <code>toHalf(Float.parseString(h))</code>. See {@link Float#valueOf(String)}
 * for more information on the format of the string representation.
 *
 * @param s The string to be parsed
 * @return A half-precision float value represented by the string
 * @throws NumberFormatException if the string does not contain a parsable
 * half-precision float value
 */

Body of Frist Method:
{
    return toHalf(FloatingDecimal.parseFloat(s));
}
Body of Second Method:
{
    return toHalf(Float.parseFloat(s));
}
------------------------
Find a silently evolved API code:android.net.util.NetdService.getInstance:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Return an INetd instance, or null if not available.
 *
 * It is the caller's responsibility to check for a null return value
 * and to handle RemoteException errors from invocations on the returned
 * interface if, for example, netd dies and is restarted.
 *
 * Returned instances of INetd should not be cached.
 *
 * @return an INetd instance or null.
 */

Body of Frist Method:
{
    // NOTE: ServiceManager does no caching for the netd service,
    // because netd is not one of the defined common services.
    final INetd netdInstance = INetd.Stub.asInterface(ServiceManager.getService(NETD_SERVICE_NAME));
    if (netdInstance == null) {
        Log.w(TAG, "WARNING: returning null INetd instance.");
    }
    return netdInstance;
}
Body of Second Method:
{
    // NOTE: ServiceManager does no caching for the netd service,
    // because netd is not one of the defined common services.
    final INetd netdInstance = INetd.Stub.asInterface(ServiceManager.getService(Context.NETD_SERVICE));
    if (netdInstance == null) {
        Log.w(TAG, "WARNING: returning null INetd instance.");
    }
    return netdInstance;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothSap.getClient:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the currently connected remote Bluetooth device (PCE).
 *
 * @return The remote Bluetooth device, or null if not in connected or connecting state, or if
 * this proxy object is not connected to the Sap service.
 * @hide
 */

Body of Frist Method:
{
    if (VDBG)
        log("getClient()");
    final IBluetoothSap service = mService;
    if (service != null) {
        try {
            return service.getClient();
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            log(Log.getStackTraceString(new Throwable()));
    }
    return null;
}
Body of Second Method:
{
    if (VDBG)
        log("getClient()");
    final IBluetoothSap service = getService();
    if (service != null) {
        try {
            return service.getClient();
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            log(Log.getStackTraceString(new Throwable()));
    }
    return null;
}
------------------------
Find a silently evolved API code:android.telephony.CellIdentityTdscdma.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Implement the Parcelable interface
 */

Body of Frist Method:
{
    if (DBG)
        log("writeToParcel(Parcel, int): " + toString());
    super.writeToParcel(dest, TYPE_TDSCDMA);
    dest.writeInt(mLac);
    dest.writeInt(mCid);
    dest.writeInt(mCpid);
}
Body of Second Method:
{
    if (DBG)
        log("writeToParcel(Parcel, int): " + toString());
    super.writeToParcel(dest, CellInfo.TYPE_TDSCDMA);
    dest.writeInt(mLac);
    dest.writeInt(mCid);
    dest.writeInt(mCpid);
    dest.writeInt(mUarfcn);
}
------------------------
Find a silently evolved API code:android.util.LongArray.get:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns the value at the specified position in this array.
 */

Body of Frist Method:
{
    checkBounds(index);
    return mValues[index];
}
Body of Second Method:
{
    ArrayUtils.checkBounds(mSize, index);
    return mValues[index];
}
------------------------
Find a silently evolved API code:android.view.textservice.TextServicesManager.getCurrentSpellCheckerSubtype:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    try {
        // Passing null as a locale until we support multiple enabled spell checker subtypes.
        return mService.getCurrentSpellCheckerSubtype(null, allowImplicitlySelectedSubtype);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    try {
        return mService.getCurrentSpellCheckerSubtype(mUserId, allowImplicitlySelectedSubtype);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHidHost.getProtocolMode:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Send Get_Protocol_Mode command to the connected HID input device.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN} permission.
 *
 * @param device Remote Bluetooth Device
 * @return false on immediate error, true otherwise
 * @hide
 */

Body of Frist Method:
{
    if (VDBG)
        log("getProtocolMode(" + device + ")");
    final IBluetoothHidHost service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getProtocolMode(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (VDBG)
        log("getProtocolMode(" + device + ")");
    final IBluetoothHidHost service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getProtocolMode(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.widget.ProgressBar.applyProgressBackgroundTint:COMMENT
Method Modifier: private     
Comment:/**
 * Should only be called if we've already verified that mProgressDrawable
 * and mProgressTintInfo are non-null.
 */

Body of Frist Method:
{
    if (mProgressTintInfo.mHasProgressBackgroundTint || mProgressTintInfo.mHasProgressBackgroundTintMode) {
        final Drawable target = getTintTarget(R.id.background, false);
        if (target != null) {
            if (mProgressTintInfo.mHasProgressBackgroundTint) {
                target.setTintList(mProgressTintInfo.mProgressBackgroundTintList);
            }
            if (mProgressTintInfo.mHasProgressBackgroundTintMode) {
                target.setTintMode(mProgressTintInfo.mProgressBackgroundTintMode);
            }
            // stateful before applying the tint, so let's try again.
            if (target.isStateful()) {
                target.setState(getDrawableState());
            }
        }
    }
}
Body of Second Method:
{
    if (mProgressTintInfo.mHasProgressBackgroundTint || mProgressTintInfo.mHasProgressBackgroundTintMode) {
        final Drawable target = getTintTarget(R.id.background, false);
        if (target != null) {
            if (mProgressTintInfo.mHasProgressBackgroundTint) {
                target.setTintList(mProgressTintInfo.mProgressBackgroundTintList);
            }
            if (mProgressTintInfo.mHasProgressBackgroundTintMode) {
                target.setTintBlendMode(mProgressTintInfo.mProgressBackgroundBlendMode);
            }
            // stateful before applying the tint, so let's try again.
            if (target.isStateful()) {
                target.setState(getDrawableState());
            }
        }
    }
}
------------------------
Find a silently evolved API code:android.location.GnssMeasurement.set:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets all contents to the values stored in the provided object.
 * @hide
 */

Body of Frist Method:
{
    mFlags = measurement.mFlags;
    mSvid = measurement.mSvid;
    mConstellationType = measurement.mConstellationType;
    mTimeOffsetNanos = measurement.mTimeOffsetNanos;
    mState = measurement.mState;
    mReceivedSvTimeNanos = measurement.mReceivedSvTimeNanos;
    mReceivedSvTimeUncertaintyNanos = measurement.mReceivedSvTimeUncertaintyNanos;
    mCn0DbHz = measurement.mCn0DbHz;
    mPseudorangeRateMetersPerSecond = measurement.mPseudorangeRateMetersPerSecond;
    mPseudorangeRateUncertaintyMetersPerSecond = measurement.mPseudorangeRateUncertaintyMetersPerSecond;
    mAccumulatedDeltaRangeState = measurement.mAccumulatedDeltaRangeState;
    mAccumulatedDeltaRangeMeters = measurement.mAccumulatedDeltaRangeMeters;
    mAccumulatedDeltaRangeUncertaintyMeters = measurement.mAccumulatedDeltaRangeUncertaintyMeters;
    mCarrierFrequencyHz = measurement.mCarrierFrequencyHz;
    mCarrierCycles = measurement.mCarrierCycles;
    mCarrierPhase = measurement.mCarrierPhase;
    mCarrierPhaseUncertainty = measurement.mCarrierPhaseUncertainty;
    mMultipathIndicator = measurement.mMultipathIndicator;
    mSnrInDb = measurement.mSnrInDb;
    mAutomaticGainControlLevelInDb = measurement.mAutomaticGainControlLevelInDb;
}
Body of Second Method:
{
    mFlags = measurement.mFlags;
    mSvid = measurement.mSvid;
    mConstellationType = measurement.mConstellationType;
    mTimeOffsetNanos = measurement.mTimeOffsetNanos;
    mState = measurement.mState;
    mReceivedSvTimeNanos = measurement.mReceivedSvTimeNanos;
    mReceivedSvTimeUncertaintyNanos = measurement.mReceivedSvTimeUncertaintyNanos;
    mCn0DbHz = measurement.mCn0DbHz;
    mPseudorangeRateMetersPerSecond = measurement.mPseudorangeRateMetersPerSecond;
    mPseudorangeRateUncertaintyMetersPerSecond = measurement.mPseudorangeRateUncertaintyMetersPerSecond;
    mAccumulatedDeltaRangeState = measurement.mAccumulatedDeltaRangeState;
    mAccumulatedDeltaRangeMeters = measurement.mAccumulatedDeltaRangeMeters;
    mAccumulatedDeltaRangeUncertaintyMeters = measurement.mAccumulatedDeltaRangeUncertaintyMeters;
    mCarrierFrequencyHz = measurement.mCarrierFrequencyHz;
    mCarrierCycles = measurement.mCarrierCycles;
    mCarrierPhase = measurement.mCarrierPhase;
    mCarrierPhaseUncertainty = measurement.mCarrierPhaseUncertainty;
    mMultipathIndicator = measurement.mMultipathIndicator;
    mSnrInDb = measurement.mSnrInDb;
    mAutomaticGainControlLevelInDb = measurement.mAutomaticGainControlLevelInDb;
    mCodeType = measurement.mCodeType;
}
------------------------
Find a silently evolved API code:android.location.LocationRequest.create:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Create a location request with default parameters.
 *
 * <p>Default parameters are for a low power, slowly updated location.
 * It can then be adjusted as required by the applications before passing
 * to the {@link LocationManager}
 *
 * @return a new location request
 */

Body of Frist Method:
{
    LocationRequest request = new LocationRequest();
    return request;
}
Body of Second Method:
{
    return new LocationRequest();
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothA2dpSink.disconnect:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Initiate disconnection from a profile
 *
 * <p> This API will return false in scenarios like the profile on the
 * Bluetooth device is not in connected state etc. When this API returns,
 * true, it is guaranteed that the connection state change
 * intent will be broadcasted with the state. Users can get the
 * disconnection state of the profile from this intent.
 *
 * <p> If the disconnection is initiated by a remote device, the state
 * will transition from {@link #STATE_CONNECTED} to
 * {@link #STATE_DISCONNECTED}. If the disconnect is initiated by the
 * host (local) device the state will transition from
 * {@link #STATE_CONNECTED} to state {@link #STATE_DISCONNECTING} to
 * state {@link #STATE_DISCONNECTED}. The transition to
 * {@link #STATE_DISCONNECTING} can be used to distinguish between the
 * two scenarios.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}
 * permission.
 *
 * @param device Remote Bluetooth Device
 * @return false on immediate error, true otherwise
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("disconnect(" + device + ")");
    final IBluetoothA2dpSink service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.disconnect(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("disconnect(" + device + ")");
    final IBluetoothA2dpSink service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.disconnect(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.view.DisplayEventReceiver.dispatchVsync:COMMENT
Method Modifier: private     hidden      
Comment:// Called from native code.

Body of Frist Method:
{
    onVsync(timestampNanos, builtInDisplayId, frame);
}
Body of Second Method:
{
    onVsync(timestampNanos, physicalDisplayId, frame);
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiEnterpriseConfig.setCaCertificates:COMMENT
Method Modifier: public      
Comment:/**
 * Specify a list of X.509 certificates that identifies the server. The validation
 * passes if the CA of server certificate matches one of the given certificates.
 *
 * <p>Default names are automatically assigned to the certificates and used
 * with this configuration. The framework takes care of installing the
 * certificates when the config is saved and removing the certificates when
 * the config is removed.
 *
 * @param certs X.509 CA certificates
 * @throws IllegalArgumentException if any of the provided certificates is
 * not a CA certificate
 */

Body of Frist Method:
{
    if (certs != null) {
        X509Certificate[] newCerts = new X509Certificate[certs.length];
        for (int i = 0; i < certs.length; i++) {
            if (certs[i].getBasicConstraints() >= 0) {
                newCerts[i] = certs[i];
            } else {
                throw new IllegalArgumentException("Not a CA certificate");
            }
        }
        mCaCerts = newCerts;
    } else {
        mCaCerts = null;
    }
}
Body of Second Method:
{
    if (certs != null) {
        X509Certificate[] newCerts = new X509Certificate[certs.length];
        for (int i = 0; i < certs.length; i++) {
            if (certs[i].getBasicConstraints() >= 0) {
                newCerts[i] = certs[i];
            } else {
                mCaCerts = null;
                throw new IllegalArgumentException("Not a CA certificate");
            }
        }
        mCaCerts = newCerts;
        mIsAppInstalledCaCert = true;
    } else {
        mCaCerts = null;
    }
}
------------------------
Find a silently evolved API code:android.telephony.euicc.EuiccManager.retainSubscriptionsForFactoryReset:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Ensure that subscriptions will be retained on the next factory reset.
 *
 * <p>By default, all subscriptions on the eUICC are erased the first time a device boots (ever
 * and after factory resets). This ensures that the data is wiped after a factory reset is
 * performed via fastboot or recovery mode, as these modes do not support the necessary radio
 * communication needed to wipe the eSIM.
 *
 * <p>However, this method may be called right before a factory reset issued via settings when
 * the user elects to retain subscriptions. Doing so will mark them for retention so that they
 * are not cleared after the ensuing reset.
 *
 * <p>Requires that the calling app has the {@link android.Manifest.permission#MASTER_CLEAR}
 * permission. This is for internal system use only.
 *
 * @param callbackIntent a PendingIntent to launch when the operation completes.
 * @hide
 */

Body of Frist Method:
{
    if (!isEnabled()) {
        sendUnavailableError(callbackIntent);
        return;
    }
    try {
        getIEuiccController().retainSubscriptionsForFactoryReset(callbackIntent);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    if (!isEnabled()) {
        sendUnavailableError(callbackIntent);
        return;
    }
    try {
        getIEuiccController().retainSubscriptionsForFactoryReset(mCardId, callbackIntent);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.graphics.Picture.beginRecording:COMMENT
Method Modifier: public      
Comment:/**
 * To record a picture, call beginRecording() and then draw into the Canvas
 * that is returned. Nothing we appear on screen, but all of the draw
 * commands (e.g. {@link Canvas#drawRect(Rect, Paint)}) will be recorded.
 * To stop recording, call endRecording(). After endRecording() the Canvas
 * that was returned must no longer be used, and nothing should be drawn
 * into it.
 */

Body of Frist Method:
{
    if (mRecordingCanvas != null) {
        throw new IllegalStateException("Picture already recording, must call #endRecording()");
    }
    long ni = nativeBeginRecording(mNativePicture, width, height);
    mRecordingCanvas = new PictureCanvas(this, ni);
    mRequiresHwAcceleration = false;
    return mRecordingCanvas;
}
Body of Second Method:
{
    verifyValid();
    if (mRecordingCanvas != null) {
        throw new IllegalStateException("Picture already recording, must call #endRecording()");
    }
    long ni = nativeBeginRecording(mNativePicture, width, height);
    mRecordingCanvas = new PictureCanvas(this, ni);
    mRequiresHwAcceleration = false;
    return mRecordingCanvas;
}
------------------------
Find a silently evolved API code:android.net.wifi.p2p.WifiP2pGroup.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Implement the Parcelable interface
 */

Body of Frist Method:
{
    dest.writeString(mNetworkName);
    dest.writeParcelable(mOwner, flags);
    dest.writeByte(mIsGroupOwner ? (byte) 1 : (byte) 0);
    dest.writeInt(mClients.size());
    for (WifiP2pDevice client : mClients) {
        dest.writeParcelable(client, flags);
    }
    dest.writeString(mPassphrase);
    dest.writeString(mInterface);
    dest.writeInt(mNetId);
}
Body of Second Method:
{
    dest.writeString(mNetworkName);
    dest.writeParcelable(mOwner, flags);
    dest.writeByte(mIsGroupOwner ? (byte) 1 : (byte) 0);
    dest.writeInt(mClients.size());
    for (WifiP2pDevice client : mClients) {
        dest.writeParcelable(client, flags);
    }
    dest.writeString(mPassphrase);
    dest.writeString(mInterface);
    dest.writeInt(mNetId);
    dest.writeInt(mFrequency);
}
------------------------
Find a silently evolved API code:android.os.ParcelFileDescriptor.createPipe:COMMENT
Method Modifier: public      static      
Comment:/**
 * Create two ParcelFileDescriptors structured as a data pipe.  The first
 * ParcelFileDescriptor in the returned array is the read side; the second
 * is the write side.
 */

Body of Frist Method:
{
    try {
        final FileDescriptor[] fds = Os.pipe();
        return new ParcelFileDescriptor[] { new ParcelFileDescriptor(fds[0]), new ParcelFileDescriptor(fds[1]) };
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
}
Body of Second Method:
{
    try {
        final FileDescriptor[] fds = Os.pipe2(ifAtLeastQ(O_CLOEXEC));
        return new ParcelFileDescriptor[] { new ParcelFileDescriptor(fds[0]), new ParcelFileDescriptor(fds[1]) };
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
}
------------------------
Find a silently evolved API code:android.hardware.camera2.params.StreamConfigurationMap.getValidOutputFormatsForInput:COMMENT
<android.hardware.camera2.params.StreamConfigurationMap: int[] getValidOutputFormatsForInput(int)>
public      final       ->public      
Method Modifier: public      final       
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * Get the image {@code format} output formats for a reprocessing input format.
 *
 * <p>When submitting a {@link CaptureRequest} with an input Surface of a given format,
 * the only allowed target outputs of the {@link CaptureRequest} are the ones with a format
 * listed in the return value of this method. Including any other output Surface as a target
 * will throw an IllegalArgumentException. If no output format is supported given the input
 * format, an empty int[] will be returned.</p>
 *
 * <p>All image formats returned by this function will be defined in either {@link ImageFormat}
 * or in {@link PixelFormat} (and there is no possibility of collision).</p>
 *
 * <p>Formats listed in this array are guaranteed to return true if queried with
 * {@link #isOutputSupportedFor(int)}.</p>
 *
 * @return an array of integer format
 *
 * @see ImageFormat
 * @see PixelFormat
 */

Body of Frist Method:
{
    if (mInputOutputFormatsMap == null) {
        return new int[0];
    }
    return mInputOutputFormatsMap.getOutputs(inputFormat);
}
Body of Second Method:
{
    if (mInputOutputFormatsMap == null) {
        return new int[0];
    }
    int[] outputs = mInputOutputFormatsMap.getOutputs(inputFormat);
    if (mHeicOutputFormats.size() > 0) {
        // All reprocessing formats map contain JPEG.
        int[] outputsWithHeic = Arrays.copyOf(outputs, outputs.length + 1);
        outputsWithHeic[outputs.length] = ImageFormat.HEIC;
        return outputsWithHeic;
    } else {
        return outputs;
    }
}
------------------------
Find a silently evolved API code:android.graphics.Picture.requiresHardwareAcceleration:COMMENT
Method Modifier: public      
Comment:/**
 * Indicates whether or not this Picture contains recorded commands that only work when
 * drawn to a hardware-accelerated canvas. If this returns true then this Picture can only
 * be drawn to another Picture or to a Canvas where canvas.isHardwareAccelerated() is true.
 *
 * Note this value is only updated after recording has finished by a call to
 * {@link #endRecording()}. Prior to that it will be the default value of false.
 *
 * @return true if the Picture can only be drawn to a hardware-accelerated canvas,
 * false otherwise.
 */

Body of Frist Method:
{
    return mRequiresHwAcceleration;
}
Body of Second Method:
{
    verifyValid();
    return mRequiresHwAcceleration;
}
------------------------
Find a silently evolved API code:android.app.SharedElementCallback.onCaptureSharedElementSnapshot:COMMENT
Method Modifier: public      
Comment:/**
 * Creates a snapshot of a shared element to be used by the remote Activity and reconstituted
 * with {@link #onCreateSnapshotView(android.content.Context, android.os.Parcelable)}. A
 * null return value will mean that the remote Activity will have a null snapshot View in
 * {@link #onSharedElementStart(java.util.List, java.util.List, java.util.List)} and
 * {@link #onSharedElementEnd(java.util.List, java.util.List, java.util.List)}.
 *
 * <p>This is not called for Fragment Transitions.</p>
 *
 * @param sharedElement The shared element View to create a snapshot for.
 * @param viewToGlobalMatrix A matrix containing a transform from the view to the screen
 * coordinates.
 * @param screenBounds The bounds of shared element in screen coordinate space. This is
 * the bounds of the view with the viewToGlobalMatrix applied.
 * @return A snapshot to send to the remote Activity to be reconstituted with
 * {@link #onCreateSnapshotView(android.content.Context, android.os.Parcelable)} and passed
 * into {@link #onSharedElementStart(java.util.List, java.util.List, java.util.List)} and
 * {@link #onSharedElementEnd(java.util.List, java.util.List, java.util.List)}.
 */

Body of Frist Method:
{
    if (sharedElement instanceof ImageView) {
        ImageView imageView = ((ImageView) sharedElement);
        Drawable d = imageView.getDrawable();
        Drawable bg = imageView.getBackground();
        if (d != null && (bg == null || bg.getAlpha() == 0)) {
            Bitmap bitmap = TransitionUtils.createDrawableBitmap(d, imageView);
            if (bitmap != null) {
                Bundle bundle = new Bundle();
                if (bitmap.getConfig() != Bitmap.Config.HARDWARE) {
                    bundle.putParcelable(BUNDLE_SNAPSHOT_BITMAP, bitmap);
                } else {
                    GraphicBuffer graphicBuffer = bitmap.createGraphicBufferHandle();
                    bundle.putParcelable(BUNDLE_SNAPSHOT_GRAPHIC_BUFFER, graphicBuffer);
                }
                bundle.putString(BUNDLE_SNAPSHOT_IMAGE_SCALETYPE, imageView.getScaleType().toString());
                if (imageView.getScaleType() == ScaleType.MATRIX) {
                    Matrix matrix = imageView.getImageMatrix();
                    float[] values = new float[9];
                    matrix.getValues(values);
                    bundle.putFloatArray(BUNDLE_SNAPSHOT_IMAGE_MATRIX, values);
                }
                return bundle;
            }
        }
    }
    if (mTempMatrix == null) {
        mTempMatrix = new Matrix(viewToGlobalMatrix);
    } else {
        mTempMatrix.set(viewToGlobalMatrix);
    }
    ViewGroup parent = (ViewGroup) sharedElement.getParent();
    return TransitionUtils.createViewBitmap(sharedElement, mTempMatrix, screenBounds, parent);
}
Body of Second Method:
{
    if (sharedElement instanceof ImageView) {
        ImageView imageView = ((ImageView) sharedElement);
        Drawable d = imageView.getDrawable();
        Drawable bg = imageView.getBackground();
        if (d != null && (bg == null || bg.getAlpha() == 0)) {
            Bitmap bitmap = TransitionUtils.createDrawableBitmap(d, imageView);
            if (bitmap != null) {
                Bundle bundle = new Bundle();
                if (bitmap.getConfig() != Bitmap.Config.HARDWARE) {
                    bundle.putParcelable(BUNDLE_SNAPSHOT_BITMAP, bitmap);
                } else {
                    GraphicBuffer graphicBuffer = bitmap.createGraphicBufferHandle();
                    bundle.putParcelable(BUNDLE_SNAPSHOT_GRAPHIC_BUFFER, graphicBuffer);
                    ColorSpace cs = bitmap.getColorSpace();
                    if (cs != null) {
                        bundle.putInt(BUNDLE_SNAPSHOT_COLOR_SPACE, cs.getId());
                    }
                }
                bundle.putString(BUNDLE_SNAPSHOT_IMAGE_SCALETYPE, imageView.getScaleType().toString());
                if (imageView.getScaleType() == ScaleType.MATRIX) {
                    Matrix matrix = imageView.getImageMatrix();
                    float[] values = new float[9];
                    matrix.getValues(values);
                    bundle.putFloatArray(BUNDLE_SNAPSHOT_IMAGE_MATRIX, values);
                }
                return bundle;
            }
        }
    }
    if (mTempMatrix == null) {
        mTempMatrix = new Matrix(viewToGlobalMatrix);
    } else {
        mTempMatrix.set(viewToGlobalMatrix);
    }
    ViewGroup parent = (ViewGroup) sharedElement.getParent();
    return TransitionUtils.createViewBitmap(sharedElement, mTempMatrix, screenBounds, parent);
}
------------------------
Find a silently evolved API code:android.graphics.BitmapRegionDecoder.decodeRegion:COMMENT
Method Modifier: public      
Comment:/**
 * Decodes a rectangle region in the image specified by rect.
 *
 * @param rect The rectangle that specified the region to be decode.
 * @param options null-ok; Options that control downsampling.
 * inPurgeable is not supported.
 * @return The decoded bitmap, or null if the image data could not be
 * decoded.
 * @throws IllegalArgumentException if {@link BitmapFactory.Options#inPreferredConfig}
 * is {@link android.graphics.Bitmap.Config#HARDWARE}
 * and {@link BitmapFactory.Options#inMutable} is set, if the specified color space
 * is not {@link ColorSpace.Model#RGB RGB}, or if the specified color space's transfer
 * function is not an {@link ColorSpace.Rgb.TransferParameters ICC parametric curve}
 */

Body of Frist Method:
{
    BitmapFactory.Options.validate(options);
    synchronized (mNativeLock) {
        checkRecycled("decodeRegion called on recycled region decoder");
        if (rect.right <= 0 || rect.bottom <= 0 || rect.left >= getWidth() || rect.top >= getHeight())
            throw new IllegalArgumentException("rectangle is outside the image");
        return nativeDecodeRegion(mNativeBitmapRegionDecoder, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top, options);
    }
}
Body of Second Method:
{
    BitmapFactory.Options.validate(options);
    synchronized (mNativeLock) {
        checkRecycled("decodeRegion called on recycled region decoder");
        if (rect.right <= 0 || rect.bottom <= 0 || rect.left >= getWidth() || rect.top >= getHeight())
            throw new IllegalArgumentException("rectangle is outside the image");
        return nativeDecodeRegion(mNativeBitmapRegionDecoder, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top, options, BitmapFactory.Options.nativeInBitmap(options), BitmapFactory.Options.nativeColorSpace(options));
    }
}
------------------------
Find a silently evolved API code:android.graphics.Picture.getWidth:COMMENT
Method Modifier: public      
Comment:/**
 * Get the width of the picture as passed to beginRecording. This
 * does not reflect (per se) the content of the picture.
 */

Body of Frist Method:
{
    return nativeGetWidth(mNativePicture);
}
Body of Second Method:
{
    verifyValid();
    return nativeGetWidth(mNativePicture);
}
------------------------
Find a silently evolved API code:android.os.ParcelFileDescriptor.detachFd:COMMENT
Method Modifier: public      
Comment:/**
 * Return the native fd int for this ParcelFileDescriptor and detach it from
 * the object here. You are now responsible for closing the fd in native
 * code.
 * <p>
 * You should not detach when the original creator of the descriptor is
 * expecting a reliable signal through {@link #close()} or
 * {@link #closeWithError(String)}.
 *
 * @see #canDetectErrors()
 */

Body of Frist Method:
{
    if (mWrapped != null) {
        return mWrapped.detachFd();
    } else {
        if (mClosed) {
            throw new IllegalStateException("Already closed");
        }
        final int fd = getFd();
        mFd.setInt$(-1);
        writeCommStatusAndClose(Status.DETACHED, null);
        mClosed = true;
        mGuard.close();
        releaseResources();
        return fd;
    }
}
Body of Second Method:
{
    if (mWrapped != null) {
        return mWrapped.detachFd();
    } else {
        if (mClosed) {
            throw new IllegalStateException("Already closed");
        }
        int fd = IoUtils.acquireRawFd(mFd);
        writeCommStatusAndClose(Status.DETACHED, null);
        mClosed = true;
        mGuard.close();
        releaseResources();
        return fd;
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.explicitCallTransfer:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Performs explicit call transfer.
 *
 * That means connect other calls and disconnect.
 *
 * @param device remote device
 * @return <code>true</code> if command has been issued successfully; <code>false</code>
 * otherwise; upon completion HFP sends {@link #ACTION_CALL_CHANGED} intent.
 *
 * <p>Feature required for successful execution is being reported by: {@link
 * #EXTRA_AG_FEATURE_MERGE_AND_DETACH}. This method invocation will fail silently when feature
 * is not supported.</p>
 */

Body of Frist Method:
{
    if (DBG)
        log("explicitCallTransfer()");
    final IBluetoothHeadsetClient service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.explicitCallTransfer(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("explicitCallTransfer()");
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.explicitCallTransfer(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.media.MediaExtractor.getAudioPresentations:COMMENT
Method Modifier: public      
Comment:/**
 * Get the list of available audio presentations for the track.
 * @param trackIndex index of the track.
 * @return a list of available audio presentations for a given valid audio track index.
 * The list will be empty if the source does not contain any audio presentations.
 */

Body of Frist Method:
{
    return new ArrayList<AudioPresentation>();
}
Body of Second Method:
{
    return native_getAudioPresentations(trackIndex);
}
------------------------
Find a silently evolved API code:android.service.carrier.CarrierIdentifier.readFromParcel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    mMcc = in.readString();
    mMnc = in.readString();
    mSpn = in.readString();
    mImsi = in.readString();
    mGid1 = in.readString();
    mGid2 = in.readString();
}
Body of Second Method:
{
    mMcc = in.readString();
    mMnc = in.readString();
    mSpn = in.readString();
    mImsi = in.readString();
    mGid1 = in.readString();
    mGid2 = in.readString();
    mCarrierId = in.readInt();
    mSpecificCarrierId = in.readInt();
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothPbapClient.setPriority:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Set priority of the profile
 *
 * <p> The device should already be paired.
 * Priority can be one of {@link #PRIORITY_ON} or
 * {@link #PRIORITY_OFF},
 *
 * @param device Paired bluetooth device
 * @param priority Priority of this profile
 * @return true if priority is set, false on error
 */

Body of Frist Method:
{
    if (DBG) {
        log("setPriority(" + device + ", " + priority + ")");
    }
    final IBluetoothPbapClient service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        if (priority != BluetoothProfile.PRIORITY_OFF && priority != BluetoothProfile.PRIORITY_ON) {
            return false;
        }
        try {
            return service.setPriority(device, priority);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null) {
        Log.w(TAG, "Proxy not attached to service");
    }
    return false;
}
Body of Second Method:
{
    if (DBG) {
        log("setPriority(" + device + ", " + priority + ")");
    }
    final IBluetoothPbapClient service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        if (priority != BluetoothProfile.PRIORITY_OFF && priority != BluetoothProfile.PRIORITY_ON) {
            return false;
        }
        try {
            return service.setPriority(device, priority);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null) {
        Log.w(TAG, "Proxy not attached to service");
    }
    return false;
}
------------------------
Find a silently evolved API code:android.hardware.camera2.CameraMetadata.getKeys:COMMENT
Method Modifier: public      
Comment:/**
 * Returns a list of the keys contained in this map.
 *
 * <p>The list returned is not modifiable, so any attempts to modify it will throw
 * a {@code UnsupportedOperationException}.</p>
 *
 * <p>All values retrieved by a key from this list with {@code #get} are guaranteed to be
 * non-{@code null}. Each key is only listed once in the list. The order of the keys
 * is undefined.</p>
 *
 * @return List of the keys contained in this map.
 */

Body of Frist Method:
{
    Class<CameraMetadata<TKey>> thisClass = (Class<CameraMetadata<TKey>>) getClass();
    return Collections.unmodifiableList(getKeys(thisClass, getKeyClass(), this, /*filterTags*/
    null));
}
Body of Second Method:
{
    Class<CameraMetadata<TKey>> thisClass = (Class<CameraMetadata<TKey>>) getClass();
    return Collections.unmodifiableList(getKeys(thisClass, getKeyClass(), this, /*filterTags*/
    null, /*includeSynthetic*/
    true));
}
------------------------
Find a silently evolved API code:android.hardware.camera2.CameraCharacteristics.getAvailableCaptureResultKeys:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the list of keys supported by this {@link CameraDevice} for querying
 * with a {@link CaptureResult}.
 *
 * <p>The list returned is not modifiable, so any attempts to modify it will throw
 * a {@code UnsupportedOperationException}.</p>
 *
 * <p>Each key is only listed once in the list. The order of the keys is undefined.</p>
 *
 * <p>Note that there is no {@code getAvailableCameraCharacteristicsKeys()} -- use
 * {@link #getKeys()} instead.</p>
 *
 * @return List of keys supported by this CameraDevice for CaptureResults.
 */

Body of Frist Method:
{
    if (mAvailableResultKeys == null) {
        Object crKey = CaptureResult.Key.class;
        Class<CaptureResult.Key<?>> crKeyTyped = (Class<CaptureResult.Key<?>>) crKey;
        int[] filterTags = get(REQUEST_AVAILABLE_RESULT_KEYS);
        if (filterTags == null) {
            throw new AssertionError("android.request.availableResultKeys must be non-null " + "in the characteristics");
        }
        mAvailableResultKeys = getAvailableKeyList(CaptureResult.class, crKeyTyped, filterTags);
    }
    return mAvailableResultKeys;
}
Body of Second Method:
{
    if (mAvailableResultKeys == null) {
        Object crKey = CaptureResult.Key.class;
        Class<CaptureResult.Key<?>> crKeyTyped = (Class<CaptureResult.Key<?>>) crKey;
        int[] filterTags = get(REQUEST_AVAILABLE_RESULT_KEYS);
        if (filterTags == null) {
            throw new AssertionError("android.request.availableResultKeys must be non-null " + "in the characteristics");
        }
        mAvailableResultKeys = getAvailableKeyList(CaptureResult.class, crKeyTyped, filterTags, /*includeSynthetic*/
        true);
    }
    return mAvailableResultKeys;
}
------------------------
Find a silently evolved API code:android.net.NetworkAgent.explicitlySelected:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Called by the bearer to indicate this network was manually selected by the user.
 * This should be called before the NetworkInfo is marked CONNECTED so that this
 * Network can be given special treatment at that time. If {@code acceptUnvalidated} is
 * {@code true}, then the system will switch to this network. If it is {@code false} and the
 * network cannot be validated, the system will ask the user whether to switch to this network.
 * If the user confirms and selects "don't ask again", then the system will call
 * {@link #saveAcceptUnvalidated} to persist the user's choice. Thus, if the transport ever
 * calls this method with {@code acceptUnvalidated} set to {@code false}, it must also implement
 * {@link #saveAcceptUnvalidated} to respect the user's choice.
 */

Body of Frist Method:
{
    queueOrSendMessage(EVENT_SET_EXPLICITLY_SELECTED, acceptUnvalidated);
}
Body of Second Method:
{
    explicitlySelected(true, /* explicitlySelected */
    acceptUnvalidated);
}
------------------------
Find a silently evolved API code:android.location.GnssMeasurement.getStateString:COMMENT
Method Modifier: private     
Comment:/**
 * Gets a string representation of the 'sync state'.
 *
 * <p>For internal and logging use only.
 */

Body of Frist Method:
{
    if (mState == STATE_UNKNOWN) {
        return "Unknown";
    }
    StringBuilder builder = new StringBuilder();
    if ((mState & STATE_CODE_LOCK) != 0) {
        builder.append("CodeLock|");
    }
    if ((mState & STATE_BIT_SYNC) != 0) {
        builder.append("BitSync|");
    }
    if ((mState & STATE_SUBFRAME_SYNC) != 0) {
        builder.append("SubframeSync|");
    }
    if ((mState & STATE_TOW_DECODED) != 0) {
        builder.append("TowDecoded|");
    }
    if ((mState & STATE_TOW_KNOWN) != 0) {
        builder.append("TowKnown|");
    }
    if ((mState & STATE_MSEC_AMBIGUOUS) != 0) {
        builder.append("MsecAmbiguous|");
    }
    if ((mState & STATE_SYMBOL_SYNC) != 0) {
        builder.append("SymbolSync|");
    }
    if ((mState & STATE_GLO_STRING_SYNC) != 0) {
        builder.append("GloStringSync|");
    }
    if ((mState & STATE_GLO_TOD_DECODED) != 0) {
        builder.append("GloTodDecoded|");
    }
    if ((mState & STATE_GLO_TOD_KNOWN) != 0) {
        builder.append("GloTodKnown|");
    }
    if ((mState & STATE_BDS_D2_BIT_SYNC) != 0) {
        builder.append("BdsD2BitSync|");
    }
    if ((mState & STATE_BDS_D2_SUBFRAME_SYNC) != 0) {
        builder.append("BdsD2SubframeSync|");
    }
    if ((mState & STATE_GAL_E1BC_CODE_LOCK) != 0) {
        builder.append("GalE1bcCodeLock|");
    }
    if ((mState & STATE_GAL_E1C_2ND_CODE_LOCK) != 0) {
        builder.append("E1c2ndCodeLock|");
    }
    if ((mState & STATE_GAL_E1B_PAGE_SYNC) != 0) {
        builder.append("GalE1bPageSync|");
    }
    if ((mState & STATE_SBAS_SYNC) != 0) {
        builder.append("SbasSync|");
    }
    int remainingStates = mState & ~STATE_ALL;
    if (remainingStates > 0) {
        builder.append("Other(");
        builder.append(Integer.toBinaryString(remainingStates));
        builder.append(")|");
    }
    builder.setLength(builder.length() - 1);
    return builder.toString();
}
Body of Second Method:
{
    if (mState == STATE_UNKNOWN) {
        return "Unknown";
    }
    StringBuilder builder = new StringBuilder();
    if ((mState & STATE_CODE_LOCK) != 0) {
        builder.append("CodeLock|");
    }
    if ((mState & STATE_BIT_SYNC) != 0) {
        builder.append("BitSync|");
    }
    if ((mState & STATE_SUBFRAME_SYNC) != 0) {
        builder.append("SubframeSync|");
    }
    if ((mState & STATE_TOW_DECODED) != 0) {
        builder.append("TowDecoded|");
    }
    if ((mState & STATE_TOW_KNOWN) != 0) {
        builder.append("TowKnown|");
    }
    if ((mState & STATE_MSEC_AMBIGUOUS) != 0) {
        builder.append("MsecAmbiguous|");
    }
    if ((mState & STATE_SYMBOL_SYNC) != 0) {
        builder.append("SymbolSync|");
    }
    if ((mState & STATE_GLO_STRING_SYNC) != 0) {
        builder.append("GloStringSync|");
    }
    if ((mState & STATE_GLO_TOD_DECODED) != 0) {
        builder.append("GloTodDecoded|");
    }
    if ((mState & STATE_GLO_TOD_KNOWN) != 0) {
        builder.append("GloTodKnown|");
    }
    if ((mState & STATE_BDS_D2_BIT_SYNC) != 0) {
        builder.append("BdsD2BitSync|");
    }
    if ((mState & STATE_BDS_D2_SUBFRAME_SYNC) != 0) {
        builder.append("BdsD2SubframeSync|");
    }
    if ((mState & STATE_GAL_E1BC_CODE_LOCK) != 0) {
        builder.append("GalE1bcCodeLock|");
    }
    if ((mState & STATE_GAL_E1C_2ND_CODE_LOCK) != 0) {
        builder.append("E1c2ndCodeLock|");
    }
    if ((mState & STATE_GAL_E1B_PAGE_SYNC) != 0) {
        builder.append("GalE1bPageSync|");
    }
    if ((mState & STATE_SBAS_SYNC) != 0) {
        builder.append("SbasSync|");
    }
    if ((mState & STATE_2ND_CODE_LOCK) != 0) {
        builder.append("2ndCodeLock|");
    }
    int remainingStates = mState & ~STATE_ALL;
    if (remainingStates > 0) {
        builder.append("Other(");
        builder.append(Integer.toBinaryString(remainingStates));
        builder.append(")|");
    }
    builder.setLength(builder.length() - 1);
    return builder.toString();
}
------------------------
Find a silently evolved API code:android.app.Service.stopForeground:COMMENT
Method Modifier: public      final       
Comment:/**
 * Remove this service from foreground state, allowing it to be killed if
 * more memory is needed.  This does not stop the service from running (for that
 * you use {@link #stopSelf()} or related methods), just takes it out of the
 * foreground state.
 *
 * @param flags additional behavior options.
 * @see #startForeground(int, Notification)
 */

Body of Frist Method:
{
    try {
        mActivityManager.setServiceForeground(new ComponentName(this, mClassName), mToken, 0, null, flags);
    } catch (RemoteException ex) {
    }
}
Body of Second Method:
{
    try {
        mActivityManager.setServiceForeground(new ComponentName(this, mClassName), mToken, 0, null, flags, 0);
    } catch (RemoteException ex) {
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHidHost.getReport:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Send Get_Report command to the connected HID input device.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN} permission.
 *
 * @param device Remote Bluetooth Device
 * @param reportType Report type
 * @param reportId Report ID
 * @param bufferSize Report receiving buffer size
 * @return false on immediate error, true otherwise
 * @hide
 */

Body of Frist Method:
{
    if (VDBG) {
        log("getReport(" + device + "), reportType=" + reportType + " reportId=" + reportId + "bufferSize=" + bufferSize);
    }
    final IBluetoothHidHost service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getReport(device, reportType, reportId, bufferSize);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (VDBG) {
        log("getReport(" + device + "), reportType=" + reportType + " reportId=" + reportId + "bufferSize=" + bufferSize);
    }
    final IBluetoothHidHost service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getReport(device, reportType, reportId, bufferSize);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.media.MediaExtractor.getCasInfo:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieves the information about the conditional access system used to scramble
 * a track.
 *
 * @param index of the track.
 * @return an {@link CasInfo} object describing the conditional access system.
 */

Body of Frist Method:
{
    Map<String, Object> formatMap = getTrackFormatNative(index);
    if (formatMap.containsKey(MediaFormat.KEY_CA_SYSTEM_ID)) {
        int systemId = ((Integer) formatMap.get(MediaFormat.KEY_CA_SYSTEM_ID)).intValue();
        MediaCas.Session session = null;
        if (mMediaCas != null && formatMap.containsKey(MediaFormat.KEY_CA_SESSION_ID)) {
            ByteBuffer buf = (ByteBuffer) formatMap.get(MediaFormat.KEY_CA_SESSION_ID);
            buf.rewind();
            final byte[] sessionId = new byte[buf.remaining()];
            buf.get(sessionId);
            session = mMediaCas.createFromSessionId(toByteArray(sessionId));
        }
        return new CasInfo(systemId, session);
    }
    return null;
}
Body of Second Method:
{
    Map<String, Object> formatMap = getTrackFormatNative(index);
    if (formatMap.containsKey(MediaFormat.KEY_CA_SYSTEM_ID)) {
        int systemId = ((Integer) formatMap.get(MediaFormat.KEY_CA_SYSTEM_ID)).intValue();
        MediaCas.Session session = null;
        byte[] privateData = null;
        if (formatMap.containsKey(MediaFormat.KEY_CA_PRIVATE_DATA)) {
            ByteBuffer buf = (ByteBuffer) formatMap.get(MediaFormat.KEY_CA_PRIVATE_DATA);
            buf.rewind();
            privateData = new byte[buf.remaining()];
            buf.get(privateData);
        }
        if (mMediaCas != null && formatMap.containsKey(MediaFormat.KEY_CA_SESSION_ID)) {
            ByteBuffer buf = (ByteBuffer) formatMap.get(MediaFormat.KEY_CA_SESSION_ID);
            buf.rewind();
            final byte[] sessionId = new byte[buf.remaining()];
            buf.get(sessionId);
            session = mMediaCas.createFromSessionId(toByteArray(sessionId));
        }
        return new CasInfo(systemId, session, privateData);
    }
    return null;
}
------------------------
Find a silently evolved API code:android.graphics.ImageFormat.isPublicFormat:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Determine whether or not this is a public-visible {@code format}.
 *
 * <p>In particular, {@code @hide} formats will return {@code false}.</p>
 *
 * <p>Any other formats (including UNKNOWN) will return {@code false}.</p>
 *
 * @param format an integer format
 * @return a boolean
 *
 * @hide
 */

Body of Frist Method:
{
    switch(format) {
        case RGB_565:
        case NV16:
        case YUY2:
        case YV12:
        case JPEG:
        case NV21:
        case YUV_420_888:
        case YUV_422_888:
        case YUV_444_888:
        case FLEX_RGB_888:
        case FLEX_RGBA_8888:
        case RAW_SENSOR:
        case RAW_PRIVATE:
        case RAW10:
        case RAW12:
        case DEPTH16:
        case DEPTH_POINT_CLOUD:
        case PRIVATE:
        case RAW_DEPTH:
            return true;
    }
    return false;
}
Body of Second Method:
{
    switch(format) {
        case RGB_565:
        case NV16:
        case YUY2:
        case YV12:
        case JPEG:
        case NV21:
        case YUV_420_888:
        case YUV_422_888:
        case YUV_444_888:
        case FLEX_RGB_888:
        case FLEX_RGBA_8888:
        case RAW_SENSOR:
        case RAW_PRIVATE:
        case RAW10:
        case RAW12:
        case DEPTH16:
        case DEPTH_POINT_CLOUD:
        case PRIVATE:
        case RAW_DEPTH:
        case Y8:
        case DEPTH_JPEG:
        case HEIC:
            return true;
    }
    return false;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothAvrcpController.sendGroupNavigationCmd:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Send Group Navigation Command to Remote.
 * possible keycode values: next_grp, previous_grp defined above
 */

Body of Frist Method:
{
    Log.d(TAG, "sendGroupNavigationCmd dev = " + device + " key " + keyCode + " State = " + keyState);
    final IBluetoothAvrcpController service = mService;
    if (service != null && isEnabled()) {
        try {
            service.sendGroupNavigationCmd(device, keyCode, keyState);
            return;
        } catch (RemoteException e) {
            Log.e(TAG, "Error talking to BT service in sendGroupNavigationCmd()", e);
            return;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
}
Body of Second Method:
{
    Log.d(TAG, "sendGroupNavigationCmd dev = " + device + " key " + keyCode + " State = " + keyState);
    final IBluetoothAvrcpController service = getService();
    if (service != null && isEnabled()) {
        try {
            service.sendGroupNavigationCmd(device, keyCode, keyState);
            return;
        } catch (RemoteException e) {
            Log.e(TAG, "Error talking to BT service in sendGroupNavigationCmd()", e);
            return;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
}
------------------------
Find a silently evolved API code:android.media.Rating.getStarRating:COMMENT
Method Modifier: public      
Comment:/**
 * Return the star-based rating value.
 * @return a rating value greater or equal to 0.0f, or a negative value if the rating style is
 * not star-based, or if it is unrated.
 */

Body of Frist Method:
{
    switch(mRatingStyle) {
        case RATING_3_STARS:
        case RATING_4_STARS:
        case RATING_5_STARS:
            if (isRated()) {
                return mRatingValue;
            }
        default:
            return -1.0f;
    }
}
Body of Second Method:
{
    float ratingValue = -1.0f;
    switch(mRatingStyle) {
        case RATING_3_STARS:
        case RATING_4_STARS:
        case RATING_5_STARS:
            if (isRated()) {
                ratingValue = mRatingValue;
            }
    }
    return ratingValue;
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiScanner.stopBackgroundScan:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * stop an ongoing wifi scan
 * @param listener specifies which scan to cancel; must be same object as passed in {@link
 * #startBackgroundScan}
 */

Body of Frist Method:
{
    Preconditions.checkNotNull(listener, "listener cannot be null");
    int key = removeListener(listener);
    if (key == INVALID_KEY)
        return;
    validateChannel();
    mAsyncChannel.sendMessage(CMD_STOP_BACKGROUND_SCAN, 0, key);
}
Body of Second Method:
{
    Preconditions.checkNotNull(listener, "listener cannot be null");
    int key = removeListener(listener);
    if (key == INVALID_KEY)
        return;
    validateChannel();
    Bundle scanParams = new Bundle();
    scanParams.putString(REQUEST_PACKAGE_NAME_KEY, mContext.getOpPackageName());
    mAsyncChannel.sendMessage(CMD_STOP_BACKGROUND_SCAN, 0, key, scanParams);
}
------------------------
Find a silently evolved API code:android.location.Location.reset:COMMENT
Method Modifier: public      
Comment:/**
 * Clears the contents of the location.
 */

Body of Frist Method:
{
    mProvider = null;
    mTime = 0;
    mElapsedRealtimeNanos = 0;
    mFieldsMask = 0;
    mLatitude = 0;
    mLongitude = 0;
    mAltitude = 0;
    mSpeed = 0;
    mBearing = 0;
    mHorizontalAccuracyMeters = 0;
    mVerticalAccuracyMeters = 0;
    mSpeedAccuracyMetersPerSecond = 0;
    mBearingAccuracyDegrees = 0;
    mExtras = null;
}
Body of Second Method:
{
    mProvider = null;
    mTime = 0;
    mElapsedRealtimeNanos = 0;
    mElapsedRealtimeUncertaintyNanos = 0.0;
    mFieldsMask = 0;
    mLatitude = 0;
    mLongitude = 0;
    mAltitude = 0;
    mSpeed = 0;
    mBearing = 0;
    mHorizontalAccuracyMeters = 0;
    mVerticalAccuracyMeters = 0;
    mSpeedAccuracyMetersPerSecond = 0;
    mBearingAccuracyDegrees = 0;
    mExtras = null;
}
------------------------
Find a silently evolved API code:android.os.IncidentReportArgs.toString:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Print this report as a string.
 */

Body of Frist Method:
{
    final StringBuilder sb = new StringBuilder("Incident(");
    if (mAll) {
        sb.append("all");
    } else {
        final int N = mSections.size();
        if (N > 0) {
            sb.append(mSections.get(0));
        }
        for (int i = 1; i < N; i++) {
            sb.append(" ");
            sb.append(mSections.get(i));
        }
    }
    sb.append(", ");
    sb.append(mHeaders.size());
    sb.append(" headers), ");
    sb.append("Dest enum value: ").append(mDest);
    return sb.toString();
}
Body of Second Method:
{
    final StringBuilder sb = new StringBuilder("Incident(");
    if (mAll) {
        sb.append("all");
    } else {
        final int N = mSections.size();
        if (N > 0) {
            sb.append(mSections.get(0));
        }
        for (int i = 1; i < N; i++) {
            sb.append(" ");
            sb.append(mSections.get(i));
        }
    }
    sb.append(", ");
    sb.append(mHeaders.size());
    sb.append(" headers), ");
    sb.append("privacy: ").append(mPrivacyPolicy);
    sb.append("receiver pkg: ").append(mReceiverPkg);
    sb.append("receiver cls: ").append(mReceiverCls);
    return sb.toString();
}
------------------------
Find a silently evolved API code:android.text.style.TextAppearanceSpan.writeToParcelInternal:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    dest.writeString(mFamilyName);
    dest.writeInt(mStyle);
    dest.writeInt(mTextSize);
    if (mTextColor != null) {
        dest.writeInt(1);
        mTextColor.writeToParcel(dest, flags);
    } else {
        dest.writeInt(0);
    }
    if (mTextColorLink != null) {
        dest.writeInt(1);
        mTextColorLink.writeToParcel(dest, flags);
    } else {
        dest.writeInt(0);
    }
    LeakyTypefaceStorage.writeTypefaceToParcel(mTypeface, dest);
}
Body of Second Method:
{
    dest.writeString(mFamilyName);
    dest.writeInt(mStyle);
    dest.writeInt(mTextSize);
    if (mTextColor != null) {
        dest.writeInt(1);
        mTextColor.writeToParcel(dest, flags);
    } else {
        dest.writeInt(0);
    }
    if (mTextColorLink != null) {
        dest.writeInt(1);
        mTextColorLink.writeToParcel(dest, flags);
    } else {
        dest.writeInt(0);
    }
    LeakyTypefaceStorage.writeTypefaceToParcel(mTypeface, dest);
    dest.writeInt(mTextFontWeight);
    dest.writeParcelable(mTextLocales, flags);
    dest.writeFloat(mShadowRadius);
    dest.writeFloat(mShadowDx);
    dest.writeFloat(mShadowDy);
    dest.writeInt(mShadowColor);
    dest.writeBoolean(mHasElegantTextHeight);
    dest.writeBoolean(mElegantTextHeight);
    dest.writeBoolean(mHasLetterSpacing);
    dest.writeFloat(mLetterSpacing);
    dest.writeString(mFontFeatureSettings);
    dest.writeString(mFontVariationSettings);
}
------------------------
Find a silently evolved API code:android.telephony.SmsMessage.createFromPdu:COMMENT
Method Modifier: public      static      
Comment:/**
 * Create an SmsMessage from a raw PDU with the specified message format. The
 * message format is passed in the
 * {@link android.provider.Telephony.Sms.Intents#SMS_RECEIVED_ACTION} as the {@code format}
 * String extra, and will be either "3gpp" for GSM/UMTS/LTE messages in 3GPP format
 * or "3gpp2" for CDMA/LTE messages in 3GPP2 format.
 *
 * @param pdu the message PDU from the
 * {@link android.provider.Telephony.Sms.Intents#SMS_RECEIVED_ACTION} intent
 * @param format the format extra from the
 * {@link android.provider.Telephony.Sms.Intents#SMS_RECEIVED_ACTION} intent
 */

Body of Frist Method:
{
    SmsMessageBase wrappedMessage;
    if (pdu == null) {
        Rlog.i(LOG_TAG, "createFromPdu(): pdu is null");
        return null;
    }
    if (SmsConstants.FORMAT_3GPP2.equals(format)) {
        wrappedMessage = com.android.internal.telephony.cdma.SmsMessage.createFromPdu(pdu);
    } else if (SmsConstants.FORMAT_3GPP.equals(format)) {
        wrappedMessage = com.android.internal.telephony.gsm.SmsMessage.createFromPdu(pdu);
    } else {
        Rlog.e(LOG_TAG, "createFromPdu(): unsupported message format " + format);
        return null;
    }
    if (wrappedMessage != null) {
        return new SmsMessage(wrappedMessage);
    } else {
        Rlog.e(LOG_TAG, "createFromPdu(): wrappedMessage is null");
        return null;
    }
}
Body of Second Method:
{
    return createFromPdu(pdu, format, true);
}
------------------------
Find a silently evolved API code:android.app.ActivityView.cleanTapExcludeRegion:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Report to server that tap exclude region on hosting display should be cleared.
 */

Body of Frist Method:
{
    // Update tap exclude region with an empty rect to clean the state on server.
    try {
        WindowManagerGlobal.getWindowSession().updateTapExcludeRegion(getWindow(), hashCode(), 0, /* left */
        0, /* top */
        0, /* width */
        0);
    } catch (RemoteException e) {
        e.rethrowAsRuntimeException();
    }
}
Body of Second Method:
{
    if (!isAttachedToWindow() || mTapExcludeRegion.isEmpty()) {
        return;
    }
    // Update tap exclude region with a null region to clean the state on server.
    try {
        WindowManagerGlobal.getWindowSession().updateTapExcludeRegion(getWindow(), hashCode(), null);
        mTapExcludeRegion.setEmpty();
    } catch (RemoteException e) {
        e.rethrowAsRuntimeException();
    }
}
------------------------
Find a silently evolved API code:android.app.servertransaction.NewIntentItem.writeToParcel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Write to Parcel.
 */

Body of Frist Method:
{
    dest.writeBoolean(mPause);
    dest.writeTypedList(mIntents, flags);
}
Body of Second Method:
{
    dest.writeBoolean(mResume);
    dest.writeTypedList(mIntents, flags);
}
------------------------
Find a silently evolved API code:android.media.AudioRecordingConfiguration.toLogFriendlyString:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return new String("session:" + arc.mSessionId + " -- source:" + MediaRecorder.toLogFriendlyAudioSource(arc.mClientSource) + " -- uid:" + arc.mClientUid + " -- patch:" + arc.mPatchHandle + " -- pack:" + arc.mClientPackageName + " -- format client=" + arc.mClientFormat.toLogFriendlyString() + ", dev=" + arc.mDeviceFormat.toLogFriendlyString());
}
Body of Second Method:
{
    String clientEffects = new String();
    for (AudioEffect.Descriptor desc : arc.mClientEffects) {
        clientEffects += "'" + desc.name + "' ";
    }
    String deviceEffects = new String();
    for (AudioEffect.Descriptor desc : arc.mDeviceEffects) {
        deviceEffects += "'" + desc.name + "' ";
    }
    return new String("session:" + arc.mClientSessionId + " -- source client=" + MediaRecorder.toLogFriendlyAudioSource(arc.mClientSource) + ", dev=" + arc.mDeviceFormat.toLogFriendlyString() + " -- uid:" + arc.mClientUid + " -- patch:" + arc.mPatchHandle + " -- pack:" + arc.mClientPackageName + " -- format client=" + arc.mClientFormat.toLogFriendlyString() + ", dev=" + arc.mDeviceFormat.toLogFriendlyString() + " -- silenced:" + arc.mClientSilenced + " -- effects client=" + clientEffects + ", dev=" + deviceEffects);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothGatt.writeDescriptor:COMMENT
Method Modifier: public      
Comment:/**
 * Write the value of a given descriptor to the associated remote device.
 *
 * <p>A {@link BluetoothGattCallback#onDescriptorWrite} callback is
 * triggered to report the result of the write operation.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param descriptor Descriptor to write to the associated remote device
 * @return true, if the write operation was initiated successfully
 */

Body of Frist Method:
{
    if (VDBG)
        Log.d(TAG, "writeDescriptor() - uuid: " + descriptor.getUuid());
    if (mService == null || mClientIf == 0 || descriptor.getValue() == null)
        return false;
    BluetoothGattCharacteristic characteristic = descriptor.getCharacteristic();
    if (characteristic == null)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusy) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.writeDescriptor(mClientIf, device.getAddress(), descriptor.getInstanceId(), AUTHENTICATION_NONE, descriptor.getValue());
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}
Body of Second Method:
{
    if (VDBG)
        Log.d(TAG, "writeDescriptor() - uuid: " + descriptor.getUuid());
    if (mService == null || mClientIf == 0 || descriptor.getValue() == null)
        return false;
    BluetoothGattCharacteristic characteristic = descriptor.getCharacteristic();
    if (characteristic == null)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusyLock) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.writeDescriptor(mClientIf, device.getAddress(), descriptor.getInstanceId(), AUTHENTICATION_NONE, descriptor.getValue());
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}
------------------------
Find a silently evolved API code:android.media.RemoteController.sendMediaKeyEvent:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * Send a simulated key event for a media button to be received by the current client.
 * To simulate a key press, you must first send a KeyEvent built with
 * a {@link KeyEvent#ACTION_DOWN} action, then another event with the {@link KeyEvent#ACTION_UP}
 * action.
 * <p>The key event will be sent to the registered receiver
 * (see {@link AudioManager#registerMediaButtonEventReceiver(PendingIntent)}) whose associated
 * {@link RemoteControlClient}'s metadata and playback state is published (there may be
 * none under some circumstances).
 * @param keyEvent a {@link KeyEvent} instance whose key code is one of
 * {@link KeyEvent#KEYCODE_MUTE},
 * {@link KeyEvent#KEYCODE_HEADSETHOOK},
 * {@link KeyEvent#KEYCODE_MEDIA_PLAY},
 * {@link KeyEvent#KEYCODE_MEDIA_PAUSE},
 * {@link KeyEvent#KEYCODE_MEDIA_PLAY_PAUSE},
 * {@link KeyEvent#KEYCODE_MEDIA_STOP},
 * {@link KeyEvent#KEYCODE_MEDIA_NEXT},
 * {@link KeyEvent#KEYCODE_MEDIA_PREVIOUS},
 * {@link KeyEvent#KEYCODE_MEDIA_REWIND},
 * {@link KeyEvent#KEYCODE_MEDIA_RECORD},
 * {@link KeyEvent#KEYCODE_MEDIA_FAST_FORWARD},
 * {@link KeyEvent#KEYCODE_MEDIA_CLOSE},
 * {@link KeyEvent#KEYCODE_MEDIA_EJECT},
 * or {@link KeyEvent#KEYCODE_MEDIA_AUDIO_TRACK}.
 * @return true if the event was successfully sent, false otherwise.
 * @throws IllegalArgumentException
 */

Body of Frist Method:
{
    if (!KeyEvent.isMediaKey(keyEvent.getKeyCode())) {
        throw new IllegalArgumentException("not a media key event");
    }
    synchronized (mInfoLock) {
        if (mCurrentSession != null) {
            return mCurrentSession.dispatchMediaButtonEvent(keyEvent);
        }
        return false;
    }
}
Body of Second Method:
{
    if (!KeyEvent.isMediaSessionKey(keyEvent.getKeyCode())) {
        throw new IllegalArgumentException("not a media key event");
    }
    synchronized (mInfoLock) {
        if (mCurrentSession != null) {
            return mCurrentSession.dispatchMediaButtonEvent(keyEvent);
        }
        return false;
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiScanner.getScanResults:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * reports currently available scan results on appropriate listeners
 * @return true if all scan results were reported correctly
 */

Body of Frist Method:
{
    validateChannel();
    Message reply = mAsyncChannel.sendMessageSynchronously(CMD_GET_SCAN_RESULTS, 0);
    return reply.what == CMD_OP_SUCCEEDED;
}
Body of Second Method:
{
    validateChannel();
    Bundle scanParams = new Bundle();
    scanParams.putString(REQUEST_PACKAGE_NAME_KEY, mContext.getOpPackageName());
    Message reply = mAsyncChannel.sendMessageSynchronously(CMD_GET_SCAN_RESULTS, 0, 0, scanParams);
    return reply.what == CMD_OP_SUCCEEDED;
}
------------------------
Find a silently evolved API code:android.media.AudioFormat.getChannelIndexMask:COMMENT
Method Modifier: public      
Comment:/**
 * Return the channel index mask.
 * See the section on <a href="#channelMask">channel masks</a> for more information about
 * the difference between index-based masks, and position-based masks (as returned
 * by {@link #getChannelMask()}).
 * @return one of the values that can be set in {@link Builder#setChannelIndexMask(int)} or
 * {@link AudioFormat#CHANNEL_INVALID} if not set or an invalid mask was used.
 */

Body of Frist Method:
{
    if ((mPropertySetMask & AUDIO_FORMAT_HAS_PROPERTY_CHANNEL_INDEX_MASK) == 0) {
        return CHANNEL_INVALID;
    }
    return mChannelIndexMask;
}
Body of Second Method:
{
    return mChannelIndexMask;
}
------------------------
Find a silently evolved API code:android.service.notification.NotificationAssistantService.adjustNotification:COMMENT
Method Modifier: public      final       hidden      
Comment:/**
 * Updates a notification.  N.B. this wont cause
 * an existing notification to alert, but might allow a future update to
 * this notification to alert.
 *
 * @param adjustment the adjustment with an explanation
 */

Body of Frist Method:
{
    if (!isBound())
        return;
    try {
        getNotificationInterface().applyAdjustmentFromAssistant(mWrapper, adjustment);
    } catch (android.os.RemoteException ex) {
        Log.v(TAG, "Unable to contact notification manager", ex);
        throw ex.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    if (!isBound())
        return;
    try {
        setAdjustmentIssuer(adjustment);
        getNotificationInterface().applyEnqueuedAdjustmentFromAssistant(mWrapper, adjustment);
    } catch (android.os.RemoteException ex) {
        Log.v(TAG, "Unable to contact notification manager", ex);
        throw ex.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.text.BoringLayout.init:COMMENT
Method Modifier: default     
Comment:/* package */

Body of Frist Method:
{
    int spacing;
    if (source instanceof String && align == Layout.Alignment.ALIGN_NORMAL) {
        mDirect = source.toString();
    } else {
        mDirect = null;
    }
    mPaint = paint;
    if (includePad) {
        spacing = metrics.bottom - metrics.top;
        mDesc = metrics.bottom;
    } else {
        spacing = metrics.descent - metrics.ascent;
        mDesc = metrics.descent;
    }
    mBottom = spacing;
    if (trustWidth) {
        mMax = metrics.width;
    } else {
        /*
             * If we have ellipsized, we have to actually calculate the
             * width because the width that was passed in was for the
             * full text, not the ellipsized form.
             */
        TextLine line = TextLine.obtain();
        line.set(paint, source, 0, source.length(), Layout.DIR_LEFT_TO_RIGHT, Layout.DIRS_ALL_LEFT_TO_RIGHT, false, null);
        mMax = (int) Math.ceil(line.metrics(null));
        TextLine.recycle(line);
    }
    if (includePad) {
        mTopPadding = metrics.top - metrics.ascent;
        mBottomPadding = metrics.bottom - metrics.descent;
    }
}
Body of Second Method:
{
    int spacing;
    if (source instanceof String && align == Layout.Alignment.ALIGN_NORMAL) {
        mDirect = source.toString();
    } else {
        mDirect = null;
    }
    mPaint = paint;
    if (includePad) {
        spacing = metrics.bottom - metrics.top;
        mDesc = metrics.bottom;
    } else {
        spacing = metrics.descent - metrics.ascent;
        mDesc = metrics.descent;
    }
    mBottom = spacing;
    if (trustWidth) {
        mMax = metrics.width;
    } else {
        /*
             * If we have ellipsized, we have to actually calculate the
             * width because the width that was passed in was for the
             * full text, not the ellipsized form.
             */
        TextLine line = TextLine.obtain();
        line.set(paint, source, 0, source.length(), Layout.DIR_LEFT_TO_RIGHT, Layout.DIRS_ALL_LEFT_TO_RIGHT, false, null, mEllipsizedStart, mEllipsizedStart + mEllipsizedCount);
        mMax = (int) Math.ceil(line.metrics(null));
        TextLine.recycle(line);
    }
    if (includePad) {
        mTopPadding = metrics.top - metrics.ascent;
        mBottomPadding = metrics.bottom - metrics.descent;
    }
}
------------------------
Find a silently evolved API code:android.media.ImageUtils.getEstimatedNativeAllocBytes:COMMENT
Method Modifier: public      static      
Comment:/**
 * Return the estimated native allocation size in bytes based on width, height, format,
 * and number of images.
 *
 * <p>This is a very rough estimation and should only be used for native allocation
 * registration in VM so it can be accounted for during GC.</p>
 *
 * @param width The width of the images.
 * @param height The height of the images.
 * @param format The format of the images.
 * @param numImages The number of the images.
 */

Body of Frist Method:
{
    double estimatedBytePerPixel;
    switch(format) {
        // 10x compression from RGB_888
        case ImageFormat.JPEG:
        case ImageFormat.DEPTH_POINT_CLOUD:
            estimatedBytePerPixel = 0.3;
            break;
        case ImageFormat.Y8:
            estimatedBytePerPixel = 1.0;
            break;
        case ImageFormat.RAW10:
            estimatedBytePerPixel = 1.25;
            break;
        case ImageFormat.YV12:
        case ImageFormat.YUV_420_888:
        case ImageFormat.NV21:
        case ImageFormat.RAW12:
        case // A rough estimate because the real size is unknown.
        ImageFormat.PRIVATE:
            estimatedBytePerPixel = 1.5;
            break;
        case ImageFormat.NV16:
        case PixelFormat.RGB_565:
        case ImageFormat.YUY2:
        case ImageFormat.Y16:
        case ImageFormat.RAW_DEPTH:
        case ImageFormat.RAW_SENSOR:
        // round estimate, real size is unknown
        case ImageFormat.RAW_PRIVATE:
        case ImageFormat.DEPTH16:
            estimatedBytePerPixel = 2.0;
            break;
        case PixelFormat.RGB_888:
            estimatedBytePerPixel = 3.0;
            break;
        case PixelFormat.RGBA_8888:
        case PixelFormat.RGBX_8888:
            estimatedBytePerPixel = 4.0;
            break;
        default:
            throw new UnsupportedOperationException(String.format("Invalid format specified %d", format));
    }
    return (int) (width * height * estimatedBytePerPixel * numImages);
}
Body of Second Method:
{
    double estimatedBytePerPixel;
    switch(format) {
        // 10x compression from RGB_888
        case ImageFormat.JPEG:
        case ImageFormat.DEPTH_POINT_CLOUD:
        case ImageFormat.DEPTH_JPEG:
        case ImageFormat.HEIC:
            estimatedBytePerPixel = 0.3;
            break;
        case ImageFormat.Y8:
            estimatedBytePerPixel = 1.0;
            break;
        case ImageFormat.RAW10:
            estimatedBytePerPixel = 1.25;
            break;
        case ImageFormat.YV12:
        case ImageFormat.YUV_420_888:
        case ImageFormat.NV21:
        case ImageFormat.RAW12:
        case // A rough estimate because the real size is unknown.
        ImageFormat.PRIVATE:
            estimatedBytePerPixel = 1.5;
            break;
        case ImageFormat.NV16:
        case PixelFormat.RGB_565:
        case ImageFormat.YUY2:
        case ImageFormat.Y16:
        case ImageFormat.RAW_DEPTH:
        case ImageFormat.RAW_SENSOR:
        // round estimate, real size is unknown
        case ImageFormat.RAW_PRIVATE:
        case ImageFormat.DEPTH16:
            estimatedBytePerPixel = 2.0;
            break;
        case PixelFormat.RGB_888:
            estimatedBytePerPixel = 3.0;
            break;
        case PixelFormat.RGBA_8888:
        case PixelFormat.RGBX_8888:
            estimatedBytePerPixel = 4.0;
            break;
        default:
            throw new UnsupportedOperationException(String.format("Invalid format specified %d", format));
    }
    return (int) (width * height * estimatedBytePerPixel * numImages);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothPan.getConnectedDevices:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (VDBG)
        log("getConnectedDevices()");
    final IBluetoothPan service = mPanService;
    if (service != null && isEnabled()) {
        try {
            return service.getConnectedDevices();
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
Body of Second Method:
{
    if (VDBG)
        log("getConnectedDevices()");
    final IBluetoothPan service = getService();
    if (service != null && isEnabled()) {
        try {
            return service.getConnectedDevices();
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiEnterpriseConfig.setClientKeyEntryWithCertificateChain:COMMENT
Method Modifier: public      
Comment:/**
 * Specify a private key and client certificate chain for client authorization.
 *
 * <p>A default name is automatically assigned to the key entry and used
 * with this configuration.  The framework takes care of installing the
 * key entry when the config is saved and removing the key entry when
 * the config is removed.
 *
 * @param privateKey a PrivateKey instance for the end certificate.
 * @param clientCertificateChain an array of X509Certificate instances which starts with
 * end certificate and continues with additional CA certificates necessary to
 * link the end certificate with some root certificate known by the authenticator.
 * @throws IllegalArgumentException for an invalid key or certificate.
 */

Body of Frist Method:
{
    X509Certificate[] newCerts = null;
    if (clientCertificateChain != null && clientCertificateChain.length > 0) {
        // https://cryptography.io/en/latest/x509/reference/
        if (clientCertificateChain[0].getBasicConstraints() != -1) {
            throw new IllegalArgumentException("First certificate in the chain must be a client end certificate");
        }
        for (int i = 1; i < clientCertificateChain.length; i++) {
            if (clientCertificateChain[i].getBasicConstraints() == -1) {
                throw new IllegalArgumentException("All certificates following the first must be CA certificates");
            }
        }
        newCerts = Arrays.copyOf(clientCertificateChain, clientCertificateChain.length);
        if (privateKey == null) {
            throw new IllegalArgumentException("Client cert without a private key");
        }
        if (privateKey.getEncoded() == null) {
            throw new IllegalArgumentException("Private key cannot be encoded");
        }
    }
    mClientPrivateKey = privateKey;
    mClientCertificateChain = newCerts;
}
Body of Second Method:
{
    X509Certificate[] newCerts = null;
    if (clientCertificateChain != null && clientCertificateChain.length > 0) {
        // https://cryptography.io/en/latest/x509/reference/
        if (clientCertificateChain[0].getBasicConstraints() != -1) {
            throw new IllegalArgumentException("First certificate in the chain must be a client end certificate");
        }
        for (int i = 1; i < clientCertificateChain.length; i++) {
            if (clientCertificateChain[i].getBasicConstraints() == -1) {
                throw new IllegalArgumentException("All certificates following the first must be CA certificates");
            }
        }
        newCerts = Arrays.copyOf(clientCertificateChain, clientCertificateChain.length);
        if (privateKey == null) {
            throw new IllegalArgumentException("Client cert without a private key");
        }
        if (privateKey.getEncoded() == null) {
            throw new IllegalArgumentException("Private key cannot be encoded");
        }
    }
    mClientPrivateKey = privateKey;
    mClientCertificateChain = newCerts;
    mIsAppInstalledDeviceKeyAndCert = true;
}
------------------------
Find a silently evolved API code:android.view.WindowInsets.hasSystemWindowInsets:COMMENT
Method Modifier: public      
Comment:/**
 * Returns true if this WindowInsets has nonzero system window insets.
 *
 * <p>The system window inset represents the area of a full-screen window that is
 * partially or fully obscured by the status bar, navigation bar, IME or other system windows.
 * </p>
 *
 * @return true if any of the system window inset values are nonzero
 */

Body of Frist Method:
{
    return mSystemWindowInsets.left != 0 || mSystemWindowInsets.top != 0 || mSystemWindowInsets.right != 0 || mSystemWindowInsets.bottom != 0;
}
Body of Second Method:
{
    return !getSystemWindowInsets().equals(Insets.NONE);
}
------------------------
Find a silently evolved API code:android.net.NetworkStats.apply464xlatAdjustments:COMMENT
<android.net.NetworkStats: void apply464xlatAdjustments(Map<String, String>)>
public      hidden      ->public      
Method Modifier: public      hidden      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * Calculate and apply adjustments to captured statistics for 464xlat traffic counted twice.
 *
 * <p>This mutates the object this method is called on. Equivalent to calling
 * {@link #apply464xlatAdjustments(NetworkStats, NetworkStats, Map)} with {@code this} as
 * base and stacked traffic.
 * @param stackedIfaces Mapping ipv6if -> ipv4if interface where traffic is counted on both.
 */

Body of Frist Method:
{
    apply464xlatAdjustments(this, this, stackedIfaces);
}
Body of Second Method:
{
    apply464xlatAdjustments(this, this, stackedIfaces, useBpfStats);
}
------------------------
Find a silently evolved API code:android.content.pm.PackageManager.installStatusToString:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * {@hide}
 */

Body of Frist Method:
{
    switch(status) {
        case INSTALL_SUCCEEDED:
            return "INSTALL_SUCCEEDED";
        case INSTALL_FAILED_ALREADY_EXISTS:
            return "INSTALL_FAILED_ALREADY_EXISTS";
        case INSTALL_FAILED_INVALID_APK:
            return "INSTALL_FAILED_INVALID_APK";
        case INSTALL_FAILED_INVALID_URI:
            return "INSTALL_FAILED_INVALID_URI";
        case INSTALL_FAILED_INSUFFICIENT_STORAGE:
            return "INSTALL_FAILED_INSUFFICIENT_STORAGE";
        case INSTALL_FAILED_DUPLICATE_PACKAGE:
            return "INSTALL_FAILED_DUPLICATE_PACKAGE";
        case INSTALL_FAILED_NO_SHARED_USER:
            return "INSTALL_FAILED_NO_SHARED_USER";
        case INSTALL_FAILED_UPDATE_INCOMPATIBLE:
            return "INSTALL_FAILED_UPDATE_INCOMPATIBLE";
        case INSTALL_FAILED_SHARED_USER_INCOMPATIBLE:
            return "INSTALL_FAILED_SHARED_USER_INCOMPATIBLE";
        case INSTALL_FAILED_MISSING_SHARED_LIBRARY:
            return "INSTALL_FAILED_MISSING_SHARED_LIBRARY";
        case INSTALL_FAILED_REPLACE_COULDNT_DELETE:
            return "INSTALL_FAILED_REPLACE_COULDNT_DELETE";
        case INSTALL_FAILED_DEXOPT:
            return "INSTALL_FAILED_DEXOPT";
        case INSTALL_FAILED_OLDER_SDK:
            return "INSTALL_FAILED_OLDER_SDK";
        case INSTALL_FAILED_CONFLICTING_PROVIDER:
            return "INSTALL_FAILED_CONFLICTING_PROVIDER";
        case INSTALL_FAILED_NEWER_SDK:
            return "INSTALL_FAILED_NEWER_SDK";
        case INSTALL_FAILED_TEST_ONLY:
            return "INSTALL_FAILED_TEST_ONLY";
        case INSTALL_FAILED_CPU_ABI_INCOMPATIBLE:
            return "INSTALL_FAILED_CPU_ABI_INCOMPATIBLE";
        case INSTALL_FAILED_MISSING_FEATURE:
            return "INSTALL_FAILED_MISSING_FEATURE";
        case INSTALL_FAILED_CONTAINER_ERROR:
            return "INSTALL_FAILED_CONTAINER_ERROR";
        case INSTALL_FAILED_INVALID_INSTALL_LOCATION:
            return "INSTALL_FAILED_INVALID_INSTALL_LOCATION";
        case INSTALL_FAILED_MEDIA_UNAVAILABLE:
            return "INSTALL_FAILED_MEDIA_UNAVAILABLE";
        case INSTALL_FAILED_VERIFICATION_TIMEOUT:
            return "INSTALL_FAILED_VERIFICATION_TIMEOUT";
        case INSTALL_FAILED_VERIFICATION_FAILURE:
            return "INSTALL_FAILED_VERIFICATION_FAILURE";
        case INSTALL_FAILED_PACKAGE_CHANGED:
            return "INSTALL_FAILED_PACKAGE_CHANGED";
        case INSTALL_FAILED_UID_CHANGED:
            return "INSTALL_FAILED_UID_CHANGED";
        case INSTALL_FAILED_VERSION_DOWNGRADE:
            return "INSTALL_FAILED_VERSION_DOWNGRADE";
        case INSTALL_PARSE_FAILED_NOT_APK:
            return "INSTALL_PARSE_FAILED_NOT_APK";
        case INSTALL_PARSE_FAILED_BAD_MANIFEST:
            return "INSTALL_PARSE_FAILED_BAD_MANIFEST";
        case INSTALL_PARSE_FAILED_UNEXPECTED_EXCEPTION:
            return "INSTALL_PARSE_FAILED_UNEXPECTED_EXCEPTION";
        case INSTALL_PARSE_FAILED_NO_CERTIFICATES:
            return "INSTALL_PARSE_FAILED_NO_CERTIFICATES";
        case INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES:
            return "INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES";
        case INSTALL_PARSE_FAILED_CERTIFICATE_ENCODING:
            return "INSTALL_PARSE_FAILED_CERTIFICATE_ENCODING";
        case INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME:
            return "INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME";
        case INSTALL_PARSE_FAILED_BAD_SHARED_USER_ID:
            return "INSTALL_PARSE_FAILED_BAD_SHARED_USER_ID";
        case INSTALL_PARSE_FAILED_MANIFEST_MALFORMED:
            return "INSTALL_PARSE_FAILED_MANIFEST_MALFORMED";
        case INSTALL_PARSE_FAILED_MANIFEST_EMPTY:
            return "INSTALL_PARSE_FAILED_MANIFEST_EMPTY";
        case INSTALL_FAILED_INTERNAL_ERROR:
            return "INSTALL_FAILED_INTERNAL_ERROR";
        case INSTALL_FAILED_USER_RESTRICTED:
            return "INSTALL_FAILED_USER_RESTRICTED";
        case INSTALL_FAILED_DUPLICATE_PERMISSION:
            return "INSTALL_FAILED_DUPLICATE_PERMISSION";
        case INSTALL_FAILED_NO_MATCHING_ABIS:
            return "INSTALL_FAILED_NO_MATCHING_ABIS";
        case INSTALL_FAILED_ABORTED:
            return "INSTALL_FAILED_ABORTED";
        case INSTALL_FAILED_BAD_DEX_METADATA:
            return "INSTALL_FAILED_BAD_DEX_METADATA";
        default:
            return Integer.toString(status);
    }
}
Body of Second Method:
{
    final String str = installStatusToString(status);
    if (msg != null) {
        return str + ": " + msg;
    } else {
        return str;
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothA2dp.connect:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Initiate connection to a profile of the remote Bluetooth device.
 *
 * <p> This API returns false in scenarios like the profile on the
 * device is already connected or Bluetooth is not turned on.
 * When this API returns true, it is guaranteed that
 * connection state intent for the profile will be broadcasted with
 * the state. Users can get the connection state of the profile
 * from this intent.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}
 * permission.
 *
 * @param device Remote Bluetooth Device
 * @return false on immediate error, true otherwise
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("connect(" + device + ")");
    try {
        mServiceLock.readLock().lock();
        if (mService != null && isEnabled() && isValidDevice(device)) {
            return mService.connect(device);
        }
        if (mService == null)
            Log.w(TAG, "Proxy not attached to service");
        return false;
    } catch (RemoteException e) {
        Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
        return false;
    } finally {
        mServiceLock.readLock().unlock();
    }
}
Body of Second Method:
{
    if (DBG)
        log("connect(" + device + ")");
    try {
        final IBluetoothA2dp service = getService();
        if (service != null && isEnabled() && isValidDevice(device)) {
            return service.connect(device);
        }
        if (service == null)
            Log.w(TAG, "Proxy not attached to service");
        return false;
    } catch (RemoteException e) {
        Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
        return false;
    }
}
------------------------
Find a silently evolved API code:android.media.session.MediaController.getQueue:COMMENT
Method Modifier: public      
Comment:/**
 * Get the current play queue for this session if one is set. If you only
 * care about the current item {@link #getMetadata()} should be used.
 *
 * @return The current play queue or null.
 */

Body of Frist Method:
{
    try {
        ParceledListSlice queue = mSessionBinder.getQueue();
        if (queue != null) {
            return queue.getList();
        }
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling getQueue.", e);
    }
    return null;
}
Body of Second Method:
{
    try {
        ParceledListSlice list = mSessionBinder.getQueue();
        return list == null ? null : list.getList();
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling getQueue.", e);
    }
    return null;
}
------------------------
Find a silently evolved API code:android.graphics.drawable.Icon.setTintMode:COMMENT
Method Modifier: public      
Comment:/**
 * Store a blending mode to use whenever this Icon is drawn.
 *
 * @param mode a blending mode, as in {@link Drawable#setTintMode(PorterDuff.Mode)}, may be null
 * @return this same object, for use in chained construction
 */

Body of Frist Method:
{
    mTintMode = mode;
    return this;
}
Body of Second Method:
{
    mBlendMode = BlendMode.fromValue(mode.nativeInt);
    return this;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothA2dp.getDevicesMatchingConnectionStates:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (VDBG)
        log("getDevicesMatchingStates()");
    try {
        mServiceLock.readLock().lock();
        if (mService != null && isEnabled()) {
            return mService.getDevicesMatchingConnectionStates(states);
        }
        if (mService == null)
            Log.w(TAG, "Proxy not attached to service");
        return new ArrayList<BluetoothDevice>();
    } catch (RemoteException e) {
        Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
        return new ArrayList<BluetoothDevice>();
    } finally {
        mServiceLock.readLock().unlock();
    }
}
Body of Second Method:
{
    if (VDBG)
        log("getDevicesMatchingStates()");
    try {
        final IBluetoothA2dp service = getService();
        if (service != null && isEnabled()) {
            return service.getDevicesMatchingConnectionStates(states);
        }
        if (service == null)
            Log.w(TAG, "Proxy not attached to service");
        return new ArrayList<BluetoothDevice>();
    } catch (RemoteException e) {
        Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
        return new ArrayList<BluetoothDevice>();
    }
}
------------------------
Find a silently evolved API code:android.telephony.CellSignalStrengthCdma.copyFrom:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    mCdmaDbm = s.mCdmaDbm;
    mCdmaEcio = s.mCdmaEcio;
    mEvdoDbm = s.mEvdoDbm;
    mEvdoEcio = s.mEvdoEcio;
    mEvdoSnr = s.mEvdoSnr;
}
Body of Second Method:
{
    mCdmaDbm = s.mCdmaDbm;
    mCdmaEcio = s.mCdmaEcio;
    mEvdoDbm = s.mEvdoDbm;
    mEvdoEcio = s.mEvdoEcio;
    mEvdoSnr = s.mEvdoSnr;
    mLevel = s.mLevel;
}
------------------------
Find a silently evolved API code:android.text.method.BaseKeyListener.getOffsetForForwardDeleteKey:COMMENT
Method Modifier: private     static      
Comment:// Returns the end offset to be deleted by a forward delete key from the given offset.

Body of Frist Method:
{
    final int len = text.length();
    if (offset >= len - 1) {
        return len;
    }
    offset = paint.getTextRunCursor(text, offset, len, Paint.DIRECTION_LTR, /* not used */
    offset, Paint.CURSOR_AFTER);
    return adjustReplacementSpan(text, offset, false);
}
Body of Second Method:
{
    final int len = text.length();
    if (offset >= len - 1) {
        return len;
    }
    offset = paint.getTextRunCursor(text, offset, len, false, /* LTR, not used */
    offset, Paint.CURSOR_AFTER);
    return adjustReplacementSpan(text, offset, false);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothA2dpSink.getPriority:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the priority of the profile.
 *
 * <p> The priority can be any of:
 * {@link #PRIORITY_AUTO_CONNECT}, {@link #PRIORITY_OFF},
 * {@link #PRIORITY_ON}, {@link #PRIORITY_UNDEFINED}
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param device Bluetooth device
 * @return priority of the device
 * @hide
 */

Body of Frist Method:
{
    if (VDBG)
        log("getPriority(" + device + ")");
    final IBluetoothA2dpSink service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getPriority(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.PRIORITY_OFF;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return BluetoothProfile.PRIORITY_OFF;
}
Body of Second Method:
{
    if (VDBG)
        log("getPriority(" + device + ")");
    final IBluetoothA2dpSink service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getPriority(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.PRIORITY_OFF;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return BluetoothProfile.PRIORITY_OFF;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothPbapClient.getPriority:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the priority of the profile.
 *
 * <p> The priority can be any of:
 * {@link #PRIORITY_AUTO_CONNECT}, {@link #PRIORITY_OFF},
 * {@link #PRIORITY_ON}, {@link #PRIORITY_UNDEFINED}
 *
 * @param device Bluetooth device
 * @return priority of the device
 */

Body of Frist Method:
{
    if (VDBG) {
        log("getPriority(" + device + ")");
    }
    final IBluetoothPbapClient service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getPriority(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return PRIORITY_OFF;
        }
    }
    if (service == null) {
        Log.w(TAG, "Proxy not attached to service");
    }
    return PRIORITY_OFF;
}
Body of Second Method:
{
    if (VDBG) {
        log("getPriority(" + device + ")");
    }
    final IBluetoothPbapClient service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getPriority(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return PRIORITY_OFF;
        }
    }
    if (service == null) {
        Log.w(TAG, "Proxy not attached to service");
    }
    return PRIORITY_OFF;
}
------------------------
Find a silently evolved API code:android.text.SpannableStringInternal.equals:COMMENT
Method Modifier: public      
Comment:// Same as SpannableStringBuilder

Body of Frist Method:
{
    if (o instanceof Spanned && toString().equals(o.toString())) {
        Spanned other = (Spanned) o;
        // Check span data
        Object[] otherSpans = other.getSpans(0, other.length(), Object.class);
        if (mSpanCount == otherSpans.length) {
            for (int i = 0; i < mSpanCount; ++i) {
                Object thisSpan = mSpans[i];
                Object otherSpan = otherSpans[i];
                if (thisSpan == this) {
                    if (other != otherSpan || getSpanStart(thisSpan) != other.getSpanStart(otherSpan) || getSpanEnd(thisSpan) != other.getSpanEnd(otherSpan) || getSpanFlags(thisSpan) != other.getSpanFlags(otherSpan)) {
                        return false;
                    }
                } else if (!thisSpan.equals(otherSpan) || getSpanStart(thisSpan) != other.getSpanStart(otherSpan) || getSpanEnd(thisSpan) != other.getSpanEnd(otherSpan) || getSpanFlags(thisSpan) != other.getSpanFlags(otherSpan)) {
                    return false;
                }
            }
            return true;
        }
    }
    return false;
}
Body of Second Method:
{
    if (o instanceof Spanned && toString().equals(o.toString())) {
        final Spanned other = (Spanned) o;
        // Check span data
        final Object[] otherSpans = other.getSpans(0, other.length(), Object.class);
        final Object[] thisSpans = getSpans(0, length(), Object.class);
        if (mSpanCount == otherSpans.length) {
            for (int i = 0; i < mSpanCount; ++i) {
                final Object thisSpan = thisSpans[i];
                final Object otherSpan = otherSpans[i];
                if (thisSpan == this) {
                    if (other != otherSpan || getSpanStart(thisSpan) != other.getSpanStart(otherSpan) || getSpanEnd(thisSpan) != other.getSpanEnd(otherSpan) || getSpanFlags(thisSpan) != other.getSpanFlags(otherSpan)) {
                        return false;
                    }
                } else if (!thisSpan.equals(otherSpan) || getSpanStart(thisSpan) != other.getSpanStart(otherSpan) || getSpanEnd(thisSpan) != other.getSpanEnd(otherSpan) || getSpanFlags(thisSpan) != other.getSpanFlags(otherSpan)) {
                    return false;
                }
            }
            return true;
        }
    }
    return false;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothAvrcpController.close:COMMENT
Method Modifier: default     hidden      
Comment:/*package*/

Body of Frist Method:
{
    mServiceListener = null;
    IBluetoothManager mgr = mAdapter.getBluetoothManager();
    if (mgr != null) {
        try {
            mgr.unregisterStateChangeCallback(mBluetoothStateChangeCallback);
        } catch (Exception e) {
            Log.e(TAG, "", e);
        }
    }
    synchronized (mConnection) {
        if (mService != null) {
            try {
                mService = null;
                mContext.unbindService(mConnection);
            } catch (Exception re) {
                Log.e(TAG, "", re);
            }
        }
    }
}
Body of Second Method:
{
    mProfileConnector.disconnect();
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiScanner.ScanData.writeToParcel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Implement the Parcelable interface {@hide}
 */

Body of Frist Method:
{
    if (mResults != null) {
        dest.writeInt(mId);
        dest.writeInt(mFlags);
        dest.writeInt(mBucketsScanned);
        dest.writeInt(mAllChannelsScanned ? 1 : 0);
        dest.writeInt(mResults.length);
        for (int i = 0; i < mResults.length; i++) {
            ScanResult result = mResults[i];
            result.writeToParcel(dest, flags);
        }
    } else {
        dest.writeInt(0);
    }
}
Body of Second Method:
{
    if (mResults != null) {
        dest.writeInt(mId);
        dest.writeInt(mFlags);
        dest.writeInt(mBucketsScanned);
        dest.writeInt(mBandScanned);
        dest.writeInt(mResults.length);
        for (int i = 0; i < mResults.length; i++) {
            ScanResult result = mResults[i];
            result.writeToParcel(dest, flags);
        }
    } else {
        dest.writeInt(0);
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.disconnect:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Disconnects remote device
 *
 * @param device a remote device we want disconnect
 * @return <code>true</code> if command has been issued successfully; <code>false</code>
 * otherwise; upon completion HFP sends {@link #ACTION_CONNECTION_STATE_CHANGED} intent.
 */

Body of Frist Method:
{
    if (DBG)
        log("disconnect(" + device + ")");
    final IBluetoothHeadsetClient service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.disconnect(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("disconnect(" + device + ")");
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.disconnect(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.media.audiopolicy.AudioMixingRule.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Combines all of the matching and exclusion rules that have been set and return a new
 * {@link AudioMixingRule} object.
 * @return a new {@link AudioMixingRule} object
 */

Body of Frist Method:
{
    return new AudioMixingRule(mTargetMixType, mCriteria);
}
Body of Second Method:
{
    return new AudioMixingRule(mTargetMixType, mCriteria, mAllowPrivilegedPlaybackCapture);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothA2dp.getConnectionState:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (VDBG)
        log("getState(" + device + ")");
    try {
        mServiceLock.readLock().lock();
        if (mService != null && isEnabled() && isValidDevice(device)) {
            return mService.getConnectionState(device);
        }
        if (mService == null)
            Log.w(TAG, "Proxy not attached to service");
        return BluetoothProfile.STATE_DISCONNECTED;
    } catch (RemoteException e) {
        Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
        return BluetoothProfile.STATE_DISCONNECTED;
    } finally {
        mServiceLock.readLock().unlock();
    }
}
Body of Second Method:
{
    if (VDBG)
        log("getState(" + device + ")");
    try {
        final IBluetoothA2dp service = getService();
        if (service != null && isEnabled() && isValidDevice(device)) {
            return service.getConnectionState(device);
        }
        if (service == null)
            Log.w(TAG, "Proxy not attached to service");
        return BluetoothProfile.STATE_DISCONNECTED;
    } catch (RemoteException e) {
        Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
        return BluetoothProfile.STATE_DISCONNECTED;
    }
}
------------------------
Find a silently evolved API code:android.util.SparseBooleanArray.setKeyAt:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    mKeys[index] = key;
}
Body of Second Method:
{
    if (index >= mSize) {
        // The array might be slightly bigger than mSize, in which case, indexing won't fail.
        throw new ArrayIndexOutOfBoundsException(index);
    }
    mKeys[index] = key;
}
------------------------
Find a silently evolved API code:android.database.DefaultDatabaseErrorHandler.onCorruption:COMMENT
Method Modifier: public      
Comment:/**
 * defines the default method to be invoked when database corruption is detected.
 * @param dbObj the {@link SQLiteDatabase} object representing the database on which corruption
 * is detected.
 */

Body of Frist Method:
{
    Log.e(TAG, "Corruption reported by sqlite on database: " + dbObj.getPath());
    // is the corruption detected even before database could be 'opened'?
    if (!dbObj.isOpen()) {
        // database files are not even openable. delete this database file.
        // NOTE if the database has attached databases, then any of them could be corrupt.
        // and not deleting all of them could cause corrupted database file to remain and
        // make the application crash on database open operation. To avoid this problem,
        // the application should provide its own {@link DatabaseErrorHandler} impl class
        // to delete ALL files of the database (including the attached databases).
        deleteDatabaseFile(dbObj.getPath());
        return;
    }
    List<Pair<String, String>> attachedDbs = null;
    try {
        // before that, get the attached database list first.
        try {
            attachedDbs = dbObj.getAttachedDbs();
        } catch (SQLiteException e) {
        /* ignore */
        }
        try {
            dbObj.close();
        } catch (SQLiteException e) {
        /* ignore */
        }
    } finally {
        // Delete all files of this corrupt database and/or attached databases
        if (attachedDbs != null) {
            for (Pair<String, String> p : attachedDbs) {
                deleteDatabaseFile(p.second);
            }
        } else {
            // attachedDbs = null is possible when the database is so corrupt that even
            // "PRAGMA database_list;" also fails. delete the main database file
            deleteDatabaseFile(dbObj.getPath());
        }
    }
}
Body of Second Method:
{
    Log.e(TAG, "Corruption reported by sqlite on database: " + dbObj.getPath());
    SQLiteDatabase.wipeDetected(dbObj.getPath(), "corruption");
    // is the corruption detected even before database could be 'opened'?
    if (!dbObj.isOpen()) {
        // database files are not even openable. delete this database file.
        // NOTE if the database has attached databases, then any of them could be corrupt.
        // and not deleting all of them could cause corrupted database file to remain and
        // make the application crash on database open operation. To avoid this problem,
        // the application should provide its own {@link DatabaseErrorHandler} impl class
        // to delete ALL files of the database (including the attached databases).
        deleteDatabaseFile(dbObj.getPath());
        return;
    }
    List<Pair<String, String>> attachedDbs = null;
    try {
        // before that, get the attached database list first.
        try {
            attachedDbs = dbObj.getAttachedDbs();
        } catch (SQLiteException e) {
        /* ignore */
        }
        try {
            dbObj.close();
        } catch (SQLiteException e) {
        /* ignore */
        }
    } finally {
        // Delete all files of this corrupt database and/or attached databases
        if (attachedDbs != null) {
            for (Pair<String, String> p : attachedDbs) {
                deleteDatabaseFile(p.second);
            }
        } else {
            // attachedDbs = null is possible when the database is so corrupt that even
            // "PRAGMA database_list;" also fails. delete the main database file
            deleteDatabaseFile(dbObj.getPath());
        }
    }
}
------------------------
Find a silently evolved API code:android.hardware.camera2.params.StreamConfigurationMap.getPublicFormats:COMMENT
Method Modifier: private     
Comment:/**
 * Get the list of publically visible output formats; does not include IMPL_DEFINED
 */

Body of Frist Method:
{
    int[] formats = new int[getPublicFormatCount(output)];
    int i = 0;
    SparseIntArray map = getFormatsMap(output);
    for (int j = 0; j < map.size(); j++) {
        int format = map.keyAt(j);
        formats[i++] = imageFormatToPublic(format);
    }
    if (output) {
        for (int j = 0; j < mDepthOutputFormats.size(); j++) {
            formats[i++] = depthFormatToPublic(mDepthOutputFormats.keyAt(j));
        }
    }
    if (formats.length != i) {
        throw new AssertionError("Too few formats " + i + ", expected " + formats.length);
    }
    return formats;
}
Body of Second Method:
{
    int[] formats = new int[getPublicFormatCount(output)];
    int i = 0;
    SparseIntArray map = getFormatsMap(output);
    for (int j = 0; j < map.size(); j++) {
        int format = map.keyAt(j);
        formats[i++] = imageFormatToPublic(format);
    }
    if (output) {
        for (int j = 0; j < mDepthOutputFormats.size(); j++) {
            formats[i++] = depthFormatToPublic(mDepthOutputFormats.keyAt(j));
        }
        if (mDynamicDepthOutputFormats.size() > 0) {
            // Only one publicly dynamic depth format is available.
            formats[i++] = ImageFormat.DEPTH_JPEG;
        }
        if (mHeicOutputFormats.size() > 0) {
            formats[i++] = ImageFormat.HEIC;
        }
    }
    if (formats.length != i) {
        throw new AssertionError("Too few formats " + i + ", expected " + formats.length);
    }
    return formats;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.enterPrivateMode:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Enters private mode with a specified call.
 *
 * Works only when Extended Call Control is supported by Audio Gateway.
 *
 * @param device remote device
 * @param index index of the call to connect in private mode
 * @return <code>true</code> if command has been issued successfully; <code>false</code>
 * otherwise; upon completion HFP sends {@link #ACTION_CALL_CHANGED} intent.
 *
 * <p>Feature required for successful execution is being reported by: {@link
 * #EXTRA_AG_FEATURE_ECC}. This method invocation will fail silently when feature is not
 * supported.</p>
 */

Body of Frist Method:
{
    if (DBG)
        log("enterPrivateMode()");
    final IBluetoothHeadsetClient service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.enterPrivateMode(device, index);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("enterPrivateMode()");
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.enterPrivateMode(device, index);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.net.http.HttpResponseCache.getRequestCount:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the total number of HTTP requests that were made. This includes
 * both client requests and requests that were made on the client's behalf
 * to handle a redirects and retries.
 */

Body of Frist Method:
{
    return delegate.getRequestCount();
}
Body of Second Method:
{
    return mDelegate.getRequestCount();
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiInfo.setLinkSpeed:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    this.mLinkSpeed = linkSpeed;
}
Body of Second Method:
{
    mLinkSpeed = linkSpeed;
}
------------------------
Find a silently evolved API code:android.telephony.ims.feature.MmTelFeature.setListener:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * @param listener A {@link Listener} used when the MmTelFeature receives an incoming call and
 * notifies the framework.
 */

Body of Frist Method:
{
    synchronized (mLock) {
        mListener = listener;
    }
    if (mListener != null) {
        onFeatureReady();
    }
}
Body of Second Method:
{
    synchronized (mLock) {
        mListener = listener;
        if (mListener != null) {
            onFeatureReady();
        }
    }
}
------------------------
Find a silently evolved API code:android.util.IntArray.set:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets the value at the specified position in this array.
 */

Body of Frist Method:
{
    checkBounds(index);
    mValues[index] = value;
}
Body of Second Method:
{
    ArrayUtils.checkBounds(mSize, index);
    mValues[index] = value;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothMap.isConnected:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns true if the specified Bluetooth device is connected.
 * Returns false if not connected, or if this proxy object is not
 * currently connected to the Map service.
 */

Body of Frist Method:
{
    if (VDBG)
        log("isConnected(" + device + ")");
    final IBluetoothMap service = mService;
    if (service != null) {
        try {
            return service.isConnected(device);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            log(Log.getStackTraceString(new Throwable()));
    }
    return false;
}
Body of Second Method:
{
    if (VDBG)
        log("isConnected(" + device + ")");
    final IBluetoothMap service = getService();
    if (service != null) {
        try {
            return service.isConnected(device);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            log(Log.getStackTraceString(new Throwable()));
    }
    return false;
}
------------------------
Find a silently evolved API code:android.view.WindowInsets.isConsumed:COMMENT
Method Modifier: public      
Comment:/**
 * Check if these insets have been fully consumed.
 *
 * <p>Insets are considered "consumed" if the applicable <code>consume*</code> methods
 * have been called such that all insets have been set to zero. This affects propagation of
 * insets through the view hierarchy; insets that have not been fully consumed will continue
 * to propagate down to child views.</p>
 *
 * <p>The result of this method is equivalent to the return value of
 * {@link View#fitSystemWindows(android.graphics.Rect)}.</p>
 *
 * @return true if the insets have been fully consumed.
 */

Body of Frist Method:
{
    return mSystemWindowInsetsConsumed && mWindowDecorInsetsConsumed && mStableInsetsConsumed && mDisplayCutoutConsumed;
}
Body of Second Method:
{
    return mSystemWindowInsetsConsumed && mStableInsetsConsumed && mDisplayCutoutConsumed;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothAvrcpController.getPlayerSettings:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Gets the player application settings.
 *
 * @return the {@link BluetoothAvrcpPlayerSettings} or {@link null} if there is an error.
 */

Body of Frist Method:
{
    if (DBG)
        Log.d(TAG, "getPlayerSettings");
    BluetoothAvrcpPlayerSettings settings = null;
    final IBluetoothAvrcpController service = mService;
    if (service != null && isEnabled()) {
        try {
            settings = service.getPlayerSettings(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Error talking to BT service in getMetadata() " + e);
            return null;
        }
    }
    return settings;
}
Body of Second Method:
{
    if (DBG)
        Log.d(TAG, "getPlayerSettings");
    BluetoothAvrcpPlayerSettings settings = null;
    final IBluetoothAvrcpController service = getService();
    if (service != null && isEnabled()) {
        try {
            settings = service.getPlayerSettings(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Error talking to BT service in getMetadata() " + e);
            return null;
        }
    }
    return settings;
}
------------------------
Find a silently evolved API code:android.widget.NumberPicker.hideSoftInput:COMMENT
Method Modifier: private     
Comment:/**
 * Hides the soft input if it is active for the input text.
 */

Body of Frist Method:
{
    InputMethodManager inputMethodManager = InputMethodManager.peekInstance();
    if (inputMethodManager != null && inputMethodManager.isActive(mInputText)) {
        inputMethodManager.hideSoftInputFromWindow(getWindowToken(), 0);
    }
    if (mHasSelectorWheel) {
        mInputText.setVisibility(View.INVISIBLE);
    }
}
Body of Second Method:
{
    InputMethodManager inputMethodManager = getContext().getSystemService(InputMethodManager.class);
    if (inputMethodManager != null && inputMethodManager.isActive(mInputText)) {
        inputMethodManager.hideSoftInputFromWindow(getWindowToken(), 0);
    }
    if (mHasSelectorWheel) {
        mInputText.setVisibility(View.INVISIBLE);
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothA2dp.getActiveDevice:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the connected device that is active.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}
 * permission.
 *
 * @return the connected device that is active or null if no device
 * is active
 * @hide
 */

Body of Frist Method:
{
    if (VDBG)
        log("getActiveDevice()");
    try {
        mServiceLock.readLock().lock();
        if (mService != null && isEnabled()) {
            return mService.getActiveDevice();
        }
        if (mService == null)
            Log.w(TAG, "Proxy not attached to service");
        return null;
    } catch (RemoteException e) {
        Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
        return null;
    } finally {
        mServiceLock.readLock().unlock();
    }
}
Body of Second Method:
{
    if (VDBG)
        log("getActiveDevice()");
    try {
        final IBluetoothA2dp service = getService();
        if (service != null && isEnabled()) {
            return service.getActiveDevice();
        }
        if (service == null)
            Log.w(TAG, "Proxy not attached to service");
        return null;
    } catch (RemoteException e) {
        Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
        return null;
    }
}
------------------------
Find a silently evolved API code:android.view.WindowInsets.getSystemWindowInsetTop:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the top system window inset in pixels.
 *
 * <p>The system window inset represents the area of a full-screen window that is
 * partially or fully obscured by the status bar, navigation bar, IME or other system windows.
 * </p>
 *
 * @return The top system window inset
 */

Body of Frist Method:
{
    return mSystemWindowInsets.top;
}
Body of Second Method:
{
    return getSystemWindowInsets().top;
}
------------------------
Find a silently evolved API code:android.telephony.CellSignalStrengthWcdma.setDefaultValues:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    mSignalStrength = Integer.MAX_VALUE;
    mBitErrorRate = Integer.MAX_VALUE;
}
Body of Second Method:
{
    mRssi = CellInfo.UNAVAILABLE;
    mBitErrorRate = CellInfo.UNAVAILABLE;
    mRscp = CellInfo.UNAVAILABLE;
    mEcNo = CellInfo.UNAVAILABLE;
    mLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
}
------------------------
Find a silently evolved API code:android.view.TextureView.draw:COMMENT
Method Modifier: public      final       
Comment:/**
 * Subclasses of TextureView cannot do their own rendering
 * with the {@link Canvas} object.
 *
 * @param canvas The Canvas to which the View is rendered.
 */

Body of Frist Method:
{
    // NOTE: Maintain this carefully (see View#draw)
    mPrivateFlags = (mPrivateFlags & ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;
    if (canvas.isHardwareAccelerated()) {
        DisplayListCanvas displayListCanvas = (DisplayListCanvas) canvas;
        TextureLayer layer = getTextureLayer();
        if (layer != null) {
            applyUpdate();
            applyTransformMatrix();
            // ensure layer paint is up to date
            mLayer.setLayerPaint(mLayerPaint);
            displayListCanvas.drawTextureLayer(layer);
        }
    }
}
Body of Second Method:
{
    // NOTE: Maintain this carefully (see View#draw)
    mPrivateFlags = (mPrivateFlags & ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;
    if (canvas.isHardwareAccelerated()) {
        RecordingCanvas recordingCanvas = (RecordingCanvas) canvas;
        TextureLayer layer = getTextureLayer();
        if (layer != null) {
            applyUpdate();
            applyTransformMatrix();
            // ensure layer paint is up to date
            mLayer.setLayerPaint(mLayerPaint);
            recordingCanvas.drawTextureLayer(layer);
        }
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothPan.getConnectionState:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (VDBG)
        log("getState(" + device + ")");
    final IBluetoothPan service = mPanService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getConnectionState(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.STATE_DISCONNECTED;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return BluetoothProfile.STATE_DISCONNECTED;
}
Body of Second Method:
{
    if (VDBG)
        log("getState(" + device + ")");
    final IBluetoothPan service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getConnectionState(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.STATE_DISCONNECTED;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return BluetoothProfile.STATE_DISCONNECTED;
}
------------------------
Find a silently evolved API code:android.transition.Transition.forceToEnd:COMMENT
Method Modifier: default     hidden      
Comment:/**
 * Force the transition to move to its end state, ending all the animators.
 *
 * @hide
 */

Body of Frist Method:
{
    ArrayMap<Animator, AnimationInfo> runningAnimators = getRunningAnimators();
    int numOldAnims = runningAnimators.size();
    if (sceneRoot != null) {
        WindowId windowId = sceneRoot.getWindowId();
        for (int i = numOldAnims - 1; i >= 0; i--) {
            AnimationInfo info = runningAnimators.valueAt(i);
            if (info.view != null && windowId != null && windowId.equals(info.windowId)) {
                Animator anim = runningAnimators.keyAt(i);
                anim.end();
            }
        }
    }
}
Body of Second Method:
{
    final ArrayMap<Animator, AnimationInfo> runningAnimators = getRunningAnimators();
    int numOldAnims = runningAnimators.size();
    if (sceneRoot == null || numOldAnims == 0) {
        return;
    }
    WindowId windowId = sceneRoot.getWindowId();
    final ArrayMap<Animator, AnimationInfo> oldAnimators = new ArrayMap(runningAnimators);
    runningAnimators.clear();
    for (int i = numOldAnims - 1; i >= 0; i--) {
        AnimationInfo info = oldAnimators.valueAt(i);
        if (info.view != null && windowId != null && windowId.equals(info.windowId)) {
            Animator anim = oldAnimators.keyAt(i);
            anim.end();
        }
    }
}
------------------------
Find a silently evolved API code:android.media.PlayerBase.baseRegisterPlayer:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * Call from derived class when instantiation / initialization is successful
 */

Body of Frist Method:
{
    int newPiid = AudioPlaybackConfiguration.PLAYER_PIID_INVALID;
    IBinder b = ServiceManager.getService(Context.APP_OPS_SERVICE);
    mAppOps = IAppOpsService.Stub.asInterface(b);
    // initialize mHasAppOpsPlayAudio
    updateAppOpsPlayAudio();
    // register a callback to monitor whether the OP_PLAY_AUDIO is still allowed
    mAppOpsCallback = new IAppOpsCallbackWrapper(this);
    try {
        mAppOps.startWatchingMode(AppOpsManager.OP_PLAY_AUDIO, ActivityThread.currentPackageName(), mAppOpsCallback);
    } catch (RemoteException e) {
        Log.e(TAG, "Error registering appOps callback", e);
        mHasAppOpsPlayAudio = false;
    }
    try {
        newPiid = getService().trackPlayer(new PlayerIdCard(mImplType, mAttributes, new IPlayerWrapper(this)));
    } catch (RemoteException e) {
        Log.e(TAG, "Error talking to audio service, player will not be tracked", e);
    }
    mPlayerIId = newPiid;
}
Body of Second Method:
{
    if (!USE_AUDIOFLINGER_MUTING_FOR_OP) {
        IBinder b = ServiceManager.getService(Context.APP_OPS_SERVICE);
        mAppOps = IAppOpsService.Stub.asInterface(b);
        // initialize mHasAppOpsPlayAudio
        updateAppOpsPlayAudio();
        // register a callback to monitor whether the OP_PLAY_AUDIO is still allowed
        mAppOpsCallback = new IAppOpsCallbackWrapper(this);
        try {
            mAppOps.startWatchingMode(AppOpsManager.OP_PLAY_AUDIO, ActivityThread.currentPackageName(), mAppOpsCallback);
        } catch (RemoteException e) {
            Log.e(TAG, "Error registering appOps callback", e);
            mHasAppOpsPlayAudio = false;
        }
    }
    try {
        mPlayerIId = getService().trackPlayer(new PlayerIdCard(mImplType, mAttributes, new IPlayerWrapper(this)));
    } catch (RemoteException e) {
        Log.e(TAG, "Error talking to audio service, player will not be tracked", e);
    }
}
------------------------
Find a silently evolved API code:android.widget.ProgressBar.applySecondaryProgressTint:COMMENT
Method Modifier: private     
Comment:/**
 * Should only be called if we've already verified that mProgressDrawable
 * and mProgressTintInfo are non-null.
 */

Body of Frist Method:
{
    if (mProgressTintInfo.mHasSecondaryProgressTint || mProgressTintInfo.mHasSecondaryProgressTintMode) {
        final Drawable target = getTintTarget(R.id.secondaryProgress, false);
        if (target != null) {
            if (mProgressTintInfo.mHasSecondaryProgressTint) {
                target.setTintList(mProgressTintInfo.mSecondaryProgressTintList);
            }
            if (mProgressTintInfo.mHasSecondaryProgressTintMode) {
                target.setTintMode(mProgressTintInfo.mSecondaryProgressTintMode);
            }
            // stateful before applying the tint, so let's try again.
            if (target.isStateful()) {
                target.setState(getDrawableState());
            }
        }
    }
}
Body of Second Method:
{
    if (mProgressTintInfo.mHasSecondaryProgressTint || mProgressTintInfo.mHasSecondaryProgressTintMode) {
        final Drawable target = getTintTarget(R.id.secondaryProgress, false);
        if (target != null) {
            if (mProgressTintInfo.mHasSecondaryProgressTint) {
                target.setTintList(mProgressTintInfo.mSecondaryProgressTintList);
            }
            if (mProgressTintInfo.mHasSecondaryProgressTintMode) {
                target.setTintBlendMode(mProgressTintInfo.mSecondaryProgressBlendMode);
            }
            // stateful before applying the tint, so let's try again.
            if (target.isStateful()) {
                target.setState(getDrawableState());
            }
        }
    }
}
------------------------
Find a silently evolved API code:android.app.SharedElementCallback.onCreateSnapshotView:COMMENT
Method Modifier: public      
Comment:/**
 * Reconstitutes a snapshot View from a Parcelable returned in
 * {@link #onCaptureSharedElementSnapshot(android.view.View, android.graphics.Matrix,
 * android.graphics.RectF)} to be used in {@link #onSharedElementStart(java.util.List,
 * java.util.List, java.util.List)} and {@link #onSharedElementEnd(java.util.List,
 * java.util.List, java.util.List)}. The returned View will be sized and positioned after
 * this call so that it is ready to be added to the decor View's overlay.
 *
 * <p>This is not called for Fragment Transitions.</p>
 *
 * @param context The Context used to create the snapshot View.
 * @param snapshot The Parcelable returned by {@link #onCaptureSharedElementSnapshot(
 * android.view.View, android.graphics.Matrix, android.graphics.RectF)}.
 * @return A View to be sent in {@link #onSharedElementStart(java.util.List, java.util.List,
 * java.util.List)} and {@link #onSharedElementEnd(java.util.List, java.util.List,
 * java.util.List)}. A null value will produce a null snapshot value for those two methods.
 */

Body of Frist Method:
{
    View view = null;
    if (snapshot instanceof Bundle) {
        Bundle bundle = (Bundle) snapshot;
        GraphicBuffer buffer = bundle.getParcelable(BUNDLE_SNAPSHOT_GRAPHIC_BUFFER);
        Bitmap bitmap = bundle.getParcelable(BUNDLE_SNAPSHOT_BITMAP);
        if (buffer == null && bitmap == null) {
            return null;
        }
        if (bitmap == null) {
            bitmap = Bitmap.createHardwareBitmap(buffer);
        }
        ImageView imageView = new ImageView(context);
        view = imageView;
        imageView.setImageBitmap(bitmap);
        imageView.setScaleType(ScaleType.valueOf(bundle.getString(BUNDLE_SNAPSHOT_IMAGE_SCALETYPE)));
        if (imageView.getScaleType() == ScaleType.MATRIX) {
            float[] values = bundle.getFloatArray(BUNDLE_SNAPSHOT_IMAGE_MATRIX);
            Matrix matrix = new Matrix();
            matrix.setValues(values);
            imageView.setImageMatrix(matrix);
        }
    } else if (snapshot instanceof Bitmap) {
        Bitmap bitmap = (Bitmap) snapshot;
        view = new View(context);
        Resources resources = context.getResources();
        view.setBackground(new BitmapDrawable(resources, bitmap));
    }
    return view;
}
Body of Second Method:
{
    View view = null;
    if (snapshot instanceof Bundle) {
        Bundle bundle = (Bundle) snapshot;
        GraphicBuffer buffer = bundle.getParcelable(BUNDLE_SNAPSHOT_GRAPHIC_BUFFER);
        Bitmap bitmap = bundle.getParcelable(BUNDLE_SNAPSHOT_BITMAP);
        if (buffer == null && bitmap == null) {
            return null;
        }
        if (bitmap == null) {
            ColorSpace colorSpace = null;
            int colorSpaceId = bundle.getInt(BUNDLE_SNAPSHOT_COLOR_SPACE, 0);
            if (colorSpaceId >= 0 && colorSpaceId < ColorSpace.Named.values().length) {
                colorSpace = ColorSpace.get(ColorSpace.Named.values()[colorSpaceId]);
            }
            bitmap = Bitmap.wrapHardwareBuffer(HardwareBuffer.createFromGraphicBuffer(buffer), colorSpace);
        }
        ImageView imageView = new ImageView(context);
        view = imageView;
        imageView.setImageBitmap(bitmap);
        imageView.setScaleType(ScaleType.valueOf(bundle.getString(BUNDLE_SNAPSHOT_IMAGE_SCALETYPE)));
        if (imageView.getScaleType() == ScaleType.MATRIX) {
            float[] values = bundle.getFloatArray(BUNDLE_SNAPSHOT_IMAGE_MATRIX);
            Matrix matrix = new Matrix();
            matrix.setValues(values);
            imageView.setImageMatrix(matrix);
        }
    } else if (snapshot instanceof Bitmap) {
        Bitmap bitmap = (Bitmap) snapshot;
        view = new View(context);
        Resources resources = context.getResources();
        view.setBackground(new BitmapDrawable(resources, bitmap));
    }
    return view;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothSap.isConnected:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns true if the specified Bluetooth device is connected.
 * Returns false if not connected, or if this proxy object is not
 * currently connected to the Sap service.
 *
 * @hide
 */

Body of Frist Method:
{
    if (VDBG)
        log("isConnected(" + device + ")");
    final IBluetoothSap service = mService;
    if (service != null) {
        try {
            return service.isConnected(device);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            log(Log.getStackTraceString(new Throwable()));
    }
    return false;
}
Body of Second Method:
{
    if (VDBG)
        log("isConnected(" + device + ")");
    final IBluetoothSap service = getService();
    if (service != null) {
        try {
            return service.isConnected(device);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            log(Log.getStackTraceString(new Throwable()));
    }
    return false;
}
------------------------
Find a silently evolved API code:android.app.servertransaction.TransactionExecutor.cycleToPath:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Transition the client between states.
 */

Body of Frist Method:
{
    cycleToPath(r, finish, false);
}
Body of Second Method:
{
    cycleToPath(r, finish, false, /* excludeLastState */
    transaction);
}
------------------------
Find a silently evolved API code:android.nfc.NfcAdapter.getNfcAdapter:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Returns the NfcAdapter for application context,
 * or throws if NFC is not available.
 * @hide
 */

Body of Frist Method:
{
    if (!sIsInitialized) {
        sHasNfcFeature = hasNfcFeature();
        boolean hasHceFeature = hasNfcHceFeature();
        /* is this device meant to have NFC */
        if (!sHasNfcFeature && !hasHceFeature) {
            Log.v(TAG, "this device does not have NFC support");
            throw new UnsupportedOperationException();
        }
        sService = getServiceInterface();
        if (sService == null) {
            Log.e(TAG, "could not retrieve NFC service");
            throw new UnsupportedOperationException();
        }
        if (sHasNfcFeature) {
            try {
                sTagService = sService.getNfcTagInterface();
            } catch (RemoteException e) {
                Log.e(TAG, "could not retrieve NFC Tag service");
                throw new UnsupportedOperationException();
            }
        }
        if (hasHceFeature) {
            try {
                sNfcFCardEmulationService = sService.getNfcFCardEmulationInterface();
            } catch (RemoteException e) {
                Log.e(TAG, "could not retrieve NFC-F card emulation service");
                throw new UnsupportedOperationException();
            }
            try {
                sCardEmulationService = sService.getNfcCardEmulationInterface();
            } catch (RemoteException e) {
                Log.e(TAG, "could not retrieve card emulation service");
                throw new UnsupportedOperationException();
            }
        }
        sIsInitialized = true;
    }
    if (context == null) {
        if (sNullContextNfcAdapter == null) {
            sNullContextNfcAdapter = new NfcAdapter(null);
        }
        return sNullContextNfcAdapter;
    }
    NfcAdapter adapter = sNfcAdapters.get(context);
    if (adapter == null) {
        adapter = new NfcAdapter(context);
        sNfcAdapters.put(context, adapter);
    }
    return adapter;
}
Body of Second Method:
{
    if (!sIsInitialized) {
        sHasNfcFeature = hasNfcFeature();
        sHasBeamFeature = hasBeamFeature();
        boolean hasHceFeature = hasNfcHceFeature();
        /* is this device meant to have NFC */
        if (!sHasNfcFeature && !hasHceFeature) {
            Log.v(TAG, "this device does not have NFC support");
            throw new UnsupportedOperationException();
        }
        sService = getServiceInterface();
        if (sService == null) {
            Log.e(TAG, "could not retrieve NFC service");
            throw new UnsupportedOperationException();
        }
        if (sHasNfcFeature) {
            try {
                sTagService = sService.getNfcTagInterface();
            } catch (RemoteException e) {
                Log.e(TAG, "could not retrieve NFC Tag service");
                throw new UnsupportedOperationException();
            }
        }
        if (hasHceFeature) {
            try {
                sNfcFCardEmulationService = sService.getNfcFCardEmulationInterface();
            } catch (RemoteException e) {
                Log.e(TAG, "could not retrieve NFC-F card emulation service");
                throw new UnsupportedOperationException();
            }
            try {
                sCardEmulationService = sService.getNfcCardEmulationInterface();
            } catch (RemoteException e) {
                Log.e(TAG, "could not retrieve card emulation service");
                throw new UnsupportedOperationException();
            }
        }
        sIsInitialized = true;
    }
    if (context == null) {
        if (sNullContextNfcAdapter == null) {
            sNullContextNfcAdapter = new NfcAdapter(null);
        }
        return sNullContextNfcAdapter;
    }
    NfcAdapter adapter = sNfcAdapters.get(context);
    if (adapter == null) {
        adapter = new NfcAdapter(context);
        sNfcAdapters.put(context, adapter);
    }
    return adapter;
}
------------------------
Find a silently evolved API code:android.transition.ChangeImageTransform.createAnimator:COMMENT
Method Modifier: public      
Comment:/**
 * Creates an Animator for ImageViews moving, changing dimensions, and/or changing
 * {@link android.widget.ImageView.ScaleType}.
 *
 * @param sceneRoot   The root of the transition hierarchy.
 * @param startValues The values for a specific target in the start scene.
 * @param endValues   The values for the target in the end scene.
 * @return An Animator to move an ImageView or null if the View is not an ImageView,
 * the Drawable changed, the View is not VISIBLE, or there was no change.
 */

Body of Frist Method:
{
    if (startValues == null || endValues == null) {
        return null;
    }
    Rect startBounds = (Rect) startValues.values.get(PROPNAME_BOUNDS);
    Rect endBounds = (Rect) endValues.values.get(PROPNAME_BOUNDS);
    if (startBounds == null || endBounds == null) {
        return null;
    }
    Matrix startMatrix = (Matrix) startValues.values.get(PROPNAME_MATRIX);
    Matrix endMatrix = (Matrix) endValues.values.get(PROPNAME_MATRIX);
    boolean matricesEqual = (startMatrix == null && endMatrix == null) || (startMatrix != null && startMatrix.equals(endMatrix));
    if (startBounds.equals(endBounds) && matricesEqual) {
        return null;
    }
    ImageView imageView = (ImageView) endValues.view;
    Drawable drawable = imageView.getDrawable();
    int drawableWidth = drawable.getIntrinsicWidth();
    int drawableHeight = drawable.getIntrinsicHeight();
    ObjectAnimator animator;
    if (drawableWidth == 0 || drawableHeight == 0) {
        animator = createNullAnimator(imageView);
    } else {
        if (startMatrix == null) {
            startMatrix = Matrix.IDENTITY_MATRIX;
        }
        if (endMatrix == null) {
            endMatrix = Matrix.IDENTITY_MATRIX;
        }
        ANIMATED_TRANSFORM_PROPERTY.set(imageView, startMatrix);
        animator = createMatrixAnimator(imageView, startMatrix, endMatrix);
    }
    return animator;
}
Body of Second Method:
{
    if (startValues == null || endValues == null) {
        return null;
    }
    Rect startBounds = (Rect) startValues.values.get(PROPNAME_BOUNDS);
    Rect endBounds = (Rect) endValues.values.get(PROPNAME_BOUNDS);
    Matrix startMatrix = (Matrix) startValues.values.get(PROPNAME_MATRIX);
    Matrix endMatrix = (Matrix) endValues.values.get(PROPNAME_MATRIX);
    if (startBounds == null || endBounds == null || startMatrix == null || endMatrix == null) {
        return null;
    }
    if (startBounds.equals(endBounds) && startMatrix.equals(endMatrix)) {
        return null;
    }
    ImageView imageView = (ImageView) endValues.view;
    Drawable drawable = imageView.getDrawable();
    int drawableWidth = drawable.getIntrinsicWidth();
    int drawableHeight = drawable.getIntrinsicHeight();
    ObjectAnimator animator;
    if (drawableWidth <= 0 || drawableHeight <= 0) {
        animator = createNullAnimator(imageView);
    } else {
        ANIMATED_TRANSFORM_PROPERTY.set(imageView, startMatrix);
        animator = createMatrixAnimator(imageView, startMatrix, endMatrix);
    }
    return animator;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothSap.getDevicesMatchingConnectionStates:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the list of devices matching specified states. Currently at most one.
 *
 * @return list of matching devices
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("getDevicesMatchingStates()");
    final IBluetoothSap service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.getDevicesMatchingConnectionStates(states);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
Body of Second Method:
{
    if (DBG)
        log("getDevicesMatchingStates()");
    final IBluetoothSap service = getService();
    if (service != null && isEnabled()) {
        try {
            return service.getDevicesMatchingConnectionStates(states);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
------------------------
Find a silently evolved API code:android.os.ParcelFileDescriptor.fromFd:COMMENT
Method Modifier: public      static      
Comment:/**
 * Create a new ParcelFileDescriptor from a raw native fd.  The new
 * ParcelFileDescriptor holds a dup of the original fd passed in here,
 * so you must still close that fd as well as the new ParcelFileDescriptor.
 *
 * @param fd The native fd that the ParcelFileDescriptor should dup.
 *
 * @return Returns a new ParcelFileDescriptor holding a FileDescriptor
 * for a dup of the given fd.
 */

Body of Frist Method:
{
    final FileDescriptor original = new FileDescriptor();
    original.setInt$(fd);
    try {
        final FileDescriptor dup = Os.dup(original);
        return new ParcelFileDescriptor(dup);
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
}
Body of Second Method:
{
    final FileDescriptor original = new FileDescriptor();
    original.setInt$(fd);
    try {
        final FileDescriptor dup = new FileDescriptor();
        int intfd = Os.fcntlInt(original, (isAtLeastQ() ? F_DUPFD_CLOEXEC : F_DUPFD), 0);
        dup.setInt$(intfd);
        return new ParcelFileDescriptor(dup);
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
}
------------------------
Find a silently evolved API code:android.telephony.CellIdentityGsm.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Implement the Parcelable interface
 */

Body of Frist Method:
{
    if (DBG)
        log("writeToParcel(Parcel, int): " + toString());
    super.writeToParcel(dest, TYPE_GSM);
    dest.writeInt(mLac);
    dest.writeInt(mCid);
    dest.writeInt(mArfcn);
    dest.writeInt(mBsic);
}
Body of Second Method:
{
    if (DBG)
        log("writeToParcel(Parcel, int): " + toString());
    super.writeToParcel(dest, CellInfo.TYPE_GSM);
    dest.writeInt(mLac);
    dest.writeInt(mCid);
    dest.writeInt(mArfcn);
    dest.writeInt(mBsic);
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiConfiguration.getBytesForBackup:COMMENT
<android.net.wifi.WifiConfiguration: byte[] getBytesForBackup()>
public      hidden      ->public      hidden      deprecated  
Method Modifier: public      hidden      deprecated  
Method Modifier: Yes         Yes         No          
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * Serializes the object for backup
 * @hide
 */

Body of Frist Method:
{
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    DataOutputStream out = new DataOutputStream(baos);
    out.writeInt(BACKUP_VERSION);
    BackupUtils.writeString(out, SSID);
    out.writeInt(apBand);
    out.writeInt(apChannel);
    BackupUtils.writeString(out, preSharedKey);
    out.writeInt(getAuthType());
    return baos.toByteArray();
}
Body of Second Method:
{
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    DataOutputStream out = new DataOutputStream(baos);
    out.writeInt(BACKUP_VERSION);
    BackupUtils.writeString(out, SSID);
    out.writeInt(apBand);
    out.writeInt(apChannel);
    BackupUtils.writeString(out, preSharedKey);
    out.writeInt(getAuthType());
    out.writeBoolean(hiddenSSID);
    return baos.toByteArray();
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiScanner.getSingleScanResults:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Retrieve the most recent scan results from a single scan request.
 * {@hide}
 */

Body of Frist Method:
{
    validateChannel();
    Message reply = mAsyncChannel.sendMessageSynchronously(CMD_GET_SINGLE_SCAN_RESULTS, 0);
    if (reply.what == WifiScanner.CMD_OP_SUCCEEDED) {
        return Arrays.asList(((ParcelableScanResults) reply.obj).getResults());
    }
    OperationResult result = (OperationResult) reply.obj;
    Log.e(TAG, "Error retrieving SingleScan results reason: " + result.reason + " description: " + result.description);
    return new ArrayList<ScanResult>();
}
Body of Second Method:
{
    validateChannel();
    Bundle scanParams = new Bundle();
    scanParams.putString(REQUEST_PACKAGE_NAME_KEY, mContext.getOpPackageName());
    Message reply = mAsyncChannel.sendMessageSynchronously(CMD_GET_SINGLE_SCAN_RESULTS, 0, 0, scanParams);
    if (reply.what == WifiScanner.CMD_OP_SUCCEEDED) {
        return Arrays.asList(((ParcelableScanResults) reply.obj).getResults());
    }
    OperationResult result = (OperationResult) reply.obj;
    Log.e(TAG, "Error retrieving SingleScan results reason: " + result.reason + " description: " + result.description);
    return new ArrayList<ScanResult>();
}
------------------------
Find a silently evolved API code:android.view.inputmethod.EditorInfo.dump:COMMENT
Method Modifier: public      
Comment:/**
 * Write debug output of this object.
 */

Body of Frist Method:
{
    pw.println(prefix + "inputType=0x" + Integer.toHexString(inputType) + " imeOptions=0x" + Integer.toHexString(imeOptions) + " privateImeOptions=" + privateImeOptions);
    pw.println(prefix + "actionLabel=" + actionLabel + " actionId=" + actionId);
    pw.println(prefix + "initialSelStart=" + initialSelStart + " initialSelEnd=" + initialSelEnd + " initialCapsMode=0x" + Integer.toHexString(initialCapsMode));
    pw.println(prefix + "hintText=" + hintText + " label=" + label);
    pw.println(prefix + "packageName=" + packageName + " fieldId=" + fieldId + " fieldName=" + fieldName);
    pw.println(prefix + "extras=" + extras);
    pw.println(prefix + "hintLocales=" + hintLocales);
    pw.println(prefix + "contentMimeTypes=" + Arrays.toString(contentMimeTypes));
}
Body of Second Method:
{
    pw.println(prefix + "inputType=0x" + Integer.toHexString(inputType) + " imeOptions=0x" + Integer.toHexString(imeOptions) + " privateImeOptions=" + privateImeOptions);
    pw.println(prefix + "actionLabel=" + actionLabel + " actionId=" + actionId);
    pw.println(prefix + "initialSelStart=" + initialSelStart + " initialSelEnd=" + initialSelEnd + " initialCapsMode=0x" + Integer.toHexString(initialCapsMode));
    pw.println(prefix + "hintText=" + hintText + " label=" + label);
    pw.println(prefix + "packageName=" + packageName + " fieldId=" + fieldId + " fieldName=" + fieldName);
    pw.println(prefix + "extras=" + extras);
    pw.println(prefix + "hintLocales=" + hintLocales);
    pw.println(prefix + "contentMimeTypes=" + Arrays.toString(contentMimeTypes));
    if (targetInputMethodUser != null) {
        pw.println(prefix + "targetInputMethodUserId=" + targetInputMethodUser.getIdentifier());
    }
}
------------------------
Find a silently evolved API code:android.graphics.drawable.GradientDrawable.setOrientation:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the orientation of the gradient defined in this drawable.
 * <p>
 * <strong>Note</strong>: changing orientation will affect all instances
 * of a drawable loaded from a resource. It is recommended to invoke
 * {@link #mutate()} before changing the orientation.
 *
 * @param orientation the desired orientation (angle) of the gradient
 *
 * @see #mutate()
 * @see #getOrientation()
 */

Body of Frist Method:
{
    mGradientState.mOrientation = orientation;
    mGradientIsDirty = true;
    invalidateSelf();
}
Body of Second Method:
{
    mGradientState.setOrientation(orientation);
    mGradientIsDirty = true;
    invalidateSelf();
}
------------------------
Find a silently evolved API code:android.net.http.HttpResponseCache.close:COMMENT
Method Modifier: public      
Comment:/**
 * Uninstalls the cache and releases any active resources. Stored contents
 * will remain on the filesystem.
 */

Body of Frist Method:
{
    if (ResponseCache.getDefault() == this) {
        ResponseCache.setDefault(null);
    }
    delegate.close();
}
Body of Second Method:
{
    if (ResponseCache.getDefault() == this) {
        ResponseCache.setDefault(null);
    }
    mDelegate.close();
}
------------------------
Find a silently evolved API code:android.media.AudioFormat.toLogFriendlyEncoding:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    switch(enc) {
        case ENCODING_INVALID:
            return "ENCODING_INVALID";
        case ENCODING_PCM_16BIT:
            return "ENCODING_PCM_16BIT";
        case ENCODING_PCM_8BIT:
            return "ENCODING_PCM_8BIT";
        case ENCODING_PCM_FLOAT:
            return "ENCODING_PCM_FLOAT";
        case ENCODING_AC3:
            return "ENCODING_AC3";
        case ENCODING_E_AC3:
            return "ENCODING_E_AC3";
        case ENCODING_DTS:
            return "ENCODING_DTS";
        case ENCODING_DTS_HD:
            return "ENCODING_DTS_HD";
        case ENCODING_MP3:
            return "ENCODING_MP3";
        case ENCODING_AAC_LC:
            return "ENCODING_AAC_LC";
        case ENCODING_AAC_HE_V1:
            return "ENCODING_AAC_HE_V1";
        case ENCODING_AAC_HE_V2:
            return "ENCODING_AAC_HE_V2";
        case ENCODING_IEC61937:
            return "ENCODING_IEC61937";
        case ENCODING_DOLBY_TRUEHD:
            return "ENCODING_DOLBY_TRUEHD";
        case ENCODING_AAC_ELD:
            return "ENCODING_AAC_ELD";
        case ENCODING_AAC_XHE:
            return "ENCODING_AAC_XHE";
        case ENCODING_AC4:
            return "ENCODING_AC4";
        default:
            return "invalid encoding " + enc;
    }
}
Body of Second Method:
{
    switch(enc) {
        case ENCODING_INVALID:
            return "ENCODING_INVALID";
        case ENCODING_PCM_16BIT:
            return "ENCODING_PCM_16BIT";
        case ENCODING_PCM_8BIT:
            return "ENCODING_PCM_8BIT";
        case ENCODING_PCM_FLOAT:
            return "ENCODING_PCM_FLOAT";
        case ENCODING_AC3:
            return "ENCODING_AC3";
        case ENCODING_E_AC3:
            return "ENCODING_E_AC3";
        case ENCODING_DTS:
            return "ENCODING_DTS";
        case ENCODING_DTS_HD:
            return "ENCODING_DTS_HD";
        case ENCODING_MP3:
            return "ENCODING_MP3";
        case ENCODING_AAC_LC:
            return "ENCODING_AAC_LC";
        case ENCODING_AAC_HE_V1:
            return "ENCODING_AAC_HE_V1";
        case ENCODING_AAC_HE_V2:
            return "ENCODING_AAC_HE_V2";
        case ENCODING_IEC61937:
            return "ENCODING_IEC61937";
        case ENCODING_DOLBY_TRUEHD:
            return "ENCODING_DOLBY_TRUEHD";
        case ENCODING_AAC_ELD:
            return "ENCODING_AAC_ELD";
        case ENCODING_AAC_XHE:
            return "ENCODING_AAC_XHE";
        case ENCODING_AC4:
            return "ENCODING_AC4";
        case ENCODING_E_AC3_JOC:
            return "ENCODING_E_AC3_JOC";
        case ENCODING_DOLBY_MAT:
            return "ENCODING_DOLBY_MAT";
        default:
            return "invalid encoding " + enc;
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothA2dp.getCodecStatus:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Gets the current codec status (configuration and capability).
 *
 * @param device the remote Bluetooth device. If null, use the current
 * active A2DP Bluetooth device.
 * @return the current codec status
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        Log.d(TAG, "getCodecStatus(" + device + ")");
    try {
        mServiceLock.readLock().lock();
        if (mService != null && isEnabled()) {
            return mService.getCodecStatus(device);
        }
        if (mService == null) {
            Log.w(TAG, "Proxy not attached to service");
        }
        return null;
    } catch (RemoteException e) {
        Log.e(TAG, "Error talking to BT service in getCodecStatus()", e);
        return null;
    } finally {
        mServiceLock.readLock().unlock();
    }
}
Body of Second Method:
{
    if (DBG)
        Log.d(TAG, "getCodecStatus(" + device + ")");
    try {
        final IBluetoothA2dp service = getService();
        if (service != null && isEnabled()) {
            return service.getCodecStatus(device);
        }
        if (service == null) {
            Log.w(TAG, "Proxy not attached to service");
        }
        return null;
    } catch (RemoteException e) {
        Log.e(TAG, "Error talking to BT service in getCodecStatus()", e);
        return null;
    }
}
------------------------
Find a silently evolved API code:android.app.Instrumentation.execStartActivitiesAsUser:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Like {@link #execStartActivity(Context, IBinder, IBinder, Activity, Intent, int, Bundle)},
 * but accepts an array of activities to be started.  Note that active
 * {@link ActivityMonitor} objects only match against the first activity in
 * the array.
 *
 * @return The corresponding flag {@link ActivityManager#START_CANCELED},
 * {@link ActivityManager#START_SUCCESS} etc. indicating whether the launch was
 * successful.
 *
 * {@hide}
 */

Body of Frist Method:
{
    IApplicationThread whoThread = (IApplicationThread) contextThread;
    if (mActivityMonitors != null) {
        synchronized (mSync) {
            final int N = mActivityMonitors.size();
            for (int i = 0; i < N; i++) {
                final ActivityMonitor am = mActivityMonitors.get(i);
                ActivityResult result = null;
                if (am.ignoreMatchingSpecificIntents()) {
                    result = am.onStartActivity(intents[0]);
                }
                if (result != null) {
                    am.mHits++;
                    return ActivityManager.START_CANCELED;
                } else if (am.match(who, null, intents[0])) {
                    am.mHits++;
                    if (am.isBlocking()) {
                        return ActivityManager.START_CANCELED;
                    }
                    break;
                }
            }
        }
    }
    try {
        String[] resolvedTypes = new String[intents.length];
        for (int i = 0; i < intents.length; i++) {
            intents[i].migrateExtraStreamToClipData();
            intents[i].prepareToLeaveProcess(who);
            resolvedTypes[i] = intents[i].resolveTypeIfNeeded(who.getContentResolver());
        }
        int result = ActivityManager.getService().startActivities(whoThread, who.getBasePackageName(), intents, resolvedTypes, token, options, userId);
        checkStartActivityResult(result, intents[0]);
        return result;
    } catch (RemoteException e) {
        throw new RuntimeException("Failure from system", e);
    }
}
Body of Second Method:
{
    IApplicationThread whoThread = (IApplicationThread) contextThread;
    if (mActivityMonitors != null) {
        synchronized (mSync) {
            final int N = mActivityMonitors.size();
            for (int i = 0; i < N; i++) {
                final ActivityMonitor am = mActivityMonitors.get(i);
                ActivityResult result = null;
                if (am.ignoreMatchingSpecificIntents()) {
                    result = am.onStartActivity(intents[0]);
                }
                if (result != null) {
                    am.mHits++;
                    return ActivityManager.START_CANCELED;
                } else if (am.match(who, null, intents[0])) {
                    am.mHits++;
                    if (am.isBlocking()) {
                        return ActivityManager.START_CANCELED;
                    }
                    break;
                }
            }
        }
    }
    try {
        String[] resolvedTypes = new String[intents.length];
        for (int i = 0; i < intents.length; i++) {
            intents[i].migrateExtraStreamToClipData();
            intents[i].prepareToLeaveProcess(who);
            resolvedTypes[i] = intents[i].resolveTypeIfNeeded(who.getContentResolver());
        }
        int result = ActivityTaskManager.getService().startActivities(whoThread, who.getBasePackageName(), intents, resolvedTypes, token, options, userId);
        checkStartActivityResult(result, intents[0]);
        return result;
    } catch (RemoteException e) {
        throw new RuntimeException("Failure from system", e);
    }
}
------------------------
Find a silently evolved API code:android.content.pm.CrossProfileApps.startMainActivity:COMMENT
Method Modifier: public      
Comment:/**
 * Starts the specified main activity of the caller package in the specified profile.
 *
 * @param component The ComponentName of the activity to launch, it must be exported and has
 * action {@link android.content.Intent#ACTION_MAIN}, category
 * {@link android.content.Intent#CATEGORY_LAUNCHER}. Otherwise, SecurityException will
 * be thrown.
 * @param targetUser The UserHandle of the profile, must be one of the users returned by
 * {@link #getTargetUserProfiles()}, otherwise a {@link SecurityException} will
 * be thrown.
 */

Body of Frist Method:
{
    try {
        mService.startActivityAsUser(mContext.getIApplicationThread(), mContext.getPackageName(), component, targetUser);
    } catch (RemoteException ex) {
        throw ex.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    try {
        mService.startActivityAsUser(mContext.getIApplicationThread(), mContext.getPackageName(), component, targetUser.getIdentifier(), true);
    } catch (RemoteException ex) {
        throw ex.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.widget.CompoundButton.getButtonTintMode:COMMENT
Method Modifier: public      
Comment:/**
 * @return the blending mode used to apply the tint to the button drawable
 * @attr ref android.R.styleable#CompoundButton_buttonTintMode
 * @see #setButtonTintMode(PorterDuff.Mode)
 */

Body of Frist Method:
{
    return mButtonTintMode;
}
Body of Second Method:
{
    return mButtonBlendMode != null ? BlendMode.blendModeToPorterDuffMode(mButtonBlendMode) : null;
}
------------------------
Find a silently evolved API code:android.widget.ProgressBar.setProgressTintMode:COMMENT
Method Modifier: public      
Comment:/**
 * Specifies the blending mode used to apply the tint specified by
 * {@link #setProgressTintList(ColorStateList)}} to the progress
 * indicator. The default mode is {@link PorterDuff.Mode#SRC_IN}.
 *
 * @param tintMode the blending mode used to apply the tint, may be
 * {@code null} to clear tint
 * @attr ref android.R.styleable#ProgressBar_progressTintMode
 * @see #getProgressTintMode()
 * @see Drawable#setTintMode(PorterDuff.Mode)
 */

Body of Frist Method:
{
    if (mProgressTintInfo == null) {
        mProgressTintInfo = new ProgressTintInfo();
    }
    mProgressTintInfo.mProgressTintMode = tintMode;
    mProgressTintInfo.mHasProgressTintMode = true;
    if (mProgressDrawable != null) {
        applyPrimaryProgressTint();
    }
}
Body of Second Method:
{
    setProgressTintBlendMode(tintMode != null ? BlendMode.fromValue(tintMode.nativeInt) : null);
}
------------------------
Find a silently evolved API code:android.hardware.location.NanoApp.setNeededSensors:COMMENT
Method Modifier: public      hidden      deprecated  
Comment:/**
 * set the sensors needed for this app
 *
 * @param neededSensors
 * needed Sensors
 */

Body of Frist Method:
{
    mNeededSensors = neededSensors;
}
Body of Second Method:
{
    Preconditions.checkNotNull(neededSensors, "neededSensors must not be null");
    mNeededSensors = neededSensors;
}
------------------------
Find a silently evolved API code:android.widget.CompoundButton.setButtonTintMode:COMMENT
Method Modifier: public      
Comment:/**
 * Specifies the blending mode used to apply the tint specified by
 * {@link #setButtonTintList(ColorStateList)}} to the button drawable. The
 * default mode is {@link PorterDuff.Mode#SRC_IN}.
 *
 * @param tintMode the blending mode used to apply the tint, may be
 * {@code null} to clear tint
 * @attr ref android.R.styleable#CompoundButton_buttonTintMode
 * @see #getButtonTintMode()
 * @see Drawable#setTintMode(PorterDuff.Mode)
 */

Body of Frist Method:
{
    mButtonTintMode = tintMode;
    mHasButtonTintMode = true;
    applyButtonTint();
}
Body of Second Method:
{
    setButtonTintBlendMode(tintMode != null ? BlendMode.fromValue(tintMode.nativeInt) : null);
}
------------------------
Find a silently evolved API code:android.telephony.CellIdentityCdma.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Implement the Parcelable interface
 */

Body of Frist Method:
{
    if (DBG)
        log("writeToParcel(Parcel, int): " + toString());
    super.writeToParcel(dest, TYPE_CDMA);
    dest.writeInt(mNetworkId);
    dest.writeInt(mSystemId);
    dest.writeInt(mBasestationId);
    dest.writeInt(mLongitude);
    dest.writeInt(mLatitude);
}
Body of Second Method:
{
    if (DBG)
        log("writeToParcel(Parcel, int): " + toString());
    super.writeToParcel(dest, CellInfo.TYPE_CDMA);
    dest.writeInt(mNetworkId);
    dest.writeInt(mSystemId);
    dest.writeInt(mBasestationId);
    dest.writeInt(mLongitude);
    dest.writeInt(mLatitude);
}
------------------------
Find a silently evolved API code:android.widget.Switch.setThumbTintMode:COMMENT
Method Modifier: public      
Comment:/**
 * Specifies the blending mode used to apply the tint specified by
 * {@link #setThumbTintList(ColorStateList)}} to the thumb drawable.
 * The default mode is {@link PorterDuff.Mode#SRC_IN}.
 *
 * @param tintMode the blending mode used to apply the tint, may be
 * {@code null} to clear tint
 * @attr ref android.R.styleable#Switch_thumbTintMode
 * @see #getThumbTintMode()
 * @see Drawable#setTintMode(PorterDuff.Mode)
 */

Body of Frist Method:
{
    mThumbTintMode = tintMode;
    mHasThumbTintMode = true;
    applyThumbTint();
}
Body of Second Method:
{
    setThumbTintBlendMode(tintMode != null ? BlendMode.fromValue(tintMode.nativeInt) : null);
}
------------------------
Find a silently evolved API code:android.media.soundtrigger.SoundTriggerManager.stopRecognition:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Stops the given model's recognition.
 * @hide
 */

Body of Frist Method:
{
    if (soundModelId == null) {
        return STATUS_ERROR;
    }
    try {
        return mSoundTriggerService.stopRecognitionForIntent(new ParcelUuid(soundModelId));
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    if (soundModelId == null) {
        return STATUS_ERROR;
    }
    try {
        return mSoundTriggerService.stopRecognitionForService(new ParcelUuid(soundModelId));
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothA2dp.setCodecConfigPreference:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets the codec configuration preference.
 *
 * @param device the remote Bluetooth device. If null, use the current
 * active A2DP Bluetooth device.
 * @param codecConfig the codec configuration preference
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        Log.d(TAG, "setCodecConfigPreference(" + device + ")");
    try {
        mServiceLock.readLock().lock();
        if (mService != null && isEnabled()) {
            mService.setCodecConfigPreference(device, codecConfig);
        }
        if (mService == null)
            Log.w(TAG, "Proxy not attached to service");
        return;
    } catch (RemoteException e) {
        Log.e(TAG, "Error talking to BT service in setCodecConfigPreference()", e);
        return;
    } finally {
        mServiceLock.readLock().unlock();
    }
}
Body of Second Method:
{
    if (DBG)
        Log.d(TAG, "setCodecConfigPreference(" + device + ")");
    try {
        final IBluetoothA2dp service = getService();
        if (service != null && isEnabled()) {
            service.setCodecConfigPreference(device, codecConfig);
        }
        if (service == null)
            Log.w(TAG, "Proxy not attached to service");
        return;
    } catch (RemoteException e) {
        Log.e(TAG, "Error talking to BT service in setCodecConfigPreference()", e);
        return;
    }
}
------------------------
Find a silently evolved API code:android.telephony.CellInfo.setTimeStamp:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    mTimeStamp = timeStamp;
}
Body of Second Method:
{
    mTimeStamp = ts;
}
------------------------
Find a silently evolved API code:android.content.ContentProviderClient.call:COMMENT
Method Modifier: public      
Comment:/**
 * See {@link ContentProvider#call(String, String, Bundle)}
 */

Body of Frist Method:
{
    Preconditions.checkNotNull(method, "method");
    beforeRemote();
    try {
        return mContentProvider.call(mPackageName, method, arg, extras);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}
Body of Second Method:
{
    Preconditions.checkNotNull(authority, "authority");
    Preconditions.checkNotNull(method, "method");
    beforeRemote();
    try {
        return mContentProvider.call(mPackageName, authority, method, arg, extras);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}
------------------------
Find a silently evolved API code:android.util.StatsLog.logStop:COMMENT
Method Modifier: public      static      
Comment:/**
 * Logs a stop event.
 *
 * @param label developer-chosen label.
 * @return True if the log request was sent to statsd.
 */

Body of Frist Method:
{
    synchronized (StatsLog.class) {
        try {
            IStatsManager service = getIStatsManagerLocked();
            if (service == null) {
                if (DEBUG)
                    Slog.d(TAG, "Failed to find statsd when logging stop");
                return false;
            }
            service.sendAppBreadcrumbAtom(label, StatsLog.APP_BREADCRUMB_REPORTED__STATE__STOP);
            return true;
        } catch (RemoteException e) {
            sService = null;
            if (DEBUG)
                Slog.d(TAG, "Failed to connect to statsd when logging stop");
            return false;
        }
    }
}
Body of Second Method:
{
    synchronized (sLogLock) {
        try {
            IStatsManager service = getIStatsManagerLocked();
            if (service == null) {
                if (DEBUG) {
                    Slog.d(TAG, "Failed to find statsd when logging stop");
                }
                return false;
            }
            service.sendAppBreadcrumbAtom(label, StatsLog.APP_BREADCRUMB_REPORTED__STATE__STOP);
            return true;
        } catch (RemoteException e) {
            sService = null;
            if (DEBUG) {
                Slog.d(TAG, "Failed to connect to statsd when logging stop");
            }
            return false;
        }
    }
}
------------------------
Find a silently evolved API code:android.content.pm.PackageItemInfo.writeToProto:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    long token = proto.start(fieldId);
    if (name != null) {
        proto.write(PackageItemInfoProto.NAME, name);
    }
    proto.write(PackageItemInfoProto.PACKAGE_NAME, packageName);
    if (labelRes != 0 || nonLocalizedLabel != null || icon != 0 || banner != 0) {
        proto.write(PackageItemInfoProto.LABEL_RES, labelRes);
        proto.write(PackageItemInfoProto.NON_LOCALIZED_LABEL, nonLocalizedLabel.toString());
        proto.write(PackageItemInfoProto.ICON, icon);
        proto.write(PackageItemInfoProto.BANNER, banner);
    }
    proto.end(token);
}
Body of Second Method:
{
    long token = proto.start(fieldId);
    if (name != null) {
        proto.write(PackageItemInfoProto.NAME, name);
    }
    proto.write(PackageItemInfoProto.PACKAGE_NAME, packageName);
    proto.write(PackageItemInfoProto.LABEL_RES, labelRes);
    if (nonLocalizedLabel != null) {
        proto.write(PackageItemInfoProto.NON_LOCALIZED_LABEL, nonLocalizedLabel.toString());
    }
    proto.write(PackageItemInfoProto.ICON, icon);
    proto.write(PackageItemInfoProto.BANNER, banner);
    proto.end(token);
}
------------------------
Find a silently evolved API code:android.database.sqlite.SQLiteGlobal.getWALSyncMode:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Gets the database synchronization mode when in WAL mode.
 */

Body of Frist Method:
{
    return SystemProperties.get("debug.sqlite.wal.syncmode", Resources.getSystem().getString(com.android.internal.R.string.db_wal_sync_mode));
}
Body of Second Method:
{
    // Use the FULL synchronous mode for system processes by default.
    String defaultMode = sDefaultSyncMode;
    if (defaultMode != null) {
        return defaultMode;
    }
    return SystemProperties.get("debug.sqlite.wal.syncmode", Resources.getSystem().getString(com.android.internal.R.string.db_wal_sync_mode));
}
------------------------
Find a silently evolved API code:android.telephony.CellSignalStrengthWcdma.copyFrom:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    mSignalStrength = s.mSignalStrength;
    mBitErrorRate = s.mBitErrorRate;
}
Body of Second Method:
{
    mRssi = s.mRssi;
    mBitErrorRate = s.mBitErrorRate;
    mRscp = s.mRscp;
    mEcNo = s.mEcNo;
    mLevel = s.mLevel;
}
------------------------
Find a silently evolved API code:android.os.Message.copyFrom:COMMENT
Method Modifier: public      
Comment:/**
 * Make this message like o.  Performs a shallow copy of the data field.
 * Does not copy the linked list fields, nor the timestamp or
 * target/callback of the original message.
 */

Body of Frist Method:
{
    this.flags = o.flags & ~FLAGS_TO_CLEAR_ON_COPY_FROM;
    this.what = o.what;
    this.arg1 = o.arg1;
    this.arg2 = o.arg2;
    this.obj = o.obj;
    this.replyTo = o.replyTo;
    this.sendingUid = o.sendingUid;
    if (o.data != null) {
        this.data = (Bundle) o.data.clone();
    } else {
        this.data = null;
    }
}
Body of Second Method:
{
    this.flags = o.flags & ~FLAGS_TO_CLEAR_ON_COPY_FROM;
    this.what = o.what;
    this.arg1 = o.arg1;
    this.arg2 = o.arg2;
    this.obj = o.obj;
    this.replyTo = o.replyTo;
    this.sendingUid = o.sendingUid;
    this.workSourceUid = o.workSourceUid;
    if (o.data != null) {
        this.data = (Bundle) o.data.clone();
    } else {
        this.data = null;
    }
}
------------------------
Find a silently evolved API code:android.view.textservice.TextServicesManager.isSpellCheckerEnabled:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    try {
        return mService.isSpellCheckerEnabled();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    try {
        return mService.isSpellCheckerEnabled(mUserId);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.app.backup.BackupManager.getAvailableRestoreToken:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Ask the framework which dataset, if any, the given package's data would be
 * restored from if we were to install it right now.
 *
 * @param packageName The name of the package whose most-suitable dataset we
 * wish to look up
 * @return The dataset token from which a restore should be attempted, or zero if
 * no suitable data is available.
 *
 * @hide
 */

Body of Frist Method:
{
    checkServiceBinder();
    if (sService != null) {
        try {
            return sService.getAvailableRestoreToken(packageName);
        } catch (RemoteException e) {
            Log.e(TAG, "getAvailableRestoreToken() couldn't connect");
        }
    }
    return 0;
}
Body of Second Method:
{
    checkServiceBinder();
    if (sService != null) {
        try {
            return sService.getAvailableRestoreTokenForUser(mContext.getUserId(), packageName);
        } catch (RemoteException e) {
            Log.e(TAG, "getAvailableRestoreToken() couldn't connect");
        }
    }
    return 0;
}
------------------------
Find a silently evolved API code:android.database.AbstractCursor.onChange:COMMENT
Method Modifier: protected   
Comment:/**
 * Subclasses must call this method when they finish committing updates to notify all
 * observers.
 *
 * @param selfChange
 */

Body of Frist Method:
{
    synchronized (mSelfObserverLock) {
        mContentObservable.dispatchChange(selfChange, null);
        if (mNotifyUri != null && selfChange) {
            mContentResolver.notifyChange(mNotifyUri, mSelfObserver);
        }
    }
}
Body of Second Method:
{
    synchronized (mSelfObserverLock) {
        mContentObservable.dispatchChange(selfChange, null);
        if (mNotifyUris != null && selfChange) {
            final int size = mNotifyUris.size();
            for (int i = 0; i < size; ++i) {
                final Uri notifyUri = mNotifyUris.get(i);
                mContentResolver.notifyChange(notifyUri, mSelfObserver);
            }
        }
    }
}
------------------------
Find a silently evolved API code:android.graphics.PixelFormat.formatToString:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    switch(format) {
        case UNKNOWN:
            return "UNKNOWN";
        case TRANSLUCENT:
            return "TRANSLUCENT";
        case TRANSPARENT:
            return "TRANSPARENT";
        case RGBA_8888:
            return "RGBA_8888";
        case RGBX_8888:
            return "RGBX_8888";
        case RGB_888:
            return "RGB_888";
        case RGB_565:
            return "RGB_565";
        case RGBA_5551:
            return "RGBA_5551";
        case RGBA_4444:
            return "RGBA_4444";
        case A_8:
            return "A_8";
        case L_8:
            return "L_8";
        case LA_88:
            return "LA_88";
        case RGB_332:
            return "RGB_332";
        case YCbCr_422_SP:
            return "YCbCr_422_SP";
        case YCbCr_420_SP:
            return "YCbCr_420_SP";
        case YCbCr_422_I:
            return "YCbCr_422_I";
        case RGBA_F16:
            return "RGBA_F16";
        case RGBA_1010102:
            return "RGBA_1010102";
        case JPEG:
            return "JPEG";
        default:
            return Integer.toString(format);
    }
}
Body of Second Method:
{
    switch(format) {
        case UNKNOWN:
            return "UNKNOWN";
        case TRANSLUCENT:
            return "TRANSLUCENT";
        case TRANSPARENT:
            return "TRANSPARENT";
        case RGBA_8888:
            return "RGBA_8888";
        case RGBX_8888:
            return "RGBX_8888";
        case RGB_888:
            return "RGB_888";
        case RGB_565:
            return "RGB_565";
        case RGBA_5551:
            return "RGBA_5551";
        case RGBA_4444:
            return "RGBA_4444";
        case A_8:
            return "A_8";
        case L_8:
            return "L_8";
        case LA_88:
            return "LA_88";
        case RGB_332:
            return "RGB_332";
        case YCbCr_422_SP:
            return "YCbCr_422_SP";
        case YCbCr_420_SP:
            return "YCbCr_420_SP";
        case YCbCr_422_I:
            return "YCbCr_422_I";
        case RGBA_F16:
            return "RGBA_F16";
        case RGBA_1010102:
            return "RGBA_1010102";
        case HSV_888:
            return "HSV_888";
        case JPEG:
            return "JPEG";
        default:
            return Integer.toString(format);
    }
}
------------------------
Find a silently evolved API code:android.media.AudioFormat.getEncoding:COMMENT
Method Modifier: public      
Comment:/**
 * Return the encoding.
 * See the section on <a href="#encoding">encodings</a> for more information about the different
 * types of supported audio encoding.
 * @return one of the values that can be set in {@link Builder#setEncoding(int)} or
 * {@link AudioFormat#ENCODING_INVALID} if not set.
 */

Body of Frist Method:
{
    if ((mPropertySetMask & AUDIO_FORMAT_HAS_PROPERTY_ENCODING) == 0) {
        return ENCODING_INVALID;
    }
    return mEncoding;
}
Body of Second Method:
{
    return mEncoding;
}
------------------------
Find a silently evolved API code:android.graphics.BitmapFactory.decodeStreamInternal:COMMENT
Method Modifier: private     static      
Comment:/**
 * Private helper function for decoding an InputStream natively. Buffers the input enough to
 * do a rewind as needed, and supplies temporary storage if necessary. is MUST NOT be null.
 */

Body of Frist Method:
{
    // ASSERT(is != null);
    byte[] tempStorage = null;
    if (opts != null)
        tempStorage = opts.inTempStorage;
    if (tempStorage == null)
        tempStorage = new byte[DECODE_BUFFER_SIZE];
    return nativeDecodeStream(is, tempStorage, outPadding, opts);
}
Body of Second Method:
{
    // ASSERT(is != null);
    byte[] tempStorage = null;
    if (opts != null)
        tempStorage = opts.inTempStorage;
    if (tempStorage == null)
        tempStorage = new byte[DECODE_BUFFER_SIZE];
    return nativeDecodeStream(is, tempStorage, outPadding, opts, Options.nativeInBitmap(opts), Options.nativeColorSpace(opts));
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.disconnectAudio:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Disconnects audio channel.
 *
 * It tears down the SCO channel from remote AG device.
 *
 * @param device remote device
 * @return <code>true</code> if command has been issued successfully; <code>false</code>
 * otherwise; upon completion HFP sends {@link #ACTION_AUDIO_STATE_CHANGED} intent;
 */

Body of Frist Method:
{
    final IBluetoothHeadsetClient service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.disconnectAudio(device);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return false;
}
Body of Second Method:
{
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled()) {
        try {
            return service.disconnectAudio(device);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return false;
}
------------------------
Find a silently evolved API code:android.util.Half.toFloat:COMMENT
Method Modifier: public      static      
Comment:/**
 * <p>Converts the specified half-precision float value into a
 * single-precision float value. The following special cases are handled:</p>
 * <ul>
 * <li>If the input is {@link #NaN}, the returned value is {@link Float#NaN}</li>
 * <li>If the input is {@link #POSITIVE_INFINITY} or
 * {@link #NEGATIVE_INFINITY}, the returned value is respectively
 * {@link Float#POSITIVE_INFINITY} or {@link Float#NEGATIVE_INFINITY}</li>
 * <li>If the input is 0 (positive or negative), the returned value is +/-0.0f</li>
 * <li>Otherwise, the returned value is a normalized single-precision float value</li>
 * </ul>
 *
 * @param h The half-precision float value to convert to single-precision
 * @return A normalized single-precision float value
 */

Body of Frist Method:
{
    int bits = h & 0xffff;
    int s = bits & FP16_SIGN_MASK;
    int e = (bits >>> FP16_EXPONENT_SHIFT) & FP16_EXPONENT_MASK;
    int m = (bits) & FP16_SIGNIFICAND_MASK;
    int outE = 0;
    int outM = 0;
    if (e == 0) {
        // Denormal or 0
        if (m != 0) {
            // Convert denorm fp16 into normalized fp32
            float o = Float.intBitsToFloat(FP32_DENORMAL_MAGIC + m);
            o -= FP32_DENORMAL_FLOAT;
            return s == 0 ? o : -o;
        }
    } else {
        outM = m << 13;
        if (e == 0x1f) {
            // Infinite or NaN
            outE = 0xff;
        } else {
            outE = e - FP16_EXPONENT_BIAS + FP32_EXPONENT_BIAS;
        }
    }
    int out = (s << 16) | (outE << FP32_EXPONENT_SHIFT) | outM;
    return Float.intBitsToFloat(out);
}
Body of Second Method:
{
    int bits = h & 0xffff;
    int s = bits & FP16_SIGN_MASK;
    int e = (bits >>> FP16_EXPONENT_SHIFT) & FP16_EXPONENT_MASK;
    int m = (bits) & FP16_SIGNIFICAND_MASK;
    int outE = 0;
    int outM = 0;
    if (e == 0) {
        // Denormal or 0
        if (m != 0) {
            // Convert denorm fp16 into normalized fp32
            float o = Float.intBitsToFloat(FP32_DENORMAL_MAGIC + m);
            o -= FP32_DENORMAL_FLOAT;
            return s == 0 ? o : -o;
        }
    } else {
        outM = m << 13;
        if (e == 0x1f) {
            // Infinite or NaN
            outE = 0xff;
            if (outM != 0) {
                // SNaNs are quieted
                outM |= FP32_QNAN_MASK;
            }
        } else {
            outE = e - FP16_EXPONENT_BIAS + FP32_EXPONENT_BIAS;
        }
    }
    int out = (s << 16) | (outE << FP32_EXPONENT_SHIFT) | outM;
    return Float.intBitsToFloat(out);
}
------------------------
Find a silently evolved API code:android.widget.ProgressBar.setProgressBackgroundTintMode:COMMENT
Method Modifier: public      
Comment:/**
 * Specifies the blending mode used to apply the tint specified by
 * {@link #setProgressBackgroundTintList(ColorStateList)}} to the progress
 * background. The default mode is {@link PorterDuff.Mode#SRC_IN}.
 *
 * @param tintMode the blending mode used to apply the tint, may be
 * {@code null} to clear tint
 * @attr ref android.R.styleable#ProgressBar_progressBackgroundTintMode
 * @see #setProgressBackgroundTintList(ColorStateList)
 * @see Drawable#setTintMode(PorterDuff.Mode)
 */

Body of Frist Method:
{
    if (mProgressTintInfo == null) {
        mProgressTintInfo = new ProgressTintInfo();
    }
    mProgressTintInfo.mProgressBackgroundTintMode = tintMode;
    mProgressTintInfo.mHasProgressBackgroundTintMode = true;
    if (mProgressDrawable != null) {
        applyProgressBackgroundTint();
    }
}
Body of Second Method:
{
    setProgressBackgroundTintBlendMode(tintMode != null ? BlendMode.fromValue(tintMode.nativeInt) : null);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothPan.getDevicesMatchingConnectionStates:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (VDBG)
        log("getDevicesMatchingStates()");
    final IBluetoothPan service = mPanService;
    if (service != null && isEnabled()) {
        try {
            return service.getDevicesMatchingConnectionStates(states);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
Body of Second Method:
{
    if (VDBG)
        log("getDevicesMatchingStates()");
    final IBluetoothPan service = getService();
    if (service != null && isEnabled()) {
        try {
            return service.getDevicesMatchingConnectionStates(states);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
------------------------
Find a silently evolved API code:android.graphics.pdf.PdfRenderer.Page.render:COMMENT
Method Modifier: public      
Comment:/**
 * Renders a page to a bitmap.
 * <p>
 * You may optionally specify a rectangular clip in the bitmap bounds. No rendering
 * outside the clip will be performed, hence it is your responsibility to initialize
 * the bitmap outside the clip.
 * </p>
 * <p>
 * You may optionally specify a matrix to transform the content from page coordinates
 * which are in points (1/72") to bitmap coordinates which are in pixels. If this
 * matrix is not provided this method will apply a transformation that will fit the
 * whole page to the destination clip if provided or the destination bitmap if no
 * clip is provided.
 * </p>
 * <p>
 * The clip and transformation are useful for implementing tile rendering where the
 * destination bitmap contains a portion of the image, for example when zooming.
 * Another useful application is for printing where the size of the bitmap holding
 * the page is too large and a client can render the page in stripes.
 * </p>
 * <p>
 * <strong>Note: </strong> The destination bitmap format must be
 * {@link Config#ARGB_8888 ARGB}.
 * </p>
 * <p>
 * <strong>Note: </strong> The optional transformation matrix must be affine as per
 * {@link android.graphics.Matrix#isAffine() Matrix.isAffine()}. Hence, you can specify
 * rotation, scaling, translation but not a perspective transformation.
 * </p>
 *
 * @param destination Destination bitmap to which to render.
 * @param destClip Optional clip in the bitmap bounds.
 * @param transform Optional transformation to apply when rendering.
 * @param renderMode The render mode.
 *
 * @see #RENDER_MODE_FOR_DISPLAY
 * @see #RENDER_MODE_FOR_PRINT
 */

Body of Frist Method:
{
    if (mNativePage == 0) {
        throw new NullPointerException();
    }
    destination = Preconditions.checkNotNull(destination, "bitmap null");
    if (destination.getConfig() != Config.ARGB_8888) {
        throw new IllegalArgumentException("Unsupported pixel format");
    }
    if (destClip != null) {
        if (destClip.left < 0 || destClip.top < 0 || destClip.right > destination.getWidth() || destClip.bottom > destination.getHeight()) {
            throw new IllegalArgumentException("destBounds not in destination");
        }
    }
    if (transform != null && !transform.isAffine()) {
        throw new IllegalArgumentException("transform not affine");
    }
    if (renderMode != RENDER_MODE_FOR_PRINT && renderMode != RENDER_MODE_FOR_DISPLAY) {
        throw new IllegalArgumentException("Unsupported render mode");
    }
    if (renderMode == RENDER_MODE_FOR_PRINT && renderMode == RENDER_MODE_FOR_DISPLAY) {
        throw new IllegalArgumentException("Only single render mode supported");
    }
    final int contentLeft = (destClip != null) ? destClip.left : 0;
    final int contentTop = (destClip != null) ? destClip.top : 0;
    final int contentRight = (destClip != null) ? destClip.right : destination.getWidth();
    final int contentBottom = (destClip != null) ? destClip.bottom : destination.getHeight();
    // If transform is not set, stretch page to whole clipped area
    if (transform == null) {
        int clipWidth = contentRight - contentLeft;
        int clipHeight = contentBottom - contentTop;
        transform = new Matrix();
        transform.postScale((float) clipWidth / getWidth(), (float) clipHeight / getHeight());
        transform.postTranslate(contentLeft, contentTop);
    }
    final long transformPtr = transform.native_instance;
    synchronized (sPdfiumLock) {
        nativeRenderPage(mNativeDocument, mNativePage, destination, contentLeft, contentTop, contentRight, contentBottom, transformPtr, renderMode);
    }
}
Body of Second Method:
{
    if (mNativePage == 0) {
        throw new NullPointerException();
    }
    destination = Preconditions.checkNotNull(destination, "bitmap null");
    if (destination.getConfig() != Config.ARGB_8888) {
        throw new IllegalArgumentException("Unsupported pixel format");
    }
    if (destClip != null) {
        if (destClip.left < 0 || destClip.top < 0 || destClip.right > destination.getWidth() || destClip.bottom > destination.getHeight()) {
            throw new IllegalArgumentException("destBounds not in destination");
        }
    }
    if (transform != null && !transform.isAffine()) {
        throw new IllegalArgumentException("transform not affine");
    }
    if (renderMode != RENDER_MODE_FOR_PRINT && renderMode != RENDER_MODE_FOR_DISPLAY) {
        throw new IllegalArgumentException("Unsupported render mode");
    }
    if (renderMode == RENDER_MODE_FOR_PRINT && renderMode == RENDER_MODE_FOR_DISPLAY) {
        throw new IllegalArgumentException("Only single render mode supported");
    }
    final int contentLeft = (destClip != null) ? destClip.left : 0;
    final int contentTop = (destClip != null) ? destClip.top : 0;
    final int contentRight = (destClip != null) ? destClip.right : destination.getWidth();
    final int contentBottom = (destClip != null) ? destClip.bottom : destination.getHeight();
    // If transform is not set, stretch page to whole clipped area
    if (transform == null) {
        int clipWidth = contentRight - contentLeft;
        int clipHeight = contentBottom - contentTop;
        transform = new Matrix();
        transform.postScale((float) clipWidth / getWidth(), (float) clipHeight / getHeight());
        transform.postTranslate(contentLeft, contentTop);
    }
    final long transformPtr = transform.native_instance;
    synchronized (sPdfiumLock) {
        nativeRenderPage(mNativeDocument, mNativePage, destination.getNativeInstance(), contentLeft, contentTop, contentRight, contentBottom, transformPtr, renderMode);
    }
}
------------------------
Find a silently evolved API code:android.telecom.ConferenceParticipant.writeToParcel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Writes the {@code ConferenceParticipant} to a parcel.
 *
 * @param dest The Parcel in which the object should be written.
 * @param flags Additional flags about how the object should be written.
 */

Body of Frist Method:
{
    dest.writeParcelable(mHandle, 0);
    dest.writeString(mDisplayName);
    dest.writeParcelable(mEndpoint, 0);
    dest.writeInt(mState);
}
Body of Second Method:
{
    dest.writeParcelable(mHandle, 0);
    dest.writeString(mDisplayName);
    dest.writeParcelable(mEndpoint, 0);
    dest.writeInt(mState);
    dest.writeLong(mConnectTime);
    dest.writeLong(mConnectElapsedTime);
    dest.writeInt(mCallDirection);
}
------------------------
Find a silently evolved API code:android.telephony.CellSignalStrengthLte.setDefaultValues:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    mSignalStrength = Integer.MAX_VALUE;
    mRsrp = Integer.MAX_VALUE;
    mRsrq = Integer.MAX_VALUE;
    mRssnr = Integer.MAX_VALUE;
    mCqi = Integer.MAX_VALUE;
    mTimingAdvance = Integer.MAX_VALUE;
}
Body of Second Method:
{
    mSignalStrength = CellInfo.UNAVAILABLE;
    mRssi = CellInfo.UNAVAILABLE;
    mRsrp = CellInfo.UNAVAILABLE;
    mRsrq = CellInfo.UNAVAILABLE;
    mRssnr = CellInfo.UNAVAILABLE;
    mCqi = CellInfo.UNAVAILABLE;
    mTimingAdvance = CellInfo.UNAVAILABLE;
    mLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
}
------------------------
Find a silently evolved API code:android.hardware.camera2.params.StreamConfigurationMap.hashCode:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    // XX: do we care about order?
    return HashCodeHelpers.hashCodeGeneric(mConfigurations, mMinFrameDurations, mStallDurations, mDepthConfigurations, mHighSpeedVideoConfigurations);
}
Body of Second Method:
{
    // XX: do we care about order?
    return HashCodeHelpers.hashCodeGeneric(mConfigurations, mMinFrameDurations, mStallDurations, mDepthConfigurations, mDepthMinFrameDurations, mDepthStallDurations, mDynamicDepthConfigurations, mDynamicDepthMinFrameDurations, mDynamicDepthStallDurations, mHeicConfigurations, mHeicMinFrameDurations, mHeicStallDurations, mHighSpeedVideoConfigurations);
}
------------------------
Find a silently evolved API code:android.ddm.DdmHandleHello.handleHELO:COMMENT
Method Modifier: private     
Comment:/*
     * Handle introductory packet. This is called during JNI_CreateJavaVM
     * before frameworks native methods are registered, so be careful not
     * to call any APIs that depend on frameworks native code.
     */

Body of Frist Method:
{
    if (false)
        return createFailChunk(123, "This is a test");
    /*
         * Process the request.
         */
    ByteBuffer in = wrapChunk(request);
    int serverProtoVers = in.getInt();
    if (false)
        Log.v("ddm-hello", "Server version is " + serverProtoVers);
    /*
         * Create a response.
         */
    String vmName = System.getProperty("java.vm.name", "?");
    String vmVersion = System.getProperty("java.vm.version", "?");
    String vmIdent = vmName + " v" + vmVersion;
    // String appName = android.app.ActivityThread.currentPackageName();
    // if (appName == null)
    // appName = "unknown";
    String appName = DdmHandleAppName.getAppName();
    VMRuntime vmRuntime = VMRuntime.getRuntime();
    String instructionSetDescription = vmRuntime.is64Bit() ? "64-bit" : "32-bit";
    String vmInstructionSet = vmRuntime.vmInstructionSet();
    if (vmInstructionSet != null && vmInstructionSet.length() > 0) {
        instructionSetDescription += " (" + vmInstructionSet + ")";
    }
    String vmFlags = "CheckJNI=" + (vmRuntime.isCheckJniEnabled() ? "true" : "false");
    boolean isNativeDebuggable = vmRuntime.isNativeDebuggable();
    ByteBuffer out = ByteBuffer.allocate(28 + vmIdent.length() * 2 + appName.length() * 2 + instructionSetDescription.length() * 2 + vmFlags.length() * 2 + 1);
    out.order(ChunkHandler.CHUNK_ORDER);
    out.putInt(DdmServer.CLIENT_PROTOCOL_VERSION);
    out.putInt(android.os.Process.myPid());
    out.putInt(vmIdent.length());
    out.putInt(appName.length());
    putString(out, vmIdent);
    putString(out, appName);
    out.putInt(UserHandle.myUserId());
    out.putInt(instructionSetDescription.length());
    putString(out, instructionSetDescription);
    out.putInt(vmFlags.length());
    putString(out, vmFlags);
    out.put((byte) (isNativeDebuggable ? 1 : 0));
    Chunk reply = new Chunk(CHUNK_HELO, out);
    /*
         * Take the opportunity to inform DDMS if we are waiting for a
         * debugger to attach.
         */
    if (Debug.waitingForDebugger())
        sendWAIT(0);
    return reply;
}
Body of Second Method:
{
    if (false)
        return createFailChunk(123, "This is a test");
    /*
         * Process the request.
         */
    ByteBuffer in = wrapChunk(request);
    int serverProtoVers = in.getInt();
    if (false)
        Log.v("ddm-hello", "Server version is " + serverProtoVers);
    /*
         * Create a response.
         */
    String vmName = System.getProperty("java.vm.name", "?");
    String vmVersion = System.getProperty("java.vm.version", "?");
    String vmIdent = vmName + " v" + vmVersion;
    // String appName = android.app.ActivityThread.currentPackageName();
    // if (appName == null)
    // appName = "unknown";
    String appName = DdmHandleAppName.getAppName();
    VMRuntime vmRuntime = VMRuntime.getRuntime();
    String instructionSetDescription = vmRuntime.is64Bit() ? "64-bit" : "32-bit";
    String vmInstructionSet = vmRuntime.vmInstructionSet();
    if (vmInstructionSet != null && vmInstructionSet.length() > 0) {
        instructionSetDescription += " (" + vmInstructionSet + ")";
    }
    String vmFlags = "CheckJNI=" + (vmRuntime.isCheckJniEnabled() ? "true" : "false");
    boolean isNativeDebuggable = vmRuntime.isNativeDebuggable();
    ByteBuffer out = ByteBuffer.allocate(28 + vmIdent.length() * 2 + appName.length() * 2 + instructionSetDescription.length() * 2 + vmFlags.length() * 2 + 1);
    out.order(ChunkHandler.CHUNK_ORDER);
    out.putInt(CLIENT_PROTOCOL_VERSION);
    out.putInt(android.os.Process.myPid());
    out.putInt(vmIdent.length());
    out.putInt(appName.length());
    putString(out, vmIdent);
    putString(out, appName);
    out.putInt(UserHandle.myUserId());
    out.putInt(instructionSetDescription.length());
    putString(out, instructionSetDescription);
    out.putInt(vmFlags.length());
    putString(out, vmFlags);
    out.put((byte) (isNativeDebuggable ? 1 : 0));
    Chunk reply = new Chunk(CHUNK_HELO, out);
    /*
         * Take the opportunity to inform DDMS if we are waiting for a
         * debugger to attach.
         */
    if (Debug.waitingForDebugger())
        sendWAIT(0);
    return reply;
}
------------------------
Find a silently evolved API code:android.app.WindowConfiguration.isAlwaysOnTop:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns true if the container associated with this window configuration is always-on-top of
 * its siblings.
 * @hide
 */

Body of Frist Method:
{
    return mWindowingMode == WINDOWING_MODE_PINNED;
}
Body of Second Method:
{
    return mWindowingMode == WINDOWING_MODE_PINNED || (mWindowingMode == WINDOWING_MODE_FREEFORM && mAlwaysOnTop == ALWAYS_ON_TOP_ON);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHidHost.close:COMMENT
Method Modifier: default     hidden      
Comment:/*package*/

Body of Frist Method:
{
    if (VDBG)
        log("close()");
    IBluetoothManager mgr = mAdapter.getBluetoothManager();
    if (mgr != null) {
        try {
            mgr.unregisterStateChangeCallback(mBluetoothStateChangeCallback);
        } catch (Exception e) {
            Log.e(TAG, "", e);
        }
    }
    synchronized (mConnection) {
        if (mService != null) {
            try {
                mService = null;
                mContext.unbindService(mConnection);
            } catch (Exception re) {
                Log.e(TAG, "", re);
            }
        }
    }
    mServiceListener = null;
}
Body of Second Method:
{
    if (VDBG)
        log("close()");
    mProfileConnector.disconnect();
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothA2dp.getOptionalCodecsEnabled:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns whether this device should have optional codecs enabled.
 *
 * @param device The device in question.
 * @return one of OPTIONAL_CODECS_PREF_UNKNOWN, OPTIONAL_CODECS_PREF_ENABLED, or
 * OPTIONAL_CODECS_PREF_DISABLED.
 * @hide
 */

Body of Frist Method:
{
    try {
        mServiceLock.readLock().lock();
        if (mService != null && isEnabled() && isValidDevice(device)) {
            return mService.getOptionalCodecsEnabled(device);
        }
        if (mService == null)
            Log.w(TAG, "Proxy not attached to service");
        return OPTIONAL_CODECS_PREF_UNKNOWN;
    } catch (RemoteException e) {
        Log.e(TAG, "Error talking to BT service in getSupportsOptionalCodecs()", e);
        return OPTIONAL_CODECS_PREF_UNKNOWN;
    } finally {
        mServiceLock.readLock().unlock();
    }
}
Body of Second Method:
{
    try {
        final IBluetoothA2dp service = getService();
        if (service != null && isEnabled() && isValidDevice(device)) {
            return service.getOptionalCodecsEnabled(device);
        }
        if (service == null)
            Log.w(TAG, "Proxy not attached to service");
        return OPTIONAL_CODECS_PREF_UNKNOWN;
    } catch (RemoteException e) {
        Log.e(TAG, "Error talking to BT service in getSupportsOptionalCodecs()", e);
        return OPTIONAL_CODECS_PREF_UNKNOWN;
    }
}
------------------------
Find a silently evolved API code:android.graphics.drawable.GradientDrawable.updateStateFromTypedArray:COMMENT
Method Modifier: private     
Comment:/**
 * Updates the constant state from the values in the typed array.
 */

Body of Frist Method:
{
    final GradientState state = mGradientState;
    // Account for any configuration changes.
    state.mChangingConfigurations |= a.getChangingConfigurations();
    // Extract the theme attributes, if any.
    state.mThemeAttrs = a.extractThemeAttrs();
    state.mShape = a.getInt(R.styleable.GradientDrawable_shape, state.mShape);
    state.mDither = a.getBoolean(R.styleable.GradientDrawable_dither, state.mDither);
    if (state.mShape == RING) {
        state.mInnerRadius = a.getDimensionPixelSize(R.styleable.GradientDrawable_innerRadius, state.mInnerRadius);
        if (state.mInnerRadius == -1) {
            state.mInnerRadiusRatio = a.getFloat(R.styleable.GradientDrawable_innerRadiusRatio, state.mInnerRadiusRatio);
        }
        state.mThickness = a.getDimensionPixelSize(R.styleable.GradientDrawable_thickness, state.mThickness);
        if (state.mThickness == -1) {
            state.mThicknessRatio = a.getFloat(R.styleable.GradientDrawable_thicknessRatio, state.mThicknessRatio);
        }
        state.mUseLevelForShape = a.getBoolean(R.styleable.GradientDrawable_useLevel, state.mUseLevelForShape);
    }
    final int tintMode = a.getInt(R.styleable.GradientDrawable_tintMode, -1);
    if (tintMode != -1) {
        state.mTintMode = Drawable.parseTintMode(tintMode, PorterDuff.Mode.SRC_IN);
    }
    final ColorStateList tint = a.getColorStateList(R.styleable.GradientDrawable_tint);
    if (tint != null) {
        state.mTint = tint;
    }
    final int insetLeft = a.getDimensionPixelSize(R.styleable.GradientDrawable_opticalInsetLeft, state.mOpticalInsets.left);
    final int insetTop = a.getDimensionPixelSize(R.styleable.GradientDrawable_opticalInsetTop, state.mOpticalInsets.top);
    final int insetRight = a.getDimensionPixelSize(R.styleable.GradientDrawable_opticalInsetRight, state.mOpticalInsets.right);
    final int insetBottom = a.getDimensionPixelSize(R.styleable.GradientDrawable_opticalInsetBottom, state.mOpticalInsets.bottom);
    state.mOpticalInsets = Insets.of(insetLeft, insetTop, insetRight, insetBottom);
}
Body of Second Method:
{
    final GradientState state = mGradientState;
    // Account for any configuration changes.
    state.mChangingConfigurations |= a.getChangingConfigurations();
    // Extract the theme attributes, if any.
    state.mThemeAttrs = a.extractThemeAttrs();
    state.mShape = a.getInt(R.styleable.GradientDrawable_shape, state.mShape);
    state.mDither = a.getBoolean(R.styleable.GradientDrawable_dither, state.mDither);
    if (state.mShape == RING) {
        state.mInnerRadius = a.getDimensionPixelSize(R.styleable.GradientDrawable_innerRadius, state.mInnerRadius);
        if (state.mInnerRadius == -1) {
            state.mInnerRadiusRatio = a.getFloat(R.styleable.GradientDrawable_innerRadiusRatio, state.mInnerRadiusRatio);
        }
        state.mThickness = a.getDimensionPixelSize(R.styleable.GradientDrawable_thickness, state.mThickness);
        if (state.mThickness == -1) {
            state.mThicknessRatio = a.getFloat(R.styleable.GradientDrawable_thicknessRatio, state.mThicknessRatio);
        }
        state.mUseLevelForShape = a.getBoolean(R.styleable.GradientDrawable_useLevel, state.mUseLevelForShape);
    }
    final int tintMode = a.getInt(R.styleable.GradientDrawable_tintMode, -1);
    if (tintMode != -1) {
        state.mBlendMode = Drawable.parseBlendMode(tintMode, BlendMode.SRC_IN);
    }
    final ColorStateList tint = a.getColorStateList(R.styleable.GradientDrawable_tint);
    if (tint != null) {
        state.mTint = tint;
    }
    final int insetLeft = a.getDimensionPixelSize(R.styleable.GradientDrawable_opticalInsetLeft, state.mOpticalInsets.left);
    final int insetTop = a.getDimensionPixelSize(R.styleable.GradientDrawable_opticalInsetTop, state.mOpticalInsets.top);
    final int insetRight = a.getDimensionPixelSize(R.styleable.GradientDrawable_opticalInsetRight, state.mOpticalInsets.right);
    final int insetBottom = a.getDimensionPixelSize(R.styleable.GradientDrawable_opticalInsetBottom, state.mOpticalInsets.bottom);
    state.mOpticalInsets = Insets.of(insetLeft, insetTop, insetRight, insetBottom);
}
------------------------
Find a silently evolved API code:android.database.sqlite.SQLiteCompatibilityWalFlags.reset:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    sInitialized = false;
    sFlagsSet = false;
    sCompatibilityWalSupported = false;
    sWALSyncMode = null;
}
Body of Second Method:
{
    sInitialized = false;
    sLegacyCompatibilityWalEnabled = false;
    sWALSyncMode = null;
}
------------------------
Find a silently evolved API code:android.telephony.NetworkScan.stopScan:COMMENT
Method Modifier: public      
Comment:/**
 * Stops the network scan
 *
 * Use this method to stop an ongoing scan. When user requests a new scan, a {@link NetworkScan}
 * object will be returned, and the user can stop the scan by calling this method.
 */

Body of Frist Method:
{
    ITelephony telephony = getITelephony();
    if (telephony == null) {
        Rlog.e(TAG, "Failed to get the ITelephony instance.");
    }
    try {
        telephony.stopNetworkScan(mSubId, mScanId);
    } catch (RemoteException ex) {
        Rlog.e(TAG, "stopNetworkScan  RemoteException", ex);
    } catch (RuntimeException ex) {
        Rlog.e(TAG, "stopNetworkScan  RuntimeException", ex);
    }
}
Body of Second Method:
{
    ITelephony telephony = getITelephony();
    if (telephony == null) {
        Rlog.e(TAG, "Failed to get the ITelephony instance.");
    }
    try {
        telephony.stopNetworkScan(mSubId, mScanId);
    } catch (IllegalArgumentException ex) {
        Rlog.d(TAG, "stopNetworkScan - no active scan for ScanID=" + mScanId);
    } catch (RemoteException ex) {
        Rlog.e(TAG, "stopNetworkScan  RemoteException", ex);
    } catch (RuntimeException ex) {
        Rlog.e(TAG, "stopNetworkScan  RuntimeException", ex);
    }
}
------------------------
Find a silently evolved API code:android.net.http.HttpResponseCache.size:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the number of bytes currently being used to store the values in
 * this cache. This may be greater than the {@link #maxSize} if a background
 * deletion is pending. {@code -1} is returned if the size cannot be determined.
 */

Body of Frist Method:
{
    try {
        return delegate.size();
    } catch (IOException e) {
        // This can occur if the cache failed to lazily initialize.
        return -1;
    }
}
Body of Second Method:
{
    try {
        return mDelegate.getSize();
    } catch (IOException e) {
        // This can occur if the cache failed to lazily initialize.
        return -1;
    }
}
------------------------
Find a silently evolved API code:android.telephony.RadioAccessFamily.getAdjustedRaf:COMMENT
Method Modifier: private     static      hidden      
Comment:/**
 * if the raf includes ANY bit set for a group
 * adjust it to contain ALL the bits for that group
 */

Body of Frist Method:
{
    raf = ((GSM & raf) > 0) ? (GSM | raf) : raf;
    raf = ((WCDMA & raf) > 0) ? (WCDMA | raf) : raf;
    raf = ((CDMA & raf) > 0) ? (CDMA | raf) : raf;
    raf = ((EVDO & raf) > 0) ? (EVDO | raf) : raf;
    raf = ((LTE & raf) > 0) ? (LTE | raf) : raf;
    return raf;
}
Body of Second Method:
{
    raf = ((GSM & raf) > 0) ? (GSM | raf) : raf;
    raf = ((WCDMA & raf) > 0) ? (WCDMA | raf) : raf;
    raf = ((CDMA & raf) > 0) ? (CDMA | raf) : raf;
    raf = ((EVDO & raf) > 0) ? (EVDO | raf) : raf;
    raf = ((LTE & raf) > 0) ? (LTE | raf) : raf;
    raf = ((NR & raf) > 0) ? (NR | raf) : raf;
    return raf;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.startVoiceRecognition:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Starts voice recognition.
 *
 * @param device remote device
 * @return <code>true</code> if command has been issued successfully; <code>false</code>
 * otherwise; upon completion HFP sends {@link #ACTION_AG_EVENT} intent.
 *
 * <p>Feature required for successful execution is being reported by: {@link
 * #EXTRA_AG_FEATURE_VOICE_RECOGNITION}. This method invocation will fail silently when feature
 * is not supported.</p>
 */

Body of Frist Method:
{
    if (DBG)
        log("startVoiceRecognition()");
    final IBluetoothHeadsetClient service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.startVoiceRecognition(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("startVoiceRecognition()");
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.startVoiceRecognition(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.webkit.WebViewDelegate.addWebViewAssetPath:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Adds the WebView asset path to {@link android.content.res.AssetManager}.
 */

Body of Frist Method:
{
    final String newAssetPath = WebViewFactory.getLoadedPackageInfo().applicationInfo.sourceDir;
    final ApplicationInfo appInfo = context.getApplicationInfo();
    final String[] libs = appInfo.sharedLibraryFiles;
    if (!ArrayUtils.contains(libs, newAssetPath)) {
        // Build the new library asset path list.
        final int newLibAssetsCount = 1 + (libs != null ? libs.length : 0);
        final String[] newLibAssets = new String[newLibAssetsCount];
        if (libs != null) {
            System.arraycopy(libs, 0, newLibAssets, 0, libs.length);
        }
        newLibAssets[newLibAssetsCount - 1] = newAssetPath;
        // Update the ApplicationInfo object with the new list.
        // We know this will persist and future Resources created via ResourcesManager
        // will include the shared library because this ApplicationInfo comes from the
        // underlying LoadedApk in ContextImpl, which does not change during the life of the
        // application.
        appInfo.sharedLibraryFiles = newLibAssets;
        // Update existing Resources with the WebView library.
        ResourcesManager.getInstance().appendLibAssetForMainAssetPath(appInfo.getBaseResourcePath(), newAssetPath);
    }
}
Body of Second Method:
{
    final String[] newAssetPaths = WebViewFactory.getLoadedPackageInfo().applicationInfo.getAllApkPaths();
    final ApplicationInfo appInfo = context.getApplicationInfo();
    // Build the new library asset path list.
    String[] newLibAssets = appInfo.sharedLibraryFiles;
    for (String newAssetPath : newAssetPaths) {
        newLibAssets = ArrayUtils.appendElement(String.class, newLibAssets, newAssetPath);
    }
    if (newLibAssets != appInfo.sharedLibraryFiles) {
        // Update the ApplicationInfo object with the new list.
        // We know this will persist and future Resources created via ResourcesManager
        // will include the shared library because this ApplicationInfo comes from the
        // underlying LoadedApk in ContextImpl, which does not change during the life of the
        // application.
        appInfo.sharedLibraryFiles = newLibAssets;
        // Update existing Resources with the WebView library.
        ResourcesManager.getInstance().appendLibAssetsForMainAssetPath(appInfo.getBaseResourcePath(), newAssetPaths);
    }
}
------------------------
Find a silently evolved API code:android.hardware.location.NanoApp.setAppBinary:COMMENT
Method Modifier: public      hidden      deprecated  
Comment:/**
 * set output events returned by the nano app
 *
 * @param appBinary generated events
 */

Body of Frist Method:
{
    mAppBinary = appBinary;
}
Body of Second Method:
{
    Preconditions.checkNotNull(appBinary, "appBinary must not be null");
    mAppBinary = appBinary;
}
------------------------
Find a silently evolved API code:android.app.servertransaction.LaunchActivityItem.writeToParcel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Write from Parcel.
 */

Body of Frist Method:
{
    dest.writeTypedObject(mIntent, flags);
    dest.writeInt(mIdent);
    dest.writeTypedObject(mInfo, flags);
    dest.writeTypedObject(mCurConfig, flags);
    dest.writeTypedObject(mOverrideConfig, flags);
    dest.writeTypedObject(mCompatInfo, flags);
    dest.writeString(mReferrer);
    dest.writeStrongInterface(mVoiceInteractor);
    dest.writeInt(mProcState);
    dest.writeBundle(mState);
    dest.writePersistableBundle(mPersistentState);
    dest.writeTypedList(mPendingResults, flags);
    dest.writeTypedList(mPendingNewIntents, flags);
    dest.writeBoolean(mIsForward);
    dest.writeTypedObject(mProfilerInfo, flags);
}
Body of Second Method:
{
    dest.writeTypedObject(mIntent, flags);
    dest.writeInt(mIdent);
    dest.writeTypedObject(mInfo, flags);
    dest.writeTypedObject(mCurConfig, flags);
    dest.writeTypedObject(mOverrideConfig, flags);
    dest.writeTypedObject(mCompatInfo, flags);
    dest.writeString(mReferrer);
    dest.writeStrongInterface(mVoiceInteractor);
    dest.writeInt(mProcState);
    dest.writeBundle(mState);
    dest.writePersistableBundle(mPersistentState);
    dest.writeTypedList(mPendingResults, flags);
    dest.writeTypedList(mPendingNewIntents, flags);
    dest.writeBoolean(mIsForward);
    dest.writeTypedObject(mProfilerInfo, flags);
    dest.writeStrongBinder(mAssistToken);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothPan.disconnect:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Initiate disconnection from a profile
 *
 * <p> This API will return false in scenarios like the profile on the
 * Bluetooth device is not in connected state etc. When this API returns,
 * true, it is guaranteed that the connection state change
 * intent will be broadcasted with the state. Users can get the
 * disconnection state of the profile from this intent.
 *
 * <p> If the disconnection is initiated by a remote device, the state
 * will transition from {@link #STATE_CONNECTED} to
 * {@link #STATE_DISCONNECTED}. If the disconnect is initiated by the
 * host (local) device the state will transition from
 * {@link #STATE_CONNECTED} to state {@link #STATE_DISCONNECTING} to
 * state {@link #STATE_DISCONNECTED}. The transition to
 * {@link #STATE_DISCONNECTING} can be used to distinguish between the
 * two scenarios.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}
 * permission.
 *
 * @param device Remote Bluetooth Device
 * @return false on immediate error, true otherwise
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("disconnect(" + device + ")");
    final IBluetoothPan service = mPanService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.disconnect(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("disconnect(" + device + ")");
    final IBluetoothPan service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.disconnect(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.widget.CheckedTextView.getCheckMarkTintMode:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the blending mode used to apply the tint to the check mark
 * drawable, if specified.
 *
 * @return the blending mode used to apply the tint to the check mark
 * drawable
 * @attr ref android.R.styleable#CheckedTextView_checkMarkTintMode
 * @see #setCheckMarkTintMode(PorterDuff.Mode)
 */

Body of Frist Method:
{
    return mCheckMarkTintMode;
}
Body of Second Method:
{
    return mCheckMarkBlendMode != null ? BlendMode.blendModeToPorterDuffMode(mCheckMarkBlendMode) : null;
}
------------------------
Find a silently evolved API code:android.graphics.drawable.GradientDrawable.getOrientation:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the orientation of the gradient defined in this drawable.
 *
 * @return the orientation of the gradient defined in this drawable
 * @see #setOrientation(Orientation)
 */

Body of Frist Method:
{
    return mGradientState.mOrientation;
}
Body of Second Method:
{
    return mGradientState.getOrientation();
}
------------------------
Find a silently evolved API code:android.media.AudioAttributes.Builder.setInternalLegacyStreamType:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 * For internal framework use only, enables building from hidden stream types.
 * @param streamType
 * @return the same Builder instance.
 */

Body of Frist Method:
{
    switch(streamType) {
        case AudioSystem.STREAM_VOICE_CALL:
            mContentType = CONTENT_TYPE_SPEECH;
            break;
        case AudioSystem.STREAM_SYSTEM_ENFORCED:
            mFlags |= FLAG_AUDIBILITY_ENFORCED;
        // intended fall through, attributes in common with STREAM_SYSTEM
        case AudioSystem.STREAM_SYSTEM:
            mContentType = CONTENT_TYPE_SONIFICATION;
            break;
        case AudioSystem.STREAM_RING:
            mContentType = CONTENT_TYPE_SONIFICATION;
            break;
        case AudioSystem.STREAM_MUSIC:
            mContentType = CONTENT_TYPE_MUSIC;
            break;
        case AudioSystem.STREAM_ALARM:
            mContentType = CONTENT_TYPE_SONIFICATION;
            break;
        case AudioSystem.STREAM_NOTIFICATION:
            mContentType = CONTENT_TYPE_SONIFICATION;
            break;
        case AudioSystem.STREAM_BLUETOOTH_SCO:
            mContentType = CONTENT_TYPE_SPEECH;
            mFlags |= FLAG_SCO;
            break;
        case AudioSystem.STREAM_DTMF:
            mContentType = CONTENT_TYPE_SONIFICATION;
            break;
        case AudioSystem.STREAM_TTS:
            mContentType = CONTENT_TYPE_SONIFICATION;
            break;
        case AudioSystem.STREAM_ACCESSIBILITY:
            mContentType = CONTENT_TYPE_SPEECH;
            break;
        default:
            Log.e(TAG, "Invalid stream type " + streamType + " for AudioAttributes");
    }
    mUsage = usageForStreamType(streamType);
    return this;
}
Body of Second Method:
{
    mContentType = CONTENT_TYPE_UNKNOWN;
    mUsage = USAGE_UNKNOWN;
    if (AudioProductStrategy.getAudioProductStrategies().size() > 0) {
        AudioAttributes attributes = AudioProductStrategy.getAudioAttributesForStrategyWithLegacyStreamType(streamType);
        if (attributes != null) {
            mUsage = attributes.mUsage;
            mContentType = attributes.mContentType;
            mFlags = attributes.mFlags;
            mMuteHapticChannels = attributes.areHapticChannelsMuted();
            mTags = attributes.mTags;
            mBundle = attributes.mBundle;
            mSource = attributes.mSource;
        }
    }
    if (mContentType == CONTENT_TYPE_UNKNOWN) {
        switch(streamType) {
            case AudioSystem.STREAM_VOICE_CALL:
                mContentType = CONTENT_TYPE_SPEECH;
                break;
            case AudioSystem.STREAM_SYSTEM_ENFORCED:
                mFlags |= FLAG_AUDIBILITY_ENFORCED;
            // intended fall through, attributes in common with STREAM_SYSTEM
            case AudioSystem.STREAM_SYSTEM:
                mContentType = CONTENT_TYPE_SONIFICATION;
                break;
            case AudioSystem.STREAM_RING:
                mContentType = CONTENT_TYPE_SONIFICATION;
                break;
            case AudioSystem.STREAM_MUSIC:
                mContentType = CONTENT_TYPE_MUSIC;
                break;
            case AudioSystem.STREAM_ALARM:
                mContentType = CONTENT_TYPE_SONIFICATION;
                break;
            case AudioSystem.STREAM_NOTIFICATION:
                mContentType = CONTENT_TYPE_SONIFICATION;
                break;
            case AudioSystem.STREAM_BLUETOOTH_SCO:
                mContentType = CONTENT_TYPE_SPEECH;
                mFlags |= FLAG_SCO;
                break;
            case AudioSystem.STREAM_DTMF:
                mContentType = CONTENT_TYPE_SONIFICATION;
                break;
            case AudioSystem.STREAM_TTS:
                mContentType = CONTENT_TYPE_SONIFICATION;
                mFlags |= FLAG_BEACON;
                break;
            case AudioSystem.STREAM_ACCESSIBILITY:
                mContentType = CONTENT_TYPE_SPEECH;
                break;
            default:
                Log.e(TAG, "Invalid stream type " + streamType + " for AudioAttributes");
        }
    }
    if (mUsage == USAGE_UNKNOWN) {
        mUsage = usageForStreamType(streamType);
    }
    return this;
}
------------------------
Find a silently evolved API code:android.view.WindowInsets.getStableInsetBottom:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the bottom stable inset in pixels.
 *
 * <p>The stable inset represents the area of a full-screen window that <b>may</b> be
 * partially or fully obscured by the system UI elements.  This value does not change
 * based on the visibility state of those elements; for example, if the status bar is
 * normally shown, but temporarily hidden, the stable inset will still provide the inset
 * associated with the status bar being shown.</p>
 *
 * @return The bottom stable inset
 */

Body of Frist Method:
{
    return mStableInsets.bottom;
}
Body of Second Method:
{
    return getStableInsets().bottom;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHidHost.setReport:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Send Set_Report command to the connected HID input device.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN} permission.
 *
 * @param device Remote Bluetooth Device
 * @param reportType Report type
 * @param report Report receiving buffer size
 * @return false on immediate error, true otherwise
 * @hide
 */

Body of Frist Method:
{
    if (VDBG)
        log("setReport(" + device + "), reportType=" + reportType + " report=" + report);
    final IBluetoothHidHost service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.setReport(device, reportType, report);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (VDBG)
        log("setReport(" + device + "), reportType=" + reportType + " report=" + report);
    final IBluetoothHidHost service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.setReport(device, reportType, report);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.view.textservice.TextServicesManager.getEnabledSpellCheckers:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    try {
        final SpellCheckerInfo[] retval = mService.getEnabledSpellCheckers();
        if (DBG) {
            Log.d(TAG, "getEnabledSpellCheckers: " + (retval != null ? retval.length : "null"));
        }
        return retval;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    try {
        final SpellCheckerInfo[] retval = mService.getEnabledSpellCheckers(mUserId);
        if (DBG) {
            Log.d(TAG, "getEnabledSpellCheckers: " + (retval != null ? retval.length : "null"));
        }
        return retval;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothGatt.writeCharacteristic:COMMENT
Method Modifier: public      
Comment:/**
 * Writes a given characteristic and its values to the associated remote device.
 *
 * <p>Once the write operation has been completed, the
 * {@link BluetoothGattCallback#onCharacteristicWrite} callback is invoked,
 * reporting the result of the operation.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param characteristic Characteristic to write on the remote device
 * @return true, if the write operation was initiated successfully
 */

Body of Frist Method:
{
    if ((characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_WRITE) == 0 && (characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE) == 0) {
        return false;
    }
    if (VDBG)
        Log.d(TAG, "writeCharacteristic() - uuid: " + characteristic.getUuid());
    if (mService == null || mClientIf == 0 || characteristic.getValue() == null)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusy) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.writeCharacteristic(mClientIf, device.getAddress(), characteristic.getInstanceId(), characteristic.getWriteType(), AUTHENTICATION_NONE, characteristic.getValue());
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}
Body of Second Method:
{
    if ((characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_WRITE) == 0 && (characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE) == 0) {
        return false;
    }
    if (VDBG)
        Log.d(TAG, "writeCharacteristic() - uuid: " + characteristic.getUuid());
    if (mService == null || mClientIf == 0 || characteristic.getValue() == null)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusyLock) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.writeCharacteristic(mClientIf, device.getAddress(), characteristic.getInstanceId(), characteristic.getWriteType(), AUTHENTICATION_NONE, characteristic.getValue());
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothMap.getConnectedDevices:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the list of connected devices. Currently at most one.
 *
 * @return list of connected devices
 */

Body of Frist Method:
{
    if (DBG)
        log("getConnectedDevices()");
    final IBluetoothMap service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.getConnectedDevices();
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
Body of Second Method:
{
    if (DBG)
        log("getConnectedDevices()");
    final IBluetoothMap service = getService();
    if (service != null && isEnabled()) {
        try {
            return service.getConnectedDevices();
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
------------------------
Find a silently evolved API code:android.provider.CallLog.Calls.updateNormalizedNumber:COMMENT
Method Modifier: private     static      
Comment:/*
         * Update the normalized phone number for the given dataId in the ContactsProvider, based
         * on the user's current country.
         */

Body of Frist Method:
{
    if (TextUtils.isEmpty(number) || TextUtils.isEmpty(dataId)) {
        return;
    }
    final String countryIso = getCurrentCountryIso(context);
    if (TextUtils.isEmpty(countryIso)) {
        return;
    }
    final String normalizedNumber = PhoneNumberUtils.formatNumberToE164(number, getCurrentCountryIso(context));
    if (TextUtils.isEmpty(normalizedNumber)) {
        return;
    }
    final ContentValues values = new ContentValues();
    values.put(Phone.NORMALIZED_NUMBER, normalizedNumber);
    resolver.update(Data.CONTENT_URI, values, Data._ID + "=?", new String[] { dataId });
}
Body of Second Method:
{
    if (TextUtils.isEmpty(number) || TextUtils.isEmpty(dataId)) {
        return;
    }
    final String countryIso = getCurrentCountryIso(context);
    if (TextUtils.isEmpty(countryIso)) {
        return;
    }
    final String normalizedNumber = PhoneNumberUtils.formatNumberToE164(number, countryIso);
    if (TextUtils.isEmpty(normalizedNumber)) {
        return;
    }
    final ContentValues values = new ContentValues();
    values.put(Phone.NORMALIZED_NUMBER, normalizedNumber);
    resolver.update(Data.CONTENT_URI, values, Data._ID + "=?", new String[] { dataId });
}
------------------------
Find a silently evolved API code:android.media.audiopolicy.AudioMixingRule.Builder.addRuleInternal:COMMENT
Method Modifier: private     
Comment:/**
 * Add or exclude a rule on AudioAttributes or integer property for the selection of which
 * streams are mixed together.
 * No rule-to-parameter type check, all done in {@link #checkAddRuleObjInternal(int, Object)}.
 * Exceptions are thrown only when incompatible rules are added.
 * @param attrToMatch a non-null AudioAttributes instance for which a contradictory
 * rule hasn't been set yet, null if not used.
 * @param intProp an integer property to match or exclude, null if not used.
 * @param rule one of {@link AudioMixingRule#RULE_EXCLUDE_ATTRIBUTE_USAGE},
 * {@link AudioMixingRule#RULE_MATCH_ATTRIBUTE_USAGE},
 * {@link AudioMixingRule#RULE_MATCH_ATTRIBUTE_CAPTURE_PRESET} or
 * {@link AudioMixingRule#RULE_EXCLUDE_ATTRIBUTE_CAPTURE_PRESET},
 * {@link AudioMixingRule#RULE_MATCH_UID}, {@link AudioMixingRule#RULE_EXCLUDE_UID}.
 * @return the same Builder instance.
 * @throws IllegalArgumentException
 */

Body of Frist Method:
{
    // of mix being built. When adding the first rule, the mix type is MIX_TYPE_INVALID.
    if (mTargetMixType == AudioMix.MIX_TYPE_INVALID) {
        if (isPlayerRule(rule)) {
            mTargetMixType = AudioMix.MIX_TYPE_PLAYERS;
        } else {
            mTargetMixType = AudioMix.MIX_TYPE_RECORDERS;
        }
    } else if (((mTargetMixType == AudioMix.MIX_TYPE_PLAYERS) && !isPlayerRule(rule)) || ((mTargetMixType == AudioMix.MIX_TYPE_RECORDERS) && isPlayerRule(rule))) {
        throw new IllegalArgumentException("Incompatible rule for mix");
    }
    synchronized (mCriteria) {
        Iterator<AudioMixMatchCriterion> crIterator = mCriteria.iterator();
        final int match_rule = rule & ~RULE_EXCLUSION_MASK;
        while (crIterator.hasNext()) {
            final AudioMixMatchCriterion criterion = crIterator.next();
            switch(match_rule) {
                case RULE_MATCH_ATTRIBUTE_USAGE:
                    // "usage"-based rule
                    if (criterion.mAttr.getUsage() == attrToMatch.getUsage()) {
                        if (criterion.mRule == rule) {
                            // rule already exists, we're done
                            return this;
                        } else {
                            // it is incompatible
                            throw new IllegalArgumentException("Contradictory rule exists" + " for " + attrToMatch);
                        }
                    }
                    break;
                case RULE_MATCH_ATTRIBUTE_CAPTURE_PRESET:
                    // "capture preset"-base rule
                    if (criterion.mAttr.getCapturePreset() == attrToMatch.getCapturePreset()) {
                        if (criterion.mRule == rule) {
                            // rule already exists, we're done
                            return this;
                        } else {
                            // it is incompatible
                            throw new IllegalArgumentException("Contradictory rule exists" + " for " + attrToMatch);
                        }
                    }
                    break;
                case RULE_MATCH_UID:
                    // "usage"-based rule
                    if (criterion.mIntProp == intProp.intValue()) {
                        if (criterion.mRule == rule) {
                            // rule already exists, we're done
                            return this;
                        } else {
                            // it is incompatible
                            throw new IllegalArgumentException("Contradictory rule exists" + " for UID " + intProp);
                        }
                    }
                    break;
            }
        }
        // rule didn't exist, add it
        switch(match_rule) {
            case RULE_MATCH_ATTRIBUTE_USAGE:
            case RULE_MATCH_ATTRIBUTE_CAPTURE_PRESET:
                mCriteria.add(new AudioMixMatchCriterion(attrToMatch, rule));
                break;
            case RULE_MATCH_UID:
                mCriteria.add(new AudioMixMatchCriterion(intProp, rule));
                break;
            default:
                throw new IllegalStateException("Unreachable code in addRuleInternal()");
        }
    }
    return this;
}
Body of Second Method:
{
    // of mix being built. When adding the first rule, the mix type is MIX_TYPE_INVALID.
    if (mTargetMixType == AudioMix.MIX_TYPE_INVALID) {
        if (isPlayerRule(rule)) {
            mTargetMixType = AudioMix.MIX_TYPE_PLAYERS;
        } else {
            mTargetMixType = AudioMix.MIX_TYPE_RECORDERS;
        }
    } else if (((mTargetMixType == AudioMix.MIX_TYPE_PLAYERS) && !isPlayerRule(rule)) || ((mTargetMixType == AudioMix.MIX_TYPE_RECORDERS) && isPlayerRule(rule))) {
        throw new IllegalArgumentException("Incompatible rule for mix");
    }
    synchronized (mCriteria) {
        Iterator<AudioMixMatchCriterion> crIterator = mCriteria.iterator();
        final int match_rule = rule & ~RULE_EXCLUSION_MASK;
        while (crIterator.hasNext()) {
            final AudioMixMatchCriterion criterion = crIterator.next();
            if ((criterion.mRule & ~RULE_EXCLUSION_MASK) != match_rule) {
                // The two rules are not of the same type
                continue;
            }
            switch(match_rule) {
                case RULE_MATCH_ATTRIBUTE_USAGE:
                    // "usage"-based rule
                    if (criterion.mAttr.getUsage() == attrToMatch.getUsage()) {
                        if (criterion.mRule == rule) {
                            // rule already exists, we're done
                            return this;
                        } else {
                            // it is incompatible
                            throw new IllegalArgumentException("Contradictory rule exists" + " for " + attrToMatch);
                        }
                    }
                    break;
                case RULE_MATCH_ATTRIBUTE_CAPTURE_PRESET:
                    // "capture preset"-base rule
                    if (criterion.mAttr.getCapturePreset() == attrToMatch.getCapturePreset()) {
                        if (criterion.mRule == rule) {
                            // rule already exists, we're done
                            return this;
                        } else {
                            // it is incompatible
                            throw new IllegalArgumentException("Contradictory rule exists" + " for " + attrToMatch);
                        }
                    }
                    break;
                case RULE_MATCH_UID:
                    // "usage"-based rule
                    if (criterion.mIntProp == intProp.intValue()) {
                        if (criterion.mRule == rule) {
                            // rule already exists, we're done
                            return this;
                        } else {
                            // it is incompatible
                            throw new IllegalArgumentException("Contradictory rule exists" + " for UID " + intProp);
                        }
                    }
                    break;
            }
        }
        // rule didn't exist, add it
        switch(match_rule) {
            case RULE_MATCH_ATTRIBUTE_USAGE:
            case RULE_MATCH_ATTRIBUTE_CAPTURE_PRESET:
                mCriteria.add(new AudioMixMatchCriterion(attrToMatch, rule));
                break;
            case RULE_MATCH_UID:
                mCriteria.add(new AudioMixMatchCriterion(intProp, rule));
                break;
            default:
                throw new IllegalStateException("Unreachable code in addRuleInternal()");
        }
    }
    return this;
}
------------------------
Find a silently evolved API code:android.telephony.CellSignalStrengthCdma.getCdmaLevel:COMMENT
Method Modifier: public      
Comment:/**
 * Get cdma as level 0..4
 */

Body of Frist Method:
{
    final int cdmaDbm = getCdmaDbm();
    final int cdmaEcio = getCdmaEcio();
    int levelDbm;
    int levelEcio;
    if (cdmaDbm == Integer.MAX_VALUE)
        levelDbm = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    else if (cdmaDbm >= -75)
        levelDbm = SIGNAL_STRENGTH_GREAT;
    else if (cdmaDbm >= -85)
        levelDbm = SIGNAL_STRENGTH_GOOD;
    else if (cdmaDbm >= -95)
        levelDbm = SIGNAL_STRENGTH_MODERATE;
    else if (cdmaDbm >= -100)
        levelDbm = SIGNAL_STRENGTH_POOR;
    else
        levelDbm = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    // Ec/Io are in dB*10
    if (cdmaEcio == Integer.MAX_VALUE)
        levelEcio = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    else if (cdmaEcio >= -90)
        levelEcio = SIGNAL_STRENGTH_GREAT;
    else if (cdmaEcio >= -110)
        levelEcio = SIGNAL_STRENGTH_GOOD;
    else if (cdmaEcio >= -130)
        levelEcio = SIGNAL_STRENGTH_MODERATE;
    else if (cdmaEcio >= -150)
        levelEcio = SIGNAL_STRENGTH_POOR;
    else
        levelEcio = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    int level = (levelDbm < levelEcio) ? levelDbm : levelEcio;
    if (DBG)
        log("getCdmaLevel=" + level);
    return level;
}
Body of Second Method:
{
    final int cdmaDbm = getCdmaDbm();
    final int cdmaEcio = getCdmaEcio();
    int levelDbm;
    int levelEcio;
    if (cdmaDbm == CellInfo.UNAVAILABLE)
        levelDbm = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    else if (cdmaDbm >= -75)
        levelDbm = SIGNAL_STRENGTH_GREAT;
    else if (cdmaDbm >= -85)
        levelDbm = SIGNAL_STRENGTH_GOOD;
    else if (cdmaDbm >= -95)
        levelDbm = SIGNAL_STRENGTH_MODERATE;
    else if (cdmaDbm >= -100)
        levelDbm = SIGNAL_STRENGTH_POOR;
    else
        levelDbm = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    // Ec/Io are in dB*10
    if (cdmaEcio == CellInfo.UNAVAILABLE)
        levelEcio = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    else if (cdmaEcio >= -90)
        levelEcio = SIGNAL_STRENGTH_GREAT;
    else if (cdmaEcio >= -110)
        levelEcio = SIGNAL_STRENGTH_GOOD;
    else if (cdmaEcio >= -130)
        levelEcio = SIGNAL_STRENGTH_MODERATE;
    else if (cdmaEcio >= -150)
        levelEcio = SIGNAL_STRENGTH_POOR;
    else
        levelEcio = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    int level = (levelDbm < levelEcio) ? levelDbm : levelEcio;
    if (DBG)
        log("getCdmaLevel=" + level);
    return level;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothMap.getConnectionState:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get connection state of device
 *
 * @return device connection state
 */

Body of Frist Method:
{
    if (DBG)
        log("getConnectionState(" + device + ")");
    final IBluetoothMap service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getConnectionState(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.STATE_DISCONNECTED;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return BluetoothProfile.STATE_DISCONNECTED;
}
Body of Second Method:
{
    if (DBG)
        log("getConnectionState(" + device + ")");
    final IBluetoothMap service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getConnectionState(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.STATE_DISCONNECTED;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return BluetoothProfile.STATE_DISCONNECTED;
}
------------------------
Find a silently evolved API code:android.app.Instrumentation.sendKeySync:COMMENT
Method Modifier: public      
Comment:/**
 * Send a key event to the currently focused window/view and wait for it to
 * be processed.  Finished at some point after the recipient has returned
 * from its event processing, though it may <em>not</em> have completely
 * finished reacting from the event -- for example, if it needs to update
 * its display as a result, it may still be in the process of doing that.
 *
 * @param event The event to send to the current focus.
 */

Body of Frist Method:
{
    validateNotAppThread();
    long downTime = event.getDownTime();
    long eventTime = event.getEventTime();
    int action = event.getAction();
    int code = event.getKeyCode();
    int repeatCount = event.getRepeatCount();
    int metaState = event.getMetaState();
    int deviceId = event.getDeviceId();
    int scancode = event.getScanCode();
    int source = event.getSource();
    int flags = event.getFlags();
    if (source == InputDevice.SOURCE_UNKNOWN) {
        source = InputDevice.SOURCE_KEYBOARD;
    }
    if (eventTime == 0) {
        eventTime = SystemClock.uptimeMillis();
    }
    if (downTime == 0) {
        downTime = eventTime;
    }
    KeyEvent newEvent = new KeyEvent(downTime, eventTime, action, code, repeatCount, metaState, deviceId, scancode, flags | KeyEvent.FLAG_FROM_SYSTEM, source);
    InputManager.getInstance().injectInputEvent(newEvent, InputManager.INJECT_INPUT_EVENT_MODE_WAIT_FOR_FINISH);
}
Body of Second Method:
{
    validateNotAppThread();
    long downTime = event.getDownTime();
    long eventTime = event.getEventTime();
    int source = event.getSource();
    if (source == InputDevice.SOURCE_UNKNOWN) {
        source = InputDevice.SOURCE_KEYBOARD;
    }
    if (eventTime == 0) {
        eventTime = SystemClock.uptimeMillis();
    }
    if (downTime == 0) {
        downTime = eventTime;
    }
    KeyEvent newEvent = new KeyEvent(event);
    newEvent.setTime(downTime, eventTime);
    newEvent.setSource(source);
    newEvent.setFlags(event.getFlags() | KeyEvent.FLAG_FROM_SYSTEM);
    InputManager.getInstance().injectInputEvent(newEvent, InputManager.INJECT_INPUT_EVENT_MODE_WAIT_FOR_FINISH);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothGatt.readCharacteristic:COMMENT
Method Modifier: public      
Comment:/**
 * Reads the requested characteristic from the associated remote device.
 *
 * <p>This is an asynchronous operation. The result of the read operation
 * is reported by the {@link BluetoothGattCallback#onCharacteristicRead}
 * callback.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param characteristic Characteristic to read from the remote device
 * @return true, if the read operation was initiated successfully
 */

Body of Frist Method:
{
    if ((characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_READ) == 0) {
        return false;
    }
    if (VDBG)
        Log.d(TAG, "readCharacteristic() - uuid: " + characteristic.getUuid());
    if (mService == null || mClientIf == 0)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusy) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.readCharacteristic(mClientIf, device.getAddress(), characteristic.getInstanceId(), AUTHENTICATION_NONE);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}
Body of Second Method:
{
    if ((characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_READ) == 0) {
        return false;
    }
    if (VDBG)
        Log.d(TAG, "readCharacteristic() - uuid: " + characteristic.getUuid());
    if (mService == null || mClientIf == 0)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusyLock) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.readCharacteristic(mClientIf, device.getAddress(), characteristic.getInstanceId(), AUTHENTICATION_NONE);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}
------------------------
Find a silently evolved API code:android.telephony.euicc.EuiccManager.eraseSubscriptions:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Erase all subscriptions and reset the eUICC.
 *
 * <p>Requires that the calling app has the
 * {@code android.Manifest.permission#WRITE_EMBEDDED_SUBSCRIPTIONS} permission.
 *
 * @param callbackIntent a PendingIntent to launch when the operation completes.
 * @hide
 */

Body of Frist Method:
{
    if (!isEnabled()) {
        sendUnavailableError(callbackIntent);
        return;
    }
    try {
        getIEuiccController().eraseSubscriptions(callbackIntent);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    if (!isEnabled()) {
        sendUnavailableError(callbackIntent);
        return;
    }
    try {
        getIEuiccController().eraseSubscriptions(mCardId, callbackIntent);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothMap.getDevicesMatchingConnectionStates:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the list of devices matching specified states. Currently at most one.
 *
 * @return list of matching devices
 */

Body of Frist Method:
{
    if (DBG)
        log("getDevicesMatchingStates()");
    final IBluetoothMap service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.getDevicesMatchingConnectionStates(states);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
Body of Second Method:
{
    if (DBG)
        log("getDevicesMatchingStates()");
    final IBluetoothMap service = getService();
    if (service != null && isEnabled()) {
        try {
            return service.getDevicesMatchingConnectionStates(states);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiScanner.ScanSettings.writeToParcel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Implement the Parcelable interface {@hide}
 */

Body of Frist Method:
{
    dest.writeInt(band);
    dest.writeInt(periodInMs);
    dest.writeInt(reportEvents);
    dest.writeInt(numBssidsPerScan);
    dest.writeInt(maxScansToCache);
    dest.writeInt(maxPeriodInMs);
    dest.writeInt(stepCount);
    dest.writeInt(isPnoScan ? 1 : 0);
    dest.writeInt(type);
    if (channels != null) {
        dest.writeInt(channels.length);
        for (int i = 0; i < channels.length; i++) {
            dest.writeInt(channels[i].frequency);
            dest.writeInt(channels[i].dwellTimeMS);
            dest.writeInt(channels[i].passive ? 1 : 0);
        }
    } else {
        dest.writeInt(0);
    }
    if (hiddenNetworks != null) {
        dest.writeInt(hiddenNetworks.length);
        for (int i = 0; i < hiddenNetworks.length; i++) {
            dest.writeString(hiddenNetworks[i].ssid);
        }
    } else {
        dest.writeInt(0);
    }
}
Body of Second Method:
{
    dest.writeInt(band);
    dest.writeInt(periodInMs);
    dest.writeInt(reportEvents);
    dest.writeInt(numBssidsPerScan);
    dest.writeInt(maxScansToCache);
    dest.writeInt(maxPeriodInMs);
    dest.writeInt(stepCount);
    dest.writeInt(isPnoScan ? 1 : 0);
    dest.writeInt(type);
    dest.writeInt(ignoreLocationSettings ? 1 : 0);
    dest.writeInt(hideFromAppOps ? 1 : 0);
    if (channels != null) {
        dest.writeInt(channels.length);
        for (int i = 0; i < channels.length; i++) {
            dest.writeInt(channels[i].frequency);
            dest.writeInt(channels[i].dwellTimeMS);
            dest.writeInt(channels[i].passive ? 1 : 0);
        }
    } else {
        dest.writeInt(0);
    }
    if (hiddenNetworks != null) {
        dest.writeInt(hiddenNetworks.length);
        for (int i = 0; i < hiddenNetworks.length; i++) {
            dest.writeString(hiddenNetworks[i].ssid);
        }
    } else {
        dest.writeInt(0);
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothA2dp.disconnect:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Initiate disconnection from a profile
 *
 * <p> This API will return false in scenarios like the profile on the
 * Bluetooth device is not in connected state etc. When this API returns,
 * true, it is guaranteed that the connection state change
 * intent will be broadcasted with the state. Users can get the
 * disconnection state of the profile from this intent.
 *
 * <p> If the disconnection is initiated by a remote device, the state
 * will transition from {@link #STATE_CONNECTED} to
 * {@link #STATE_DISCONNECTED}. If the disconnect is initiated by the
 * host (local) device the state will transition from
 * {@link #STATE_CONNECTED} to state {@link #STATE_DISCONNECTING} to
 * state {@link #STATE_DISCONNECTED}. The transition to
 * {@link #STATE_DISCONNECTING} can be used to distinguish between the
 * two scenarios.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}
 * permission.
 *
 * @param device Remote Bluetooth Device
 * @return false on immediate error, true otherwise
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("disconnect(" + device + ")");
    try {
        mServiceLock.readLock().lock();
        if (mService != null && isEnabled() && isValidDevice(device)) {
            return mService.disconnect(device);
        }
        if (mService == null)
            Log.w(TAG, "Proxy not attached to service");
        return false;
    } catch (RemoteException e) {
        Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
        return false;
    } finally {
        mServiceLock.readLock().unlock();
    }
}
Body of Second Method:
{
    if (DBG)
        log("disconnect(" + device + ")");
    try {
        final IBluetoothA2dp service = getService();
        if (service != null && isEnabled() && isValidDevice(device)) {
            return service.disconnect(device);
        }
        if (service == null)
            Log.w(TAG, "Proxy not attached to service");
        return false;
    } catch (RemoteException e) {
        Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
        return false;
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.setAudioRouteAllowed:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets whether audio routing is allowed.
 *
 * @param device remote device
 * @param allowed if routing is allowed to the device Note: This is an internal function and
 * shouldn't be exposed
 */

Body of Frist Method:
{
    if (VDBG)
        log("setAudioRouteAllowed");
    final IBluetoothHeadsetClient service = mService;
    if (service != null && isEnabled()) {
        try {
            service.setAudioRouteAllowed(device, allowed);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
}
Body of Second Method:
{
    if (VDBG)
        log("setAudioRouteAllowed");
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled()) {
        try {
            service.setAudioRouteAllowed(device, allowed);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHidHost.getConnectionState:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (VDBG)
        log("getState(" + device + ")");
    final IBluetoothHidHost service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getConnectionState(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.STATE_DISCONNECTED;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return BluetoothProfile.STATE_DISCONNECTED;
}
Body of Second Method:
{
    if (VDBG)
        log("getState(" + device + ")");
    final IBluetoothHidHost service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getConnectionState(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.STATE_DISCONNECTED;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return BluetoothProfile.STATE_DISCONNECTED;
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiConfiguration.getAuthType:COMMENT
<android.net.wifi.WifiConfiguration: int getAuthType()>
public      hidden      ->public      hidden      deprecated  
Method Modifier: public      hidden      deprecated  
Method Modifier: Yes         Yes         No          
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (allowedKeyManagement.cardinality() > 1) {
        throw new IllegalStateException("More than one auth type set");
    }
    if (allowedKeyManagement.get(KeyMgmt.WPA_PSK)) {
        return KeyMgmt.WPA_PSK;
    } else if (allowedKeyManagement.get(KeyMgmt.WPA2_PSK)) {
        return KeyMgmt.WPA2_PSK;
    } else if (allowedKeyManagement.get(KeyMgmt.WPA_EAP)) {
        return KeyMgmt.WPA_EAP;
    } else if (allowedKeyManagement.get(KeyMgmt.IEEE8021X)) {
        return KeyMgmt.IEEE8021X;
    }
    return KeyMgmt.NONE;
}
Body of Second Method:
{
    if (allowedKeyManagement.cardinality() > 1) {
        throw new IllegalStateException("More than one auth type set");
    }
    if (allowedKeyManagement.get(KeyMgmt.WPA_PSK)) {
        return KeyMgmt.WPA_PSK;
    } else if (allowedKeyManagement.get(KeyMgmt.WPA2_PSK)) {
        return KeyMgmt.WPA2_PSK;
    } else if (allowedKeyManagement.get(KeyMgmt.WPA_EAP)) {
        return KeyMgmt.WPA_EAP;
    } else if (allowedKeyManagement.get(KeyMgmt.IEEE8021X)) {
        return KeyMgmt.IEEE8021X;
    } else if (allowedKeyManagement.get(KeyMgmt.SAE)) {
        return KeyMgmt.SAE;
    } else if (allowedKeyManagement.get(KeyMgmt.OWE)) {
        return KeyMgmt.OWE;
    } else if (allowedKeyManagement.get(KeyMgmt.SUITE_B_192)) {
        return KeyMgmt.SUITE_B_192;
    }
    return KeyMgmt.NONE;
}
------------------------
Find a silently evolved API code:android.net.http.HttpResponseCache.install:COMMENT
Method Modifier: public      static      
Comment:/**
 * Creates a new HTTP response cache and sets it as the system default cache.
 *
 * @param directory the directory to hold cache data.
 * @param maxSize the maximum size of the cache in bytes.
 * @return the newly-installed cache
 * @throws IOException if {@code directory} cannot be used for this cache.
 * Most applications should respond to this exception by logging a
 * warning.
 */

Body of Frist Method:
{
    ResponseCache installed = ResponseCache.getDefault();
    if (installed instanceof HttpResponseCache) {
        HttpResponseCache installedResponseCache = (HttpResponseCache) installed;
        // don't close and reopen if an equivalent cache is already installed
        AndroidShimResponseCache trueResponseCache = installedResponseCache.delegate;
        if (trueResponseCache.isEquivalent(directory, maxSize)) {
            return installedResponseCache;
        } else {
            // The HttpResponseCache that owns this object is about to be replaced.
            trueResponseCache.close();
        }
    }
    AndroidShimResponseCache trueResponseCache = AndroidShimResponseCache.create(directory, maxSize);
    HttpResponseCache newResponseCache = new HttpResponseCache(trueResponseCache);
    ResponseCache.setDefault(newResponseCache);
    return newResponseCache;
}
Body of Second Method:
{
    ResponseCache installed = ResponseCache.getDefault();
    if (installed instanceof HttpResponseCache) {
        HttpResponseCache installedResponseCache = (HttpResponseCache) installed;
        CacheHolder cacheHolder = installedResponseCache.getCacheHolder();
        // don't close and reopen if an equivalent cache is already installed
        if (cacheHolder.isEquivalent(directory, maxSize)) {
            return installedResponseCache;
        } else {
            // The HttpResponseCache that owns this object is about to be replaced.
            installedResponseCache.close();
        }
    }
    CacheHolder cacheHolder = CacheHolder.create(directory, maxSize);
    AndroidResponseCacheAdapter androidResponseCacheAdapter = new AndroidResponseCacheAdapter(cacheHolder);
    HttpResponseCache responseCache = new HttpResponseCache(androidResponseCacheAdapter);
    ResponseCache.setDefault(responseCache);
    return responseCache;
}
------------------------
Find a silently evolved API code:android.graphics.Camera.applyToCanvas:COMMENT
Method Modifier: public      
Comment:/**
 * Computes the matrix corresponding to the current transformation
 * and applies it to the specified Canvas.
 *
 * @param canvas The Canvas to set the transform matrix onto
 */

Body of Frist Method:
{
    if (canvas.isHardwareAccelerated()) {
        if (mMatrix == null)
            mMatrix = new Matrix();
        getMatrix(mMatrix);
        canvas.concat(mMatrix);
    } else {
        nativeApplyToCanvas(canvas.getNativeCanvasWrapper());
    }
}
Body of Second Method:
{
    nativeApplyToCanvas(canvas.getNativeCanvasWrapper());
}
------------------------
Find a silently evolved API code:android.opengl.GLUtils.getInternalFormat:COMMENT
Method Modifier: public      static      
Comment:/**
 * return the internal format as defined by OpenGL ES of the supplied bitmap.
 * @param bitmap
 * @return the internal format of the bitmap.
 */

Body of Frist Method:
{
    if (bitmap == null) {
        throw new NullPointerException("getInternalFormat can't be used with a null Bitmap");
    }
    if (bitmap.isRecycled()) {
        throw new IllegalArgumentException("bitmap is recycled");
    }
    int result = native_getInternalFormat(bitmap);
    if (result < 0) {
        throw new IllegalArgumentException("Unknown internalformat");
    }
    return result;
}
Body of Second Method:
{
    if (bitmap == null) {
        throw new NullPointerException("getInternalFormat can't be used with a null Bitmap");
    }
    if (bitmap.isRecycled()) {
        throw new IllegalArgumentException("bitmap is recycled");
    }
    int result = native_getInternalFormat(bitmap.getNativeInstance());
    if (result < 0) {
        throw new IllegalArgumentException("Unknown internalformat");
    }
    return result;
}
------------------------
Find a silently evolved API code:android.widget.AutoCompleteTextView.dismissDropDown:COMMENT
Method Modifier: public      
Comment:/**
 * <p>Closes the drop down if present on screen.</p>
 */

Body of Frist Method:
{
    InputMethodManager imm = InputMethodManager.peekInstance();
    if (imm != null) {
        imm.displayCompletions(this, null);
    }
    mPopup.dismiss();
    mPopupCanBeUpdated = false;
}
Body of Second Method:
{
    InputMethodManager imm = getContext().getSystemService(InputMethodManager.class);
    if (imm != null) {
        imm.displayCompletions(this, null);
    }
    mPopup.dismiss();
    mPopupCanBeUpdated = false;
}
------------------------
Find a silently evolved API code:android.net.LinkAddress.isSameAddressAs:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Determines whether this {@code LinkAddress} and the provided {@code LinkAddress}
 * represent the same address. Two {@code LinkAddresses} represent the same address
 * if they have the same IP address and prefix length, even if their properties are
 * different.
 *
 * @param other the {@code LinkAddress} to compare to.
 * @return {@code true} if both objects have the same address and prefix length, {@code false}
 * otherwise.
 * @hide
 */

Body of Frist Method:
{
    return address.equals(other.address) && prefixLength == other.prefixLength;
}
Body of Second Method:
{
    if (other == null) {
        return false;
    }
    return address.equals(other.address) && prefixLength == other.prefixLength;
}
------------------------
Find a silently evolved API code:android.database.sqlite.SQLiteConnectionPool.dump:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Dumps debugging information about this connection pool.
 *
 * @param printer The printer to receive the dump, not null.
 * @param verbose True to dump more verbose information.
 */

Body of Frist Method:
{
    Printer indentedPrinter = PrefixPrinter.create(printer, "    ");
    synchronized (mLock) {
        printer.println("Connection pool for " + mConfiguration.path + ":");
        printer.println("  Open: " + mIsOpen);
        printer.println("  Max connections: " + mMaxConnectionPoolSize);
        printer.println("  Total execution time: " + mTotalExecutionTimeCounter);
        printer.println("  Configuration: openFlags=" + mConfiguration.openFlags + ", useCompatibilityWal=" + mConfiguration.useCompatibilityWal() + ", journalMode=" + TextUtils.emptyIfNull(mConfiguration.journalMode) + ", syncMode=" + TextUtils.emptyIfNull(mConfiguration.syncMode));
        if (SQLiteCompatibilityWalFlags.areFlagsSet()) {
            printer.println("  Compatibility WAL settings: compatibility_wal_supported=" + SQLiteCompatibilityWalFlags.isCompatibilityWalSupported() + ", wal_syncmode=" + SQLiteCompatibilityWalFlags.getWALSyncMode());
        }
        if (mConfiguration.isLookasideConfigSet()) {
            printer.println("  Lookaside config: sz=" + mConfiguration.lookasideSlotSize + " cnt=" + mConfiguration.lookasideSlotCount);
        }
        if (mConfiguration.idleConnectionTimeoutMs != Long.MAX_VALUE) {
            printer.println("  Idle connection timeout: " + mConfiguration.idleConnectionTimeoutMs);
        }
        printer.println("  Available primary connection:");
        if (mAvailablePrimaryConnection != null) {
            mAvailablePrimaryConnection.dump(indentedPrinter, verbose);
        } else {
            indentedPrinter.println("<none>");
        }
        printer.println("  Available non-primary connections:");
        if (!mAvailableNonPrimaryConnections.isEmpty()) {
            final int count = mAvailableNonPrimaryConnections.size();
            for (int i = 0; i < count; i++) {
                mAvailableNonPrimaryConnections.get(i).dump(indentedPrinter, verbose);
            }
        } else {
            indentedPrinter.println("<none>");
        }
        printer.println("  Acquired connections:");
        if (!mAcquiredConnections.isEmpty()) {
            for (Map.Entry<SQLiteConnection, AcquiredConnectionStatus> entry : mAcquiredConnections.entrySet()) {
                final SQLiteConnection connection = entry.getKey();
                connection.dumpUnsafe(indentedPrinter, verbose);
                indentedPrinter.println("  Status: " + entry.getValue());
            }
        } else {
            indentedPrinter.println("<none>");
        }
        printer.println("  Connection waiters:");
        if (mConnectionWaiterQueue != null) {
            int i = 0;
            final long now = SystemClock.uptimeMillis();
            for (ConnectionWaiter waiter = mConnectionWaiterQueue; waiter != null; waiter = waiter.mNext, i++) {
                indentedPrinter.println(i + ": waited for " + ((now - waiter.mStartTime) * 0.001f) + " ms - thread=" + waiter.mThread + ", priority=" + waiter.mPriority + ", sql='" + waiter.mSql + "'");
            }
        } else {
            indentedPrinter.println("<none>");
        }
    }
}
Body of Second Method:
{
    Printer indentedPrinter = PrefixPrinter.create(printer, "    ");
    synchronized (mLock) {
        if (directories != null) {
            directories.add(new File(mConfiguration.path).getParent());
        }
        boolean isCompatibilityWalEnabled = mConfiguration.isLegacyCompatibilityWalEnabled();
        printer.println("Connection pool for " + mConfiguration.path + ":");
        printer.println("  Open: " + mIsOpen);
        printer.println("  Max connections: " + mMaxConnectionPoolSize);
        printer.println("  Total execution time: " + mTotalExecutionTimeCounter);
        printer.println("  Configuration: openFlags=" + mConfiguration.openFlags + ", isLegacyCompatibilityWalEnabled=" + isCompatibilityWalEnabled + ", journalMode=" + TextUtils.emptyIfNull(mConfiguration.journalMode) + ", syncMode=" + TextUtils.emptyIfNull(mConfiguration.syncMode));
        if (isCompatibilityWalEnabled) {
            printer.println("  Compatibility WAL enabled: wal_syncmode=" + SQLiteCompatibilityWalFlags.getWALSyncMode());
        }
        if (mConfiguration.isLookasideConfigSet()) {
            printer.println("  Lookaside config: sz=" + mConfiguration.lookasideSlotSize + " cnt=" + mConfiguration.lookasideSlotCount);
        }
        if (mConfiguration.idleConnectionTimeoutMs != Long.MAX_VALUE) {
            printer.println("  Idle connection timeout: " + mConfiguration.idleConnectionTimeoutMs);
        }
        printer.println("  Available primary connection:");
        if (mAvailablePrimaryConnection != null) {
            mAvailablePrimaryConnection.dump(indentedPrinter, verbose);
        } else {
            indentedPrinter.println("<none>");
        }
        printer.println("  Available non-primary connections:");
        if (!mAvailableNonPrimaryConnections.isEmpty()) {
            final int count = mAvailableNonPrimaryConnections.size();
            for (int i = 0; i < count; i++) {
                mAvailableNonPrimaryConnections.get(i).dump(indentedPrinter, verbose);
            }
        } else {
            indentedPrinter.println("<none>");
        }
        printer.println("  Acquired connections:");
        if (!mAcquiredConnections.isEmpty()) {
            for (Map.Entry<SQLiteConnection, AcquiredConnectionStatus> entry : mAcquiredConnections.entrySet()) {
                final SQLiteConnection connection = entry.getKey();
                connection.dumpUnsafe(indentedPrinter, verbose);
                indentedPrinter.println("  Status: " + entry.getValue());
            }
        } else {
            indentedPrinter.println("<none>");
        }
        printer.println("  Connection waiters:");
        if (mConnectionWaiterQueue != null) {
            int i = 0;
            final long now = SystemClock.uptimeMillis();
            for (ConnectionWaiter waiter = mConnectionWaiterQueue; waiter != null; waiter = waiter.mNext, i++) {
                indentedPrinter.println(i + ": waited for " + ((now - waiter.mStartTime) * 0.001f) + " ms - thread=" + waiter.mThread + ", priority=" + waiter.mPriority + ", sql='" + waiter.mSql + "'");
            }
        } else {
            indentedPrinter.println("<none>");
        }
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.rtt.RangingResult.toString:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return new StringBuilder("RangingResult: [status=").append(mStatus).append(", mac=").append(mMac).append(", peerHandle=").append(mPeerHandle == null ? "<null>" : mPeerHandle.peerId).append(", distanceMm=").append(mDistanceMm).append(", distanceStdDevMm=").append(mDistanceStdDevMm).append(", rssi=").append(mRssi).append(", numAttemptedMeasurements=").append(mNumAttemptedMeasurements).append(", numSuccessfulMeasurements=").append(mNumSuccessfulMeasurements).append(", lci=").append(mLci).append(", lcr=").append(mLcr).append(", timestamp=").append(mTimestamp).append("]").toString();
}
Body of Second Method:
{
    return new StringBuilder("RangingResult: [status=").append(mStatus).append(", mac=").append(mMac).append(", peerHandle=").append(mPeerHandle == null ? "<null>" : mPeerHandle.peerId).append(", distanceMm=").append(mDistanceMm).append(", distanceStdDevMm=").append(mDistanceStdDevMm).append(", rssi=").append(mRssi).append(", numAttemptedMeasurements=").append(mNumAttemptedMeasurements).append(", numSuccessfulMeasurements=").append(mNumSuccessfulMeasurements).append(", lci=").append(mLci).append(", lcr=").append(mLcr).append(", responderLocation=").append(mResponderLocation).append(", timestamp=").append(mTimestamp).append("]").toString();
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothPbapClient.getConnectedDevices:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the list of connected devices.
 * Currently at most one.
 *
 * @return list of connected devices
 */

Body of Frist Method:
{
    if (DBG) {
        log("getConnectedDevices()");
    }
    final IBluetoothPbapClient service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.getConnectedDevices();
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null) {
        Log.w(TAG, "Proxy not attached to service");
    }
    return new ArrayList<BluetoothDevice>();
}
Body of Second Method:
{
    if (DBG) {
        log("getConnectedDevices()");
    }
    final IBluetoothPbapClient service = getService();
    if (service != null && isEnabled()) {
        try {
            return service.getConnectedDevices();
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null) {
        Log.w(TAG, "Proxy not attached to service");
    }
    return new ArrayList<BluetoothDevice>();
}
------------------------
Find a silently evolved API code:android.database.sqlite.SQLiteCompatibilityWalFlags.init:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (TextUtils.isEmpty(flags)) {
        sInitialized = true;
        return;
    }
    KeyValueListParser parser = new KeyValueListParser(',');
    try {
        parser.setString(flags);
    } catch (IllegalArgumentException e) {
        Log.e(TAG, "Setting has invalid format: " + flags, e);
        sInitialized = true;
        return;
    }
    sCompatibilityWalSupported = parser.getBoolean("compatibility_wal_supported", SQLiteGlobal.isCompatibilityWalSupported());
    sWALSyncMode = parser.getString("wal_syncmode", SQLiteGlobal.getWALSyncMode());
    Log.i(TAG, "Read compatibility WAL flags: compatibility_wal_supported=" + sCompatibilityWalSupported + ", wal_syncmode=" + sWALSyncMode);
    sFlagsSet = true;
    sInitialized = true;
}
Body of Second Method:
{
    if (TextUtils.isEmpty(flags)) {
        sInitialized = true;
        return;
    }
    KeyValueListParser parser = new KeyValueListParser(',');
    try {
        parser.setString(flags);
    } catch (IllegalArgumentException e) {
        Log.e(TAG, "Setting has invalid format: " + flags, e);
        sInitialized = true;
        return;
    }
    sLegacyCompatibilityWalEnabled = parser.getBoolean("legacy_compatibility_wal_enabled", false);
    sWALSyncMode = parser.getString("wal_syncmode", SQLiteGlobal.getWALSyncMode());
    sTruncateSize = parser.getInt("truncate_size", -1);
    Log.i(TAG, "Read compatibility WAL flags: legacy_compatibility_wal_enabled=" + sLegacyCompatibilityWalEnabled + ", wal_syncmode=" + sWALSyncMode);
    sInitialized = true;
}
------------------------
Find a silently evolved API code:android.os.ParcelFileDescriptor.fromData:COMMENT
Method Modifier: public      static      hidden      deprecated  
Comment:/**
 * @hide Please use createPipe() or ContentProvider.openPipeHelper().
 * Gets a file descriptor for a read-only copy of the given data.
 *
 * @param data Data to copy.
 * @param name Name for the shared memory area that may back the file descriptor.
 * This is purely informative and may be {@code null}.
 * @return A ParcelFileDescriptor.
 * @throws IOException if there is an error while creating the shared memory area.
 */

Body of Frist Method:
{
    if (data == null)
        return null;
    MemoryFile file = new MemoryFile(name, data.length);
    if (data.length > 0) {
        file.writeBytes(data, 0, 0, data.length);
    }
    file.deactivate();
    FileDescriptor fd = file.getFileDescriptor();
    return fd != null ? new ParcelFileDescriptor(fd) : null;
}
Body of Second Method:
{
    if (data == null)
        return null;
    MemoryFile file = new MemoryFile(name, data.length);
    if (data.length > 0) {
        file.writeBytes(data, 0, 0, data.length);
    }
    file.deactivate();
    FileDescriptor fd = file.getFileDescriptor();
    return fd != null ? ParcelFileDescriptor.dup(fd) : null;
}
------------------------
Find a silently evolved API code:android.telephony.CellSignalStrengthGsm.toString:COMMENT
Method Modifier: public      
Comment:/**
 * @return string representation.
 */

Body of Frist Method:
{
    return "CellSignalStrengthGsm:" + " ss=" + mSignalStrength + " ber=" + mBitErrorRate + " mTa=" + mTimingAdvance;
}
Body of Second Method:
{
    return "CellSignalStrengthGsm:" + " rssi=" + mRssi + " ber=" + mBitErrorRate + " mTa=" + mTimingAdvance + " mLevel=" + mLevel;
}
------------------------
Find a silently evolved API code:android.widget.Toast.show:COMMENT
Method Modifier: public      
Comment:/**
 * Show the view for the specified duration.
 */

Body of Frist Method:
{
    if (mNextView == null) {
        throw new RuntimeException("setView must have been called");
    }
    INotificationManager service = getService();
    String pkg = mContext.getOpPackageName();
    TN tn = mTN;
    tn.mNextView = mNextView;
    try {
        service.enqueueToast(pkg, tn, mDuration);
    } catch (RemoteException e) {
    // Empty
    }
}
Body of Second Method:
{
    if (mNextView == null) {
        throw new RuntimeException("setView must have been called");
    }
    INotificationManager service = getService();
    String pkg = mContext.getOpPackageName();
    TN tn = mTN;
    tn.mNextView = mNextView;
    final int displayId = mContext.getDisplayId();
    try {
        service.enqueueToast(pkg, tn, mDuration, displayId);
    } catch (RemoteException e) {
    // Empty
    }
}
------------------------
Find a silently evolved API code:android.app.SearchManager.getAssistIntent:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Gets an intent for launching installed assistant activity, or null if not available.
 * @return The assist intent.
 *
 * @hide
 */

Body of Frist Method:
{
    try {
        Intent intent = new Intent(Intent.ACTION_ASSIST);
        if (inclContext) {
            IActivityManager am = ActivityManager.getService();
            Bundle extras = am.getAssistContextExtras(ActivityManager.ASSIST_CONTEXT_BASIC);
            if (extras != null) {
                intent.replaceExtras(extras);
            }
        }
        return intent;
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    try {
        Intent intent = new Intent(Intent.ACTION_ASSIST);
        if (inclContext) {
            IActivityTaskManager am = ActivityTaskManager.getService();
            Bundle extras = am.getAssistContextExtras(ActivityManager.ASSIST_CONTEXT_BASIC);
            if (extras != null) {
                intent.replaceExtras(extras);
            }
        }
        return intent;
    } catch (RemoteException re) {
        throw re.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothA2dpSink.setPriority:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Set priority of the profile
 *
 * <p> The device should already be paired.
 * Priority can be one of {@link #PRIORITY_ON} orgetBluetoothManager
 * {@link #PRIORITY_OFF},
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}
 * permission.
 *
 * @param device Paired bluetooth device
 * @param priority
 * @return true if priority is set, false on error
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("setPriority(" + device + ", " + priority + ")");
    final IBluetoothA2dpSink service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        if (priority != BluetoothProfile.PRIORITY_OFF && priority != BluetoothProfile.PRIORITY_ON) {
            return false;
        }
        try {
            return service.setPriority(device, priority);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("setPriority(" + device + ", " + priority + ")");
    final IBluetoothA2dpSink service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        if (priority != BluetoothProfile.PRIORITY_OFF && priority != BluetoothProfile.PRIORITY_ON) {
            return false;
        }
        try {
            return service.setPriority(device, priority);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.view.MenuInflater.MenuState.readItem:COMMENT
Method Modifier: public      
Comment:/**
 * Called when the parser is pointing to an item tag.
 */

Body of Frist Method:
{
    TypedArray a = mContext.obtainStyledAttributes(attrs, com.android.internal.R.styleable.MenuItem);
    // Inherit attributes from the group as default value
    itemId = a.getResourceId(com.android.internal.R.styleable.MenuItem_id, defaultItemId);
    final int category = a.getInt(com.android.internal.R.styleable.MenuItem_menuCategory, groupCategory);
    final int order = a.getInt(com.android.internal.R.styleable.MenuItem_orderInCategory, groupOrder);
    itemCategoryOrder = (category & Menu.CATEGORY_MASK) | (order & Menu.USER_MASK);
    itemTitle = a.getText(com.android.internal.R.styleable.MenuItem_title);
    itemTitleCondensed = a.getText(com.android.internal.R.styleable.MenuItem_titleCondensed);
    itemIconResId = a.getResourceId(com.android.internal.R.styleable.MenuItem_icon, 0);
    if (a.hasValue(com.android.internal.R.styleable.MenuItem_iconTintMode)) {
        itemIconTintMode = Drawable.parseTintMode(a.getInt(com.android.internal.R.styleable.MenuItem_iconTintMode, -1), itemIconTintMode);
    } else {
        // Reset to null so that it's not carried over to the next item
        itemIconTintMode = null;
    }
    if (a.hasValue(com.android.internal.R.styleable.MenuItem_iconTint)) {
        itemIconTintList = a.getColorStateList(com.android.internal.R.styleable.MenuItem_iconTint);
    } else {
        // Reset to null so that it's not carried over to the next item
        itemIconTintList = null;
    }
    itemAlphabeticShortcut = getShortcut(a.getString(com.android.internal.R.styleable.MenuItem_alphabeticShortcut));
    itemAlphabeticModifiers = a.getInt(com.android.internal.R.styleable.MenuItem_alphabeticModifiers, KeyEvent.META_CTRL_ON);
    itemNumericShortcut = getShortcut(a.getString(com.android.internal.R.styleable.MenuItem_numericShortcut));
    itemNumericModifiers = a.getInt(com.android.internal.R.styleable.MenuItem_numericModifiers, KeyEvent.META_CTRL_ON);
    if (a.hasValue(com.android.internal.R.styleable.MenuItem_checkable)) {
        // Item has attribute checkable, use it
        itemCheckable = a.getBoolean(com.android.internal.R.styleable.MenuItem_checkable, false) ? 1 : 0;
    } else {
        // Item does not have attribute, use the group's (group can have one more state
        // for checkable that represents the exclusive checkable)
        itemCheckable = groupCheckable;
    }
    itemChecked = a.getBoolean(com.android.internal.R.styleable.MenuItem_checked, defaultItemChecked);
    itemVisible = a.getBoolean(com.android.internal.R.styleable.MenuItem_visible, groupVisible);
    itemEnabled = a.getBoolean(com.android.internal.R.styleable.MenuItem_enabled, groupEnabled);
    itemShowAsAction = a.getInt(com.android.internal.R.styleable.MenuItem_showAsAction, -1);
    itemListenerMethodName = a.getString(com.android.internal.R.styleable.MenuItem_onClick);
    itemActionViewLayout = a.getResourceId(com.android.internal.R.styleable.MenuItem_actionLayout, 0);
    itemActionViewClassName = a.getString(com.android.internal.R.styleable.MenuItem_actionViewClass);
    itemActionProviderClassName = a.getString(com.android.internal.R.styleable.MenuItem_actionProviderClass);
    final boolean hasActionProvider = itemActionProviderClassName != null;
    if (hasActionProvider && itemActionViewLayout == 0 && itemActionViewClassName == null) {
        itemActionProvider = newInstance(itemActionProviderClassName, ACTION_PROVIDER_CONSTRUCTOR_SIGNATURE, mActionProviderConstructorArguments);
    } else {
        if (hasActionProvider) {
            Log.w(LOG_TAG, "Ignoring attribute 'actionProviderClass'." + " Action view already specified.");
        }
        itemActionProvider = null;
    }
    itemContentDescription = a.getText(com.android.internal.R.styleable.MenuItem_contentDescription);
    itemTooltipText = a.getText(com.android.internal.R.styleable.MenuItem_tooltipText);
    a.recycle();
    itemAdded = false;
}
Body of Second Method:
{
    TypedArray a = mContext.obtainStyledAttributes(attrs, com.android.internal.R.styleable.MenuItem);
    // Inherit attributes from the group as default value
    itemId = a.getResourceId(com.android.internal.R.styleable.MenuItem_id, defaultItemId);
    final int category = a.getInt(com.android.internal.R.styleable.MenuItem_menuCategory, groupCategory);
    final int order = a.getInt(com.android.internal.R.styleable.MenuItem_orderInCategory, groupOrder);
    itemCategoryOrder = (category & Menu.CATEGORY_MASK) | (order & Menu.USER_MASK);
    itemTitle = a.getText(com.android.internal.R.styleable.MenuItem_title);
    itemTitleCondensed = a.getText(com.android.internal.R.styleable.MenuItem_titleCondensed);
    itemIconResId = a.getResourceId(com.android.internal.R.styleable.MenuItem_icon, 0);
    if (a.hasValue(com.android.internal.R.styleable.MenuItem_iconTintMode)) {
        mItemIconBlendMode = Drawable.parseBlendMode(a.getInt(com.android.internal.R.styleable.MenuItem_iconTintMode, -1), mItemIconBlendMode);
    } else {
        // Reset to null so that it's not carried over to the next item
        mItemIconBlendMode = null;
    }
    if (a.hasValue(com.android.internal.R.styleable.MenuItem_iconTint)) {
        itemIconTintList = a.getColorStateList(com.android.internal.R.styleable.MenuItem_iconTint);
    } else {
        // Reset to null so that it's not carried over to the next item
        itemIconTintList = null;
    }
    itemAlphabeticShortcut = getShortcut(a.getString(com.android.internal.R.styleable.MenuItem_alphabeticShortcut));
    itemAlphabeticModifiers = a.getInt(com.android.internal.R.styleable.MenuItem_alphabeticModifiers, KeyEvent.META_CTRL_ON);
    itemNumericShortcut = getShortcut(a.getString(com.android.internal.R.styleable.MenuItem_numericShortcut));
    itemNumericModifiers = a.getInt(com.android.internal.R.styleable.MenuItem_numericModifiers, KeyEvent.META_CTRL_ON);
    if (a.hasValue(com.android.internal.R.styleable.MenuItem_checkable)) {
        // Item has attribute checkable, use it
        itemCheckable = a.getBoolean(com.android.internal.R.styleable.MenuItem_checkable, false) ? 1 : 0;
    } else {
        // Item does not have attribute, use the group's (group can have one more state
        // for checkable that represents the exclusive checkable)
        itemCheckable = groupCheckable;
    }
    itemChecked = a.getBoolean(com.android.internal.R.styleable.MenuItem_checked, defaultItemChecked);
    itemVisible = a.getBoolean(com.android.internal.R.styleable.MenuItem_visible, groupVisible);
    itemEnabled = a.getBoolean(com.android.internal.R.styleable.MenuItem_enabled, groupEnabled);
    itemShowAsAction = a.getInt(com.android.internal.R.styleable.MenuItem_showAsAction, -1);
    itemListenerMethodName = a.getString(com.android.internal.R.styleable.MenuItem_onClick);
    itemActionViewLayout = a.getResourceId(com.android.internal.R.styleable.MenuItem_actionLayout, 0);
    itemActionViewClassName = a.getString(com.android.internal.R.styleable.MenuItem_actionViewClass);
    itemActionProviderClassName = a.getString(com.android.internal.R.styleable.MenuItem_actionProviderClass);
    final boolean hasActionProvider = itemActionProviderClassName != null;
    if (hasActionProvider && itemActionViewLayout == 0 && itemActionViewClassName == null) {
        itemActionProvider = newInstance(itemActionProviderClassName, ACTION_PROVIDER_CONSTRUCTOR_SIGNATURE, mActionProviderConstructorArguments);
    } else {
        if (hasActionProvider) {
            Log.w(LOG_TAG, "Ignoring attribute 'actionProviderClass'." + " Action view already specified.");
        }
        itemActionProvider = null;
    }
    itemContentDescription = a.getText(com.android.internal.R.styleable.MenuItem_contentDescription);
    itemTooltipText = a.getText(com.android.internal.R.styleable.MenuItem_tooltipText);
    a.recycle();
    itemAdded = false;
}
------------------------
Find a silently evolved API code:android.database.sqlite.SQLiteOpenHelper.setWriteAheadLoggingEnabled:COMMENT
Method Modifier: public      
Comment:/**
 * Enables or disables the use of write-ahead logging for the database.
 *
 * Write-ahead logging cannot be used with read-only databases so the value of
 * this flag is ignored if the database is opened read-only.
 *
 * @param enabled True if write-ahead logging should be enabled, false if it
 * should be disabled.
 *
 * @see SQLiteDatabase#enableWriteAheadLogging()
 */

Body of Frist Method:
{
    synchronized (this) {
        if (mOpenParamsBuilder.isWriteAheadLoggingEnabled() != enabled) {
            if (mDatabase != null && mDatabase.isOpen() && !mDatabase.isReadOnly()) {
                if (enabled) {
                    mDatabase.enableWriteAheadLogging();
                } else {
                    mDatabase.disableWriteAheadLogging();
                }
            }
            mOpenParamsBuilder.setWriteAheadLoggingEnabled(enabled);
        }
        // Compatibility WAL is disabled if an app disables or enables WAL
        mOpenParamsBuilder.addOpenFlags(SQLiteDatabase.DISABLE_COMPATIBILITY_WAL);
    }
}
Body of Second Method:
{
    synchronized (this) {
        if (mOpenParamsBuilder.isWriteAheadLoggingEnabled() != enabled) {
            if (mDatabase != null && mDatabase.isOpen() && !mDatabase.isReadOnly()) {
                if (enabled) {
                    mDatabase.enableWriteAheadLogging();
                } else {
                    mDatabase.disableWriteAheadLogging();
                }
            }
            mOpenParamsBuilder.setWriteAheadLoggingEnabled(enabled);
        }
        // Compatibility WAL is disabled if an app disables or enables WAL
        mOpenParamsBuilder.removeOpenFlags(SQLiteDatabase.ENABLE_LEGACY_COMPATIBILITY_WAL);
    }
}
------------------------
Find a silently evolved API code:android.hardware.display.BrightnessChangeEvent.Builder.build:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Builds a BrightnessChangeEvent
 */

Body of Frist Method:
{
    return new BrightnessChangeEvent(mBrightness, mTimeStamp, mPackageName, mUserId, mLuxValues, mLuxTimestamps, mBatteryLevel, mPowerBrightnessFactor, mNightMode, mColorTemperature, mLastBrightness, mIsDefaultBrightnessConfig, mIsUserSetBrightness);
}
Body of Second Method:
{
    return new BrightnessChangeEvent(mBrightness, mTimeStamp, mPackageName, mUserId, mLuxValues, mLuxTimestamps, mBatteryLevel, mPowerBrightnessFactor, mNightMode, mColorTemperature, mLastBrightness, mIsDefaultBrightnessConfig, mIsUserSetBrightness, mColorValueBuckets, mColorSampleDuration);
}
------------------------
Find a silently evolved API code:android.app.Instrumentation.sendPointerSync:COMMENT
Method Modifier: public      
Comment:/**
 * Dispatch a pointer event. Finished at some point after the recipient has
 * returned from its event processing, though it may <em>not</em> have
 * completely finished reacting from the event -- for example, if it needs
 * to update its display as a result, it may still be in the process of
 * doing that.
 *
 * @param event A motion event describing the pointer action.  (As noted in
 * {@link MotionEvent#obtain(long, long, int, float, float, int)}, be sure to use
 * {@link SystemClock#uptimeMillis()} as the timebase.
 */

Body of Frist Method:
{
    validateNotAppThread();
    if ((event.getSource() & InputDevice.SOURCE_CLASS_POINTER) == 0) {
        event.setSource(InputDevice.SOURCE_TOUCHSCREEN);
    }
    InputManager.getInstance().injectInputEvent(event, InputManager.INJECT_INPUT_EVENT_MODE_WAIT_FOR_FINISH);
}
Body of Second Method:
{
    validateNotAppThread();
    if ((event.getSource() & InputDevice.SOURCE_CLASS_POINTER) == 0) {
        event.setSource(InputDevice.SOURCE_TOUCHSCREEN);
    }
    try {
        WindowManagerGlobal.getWindowManagerService().injectInputAfterTransactionsApplied(event, InputManager.INJECT_INPUT_EVENT_MODE_WAIT_FOR_FINISH);
    } catch (RemoteException e) {
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothGatt.executeReliableWrite:COMMENT
Method Modifier: public      
Comment:/**
 * Executes a reliable write transaction for a given remote device.
 *
 * <p>This function will commit all queued up characteristic write
 * operations for a given remote device.
 *
 * <p>A {@link BluetoothGattCallback#onReliableWriteCompleted} callback is
 * invoked to indicate whether the transaction has been executed correctly.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @return true, if the request to execute the transaction has been sent
 */

Body of Frist Method:
{
    if (VDBG)
        Log.d(TAG, "executeReliableWrite() - device: " + mDevice.getAddress());
    if (mService == null || mClientIf == 0)
        return false;
    synchronized (mDeviceBusy) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.endReliableWrite(mClientIf, mDevice.getAddress(), true);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}
Body of Second Method:
{
    if (VDBG)
        Log.d(TAG, "executeReliableWrite() - device: " + mDevice.getAddress());
    if (mService == null || mClientIf == 0)
        return false;
    synchronized (mDeviceBusyLock) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.endReliableWrite(mClientIf, mDevice.getAddress(), true);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}
------------------------
Find a silently evolved API code:android.net.http.HttpResponseCache.maxSize:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the maximum number of bytes that this cache should use to store
 * its data.
 */

Body of Frist Method:
{
    return delegate.maxSize();
}
Body of Second Method:
{
    return mDelegate.getMaxSize();
}
------------------------
Find a silently evolved API code:android.telephony.CellSignalStrengthLte.copyFrom:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    mSignalStrength = s.mSignalStrength;
    mRsrp = s.mRsrp;
    mRsrq = s.mRsrq;
    mRssnr = s.mRssnr;
    mCqi = s.mCqi;
    mTimingAdvance = s.mTimingAdvance;
}
Body of Second Method:
{
    mSignalStrength = s.mSignalStrength;
    mRssi = s.mRssi;
    mRsrp = s.mRsrp;
    mRsrq = s.mRsrq;
    mRssnr = s.mRssnr;
    mCqi = s.mCqi;
    mTimingAdvance = s.mTimingAdvance;
    mLevel = s.mLevel;
}
------------------------
Find a silently evolved API code:android.media.AudioPlaybackConfiguration.anonymizedCopy:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 * Creates a copy of the playback configuration that is stripped of any data enabling
 * identification of which application it is associated with ("anonymized").
 * @param toSanitize
 */

Body of Frist Method:
{
    final AudioPlaybackConfiguration anonymCopy = new AudioPlaybackConfiguration(in.mPlayerIId);
    anonymCopy.mPlayerState = in.mPlayerState;
    // do not reuse the full attributes: only usage, content type and public flags are allowed
    anonymCopy.mPlayerAttr = new AudioAttributes.Builder().setUsage(in.mPlayerAttr.getUsage()).setContentType(in.mPlayerAttr.getContentType()).setFlags(in.mPlayerAttr.getFlags()).build();
    // anonymized data
    anonymCopy.mPlayerType = PLAYER_TYPE_UNKNOWN;
    anonymCopy.mClientUid = PLAYER_UPID_INVALID;
    anonymCopy.mClientPid = PLAYER_UPID_INVALID;
    anonymCopy.mIPlayerShell = null;
    return anonymCopy;
}
Body of Second Method:
{
    final AudioPlaybackConfiguration anonymCopy = new AudioPlaybackConfiguration(in.mPlayerIId);
    anonymCopy.mPlayerState = in.mPlayerState;
    // do not reuse the full attributes: only usage, content type and public flags are allowed
    anonymCopy.mPlayerAttr = new AudioAttributes.Builder().setUsage(in.mPlayerAttr.getUsage()).setContentType(in.mPlayerAttr.getContentType()).setFlags(in.mPlayerAttr.getFlags()).setAllowedCapturePolicy(in.mPlayerAttr.getAllowedCapturePolicy() == ALLOW_CAPTURE_BY_ALL ? ALLOW_CAPTURE_BY_ALL : ALLOW_CAPTURE_BY_NONE).build();
    // anonymized data
    anonymCopy.mPlayerType = PLAYER_TYPE_UNKNOWN;
    anonymCopy.mClientUid = PLAYER_UPID_INVALID;
    anonymCopy.mClientPid = PLAYER_UPID_INVALID;
    anonymCopy.mIPlayerShell = null;
    return anonymCopy;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothMap.close:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Close the connection to the backing service.
 * Other public functions of BluetoothMap will return default error
 * results once close() has been called. Multiple invocations of close()
 * are ok.
 */

Body of Frist Method:
{
    IBluetoothManager mgr = mAdapter.getBluetoothManager();
    if (mgr != null) {
        try {
            mgr.unregisterStateChangeCallback(mBluetoothStateChangeCallback);
        } catch (Exception e) {
            Log.e(TAG, "", e);
        }
    }
    synchronized (mConnection) {
        if (mService != null) {
            try {
                mService = null;
                mContext.unbindService(mConnection);
            } catch (Exception re) {
                Log.e(TAG, "", re);
            }
        }
    }
    mServiceListener = null;
}
Body of Second Method:
{
    mProfileConnector.disconnect();
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiConfiguration.getWifiConfigFromBackup:COMMENT
<android.net.wifi.WifiConfiguration: WifiConfiguration getWifiConfigFromBackup(DataInputStream)>
public      static      hidden      ->public      static      hidden      deprecated  
Method Modifier: public      static      hidden      deprecated  
Method Modifier: Yes         Yes         Yes         No          
Method Updated:  Yes         Yes         Yes         Yes         
Comment:/**
 * Deserializes a byte array into the WiFiConfiguration Object
 * @hide
 */

Body of Frist Method:
{
    WifiConfiguration config = new WifiConfiguration();
    int version = in.readInt();
    if (version < 1 || version > BACKUP_VERSION) {
        throw new BackupUtils.BadVersionException("Unknown Backup Serialization Version");
    }
    // Version 1 is a bad dataset.
    if (version == 1)
        return null;
    config.SSID = BackupUtils.readString(in);
    config.apBand = in.readInt();
    config.apChannel = in.readInt();
    config.preSharedKey = BackupUtils.readString(in);
    config.allowedKeyManagement.set(in.readInt());
    return config;
}
Body of Second Method:
{
    WifiConfiguration config = new WifiConfiguration();
    int version = in.readInt();
    if (version < 1 || version > BACKUP_VERSION) {
        throw new BackupUtils.BadVersionException("Unknown Backup Serialization Version");
    }
    // Version 1 is a bad dataset.
    if (version == 1)
        return null;
    config.SSID = BackupUtils.readString(in);
    config.apBand = in.readInt();
    config.apChannel = in.readInt();
    config.preSharedKey = BackupUtils.readString(in);
    config.allowedKeyManagement.set(in.readInt());
    if (version >= 3) {
        config.hiddenSSID = in.readBoolean();
    }
    return config;
}
------------------------
Find a silently evolved API code:android.telephony.CellSignalStrengthCdma.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Implement the Parcelable interface
 */

Body of Frist Method:
{
    if (DBG)
        log("writeToParcel(Parcel, int): " + toString());
    dest.writeInt(mCdmaDbm);
    dest.writeInt(mCdmaEcio);
    dest.writeInt(mEvdoDbm);
    dest.writeInt(mEvdoEcio);
    dest.writeInt(mEvdoSnr);
}
Body of Second Method:
{
    if (DBG)
        log("writeToParcel(Parcel, int): " + toString());
    dest.writeInt(mCdmaDbm);
    dest.writeInt(mCdmaEcio);
    dest.writeInt(mEvdoDbm);
    dest.writeInt(mEvdoEcio);
    dest.writeInt(mEvdoSnr);
    dest.writeInt(mLevel);
}
------------------------
Find a silently evolved API code:android.telephony.CellSignalStrengthGsm.copyFrom:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    mSignalStrength = s.mSignalStrength;
    mBitErrorRate = s.mBitErrorRate;
    mTimingAdvance = s.mTimingAdvance;
}
Body of Second Method:
{
    mRssi = s.mRssi;
    mBitErrorRate = s.mBitErrorRate;
    mTimingAdvance = s.mTimingAdvance;
    mLevel = s.mLevel;
}
------------------------
Find a silently evolved API code:android.telephony.CellSignalStrengthLte.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Implement the Parcelable interface
 */

Body of Frist Method:
{
    if (DBG)
        log("writeToParcel(Parcel, int): " + toString());
    dest.writeInt(mSignalStrength);
    // Need to multiply rsrp and rsrq by -1
    // to ensure consistency when reading values written here
    // unless the values are invalid
    dest.writeInt(mRsrp * (mRsrp != Integer.MAX_VALUE ? -1 : 1));
    dest.writeInt(mRsrq * (mRsrq != Integer.MAX_VALUE ? -1 : 1));
    dest.writeInt(mRssnr);
    dest.writeInt(mCqi);
    dest.writeInt(mTimingAdvance);
}
Body of Second Method:
{
    if (DBG)
        log("writeToParcel(Parcel, int): " + toString());
    dest.writeInt(mRssi);
    // Need to multiply rsrp and rsrq by -1
    // to ensure consistency when reading values written here
    // unless the values are invalid
    dest.writeInt(mRsrp);
    dest.writeInt(mRsrq);
    dest.writeInt(mRssnr);
    dest.writeInt(mCqi);
    dest.writeInt(mTimingAdvance);
    dest.writeInt(mLevel);
}
------------------------
Find a silently evolved API code:android.app.backup.BackupManager.isAppEligibleForBackup:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Ask the framework whether this app is eligible for backup.
 *
 * @param packageName The name of the package.
 * @return Whether this app is eligible for backup.
 *
 * @hide
 */

Body of Frist Method:
{
    checkServiceBinder();
    if (sService != null) {
        try {
            return sService.isAppEligibleForBackup(packageName);
        } catch (RemoteException e) {
            Log.e(TAG, "isAppEligibleForBackup(pkg) couldn't connect");
        }
    }
    return false;
}
Body of Second Method:
{
    checkServiceBinder();
    if (sService != null) {
        try {
            return sService.isAppEligibleForBackupForUser(mContext.getUserId(), packageName);
        } catch (RemoteException e) {
            Log.e(TAG, "isAppEligibleForBackup(pkg) couldn't connect");
        }
    }
    return false;
}
------------------------
Find a silently evolved API code:android.telephony.CarrierConfigManager.getConfigForSubId:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the configuration values for a particular subscription, which is associated with a
 * specific SIM card. If an invalid subId is used, the returned config will contain default
 * values. After using this method to get the configuration bundle,
 * {@link #isConfigForIdentifiedCarrier(PersistableBundle)} should be called to confirm whether
 * any carrier specific configuration has been applied.
 *
 * <p>Requires Permission:
 * {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}
 *
 * @param subId the subscription ID, normally obtained from {@link SubscriptionManager}.
 * @return A {@link PersistableBundle} containing the config for the given subId, or default
 * values for an invalid subId.
 */

Body of Frist Method:
{
    try {
        ICarrierConfigLoader loader = getICarrierConfigLoader();
        if (loader == null) {
            Rlog.w(TAG, "Error getting config for subId " + subId + " ICarrierConfigLoader is null");
            return null;
        }
        return loader.getConfigForSubId(subId);
    } catch (RemoteException ex) {
        Rlog.e(TAG, "Error getting config for subId " + subId + ": " + ex.toString());
    }
    return null;
}
Body of Second Method:
{
    try {
        ICarrierConfigLoader loader = getICarrierConfigLoader();
        if (loader == null) {
            Rlog.w(TAG, "Error getting config for subId " + subId + " ICarrierConfigLoader is null");
            return null;
        }
        return loader.getConfigForSubId(subId, mContext.getOpPackageName());
    } catch (RemoteException ex) {
        Rlog.e(TAG, "Error getting config for subId " + subId + ": " + ex.toString());
    }
    return null;
}
------------------------
Find a silently evolved API code:android.content.Context.isAutofillCompatibilityEnabled:COMMENT
<android.content.Context: boolean isAutofillCompatibilityEnabled()>
public      hidden      ->public      final       hidden      
Method Modifier: public      final       hidden      
Method Modifier: Yes         No          Yes         
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return false;
}
Body of Second Method:
{
    final AutofillOptions options = getAutofillOptions();
    return options != null && options.compatModeEnabled;
}
------------------------
Find a silently evolved API code:android.telephony.ims.compat.feature.ImsFeature.notifyFeatureState:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Internal method called by ImsFeature when setFeatureState has changed.
 * @param state
 */

Body of Frist Method:
{
    synchronized (mStatusCallbacks) {
        for (Iterator<IImsFeatureStatusCallback> iter = mStatusCallbacks.iterator(); iter.hasNext(); ) {
            IImsFeatureStatusCallback callback = iter.next();
            try {
                Log.i(LOG_TAG, "notifying ImsFeatureState=" + state);
                callback.notifyImsFeatureStatus(state);
            } catch (RemoteException e) {
                // remove if the callback is no longer alive.
                iter.remove();
                Log.w(LOG_TAG, "Couldn't notify feature state: " + e.getMessage());
            }
        }
    }
    sendImsServiceIntent(state);
}
Body of Second Method:
{
    synchronized (mStatusCallbacks) {
        for (Iterator<IImsFeatureStatusCallback> iter = mStatusCallbacks.iterator(); iter.hasNext(); ) {
            IImsFeatureStatusCallback callback = iter.next();
            try {
                Log.i(LOG_TAG, "notifying ImsFeatureState=" + state);
                callback.notifyImsFeatureStatus(state);
            } catch (RemoteException e) {
                // remove if the callback is no longer alive.
                iter.remove();
                Log.w(LOG_TAG, "Couldn't notify feature state: " + e.getMessage());
            }
        }
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiConfiguration.getKeyIdForCredentials:COMMENT
<android.net.wifi.WifiConfiguration: String getKeyIdForCredentials(WifiConfiguration)>
public      hidden      ->public      hidden      deprecated  
Method Modifier: public      hidden      deprecated  
Method Modifier: Yes         Yes         No          
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * Get an identifier for associating credentials with this config
 * @param current configuration contains values for additional fields
 * that are not part of this configuration. Used
 * when a config with some fields is passed by an application.
 * @throws IllegalStateException if config is invalid for key id generation
 * @hide
 */

Body of Frist Method:
{
    String keyMgmt = null;
    try {
        // Get current config details for fields that are not initialized
        if (TextUtils.isEmpty(SSID))
            SSID = current.SSID;
        if (allowedKeyManagement.cardinality() == 0) {
            allowedKeyManagement = current.allowedKeyManagement;
        }
        if (allowedKeyManagement.get(KeyMgmt.WPA_EAP)) {
            keyMgmt = KeyMgmt.strings[KeyMgmt.WPA_EAP];
        }
        if (allowedKeyManagement.get(KeyMgmt.OSEN)) {
            keyMgmt = KeyMgmt.strings[KeyMgmt.OSEN];
        }
        if (allowedKeyManagement.get(KeyMgmt.IEEE8021X)) {
            keyMgmt += KeyMgmt.strings[KeyMgmt.IEEE8021X];
        }
        if (TextUtils.isEmpty(keyMgmt)) {
            throw new IllegalStateException("Not an EAP network");
        }
        return trimStringForKeyId(SSID) + "_" + keyMgmt + "_" + trimStringForKeyId(enterpriseConfig.getKeyId(current != null ? current.enterpriseConfig : null));
    } catch (NullPointerException e) {
        throw new IllegalStateException("Invalid config details");
    }
}
Body of Second Method:
{
    String keyMgmt = "";
    try {
        // Get current config details for fields that are not initialized
        if (TextUtils.isEmpty(SSID))
            SSID = current.SSID;
        if (allowedKeyManagement.cardinality() == 0) {
            allowedKeyManagement = current.allowedKeyManagement;
        }
        if (allowedKeyManagement.get(KeyMgmt.WPA_EAP)) {
            keyMgmt += KeyMgmt.strings[KeyMgmt.WPA_EAP];
        }
        if (allowedKeyManagement.get(KeyMgmt.OSEN)) {
            keyMgmt += KeyMgmt.strings[KeyMgmt.OSEN];
        }
        if (allowedKeyManagement.get(KeyMgmt.IEEE8021X)) {
            keyMgmt += KeyMgmt.strings[KeyMgmt.IEEE8021X];
        }
        if (allowedKeyManagement.get(KeyMgmt.SUITE_B_192)) {
            keyMgmt += KeyMgmt.strings[KeyMgmt.SUITE_B_192];
        }
        if (TextUtils.isEmpty(keyMgmt)) {
            throw new IllegalStateException("Not an EAP network");
        }
        return trimStringForKeyId(SSID) + "_" + keyMgmt + "_" + trimStringForKeyId(enterpriseConfig.getKeyId(current != null ? current.enterpriseConfig : null));
    } catch (NullPointerException e) {
        throw new IllegalStateException("Invalid config details");
    }
}
------------------------
Find a silently evolved API code:android.app.WallpaperInfo.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Used to package this object into a {@link Parcel}.
 *
 * @param dest The {@link Parcel} to be written.
 * @param flags The flags used for parceling.
 */

Body of Frist Method:
{
    dest.writeString(mSettingsActivityName);
    dest.writeInt(mThumbnailResource);
    dest.writeInt(mAuthorResource);
    dest.writeInt(mDescriptionResource);
    dest.writeInt(mContextUriResource);
    dest.writeInt(mContextDescriptionResource);
    dest.writeInt(mShowMetadataInPreview ? 1 : 0);
    dest.writeInt(mSupportsAmbientMode ? 1 : 0);
    mService.writeToParcel(dest, flags);
}
Body of Second Method:
{
    dest.writeString(mSettingsActivityName);
    dest.writeInt(mThumbnailResource);
    dest.writeInt(mAuthorResource);
    dest.writeInt(mDescriptionResource);
    dest.writeInt(mContextUriResource);
    dest.writeInt(mContextDescriptionResource);
    dest.writeInt(mShowMetadataInPreview ? 1 : 0);
    dest.writeInt(mSupportsAmbientMode ? 1 : 0);
    dest.writeString(mSettingsSliceUri);
    dest.writeInt(mSupportMultipleDisplays ? 1 : 0);
    mService.writeToParcel(dest, flags);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothPan.connect:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Initiate connection to a profile of the remote bluetooth device.
 *
 * <p> This API returns false in scenarios like the profile on the
 * device is already connected or Bluetooth is not turned on.
 * When this API returns true, it is guaranteed that
 * connection state intent for the profile will be broadcasted with
 * the state. Users can get the connection state of the profile
 * from this intent.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}
 * permission.
 *
 * @param device Remote Bluetooth Device
 * @return false on immediate error, true otherwise
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("connect(" + device + ")");
    final IBluetoothPan service = mPanService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.connect(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("connect(" + device + ")");
    final IBluetoothPan service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.connect(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.getConnectedDevices:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Return the list of connected remote devices
 *
 * @return list of connected devices; empty list if nothing is connected.
 */

Body of Frist Method:
{
    if (VDBG)
        log("getConnectedDevices()");
    final IBluetoothHeadsetClient service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.getConnectedDevices();
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
Body of Second Method:
{
    if (VDBG)
        log("getConnectedDevices()");
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled()) {
        try {
            return service.getConnectedDevices();
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
------------------------
Find a silently evolved API code:android.os.ParcelFileDescriptor.createReliablePipe:COMMENT
Method Modifier: public      static      
Comment:/**
 * Create two ParcelFileDescriptors structured as a data pipe. The first
 * ParcelFileDescriptor in the returned array is the read side; the second
 * is the write side.
 * <p>
 * The write end has the ability to deliver an error message through
 * {@link #closeWithError(String)} which can be handled by the read end
 * calling {@link #checkError()}, usually after detecting an EOF.
 * This can also be used to detect remote crashes.
 */

Body of Frist Method:
{
    try {
        final FileDescriptor[] comm = createCommSocketPair();
        final FileDescriptor[] fds = Os.pipe();
        return new ParcelFileDescriptor[] { new ParcelFileDescriptor(fds[0], comm[0]), new ParcelFileDescriptor(fds[1], comm[1]) };
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
}
Body of Second Method:
{
    try {
        final FileDescriptor[] comm = createCommSocketPair();
        final FileDescriptor[] fds = Os.pipe2(ifAtLeastQ(O_CLOEXEC));
        return new ParcelFileDescriptor[] { new ParcelFileDescriptor(fds[0], comm[0]), new ParcelFileDescriptor(fds[1], comm[1]) };
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothSap.disconnect:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Initiate disconnect.
 *
 * @param device Remote Bluetooth Device
 * @return false on error, true otherwise
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("disconnect(" + device + ")");
    final IBluetoothSap service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.disconnect(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("disconnect(" + device + ")");
    final IBluetoothSap service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.disconnect(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.transition.Transition.createAnimators:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * This method, essentially a wrapper around all calls to createAnimator for all
 * possible target views, is called with the entire set of start/end
 * values. The implementation in Transition iterates through these lists
 * and calls {@link #createAnimator(ViewGroup, TransitionValues, TransitionValues)}
 * with each set of start/end values on this transition. The
 * TransitionSet subclass overrides this method and delegates it to
 * each of its children in succession.
 *
 * @hide
 */

Body of Frist Method:
{
    if (DBG) {
        Log.d(LOG_TAG, "createAnimators() for " + this);
    }
    ArrayMap<Animator, AnimationInfo> runningAnimators = getRunningAnimators();
    long minStartDelay = Long.MAX_VALUE;
    int minAnimator = mAnimators.size();
    SparseLongArray startDelays = new SparseLongArray();
    int startValuesListCount = startValuesList.size();
    for (int i = 0; i < startValuesListCount; ++i) {
        TransitionValues start = startValuesList.get(i);
        TransitionValues end = endValuesList.get(i);
        if (start != null && !start.targetedTransitions.contains(this)) {
            start = null;
        }
        if (end != null && !end.targetedTransitions.contains(this)) {
            end = null;
        }
        if (start == null && end == null) {
            continue;
        }
        // Only bother trying to animate with values that differ between start/end
        boolean isChanged = start == null || end == null || isTransitionRequired(start, end);
        if (isChanged) {
            if (DBG) {
                View view = (end != null) ? end.view : start.view;
                Log.d(LOG_TAG, "  differing start/end values for view " + view);
                if (start == null || end == null) {
                    Log.d(LOG_TAG, "    " + ((start == null) ? "start null, end non-null" : "start non-null, end null"));
                } else {
                    for (String key : start.values.keySet()) {
                        Object startValue = start.values.get(key);
                        Object endValue = end.values.get(key);
                        if (startValue != endValue && !startValue.equals(endValue)) {
                            Log.d(LOG_TAG, "    " + key + ": start(" + startValue + "), end(" + endValue + ")");
                        }
                    }
                }
            }
            // TODO: what to do about targetIds and itemIds?
            Animator animator = createAnimator(sceneRoot, start, end);
            if (animator != null) {
                // Save animation info for future cancellation purposes
                View view = null;
                TransitionValues infoValues = null;
                if (end != null) {
                    view = end.view;
                    String[] properties = getTransitionProperties();
                    if (view != null && properties != null && properties.length > 0) {
                        infoValues = new TransitionValues();
                        infoValues.view = view;
                        TransitionValues newValues = endValues.viewValues.get(view);
                        if (newValues != null) {
                            for (int j = 0; j < properties.length; ++j) {
                                infoValues.values.put(properties[j], newValues.values.get(properties[j]));
                            }
                        }
                        int numExistingAnims = runningAnimators.size();
                        for (int j = 0; j < numExistingAnims; ++j) {
                            Animator anim = runningAnimators.keyAt(j);
                            AnimationInfo info = runningAnimators.get(anim);
                            if (info.values != null && info.view == view && ((info.name == null && getName() == null) || info.name.equals(getName()))) {
                                if (info.values.equals(infoValues)) {
                                    // Favor the old animator
                                    animator = null;
                                    break;
                                }
                            }
                        }
                    }
                } else {
                    view = (start != null) ? start.view : null;
                }
                if (animator != null) {
                    if (mPropagation != null) {
                        long delay = mPropagation.getStartDelay(sceneRoot, this, start, end);
                        startDelays.put(mAnimators.size(), delay);
                        minStartDelay = Math.min(delay, minStartDelay);
                    }
                    AnimationInfo info = new AnimationInfo(view, getName(), this, sceneRoot.getWindowId(), infoValues);
                    runningAnimators.put(animator, info);
                    mAnimators.add(animator);
                }
            }
        }
    }
    if (startDelays.size() != 0) {
        for (int i = 0; i < startDelays.size(); i++) {
            int index = startDelays.keyAt(i);
            Animator animator = mAnimators.get(index);
            long delay = startDelays.valueAt(i) - minStartDelay + animator.getStartDelay();
            animator.setStartDelay(delay);
        }
    }
}
Body of Second Method:
{
    if (DBG) {
        Log.d(LOG_TAG, "createAnimators() for " + this);
    }
    ArrayMap<Animator, AnimationInfo> runningAnimators = getRunningAnimators();
    long minStartDelay = Long.MAX_VALUE;
    int minAnimator = mAnimators.size();
    SparseLongArray startDelays = new SparseLongArray();
    int startValuesListCount = startValuesList.size();
    for (int i = 0; i < startValuesListCount; ++i) {
        TransitionValues start = startValuesList.get(i);
        TransitionValues end = endValuesList.get(i);
        if (start != null && !start.targetedTransitions.contains(this)) {
            start = null;
        }
        if (end != null && !end.targetedTransitions.contains(this)) {
            end = null;
        }
        if (start == null && end == null) {
            continue;
        }
        // Only bother trying to animate with values that differ between start/end
        boolean isChanged = start == null || end == null || isTransitionRequired(start, end);
        if (isChanged) {
            if (DBG) {
                View view = (end != null) ? end.view : start.view;
                Log.d(LOG_TAG, "  differing start/end values for view " + view);
                if (start == null || end == null) {
                    Log.d(LOG_TAG, "    " + ((start == null) ? "start null, end non-null" : "start non-null, end null"));
                } else {
                    for (String key : start.values.keySet()) {
                        Object startValue = start.values.get(key);
                        Object endValue = end.values.get(key);
                        if (startValue != endValue && !startValue.equals(endValue)) {
                            Log.d(LOG_TAG, "    " + key + ": start(" + startValue + "), end(" + endValue + ")");
                        }
                    }
                }
            }
            // TODO: what to do about targetIds and itemIds?
            Animator animator = createAnimator(sceneRoot, start, end);
            if (animator != null) {
                // Save animation info for future cancellation purposes
                View view = null;
                TransitionValues infoValues = null;
                if (end != null) {
                    view = end.view;
                    String[] properties = getTransitionProperties();
                    if (properties != null && properties.length > 0) {
                        infoValues = new TransitionValues(view);
                        TransitionValues newValues = endValues.viewValues.get(view);
                        if (newValues != null) {
                            for (int j = 0; j < properties.length; ++j) {
                                infoValues.values.put(properties[j], newValues.values.get(properties[j]));
                            }
                        }
                        int numExistingAnims = runningAnimators.size();
                        for (int j = 0; j < numExistingAnims; ++j) {
                            Animator anim = runningAnimators.keyAt(j);
                            AnimationInfo info = runningAnimators.get(anim);
                            if (info.values != null && info.view == view && ((info.name == null && getName() == null) || info.name.equals(getName()))) {
                                if (info.values.equals(infoValues)) {
                                    // Favor the old animator
                                    animator = null;
                                    break;
                                }
                            }
                        }
                    }
                } else {
                    view = (start != null) ? start.view : null;
                }
                if (animator != null) {
                    if (mPropagation != null) {
                        long delay = mPropagation.getStartDelay(sceneRoot, this, start, end);
                        startDelays.put(mAnimators.size(), delay);
                        minStartDelay = Math.min(delay, minStartDelay);
                    }
                    AnimationInfo info = new AnimationInfo(view, getName(), this, sceneRoot.getWindowId(), infoValues);
                    runningAnimators.put(animator, info);
                    mAnimators.add(animator);
                }
            }
        }
    }
    if (startDelays.size() != 0) {
        for (int i = 0; i < startDelays.size(); i++) {
            int index = startDelays.keyAt(i);
            Animator animator = mAnimators.get(index);
            long delay = startDelays.valueAt(i) - minStartDelay + animator.getStartDelay();
            animator.setStartDelay(delay);
        }
    }
}
------------------------
Find a silently evolved API code:android.content.pm.PackageManager.installStatusToPublicStatus:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * {@hide}
 */

Body of Frist Method:
{
    switch(status) {
        case INSTALL_SUCCEEDED:
            return PackageInstaller.STATUS_SUCCESS;
        case INSTALL_FAILED_ALREADY_EXISTS:
            return PackageInstaller.STATUS_FAILURE_CONFLICT;
        case INSTALL_FAILED_INVALID_APK:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_FAILED_INVALID_URI:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_FAILED_INSUFFICIENT_STORAGE:
            return PackageInstaller.STATUS_FAILURE_STORAGE;
        case INSTALL_FAILED_DUPLICATE_PACKAGE:
            return PackageInstaller.STATUS_FAILURE_CONFLICT;
        case INSTALL_FAILED_NO_SHARED_USER:
            return PackageInstaller.STATUS_FAILURE_CONFLICT;
        case INSTALL_FAILED_UPDATE_INCOMPATIBLE:
            return PackageInstaller.STATUS_FAILURE_CONFLICT;
        case INSTALL_FAILED_SHARED_USER_INCOMPATIBLE:
            return PackageInstaller.STATUS_FAILURE_CONFLICT;
        case INSTALL_FAILED_MISSING_SHARED_LIBRARY:
            return PackageInstaller.STATUS_FAILURE_INCOMPATIBLE;
        case INSTALL_FAILED_REPLACE_COULDNT_DELETE:
            return PackageInstaller.STATUS_FAILURE_CONFLICT;
        case INSTALL_FAILED_DEXOPT:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_FAILED_OLDER_SDK:
            return PackageInstaller.STATUS_FAILURE_INCOMPATIBLE;
        case INSTALL_FAILED_CONFLICTING_PROVIDER:
            return PackageInstaller.STATUS_FAILURE_CONFLICT;
        case INSTALL_FAILED_NEWER_SDK:
            return PackageInstaller.STATUS_FAILURE_INCOMPATIBLE;
        case INSTALL_FAILED_TEST_ONLY:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_FAILED_CPU_ABI_INCOMPATIBLE:
            return PackageInstaller.STATUS_FAILURE_INCOMPATIBLE;
        case INSTALL_FAILED_MISSING_FEATURE:
            return PackageInstaller.STATUS_FAILURE_INCOMPATIBLE;
        case INSTALL_FAILED_CONTAINER_ERROR:
            return PackageInstaller.STATUS_FAILURE_STORAGE;
        case INSTALL_FAILED_INVALID_INSTALL_LOCATION:
            return PackageInstaller.STATUS_FAILURE_STORAGE;
        case INSTALL_FAILED_MEDIA_UNAVAILABLE:
            return PackageInstaller.STATUS_FAILURE_STORAGE;
        case INSTALL_FAILED_VERIFICATION_TIMEOUT:
            return PackageInstaller.STATUS_FAILURE_ABORTED;
        case INSTALL_FAILED_VERIFICATION_FAILURE:
            return PackageInstaller.STATUS_FAILURE_ABORTED;
        case INSTALL_FAILED_PACKAGE_CHANGED:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_FAILED_UID_CHANGED:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_FAILED_VERSION_DOWNGRADE:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_FAILED_PERMISSION_MODEL_DOWNGRADE:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_PARSE_FAILED_NOT_APK:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_PARSE_FAILED_BAD_MANIFEST:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_PARSE_FAILED_UNEXPECTED_EXCEPTION:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_PARSE_FAILED_NO_CERTIFICATES:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_PARSE_FAILED_CERTIFICATE_ENCODING:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_PARSE_FAILED_BAD_SHARED_USER_ID:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_PARSE_FAILED_MANIFEST_MALFORMED:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_PARSE_FAILED_MANIFEST_EMPTY:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_FAILED_BAD_DEX_METADATA:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_FAILED_INTERNAL_ERROR:
            return PackageInstaller.STATUS_FAILURE;
        case INSTALL_FAILED_USER_RESTRICTED:
            return PackageInstaller.STATUS_FAILURE_INCOMPATIBLE;
        case INSTALL_FAILED_DUPLICATE_PERMISSION:
            return PackageInstaller.STATUS_FAILURE_CONFLICT;
        case INSTALL_FAILED_NO_MATCHING_ABIS:
            return PackageInstaller.STATUS_FAILURE_INCOMPATIBLE;
        case INSTALL_FAILED_ABORTED:
            return PackageInstaller.STATUS_FAILURE_ABORTED;
        default:
            return PackageInstaller.STATUS_FAILURE;
    }
}
Body of Second Method:
{
    switch(status) {
        case INSTALL_SUCCEEDED:
            return PackageInstaller.STATUS_SUCCESS;
        case INSTALL_FAILED_ALREADY_EXISTS:
            return PackageInstaller.STATUS_FAILURE_CONFLICT;
        case INSTALL_FAILED_INVALID_APK:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_FAILED_INVALID_URI:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_FAILED_INSUFFICIENT_STORAGE:
            return PackageInstaller.STATUS_FAILURE_STORAGE;
        case INSTALL_FAILED_DUPLICATE_PACKAGE:
            return PackageInstaller.STATUS_FAILURE_CONFLICT;
        case INSTALL_FAILED_NO_SHARED_USER:
            return PackageInstaller.STATUS_FAILURE_CONFLICT;
        case INSTALL_FAILED_UPDATE_INCOMPATIBLE:
            return PackageInstaller.STATUS_FAILURE_CONFLICT;
        case INSTALL_FAILED_SHARED_USER_INCOMPATIBLE:
            return PackageInstaller.STATUS_FAILURE_CONFLICT;
        case INSTALL_FAILED_MISSING_SHARED_LIBRARY:
            return PackageInstaller.STATUS_FAILURE_INCOMPATIBLE;
        case INSTALL_FAILED_REPLACE_COULDNT_DELETE:
            return PackageInstaller.STATUS_FAILURE_CONFLICT;
        case INSTALL_FAILED_DEXOPT:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_FAILED_OLDER_SDK:
            return PackageInstaller.STATUS_FAILURE_INCOMPATIBLE;
        case INSTALL_FAILED_CONFLICTING_PROVIDER:
            return PackageInstaller.STATUS_FAILURE_CONFLICT;
        case INSTALL_FAILED_NEWER_SDK:
            return PackageInstaller.STATUS_FAILURE_INCOMPATIBLE;
        case INSTALL_FAILED_TEST_ONLY:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_FAILED_CPU_ABI_INCOMPATIBLE:
            return PackageInstaller.STATUS_FAILURE_INCOMPATIBLE;
        case INSTALL_FAILED_MISSING_FEATURE:
            return PackageInstaller.STATUS_FAILURE_INCOMPATIBLE;
        case INSTALL_FAILED_CONTAINER_ERROR:
            return PackageInstaller.STATUS_FAILURE_STORAGE;
        case INSTALL_FAILED_INVALID_INSTALL_LOCATION:
            return PackageInstaller.STATUS_FAILURE_STORAGE;
        case INSTALL_FAILED_MEDIA_UNAVAILABLE:
            return PackageInstaller.STATUS_FAILURE_STORAGE;
        case INSTALL_FAILED_VERIFICATION_TIMEOUT:
            return PackageInstaller.STATUS_FAILURE_ABORTED;
        case INSTALL_FAILED_VERIFICATION_FAILURE:
            return PackageInstaller.STATUS_FAILURE_ABORTED;
        case INSTALL_FAILED_PACKAGE_CHANGED:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_FAILED_UID_CHANGED:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_FAILED_VERSION_DOWNGRADE:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_FAILED_PERMISSION_MODEL_DOWNGRADE:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_PARSE_FAILED_NOT_APK:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_PARSE_FAILED_BAD_MANIFEST:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_PARSE_FAILED_UNEXPECTED_EXCEPTION:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_PARSE_FAILED_NO_CERTIFICATES:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_PARSE_FAILED_CERTIFICATE_ENCODING:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_PARSE_FAILED_BAD_SHARED_USER_ID:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_PARSE_FAILED_MANIFEST_MALFORMED:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_PARSE_FAILED_MANIFEST_EMPTY:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_FAILED_BAD_DEX_METADATA:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_FAILED_BAD_SIGNATURE:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_FAILED_INTERNAL_ERROR:
            return PackageInstaller.STATUS_FAILURE;
        case INSTALL_FAILED_USER_RESTRICTED:
            return PackageInstaller.STATUS_FAILURE_INCOMPATIBLE;
        case INSTALL_FAILED_DUPLICATE_PERMISSION:
            return PackageInstaller.STATUS_FAILURE_CONFLICT;
        case INSTALL_FAILED_NO_MATCHING_ABIS:
            return PackageInstaller.STATUS_FAILURE_INCOMPATIBLE;
        case INSTALL_FAILED_ABORTED:
            return PackageInstaller.STATUS_FAILURE_ABORTED;
        case INSTALL_FAILED_MISSING_SPLIT:
            return PackageInstaller.STATUS_FAILURE_INCOMPATIBLE;
        default:
            return PackageInstaller.STATUS_FAILURE;
    }
}
------------------------
Find a silently evolved API code:android.os.Message.recycleUnchecked:COMMENT
Method Modifier: default     
Comment:/**
 * Recycles a Message that may be in-use.
 * Used internally by the MessageQueue and Looper when disposing of queued Messages.
 */

Body of Frist Method:
{
    // Mark the message as in use while it remains in the recycled object pool.
    // Clear out all other details.
    flags = FLAG_IN_USE;
    what = 0;
    arg1 = 0;
    arg2 = 0;
    obj = null;
    replyTo = null;
    sendingUid = -1;
    when = 0;
    target = null;
    callback = null;
    data = null;
    synchronized (sPoolSync) {
        if (sPoolSize < MAX_POOL_SIZE) {
            next = sPool;
            sPool = this;
            sPoolSize++;
        }
    }
}
Body of Second Method:
{
    // Mark the message as in use while it remains in the recycled object pool.
    // Clear out all other details.
    flags = FLAG_IN_USE;
    what = 0;
    arg1 = 0;
    arg2 = 0;
    obj = null;
    replyTo = null;
    sendingUid = UID_NONE;
    workSourceUid = UID_NONE;
    when = 0;
    target = null;
    callback = null;
    data = null;
    synchronized (sPoolSync) {
        if (sPoolSize < MAX_POOL_SIZE) {
            next = sPool;
            sPool = this;
            sPoolSize++;
        }
    }
}
------------------------
Find a silently evolved API code:android.hardware.camera2.params.StreamConfigurationMap.checkArgumentFormatInternal:COMMENT
Method Modifier: default     static      
Comment:/**
 * Ensures that the format is either user-defined or implementation defined.
 *
 * <p>If a format has a different internal representation than the public representation,
 * passing in the public representation here will fail.</p>
 *
 * <p>For example if trying to use {@link ImageFormat#JPEG}:
 * it has a different public representation than the internal representation
 * {@code HAL_PIXEL_FORMAT_BLOB}, this check will fail.</p>
 *
 * <p>Any invalid/undefined formats will raise an exception.</p>
 *
 * @param format image format
 * @return the format
 *
 * @throws IllegalArgumentException if the format was invalid
 */

Body of Frist Method:
{
    switch(format) {
        case HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED:
        case HAL_PIXEL_FORMAT_BLOB:
        case HAL_PIXEL_FORMAT_RAW_OPAQUE:
        case HAL_PIXEL_FORMAT_Y16:
            return format;
        case ImageFormat.JPEG:
            throw new IllegalArgumentException("ImageFormat.JPEG is an unknown internal format");
        default:
            return checkArgumentFormat(format);
    }
}
Body of Second Method:
{
    switch(format) {
        case HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED:
        case HAL_PIXEL_FORMAT_BLOB:
        case HAL_PIXEL_FORMAT_RAW_OPAQUE:
        case HAL_PIXEL_FORMAT_Y16:
            return format;
        case ImageFormat.JPEG:
        case ImageFormat.HEIC:
            throw new IllegalArgumentException("An unknown internal format: " + format);
        default:
            return checkArgumentFormat(format);
    }
}
------------------------
Find a silently evolved API code:android.app.servertransaction.NewIntentItem.obtain:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Obtain an instance initialized with provided params.
 */

Body of Frist Method:
{
    NewIntentItem instance = ObjectPool.obtain(NewIntentItem.class);
    if (instance == null) {
        instance = new NewIntentItem();
    }
    instance.mIntents = intents;
    instance.mPause = pause;
    return instance;
}
Body of Second Method:
{
    NewIntentItem instance = ObjectPool.obtain(NewIntentItem.class);
    if (instance == null) {
        instance = new NewIntentItem();
    }
    instance.mIntents = intents;
    instance.mResume = resume;
    return instance;
}
------------------------
Find a silently evolved API code:android.view.ThreadedRenderer.dumpGfxInfo:COMMENT
Method Modifier: default     hidden      
Comment:/**
 * Outputs extra debugging information in the specified file descriptor.
 */

Body of Frist Method:
{
    pw.flush();
    // If there's no arguments, eg 'dumpsys gfxinfo', then dump everything.
    // If there's a targetted package, eg 'dumpsys gfxinfo com.android.systemui', then only
    // dump the summary information
    int flags = (args == null || args.length == 0) ? FLAG_DUMP_ALL : 0;
    for (int i = 0; i < args.length; i++) {
        switch(args[i]) {
            case "framestats":
                flags |= FLAG_DUMP_FRAMESTATS;
                break;
            case "reset":
                flags |= FLAG_DUMP_RESET;
                break;
            case // magic option passed when dumping a bugreport.
            "-a":
                flags = FLAG_DUMP_ALL;
                break;
        }
    }
    nDumpProfileInfo(mNativeProxy, fd, flags);
}
Body of Second Method:
{
    pw.flush();
    // If there's no arguments, eg 'dumpsys gfxinfo', then dump everything.
    // If there's a targetted package, eg 'dumpsys gfxinfo com.android.systemui', then only
    // dump the summary information
    int flags = (args == null || args.length == 0) ? FLAG_DUMP_ALL : 0;
    for (int i = 0; i < args.length; i++) {
        switch(args[i]) {
            case "framestats":
                flags |= FLAG_DUMP_FRAMESTATS;
                break;
            case "reset":
                flags |= FLAG_DUMP_RESET;
                break;
            case // magic option passed when dumping a bugreport.
            "-a":
                flags = FLAG_DUMP_ALL;
                break;
        }
    }
    dumpProfileInfo(fd, flags);
}
------------------------
Find a silently evolved API code:android.telephony.euicc.EuiccManager.continueOperation:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Continue an operation after the user resolves an error.
 *
 * <p>To be called by the LUI upon completion of a resolvable error flow.
 *
 * <p>Requires that the calling app has the
 * {@link android.Manifest.permission#WRITE_EMBEDDED_SUBSCRIPTIONS} permission.
 *
 * @param resolutionIntent The original intent used to start the LUI.
 * @param resolutionExtras Resolution-specific extras depending on the result of the resolution.
 * For example, this may indicate whether the user has consented or may include the input
 * they provided.
 * @hide
 */

Body of Frist Method:
{
    if (!isEnabled()) {
        PendingIntent callbackIntent = resolutionIntent.getParcelableExtra(EuiccManager.EXTRA_EMBEDDED_SUBSCRIPTION_RESOLUTION_CALLBACK_INTENT);
        if (callbackIntent != null) {
            sendUnavailableError(callbackIntent);
        }
        return;
    }
    try {
        getIEuiccController().continueOperation(resolutionIntent, resolutionExtras);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    if (!isEnabled()) {
        PendingIntent callbackIntent = resolutionIntent.getParcelableExtra(EuiccManager.EXTRA_EMBEDDED_SUBSCRIPTION_RESOLUTION_CALLBACK_INTENT);
        if (callbackIntent != null) {
            sendUnavailableError(callbackIntent);
        }
        return;
    }
    try {
        getIEuiccController().continueOperation(mCardId, resolutionIntent, resolutionExtras);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothPbap.close:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Close the connection to the backing service.
 * Other public functions of BluetoothPbap will return default error
 * results once close() has been called. Multiple invocations of close()
 * are ok.
 */

Body of Frist Method:
{
    IBluetoothManager mgr = mAdapter.getBluetoothManager();
    if (mgr != null) {
        try {
            mgr.unregisterStateChangeCallback(mBluetoothStateChangeCallback);
        } catch (Exception e) {
            Log.e(TAG, "", e);
        }
    }
    synchronized (mConnection) {
        if (mService != null) {
            try {
                mService = null;
                mContext.unbindService(mConnection);
            } catch (Exception re) {
                Log.e(TAG, "", re);
            }
        }
    }
    mServiceListener = null;
}
Body of Second Method:
{
    IBluetoothManager mgr = mAdapter.getBluetoothManager();
    if (mgr != null) {
        try {
            mgr.unregisterStateChangeCallback(mBluetoothStateChangeCallback);
        } catch (RemoteException re) {
            Log.e(TAG, "", re);
        }
    }
    doUnbind();
    mServiceListener = null;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothPbapClient.getConnectionState:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get connection state of device
 *
 * @return device connection state
 */

Body of Frist Method:
{
    if (DBG) {
        log("getConnectionState(" + device + ")");
    }
    final IBluetoothPbapClient service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getConnectionState(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.STATE_DISCONNECTED;
        }
    }
    if (service == null) {
        Log.w(TAG, "Proxy not attached to service");
    }
    return BluetoothProfile.STATE_DISCONNECTED;
}
Body of Second Method:
{
    if (DBG) {
        log("getConnectionState(" + device + ")");
    }
    final IBluetoothPbapClient service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getConnectionState(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.STATE_DISCONNECTED;
        }
    }
    if (service == null) {
        Log.w(TAG, "Proxy not attached to service");
    }
    return BluetoothProfile.STATE_DISCONNECTED;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothSap.setPriority:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Set priority of the profile
 *
 * <p> The device should already be paired.
 *
 * @param device Paired bluetooth device
 * @param priority
 * @return true if priority is set, false on error
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("setPriority(" + device + ", " + priority + ")");
    final IBluetoothSap service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        if (priority != BluetoothProfile.PRIORITY_OFF && priority != BluetoothProfile.PRIORITY_ON) {
            return false;
        }
        try {
            return service.setPriority(device, priority);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("setPriority(" + device + ", " + priority + ")");
    final IBluetoothSap service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        if (priority != BluetoothProfile.PRIORITY_OFF && priority != BluetoothProfile.PRIORITY_ON) {
            return false;
        }
        try {
            return service.setPriority(device, priority);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothMap.disconnect:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Initiate disconnect.
 *
 * @param device Remote Bluetooth Device
 * @return false on error, true otherwise
 */

Body of Frist Method:
{
    if (DBG)
        log("disconnect(" + device + ")");
    final IBluetoothMap service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.disconnect(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("disconnect(" + device + ")");
    final IBluetoothMap service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.disconnect(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.content.PermissionChecker.checkPermission:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Checks whether a given package in a UID and PID has a given permission
 * and whether the app op that corresponds to this permission is allowed.
 *
 * @param context Context for accessing resources.
 * @param permission The permission to check.
 * @param pid The process id for which to check.
 * @param uid The uid for which to check.
 * @param packageName The package name for which to check. If null the
 * the first package for the calling UID will be used.
 * @return The permission check result which is either {@link #PERMISSION_GRANTED}
 * or {@link #PERMISSION_DENIED} or {@link #PERMISSION_DENIED_APP_OP}.
 */

Body of Frist Method:
{
    if (context.checkPermission(permission, pid, uid) == PackageManager.PERMISSION_DENIED) {
        return PERMISSION_DENIED;
    }
    AppOpsManager appOpsManager = context.getSystemService(AppOpsManager.class);
    String op = appOpsManager.permissionToOp(permission);
    if (op == null) {
        return PERMISSION_GRANTED;
    }
    if (packageName == null) {
        String[] packageNames = context.getPackageManager().getPackagesForUid(uid);
        if (packageNames == null || packageNames.length <= 0) {
            return PERMISSION_DENIED;
        }
        packageName = packageNames[0];
    }
    if (appOpsManager.noteProxyOpNoThrow(op, packageName) != AppOpsManager.MODE_ALLOWED) {
        return PERMISSION_DENIED_APP_OP;
    }
    return PERMISSION_GRANTED;
}
Body of Second Method:
{
    if (context.checkPermission(permission, pid, uid) == PackageManager.PERMISSION_DENIED) {
        return PERMISSION_DENIED;
    }
    AppOpsManager appOpsManager = context.getSystemService(AppOpsManager.class);
    String op = appOpsManager.permissionToOp(permission);
    if (op == null) {
        return PERMISSION_GRANTED;
    }
    if (packageName == null) {
        String[] packageNames = context.getPackageManager().getPackagesForUid(uid);
        if (packageNames == null || packageNames.length <= 0) {
            return PERMISSION_DENIED;
        }
        packageName = packageNames[0];
    }
    if (appOpsManager.noteProxyOpNoThrow(op, packageName, uid) != AppOpsManager.MODE_ALLOWED) {
        return PERMISSION_DENIED_APP_OP;
    }
    return PERMISSION_GRANTED;
}
------------------------
Find a silently evolved API code:android.app.servertransaction.LaunchActivityItem.setValues:COMMENT
Method Modifier: private     static      hidden      
Comment:// Using the same method to set and clear values to make sure we don't forget anything

Body of Frist Method:
{
    instance.mIntent = intent;
    instance.mIdent = ident;
    instance.mInfo = info;
    instance.mCurConfig = curConfig;
    instance.mOverrideConfig = overrideConfig;
    instance.mCompatInfo = compatInfo;
    instance.mReferrer = referrer;
    instance.mVoiceInteractor = voiceInteractor;
    instance.mProcState = procState;
    instance.mState = state;
    instance.mPersistentState = persistentState;
    instance.mPendingResults = pendingResults;
    instance.mPendingNewIntents = pendingNewIntents;
    instance.mIsForward = isForward;
    instance.mProfilerInfo = profilerInfo;
}
Body of Second Method:
{
    instance.mIntent = intent;
    instance.mIdent = ident;
    instance.mInfo = info;
    instance.mCurConfig = curConfig;
    instance.mOverrideConfig = overrideConfig;
    instance.mCompatInfo = compatInfo;
    instance.mReferrer = referrer;
    instance.mVoiceInteractor = voiceInteractor;
    instance.mProcState = procState;
    instance.mState = state;
    instance.mPersistentState = persistentState;
    instance.mPendingResults = pendingResults;
    instance.mPendingNewIntents = pendingNewIntents;
    instance.mIsForward = isForward;
    instance.mProfilerInfo = profilerInfo;
    instance.mAssistToken = assistToken;
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiConfiguration.isOpenNetwork:COMMENT
<android.net.wifi.WifiConfiguration: boolean isOpenNetwork()>
public      hidden      ->public      hidden      deprecated  
Method Modifier: public      hidden      deprecated  
Method Modifier: Yes         Yes         No          
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * @hide
 * Returns true if this WiFi config is for an open network.
 */

Body of Frist Method:
{
    final int cardinality = allowedKeyManagement.cardinality();
    final boolean hasNoKeyMgmt = cardinality == 0 || (cardinality == 1 && allowedKeyManagement.get(KeyMgmt.NONE));
    boolean hasNoWepKeys = true;
    if (wepKeys != null) {
        for (int i = 0; i < wepKeys.length; i++) {
            if (wepKeys[i] != null) {
                hasNoWepKeys = false;
                break;
            }
        }
    }
    return hasNoKeyMgmt && hasNoWepKeys;
}
Body of Second Method:
{
    final int cardinality = allowedKeyManagement.cardinality();
    final boolean hasNoKeyMgmt = cardinality == 0 || (cardinality == 1 && (allowedKeyManagement.get(KeyMgmt.NONE) || allowedKeyManagement.get(KeyMgmt.OWE)));
    boolean hasNoWepKeys = true;
    if (wepKeys != null) {
        for (int i = 0; i < wepKeys.length; i++) {
            if (wepKeys[i] != null) {
                hasNoWepKeys = false;
                break;
            }
        }
    }
    return hasNoKeyMgmt && hasNoWepKeys;
}
------------------------
Find a silently evolved API code:android.graphics.drawable.ShapeDrawable.updateLocalState:COMMENT
Method Modifier: private     
Comment:/**
 * Initializes local dynamic properties from state. This should be called
 * after significant state changes, e.g. from the One True Constructor and
 * after inflating or applying a theme.
 */

Body of Frist Method:
{
    mTintFilter = updateTintFilter(mTintFilter, mShapeState.mTint, mShapeState.mTintMode);
}
Body of Second Method:
{
    mBlendModeColorFilter = updateBlendModeFilter(mBlendModeColorFilter, mShapeState.mTint, mShapeState.mBlendMode);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHidHost.setProtocolMode:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Send Set_Protocol_Mode command to the connected HID input device.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN} permission.
 *
 * @param device Remote Bluetooth Device
 * @return false on immediate error, true otherwise
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("setProtocolMode(" + device + ")");
    final IBluetoothHidHost service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.setProtocolMode(device, protocolMode);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("setProtocolMode(" + device + ")");
    final IBluetoothHidHost service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.setProtocolMode(device, protocolMode);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiScanner.PnoSettings.writeToParcel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Implement the Parcelable interface {@hide}
 */

Body of Frist Method:
{
    dest.writeInt(isConnected ? 1 : 0);
    dest.writeInt(min5GHzRssi);
    dest.writeInt(min24GHzRssi);
    dest.writeInt(initialScoreMax);
    dest.writeInt(currentConnectionBonus);
    dest.writeInt(sameNetworkBonus);
    dest.writeInt(secureBonus);
    dest.writeInt(band5GHzBonus);
    if (networkList != null) {
        dest.writeInt(networkList.length);
        for (int i = 0; i < networkList.length; i++) {
            dest.writeString(networkList[i].ssid);
            dest.writeByte(networkList[i].flags);
            dest.writeByte(networkList[i].authBitField);
        }
    } else {
        dest.writeInt(0);
    }
}
Body of Second Method:
{
    dest.writeInt(isConnected ? 1 : 0);
    dest.writeInt(min5GHzRssi);
    dest.writeInt(min24GHzRssi);
    dest.writeInt(initialScoreMax);
    dest.writeInt(currentConnectionBonus);
    dest.writeInt(sameNetworkBonus);
    dest.writeInt(secureBonus);
    dest.writeInt(band5GHzBonus);
    if (networkList != null) {
        dest.writeInt(networkList.length);
        for (int i = 0; i < networkList.length; i++) {
            dest.writeString(networkList[i].ssid);
            dest.writeByte(networkList[i].flags);
            dest.writeByte(networkList[i].authBitField);
            dest.writeIntArray(networkList[i].frequencies);
        }
    } else {
        dest.writeInt(0);
    }
}
------------------------
Find a silently evolved API code:android.util.proto.ProtoOutputStream.endObjectImpl:COMMENT
Method Modifier: private     
Comment:/**
 * Common implementation of endObject and endRepeatedObject.
 */

Body of Frist Method:
{
    // The upper 32 bits of the token is the depth of startObject /
    // endObject calls.  We could get aritrarily sophisticated, but
    // that's enough to prevent the common error of missing an
    // endObject somewhere.
    // The lower 32 bits of the token is the offset in the buffer
    // at which to write the size.
    final int depth = getDepthFromToken(token);
    final boolean expectedRepeated = getRepeatedFromToken(token);
    final int sizePos = getSizePosFromToken(token);
    final int childRawSize = mBuffer.getWritePos() - sizePos - 8;
    if (repeated != expectedRepeated) {
        if (repeated) {
            throw new IllegalArgumentException("endRepeatedObject called where endObject should" + " have been");
        } else {
            throw new IllegalArgumentException("endObject called where endRepeatedObject should" + " have been");
        }
    }
    // Check that we're getting the token and depth that we are expecting.
    if ((mDepth & 0x01ff) != depth || mExpectedObjectToken != token) {
        // that we're tracking the objectIds and depths correctly.
        throw new IllegalArgumentException("Mismatched startObject/endObject calls." + " Current depth " + mDepth + " token=" + token2String(token) + " expectedToken=" + token2String(mExpectedObjectToken));
    }
    // Get the next expected token that we stashed away in the buffer.
    mExpectedObjectToken = (((long) mBuffer.getRawFixed32At(sizePos)) << 32) | (0x0ffffffffL & (long) mBuffer.getRawFixed32At(sizePos + 4));
    mDepth--;
    if (childRawSize > 0) {
        mBuffer.editRawFixed32(sizePos, -childRawSize);
        mBuffer.editRawFixed32(sizePos + 4, -1);
    } else if (repeated) {
        mBuffer.editRawFixed32(sizePos, 0);
        mBuffer.editRawFixed32(sizePos + 4, 0);
    } else {
        // The object has no data.  Don't include it.
        mBuffer.rewindWriteTo(sizePos - getTagSizeFromToken(token));
    }
}
Body of Second Method:
{
    // The upper 32 bits of the token is the depth of startObject /
    // endObject calls.  We could get aritrarily sophisticated, but
    // that's enough to prevent the common error of missing an
    // endObject somewhere.
    // The lower 32 bits of the token is the offset in the buffer
    // at which to write the size.
    final int depth = getDepthFromToken(token);
    final boolean expectedRepeated = getRepeatedFromToken(token);
    final int sizePos = getOffsetFromToken(token);
    final int childRawSize = mBuffer.getWritePos() - sizePos - 8;
    if (repeated != expectedRepeated) {
        if (repeated) {
            throw new IllegalArgumentException("endRepeatedObject called where endObject should" + " have been");
        } else {
            throw new IllegalArgumentException("endObject called where endRepeatedObject should" + " have been");
        }
    }
    // Check that we're getting the token and depth that we are expecting.
    if ((mDepth & 0x01ff) != depth || mExpectedObjectToken != token) {
        // that we're tracking the objectIds and depths correctly.
        throw new IllegalArgumentException("Mismatched startObject/endObject calls." + " Current depth " + mDepth + " token=" + token2String(token) + " expectedToken=" + token2String(mExpectedObjectToken));
    }
    // Get the next expected token that we stashed away in the buffer.
    mExpectedObjectToken = (((long) mBuffer.getRawFixed32At(sizePos)) << 32) | (0x0ffffffffL & (long) mBuffer.getRawFixed32At(sizePos + 4));
    mDepth--;
    if (childRawSize > 0) {
        mBuffer.editRawFixed32(sizePos, -childRawSize);
        mBuffer.editRawFixed32(sizePos + 4, -1);
    } else if (repeated) {
        mBuffer.editRawFixed32(sizePos, 0);
        mBuffer.editRawFixed32(sizePos + 4, 0);
    } else {
        // The object has no data.  Don't include it.
        mBuffer.rewindWriteTo(sizePos - getTagSizeFromToken(token));
    }
}
------------------------
Find a silently evolved API code:android.media.AudioFormat.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Combines all of the format characteristics that have been set and return a new
 * {@link AudioFormat} object.
 * @return a new {@link AudioFormat} object
 */

Body of Frist Method:
{
    AudioFormat af = new AudioFormat(1980);
    af.mEncoding = mEncoding;
    // not calling setSampleRate is equivalent to calling
    // setSampleRate(SAMPLE_RATE_UNSPECIFIED)
    af.mSampleRate = mSampleRate;
    af.mChannelMask = mChannelMask;
    af.mChannelIndexMask = mChannelIndexMask;
    af.mPropertySetMask = mPropertySetMask;
    return af;
}
Body of Second Method:
{
    AudioFormat af = new AudioFormat(mPropertySetMask, mEncoding, mSampleRate, mChannelMask, mChannelIndexMask);
    return af;
}
------------------------
Find a silently evolved API code:android.telephony.CellSignalStrengthLte.toString:COMMENT
Method Modifier: public      
Comment:/**
 * @return string representation.
 */

Body of Frist Method:
{
    return "CellSignalStrengthLte:" + " ss=" + mSignalStrength + " rsrp=" + mRsrp + " rsrq=" + mRsrq + " rssnr=" + mRssnr + " cqi=" + mCqi + " ta=" + mTimingAdvance;
}
Body of Second Method:
{
    return "CellSignalStrengthLte:" + " rssi=" + mRssi + " rsrp=" + mRsrp + " rsrq=" + mRsrq + " rssnr=" + mRssnr + " cqi=" + mCqi + " ta=" + mTimingAdvance + " level=" + mLevel;
}
------------------------
Find a silently evolved API code:android.hardware.camera2.impl.CameraMetadataNative.swap:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * <p>Perform a 0-copy swap of the internal metadata with another object.</p>
 *
 * <p>Useful to convert a CameraMetadata into e.g. a CaptureRequest.</p>
 *
 * @param other Metadata to swap with
 * @throws NullPointerException if other was null
 * @hide
 */

Body of Frist Method:
{
    nativeSwap(other);
}
Body of Second Method:
{
    nativeSwap(other);
    mCameraId = other.mCameraId;
    mDisplaySize = other.mDisplaySize;
}
------------------------
Find a silently evolved API code:android.content.ContentProviderClient.releaseQuietly:COMMENT
<android.content.ContentProviderClient: void releaseQuietly(ContentProviderClient)>
public      static      hidden      ->public      static      hidden      deprecated  
Method Modifier: public      static      hidden      deprecated  
Method Modifier: Yes         Yes         Yes         No          
Method Updated:  Yes         Yes         Yes         Yes         
Comment:/**
 * {@hide}
 */

Body of Frist Method:
{
    if (client != null) {
        try {
            client.release();
        } catch (Exception ignored) {
        }
    }
}
Body of Second Method:
{
    IoUtils.closeQuietly(client);
}
------------------------
Find a silently evolved API code:android.telephony.CellSignalStrengthWcdma.toString:COMMENT
Method Modifier: public      
Comment:/**
 * @return string representation.
 */

Body of Frist Method:
{
    return "CellSignalStrengthWcdma:" + " ss=" + mSignalStrength + " ber=" + mBitErrorRate;
}
Body of Second Method:
{
    return "CellSignalStrengthWcdma:" + " ss=" + mRssi + " ber=" + mBitErrorRate + " rscp=" + mRscp + " ecno=" + mEcNo + " level=" + mLevel;
}
------------------------
Find a silently evolved API code:android.app.BroadcastOptions.toBundle:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns the created options as a Bundle, which can be passed to
 * {@link android.content.Context#sendBroadcast(android.content.Intent)
 * Context.sendBroadcast(Intent)} and related methods.
 * Note that the returned Bundle is still owned by the BroadcastOptions
 * object; you must not modify it, but can supply it to the sendBroadcast
 * methods that take an options Bundle.
 */

Body of Frist Method:
{
    Bundle b = new Bundle();
    if (mTemporaryAppWhitelistDuration > 0) {
        b.putLong(KEY_TEMPORARY_APP_WHITELIST_DURATION, mTemporaryAppWhitelistDuration);
    }
    if (mMinManifestReceiverApiLevel != 0) {
        b.putInt(KEY_MIN_MANIFEST_RECEIVER_API_LEVEL, mMinManifestReceiverApiLevel);
    }
    if (mMaxManifestReceiverApiLevel != Build.VERSION_CODES.CUR_DEVELOPMENT) {
        b.putInt(KEY_MAX_MANIFEST_RECEIVER_API_LEVEL, mMaxManifestReceiverApiLevel);
    }
    if (mDontSendToRestrictedApps) {
        b.putBoolean(KEY_DONT_SEND_TO_RESTRICTED_APPS, true);
    }
    return b.isEmpty() ? null : b;
}
Body of Second Method:
{
    Bundle b = new Bundle();
    if (mTemporaryAppWhitelistDuration > 0) {
        b.putLong(KEY_TEMPORARY_APP_WHITELIST_DURATION, mTemporaryAppWhitelistDuration);
    }
    if (mMinManifestReceiverApiLevel != 0) {
        b.putInt(KEY_MIN_MANIFEST_RECEIVER_API_LEVEL, mMinManifestReceiverApiLevel);
    }
    if (mMaxManifestReceiverApiLevel != Build.VERSION_CODES.CUR_DEVELOPMENT) {
        b.putInt(KEY_MAX_MANIFEST_RECEIVER_API_LEVEL, mMaxManifestReceiverApiLevel);
    }
    if (mDontSendToRestrictedApps) {
        b.putBoolean(KEY_DONT_SEND_TO_RESTRICTED_APPS, true);
    }
    if (mAllowBackgroundActivityStarts) {
        b.putBoolean(KEY_ALLOW_BACKGROUND_ACTIVITY_STARTS, true);
    }
    return b.isEmpty() ? null : b;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHidHost.connect:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Initiate connection to a profile of the remote bluetooth device.
 *
 * <p> The system supports connection to multiple input devices.
 *
 * <p> This API returns false in scenarios like the profile on the
 * device is already connected or Bluetooth is not turned on.
 * When this API returns true, it is guaranteed that
 * connection state intent for the profile will be broadcasted with
 * the state. Users can get the connection state of the profile
 * from this intent.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}
 * permission.
 *
 * @param device Remote Bluetooth Device
 * @return false on immediate error, true otherwise
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("connect(" + device + ")");
    final IBluetoothHidHost service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.connect(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("connect(" + device + ")");
    final IBluetoothHidHost service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.connect(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.widget.NumberPicker.showSoftInput:COMMENT
Method Modifier: private     
Comment:/**
 * Shows the soft input for its input text.
 */

Body of Frist Method:
{
    InputMethodManager inputMethodManager = InputMethodManager.peekInstance();
    if (inputMethodManager != null) {
        if (mHasSelectorWheel) {
            mInputText.setVisibility(View.VISIBLE);
        }
        mInputText.requestFocus();
        inputMethodManager.showSoftInput(mInputText, 0);
    }
}
Body of Second Method:
{
    InputMethodManager inputMethodManager = getContext().getSystemService(InputMethodManager.class);
    if (inputMethodManager != null) {
        if (mHasSelectorWheel) {
            mInputText.setVisibility(View.VISIBLE);
        }
        mInputText.requestFocus();
        inputMethodManager.showSoftInput(mInputText, 0);
    }
}
------------------------
Find a silently evolved API code:android.telephony.CellSignalStrengthGsm.getDbm:COMMENT
Method Modifier: public      
Comment:/**
 * Get the signal strength as dBm
 */

Body of Frist Method:
{
    int dBm;
    int level = mSignalStrength;
    int asu = (level == 99 ? Integer.MAX_VALUE : level);
    if (asu != Integer.MAX_VALUE) {
        dBm = -113 + (2 * asu);
    } else {
        dBm = Integer.MAX_VALUE;
    }
    if (DBG)
        log("getDbm=" + dBm);
    return dBm;
}
Body of Second Method:
{
    return mRssi;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.getConnectionState:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns state of the <code>device</code>
 *
 * @param device a remote device
 * @return the state of connection of the device
 */

Body of Frist Method:
{
    if (VDBG)
        log("getConnectionState(" + device + ")");
    final IBluetoothHeadsetClient service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getConnectionState(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.STATE_DISCONNECTED;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return BluetoothProfile.STATE_DISCONNECTED;
}
Body of Second Method:
{
    if (VDBG)
        log("getConnectionState(" + device + ")");
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getConnectionState(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.STATE_DISCONNECTED;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return BluetoothProfile.STATE_DISCONNECTED;
}
------------------------
Find a silently evolved API code:android.telephony.CellIdentityLte.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Implement the Parcelable interface
 */

Body of Frist Method:
{
    if (DBG)
        log("writeToParcel(Parcel, int): " + toString());
    super.writeToParcel(dest, TYPE_LTE);
    dest.writeInt(mCi);
    dest.writeInt(mPci);
    dest.writeInt(mTac);
    dest.writeInt(mEarfcn);
    dest.writeInt(mBandwidth);
}
Body of Second Method:
{
    if (DBG)
        log("writeToParcel(Parcel, int): " + toString());
    super.writeToParcel(dest, CellInfo.TYPE_LTE);
    dest.writeInt(mCi);
    dest.writeInt(mPci);
    dest.writeInt(mTac);
    dest.writeInt(mEarfcn);
    dest.writeInt(mBandwidth);
}
------------------------
Find a silently evolved API code:android.transition.Transition.captureHierarchy:COMMENT
Method Modifier: private     
Comment:/**
 * Recursive method which captures values for an entire view hierarchy,
 * starting at some root view. Transitions without targetIDs will use this
 * method to capture values for all possible views.
 *
 * @param view The view for which to capture values. Children of this View
 * will also be captured, recursively down to the leaf nodes.
 * @param start true if values are being captured in the start scene, false
 * otherwise.
 */

Body of Frist Method:
{
    if (view == null) {
        return;
    }
    int id = view.getId();
    if (mTargetIdExcludes != null && mTargetIdExcludes.contains(id)) {
        return;
    }
    if (mTargetExcludes != null && mTargetExcludes.contains(view)) {
        return;
    }
    if (mTargetTypeExcludes != null && view != null) {
        int numTypes = mTargetTypeExcludes.size();
        for (int i = 0; i < numTypes; ++i) {
            if (mTargetTypeExcludes.get(i).isInstance(view)) {
                return;
            }
        }
    }
    if (view.getParent() instanceof ViewGroup) {
        TransitionValues values = new TransitionValues();
        values.view = view;
        if (start) {
            captureStartValues(values);
        } else {
            captureEndValues(values);
        }
        values.targetedTransitions.add(this);
        capturePropagationValues(values);
        if (start) {
            addViewValues(mStartValues, view, values);
        } else {
            addViewValues(mEndValues, view, values);
        }
    }
    if (view instanceof ViewGroup) {
        // Don't traverse child hierarchy if there are any child-excludes on this view
        if (mTargetIdChildExcludes != null && mTargetIdChildExcludes.contains(id)) {
            return;
        }
        if (mTargetChildExcludes != null && mTargetChildExcludes.contains(view)) {
            return;
        }
        if (mTargetTypeChildExcludes != null) {
            int numTypes = mTargetTypeChildExcludes.size();
            for (int i = 0; i < numTypes; ++i) {
                if (mTargetTypeChildExcludes.get(i).isInstance(view)) {
                    return;
                }
            }
        }
        ViewGroup parent = (ViewGroup) view;
        for (int i = 0; i < parent.getChildCount(); ++i) {
            captureHierarchy(parent.getChildAt(i), start);
        }
    }
}
Body of Second Method:
{
    if (view == null) {
        return;
    }
    int id = view.getId();
    if (mTargetIdExcludes != null && mTargetIdExcludes.contains(id)) {
        return;
    }
    if (mTargetExcludes != null && mTargetExcludes.contains(view)) {
        return;
    }
    if (mTargetTypeExcludes != null && view != null) {
        int numTypes = mTargetTypeExcludes.size();
        for (int i = 0; i < numTypes; ++i) {
            if (mTargetTypeExcludes.get(i).isInstance(view)) {
                return;
            }
        }
    }
    if (view.getParent() instanceof ViewGroup) {
        TransitionValues values = new TransitionValues(view);
        if (start) {
            captureStartValues(values);
        } else {
            captureEndValues(values);
        }
        values.targetedTransitions.add(this);
        capturePropagationValues(values);
        if (start) {
            addViewValues(mStartValues, view, values);
        } else {
            addViewValues(mEndValues, view, values);
        }
    }
    if (view instanceof ViewGroup) {
        // Don't traverse child hierarchy if there are any child-excludes on this view
        if (mTargetIdChildExcludes != null && mTargetIdChildExcludes.contains(id)) {
            return;
        }
        if (mTargetChildExcludes != null && mTargetChildExcludes.contains(view)) {
            return;
        }
        if (mTargetTypeChildExcludes != null) {
            int numTypes = mTargetTypeChildExcludes.size();
            for (int i = 0; i < numTypes; ++i) {
                if (mTargetTypeChildExcludes.get(i).isInstance(view)) {
                    return;
                }
            }
        }
        ViewGroup parent = (ViewGroup) view;
        for (int i = 0; i < parent.getChildCount(); ++i) {
            captureHierarchy(parent.getChildAt(i), start);
        }
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.getCurrentAgFeatures:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get Audio Gateway features
 *
 * @param device remote device
 * @return bundle of AG features; null if no service or AG not connected
 */

Body of Frist Method:
{
    final IBluetoothHeadsetClient service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.getCurrentAgFeatures(device);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return null;
}
Body of Second Method:
{
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled()) {
        try {
            return service.getCurrentAgFeatures(device);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return null;
}
------------------------
Find a silently evolved API code:android.app.NotificationChannel.toJson:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    JSONObject record = new JSONObject();
    record.put(ATT_ID, getId());
    record.put(ATT_NAME, getName());
    record.put(ATT_DESC, getDescription());
    if (getImportance() != DEFAULT_IMPORTANCE) {
        record.put(ATT_IMPORTANCE, NotificationListenerService.Ranking.importanceToString(getImportance()));
    }
    if (canBypassDnd()) {
        record.put(ATT_PRIORITY, Notification.PRIORITY_MAX);
    }
    if (getLockscreenVisibility() != DEFAULT_VISIBILITY) {
        record.put(ATT_VISIBILITY, Notification.visibilityToString(getLockscreenVisibility()));
    }
    if (getSound() != null) {
        record.put(ATT_SOUND, getSound().toString());
    }
    if (getAudioAttributes() != null) {
        record.put(ATT_USAGE, Integer.toString(getAudioAttributes().getUsage()));
        record.put(ATT_CONTENT_TYPE, Integer.toString(getAudioAttributes().getContentType()));
        record.put(ATT_FLAGS, Integer.toString(getAudioAttributes().getFlags()));
    }
    record.put(ATT_LIGHTS, Boolean.toString(shouldShowLights()));
    record.put(ATT_LIGHT_COLOR, Integer.toString(getLightColor()));
    record.put(ATT_VIBRATION_ENABLED, Boolean.toString(shouldVibrate()));
    record.put(ATT_USER_LOCKED, Integer.toString(getUserLockedFields()));
    record.put(ATT_FG_SERVICE_SHOWN, Boolean.toString(isFgServiceShown()));
    record.put(ATT_VIBRATION, longArrayToString(getVibrationPattern()));
    record.put(ATT_SHOW_BADGE, Boolean.toString(canShowBadge()));
    record.put(ATT_DELETED, Boolean.toString(isDeleted()));
    record.put(ATT_GROUP, getGroup());
    record.put(ATT_BLOCKABLE_SYSTEM, isBlockableSystem());
    return record;
}
Body of Second Method:
{
    JSONObject record = new JSONObject();
    record.put(ATT_ID, getId());
    record.put(ATT_NAME, getName());
    record.put(ATT_DESC, getDescription());
    if (getImportance() != DEFAULT_IMPORTANCE) {
        record.put(ATT_IMPORTANCE, NotificationListenerService.Ranking.importanceToString(getImportance()));
    }
    if (canBypassDnd()) {
        record.put(ATT_PRIORITY, Notification.PRIORITY_MAX);
    }
    if (getLockscreenVisibility() != DEFAULT_VISIBILITY) {
        record.put(ATT_VISIBILITY, Notification.visibilityToString(getLockscreenVisibility()));
    }
    if (getSound() != null) {
        record.put(ATT_SOUND, getSound().toString());
    }
    if (getAudioAttributes() != null) {
        record.put(ATT_USAGE, Integer.toString(getAudioAttributes().getUsage()));
        record.put(ATT_CONTENT_TYPE, Integer.toString(getAudioAttributes().getContentType()));
        record.put(ATT_FLAGS, Integer.toString(getAudioAttributes().getFlags()));
    }
    record.put(ATT_LIGHTS, Boolean.toString(shouldShowLights()));
    record.put(ATT_LIGHT_COLOR, Integer.toString(getLightColor()));
    record.put(ATT_VIBRATION_ENABLED, Boolean.toString(shouldVibrate()));
    record.put(ATT_USER_LOCKED, Integer.toString(getUserLockedFields()));
    record.put(ATT_FG_SERVICE_SHOWN, Boolean.toString(isFgServiceShown()));
    record.put(ATT_VIBRATION, longArrayToString(getVibrationPattern()));
    record.put(ATT_SHOW_BADGE, Boolean.toString(canShowBadge()));
    record.put(ATT_DELETED, Boolean.toString(isDeleted()));
    record.put(ATT_GROUP, getGroup());
    record.put(ATT_BLOCKABLE_SYSTEM, isBlockableSystem());
    record.put(ATT_ALLOW_BUBBLE, canBubble());
    return record;
}
------------------------
Find a silently evolved API code:android.content.ContentProviderClient.openTypedAssetFileDescriptor:COMMENT
Method Modifier: public      final       
Comment:/**
 * See {@link ContentProvider#openTypedAssetFile ContentProvider.openTypedAssetFile}
 */

Body of Frist Method:
{
    Preconditions.checkNotNull(uri, "uri");
    Preconditions.checkNotNull(mimeType, "mimeType");
    beforeRemote();
    try {
        ICancellationSignal remoteSignal = null;
        if (signal != null) {
            signal.throwIfCanceled();
            remoteSignal = mContentProvider.createCancellationSignal();
            signal.setRemote(remoteSignal);
        }
        return mContentProvider.openTypedAssetFile(mPackageName, uri, mimeType, opts, remoteSignal);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}
Body of Second Method:
{
    return openTypedAssetFile(uri, mimeType, opts, signal);
}
------------------------
Find a silently evolved API code:android.widget.ProgressBar.getProgressBackgroundTintMode:COMMENT
Method Modifier: public      
Comment:/**
 * @return the blending mode used to apply the tint to the progress
 * background
 * @attr ref android.R.styleable#ProgressBar_progressBackgroundTintMode
 * @see #setProgressBackgroundTintMode(PorterDuff.Mode)
 */

Body of Frist Method:
{
    return mProgressTintInfo != null ? mProgressTintInfo.mProgressBackgroundTintMode : null;
}
Body of Second Method:
{
    BlendMode mode = getProgressBackgroundTintBlendMode();
    return mode != null ? BlendMode.blendModeToPorterDuffMode(mode) : null;
}
------------------------
Find a silently evolved API code:android.graphics.drawable.AdaptiveIconDrawable.isProjected:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (super.isProjected()) {
        return true;
    }
    final ChildDrawable[] layers = mLayerState.mChildren;
    for (int i = 0; i < mLayerState.N_CHILDREN; i++) {
        if (layers[i].mDrawable.isProjected()) {
            return true;
        }
    }
    return false;
}
Body of Second Method:
{
    if (super.isProjected()) {
        return true;
    }
    final ChildDrawable[] layers = mLayerState.mChildren;
    for (int i = 0; i < mLayerState.N_CHILDREN; i++) {
        if (layers[i].mDrawable != null && layers[i].mDrawable.isProjected()) {
            return true;
        }
    }
    return false;
}
------------------------
Find a silently evolved API code:android.media.AudioRecordingConfiguration.getClientAudioSessionId:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the session number of the recording, see {@link AudioRecord#getAudioSessionId()}.
 * @return the session number.
 */

Body of Frist Method:
{
    return mSessionId;
}
Body of Second Method:
{
    return mClientSessionId;
}
------------------------
Find a silently evolved API code:android.os.UserHandle.isIsolated:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Whether a UID is an "isolated" UID.
 * @hide
 */

Body of Frist Method:
{
    if (uid > 0) {
        final int appId = getAppId(uid);
        return appId >= Process.FIRST_ISOLATED_UID && appId <= Process.LAST_ISOLATED_UID;
    } else {
        return false;
    }
}
Body of Second Method:
{
    if (uid > 0) {
        return Process.isIsolated(uid);
    } else {
        return false;
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothSap.getConnectionState:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get connection state of device
 *
 * @return device connection state
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("getConnectionState(" + device + ")");
    final IBluetoothSap service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getConnectionState(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.STATE_DISCONNECTED;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return BluetoothProfile.STATE_DISCONNECTED;
}
Body of Second Method:
{
    if (DBG)
        log("getConnectionState(" + device + ")");
    final IBluetoothSap service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getConnectionState(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.STATE_DISCONNECTED;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return BluetoothProfile.STATE_DISCONNECTED;
}
------------------------
Find a silently evolved API code:android.app.WindowConfiguration.diff:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Return a bit mask of the differences between this Configuration object and the given one.
 * Does not change the values of either. Any undefined fields in <var>other</var> are ignored.
 * @param other The configuration to diff against.
 * @param compareUndefined If undefined values should be compared.
 * @return Returns a bit mask indicating which configuration
 * values has changed, containing any combination of {@link WindowConfig} flags.
 *
 * @see Configuration#diff(Configuration)
 * @hide
 */

Body of Frist Method:
{
    long changes = 0;
    if (!mBounds.equals(other.mBounds)) {
        changes |= WINDOW_CONFIG_BOUNDS;
    }
    // Make sure that one of the values is not null and that they are not equal.
    if ((compareUndefined || other.mAppBounds != null) && mAppBounds != other.mAppBounds && (mAppBounds == null || !mAppBounds.equals(other.mAppBounds))) {
        changes |= WINDOW_CONFIG_APP_BOUNDS;
    }
    if ((compareUndefined || other.mWindowingMode != WINDOWING_MODE_UNDEFINED) && mWindowingMode != other.mWindowingMode) {
        changes |= WINDOW_CONFIG_WINDOWING_MODE;
    }
    if ((compareUndefined || other.mActivityType != ACTIVITY_TYPE_UNDEFINED) && mActivityType != other.mActivityType) {
        changes |= WINDOW_CONFIG_ACTIVITY_TYPE;
    }
    return changes;
}
Body of Second Method:
{
    long changes = 0;
    if (!mBounds.equals(other.mBounds)) {
        changes |= WINDOW_CONFIG_BOUNDS;
    }
    // Make sure that one of the values is not null and that they are not equal.
    if ((compareUndefined || other.mAppBounds != null) && mAppBounds != other.mAppBounds && (mAppBounds == null || !mAppBounds.equals(other.mAppBounds))) {
        changes |= WINDOW_CONFIG_APP_BOUNDS;
    }
    if ((compareUndefined || other.mWindowingMode != WINDOWING_MODE_UNDEFINED) && mWindowingMode != other.mWindowingMode) {
        changes |= WINDOW_CONFIG_WINDOWING_MODE;
    }
    if ((compareUndefined || other.mActivityType != ACTIVITY_TYPE_UNDEFINED) && mActivityType != other.mActivityType) {
        changes |= WINDOW_CONFIG_ACTIVITY_TYPE;
    }
    if ((compareUndefined || other.mAlwaysOnTop != ALWAYS_ON_TOP_UNDEFINED) && mAlwaysOnTop != other.mAlwaysOnTop) {
        changes |= WINDOW_CONFIG_ALWAYS_ON_TOP;
    }
    if ((compareUndefined || other.mRotation != ROTATION_UNDEFINED) && mRotation != other.mRotation) {
        changes |= WINDOW_CONFIG_ROTATION;
    }
    if ((compareUndefined || other.mDisplayWindowingMode != WINDOWING_MODE_UNDEFINED) && mDisplayWindowingMode != other.mDisplayWindowingMode) {
        changes |= WINDOW_CONFIG_DISPLAY_WINDOWING_MODE;
    }
    return changes;
}
------------------------
Find a silently evolved API code:android.app.SearchDialog.onConfigurationChanged:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Called after resources have changed, e.g. after screen rotation or locale change.
 */

Body of Frist Method:
{
    if (mSearchable != null && isShowing()) {
        // Redraw (resources may have changed)
        updateSearchAppIcon();
        updateSearchBadge();
        if (isLandscapeMode(getContext())) {
            mSearchAutoComplete.ensureImeVisible(true);
        }
    }
}
Body of Second Method:
{
    if (mSearchable != null && isShowing()) {
        // Redraw (resources may have changed)
        updateSearchAppIcon();
        updateSearchBadge();
        if (isLandscapeMode(getContext())) {
            mSearchAutoComplete.setInputMethodMode(ListPopupWindow.INPUT_METHOD_NEEDED);
            if (mSearchAutoComplete.isDropDownAlwaysVisible() || enoughToFilter()) {
                mSearchAutoComplete.showDropDown();
            }
        }
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothA2dpSink.getAudioConfig:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the current audio configuration for the A2DP source device,
 * or null if the device has no audio configuration
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param device Remote bluetooth device.
 * @return audio configuration for the device, or null
 *
 * {@see BluetoothAudioConfig}
 */

Body of Frist Method:
{
    if (VDBG)
        log("getAudioConfig(" + device + ")");
    final IBluetoothA2dpSink service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getAudioConfig(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return null;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return null;
}
Body of Second Method:
{
    if (VDBG)
        log("getAudioConfig(" + device + ")");
    final IBluetoothA2dpSink service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getAudioConfig(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return null;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return null;
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiInfo.reset:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    setInetAddress(null);
    setBSSID(null);
    setSSID(null);
    setNetworkId(-1);
    setRssi(INVALID_RSSI);
    setLinkSpeed(-1);
    setFrequency(-1);
    setMeteredHint(false);
    setEphemeral(false);
    txBad = 0;
    txSuccess = 0;
    rxSuccess = 0;
    txRetries = 0;
    txBadRate = 0;
    txSuccessRate = 0;
    rxSuccessRate = 0;
    txRetriesRate = 0;
    score = 0;
}
Body of Second Method:
{
    setInetAddress(null);
    setBSSID(null);
    setSSID(null);
    setNetworkId(-1);
    setRssi(INVALID_RSSI);
    setLinkSpeed(LINK_SPEED_UNKNOWN);
    setTxLinkSpeedMbps(LINK_SPEED_UNKNOWN);
    setRxLinkSpeedMbps(LINK_SPEED_UNKNOWN);
    setFrequency(-1);
    setMeteredHint(false);
    setEphemeral(false);
    setOsuAp(false);
    setNetworkSuggestionOrSpecifierPackageName(null);
    setFQDN(null);
    setProviderFriendlyName(null);
    txBad = 0;
    txSuccess = 0;
    rxSuccess = 0;
    txRetries = 0;
    txBadRate = 0;
    txSuccessRate = 0;
    rxSuccessRate = 0;
    txRetriesRate = 0;
    score = 0;
}
------------------------
Find a silently evolved API code:android.text.SpannableStringBuilder.equals:COMMENT
Method Modifier: public      
Comment:// Same as SpannableStringInternal

Body of Frist Method:
{
    if (o instanceof Spanned && toString().equals(o.toString())) {
        Spanned other = (Spanned) o;
        // Check span data
        Object[] otherSpans = other.getSpans(0, other.length(), Object.class);
        if (mSpanCount == otherSpans.length) {
            for (int i = 0; i < mSpanCount; ++i) {
                Object thisSpan = mSpans[i];
                Object otherSpan = otherSpans[i];
                if (thisSpan == this) {
                    if (other != otherSpan || getSpanStart(thisSpan) != other.getSpanStart(otherSpan) || getSpanEnd(thisSpan) != other.getSpanEnd(otherSpan) || getSpanFlags(thisSpan) != other.getSpanFlags(otherSpan)) {
                        return false;
                    }
                } else if (!thisSpan.equals(otherSpan) || getSpanStart(thisSpan) != other.getSpanStart(otherSpan) || getSpanEnd(thisSpan) != other.getSpanEnd(otherSpan) || getSpanFlags(thisSpan) != other.getSpanFlags(otherSpan)) {
                    return false;
                }
            }
            return true;
        }
    }
    return false;
}
Body of Second Method:
{
    if (o instanceof Spanned && toString().equals(o.toString())) {
        final Spanned other = (Spanned) o;
        // Check span data
        final Object[] otherSpans = other.getSpans(0, other.length(), Object.class);
        final Object[] thisSpans = getSpans(0, length(), Object.class);
        if (mSpanCount == otherSpans.length) {
            for (int i = 0; i < mSpanCount; ++i) {
                final Object thisSpan = thisSpans[i];
                final Object otherSpan = otherSpans[i];
                if (thisSpan == this) {
                    if (other != otherSpan || getSpanStart(thisSpan) != other.getSpanStart(otherSpan) || getSpanEnd(thisSpan) != other.getSpanEnd(otherSpan) || getSpanFlags(thisSpan) != other.getSpanFlags(otherSpan)) {
                        return false;
                    }
                } else if (!thisSpan.equals(otherSpan) || getSpanStart(thisSpan) != other.getSpanStart(otherSpan) || getSpanEnd(thisSpan) != other.getSpanEnd(otherSpan) || getSpanFlags(thisSpan) != other.getSpanFlags(otherSpan)) {
                    return false;
                }
            }
            return true;
        }
    }
    return false;
}
------------------------
Find a silently evolved API code:android.view.WindowInsets.getStableInsetLeft:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the left stable inset in pixels.
 *
 * <p>The stable inset represents the area of a full-screen window that <b>may</b> be
 * partially or fully obscured by the system UI elements.  This value does not change
 * based on the visibility state of those elements; for example, if the status bar is
 * normally shown, but temporarily hidden, the stable inset will still provide the inset
 * associated with the status bar being shown.</p>
 *
 * @return The left stable inset
 */

Body of Frist Method:
{
    return mStableInsets.left;
}
Body of Second Method:
{
    return getStableInsets().left;
}
------------------------
Find a silently evolved API code:android.hardware.camera2.CameraCharacteristics.getAvailableCaptureRequestKeys:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the list of keys supported by this {@link CameraDevice} for querying
 * with a {@link CaptureRequest}.
 *
 * <p>The list returned is not modifiable, so any attempts to modify it will throw
 * a {@code UnsupportedOperationException}.</p>
 *
 * <p>Each key is only listed once in the list. The order of the keys is undefined.</p>
 *
 * <p>Note that there is no {@code getAvailableCameraCharacteristicsKeys()} -- use
 * {@link #getKeys()} instead.</p>
 *
 * @return List of keys supported by this CameraDevice for CaptureRequests.
 */

Body of Frist Method:
{
    if (mAvailableRequestKeys == null) {
        Object crKey = CaptureRequest.Key.class;
        Class<CaptureRequest.Key<?>> crKeyTyped = (Class<CaptureRequest.Key<?>>) crKey;
        int[] filterTags = get(REQUEST_AVAILABLE_REQUEST_KEYS);
        if (filterTags == null) {
            throw new AssertionError("android.request.availableRequestKeys must be non-null " + "in the characteristics");
        }
        mAvailableRequestKeys = getAvailableKeyList(CaptureRequest.class, crKeyTyped, filterTags);
    }
    return mAvailableRequestKeys;
}
Body of Second Method:
{
    if (mAvailableRequestKeys == null) {
        Object crKey = CaptureRequest.Key.class;
        Class<CaptureRequest.Key<?>> crKeyTyped = (Class<CaptureRequest.Key<?>>) crKey;
        int[] filterTags = get(REQUEST_AVAILABLE_REQUEST_KEYS);
        if (filterTags == null) {
            throw new AssertionError("android.request.availableRequestKeys must be non-null " + "in the characteristics");
        }
        mAvailableRequestKeys = getAvailableKeyList(CaptureRequest.class, crKeyTyped, filterTags, /*includeSynthetic*/
        true);
    }
    return mAvailableRequestKeys;
}
------------------------
Find a silently evolved API code:android.view.WindowInsets.hasInsets:COMMENT
Method Modifier: public      
Comment:/**
 * Returns true if this WindowInsets has any nonzero insets.
 *
 * @return true if any inset values are nonzero
 */

Body of Frist Method:
{
    return hasSystemWindowInsets() || hasWindowDecorInsets() || hasStableInsets() || mDisplayCutout != null;
}
Body of Second Method:
{
    return !getInsets(mTypeInsetsMap, all()).equals(Insets.NONE) || !getInsets(mTypeMaxInsetsMap, all()).equals(Insets.NONE) || mDisplayCutout != null;
}
------------------------
Find a silently evolved API code:android.os.ParcelFileDescriptor.parseMode:COMMENT
Method Modifier: public      static      
Comment:/**
 * Converts a string representing a file mode, such as "rw", into a bitmask suitable for use
 * with {@link #open}.
 * <p>
 * @param mode The string representation of the file mode. Can be "r", "w", "wt", "wa", "rw"
 * or "rwt".
 * @return A bitmask representing the given file mode.
 * @throws IllegalArgumentException if the given string does not match a known file mode.
 */

Body of Frist Method:
{
    final int modeBits;
    if ("r".equals(mode)) {
        modeBits = ParcelFileDescriptor.MODE_READ_ONLY;
    } else if ("w".equals(mode) || "wt".equals(mode)) {
        modeBits = ParcelFileDescriptor.MODE_WRITE_ONLY | ParcelFileDescriptor.MODE_CREATE | ParcelFileDescriptor.MODE_TRUNCATE;
    } else if ("wa".equals(mode)) {
        modeBits = ParcelFileDescriptor.MODE_WRITE_ONLY | ParcelFileDescriptor.MODE_CREATE | ParcelFileDescriptor.MODE_APPEND;
    } else if ("rw".equals(mode)) {
        modeBits = ParcelFileDescriptor.MODE_READ_WRITE | ParcelFileDescriptor.MODE_CREATE;
    } else if ("rwt".equals(mode)) {
        modeBits = ParcelFileDescriptor.MODE_READ_WRITE | ParcelFileDescriptor.MODE_CREATE | ParcelFileDescriptor.MODE_TRUNCATE;
    } else {
        throw new IllegalArgumentException("Bad mode '" + mode + "'");
    }
    return modeBits;
}
Body of Second Method:
{
    return FileUtils.translateModePosixToPfd(FileUtils.translateModeStringToPosix(mode));
}
------------------------
Find a silently evolved API code:android.telephony.CellSignalStrengthCdma.getEvdoLevel:COMMENT
Method Modifier: public      
Comment:/**
 * Get Evdo as level 0..4
 */

Body of Frist Method:
{
    int evdoDbm = getEvdoDbm();
    int evdoSnr = getEvdoSnr();
    int levelEvdoDbm;
    int levelEvdoSnr;
    if (evdoDbm == Integer.MAX_VALUE)
        levelEvdoDbm = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    else if (evdoDbm >= -65)
        levelEvdoDbm = SIGNAL_STRENGTH_GREAT;
    else if (evdoDbm >= -75)
        levelEvdoDbm = SIGNAL_STRENGTH_GOOD;
    else if (evdoDbm >= -90)
        levelEvdoDbm = SIGNAL_STRENGTH_MODERATE;
    else if (evdoDbm >= -105)
        levelEvdoDbm = SIGNAL_STRENGTH_POOR;
    else
        levelEvdoDbm = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    if (evdoSnr == Integer.MAX_VALUE)
        levelEvdoSnr = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    else if (evdoSnr >= 7)
        levelEvdoSnr = SIGNAL_STRENGTH_GREAT;
    else if (evdoSnr >= 5)
        levelEvdoSnr = SIGNAL_STRENGTH_GOOD;
    else if (evdoSnr >= 3)
        levelEvdoSnr = SIGNAL_STRENGTH_MODERATE;
    else if (evdoSnr >= 1)
        levelEvdoSnr = SIGNAL_STRENGTH_POOR;
    else
        levelEvdoSnr = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    int level = (levelEvdoDbm < levelEvdoSnr) ? levelEvdoDbm : levelEvdoSnr;
    if (DBG)
        log("getEvdoLevel=" + level);
    return level;
}
Body of Second Method:
{
    int evdoDbm = getEvdoDbm();
    int evdoSnr = getEvdoSnr();
    int levelEvdoDbm;
    int levelEvdoSnr;
    if (evdoDbm == CellInfo.UNAVAILABLE)
        levelEvdoDbm = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    else if (evdoDbm >= -65)
        levelEvdoDbm = SIGNAL_STRENGTH_GREAT;
    else if (evdoDbm >= -75)
        levelEvdoDbm = SIGNAL_STRENGTH_GOOD;
    else if (evdoDbm >= -90)
        levelEvdoDbm = SIGNAL_STRENGTH_MODERATE;
    else if (evdoDbm >= -105)
        levelEvdoDbm = SIGNAL_STRENGTH_POOR;
    else
        levelEvdoDbm = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    if (evdoSnr == CellInfo.UNAVAILABLE)
        levelEvdoSnr = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    else if (evdoSnr >= 7)
        levelEvdoSnr = SIGNAL_STRENGTH_GREAT;
    else if (evdoSnr >= 5)
        levelEvdoSnr = SIGNAL_STRENGTH_GOOD;
    else if (evdoSnr >= 3)
        levelEvdoSnr = SIGNAL_STRENGTH_MODERATE;
    else if (evdoSnr >= 1)
        levelEvdoSnr = SIGNAL_STRENGTH_POOR;
    else
        levelEvdoSnr = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    int level = (levelEvdoDbm < levelEvdoSnr) ? levelEvdoDbm : levelEvdoSnr;
    if (DBG)
        log("getEvdoLevel=" + level);
    return level;
}
------------------------
Find a silently evolved API code:android.content.pm.PackageManager.permissionFlagToString:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * {@hide}
 */

Body of Frist Method:
{
    switch(flag) {
        case FLAG_PERMISSION_GRANTED_BY_DEFAULT:
            return "GRANTED_BY_DEFAULT";
        case FLAG_PERMISSION_POLICY_FIXED:
            return "POLICY_FIXED";
        case FLAG_PERMISSION_SYSTEM_FIXED:
            return "SYSTEM_FIXED";
        case FLAG_PERMISSION_USER_SET:
            return "USER_SET";
        case FLAG_PERMISSION_REVOKE_ON_UPGRADE:
            return "REVOKE_ON_UPGRADE";
        case FLAG_PERMISSION_USER_FIXED:
            return "USER_FIXED";
        case FLAG_PERMISSION_REVIEW_REQUIRED:
            return "REVIEW_REQUIRED";
        default:
            return Integer.toString(flag);
    }
}
Body of Second Method:
{
    switch(flag) {
        case FLAG_PERMISSION_GRANTED_BY_DEFAULT:
            return "GRANTED_BY_DEFAULT";
        case FLAG_PERMISSION_POLICY_FIXED:
            return "POLICY_FIXED";
        case FLAG_PERMISSION_SYSTEM_FIXED:
            return "SYSTEM_FIXED";
        case FLAG_PERMISSION_USER_SET:
            return "USER_SET";
        case FLAG_PERMISSION_REVOKE_ON_UPGRADE:
            return "REVOKE_ON_UPGRADE";
        case FLAG_PERMISSION_USER_FIXED:
            return "USER_FIXED";
        case FLAG_PERMISSION_REVIEW_REQUIRED:
            return "REVIEW_REQUIRED";
        case FLAG_PERMISSION_REVOKE_WHEN_REQUESTED:
            return "REVOKE_WHEN_REQUESTED";
        case FLAG_PERMISSION_USER_SENSITIVE_WHEN_GRANTED:
            return "USER_SENSITIVE_WHEN_GRANTED";
        case FLAG_PERMISSION_USER_SENSITIVE_WHEN_DENIED:
            return "USER_SENSITIVE_WHEN_DENIED";
        case FLAG_PERMISSION_RESTRICTION_INSTALLER_EXEMPT:
            return "RESTRICTION_INSTALLER_EXEMPT";
        case FLAG_PERMISSION_RESTRICTION_SYSTEM_EXEMPT:
            return "RESTRICTION_SYSTEM_EXEMPT";
        case FLAG_PERMISSION_RESTRICTION_UPGRADE_EXEMPT:
            return "RESTRICTION_UPGRADE_EXEMPT";
        case FLAG_PERMISSION_APPLY_RESTRICTION:
            return "APPLY_RESTRICTION";
        case FLAG_PERMISSION_GRANTED_BY_ROLE:
            return "GRANTED_BY_ROLE";
        default:
            return Integer.toString(flag);
    }
}
------------------------
Find a silently evolved API code:android.os.Build.getRadioVersion:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns the version string for the radio firmware.  May return
 * null (if, for instance, the radio is not currently on).
 */

Body of Frist Method:
{
    return SystemProperties.get(TelephonyProperties.PROPERTY_BASEBAND_VERSION, null);
}
Body of Second Method:
{
    String propVal = SystemProperties.get(TelephonyProperties.PROPERTY_BASEBAND_VERSION);
    return TextUtils.isEmpty(propVal) ? null : propVal;
}
------------------------
Find a silently evolved API code:android.text.Emoji.isNewEmoji:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Returns true if the character is a new emoji still not supported in our version of ICU.
 */

Body of Frist Method:
{
    // TODO: Remove once emoji-data.text 11 is in ICU or update to 11.
    if (c < 0x1F6F9 || c > 0x1F9FF) {
        // Optimization for characters outside the new emoji range.
        return false;
    }
    return c == 0x265F || c == 0x267E || c == 0x1F6F9 || c == 0x1F97A || (0x1F94D <= c && c <= 0x1F94F) || (0x1F96C <= c && c <= 0x1F970) || (0x1F973 <= c && c <= 0x1F976) || (0x1F97C <= c && c <= 0x1F97F) || (0x1F998 <= c && c <= 0x1F9A2) || (0x1F9B0 <= c && c <= 0x1F9B9) || (0x1F9C1 <= c && c <= 0x1F9C2) || (0x1F9E7 <= c && c <= 0x1F9FF);
}
Body of Second Method:
{
    // TODO: Remove once emoji-data.text 12 is in ICU or update to 12.
    if (c < 0x1F6D5 || c > 0x1FA95) {
        // Optimization for characters outside the new emoji range.
        return false;
    }
    return c == 0x1F6D5 || c == 0x1F6FA || c == 0x1F93F || c == 0x1F971 || c == 0x1F97B || (0x1F7E0 <= c && c <= 0x1F7EB) || (0x1F90D <= c && c <= 0x1F90F) || (0x1F9A5 <= c && c <= 0x1F9AA) || (0x1F9AE <= c && c <= 0x1F9AF) || (0x1F9BA <= c && c <= 0x1F9BF) || (0x1F9C3 <= c && c <= 0x1F9CA) || (0x1F9CD <= c && c <= 0x1F9CF) || (0x1FA70 <= c && c <= 0x1FA73) || (0x1FA78 <= c && c <= 0x1FA7A) || (0x1FA80 <= c && c <= 0x1FA82) || (0x1FA90 <= c && c <= 0x1FA95);
}
------------------------
Find a silently evolved API code:android.accessibilityservice.AccessibilityServiceInfo.updateDynamicallyConfigurableProperties:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Updates the properties that an AccessibilitySerivice can change dynamically.
 *
 * @param other The info from which to update the properties.
 *
 * @hide
 */

Body of Frist Method:
{
    eventTypes = other.eventTypes;
    packageNames = other.packageNames;
    feedbackType = other.feedbackType;
    notificationTimeout = other.notificationTimeout;
    flags = other.flags;
}
Body of Second Method:
{
    eventTypes = other.eventTypes;
    packageNames = other.packageNames;
    feedbackType = other.feedbackType;
    notificationTimeout = other.notificationTimeout;
    mNonInteractiveUiTimeout = other.mNonInteractiveUiTimeout;
    mInteractiveUiTimeout = other.mInteractiveUiTimeout;
    flags = other.flags;
}
------------------------
Find a silently evolved API code:android.service.notification.ConditionProviderService.requestUnbind:COMMENT
<android.service.notification.ConditionProviderService: void requestUnbind()>
public      final       ->public      final       deprecated  
Method Modifier: public      final       deprecated  
Method Modifier: Yes         Yes         No          
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * Request that the provider service be unbound.
 *
 * <p>This will no longer receive subscription updates and will not be able to update the
 * state of conditions until {@link #requestRebind(ComponentName)} is called.
 * The service will likely be killed by the system after this call.
 *
 * <p>The service should wait for the {@link #onConnected()} event before performing this
 * operation.
 */

Body of Frist Method:
{
    INotificationManager noMan = getNotificationInterface();
    try {
        noMan.requestUnbindProvider(mProvider);
        // Disable future messages.
        mProvider = null;
    } catch (RemoteException ex) {
        throw ex.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    INotificationManager noMan = getNotificationInterface();
    try {
        noMan.requestUnbindProvider(mProvider);
        // Disable future messages.
        mIsConnected = false;
    } catch (RemoteException ex) {
        throw ex.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothPbapClient.connect:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Initiate connection.
 * Upon successful connection to remote PBAP server the Client will
 * attempt to automatically download the users phonebook and call log.
 *
 * @param device a remote device we want connect to
 * @return <code>true</code> if command has been issued successfully; <code>false</code>
 * otherwise;
 */

Body of Frist Method:
{
    if (DBG) {
        log("connect(" + device + ") for PBAP Client.");
    }
    final IBluetoothPbapClient service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.connect(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null) {
        Log.w(TAG, "Proxy not attached to service");
    }
    return false;
}
Body of Second Method:
{
    if (DBG) {
        log("connect(" + device + ") for PBAP Client.");
    }
    final IBluetoothPbapClient service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.connect(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null) {
        Log.w(TAG, "Proxy not attached to service");
    }
    return false;
}
------------------------
Find a silently evolved API code:android.graphics.drawable.GradientDrawable.ensureValidRect:COMMENT
Method Modifier: private     
Comment:/**
 * This checks mGradientIsDirty, and if it is true, recomputes both our drawing
 * rectangle (mRect) and the gradient itself, since it depends on our
 * rectangle too.
 * @return true if the resulting rectangle is not empty, false otherwise
 */

Body of Frist Method:
{
    if (mGradientIsDirty) {
        mGradientIsDirty = false;
        Rect bounds = getBounds();
        float inset = 0;
        if (mStrokePaint != null) {
            inset = mStrokePaint.getStrokeWidth() * 0.5f;
        }
        final GradientState st = mGradientState;
        mRect.set(bounds.left + inset, bounds.top + inset, bounds.right - inset, bounds.bottom - inset);
        final int[] gradientColors = st.mGradientColors;
        if (gradientColors != null) {
            final RectF r = mRect;
            final float x0, x1, y0, y1;
            if (st.mGradient == LINEAR_GRADIENT) {
                final float level = st.mUseLevel ? getLevel() / 10000.0f : 1.0f;
                switch(st.mOrientation) {
                    case TOP_BOTTOM:
                        x0 = r.left;
                        y0 = r.top;
                        x1 = x0;
                        y1 = level * r.bottom;
                        break;
                    case TR_BL:
                        x0 = r.right;
                        y0 = r.top;
                        x1 = level * r.left;
                        y1 = level * r.bottom;
                        break;
                    case RIGHT_LEFT:
                        x0 = r.right;
                        y0 = r.top;
                        x1 = level * r.left;
                        y1 = y0;
                        break;
                    case BR_TL:
                        x0 = r.right;
                        y0 = r.bottom;
                        x1 = level * r.left;
                        y1 = level * r.top;
                        break;
                    case BOTTOM_TOP:
                        x0 = r.left;
                        y0 = r.bottom;
                        x1 = x0;
                        y1 = level * r.top;
                        break;
                    case BL_TR:
                        x0 = r.left;
                        y0 = r.bottom;
                        x1 = level * r.right;
                        y1 = level * r.top;
                        break;
                    case LEFT_RIGHT:
                        x0 = r.left;
                        y0 = r.top;
                        x1 = level * r.right;
                        y1 = y0;
                        break;
                    default:
                        /* TL_BR */
                        x0 = r.left;
                        y0 = r.top;
                        x1 = level * r.right;
                        y1 = level * r.bottom;
                        break;
                }
                mFillPaint.setShader(new LinearGradient(x0, y0, x1, y1, gradientColors, st.mPositions, Shader.TileMode.CLAMP));
            } else if (st.mGradient == RADIAL_GRADIENT) {
                x0 = r.left + (r.right - r.left) * st.mCenterX;
                y0 = r.top + (r.bottom - r.top) * st.mCenterY;
                float radius = st.mGradientRadius;
                if (st.mGradientRadiusType == RADIUS_TYPE_FRACTION) {
                    // Fall back to parent width or height if intrinsic
                    // size is not specified.
                    final float width = st.mWidth >= 0 ? st.mWidth : r.width();
                    final float height = st.mHeight >= 0 ? st.mHeight : r.height();
                    radius *= Math.min(width, height);
                } else if (st.mGradientRadiusType == RADIUS_TYPE_FRACTION_PARENT) {
                    radius *= Math.min(r.width(), r.height());
                }
                if (st.mUseLevel) {
                    radius *= getLevel() / 10000.0f;
                }
                mGradientRadius = radius;
                if (radius <= 0) {
                    // We can't have a shader with non-positive radius, so
                    // let's have a very, very small radius.
                    radius = 0.001f;
                }
                mFillPaint.setShader(new RadialGradient(x0, y0, radius, gradientColors, null, Shader.TileMode.CLAMP));
            } else if (st.mGradient == SWEEP_GRADIENT) {
                x0 = r.left + (r.right - r.left) * st.mCenterX;
                y0 = r.top + (r.bottom - r.top) * st.mCenterY;
                int[] tempColors = gradientColors;
                float[] tempPositions = null;
                if (st.mUseLevel) {
                    tempColors = st.mTempColors;
                    final int length = gradientColors.length;
                    if (tempColors == null || tempColors.length != length + 1) {
                        tempColors = st.mTempColors = new int[length + 1];
                    }
                    System.arraycopy(gradientColors, 0, tempColors, 0, length);
                    tempColors[length] = gradientColors[length - 1];
                    tempPositions = st.mTempPositions;
                    final float fraction = 1.0f / (length - 1);
                    if (tempPositions == null || tempPositions.length != length + 1) {
                        tempPositions = st.mTempPositions = new float[length + 1];
                    }
                    final float level = getLevel() / 10000.0f;
                    for (int i = 0; i < length; i++) {
                        tempPositions[i] = i * fraction * level;
                    }
                    tempPositions[length] = 1.0f;
                }
                mFillPaint.setShader(new SweepGradient(x0, y0, tempColors, tempPositions));
            }
            // maxed out so that alpha modulation works correctly.
            if (st.mSolidColors == null) {
                mFillPaint.setColor(Color.BLACK);
            }
        }
    }
    return !mRect.isEmpty();
}
Body of Second Method:
{
    if (mGradientIsDirty) {
        mGradientIsDirty = false;
        Rect bounds = getBounds();
        float inset = 0;
        if (mStrokePaint != null) {
            inset = mStrokePaint.getStrokeWidth() * 0.5f;
        }
        final GradientState st = mGradientState;
        mRect.set(bounds.left + inset, bounds.top + inset, bounds.right - inset, bounds.bottom - inset);
        final int[] gradientColors = st.mGradientColors;
        if (gradientColors != null) {
            final RectF r = mRect;
            final float x0, x1, y0, y1;
            if (st.mGradient == LINEAR_GRADIENT) {
                final float level = st.mUseLevel ? getLevel() / 10000.0f : 1.0f;
                switch(st.getOrientation()) {
                    case TOP_BOTTOM:
                        x0 = r.left;
                        y0 = r.top;
                        x1 = x0;
                        y1 = level * r.bottom;
                        break;
                    case TR_BL:
                        x0 = r.right;
                        y0 = r.top;
                        x1 = level * r.left;
                        y1 = level * r.bottom;
                        break;
                    case RIGHT_LEFT:
                        x0 = r.right;
                        y0 = r.top;
                        x1 = level * r.left;
                        y1 = y0;
                        break;
                    case BR_TL:
                        x0 = r.right;
                        y0 = r.bottom;
                        x1 = level * r.left;
                        y1 = level * r.top;
                        break;
                    case BOTTOM_TOP:
                        x0 = r.left;
                        y0 = r.bottom;
                        x1 = x0;
                        y1 = level * r.top;
                        break;
                    case BL_TR:
                        x0 = r.left;
                        y0 = r.bottom;
                        x1 = level * r.right;
                        y1 = level * r.top;
                        break;
                    case LEFT_RIGHT:
                        x0 = r.left;
                        y0 = r.top;
                        x1 = level * r.right;
                        y1 = y0;
                        break;
                    default:
                        /* TL_BR */
                        x0 = r.left;
                        y0 = r.top;
                        x1 = level * r.right;
                        y1 = level * r.bottom;
                        break;
                }
                mFillPaint.setShader(new LinearGradient(x0, y0, x1, y1, gradientColors, st.mPositions, Shader.TileMode.CLAMP));
            } else if (st.mGradient == RADIAL_GRADIENT) {
                x0 = r.left + (r.right - r.left) * st.mCenterX;
                y0 = r.top + (r.bottom - r.top) * st.mCenterY;
                float radius = st.mGradientRadius;
                if (st.mGradientRadiusType == RADIUS_TYPE_FRACTION) {
                    // Fall back to parent width or height if intrinsic
                    // size is not specified.
                    final float width = st.mWidth >= 0 ? st.mWidth : r.width();
                    final float height = st.mHeight >= 0 ? st.mHeight : r.height();
                    radius *= Math.min(width, height);
                } else if (st.mGradientRadiusType == RADIUS_TYPE_FRACTION_PARENT) {
                    radius *= Math.min(r.width(), r.height());
                }
                if (st.mUseLevel) {
                    radius *= getLevel() / 10000.0f;
                }
                mGradientRadius = radius;
                if (radius <= 0) {
                    // We can't have a shader with non-positive radius, so
                    // let's have a very, very small radius.
                    radius = 0.001f;
                }
                mFillPaint.setShader(new RadialGradient(x0, y0, radius, gradientColors, null, Shader.TileMode.CLAMP));
            } else if (st.mGradient == SWEEP_GRADIENT) {
                x0 = r.left + (r.right - r.left) * st.mCenterX;
                y0 = r.top + (r.bottom - r.top) * st.mCenterY;
                int[] tempColors = gradientColors;
                float[] tempPositions = null;
                if (st.mUseLevel) {
                    tempColors = st.mTempColors;
                    final int length = gradientColors.length;
                    if (tempColors == null || tempColors.length != length + 1) {
                        tempColors = st.mTempColors = new int[length + 1];
                    }
                    System.arraycopy(gradientColors, 0, tempColors, 0, length);
                    tempColors[length] = gradientColors[length - 1];
                    tempPositions = st.mTempPositions;
                    final float fraction = 1.0f / (length - 1);
                    if (tempPositions == null || tempPositions.length != length + 1) {
                        tempPositions = st.mTempPositions = new float[length + 1];
                    }
                    final float level = getLevel() / 10000.0f;
                    for (int i = 0; i < length; i++) {
                        tempPositions[i] = i * fraction * level;
                    }
                    tempPositions[length] = 1.0f;
                }
                mFillPaint.setShader(new SweepGradient(x0, y0, tempColors, tempPositions));
            }
            // maxed out so that alpha modulation works correctly.
            if (st.mSolidColors == null) {
                mFillPaint.setColor(Color.BLACK);
            }
        }
    }
    return !mRect.isEmpty();
}
------------------------
Find a silently evolved API code:android.hardware.camera2.legacy.SurfaceTextureRenderer.configureSurfaces:COMMENT
Method Modifier: public      
Comment:/**
 * Set a collection of output {@link Surface}s that can be drawn to.
 *
 * @param surfaces a {@link Collection} of surfaces.
 */

Body of Frist Method:
{
    releaseEGLContext();
    if (surfaces == null || surfaces.size() == 0) {
        Log.w(TAG, "No output surfaces configured for GL drawing.");
        return;
    }
    for (Pair<Surface, Size> p : surfaces) {
        Surface s = p.first;
        Size surfaceSize = p.second;
        // If pixel conversions aren't handled by egl, use a pbuffer
        try {
            EGLSurfaceHolder holder = new EGLSurfaceHolder();
            holder.surface = s;
            holder.width = surfaceSize.getWidth();
            holder.height = surfaceSize.getHeight();
            if (LegacyCameraDevice.needsConversion(s)) {
                mConversionSurfaces.add(holder);
                // LegacyCameraDevice is the producer of surfaces if it's not handled by EGL,
                // so LegacyCameraDevice needs to connect to the surfaces.
                LegacyCameraDevice.connectSurface(s);
            } else {
                mSurfaces.add(holder);
            }
        } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
            Log.w(TAG, "Surface abandoned, skipping configuration... ", e);
        }
    }
    // Set up egl display
    configureEGLContext();
    // Set up regular egl surfaces if needed
    if (mSurfaces.size() > 0) {
        configureEGLOutputSurfaces(mSurfaces);
    }
    // Set up pbuffer surface if needed
    if (mConversionSurfaces.size() > 0) {
        configureEGLPbufferSurfaces(mConversionSurfaces);
    }
    makeCurrent((mSurfaces.size() > 0) ? mSurfaces.get(0).eglSurface : mConversionSurfaces.get(0).eglSurface);
    initializeGLState();
    mSurfaceTexture = new SurfaceTexture(getTextureId());
    // Set up performance tracking if enabled
    if (SystemProperties.getBoolean(LEGACY_PERF_PROPERTY, false)) {
        setupGlTiming();
    }
}
Body of Second Method:
{
    releaseEGLContext();
    if (surfaces == null || surfaces.size() == 0) {
        Log.w(TAG, "No output surfaces configured for GL drawing.");
        return;
    }
    for (Pair<Surface, Size> p : surfaces) {
        Surface s = p.first;
        Size surfaceSize = p.second;
        // If pixel conversions aren't handled by egl, use a pbuffer
        try {
            EGLSurfaceHolder holder = new EGLSurfaceHolder();
            holder.surface = s;
            holder.width = surfaceSize.getWidth();
            holder.height = surfaceSize.getHeight();
            if (LegacyCameraDevice.needsConversion(s)) {
                mConversionSurfaces.add(holder);
                // LegacyCameraDevice is the producer of surfaces if it's not handled by EGL,
                // so LegacyCameraDevice needs to connect to the surfaces.
                LegacyCameraDevice.connectSurface(s);
            } else {
                mSurfaces.add(holder);
            }
        } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
            Log.w(TAG, "Surface abandoned, skipping configuration... ", e);
        }
    }
    // Set up egl display
    configureEGLContext();
    // Set up regular egl surfaces if needed
    if (mSurfaces.size() > 0) {
        configureEGLOutputSurfaces(mSurfaces);
    }
    // Set up pbuffer surface if needed
    if (mConversionSurfaces.size() > 0) {
        configureEGLPbufferSurfaces(mConversionSurfaces);
    }
    try {
        makeCurrent((mSurfaces.size() > 0) ? mSurfaces.get(0).eglSurface : mConversionSurfaces.get(0).eglSurface);
    } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
        Log.w(TAG, "Surface abandoned, skipping configuration... ", e);
    }
    initializeGLState();
    mSurfaceTexture = new SurfaceTexture(getTextureId());
    // Set up performance tracking if enabled
    if (SystemProperties.getBoolean(LEGACY_PERF_PROPERTY, false)) {
        setupGlTiming();
    }
}
------------------------
Find a silently evolved API code:android.database.sqlite.SQLiteGlobal.getDefaultSyncMode:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Gets the default database synchronization mode when WAL is not in use.
 */

Body of Frist Method:
{
    return SystemProperties.get("debug.sqlite.syncmode", Resources.getSystem().getString(com.android.internal.R.string.db_default_sync_mode));
}
Body of Second Method:
{
    // Use the FULL synchronous mode for system processes by default.
    String defaultMode = sDefaultSyncMode;
    if (defaultMode != null) {
        return defaultMode;
    }
    return SystemProperties.get("debug.sqlite.syncmode", Resources.getSystem().getString(com.android.internal.R.string.db_default_sync_mode));
}
------------------------
Find a silently evolved API code:android.media.session.MediaController.dispatchMediaButtonEvent:COMMENT
Method Modifier: public      
Comment:/**
 * Send the specified media button event to the session. Only media keys can
 * be sent by this method, other keys will be ignored.
 *
 * @param keyEvent The media button event to dispatch.
 * @return true if the event was sent to the session, false otherwise.
 */

Body of Frist Method:
{
    return dispatchMediaButtonEventInternal(false, keyEvent);
}
Body of Second Method:
{
    if (keyEvent == null) {
        throw new IllegalArgumentException("KeyEvent may not be null");
    }
    if (!KeyEvent.isMediaSessionKey(keyEvent.getKeyCode())) {
        return false;
    }
    try {
        return mSessionBinder.sendMediaButton(mContext.getPackageName(), mCbStub, keyEvent);
    } catch (RemoteException e) {
    // System is dead. =(
    }
    return false;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothA2dp.setPriority:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Set priority of the profile
 *
 * <p> The device should already be paired.
 * Priority can be one of {@link #PRIORITY_ON} orgetBluetoothManager
 * {@link #PRIORITY_OFF},
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}
 * permission.
 *
 * @param device Paired bluetooth device
 * @param priority
 * @return true if priority is set, false on error
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("setPriority(" + device + ", " + priority + ")");
    try {
        mServiceLock.readLock().lock();
        if (mService != null && isEnabled() && isValidDevice(device)) {
            if (priority != BluetoothProfile.PRIORITY_OFF && priority != BluetoothProfile.PRIORITY_ON) {
                return false;
            }
            return mService.setPriority(device, priority);
        }
        if (mService == null)
            Log.w(TAG, "Proxy not attached to service");
        return false;
    } catch (RemoteException e) {
        Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
        return false;
    } finally {
        mServiceLock.readLock().unlock();
    }
}
Body of Second Method:
{
    if (DBG)
        log("setPriority(" + device + ", " + priority + ")");
    try {
        final IBluetoothA2dp service = getService();
        if (service != null && isEnabled() && isValidDevice(device)) {
            if (priority != BluetoothProfile.PRIORITY_OFF && priority != BluetoothProfile.PRIORITY_ON) {
                return false;
            }
            return service.setPriority(device, priority);
        }
        if (service == null)
            Log.w(TAG, "Proxy not attached to service");
        return false;
    } catch (RemoteException e) {
        Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
        return false;
    }
}
------------------------
Find a silently evolved API code:android.view.animation.Animation.setListenerHandler:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets the handler used to invoke listeners.
 *
 * @hide
 */

Body of Frist Method:
{
    if (mListenerHandler == null) {
        mOnStart = new Runnable() {

            public void run() {
                if (mListener != null) {
                    mListener.onAnimationStart(Animation.this);
                }
            }
        };
        mOnRepeat = new Runnable() {

            public void run() {
                if (mListener != null) {
                    mListener.onAnimationRepeat(Animation.this);
                }
            }
        };
        mOnEnd = new Runnable() {

            public void run() {
                if (mListener != null) {
                    mListener.onAnimationEnd(Animation.this);
                }
            }
        };
    }
    mListenerHandler = handler;
}
Body of Second Method:
{
    if (mListenerHandler == null) {
        mOnStart = new Runnable() {

            public void run() {
                dispatchAnimationStart();
            }
        };
        mOnRepeat = new Runnable() {

            public void run() {
                dispatchAnimationRepeat();
            }
        };
        mOnEnd = new Runnable() {

            public void run() {
                dispatchAnimationEnd();
            }
        };
    }
    mListenerHandler = handler;
}
------------------------
Find a silently evolved API code:android.content.pm.PermissionInfo.protectionToString:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    String protLevel = "????";
    switch(level & PROTECTION_MASK_BASE) {
        case PermissionInfo.PROTECTION_DANGEROUS:
            protLevel = "dangerous";
            break;
        case PermissionInfo.PROTECTION_NORMAL:
            protLevel = "normal";
            break;
        case PermissionInfo.PROTECTION_SIGNATURE:
            protLevel = "signature";
            break;
        case PermissionInfo.PROTECTION_SIGNATURE_OR_SYSTEM:
            protLevel = "signatureOrSystem";
            break;
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_PRIVILEGED) != 0) {
        protLevel += "|privileged";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_DEVELOPMENT) != 0) {
        protLevel += "|development";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_APPOP) != 0) {
        protLevel += "|appop";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_PRE23) != 0) {
        protLevel += "|pre23";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_INSTALLER) != 0) {
        protLevel += "|installer";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_VERIFIER) != 0) {
        protLevel += "|verifier";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_PREINSTALLED) != 0) {
        protLevel += "|preinstalled";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_SETUP) != 0) {
        protLevel += "|setup";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_INSTANT) != 0) {
        protLevel += "|instant";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_RUNTIME_ONLY) != 0) {
        protLevel += "|runtime";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_OEM) != 0) {
        protLevel += "|oem";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_VENDOR_PRIVILEGED) != 0) {
        protLevel += "|vendorPrivileged";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_SYSTEM_TEXT_CLASSIFIER) != 0) {
        protLevel += "|textClassifier";
    }
    return protLevel;
}
Body of Second Method:
{
    String protLevel = "????";
    switch(level & PROTECTION_MASK_BASE) {
        case PermissionInfo.PROTECTION_DANGEROUS:
            protLevel = "dangerous";
            break;
        case PermissionInfo.PROTECTION_NORMAL:
            protLevel = "normal";
            break;
        case PermissionInfo.PROTECTION_SIGNATURE:
            protLevel = "signature";
            break;
        case PermissionInfo.PROTECTION_SIGNATURE_OR_SYSTEM:
            protLevel = "signatureOrSystem";
            break;
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_PRIVILEGED) != 0) {
        protLevel += "|privileged";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_DEVELOPMENT) != 0) {
        protLevel += "|development";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_APPOP) != 0) {
        protLevel += "|appop";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_PRE23) != 0) {
        protLevel += "|pre23";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_INSTALLER) != 0) {
        protLevel += "|installer";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_VERIFIER) != 0) {
        protLevel += "|verifier";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_PREINSTALLED) != 0) {
        protLevel += "|preinstalled";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_SETUP) != 0) {
        protLevel += "|setup";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_INSTANT) != 0) {
        protLevel += "|instant";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_RUNTIME_ONLY) != 0) {
        protLevel += "|runtime";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_OEM) != 0) {
        protLevel += "|oem";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_VENDOR_PRIVILEGED) != 0) {
        protLevel += "|vendorPrivileged";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_SYSTEM_TEXT_CLASSIFIER) != 0) {
        protLevel += "|textClassifier";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_WELLBEING) != 0) {
        protLevel += "|wellbeing";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_DOCUMENTER) != 0) {
        protLevel += "|documenter";
    }
    if ((level & PROTECTION_FLAG_CONFIGURATOR) != 0) {
        protLevel += "|configurator";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_INCIDENT_REPORT_APPROVER) != 0) {
        protLevel += "|incidentReportApprover";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_APP_PREDICTOR) != 0) {
        protLevel += "|appPredictor";
    }
    return protLevel;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.dial:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Places a call with specified number.
 *
 * @param device remote device
 * @param number valid phone number
 * @return <code>{@link BluetoothHeadsetClientCall} call</code> if command has been issued
 * successfully; <code>{@link null}</code> otherwise; upon completion HFP sends {@link
 * #ACTION_CALL_CHANGED} intent in case of success; {@link #ACTION_RESULT} is sent otherwise;
 */

Body of Frist Method:
{
    if (DBG)
        log("dial()");
    final IBluetoothHeadsetClient service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.dial(device, number);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return null;
}
Body of Second Method:
{
    if (DBG)
        log("dial()");
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.dial(device, number);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return null;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHidHost.virtualUnplug:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Initiate virtual unplug for a HID input device.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN} permission.
 *
 * @param device Remote Bluetooth Device
 * @return false on immediate error, true otherwise
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("virtualUnplug(" + device + ")");
    final IBluetoothHidHost service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.virtualUnplug(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("virtualUnplug(" + device + ")");
    final IBluetoothHidHost service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.virtualUnplug(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.util.StatsLog.logStart:COMMENT
Method Modifier: public      static      
Comment:/**
 * Logs a start event.
 *
 * @param label developer-chosen label.
 * @return True if the log request was sent to statsd.
 */

Body of Frist Method:
{
    synchronized (StatsLog.class) {
        try {
            IStatsManager service = getIStatsManagerLocked();
            if (service == null) {
                if (DEBUG)
                    Slog.d(TAG, "Failed to find statsd when logging start");
                return false;
            }
            service.sendAppBreadcrumbAtom(label, StatsLog.APP_BREADCRUMB_REPORTED__STATE__START);
            return true;
        } catch (RemoteException e) {
            sService = null;
            if (DEBUG)
                Slog.d(TAG, "Failed to connect to statsd when logging start");
            return false;
        }
    }
}
Body of Second Method:
{
    synchronized (sLogLock) {
        try {
            IStatsManager service = getIStatsManagerLocked();
            if (service == null) {
                if (DEBUG) {
                    Slog.d(TAG, "Failed to find statsd when logging start");
                }
                return false;
            }
            service.sendAppBreadcrumbAtom(label, StatsLog.APP_BREADCRUMB_REPORTED__STATE__START);
            return true;
        } catch (RemoteException e) {
            sService = null;
            if (DEBUG) {
                Slog.d(TAG, "Failed to connect to statsd when logging start");
            }
            return false;
        }
    }
}
------------------------
Find a silently evolved API code:android.util.Xml.newSerializer:COMMENT
Method Modifier: public      static      
Comment:/**
 * Creates a new xml serializer.
 */

Body of Frist Method:
{
    try {
        return XmlSerializerFactory.instance.newSerializer();
    } catch (XmlPullParserException e) {
        throw new AssertionError(e);
    }
}
Body of Second Method:
{
    return XmlObjectFactory.newXmlSerializer();
}
------------------------
Find a silently evolved API code:android.widget.Switch.setTrackTintMode:COMMENT
Method Modifier: public      
Comment:/**
 * Specifies the blending mode used to apply the tint specified by
 * {@link #setTrackTintList(ColorStateList)}} to the track drawable.
 * The default mode is {@link PorterDuff.Mode#SRC_IN}.
 *
 * @param tintMode the blending mode used to apply the tint, may be
 * {@code null} to clear tint
 * @attr ref android.R.styleable#Switch_trackTintMode
 * @see #getTrackTintMode()
 * @see Drawable#setTintMode(PorterDuff.Mode)
 */

Body of Frist Method:
{
    mTrackTintMode = tintMode;
    mHasTrackTintMode = true;
    applyTrackTint();
}
Body of Second Method:
{
    setTrackTintBlendMode(tintMode != null ? BlendMode.fromValue(tintMode.nativeInt) : null);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHidHost.disconnect:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Initiate disconnection from a profile
 *
 * <p> This API will return false in scenarios like the profile on the
 * Bluetooth device is not in connected state etc. When this API returns,
 * true, it is guaranteed that the connection state change
 * intent will be broadcasted with the state. Users can get the
 * disconnection state of the profile from this intent.
 *
 * <p> If the disconnection is initiated by a remote device, the state
 * will transition from {@link #STATE_CONNECTED} to
 * {@link #STATE_DISCONNECTED}. If the disconnect is initiated by the
 * host (local) device the state will transition from
 * {@link #STATE_CONNECTED} to state {@link #STATE_DISCONNECTING} to
 * state {@link #STATE_DISCONNECTED}. The transition to
 * {@link #STATE_DISCONNECTING} can be used to distinguish between the
 * two scenarios.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}
 * permission.
 *
 * @param device Remote Bluetooth Device
 * @return false on immediate error, true otherwise
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("disconnect(" + device + ")");
    final IBluetoothHidHost service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.disconnect(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("disconnect(" + device + ")");
    final IBluetoothHidHost service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.disconnect(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.media.PlayerBase.updateAppOpsPlayAudio_sync:COMMENT
Method Modifier: default     hidden      
Comment:/**
 * To be called whenever a condition that might affect audibility of this player is updated.
 * Must be called synchronized on mLock.
 */

Body of Frist Method:
{
    boolean oldHasAppOpsPlayAudio = mHasAppOpsPlayAudio;
    try {
        int mode = AppOpsManager.MODE_IGNORED;
        if (mAppOps != null) {
            mode = mAppOps.checkAudioOperation(AppOpsManager.OP_PLAY_AUDIO, mAttributes.getUsage(), Process.myUid(), ActivityThread.currentPackageName());
        }
        mHasAppOpsPlayAudio = (mode == AppOpsManager.MODE_ALLOWED);
    } catch (RemoteException e) {
        mHasAppOpsPlayAudio = false;
    }
    // volume used by the player
    try {
        if (oldHasAppOpsPlayAudio != mHasAppOpsPlayAudio || attributesChanged) {
            getService().playerHasOpPlayAudio(mPlayerIId, mHasAppOpsPlayAudio);
            if (!isRestricted_sync()) {
                if (DEBUG_APP_OPS) {
                    Log.v(TAG, "updateAppOpsPlayAudio: unmuting player, vol=" + mLeftVolume + "/" + mRightVolume);
                }
                playerSetVolume(false, /*muting*/
                mLeftVolume * mPanMultiplierL, mRightVolume * mPanMultiplierR);
                playerSetAuxEffectSendLevel(false, /*muting*/
                mAuxEffectSendLevel);
            } else {
                if (DEBUG_APP_OPS) {
                    Log.v(TAG, "updateAppOpsPlayAudio: muting player");
                }
                playerSetVolume(true, /*muting*/
                0.0f, 0.0f);
                playerSetAuxEffectSendLevel(true, /*muting*/
                0.0f);
            }
        }
    } catch (Exception e) {
    // failing silently, player might not be in right state
    }
}
Body of Second Method:
{
    if (USE_AUDIOFLINGER_MUTING_FOR_OP) {
        return;
    }
    boolean oldHasAppOpsPlayAudio = mHasAppOpsPlayAudio;
    try {
        int mode = AppOpsManager.MODE_IGNORED;
        if (mAppOps != null) {
            mode = mAppOps.checkAudioOperation(AppOpsManager.OP_PLAY_AUDIO, mAttributes.getUsage(), Process.myUid(), ActivityThread.currentPackageName());
        }
        mHasAppOpsPlayAudio = (mode == AppOpsManager.MODE_ALLOWED);
    } catch (RemoteException e) {
        mHasAppOpsPlayAudio = false;
    }
    // volume used by the player
    try {
        if (oldHasAppOpsPlayAudio != mHasAppOpsPlayAudio || attributesChanged) {
            getService().playerHasOpPlayAudio(mPlayerIId, mHasAppOpsPlayAudio);
            if (!isRestricted_sync()) {
                if (DEBUG_APP_OPS) {
                    Log.v(TAG, "updateAppOpsPlayAudio: unmuting player, vol=" + mLeftVolume + "/" + mRightVolume);
                }
                playerSetVolume(false, /*muting*/
                mLeftVolume * mPanMultiplierL, mRightVolume * mPanMultiplierR);
                playerSetAuxEffectSendLevel(false, /*muting*/
                mAuxEffectSendLevel);
            } else {
                if (DEBUG_APP_OPS) {
                    Log.v(TAG, "updateAppOpsPlayAudio: muting player");
                }
                playerSetVolume(true, /*muting*/
                0.0f, 0.0f);
                playerSetAuxEffectSendLevel(true, /*muting*/
                0.0f);
            }
        }
    } catch (Exception e) {
    // failing silently, player might not be in right state
    }
}
------------------------
Find a silently evolved API code:android.net.LinkAddress.isGlobalPreferred:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns true if this {@code LinkAddress} is global scope and preferred.
 * @hide
 */

Body of Frist Method:
{
    /**
     * Note that addresses flagged as IFA_F_OPTIMISTIC are
     * simultaneously flagged as IFA_F_TENTATIVE (when the tentative
     * state has cleared either DAD has succeeded or failed, and both
     * flags are cleared regardless).
     */
    return (scope == RT_SCOPE_UNIVERSE && !isIPv6ULA() && (flags & (IFA_F_DADFAILED | IFA_F_DEPRECATED)) == 0L && ((flags & IFA_F_TENTATIVE) == 0L || (flags & IFA_F_OPTIMISTIC) != 0L));
}
Body of Second Method:
{
    /**
     * Note that addresses flagged as IFA_F_OPTIMISTIC are
     * simultaneously flagged as IFA_F_TENTATIVE (when the tentative
     * state has cleared either DAD has succeeded or failed, and both
     * flags are cleared regardless).
     */
    return (scope == RT_SCOPE_UNIVERSE && !isIpv6ULA() && (flags & (IFA_F_DADFAILED | IFA_F_DEPRECATED)) == 0L && ((flags & IFA_F_TENTATIVE) == 0L || (flags & IFA_F_OPTIMISTIC) != 0L));
}
------------------------
Find a silently evolved API code:android.bluetooth.le.ScanFilter.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Build {@link ScanFilter}.
 *
 * @throws IllegalArgumentException If the filter cannot be built.
 */

Body of Frist Method:
{
    return new ScanFilter(mDeviceName, mDeviceAddress, mServiceUuid, mUuidMask, mServiceDataUuid, mServiceData, mServiceDataMask, mManufacturerId, mManufacturerData, mManufacturerDataMask);
}
Body of Second Method:
{
    return new ScanFilter(mDeviceName, mDeviceAddress, mServiceUuid, mUuidMask, mServiceSolicitationUuid, mServiceSolicitationUuidMask, mServiceDataUuid, mServiceData, mServiceDataMask, mManufacturerId, mManufacturerData, mManufacturerDataMask);
}
------------------------
Find a silently evolved API code:android.app.Instrumentation.execStartActivityAsCaller:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Special version!
 * @hide
 */

Body of Frist Method:
{
    IApplicationThread whoThread = (IApplicationThread) contextThread;
    if (mActivityMonitors != null) {
        synchronized (mSync) {
            final int N = mActivityMonitors.size();
            for (int i = 0; i < N; i++) {
                final ActivityMonitor am = mActivityMonitors.get(i);
                ActivityResult result = null;
                if (am.ignoreMatchingSpecificIntents()) {
                    result = am.onStartActivity(intent);
                }
                if (result != null) {
                    am.mHits++;
                    return result;
                } else if (am.match(who, null, intent)) {
                    am.mHits++;
                    if (am.isBlocking()) {
                        return requestCode >= 0 ? am.getResult() : null;
                    }
                    break;
                }
            }
        }
    }
    try {
        intent.migrateExtraStreamToClipData();
        intent.prepareToLeaveProcess(who);
        int result = ActivityManager.getService().startActivityAsCaller(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options, ignoreTargetSecurity, userId);
        checkStartActivityResult(result, intent);
    } catch (RemoteException e) {
        throw new RuntimeException("Failure from system", e);
    }
    return null;
}
Body of Second Method:
{
    IApplicationThread whoThread = (IApplicationThread) contextThread;
    if (mActivityMonitors != null) {
        synchronized (mSync) {
            final int N = mActivityMonitors.size();
            for (int i = 0; i < N; i++) {
                final ActivityMonitor am = mActivityMonitors.get(i);
                ActivityResult result = null;
                if (am.ignoreMatchingSpecificIntents()) {
                    result = am.onStartActivity(intent);
                }
                if (result != null) {
                    am.mHits++;
                    return result;
                } else if (am.match(who, null, intent)) {
                    am.mHits++;
                    if (am.isBlocking()) {
                        return requestCode >= 0 ? am.getResult() : null;
                    }
                    break;
                }
            }
        }
    }
    try {
        intent.migrateExtraStreamToClipData();
        intent.prepareToLeaveProcess(who);
        int result = ActivityTaskManager.getService().startActivityAsCaller(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options, permissionToken, ignoreTargetSecurity, userId);
        checkStartActivityResult(result, intent);
    } catch (RemoteException e) {
        throw new RuntimeException("Failure from system", e);
    }
    return null;
}
------------------------
Find a silently evolved API code:android.view.ViewPropertyAnimator.getValue:COMMENT
Method Modifier: private     
Comment:/**
 * This method gets the value of the named property from the View object.
 *
 * @param propertyConstant The property whose value should be returned
 * @return float The value of the named property
 */

Body of Frist Method:
{
    final RenderNode node = mView.mRenderNode;
    switch(propertyConstant) {
        case TRANSLATION_X:
            return node.getTranslationX();
        case TRANSLATION_Y:
            return node.getTranslationY();
        case TRANSLATION_Z:
            return node.getTranslationZ();
        case ROTATION:
            return node.getRotation();
        case ROTATION_X:
            return node.getRotationX();
        case ROTATION_Y:
            return node.getRotationY();
        case SCALE_X:
            return node.getScaleX();
        case SCALE_Y:
            return node.getScaleY();
        case X:
            return mView.mLeft + node.getTranslationX();
        case Y:
            return mView.mTop + node.getTranslationY();
        case Z:
            return node.getElevation() + node.getTranslationZ();
        case ALPHA:
            return mView.mTransformationInfo.mAlpha;
    }
    return 0;
}
Body of Second Method:
{
    final RenderNode node = mView.mRenderNode;
    switch(propertyConstant) {
        case TRANSLATION_X:
            return node.getTranslationX();
        case TRANSLATION_Y:
            return node.getTranslationY();
        case TRANSLATION_Z:
            return node.getTranslationZ();
        case ROTATION:
            return node.getRotationZ();
        case ROTATION_X:
            return node.getRotationX();
        case ROTATION_Y:
            return node.getRotationY();
        case SCALE_X:
            return node.getScaleX();
        case SCALE_Y:
            return node.getScaleY();
        case X:
            return mView.mLeft + node.getTranslationX();
        case Y:
            return mView.mTop + node.getTranslationY();
        case Z:
            return node.getElevation() + node.getTranslationZ();
        case ALPHA:
            return mView.getAlpha();
    }
    return 0;
}
------------------------
Find a silently evolved API code:android.widget.CheckedTextView.setCheckMarkTintMode:COMMENT
Method Modifier: public      
Comment:/**
 * Specifies the blending mode used to apply the tint specified by
 * {@link #setCheckMarkTintList(ColorStateList)} to the check mark
 * drawable. The default mode is {@link PorterDuff.Mode#SRC_IN}.
 *
 * @param tintMode the blending mode used to apply the tint, may be
 * {@code null} to clear tint
 * @attr ref android.R.styleable#CheckedTextView_checkMarkTintMode
 * @see #setCheckMarkTintList(ColorStateList)
 * @see Drawable#setTintMode(PorterDuff.Mode)
 */

Body of Frist Method:
{
    mCheckMarkTintMode = tintMode;
    mHasCheckMarkTintMode = true;
    applyCheckMarkTint();
}
Body of Second Method:
{
    setCheckMarkTintBlendMode(tintMode != null ? BlendMode.fromValue(tintMode.nativeInt) : null);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothA2dp.supportsOptionalCodecs:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns whether this device supports optional codecs.
 *
 * @param device The device to check
 * @return one of OPTIONAL_CODECS_SUPPORT_UNKNOWN, OPTIONAL_CODECS_NOT_SUPPORTED, or
 * OPTIONAL_CODECS_SUPPORTED.
 * @hide
 */

Body of Frist Method:
{
    try {
        mServiceLock.readLock().lock();
        if (mService != null && isEnabled() && isValidDevice(device)) {
            return mService.supportsOptionalCodecs(device);
        }
        if (mService == null)
            Log.w(TAG, "Proxy not attached to service");
        return OPTIONAL_CODECS_SUPPORT_UNKNOWN;
    } catch (RemoteException e) {
        Log.e(TAG, "Error talking to BT service in getSupportsOptionalCodecs()", e);
        return OPTIONAL_CODECS_SUPPORT_UNKNOWN;
    } finally {
        mServiceLock.readLock().unlock();
    }
}
Body of Second Method:
{
    try {
        final IBluetoothA2dp service = getService();
        if (service != null && isEnabled() && isValidDevice(device)) {
            return service.supportsOptionalCodecs(device);
        }
        if (service == null)
            Log.w(TAG, "Proxy not attached to service");
        return OPTIONAL_CODECS_SUPPORT_UNKNOWN;
    } catch (RemoteException e) {
        Log.e(TAG, "Error talking to BT service in getSupportsOptionalCodecs()", e);
        return OPTIONAL_CODECS_SUPPORT_UNKNOWN;
    }
}
------------------------
Find a silently evolved API code:android.widget.ProgressBar.getSecondaryProgressTintMode:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the blending mode used to apply the tint to the secondary
 * progress drawable, if specified.
 *
 * @return the blending mode used to apply the tint to the secondary
 * progress drawable
 * @attr ref android.R.styleable#ProgressBar_secondaryProgressTintMode
 * @see #setSecondaryProgressTintMode(PorterDuff.Mode)
 */

Body of Frist Method:
{
    return mProgressTintInfo != null ? mProgressTintInfo.mSecondaryProgressTintMode : null;
}
Body of Second Method:
{
    BlendMode mode = getSecondaryProgressTintBlendMode();
    return mode != null ? BlendMode.blendModeToPorterDuffMode(mode) : null;
}
------------------------
Find a silently evolved API code:android.media.SubtitleTrack.onStop:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    synchronized (this) {
        if (DEBUG)
            Log.d(TAG, "onStop");
        clearActiveCues();
        mLastTimeMs = -1;
    }
    updateView(mActiveCues);
    mNextScheduledTimeMs = -1;
    mTimeProvider.notifyAt(MediaTimeProvider.NO_TIME, this);
}
Body of Second Method:
{
    synchronized (this) {
        if (DEBUG)
            Log.d(TAG, "onStop");
        clearActiveCues();
        mLastTimeMs = -1;
    }
    updateView(mActiveCues);
    mNextScheduledTimeMs = -1;
    if (mTimeProvider != null) {
        mTimeProvider.notifyAt(MediaTimeProvider.NO_TIME, this);
    }
}
------------------------
Find a silently evolved API code:android.media.AudioRecordingConfiguration.anonymizedCopy:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 * Creates a copy of the recording configuration that is stripped of any data enabling
 * identification of which application it is associated with ("anonymized").
 * @param in
 */

Body of Frist Method:
{
    return new AudioRecordingConfiguration(/*anonymized uid*/
    -1, in.mSessionId, in.mClientSource, in.mClientFormat, in.mDeviceFormat, in.mPatchHandle, "");
}
Body of Second Method:
{
    return new AudioRecordingConfiguration(/*anonymized uid*/
    -1, in.mClientSessionId, in.mClientSource, in.mClientFormat, in.mDeviceFormat, in.mPatchHandle, "", /*empty package name*/
    in.mClientPortId, in.mClientSilenced, in.mDeviceSource, in.mClientEffects, in.mDeviceEffects);
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiConfiguration.isEnterprise:COMMENT
<android.net.wifi.WifiConfiguration: boolean isEnterprise()>
public      hidden      ->public      hidden      deprecated  
Method Modifier: public      hidden      deprecated  
Method Modifier: Yes         Yes         No          
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * Helper function, idenfity if a configuration should be treated as an enterprise network
 * @hide
 */

Body of Frist Method:
{
    return (allowedKeyManagement.get(KeyMgmt.WPA_EAP) || allowedKeyManagement.get(KeyMgmt.IEEE8021X)) && enterpriseConfig != null && enterpriseConfig.getEapMethod() != WifiEnterpriseConfig.Eap.NONE;
}
Body of Second Method:
{
    return (allowedKeyManagement.get(KeyMgmt.WPA_EAP) || allowedKeyManagement.get(KeyMgmt.IEEE8021X) || allowedKeyManagement.get(KeyMgmt.SUITE_B_192)) && enterpriseConfig != null && enterpriseConfig.getEapMethod() != WifiEnterpriseConfig.Eap.NONE;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothPbapClient.close:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Close the connection to the backing service.
 * Other public functions of BluetoothPbapClient will return default error
 * results once close() has been called. Multiple invocations of close()
 * are ok.
 */

Body of Frist Method:
{
    IBluetoothManager mgr = mAdapter.getBluetoothManager();
    if (mgr != null) {
        try {
            mgr.unregisterStateChangeCallback(mBluetoothStateChangeCallback);
        } catch (Exception e) {
            Log.e(TAG, "", e);
        }
    }
    synchronized (mConnection) {
        if (mService != null) {
            try {
                mService = null;
                mContext.unbindService(mConnection);
            } catch (Exception re) {
                Log.e(TAG, "", re);
            }
        }
    }
    mServiceListener = null;
}
Body of Second Method:
{
    mProfileConnector.disconnect();
}
------------------------
Find a silently evolved API code:android.location.GnssClock.set:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets all contents to the values stored in the provided object.
 * @hide
 */

Body of Frist Method:
{
    mFlags = clock.mFlags;
    mLeapSecond = clock.mLeapSecond;
    mTimeNanos = clock.mTimeNanos;
    mTimeUncertaintyNanos = clock.mTimeUncertaintyNanos;
    mFullBiasNanos = clock.mFullBiasNanos;
    mBiasNanos = clock.mBiasNanos;
    mBiasUncertaintyNanos = clock.mBiasUncertaintyNanos;
    mDriftNanosPerSecond = clock.mDriftNanosPerSecond;
    mDriftUncertaintyNanosPerSecond = clock.mDriftUncertaintyNanosPerSecond;
    mHardwareClockDiscontinuityCount = clock.mHardwareClockDiscontinuityCount;
}
Body of Second Method:
{
    mFlags = clock.mFlags;
    mLeapSecond = clock.mLeapSecond;
    mTimeNanos = clock.mTimeNanos;
    mTimeUncertaintyNanos = clock.mTimeUncertaintyNanos;
    mFullBiasNanos = clock.mFullBiasNanos;
    mBiasNanos = clock.mBiasNanos;
    mBiasUncertaintyNanos = clock.mBiasUncertaintyNanos;
    mDriftNanosPerSecond = clock.mDriftNanosPerSecond;
    mDriftUncertaintyNanosPerSecond = clock.mDriftUncertaintyNanosPerSecond;
    mHardwareClockDiscontinuityCount = clock.mHardwareClockDiscontinuityCount;
    mElapsedRealtimeNanos = clock.mElapsedRealtimeNanos;
    mElapsedRealtimeUncertaintyNanos = clock.mElapsedRealtimeUncertaintyNanos;
}
------------------------
Find a silently evolved API code:android.os.LocaleList.writeToProto:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Helper to write LocaleList to a protocol buffer output stream.  Assumes the parent
 * protobuf has declared the locale as repeated.
 *
 * @param protoOutputStream Stream to write the locale to.
 * @param fieldId Field Id of the Locale as defined in the parent message.
 * @hide
 */

Body of Frist Method:
{
    for (int i = 0; i < mList.length; i++) {
        final Locale locale = mList[i];
        final long token = protoOutputStream.start(fieldId);
        protoOutputStream.write(LocaleProto.LANGUAGE, locale.getLanguage());
        protoOutputStream.write(LocaleProto.COUNTRY, locale.getCountry());
        protoOutputStream.write(LocaleProto.VARIANT, locale.getVariant());
        protoOutputStream.end(token);
    }
}
Body of Second Method:
{
    for (int i = 0; i < mList.length; i++) {
        final Locale locale = mList[i];
        final long token = protoOutputStream.start(fieldId);
        protoOutputStream.write(LocaleProto.LANGUAGE, locale.getLanguage());
        protoOutputStream.write(LocaleProto.COUNTRY, locale.getCountry());
        protoOutputStream.write(LocaleProto.VARIANT, locale.getVariant());
        protoOutputStream.write(LocaleProto.SCRIPT, locale.getScript());
        protoOutputStream.end(token);
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothA2dp.isAvrcpAbsoluteVolumeSupported:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Checks if Avrcp device supports the absolute volume feature.
 *
 * @return true if device supports absolute volume
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        Log.d(TAG, "isAvrcpAbsoluteVolumeSupported");
    try {
        mServiceLock.readLock().lock();
        if (mService != null && isEnabled()) {
            return mService.isAvrcpAbsoluteVolumeSupported();
        }
        if (mService == null)
            Log.w(TAG, "Proxy not attached to service");
        return false;
    } catch (RemoteException e) {
        Log.e(TAG, "Error talking to BT service in isAvrcpAbsoluteVolumeSupported()", e);
        return false;
    } finally {
        mServiceLock.readLock().unlock();
    }
}
Body of Second Method:
{
    if (DBG)
        Log.d(TAG, "isAvrcpAbsoluteVolumeSupported");
    try {
        final IBluetoothA2dp service = getService();
        if (service != null && isEnabled()) {
            return service.isAvrcpAbsoluteVolumeSupported();
        }
        if (service == null)
            Log.w(TAG, "Proxy not attached to service");
        return false;
    } catch (RemoteException e) {
        Log.e(TAG, "Error talking to BT service in isAvrcpAbsoluteVolumeSupported()", e);
        return false;
    }
}
------------------------
Find a silently evolved API code:android.app.WindowConfiguration.toString:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return "{ mBounds=" + mBounds + " mAppBounds=" + mAppBounds + " mWindowingMode=" + windowingModeToString(mWindowingMode) + " mActivityType=" + activityTypeToString(mActivityType) + "}";
}
Body of Second Method:
{
    return "{ mBounds=" + mBounds + " mAppBounds=" + mAppBounds + " mWindowingMode=" + windowingModeToString(mWindowingMode) + " mDisplayWindowingMode=" + windowingModeToString(mDisplayWindowingMode) + " mActivityType=" + activityTypeToString(mActivityType) + " mAlwaysOnTop=" + alwaysOnTopToString(mAlwaysOnTop) + " mRotation=" + (mRotation == ROTATION_UNDEFINED ? "undefined" : rotationToString(mRotation)) + "}";
}
------------------------
Find a silently evolved API code:android.graphics.Picture.draw:COMMENT
Method Modifier: public      
Comment:/**
 * Draw this picture on the canvas.
 * <p>
 * Prior to {@link android.os.Build.VERSION_CODES#LOLLIPOP}, this call could
 * have the side effect of changing the matrix and clip of the canvas
 * if this picture had imbalanced saves/restores.
 *
 * <p>
 * <strong>Note:</strong> This forces the picture to internally call
 * {@link Picture#endRecording()} in order to prepare for playback.
 *
 * @param canvas  The picture is drawn to this canvas
 */

Body of Frist Method:
{
    if (mRecordingCanvas != null) {
        endRecording();
    }
    if (mRequiresHwAcceleration && !canvas.isHardwareAccelerated()) {
        canvas.onHwBitmapInSwMode();
    }
    nativeDraw(canvas.getNativeCanvasWrapper(), mNativePicture);
}
Body of Second Method:
{
    verifyValid();
    if (mRecordingCanvas != null) {
        endRecording();
    }
    if (mRequiresHwAcceleration && !canvas.isHardwareAccelerated()) {
        canvas.onHwBitmapInSwMode();
    }
    nativeDraw(canvas.getNativeCanvasWrapper(), mNativePicture);
}
------------------------
Find a silently evolved API code:android.location.LocationRequest.createFromDeprecatedCriteria:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (minTime < 0)
        minTime = 0;
    if (minDistance < 0)
        minDistance = 0;
    int quality;
    switch(criteria.getAccuracy()) {
        case Criteria.ACCURACY_COARSE:
            quality = ACCURACY_BLOCK;
            break;
        case Criteria.ACCURACY_FINE:
            quality = ACCURACY_FINE;
            break;
        default:
            {
                switch(criteria.getPowerRequirement()) {
                    case Criteria.POWER_HIGH:
                        quality = POWER_HIGH;
                        break;
                    default:
                        quality = POWER_LOW;
                }
            }
    }
    LocationRequest request = new LocationRequest().setQuality(quality).setInterval(minTime).setFastestInterval(minTime).setSmallestDisplacement(minDistance);
    if (singleShot)
        request.setNumUpdates(1);
    return request;
}
Body of Second Method:
{
    if (minTime < 0)
        minTime = 0;
    if (minDistance < 0)
        minDistance = 0;
    int quality;
    switch(criteria.getAccuracy()) {
        case Criteria.ACCURACY_COARSE:
            quality = ACCURACY_BLOCK;
            break;
        case Criteria.ACCURACY_FINE:
            quality = ACCURACY_FINE;
            break;
        default:
            {
                if (criteria.getPowerRequirement() == Criteria.POWER_HIGH) {
                    quality = POWER_HIGH;
                } else {
                    quality = POWER_LOW;
                }
            }
    }
    LocationRequest request = new LocationRequest().setQuality(quality).setInterval(minTime).setFastestInterval(minTime).setSmallestDisplacement(minDistance);
    if (singleShot)
        request.setNumUpdates(1);
    return request;
}
------------------------
Find a silently evolved API code:android.view.ThreadedRenderer.setLightCenter:COMMENT
Method Modifier: default     hidden      
Comment:/**
 * Updates the light position based on the position of the window.
 *
 * @param attachInfo Information about the window.
 */

Body of Frist Method:
{
    // Adjust light position for window offsets.
    final Point displaySize = attachInfo.mPoint;
    attachInfo.mDisplay.getRealSize(displaySize);
    final float lightX = displaySize.x / 2f - attachInfo.mWindowLeft;
    final float lightY = mLightY - attachInfo.mWindowTop;
    nSetLightCenter(mNativeProxy, lightX, lightY, mLightZ);
}
Body of Second Method:
{
    // Adjust light position for window offsets.
    final Point displaySize = attachInfo.mPoint;
    attachInfo.mDisplay.getRealSize(displaySize);
    final float lightX = displaySize.x / 2f - attachInfo.mWindowLeft;
    final float lightY = mLightY - attachInfo.mWindowTop;
    setLightSourceGeometry(lightX, lightY, mLightZ, mLightRadius);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.getCurrentCalls:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns list of all calls in any state.
 *
 * @param device remote device
 * @return list of calls; empty list if none call exists
 */

Body of Frist Method:
{
    if (DBG)
        log("getCurrentCalls()");
    final IBluetoothHeadsetClient service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getCurrentCalls(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return null;
}
Body of Second Method:
{
    if (DBG)
        log("getCurrentCalls()");
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getCurrentCalls(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return null;
}
------------------------
Find a silently evolved API code:android.widget.ProgressBar.applyPrimaryProgressTint:COMMENT
Method Modifier: private     
Comment:/**
 * Should only be called if we've already verified that mProgressDrawable
 * and mProgressTintInfo are non-null.
 */

Body of Frist Method:
{
    if (mProgressTintInfo.mHasProgressTint || mProgressTintInfo.mHasProgressTintMode) {
        final Drawable target = getTintTarget(R.id.progress, true);
        if (target != null) {
            if (mProgressTintInfo.mHasProgressTint) {
                target.setTintList(mProgressTintInfo.mProgressTintList);
            }
            if (mProgressTintInfo.mHasProgressTintMode) {
                target.setTintMode(mProgressTintInfo.mProgressTintMode);
            }
            // stateful before applying the tint, so let's try again.
            if (target.isStateful()) {
                target.setState(getDrawableState());
            }
        }
    }
}
Body of Second Method:
{
    if (mProgressTintInfo.mHasProgressTint || mProgressTintInfo.mHasProgressTintMode) {
        final Drawable target = getTintTarget(R.id.progress, true);
        if (target != null) {
            if (mProgressTintInfo.mHasProgressTint) {
                target.setTintList(mProgressTintInfo.mProgressTintList);
            }
            if (mProgressTintInfo.mHasProgressTintMode) {
                target.setTintBlendMode(mProgressTintInfo.mProgressBlendMode);
            }
            // stateful before applying the tint, so let's try again.
            if (target.isStateful()) {
                target.setState(getDrawableState());
            }
        }
    }
}
------------------------
Find a silently evolved API code:android.view.ViewPropertyAnimator.startAnimation:COMMENT
Method Modifier: private     
Comment:/**
 * Starts the underlying Animator for a set of properties. We use a single animator that
 * simply runs from 0 to 1, and then use that fractional value to set each property
 * value accordingly.
 */

Body of Frist Method:
{
    if (mRTBackend != null && mRTBackend.startAnimation(this)) {
        return;
    }
    mView.setHasTransientState(true);
    ValueAnimator animator = ValueAnimator.ofFloat(1.0f);
    ArrayList<NameValuesHolder> nameValueList = (ArrayList<NameValuesHolder>) mPendingAnimations.clone();
    mPendingAnimations.clear();
    int propertyMask = 0;
    int propertyCount = nameValueList.size();
    for (int i = 0; i < propertyCount; ++i) {
        NameValuesHolder nameValuesHolder = nameValueList.get(i);
        propertyMask |= nameValuesHolder.mNameConstant;
    }
    mAnimatorMap.put(animator, new PropertyBundle(propertyMask, nameValueList));
    if (mPendingSetupAction != null) {
        mAnimatorSetupMap.put(animator, mPendingSetupAction);
        mPendingSetupAction = null;
    }
    if (mPendingCleanupAction != null) {
        mAnimatorCleanupMap.put(animator, mPendingCleanupAction);
        mPendingCleanupAction = null;
    }
    if (mPendingOnStartAction != null) {
        mAnimatorOnStartMap.put(animator, mPendingOnStartAction);
        mPendingOnStartAction = null;
    }
    if (mPendingOnEndAction != null) {
        mAnimatorOnEndMap.put(animator, mPendingOnEndAction);
        mPendingOnEndAction = null;
    }
    animator.addUpdateListener(mAnimatorEventListener);
    animator.addListener(mAnimatorEventListener);
    if (mStartDelaySet) {
        animator.setStartDelay(mStartDelay);
    }
    if (mDurationSet) {
        animator.setDuration(mDuration);
    }
    if (mInterpolatorSet) {
        animator.setInterpolator(mInterpolator);
    }
    animator.start();
}
Body of Second Method:
{
    mView.setHasTransientState(true);
    ValueAnimator animator = ValueAnimator.ofFloat(1.0f);
    ArrayList<NameValuesHolder> nameValueList = (ArrayList<NameValuesHolder>) mPendingAnimations.clone();
    mPendingAnimations.clear();
    int propertyMask = 0;
    int propertyCount = nameValueList.size();
    for (int i = 0; i < propertyCount; ++i) {
        NameValuesHolder nameValuesHolder = nameValueList.get(i);
        propertyMask |= nameValuesHolder.mNameConstant;
    }
    mAnimatorMap.put(animator, new PropertyBundle(propertyMask, nameValueList));
    if (mPendingSetupAction != null) {
        mAnimatorSetupMap.put(animator, mPendingSetupAction);
        mPendingSetupAction = null;
    }
    if (mPendingCleanupAction != null) {
        mAnimatorCleanupMap.put(animator, mPendingCleanupAction);
        mPendingCleanupAction = null;
    }
    if (mPendingOnStartAction != null) {
        mAnimatorOnStartMap.put(animator, mPendingOnStartAction);
        mPendingOnStartAction = null;
    }
    if (mPendingOnEndAction != null) {
        mAnimatorOnEndMap.put(animator, mPendingOnEndAction);
        mPendingOnEndAction = null;
    }
    animator.addUpdateListener(mAnimatorEventListener);
    animator.addListener(mAnimatorEventListener);
    if (mStartDelaySet) {
        animator.setStartDelay(mStartDelay);
    }
    if (mDurationSet) {
        animator.setDuration(mDuration);
    }
    if (mInterpolatorSet) {
        animator.setInterpolator(mInterpolator);
    }
    animator.start();
}
------------------------
Find a silently evolved API code:android.widget.TextClock.onTimeChanged:COMMENT
Method Modifier: private     
Comment:/**
 * Update the displayed time if this view and its ancestors and window is visible
 */

Body of Frist Method:
{
    // mShouldRunTicker always equals the last value passed into onVisibilityAggregated
    if (mShouldRunTicker) {
        mTime.setTimeInMillis(System.currentTimeMillis());
        setText(DateFormat.format(mFormat, mTime));
        setContentDescription(DateFormat.format(mDescFormat, mTime));
    }
}
Body of Second Method:
{
    mTime.setTimeInMillis(System.currentTimeMillis());
    setText(DateFormat.format(mFormat, mTime));
    setContentDescription(DateFormat.format(mDescFormat, mTime));
}
------------------------
Find a silently evolved API code:android.graphics.Canvas.saveUnclippedLayer:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return nSaveLayer(mNativeCanvasWrapper, left, top, right, bottom, 0, 0);
}
Body of Second Method:
{
    return nSaveUnclippedLayer(mNativeCanvasWrapper, left, top, right, bottom);
}
------------------------
Find a silently evolved API code:android.graphics.drawable.GradientDrawable.setColors:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the colors used to draw the gradient.
 * <p>
 * Each color is specified as an ARGB integer and the array must contain at
 * least 2 colors.
 * <p>
 * <strong>Note</strong>: changing colors will affect all instances of a
 * drawable loaded from a resource. It is recommended to invoke
 * {@link #mutate()} before changing the colors.
 *
 * @param colors an array containing 2 or more ARGB colors
 * @see #mutate()
 * @see #setColor(int)
 */

Body of Frist Method:
{
    mGradientState.setGradientColors(colors);
    mGradientIsDirty = true;
    invalidateSelf();
}
Body of Second Method:
{
    setColors(colors, null);
}
------------------------
Find a silently evolved API code:android.app.ApplicationErrorReport.CrashInfo.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Save a CrashInfo instance to a parcel.
 */

Body of Frist Method:
{
    int start = dest.dataPosition();
    dest.writeString(exceptionClassName);
    dest.writeString(exceptionMessage);
    dest.writeString(throwFileName);
    dest.writeString(throwClassName);
    dest.writeString(throwMethodName);
    dest.writeInt(throwLineNumber);
    dest.writeString(stackTrace);
    int total = dest.dataPosition() - start;
    if (Binder.CHECK_PARCEL_SIZE && total > 20 * 1024) {
        Slog.d("Error", "ERR: exClass=" + exceptionClassName);
        Slog.d("Error", "ERR: exMsg=" + exceptionMessage);
        Slog.d("Error", "ERR: file=" + throwFileName);
        Slog.d("Error", "ERR: class=" + throwClassName);
        Slog.d("Error", "ERR: method=" + throwMethodName + " line=" + throwLineNumber);
        Slog.d("Error", "ERR: stack=" + stackTrace);
        Slog.d("Error", "ERR: TOTAL BYTES WRITTEN: " + (dest.dataPosition() - start));
    }
}
Body of Second Method:
{
    int start = dest.dataPosition();
    dest.writeString(exceptionClassName);
    dest.writeString(exceptionMessage);
    dest.writeString(throwFileName);
    dest.writeString(throwClassName);
    dest.writeString(throwMethodName);
    dest.writeInt(throwLineNumber);
    dest.writeString(stackTrace);
    dest.writeString(crashTag);
    int total = dest.dataPosition() - start;
    if (Binder.CHECK_PARCEL_SIZE && total > 20 * 1024) {
        Slog.d("Error", "ERR: exClass=" + exceptionClassName);
        Slog.d("Error", "ERR: exMsg=" + exceptionMessage);
        Slog.d("Error", "ERR: file=" + throwFileName);
        Slog.d("Error", "ERR: class=" + throwClassName);
        Slog.d("Error", "ERR: method=" + throwMethodName + " line=" + throwLineNumber);
        Slog.d("Error", "ERR: stack=" + stackTrace);
        Slog.d("Error", "ERR: TOTAL BYTES WRITTEN: " + (dest.dataPosition() - start));
    }
}
------------------------
Find a silently evolved API code:android.app.servertransaction.TransactionExecutor.performLifecycleSequence:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Transition the client through previously initialized state sequence.
 */

Body of Frist Method:
{
    final int size = path.size();
    for (int i = 0, state; i < size; i++) {
        state = path.get(i);
        log("Transitioning to state: " + state);
        switch(state) {
            case ON_CREATE:
                mTransactionHandler.handleLaunchActivity(r, mPendingActions, null);
                break;
            case ON_START:
                mTransactionHandler.handleStartActivity(r, mPendingActions);
                break;
            case ON_RESUME:
                mTransactionHandler.handleResumeActivity(r.token, false, /* finalStateRequest */
                r.isForward, "LIFECYCLER_RESUME_ACTIVITY");
                break;
            case ON_PAUSE:
                mTransactionHandler.handlePauseActivity(r.token, false, /* finished */
                false, /* userLeaving */
                0, /* configChanges */
                mPendingActions, "LIFECYCLER_PAUSE_ACTIVITY");
                break;
            case ON_STOP:
                mTransactionHandler.handleStopActivity(r.token, false, /* show */
                0, /* configChanges */
                mPendingActions, false, /* finalStateRequest */
                "LIFECYCLER_STOP_ACTIVITY");
                break;
            case ON_DESTROY:
                mTransactionHandler.handleDestroyActivity(r.token, false, /* finishing */
                0, /* configChanges */
                false, /* getNonConfigInstance */
                "performLifecycleSequence. cycling to:" + path.get(size - 1));
                break;
            case ON_RESTART:
                mTransactionHandler.performRestartActivity(r.token, false);
                break;
            default:
                throw new IllegalArgumentException("Unexpected lifecycle state: " + state);
        }
    }
}
Body of Second Method:
{
    final int size = path.size();
    for (int i = 0, state; i < size; i++) {
        state = path.get(i);
        if (DEBUG_RESOLVER) {
            Slog.d(TAG, tId(transaction) + "Transitioning activity: " + getShortActivityName(r.token, mTransactionHandler) + " to state: " + getStateName(state));
        }
        switch(state) {
            case ON_CREATE:
                mTransactionHandler.handleLaunchActivity(r, mPendingActions, null);
                break;
            case ON_START:
                mTransactionHandler.handleStartActivity(r, mPendingActions);
                break;
            case ON_RESUME:
                mTransactionHandler.handleResumeActivity(r.token, false, /* finalStateRequest */
                r.isForward, "LIFECYCLER_RESUME_ACTIVITY");
                break;
            case ON_PAUSE:
                mTransactionHandler.handlePauseActivity(r.token, false, /* finished */
                false, /* userLeaving */
                0, /* configChanges */
                mPendingActions, "LIFECYCLER_PAUSE_ACTIVITY");
                break;
            case ON_STOP:
                mTransactionHandler.handleStopActivity(r.token, false, /* show */
                0, /* configChanges */
                mPendingActions, false, /* finalStateRequest */
                "LIFECYCLER_STOP_ACTIVITY");
                break;
            case ON_DESTROY:
                mTransactionHandler.handleDestroyActivity(r.token, false, /* finishing */
                0, /* configChanges */
                false, /* getNonConfigInstance */
                "performLifecycleSequence. cycling to:" + path.get(size - 1));
                break;
            case ON_RESTART:
                mTransactionHandler.performRestartActivity(r.token, false);
                break;
            default:
                throw new IllegalArgumentException("Unexpected lifecycle state: " + state);
        }
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.holdCall:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Holds a call.
 *
 * @param device remote device
 * @return <code>true</code> if command has been issued successfully; <code>false</code>
 * otherwise; upon completion HFP sends {@link #ACTION_CALL_CHANGED} intent.
 */

Body of Frist Method:
{
    if (DBG)
        log("holdCall()");
    final IBluetoothHeadsetClient service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.holdCall(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("holdCall()");
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.holdCall(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.net.wifi.aware.WifiAwareNetworkSpecifier.equals:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof WifiAwareNetworkSpecifier)) {
        return false;
    }
    WifiAwareNetworkSpecifier lhs = (WifiAwareNetworkSpecifier) obj;
    return type == lhs.type && role == lhs.role && clientId == lhs.clientId && sessionId == lhs.sessionId && peerId == lhs.peerId && Arrays.equals(peerMac, lhs.peerMac) && Arrays.equals(pmk, lhs.pmk) && Objects.equals(passphrase, lhs.passphrase) && requestorUid == lhs.requestorUid;
}
Body of Second Method:
{
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof WifiAwareNetworkSpecifier)) {
        return false;
    }
    WifiAwareNetworkSpecifier lhs = (WifiAwareNetworkSpecifier) obj;
    return type == lhs.type && role == lhs.role && clientId == lhs.clientId && sessionId == lhs.sessionId && peerId == lhs.peerId && Arrays.equals(peerMac, lhs.peerMac) && Arrays.equals(pmk, lhs.pmk) && Objects.equals(passphrase, lhs.passphrase) && port == lhs.port && transportProtocol == lhs.transportProtocol && requestorUid == lhs.requestorUid;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothA2dpSink.connect:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Initiate connection to a profile of the remote bluetooth device.
 *
 * <p> Currently, the system supports only 1 connection to the
 * A2DP profile. The API will automatically disconnect connected
 * devices before connecting.
 *
 * <p> This API returns false in scenarios like the profile on the
 * device is already connected or Bluetooth is not turned on.
 * When this API returns true, it is guaranteed that
 * connection state intent for the profile will be broadcasted with
 * the state. Users can get the connection state of the profile
 * from this intent.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}
 * permission.
 *
 * @param device Remote Bluetooth Device
 * @return false on immediate error, true otherwise
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("connect(" + device + ")");
    final IBluetoothA2dpSink service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.connect(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("connect(" + device + ")");
    final IBluetoothA2dpSink service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.connect(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.graphics.NinePatch.getTransparentRegion:COMMENT
Method Modifier: public      final       
Comment:/**
 * Returns a {@link Region} representing the parts of the NinePatch that are
 * completely transparent.
 *
 * @param bounds The location and size of the NinePatch.
 *
 * @return null if the NinePatch has no transparent region to
 * report, else a {@link Region} holding the parts of the specified bounds
 * that are transparent.
 */

Body of Frist Method:
{
    long r = nativeGetTransparentRegion(mBitmap, mNativeChunk, bounds);
    return r != 0 ? new Region(r) : null;
}
Body of Second Method:
{
    long r = nativeGetTransparentRegion(mBitmap.getNativeInstance(), mNativeChunk, bounds);
    return r != 0 ? new Region(r) : null;
}
------------------------
Find a silently evolved API code:android.hardware.camera2.CameraCharacteristics.getKeys:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    // List of keys is immutable; cache the results after we calculate them
    if (mKeys != null) {
        return mKeys;
    }
    int[] filterTags = get(REQUEST_AVAILABLE_CHARACTERISTICS_KEYS);
    if (filterTags == null) {
        throw new AssertionError("android.request.availableCharacteristicsKeys must be non-null" + " in the characteristics");
    }
    mKeys = Collections.unmodifiableList(getKeys(getClass(), getKeyClass(), this, filterTags));
    return mKeys;
}
Body of Second Method:
{
    // List of keys is immutable; cache the results after we calculate them
    if (mKeys != null) {
        return mKeys;
    }
    int[] filterTags = get(REQUEST_AVAILABLE_CHARACTERISTICS_KEYS);
    if (filterTags == null) {
        throw new AssertionError("android.request.availableCharacteristicsKeys must be non-null" + " in the characteristics");
    }
    mKeys = Collections.unmodifiableList(getKeys(getClass(), getKeyClass(), this, filterTags, true));
    return mKeys;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHidHost.setPriority:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Set priority of the profile
 *
 * <p> The device should already be paired.
 * Priority can be one of {@link #PRIORITY_ON} or
 * {@link #PRIORITY_OFF},
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}
 * permission.
 *
 * @param device Paired bluetooth device
 * @param priority
 * @return true if priority is set, false on error
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("setPriority(" + device + ", " + priority + ")");
    final IBluetoothHidHost service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        if (priority != BluetoothProfile.PRIORITY_OFF && priority != BluetoothProfile.PRIORITY_ON) {
            return false;
        }
        try {
            return service.setPriority(device, priority);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("setPriority(" + device + ", " + priority + ")");
    final IBluetoothHidHost service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        if (priority != BluetoothProfile.PRIORITY_OFF && priority != BluetoothProfile.PRIORITY_ON) {
            return false;
        }
        try {
            return service.setPriority(device, priority);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.view.LayoutInflater.failNotAllowed:COMMENT
Method Modifier: private     
Comment:/**
 * Throw an exception because the specified class is not allowed to be inflated.
 */

Body of Frist Method:
{
    throw new InflateException(attrs.getPositionDescription() + ": Class not allowed to be inflated " + (prefix != null ? (prefix + name) : name));
}
Body of Second Method:
{
    throw new InflateException(getParserStateDescription(context, attrs) + ": Class not allowed to be inflated " + (prefix != null ? (prefix + name) : name));
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothAvrcpController.setPlayerApplicationSetting:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets the player app setting for current player.
 * returns true in case setting is supported by remote, false otherwise
 */

Body of Frist Method:
{
    if (DBG)
        Log.d(TAG, "setPlayerApplicationSetting");
    final IBluetoothAvrcpController service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.setPlayerApplicationSetting(plAppSetting);
        } catch (RemoteException e) {
            Log.e(TAG, "Error talking to BT service in setPlayerApplicationSetting() " + e);
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        Log.d(TAG, "setPlayerApplicationSetting");
    final IBluetoothAvrcpController service = getService();
    if (service != null && isEnabled()) {
        try {
            return service.setPlayerApplicationSetting(plAppSetting);
        } catch (RemoteException e) {
            Log.e(TAG, "Error talking to BT service in setPlayerApplicationSetting() " + e);
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiInfo.writeToParcel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Implement the Parcelable interface {@hide}
 */

Body of Frist Method:
{
    dest.writeInt(mNetworkId);
    dest.writeInt(mRssi);
    dest.writeInt(mLinkSpeed);
    dest.writeInt(mFrequency);
    if (mIpAddress != null) {
        dest.writeByte((byte) 1);
        dest.writeByteArray(mIpAddress.getAddress());
    } else {
        dest.writeByte((byte) 0);
    }
    if (mWifiSsid != null) {
        dest.writeInt(1);
        mWifiSsid.writeToParcel(dest, flags);
    } else {
        dest.writeInt(0);
    }
    dest.writeString(mBSSID);
    dest.writeString(mMacAddress);
    dest.writeInt(mMeteredHint ? 1 : 0);
    dest.writeInt(mEphemeral ? 1 : 0);
    dest.writeInt(score);
    dest.writeDouble(txSuccessRate);
    dest.writeDouble(txRetriesRate);
    dest.writeDouble(txBadRate);
    dest.writeDouble(rxSuccessRate);
    mSupplicantState.writeToParcel(dest, flags);
}
Body of Second Method:
{
    dest.writeInt(mNetworkId);
    dest.writeInt(mRssi);
    dest.writeInt(mLinkSpeed);
    dest.writeInt(mTxLinkSpeed);
    dest.writeInt(mRxLinkSpeed);
    dest.writeInt(mFrequency);
    if (mIpAddress != null) {
        dest.writeByte((byte) 1);
        dest.writeByteArray(mIpAddress.getAddress());
    } else {
        dest.writeByte((byte) 0);
    }
    if (mWifiSsid != null) {
        dest.writeInt(1);
        mWifiSsid.writeToParcel(dest, flags);
    } else {
        dest.writeInt(0);
    }
    dest.writeString(mBSSID);
    dest.writeString(mMacAddress);
    dest.writeInt(mMeteredHint ? 1 : 0);
    dest.writeInt(mEphemeral ? 1 : 0);
    dest.writeInt(mTrusted ? 1 : 0);
    dest.writeInt(score);
    dest.writeLong(txSuccess);
    dest.writeDouble(txSuccessRate);
    dest.writeLong(txRetries);
    dest.writeDouble(txRetriesRate);
    dest.writeLong(txBad);
    dest.writeDouble(txBadRate);
    dest.writeLong(rxSuccess);
    dest.writeDouble(rxSuccessRate);
    mSupplicantState.writeToParcel(dest, flags);
    dest.writeInt(mOsuAp ? 1 : 0);
    dest.writeString(mNetworkSuggestionOrSpecifierPackageName);
    dest.writeString(mFqdn);
    dest.writeString(mProviderFriendlyName);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.getPriority:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the priority of the profile.
 */

Body of Frist Method:
{
    if (VDBG)
        log("getPriority(" + device + ")");
    final IBluetoothHeadsetClient service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getPriority(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return PRIORITY_OFF;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return PRIORITY_OFF;
}
Body of Second Method:
{
    if (VDBG)
        log("getPriority(" + device + ")");
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getPriority(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return PRIORITY_OFF;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return PRIORITY_OFF;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHidHost.getPriority:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the priority of the profile.
 *
 * <p> The priority can be any of:
 * {@link #PRIORITY_AUTO_CONNECT}, {@link #PRIORITY_OFF},
 * {@link #PRIORITY_ON}, {@link #PRIORITY_UNDEFINED}
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param device Bluetooth device
 * @return priority of the device
 * @hide
 */

Body of Frist Method:
{
    if (VDBG)
        log("getPriority(" + device + ")");
    final IBluetoothHidHost service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getPriority(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.PRIORITY_OFF;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return BluetoothProfile.PRIORITY_OFF;
}
Body of Second Method:
{
    if (VDBG)
        log("getPriority(" + device + ")");
    final IBluetoothHidHost service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getPriority(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.PRIORITY_OFF;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return BluetoothProfile.PRIORITY_OFF;
}
------------------------
Find a silently evolved API code:android.view.WindowInsets.getSystemWindowInsetRight:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the right system window inset in pixels.
 *
 * <p>The system window inset represents the area of a full-screen window that is
 * partially or fully obscured by the status bar, navigation bar, IME or other system windows.
 * </p>
 *
 * @return The right system window inset
 */

Body of Frist Method:
{
    return mSystemWindowInsets.right;
}
Body of Second Method:
{
    return getSystemWindowInsets().right;
}
------------------------
Find a silently evolved API code:android.telephony.CellInfoLte.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Implement the Parcelable interface
 */

Body of Frist Method:
{
    if (DBG)
        log("writeToParcel(Parcel, int): " + toString());
    super.writeToParcel(dest, flags, TYPE_LTE);
    mCellIdentityLte.writeToParcel(dest, flags);
    mCellSignalStrengthLte.writeToParcel(dest, flags);
}
Body of Second Method:
{
    if (DBG)
        log("writeToParcel(Parcel, int): " + toString());
    super.writeToParcel(dest, flags, TYPE_LTE);
    mCellIdentityLte.writeToParcel(dest, flags);
    mCellSignalStrengthLte.writeToParcel(dest, flags);
    mCellConfig.writeToParcel(dest, flags);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothSocket.getConnectionType:COMMENT
Method Modifier: public      
Comment:/**
 * Get the type of the underlying connection.
 *
 * @return one of {@link #TYPE_RFCOMM}, {@link #TYPE_SCO} or {@link #TYPE_L2CAP}
 */

Body of Frist Method:
{
    return mType;
}
Body of Second Method:
{
    if (mType == TYPE_L2CAP_LE) {
        // Treat the LE CoC to be the same type as L2CAP.
        return TYPE_L2CAP;
    }
    return mType;
}
------------------------
Find a silently evolved API code:android.view.MotionEvent.clampNoHistory:COMMENT
Method Modifier: public      final       hidden      
Comment:/**
 * Returns a new motion events whose points have been clamped to the specified bounds.
 * @hide
 */

Body of Frist Method:
{
    MotionEvent ev = obtain();
    synchronized (gSharedTempLock) {
        final int pointerCount = nativeGetPointerCount(mNativePtr);
        ensureSharedTempPointerCapacity(pointerCount);
        final PointerProperties[] pp = gSharedTempPointerProperties;
        final PointerCoords[] pc = gSharedTempPointerCoords;
        for (int i = 0; i < pointerCount; i++) {
            nativeGetPointerProperties(mNativePtr, i, pp[i]);
            nativeGetPointerCoords(mNativePtr, i, HISTORY_CURRENT, pc[i]);
            pc[i].x = clamp(pc[i].x, left, right);
            pc[i].y = clamp(pc[i].y, top, bottom);
        }
        ev.mNativePtr = nativeInitialize(ev.mNativePtr, nativeGetDeviceId(mNativePtr), nativeGetSource(mNativePtr), nativeGetAction(mNativePtr), nativeGetFlags(mNativePtr), nativeGetEdgeFlags(mNativePtr), nativeGetMetaState(mNativePtr), nativeGetButtonState(mNativePtr), nativeGetXOffset(mNativePtr), nativeGetYOffset(mNativePtr), nativeGetXPrecision(mNativePtr), nativeGetYPrecision(mNativePtr), nativeGetDownTimeNanos(mNativePtr), nativeGetEventTimeNanos(mNativePtr, HISTORY_CURRENT), pointerCount, pp, pc);
        return ev;
    }
}
Body of Second Method:
{
    MotionEvent ev = obtain();
    synchronized (gSharedTempLock) {
        final int pointerCount = nativeGetPointerCount(mNativePtr);
        ensureSharedTempPointerCapacity(pointerCount);
        final PointerProperties[] pp = gSharedTempPointerProperties;
        final PointerCoords[] pc = gSharedTempPointerCoords;
        for (int i = 0; i < pointerCount; i++) {
            nativeGetPointerProperties(mNativePtr, i, pp[i]);
            nativeGetPointerCoords(mNativePtr, i, HISTORY_CURRENT, pc[i]);
            pc[i].x = clamp(pc[i].x, left, right);
            pc[i].y = clamp(pc[i].y, top, bottom);
        }
        ev.mNativePtr = nativeInitialize(ev.mNativePtr, nativeGetDeviceId(mNativePtr), nativeGetSource(mNativePtr), nativeGetDisplayId(mNativePtr), nativeGetAction(mNativePtr), nativeGetFlags(mNativePtr), nativeGetEdgeFlags(mNativePtr), nativeGetMetaState(mNativePtr), nativeGetButtonState(mNativePtr), nativeGetClassification(mNativePtr), nativeGetXOffset(mNativePtr), nativeGetYOffset(mNativePtr), nativeGetXPrecision(mNativePtr), nativeGetYPrecision(mNativePtr), nativeGetDownTimeNanos(mNativePtr), nativeGetEventTimeNanos(mNativePtr, HISTORY_CURRENT), pointerCount, pp, pc);
        return ev;
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothGatt.readDescriptor:COMMENT
Method Modifier: public      
Comment:/**
 * Reads the value for a given descriptor from the associated remote device.
 *
 * <p>Once the read operation has been completed, the
 * {@link BluetoothGattCallback#onDescriptorRead} callback is
 * triggered, signaling the result of the operation.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param descriptor Descriptor value to read from the remote device
 * @return true, if the read operation was initiated successfully
 */

Body of Frist Method:
{
    if (VDBG)
        Log.d(TAG, "readDescriptor() - uuid: " + descriptor.getUuid());
    if (mService == null || mClientIf == 0)
        return false;
    BluetoothGattCharacteristic characteristic = descriptor.getCharacteristic();
    if (characteristic == null)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusy) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.readDescriptor(mClientIf, device.getAddress(), descriptor.getInstanceId(), AUTHENTICATION_NONE);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}
Body of Second Method:
{
    if (VDBG)
        Log.d(TAG, "readDescriptor() - uuid: " + descriptor.getUuid());
    if (mService == null || mClientIf == 0)
        return false;
    BluetoothGattCharacteristic characteristic = descriptor.getCharacteristic();
    if (characteristic == null)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusyLock) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.readDescriptor(mClientIf, device.getAddress(), descriptor.getInstanceId(), AUTHENTICATION_NONE);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}
------------------------
Find a silently evolved API code:android.util.LongArray.set:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets the value at the specified position in this array.
 */

Body of Frist Method:
{
    checkBounds(index);
    mValues[index] = value;
}
Body of Second Method:
{
    ArrayUtils.checkBounds(mSize, index);
    mValues[index] = value;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothA2dpSink.close:COMMENT
Method Modifier: default     hidden      
Comment:/*package*/

Body of Frist Method:
{
    mServiceListener = null;
    IBluetoothManager mgr = mAdapter.getBluetoothManager();
    if (mgr != null) {
        try {
            mgr.unregisterStateChangeCallback(mBluetoothStateChangeCallback);
        } catch (Exception e) {
            Log.e(TAG, "", e);
        }
    }
    synchronized (mConnection) {
        if (mService != null) {
            try {
                mService = null;
                mContext.unbindService(mConnection);
            } catch (Exception re) {
                Log.e(TAG, "", re);
            }
        }
    }
}
Body of Second Method:
{
    mProfileConnector.disconnect();
}
------------------------
Find a silently evolved API code:android.widget.AdapterView.onProvideAutofillStructure:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 *
 * <p>It also sets the autofill options in the structure; when overridden, it should set it as
 * well, either explicitly by calling {@link ViewStructure#setAutofillOptions(CharSequence[])}
 * or implicitly by calling {@code super.onProvideAutofillStructure(structure, flags)}.
 */

Body of Frist Method:
{
    super.onProvideAutofillStructure(structure, flags);
    final Adapter adapter = getAdapter();
    if (adapter == null)
        return;
    final CharSequence[] options = adapter.getAutofillOptions();
    if (options != null) {
        structure.setAutofillOptions(options);
    }
}
Body of Second Method:
{
    super.onProvideAutofillStructure(structure, flags);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.getDevicesMatchingConnectionStates:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns list of remote devices in a particular state
 *
 * @param states collection of states
 * @return list of devices that state matches the states listed in <code>states</code>; empty
 * list if nothing matches the <code>states</code>
 */

Body of Frist Method:
{
    if (VDBG)
        log("getDevicesMatchingStates()");
    final IBluetoothHeadsetClient service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.getDevicesMatchingConnectionStates(states);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
Body of Second Method:
{
    if (VDBG)
        log("getDevicesMatchingStates()");
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled()) {
        try {
            return service.getDevicesMatchingConnectionStates(states);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothSap.getConnectedDevices:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the list of connected devices. Currently at most one.
 *
 * @return list of connected devices
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("getConnectedDevices()");
    final IBluetoothSap service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.getConnectedDevices();
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
Body of Second Method:
{
    if (DBG)
        log("getConnectedDevices()");
    final IBluetoothSap service = getService();
    if (service != null && isEnabled()) {
        try {
            return service.getConnectedDevices();
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.getAudioRouteAllowed:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns whether audio routing is allowed.
 *
 * @param device remote device
 * @return whether the command succeeded Note: This is an internal function and shouldn't be
 * exposed
 */

Body of Frist Method:
{
    if (VDBG)
        log("getAudioRouteAllowed");
    final IBluetoothHeadsetClient service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.getAudioRouteAllowed(device);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return false;
}
Body of Second Method:
{
    if (VDBG)
        log("getAudioRouteAllowed");
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled()) {
        try {
            return service.getAudioRouteAllowed(device);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return false;
}
------------------------
Find a silently evolved API code:android.net.http.HttpResponseCache.flush:COMMENT
Method Modifier: public      
Comment:/**
 * Force buffered operations to the filesystem. This ensures that responses
 * written to the cache will be available the next time the cache is opened,
 * even if this process is killed.
 */

Body of Frist Method:
{
    try {
        delegate.flush();
    } catch (IOException ignored) {
    }
}
Body of Second Method:
{
    try {
        mDelegate.flush();
    } catch (IOException ignored) {
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothA2dp.setActiveDevice:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Select a connected device as active.
 *
 * The active device selection is per profile. An active device's
 * purpose is profile-specific. For example, A2DP audio streaming
 * is to the active A2DP Sink device. If a remote device is not
 * connected, it cannot be selected as active.
 *
 * <p> This API returns false in scenarios like the profile on the
 * device is not connected or Bluetooth is not turned on.
 * When this API returns true, it is guaranteed that the
 * {@link #ACTION_ACTIVE_DEVICE_CHANGED} intent will be broadcasted
 * with the active device.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}
 * permission.
 *
 * @param device the remote Bluetooth device. Could be null to clear
 * the active device and stop streaming audio to a Bluetooth device.
 * @return false on immediate error, true otherwise
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("setActiveDevice(" + device + ")");
    try {
        mServiceLock.readLock().lock();
        if (mService != null && isEnabled() && ((device == null) || isValidDevice(device))) {
            return mService.setActiveDevice(device);
        }
        if (mService == null)
            Log.w(TAG, "Proxy not attached to service");
        return false;
    } catch (RemoteException e) {
        Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
        return false;
    } finally {
        mServiceLock.readLock().unlock();
    }
}
Body of Second Method:
{
    if (DBG)
        log("setActiveDevice(" + device + ")");
    try {
        final IBluetoothA2dp service = getService();
        if (service != null && isEnabled() && ((device == null) || isValidDevice(device))) {
            return service.setActiveDevice(device);
        }
        if (service == null)
            Log.w(TAG, "Proxy not attached to service");
        return false;
    } catch (RemoteException e) {
        Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
        return false;
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.connectAudio:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Initiates a connection of audio channel.
 *
 * It setup SCO channel with remote connected Handsfree AG device.
 *
 * @param device remote device
 * @return <code>true</code> if command has been issued successfully; <code>false</code>
 * otherwise; upon completion HFP sends {@link #ACTION_AUDIO_STATE_CHANGED} intent;
 */

Body of Frist Method:
{
    final IBluetoothHeadsetClient service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.connectAudio(device);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return false;
}
Body of Second Method:
{
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled()) {
        try {
            return service.connectAudio(device);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return false;
}
------------------------
Find a silently evolved API code:android.view.WindowInsets.consumeDisplayCutout:COMMENT
Method Modifier: public      
Comment:/**
 * Returns a copy of this WindowInsets with the cutout fully consumed.
 *
 * @return A modified copy of this WindowInsets
 */

Body of Frist Method:
{
    final WindowInsets result = new WindowInsets(this);
    result.mDisplayCutout = null;
    result.mDisplayCutoutConsumed = true;
    return result;
}
Body of Second Method:
{
    return new WindowInsets(mSystemWindowInsetsConsumed ? null : mTypeInsetsMap, mStableInsetsConsumed ? null : mTypeMaxInsetsMap, mTypeVisibilityMap, mIsRound, mAlwaysConsumeSystemBars, null);
}
------------------------
Find a silently evolved API code:android.text.TextUtils.length:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * {@hide}
 */

Body of Frist Method:
{
    return isEmpty(s) ? 0 : s.length();
}
Body of Second Method:
{
    return s != null ? s.length() : 0;
}
------------------------
Find a silently evolved API code:android.nfc.cardemulation.CardEmulation.isValidAid:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * A valid AID according to ISO/IEC 7816-4:
 * <ul>
 * <li>Has >= 5 bytes and <=16 bytes (>=10 hex chars and <= 32 hex chars)
 * <li>Consist of only hex characters
 * <li>Additionally, we allow an asterisk at the end, to indicate
 * a prefix
 * <li>Additinally we allow an (#) at symbol at the end, to indicate
 * a subset
 * </ul>
 *
 * @hide
 */

Body of Frist Method:
{
    if (aid == null)
        return false;
    // If a prefix/subset AID, the total length must be odd (even # of AID chars + '*')
    if ((aid.endsWith("*") || aid.endsWith("#")) && ((aid.length() % 2) == 0)) {
        Log.e(TAG, "AID " + aid + " is not a valid AID.");
        return false;
    }
    // If not a prefix/subset AID, the total length must be even (even # of AID chars)
    if ((!(aid.endsWith("*") || aid.endsWith("#"))) && ((aid.length() % 2) != 0)) {
        Log.e(TAG, "AID " + aid + " is not a valid AID.");
        return false;
    }
    // Verify hex characters
    if (!aid.matches("[0-9A-Fa-f]{10,32}\\*?\\#?")) {
        Log.e(TAG, "AID " + aid + " is not a valid AID.");
        return false;
    }
    return true;
}
Body of Second Method:
{
    if (aid == null)
        return false;
    // If a prefix/subset AID, the total length must be odd (even # of AID chars + '*')
    if ((aid.endsWith("*") || aid.endsWith("#")) && ((aid.length() % 2) == 0)) {
        Log.e(TAG, "AID " + aid + " is not a valid AID.");
        return false;
    }
    // If not a prefix/subset AID, the total length must be even (even # of AID chars)
    if ((!(aid.endsWith("*") || aid.endsWith("#"))) && ((aid.length() % 2) != 0)) {
        Log.e(TAG, "AID " + aid + " is not a valid AID.");
        return false;
    }
    // Verify hex characters
    if (!AID_PATTERN.matcher(aid).matches()) {
        Log.e(TAG, "AID " + aid + " is not a valid AID.");
        return false;
    }
    return true;
}
------------------------
Find a silently evolved API code:android.telecom.ConnectionServiceAdapter.queryRemoteConnectionServices:COMMENT
Method Modifier: default     hidden      
Comment:/**
 * Retrieves a list of remote connection services usable to place calls.
 */

Body of Frist Method:
{
    // Only supported when there is only one adapter.
    if (mAdapters.size() == 1) {
        try {
            mAdapters.iterator().next().queryRemoteConnectionServices(callback, Log.getExternalSession());
        } catch (RemoteException e) {
            Log.e(this, e, "Exception trying to query for remote CSs");
        }
    }
}
Body of Second Method:
{
    // Only supported when there is only one adapter.
    if (mAdapters.size() == 1) {
        try {
            mAdapters.iterator().next().queryRemoteConnectionServices(callback, callingPackage, Log.getExternalSession());
        } catch (RemoteException e) {
            Log.e(this, e, "Exception trying to query for remote CSs");
        }
    } else {
        try {
            // This is not an error condition, so just pass back an empty list.
            // This happens when querying from a remote connection service, not the connection
            // manager itself.
            callback.onResult(Collections.EMPTY_LIST, Collections.EMPTY_LIST);
        } catch (RemoteException e) {
            Log.e(this, e, "Exception trying to query for remote CSs");
        }
    }
}
------------------------
Find a silently evolved API code:android.view.ViewPropertyAnimator.AnimatorEventListener.onAnimationUpdate:COMMENT
Method Modifier: public      
Comment:/**
 * Calculate the current value for each property and set it on the view. Invalidate
 * the view object appropriately, depending on which properties are being animated.
 *
 * @param animation The animator associated with the properties that need to be
 * set. This animator holds the animation fraction which we will use to calculate
 * the current value of each property.
 */

Body of Frist Method:
{
    PropertyBundle propertyBundle = mAnimatorMap.get(animation);
    if (propertyBundle == null) {
        // Shouldn't happen, but just to play it safe
        return;
    }
    boolean hardwareAccelerated = mView.isHardwareAccelerated();
    // alpha requires slightly different treatment than the other (transform) properties.
    // The logic in setAlpha() is not simply setting mAlpha, plus the invalidation
    // logic is dependent on how the view handles an internal call to onSetAlpha().
    // We track what kinds of properties are set, and how alpha is handled when it is
    // set, and perform the invalidation steps appropriately.
    boolean alphaHandled = false;
    if (!hardwareAccelerated) {
        mView.invalidateParentCaches();
    }
    float fraction = animation.getAnimatedFraction();
    int propertyMask = propertyBundle.mPropertyMask;
    if ((propertyMask & TRANSFORM_MASK) != 0) {
        mView.invalidateViewProperty(hardwareAccelerated, false);
    }
    ArrayList<NameValuesHolder> valueList = propertyBundle.mNameValuesHolder;
    if (valueList != null) {
        int count = valueList.size();
        for (int i = 0; i < count; ++i) {
            NameValuesHolder values = valueList.get(i);
            float value = values.mFromValue + fraction * values.mDeltaValue;
            if (values.mNameConstant == ALPHA) {
                alphaHandled = mView.setAlphaNoInvalidation(value);
            } else {
                setValue(values.mNameConstant, value);
            }
        }
    }
    if ((propertyMask & TRANSFORM_MASK) != 0) {
        if (!hardwareAccelerated) {
            // force another invalidation
            mView.mPrivateFlags |= View.PFLAG_DRAWN;
        }
    }
    // via the call to setAlphaNoInvalidation(), above
    if (alphaHandled) {
        mView.invalidate(true);
    } else {
        mView.invalidateViewProperty(false, false);
    }
    if (mUpdateListener != null) {
        mUpdateListener.onAnimationUpdate(animation);
    }
}
Body of Second Method:
{
    PropertyBundle propertyBundle = mAnimatorMap.get(animation);
    if (propertyBundle == null) {
        // Shouldn't happen, but just to play it safe
        return;
    }
    boolean hardwareAccelerated = mView.isHardwareAccelerated();
    if (!hardwareAccelerated) {
        mView.invalidateParentCaches();
    }
    float fraction = animation.getAnimatedFraction();
    int propertyMask = propertyBundle.mPropertyMask;
    if ((propertyMask & TRANSFORM_MASK) != 0) {
        mView.invalidateViewProperty(hardwareAccelerated, false);
    }
    ArrayList<NameValuesHolder> valueList = propertyBundle.mNameValuesHolder;
    if (valueList != null) {
        int count = valueList.size();
        for (int i = 0; i < count; ++i) {
            NameValuesHolder values = valueList.get(i);
            float value = values.mFromValue + fraction * values.mDeltaValue;
            setValue(values.mNameConstant, value);
        }
    }
    if ((propertyMask & TRANSFORM_MASK) != 0) {
        if (!hardwareAccelerated) {
            // force another invalidation
            mView.mPrivateFlags |= View.PFLAG_DRAWN;
        }
    }
    mView.invalidateViewProperty(false, false);
    if (mUpdateListener != null) {
        mUpdateListener.onAnimationUpdate(animation);
    }
}
------------------------
Find a silently evolved API code:android.nfc.NfcAdapter.enableForegroundNdefPush:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * Enable NDEF message push over NFC while this Activity is in the foreground.
 *
 * <p>You must explicitly call this method every time the activity is
 * resumed, and you must call {@link #disableForegroundNdefPush} before
 * your activity completes {@link Activity#onPause}.
 *
 * <p>Strongly recommend to use the new {@link #setNdefPushMessage}
 * instead: it automatically hooks into your activity life-cycle,
 * so you do not need to call enable/disable in your onResume/onPause.
 *
 * <p>For NDEF push to function properly the other NFC device must
 * support either NFC Forum's SNEP (Simple Ndef Exchange Protocol), or
 * Android's "com.android.npp" (Ndef Push Protocol). This was optional
 * on Gingerbread level Android NFC devices, but SNEP is mandatory on
 * Ice-Cream-Sandwich and beyond.
 *
 * <p>This method must be called from the main thread.
 *
 * <p class="note">Requires the {@link android.Manifest.permission#NFC} permission.
 *
 * @param activity foreground activity
 * @param message a NDEF Message to push over NFC
 * @throws IllegalStateException if the activity is not currently in the foreground
 * @throws UnsupportedOperationException if FEATURE_NFC is unavailable.
 * @deprecated use {@link #setNdefPushMessage} instead
 */

Body of Frist Method:
{
    synchronized (NfcAdapter.class) {
        if (!sHasNfcFeature) {
            throw new UnsupportedOperationException();
        }
    }
    if (activity == null || message == null) {
        throw new NullPointerException();
    }
    enforceResumed(activity);
    mNfcActivityManager.setNdefPushMessage(activity, message, 0);
}
Body of Second Method:
{
    synchronized (NfcAdapter.class) {
        if (!sHasNfcFeature) {
            throw new UnsupportedOperationException();
        }
        if (!sHasBeamFeature) {
            return;
        }
    }
    if (activity == null || message == null) {
        throw new NullPointerException();
    }
    enforceResumed(activity);
    mNfcActivityManager.setNdefPushMessage(activity, message, 0);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothMap.getState:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the current state of the BluetoothMap service.
 *
 * @return One of the STATE_ return codes, or STATE_ERROR if this proxy object is currently not
 * connected to the Map service.
 */

Body of Frist Method:
{
    if (VDBG)
        log("getState()");
    final IBluetoothMap service = mService;
    if (service != null) {
        try {
            return service.getState();
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            log(Log.getStackTraceString(new Throwable()));
    }
    return BluetoothMap.STATE_ERROR;
}
Body of Second Method:
{
    if (VDBG)
        log("getState()");
    final IBluetoothMap service = getService();
    if (service != null) {
        try {
            return service.getState();
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            log(Log.getStackTraceString(new Throwable()));
    }
    return BluetoothMap.STATE_ERROR;
}
------------------------
Find a silently evolved API code:android.transition.Transition.matchInstances:COMMENT
Method Modifier: private     
Comment:/**
 * Match start/end values by View instance. Adds matched values to mStartValuesList
 * and mEndValuesList and removes them from unmatchedStart and unmatchedEnd.
 */

Body of Frist Method:
{
    for (int i = unmatchedStart.size() - 1; i >= 0; i--) {
        View view = unmatchedStart.keyAt(i);
        if (view != null && isValidTarget(view)) {
            TransitionValues end = unmatchedEnd.remove(view);
            if (end != null && end.view != null && isValidTarget(end.view)) {
                TransitionValues start = unmatchedStart.removeAt(i);
                mStartValuesList.add(start);
                mEndValuesList.add(end);
            }
        }
    }
}
Body of Second Method:
{
    for (int i = unmatchedStart.size() - 1; i >= 0; i--) {
        View view = unmatchedStart.keyAt(i);
        if (view != null && isValidTarget(view)) {
            TransitionValues end = unmatchedEnd.remove(view);
            if (end != null && isValidTarget(end.view)) {
                TransitionValues start = unmatchedStart.removeAt(i);
                mStartValuesList.add(start);
                mEndValuesList.add(end);
            }
        }
    }
}
------------------------
Find a silently evolved API code:android.media.AudioAttributes.Builder.setContentType:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the attribute describing the content type of the audio signal, such as speech,
 * or music.
 * @param contentType the content type values, one of
 * {@link AudioAttributes#CONTENT_TYPE_MOVIE},
 * {@link AudioAttributes#CONTENT_TYPE_MUSIC},
 * {@link AudioAttributes#CONTENT_TYPE_SONIFICATION},
 * {@link AudioAttributes#CONTENT_TYPE_SPEECH},
 * {@link AudioAttributes#CONTENT_TYPE_UNKNOWN}.
 * @return the same Builder instance.
 */

Body of Frist Method:
{
    switch(contentType) {
        case CONTENT_TYPE_UNKNOWN:
        case CONTENT_TYPE_MOVIE:
        case CONTENT_TYPE_MUSIC:
        case CONTENT_TYPE_SONIFICATION:
        case CONTENT_TYPE_SPEECH:
            mContentType = contentType;
            break;
        default:
            mUsage = CONTENT_TYPE_UNKNOWN;
    }
    return this;
}
Body of Second Method:
{
    switch(contentType) {
        case CONTENT_TYPE_UNKNOWN:
        case CONTENT_TYPE_MOVIE:
        case CONTENT_TYPE_MUSIC:
        case CONTENT_TYPE_SONIFICATION:
        case CONTENT_TYPE_SPEECH:
            mContentType = contentType;
            break;
        default:
            mContentType = CONTENT_TYPE_UNKNOWN;
    }
    return this;
}
------------------------
Find a silently evolved API code:android.media.AudioFormat.getChannelCount:COMMENT
Method Modifier: public      
Comment:/**
 * Return the channel count.
 * @return the channel count derived from the channel position mask or the channel index mask.
 * Zero is returned if both the channel position mask and the channel index mask are not set.
 */

Body of Frist Method:
{
    final int channelIndexCount = Integer.bitCount(getChannelIndexMask());
    int channelCount = channelCountFromOutChannelMask(getChannelMask());
    if (channelCount == 0) {
        channelCount = channelIndexCount;
    } else if (channelCount != channelIndexCount && channelIndexCount != 0) {
        // position and index channel count mismatch
        channelCount = 0;
    }
    return channelCount;
}
Body of Second Method:
{
    return mChannelCount;
}
------------------------
Find a silently evolved API code:android.widget.TextInputTimePickerView.updateTextInputValues:COMMENT
Method Modifier: default     hidden      
Comment:/**
 * Computes the display value and updates the text of the view.
 * <p>
 * This method should be called whenever the current value or display
 * properties (leading zeroes, max digits) change.
 */

Body of Frist Method:
{
    final String hourFormat = "%d";
    final String minuteFormat = "%02d";
    mIs24Hour = is24Hour;
    mHourFormatStartsAtZero = hourFormatStartsAtZero;
    mAmPmSpinner.setVisibility(is24Hour ? View.INVISIBLE : View.VISIBLE);
    if (amOrPm == AM) {
        mAmPmSpinner.setSelection(0);
    } else {
        mAmPmSpinner.setSelection(1);
    }
    mHourEditText.setText(String.format(hourFormat, localizedHour));
    mMinuteEditText.setText(String.format(minuteFormat, minute));
    if (mErrorShowing) {
        validateInput();
    }
}
Body of Second Method:
{
    final String hourFormat = "%d";
    final String minuteFormat = "%02d";
    mIs24Hour = is24Hour;
    mHourFormatStartsAtZero = hourFormatStartsAtZero;
    mAmPmSpinner.setVisibility(is24Hour ? View.INVISIBLE : View.VISIBLE);
    if (amOrPm == AM) {
        mAmPmSpinner.setSelection(0);
    } else {
        mAmPmSpinner.setSelection(1);
    }
    if (isTimeSet()) {
        mHourEditText.setText(String.format(hourFormat, localizedHour));
        mMinuteEditText.setText(String.format(minuteFormat, minute));
    } else {
        mHourEditText.setHint(String.format(hourFormat, localizedHour));
        mMinuteEditText.setHint(String.format(minuteFormat, minute));
    }
    if (mErrorShowing) {
        validateInput();
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothA2dpSink.getConnectedDevices:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (VDBG)
        log("getConnectedDevices()");
    final IBluetoothA2dpSink service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.getConnectedDevices();
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
Body of Second Method:
{
    if (VDBG)
        log("getConnectedDevices()");
    final IBluetoothA2dpSink service = getService();
    if (service != null && isEnabled()) {
        try {
            return service.getConnectedDevices();
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
------------------------
Find a silently evolved API code:android.app.usage.UsageEvents.Event.getObfuscatedIfInstantApp:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if ((mFlags & FLAG_IS_PACKAGE_INSTANT_APP) == 0) {
        return this;
    }
    final Event ret = new Event(this);
    ret.mPackage = INSTANT_APP_PACKAGE_NAME;
    ret.mClass = INSTANT_APP_CLASS_NAME;
    // which instant apps can't use anyway, so there's no need to hide them.
    return ret;
}
Body of Second Method:
{
    if (!isInstantApp()) {
        return this;
    }
    final Event ret = new Event(this);
    ret.mPackage = INSTANT_APP_PACKAGE_NAME;
    ret.mClass = INSTANT_APP_CLASS_NAME;
    // which instant apps can't use anyway, so there's no need to hide them.
    return ret;
}
------------------------
Find a silently evolved API code:android.widget.ProgressBar.setSecondaryProgressTintMode:COMMENT
Method Modifier: public      
Comment:/**
 * Specifies the blending mode used to apply the tint specified by
 * {@link #setSecondaryProgressTintList(ColorStateList)}} to the secondary
 * progress indicator. The default mode is
 * {@link PorterDuff.Mode#SRC_ATOP}.
 *
 * @param tintMode the blending mode used to apply the tint, may be
 * {@code null} to clear tint
 * @attr ref android.R.styleable#ProgressBar_secondaryProgressTintMode
 * @see #setSecondaryProgressTintList(ColorStateList)
 * @see Drawable#setTintMode(PorterDuff.Mode)
 */

Body of Frist Method:
{
    if (mProgressTintInfo == null) {
        mProgressTintInfo = new ProgressTintInfo();
    }
    mProgressTintInfo.mSecondaryProgressTintMode = tintMode;
    mProgressTintInfo.mHasSecondaryProgressTintMode = true;
    if (mProgressDrawable != null) {
        applySecondaryProgressTint();
    }
}
Body of Second Method:
{
    setSecondaryProgressTintBlendMode(tintMode != null ? BlendMode.fromValue(tintMode.nativeInt) : null);
}
------------------------
Find a silently evolved API code:android.os.RemoteCallbackList.dump:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    pw.print(prefix);
    pw.print("callbacks: ");
    pw.println(mCallbacks.size());
    pw.print(prefix);
    pw.print("killed: ");
    pw.println(mKilled);
    pw.print(prefix);
    pw.print("broadcasts count: ");
    pw.println(mBroadcastCount);
}
Body of Second Method:
{
    synchronized (mCallbacks) {
        pw.print(prefix);
        pw.print("callbacks: ");
        pw.println(mCallbacks.size());
        pw.print(prefix);
        pw.print("killed: ");
        pw.println(mKilled);
        pw.print(prefix);
        pw.print("broadcasts count: ");
        pw.println(mBroadcastCount);
    }
}
------------------------
Find a silently evolved API code:android.text.BoringLayout.isBoring:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Returns null if not boring; the width, ascent, and descent in the
 * provided Metrics object (or a new one if the provided one was null)
 * if boring.
 * @hide
 */

Body of Frist Method:
{
    final int textLength = text.length();
    if (hasAnyInterestingChars(text, textLength)) {
        // There are some interesting characters. Not boring.
        return null;
    }
    if (textDir != null && textDir.isRtl(text, 0, textLength)) {
        // The heuristic considers the whole text RTL. Not boring.
        return null;
    }
    if (text instanceof Spanned) {
        Spanned sp = (Spanned) text;
        Object[] styles = sp.getSpans(0, textLength, ParagraphStyle.class);
        if (styles.length > 0) {
            // There are some PargraphStyle spans. Not boring.
            return null;
        }
    }
    Metrics fm = metrics;
    if (fm == null) {
        fm = new Metrics();
    } else {
        fm.reset();
    }
    TextLine line = TextLine.obtain();
    line.set(paint, text, 0, textLength, Layout.DIR_LEFT_TO_RIGHT, Layout.DIRS_ALL_LEFT_TO_RIGHT, false, null);
    fm.width = (int) Math.ceil(line.metrics(fm));
    TextLine.recycle(line);
    return fm;
}
Body of Second Method:
{
    final int textLength = text.length();
    if (hasAnyInterestingChars(text, textLength)) {
        // There are some interesting characters. Not boring.
        return null;
    }
    if (textDir != null && textDir.isRtl(text, 0, textLength)) {
        // The heuristic considers the whole text RTL. Not boring.
        return null;
    }
    if (text instanceof Spanned) {
        Spanned sp = (Spanned) text;
        Object[] styles = sp.getSpans(0, textLength, ParagraphStyle.class);
        if (styles.length > 0) {
            // There are some ParagraphStyle spans. Not boring.
            return null;
        }
    }
    Metrics fm = metrics;
    if (fm == null) {
        fm = new Metrics();
    } else {
        fm.reset();
    }
    TextLine line = TextLine.obtain();
    line.set(paint, text, 0, textLength, Layout.DIR_LEFT_TO_RIGHT, Layout.DIRS_ALL_LEFT_TO_RIGHT, false, null, 0, /* ellipsisStart, 0 since text has not been ellipsized at this point */
    0);
    fm.width = (int) Math.ceil(line.metrics(fm));
    TextLine.recycle(line);
    return fm;
}
------------------------
Find a silently evolved API code:android.graphics.Picture.getHeight:COMMENT
Method Modifier: public      
Comment:/**
 * Get the height of the picture as passed to beginRecording. This
 * does not reflect (per se) the content of the picture.
 */

Body of Frist Method:
{
    return nativeGetHeight(mNativePicture);
}
Body of Second Method:
{
    verifyValid();
    return nativeGetHeight(mNativePicture);
}
------------------------

