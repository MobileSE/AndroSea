Find a silently evolved API code:android.text.SpanSet.recycle:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Removes all internal references to the spans to avoid memory leaks.
 */

Body of Frist Method:
{
    // The spans array is guaranteed to be not null when numberOfSpans is > 0
    for (int i = 0; i < numberOfSpans; i++) {
        // prevent a leak: no reference kept when TextLine is recycled
        spans[i] = null;
    }
}
Body of Second Method:
{
    if (spans != null) {
        Arrays.fill(spans, 0, numberOfSpans, null);
    }
}
------------------------
Find a silently evolved API code:android.media.audiofx.AutomaticGainControl.create:COMMENT
Method Modifier: public      static      
Comment:/**
 * Creates an AutomaticGainControl and attaches it to the AudioRecord on the audio
 * session specified.
 * @param audioSession system wide unique audio session identifier. The AutomaticGainControl
 * will be applied to the AudioRecord with the same audio session.
 * @return AutomaticGainControl created or null if the device does not implement AGC.
 */

Body of Frist Method:
{
    AutomaticGainControl agc = null;
    try {
        agc = new AutomaticGainControl(audioSession);
    } catch (IllegalArgumentException e) {
        Log.w(TAG, "not implemented on this device " + agc);
    } catch (UnsupportedOperationException e) {
        Log.w(TAG, "not enough resources");
    } catch (RuntimeException e) {
        Log.w(TAG, "not enough memory");
    } finally {
        return agc;
    }
}
Body of Second Method:
{
    AutomaticGainControl agc = null;
    try {
        agc = new AutomaticGainControl(audioSession);
    } catch (IllegalArgumentException e) {
        Log.w(TAG, "not implemented on this device " + agc);
    } catch (UnsupportedOperationException e) {
        Log.w(TAG, "not enough resources");
    } catch (RuntimeException e) {
        Log.w(TAG, "not enough memory");
    }
    return agc;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothAdapter.getState:COMMENT
Method Modifier: public      
Comment:/**
 * Get the current state of the local Bluetooth adapter.
 * <p>Possible return values are
 * {@link #STATE_OFF},
 * {@link #STATE_TURNING_ON},
 * {@link #STATE_ON},
 * {@link #STATE_TURNING_OFF}.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}
 *
 * @return current state of Bluetooth adapter
 */

Body of Frist Method:
{
    try {
        synchronized (mManagerCallback) {
            if (mService != null) {
                int state = mService.getState();
                if (VDBG)
                    Log.d(TAG, "" + hashCode() + ": getState(). Returning " + state);
                return state;
            }
        // TODO(BT) there might be a small gap during STATE_TURNING_ON that
        // mService is null, handle that case
        }
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    if (DBG)
        Log.d(TAG, "" + hashCode() + ": getState() :  mService = null. Returning STATE_OFF");
    return STATE_OFF;
}
Body of Second Method:
{
    try {
        synchronized (mManagerCallback) {
            if (mService != null) {
                int state = mService.getState();
                if (VDBG)
                    Log.d(TAG, "" + hashCode() + ": getState(). Returning " + state);
                // consider all internal states as OFF
                if (state == BluetoothAdapter.STATE_BLE_ON || state == BluetoothAdapter.STATE_BLE_TURNING_ON || state == BluetoothAdapter.STATE_BLE_TURNING_OFF) {
                    if (VDBG)
                        Log.d(TAG, "Consider internal state as OFF");
                    state = BluetoothAdapter.STATE_OFF;
                }
                return state;
            }
        // TODO(BT) there might be a small gap during STATE_TURNING_ON that
        // mService is null, handle that case
        }
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return STATE_OFF;
}
------------------------
Find a silently evolved API code:android.widget.TextView.getCompoundDrawables:COMMENT
Method Modifier: public      
Comment:/**
 * Returns drawables for the left, top, right, and bottom borders.
 *
 * @attr ref android.R.styleable#TextView_drawableLeft
 * @attr ref android.R.styleable#TextView_drawableTop
 * @attr ref android.R.styleable#TextView_drawableRight
 * @attr ref android.R.styleable#TextView_drawableBottom
 */

Body of Frist Method:
{
    final Drawables dr = mDrawables;
    if (dr != null) {
        return new Drawable[] { dr.mDrawableLeft, dr.mDrawableTop, dr.mDrawableRight, dr.mDrawableBottom };
    } else {
        return new Drawable[] { null, null, null, null };
    }
}
Body of Second Method:
{
    final Drawables dr = mDrawables;
    if (dr != null) {
        return dr.mShowing.clone();
    } else {
        return new Drawable[] { null, null, null, null };
    }
}
------------------------
Find a silently evolved API code:android.telephony.ServiceState.fillInNotifierBundle:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Set intent notifier Bundle based on service state.
 *
 * @param m intent notifier Bundle
 * @hide
 */

Body of Frist Method:
{
    m.putInt("voiceRegState", mVoiceRegState);
    m.putInt("dataRegState", mDataRegState);
    m.putInt("voiceRoamingType", mVoiceRoamingType);
    m.putInt("dataRoamingType", mDataRoamingType);
    m.putString("operator-alpha-long", mVoiceOperatorAlphaLong);
    m.putString("operator-alpha-short", mVoiceOperatorAlphaShort);
    m.putString("operator-numeric", mVoiceOperatorNumeric);
    m.putString("data-operator-alpha-long", mDataOperatorAlphaLong);
    m.putString("data-operator-alpha-short", mDataOperatorAlphaShort);
    m.putString("data-operator-numeric", mDataOperatorNumeric);
    m.putBoolean("manual", Boolean.valueOf(mIsManualNetworkSelection));
    m.putInt("radioTechnology", mRilVoiceRadioTechnology);
    m.putInt("dataRadioTechnology", mRilDataRadioTechnology);
    m.putBoolean("cssIndicator", mCssIndicator);
    m.putInt("networkId", mNetworkId);
    m.putInt("systemId", mSystemId);
    m.putInt("cdmaRoamingIndicator", mCdmaRoamingIndicator);
    m.putInt("cdmaDefaultRoamingIndicator", mCdmaDefaultRoamingIndicator);
    m.putBoolean("emergencyOnly", Boolean.valueOf(mIsEmergencyOnly));
}
Body of Second Method:
{
    m.putInt("voiceRegState", mVoiceRegState);
    m.putInt("dataRegState", mDataRegState);
    m.putInt("voiceRoamingType", mVoiceRoamingType);
    m.putInt("dataRoamingType", mDataRoamingType);
    m.putString("operator-alpha-long", mVoiceOperatorAlphaLong);
    m.putString("operator-alpha-short", mVoiceOperatorAlphaShort);
    m.putString("operator-numeric", mVoiceOperatorNumeric);
    m.putString("data-operator-alpha-long", mDataOperatorAlphaLong);
    m.putString("data-operator-alpha-short", mDataOperatorAlphaShort);
    m.putString("data-operator-numeric", mDataOperatorNumeric);
    m.putBoolean("manual", Boolean.valueOf(mIsManualNetworkSelection));
    m.putInt("radioTechnology", mRilVoiceRadioTechnology);
    m.putInt("dataRadioTechnology", mRilDataRadioTechnology);
    m.putBoolean("cssIndicator", mCssIndicator);
    m.putInt("networkId", mNetworkId);
    m.putInt("systemId", mSystemId);
    m.putInt("cdmaRoamingIndicator", mCdmaRoamingIndicator);
    m.putInt("cdmaDefaultRoamingIndicator", mCdmaDefaultRoamingIndicator);
    m.putBoolean("emergencyOnly", Boolean.valueOf(mIsEmergencyOnly));
    m.putBoolean("isDataRoamingFromRegistration", Boolean.valueOf(mIsDataRoamingFromRegistration));
}
------------------------
Find a silently evolved API code:android.media.tv.TvTrackInfo.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Used to package this object into a {@link Parcel}.
 *
 * @param dest The {@link Parcel} to be written.
 * @param flags The flags used for parceling.
 */

Body of Frist Method:
{
    dest.writeInt(mType);
    dest.writeString(mId);
    dest.writeString(mLanguage);
    dest.writeInt(mAudioChannelCount);
    dest.writeInt(mAudioSampleRate);
    dest.writeInt(mVideoWidth);
    dest.writeInt(mVideoHeight);
    dest.writeFloat(mVideoFrameRate);
    dest.writeBundle(mExtra);
}
Body of Second Method:
{
    dest.writeInt(mType);
    dest.writeString(mId);
    dest.writeString(mLanguage);
    dest.writeString(mDescription != null ? mDescription.toString() : null);
    dest.writeInt(mAudioChannelCount);
    dest.writeInt(mAudioSampleRate);
    dest.writeInt(mVideoWidth);
    dest.writeInt(mVideoHeight);
    dest.writeFloat(mVideoFrameRate);
    dest.writeFloat(mVideoPixelAspectRatio);
    dest.writeBundle(mExtra);
}
------------------------
Find a silently evolved API code:android.transition.Transition.matchItemIds:COMMENT
Method Modifier: private     
Comment:/**
 * Match start/end values by Adapter item ID. Adds matched values to mStartValuesList
 * and mEndValuesList and removes them from unmatchedStart and unmatchedEnd, using
 * startItemIds and endItemIds as a guide for which Views have unique item IDs.
 */

Body of Frist Method:
{
    int numStartIds = startItemIds.size();
    for (int i = 0; i < numStartIds; i++) {
        View startView = startItemIds.valueAt(i);
        if (startView != null) {
            View endView = endItemIds.get(startItemIds.keyAt(i));
            if (endView != null) {
                TransitionValues startValues = unmatchedStart.get(startView);
                TransitionValues endValues = unmatchedEnd.get(endView);
                if (startValues != null && endValues != null) {
                    mStartValuesList.add(startValues);
                    mEndValuesList.add(endValues);
                    unmatchedStart.remove(startView);
                    unmatchedEnd.remove(endView);
                }
            }
        }
    }
}
Body of Second Method:
{
    int numStartIds = startItemIds.size();
    for (int i = 0; i < numStartIds; i++) {
        View startView = startItemIds.valueAt(i);
        if (startView != null && isValidTarget(startView)) {
            View endView = endItemIds.get(startItemIds.keyAt(i));
            if (endView != null && isValidTarget(endView)) {
                TransitionValues startValues = unmatchedStart.get(startView);
                TransitionValues endValues = unmatchedEnd.get(endView);
                if (startValues != null && endValues != null) {
                    mStartValuesList.add(startValues);
                    mEndValuesList.add(endValues);
                    unmatchedStart.remove(startView);
                    unmatchedEnd.remove(endView);
                }
            }
        }
    }
}
------------------------
Find a silently evolved API code:android.webkit.WebView.clearMatches:COMMENT
Method Modifier: public      
Comment:/**
 * Clears the highlighting surrounding text matches created by
 * {@link #findAllAsync}.
 */

Body of Frist Method:
{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, "clearMatches");
    mProvider.clearMatches();
}
Body of Second Method:
{
    checkThread();
    mProvider.clearMatches();
}
------------------------
Find a silently evolved API code:javax.obex.ServerSession.close:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Closes the server session - in detail close I/O streams and the
 * underlying transport layer. Internal flag is also set so that later
 * attempt to read/write will throw an exception.
 */

Body of Frist Method:
{
    if (mListener != null) {
        mListener.onClose();
    }
    try {
        mInput.close();
        mOutput.close();
        mTransport.close();
        mClosed = true;
    } catch (Exception e) {
    }
    mTransport = null;
    mInput = null;
    mOutput = null;
    mListener = null;
}
Body of Second Method:
{
    if (mListener != null) {
        mListener.onClose();
    }
    try {
        /* Set state to closed before interrupting the thread by closing the streams */
        mClosed = true;
        if (mInput != null)
            mInput.close();
        if (mOutput != null)
            mOutput.close();
        if (mTransport != null)
            mTransport.close();
    } catch (Exception e) {
        if (V)
            Log.d(TAG, "Exception occured during close() - ignore", e);
    }
    mTransport = null;
    mInput = null;
    mOutput = null;
    mListener = null;
}
------------------------
Find a silently evolved API code:android.speech.tts.TextToSpeech.setLanguage:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the text-to-speech language.
 * The TTS engine will try to use the closest match to the specified
 * language as represented by the Locale, but there is no guarantee that the exact same Locale
 * will be used. Use {@link #isLanguageAvailable(Locale)} to check the level of support
 * before choosing the language to use for the next utterances.
 *
 * This method sets the current voice to the default one for the given Locale;
 * {@link #getVoice()} can be used to retrieve it.
 *
 * @param loc The locale describing the language to be used.
 *
 * @return Code indicating the support status for the locale. See {@link #LANG_AVAILABLE},
 * {@link #LANG_COUNTRY_AVAILABLE}, {@link #LANG_COUNTRY_VAR_AVAILABLE},
 * {@link #LANG_MISSING_DATA} and {@link #LANG_NOT_SUPPORTED}.
 */

Body of Frist Method:
{
    return runAction(new Action<Integer>() {

        @Override
        public Integer run(ITextToSpeechService service) throws RemoteException {
            if (loc == null) {
                return LANG_NOT_SUPPORTED;
            }
            String language = null, country = null;
            try {
                language = loc.getISO3Language();
            } catch (MissingResourceException e) {
                Log.w(TAG, "Couldn't retrieve ISO 639-2/T language code for locale: " + loc, e);
                return LANG_NOT_SUPPORTED;
            }
            try {
                country = loc.getISO3Country();
            } catch (MissingResourceException e) {
                Log.w(TAG, "Couldn't retrieve ISO 3166 country code for locale: " + loc, e);
                return LANG_NOT_SUPPORTED;
            }
            String variant = loc.getVariant();
            // As of API level 21, setLanguage is implemented using setVoice.
            // (which, in the default implementation, will call loadLanguage on the service
            // interface).
            // Sanitize locale using isLanguageAvailable.
            int result = service.isLanguageAvailable(language, country, variant);
            if (result >= LANG_AVAILABLE) {
                if (result < LANG_COUNTRY_VAR_AVAILABLE) {
                    variant = "";
                    if (result < LANG_COUNTRY_AVAILABLE) {
                        country = "";
                    }
                }
                // Get the default voice for the locale.
                String voiceName = service.getDefaultVoiceNameFor(language, country, variant);
                if (TextUtils.isEmpty(voiceName)) {
                    Log.w(TAG, "Couldn't find the default voice for " + language + "/" + country + "/" + variant);
                    return LANG_NOT_SUPPORTED;
                }
                // Load it.
                if (service.loadVoice(getCallerIdentity(), voiceName) == TextToSpeech.ERROR) {
                    return LANG_NOT_SUPPORTED;
                }
                mParams.putString(Engine.KEY_PARAM_VOICE_NAME, voiceName);
                mParams.putString(Engine.KEY_PARAM_LANGUAGE, language);
                mParams.putString(Engine.KEY_PARAM_COUNTRY, country);
                mParams.putString(Engine.KEY_PARAM_VARIANT, variant);
            }
            return result;
        }
    }, LANG_NOT_SUPPORTED, "setLanguage");
}
Body of Second Method:
{
    return runAction(new Action<Integer>() {

        @Override
        public Integer run(ITextToSpeechService service) throws RemoteException {
            if (loc == null) {
                return LANG_NOT_SUPPORTED;
            }
            String language = null, country = null;
            try {
                language = loc.getISO3Language();
            } catch (MissingResourceException e) {
                Log.w(TAG, "Couldn't retrieve ISO 639-2/T language code for locale: " + loc, e);
                return LANG_NOT_SUPPORTED;
            }
            try {
                country = loc.getISO3Country();
            } catch (MissingResourceException e) {
                Log.w(TAG, "Couldn't retrieve ISO 3166 country code for locale: " + loc, e);
                return LANG_NOT_SUPPORTED;
            }
            String variant = loc.getVariant();
            // As of API level 21, setLanguage is implemented using setVoice.
            // (which, in the default implementation, will call loadLanguage on the service
            // interface).
            // Sanitize locale using isLanguageAvailable.
            int result = service.isLanguageAvailable(language, country, variant);
            if (result >= LANG_AVAILABLE) {
                // Get the default voice for the locale.
                String voiceName = service.getDefaultVoiceNameFor(language, country, variant);
                if (TextUtils.isEmpty(voiceName)) {
                    Log.w(TAG, "Couldn't find the default voice for " + language + "-" + country + "-" + variant);
                    return LANG_NOT_SUPPORTED;
                }
                // Load it.
                if (service.loadVoice(getCallerIdentity(), voiceName) == TextToSpeech.ERROR) {
                    Log.w(TAG, "The service claimed " + language + "-" + country + "-" + variant + " was available with voice name " + voiceName + " but loadVoice returned ERROR");
                    return LANG_NOT_SUPPORTED;
                }
                // Set the language/country/variant of the voice, so #getLanguage will return
                // the currently set voice locale when called.
                Voice voice = getVoice(service, voiceName);
                if (voice == null) {
                    Log.w(TAG, "getDefaultVoiceNameFor returned " + voiceName + " for locale " + language + "-" + country + "-" + variant + " but getVoice returns null");
                    return LANG_NOT_SUPPORTED;
                }
                String voiceLanguage = "";
                try {
                    voiceLanguage = voice.getLocale().getISO3Language();
                } catch (MissingResourceException e) {
                    Log.w(TAG, "Couldn't retrieve ISO 639-2/T language code for locale: " + voice.getLocale(), e);
                }
                String voiceCountry = "";
                try {
                    voiceCountry = voice.getLocale().getISO3Country();
                } catch (MissingResourceException e) {
                    Log.w(TAG, "Couldn't retrieve ISO 3166 country code for locale: " + voice.getLocale(), e);
                }
                mParams.putString(Engine.KEY_PARAM_VOICE_NAME, voiceName);
                mParams.putString(Engine.KEY_PARAM_LANGUAGE, voiceLanguage);
                mParams.putString(Engine.KEY_PARAM_COUNTRY, voiceCountry);
                mParams.putString(Engine.KEY_PARAM_VARIANT, voice.getLocale().getVariant());
            }
            return result;
        }
    }, LANG_NOT_SUPPORTED, "setLanguage");
}
------------------------
Find a silently evolved API code:android.graphics.Canvas.restore:COMMENT
Method Modifier: public      
Comment:/**
 * This call balances a previous call to save(), and is used to remove all
 * modifications to the matrix/clip state since the last save call. It is
 * an error to call restore() more times than save() was called.
 */

Body of Frist Method:
{
    native_restore(mNativeCanvasWrapper);
}
Body of Second Method:
{
    boolean throwOnUnderflow = !sCompatibilityRestore || !isHardwareAccelerated();
    native_restore(mNativeCanvasWrapper, throwOnUnderflow);
}
------------------------
Find a silently evolved API code:android.inputmethodservice.InputMethodService.InputMethodImpl.showSoftInput:COMMENT
Method Modifier: public      
Comment:/**
 * Handle a request by the system to show the soft input area.
 */

Body of Frist Method:
{
    if (DEBUG)
        Log.v(TAG, "showSoftInput()");
    boolean wasVis = isInputViewShown();
    mShowInputFlags = 0;
    if (onShowInputRequested(flags, false)) {
        try {
            showWindow(true);
        } catch (BadTokenException e) {
            if (DEBUG)
                Log.v(TAG, "BadTokenException: IME is done.");
            mWindowVisible = false;
            mWindowAdded = false;
        }
    }
    // If user uses hard keyboard, IME button should always be shown.
    boolean showing = isInputViewShown();
    mImm.setImeWindowStatus(mToken, IME_ACTIVE | (showing ? IME_VISIBLE : 0), mBackDisposition);
    if (resultReceiver != null) {
        resultReceiver.send(wasVis != isInputViewShown() ? InputMethodManager.RESULT_SHOWN : (wasVis ? InputMethodManager.RESULT_UNCHANGED_SHOWN : InputMethodManager.RESULT_UNCHANGED_HIDDEN), null);
    }
}
Body of Second Method:
{
    if (DEBUG)
        Log.v(TAG, "showSoftInput()");
    boolean wasVis = isInputViewShown();
    mShowInputFlags = 0;
    if (onShowInputRequested(flags, false)) {
        try {
            showWindow(true);
        } catch (BadTokenException e) {
            if (DEBUG)
                Log.v(TAG, "BadTokenException: IME is done.");
            mWindowVisible = false;
            mWindowAdded = false;
        }
    }
    clearInsetOfPreviousIme();
    // If user uses hard keyboard, IME button should always be shown.
    boolean showing = isInputViewShown();
    mImm.setImeWindowStatus(mToken, IME_ACTIVE | (showing ? IME_VISIBLE : 0), mBackDisposition);
    if (resultReceiver != null) {
        resultReceiver.send(wasVis != isInputViewShown() ? InputMethodManager.RESULT_SHOWN : (wasVis ? InputMethodManager.RESULT_UNCHANGED_SHOWN : InputMethodManager.RESULT_UNCHANGED_HIDDEN), null);
    }
}
------------------------
Find a silently evolved API code:android.graphics.Atlas.SlicePolicy.insert:COMMENT
Method Modifier: private     
Comment:/**
 * Attempts to pack a rectangle of specified dimensions in the available
 * empty space.
 *
 * @param cell The cell representing free space in which to pack the rectangle
 * @param prev The previous cell in the free space linked list
 * @param width The width of the rectangle to pack
 * @param height The height of the rectangle to pack
 * @param entry Stores the location of the packged rectangle, if it fits
 *
 * @return True if the rectangle was packed in the atlas, false otherwise
 */

Body of Frist Method:
{
    boolean rotated = false;
    // if possible before giving up
    if (cell.width < width || cell.height < height) {
        if (mAllowRotation) {
            if (cell.width < height || cell.height < width) {
                return false;
            }
            // Rotate the rectangle
            int temp = width;
            width = height;
            height = temp;
            rotated = true;
        } else {
            return false;
        }
    }
    // Remaining free space after packing the rectangle
    int deltaWidth = cell.width - width;
    int deltaHeight = cell.height - height;
    // Split the remaining free space into two new cells
    Cell first = new Cell();
    Cell second = new Cell();
    first.x = cell.x + width + mPadding;
    first.y = cell.y;
    first.width = deltaWidth - mPadding;
    second.x = cell.x;
    second.y = cell.y + height + mPadding;
    second.height = deltaHeight - mPadding;
    if (mSplitDecision.splitHorizontal(deltaWidth, deltaHeight, width, height)) {
        first.height = height;
        second.width = cell.width;
    } else {
        first.height = cell.height;
        second.width = width;
        // The order of the cells matters for efficient packing
        // We want to give priority to the cell chosen by the
        // split decision heuristic
        Cell temp = first;
        first = second;
        second = temp;
    }
    // Remove degenerate cases to keep the free list as small as possible
    if (first.width > 0 && first.height > 0) {
        prev.next = first;
        prev = first;
    }
    if (second.width > 0 && second.height > 0) {
        prev.next = second;
        second.next = cell.next;
    } else {
        prev.next = cell.next;
    }
    // The cell is now completely removed from the free list
    cell.next = null;
    // Return the location and rotation of the packed rectangle
    entry.x = cell.x;
    entry.y = cell.y;
    entry.rotated = rotated;
    return true;
}
Body of Second Method:
{
    if (cell.width < width || cell.height < height) {
        return false;
    }
    // Remaining free space after packing the rectangle
    int deltaWidth = cell.width - width;
    int deltaHeight = cell.height - height;
    // Split the remaining free space into two new cells
    Cell first = new Cell();
    Cell second = new Cell();
    first.x = cell.x + width + mPadding;
    first.y = cell.y;
    first.width = deltaWidth - mPadding;
    second.x = cell.x;
    second.y = cell.y + height + mPadding;
    second.height = deltaHeight - mPadding;
    if (mSplitDecision.splitHorizontal(deltaWidth, deltaHeight, width, height)) {
        first.height = height;
        second.width = cell.width;
    } else {
        first.height = cell.height;
        second.width = width;
        // The order of the cells matters for efficient packing
        // We want to give priority to the cell chosen by the
        // split decision heuristic
        Cell temp = first;
        first = second;
        second = temp;
    }
    // Remove degenerate cases to keep the free list as small as possible
    if (first.width > 0 && first.height > 0) {
        prev.next = first;
        prev = first;
    }
    if (second.width > 0 && second.height > 0) {
        prev.next = second;
        second.next = cell.next;
    } else {
        prev.next = cell.next;
    }
    // The cell is now completely removed from the free list
    cell.next = null;
    // Return the location and rotation of the packed rectangle
    entry.x = cell.x;
    entry.y = cell.y;
    return true;
}
------------------------
Find a silently evolved API code:android.hardware.camera2.utils.TaskDrainer.taskFinished:COMMENT
Method Modifier: public      
Comment:/**
 * Mark an asynchronous task as having finished.
 *
 * <p>A task cannot be finished if it hasn't started. Once finished, a task
 * cannot be finished again (unless it's started again).</p>
 *
 * @param task a key to identify a task
 *
 * @see #taskStarted
 * @see #beginDrain
 *
 * @throws IllegalStateException
 * If attempting to start a task which is already finished (and not re-started),
 */

Body of Frist Method:
{
    synchronized (mLock) {
        if (VERBOSE) {
            Log.v(TAG + "[" + mName + "]", "taskFinished " + task);
        }
        if (!mTaskSet.remove(task)) {
            throw new IllegalStateException("Task " + task + " was already finished");
        }
        // If this is the last finished task and draining has already begun, fire #onDrained
        checkIfDrainFinished();
    }
}
Body of Second Method:
{
    synchronized (mLock) {
        if (DEBUG) {
            Log.v(TAG + "[" + mName + "]", "taskFinished " + task);
        }
        if (!mTaskSet.remove(task)) {
            throw new IllegalStateException("Task " + task + " was already finished");
        }
        // If this is the last finished task and draining has already begun, fire #onDrained
        checkIfDrainFinished();
    }
}
------------------------
Find a silently evolved API code:android.app.LoaderManagerImpl.destroyLoader:COMMENT
Method Modifier: public      
Comment:/**
 * Rip down, tear apart, shred to pieces a current Loader ID.  After returning
 * from this function, any Loader objects associated with this ID are
 * destroyed.  Any data associated with them is destroyed.  You better not
 * be using it when you do this.
 * @param id Identifier of the Loader to be destroyed.
 */

Body of Frist Method:
{
    if (mCreatingLoader) {
        throw new IllegalStateException("Called while creating a loader");
    }
    if (DEBUG)
        Log.v(TAG, "destroyLoader in " + this + " of " + id);
    int idx = mLoaders.indexOfKey(id);
    if (idx >= 0) {
        LoaderInfo info = mLoaders.valueAt(idx);
        mLoaders.removeAt(idx);
        info.destroy();
    }
    idx = mInactiveLoaders.indexOfKey(id);
    if (idx >= 0) {
        LoaderInfo info = mInactiveLoaders.valueAt(idx);
        mInactiveLoaders.removeAt(idx);
        info.destroy();
    }
    if (mActivity != null && !hasRunningLoaders()) {
        mActivity.mFragments.startPendingDeferredFragments();
    }
}
Body of Second Method:
{
    if (mCreatingLoader) {
        throw new IllegalStateException("Called while creating a loader");
    }
    if (DEBUG)
        Log.v(TAG, "destroyLoader in " + this + " of " + id);
    int idx = mLoaders.indexOfKey(id);
    if (idx >= 0) {
        LoaderInfo info = mLoaders.valueAt(idx);
        mLoaders.removeAt(idx);
        info.destroy();
    }
    idx = mInactiveLoaders.indexOfKey(id);
    if (idx >= 0) {
        LoaderInfo info = mInactiveLoaders.valueAt(idx);
        mInactiveLoaders.removeAt(idx);
        info.destroy();
    }
    if (mHost != null && !hasRunningLoaders()) {
        mHost.mFragmentManager.startPendingDeferredFragments();
    }
}
------------------------
Find a silently evolved API code:android.service.dreams.DreamService.attach:COMMENT
Method Modifier: private     final       
Comment:/**
 * Called when the Dream is ready to be shown.
 *
 * Must run on mHandler.
 *
 * @param windowToken A window token that will allow a window to be created in the correct layer.
 */

Body of Frist Method:
{
    if (mWindowToken != null) {
        Slog.e(TAG, "attach() called when already attached with token=" + mWindowToken);
        return;
    }
    if (mFinished || mWaking) {
        Slog.w(TAG, "attach() called after dream already finished");
        try {
            mSandman.finishSelf(windowToken, true);
        } catch (RemoteException ex) {
        // system server died
        }
        return;
    }
    mWindowToken = windowToken;
    mCanDoze = canDoze;
    if (mWindowless && !mCanDoze) {
        throw new IllegalStateException("Only doze dreams can be windowless");
    }
    if (!mWindowless) {
        mWindow = PolicyManager.makeNewWindow(this);
        mWindow.setCallback(this);
        mWindow.requestFeature(Window.FEATURE_NO_TITLE);
        mWindow.setBackgroundDrawable(new ColorDrawable(0xFF000000));
        mWindow.setFormat(PixelFormat.OPAQUE);
        if (mDebug)
            Slog.v(TAG, String.format("Attaching window token: %s to window of type %s", windowToken, WindowManager.LayoutParams.TYPE_DREAM));
        WindowManager.LayoutParams lp = mWindow.getAttributes();
        lp.type = WindowManager.LayoutParams.TYPE_DREAM;
        lp.token = windowToken;
        lp.windowAnimations = com.android.internal.R.style.Animation_Dream;
        lp.flags |= (WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR | WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED | WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD | WindowManager.LayoutParams.FLAG_ALLOW_LOCK_WHILE_SCREEN_ON | (mFullscreen ? WindowManager.LayoutParams.FLAG_FULLSCREEN : 0) | (mScreenBright ? WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON : 0));
        mWindow.setAttributes(lp);
        // Workaround: Currently low-profile and in-window system bar backgrounds don't go
        // along well. Dreams usually don't need such bars anyways, so disable them by default.
        mWindow.clearFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);
        mWindow.setWindowManager(null, windowToken, "dream", true);
        applySystemUiVisibilityFlags((mLowProfile ? View.SYSTEM_UI_FLAG_LOW_PROFILE : 0), View.SYSTEM_UI_FLAG_LOW_PROFILE);
        try {
            getWindowManager().addView(mWindow.getDecorView(), mWindow.getAttributes());
        } catch (WindowManager.BadTokenException ex) {
            // This can happen because the dream manager service will remove the token
            // immediately without necessarily waiting for the dream to start.
            // We should receive a finish message soon.
            Slog.i(TAG, "attach() called after window token already removed, dream will " + "finish soon");
            mWindow = null;
            return;
        }
    }
    // We need to defer calling onDreamingStarted until after onWindowAttached,
    // which is posted to the handler by addView, so we post onDreamingStarted
    // to the handler also.  Need to watch out here in case detach occurs before
    // this callback is invoked.
    mHandler.post(new Runnable() {

        @Override
        public void run() {
            if (mWindow != null || mWindowless) {
                if (mDebug)
                    Slog.v(TAG, "Calling onDreamingStarted()");
                mStarted = true;
                onDreamingStarted();
            }
        }
    });
}
Body of Second Method:
{
    if (mWindowToken != null) {
        Slog.e(TAG, "attach() called when already attached with token=" + mWindowToken);
        return;
    }
    if (mFinished || mWaking) {
        Slog.w(TAG, "attach() called after dream already finished");
        try {
            mSandman.finishSelf(windowToken, true);
        } catch (RemoteException ex) {
        // system server died
        }
        return;
    }
    mWindowToken = windowToken;
    mCanDoze = canDoze;
    if (mWindowless && !mCanDoze) {
        throw new IllegalStateException("Only doze dreams can be windowless");
    }
    if (!mWindowless) {
        mWindow = new PhoneWindow(this);
        mWindow.setCallback(this);
        mWindow.requestFeature(Window.FEATURE_NO_TITLE);
        mWindow.setBackgroundDrawable(new ColorDrawable(0xFF000000));
        mWindow.setFormat(PixelFormat.OPAQUE);
        if (mDebug)
            Slog.v(TAG, String.format("Attaching window token: %s to window of type %s", windowToken, WindowManager.LayoutParams.TYPE_DREAM));
        WindowManager.LayoutParams lp = mWindow.getAttributes();
        lp.type = WindowManager.LayoutParams.TYPE_DREAM;
        lp.token = windowToken;
        lp.windowAnimations = com.android.internal.R.style.Animation_Dream;
        lp.flags |= (WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR | WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED | WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD | WindowManager.LayoutParams.FLAG_ALLOW_LOCK_WHILE_SCREEN_ON | (mFullscreen ? WindowManager.LayoutParams.FLAG_FULLSCREEN : 0) | (mScreenBright ? WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON : 0));
        mWindow.setAttributes(lp);
        // Workaround: Currently low-profile and in-window system bar backgrounds don't go
        // along well. Dreams usually don't need such bars anyways, so disable them by default.
        mWindow.clearFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);
        mWindow.setWindowManager(null, windowToken, "dream", true);
        applySystemUiVisibilityFlags((mLowProfile ? View.SYSTEM_UI_FLAG_LOW_PROFILE : 0), View.SYSTEM_UI_FLAG_LOW_PROFILE);
        try {
            getWindowManager().addView(mWindow.getDecorView(), mWindow.getAttributes());
        } catch (WindowManager.BadTokenException ex) {
            // This can happen because the dream manager service will remove the token
            // immediately without necessarily waiting for the dream to start.
            // We should receive a finish message soon.
            Slog.i(TAG, "attach() called after window token already removed, dream will " + "finish soon");
            mWindow = null;
            return;
        }
    }
    // We need to defer calling onDreamingStarted until after onWindowAttached,
    // which is posted to the handler by addView, so we post onDreamingStarted
    // to the handler also.  Need to watch out here in case detach occurs before
    // this callback is invoked.
    mHandler.post(new Runnable() {

        @Override
        public void run() {
            if (mWindow != null || mWindowless) {
                if (mDebug)
                    Slog.v(TAG, "Calling onDreamingStarted()");
                mStarted = true;
                onDreamingStarted();
            }
        }
    });
}
------------------------
Find a silently evolved API code:android.media.AudioManager.setBluetoothA2dpDeviceConnectionState:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Indicate A2DP source or sink connection state change.
 * @param device Bluetooth device connected/disconnected
 * @param state  new connection state (BluetoothProfile.STATE_xxx)
 * @param profile profile for the A2DP device
 * (either {@link android.bluetooth.BluetoothProfile.A2DP} or
 * {@link android.bluetooth.BluetoothProfile.A2DP_SINK})
 * @return a delay in ms that the caller should wait before broadcasting
 * BluetoothA2dp.ACTION_CONNECTION_STATE_CHANGED intent.
 * {@hide}
 */

Body of Frist Method:
{
    IAudioService service = getService();
    int delay = 0;
    try {
        delay = service.setBluetoothA2dpDeviceConnectionState(device, state, profile);
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in setBluetoothA2dpDeviceConnectionState " + e);
    } finally {
        return delay;
    }
}
Body of Second Method:
{
    IAudioService service = getService();
    int delay = 0;
    try {
        delay = service.setBluetoothA2dpDeviceConnectionState(device, state, profile);
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in setBluetoothA2dpDeviceConnectionState " + e);
    }
    return delay;
}
------------------------
Find a silently evolved API code:android.accounts.AccountManager.getAccountsForPackage:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 * For use by internal activities. Returns the list of accounts that the calling package
 * is authorized to use, particularly for shared accounts.
 * @param packageName package name of the calling app.
 * @param uid the uid of the calling app.
 * @return the accounts that are available to this package and user.
 */

Body of Frist Method:
{
    try {
        return mService.getAccountsForPackage(packageName, uid);
    } catch (RemoteException re) {
        // possible security exception
        throw new RuntimeException(re);
    }
}
Body of Second Method:
{
    try {
        return mService.getAccountsForPackage(packageName, uid, mContext.getOpPackageName());
    } catch (RemoteException re) {
        // won't ever happen
        throw new RuntimeException(re);
    }
}
------------------------
Find a silently evolved API code:android.content.ContentResolver.insert:COMMENT
Method Modifier: public      final       
Comment:/**
 * Inserts a row into a table at the given URL.
 *
 * If the content provider supports transactions the insertion will be atomic.
 *
 * @param url The URL of the table to insert into.
 * @param values The initial values for the newly inserted row. The key is the column name for
 * the field. Passing an empty ContentValues will create an empty row.
 * @return the URL of the newly created row.
 */

Body of Frist Method:
{
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        throw new IllegalArgumentException("Unknown URL " + url);
    }
    try {
        long startTime = SystemClock.uptimeMillis();
        Uri createdRow = provider.insert(mPackageName, url, values);
        long durationMillis = SystemClock.uptimeMillis() - startTime;
        maybeLogUpdateToEventLog(durationMillis, url, "insert", null);
        return createdRow;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } finally {
        releaseProvider(provider);
    }
}
Body of Second Method:
{
    Preconditions.checkNotNull(url, "url");
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        throw new IllegalArgumentException("Unknown URL " + url);
    }
    try {
        long startTime = SystemClock.uptimeMillis();
        Uri createdRow = provider.insert(mPackageName, url, values);
        long durationMillis = SystemClock.uptimeMillis() - startTime;
        maybeLogUpdateToEventLog(durationMillis, url, "insert", null);
        return createdRow;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } finally {
        releaseProvider(provider);
    }
}
------------------------
Find a silently evolved API code:android.content.ContentResolver.getType:COMMENT
Method Modifier: public      final       
Comment:/**
 * Return the MIME type of the given content URL.
 *
 * @param url A Uri identifying content (either a list or specific type),
 * using the content:// scheme.
 * @return A MIME type for the content, or null if the URL is invalid or the type is unknown
 */

Body of Frist Method:
{
    // XXX would like to have an acquireExistingUnstableProvider for this.
    IContentProvider provider = acquireExistingProvider(url);
    if (provider != null) {
        try {
            return provider.getType(url);
        } catch (RemoteException e) {
            return null;
        } catch (java.lang.Exception e) {
            Log.w(TAG, "Failed to get type for: " + url + " (" + e.getMessage() + ")");
            return null;
        } finally {
            releaseProvider(provider);
        }
    }
    if (!SCHEME_CONTENT.equals(url.getScheme())) {
        return null;
    }
    try {
        String type = ActivityManagerNative.getDefault().getProviderMimeType(ContentProvider.getUriWithoutUserId(url), resolveUserId(url));
        return type;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } catch (java.lang.Exception e) {
        Log.w(TAG, "Failed to get type for: " + url + " (" + e.getMessage() + ")");
        return null;
    }
}
Body of Second Method:
{
    Preconditions.checkNotNull(url, "url");
    // XXX would like to have an acquireExistingUnstableProvider for this.
    IContentProvider provider = acquireExistingProvider(url);
    if (provider != null) {
        try {
            return provider.getType(url);
        } catch (RemoteException e) {
            return null;
        } catch (java.lang.Exception e) {
            Log.w(TAG, "Failed to get type for: " + url + " (" + e.getMessage() + ")");
            return null;
        } finally {
            releaseProvider(provider);
        }
    }
    if (!SCHEME_CONTENT.equals(url.getScheme())) {
        return null;
    }
    try {
        String type = ActivityManagerNative.getDefault().getProviderMimeType(ContentProvider.getUriWithoutUserId(url), resolveUserId(url));
        return type;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } catch (java.lang.Exception e) {
        Log.w(TAG, "Failed to get type for: " + url + " (" + e.getMessage() + ")");
        return null;
    }
}
------------------------
Find a silently evolved API code:android.hardware.camera2.marshal.impl.MarshalQueryableEnum.registerEnumValues:COMMENT
Method Modifier: public      static      
Comment:/**
 * Register a non-sequential set of values to be used with the marshal/unmarshal functions.
 *
 * <p>This enables get/set to correctly marshal the enum into a value that is C-compatible.</p>
 *
 * @param enumType The class for an enum
 * @param values A list of values mapping to the ordinals of the enum
 */

Body of Frist Method:
{
    if (enumType.getEnumConstants().length != values.length) {
        throw new IllegalArgumentException("Expected values array to be the same size as the enumTypes values " + values.length + " for type " + enumType);
    }
    if (VERBOSE) {
        Log.v(TAG, "Registered enum values for type " + enumType + " values");
    }
    sEnumValues.put(enumType, values);
}
Body of Second Method:
{
    if (enumType.getEnumConstants().length != values.length) {
        throw new IllegalArgumentException("Expected values array to be the same size as the enumTypes values " + values.length + " for type " + enumType);
    }
    if (DEBUG) {
        Log.v(TAG, "Registered enum values for type " + enumType + " values");
    }
    sEnumValues.put(enumType, values);
}
------------------------
Find a silently evolved API code:android.graphics.drawable.RippleDrawable.updateMaskShaderIfNeeded:COMMENT
Method Modifier: private     
Comment:/**
 * @return whether we need to use a mask
 */

Body of Frist Method:
{
    if (mHasValidMask) {
        return;
    }
    final int maskType = getMaskType();
    if (maskType == MASK_UNKNOWN) {
        return;
    }
    mHasValidMask = true;
    final Rect bounds = getBounds();
    if (maskType == MASK_NONE || bounds.isEmpty()) {
        if (mMaskBuffer != null) {
            mMaskBuffer.recycle();
            mMaskBuffer = null;
            mMaskShader = null;
            mMaskCanvas = null;
        }
        mMaskMatrix = null;
        mMaskColorFilter = null;
        return;
    }
    // Ensure we have a correctly-sized buffer.
    if (mMaskBuffer == null || mMaskBuffer.getWidth() != bounds.width() || mMaskBuffer.getHeight() != bounds.height()) {
        if (mMaskBuffer != null) {
            mMaskBuffer.recycle();
        }
        mMaskBuffer = Bitmap.createBitmap(bounds.width(), bounds.height(), Bitmap.Config.ALPHA_8);
        mMaskShader = new BitmapShader(mMaskBuffer, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP);
        mMaskCanvas = new Canvas(mMaskBuffer);
    } else {
        mMaskBuffer.eraseColor(Color.TRANSPARENT);
    }
    if (mMaskMatrix == null) {
        mMaskMatrix = new Matrix();
    } else {
        mMaskMatrix.reset();
    }
    if (mMaskColorFilter == null) {
        mMaskColorFilter = new PorterDuffColorFilter(0, PorterDuff.Mode.SRC_IN);
    }
    // Draw the appropriate mask.
    if (maskType == MASK_EXPLICIT) {
        drawMask(mMaskCanvas);
    } else if (maskType == MASK_CONTENT) {
        drawContent(mMaskCanvas);
    }
}
Body of Second Method:
{
    if (mHasValidMask) {
        return;
    }
    final int maskType = getMaskType();
    if (maskType == MASK_UNKNOWN) {
        return;
    }
    mHasValidMask = true;
    final Rect bounds = getBounds();
    if (maskType == MASK_NONE || bounds.isEmpty()) {
        if (mMaskBuffer != null) {
            mMaskBuffer.recycle();
            mMaskBuffer = null;
            mMaskShader = null;
            mMaskCanvas = null;
        }
        mMaskMatrix = null;
        mMaskColorFilter = null;
        return;
    }
    // Ensure we have a correctly-sized buffer.
    if (mMaskBuffer == null || mMaskBuffer.getWidth() != bounds.width() || mMaskBuffer.getHeight() != bounds.height()) {
        if (mMaskBuffer != null) {
            mMaskBuffer.recycle();
        }
        mMaskBuffer = Bitmap.createBitmap(bounds.width(), bounds.height(), Bitmap.Config.ALPHA_8);
        mMaskShader = new BitmapShader(mMaskBuffer, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP);
        mMaskCanvas = new Canvas(mMaskBuffer);
    } else {
        mMaskBuffer.eraseColor(Color.TRANSPARENT);
    }
    if (mMaskMatrix == null) {
        mMaskMatrix = new Matrix();
    } else {
        mMaskMatrix.reset();
    }
    if (mMaskColorFilter == null) {
        mMaskColorFilter = new PorterDuffColorFilter(0, PorterDuff.Mode.SRC_IN);
    }
    // Draw the appropriate mask anchored to (0,0).
    final int left = bounds.left;
    final int top = bounds.top;
    mMaskCanvas.translate(-left, -top);
    if (maskType == MASK_EXPLICIT) {
        drawMask(mMaskCanvas);
    } else if (maskType == MASK_CONTENT) {
        drawContent(mMaskCanvas);
    }
    mMaskCanvas.translate(left, top);
}
------------------------
Find a silently evolved API code:android.app.WallpaperManager.setResource:COMMENT
Method Modifier: public      
Comment:/**
 * Change the current system wallpaper to the bitmap in the given resource.
 * The resource is opened as a raw data stream and copied into the
 * wallpaper; it must be a valid PNG or JPEG image.  On success, the intent
 * {@link Intent#ACTION_WALLPAPER_CHANGED} is broadcast.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#SET_WALLPAPER}.
 *
 * @param resid The bitmap to save.
 *
 * @throws IOException If an error occurs reverting to the built-in
 * wallpaper.
 */

Body of Frist Method:
{
    if (sGlobals.mService == null) {
        Log.w(TAG, "WallpaperService not running");
        return;
    }
    try {
        Resources resources = mContext.getResources();
        /* Set the wallpaper to the default values */
        ParcelFileDescriptor fd = sGlobals.mService.setWallpaper("res:" + resources.getResourceName(resid));
        if (fd != null) {
            FileOutputStream fos = null;
            try {
                fos = new ParcelFileDescriptor.AutoCloseOutputStream(fd);
                setWallpaper(resources.openRawResource(resid), fos);
            } finally {
                if (fos != null) {
                    fos.close();
                }
            }
        }
    } catch (RemoteException e) {
    // Ignore
    }
}
Body of Second Method:
{
    if (sGlobals.mService == null) {
        Log.w(TAG, "WallpaperService not running");
        return;
    }
    try {
        Resources resources = mContext.getResources();
        /* Set the wallpaper to the default values */
        ParcelFileDescriptor fd = sGlobals.mService.setWallpaper("res:" + resources.getResourceName(resid), mContext.getOpPackageName());
        if (fd != null) {
            FileOutputStream fos = null;
            try {
                fos = new ParcelFileDescriptor.AutoCloseOutputStream(fd);
                setWallpaper(resources.openRawResource(resid), fos);
            } finally {
                if (fos != null) {
                    fos.close();
                }
            }
        }
    } catch (RemoteException e) {
    // Ignore
    }
}
------------------------
Find a silently evolved API code:android.app.AlarmManager.set:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    setImpl(type, triggerAtMillis, windowMillis, intervalMillis, operation, workSource, null);
}
Body of Second Method:
{
    setImpl(type, triggerAtMillis, windowMillis, intervalMillis, 0, operation, workSource, null);
}
------------------------
Find a silently evolved API code:android.widget.TextView.setTextLocale:COMMENT
Method Modifier: public      
Comment:/**
 * Set the default {@link Locale} of the text in this TextView to the given value. This value
 * is used to choose appropriate typefaces for ambiguous characters. Typically used for CJK
 * locales to disambiguate Hanzi/Kanji/Hanja characters.
 *
 * @param locale the {@link Locale} for drawing text, must not be null.
 *
 * @see Paint#setTextLocale
 */

Body of Frist Method:
{
    mTextPaint.setTextLocale(locale);
}
Body of Second Method:
{
    mLocaleChanged = true;
    mTextPaint.setTextLocale(locale);
}
------------------------
Find a silently evolved API code:android.net.NetworkAgent.sendNetworkCapabilities:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Called by the bearer code when it has new NetworkCapabilities data.
 */

Body of Frist Method:
{
    queueOrSendMessage(EVENT_NETWORK_CAPABILITIES_CHANGED, new NetworkCapabilities(networkCapabilities));
}
Body of Second Method:
{
    mPollLcePending.set(false);
    mLastBwRefreshTime = System.currentTimeMillis();
    queueOrSendMessage(EVENT_NETWORK_CAPABILITIES_CHANGED, new NetworkCapabilities(networkCapabilities));
}
------------------------
Find a silently evolved API code:android.content.res.BridgeResources.throwException:COMMENT
Method Modifier: private     
Comment:/**
 * Builds and throws a {@link Resources.NotFoundException} based on a resource id and a resource type.
 * @param id the id of the resource
 * @throws NotFoundException
 */

Body of Frist Method:
{
    // first get the String related to this id in the framework
    Pair<ResourceType, String> resourceInfo = Bridge.resolveResourceId(id);
    // if the name is unknown in the framework, get it from the custom view loader.
    if (resourceInfo == null && mProjectCallback != null) {
        resourceInfo = mProjectCallback.resolveResourceId(id);
    }
    String message = null;
    if (resourceInfo != null) {
        message = String.format("Could not find %1$s resource matching value 0x%2$X (resolved name: %3$s) in current configuration.", resourceInfo.getFirst(), id, resourceInfo.getSecond());
    } else {
        message = String.format("Could not resolve resource value: 0x%1$X.", id);
    }
    throw new NotFoundException(message);
}
Body of Second Method:
{
    // first get the String related to this id in the framework
    Pair<ResourceType, String> resourceInfo = Bridge.resolveResourceId(id);
    // if the name is unknown in the framework, get it from the custom view loader.
    if (resourceInfo == null && mLayoutlibCallback != null) {
        resourceInfo = mLayoutlibCallback.resolveResourceId(id);
    }
    String message;
    if (resourceInfo != null) {
        message = String.format("Could not find %1$s resource matching value 0x%2$X (resolved name: %3$s) in current configuration.", resourceInfo.getFirst(), id, resourceInfo.getSecond());
    } else {
        message = String.format("Could not resolve resource value: 0x%1$X.", id);
    }
    throw new NotFoundException(message);
}
------------------------
Find a silently evolved API code:android.net.VpnService.prepareAndAuthorize:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Version of {@link #prepare(Context)} which does not require user consent.
 *
 * <p>Requires {@link android.Manifest.permission#CONTROL_VPN} and should generally not be
 * used. Only acceptable in situations where user consent has been obtained through other means.
 *
 * <p>Once this is run, future preparations may be done with the standard prepare method as this
 * will authorize the package to prepare the VPN without consent in the future.
 *
 * @hide
 */

Body of Frist Method:
{
    IConnectivityManager cm = getService();
    String packageName = context.getPackageName();
    try {
        // Only prepare if we're not already prepared.
        if (!cm.prepareVpn(packageName, null)) {
            cm.prepareVpn(null, packageName);
        }
        cm.setVpnPackageAuthorization(true);
    } catch (RemoteException e) {
    // ignore
    }
}
Body of Second Method:
{
    IConnectivityManager cm = getService();
    String packageName = context.getPackageName();
    try {
        // Only prepare if we're not already prepared.
        int userId = UserHandle.myUserId();
        if (!cm.prepareVpn(packageName, null, userId)) {
            cm.prepareVpn(null, packageName, userId);
        }
        cm.setVpnPackageAuthorization(packageName, userId, true);
    } catch (RemoteException e) {
    // ignore
    }
}
------------------------
Find a silently evolved API code:android.graphics.Canvas_Delegate.getImageToDraw:COMMENT
Method Modifier: private     static      
Comment:/**
 * Returns a BufferedImage ready for drawing, based on the bitmap and paint delegate.
 * The image returns, through a 1-size boolean array, whether the drawing code should
 * use a SRC composite no matter what the paint says.
 *
 * @param bitmap the bitmap
 * @param paint the paint that will be used to draw
 * @param forceSrcMode whether the composite will have to be SRC
 * @return the image to draw
 */

Body of Frist Method:
{
    BufferedImage image = bitmap.getImage();
    forceSrcMode[0] = false;
    // before drawing it.
    if (bitmap.getConfig() == Bitmap.Config.ALPHA_8) {
        fixAlpha8Bitmap(image);
    } else if (bitmap.hasAlpha() == false) {
        // to 0xFF.
        if (paint != null) {
            Xfermode_Delegate xfermodeDelegate = paint.getXfermode();
            if (xfermodeDelegate instanceof PorterDuffXfermode_Delegate) {
                PorterDuff.Mode mode = ((PorterDuffXfermode_Delegate) xfermodeDelegate).getMode();
                forceSrcMode[0] = mode == PorterDuff.Mode.SRC_OVER || mode == PorterDuff.Mode.SRC;
            }
        }
        // if we can't force SRC mode, then create a temp bitmap of TYPE_RGB
        if (forceSrcMode[0] == false) {
            image = Bitmap_Delegate.createCopy(image, BufferedImage.TYPE_INT_RGB, 0xFF);
        }
    }
    return image;
}
Body of Second Method:
{
    BufferedImage image = bitmap.getImage();
    forceSrcMode[0] = false;
    // before drawing it.
    if (bitmap.getConfig() == Bitmap.Config.ALPHA_8) {
        fixAlpha8Bitmap(image);
    } else if (!bitmap.hasAlpha()) {
        // to 0xFF.
        if (paint != null) {
            Xfermode_Delegate xfermodeDelegate = paint.getXfermode();
            if (xfermodeDelegate instanceof PorterDuffXfermode_Delegate) {
                PorterDuff.Mode mode = ((PorterDuffXfermode_Delegate) xfermodeDelegate).getMode();
                forceSrcMode[0] = mode == PorterDuff.Mode.SRC_OVER || mode == PorterDuff.Mode.SRC;
            }
        }
        // if we can't force SRC mode, then create a temp bitmap of TYPE_RGB
        if (!forceSrcMode[0]) {
            image = Bitmap_Delegate.createCopy(image, BufferedImage.TYPE_INT_RGB, 0xFF);
        }
    }
    return image;
}
------------------------
Find a silently evolved API code:android.text.SpannableStringBuilder.clearSpans:COMMENT
Method Modifier: public      
Comment:// Documentation from interface

Body of Frist Method:
{
    for (int i = mSpanCount - 1; i >= 0; i--) {
        Object what = mSpans[i];
        int ostart = mSpanStarts[i];
        int oend = mSpanEnds[i];
        if (ostart > mGapStart)
            ostart -= mGapLength;
        if (oend > mGapStart)
            oend -= mGapLength;
        mSpanCount = i;
        mSpans[i] = null;
        sendSpanRemoved(what, ostart, oend);
    }
}
Body of Second Method:
{
    for (int i = mSpanCount - 1; i >= 0; i--) {
        Object what = mSpans[i];
        int ostart = mSpanStarts[i];
        int oend = mSpanEnds[i];
        if (ostart > mGapStart)
            ostart -= mGapLength;
        if (oend > mGapStart)
            oend -= mGapLength;
        mSpanCount = i;
        mSpans[i] = null;
        sendSpanRemoved(what, ostart, oend);
    }
    if (mIndexOfSpan != null) {
        mIndexOfSpan.clear();
    }
}
------------------------
Find a silently evolved API code:android.app.trust.TrustManager.registerTrustListener:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Registers a listener for trust events.
 *
 * Requires the {@link android.Manifest.permission#TRUST_LISTENER} permission.
 */

Body of Frist Method:
{
    try {
        ITrustListener.Stub iTrustListener = new ITrustListener.Stub() {

            @Override
            public void onTrustChanged(boolean enabled, int userId, boolean initiatedByUser) {
                Message m = mHandler.obtainMessage(MSG_TRUST_CHANGED, (enabled ? 1 : 0), userId, trustListener);
                if (initiatedByUser) {
                    m.getData().putBoolean(DATA_INITIATED_BY_USER, initiatedByUser);
                }
                m.sendToTarget();
            }

            @Override
            public void onTrustManagedChanged(boolean managed, int userId) {
                mHandler.obtainMessage(MSG_TRUST_MANAGED_CHANGED, (managed ? 1 : 0), userId, trustListener).sendToTarget();
            }
        };
        mService.registerTrustListener(iTrustListener);
        mTrustListeners.put(trustListener, iTrustListener);
    } catch (RemoteException e) {
        onError(e);
    }
}
Body of Second Method:
{
    try {
        ITrustListener.Stub iTrustListener = new ITrustListener.Stub() {

            @Override
            public void onTrustChanged(boolean enabled, int userId, int flags) {
                Message m = mHandler.obtainMessage(MSG_TRUST_CHANGED, (enabled ? 1 : 0), userId, trustListener);
                if (flags != 0) {
                    m.getData().putInt(DATA_FLAGS, flags);
                }
                m.sendToTarget();
            }

            @Override
            public void onTrustManagedChanged(boolean managed, int userId) {
                mHandler.obtainMessage(MSG_TRUST_MANAGED_CHANGED, (managed ? 1 : 0), userId, trustListener).sendToTarget();
            }
        };
        mService.registerTrustListener(iTrustListener);
        mTrustListeners.put(trustListener, iTrustListener);
    } catch (RemoteException e) {
        onError(e);
    }
}
------------------------
Find a silently evolved API code:android.speech.tts.TextToSpeechService.onGetFeaturesForLanguage:COMMENT
Method Modifier: protected   
Comment:/**
 * Queries the service for a set of features supported for a given language.
 *
 * Can be called on multiple threads.
 *
 * @param lang ISO-3 language code.
 * @param country ISO-3 country code. May be empty or null.
 * @param variant Language variant. May be empty or null.
 * @return A list of features supported for the given language.
 */

Body of Frist Method:
{
    return null;
}
Body of Second Method:
{
    return new HashSet<String>();
}
------------------------
Find a silently evolved API code:android.content.pm.ResolveInfo.loadIcon:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the current graphical icon associated with this resolution.  This
 * will call back on the given PackageManager to load the icon from
 * the application.
 *
 * @param pm A PackageManager from which the icon can be loaded; usually
 * the PackageManager from which you originally retrieved this item.
 *
 * @return Returns a Drawable containing the resolution's icon.  If the
 * item does not have an icon, the default activity icon is returned.
 */

Body of Frist Method:
{
    Drawable dr;
    if (resolvePackageName != null && icon != 0) {
        dr = pm.getDrawable(resolvePackageName, icon, null);
        if (dr != null) {
            return dr;
        }
    }
    ComponentInfo ci = getComponentInfo();
    ApplicationInfo ai = ci.applicationInfo;
    if (icon != 0) {
        dr = pm.getDrawable(ci.packageName, icon, ai);
        if (dr != null) {
            return dr;
        }
    }
    return ci.loadIcon(pm);
}
Body of Second Method:
{
    Drawable dr = null;
    if (resolvePackageName != null && iconResourceId != 0) {
        dr = pm.getDrawable(resolvePackageName, iconResourceId, null);
    }
    ComponentInfo ci = getComponentInfo();
    if (dr == null && iconResourceId != 0) {
        ApplicationInfo ai = ci.applicationInfo;
        dr = pm.getDrawable(ci.packageName, iconResourceId, ai);
    }
    if (dr != null) {
        return pm.getUserBadgedIcon(dr, new UserHandle(UserHandle.myUserId()));
    }
    return ci.loadIcon(pm);
}
------------------------
Find a silently evolved API code:android.widget.ImageView.getDrawable:COMMENT
Method Modifier: public      
Comment:/**
 * Return the view's drawable, or null if no drawable has been
 * assigned.
 */

Body of Frist Method:
{
    return mDrawable;
}
Body of Second Method:
{
    if (mDrawable == mRecycleableBitmapDrawable) {
        // Consider our cached version dirty since app code now has a reference to it
        mRecycleableBitmapDrawable = null;
    }
    return mDrawable;
}
------------------------
Find a silently evolved API code:android.content.ContentProvider.enforceReadPermissionInner:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * {@hide}
 */

Body of Frist Method:
{
    final Context context = getContext();
    final int pid = Binder.getCallingPid();
    final int uid = Binder.getCallingUid();
    String missingPerm = null;
    if (UserHandle.isSameApp(uid, mMyUid)) {
        return;
    }
    if (mExported && checkUser(pid, uid, context)) {
        final String componentPerm = getReadPermission();
        if (componentPerm != null) {
            if (context.checkPermission(componentPerm, pid, uid, callerToken) == PERMISSION_GRANTED) {
                return;
            } else {
                missingPerm = componentPerm;
            }
        }
        // track if unprotected read is allowed; any denied
        // <path-permission> below removes this ability
        boolean allowDefaultRead = (componentPerm == null);
        final PathPermission[] pps = getPathPermissions();
        if (pps != null) {
            final String path = uri.getPath();
            for (PathPermission pp : pps) {
                final String pathPerm = pp.getReadPermission();
                if (pathPerm != null && pp.match(path)) {
                    if (context.checkPermission(pathPerm, pid, uid, callerToken) == PERMISSION_GRANTED) {
                        return;
                    } else {
                        // any denied <path-permission> means we lose
                        // default <provider> access.
                        allowDefaultRead = false;
                        missingPerm = pathPerm;
                    }
                }
            }
        }
        // <provider> permission, then allow access.
        if (allowDefaultRead)
            return;
    }
    // last chance, check against any uri grants
    final int callingUserId = UserHandle.getUserId(uid);
    final Uri userUri = (mSingleUser && !UserHandle.isSameUser(mMyUid, uid)) ? maybeAddUserId(uri, callingUserId) : uri;
    if (context.checkUriPermission(userUri, pid, uid, Intent.FLAG_GRANT_READ_URI_PERMISSION, callerToken) == PERMISSION_GRANTED) {
        return;
    }
    final String failReason = mExported ? " requires " + missingPerm + ", or grantUriPermission()" : " requires the provider be exported, or grantUriPermission()";
    throw new SecurityException("Permission Denial: reading " + ContentProvider.this.getClass().getName() + " uri " + uri + " from pid=" + pid + ", uid=" + uid + failReason);
}
Body of Second Method:
{
    final Context context = getContext();
    final int pid = Binder.getCallingPid();
    final int uid = Binder.getCallingUid();
    String missingPerm = null;
    int strongestMode = MODE_ALLOWED;
    if (UserHandle.isSameApp(uid, mMyUid)) {
        return MODE_ALLOWED;
    }
    if (mExported && checkUser(pid, uid, context)) {
        final String componentPerm = getReadPermission();
        if (componentPerm != null) {
            final int mode = checkPermissionAndAppOp(componentPerm, callingPkg, callerToken);
            if (mode == MODE_ALLOWED) {
                return MODE_ALLOWED;
            } else {
                missingPerm = componentPerm;
                strongestMode = Math.max(strongestMode, mode);
            }
        }
        // track if unprotected read is allowed; any denied
        // <path-permission> below removes this ability
        boolean allowDefaultRead = (componentPerm == null);
        final PathPermission[] pps = getPathPermissions();
        if (pps != null) {
            final String path = uri.getPath();
            for (PathPermission pp : pps) {
                final String pathPerm = pp.getReadPermission();
                if (pathPerm != null && pp.match(path)) {
                    final int mode = checkPermissionAndAppOp(pathPerm, callingPkg, callerToken);
                    if (mode == MODE_ALLOWED) {
                        return MODE_ALLOWED;
                    } else {
                        // any denied <path-permission> means we lose
                        // default <provider> access.
                        allowDefaultRead = false;
                        missingPerm = pathPerm;
                        strongestMode = Math.max(strongestMode, mode);
                    }
                }
            }
        }
        // <provider> permission, then allow access.
        if (allowDefaultRead)
            return MODE_ALLOWED;
    }
    // last chance, check against any uri grants
    final int callingUserId = UserHandle.getUserId(uid);
    final Uri userUri = (mSingleUser && !UserHandle.isSameUser(mMyUid, uid)) ? maybeAddUserId(uri, callingUserId) : uri;
    if (context.checkUriPermission(userUri, pid, uid, Intent.FLAG_GRANT_READ_URI_PERMISSION, callerToken) == PERMISSION_GRANTED) {
        return MODE_ALLOWED;
    }
    // ignored through; otherwise we assume it should be a real error below.
    if (strongestMode == MODE_IGNORED) {
        return MODE_IGNORED;
    }
    final String failReason = mExported ? " requires " + missingPerm + ", or grantUriPermission()" : " requires the provider be exported, or grantUriPermission()";
    throw new SecurityException("Permission Denial: reading " + ContentProvider.this.getClass().getName() + " uri " + uri + " from pid=" + pid + ", uid=" + uid + failReason);
}
------------------------
Find a silently evolved API code:android.widget.TextView.getCompoundPaddingLeft:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the left padding of the view, plus space for the left
 * Drawable if any.
 */

Body of Frist Method:
{
    final Drawables dr = mDrawables;
    if (dr == null || dr.mDrawableLeft == null) {
        return mPaddingLeft;
    } else {
        return mPaddingLeft + dr.mDrawablePadding + dr.mDrawableSizeLeft;
    }
}
Body of Second Method:
{
    final Drawables dr = mDrawables;
    if (dr == null || dr.mShowing[Drawables.LEFT] == null) {
        return mPaddingLeft;
    } else {
        return mPaddingLeft + dr.mDrawablePadding + dr.mDrawableSizeLeft;
    }
}
------------------------
Find a silently evolved API code:android.net.ConnectivityManager.getInstance:COMMENT
<android.net.ConnectivityManager: ConnectivityManager getInstance()>
public      static      hidden      deprecated  ->private     static      hidden      deprecated  
Method Modifier: public      private     static      hidden      deprecated  
Method Modifier: Yes         No          Yes         Yes         Yes         
Method Updated:  No          Yes         Yes         Yes         Yes         
Comment:/**
 * @deprecated - use getSystemService. This is a kludge to support static access in certain
 * situations where a Context pointer is unavailable.
 * @hide
 */

Body of Frist Method:
{
    if (sInstance == null) {
        throw new IllegalStateException("No ConnectivityManager yet constructed");
    }
    return sInstance;
}
Body of Second Method:
{
    if (getInstanceOrNull() == null) {
        throw new IllegalStateException("No ConnectivityManager yet constructed");
    }
    return getInstanceOrNull();
}
------------------------
Find a silently evolved API code:android.util.BridgeXmlPullAttributes.getAttributeNameResource:COMMENT
Method Modifier: public      
Comment:/*
     * (non-Javadoc)
     * @see android.util.XmlPullAttributes#getAttributeNameResource(int)
     *
     * This methods must return com.android.internal.R.attr.<name> matching
     * the name of the attribute.
     * It returns 0 if it doesn't find anything.
     */

Body of Frist Method:
{
    // get the attribute name.
    String name = getAttributeName(index);
    // get the attribute namespace
    String ns = mParser.getAttributeNamespace(index);
    if (BridgeConstants.NS_RESOURCES.equals(ns)) {
        Integer v = Bridge.getResourceId(ResourceType.ATTR, name);
        if (v != null) {
            return v.intValue();
        }
        return 0;
    }
    // the namespaces match.
    if (mContext.getProjectCallback().getNamespace().equals(ns)) {
        Integer v = mContext.getProjectCallback().getResourceId(ResourceType.ATTR, name);
        if (v != null) {
            return v.intValue();
        }
    }
    return 0;
}
Body of Second Method:
{
    // get the attribute name.
    String name = getAttributeName(index);
    // get the attribute namespace
    String ns = mParser.getAttributeNamespace(index);
    if (BridgeConstants.NS_RESOURCES.equals(ns)) {
        Integer v = Bridge.getResourceId(ResourceType.ATTR, name);
        if (v != null) {
            return v.intValue();
        }
        return 0;
    }
    // the namespaces match.
    if (mContext.getLayoutlibCallback().getNamespace().equals(ns)) {
        Integer v = mContext.getLayoutlibCallback().getResourceId(ResourceType.ATTR, name);
        if (v != null) {
            return v.intValue();
        }
    }
    return 0;
}
------------------------
Find a silently evolved API code:android.media.AudioManager.getStreamMaxVolume:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the maximum volume index for a particular stream.
 *
 * @param streamType The stream type whose maximum volume index is returned.
 * @return The maximum valid volume index for the stream.
 * @see #getStreamVolume(int)
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        if (mUseMasterVolume) {
            return service.getMasterMaxVolume();
        } else {
            return service.getStreamMaxVolume(streamType);
        }
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in getStreamMaxVolume", e);
        return 0;
    }
}
Body of Second Method:
{
    IAudioService service = getService();
    try {
        return service.getStreamMaxVolume(streamType);
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in getStreamMaxVolume", e);
        return 0;
    }
}
------------------------
Find a silently evolved API code:android.content.res.BridgeTypedArray.getColorStateList:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the ColorStateList for the attribute at <var>index</var>.
 * The value may be either a single solid color or a reference to
 * a color or complex {@link android.content.res.ColorStateList} description.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return ColorStateList for the attribute, or null if not defined.
 */

Body of Frist Method:
{
    if (!hasValue(index)) {
        return null;
    }
    ResourceValue resValue = mResourceData[index];
    String value = resValue.getValue();
    if (value == null) {
        return null;
    }
    // let the framework inflate the ColorStateList from the XML file.
    File f = new File(value);
    if (f.isFile()) {
        try {
            XmlPullParser parser = ParserFactory.create(f);
            BridgeXmlBlockParser blockParser = new BridgeXmlBlockParser(parser, mContext, resValue.isFramework());
            try {
                return ColorStateList.createFromXml(mContext.getResources(), blockParser);
            } finally {
                blockParser.ensurePopped();
            }
        } catch (XmlPullParserException e) {
            Bridge.getLog().error(LayoutLog.TAG_BROKEN, "Failed to configure parser for " + value, e, null);
            return null;
        } catch (Exception e) {
            // this is an error and not warning since the file existence is checked before
            // attempting to parse it.
            Bridge.getLog().error(LayoutLog.TAG_RESOURCES_READ, "Failed to parse file " + value, e, null);
            return null;
        }
    }
    try {
        int color = ResourceHelper.getColor(value);
        return ColorStateList.valueOf(color);
    } catch (NumberFormatException e) {
        Bridge.getLog().error(LayoutLog.TAG_RESOURCES_FORMAT, e.getMessage(), e, null);
    }
    return null;
}
Body of Second Method:
{
    if (!hasValue(index)) {
        return null;
    }
    ResourceValue resValue = mResourceData[index];
    String value = resValue.getValue();
    if (value == null) {
        return null;
    }
    // let the framework inflate the ColorStateList from the XML file.
    File f = new File(value);
    if (f.isFile()) {
        try {
            XmlPullParser parser = ParserFactory.create(f);
            BridgeXmlBlockParser blockParser = new BridgeXmlBlockParser(parser, mContext, resValue.isFramework());
            try {
                return ColorStateList.createFromXml(mContext.getResources(), blockParser, mContext.getTheme());
            } finally {
                blockParser.ensurePopped();
            }
        } catch (XmlPullParserException e) {
            Bridge.getLog().error(LayoutLog.TAG_BROKEN, "Failed to configure parser for " + value, e, null);
            return null;
        } catch (Exception e) {
            // this is an error and not warning since the file existence is checked before
            // attempting to parse it.
            Bridge.getLog().error(LayoutLog.TAG_RESOURCES_READ, "Failed to parse file " + value, e, null);
            return null;
        }
    }
    try {
        int color = ResourceHelper.getColor(value);
        return ColorStateList.valueOf(color);
    } catch (NumberFormatException e) {
        Bridge.getLog().error(LayoutLog.TAG_RESOURCES_FORMAT, e.getMessage(), e, null);
    }
    return null;
}
------------------------
Find a silently evolved API code:android.media.AudioTrack.audioParamCheck:COMMENT
Method Modifier: private     
Comment:// mDataLoadMode is valid

Body of Frist Method:
{
    // sample rate, note these values are subject to change
    if (sampleRateInHz < SAMPLE_RATE_HZ_MIN || sampleRateInHz > SAMPLE_RATE_HZ_MAX) {
        throw new IllegalArgumentException(sampleRateInHz + "Hz is not a supported sample rate.");
    }
    mSampleRate = sampleRateInHz;
    // --------------
    // channel config
    mChannelConfiguration = channelConfig;
    switch(channelConfig) {
        // AudioFormat.CHANNEL_CONFIGURATION_DEFAULT
        case AudioFormat.CHANNEL_OUT_DEFAULT:
        case AudioFormat.CHANNEL_OUT_MONO:
        case AudioFormat.CHANNEL_CONFIGURATION_MONO:
            mChannelCount = 1;
            mChannels = AudioFormat.CHANNEL_OUT_MONO;
            break;
        case AudioFormat.CHANNEL_OUT_STEREO:
        case AudioFormat.CHANNEL_CONFIGURATION_STEREO:
            mChannelCount = 2;
            mChannels = AudioFormat.CHANNEL_OUT_STEREO;
            break;
        default:
            if (!isMultichannelConfigSupported(channelConfig)) {
                // input channel configuration features unsupported channels
                throw new IllegalArgumentException("Unsupported channel configuration.");
            }
            mChannels = channelConfig;
            mChannelCount = Integer.bitCount(channelConfig);
    }
    // audio format
    if (audioFormat == AudioFormat.ENCODING_DEFAULT) {
        audioFormat = AudioFormat.ENCODING_PCM_16BIT;
    }
    if (!AudioFormat.isValidEncoding(audioFormat)) {
        throw new IllegalArgumentException("Unsupported audio encoding.");
    }
    mAudioFormat = audioFormat;
    // audio load mode
    if (((mode != MODE_STREAM) && (mode != MODE_STATIC)) || ((mode != MODE_STREAM) && !AudioFormat.isEncodingLinearPcm(mAudioFormat))) {
        throw new IllegalArgumentException("Invalid mode.");
    }
    mDataLoadMode = mode;
}
Body of Second Method:
{
    // sample rate, note these values are subject to change
    if (sampleRateInHz < SAMPLE_RATE_HZ_MIN || sampleRateInHz > SAMPLE_RATE_HZ_MAX) {
        throw new IllegalArgumentException(sampleRateInHz + "Hz is not a supported sample rate.");
    }
    mSampleRate = sampleRateInHz;
    // --------------
    // channel config
    mChannelConfiguration = channelConfig;
    switch(channelConfig) {
        // AudioFormat.CHANNEL_CONFIGURATION_DEFAULT
        case AudioFormat.CHANNEL_OUT_DEFAULT:
        case AudioFormat.CHANNEL_OUT_MONO:
        case AudioFormat.CHANNEL_CONFIGURATION_MONO:
            mChannelCount = 1;
            mChannelMask = AudioFormat.CHANNEL_OUT_MONO;
            break;
        case AudioFormat.CHANNEL_OUT_STEREO:
        case AudioFormat.CHANNEL_CONFIGURATION_STEREO:
            mChannelCount = 2;
            mChannelMask = AudioFormat.CHANNEL_OUT_STEREO;
            break;
        default:
            if (channelConfig == AudioFormat.CHANNEL_INVALID && channelIndexMask != 0) {
                mChannelCount = 0;
                // channel index configuration only
                break;
            }
            if (!isMultichannelConfigSupported(channelConfig)) {
                // input channel configuration features unsupported channels
                throw new IllegalArgumentException("Unsupported channel configuration.");
            }
            mChannelMask = channelConfig;
            mChannelCount = AudioFormat.channelCountFromOutChannelMask(channelConfig);
    }
    // check the channel index configuration (if present)
    mChannelIndexMask = channelIndexMask;
    if (mChannelIndexMask != 0) {
        // restrictive: indexMask could allow up to AUDIO_CHANNEL_BITS_LOG2
        final int indexMask = (1 << CHANNEL_COUNT_MAX) - 1;
        if ((channelIndexMask & ~indexMask) != 0) {
            throw new IllegalArgumentException("Unsupported channel index configuration " + channelIndexMask);
        }
        int channelIndexCount = Integer.bitCount(channelIndexMask);
        if (mChannelCount == 0) {
            mChannelCount = channelIndexCount;
        } else if (mChannelCount != channelIndexCount) {
            throw new IllegalArgumentException("Channel count must match");
        }
    }
    // audio format
    if (audioFormat == AudioFormat.ENCODING_DEFAULT) {
        audioFormat = AudioFormat.ENCODING_PCM_16BIT;
    }
    if (!AudioFormat.isPublicEncoding(audioFormat)) {
        throw new IllegalArgumentException("Unsupported audio encoding.");
    }
    mAudioFormat = audioFormat;
    // audio load mode
    if (((mode != MODE_STREAM) && (mode != MODE_STATIC)) || ((mode != MODE_STREAM) && !AudioFormat.isEncodingLinearPcm(mAudioFormat))) {
        throw new IllegalArgumentException("Invalid mode.");
    }
    mDataLoadMode = mode;
}
------------------------
Find a silently evolved API code:android.view.accessibility.AccessibilityRecord.getSource:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the {@link AccessibilityNodeInfo} of the event source.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the received info
 * by calling {@link AccessibilityNodeInfo#recycle() AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 * @return The info of the source.
 */

Body of Frist Method:
{
    enforceSealed();
    if (mConnectionId == UNDEFINED || mSourceWindowId == UNDEFINED || AccessibilityNodeInfo.getAccessibilityViewId(mSourceNodeId) == UNDEFINED) {
        return null;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mSourceWindowId, mSourceNodeId, false, GET_SOURCE_PREFETCH_FLAGS);
}
Body of Second Method:
{
    enforceSealed();
    if (mSourceNode != null) {
        return AccessibilityNodeInfo.obtain(mSourceNode);
    }
    return null;
}
------------------------
Find a silently evolved API code:android.media.AudioRecord.postEventFromNative:COMMENT
Method Modifier: private     static      
Comment:// --------------------

Body of Frist Method:
{
    // logd("Event posted from the native side: event="+ what + " args="+ arg1+" "+arg2);
    AudioRecord recorder = (AudioRecord) ((WeakReference) audiorecord_ref).get();
    if (recorder == null) {
        return;
    }
    if (recorder.mEventHandler != null) {
        Message m = recorder.mEventHandler.obtainMessage(what, arg1, arg2, obj);
        recorder.mEventHandler.sendMessage(m);
    }
}
Body of Second Method:
{
    // logd("Event posted from the native side: event="+ what + " args="+ arg1+" "+arg2);
    AudioRecord recorder = (AudioRecord) ((WeakReference) audiorecord_ref).get();
    if (recorder == null) {
        return;
    }
    if (what == AudioSystem.NATIVE_EVENT_ROUTING_CHANGE) {
        recorder.broadcastRoutingChange();
        return;
    }
    if (recorder.mEventHandler != null) {
        Message m = recorder.mEventHandler.obtainMessage(what, arg1, arg2, obj);
        recorder.mEventHandler.sendMessage(m);
    }
}
------------------------
Find a silently evolved API code:android.view.GestureDetector.onTouchEvent:COMMENT
Method Modifier: public      
Comment:/**
 * Analyzes the given motion event and if applicable triggers the
 * appropriate callbacks on the {@link OnGestureListener} supplied.
 *
 * @param ev The current motion event.
 * @return true if the {@link OnGestureListener} consumed the event,
 * else false.
 */

Body of Frist Method:
{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(ev, 0);
    }
    final int action = ev.getAction();
    if (mVelocityTracker == null) {
        mVelocityTracker = VelocityTracker.obtain();
    }
    mVelocityTracker.addMovement(ev);
    final boolean pointerUp = (action & MotionEvent.ACTION_MASK) == MotionEvent.ACTION_POINTER_UP;
    final int skipIndex = pointerUp ? ev.getActionIndex() : -1;
    // Determine focal point
    float sumX = 0, sumY = 0;
    final int count = ev.getPointerCount();
    for (int i = 0; i < count; i++) {
        if (skipIndex == i)
            continue;
        sumX += ev.getX(i);
        sumY += ev.getY(i);
    }
    final int div = pointerUp ? count - 1 : count;
    final float focusX = sumX / div;
    final float focusY = sumY / div;
    boolean handled = false;
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_POINTER_DOWN:
            mDownFocusX = mLastFocusX = focusX;
            mDownFocusY = mLastFocusY = focusY;
            // Cancel long press and taps
            cancelTaps();
            break;
        case MotionEvent.ACTION_POINTER_UP:
            mDownFocusX = mLastFocusX = focusX;
            mDownFocusY = mLastFocusY = focusY;
            // Check the dot product of current velocities.
            // If the pointer that left was opposing another velocity vector, clear.
            mVelocityTracker.computeCurrentVelocity(1000, mMaximumFlingVelocity);
            final int upIndex = ev.getActionIndex();
            final int id1 = ev.getPointerId(upIndex);
            final float x1 = mVelocityTracker.getXVelocity(id1);
            final float y1 = mVelocityTracker.getYVelocity(id1);
            for (int i = 0; i < count; i++) {
                if (i == upIndex)
                    continue;
                final int id2 = ev.getPointerId(i);
                final float x = x1 * mVelocityTracker.getXVelocity(id2);
                final float y = y1 * mVelocityTracker.getYVelocity(id2);
                final float dot = x + y;
                if (dot < 0) {
                    mVelocityTracker.clear();
                    break;
                }
            }
            break;
        case MotionEvent.ACTION_DOWN:
            if (mDoubleTapListener != null) {
                boolean hadTapMessage = mHandler.hasMessages(TAP);
                if (hadTapMessage)
                    mHandler.removeMessages(TAP);
                if ((mCurrentDownEvent != null) && (mPreviousUpEvent != null) && hadTapMessage && isConsideredDoubleTap(mCurrentDownEvent, mPreviousUpEvent, ev)) {
                    // This is a second tap
                    mIsDoubleTapping = true;
                    // Give a callback with the first tap of the double-tap
                    handled |= mDoubleTapListener.onDoubleTap(mCurrentDownEvent);
                    // Give a callback with down event of the double-tap
                    handled |= mDoubleTapListener.onDoubleTapEvent(ev);
                } else {
                    // This is a first tap
                    mHandler.sendEmptyMessageDelayed(TAP, DOUBLE_TAP_TIMEOUT);
                }
            }
            mDownFocusX = mLastFocusX = focusX;
            mDownFocusY = mLastFocusY = focusY;
            if (mCurrentDownEvent != null) {
                mCurrentDownEvent.recycle();
            }
            mCurrentDownEvent = MotionEvent.obtain(ev);
            mAlwaysInTapRegion = true;
            mAlwaysInBiggerTapRegion = true;
            mStillDown = true;
            mInLongPress = false;
            mDeferConfirmSingleTap = false;
            if (mIsLongpressEnabled) {
                mHandler.removeMessages(LONG_PRESS);
                mHandler.sendEmptyMessageAtTime(LONG_PRESS, mCurrentDownEvent.getDownTime() + TAP_TIMEOUT + LONGPRESS_TIMEOUT);
            }
            mHandler.sendEmptyMessageAtTime(SHOW_PRESS, mCurrentDownEvent.getDownTime() + TAP_TIMEOUT);
            handled |= mListener.onDown(ev);
            break;
        case MotionEvent.ACTION_MOVE:
            if (mInLongPress) {
                break;
            }
            final float scrollX = mLastFocusX - focusX;
            final float scrollY = mLastFocusY - focusY;
            if (mIsDoubleTapping) {
                // Give the move events of the double-tap
                handled |= mDoubleTapListener.onDoubleTapEvent(ev);
            } else if (mAlwaysInTapRegion) {
                final int deltaX = (int) (focusX - mDownFocusX);
                final int deltaY = (int) (focusY - mDownFocusY);
                int distance = (deltaX * deltaX) + (deltaY * deltaY);
                if (distance > mTouchSlopSquare) {
                    handled = mListener.onScroll(mCurrentDownEvent, ev, scrollX, scrollY);
                    mLastFocusX = focusX;
                    mLastFocusY = focusY;
                    mAlwaysInTapRegion = false;
                    mHandler.removeMessages(TAP);
                    mHandler.removeMessages(SHOW_PRESS);
                    mHandler.removeMessages(LONG_PRESS);
                }
                if (distance > mDoubleTapTouchSlopSquare) {
                    mAlwaysInBiggerTapRegion = false;
                }
            } else if ((Math.abs(scrollX) >= 1) || (Math.abs(scrollY) >= 1)) {
                handled = mListener.onScroll(mCurrentDownEvent, ev, scrollX, scrollY);
                mLastFocusX = focusX;
                mLastFocusY = focusY;
            }
            break;
        case MotionEvent.ACTION_UP:
            mStillDown = false;
            MotionEvent currentUpEvent = MotionEvent.obtain(ev);
            if (mIsDoubleTapping) {
                // Finally, give the up event of the double-tap
                handled |= mDoubleTapListener.onDoubleTapEvent(ev);
            } else if (mInLongPress) {
                mHandler.removeMessages(TAP);
                mInLongPress = false;
            } else if (mAlwaysInTapRegion) {
                handled = mListener.onSingleTapUp(ev);
                if (mDeferConfirmSingleTap && mDoubleTapListener != null) {
                    mDoubleTapListener.onSingleTapConfirmed(ev);
                }
            } else {
                // A fling must travel the minimum tap distance
                final VelocityTracker velocityTracker = mVelocityTracker;
                final int pointerId = ev.getPointerId(0);
                velocityTracker.computeCurrentVelocity(1000, mMaximumFlingVelocity);
                final float velocityY = velocityTracker.getYVelocity(pointerId);
                final float velocityX = velocityTracker.getXVelocity(pointerId);
                if ((Math.abs(velocityY) > mMinimumFlingVelocity) || (Math.abs(velocityX) > mMinimumFlingVelocity)) {
                    handled = mListener.onFling(mCurrentDownEvent, ev, velocityX, velocityY);
                }
            }
            if (mPreviousUpEvent != null) {
                mPreviousUpEvent.recycle();
            }
            // Hold the event we obtained above - listeners may have changed the original.
            mPreviousUpEvent = currentUpEvent;
            if (mVelocityTracker != null) {
                // This may have been cleared when we called out to the
                // application above.
                mVelocityTracker.recycle();
                mVelocityTracker = null;
            }
            mIsDoubleTapping = false;
            mDeferConfirmSingleTap = false;
            mHandler.removeMessages(SHOW_PRESS);
            mHandler.removeMessages(LONG_PRESS);
            break;
        case MotionEvent.ACTION_CANCEL:
            cancel();
            break;
    }
    if (!handled && mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(ev, 0);
    }
    return handled;
}
Body of Second Method:
{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(ev, 0);
    }
    final int action = ev.getAction();
    if (mVelocityTracker == null) {
        mVelocityTracker = VelocityTracker.obtain();
    }
    mVelocityTracker.addMovement(ev);
    final boolean pointerUp = (action & MotionEvent.ACTION_MASK) == MotionEvent.ACTION_POINTER_UP;
    final int skipIndex = pointerUp ? ev.getActionIndex() : -1;
    // Determine focal point
    float sumX = 0, sumY = 0;
    final int count = ev.getPointerCount();
    for (int i = 0; i < count; i++) {
        if (skipIndex == i)
            continue;
        sumX += ev.getX(i);
        sumY += ev.getY(i);
    }
    final int div = pointerUp ? count - 1 : count;
    final float focusX = sumX / div;
    final float focusY = sumY / div;
    boolean handled = false;
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_POINTER_DOWN:
            mDownFocusX = mLastFocusX = focusX;
            mDownFocusY = mLastFocusY = focusY;
            // Cancel long press and taps
            cancelTaps();
            break;
        case MotionEvent.ACTION_POINTER_UP:
            mDownFocusX = mLastFocusX = focusX;
            mDownFocusY = mLastFocusY = focusY;
            // Check the dot product of current velocities.
            // If the pointer that left was opposing another velocity vector, clear.
            mVelocityTracker.computeCurrentVelocity(1000, mMaximumFlingVelocity);
            final int upIndex = ev.getActionIndex();
            final int id1 = ev.getPointerId(upIndex);
            final float x1 = mVelocityTracker.getXVelocity(id1);
            final float y1 = mVelocityTracker.getYVelocity(id1);
            for (int i = 0; i < count; i++) {
                if (i == upIndex)
                    continue;
                final int id2 = ev.getPointerId(i);
                final float x = x1 * mVelocityTracker.getXVelocity(id2);
                final float y = y1 * mVelocityTracker.getYVelocity(id2);
                final float dot = x + y;
                if (dot < 0) {
                    mVelocityTracker.clear();
                    break;
                }
            }
            break;
        case MotionEvent.ACTION_DOWN:
            if (mDoubleTapListener != null) {
                boolean hadTapMessage = mHandler.hasMessages(TAP);
                if (hadTapMessage)
                    mHandler.removeMessages(TAP);
                if ((mCurrentDownEvent != null) && (mPreviousUpEvent != null) && hadTapMessage && isConsideredDoubleTap(mCurrentDownEvent, mPreviousUpEvent, ev)) {
                    // This is a second tap
                    mIsDoubleTapping = true;
                    // Give a callback with the first tap of the double-tap
                    handled |= mDoubleTapListener.onDoubleTap(mCurrentDownEvent);
                    // Give a callback with down event of the double-tap
                    handled |= mDoubleTapListener.onDoubleTapEvent(ev);
                } else {
                    // This is a first tap
                    mHandler.sendEmptyMessageDelayed(TAP, DOUBLE_TAP_TIMEOUT);
                }
            }
            mDownFocusX = mLastFocusX = focusX;
            mDownFocusY = mLastFocusY = focusY;
            if (mCurrentDownEvent != null) {
                mCurrentDownEvent.recycle();
            }
            mCurrentDownEvent = MotionEvent.obtain(ev);
            mAlwaysInTapRegion = true;
            mAlwaysInBiggerTapRegion = true;
            mStillDown = true;
            mInLongPress = false;
            mDeferConfirmSingleTap = false;
            if (mIsLongpressEnabled) {
                mHandler.removeMessages(LONG_PRESS);
                mHandler.sendEmptyMessageAtTime(LONG_PRESS, mCurrentDownEvent.getDownTime() + TAP_TIMEOUT + LONGPRESS_TIMEOUT);
            }
            mHandler.sendEmptyMessageAtTime(SHOW_PRESS, mCurrentDownEvent.getDownTime() + TAP_TIMEOUT);
            handled |= mListener.onDown(ev);
            break;
        case MotionEvent.ACTION_MOVE:
            if (mInLongPress || mInContextClick) {
                break;
            }
            final float scrollX = mLastFocusX - focusX;
            final float scrollY = mLastFocusY - focusY;
            if (mIsDoubleTapping) {
                // Give the move events of the double-tap
                handled |= mDoubleTapListener.onDoubleTapEvent(ev);
            } else if (mAlwaysInTapRegion) {
                final int deltaX = (int) (focusX - mDownFocusX);
                final int deltaY = (int) (focusY - mDownFocusY);
                int distance = (deltaX * deltaX) + (deltaY * deltaY);
                if (distance > mTouchSlopSquare) {
                    handled = mListener.onScroll(mCurrentDownEvent, ev, scrollX, scrollY);
                    mLastFocusX = focusX;
                    mLastFocusY = focusY;
                    mAlwaysInTapRegion = false;
                    mHandler.removeMessages(TAP);
                    mHandler.removeMessages(SHOW_PRESS);
                    mHandler.removeMessages(LONG_PRESS);
                }
                if (distance > mDoubleTapTouchSlopSquare) {
                    mAlwaysInBiggerTapRegion = false;
                }
            } else if ((Math.abs(scrollX) >= 1) || (Math.abs(scrollY) >= 1)) {
                handled = mListener.onScroll(mCurrentDownEvent, ev, scrollX, scrollY);
                mLastFocusX = focusX;
                mLastFocusY = focusY;
            }
            break;
        case MotionEvent.ACTION_UP:
            mStillDown = false;
            MotionEvent currentUpEvent = MotionEvent.obtain(ev);
            if (mIsDoubleTapping) {
                // Finally, give the up event of the double-tap
                handled |= mDoubleTapListener.onDoubleTapEvent(ev);
            } else if (mInLongPress) {
                mHandler.removeMessages(TAP);
                mInLongPress = false;
            } else if (mAlwaysInTapRegion && !mIgnoreNextUpEvent) {
                handled = mListener.onSingleTapUp(ev);
                if (mDeferConfirmSingleTap && mDoubleTapListener != null) {
                    mDoubleTapListener.onSingleTapConfirmed(ev);
                }
            } else if (!mIgnoreNextUpEvent) {
                // A fling must travel the minimum tap distance
                final VelocityTracker velocityTracker = mVelocityTracker;
                final int pointerId = ev.getPointerId(0);
                velocityTracker.computeCurrentVelocity(1000, mMaximumFlingVelocity);
                final float velocityY = velocityTracker.getYVelocity(pointerId);
                final float velocityX = velocityTracker.getXVelocity(pointerId);
                if ((Math.abs(velocityY) > mMinimumFlingVelocity) || (Math.abs(velocityX) > mMinimumFlingVelocity)) {
                    handled = mListener.onFling(mCurrentDownEvent, ev, velocityX, velocityY);
                }
            }
            if (mPreviousUpEvent != null) {
                mPreviousUpEvent.recycle();
            }
            // Hold the event we obtained above - listeners may have changed the original.
            mPreviousUpEvent = currentUpEvent;
            if (mVelocityTracker != null) {
                // This may have been cleared when we called out to the
                // application above.
                mVelocityTracker.recycle();
                mVelocityTracker = null;
            }
            mIsDoubleTapping = false;
            mDeferConfirmSingleTap = false;
            mIgnoreNextUpEvent = false;
            mHandler.removeMessages(SHOW_PRESS);
            mHandler.removeMessages(LONG_PRESS);
            break;
        case MotionEvent.ACTION_CANCEL:
            cancel();
            break;
    }
    if (!handled && mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(ev, 0);
    }
    return handled;
}
------------------------
Find a silently evolved API code:android.app.Notification.MediaStyle.styleText:COMMENT
Method Modifier: private     
Comment:/**
 * Applies the special text colors for media notifications to all text views.
 */

Body of Frist Method:
{
    int primaryColor = mBuilder.mContext.getResources().getColor(R.color.notification_media_primary_color);
    int secondaryColor = mBuilder.mContext.getResources().getColor(R.color.notification_media_secondary_color);
    contentView.setTextColor(R.id.title, primaryColor);
    if (mBuilder.showsTimeOrChronometer()) {
        if (mBuilder.mUseChronometer) {
            contentView.setTextColor(R.id.chronometer, secondaryColor);
        } else {
            contentView.setTextColor(R.id.time, secondaryColor);
        }
    }
    contentView.setTextColor(R.id.text2, secondaryColor);
    contentView.setTextColor(R.id.text, secondaryColor);
    contentView.setTextColor(R.id.info, secondaryColor);
}
Body of Second Method:
{
    int primaryColor = mBuilder.mContext.getColor(R.color.notification_media_primary_color);
    int secondaryColor = mBuilder.mContext.getColor(R.color.notification_media_secondary_color);
    contentView.setTextColor(R.id.title, primaryColor);
    if (mBuilder.showsTimeOrChronometer()) {
        if (mBuilder.mUseChronometer) {
            contentView.setTextColor(R.id.chronometer, secondaryColor);
        } else {
            contentView.setTextColor(R.id.time, secondaryColor);
        }
    }
    contentView.setTextColor(R.id.text2, secondaryColor);
    contentView.setTextColor(R.id.text, secondaryColor);
    contentView.setTextColor(R.id.info, secondaryColor);
}
------------------------
Find a silently evolved API code:android.content.ContentProviderClient.update:COMMENT
Method Modifier: public      
Comment:/**
 * See {@link ContentProvider#update ContentProvider.update}
 */

Body of Frist Method:
{
    beforeRemote();
    try {
        return mContentProvider.update(mPackageName, url, values, selection, selectionArgs);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}
Body of Second Method:
{
    Preconditions.checkNotNull(url, "url");
    beforeRemote();
    try {
        return mContentProvider.update(mPackageName, url, values, selection, selectionArgs);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}
------------------------
Find a silently evolved API code:android.content.ContentResolver.canonicalize:COMMENT
Method Modifier: public      final       
Comment:/**
 * Transform the given <var>url</var> to a canonical representation of
 * its referenced resource, which can be used across devices, persisted,
 * backed up and restored, etc.  The returned Uri is still a fully capable
 * Uri for use with its content provider, allowing you to do all of the
 * same content provider operations as with the original Uri --
 * {@link #query}, {@link #openInputStream(android.net.Uri)}, etc.  The
 * only difference in behavior between the original and new Uris is that
 * the content provider may need to do some additional work at each call
 * using it to resolve it to the correct resource, especially if the
 * canonical Uri has been moved to a different environment.
 *
 * <p>If you are moving a canonical Uri between environments, you should
 * perform another call to {@link #canonicalize} with that original Uri to
 * re-canonicalize it for the current environment.  Alternatively, you may
 * want to use {@link #uncanonicalize} to transform it to a non-canonical
 * Uri that works only in the current environment but potentially more
 * efficiently than the canonical representation.</p>
 *
 * @param url The {@link Uri} that is to be transformed to a canonical
 * representation.  Like all resolver calls, the input can be either
 * a non-canonical or canonical Uri.
 *
 * @return Returns the official canonical representation of <var>url</var>,
 * or null if the content provider does not support a canonical representation
 * of the given Uri.  Many providers may not support canonicalization of some
 * or all of their Uris.
 *
 * @see #uncanonicalize
 */

Body of Frist Method:
{
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        return null;
    }
    try {
        return provider.canonicalize(mPackageName, url);
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } finally {
        releaseProvider(provider);
    }
}
Body of Second Method:
{
    Preconditions.checkNotNull(url, "url");
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        return null;
    }
    try {
        return provider.canonicalize(mPackageName, url);
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } finally {
        releaseProvider(provider);
    }
}
------------------------
Find a silently evolved API code:android.media.MediaRecorder.setCaptureRate:COMMENT
Method Modifier: public      
Comment:/**
 * Set video frame capture rate. This can be used to set a different video frame capture
 * rate than the recorded video's playback rate. This method also sets the recording mode
 * to time lapse. In time lapse video recording, only video is recorded. Audio related
 * parameters are ignored when a time lapse recording session starts, if an application
 * sets them.
 *
 * @param fps Rate at which frames should be captured in frames per second.
 * The fps can go as low as desired. However the fastest fps will be limited by the hardware.
 * For resolutions that can be captured by the video camera, the fastest fps can be computed using
 * {@link android.hardware.Camera.Parameters#getPreviewFpsRange(int[])}. For higher
 * resolutions the fastest fps may be more restrictive.
 * Note that the recorder cannot guarantee that frames will be captured at the
 * given rate due to camera/encoder limitations. However it tries to be as close as
 * possible.
 */

Body of Frist Method:
{
    // Make sure that time lapse is enabled when this method is called.
    setParameter("time-lapse-enable=1");
    double timeBetweenFrameCapture = 1 / fps;
    long timeBetweenFrameCaptureUs = (long) (1000000 * timeBetweenFrameCapture);
    setParameter("time-between-time-lapse-frame-capture=" + timeBetweenFrameCaptureUs);
}
Body of Second Method:
{
    // Make sure that time lapse is enabled when this method is called.
    setParameter("time-lapse-enable=1");
    setParameter("time-lapse-fps=" + fps);
}
------------------------
Find a silently evolved API code:android.media.SoundPool.play:COMMENT
Method Modifier: public      final       
Comment:/**
 * Play a sound from a sound ID.
 *
 * Play the sound specified by the soundID. This is the value
 * returned by the load() function. Returns a non-zero streamID
 * if successful, zero if it fails. The streamID can be used to
 * further control playback. Note that calling play() may cause
 * another sound to stop playing if the maximum number of active
 * streams is exceeded. A loop value of -1 means loop forever,
 * a value of 0 means don't loop, other values indicate the
 * number of repeats, e.g. a value of 1 plays the audio twice.
 * The playback rate allows the application to vary the playback
 * rate (pitch) of the sound. A value of 1.0 means play back at
 * the original frequency. A value of 2.0 means play back twice
 * as fast, and a value of 0.5 means playback at half speed.
 *
 * @param soundID a soundID returned by the load() function
 * @param leftVolume left volume value (range = 0.0 to 1.0)
 * @param rightVolume right volume value (range = 0.0 to 1.0)
 * @param priority stream priority (0 = lowest priority)
 * @param loop loop mode (0 = no loop, -1 = loop forever)
 * @param rate playback rate (1.0 = normal playback, range 0.5 to 2.0)
 * @return non-zero streamID if successful, zero if failed
 */

Body of Frist Method:
{
    return mImpl.play(soundID, leftVolume, rightVolume, priority, loop, rate);
}
Body of Second Method:
{
    if (isRestricted()) {
        leftVolume = rightVolume = 0;
    }
    return _play(soundID, leftVolume, rightVolume, priority, loop, rate);
}
------------------------
Find a silently evolved API code:android.view.MotionEvent.actionToString:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns a string that represents the symbolic name of the specified unmasked action
 * such as "ACTION_DOWN", "ACTION_POINTER_DOWN(3)" or an equivalent numeric constant
 * such as "35" if unknown.
 *
 * @param action The unmasked action.
 * @return The symbolic name of the specified action.
 * @see #getAction()
 */

Body of Frist Method:
{
    switch(action) {
        case ACTION_DOWN:
            return "ACTION_DOWN";
        case ACTION_UP:
            return "ACTION_UP";
        case ACTION_CANCEL:
            return "ACTION_CANCEL";
        case ACTION_OUTSIDE:
            return "ACTION_OUTSIDE";
        case ACTION_MOVE:
            return "ACTION_MOVE";
        case ACTION_HOVER_MOVE:
            return "ACTION_HOVER_MOVE";
        case ACTION_SCROLL:
            return "ACTION_SCROLL";
        case ACTION_HOVER_ENTER:
            return "ACTION_HOVER_ENTER";
        case ACTION_HOVER_EXIT:
            return "ACTION_HOVER_EXIT";
    }
    int index = (action & ACTION_POINTER_INDEX_MASK) >> ACTION_POINTER_INDEX_SHIFT;
    switch(action & ACTION_MASK) {
        case ACTION_POINTER_DOWN:
            return "ACTION_POINTER_DOWN(" + index + ")";
        case ACTION_POINTER_UP:
            return "ACTION_POINTER_UP(" + index + ")";
        default:
            return Integer.toString(action);
    }
}
Body of Second Method:
{
    switch(action) {
        case ACTION_DOWN:
            return "ACTION_DOWN";
        case ACTION_UP:
            return "ACTION_UP";
        case ACTION_CANCEL:
            return "ACTION_CANCEL";
        case ACTION_OUTSIDE:
            return "ACTION_OUTSIDE";
        case ACTION_MOVE:
            return "ACTION_MOVE";
        case ACTION_HOVER_MOVE:
            return "ACTION_HOVER_MOVE";
        case ACTION_SCROLL:
            return "ACTION_SCROLL";
        case ACTION_HOVER_ENTER:
            return "ACTION_HOVER_ENTER";
        case ACTION_HOVER_EXIT:
            return "ACTION_HOVER_EXIT";
        case ACTION_BUTTON_PRESS:
            return "ACTION_BUTTON_PRESS";
        case ACTION_BUTTON_RELEASE:
            return "ACTION_BUTTON_RELEASE";
    }
    int index = (action & ACTION_POINTER_INDEX_MASK) >> ACTION_POINTER_INDEX_SHIFT;
    switch(action & ACTION_MASK) {
        case ACTION_POINTER_DOWN:
            return "ACTION_POINTER_DOWN(" + index + ")";
        case ACTION_POINTER_UP:
            return "ACTION_POINTER_UP(" + index + ")";
        default:
            return Integer.toString(action);
    }
}
------------------------
Find a silently evolved API code:android.transition.PatternPathMotion.setPatternPath:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the Path defining a pattern of motion between two coordinates.
 * The pattern will be translated, rotated, and scaled to fit between the start and end points.
 * The pattern must not be empty and must have the end point differ from the start point.
 *
 * @param patternPath A Path to be used as a pattern for two-dimensional motion.
 * @attr ref android.R.styleable#PatternPathMotion_patternPathData
 */

Body of Frist Method:
{
    PathMeasure pathMeasure = new PathMeasure(patternPath, false);
    float length = pathMeasure.getLength();
    float[] pos = new float[2];
    pathMeasure.getPosTan(length, pos, null);
    float endX = pos[0];
    float endY = pos[1];
    pathMeasure.getPosTan(0, pos, null);
    float startX = pos[0];
    float startY = pos[1];
    if (startX == endX && startY == endY) {
        throw new IllegalArgumentException("pattern must not end at the starting point");
    }
    mTempMatrix.setTranslate(-startX, -startY);
    float dx = endX - startX;
    float dy = endY - startY;
    float distance = distance(dx, dy);
    float scale = 1 / distance;
    mTempMatrix.postScale(scale, scale);
    double angle = Math.atan2(dy, dx);
    mTempMatrix.postRotate((float) Math.toDegrees(-angle));
    patternPath.transform(mTempMatrix, mPatternPath);
    mOriginalPatternPath = patternPath;
}
Body of Second Method:
{
    PathMeasure pathMeasure = new PathMeasure(patternPath, false);
    float length = pathMeasure.getLength();
    float[] pos = new float[2];
    pathMeasure.getPosTan(length, pos, null);
    float endX = pos[0];
    float endY = pos[1];
    pathMeasure.getPosTan(0, pos, null);
    float startX = pos[0];
    float startY = pos[1];
    if (startX == endX && startY == endY) {
        throw new IllegalArgumentException("pattern must not end at the starting point");
    }
    mTempMatrix.setTranslate(-startX, -startY);
    float dx = endX - startX;
    float dy = endY - startY;
    float distance = (float) Math.hypot(dx, dy);
    float scale = 1 / distance;
    mTempMatrix.postScale(scale, scale);
    double angle = Math.atan2(dy, dx);
    mTempMatrix.postRotate((float) Math.toDegrees(-angle));
    patternPath.transform(mTempMatrix, mPatternPath);
    mOriginalPatternPath = patternPath;
}
------------------------
Find a silently evolved API code:android.net.ConnectivityManager.inferLegacyTypeForNetworkCapabilities:COMMENT
Method Modifier: private     
Comment:/**
 * Guess what the network request was trying to say so that the resulting
 * network is accessible via the legacy (deprecated) API such as
 * requestRouteToHost.
 * This means we should try to be fairly preceise about transport and
 * capability but ignore things such as networkSpecifier.
 * If the request has more than one transport or capability it doesn't
 * match the old legacy requests (they selected only single transport/capability)
 * so this function cannot map the request to a single legacy type and
 * the resulting network will not be available to the legacy APIs.
 *
 * TODO - This should be removed when the legacy APIs are removed.
 */

Body of Frist Method:
{
    if (netCap == null) {
        return TYPE_NONE;
    }
    if (!netCap.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
        return TYPE_NONE;
    }
    String type = null;
    int result = TYPE_NONE;
    if (netCap.hasCapability(NetworkCapabilities.NET_CAPABILITY_CBS)) {
        type = "enableCBS";
        result = TYPE_MOBILE_CBS;
    } else if (netCap.hasCapability(NetworkCapabilities.NET_CAPABILITY_IMS)) {
        type = "enableIMS";
        result = TYPE_MOBILE_IMS;
    } else if (netCap.hasCapability(NetworkCapabilities.NET_CAPABILITY_FOTA)) {
        type = "enableFOTA";
        result = TYPE_MOBILE_FOTA;
    } else if (netCap.hasCapability(NetworkCapabilities.NET_CAPABILITY_DUN)) {
        type = "enableDUN";
        result = TYPE_MOBILE_DUN;
    } else if (netCap.hasCapability(NetworkCapabilities.NET_CAPABILITY_SUPL)) {
        type = "enableSUPL";
        result = TYPE_MOBILE_SUPL;
    } else if (netCap.hasCapability(NetworkCapabilities.NET_CAPABILITY_MMS)) {
        type = "enableMMS";
        result = TYPE_MOBILE_MMS;
    } else if (netCap.hasCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)) {
        type = "enableHIPRI";
        result = TYPE_MOBILE_HIPRI;
    }
    if (type != null) {
        NetworkCapabilities testCap = networkCapabilitiesForFeature(TYPE_MOBILE, type);
        if (testCap.equalsNetCapabilities(netCap) && testCap.equalsTransportTypes(netCap)) {
            return result;
        }
    }
    return TYPE_NONE;
}
Body of Second Method:
{
    if (netCap == null) {
        return TYPE_NONE;
    }
    if (!netCap.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
        return TYPE_NONE;
    }
    String type = null;
    int result = TYPE_NONE;
    if (netCap.hasCapability(NetworkCapabilities.NET_CAPABILITY_CBS)) {
        type = "enableCBS";
        result = TYPE_MOBILE_CBS;
    } else if (netCap.hasCapability(NetworkCapabilities.NET_CAPABILITY_IMS)) {
        type = "enableIMS";
        result = TYPE_MOBILE_IMS;
    } else if (netCap.hasCapability(NetworkCapabilities.NET_CAPABILITY_FOTA)) {
        type = "enableFOTA";
        result = TYPE_MOBILE_FOTA;
    } else if (netCap.hasCapability(NetworkCapabilities.NET_CAPABILITY_DUN)) {
        type = "enableDUN";
        result = TYPE_MOBILE_DUN;
    } else if (netCap.hasCapability(NetworkCapabilities.NET_CAPABILITY_SUPL)) {
        type = "enableSUPL";
        result = TYPE_MOBILE_SUPL;
    // back out this hack for mms as they no longer need this and it's causing
    // device slowdowns - b/23350688 (note, supl still needs this)
    // } else if (netCap.hasCapability(NetworkCapabilities.NET_CAPABILITY_MMS)) {
    // type = "enableMMS";
    // result = TYPE_MOBILE_MMS;
    } else if (netCap.hasCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)) {
        type = "enableHIPRI";
        result = TYPE_MOBILE_HIPRI;
    }
    if (type != null) {
        NetworkCapabilities testCap = networkCapabilitiesForFeature(TYPE_MOBILE, type);
        if (testCap.equalsNetCapabilities(netCap) && testCap.equalsTransportTypes(netCap)) {
            return result;
        }
    }
    return TYPE_NONE;
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiActivityEnergyInfo.getControllerTxTimeMillis:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @return tx time in ms
 */

Body of Frist Method:
{
    return (int) mControllerTxTimeMs;
}
Body of Second Method:
{
    return mControllerTxTimeMs;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothDevice.createRfcommSocket:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Create an RFCOMM {@link BluetoothSocket} ready to start a secure
 * outgoing connection to this remote device on given channel.
 * <p>The remote device will be authenticated and communication on this
 * socket will be encrypted.
 * <p> Use this socket only if an authenticated socket link is possible.
 * Authentication refers to the authentication of the link key to
 * prevent man-in-the-middle type of attacks.
 * For example, for Bluetooth 2.1 devices, if any of the devices does not
 * have an input and output capability or just has the ability to
 * display a numeric key, a secure socket connection is not possible.
 * In such a case, use {#link createInsecureRfcommSocket}.
 * For more details, refer to the Security Model section 5.2 (vol 3) of
 * Bluetooth Core Specification version 2.1 + EDR.
 * <p>Use {@link BluetoothSocket#connect} to initiate the outgoing
 * connection.
 * <p>Valid RFCOMM channels are in range 1 to 30.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}
 *
 * @param channel RFCOMM channel to connect to
 * @return a RFCOMM BluetoothServerSocket ready for an outgoing connection
 * @throws IOException on error, for example Bluetooth not available, or
 * insufficient permissions
 * @hide
 */

Body of Frist Method:
{
    return new BluetoothSocket(BluetoothSocket.TYPE_RFCOMM, -1, true, true, this, channel, null);
}
Body of Second Method:
{
    if (isBluetoothEnabled() == false) {
        Log.e(TAG, "Bluetooth is not enabled");
        throw new IOException();
    }
    return new BluetoothSocket(BluetoothSocket.TYPE_RFCOMM, -1, true, true, this, channel, null);
}
------------------------
Find a silently evolved API code:android.app.Activity.onStart:COMMENT
Method Modifier: protected   
Comment:/**
 * Called after {@link #onCreate} &mdash; or after {@link #onRestart} when
 * the activity had been stopped, but is now again being displayed to the
 * user.  It will be followed by {@link #onResume}.
 *
 * <p><em>Derived classes must call through to the super class's
 * implementation of this method.  If they do not, an exception will be
 * thrown.</em></p>
 *
 * @see #onCreate
 * @see #onStop
 * @see #onResume
 */

Body of Frist Method:
{
    if (DEBUG_LIFECYCLE)
        Slog.v(TAG, "onStart " + this);
    mCalled = true;
    if (!mLoadersStarted) {
        mLoadersStarted = true;
        if (mLoaderManager != null) {
            mLoaderManager.doStart();
        } else if (!mCheckedForLoaderManager) {
            mLoaderManager = getLoaderManager("(root)", mLoadersStarted, false);
        }
        mCheckedForLoaderManager = true;
    }
    getApplication().dispatchActivityStarted(this);
}
Body of Second Method:
{
    if (DEBUG_LIFECYCLE)
        Slog.v(TAG, "onStart " + this);
    mCalled = true;
    mFragments.doLoaderStart();
    getApplication().dispatchActivityStarted(this);
}
------------------------
Find a silently evolved API code:android.widget.TextView.handleTextChanged:COMMENT
Method Modifier: default     
Comment:/**
 * Not private so it can be called from an inner class without going
 * through a thunk.
 */

Body of Frist Method:
{
    final Editor.InputMethodState ims = mEditor == null ? null : mEditor.mInputMethodState;
    if (ims == null || ims.mBatchEditNesting == 0) {
        updateAfterEdit();
    }
    if (ims != null) {
        ims.mContentChanged = true;
        if (ims.mChangedStart < 0) {
            ims.mChangedStart = start;
            ims.mChangedEnd = start + before;
        } else {
            ims.mChangedStart = Math.min(ims.mChangedStart, start);
            ims.mChangedEnd = Math.max(ims.mChangedEnd, start + before - ims.mChangedDelta);
        }
        ims.mChangedDelta += after - before;
    }
    resetErrorChangedFlag();
    sendOnTextChanged(buffer, start, before, after);
    onTextChanged(buffer, start, before, after);
}
Body of Second Method:
{
    sLastCutCopyOrTextChangedTime = 0;
    final Editor.InputMethodState ims = mEditor == null ? null : mEditor.mInputMethodState;
    if (ims == null || ims.mBatchEditNesting == 0) {
        updateAfterEdit();
    }
    if (ims != null) {
        ims.mContentChanged = true;
        if (ims.mChangedStart < 0) {
            ims.mChangedStart = start;
            ims.mChangedEnd = start + before;
        } else {
            ims.mChangedStart = Math.min(ims.mChangedStart, start);
            ims.mChangedEnd = Math.max(ims.mChangedEnd, start + before - ims.mChangedDelta);
        }
        ims.mChangedDelta += after - before;
    }
    resetErrorChangedFlag();
    sendOnTextChanged(buffer, start, before, after);
    onTextChanged(buffer, start, before, after);
}
------------------------
Find a silently evolved API code:android.media.AudioFormat.isEncodingLinearPcm:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    switch(audioFormat) {
        case ENCODING_PCM_8BIT:
        case ENCODING_PCM_16BIT:
        case ENCODING_PCM_FLOAT:
        case ENCODING_DEFAULT:
            return true;
        case ENCODING_AC3:
        case ENCODING_E_AC3:
            return false;
        case ENCODING_INVALID:
        default:
            throw new IllegalArgumentException("Bad audio format " + audioFormat);
    }
}
Body of Second Method:
{
    switch(audioFormat) {
        case ENCODING_PCM_8BIT:
        case ENCODING_PCM_16BIT:
        case ENCODING_PCM_FLOAT:
        case ENCODING_DEFAULT:
            return true;
        case ENCODING_AC3:
        case ENCODING_E_AC3:
        case ENCODING_DTS:
        case ENCODING_DTS_HD:
        case ENCODING_MP3:
        case ENCODING_AAC_LC:
        case ENCODING_AAC_HE_V1:
        case ENCODING_AAC_HE_V2:
            return false;
        case ENCODING_INVALID:
        default:
            throw new IllegalArgumentException("Bad audio format " + audioFormat);
    }
}
------------------------
Find a silently evolved API code:android.app.SearchManager.triggerSearch:COMMENT
Method Modifier: public      
Comment:/**
 * Similar to {@link #startSearch} but actually fires off the search query after invoking
 * the search dialog.  Made available for testing purposes.
 *
 * @param query The query to trigger.  If empty, request will be ignored.
 * @param launchActivity The ComponentName of the activity that has launched this search.
 * @param appSearchData An application can insert application-specific
 * context here, in order to improve quality or specificity of its own
 * searches.  This data will be returned with SEARCH intent(s).  Null if
 * no extra data is required.
 *
 * @see #startSearch
 */

Body of Frist Method:
{
    if (!mAssociatedPackage.equals(launchActivity.getPackageName())) {
        throw new IllegalArgumentException("invoking app search on a different package " + "not associated with this search manager");
    }
    if (query == null || TextUtils.getTrimmedLength(query) == 0) {
        Log.w(TAG, "triggerSearch called with empty query, ignoring.");
        return;
    }
    startSearch(query, false, launchActivity, appSearchData, false);
    mSearchDialog.launchQuerySearch();
}
Body of Second Method:
{
    if (query == null || TextUtils.getTrimmedLength(query) == 0) {
        Log.w(TAG, "triggerSearch called with empty query, ignoring.");
        return;
    }
    startSearch(query, false, launchActivity, appSearchData, false);
    mSearchDialog.launchQuerySearch();
}
------------------------
Find a silently evolved API code:android.media.SoundPool.setLoop:COMMENT
<android.media.SoundPool: void setLoop(int,int)>
public      final       ->public      final       native      
Method Modifier: public      final       native      
Method Modifier: Yes         Yes         No          
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * Set loop mode.
 *
 * Change the loop mode. A loop value of -1 means loop forever,
 * a value of 0 means don't loop, other values indicate the
 * number of repeats, e.g. a value of 1 plays the audio twice.
 * If the stream does not exist, it will have no effect.
 *
 * @param streamID a streamID returned by the play() function
 * @param loop loop mode (0 = no loop, -1 = loop forever)
 */

Body of Frist Method:
{
    mImpl.setLoop(streamID, loop);
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.view.ScaleGestureDetector.onTouchEvent:COMMENT
Method Modifier: public      
Comment:/**
 * Accepts MotionEvents and dispatches events to a {@link OnScaleGestureListener}
 * when appropriate.
 *
 * <p>Applications should pass a complete and consistent event stream to this method.
 * A complete and consistent event stream involves all MotionEvents from the initial
 * ACTION_DOWN to the final ACTION_UP or ACTION_CANCEL.</p>
 *
 * @param event The event to process
 * @return true if the event was processed and the detector wants to receive the
 * rest of the MotionEvents in this event stream.
 */

Body of Frist Method:
{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(event, 0);
    }
    mCurrTime = event.getEventTime();
    final int action = event.getActionMasked();
    // Forward the event to check for double tap gesture
    if (mQuickScaleEnabled) {
        mGestureDetector.onTouchEvent(event);
    }
    final boolean streamComplete = action == MotionEvent.ACTION_UP || action == MotionEvent.ACTION_CANCEL;
    if (action == MotionEvent.ACTION_DOWN || streamComplete) {
        // This means the app probably didn't give us all the events. Shame on it.
        if (mInProgress) {
            mListener.onScaleEnd(this);
            mInProgress = false;
            mInitialSpan = 0;
            mDoubleTapMode = DOUBLE_TAP_MODE_NONE;
        } else if (mDoubleTapMode == DOUBLE_TAP_MODE_IN_PROGRESS && streamComplete) {
            mInProgress = false;
            mInitialSpan = 0;
            mDoubleTapMode = DOUBLE_TAP_MODE_NONE;
        }
        if (streamComplete) {
            clearTouchHistory();
            return true;
        }
    }
    final boolean configChanged = action == MotionEvent.ACTION_DOWN || action == MotionEvent.ACTION_POINTER_UP || action == MotionEvent.ACTION_POINTER_DOWN;
    final boolean pointerUp = action == MotionEvent.ACTION_POINTER_UP;
    final int skipIndex = pointerUp ? event.getActionIndex() : -1;
    // Determine focal point
    float sumX = 0, sumY = 0;
    final int count = event.getPointerCount();
    final int div = pointerUp ? count - 1 : count;
    final float focusX;
    final float focusY;
    if (mDoubleTapMode == DOUBLE_TAP_MODE_IN_PROGRESS) {
        // In double tap mode, the focal pt is always where the double tap
        // gesture started
        focusX = mDoubleTapEvent.getX();
        focusY = mDoubleTapEvent.getY();
        if (event.getY() < focusY) {
            mEventBeforeOrAboveStartingGestureEvent = true;
        } else {
            mEventBeforeOrAboveStartingGestureEvent = false;
        }
    } else {
        for (int i = 0; i < count; i++) {
            if (skipIndex == i)
                continue;
            sumX += event.getX(i);
            sumY += event.getY(i);
        }
        focusX = sumX / div;
        focusY = sumY / div;
    }
    addTouchHistory(event);
    // Determine average deviation from focal point
    float devSumX = 0, devSumY = 0;
    for (int i = 0; i < count; i++) {
        if (skipIndex == i)
            continue;
        // Convert the resulting diameter into a radius.
        final float touchSize = mTouchHistoryLastAccepted / 2;
        devSumX += Math.abs(event.getX(i) - focusX) + touchSize;
        devSumY += Math.abs(event.getY(i) - focusY) + touchSize;
    }
    final float devX = devSumX / div;
    final float devY = devSumY / div;
    // Span is the average distance between touch points through the focal point;
    // i.e. the diameter of the circle with a radius of the average deviation from
    // the focal point.
    final float spanX = devX * 2;
    final float spanY = devY * 2;
    final float span;
    if (inDoubleTapMode()) {
        span = spanY;
    } else {
        span = FloatMath.sqrt(spanX * spanX + spanY * spanY);
    }
    // Dispatch begin/end events as needed.
    // If the configuration changes, notify the app to reset its current state by beginning
    // a fresh scale event stream.
    final boolean wasInProgress = mInProgress;
    mFocusX = focusX;
    mFocusY = focusY;
    if (!inDoubleTapMode() && mInProgress && (span < mMinSpan || configChanged)) {
        mListener.onScaleEnd(this);
        mInProgress = false;
        mInitialSpan = span;
        mDoubleTapMode = DOUBLE_TAP_MODE_NONE;
    }
    if (configChanged) {
        mPrevSpanX = mCurrSpanX = spanX;
        mPrevSpanY = mCurrSpanY = spanY;
        mInitialSpan = mPrevSpan = mCurrSpan = span;
    }
    final int minSpan = inDoubleTapMode() ? mSpanSlop : mMinSpan;
    if (!mInProgress && span >= minSpan && (wasInProgress || Math.abs(span - mInitialSpan) > mSpanSlop)) {
        mPrevSpanX = mCurrSpanX = spanX;
        mPrevSpanY = mCurrSpanY = spanY;
        mPrevSpan = mCurrSpan = span;
        mPrevTime = mCurrTime;
        mInProgress = mListener.onScaleBegin(this);
    }
    // Handle motion; focal point and span/scale factor are changing.
    if (action == MotionEvent.ACTION_MOVE) {
        mCurrSpanX = spanX;
        mCurrSpanY = spanY;
        mCurrSpan = span;
        boolean updatePrev = true;
        if (mInProgress) {
            updatePrev = mListener.onScale(this);
        }
        if (updatePrev) {
            mPrevSpanX = mCurrSpanX;
            mPrevSpanY = mCurrSpanY;
            mPrevSpan = mCurrSpan;
            mPrevTime = mCurrTime;
        }
    }
    return true;
}
Body of Second Method:
{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(event, 0);
    }
    mCurrTime = event.getEventTime();
    final int action = event.getActionMasked();
    // Forward the event to check for double tap gesture
    if (mQuickScaleEnabled) {
        mGestureDetector.onTouchEvent(event);
    }
    final int count = event.getPointerCount();
    final boolean isStylusButtonDown = (event.getButtonState() & MotionEvent.BUTTON_STYLUS_PRIMARY) != 0;
    final boolean anchoredScaleCancelled = mAnchoredScaleMode == ANCHORED_SCALE_MODE_STYLUS && !isStylusButtonDown;
    final boolean streamComplete = action == MotionEvent.ACTION_UP || action == MotionEvent.ACTION_CANCEL || anchoredScaleCancelled;
    if (action == MotionEvent.ACTION_DOWN || streamComplete) {
        // This means the app probably didn't give us all the events. Shame on it.
        if (mInProgress) {
            mListener.onScaleEnd(this);
            mInProgress = false;
            mInitialSpan = 0;
            mAnchoredScaleMode = ANCHORED_SCALE_MODE_NONE;
        } else if (inAnchoredScaleMode() && streamComplete) {
            mInProgress = false;
            mInitialSpan = 0;
            mAnchoredScaleMode = ANCHORED_SCALE_MODE_NONE;
        }
        if (streamComplete) {
            clearTouchHistory();
            return true;
        }
    }
    if (!mInProgress && mStylusScaleEnabled && !inAnchoredScaleMode() && !streamComplete && isStylusButtonDown) {
        // Start of a button scale gesture
        mAnchoredScaleStartX = event.getX();
        mAnchoredScaleStartY = event.getY();
        mAnchoredScaleMode = ANCHORED_SCALE_MODE_STYLUS;
        mInitialSpan = 0;
    }
    final boolean configChanged = action == MotionEvent.ACTION_DOWN || action == MotionEvent.ACTION_POINTER_UP || action == MotionEvent.ACTION_POINTER_DOWN || anchoredScaleCancelled;
    final boolean pointerUp = action == MotionEvent.ACTION_POINTER_UP;
    final int skipIndex = pointerUp ? event.getActionIndex() : -1;
    // Determine focal point
    float sumX = 0, sumY = 0;
    final int div = pointerUp ? count - 1 : count;
    final float focusX;
    final float focusY;
    if (inAnchoredScaleMode()) {
        // In anchored scale mode, the focal pt is always where the double tap
        // or button down gesture started
        focusX = mAnchoredScaleStartX;
        focusY = mAnchoredScaleStartY;
        if (event.getY() < focusY) {
            mEventBeforeOrAboveStartingGestureEvent = true;
        } else {
            mEventBeforeOrAboveStartingGestureEvent = false;
        }
    } else {
        for (int i = 0; i < count; i++) {
            if (skipIndex == i)
                continue;
            sumX += event.getX(i);
            sumY += event.getY(i);
        }
        focusX = sumX / div;
        focusY = sumY / div;
    }
    addTouchHistory(event);
    // Determine average deviation from focal point
    float devSumX = 0, devSumY = 0;
    for (int i = 0; i < count; i++) {
        if (skipIndex == i)
            continue;
        // Convert the resulting diameter into a radius.
        final float touchSize = mTouchHistoryLastAccepted / 2;
        devSumX += Math.abs(event.getX(i) - focusX) + touchSize;
        devSumY += Math.abs(event.getY(i) - focusY) + touchSize;
    }
    final float devX = devSumX / div;
    final float devY = devSumY / div;
    // Span is the average distance between touch points through the focal point;
    // i.e. the diameter of the circle with a radius of the average deviation from
    // the focal point.
    final float spanX = devX * 2;
    final float spanY = devY * 2;
    final float span;
    if (inAnchoredScaleMode()) {
        span = spanY;
    } else {
        span = (float) Math.hypot(spanX, spanY);
    }
    // Dispatch begin/end events as needed.
    // If the configuration changes, notify the app to reset its current state by beginning
    // a fresh scale event stream.
    final boolean wasInProgress = mInProgress;
    mFocusX = focusX;
    mFocusY = focusY;
    if (!inAnchoredScaleMode() && mInProgress && (span < mMinSpan || configChanged)) {
        mListener.onScaleEnd(this);
        mInProgress = false;
        mInitialSpan = span;
    }
    if (configChanged) {
        mPrevSpanX = mCurrSpanX = spanX;
        mPrevSpanY = mCurrSpanY = spanY;
        mInitialSpan = mPrevSpan = mCurrSpan = span;
    }
    final int minSpan = inAnchoredScaleMode() ? mSpanSlop : mMinSpan;
    if (!mInProgress && span >= minSpan && (wasInProgress || Math.abs(span - mInitialSpan) > mSpanSlop)) {
        mPrevSpanX = mCurrSpanX = spanX;
        mPrevSpanY = mCurrSpanY = spanY;
        mPrevSpan = mCurrSpan = span;
        mPrevTime = mCurrTime;
        mInProgress = mListener.onScaleBegin(this);
    }
    // Handle motion; focal point and span/scale factor are changing.
    if (action == MotionEvent.ACTION_MOVE) {
        mCurrSpanX = spanX;
        mCurrSpanY = spanY;
        mCurrSpan = span;
        boolean updatePrev = true;
        if (mInProgress) {
            updatePrev = mListener.onScale(this);
        }
        if (updatePrev) {
            mPrevSpanX = mCurrSpanX;
            mPrevSpanY = mCurrSpanY;
            mPrevSpan = mCurrSpan;
            mPrevTime = mCurrTime;
        }
    }
    return true;
}
------------------------
Find a silently evolved API code:android.media.AudioManager.requestAudioFocusForCall:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 * Used internally by telephony package to request audio focus. Will cause the focus request
 * to be associated with the "voice communication" identifier only used in AudioService
 * to identify this use case.
 * @param streamType use STREAM_RING for focus requests when ringing, VOICE_CALL for
 * the establishment of the call
 * @param durationHint the type of focus request. AUDIOFOCUS_GAIN_TRANSIENT is recommended so
 * media applications resume after a call
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        service.requestAudioFocus(new AudioAttributes.Builder().setInternalLegacyStreamType(streamType).build(), durationHint, mICallBack, null, MediaFocusControl.IN_VOICE_COMM_FOCUS_ID, mContext.getOpPackageName(), AUDIOFOCUS_FLAG_LOCK, null);
    } catch (RemoteException e) {
        Log.e(TAG, "Can't call requestAudioFocusForCall() on AudioService:", e);
    }
}
Body of Second Method:
{
    IAudioService service = getService();
    try {
        service.requestAudioFocus(new AudioAttributes.Builder().setInternalLegacyStreamType(streamType).build(), durationHint, mICallBack, null, AudioSystem.IN_VOICE_COMM_FOCUS_ID, getContext().getOpPackageName(), AUDIOFOCUS_FLAG_LOCK, null);
    } catch (RemoteException e) {
        Log.e(TAG, "Can't call requestAudioFocusForCall() on AudioService:", e);
    }
}
------------------------
Find a silently evolved API code:android.preference.SeekBarDialogPreference.createActionButtons:COMMENT
Method Modifier: public      hidden      
Comment:// Allow subclasses to override the action buttons

Body of Frist Method:
{
    setPositiveButtonText(android.R.string.ok);
    setNegativeButtonText(android.R.string.cancel);
}
Body of Second Method:
{
    setPositiveButtonText(R.string.ok);
    setNegativeButtonText(R.string.cancel);
}
------------------------
Find a silently evolved API code:android.content.ContentProviderClient.bulkInsert:COMMENT
Method Modifier: public      
Comment:/**
 * See {@link ContentProvider#bulkInsert ContentProvider.bulkInsert}
 */

Body of Frist Method:
{
    beforeRemote();
    try {
        return mContentProvider.bulkInsert(mPackageName, url, initialValues);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}
Body of Second Method:
{
    Preconditions.checkNotNull(url, "url");
    Preconditions.checkNotNull(initialValues, "initialValues");
    beforeRemote();
    try {
        return mContentProvider.bulkInsert(mPackageName, url, initialValues);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}
------------------------
Find a silently evolved API code:android.preference.VolumePreference.cleanup:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Do clean up.  This can be called multiple times!
 */

Body of Frist Method:
{
    getPreferenceManager().unregisterOnActivityStopListener(this);
    if (mSeekBarVolumizer != null) {
        Dialog dialog = getDialog();
        if (dialog != null && dialog.isShowing()) {
            View view = dialog.getWindow().getDecorView().findViewById(com.android.internal.R.id.seekbar);
            if (view != null)
                view.setOnKeyListener(null);
            // Stopped while dialog was showing, revert changes
            mSeekBarVolumizer.revertVolume();
        }
        mSeekBarVolumizer.stop();
        mSeekBarVolumizer = null;
    }
}
Body of Second Method:
{
    getPreferenceManager().unregisterOnActivityStopListener(this);
    if (mSeekBarVolumizer != null) {
        final Dialog dialog = getDialog();
        if (dialog != null && dialog.isShowing()) {
            final View view = dialog.getWindow().getDecorView().findViewById(R.id.seekbar);
            if (view != null) {
                view.setOnKeyListener(null);
            }
            // Stopped while dialog was showing, revert changes
            mSeekBarVolumizer.revertVolume();
        }
        mSeekBarVolumizer.stop();
        mSeekBarVolumizer = null;
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiConfiguration.writeToParcel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Implement the Parcelable interface {@hide}
 */

Body of Frist Method:
{
    dest.writeInt(networkId);
    dest.writeInt(status);
    dest.writeInt(disableReason);
    dest.writeString(SSID);
    dest.writeString(BSSID);
    dest.writeString(autoJoinBSSID);
    dest.writeString(FQDN);
    dest.writeString(naiRealm);
    dest.writeString(preSharedKey);
    for (String wepKey : wepKeys) {
        dest.writeString(wepKey);
    }
    dest.writeInt(wepTxKeyIndex);
    dest.writeInt(priority);
    dest.writeInt(hiddenSSID ? 1 : 0);
    dest.writeInt(requirePMF ? 1 : 0);
    dest.writeString(updateIdentifier);
    writeBitSet(dest, allowedKeyManagement);
    writeBitSet(dest, allowedProtocols);
    writeBitSet(dest, allowedAuthAlgorithms);
    writeBitSet(dest, allowedPairwiseCiphers);
    writeBitSet(dest, allowedGroupCiphers);
    dest.writeParcelable(enterpriseConfig, flags);
    dest.writeParcelable(mIpConfiguration, flags);
    dest.writeString(dhcpServer);
    dest.writeString(defaultGwMacAddress);
    dest.writeInt(autoJoinStatus);
    dest.writeInt(selfAdded ? 1 : 0);
    dest.writeInt(didSelfAdd ? 1 : 0);
    dest.writeInt(validatedInternetAccess ? 1 : 0);
    dest.writeInt(ephemeral ? 1 : 0);
    dest.writeInt(creatorUid);
    dest.writeInt(lastConnectUid);
    dest.writeInt(lastUpdateUid);
    dest.writeLong(blackListTimestamp);
    dest.writeLong(lastConnectionFailure);
    dest.writeLong(lastRoamingFailure);
    dest.writeInt(lastRoamingFailureReason);
    dest.writeLong(roamingFailureBlackListTimeMilli);
    dest.writeInt(numConnectionFailures);
    dest.writeInt(numIpConfigFailures);
    dest.writeInt(numAuthFailures);
    dest.writeInt(numScorerOverride);
    dest.writeInt(numScorerOverrideAndSwitchedNetwork);
    dest.writeInt(numAssociation);
    dest.writeInt(numUserTriggeredWifiDisableLowRSSI);
    dest.writeInt(numUserTriggeredWifiDisableBadRSSI);
    dest.writeInt(numUserTriggeredWifiDisableNotHighRSSI);
    dest.writeInt(numTicksAtLowRSSI);
    dest.writeInt(numTicksAtBadRSSI);
    dest.writeInt(numTicksAtNotHighRSSI);
    dest.writeInt(numUserTriggeredJoinAttempts);
    dest.writeInt(autoJoinUseAggressiveJoinAttemptThreshold);
    dest.writeInt(autoJoinBailedDueToLowRssi ? 1 : 0);
    dest.writeInt(numNoInternetAccessReports);
}
Body of Second Method:
{
    dest.writeInt(networkId);
    dest.writeInt(status);
    dest.writeInt(disableReason);
    dest.writeString(SSID);
    dest.writeString(BSSID);
    dest.writeInt(apBand);
    dest.writeInt(apChannel);
    dest.writeString(autoJoinBSSID);
    dest.writeString(FQDN);
    dest.writeString(providerFriendlyName);
    dest.writeInt(roamingConsortiumIds.length);
    for (long roamingConsortiumId : roamingConsortiumIds) {
        dest.writeLong(roamingConsortiumId);
    }
    dest.writeString(preSharedKey);
    for (String wepKey : wepKeys) {
        dest.writeString(wepKey);
    }
    dest.writeInt(wepTxKeyIndex);
    dest.writeInt(priority);
    dest.writeInt(hiddenSSID ? 1 : 0);
    dest.writeInt(requirePMF ? 1 : 0);
    dest.writeString(updateIdentifier);
    writeBitSet(dest, allowedKeyManagement);
    writeBitSet(dest, allowedProtocols);
    writeBitSet(dest, allowedAuthAlgorithms);
    writeBitSet(dest, allowedPairwiseCiphers);
    writeBitSet(dest, allowedGroupCiphers);
    dest.writeParcelable(enterpriseConfig, flags);
    dest.writeParcelable(mIpConfiguration, flags);
    dest.writeString(dhcpServer);
    dest.writeString(defaultGwMacAddress);
    dest.writeInt(autoJoinStatus);
    dest.writeInt(selfAdded ? 1 : 0);
    dest.writeInt(didSelfAdd ? 1 : 0);
    dest.writeInt(validatedInternetAccess ? 1 : 0);
    dest.writeInt(ephemeral ? 1 : 0);
    dest.writeInt(creatorUid);
    dest.writeInt(lastConnectUid);
    dest.writeInt(lastUpdateUid);
    dest.writeString(creatorName);
    dest.writeString(lastUpdateName);
    dest.writeLong(blackListTimestamp);
    dest.writeLong(lastConnectionFailure);
    dest.writeLong(lastRoamingFailure);
    dest.writeInt(lastRoamingFailureReason);
    dest.writeLong(roamingFailureBlackListTimeMilli);
    dest.writeInt(numConnectionFailures);
    dest.writeInt(numIpConfigFailures);
    dest.writeInt(numAuthFailures);
    dest.writeInt(numScorerOverride);
    dest.writeInt(numScorerOverrideAndSwitchedNetwork);
    dest.writeInt(numAssociation);
    dest.writeInt(numUserTriggeredWifiDisableLowRSSI);
    dest.writeInt(numUserTriggeredWifiDisableBadRSSI);
    dest.writeInt(numUserTriggeredWifiDisableNotHighRSSI);
    dest.writeInt(numTicksAtLowRSSI);
    dest.writeInt(numTicksAtBadRSSI);
    dest.writeInt(numTicksAtNotHighRSSI);
    dest.writeInt(numUserTriggeredJoinAttempts);
    dest.writeInt(autoJoinUseAggressiveJoinAttemptThreshold);
    dest.writeInt(autoJoinBailedDueToLowRssi ? 1 : 0);
    dest.writeInt(userApproved);
    dest.writeInt(numNoInternetAccessReports);
    dest.writeInt(noInternetAccessExpected ? 1 : 0);
}
------------------------
Find a silently evolved API code:android.location.GpsSatellite.setStatus:COMMENT
Method Modifier: default     
Comment:/**
 * Used by {@link LocationManager#getGpsStatus} to copy LocationManager's
 * cached GpsStatus instance to the client's copy.
 */

Body of Frist Method:
{
    mValid = satellite.mValid;
    mHasEphemeris = satellite.mHasEphemeris;
    mHasAlmanac = satellite.mHasAlmanac;
    mUsedInFix = satellite.mUsedInFix;
    mSnr = satellite.mSnr;
    mElevation = satellite.mElevation;
    mAzimuth = satellite.mAzimuth;
}
Body of Second Method:
{
    if (satellite == null) {
        mValid = false;
    } else {
        mValid = satellite.mValid;
        mHasEphemeris = satellite.mHasEphemeris;
        mHasAlmanac = satellite.mHasAlmanac;
        mUsedInFix = satellite.mUsedInFix;
        mSnr = satellite.mSnr;
        mElevation = satellite.mElevation;
        mAzimuth = satellite.mAzimuth;
    }
}
------------------------
Find a silently evolved API code:android.webkit.WebView.onResume:COMMENT
Method Modifier: public      
Comment:/**
 * Resumes a WebView after a previous call to onPause().
 */

Body of Frist Method:
{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, "onResume");
    mProvider.onResume();
}
Body of Second Method:
{
    checkThread();
    mProvider.onResume();
}
------------------------
Find a silently evolved API code:android.preference.RingtonePreference.onPrepareRingtonePickerIntent:COMMENT
Method Modifier: protected   
Comment:/**
 * Prepares the intent to launch the ringtone picker. This can be modified
 * to adjust the parameters of the ringtone picker.
 *
 * @param ringtonePickerIntent The ringtone picker intent that can be
 * modified by putting extras.
 */

Body of Frist Method:
{
    ringtonePickerIntent.putExtra(RingtoneManager.EXTRA_RINGTONE_EXISTING_URI, onRestoreRingtone());
    ringtonePickerIntent.putExtra(RingtoneManager.EXTRA_RINGTONE_SHOW_DEFAULT, mShowDefault);
    if (mShowDefault) {
        ringtonePickerIntent.putExtra(RingtoneManager.EXTRA_RINGTONE_DEFAULT_URI, RingtoneManager.getDefaultUri(getRingtoneType()));
    }
    ringtonePickerIntent.putExtra(RingtoneManager.EXTRA_RINGTONE_SHOW_SILENT, mShowSilent);
    ringtonePickerIntent.putExtra(RingtoneManager.EXTRA_RINGTONE_TYPE, mRingtoneType);
    ringtonePickerIntent.putExtra(RingtoneManager.EXTRA_RINGTONE_TITLE, getTitle());
}
Body of Second Method:
{
    ringtonePickerIntent.putExtra(RingtoneManager.EXTRA_RINGTONE_EXISTING_URI, onRestoreRingtone());
    ringtonePickerIntent.putExtra(RingtoneManager.EXTRA_RINGTONE_SHOW_DEFAULT, mShowDefault);
    if (mShowDefault) {
        ringtonePickerIntent.putExtra(RingtoneManager.EXTRA_RINGTONE_DEFAULT_URI, RingtoneManager.getDefaultUri(getRingtoneType()));
    }
    ringtonePickerIntent.putExtra(RingtoneManager.EXTRA_RINGTONE_SHOW_SILENT, mShowSilent);
    ringtonePickerIntent.putExtra(RingtoneManager.EXTRA_RINGTONE_TYPE, mRingtoneType);
    ringtonePickerIntent.putExtra(RingtoneManager.EXTRA_RINGTONE_TITLE, getTitle());
    ringtonePickerIntent.putExtra(RingtoneManager.EXTRA_RINGTONE_AUDIO_ATTRIBUTES_FLAGS, AudioAttributes.FLAG_BYPASS_INTERRUPTION_POLICY);
}
------------------------
Find a silently evolved API code:android.media.ExifInterface.getGpsDateTime:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns number of milliseconds since Jan. 1, 1970, midnight UTC.
 * Returns -1 if the date time information if not available.
 * @hide
 */

Body of Frist Method:
{
    String date = mAttributes.get(TAG_GPS_DATESTAMP);
    String time = mAttributes.get(TAG_GPS_TIMESTAMP);
    if (date == null || time == null)
        return -1;
    String dateTimeString = date + ' ' + time;
    if (dateTimeString == null)
        return -1;
    ParsePosition pos = new ParsePosition(0);
    try {
        Date datetime = sFormatter.parse(dateTimeString, pos);
        if (datetime == null)
            return -1;
        return datetime.getTime();
    } catch (IllegalArgumentException ex) {
        return -1;
    }
}
Body of Second Method:
{
    String date = mAttributes.get(TAG_GPS_DATESTAMP);
    String time = mAttributes.get(TAG_GPS_TIMESTAMP);
    if (date == null || time == null)
        return -1;
    String dateTimeString = date + ' ' + time;
    ParsePosition pos = new ParsePosition(0);
    try {
        Date datetime = sFormatter.parse(dateTimeString, pos);
        if (datetime == null)
            return -1;
        return datetime.getTime();
    } catch (IllegalArgumentException ex) {
        return -1;
    }
}
------------------------
Find a silently evolved API code:android.media.ImageReader.close:COMMENT
Method Modifier: public      
Comment:/**
 * Free up all the resources associated with this ImageReader.
 *
 * <p>
 * After calling this method, this ImageReader can not be used. Calling
 * any methods on this ImageReader and Images previously provided by
 * {@link #acquireNextImage} or {@link #acquireLatestImage}
 * will result in an {@link IllegalStateException}, and attempting to read from
 * {@link ByteBuffer ByteBuffers} returned by an earlier
 * {@link Image.Plane#getBuffer Plane#getBuffer} call will
 * have undefined behavior.
 * </p>
 */

Body of Frist Method:
{
    setOnImageAvailableListener(null, null);
    nativeClose();
}
Body of Second Method:
{
    setOnImageAvailableListener(null, null);
    if (mSurface != null)
        mSurface.release();
    nativeClose();
    if (mEstimatedNativeAllocBytes > 0) {
        VMRuntime.getRuntime().registerNativeFree(mEstimatedNativeAllocBytes);
        mEstimatedNativeAllocBytes = 0;
    }
}
------------------------
Find a silently evolved API code:android.app.BackStackRecord.configureTransitions:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Configures custom transitions for a specific fragment container.
 *
 * @param containerId The container ID of the fragments to configure the transition for.
 * @param state The Transition State keeping track of the executing transitions.
 * @param firstOutFragments The list of first fragments to be removed, keyed on the
 * container ID.
 * @param lastInFragments The list of last fragments to be added, keyed on the
 * container ID.
 * @param isBack true if this is popping the back stack or false if this is a
 * forward operation.
 */

Body of Frist Method:
{
    ViewGroup sceneRoot = (ViewGroup) mManager.mContainer.findViewById(containerId);
    if (sceneRoot != null) {
        Fragment inFragment = lastInFragments.get(containerId);
        Fragment outFragment = firstOutFragments.get(containerId);
        Transition enterTransition = getEnterTransition(inFragment, isBack);
        Transition sharedElementTransition = getSharedElementTransition(inFragment, outFragment, isBack);
        Transition exitTransition = getExitTransition(outFragment, isBack);
        if (enterTransition == null && sharedElementTransition == null && exitTransition == null) {
            // no transitions!
            return;
        }
        if (enterTransition != null) {
            enterTransition.addTarget(state.nonExistentView);
        }
        ArrayMap<String, View> namedViews = null;
        ArrayList<View> sharedElementTargets = new ArrayList<View>();
        if (sharedElementTransition != null) {
            namedViews = remapSharedElements(state, outFragment, isBack);
            sharedElementTargets.add(state.nonExistentView);
            sharedElementTargets.addAll(namedViews.values());
            addTargets(sharedElementTransition, sharedElementTargets);
            // Notify the start of the transition.
            SharedElementCallback callback = isBack ? outFragment.mEnterTransitionCallback : inFragment.mEnterTransitionCallback;
            ArrayList<String> names = new ArrayList<String>(namedViews.keySet());
            ArrayList<View> views = new ArrayList<View>(namedViews.values());
            callback.onSharedElementStart(names, views, null);
        }
        ArrayList<View> exitingViews = captureExitingViews(exitTransition, outFragment, namedViews, state.nonExistentView);
        if (exitingViews == null || exitingViews.isEmpty()) {
            exitTransition = null;
        }
        // Set the epicenter of the exit transition
        if (mSharedElementTargetNames != null && namedViews != null) {
            View epicenterView = namedViews.get(mSharedElementTargetNames.get(0));
            if (epicenterView != null) {
                if (exitTransition != null) {
                    setEpicenter(exitTransition, epicenterView);
                }
                if (sharedElementTransition != null) {
                    setEpicenter(sharedElementTransition, epicenterView);
                }
            }
        }
        Transition transition = mergeTransitions(enterTransition, exitTransition, sharedElementTransition, inFragment, isBack);
        if (transition != null) {
            ArrayList<View> hiddenFragments = new ArrayList<View>();
            ArrayList<View> enteringViews = addTransitionTargets(state, enterTransition, sharedElementTransition, transition, sceneRoot, inFragment, outFragment, hiddenFragments, isBack, sharedElementTargets);
            transition.setNameOverrides(state.nameOverrides);
            // We want to exclude hidden views later, so we need a non-null list in the
            // transition now.
            transition.excludeTarget(state.nonExistentView, true);
            // Now exclude all currently hidden fragments.
            excludeHiddenFragments(hiddenFragments, containerId, transition);
            TransitionManager.beginDelayedTransition(sceneRoot, transition);
            // Remove the view targeting after the transition starts
            removeTargetedViewsFromTransitions(sceneRoot, state.nonExistentView, enterTransition, enteringViews, exitTransition, exitingViews, sharedElementTransition, sharedElementTargets, transition, hiddenFragments);
        }
    }
}
Body of Second Method:
{
    ViewGroup sceneRoot = (ViewGroup) mManager.mContainer.onFindViewById(containerId);
    if (sceneRoot != null) {
        Fragment inFragment = lastInFragments.get(containerId);
        Fragment outFragment = firstOutFragments.get(containerId);
        Transition enterTransition = getEnterTransition(inFragment, isBack);
        TransitionSet sharedElementTransition = getSharedElementTransition(inFragment, outFragment, isBack);
        Transition exitTransition = getExitTransition(outFragment, isBack);
        if (enterTransition == null && sharedElementTransition == null && exitTransition == null) {
            // no transitions!
            return;
        }
        if (enterTransition != null) {
            enterTransition.addTarget(state.nonExistentView);
        }
        ArrayMap<String, View> namedViews = null;
        ArrayList<View> sharedElementTargets = new ArrayList<View>();
        if (sharedElementTransition != null) {
            namedViews = remapSharedElements(state, outFragment, isBack);
            setSharedElementTargets(sharedElementTransition, state.nonExistentView, namedViews, sharedElementTargets);
            // Notify the start of the transition.
            SharedElementCallback callback = isBack ? outFragment.mEnterTransitionCallback : inFragment.mEnterTransitionCallback;
            ArrayList<String> names = new ArrayList<String>(namedViews.keySet());
            ArrayList<View> views = new ArrayList<View>(namedViews.values());
            callback.onSharedElementStart(names, views, null);
        }
        ArrayList<View> exitingViews = captureExitingViews(exitTransition, outFragment, namedViews, state.nonExistentView);
        if (exitingViews == null || exitingViews.isEmpty()) {
            exitTransition = null;
        }
        // Set the epicenter of the exit transition
        if (mSharedElementTargetNames != null && namedViews != null) {
            View epicenterView = namedViews.get(mSharedElementTargetNames.get(0));
            if (epicenterView != null) {
                if (exitTransition != null) {
                    setEpicenter(exitTransition, epicenterView);
                }
                if (sharedElementTransition != null) {
                    setEpicenter(sharedElementTransition, epicenterView);
                }
            }
        }
        Transition transition = mergeTransitions(enterTransition, exitTransition, sharedElementTransition, inFragment, isBack);
        if (transition != null) {
            ArrayList<View> hiddenFragments = new ArrayList<View>();
            ArrayList<View> enteringViews = addTransitionTargets(state, enterTransition, sharedElementTransition, transition, sceneRoot, inFragment, outFragment, hiddenFragments, isBack, sharedElementTargets);
            transition.setNameOverrides(state.nameOverrides);
            // We want to exclude hidden views later, so we need a non-null list in the
            // transition now.
            transition.excludeTarget(state.nonExistentView, true);
            // Now exclude all currently hidden fragments.
            excludeHiddenFragments(hiddenFragments, containerId, transition);
            TransitionManager.beginDelayedTransition(sceneRoot, transition);
            // Remove the view targeting after the transition starts
            removeTargetedViewsFromTransitions(sceneRoot, state.nonExistentView, enterTransition, enteringViews, exitTransition, exitingViews, sharedElementTransition, sharedElementTargets, transition, hiddenFragments);
        }
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiActivityEnergyInfo.getTimeStamp:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @return timestamp(wall clock) of record creation
 */

Body of Frist Method:
{
    return timestamp;
}
Body of Second Method:
{
    return mTimestamp;
}
------------------------
Find a silently evolved API code:android.graphics.Canvas.setBitmap:COMMENT
Method Modifier: public      
Comment:/**
 * Specify a bitmap for the canvas to draw into. All canvas state such as
 * layers, filters, and the save/restore stack are reset with the exception
 * of the current matrix and clip stack. Additionally, as a side-effect
 * the canvas' target density is updated to match that of the bitmap.
 *
 * @param bitmap Specifies a mutable bitmap for the canvas to draw into.
 * @see #setDensity(int)
 * @see #getDensity()
 */

Body of Frist Method:
{
    if (isHardwareAccelerated()) {
        throw new RuntimeException("Can't set a bitmap device on a HW accelerated canvas");
    }
    if (bitmap == null) {
        native_setBitmap(mNativeCanvasWrapper, 0, false);
        mDensity = Bitmap.DENSITY_NONE;
    } else {
        if (!bitmap.isMutable()) {
            throw new IllegalStateException();
        }
        throwIfCannotDraw(bitmap);
        native_setBitmap(mNativeCanvasWrapper, bitmap.ni(), true);
        mDensity = bitmap.mDensity;
    }
    mBitmap = bitmap;
}
Body of Second Method:
{
    if (isHardwareAccelerated()) {
        throw new RuntimeException("Can't set a bitmap device on a HW accelerated canvas");
    }
    if (bitmap == null) {
        native_setBitmap(mNativeCanvasWrapper, null);
        mDensity = Bitmap.DENSITY_NONE;
    } else {
        if (!bitmap.isMutable()) {
            throw new IllegalStateException();
        }
        throwIfCannotDraw(bitmap);
        native_setBitmap(mNativeCanvasWrapper, bitmap);
        mDensity = bitmap.mDensity;
    }
    mBitmap = bitmap;
}
------------------------
Find a silently evolved API code:android.content.ContentResolver.update:COMMENT
Method Modifier: public      final       
Comment:/**
 * Update row(s) in a content URI.
 *
 * If the content provider supports transactions the update will be atomic.
 *
 * @param uri The URI to modify.
 * @param values The new field values. The key is the column name for the field.
 * A null value will remove an existing field value.
 * @param where A filter to apply to rows before updating, formatted as an SQL WHERE clause
 * (excluding the WHERE itself).
 * @return the number of rows updated.
 * @throws NullPointerException if uri or values are null
 */

Body of Frist Method:
{
    IContentProvider provider = acquireProvider(uri);
    if (provider == null) {
        throw new IllegalArgumentException("Unknown URI " + uri);
    }
    try {
        long startTime = SystemClock.uptimeMillis();
        int rowsUpdated = provider.update(mPackageName, uri, values, where, selectionArgs);
        long durationMillis = SystemClock.uptimeMillis() - startTime;
        maybeLogUpdateToEventLog(durationMillis, uri, "update", where);
        return rowsUpdated;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return -1;
    } finally {
        releaseProvider(provider);
    }
}
Body of Second Method:
{
    Preconditions.checkNotNull(uri, "uri");
    IContentProvider provider = acquireProvider(uri);
    if (provider == null) {
        throw new IllegalArgumentException("Unknown URI " + uri);
    }
    try {
        long startTime = SystemClock.uptimeMillis();
        int rowsUpdated = provider.update(mPackageName, uri, values, where, selectionArgs);
        long durationMillis = SystemClock.uptimeMillis() - startTime;
        maybeLogUpdateToEventLog(durationMillis, uri, "update", where);
        return rowsUpdated;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return -1;
    } finally {
        releaseProvider(provider);
    }
}
------------------------
Find a silently evolved API code:android.app.FragmentManagerImpl.enqueueAction:COMMENT
Method Modifier: public      
Comment:/**
 * Adds an action to the queue of pending actions.
 *
 * @param action the action to add
 * @param allowStateLoss whether to allow loss of state information
 * @throws IllegalStateException if the activity has been destroyed
 */

Body of Frist Method:
{
    if (!allowStateLoss) {
        checkStateLoss();
    }
    synchronized (this) {
        if (mDestroyed || mActivity == null) {
            throw new IllegalStateException("Activity has been destroyed");
        }
        if (mPendingActions == null) {
            mPendingActions = new ArrayList<Runnable>();
        }
        mPendingActions.add(action);
        if (mPendingActions.size() == 1) {
            mActivity.mHandler.removeCallbacks(mExecCommit);
            mActivity.mHandler.post(mExecCommit);
        }
    }
}
Body of Second Method:
{
    if (!allowStateLoss) {
        checkStateLoss();
    }
    synchronized (this) {
        if (mDestroyed || mHost == null) {
            throw new IllegalStateException("Activity has been destroyed");
        }
        if (mPendingActions == null) {
            mPendingActions = new ArrayList<Runnable>();
        }
        mPendingActions.add(action);
        if (mPendingActions.size() == 1) {
            mHost.getHandler().removeCallbacks(mExecCommit);
            mHost.getHandler().post(mExecCommit);
        }
    }
}
------------------------
Find a silently evolved API code:android.renderscript.Allocation.ioSend:COMMENT
Method Modifier: public      
Comment:/**
 * Send a buffer to the output stream.  The contents of the Allocation will
 * be undefined after this operation. This operation is only valid if {@link
 * #USAGE_IO_OUTPUT} is set on the Allocation.
 */

Body of Frist Method:
{
    Trace.traceBegin(RenderScript.TRACE_TAG, "ioSend");
    if ((mUsage & USAGE_IO_OUTPUT) == 0) {
        throw new RSIllegalArgumentException("Can only send buffer if IO_OUTPUT usage specified.");
    }
    mRS.validate();
    mRS.nAllocationIoSend(getID(mRS));
    Trace.traceEnd(RenderScript.TRACE_TAG);
}
Body of Second Method:
{
    try {
        Trace.traceBegin(RenderScript.TRACE_TAG, "ioSend");
        if ((mUsage & USAGE_IO_OUTPUT) == 0) {
            throw new RSIllegalArgumentException("Can only send buffer if IO_OUTPUT usage specified.");
        }
        mRS.validate();
        mRS.nAllocationIoSend(getID(mRS));
    } finally {
        Trace.traceEnd(RenderScript.TRACE_TAG);
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiConfiguration.setVisibility:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 * calculate and set Visibility for that configuration.
 *
 * age in milliseconds: we will consider only ScanResults that are more recent,
 * i.e. younger.
 * *
 */

Body of Frist Method:
{
    if (scanResultCache == null) {
        visibility = null;
        return null;
    }
    Visibility status = new Visibility();
    long now_ms = System.currentTimeMillis();
    for (ScanResult result : scanResultCache.values()) {
        if (result.seen == 0)
            continue;
        if (result.is5GHz()) {
            // strictly speaking: [4915, 5825]
            // number of known BSSID on 5GHz band
            status.num5 = status.num5 + 1;
        } else if (result.is24GHz()) {
            // strictly speaking: [2412, 2482]
            // number of known BSSID on 2.4Ghz band
            status.num24 = status.num24 + 1;
        }
        if ((now_ms - result.seen) > age)
            continue;
        if (result.is5GHz()) {
            if (result.level > status.rssi5) {
                status.rssi5 = result.level;
                status.age5 = result.seen;
                status.BSSID5 = result.BSSID;
            }
        } else if (result.is24GHz()) {
            if (result.level > status.rssi24) {
                status.rssi24 = result.level;
                status.age24 = result.seen;
                status.BSSID24 = result.BSSID;
            }
        }
    }
    visibility = status;
    return status;
}
Body of Second Method:
{
    visibility = status;
}
------------------------
Find a silently evolved API code:android.hardware.camera2.params.TonemapCurve.hashCode:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (mHashCalculated) {
        // Avoid re-calculating hash. Data is immutable so this is both legal and faster.
        return mHashCode;
    }
    mHashCode = HashCodeHelpers.hashCode(mRed, mGreen, mBlue);
    mHashCalculated = true;
    return mHashCode;
}
Body of Second Method:
{
    if (mHashCalculated) {
        // Avoid re-calculating hash. Data is immutable so this is both legal and faster.
        return mHashCode;
    }
    mHashCode = HashCodeHelpers.hashCodeGeneric(mRed, mGreen, mBlue);
    mHashCalculated = true;
    return mHashCode;
}
------------------------
Find a silently evolved API code:javax.obex.ServerSession.handleSetPathRequest:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Handles a SETPATH request from a client. This method will read the rest
 * of the request from the client. Assuming the request is valid, it will
 * create a <code>HeaderSet</code> object to pass to the
 * <code>ServerRequestHandler</code> object. After the handler processes the
 * request, this method will create a reply message to send to the server
 * with the response code provided.
 * @throws IOException if an error occurred at the transport layer
 */

Body of Frist Method:
{
    int length;
    int flags;
    @SuppressWarnings("unused") int constants;
    int totalLength = 3;
    byte[] head = null;
    int code = -1;
    int bytesReceived;
    HeaderSet request = new HeaderSet();
    HeaderSet reply = new HeaderSet();
    length = mInput.read();
    length = (length << 8) + mInput.read();
    flags = mInput.read();
    constants = mInput.read();
    if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
        code = ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE;
        totalLength = 3;
    } else {
        if (length > 5) {
            byte[] headers = new byte[length - 5];
            bytesReceived = mInput.read(headers);
            while (bytesReceived != headers.length) {
                bytesReceived += mInput.read(headers, bytesReceived, headers.length - bytesReceived);
            }
            ObexHelper.updateHeaderSet(request, headers);
            if (mListener.getConnectionId() != -1 && request.mConnectionID != null) {
                mListener.setConnectionId(ObexHelper.convertToLong(request.mConnectionID));
            } else {
                mListener.setConnectionId(1);
            }
            // the Auth chan is initiated by the server, client sent back the authResp .
            if (request.mAuthResp != null) {
                if (!handleAuthResp(request.mAuthResp)) {
                    code = ResponseCodes.OBEX_HTTP_UNAUTHORIZED;
                    mListener.onAuthenticationFailure(ObexHelper.getTagValue((byte) 0x01, request.mAuthResp));
                }
                request.mAuthResp = null;
            }
        }
        if (code != ResponseCodes.OBEX_HTTP_UNAUTHORIZED) {
            // the server will send back the authResp to the client
            if (request.mAuthChall != null) {
                handleAuthChall(request);
                reply.mAuthResp = new byte[request.mAuthResp.length];
                System.arraycopy(request.mAuthResp, 0, reply.mAuthResp, 0, reply.mAuthResp.length);
                request.mAuthChall = null;
                request.mAuthResp = null;
            }
            boolean backup = false;
            boolean create = true;
            if (!((flags & 1) == 0)) {
                backup = true;
            }
            if (!((flags & 2) == 0)) {
                create = false;
            }
            try {
                code = mListener.onSetPath(request, reply, backup, create);
            } catch (Exception e) {
                sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR, null);
                return;
            }
            code = validateResponseCode(code);
            if (reply.nonce != null) {
                mChallengeDigest = new byte[16];
                System.arraycopy(reply.nonce, 0, mChallengeDigest, 0, 16);
            } else {
                mChallengeDigest = null;
            }
            long id = mListener.getConnectionId();
            if (id == -1) {
                reply.mConnectionID = null;
            } else {
                reply.mConnectionID = ObexHelper.convertToByteArray(id);
            }
            head = ObexHelper.createHeader(reply, false);
            totalLength += head.length;
            if (totalLength > mMaxPacketLength) {
                totalLength = 3;
                head = null;
                code = ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
            }
        }
    }
    // Compute Length of OBEX SETPATH packet
    byte[] replyData = new byte[totalLength];
    replyData[0] = (byte) code;
    replyData[1] = (byte) (totalLength >> 8);
    replyData[2] = (byte) totalLength;
    if (head != null) {
        System.arraycopy(head, 0, replyData, 3, head.length);
    }
    /*
         * Write the OBEX SETPATH packet to the server. Byte 0: response code
         * Byte 1&2: Connect Packet Length Byte 3 to n: headers
         */
    mOutput.write(replyData);
    mOutput.flush();
}
Body of Second Method:
{
    int length;
    int flags;
    @SuppressWarnings("unused") int constants;
    int totalLength = 3;
    byte[] head = null;
    int code = -1;
    int bytesReceived;
    HeaderSet request = new HeaderSet();
    HeaderSet reply = new HeaderSet();
    length = mInput.read();
    length = (length << 8) + mInput.read();
    flags = mInput.read();
    constants = mInput.read();
    if (length > ObexHelper.getMaxRxPacketSize(mTransport)) {
        code = ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE;
        totalLength = 3;
    } else {
        if (length > 5) {
            byte[] headers = new byte[length - 5];
            bytesReceived = mInput.read(headers);
            while (bytesReceived != headers.length) {
                bytesReceived += mInput.read(headers, bytesReceived, headers.length - bytesReceived);
            }
            ObexHelper.updateHeaderSet(request, headers);
            if (mListener.getConnectionId() != -1 && request.mConnectionID != null) {
                mListener.setConnectionId(ObexHelper.convertToLong(request.mConnectionID));
            } else {
                mListener.setConnectionId(1);
            }
            // the Auth chan is initiated by the server, client sent back the authResp .
            if (request.mAuthResp != null) {
                if (!handleAuthResp(request.mAuthResp)) {
                    code = ResponseCodes.OBEX_HTTP_UNAUTHORIZED;
                    mListener.onAuthenticationFailure(ObexHelper.getTagValue((byte) 0x01, request.mAuthResp));
                }
                request.mAuthResp = null;
            }
        }
        if (code != ResponseCodes.OBEX_HTTP_UNAUTHORIZED) {
            // the server will send back the authResp to the client
            if (request.mAuthChall != null) {
                handleAuthChall(request);
                reply.mAuthResp = new byte[request.mAuthResp.length];
                System.arraycopy(request.mAuthResp, 0, reply.mAuthResp, 0, reply.mAuthResp.length);
                request.mAuthChall = null;
                request.mAuthResp = null;
            }
            boolean backup = false;
            boolean create = true;
            if (!((flags & 1) == 0)) {
                backup = true;
            }
            if (!((flags & 2) == 0)) {
                create = false;
            }
            try {
                code = mListener.onSetPath(request, reply, backup, create);
            } catch (Exception e) {
                if (V)
                    Log.d(TAG, "Exception occured - sending OBEX_HTTP_INTERNAL_ERROR reply", e);
                sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR, null);
                return;
            }
            code = validateResponseCode(code);
            if (reply.nonce != null) {
                mChallengeDigest = new byte[16];
                System.arraycopy(reply.nonce, 0, mChallengeDigest, 0, 16);
            } else {
                mChallengeDigest = null;
            }
            long id = mListener.getConnectionId();
            if (id == -1) {
                reply.mConnectionID = null;
            } else {
                reply.mConnectionID = ObexHelper.convertToByteArray(id);
            }
            head = ObexHelper.createHeader(reply, false);
            totalLength += head.length;
            if (totalLength > mMaxPacketLength) {
                totalLength = 3;
                head = null;
                code = ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
            }
        }
    }
    // Compute Length of OBEX SETPATH packet
    byte[] replyData = new byte[totalLength];
    replyData[0] = (byte) code;
    replyData[1] = (byte) (totalLength >> 8);
    replyData[2] = (byte) totalLength;
    if (head != null) {
        System.arraycopy(head, 0, replyData, 3, head.length);
    }
    /*
         * Write the OBEX SETPATH packet to the server. Byte 0: response code
         * Byte 1&2: Connect Packet Length Byte 3 to n: headers
         */
    mOutput.write(replyData);
    mOutput.flush();
}
------------------------
Find a silently evolved API code:android.graphics.Paint.setClassVariablesFrom:COMMENT
Method Modifier: private     
Comment:/**
 * Set all class variables using current values from the given
 * {@link Paint}.
 */

Body of Frist Method:
{
    mColorFilter = paint.mColorFilter;
    mMaskFilter = paint.mMaskFilter;
    mPathEffect = paint.mPathEffect;
    mRasterizer = paint.mRasterizer;
    if (paint.mShader != null) {
        mShader = paint.mShader.copy();
    } else {
        mShader = null;
    }
    mTypeface = paint.mTypeface;
    mNativeTypeface = paint.mNativeTypeface;
    mXfermode = paint.mXfermode;
    mHasCompatScaling = paint.mHasCompatScaling;
    mCompatScaling = paint.mCompatScaling;
    mInvCompatScaling = paint.mInvCompatScaling;
    mBidiFlags = paint.mBidiFlags;
    mLocale = paint.mLocale;
    mFontFeatureSettings = paint.mFontFeatureSettings;
}
Body of Second Method:
{
    mColorFilter = paint.mColorFilter;
    mMaskFilter = paint.mMaskFilter;
    mPathEffect = paint.mPathEffect;
    mRasterizer = paint.mRasterizer;
    mShader = paint.mShader;
    mNativeShader = paint.mNativeShader;
    mTypeface = paint.mTypeface;
    mNativeTypeface = paint.mNativeTypeface;
    mXfermode = paint.mXfermode;
    mHasCompatScaling = paint.mHasCompatScaling;
    mCompatScaling = paint.mCompatScaling;
    mInvCompatScaling = paint.mInvCompatScaling;
    mBidiFlags = paint.mBidiFlags;
    mLocale = paint.mLocale;
    mFontFeatureSettings = paint.mFontFeatureSettings;
}
------------------------
Find a silently evolved API code:android.content.ContentResolver.applyBatch:COMMENT
Method Modifier: public      
Comment:/**
 * Applies each of the {@link ContentProviderOperation} objects and returns an array
 * of their results. Passes through OperationApplicationException, which may be thrown
 * by the call to {@link ContentProviderOperation#apply}.
 * If all the applications succeed then a {@link ContentProviderResult} array with the
 * same number of elements as the operations will be returned. It is implementation-specific
 * how many, if any, operations will have been successfully applied if a call to
 * apply results in a {@link OperationApplicationException}.
 * @param authority the authority of the ContentProvider to which this batch should be applied
 * @param operations the operations to apply
 * @return the results of the applications
 * @throws OperationApplicationException thrown if an application fails.
 * See {@link ContentProviderOperation#apply} for more information.
 * @throws RemoteException thrown if a RemoteException is encountered while attempting
 * to communicate with a remote provider.
 */

Body of Frist Method:
{
    ContentProviderClient provider = acquireContentProviderClient(authority);
    if (provider == null) {
        throw new IllegalArgumentException("Unknown authority " + authority);
    }
    try {
        return provider.applyBatch(operations);
    } finally {
        provider.release();
    }
}
Body of Second Method:
{
    Preconditions.checkNotNull(authority, "authority");
    Preconditions.checkNotNull(operations, "operations");
    ContentProviderClient provider = acquireContentProviderClient(authority);
    if (provider == null) {
        throw new IllegalArgumentException("Unknown authority " + authority);
    }
    try {
        return provider.applyBatch(operations);
    } finally {
        provider.release();
    }
}
------------------------
Find a silently evolved API code:android.util.Range.hashCode:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    return HashCodeHelpers.hashCode(mLower, mUpper);
}
Body of Second Method:
{
    return HashCodeHelpers.hashCodeGeneric(mLower, mUpper);
}
------------------------
Find a silently evolved API code:android.renderscript.ScriptIntrinsicResize.setInput:COMMENT
Method Modifier: public      
Comment:/**
 * Set the input of the resize.
 * Must match the element type supplied during create.
 *
 * @param ain The input allocation.
 */

Body of Frist Method:
{
    Element e = ain.getElement();
    if (!e.isCompatible(Element.U8(mRS)) && !e.isCompatible(Element.U8_2(mRS)) && !e.isCompatible(Element.U8_3(mRS)) && !e.isCompatible(Element.U8_4(mRS))) {
        throw new RSIllegalArgumentException("Unsuported element type.");
    }
    mInput = ain;
    setVar(0, ain);
}
Body of Second Method:
{
    Element e = ain.getElement();
    if (!e.isCompatible(Element.U8(mRS)) && !e.isCompatible(Element.U8_2(mRS)) && !e.isCompatible(Element.U8_3(mRS)) && !e.isCompatible(Element.U8_4(mRS)) && !e.isCompatible(Element.F32(mRS)) && !e.isCompatible(Element.F32_2(mRS)) && !e.isCompatible(Element.F32_3(mRS)) && !e.isCompatible(Element.F32_4(mRS))) {
        throw new RSIllegalArgumentException("Unsuported element type.");
    }
    mInput = ain;
    setVar(0, ain);
}
------------------------
Find a silently evolved API code:android.media.AudioManager.abandonAudioFocusForCall:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 * Used internally by telephony package to abandon audio focus, typically after a call or
 * when ringing ends and the call is rejected or not answered.
 * Should match one or more calls to {@link #requestAudioFocusForCall(int, int)}.
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        service.abandonAudioFocus(null, MediaFocusControl.IN_VOICE_COMM_FOCUS_ID, null);
    } catch (RemoteException e) {
        Log.e(TAG, "Can't call abandonAudioFocusForCall() on AudioService:", e);
    }
}
Body of Second Method:
{
    IAudioService service = getService();
    try {
        service.abandonAudioFocus(null, AudioSystem.IN_VOICE_COMM_FOCUS_ID, null);
    } catch (RemoteException e) {
        Log.e(TAG, "Can't call abandonAudioFocusForCall() on AudioService:", e);
    }
}
------------------------
Find a silently evolved API code:android.graphics.Bitmap.setHasAlpha:COMMENT
Method Modifier: public      
Comment:/**
 * Tell the bitmap if all of the pixels are known to be opaque (false)
 * or if some of the pixels may contain non-opaque alpha values (true).
 * Note, for some configs (e.g. RGB_565) this call is ignored, since it
 * does not support per-pixel alpha values.
 *
 * This is meant as a drawing hint, as in some cases a bitmap that is known
 * to be opaque can take a faster drawing case than one that may have
 * non-opaque per-pixel alpha values.
 */

Body of Frist Method:
{
    nativeSetHasAlpha(mNativeBitmap, hasAlpha, mRequestPremultiplied);
}
Body of Second Method:
{
    checkRecycled("setHasAlpha called on a recycled bitmap");
    nativeSetHasAlpha(mFinalizer.mNativeBitmap, hasAlpha, mRequestPremultiplied);
}
------------------------
Find a silently evolved API code:android.app.Activity.startActivityAsUser:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide Implement to provide correct calling token.
 */

Body of Frist Method:
{
    if (mParent != null) {
        throw new RuntimeException("Can't be called from a child");
    }
    Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity(this, mMainThread.getApplicationThread(), mToken, this, intent, -1, options, user);
    if (ar != null) {
        mMainThread.sendActivityResult(mToken, mEmbeddedID, -1, ar.getResultCode(), ar.getResultData());
    }
}
Body of Second Method:
{
    if (mParent != null) {
        throw new RuntimeException("Can't be called from a child");
    }
    Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity(this, mMainThread.getApplicationThread(), mToken, this, intent, -1, options, user);
    if (ar != null) {
        mMainThread.sendActivityResult(mToken, mEmbeddedID, -1, ar.getResultCode(), ar.getResultData());
    }
    cancelInputsAndStartExitTransition(options);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothDevice.getUuids:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the supported features (UUIDs) of the remote device.
 *
 * <p>This method does not start a service discovery procedure to retrieve the UUIDs
 * from the remote device. Instead, the local cached copy of the service
 * UUIDs are returned.
 * <p>Use {@link #fetchUuidsWithSdp} if fresh UUIDs are desired.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}.
 *
 * @return the supported features (UUIDs) of the remote device,
 * or null on error
 */

Body of Frist Method:
{
    if (sService == null) {
        Log.e(TAG, "BT not enabled. Cannot get remote device Uuids");
        return null;
    }
    try {
        return sService.getRemoteUuids(this);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return null;
}
Body of Second Method:
{
    if (sService == null || isBluetoothEnabled() == false) {
        Log.e(TAG, "BT not enabled. Cannot get remote device Uuids");
        return null;
    }
    try {
        return sService.getRemoteUuids(this);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return null;
}
------------------------
Find a silently evolved API code:android.content.pm.LauncherApps.getActivityList:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieves a list of launchable activities that match {@link Intent#ACTION_MAIN} and
 * {@link Intent#CATEGORY_LAUNCHER}, for a specified user.
 *
 * @param packageName The specific package to query. If null, it checks all installed packages
 * in the profile.
 * @param user The UserHandle of the profile.
 * @return List of launchable activities. Can be an empty list but will not be null.
 */

Body of Frist Method:
{
    List<ResolveInfo> activities = null;
    try {
        activities = mService.getLauncherActivities(packageName, user);
    } catch (RemoteException re) {
    }
    if (activities == null) {
        return Collections.EMPTY_LIST;
    }
    ArrayList<LauncherActivityInfo> lais = new ArrayList<LauncherActivityInfo>();
    final int count = activities.size();
    for (int i = 0; i < count; i++) {
        ResolveInfo ri = activities.get(i);
        long firstInstallTime = 0;
        try {
            firstInstallTime = mPm.getPackageInfo(ri.activityInfo.packageName, PackageManager.GET_UNINSTALLED_PACKAGES).firstInstallTime;
        } catch (NameNotFoundException nnfe) {
        // Sorry, can't find package
        }
        LauncherActivityInfo lai = new LauncherActivityInfo(mContext, ri, user, firstInstallTime);
        if (DEBUG) {
            Log.v(TAG, "Returning activity for profile " + user + " : " + lai.getComponentName());
        }
        lais.add(lai);
    }
    return lais;
}
Body of Second Method:
{
    List<ResolveInfo> activities = null;
    try {
        activities = mService.getLauncherActivities(packageName, user);
    } catch (RemoteException re) {
        throw new RuntimeException("Failed to call LauncherAppsService");
    }
    if (activities == null) {
        return Collections.EMPTY_LIST;
    }
    ArrayList<LauncherActivityInfo> lais = new ArrayList<LauncherActivityInfo>();
    final int count = activities.size();
    for (int i = 0; i < count; i++) {
        ResolveInfo ri = activities.get(i);
        long firstInstallTime = 0;
        try {
            firstInstallTime = mPm.getPackageInfo(ri.activityInfo.packageName, PackageManager.GET_UNINSTALLED_PACKAGES).firstInstallTime;
        } catch (NameNotFoundException nnfe) {
        // Sorry, can't find package
        }
        LauncherActivityInfo lai = new LauncherActivityInfo(mContext, ri, user, firstInstallTime);
        if (DEBUG) {
            Log.v(TAG, "Returning activity for profile " + user + " : " + lai.getComponentName());
        }
        lais.add(lai);
    }
    return lais;
}
------------------------
Find a silently evolved API code:android.media.AudioManager.registerMediaButtonIntent:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 * no-op if (pi == null) or (eventReceiver == null)
 */

Body of Frist Method:
{
    if (pi == null) {
        Log.e(TAG, "Cannot call registerMediaButtonIntent() with a null parameter");
        return;
    }
    MediaSessionLegacyHelper helper = MediaSessionLegacyHelper.getHelper(mContext);
    helper.addMediaButtonListener(pi, eventReceiver, mContext);
}
Body of Second Method:
{
    if (pi == null) {
        Log.e(TAG, "Cannot call registerMediaButtonIntent() with a null parameter");
        return;
    }
    MediaSessionLegacyHelper helper = MediaSessionLegacyHelper.getHelper(getContext());
    helper.addMediaButtonListener(pi, eventReceiver, getContext());
}
------------------------
Find a silently evolved API code:android.media.ImageReader.releaseImage:COMMENT
Method Modifier: private     
Comment:/**
 * <p>Return the frame to the ImageReader for reuse.</p>
 */

Body of Frist Method:
{
    if (!(i instanceof SurfaceImage)) {
        throw new IllegalArgumentException("This image was not produced by an ImageReader");
    }
    SurfaceImage si = (SurfaceImage) i;
    if (si.getReader() != this) {
        throw new IllegalArgumentException("This image was not produced by this ImageReader");
    }
    si.clearSurfacePlanes();
    nativeReleaseImage(i);
    si.setImageValid(false);
}
Body of Second Method:
{
    if (!(i instanceof SurfaceImage)) {
        throw new IllegalArgumentException("This image was not produced by an ImageReader");
    }
    SurfaceImage si = (SurfaceImage) i;
    if (si.getReader() != this) {
        throw new IllegalArgumentException("This image was not produced by this ImageReader");
    }
    si.clearSurfacePlanes();
    nativeReleaseImage(i);
    si.mIsImageValid = false;
}
------------------------
Find a silently evolved API code:android.net.wifi.ScanResult.writeToParcel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Implement the Parcelable interface {@hide}
 */

Body of Frist Method:
{
    if (wifiSsid != null) {
        dest.writeInt(1);
        wifiSsid.writeToParcel(dest, flags);
    } else {
        dest.writeInt(0);
    }
    dest.writeString(BSSID);
    dest.writeString(capabilities);
    dest.writeInt(level);
    dest.writeInt(frequency);
    dest.writeLong(timestamp);
    dest.writeInt(distanceCm);
    dest.writeInt(distanceSdCm);
    dest.writeLong(seen);
    dest.writeInt(autoJoinStatus);
    dest.writeInt(untrusted ? 1 : 0);
    dest.writeInt(numConnection);
    dest.writeInt(numUsage);
    dest.writeInt(numIpConfigFailures);
    dest.writeInt(isAutoJoinCandidate);
    if (informationElements != null) {
        dest.writeInt(informationElements.length);
        for (int i = 0; i < informationElements.length; i++) {
            dest.writeInt(informationElements[i].id);
            dest.writeInt(informationElements[i].bytes.length);
            dest.writeByteArray(informationElements[i].bytes);
        }
    } else {
        dest.writeInt(0);
    }
}
Body of Second Method:
{
    if (wifiSsid != null) {
        dest.writeInt(1);
        wifiSsid.writeToParcel(dest, flags);
    } else {
        dest.writeInt(0);
    }
    dest.writeString(SSID);
    dest.writeString(BSSID);
    dest.writeString(capabilities);
    dest.writeInt(level);
    dest.writeInt(frequency);
    dest.writeLong(timestamp);
    dest.writeInt(distanceCm);
    dest.writeInt(distanceSdCm);
    dest.writeInt(channelWidth);
    dest.writeInt(centerFreq0);
    dest.writeInt(centerFreq1);
    dest.writeLong(seen);
    dest.writeInt(autoJoinStatus);
    dest.writeInt(untrusted ? 1 : 0);
    dest.writeInt(numConnection);
    dest.writeInt(numUsage);
    dest.writeInt(numIpConfigFailures);
    dest.writeInt(isAutoJoinCandidate);
    dest.writeString((venueName != null) ? venueName.toString() : "");
    dest.writeString((operatorFriendlyName != null) ? operatorFriendlyName.toString() : "");
    dest.writeLong(this.flags);
    if (informationElements != null) {
        dest.writeInt(informationElements.length);
        for (int i = 0; i < informationElements.length; i++) {
            dest.writeInt(informationElements[i].id);
            dest.writeInt(informationElements[i].bytes.length);
            dest.writeByteArray(informationElements[i].bytes);
        }
    } else {
        dest.writeInt(0);
    }
}
------------------------
Find a silently evolved API code:android.content.ContentProviderClient.openFile:COMMENT
Method Modifier: public      
Comment:/**
 * See {@link ContentProvider#openFile ContentProvider.openFile}.  Note that
 * this <em>does not</em>
 * take care of non-content: URIs such as file:.  It is strongly recommended
 * you use the {@link ContentResolver#openFileDescriptor
 * ContentResolver.openFileDescriptor} API instead.
 */

Body of Frist Method:
{
    return openFile(url, mode, null);
}
Body of Second Method:
{
    Preconditions.checkNotNull(url, "url");
    Preconditions.checkNotNull(mode, "mode");
    beforeRemote();
    try {
        ICancellationSignal remoteSignal = null;
        if (signal != null) {
            signal.throwIfCanceled();
            remoteSignal = mContentProvider.createCancellationSignal();
            signal.setRemote(remoteSignal);
        }
        return mContentProvider.openFile(mPackageName, url, mode, remoteSignal, null);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}
------------------------
Find a silently evolved API code:android.media.SoundPool.pause:COMMENT
<android.media.SoundPool: void pause(int)>
public      final       ->public      final       native      
Method Modifier: public      final       native      
Method Modifier: Yes         Yes         No          
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * Pause a playback stream.
 *
 * Pause the stream specified by the streamID. This is the
 * value returned by the play() function. If the stream is
 * playing, it will be paused. If the stream is not playing
 * (e.g. is stopped or was previously paused), calling this
 * function will have no effect.
 *
 * @param streamID a streamID returned by the play() function
 */

Body of Frist Method:
{
    mImpl.pause(streamID);
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.os.FileUtils.contains:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Test if a file lives under the given directory, either as a direct child
 * or a distant grandchild.
 * <p>
 * Both files <em>must</em> have been resolved using
 * {@link File#getCanonicalFile()} to avoid symlink or path traversal
 * attacks.
 */

Body of Frist Method:
{
    if (file == null)
        return false;
    String dirPath = dir.getAbsolutePath();
    String filePath = file.getAbsolutePath();
    if (dirPath.equals(filePath)) {
        return true;
    }
    if (!dirPath.endsWith("/")) {
        dirPath += "/";
    }
    return filePath.startsWith(dirPath);
}
Body of Second Method:
{
    if (dir == null || file == null)
        return false;
    String dirPath = dir.getAbsolutePath();
    String filePath = file.getAbsolutePath();
    if (dirPath.equals(filePath)) {
        return true;
    }
    if (!dirPath.endsWith("/")) {
        dirPath += "/";
    }
    return filePath.startsWith(dirPath);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothSocket.write:COMMENT
Method Modifier: default     
Comment:/*package*/

Body of Frist Method:
{
    if (mSocketOS == null)
        throw new IOException("write is called on null OutputStream");
    if (VDBG)
        Log.d(TAG, "write: " + mSocketOS + " length: " + length);
    mSocketOS.write(b, offset, length);
    // There is no good way to confirm since the entire process is asynchronous anyway
    if (VDBG)
        Log.d(TAG, "write out: " + mSocketOS + " length: " + length);
    return length;
}
Body of Second Method:
{
    // to the actual message length.
    if (VDBG)
        Log.d(TAG, "write: " + mSocketOS + " length: " + length);
    if (mType == TYPE_L2CAP) {
        if (length <= mMaxTxPacketSize) {
            mSocketOS.write(b, offset, length);
        } else {
            int tmpOffset = offset;
            int tmpLength = mMaxTxPacketSize;
            int endIndex = offset + length;
            boolean done = false;
            if (DBG)
                Log.w(TAG, "WARNING: Write buffer larger than L2CAP packet size!\n" + "Packet will be divided into SDU packets of size " + mMaxTxPacketSize);
            do {
                mSocketOS.write(b, tmpOffset, tmpLength);
                tmpOffset += mMaxTxPacketSize;
                if ((tmpOffset + mMaxTxPacketSize) > endIndex) {
                    tmpLength = endIndex - tmpOffset;
                    done = true;
                }
            } while (!done);
        }
    } else {
        mSocketOS.write(b, offset, length);
    }
    // There is no good way to confirm since the entire process is asynchronous anyway
    if (VDBG)
        Log.d(TAG, "write out: " + mSocketOS + " length: " + length);
    return length;
}
------------------------
Find a silently evolved API code:android.view.ViewRootImpl.outputDisplayList:COMMENT
Method Modifier: default     hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    RenderNode renderNode = view.getDisplayList();
    if (renderNode != null) {
        renderNode.output();
    }
}
Body of Second Method:
{
    view.mRenderNode.output();
}
------------------------
Find a silently evolved API code:android.content.BroadcastReceiver.peekService:COMMENT
Method Modifier: public      
Comment:/**
 * Provide a binder to an already-running service.  This method is synchronous
 * and will not start the target service if it is not present, so it is safe
 * to call from {@link #onReceive}.
 *
 * @param myContext The Context that had been passed to {@link #onReceive(Context, Intent)}
 * @param service The Intent indicating the service you wish to use.  See {@link
 * Context#startService(Intent)} for more information.
 */

Body of Frist Method:
{
    IActivityManager am = ActivityManagerNative.getDefault();
    IBinder binder = null;
    try {
        service.prepareToLeaveProcess();
        binder = am.peekService(service, service.resolveTypeIfNeeded(myContext.getContentResolver()));
    } catch (RemoteException e) {
    }
    return binder;
}
Body of Second Method:
{
    IActivityManager am = ActivityManagerNative.getDefault();
    IBinder binder = null;
    try {
        service.prepareToLeaveProcess();
        binder = am.peekService(service, service.resolveTypeIfNeeded(myContext.getContentResolver()), myContext.getOpPackageName());
    } catch (RemoteException e) {
    }
    return binder;
}
------------------------
Find a silently evolved API code:android.content.ContentResolver.uncanonicalize:COMMENT
Method Modifier: public      final       
Comment:/**
 * Given a canonical Uri previously generated by {@link #canonicalize}, convert
 * it to its local non-canonical form.  This can be useful in some cases where
 * you know that you will only be using the Uri in the current environment and
 * want to avoid any possible overhead when using it with the content
 * provider or want to verify that the referenced data exists at all in the
 * new environment.
 *
 * @param url The canonical {@link Uri} that is to be convered back to its
 * non-canonical form.
 *
 * @return Returns the non-canonical representation of <var>url</var>.  This will
 * return null if data identified by the canonical Uri can not be found in
 * the current environment; callers must always check for null and deal with
 * that by appropriately falling back to an alternative.
 *
 * @see #canonicalize
 */

Body of Frist Method:
{
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        return null;
    }
    try {
        return provider.uncanonicalize(mPackageName, url);
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } finally {
        releaseProvider(provider);
    }
}
Body of Second Method:
{
    Preconditions.checkNotNull(url, "url");
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        return null;
    }
    try {
        return provider.uncanonicalize(mPackageName, url);
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } finally {
        releaseProvider(provider);
    }
}
------------------------
Find a silently evolved API code:android.media.AudioManager.setMode:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the audio mode.
 * <p>
 * The audio mode encompasses audio routing AND the behavior of
 * the telephony layer. Therefore this method should only be used by applications that
 * replace the platform-wide management of audio settings or the main telephony application.
 * In particular, the {@link #MODE_IN_CALL} mode should only be used by the telephony
 * application when it places a phone call, as it will cause signals from the radio layer
 * to feed the platform mixer.
 *
 * @param mode  the requested audio mode ({@link #MODE_NORMAL}, {@link #MODE_RINGTONE},
 * {@link #MODE_IN_CALL} or {@link #MODE_IN_COMMUNICATION}).
 * Informs the HAL about the current audio state so that
 * it can route the audio appropriately.
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        service.setMode(mode, mICallBack);
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in setMode", e);
    }
}
Body of Second Method:
{
    IAudioService service = getService();
    try {
        service.setMode(mode, mICallBack, mApplicationContext.getOpPackageName());
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in setMode", e);
    }
}
------------------------
Find a silently evolved API code:android.view.Display.getRealMetrics:COMMENT
Method Modifier: public      
Comment:/**
 * Gets display metrics based on the real size of this display.
 * <p>
 * The size is adjusted based on the current rotation of the display.
 * </p><p>
 * The real size may be smaller than the physical size of the screen when the
 * window manager is emulating a smaller display (using adb shell am display-size).
 * </p>
 *
 * @param outMetrics A {@link DisplayMetrics} object to receive the metrics.
 */

Body of Frist Method:
{
    synchronized (this) {
        updateDisplayInfoLocked();
        mDisplayInfo.getLogicalMetrics(outMetrics, CompatibilityInfo.DEFAULT_COMPATIBILITY_INFO, mDisplayAdjustments.getActivityToken());
    }
}
Body of Second Method:
{
    synchronized (this) {
        updateDisplayInfoLocked();
        mDisplayInfo.getLogicalMetrics(outMetrics, CompatibilityInfo.DEFAULT_COMPATIBILITY_INFO, mDisplayAdjustments.getConfiguration());
    }
}
------------------------
Find a silently evolved API code:android.telephony.ServiceState.rilRadioTechnologyToString:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Convert radio technology to String
 *
 * @param radioTechnology
 * @return String representation of the RAT
 *
 * @hide
 */

Body of Frist Method:
{
    String rtString;
    switch(rt) {
        case RIL_RADIO_TECHNOLOGY_UNKNOWN:
            rtString = "Unknown";
            break;
        case RIL_RADIO_TECHNOLOGY_GPRS:
            rtString = "GPRS";
            break;
        case RIL_RADIO_TECHNOLOGY_EDGE:
            rtString = "EDGE";
            break;
        case RIL_RADIO_TECHNOLOGY_UMTS:
            rtString = "UMTS";
            break;
        case RIL_RADIO_TECHNOLOGY_IS95A:
            rtString = "CDMA-IS95A";
            break;
        case RIL_RADIO_TECHNOLOGY_IS95B:
            rtString = "CDMA-IS95B";
            break;
        case RIL_RADIO_TECHNOLOGY_1xRTT:
            rtString = "1xRTT";
            break;
        case RIL_RADIO_TECHNOLOGY_EVDO_0:
            rtString = "EvDo-rev.0";
            break;
        case RIL_RADIO_TECHNOLOGY_EVDO_A:
            rtString = "EvDo-rev.A";
            break;
        case RIL_RADIO_TECHNOLOGY_HSDPA:
            rtString = "HSDPA";
            break;
        case RIL_RADIO_TECHNOLOGY_HSUPA:
            rtString = "HSUPA";
            break;
        case RIL_RADIO_TECHNOLOGY_HSPA:
            rtString = "HSPA";
            break;
        case RIL_RADIO_TECHNOLOGY_EVDO_B:
            rtString = "EvDo-rev.B";
            break;
        case RIL_RADIO_TECHNOLOGY_EHRPD:
            rtString = "eHRPD";
            break;
        case RIL_RADIO_TECHNOLOGY_LTE:
            rtString = "LTE";
            break;
        case RIL_RADIO_TECHNOLOGY_HSPAP:
            rtString = "HSPAP";
            break;
        case RIL_RADIO_TECHNOLOGY_GSM:
            rtString = "GSM";
            break;
        default:
            rtString = "Unexpected";
            Rlog.w(LOG_TAG, "Unexpected radioTechnology=" + rt);
            break;
    }
    return rtString;
}
Body of Second Method:
{
    String rtString;
    switch(rt) {
        case RIL_RADIO_TECHNOLOGY_UNKNOWN:
            rtString = "Unknown";
            break;
        case RIL_RADIO_TECHNOLOGY_GPRS:
            rtString = "GPRS";
            break;
        case RIL_RADIO_TECHNOLOGY_EDGE:
            rtString = "EDGE";
            break;
        case RIL_RADIO_TECHNOLOGY_UMTS:
            rtString = "UMTS";
            break;
        case RIL_RADIO_TECHNOLOGY_IS95A:
            rtString = "CDMA-IS95A";
            break;
        case RIL_RADIO_TECHNOLOGY_IS95B:
            rtString = "CDMA-IS95B";
            break;
        case RIL_RADIO_TECHNOLOGY_1xRTT:
            rtString = "1xRTT";
            break;
        case RIL_RADIO_TECHNOLOGY_EVDO_0:
            rtString = "EvDo-rev.0";
            break;
        case RIL_RADIO_TECHNOLOGY_EVDO_A:
            rtString = "EvDo-rev.A";
            break;
        case RIL_RADIO_TECHNOLOGY_HSDPA:
            rtString = "HSDPA";
            break;
        case RIL_RADIO_TECHNOLOGY_HSUPA:
            rtString = "HSUPA";
            break;
        case RIL_RADIO_TECHNOLOGY_HSPA:
            rtString = "HSPA";
            break;
        case RIL_RADIO_TECHNOLOGY_EVDO_B:
            rtString = "EvDo-rev.B";
            break;
        case RIL_RADIO_TECHNOLOGY_EHRPD:
            rtString = "eHRPD";
            break;
        case RIL_RADIO_TECHNOLOGY_LTE:
            rtString = "LTE";
            break;
        case RIL_RADIO_TECHNOLOGY_HSPAP:
            rtString = "HSPAP";
            break;
        case RIL_RADIO_TECHNOLOGY_GSM:
            rtString = "GSM";
            break;
        case RIL_RADIO_TECHNOLOGY_IWLAN:
            rtString = "IWLAN";
            break;
        default:
            rtString = "Unexpected";
            Rlog.w(LOG_TAG, "Unexpected radioTechnology=" + rt);
            break;
    }
    return rtString;
}
------------------------
Find a silently evolved API code:android.accounts.AbstractAccountAuthenticator.getAccountCredentialsForCloning:COMMENT
Method Modifier: public      
Comment:/**
 * Returns a Bundle that contains whatever is required to clone the account on a different
 * user. The Bundle is passed to the authenticator instance in the target user via
 * {@link #addAccountFromCredentials(AccountAuthenticatorResponse, Account, Bundle)}.
 * The default implementation returns null, indicating that cloning is not supported.
 * @param response to send the result back to the AccountManager, will never be null
 * @param account the account to clone, will never be null
 * @return a Bundle result or null if the result is to be returned via the response.
 * @throws NetworkErrorException
 * @see {@link #addAccountFromCredentials(AccountAuthenticatorResponse, Account, Bundle)}
 */

Body of Frist Method:
{
    new Thread(new Runnable() {

        public void run() {
            Bundle result = new Bundle();
            result.putBoolean(AccountManager.KEY_BOOLEAN_RESULT, false);
            response.onResult(result);
        }
    }).start();
    return null;
}
Body of Second Method:
{
    new Thread(new Runnable() {

        @Override
        public void run() {
            Bundle result = new Bundle();
            result.putBoolean(AccountManager.KEY_BOOLEAN_RESULT, false);
            response.onResult(result);
        }
    }).start();
    return null;
}
------------------------
Find a silently evolved API code:android.media.AudioFormat.isValidEncoding:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    switch(audioFormat) {
        case ENCODING_PCM_8BIT:
        case ENCODING_PCM_16BIT:
        case ENCODING_PCM_FLOAT:
        case ENCODING_AC3:
        case ENCODING_E_AC3:
            return true;
        default:
            return false;
    }
}
Body of Second Method:
{
    switch(audioFormat) {
        case ENCODING_PCM_8BIT:
        case ENCODING_PCM_16BIT:
        case ENCODING_PCM_FLOAT:
        case ENCODING_AC3:
        case ENCODING_E_AC3:
        case ENCODING_DTS:
        case ENCODING_DTS_HD:
        case ENCODING_MP3:
        case ENCODING_AAC_LC:
        case ENCODING_AAC_HE_V1:
        case ENCODING_AAC_HE_V2:
            return true;
        default:
            return false;
    }
}
------------------------
Find a silently evolved API code:android.media.AudioManager.registerAudioPortUpdateListener:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Register an audio port list update listener.
 * @hide
 */

Body of Frist Method:
{
    sAudioPortEventHandler.registerListener(l);
}
Body of Second Method:
{
    sAudioPortEventHandler.init();
    sAudioPortEventHandler.registerListener(l);
}
------------------------
Find a silently evolved API code:android.graphics.drawable.RippleDrawable.tryRippleEnter:COMMENT
Method Modifier: private     
Comment:/**
 * Attempts to start an enter animation for the active hotspot. Fails if
 * there are too many animating ripples.
 */

Body of Frist Method:
{
    if (mExitingRipplesCount >= MAX_RIPPLES) {
        // or there is a bug that's preventing ripples from being removed.
        return;
    }
    if (mRipple == null) {
        final float x;
        final float y;
        if (mHasPending) {
            mHasPending = false;
            x = mPendingX;
            y = mPendingY;
        } else {
            x = mHotspotBounds.exactCenterX();
            y = mHotspotBounds.exactCenterY();
        }
        mRipple = new Ripple(this, mHotspotBounds, x, y);
    }
    mRipple.setup(mState.mMaxRadius, mDensity);
    mRipple.enter();
}
Body of Second Method:
{
    if (mExitingRipplesCount >= MAX_RIPPLES) {
        // or there is a bug that's preventing ripples from being removed.
        return;
    }
    if (mRipple == null) {
        final float x;
        final float y;
        if (mHasPending) {
            mHasPending = false;
            x = mPendingX;
            y = mPendingY;
        } else {
            x = mHotspotBounds.exactCenterX();
            y = mHotspotBounds.exactCenterY();
        }
        final boolean isBounded = isBounded();
        mRipple = new RippleForeground(this, mHotspotBounds, x, y, isBounded);
    }
    mRipple.setup(mState.mMaxRadius, mDensity);
    mRipple.enter(false);
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiConfiguration.configKey:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 * return the string used to calculate the hash in WifiConfigStore
 * and uniquely identify this WifiConfiguration
 */

Body of Frist Method:
{
    String key;
    if (allowCached && mCachedConfigKey != null) {
        key = mCachedConfigKey;
    } else {
        if (allowedKeyManagement.get(KeyMgmt.WPA_PSK)) {
            key = SSID + KeyMgmt.strings[KeyMgmt.WPA_PSK];
        } else if (allowedKeyManagement.get(KeyMgmt.WPA_EAP) || allowedKeyManagement.get(KeyMgmt.IEEE8021X)) {
            key = SSID + KeyMgmt.strings[KeyMgmt.WPA_EAP];
        } else if (wepKeys[0] != null) {
            key = SSID + "WEP";
        } else {
            key = SSID + KeyMgmt.strings[KeyMgmt.NONE];
        }
        mCachedConfigKey = key;
    }
    return key;
}
Body of Second Method:
{
    String key;
    if (allowCached && mCachedConfigKey != null) {
        key = mCachedConfigKey;
    } else if (providerFriendlyName != null) {
        key = FQDN + KeyMgmt.strings[KeyMgmt.WPA_EAP];
    } else {
        if (allowedKeyManagement.get(KeyMgmt.WPA_PSK)) {
            key = SSID + KeyMgmt.strings[KeyMgmt.WPA_PSK];
        } else if (allowedKeyManagement.get(KeyMgmt.WPA_EAP) || allowedKeyManagement.get(KeyMgmt.IEEE8021X)) {
            key = SSID + KeyMgmt.strings[KeyMgmt.WPA_EAP];
        } else if (wepKeys[0] != null) {
            key = SSID + "WEP";
        } else {
            key = SSID + KeyMgmt.strings[KeyMgmt.NONE];
        }
        mCachedConfigKey = key;
    }
    return key;
}
------------------------
Find a silently evolved API code:javax.obex.HeaderSet.createAuthenticationChallenge:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets the authentication challenge header. The <code>realm</code> will be
 * encoded based upon the default encoding scheme used by the implementation
 * to encode strings. Therefore, the encoding scheme used to encode the
 * <code>realm</code> is application dependent.
 * @param realm a short description that describes what password to use; if
 * <code>null</code> no realm will be sent in the authentication
 * challenge header
 * @param userID if <code>true</code>, a user ID is required in the reply;
 * if <code>false</code>, no user ID is required
 * @param access if <code>true</code> then full access will be granted if
 * successful; if <code>false</code> then read-only access will be
 * granted if successful
 * @throws IOException
 */

Body of Frist Method:
{
    nonce = new byte[16];
    for (int i = 0; i < 16; i++) {
        nonce[i] = (byte) mRandom.nextInt();
    }
    mAuthChall = ObexHelper.computeAuthenticationChallenge(nonce, realm, access, userID);
}
Body of Second Method:
{
    nonce = new byte[16];
    if (mRandom == null) {
        mRandom = new SecureRandom();
    }
    for (int i = 0; i < 16; i++) {
        nonce[i] = (byte) mRandom.nextInt();
    }
    mAuthChall = ObexHelper.computeAuthenticationChallenge(nonce, realm, access, userID);
}
------------------------
Find a silently evolved API code:android.view.HardwareRenderer.create:COMMENT
Method Modifier: default     static      hidden      
Comment:/**
 * Creates a hardware renderer using OpenGL.
 *
 * @param translucent True if the surface is translucent, false otherwise
 *
 * @return A hardware renderer backed by OpenGL.
 */

Body of Frist Method:
{
    HardwareRenderer renderer = null;
    if (GLES20Canvas.isAvailable()) {
        renderer = new ThreadedRenderer(context, translucent);
    }
    return renderer;
}
Body of Second Method:
{
    HardwareRenderer renderer = null;
    if (DisplayListCanvas.isAvailable()) {
        renderer = new ThreadedRenderer(context, translucent);
    }
    return renderer;
}
------------------------
Find a silently evolved API code:android.renderscript.Allocation.getSurface:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the handle to a raw buffer that is being managed by the screen
 * compositor. This operation is only valid for Allocations with {@link
 * #USAGE_IO_INPUT}.
 *
 * @return Surface object associated with allocation
 */

Body of Frist Method:
{
    if ((mUsage & USAGE_IO_INPUT) == 0) {
        throw new RSInvalidStateException("Allocation is not a surface texture.");
    }
    return mRS.nAllocationGetSurface(getID(mRS));
}
Body of Second Method:
{
    if ((mUsage & USAGE_IO_INPUT) == 0) {
        throw new RSInvalidStateException("Allocation is not a surface texture.");
    }
    if (mGetSurfaceSurface == null) {
        mGetSurfaceSurface = mRS.nAllocationGetSurface(getID(mRS));
    }
    return mGetSurfaceSurface;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothAdapter.getBluetoothLeAdvertiser:COMMENT
Method Modifier: public      
Comment:/**
 * Returns a {@link BluetoothLeAdvertiser} object for Bluetooth LE Advertising operations.
 * Will return null if Bluetooth is turned off or if Bluetooth LE Advertising is not
 * supported on this device.
 * <p>
 * Use {@link #isMultipleAdvertisementSupported()} to check whether LE Advertising is supported
 * on this device before calling this method.
 */

Body of Frist Method:
{
    if (getState() != STATE_ON) {
        return null;
    }
    if (!isMultipleAdvertisementSupported() && !isPeripheralModeSupported()) {
        Log.e(TAG, "bluetooth le advertising not supported");
        return null;
    }
    synchronized (mLock) {
        if (sBluetoothLeAdvertiser == null) {
            sBluetoothLeAdvertiser = new BluetoothLeAdvertiser(mManagerService);
        }
    }
    return sBluetoothLeAdvertiser;
}
Body of Second Method:
{
    if (!getLeAccess())
        return null;
    if (!isMultipleAdvertisementSupported() && !isPeripheralModeSupported()) {
        Log.e(TAG, "Bluetooth LE advertising not supported");
        return null;
    }
    synchronized (mLock) {
        if (sBluetoothLeAdvertiser == null) {
            sBluetoothLeAdvertiser = new BluetoothLeAdvertiser(mManagerService);
        }
    }
    return sBluetoothLeAdvertiser;
}
------------------------
Find a silently evolved API code:android.speech.tts.TextToSpeech.getVoice:COMMENT
Method Modifier: public      
Comment:/**
 * Returns a Voice instance describing the voice currently being used for synthesis
 * requests sent to the TextToSpeech engine.
 *
 * @return Voice instance used by the client, or {@code null} if not set or on error.
 *
 * @see #getVoices
 * @see #setVoice
 * @see Voice
 */

Body of Frist Method:
{
    return runAction(new Action<Voice>() {

        @Override
        public Voice run(ITextToSpeechService service) throws RemoteException {
            String voiceName = mParams.getString(Engine.KEY_PARAM_VOICE_NAME, "");
            if (TextUtils.isEmpty(voiceName)) {
                return null;
            }
            List<Voice> voices = service.getVoices();
            if (voices == null) {
                return null;
            }
            for (Voice voice : voices) {
                if (voice.getName().equals(voiceName)) {
                    return voice;
                }
            }
            return null;
        }
    }, null, "getVoice");
}
Body of Second Method:
{
    return runAction(new Action<Voice>() {

        @Override
        public Voice run(ITextToSpeechService service) throws RemoteException {
            String voiceName = mParams.getString(Engine.KEY_PARAM_VOICE_NAME, "");
            if (TextUtils.isEmpty(voiceName)) {
                return null;
            }
            return getVoice(service, voiceName);
        }
    }, null, "getVoice");
}
------------------------
Find a silently evolved API code:android.media.AudioManager.setRingerMode:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the ringer mode.
 * <p>
 * Silent mode will mute the volume and will not vibrate. Vibrate mode will
 * mute the volume and vibrate. Normal mode will be audible and may vibrate
 * according to user settings.
 * <p>This method has no effect if the device implements a fixed volume policy
 * as indicated by {@link #isVolumeFixed()}.
 * @param ringerMode The ringer mode, one of {@link #RINGER_MODE_NORMAL},
 * {@link #RINGER_MODE_SILENT}, or {@link #RINGER_MODE_VIBRATE}.
 * @see #getRingerMode()
 * @see #isVolumeFixed()
 */

Body of Frist Method:
{
    if (!isValidRingerMode(ringerMode)) {
        return;
    }
    IAudioService service = getService();
    try {
        service.setRingerModeExternal(ringerMode, mContext.getOpPackageName());
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in setRingerMode", e);
    }
}
Body of Second Method:
{
    if (!isValidRingerMode(ringerMode)) {
        return;
    }
    IAudioService service = getService();
    try {
        service.setRingerModeExternal(ringerMode, getContext().getOpPackageName());
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in setRingerMode", e);
    }
}
------------------------
Find a silently evolved API code:android.view.accessibility.AccessibilityRecord.setSource:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the source to be a virtual descendant of the given <code>root</code>.
 * If <code>virtualDescendantId</code> equals to {@link View#NO_ID} the root
 * is set as the source.
 * <p>
 * A virtual descendant is an imaginary View that is reported as a part of the view
 * hierarchy for accessibility purposes. This enables custom views that draw complex
 * content to report them selves as a tree of virtual views, thus conveying their
 * logical structure.
 * </p>
 *
 * @param root The root of the virtual subtree.
 * @param virtualDescendantId The id of the virtual descendant.
 */

Body of Frist Method:
{
    enforceNotSealed();
    final boolean important;
    if (virtualDescendantId == UNDEFINED) {
        important = (root != null) ? root.isImportantForAccessibility() : true;
    } else {
        important = true;
    }
    setBooleanProperty(PROPERTY_IMPORTANT_FOR_ACCESSIBILITY, important);
    mSourceWindowId = (root != null) ? root.getAccessibilityWindowId() : UNDEFINED;
    final int rootViewId = (root != null) ? root.getAccessibilityViewId() : UNDEFINED;
    mSourceNodeId = AccessibilityNodeInfo.makeNodeId(rootViewId, virtualDescendantId);
}
Body of Second Method:
{
    enforceNotSealed();
    boolean important = true;
    mSourceWindowId = UNDEFINED;
    clearSourceNode();
    if (root != null) {
        if (virtualDescendantId == UNDEFINED || virtualDescendantId == AccessibilityNodeInfo.UNDEFINED_ITEM_ID) {
            important = root.isImportantForAccessibility();
            mSourceNode = root.createAccessibilityNodeInfo();
        } else {
            AccessibilityNodeProvider provider = root.getAccessibilityNodeProvider();
            if (provider != null) {
                mSourceNode = provider.createAccessibilityNodeInfo(virtualDescendantId);
            }
        }
        mSourceWindowId = root.getAccessibilityWindowId();
    }
    setBooleanProperty(PROPERTY_IMPORTANT_FOR_ACCESSIBILITY, important);
}
------------------------
Find a silently evolved API code:android.media.AudioManager.registerRemoteControlClient:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * Registers the remote control client for providing information to display on the remote
 * controls.
 * @param rcClient The remote control client from which remote controls will receive
 * information to display.
 * @see RemoteControlClient
 * @deprecated Use {@link MediaSession} instead.
 */

Body of Frist Method:
{
    if ((rcClient == null) || (rcClient.getRcMediaIntent() == null)) {
        return;
    }
    rcClient.registerWithSession(MediaSessionLegacyHelper.getHelper(mContext));
}
Body of Second Method:
{
    if ((rcClient == null) || (rcClient.getRcMediaIntent() == null)) {
        return;
    }
    rcClient.registerWithSession(MediaSessionLegacyHelper.getHelper(getContext()));
}
------------------------
Find a silently evolved API code:android.media.SoundPool.unload:COMMENT
<android.media.SoundPool: boolean unload(int)>
public      final       ->public      final       native      
Method Modifier: public      final       native      
Method Modifier: Yes         Yes         No          
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * Unload a sound from a sound ID.
 *
 * Unloads the sound specified by the soundID. This is the value
 * returned by the load() function. Returns true if the sound is
 * successfully unloaded, false if the sound was already unloaded.
 *
 * @param soundID a soundID returned by the load() function
 * @return true if just unloaded, false if previously unloaded
 */

Body of Frist Method:
{
    return mImpl.unload(soundID);
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.provider.CallLog.Calls.addCall:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Adds a call to the call log.
 *
 * @param ci the CallerInfo object to get the target contact from.  Can be null
 * if the contact is unknown.
 * @param context the context used to get the ContentResolver
 * @param number the phone number to be added to the calls db
 * @param presentation enum value from PhoneConstants.PRESENTATION_xxx, which
 * is set by the network and denotes the number presenting rules for
 * "allowed", "payphone", "restricted" or "unknown"
 * @param callType enumerated values for "incoming", "outgoing", or "missed"
 * @param features features of the call (e.g. Video).
 * @param accountHandle The accountHandle object identifying the provider of the call
 * @param start time stamp for the call in milliseconds
 * @param duration call duration in seconds
 * @param dataUsage data usage for the call in bytes, null if data usage was not tracked for
 * the call.
 * @param addForAllUsers If true, the call is added to the call log of all currently
 * running users. The caller must have the MANAGE_USERS permission if this is true.
 *
 * @result The URI of the call log entry belonging to the user that made or received this
 * call.
 * {@hide}
 */

Body of Frist Method:
{
    final ContentResolver resolver = context.getContentResolver();
    int numberPresentation = PRESENTATION_ALLOWED;
    // If the number field is empty set the presentation type to Unknown.
    if (presentation == PhoneConstants.PRESENTATION_RESTRICTED) {
        numberPresentation = PRESENTATION_RESTRICTED;
    } else if (presentation == PhoneConstants.PRESENTATION_PAYPHONE) {
        numberPresentation = PRESENTATION_PAYPHONE;
    } else if (TextUtils.isEmpty(number) || presentation == PhoneConstants.PRESENTATION_UNKNOWN) {
        numberPresentation = PRESENTATION_UNKNOWN;
    }
    if (numberPresentation != PRESENTATION_ALLOWED) {
        number = "";
        if (ci != null) {
            ci.name = "";
        }
    }
    // accountHandle information
    String accountComponentString = null;
    String accountId = null;
    if (accountHandle != null) {
        accountComponentString = accountHandle.getComponentName().flattenToString();
        accountId = accountHandle.getId();
    }
    ContentValues values = new ContentValues(6);
    values.put(NUMBER, number);
    values.put(NUMBER_PRESENTATION, Integer.valueOf(numberPresentation));
    values.put(TYPE, Integer.valueOf(callType));
    values.put(FEATURES, features);
    values.put(DATE, Long.valueOf(start));
    values.put(DURATION, Long.valueOf(duration));
    if (dataUsage != null) {
        values.put(DATA_USAGE, dataUsage);
    }
    values.put(PHONE_ACCOUNT_COMPONENT_NAME, accountComponentString);
    values.put(PHONE_ACCOUNT_ID, accountId);
    values.put(NEW, Integer.valueOf(1));
    if (callType == MISSED_TYPE) {
        values.put(IS_READ, Integer.valueOf(0));
    }
    if (ci != null) {
        values.put(CACHED_NAME, ci.name);
        values.put(CACHED_NUMBER_TYPE, ci.numberType);
        values.put(CACHED_NUMBER_LABEL, ci.numberLabel);
    }
    if ((ci != null) && (ci.contactIdOrZero > 0)) {
        // Update usage information for the number associated with the contact ID.
        // We need to use both the number and the ID for obtaining a data ID since other
        // contacts may have the same number.
        final Cursor cursor;
        // Phone.NORMALIZED_NUMBER column) first. If it isn't available try others.
        if (ci.normalizedNumber != null) {
            final String normalizedPhoneNumber = ci.normalizedNumber;
            cursor = resolver.query(Phone.CONTENT_URI, new String[] { Phone._ID }, Phone.CONTACT_ID + " =? AND " + Phone.NORMALIZED_NUMBER + " =?", new String[] { String.valueOf(ci.contactIdOrZero), normalizedPhoneNumber }, null);
        } else {
            final String phoneNumber = ci.phoneNumber != null ? ci.phoneNumber : number;
            cursor = resolver.query(Uri.withAppendedPath(Callable.CONTENT_FILTER_URI, Uri.encode(phoneNumber)), new String[] { Phone._ID }, Phone.CONTACT_ID + " =?", new String[] { String.valueOf(ci.contactIdOrZero) }, null);
        }
        if (cursor != null) {
            try {
                if (cursor.getCount() > 0 && cursor.moveToFirst()) {
                    final String dataId = cursor.getString(0);
                    updateDataUsageStatForData(resolver, dataId);
                    if (duration >= MIN_DURATION_FOR_NORMALIZED_NUMBER_UPDATE_MS && callType == Calls.OUTGOING_TYPE && TextUtils.isEmpty(ci.normalizedNumber)) {
                        updateNormalizedNumber(context, resolver, dataId, number);
                    }
                }
            } finally {
                cursor.close();
            }
        }
    }
    Uri result = null;
    if (addForAllUsers) {
        // Insert the entry for all currently running users, in order to trigger any
        // ContentObservers currently set on the call log.
        final UserManager userManager = (UserManager) context.getSystemService(Context.USER_SERVICE);
        List<UserInfo> users = userManager.getUsers(true);
        final int currentUserId = userManager.getUserHandle();
        final int count = users.size();
        for (int i = 0; i < count; i++) {
            final UserInfo user = users.get(i);
            final UserHandle userHandle = user.getUserHandle();
            if (userManager.isUserRunning(userHandle) && !userManager.hasUserRestriction(UserManager.DISALLOW_OUTGOING_CALLS, userHandle) && !user.isManagedProfile()) {
                Uri uri = addEntryAndRemoveExpiredEntries(context, ContentProvider.maybeAddUserId(CONTENT_URI, user.id), values);
                if (user.id == currentUserId) {
                    result = uri;
                }
            }
        }
    } else {
        result = addEntryAndRemoveExpiredEntries(context, CONTENT_URI, values);
    }
    return result;
}
Body of Second Method:
{
    return addCall(ci, context, number, presentation, callType, features, accountHandle, start, duration, dataUsage, addForAllUsers, false);
}
------------------------
Find a silently evolved API code:android.graphics.Canvas.saveLayer:COMMENT
Method Modifier: public      
Comment:/**
 * Helper version of saveLayer() that takes 4 values rather than a RectF.
 */

Body of Frist Method:
{
    return native_saveLayer(mNativeCanvasWrapper, left, top, right, bottom, paint != null ? paint.mNativePaint : 0, saveFlags);
}
Body of Second Method:
{
    return native_saveLayer(mNativeCanvasWrapper, left, top, right, bottom, paint != null ? paint.getNativeInstance() : 0, saveFlags);
}
------------------------
Find a silently evolved API code:android.widget.TextView.bringPointIntoView:COMMENT
Method Modifier: public      
Comment:/**
 * Move the point, specified by the offset, into the view if it is needed.
 * This has to be called after layout. Returns true if anything changed.
 */

Body of Frist Method:
{
    if (isLayoutRequested()) {
        mDeferScroll = offset;
        return false;
    }
    boolean changed = false;
    Layout layout = isShowingHint() ? mHintLayout : mLayout;
    if (layout == null)
        return changed;
    int line = layout.getLineForOffset(offset);
    int grav;
    switch(layout.getParagraphAlignment(line)) {
        case ALIGN_LEFT:
            grav = 1;
            break;
        case ALIGN_RIGHT:
            grav = -1;
            break;
        case ALIGN_NORMAL:
            grav = layout.getParagraphDirection(line);
            break;
        case ALIGN_OPPOSITE:
            grav = -layout.getParagraphDirection(line);
            break;
        case ALIGN_CENTER:
        default:
            grav = 0;
            break;
    }
    // We only want to clamp the cursor to fit within the layout width
    // in left-to-right modes, because in a right to left alignment,
    // we want to scroll to keep the line-right on the screen, as other
    // lines are likely to have text flush with the right margin, which
    // we want to keep visible.
    // A better long-term solution would probably be to measure both
    // the full line and a blank-trimmed version, and, for example, use
    // the latter measurement for centering and right alignment, but for
    // the time being we only implement the cursor clamping in left to
    // right where it is most likely to be annoying.
    final boolean clamped = grav > 0;
    // FIXME: Is it okay to truncate this, or should we round?
    final int x = (int) layout.getPrimaryHorizontal(offset, clamped);
    final int top = layout.getLineTop(line);
    final int bottom = layout.getLineTop(line + 1);
    int left = (int) FloatMath.floor(layout.getLineLeft(line));
    int right = (int) FloatMath.ceil(layout.getLineRight(line));
    int ht = layout.getHeight();
    int hspace = mRight - mLeft - getCompoundPaddingLeft() - getCompoundPaddingRight();
    int vspace = mBottom - mTop - getExtendedPaddingTop() - getExtendedPaddingBottom();
    if (!mHorizontallyScrolling && right - left > hspace && right > x) {
        // If cursor has been clamped, make sure we don't scroll.
        right = Math.max(x, left + hspace);
    }
    int hslack = (bottom - top) / 2;
    int vslack = hslack;
    if (vslack > vspace / 4)
        vslack = vspace / 4;
    if (hslack > hspace / 4)
        hslack = hspace / 4;
    int hs = mScrollX;
    int vs = mScrollY;
    if (top - vs < vslack)
        vs = top - vslack;
    if (bottom - vs > vspace - vslack)
        vs = bottom - (vspace - vslack);
    if (ht - vs < vspace)
        vs = ht - vspace;
    if (0 - vs > 0)
        vs = 0;
    if (grav != 0) {
        if (x - hs < hslack) {
            hs = x - hslack;
        }
        if (x - hs > hspace - hslack) {
            hs = x - (hspace - hslack);
        }
    }
    if (grav < 0) {
        if (left - hs > 0)
            hs = left;
        if (right - hs < hspace)
            hs = right - hspace;
    } else if (grav > 0) {
        if (right - hs < hspace)
            hs = right - hspace;
        if (left - hs > 0)
            hs = left;
    } else /* grav == 0 */
    {
        if (right - left <= hspace) {
            /*
                 * If the entire text fits, center it exactly.
                 */
            hs = left - (hspace - (right - left)) / 2;
        } else if (x > right - hslack) {
            /*
                 * If we are near the right edge, keep the right edge
                 * at the edge of the view.
                 */
            hs = right - hspace;
        } else if (x < left + hslack) {
            /*
                 * If we are near the left edge, keep the left edge
                 * at the edge of the view.
                 */
            hs = left;
        } else if (left > hs) {
            /*
                 * Is there whitespace visible at the left?  Fix it if so.
                 */
            hs = left;
        } else if (right < hs + hspace) {
            /*
                 * Is there whitespace visible at the right?  Fix it if so.
                 */
            hs = right - hspace;
        } else {
            /*
                 * Otherwise, float as needed.
                 */
            if (x - hs < hslack) {
                hs = x - hslack;
            }
            if (x - hs > hspace - hslack) {
                hs = x - (hspace - hslack);
            }
        }
    }
    if (hs != mScrollX || vs != mScrollY) {
        if (mScroller == null) {
            scrollTo(hs, vs);
        } else {
            long duration = AnimationUtils.currentAnimationTimeMillis() - mLastScroll;
            int dx = hs - mScrollX;
            int dy = vs - mScrollY;
            if (duration > ANIMATED_SCROLL_GAP) {
                mScroller.startScroll(mScrollX, mScrollY, dx, dy);
                awakenScrollBars(mScroller.getDuration());
                invalidate();
            } else {
                if (!mScroller.isFinished()) {
                    mScroller.abortAnimation();
                }
                scrollBy(dx, dy);
            }
            mLastScroll = AnimationUtils.currentAnimationTimeMillis();
        }
        changed = true;
    }
    if (isFocused()) {
        // will be ignored.
        if (mTempRect == null)
            mTempRect = new Rect();
        mTempRect.set(x - 2, top, x + 2, bottom);
        getInterestingRect(mTempRect, line);
        mTempRect.offset(mScrollX, mScrollY);
        if (requestRectangleOnScreen(mTempRect)) {
            changed = true;
        }
    }
    return changed;
}
Body of Second Method:
{
    if (isLayoutRequested()) {
        mDeferScroll = offset;
        return false;
    }
    boolean changed = false;
    Layout layout = isShowingHint() ? mHintLayout : mLayout;
    if (layout == null)
        return changed;
    int line = layout.getLineForOffset(offset);
    int grav;
    switch(layout.getParagraphAlignment(line)) {
        case ALIGN_LEFT:
            grav = 1;
            break;
        case ALIGN_RIGHT:
            grav = -1;
            break;
        case ALIGN_NORMAL:
            grav = layout.getParagraphDirection(line);
            break;
        case ALIGN_OPPOSITE:
            grav = -layout.getParagraphDirection(line);
            break;
        case ALIGN_CENTER:
        default:
            grav = 0;
            break;
    }
    // We only want to clamp the cursor to fit within the layout width
    // in left-to-right modes, because in a right to left alignment,
    // we want to scroll to keep the line-right on the screen, as other
    // lines are likely to have text flush with the right margin, which
    // we want to keep visible.
    // A better long-term solution would probably be to measure both
    // the full line and a blank-trimmed version, and, for example, use
    // the latter measurement for centering and right alignment, but for
    // the time being we only implement the cursor clamping in left to
    // right where it is most likely to be annoying.
    final boolean clamped = grav > 0;
    // FIXME: Is it okay to truncate this, or should we round?
    final int x = (int) layout.getPrimaryHorizontal(offset, clamped);
    final int top = layout.getLineTop(line);
    final int bottom = layout.getLineTop(line + 1);
    int left = (int) Math.floor(layout.getLineLeft(line));
    int right = (int) Math.ceil(layout.getLineRight(line));
    int ht = layout.getHeight();
    int hspace = mRight - mLeft - getCompoundPaddingLeft() - getCompoundPaddingRight();
    int vspace = mBottom - mTop - getExtendedPaddingTop() - getExtendedPaddingBottom();
    if (!mHorizontallyScrolling && right - left > hspace && right > x) {
        // If cursor has been clamped, make sure we don't scroll.
        right = Math.max(x, left + hspace);
    }
    int hslack = (bottom - top) / 2;
    int vslack = hslack;
    if (vslack > vspace / 4)
        vslack = vspace / 4;
    if (hslack > hspace / 4)
        hslack = hspace / 4;
    int hs = mScrollX;
    int vs = mScrollY;
    if (top - vs < vslack)
        vs = top - vslack;
    if (bottom - vs > vspace - vslack)
        vs = bottom - (vspace - vslack);
    if (ht - vs < vspace)
        vs = ht - vspace;
    if (0 - vs > 0)
        vs = 0;
    if (grav != 0) {
        if (x - hs < hslack) {
            hs = x - hslack;
        }
        if (x - hs > hspace - hslack) {
            hs = x - (hspace - hslack);
        }
    }
    if (grav < 0) {
        if (left - hs > 0)
            hs = left;
        if (right - hs < hspace)
            hs = right - hspace;
    } else if (grav > 0) {
        if (right - hs < hspace)
            hs = right - hspace;
        if (left - hs > 0)
            hs = left;
    } else /* grav == 0 */
    {
        if (right - left <= hspace) {
            /*
                 * If the entire text fits, center it exactly.
                 */
            hs = left - (hspace - (right - left)) / 2;
        } else if (x > right - hslack) {
            /*
                 * If we are near the right edge, keep the right edge
                 * at the edge of the view.
                 */
            hs = right - hspace;
        } else if (x < left + hslack) {
            /*
                 * If we are near the left edge, keep the left edge
                 * at the edge of the view.
                 */
            hs = left;
        } else if (left > hs) {
            /*
                 * Is there whitespace visible at the left?  Fix it if so.
                 */
            hs = left;
        } else if (right < hs + hspace) {
            /*
                 * Is there whitespace visible at the right?  Fix it if so.
                 */
            hs = right - hspace;
        } else {
            /*
                 * Otherwise, float as needed.
                 */
            if (x - hs < hslack) {
                hs = x - hslack;
            }
            if (x - hs > hspace - hslack) {
                hs = x - (hspace - hslack);
            }
        }
    }
    if (hs != mScrollX || vs != mScrollY) {
        if (mScroller == null) {
            scrollTo(hs, vs);
        } else {
            long duration = AnimationUtils.currentAnimationTimeMillis() - mLastScroll;
            int dx = hs - mScrollX;
            int dy = vs - mScrollY;
            if (duration > ANIMATED_SCROLL_GAP) {
                mScroller.startScroll(mScrollX, mScrollY, dx, dy);
                awakenScrollBars(mScroller.getDuration());
                invalidate();
            } else {
                if (!mScroller.isFinished()) {
                    mScroller.abortAnimation();
                }
                scrollBy(dx, dy);
            }
            mLastScroll = AnimationUtils.currentAnimationTimeMillis();
        }
        changed = true;
    }
    if (isFocused()) {
        // will be ignored.
        if (mTempRect == null)
            mTempRect = new Rect();
        mTempRect.set(x - 2, top, x + 2, bottom);
        getInterestingRect(mTempRect, line);
        mTempRect.offset(mScrollX, mScrollY);
        if (requestRectangleOnScreen(mTempRect)) {
            changed = true;
        }
    }
    return changed;
}
------------------------
Find a silently evolved API code:android.app.BackStackRecord.removeTargetedViewsFromTransitions:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * After the transition has started, remove all targets that we added to the transitions
 * so that the transitions are left in a clean state.
 */

Body of Frist Method:
{
    if (overallTransition != null) {
        sceneRoot.getViewTreeObserver().addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {

            @Override
            public boolean onPreDraw() {
                sceneRoot.getViewTreeObserver().removeOnPreDrawListener(this);
                if (enterTransition != null) {
                    enterTransition.removeTarget(nonExistingView);
                    removeTargets(enterTransition, enteringViews);
                }
                if (exitTransition != null) {
                    removeTargets(exitTransition, exitingViews);
                }
                if (sharedElementTransition != null) {
                    removeTargets(sharedElementTransition, sharedElementTargets);
                }
                int numViews = hiddenViews.size();
                for (int i = 0; i < numViews; i++) {
                    overallTransition.excludeTarget(hiddenViews.get(i), false);
                }
                overallTransition.excludeTarget(nonExistingView, false);
                return true;
            }
        });
    }
}
Body of Second Method:
{
    if (overallTransition != null) {
        sceneRoot.getViewTreeObserver().addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {

            @Override
            public boolean onPreDraw() {
                sceneRoot.getViewTreeObserver().removeOnPreDrawListener(this);
                if (enterTransition != null) {
                    removeTargets(enterTransition, enteringViews);
                }
                if (exitTransition != null) {
                    removeTargets(exitTransition, exitingViews);
                }
                if (sharedElementTransition != null) {
                    removeTargets(sharedElementTransition, sharedElementTargets);
                }
                int numViews = hiddenViews.size();
                for (int i = 0; i < numViews; i++) {
                    overallTransition.excludeTarget(hiddenViews.get(i), false);
                }
                overallTransition.excludeTarget(nonExistingView, false);
                return true;
            }
        });
    }
}
------------------------
Find a silently evolved API code:android.text.TextLine.handleText:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Utility function for measuring and rendering text.  The text must
 * not include a tab or emoji.
 *
 * @param wp the working paint
 * @param start the start of the text
 * @param end the end of the text
 * @param runIsRtl true if the run is right-to-left
 * @param c the canvas, can be null if rendering is not needed
 * @param x the edge of the run closest to the leading margin
 * @param top the top of the line
 * @param y the baseline
 * @param bottom the bottom of the line
 * @param fmi receives metrics information, can be null
 * @param needWidth true if the width of the run is needed
 * @return the signed width of the run based on the run direction; only
 * valid if needWidth is true
 */

Body of Frist Method:
{
    // Get metrics first (even for empty strings or "0" width runs)
    if (fmi != null) {
        expandMetricsFromPaint(fmi, wp);
    }
    int runLen = end - start;
    // No need to do anything if the run width is "0"
    if (runLen == 0) {
        return 0f;
    }
    float ret = 0;
    int contextLen = contextEnd - contextStart;
    if (needWidth || (c != null && (wp.bgColor != 0 || wp.underlineColor != 0 || runIsRtl))) {
        if (mCharsValid) {
            ret = wp.getTextRunAdvances(mChars, start, runLen, contextStart, contextLen, runIsRtl, null, 0);
        } else {
            int delta = mStart;
            ret = wp.getTextRunAdvances(mText, delta + start, delta + end, delta + contextStart, delta + contextEnd, runIsRtl, null, 0);
        }
    }
    if (c != null) {
        if (runIsRtl) {
            x -= ret;
        }
        if (wp.bgColor != 0) {
            int previousColor = wp.getColor();
            Paint.Style previousStyle = wp.getStyle();
            wp.setColor(wp.bgColor);
            wp.setStyle(Paint.Style.FILL);
            c.drawRect(x, top, x + ret, bottom, wp);
            wp.setStyle(previousStyle);
            wp.setColor(previousColor);
        }
        if (wp.underlineColor != 0) {
            // kStdUnderline_Offset = 1/9, defined in SkTextFormatParams.h
            float underlineTop = y + wp.baselineShift + (1.0f / 9.0f) * wp.getTextSize();
            int previousColor = wp.getColor();
            Paint.Style previousStyle = wp.getStyle();
            boolean previousAntiAlias = wp.isAntiAlias();
            wp.setStyle(Paint.Style.FILL);
            wp.setAntiAlias(true);
            wp.setColor(wp.underlineColor);
            c.drawRect(x, underlineTop, x + ret, underlineTop + wp.underlineThickness, wp);
            wp.setStyle(previousStyle);
            wp.setColor(previousColor);
            wp.setAntiAlias(previousAntiAlias);
        }
        drawTextRun(c, wp, start, end, contextStart, contextEnd, runIsRtl, x, y + wp.baselineShift);
    }
    return runIsRtl ? -ret : ret;
}
Body of Second Method:
{
    // Get metrics first (even for empty strings or "0" width runs)
    if (fmi != null) {
        expandMetricsFromPaint(fmi, wp);
    }
    int runLen = end - start;
    // No need to do anything if the run width is "0"
    if (runLen == 0) {
        return 0f;
    }
    float ret = 0;
    if (needWidth || (c != null && (wp.bgColor != 0 || wp.underlineColor != 0 || runIsRtl))) {
        if (mCharsValid) {
            ret = wp.getRunAdvance(mChars, start, end, contextStart, contextEnd, runIsRtl, end);
        } else {
            int delta = mStart;
            ret = wp.getRunAdvance(mText, delta + start, delta + end, delta + contextStart, delta + contextEnd, runIsRtl, delta + end);
        }
    }
    if (c != null) {
        if (runIsRtl) {
            x -= ret;
        }
        if (wp.bgColor != 0) {
            int previousColor = wp.getColor();
            Paint.Style previousStyle = wp.getStyle();
            wp.setColor(wp.bgColor);
            wp.setStyle(Paint.Style.FILL);
            c.drawRect(x, top, x + ret, bottom, wp);
            wp.setStyle(previousStyle);
            wp.setColor(previousColor);
        }
        if (wp.underlineColor != 0) {
            // kStdUnderline_Offset = 1/9, defined in SkTextFormatParams.h
            float underlineTop = y + wp.baselineShift + (1.0f / 9.0f) * wp.getTextSize();
            int previousColor = wp.getColor();
            Paint.Style previousStyle = wp.getStyle();
            boolean previousAntiAlias = wp.isAntiAlias();
            wp.setStyle(Paint.Style.FILL);
            wp.setAntiAlias(true);
            wp.setColor(wp.underlineColor);
            c.drawRect(x, underlineTop, x + ret, underlineTop + wp.underlineThickness, wp);
            wp.setStyle(previousStyle);
            wp.setColor(previousColor);
            wp.setAntiAlias(previousAntiAlias);
        }
        drawTextRun(c, wp, start, end, contextStart, contextEnd, runIsRtl, x, y + wp.baselineShift);
    }
    return runIsRtl ? -ret : ret;
}
------------------------
Find a silently evolved API code:android.graphics.Shader.setLocalMatrix:COMMENT
Method Modifier: public      
Comment:/**
 * Set the shader's local matrix. Passing null will reset the shader's
 * matrix to identity.
 *
 * @param localM The shader's new local matrix, or null to specify identity
 */

Body of Frist Method:
{
    mLocalMatrix = localM;
    nativeSetLocalMatrix(native_instance, localM == null ? 0 : localM.native_instance);
}
Body of Second Method:
{
    mLocalMatrix = localM;
    native_instance = nativeSetLocalMatrix(native_instance, localM == null ? 0 : localM.native_instance);
}
------------------------
Find a silently evolved API code:android.service.media.MediaBrowserService.addSubscription:COMMENT
Method Modifier: private     
Comment:/**
 * Save the subscription and if it is a new subscription send the results.
 */

Body of Frist Method:
{
    // Save the subscription
    final boolean added = connection.subscriptions.add(id);
    // If this is a new subscription, send the results
    if (added) {
        performLoadChildren(id, connection);
    }
}
Body of Second Method:
{
    // Save the subscription
    connection.subscriptions.add(id);
    // send the results
    performLoadChildren(id, connection);
}
------------------------
Find a silently evolved API code:android.widget.TextView.setCompoundDrawablesRelative:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the Drawables (if any) to appear to the start of, above, to the end
 * of, and below the text. Use {@code null} if you do not want a Drawable
 * there. The Drawables must already have had {@link Drawable#setBounds}
 * called.
 * <p>
 * Calling this method will overwrite any Drawables previously set using
 * {@link #setCompoundDrawables} or related methods.
 *
 * @attr ref android.R.styleable#TextView_drawableStart
 * @attr ref android.R.styleable#TextView_drawableTop
 * @attr ref android.R.styleable#TextView_drawableEnd
 * @attr ref android.R.styleable#TextView_drawableBottom
 */

Body of Frist Method:
{
    Drawables dr = mDrawables;
    // We're switching to relative, discard absolute.
    if (dr != null) {
        if (dr.mDrawableLeft != null)
            dr.mDrawableLeft.setCallback(null);
        dr.mDrawableLeft = dr.mDrawableLeftInitial = null;
        if (dr.mDrawableRight != null)
            dr.mDrawableRight.setCallback(null);
        dr.mDrawableRight = dr.mDrawableRightInitial = null;
        dr.mDrawableSizeLeft = dr.mDrawableHeightLeft = 0;
        dr.mDrawableSizeRight = dr.mDrawableHeightRight = 0;
    }
    final boolean drawables = start != null || top != null || end != null || bottom != null;
    if (!drawables) {
        // Clearing drawables...  can we free the data structure?
        if (dr != null) {
            if (dr.mDrawablePadding == 0) {
                mDrawables = null;
            } else {
                // out all of the fields in the existing structure.
                if (dr.mDrawableStart != null)
                    dr.mDrawableStart.setCallback(null);
                dr.mDrawableStart = null;
                if (dr.mDrawableTop != null)
                    dr.mDrawableTop.setCallback(null);
                dr.mDrawableTop = null;
                if (dr.mDrawableEnd != null)
                    dr.mDrawableEnd.setCallback(null);
                dr.mDrawableEnd = null;
                if (dr.mDrawableBottom != null)
                    dr.mDrawableBottom.setCallback(null);
                dr.mDrawableBottom = null;
                dr.mDrawableSizeStart = dr.mDrawableHeightStart = 0;
                dr.mDrawableSizeEnd = dr.mDrawableHeightEnd = 0;
                dr.mDrawableSizeTop = dr.mDrawableWidthTop = 0;
                dr.mDrawableSizeBottom = dr.mDrawableWidthBottom = 0;
            }
        }
    } else {
        if (dr == null) {
            mDrawables = dr = new Drawables(getContext());
        }
        mDrawables.mOverride = true;
        if (dr.mDrawableStart != start && dr.mDrawableStart != null) {
            dr.mDrawableStart.setCallback(null);
        }
        dr.mDrawableStart = start;
        if (dr.mDrawableTop != top && dr.mDrawableTop != null) {
            dr.mDrawableTop.setCallback(null);
        }
        dr.mDrawableTop = top;
        if (dr.mDrawableEnd != end && dr.mDrawableEnd != null) {
            dr.mDrawableEnd.setCallback(null);
        }
        dr.mDrawableEnd = end;
        if (dr.mDrawableBottom != bottom && dr.mDrawableBottom != null) {
            dr.mDrawableBottom.setCallback(null);
        }
        dr.mDrawableBottom = bottom;
        final Rect compoundRect = dr.mCompoundRect;
        int[] state;
        state = getDrawableState();
        if (start != null) {
            start.setState(state);
            start.copyBounds(compoundRect);
            start.setCallback(this);
            dr.mDrawableSizeStart = compoundRect.width();
            dr.mDrawableHeightStart = compoundRect.height();
        } else {
            dr.mDrawableSizeStart = dr.mDrawableHeightStart = 0;
        }
        if (end != null) {
            end.setState(state);
            end.copyBounds(compoundRect);
            end.setCallback(this);
            dr.mDrawableSizeEnd = compoundRect.width();
            dr.mDrawableHeightEnd = compoundRect.height();
        } else {
            dr.mDrawableSizeEnd = dr.mDrawableHeightEnd = 0;
        }
        if (top != null) {
            top.setState(state);
            top.copyBounds(compoundRect);
            top.setCallback(this);
            dr.mDrawableSizeTop = compoundRect.height();
            dr.mDrawableWidthTop = compoundRect.width();
        } else {
            dr.mDrawableSizeTop = dr.mDrawableWidthTop = 0;
        }
        if (bottom != null) {
            bottom.setState(state);
            bottom.copyBounds(compoundRect);
            bottom.setCallback(this);
            dr.mDrawableSizeBottom = compoundRect.height();
            dr.mDrawableWidthBottom = compoundRect.width();
        } else {
            dr.mDrawableSizeBottom = dr.mDrawableWidthBottom = 0;
        }
    }
    resetResolvedDrawables();
    resolveDrawables();
    invalidate();
    requestLayout();
}
Body of Second Method:
{
    Drawables dr = mDrawables;
    // We're switching to relative, discard absolute.
    if (dr != null) {
        if (dr.mShowing[Drawables.LEFT] != null) {
            dr.mShowing[Drawables.LEFT].setCallback(null);
        }
        dr.mShowing[Drawables.LEFT] = dr.mDrawableLeftInitial = null;
        if (dr.mShowing[Drawables.RIGHT] != null) {
            dr.mShowing[Drawables.RIGHT].setCallback(null);
        }
        dr.mShowing[Drawables.RIGHT] = dr.mDrawableRightInitial = null;
        dr.mDrawableSizeLeft = dr.mDrawableHeightLeft = 0;
        dr.mDrawableSizeRight = dr.mDrawableHeightRight = 0;
    }
    final boolean drawables = start != null || top != null || end != null || bottom != null;
    if (!drawables) {
        // Clearing drawables...  can we free the data structure?
        if (dr != null) {
            if (dr.mDrawablePadding == 0) {
                mDrawables = null;
            } else {
                // out all of the fields in the existing structure.
                if (dr.mDrawableStart != null)
                    dr.mDrawableStart.setCallback(null);
                dr.mDrawableStart = null;
                if (dr.mShowing[Drawables.TOP] != null) {
                    dr.mShowing[Drawables.TOP].setCallback(null);
                }
                dr.mShowing[Drawables.TOP] = null;
                if (dr.mDrawableEnd != null) {
                    dr.mDrawableEnd.setCallback(null);
                }
                dr.mDrawableEnd = null;
                if (dr.mShowing[Drawables.BOTTOM] != null) {
                    dr.mShowing[Drawables.BOTTOM].setCallback(null);
                }
                dr.mShowing[Drawables.BOTTOM] = null;
                dr.mDrawableSizeStart = dr.mDrawableHeightStart = 0;
                dr.mDrawableSizeEnd = dr.mDrawableHeightEnd = 0;
                dr.mDrawableSizeTop = dr.mDrawableWidthTop = 0;
                dr.mDrawableSizeBottom = dr.mDrawableWidthBottom = 0;
            }
        }
    } else {
        if (dr == null) {
            mDrawables = dr = new Drawables(getContext());
        }
        mDrawables.mOverride = true;
        if (dr.mDrawableStart != start && dr.mDrawableStart != null) {
            dr.mDrawableStart.setCallback(null);
        }
        dr.mDrawableStart = start;
        if (dr.mShowing[Drawables.TOP] != top && dr.mShowing[Drawables.TOP] != null) {
            dr.mShowing[Drawables.TOP].setCallback(null);
        }
        dr.mShowing[Drawables.TOP] = top;
        if (dr.mDrawableEnd != end && dr.mDrawableEnd != null) {
            dr.mDrawableEnd.setCallback(null);
        }
        dr.mDrawableEnd = end;
        if (dr.mShowing[Drawables.BOTTOM] != bottom && dr.mShowing[Drawables.BOTTOM] != null) {
            dr.mShowing[Drawables.BOTTOM].setCallback(null);
        }
        dr.mShowing[Drawables.BOTTOM] = bottom;
        final Rect compoundRect = dr.mCompoundRect;
        int[] state;
        state = getDrawableState();
        if (start != null) {
            start.setState(state);
            start.copyBounds(compoundRect);
            start.setCallback(this);
            dr.mDrawableSizeStart = compoundRect.width();
            dr.mDrawableHeightStart = compoundRect.height();
        } else {
            dr.mDrawableSizeStart = dr.mDrawableHeightStart = 0;
        }
        if (end != null) {
            end.setState(state);
            end.copyBounds(compoundRect);
            end.setCallback(this);
            dr.mDrawableSizeEnd = compoundRect.width();
            dr.mDrawableHeightEnd = compoundRect.height();
        } else {
            dr.mDrawableSizeEnd = dr.mDrawableHeightEnd = 0;
        }
        if (top != null) {
            top.setState(state);
            top.copyBounds(compoundRect);
            top.setCallback(this);
            dr.mDrawableSizeTop = compoundRect.height();
            dr.mDrawableWidthTop = compoundRect.width();
        } else {
            dr.mDrawableSizeTop = dr.mDrawableWidthTop = 0;
        }
        if (bottom != null) {
            bottom.setState(state);
            bottom.copyBounds(compoundRect);
            bottom.setCallback(this);
            dr.mDrawableSizeBottom = compoundRect.height();
            dr.mDrawableWidthBottom = compoundRect.width();
        } else {
            dr.mDrawableSizeBottom = dr.mDrawableWidthBottom = 0;
        }
    }
    resetResolvedDrawables();
    resolveDrawables();
    invalidate();
    requestLayout();
}
------------------------
Find a silently evolved API code:android.app.WallpaperManager.suggestDesiredDimensions:COMMENT
Method Modifier: public      
Comment:/**
 * For use only by the current home application, to specify the size of
 * wallpaper it would like to use.  This allows such applications to have
 * a virtual wallpaper that is larger than the physical screen, matching
 * the size of their workspace.
 *
 * <p>Note developers, who don't seem to be reading this.  This is
 * for <em>home screens</em> to tell what size wallpaper they would like.
 * Nobody else should be calling this!  Certainly not other non-home-screen
 * apps that change the wallpaper.  Those apps are supposed to
 * <b>retrieve</b> the suggested size so they can construct a wallpaper
 * that matches it.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#SET_WALLPAPER_HINTS}.
 *
 * @param minimumWidth Desired minimum width
 * @param minimumHeight Desired minimum height
 */

Body of Frist Method:
{
    try {
        /**
         * The framework makes no attempt to limit the window size
         * to the maximum texture size. Any window larger than this
         * cannot be composited.
         *
         * Read maximum texture size from system property and scale down
         * minimumWidth and minimumHeight accordingly.
         */
        int maximumTextureSize;
        try {
            maximumTextureSize = SystemProperties.getInt("sys.max_texture_size", 0);
        } catch (Exception e) {
            maximumTextureSize = 0;
        }
        if (maximumTextureSize > 0) {
            if ((minimumWidth > maximumTextureSize) || (minimumHeight > maximumTextureSize)) {
                float aspect = (float) minimumHeight / (float) minimumWidth;
                if (minimumWidth > minimumHeight) {
                    minimumWidth = maximumTextureSize;
                    minimumHeight = (int) ((minimumWidth * aspect) + 0.5);
                } else {
                    minimumHeight = maximumTextureSize;
                    minimumWidth = (int) ((minimumHeight / aspect) + 0.5);
                }
            }
        }
        if (sGlobals.mService == null) {
            Log.w(TAG, "WallpaperService not running");
        } else {
            sGlobals.mService.setDimensionHints(minimumWidth, minimumHeight);
        }
    } catch (RemoteException e) {
    // Ignore
    }
}
Body of Second Method:
{
    try {
        /**
         * The framework makes no attempt to limit the window size
         * to the maximum texture size. Any window larger than this
         * cannot be composited.
         *
         * Read maximum texture size from system property and scale down
         * minimumWidth and minimumHeight accordingly.
         */
        int maximumTextureSize;
        try {
            maximumTextureSize = SystemProperties.getInt("sys.max_texture_size", 0);
        } catch (Exception e) {
            maximumTextureSize = 0;
        }
        if (maximumTextureSize > 0) {
            if ((minimumWidth > maximumTextureSize) || (minimumHeight > maximumTextureSize)) {
                float aspect = (float) minimumHeight / (float) minimumWidth;
                if (minimumWidth > minimumHeight) {
                    minimumWidth = maximumTextureSize;
                    minimumHeight = (int) ((minimumWidth * aspect) + 0.5);
                } else {
                    minimumHeight = maximumTextureSize;
                    minimumWidth = (int) ((minimumHeight / aspect) + 0.5);
                }
            }
        }
        if (sGlobals.mService == null) {
            Log.w(TAG, "WallpaperService not running");
        } else {
            sGlobals.mService.setDimensionHints(minimumWidth, minimumHeight, mContext.getOpPackageName());
        }
    } catch (RemoteException e) {
    // Ignore
    }
}
------------------------
Find a silently evolved API code:android.animation.ValueAnimator.doAnimationFrame:COMMENT
Method Modifier: default     final       
Comment:/**
 * Processes a frame of the animation, adjusting the start time if needed.
 *
 * @param frameTime The frame time.
 * @return true if the animation has ended.
 */

Body of Frist Method:
{
    if (mPlayingState == STOPPED) {
        mPlayingState = RUNNING;
        if (mSeekFraction < 0) {
            mStartTime = frameTime;
        } else {
            long seekTime = (long) (mDuration * mSeekFraction);
            mStartTime = frameTime - seekTime;
            mSeekFraction = -1;
        }
    }
    if (mPaused) {
        if (mPauseTime < 0) {
            mPauseTime = frameTime;
        }
        return false;
    } else if (mResumed) {
        mResumed = false;
        if (mPauseTime > 0) {
            // Offset by the duration that the animation was paused
            mStartTime += (frameTime - mPauseTime);
        }
    }
    // The frame time might be before the start time during the first frame of
    // an animation.  The "current time" must always be on or after the start
    // time to avoid animating frames at negative time intervals.  In practice, this
    // is very rare and only happens when seeking backwards.
    final long currentTime = Math.max(frameTime, mStartTime);
    return animationFrame(currentTime);
}
Body of Second Method:
{
    if (mPlayingState == STOPPED) {
        mPlayingState = RUNNING;
        if (mSeekFraction < 0) {
            mStartTime = frameTime;
        } else {
            long seekTime = (long) (mDuration * mSeekFraction);
            mStartTime = frameTime - seekTime;
            mSeekFraction = -1;
        }
        // allow start time to be compensated for jank
        mStartTimeCommitted = false;
    }
    if (mPaused) {
        if (mPauseTime < 0) {
            mPauseTime = frameTime;
        }
        return false;
    } else if (mResumed) {
        mResumed = false;
        if (mPauseTime > 0) {
            // Offset by the duration that the animation was paused
            mStartTime += (frameTime - mPauseTime);
            // allow start time to be compensated for jank
            mStartTimeCommitted = false;
        }
    }
    // The frame time might be before the start time during the first frame of
    // an animation.  The "current time" must always be on or after the start
    // time to avoid animating frames at negative time intervals.  In practice, this
    // is very rare and only happens when seeking backwards.
    final long currentTime = Math.max(frameTime, mStartTime);
    return animationFrame(currentTime);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothAdapter.listenUsingInsecureRfcommOn:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Construct an unencrypted, unauthenticated, RFCOMM server socket.
 * Call #accept to retrieve connections to this socket.
 * @return An RFCOMM BluetoothServerSocket
 * @throws IOException On error, for example Bluetooth not available, or
 * insufficient permissions.
 * @hide
 */

Body of Frist Method:
{
    BluetoothServerSocket socket = new BluetoothServerSocket(BluetoothSocket.TYPE_RFCOMM, false, false, port);
    int errno = socket.mSocket.bindListen();
    if (errno != 0) {
        // socket.mSocket.throwErrnoNative(errno);
        throw new IOException("Error: " + errno);
    }
    return socket;
}
Body of Second Method:
{
    BluetoothServerSocket socket = new BluetoothServerSocket(BluetoothSocket.TYPE_RFCOMM, false, false, port);
    int errno = socket.mSocket.bindListen();
    if (port == SOCKET_CHANNEL_AUTO_STATIC_NO_SDP) {
        socket.setChannel(socket.mSocket.getPort());
    }
    if (errno != 0) {
        // socket.mSocket.throwErrnoNative(errno);
        throw new IOException("Error: " + errno);
    }
    return socket;
}
------------------------
Find a silently evolved API code:android.provider.CalendarContract.CalendarAlerts.scheduleAlarm:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Schedules an alarm intent with the system AlarmManager that will
 * notify listeners when a reminder should be fired. The provider will
 * keep scheduled reminders up to date but apps may use this to
 * implement snooze functionality without modifying the reminders table.
 * Scheduled alarms will generate an intent using
 * {@link #ACTION_EVENT_REMINDER}. TODO Move to provider
 *
 * @param context A context for referencing system resources
 * @param manager The AlarmManager to use or null
 * @param alarmTime The time to fire the intent in UTC millis since
 * epoch
 * @hide
 */

Body of Frist Method:
{
    if (DEBUG) {
        Time time = new Time();
        time.set(alarmTime);
        String schedTime = time.format(" %a, %b %d, %Y %I:%M%P");
        Log.d(TAG, "Schedule alarm at " + alarmTime + " " + schedTime);
    }
    if (manager == null) {
        manager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);
    }
    Intent intent = new Intent(ACTION_EVENT_REMINDER);
    intent.setData(ContentUris.withAppendedId(CalendarContract.CONTENT_URI, alarmTime));
    intent.putExtra(ALARM_TIME, alarmTime);
    PendingIntent pi = PendingIntent.getBroadcast(context, 0, intent, 0);
    manager.setExact(AlarmManager.RTC_WAKEUP, alarmTime, pi);
}
Body of Second Method:
{
    if (DEBUG) {
        Time time = new Time();
        time.set(alarmTime);
        String schedTime = time.format(" %a, %b %d, %Y %I:%M%P");
        Log.d(TAG, "Schedule alarm at " + alarmTime + " " + schedTime);
    }
    if (manager == null) {
        manager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);
    }
    Intent intent = new Intent(ACTION_EVENT_REMINDER);
    intent.setData(ContentUris.withAppendedId(CalendarContract.CONTENT_URI, alarmTime));
    intent.putExtra(ALARM_TIME, alarmTime);
    PendingIntent pi = PendingIntent.getBroadcast(context, 0, intent, 0);
    manager.setExactAndAllowWhileIdle(AlarmManager.RTC_WAKEUP, alarmTime, pi);
}
------------------------
Find a silently evolved API code:android.view.accessibility.AccessibilityRecord.getSourceNodeId:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Gets the id of the source node.
 *
 * @return The id.
 *
 * @hide
 */

Body of Frist Method:
{
    return mSourceNodeId;
}
Body of Second Method:
{
    return mSourceNode != null ? mSourceNode.getSourceNodeId() : UNDEFINED;
}
------------------------
Find a silently evolved API code:android.app.Activity.onKeyShortcut:COMMENT
Method Modifier: public      
Comment:/**
 * Called when a key shortcut event is not handled by any of the views in the Activity.
 * Override this method to implement global key shortcuts for the Activity.
 * Key shortcuts can also be implemented by setting the
 * {@link MenuItem#setShortcut(char, char) shortcut} property of menu items.
 *
 * @param keyCode The value in event.getKeyCode().
 * @param event Description of the key event.
 * @return True if the key shortcut was handled.
 */

Body of Frist Method:
{
    return false;
}
Body of Second Method:
{
    // Let the Action Bar have a chance at handling the shortcut.
    ActionBar actionBar = getActionBar();
    return (actionBar != null && actionBar.onKeyShortcut(keyCode, event));
}
------------------------
Find a silently evolved API code:android.widget.SuggestionsAdapter.getDrawable:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Gets a drawable by URI, without using the cache.
 *
 * @return A drawable, or {@code null} if the drawable could not be loaded.
 */

Body of Frist Method:
{
    try {
        String scheme = uri.getScheme();
        if (ContentResolver.SCHEME_ANDROID_RESOURCE.equals(scheme)) {
            // Load drawables through Resources, to get the source density information
            OpenResourceIdResult r = mProviderContext.getContentResolver().getResourceId(uri);
            try {
                return r.r.getDrawable(r.id, mContext.getTheme());
            } catch (Resources.NotFoundException ex) {
                throw new FileNotFoundException("Resource does not exist: " + uri);
            }
        } else {
            // Let the ContentResolver handle content and file URIs.
            InputStream stream = mProviderContext.getContentResolver().openInputStream(uri);
            if (stream == null) {
                throw new FileNotFoundException("Failed to open " + uri);
            }
            try {
                return Drawable.createFromStream(stream, null);
            } finally {
                try {
                    stream.close();
                } catch (IOException ex) {
                    Log.e(LOG_TAG, "Error closing icon stream for " + uri, ex);
                }
            }
        }
    } catch (FileNotFoundException fnfe) {
        Log.w(LOG_TAG, "Icon not found: " + uri + ", " + fnfe.getMessage());
        return null;
    }
}
Body of Second Method:
{
    try {
        String scheme = uri.getScheme();
        if (ContentResolver.SCHEME_ANDROID_RESOURCE.equals(scheme)) {
            // Load drawables through Resources, to get the source density information
            OpenResourceIdResult r = mProviderContext.getContentResolver().getResourceId(uri);
            try {
                return r.r.getDrawable(r.id, mProviderContext.getTheme());
            } catch (Resources.NotFoundException ex) {
                throw new FileNotFoundException("Resource does not exist: " + uri);
            }
        } else {
            // Let the ContentResolver handle content and file URIs.
            InputStream stream = mProviderContext.getContentResolver().openInputStream(uri);
            if (stream == null) {
                throw new FileNotFoundException("Failed to open " + uri);
            }
            try {
                return Drawable.createFromStream(stream, null);
            } finally {
                try {
                    stream.close();
                } catch (IOException ex) {
                    Log.e(LOG_TAG, "Error closing icon stream for " + uri, ex);
                }
            }
        }
    } catch (FileNotFoundException fnfe) {
        Log.w(LOG_TAG, "Icon not found: " + uri + ", " + fnfe.getMessage());
        return null;
    }
}
------------------------
Find a silently evolved API code:android.preference.Preference.setIcon:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the icon for this Preference with a resource ID.
 *
 * @see #setIcon(Drawable)
 * @param iconResId The icon as a resource ID.
 */

Body of Frist Method:
{
    mIconResId = iconResId;
    setIcon(mContext.getDrawable(iconResId));
}
Body of Second Method:
{
    if (mIconResId != iconResId) {
        mIconResId = iconResId;
        setIcon(mContext.getDrawable(iconResId));
    }
}
------------------------
Find a silently evolved API code:android.animation.KeyframeSet.getValue:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the animated value, given the elapsed fraction of the animation (interpolated by the
 * animation's interpolator) and the evaluator used to calculate in-between values. This
 * function maps the input fraction to the appropriate keyframe interval and a fraction
 * between them and returns the interpolated value. Note that the input fraction may fall
 * outside the [0-1] bounds, if the animation's interpolator made that happen (e.g., a
 * spring interpolation that might send the fraction past 1.0). We handle this situation by
 * just using the two keyframes at the appropriate end when the value is outside those bounds.
 *
 * @param fraction The elapsed fraction of the animation
 * @return The animated value.
 */

Body of Frist Method:
{
    // Special-case optimization for the common case of only two keyframes
    if (mNumKeyframes == 2) {
        if (mInterpolator != null) {
            fraction = mInterpolator.getInterpolation(fraction);
        }
        return mEvaluator.evaluate(fraction, mFirstKeyframe.getValue(), mLastKeyframe.getValue());
    }
    if (fraction <= 0f) {
        final Keyframe nextKeyframe = mKeyframes.get(1);
        final TimeInterpolator interpolator = nextKeyframe.getInterpolator();
        if (interpolator != null) {
            fraction = interpolator.getInterpolation(fraction);
        }
        final float prevFraction = mFirstKeyframe.getFraction();
        float intervalFraction = (fraction - prevFraction) / (nextKeyframe.getFraction() - prevFraction);
        return mEvaluator.evaluate(intervalFraction, mFirstKeyframe.getValue(), nextKeyframe.getValue());
    } else if (fraction >= 1f) {
        final Keyframe prevKeyframe = mKeyframes.get(mNumKeyframes - 2);
        final TimeInterpolator interpolator = mLastKeyframe.getInterpolator();
        if (interpolator != null) {
            fraction = interpolator.getInterpolation(fraction);
        }
        final float prevFraction = prevKeyframe.getFraction();
        float intervalFraction = (fraction - prevFraction) / (mLastKeyframe.getFraction() - prevFraction);
        return mEvaluator.evaluate(intervalFraction, prevKeyframe.getValue(), mLastKeyframe.getValue());
    }
    Keyframe prevKeyframe = mFirstKeyframe;
    for (int i = 1; i < mNumKeyframes; ++i) {
        Keyframe nextKeyframe = mKeyframes.get(i);
        if (fraction < nextKeyframe.getFraction()) {
            final TimeInterpolator interpolator = nextKeyframe.getInterpolator();
            if (interpolator != null) {
                fraction = interpolator.getInterpolation(fraction);
            }
            final float prevFraction = prevKeyframe.getFraction();
            float intervalFraction = (fraction - prevFraction) / (nextKeyframe.getFraction() - prevFraction);
            return mEvaluator.evaluate(intervalFraction, prevKeyframe.getValue(), nextKeyframe.getValue());
        }
        prevKeyframe = nextKeyframe;
    }
    // shouldn't reach here
    return mLastKeyframe.getValue();
}
Body of Second Method:
{
    // Special-case optimization for the common case of only two keyframes
    if (mNumKeyframes == 2) {
        if (mInterpolator != null) {
            fraction = mInterpolator.getInterpolation(fraction);
        }
        return mEvaluator.evaluate(fraction, mFirstKeyframe.getValue(), mLastKeyframe.getValue());
    }
    if (fraction <= 0f) {
        final Keyframe nextKeyframe = mKeyframes.get(1);
        final TimeInterpolator interpolator = nextKeyframe.getInterpolator();
        if (interpolator != null) {
            fraction = interpolator.getInterpolation(fraction);
        }
        final float prevFraction = mFirstKeyframe.getFraction();
        float intervalFraction = (fraction - prevFraction) / (nextKeyframe.getFraction() - prevFraction);
        return mEvaluator.evaluate(intervalFraction, mFirstKeyframe.getValue(), nextKeyframe.getValue());
    } else if (fraction >= 1f) {
        final Keyframe prevKeyframe = mKeyframes.get(mNumKeyframes - 2);
        final TimeInterpolator interpolator = mLastKeyframe.getInterpolator();
        if (interpolator != null) {
            fraction = interpolator.getInterpolation(fraction);
        }
        final float prevFraction = prevKeyframe.getFraction();
        float intervalFraction = (fraction - prevFraction) / (mLastKeyframe.getFraction() - prevFraction);
        return mEvaluator.evaluate(intervalFraction, prevKeyframe.getValue(), mLastKeyframe.getValue());
    }
    Keyframe prevKeyframe = mFirstKeyframe;
    for (int i = 1; i < mNumKeyframes; ++i) {
        Keyframe nextKeyframe = mKeyframes.get(i);
        if (fraction < nextKeyframe.getFraction()) {
            final TimeInterpolator interpolator = nextKeyframe.getInterpolator();
            final float prevFraction = prevKeyframe.getFraction();
            float intervalFraction = (fraction - prevFraction) / (nextKeyframe.getFraction() - prevFraction);
            // Apply interpolator on the proportional duration.
            if (interpolator != null) {
                intervalFraction = interpolator.getInterpolation(intervalFraction);
            }
            return mEvaluator.evaluate(intervalFraction, prevKeyframe.getValue(), nextKeyframe.getValue());
        }
        prevKeyframe = nextKeyframe;
    }
    // shouldn't reach here
    return mLastKeyframe.getValue();
}
------------------------
Find a silently evolved API code:android.hardware.GeomagneticField.getHorizontalStrength:COMMENT
Method Modifier: public      
Comment:/**
 * @return  Horizontal component of the field strength in nonoteslas.
 */

Body of Frist Method:
{
    return (float) Math.sqrt(mX * mX + mY * mY);
}
Body of Second Method:
{
    return (float) Math.hypot(mX, mY);
}
------------------------
Find a silently evolved API code:android.graphics.Bitmap.copyPixelsToBuffer:COMMENT
Method Modifier: public      
Comment:/**
 * <p>Copy the bitmap's pixels into the specified buffer (allocated by the
 * caller). An exception is thrown if the buffer is not large enough to
 * hold all of the pixels (taking into account the number of bytes per
 * pixel) or if the Buffer subclass is not one of the support types
 * (ByteBuffer, ShortBuffer, IntBuffer).</p>
 * <p>The content of the bitmap is copied into the buffer as-is. This means
 * that if this bitmap stores its pixels pre-multiplied
 * (see {@link #isPremultiplied()}, the values in the buffer will also be
 * pre-multiplied.</p>
 * <p>After this method returns, the current position of the buffer is
 * updated: the position is incremented by the number of elements written
 * in the buffer.</p>
 */

Body of Frist Method:
{
    int elements = dst.remaining();
    int shift;
    if (dst instanceof ByteBuffer) {
        shift = 0;
    } else if (dst instanceof ShortBuffer) {
        shift = 1;
    } else if (dst instanceof IntBuffer) {
        shift = 2;
    } else {
        throw new RuntimeException("unsupported Buffer subclass");
    }
    long bufferSize = (long) elements << shift;
    long pixelSize = getByteCount();
    if (bufferSize < pixelSize) {
        throw new RuntimeException("Buffer not large enough for pixels");
    }
    nativeCopyPixelsToBuffer(mNativeBitmap, dst);
    // now update the buffer's position
    int position = dst.position();
    position += pixelSize >> shift;
    dst.position(position);
}
Body of Second Method:
{
    int elements = dst.remaining();
    int shift;
    if (dst instanceof ByteBuffer) {
        shift = 0;
    } else if (dst instanceof ShortBuffer) {
        shift = 1;
    } else if (dst instanceof IntBuffer) {
        shift = 2;
    } else {
        throw new RuntimeException("unsupported Buffer subclass");
    }
    long bufferSize = (long) elements << shift;
    long pixelSize = getByteCount();
    if (bufferSize < pixelSize) {
        throw new RuntimeException("Buffer not large enough for pixels");
    }
    nativeCopyPixelsToBuffer(mFinalizer.mNativeBitmap, dst);
    // now update the buffer's position
    int position = dst.position();
    position += pixelSize >> shift;
    dst.position(position);
}
------------------------
Find a silently evolved API code:android.webkit.WebView.setNetworkAvailable:COMMENT
Method Modifier: public      
Comment:/**
 * Informs WebView of the network state. This is used to set
 * the JavaScript property window.navigator.isOnline and
 * generates the online/offline event as specified in HTML5, sec. 5.7.7
 *
 * @param networkUp a boolean indicating if network is available
 */

Body of Frist Method:
{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, "setNetworkAvailable=" + networkUp);
    mProvider.setNetworkAvailable(networkUp);
}
Body of Second Method:
{
    checkThread();
    mProvider.setNetworkAvailable(networkUp);
}
------------------------
Find a silently evolved API code:android.media.session.MediaSessionManager.removeOnActiveSessionsChangedListener:COMMENT
Method Modifier: public      
Comment:/**
 * Stop receiving active sessions updates on the specified listener.
 *
 * @param listener The listener to remove.
 */

Body of Frist Method:
{
    if (listener == null) {
        throw new IllegalArgumentException("listener may not be null");
    }
    synchronized (mLock) {
        SessionsChangedWrapper wrapper = mListeners.remove(listener);
        if (wrapper != null) {
            try {
                mService.removeSessionsListener(wrapper.mStub);
            } catch (RemoteException e) {
                Log.e(TAG, "Error in removeOnActiveSessionsChangedListener.", e);
            }
        }
    }
}
Body of Second Method:
{
    if (listener == null) {
        throw new IllegalArgumentException("listener may not be null");
    }
    synchronized (mLock) {
        SessionsChangedWrapper wrapper = mListeners.remove(listener);
        if (wrapper != null) {
            try {
                mService.removeSessionsListener(wrapper.mStub);
            } catch (RemoteException e) {
                Log.e(TAG, "Error in removeOnActiveSessionsChangedListener.", e);
            } finally {
                wrapper.release();
            }
        }
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiActivityEnergyInfo.getControllerRxTimeMillis:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @return rx time in ms
 */

Body of Frist Method:
{
    return (int) mControllerRxTimeMs;
}
Body of Second Method:
{
    return mControllerRxTimeMs;
}
------------------------
Find a silently evolved API code:javax.obex.ServerSession.run:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Processes requests made to the server and forwards them to the
 * appropriate event listener.
 */

Body of Frist Method:
{
    try {
        boolean done = false;
        while (!done && !mClosed) {
            int requestType = mInput.read();
            switch(requestType) {
                case ObexHelper.OBEX_OPCODE_CONNECT:
                    handleConnectRequest();
                    break;
                case ObexHelper.OBEX_OPCODE_DISCONNECT:
                    handleDisconnectRequest();
                    done = true;
                    break;
                case ObexHelper.OBEX_OPCODE_GET:
                case ObexHelper.OBEX_OPCODE_GET_FINAL:
                    handleGetRequest(requestType);
                    break;
                case ObexHelper.OBEX_OPCODE_PUT:
                case ObexHelper.OBEX_OPCODE_PUT_FINAL:
                    handlePutRequest(requestType);
                    break;
                case ObexHelper.OBEX_OPCODE_SETPATH:
                    handleSetPathRequest();
                    break;
                case ObexHelper.OBEX_OPCODE_ABORT:
                    handleAbortRequest();
                    break;
                case -1:
                    done = true;
                    break;
                default:
                    /*
                         * Received a request type that is not recognized so I am
                         * just going to read the packet and send a not implemented
                         * to the client
                         */
                    int length = mInput.read();
                    length = (length << 8) + mInput.read();
                    for (int i = 3; i < length; i++) {
                        mInput.read();
                    }
                    sendResponse(ResponseCodes.OBEX_HTTP_NOT_IMPLEMENTED, null);
            }
        }
    } catch (NullPointerException e) {
        Log.d(TAG, e.toString());
    } catch (Exception e) {
        Log.d(TAG, e.toString());
    }
    close();
}
Body of Second Method:
{
    try {
        boolean done = false;
        while (!done && !mClosed) {
            if (V)
                Log.v(TAG, "Waiting for incoming request...");
            int requestType = mInput.read();
            if (V)
                Log.v(TAG, "Read request: " + requestType);
            switch(requestType) {
                case ObexHelper.OBEX_OPCODE_CONNECT:
                    handleConnectRequest();
                    break;
                case ObexHelper.OBEX_OPCODE_DISCONNECT:
                    handleDisconnectRequest();
                    done = true;
                    break;
                case ObexHelper.OBEX_OPCODE_GET:
                case ObexHelper.OBEX_OPCODE_GET_FINAL:
                    handleGetRequest(requestType);
                    break;
                case ObexHelper.OBEX_OPCODE_PUT:
                case ObexHelper.OBEX_OPCODE_PUT_FINAL:
                    handlePutRequest(requestType);
                    break;
                case ObexHelper.OBEX_OPCODE_SETPATH:
                    handleSetPathRequest();
                    break;
                case ObexHelper.OBEX_OPCODE_ABORT:
                    handleAbortRequest();
                    break;
                case -1:
                    done = true;
                    break;
                default:
                    /*
                         * Received a request type that is not recognized so I am
                         * just going to read the packet and send a not implemented
                         * to the client
                         */
                    int length = mInput.read();
                    length = (length << 8) + mInput.read();
                    for (int i = 3; i < length; i++) {
                        mInput.read();
                    }
                    sendResponse(ResponseCodes.OBEX_HTTP_NOT_IMPLEMENTED, null);
            }
        }
    } catch (NullPointerException e) {
        Log.d(TAG, "Exception occured - ignoring", e);
    } catch (Exception e) {
        Log.d(TAG, "Exception occured - ignoring", e);
    }
    close();
}
------------------------
Find a silently evolved API code:android.media.ImageReader.acquireNextImageNoThrowISE:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Don't throw IllegalStateException if there are too many images acquired.
 *
 * @return Image if acquiring succeeded, or null otherwise.
 *
 * @hide
 */

Body of Frist Method:
{
    SurfaceImage si = new SurfaceImage();
    return acquireNextSurfaceImage(si) == ACQUIRE_SUCCESS ? si : null;
}
Body of Second Method:
{
    SurfaceImage si = new SurfaceImage(mFormat);
    return acquireNextSurfaceImage(si) == ACQUIRE_SUCCESS ? si : null;
}
------------------------
Find a silently evolved API code:android.animation.ValueAnimator.setCurrentFraction:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the position of the animation to the specified fraction. This fraction should
 * be between 0 and the total fraction of the animation, including any repetition. That is,
 * a fraction of 0 will position the animation at the beginning, a value of 1 at the end,
 * and a value of 2 at the end of a reversing animator that repeats once. If
 * the animation has not yet been started, then it will not advance forward after it is
 * set to this fraction; it will simply set the fraction to this value and perform any
 * appropriate actions based on that fraction. If the animation is already running, then
 * setCurrentFraction() will set the current fraction to this value and continue
 * playing from that point. {@link Animator.AnimatorListener} events are not called
 * due to changing the fraction; those events are only processed while the animation
 * is running.
 *
 * @param fraction The fraction to which the animation is advanced or rewound. Values
 * outside the range of 0 to the maximum fraction for the animator will be clamped to
 * the correct range.
 */

Body of Frist Method:
{
    initAnimation();
    if (fraction < 0) {
        fraction = 0;
    }
    int iteration = (int) fraction;
    if (fraction == 1) {
        iteration -= 1;
    } else if (fraction > 1) {
        if (iteration < (mRepeatCount + 1) || mRepeatCount == INFINITE) {
            if (mRepeatMode == REVERSE) {
                mPlayingBackwards = (iteration % 2) != 0;
            }
            fraction = fraction % 1f;
        } else {
            fraction = 1;
            iteration -= 1;
        }
    } else {
        mPlayingBackwards = mReversing;
    }
    mCurrentIteration = iteration;
    long seekTime = (long) (mDuration * fraction);
    long currentTime = AnimationUtils.currentAnimationTimeMillis();
    mStartTime = currentTime - seekTime;
    if (mPlayingState != RUNNING) {
        mSeekFraction = fraction;
        mPlayingState = SEEKED;
    }
    if (mPlayingBackwards) {
        fraction = 1f - fraction;
    }
    animateValue(fraction);
}
Body of Second Method:
{
    initAnimation();
    if (fraction < 0) {
        fraction = 0;
    }
    int iteration = (int) fraction;
    if (fraction == 1) {
        iteration -= 1;
    } else if (fraction > 1) {
        if (iteration < (mRepeatCount + 1) || mRepeatCount == INFINITE) {
            if (mRepeatMode == REVERSE) {
                mPlayingBackwards = (iteration % 2) != 0;
            }
            fraction = fraction % 1f;
        } else {
            fraction = 1;
            iteration -= 1;
        }
    } else {
        mPlayingBackwards = mReversing;
    }
    mCurrentIteration = iteration;
    long seekTime = (long) (mDuration * fraction);
    long currentTime = AnimationUtils.currentAnimationTimeMillis();
    mStartTime = currentTime - seekTime;
    // do not allow start time to be compensated for jank
    mStartTimeCommitted = true;
    if (mPlayingState != RUNNING) {
        mSeekFraction = fraction;
        mPlayingState = SEEKED;
    }
    if (mPlayingBackwards) {
        fraction = 1f - fraction;
    }
    animateValue(fraction);
}
------------------------
Find a silently evolved API code:android.media.AudioTrack.postEventFromNative:COMMENT
Method Modifier: private     static      
Comment:// --------------------

Body of Frist Method:
{
    // logd("Event posted from the native side: event="+ what + " args="+ arg1+" "+arg2);
    AudioTrack track = (AudioTrack) ((WeakReference) audiotrack_ref).get();
    if (track == null) {
        return;
    }
    NativeEventHandlerDelegate delegate = track.mEventHandlerDelegate;
    if (delegate != null) {
        Handler handler = delegate.getHandler();
        if (handler != null) {
            Message m = handler.obtainMessage(what, arg1, arg2, obj);
            handler.sendMessage(m);
        }
    }
}
Body of Second Method:
{
    // logd("Event posted from the native side: event="+ what + " args="+ arg1+" "+arg2);
    AudioTrack track = (AudioTrack) ((WeakReference) audiotrack_ref).get();
    if (track == null) {
        return;
    }
    if (what == AudioSystem.NATIVE_EVENT_ROUTING_CHANGE) {
        track.broadcastRoutingChange();
        return;
    }
    NativePositionEventHandlerDelegate delegate = track.mEventHandlerDelegate;
    if (delegate != null) {
        Handler handler = delegate.getHandler();
        if (handler != null) {
            Message m = handler.obtainMessage(what, arg1, arg2, obj);
            handler.sendMessage(m);
        }
    }
}
------------------------
Find a silently evolved API code:android.os.Bundle.hasFileDescriptors:COMMENT
Method Modifier: public      
Comment:/**
 * Reports whether the bundle contains any parcelled file descriptors.
 */

Body of Frist Method:
{
    if (!mFdsKnown) {
        // keep going until we find one or run out of data
        boolean fdFound = false;
        if (mParcelledData != null) {
            if (mParcelledData.hasFileDescriptors()) {
                fdFound = true;
            }
        } else {
            // It's been unparcelled, so we need to walk the map
            for (int i = mMap.size() - 1; i >= 0; i--) {
                Object obj = mMap.valueAt(i);
                if (obj instanceof Parcelable) {
                    if ((((Parcelable) obj).describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0) {
                        fdFound = true;
                        break;
                    }
                } else if (obj instanceof Parcelable[]) {
                    Parcelable[] array = (Parcelable[]) obj;
                    for (int n = array.length - 1; n >= 0; n--) {
                        if ((array[n].describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0) {
                            fdFound = true;
                            break;
                        }
                    }
                } else if (obj instanceof SparseArray) {
                    SparseArray<? extends Parcelable> array = (SparseArray<? extends Parcelable>) obj;
                    for (int n = array.size() - 1; n >= 0; n--) {
                        if ((array.valueAt(n).describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0) {
                            fdFound = true;
                            break;
                        }
                    }
                } else if (obj instanceof ArrayList) {
                    ArrayList array = (ArrayList) obj;
                    // Parcelables; only look inside for Parcelables
                    if (!array.isEmpty() && (array.get(0) instanceof Parcelable)) {
                        for (int n = array.size() - 1; n >= 0; n--) {
                            Parcelable p = (Parcelable) array.get(n);
                            if (p != null && ((p.describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0)) {
                                fdFound = true;
                                break;
                            }
                        }
                    }
                }
            }
        }
        mHasFds = fdFound;
        mFdsKnown = true;
    }
    return mHasFds;
}
Body of Second Method:
{
    if (!mFdsKnown) {
        // keep going until we find one or run out of data
        boolean fdFound = false;
        if (mParcelledData != null) {
            if (mParcelledData.hasFileDescriptors()) {
                fdFound = true;
            }
        } else {
            // It's been unparcelled, so we need to walk the map
            for (int i = mMap.size() - 1; i >= 0; i--) {
                Object obj = mMap.valueAt(i);
                if (obj instanceof Parcelable) {
                    if ((((Parcelable) obj).describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0) {
                        fdFound = true;
                        break;
                    }
                } else if (obj instanceof Parcelable[]) {
                    Parcelable[] array = (Parcelable[]) obj;
                    for (int n = array.length - 1; n >= 0; n--) {
                        Parcelable p = array[n];
                        if (p != null && ((p.describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0)) {
                            fdFound = true;
                            break;
                        }
                    }
                } else if (obj instanceof SparseArray) {
                    SparseArray<? extends Parcelable> array = (SparseArray<? extends Parcelable>) obj;
                    for (int n = array.size() - 1; n >= 0; n--) {
                        Parcelable p = array.valueAt(n);
                        if (p != null && (p.describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0) {
                            fdFound = true;
                            break;
                        }
                    }
                } else if (obj instanceof ArrayList) {
                    ArrayList array = (ArrayList) obj;
                    // Parcelables; only look inside for Parcelables
                    if (!array.isEmpty() && (array.get(0) instanceof Parcelable)) {
                        for (int n = array.size() - 1; n >= 0; n--) {
                            Parcelable p = (Parcelable) array.get(n);
                            if (p != null && ((p.describeContents() & Parcelable.CONTENTS_FILE_DESCRIPTOR) != 0)) {
                                fdFound = true;
                                break;
                            }
                        }
                    }
                }
            }
        }
        mHasFds = fdFound;
        mFdsKnown = true;
    }
    return mHasFds;
}
------------------------
Find a silently evolved API code:android.view.inputmethod.InputMethodManager.getShortcutInputMethodsAndSubtypes:COMMENT
Method Modifier: public      
Comment:/**
 * Returns a map of all shortcut input method info and their subtypes.
 */

Body of Frist Method:
{
    synchronized (mH) {
        HashMap<InputMethodInfo, List<InputMethodSubtype>> ret = new HashMap<InputMethodInfo, List<InputMethodSubtype>>();
        try {
            // TODO: We should change the return type from List<Object> to List<Parcelable>
            List<Object> info = mService.getShortcutInputMethodsAndSubtypes();
            // "info" has imi1, subtype1, subtype2, imi2, subtype2, imi3, subtype3..in the list
            ArrayList<InputMethodSubtype> subtypes = null;
            final int N = info.size();
            if (info != null && N > 0) {
                for (int i = 0; i < N; ++i) {
                    Object o = info.get(i);
                    if (o instanceof InputMethodInfo) {
                        if (ret.containsKey(o)) {
                            Log.e(TAG, "IMI list already contains the same InputMethod.");
                            break;
                        }
                        subtypes = new ArrayList<InputMethodSubtype>();
                        ret.put((InputMethodInfo) o, subtypes);
                    } else if (subtypes != null && o instanceof InputMethodSubtype) {
                        subtypes.add((InputMethodSubtype) o);
                    }
                }
            }
        } catch (RemoteException e) {
            Log.w(TAG, "IME died: " + mCurId, e);
        }
        return ret;
    }
}
Body of Second Method:
{
    synchronized (mH) {
        HashMap<InputMethodInfo, List<InputMethodSubtype>> ret = new HashMap<InputMethodInfo, List<InputMethodSubtype>>();
        try {
            // TODO: We should change the return type from List<Object> to List<Parcelable>
            List<Object> info = mService.getShortcutInputMethodsAndSubtypes();
            // "info" has imi1, subtype1, subtype2, imi2, subtype2, imi3, subtype3..in the list
            ArrayList<InputMethodSubtype> subtypes = null;
            if (info != null && !info.isEmpty()) {
                final int N = info.size();
                for (int i = 0; i < N; ++i) {
                    Object o = info.get(i);
                    if (o instanceof InputMethodInfo) {
                        if (ret.containsKey(o)) {
                            Log.e(TAG, "IMI list already contains the same InputMethod.");
                            break;
                        }
                        subtypes = new ArrayList<InputMethodSubtype>();
                        ret.put((InputMethodInfo) o, subtypes);
                    } else if (subtypes != null && o instanceof InputMethodSubtype) {
                        subtypes.add((InputMethodSubtype) o);
                    }
                }
            }
        } catch (RemoteException e) {
            Log.w(TAG, "IME died: " + mCurId, e);
        }
        return ret;
    }
}
------------------------
Find a silently evolved API code:android.os.UserManager.getUserIcon:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns a file descriptor for the user's photo. PNG data can be read from this file.
 * @param userHandle the user whose photo we want to read.
 * @return a {@link Bitmap} of the user's photo, or null if there's no photo.
 * @see com.android.internal.util.UserIcons#getDefaultUserIcon for a default.
 * @hide
 */

Body of Frist Method:
{
    try {
        return mService.getUserIcon(userHandle);
    } catch (RemoteException re) {
        Log.w(TAG, "Could not get the user icon ", re);
        return null;
    }
}
Body of Second Method:
{
    try {
        ParcelFileDescriptor fd = mService.getUserIcon(userHandle);
        if (fd != null) {
            try {
                return BitmapFactory.decodeFileDescriptor(fd.getFileDescriptor());
            } finally {
                try {
                    fd.close();
                } catch (IOException e) {
                }
            }
        }
    } catch (RemoteException re) {
        Log.w(TAG, "Could not get the user icon ", re);
    }
    return null;
}
------------------------
Find a silently evolved API code:android.gesture.GestureUtils.temporalSampling:COMMENT
Method Modifier: public      static      
Comment:/**
 * Samples a stroke temporally into a given number of evenly-distributed
 * points.
 *
 * @param stroke the gesture stroke to be sampled
 * @param numPoints the number of points
 * @return the sampled points in the form of [x1, y1, x2, y2, ..., xn, yn]
 */

Body of Frist Method:
{
    final float increment = stroke.length / (numPoints - 1);
    int vectorLength = numPoints * 2;
    float[] vector = new float[vectorLength];
    float distanceSoFar = 0;
    float[] pts = stroke.points;
    float lstPointX = pts[0];
    float lstPointY = pts[1];
    int index = 0;
    float currentPointX = Float.MIN_VALUE;
    float currentPointY = Float.MIN_VALUE;
    vector[index] = lstPointX;
    index++;
    vector[index] = lstPointY;
    index++;
    int i = 0;
    int count = pts.length / 2;
    while (i < count) {
        if (currentPointX == Float.MIN_VALUE) {
            i++;
            if (i >= count) {
                break;
            }
            currentPointX = pts[i * 2];
            currentPointY = pts[i * 2 + 1];
        }
        float deltaX = currentPointX - lstPointX;
        float deltaY = currentPointY - lstPointY;
        float distance = (float) Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        if (distanceSoFar + distance >= increment) {
            float ratio = (increment - distanceSoFar) / distance;
            float nx = lstPointX + ratio * deltaX;
            float ny = lstPointY + ratio * deltaY;
            vector[index] = nx;
            index++;
            vector[index] = ny;
            index++;
            lstPointX = nx;
            lstPointY = ny;
            distanceSoFar = 0;
        } else {
            lstPointX = currentPointX;
            lstPointY = currentPointY;
            currentPointX = Float.MIN_VALUE;
            currentPointY = Float.MIN_VALUE;
            distanceSoFar += distance;
        }
    }
    for (i = index; i < vectorLength; i += 2) {
        vector[i] = lstPointX;
        vector[i + 1] = lstPointY;
    }
    return vector;
}
Body of Second Method:
{
    final float increment = stroke.length / (numPoints - 1);
    int vectorLength = numPoints * 2;
    float[] vector = new float[vectorLength];
    float distanceSoFar = 0;
    float[] pts = stroke.points;
    float lstPointX = pts[0];
    float lstPointY = pts[1];
    int index = 0;
    float currentPointX = Float.MIN_VALUE;
    float currentPointY = Float.MIN_VALUE;
    vector[index] = lstPointX;
    index++;
    vector[index] = lstPointY;
    index++;
    int i = 0;
    int count = pts.length / 2;
    while (i < count) {
        if (currentPointX == Float.MIN_VALUE) {
            i++;
            if (i >= count) {
                break;
            }
            currentPointX = pts[i * 2];
            currentPointY = pts[i * 2 + 1];
        }
        float deltaX = currentPointX - lstPointX;
        float deltaY = currentPointY - lstPointY;
        float distance = (float) Math.hypot(deltaX, deltaY);
        if (distanceSoFar + distance >= increment) {
            float ratio = (increment - distanceSoFar) / distance;
            float nx = lstPointX + ratio * deltaX;
            float ny = lstPointY + ratio * deltaY;
            vector[index] = nx;
            index++;
            vector[index] = ny;
            index++;
            lstPointX = nx;
            lstPointY = ny;
            distanceSoFar = 0;
        } else {
            lstPointX = currentPointX;
            lstPointY = currentPointY;
            currentPointX = Float.MIN_VALUE;
            currentPointY = Float.MIN_VALUE;
            distanceSoFar += distance;
        }
    }
    for (i = index; i < vectorLength; i += 2) {
        vector[i] = lstPointX;
        vector[i + 1] = lstPointY;
    }
    return vector;
}
------------------------
Find a silently evolved API code:android.telephony.SubscriptionManager.removeOnSubscriptionsChangedListener:COMMENT
Method Modifier: public      
Comment:/**
 * Unregister the {@link OnSubscriptionsChangedListener}. This is not strictly necessary
 * as the listener will automatically be unregistered if an attempt to invoke the listener
 * fails.
 *
 * @param listener that is to be unregistered.
 */

Body of Frist Method:
{
    String pkgForDebug = mContext != null ? mContext.getPackageName() : "<unknown>";
    if (DBG) {
        logd("unregister OnSubscriptionsChangedListener pkgForDebug=" + pkgForDebug + " listener=" + listener);
    }
    try {
        // We use the TelephonyRegistry as its runs in the system and thus is always
        // available where as SubscriptionController could crash and not be available
        ITelephonyRegistry tr = ITelephonyRegistry.Stub.asInterface(ServiceManager.getService("telephony.registry"));
        if (tr != null) {
            tr.removeOnSubscriptionsChangedListener(pkgForDebug, listener.callback);
        }
    } catch (RemoteException ex) {
    // Should not happen
    }
}
Body of Second Method:
{
    String pkgForDebug = mContext != null ? mContext.getOpPackageName() : "<unknown>";
    if (DBG) {
        logd("unregister OnSubscriptionsChangedListener pkgForDebug=" + pkgForDebug + " listener=" + listener);
    }
    try {
        // We use the TelephonyRegistry as its runs in the system and thus is always
        // available where as SubscriptionController could crash and not be available
        ITelephonyRegistry tr = ITelephonyRegistry.Stub.asInterface(ServiceManager.getService("telephony.registry"));
        if (tr != null) {
            tr.removeOnSubscriptionsChangedListener(pkgForDebug, listener.callback);
        }
    } catch (RemoteException ex) {
    // Should not happen
    }
}
------------------------
Find a silently evolved API code:android.graphics.drawable.LayerDrawable.getOutline:COMMENT
Method Modifier: public      
Comment:/**
 * Populates <code>outline</code> with the first available (non-empty) layer outline.
 *
 * @param outline Outline in which to place the first available layer outline
 */

Body of Frist Method:
{
    final LayerState state = mLayerState;
    final ChildDrawable[] children = state.mChildren;
    final int N = state.mNum;
    for (int i = 0; i < N; i++) {
        children[i].mDrawable.getOutline(outline);
        if (!outline.isEmpty()) {
            return;
        }
    }
}
Body of Second Method:
{
    final ChildDrawable[] array = mLayerState.mChildren;
    final int N = mLayerState.mNum;
    for (int i = 0; i < N; i++) {
        final Drawable dr = array[i].mDrawable;
        if (dr != null) {
            dr.getOutline(outline);
            if (!outline.isEmpty()) {
                return;
            }
        }
    }
}
------------------------
Find a silently evolved API code:android.animation.AnimatorInflater.loadAnimator:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    final ConfigurationBoundResourceCache<Animator> animatorCache = resources.getAnimatorCache();
    Animator animator = animatorCache.get(id, theme);
    if (animator != null) {
        if (DBG_ANIMATOR_INFLATER) {
            Log.d(TAG, "loaded animator from cache, " + resources.getResourceName(id));
        }
        return animator;
    } else if (DBG_ANIMATOR_INFLATER) {
        Log.d(TAG, "cache miss for animator " + resources.getResourceName(id));
    }
    XmlResourceParser parser = null;
    try {
        parser = resources.getAnimation(id);
        animator = createAnimatorFromXml(resources, theme, parser, pathErrorScale);
        if (animator != null) {
            animator.appendChangingConfigurations(getChangingConfigs(resources, id));
            final ConstantState<Animator> constantState = animator.createConstantState();
            if (constantState != null) {
                if (DBG_ANIMATOR_INFLATER) {
                    Log.d(TAG, "caching animator for res " + resources.getResourceName(id));
                }
                animatorCache.put(id, theme, constantState);
                // create a new animator so that cached version is never used by the user
                animator = constantState.newInstance(resources, theme);
            }
        }
        return animator;
    } catch (XmlPullParserException ex) {
        Resources.NotFoundException rnf = new Resources.NotFoundException("Can't load animation resource ID #0x" + Integer.toHexString(id));
        rnf.initCause(ex);
        throw rnf;
    } catch (IOException ex) {
        Resources.NotFoundException rnf = new Resources.NotFoundException("Can't load animation resource ID #0x" + Integer.toHexString(id));
        rnf.initCause(ex);
        throw rnf;
    } finally {
        if (parser != null)
            parser.close();
    }
}
Body of Second Method:
{
    final ConfigurationBoundResourceCache<Animator> animatorCache = resources.getAnimatorCache();
    Animator animator = animatorCache.getInstance(id, theme);
    if (animator != null) {
        if (DBG_ANIMATOR_INFLATER) {
            Log.d(TAG, "loaded animator from cache, " + resources.getResourceName(id));
        }
        return animator;
    } else if (DBG_ANIMATOR_INFLATER) {
        Log.d(TAG, "cache miss for animator " + resources.getResourceName(id));
    }
    XmlResourceParser parser = null;
    try {
        parser = resources.getAnimation(id);
        animator = createAnimatorFromXml(resources, theme, parser, pathErrorScale);
        if (animator != null) {
            animator.appendChangingConfigurations(getChangingConfigs(resources, id));
            final ConstantState<Animator> constantState = animator.createConstantState();
            if (constantState != null) {
                if (DBG_ANIMATOR_INFLATER) {
                    Log.d(TAG, "caching animator for res " + resources.getResourceName(id));
                }
                animatorCache.put(id, theme, constantState);
                // create a new animator so that cached version is never used by the user
                animator = constantState.newInstance(resources, theme);
            }
        }
        return animator;
    } catch (XmlPullParserException ex) {
        Resources.NotFoundException rnf = new Resources.NotFoundException("Can't load animation resource ID #0x" + Integer.toHexString(id));
        rnf.initCause(ex);
        throw rnf;
    } catch (IOException ex) {
        Resources.NotFoundException rnf = new Resources.NotFoundException("Can't load animation resource ID #0x" + Integer.toHexString(id));
        rnf.initCause(ex);
        throw rnf;
    } finally {
        if (parser != null)
            parser.close();
    }
}
------------------------
Find a silently evolved API code:android.os.StrictMode.onFileUriExposed:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    final String message = "file:// Uri exposed through " + location;
    onVmPolicyViolation(message, new Throwable(message));
}
Body of Second Method:
{
    final String message = "file:// Uri exposed through " + location;
    onVmPolicyViolation(null, new Throwable(message));
}
------------------------
Find a silently evolved API code:android.media.SoundPool.stop:COMMENT
<android.media.SoundPool: void stop(int)>
public      final       ->public      final       native      
Method Modifier: public      final       native      
Method Modifier: Yes         Yes         No          
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * Stop a playback stream.
 *
 * Stop the stream specified by the streamID. This
 * is the value returned by the play() function. If the stream
 * is playing, it will be stopped. It also releases any native
 * resources associated with this stream. If the stream is not
 * playing, it will have no effect.
 *
 * @param streamID a streamID returned by the play() function
 */

Body of Frist Method:
{
    mImpl.stop(streamID);
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.provider.DocumentsProvider.call:COMMENT
Method Modifier: public      
Comment:/**
 * Implementation is provided by the parent class. Can be overridden to
 * provide additional functionality, but subclasses <em>must</em> always
 * call the superclass. If the superclass returns {@code null}, the subclass
 * may implement custom behavior.
 */

Body of Frist Method:
{
    if (!method.startsWith("android:")) {
        // Ignore non-platform methods
        return super.call(method, arg, extras);
    }
    final Context context = getContext();
    final Uri documentUri = extras.getParcelable(DocumentsContract.EXTRA_URI);
    final String authority = documentUri.getAuthority();
    final String documentId = DocumentsContract.getDocumentId(documentUri);
    if (!mAuthority.equals(authority)) {
        throw new SecurityException("Requested authority " + authority + " doesn't match provider " + mAuthority);
    }
    enforceTree(documentUri);
    final Bundle out = new Bundle();
    try {
        if (METHOD_CREATE_DOCUMENT.equals(method)) {
            enforceWritePermissionInner(documentUri, null);
            final String mimeType = extras.getString(Document.COLUMN_MIME_TYPE);
            final String displayName = extras.getString(Document.COLUMN_DISPLAY_NAME);
            final String newDocumentId = createDocument(documentId, mimeType, displayName);
            // No need to issue new grants here, since caller either has
            // manage permission or a prefix grant. We might generate a
            // tree style URI if that's how they called us.
            final Uri newDocumentUri = buildDocumentUriMaybeUsingTree(documentUri, newDocumentId);
            out.putParcelable(DocumentsContract.EXTRA_URI, newDocumentUri);
        } else if (METHOD_RENAME_DOCUMENT.equals(method)) {
            enforceWritePermissionInner(documentUri, null);
            final String displayName = extras.getString(Document.COLUMN_DISPLAY_NAME);
            final String newDocumentId = renameDocument(documentId, displayName);
            if (newDocumentId != null) {
                final Uri newDocumentUri = buildDocumentUriMaybeUsingTree(documentUri, newDocumentId);
                // narrow grant for the newly renamed document.
                if (!isTreeUri(newDocumentUri)) {
                    final int modeFlags = getCallingOrSelfUriPermissionModeFlags(context, documentUri);
                    context.grantUriPermission(getCallingPackage(), newDocumentUri, modeFlags);
                }
                out.putParcelable(DocumentsContract.EXTRA_URI, newDocumentUri);
                // Original document no longer exists, clean up any grants
                revokeDocumentPermission(documentId);
            }
        } else if (METHOD_DELETE_DOCUMENT.equals(method)) {
            enforceWritePermissionInner(documentUri, null);
            deleteDocument(documentId);
            // Document no longer exists, clean up any grants
            revokeDocumentPermission(documentId);
        } else {
            throw new UnsupportedOperationException("Method not supported " + method);
        }
    } catch (FileNotFoundException e) {
        throw new IllegalStateException("Failed call " + method, e);
    }
    return out;
}
Body of Second Method:
{
    if (!method.startsWith("android:")) {
        // Ignore non-platform methods
        return super.call(method, arg, extras);
    }
    final Context context = getContext();
    final Uri documentUri = extras.getParcelable(DocumentsContract.EXTRA_URI);
    final String authority = documentUri.getAuthority();
    final String documentId = DocumentsContract.getDocumentId(documentUri);
    if (!mAuthority.equals(authority)) {
        throw new SecurityException("Requested authority " + authority + " doesn't match provider " + mAuthority);
    }
    enforceTree(documentUri);
    final Bundle out = new Bundle();
    try {
        if (METHOD_CREATE_DOCUMENT.equals(method)) {
            enforceWritePermissionInner(documentUri, getCallingPackage(), null);
            final String mimeType = extras.getString(Document.COLUMN_MIME_TYPE);
            final String displayName = extras.getString(Document.COLUMN_DISPLAY_NAME);
            final String newDocumentId = createDocument(documentId, mimeType, displayName);
            // No need to issue new grants here, since caller either has
            // manage permission or a prefix grant. We might generate a
            // tree style URI if that's how they called us.
            final Uri newDocumentUri = buildDocumentUriMaybeUsingTree(documentUri, newDocumentId);
            out.putParcelable(DocumentsContract.EXTRA_URI, newDocumentUri);
        } else if (METHOD_RENAME_DOCUMENT.equals(method)) {
            enforceWritePermissionInner(documentUri, getCallingPackage(), null);
            final String displayName = extras.getString(Document.COLUMN_DISPLAY_NAME);
            final String newDocumentId = renameDocument(documentId, displayName);
            if (newDocumentId != null) {
                final Uri newDocumentUri = buildDocumentUriMaybeUsingTree(documentUri, newDocumentId);
                // narrow grant for the newly renamed document.
                if (!isTreeUri(newDocumentUri)) {
                    final int modeFlags = getCallingOrSelfUriPermissionModeFlags(context, documentUri);
                    context.grantUriPermission(getCallingPackage(), newDocumentUri, modeFlags);
                }
                out.putParcelable(DocumentsContract.EXTRA_URI, newDocumentUri);
                // Original document no longer exists, clean up any grants
                revokeDocumentPermission(documentId);
            }
        } else if (METHOD_DELETE_DOCUMENT.equals(method)) {
            enforceWritePermissionInner(documentUri, getCallingPackage(), null);
            deleteDocument(documentId);
            // Document no longer exists, clean up any grants
            revokeDocumentPermission(documentId);
        } else {
            throw new UnsupportedOperationException("Method not supported " + method);
        }
    } catch (FileNotFoundException e) {
        throw new IllegalStateException("Failed call " + method, e);
    }
    return out;
}
------------------------
Find a silently evolved API code:android.media.audiofx.AcousticEchoCanceler.create:COMMENT
Method Modifier: public      static      
Comment:/**
 * Creates an AcousticEchoCanceler and attaches it to the AudioRecord on the audio
 * session specified.
 * @param audioSession system wide unique audio session identifier. The AcousticEchoCanceler
 * will be applied to the AudioRecord with the same audio session.
 * @return AcousticEchoCanceler created or null if the device does not implement AEC.
 */

Body of Frist Method:
{
    AcousticEchoCanceler aec = null;
    try {
        aec = new AcousticEchoCanceler(audioSession);
    } catch (IllegalArgumentException e) {
        Log.w(TAG, "not implemented on this device" + aec);
    } catch (UnsupportedOperationException e) {
        Log.w(TAG, "not enough resources");
    } catch (RuntimeException e) {
        Log.w(TAG, "not enough memory");
    } finally {
        return aec;
    }
}
Body of Second Method:
{
    AcousticEchoCanceler aec = null;
    try {
        aec = new AcousticEchoCanceler(audioSession);
    } catch (IllegalArgumentException e) {
        Log.w(TAG, "not implemented on this device" + aec);
    } catch (UnsupportedOperationException e) {
        Log.w(TAG, "not enough resources");
    } catch (RuntimeException e) {
        Log.w(TAG, "not enough memory");
    }
    return aec;
}
------------------------
Find a silently evolved API code:android.media.SoundPool.setOnLoadCompleteListener:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the callback hook for the OnLoadCompleteListener.
 */

Body of Frist Method:
{
    mImpl.setOnLoadCompleteListener(listener);
}
Body of Second Method:
{
    synchronized (mLock) {
        if (listener != null) {
            // setup message handler
            Looper looper;
            if ((looper = Looper.myLooper()) != null) {
                mEventHandler = new EventHandler(looper);
            } else if ((looper = Looper.getMainLooper()) != null) {
                mEventHandler = new EventHandler(looper);
            } else {
                mEventHandler = null;
            }
        } else {
            mEventHandler = null;
        }
        mOnLoadCompleteListener = listener;
    }
}
------------------------
Find a silently evolved API code:android.location.GpsMeasurement.setAccumulatedDeltaRangeState:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets the 'Accumulated Delta Range' state.
 */

Body of Frist Method:
{
    switch(value) {
        case ADR_STATE_UNKNOWN:
        case ADR_STATE_VALID:
        case ADR_STATE_RESET:
        case ADR_STATE_CYCLE_SLIP:
            mAccumulatedDeltaRangeState = value;
            break;
        default:
            Log.d(TAG, "Sanitizing invalid 'Accumulated Delta Range state': " + value);
            mAccumulatedDeltaRangeState = ADR_STATE_UNKNOWN;
            break;
    }
}
Body of Second Method:
{
    mAccumulatedDeltaRangeState = value;
}
------------------------
Find a silently evolved API code:android.widget.TextView.setAccessibilitySelection:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (getAccessibilitySelectionStart() == start && getAccessibilitySelectionEnd() == end) {
        return;
    }
    // controllers interact with how selection behaves.
    if (mEditor != null) {
        mEditor.hideControllers();
    }
    CharSequence text = getIterableTextForAccessibility();
    if (Math.min(start, end) >= 0 && Math.max(start, end) <= text.length()) {
        Selection.setSelection((Spannable) text, start, end);
    } else {
        Selection.removeSelection((Spannable) text);
    }
}
Body of Second Method:
{
    if (getAccessibilitySelectionStart() == start && getAccessibilitySelectionEnd() == end) {
        return;
    }
    // controllers interact with how selection behaves.
    if (mEditor != null) {
        mEditor.hideCursorAndSpanControllers();
        mEditor.stopTextActionMode();
    }
    CharSequence text = getIterableTextForAccessibility();
    if (Math.min(start, end) >= 0 && Math.max(start, end) <= text.length()) {
        Selection.setSelection((Spannable) text, start, end);
    } else {
        Selection.removeSelection((Spannable) text);
    }
}
------------------------
Find a silently evolved API code:android.hardware.camera2.params.StreamConfigurationMap.getFormatsMap:COMMENT
Method Modifier: private     
Comment:/**
 * Get the format -> size count map for either output or input formats
 */

Body of Frist Method:
{
    return output ? mOutputFormats : mInputFormats;
}
Body of Second Method:
{
    return output ? mAllOutputFormats : mInputFormats;
}
------------------------
Find a silently evolved API code:android.webkit.WebViewDelegate.getErrorString:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns the error string for the given {@code errorCode}.
 */

Body of Frist Method:
{
    return ErrorStrings.getString(errorCode, context);
}
Body of Second Method:
{
    return LegacyErrorStrings.getString(errorCode, context);
}
------------------------
Find a silently evolved API code:android.app.BackStackRecord.calculateBackFragments:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Finds the first removed fragment and last added fragments when popping the back stack.
 * If none of the fragments have transitions, then both lists will be empty.
 *
 * @param firstOutFragments The list of first fragments to be removed, keyed on the
 * container ID. This list will be modified by the method.
 * @param lastInFragments The list of last fragments to be added, keyed on the
 * container ID. This list will be modified by the method.
 */

Body of Frist Method:
{
    if (!mManager.mContainer.hasView()) {
        // nothing to see, so no transitions
        return;
    }
    Op op = mHead;
    while (op != null) {
        switch(op.cmd) {
            case OP_ADD:
                setFirstOut(firstOutFragments, op.fragment);
                break;
            case OP_REPLACE:
                if (op.removed != null) {
                    for (int i = op.removed.size() - 1; i >= 0; i--) {
                        setLastIn(lastInFragments, op.removed.get(i));
                    }
                }
                setFirstOut(firstOutFragments, op.fragment);
                break;
            case OP_REMOVE:
                setLastIn(lastInFragments, op.fragment);
                break;
            case OP_HIDE:
                setLastIn(lastInFragments, op.fragment);
                break;
            case OP_SHOW:
                setFirstOut(firstOutFragments, op.fragment);
                break;
            case OP_DETACH:
                setLastIn(lastInFragments, op.fragment);
                break;
            case OP_ATTACH:
                setFirstOut(firstOutFragments, op.fragment);
                break;
        }
        op = op.next;
    }
}
Body of Second Method:
{
    if (!mManager.mContainer.onHasView()) {
        // nothing to see, so no transitions
        return;
    }
    Op op = mHead;
    while (op != null) {
        switch(op.cmd) {
            case OP_ADD:
                setFirstOut(firstOutFragments, op.fragment);
                break;
            case OP_REPLACE:
                if (op.removed != null) {
                    for (int i = op.removed.size() - 1; i >= 0; i--) {
                        setLastIn(lastInFragments, op.removed.get(i));
                    }
                }
                setFirstOut(firstOutFragments, op.fragment);
                break;
            case OP_REMOVE:
                setLastIn(lastInFragments, op.fragment);
                break;
            case OP_HIDE:
                setLastIn(lastInFragments, op.fragment);
                break;
            case OP_SHOW:
                setFirstOut(firstOutFragments, op.fragment);
                break;
            case OP_DETACH:
                setLastIn(lastInFragments, op.fragment);
                break;
            case OP_ATTACH:
                setFirstOut(firstOutFragments, op.fragment);
                break;
        }
        op = op.next;
    }
}
------------------------
Find a silently evolved API code:android.os.FileUtils.buildValidFatFilename:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Mutate the given filename to make it valid for a FAT filesystem,
 * replacing any invalid characters with "_".
 */

Body of Frist Method:
{
    if (TextUtils.isEmpty(name) || ".".equals(name) || "..".equals(name)) {
        return "(invalid)";
    }
    final StringBuilder res = new StringBuilder(name.length());
    for (int i = 0; i < name.length(); i++) {
        final char c = name.charAt(i);
        if (isValidFatFilenameChar(c)) {
            res.append(c);
        } else {
            res.append('_');
        }
    }
    return res.toString();
}
Body of Second Method:
{
    if (TextUtils.isEmpty(name) || ".".equals(name) || "..".equals(name)) {
        return "(invalid)";
    }
    final StringBuilder res = new StringBuilder(name.length());
    for (int i = 0; i < name.length(); i++) {
        final char c = name.charAt(i);
        if (isValidFatFilenameChar(c)) {
            res.append(c);
        } else {
            res.append('_');
        }
    }
    // Even though vfat allows 255 UCS-2 chars, we might eventually write to
    // ext4 through a FUSE layer, so use that limit.
    trimFilename(res, 255);
    return res.toString();
}
------------------------
Find a silently evolved API code:android.hardware.camera2.legacy.LegacyFocusStateMapper.mapResultTriggers:COMMENT
Method Modifier: public      
Comment:/**
 * Update the {@code result} camera metadata map with the new value for the
 * {@code control.afState}.
 *
 * <p>AF callbacks are processed in the background, and each call to {@link #mapResultTriggers}
 * will have the latest AF state as reflected by the camera1 callbacks.</p>
 *
 * @param result a non-{@code null} result
 */

Body of Frist Method:
{
    checkNotNull(result, "result must not be null");
    int newAfState;
    synchronized (mLock) {
        newAfState = mAfState;
    }
    if (VERBOSE && newAfState != mAfStatePrevious) {
        Log.v(TAG, String.format("mapResultTriggers - afState changed from %s to %s", afStateToString(mAfStatePrevious), afStateToString(newAfState)));
    }
    result.set(CaptureResult.CONTROL_AF_STATE, newAfState);
    mAfStatePrevious = newAfState;
}
Body of Second Method:
{
    checkNotNull(result, "result must not be null");
    int newAfState;
    synchronized (mLock) {
        newAfState = mAfState;
    }
    if (DEBUG && newAfState != mAfStatePrevious) {
        Log.v(TAG, String.format("mapResultTriggers - afState changed from %s to %s", afStateToString(mAfStatePrevious), afStateToString(newAfState)));
    }
    result.set(CaptureResult.CONTROL_AF_STATE, newAfState);
    mAfStatePrevious = newAfState;
}
------------------------
Find a silently evolved API code:android.graphics.Bitmap.prepareToDraw:COMMENT
Method Modifier: public      
Comment:/**
 * Rebuilds any caches associated with the bitmap that are used for
 * drawing it. In the case of purgeable bitmaps, this call will attempt to
 * ensure that the pixels have been decoded.
 * If this is called on more than one bitmap in sequence, the priority is
 * given in LRU order (i.e. the last bitmap called will be given highest
 * priority).
 *
 * For bitmaps with no associated caches, this call is effectively a no-op,
 * and therefore is harmless.
 */

Body of Frist Method:
{
    nativePrepareToDraw(mNativeBitmap);
}
Body of Second Method:
{
    // TODO: Consider having this start an async upload?
    // With inPurgeable no-op'd there's currently no use for this
    // method, but it could have interesting future uses.
    checkRecycled("Can't prepareToDraw on a recycled bitmap!");
}
------------------------
Find a silently evolved API code:android.app.Activity.recreate:COMMENT
Method Modifier: public      
Comment:/**
 * Cause this Activity to be recreated with a new instance.  This results
 * in essentially the same flow as when the Activity is created due to
 * a configuration change -- the current instance will go through its
 * lifecycle to {@link #onDestroy} and a new instance then created after it.
 */

Body of Frist Method:
{
    if (mParent != null) {
        throw new IllegalStateException("Can only be called on top-level activity");
    }
    if (Looper.myLooper() != mMainThread.getLooper()) {
        throw new IllegalStateException("Must be called from main thread");
    }
    mMainThread.requestRelaunchActivity(mToken, null, null, 0, false, null, false);
}
Body of Second Method:
{
    if (mParent != null) {
        throw new IllegalStateException("Can only be called on top-level activity");
    }
    if (Looper.myLooper() != mMainThread.getLooper()) {
        throw new IllegalStateException("Must be called from main thread");
    }
    mMainThread.requestRelaunchActivity(mToken, null, null, 0, false, null, null, false);
}
------------------------
Find a silently evolved API code:android.net.http.HttpResponseCache.getInstalled:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns the currently-installed {@code HttpResponseCache}, or null if
 * there is no cache installed or it is not a {@code HttpResponseCache}.
 */

Body of Frist Method:
{
    ResponseCache installed = ResponseCache.getDefault();
    if (installed instanceof com.android.okhttp.HttpResponseCache) {
        return new HttpResponseCache((com.android.okhttp.HttpResponseCache) installed);
    }
    return null;
}
Body of Second Method:
{
    ResponseCache installed = ResponseCache.getDefault();
    if (installed instanceof HttpResponseCache) {
        return (HttpResponseCache) installed;
    }
    return null;
}
------------------------
Find a silently evolved API code:android.widget.TextView.onPreDraw:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (mLayout == null) {
        assumeLayout();
    }
    if (mMovement != null) {
        /* This code also provides auto-scrolling when a cursor is moved using a
             * CursorController (insertion point or selection limits).
             * For selection, ensure start or end is visible depending on controller's state.
             */
        int curs = getSelectionEnd();
        // Do not create the controller if it is not already created.
        if (mEditor != null && mEditor.mSelectionModifierCursorController != null && mEditor.mSelectionModifierCursorController.isSelectionStartDragged()) {
            curs = getSelectionStart();
        }
        /*
             * TODO: This should really only keep the end in view if
             * it already was before the text changed.  I'm not sure
             * of a good way to tell from here if it was.
             */
        if (curs < 0 && (mGravity & Gravity.VERTICAL_GRAVITY_MASK) == Gravity.BOTTOM) {
            curs = mText.length();
        }
        if (curs >= 0) {
            bringPointIntoView(curs);
        }
    } else {
        bringTextIntoView();
    }
    // a screen rotation) since layout is not yet initialized at that point.
    if (mEditor != null && mEditor.mCreatedWithASelection) {
        mEditor.startSelectionActionMode();
        mEditor.mCreatedWithASelection = false;
    }
    // not be set. Do the test here instead.
    if (this instanceof ExtractEditText && hasSelection() && mEditor != null) {
        mEditor.startSelectionActionMode();
    }
    unregisterForPreDraw();
    return true;
}
Body of Second Method:
{
    if (mLayout == null) {
        assumeLayout();
    }
    if (mMovement != null) {
        /* This code also provides auto-scrolling when a cursor is moved using a
             * CursorController (insertion point or selection limits).
             * For selection, ensure start or end is visible depending on controller's state.
             */
        int curs = getSelectionEnd();
        // Do not create the controller if it is not already created.
        if (mEditor != null && mEditor.mSelectionModifierCursorController != null && mEditor.mSelectionModifierCursorController.isSelectionStartDragged()) {
            curs = getSelectionStart();
        }
        /*
             * TODO: This should really only keep the end in view if
             * it already was before the text changed.  I'm not sure
             * of a good way to tell from here if it was.
             */
        if (curs < 0 && (mGravity & Gravity.VERTICAL_GRAVITY_MASK) == Gravity.BOTTOM) {
            curs = mText.length();
        }
        if (curs >= 0) {
            bringPointIntoView(curs);
        }
    } else {
        bringTextIntoView();
    }
    // a screen rotation) since layout is not yet initialized at that point.
    if (mEditor != null && mEditor.mCreatedWithASelection) {
        if (mEditor.extractedTextModeWillBeStarted()) {
            mEditor.checkFieldAndSelectCurrentWord();
        } else {
            mEditor.startSelectionActionMode();
        }
        mEditor.mCreatedWithASelection = false;
    }
    // not be set. Do the test here instead.
    if (isInExtractedMode() && hasSelection() && mEditor != null && mEditor.mTextActionMode == null && isShown() && hasWindowFocus()) {
        mEditor.startSelectionActionMode();
    }
    unregisterForPreDraw();
    return true;
}
------------------------
Find a silently evolved API code:android.widget.ArrayAdapter.getView:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    return createViewFromResource(position, convertView, parent, mResource);
}
Body of Second Method:
{
    return createViewFromResource(mInflater, position, convertView, parent, mResource);
}
------------------------
Find a silently evolved API code:android.app.ActivityTransitionCoordinator.setSharedElements:COMMENT
Method Modifier: private     
Comment:/**
 * Iterates over the shared elements and adds them to the members in order.
 * Shared elements that are nested in other shared elements are placed after the
 * elements that they are nested in. This means that layout ordering can be done
 * from first to last.
 *
 * @param sharedElements The map of transition names to shared elements to set into
 * the member fields.
 */

Body of Frist Method:
{
    boolean isFirstRun = true;
    while (!sharedElements.isEmpty()) {
        final int numSharedElements = sharedElements.size();
        for (int i = numSharedElements - 1; i >= 0; i--) {
            final View view = sharedElements.valueAt(i);
            final String name = sharedElements.keyAt(i);
            if (isFirstRun && (view == null || !view.isAttachedToWindow() || name == null)) {
                sharedElements.removeAt(i);
            } else {
                if (!isNested(view, sharedElements)) {
                    mSharedElementNames.add(name);
                    mSharedElements.add(view);
                    sharedElements.removeAt(i);
                    if (isFirstRun) {
                        // We need to keep track which shared elements are roots
                        // and which are nested.
                        mRootSharedElements.add(view);
                    }
                }
            }
        }
        isFirstRun = false;
    }
}
Body of Second Method:
{
    boolean isFirstRun = true;
    while (!sharedElements.isEmpty()) {
        final int numSharedElements = sharedElements.size();
        for (int i = numSharedElements - 1; i >= 0; i--) {
            final View view = sharedElements.valueAt(i);
            final String name = sharedElements.keyAt(i);
            if (isFirstRun && (view == null || !view.isAttachedToWindow() || name == null)) {
                sharedElements.removeAt(i);
            } else if (!isNested(view, sharedElements)) {
                mSharedElementNames.add(name);
                mSharedElements.add(view);
                sharedElements.removeAt(i);
            }
        }
        isFirstRun = false;
    }
}
------------------------
Find a silently evolved API code:android.graphics.Bitmap.eraseColor:COMMENT
Method Modifier: public      
Comment:/**
 * Fills the bitmap's pixels with the specified {@link Color}.
 *
 * @throws IllegalStateException if the bitmap is not mutable.
 */

Body of Frist Method:
{
    checkRecycled("Can't erase a recycled bitmap");
    if (!isMutable()) {
        throw new IllegalStateException("cannot erase immutable bitmaps");
    }
    nativeErase(mNativeBitmap, c);
}
Body of Second Method:
{
    checkRecycled("Can't erase a recycled bitmap");
    if (!isMutable()) {
        throw new IllegalStateException("cannot erase immutable bitmaps");
    }
    nativeErase(mFinalizer.mNativeBitmap, c);
}
------------------------
Find a silently evolved API code:android.widget.ListPopupWindow.show:COMMENT
Method Modifier: public      
Comment:/**
 * Show the popup list. If the list is already showing, this method
 * will recalculate the popup's size and position.
 */

Body of Frist Method:
{
    int height = buildDropDown();
    int widthSpec = 0;
    int heightSpec = 0;
    boolean noInputMethod = isInputMethodNotNeeded();
    mPopup.setAllowScrollingAnchorParent(!noInputMethod);
    if (mPopup.isShowing()) {
        if (mDropDownWidth == ViewGroup.LayoutParams.MATCH_PARENT) {
            // The call to PopupWindow's update method below can accept -1 for any
            // value you do not want to update.
            widthSpec = -1;
        } else if (mDropDownWidth == ViewGroup.LayoutParams.WRAP_CONTENT) {
            widthSpec = getAnchorView().getWidth();
        } else {
            widthSpec = mDropDownWidth;
        }
        if (mDropDownHeight == ViewGroup.LayoutParams.MATCH_PARENT) {
            // The call to PopupWindow's update method below can accept -1 for any
            // value you do not want to update.
            heightSpec = noInputMethod ? height : ViewGroup.LayoutParams.MATCH_PARENT;
            if (noInputMethod) {
                mPopup.setWindowLayoutMode(mDropDownWidth == ViewGroup.LayoutParams.MATCH_PARENT ? ViewGroup.LayoutParams.MATCH_PARENT : 0, 0);
            } else {
                mPopup.setWindowLayoutMode(mDropDownWidth == ViewGroup.LayoutParams.MATCH_PARENT ? ViewGroup.LayoutParams.MATCH_PARENT : 0, ViewGroup.LayoutParams.MATCH_PARENT);
            }
        } else if (mDropDownHeight == ViewGroup.LayoutParams.WRAP_CONTENT) {
            heightSpec = height;
        } else {
            heightSpec = mDropDownHeight;
        }
        mPopup.setOutsideTouchable(!mForceIgnoreOutsideTouch && !mDropDownAlwaysVisible);
        mPopup.update(getAnchorView(), mDropDownHorizontalOffset, mDropDownVerticalOffset, widthSpec, heightSpec);
    } else {
        if (mDropDownWidth == ViewGroup.LayoutParams.MATCH_PARENT) {
            widthSpec = ViewGroup.LayoutParams.MATCH_PARENT;
        } else {
            if (mDropDownWidth == ViewGroup.LayoutParams.WRAP_CONTENT) {
                mPopup.setWidth(getAnchorView().getWidth());
            } else {
                mPopup.setWidth(mDropDownWidth);
            }
        }
        if (mDropDownHeight == ViewGroup.LayoutParams.MATCH_PARENT) {
            heightSpec = ViewGroup.LayoutParams.MATCH_PARENT;
        } else {
            if (mDropDownHeight == ViewGroup.LayoutParams.WRAP_CONTENT) {
                mPopup.setHeight(height);
            } else {
                mPopup.setHeight(mDropDownHeight);
            }
        }
        mPopup.setWindowLayoutMode(widthSpec, heightSpec);
        mPopup.setClipToScreenEnabled(true);
        // use outside touchable to dismiss drop down when touching outside of it, so
        // only set this if the dropdown is not always visible
        mPopup.setOutsideTouchable(!mForceIgnoreOutsideTouch && !mDropDownAlwaysVisible);
        mPopup.setTouchInterceptor(mTouchInterceptor);
        mPopup.showAsDropDown(getAnchorView(), mDropDownHorizontalOffset, mDropDownVerticalOffset, mDropDownGravity);
        mDropDownList.setSelection(ListView.INVALID_POSITION);
        if (!mModal || mDropDownList.isInTouchMode()) {
            clearListSelection();
        }
        if (!mModal) {
            mHandler.post(mHideSelector);
        }
    }
}
Body of Second Method:
{
    int height = buildDropDown();
    final boolean noInputMethod = isInputMethodNotNeeded();
    mPopup.setAllowScrollingAnchorParent(!noInputMethod);
    mPopup.setWindowLayoutType(mDropDownWindowLayoutType);
    if (mPopup.isShowing()) {
        final int widthSpec;
        if (mDropDownWidth == ViewGroup.LayoutParams.MATCH_PARENT) {
            // The call to PopupWindow's update method below can accept -1 for any
            // value you do not want to update.
            widthSpec = -1;
        } else if (mDropDownWidth == ViewGroup.LayoutParams.WRAP_CONTENT) {
            widthSpec = getAnchorView().getWidth();
        } else {
            widthSpec = mDropDownWidth;
        }
        final int heightSpec;
        if (mDropDownHeight == ViewGroup.LayoutParams.MATCH_PARENT) {
            // The call to PopupWindow's update method below can accept -1 for any
            // value you do not want to update.
            heightSpec = noInputMethod ? height : ViewGroup.LayoutParams.MATCH_PARENT;
            if (noInputMethod) {
                mPopup.setWidth(mDropDownWidth == ViewGroup.LayoutParams.MATCH_PARENT ? ViewGroup.LayoutParams.MATCH_PARENT : 0);
                mPopup.setHeight(0);
            } else {
                mPopup.setWidth(mDropDownWidth == ViewGroup.LayoutParams.MATCH_PARENT ? ViewGroup.LayoutParams.MATCH_PARENT : 0);
                mPopup.setHeight(ViewGroup.LayoutParams.MATCH_PARENT);
            }
        } else if (mDropDownHeight == ViewGroup.LayoutParams.WRAP_CONTENT) {
            heightSpec = height;
        } else {
            heightSpec = mDropDownHeight;
        }
        mPopup.setOutsideTouchable(!mForceIgnoreOutsideTouch && !mDropDownAlwaysVisible);
        mPopup.update(getAnchorView(), mDropDownHorizontalOffset, mDropDownVerticalOffset, (widthSpec < 0) ? -1 : widthSpec, (heightSpec < 0) ? -1 : heightSpec);
    } else {
        final int widthSpec;
        if (mDropDownWidth == ViewGroup.LayoutParams.MATCH_PARENT) {
            widthSpec = ViewGroup.LayoutParams.MATCH_PARENT;
        } else {
            if (mDropDownWidth == ViewGroup.LayoutParams.WRAP_CONTENT) {
                widthSpec = getAnchorView().getWidth();
            } else {
                widthSpec = mDropDownWidth;
            }
        }
        final int heightSpec;
        if (mDropDownHeight == ViewGroup.LayoutParams.MATCH_PARENT) {
            heightSpec = ViewGroup.LayoutParams.MATCH_PARENT;
        } else {
            if (mDropDownHeight == ViewGroup.LayoutParams.WRAP_CONTENT) {
                heightSpec = height;
            } else {
                heightSpec = mDropDownHeight;
            }
        }
        mPopup.setWidth(widthSpec);
        mPopup.setHeight(heightSpec);
        mPopup.setClipToScreenEnabled(true);
        // use outside touchable to dismiss drop down when touching outside of it, so
        // only set this if the dropdown is not always visible
        mPopup.setOutsideTouchable(!mForceIgnoreOutsideTouch && !mDropDownAlwaysVisible);
        mPopup.setTouchInterceptor(mTouchInterceptor);
        mPopup.showAsDropDown(getAnchorView(), mDropDownHorizontalOffset, mDropDownVerticalOffset, mDropDownGravity);
        mDropDownList.setSelection(ListView.INVALID_POSITION);
        if (!mModal || mDropDownList.isInTouchMode()) {
            clearListSelection();
        }
        if (!mModal) {
            mHandler.post(mHideSelector);
        }
    }
}
------------------------
Find a silently evolved API code:android.renderscript.Allocation.ioReceive:COMMENT
Method Modifier: public      
Comment:/**
 * Receive the latest input into the Allocation. This operation
 * is only valid if {@link #USAGE_IO_INPUT} is set on the Allocation.
 */

Body of Frist Method:
{
    Trace.traceBegin(RenderScript.TRACE_TAG, "ioReceive");
    if ((mUsage & USAGE_IO_INPUT) == 0) {
        throw new RSIllegalArgumentException("Can only receive if IO_INPUT usage specified.");
    }
    mRS.validate();
    mRS.nAllocationIoReceive(getID(mRS));
    Trace.traceEnd(RenderScript.TRACE_TAG);
}
Body of Second Method:
{
    try {
        Trace.traceBegin(RenderScript.TRACE_TAG, "ioReceive");
        if ((mUsage & USAGE_IO_INPUT) == 0) {
            throw new RSIllegalArgumentException("Can only receive if IO_INPUT usage specified.");
        }
        mRS.validate();
        mRS.nAllocationIoReceive(getID(mRS));
    } finally {
        Trace.traceEnd(RenderScript.TRACE_TAG);
    }
}
------------------------
Find a silently evolved API code:android.security.KeyChain.isKeyAlgorithmSupported:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns {@code true} if the current device's {@code KeyChain} supports a
 * specific {@code PrivateKey} type indicated by {@code algorithm} (e.g.,
 * "RSA").
 */

Body of Frist Method:
{
    final String algUpper = algorithm.toUpperCase(Locale.US);
    return "DSA".equals(algUpper) || "EC".equals(algUpper) || "RSA".equals(algUpper);
}
Body of Second Method:
{
    final String algUpper = algorithm.toUpperCase(Locale.US);
    return KeyProperties.KEY_ALGORITHM_EC.equals(algUpper) || KeyProperties.KEY_ALGORITHM_RSA.equals(algUpper);
}
------------------------
Find a silently evolved API code:android.graphics.Bitmap.compress:COMMENT
Method Modifier: public      
Comment:/**
 * Write a compressed version of the bitmap to the specified outputstream.
 * If this returns true, the bitmap can be reconstructed by passing a
 * corresponding inputstream to BitmapFactory.decodeStream(). Note: not
 * all Formats support all bitmap configs directly, so it is possible that
 * the returned bitmap from BitmapFactory could be in a different bitdepth,
 * and/or may have lost per-pixel alpha (e.g. JPEG only supports opaque
 * pixels).
 *
 * @param format   The format of the compressed image
 * @param quality  Hint to the compressor, 0-100. 0 meaning compress for
 * small size, 100 meaning compress for max quality. Some
 * formats, like PNG which is lossless, will ignore the
 * quality setting
 * @param stream   The outputstream to write the compressed data.
 * @return true if successfully compressed to the specified stream.
 */

Body of Frist Method:
{
    checkRecycled("Can't compress a recycled bitmap");
    // do explicit check before calling the native method
    if (stream == null) {
        throw new NullPointerException();
    }
    if (quality < 0 || quality > 100) {
        throw new IllegalArgumentException("quality must be 0..100");
    }
    Trace.traceBegin(Trace.TRACE_TAG_RESOURCES, "Bitmap.compress");
    boolean result = nativeCompress(mNativeBitmap, format.nativeInt, quality, stream, new byte[WORKING_COMPRESS_STORAGE]);
    Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
    return result;
}
Body of Second Method:
{
    checkRecycled("Can't compress a recycled bitmap");
    // do explicit check before calling the native method
    if (stream == null) {
        throw new NullPointerException();
    }
    if (quality < 0 || quality > 100) {
        throw new IllegalArgumentException("quality must be 0..100");
    }
    Trace.traceBegin(Trace.TRACE_TAG_RESOURCES, "Bitmap.compress");
    boolean result = nativeCompress(mFinalizer.mNativeBitmap, format.nativeInt, quality, stream, new byte[WORKING_COMPRESS_STORAGE]);
    Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
    return result;
}
------------------------
Find a silently evolved API code:android.widget.TextView.getUndoManager:COMMENT
Method Modifier: public      final       hidden      
Comment:/**
 * Retrieve the {@link android.content.UndoManager} that is currently associated
 * with this TextView.  By default there is no associated UndoManager, so null
 * is returned.  One can be associated with the TextView through
 * {@link #setUndoManager(android.content.UndoManager, String)}
 *
 * @hide
 */

Body of Frist Method:
{
    return mEditor == null ? null : mEditor.mUndoManager;
}
Body of Second Method:
{
    // TODO: Consider supporting a global undo manager.
    throw new UnsupportedOperationException("not implemented");
}
------------------------
Find a silently evolved API code:android.graphics.Canvas.restoreToCount:COMMENT
Method Modifier: public      
Comment:/**
 * Efficient way to pop any calls to save() that happened after the save
 * count reached saveCount. It is an error for saveCount to be less than 1.
 *
 * Example:
 * int count = canvas.save();
 * ... // more calls potentially to save()
 * canvas.restoreToCount(count);
 * // now the canvas is back in the same state it was before the initial
 * // call to save().
 *
 * @param saveCount The save level to restore to.
 */

Body of Frist Method:
{
    native_restoreToCount(mNativeCanvasWrapper, saveCount);
}
Body of Second Method:
{
    boolean throwOnUnderflow = !sCompatibilityRestore || !isHardwareAccelerated();
    native_restoreToCount(mNativeCanvasWrapper, saveCount, throwOnUnderflow);
}
------------------------
Find a silently evolved API code:android.media.AudioManager.querySoundEffectsEnabled:COMMENT
Method Modifier: private     
Comment:/**
 * Settings has an in memory cache, so this is fast.
 */

Body of Frist Method:
{
    return Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SOUND_EFFECTS_ENABLED, 0, user) != 0;
}
Body of Second Method:
{
    return Settings.System.getIntForUser(getContext().getContentResolver(), Settings.System.SOUND_EFFECTS_ENABLED, 0, user) != 0;
}
------------------------
Find a silently evolved API code:android.media.AudioManager.getProperty:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the value of the property with the specified key.
 * @param key One of the strings corresponding to a property key: either
 * {@link #PROPERTY_OUTPUT_SAMPLE_RATE} or
 * {@link #PROPERTY_OUTPUT_FRAMES_PER_BUFFER}
 * @return A string representing the associated value for that property key,
 * or null if there is no value for that key.
 */

Body of Frist Method:
{
    if (PROPERTY_OUTPUT_SAMPLE_RATE.equals(key)) {
        int outputSampleRate = AudioSystem.getPrimaryOutputSamplingRate();
        return outputSampleRate > 0 ? Integer.toString(outputSampleRate) : null;
    } else if (PROPERTY_OUTPUT_FRAMES_PER_BUFFER.equals(key)) {
        int outputFramesPerBuffer = AudioSystem.getPrimaryOutputFrameCount();
        return outputFramesPerBuffer > 0 ? Integer.toString(outputFramesPerBuffer) : null;
    } else {
        // null or unknown key
        return null;
    }
}
Body of Second Method:
{
    if (PROPERTY_OUTPUT_SAMPLE_RATE.equals(key)) {
        int outputSampleRate = AudioSystem.getPrimaryOutputSamplingRate();
        return outputSampleRate > 0 ? Integer.toString(outputSampleRate) : null;
    } else if (PROPERTY_OUTPUT_FRAMES_PER_BUFFER.equals(key)) {
        int outputFramesPerBuffer = AudioSystem.getPrimaryOutputFrameCount();
        return outputFramesPerBuffer > 0 ? Integer.toString(outputFramesPerBuffer) : null;
    } else if (PROPERTY_SUPPORT_MIC_NEAR_ULTRASOUND.equals(key)) {
        // not found.
        return String.valueOf(getContext().getResources().getBoolean(com.android.internal.R.bool.config_supportMicNearUltrasound));
    } else if (PROPERTY_SUPPORT_SPEAKER_NEAR_ULTRASOUND.equals(key)) {
        return String.valueOf(getContext().getResources().getBoolean(com.android.internal.R.bool.config_supportSpeakerNearUltrasound));
    } else {
        // null or unknown key
        return null;
    }
}
------------------------
Find a silently evolved API code:android.app.ActivityOptions.toBundle:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the created options as a Bundle, which can be passed to
 * {@link android.content.Context#startActivity(android.content.Intent, android.os.Bundle)
 * Context.startActivity(Intent, Bundle)} and related methods.
 * Note that the returned Bundle is still owned by the ActivityOptions
 * object; you must not modify it, but can supply it to the startActivity
 * methods that take an options Bundle.
 */

Body of Frist Method:
{
    if (mAnimationType == ANIM_DEFAULT) {
        return null;
    }
    Bundle b = new Bundle();
    if (mPackageName != null) {
        b.putString(KEY_PACKAGE_NAME, mPackageName);
    }
    b.putInt(KEY_ANIM_TYPE, mAnimationType);
    switch(mAnimationType) {
        case ANIM_CUSTOM:
            b.putInt(KEY_ANIM_ENTER_RES_ID, mCustomEnterResId);
            b.putInt(KEY_ANIM_EXIT_RES_ID, mCustomExitResId);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_CUSTOM_IN_PLACE:
            b.putInt(KEY_ANIM_IN_PLACE_RES_ID, mCustomInPlaceResId);
            break;
        case ANIM_SCALE_UP:
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            break;
        case ANIM_THUMBNAIL_SCALE_UP:
        case ANIM_THUMBNAIL_SCALE_DOWN:
        case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
        case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
            b.putParcelable(KEY_ANIM_THUMBNAIL, mThumbnail);
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_SCENE_TRANSITION:
            if (mTransitionReceiver != null) {
                b.putParcelable(KEY_TRANSITION_COMPLETE_LISTENER, mTransitionReceiver);
            }
            b.putBoolean(KEY_TRANSITION_IS_RETURNING, mIsReturning);
            b.putStringArrayList(KEY_TRANSITION_SHARED_ELEMENTS, mSharedElementNames);
            b.putParcelable(KEY_RESULT_DATA, mResultData);
            b.putInt(KEY_RESULT_CODE, mResultCode);
            b.putInt(KEY_EXIT_COORDINATOR_INDEX, mExitCoordinatorIndex);
            break;
    }
    return b;
}
Body of Second Method:
{
    if (mAnimationType == ANIM_DEFAULT) {
        return null;
    }
    Bundle b = new Bundle();
    if (mPackageName != null) {
        b.putString(KEY_PACKAGE_NAME, mPackageName);
    }
    b.putInt(KEY_ANIM_TYPE, mAnimationType);
    if (mUsageTimeReport != null) {
        b.putParcelable(KEY_USAGE_TIME_REPORT, mUsageTimeReport);
    }
    switch(mAnimationType) {
        case ANIM_CUSTOM:
            b.putInt(KEY_ANIM_ENTER_RES_ID, mCustomEnterResId);
            b.putInt(KEY_ANIM_EXIT_RES_ID, mCustomExitResId);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_CUSTOM_IN_PLACE:
            b.putInt(KEY_ANIM_IN_PLACE_RES_ID, mCustomInPlaceResId);
            break;
        case ANIM_SCALE_UP:
        case ANIM_CLIP_REVEAL:
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            break;
        case ANIM_THUMBNAIL_SCALE_UP:
        case ANIM_THUMBNAIL_SCALE_DOWN:
        case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
        case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
            b.putParcelable(KEY_ANIM_THUMBNAIL, mThumbnail);
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_SCENE_TRANSITION:
            if (mTransitionReceiver != null) {
                b.putParcelable(KEY_TRANSITION_COMPLETE_LISTENER, mTransitionReceiver);
            }
            b.putBoolean(KEY_TRANSITION_IS_RETURNING, mIsReturning);
            b.putStringArrayList(KEY_TRANSITION_SHARED_ELEMENTS, mSharedElementNames);
            b.putParcelable(KEY_RESULT_DATA, mResultData);
            b.putInt(KEY_RESULT_CODE, mResultCode);
            b.putInt(KEY_EXIT_COORDINATOR_INDEX, mExitCoordinatorIndex);
            break;
    }
    return b;
}
------------------------
Find a silently evolved API code:android.media.audiofx.Virtualizer.getAnglesInt:COMMENT
Method Modifier: private     
Comment:/**
 * Checks if a configuration is supported, and query the virtual speaker angles.
 * @param inputChannelMask
 * @param deviceType
 * @param angles if non-null: array in which the angles will be written. If null, no angles
 * are returned
 * @return true if the combination of channel mask and output device type is supported, false
 * otherwise
 * @throws IllegalStateException
 * @throws IllegalArgumentException
 * @throws UnsupportedOperationException
 */

Body of Frist Method:
{
    // parameter check
    if (inputChannelMask == AudioFormat.CHANNEL_INVALID) {
        throw (new IllegalArgumentException("Virtualizer: illegal CHANNEL_INVALID channel mask"));
    }
    int channelMask = inputChannelMask == AudioFormat.CHANNEL_OUT_DEFAULT ? AudioFormat.CHANNEL_OUT_STEREO : inputChannelMask;
    int nbChannels = AudioFormat.channelCountFromOutChannelMask(channelMask);
    if ((angles != null) && (angles.length < (nbChannels * 3))) {
        Log.e(TAG, "Size of array for angles cannot accomodate number of channels in mask (" + nbChannels + ")");
        throw (new IllegalArgumentException("Virtualizer: array for channel / angle pairs is too small: is " + angles.length + ", should be " + (nbChannels * 3)));
    }
    ByteBuffer paramsConverter = ByteBuffer.allocate(3 * /* param + mask + device*/
    4);
    paramsConverter.order(ByteOrder.nativeOrder());
    paramsConverter.putInt(PARAM_VIRTUAL_SPEAKER_ANGLES);
    // convert channel mask to internal native representation
    paramsConverter.putInt(AudioFormat.convertChannelOutMaskToNativeMask(channelMask));
    // convert Java device type to internal representation
    paramsConverter.putInt(AudioDevice.convertDeviceTypeToInternalDevice(deviceType));
    // allocate an array to store the results
    byte[] result = new byte[nbChannels * 4 * /*int to byte*/
    3];
    // call into the effect framework
    int status = getParameter(paramsConverter.array(), result);
    if (DEBUG) {
        Log.v(TAG, "getAngles(0x" + Integer.toHexString(inputChannelMask) + ", 0x" + Integer.toHexString(deviceType) + ") returns " + status);
    }
    if (status >= 0) {
        if (angles != null) {
            // convert and copy the results
            ByteBuffer resultConverter = ByteBuffer.wrap(result);
            resultConverter.order(ByteOrder.nativeOrder());
            for (int i = 0; i < nbChannels; i++) {
                // write the channel mask
                angles[3 * i] = AudioFormat.convertNativeChannelMaskToOutMask(resultConverter.getInt((i * 4 * 3)));
                // write the azimuth
                angles[3 * i + 1] = resultConverter.getInt(i * 4 * 3 + 4);
                // write the elevation
                angles[3 * i + 2] = resultConverter.getInt(i * 4 * 3 + 8);
                if (DEBUG) {
                    Log.v(TAG, "channel 0x" + Integer.toHexString(angles[3 * i]).toUpperCase() + " at az=" + angles[3 * i + 1] + "deg" + " elev=" + angles[3 * i + 2] + "deg");
                }
            }
        }
        return true;
    } else if (status == AudioEffect.ERROR_BAD_VALUE) {
        // don't throw an exception, just return false
        return false;
    } else {
        // something wrong may have happened
        checkStatus(status);
    }
    // unexpected virtualizer behavior
    Log.e(TAG, "unexpected status code " + status + " after getParameter(PARAM_VIRTUAL_SPEAKER_ANGLES)");
    return false;
}
Body of Second Method:
{
    // parameter check
    if (inputChannelMask == AudioFormat.CHANNEL_INVALID) {
        throw (new IllegalArgumentException("Virtualizer: illegal CHANNEL_INVALID channel mask"));
    }
    int channelMask = inputChannelMask == AudioFormat.CHANNEL_OUT_DEFAULT ? AudioFormat.CHANNEL_OUT_STEREO : inputChannelMask;
    int nbChannels = AudioFormat.channelCountFromOutChannelMask(channelMask);
    if ((angles != null) && (angles.length < (nbChannels * 3))) {
        Log.e(TAG, "Size of array for angles cannot accomodate number of channels in mask (" + nbChannels + ")");
        throw (new IllegalArgumentException("Virtualizer: array for channel / angle pairs is too small: is " + angles.length + ", should be " + (nbChannels * 3)));
    }
    ByteBuffer paramsConverter = ByteBuffer.allocate(3 * /* param + mask + device*/
    4);
    paramsConverter.order(ByteOrder.nativeOrder());
    paramsConverter.putInt(PARAM_VIRTUAL_SPEAKER_ANGLES);
    // convert channel mask to internal native representation
    paramsConverter.putInt(AudioFormat.convertChannelOutMaskToNativeMask(channelMask));
    // convert Java device type to internal representation
    paramsConverter.putInt(AudioDeviceInfo.convertDeviceTypeToInternalDevice(deviceType));
    // allocate an array to store the results
    byte[] result = new byte[nbChannels * 4 * /*int to byte*/
    3];
    // call into the effect framework
    int status = getParameter(paramsConverter.array(), result);
    if (DEBUG) {
        Log.v(TAG, "getAngles(0x" + Integer.toHexString(inputChannelMask) + ", 0x" + Integer.toHexString(deviceType) + ") returns " + status);
    }
    if (status >= 0) {
        if (angles != null) {
            // convert and copy the results
            ByteBuffer resultConverter = ByteBuffer.wrap(result);
            resultConverter.order(ByteOrder.nativeOrder());
            for (int i = 0; i < nbChannels; i++) {
                // write the channel mask
                angles[3 * i] = AudioFormat.convertNativeChannelMaskToOutMask(resultConverter.getInt((i * 4 * 3)));
                // write the azimuth
                angles[3 * i + 1] = resultConverter.getInt(i * 4 * 3 + 4);
                // write the elevation
                angles[3 * i + 2] = resultConverter.getInt(i * 4 * 3 + 8);
                if (DEBUG) {
                    Log.v(TAG, "channel 0x" + Integer.toHexString(angles[3 * i]).toUpperCase() + " at az=" + angles[3 * i + 1] + "deg" + " elev=" + angles[3 * i + 2] + "deg");
                }
            }
        }
        return true;
    } else if (status == AudioEffect.ERROR_BAD_VALUE) {
        // don't throw an exception, just return false
        return false;
    } else {
        // something wrong may have happened
        checkStatus(status);
    }
    // unexpected virtualizer behavior
    Log.e(TAG, "unexpected status code " + status + " after getParameter(PARAM_VIRTUAL_SPEAKER_ANGLES)");
    return false;
}
------------------------
Find a silently evolved API code:android.telephony.SubscriptionManager.getActiveSubscriptionInfoForIccIndex:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the active SubscriptionInfo associated with the iccId
 * @param iccId the IccId of SIM card
 * @return SubscriptionInfo, maybe null if its not active
 * @hide
 */

Body of Frist Method:
{
    if (VDBG)
        logd("[getActiveSubscriptionInfoForIccIndex]+ iccId=" + iccId);
    if (iccId == null) {
        logd("[getActiveSubscriptionInfoForIccIndex]- null iccid");
        return null;
    }
    SubscriptionInfo result = null;
    try {
        ISub iSub = ISub.Stub.asInterface(ServiceManager.getService("isub"));
        if (iSub != null) {
            result = iSub.getActiveSubscriptionInfoForIccId(iccId);
        }
    } catch (RemoteException ex) {
    // ignore it
    }
    return result;
}
Body of Second Method:
{
    if (VDBG)
        logd("[getActiveSubscriptionInfoForIccIndex]+ iccId=" + iccId);
    if (iccId == null) {
        logd("[getActiveSubscriptionInfoForIccIndex]- null iccid");
        return null;
    }
    SubscriptionInfo result = null;
    try {
        ISub iSub = ISub.Stub.asInterface(ServiceManager.getService("isub"));
        if (iSub != null) {
            result = iSub.getActiveSubscriptionInfoForIccId(iccId, mContext.getOpPackageName());
        }
    } catch (RemoteException ex) {
    // ignore it
    }
    return result;
}
------------------------
Find a silently evolved API code:android.content.ContentProviderClient.canonicalize:COMMENT
Method Modifier: public      final       
Comment:/**
 * See {@link ContentProvider#canonicalize}
 */

Body of Frist Method:
{
    beforeRemote();
    try {
        return mContentProvider.canonicalize(mPackageName, url);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}
Body of Second Method:
{
    Preconditions.checkNotNull(url, "url");
    beforeRemote();
    try {
        return mContentProvider.canonicalize(mPackageName, url);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}
------------------------
Find a silently evolved API code:android.media.SoundPool.setPriority:COMMENT
<android.media.SoundPool: void setPriority(int,int)>
public      final       ->public      final       native      
Method Modifier: public      final       native      
Method Modifier: Yes         Yes         No          
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * Change stream priority.
 *
 * Change the priority of the stream specified by the streamID.
 * This is the value returned by the play() function. Affects the
 * order in which streams are re-used to play new sounds. If the
 * stream does not exist, it will have no effect.
 *
 * @param streamID a streamID returned by the play() function
 */

Body of Frist Method:
{
    mImpl.setPriority(streamID, priority);
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.transition.TranslationAnimationCreator.createAnimation:COMMENT
Method Modifier: default     static      
Comment:/**
 * Creates an animator that can be used for x and/or y translations. When interrupted,
 * it sets a tag to keep track of the position so that it may be continued from position.
 *
 * @param view The view being moved. This may be in the overlay for onDisappear.
 * @param values The values containing the view in the view hierarchy.
 * @param viewPosX The x screen coordinate of view
 * @param viewPosY The y screen coordinate of view
 * @param startX The start translation x of view
 * @param startY The start translation y of view
 * @param endX The end translation x of view
 * @param endY The end translation y of view
 * @param interpolator The interpolator to use with this animator.
 * @return An animator that moves from (startX, startY) to (endX, endY) unless there was
 * a previous interruption, in which case it moves from the current position to (endX, endY).
 */

Body of Frist Method:
{
    float terminalX = view.getTranslationX();
    float terminalY = view.getTranslationY();
    int[] startPosition = (int[]) values.view.getTag(R.id.transitionPosition);
    if (startPosition != null) {
        startX = startPosition[0] - viewPosX + terminalX;
        startY = startPosition[1] - viewPosY + terminalY;
    }
    // Initial position is at translation startX, startY, so position is offset by that amount
    int startPosX = viewPosX + Math.round(startX - terminalX);
    int startPosY = viewPosY + Math.round(startY - terminalY);
    view.setTranslationX(startX);
    view.setTranslationY(startY);
    if (startX == endX && startY == endY) {
        return null;
    }
    Path path = new Path();
    path.moveTo(startX, startY);
    path.lineTo(endX, endY);
    ObjectAnimator anim = ObjectAnimator.ofFloat(view, View.TRANSLATION_X, View.TRANSLATION_Y, path);
    TransitionPositionListener listener = new TransitionPositionListener(view, values.view, startPosX, startPosY, terminalX, terminalY);
    anim.addListener(listener);
    anim.addPauseListener(listener);
    anim.setInterpolator(interpolator);
    return anim;
}
Body of Second Method:
{
    float terminalX = view.getTranslationX();
    float terminalY = view.getTranslationY();
    int[] startPosition = (int[]) values.view.getTag(R.id.transitionPosition);
    if (startPosition != null) {
        startX = startPosition[0] - viewPosX + terminalX;
        startY = startPosition[1] - viewPosY + terminalY;
    }
    // Initial position is at translation startX, startY, so position is offset by that amount
    int startPosX = viewPosX + Math.round(startX - terminalX);
    int startPosY = viewPosY + Math.round(startY - terminalY);
    view.setTranslationX(startX);
    view.setTranslationY(startY);
    if (startX == endX && startY == endY) {
        return null;
    }
    Path path = new Path();
    path.moveTo(startX, startY);
    path.lineTo(endX, endY);
    ObjectAnimator anim = ObjectAnimator.ofFloat(view, View.TRANSLATION_X, View.TRANSLATION_Y, path);
    TransitionPositionListener listener = new TransitionPositionListener(view, values.view, startPosX, startPosY, terminalX, terminalY);
    transition.addListener(listener);
    anim.addListener(listener);
    anim.addPauseListener(listener);
    anim.setInterpolator(interpolator);
    return anim;
}
------------------------
Find a silently evolved API code:android.util.BridgeXmlPullAttributes.resolveResourceValue:COMMENT
Method Modifier: private     
Comment:/**
 * Resolves and return a value to its associated integer.
 */

Body of Frist Method:
{
    ResourceValue resource = getResourceValue(value);
    if (resource != null) {
        Integer id = null;
        if (mPlatformFile || resource.isFramework()) {
            id = Bridge.getResourceId(resource.getResourceType(), resource.getName());
        } else {
            id = mContext.getProjectCallback().getResourceId(resource.getResourceType(), resource.getName());
        }
        if (id != null) {
            return id;
        }
    }
    return defaultValue;
}
Body of Second Method:
{
    ResourceValue resource = getResourceValue(value);
    if (resource != null) {
        Integer id = null;
        if (mPlatformFile || resource.isFramework()) {
            id = Bridge.getResourceId(resource.getResourceType(), resource.getName());
        } else {
            id = mContext.getLayoutlibCallback().getResourceId(resource.getResourceType(), resource.getName());
        }
        if (id != null) {
            return id;
        }
    }
    return defaultValue;
}
------------------------
Find a silently evolved API code:android.view.ScaleGestureDetector.getScaleFactor:COMMENT
Method Modifier: public      
Comment:/**
 * Return the scaling factor from the previous scale event to the current
 * event. This value is defined as
 * ({@link #getCurrentSpan()} / {@link #getPreviousSpan()}).
 *
 * @return The current scaling factor.
 */

Body of Frist Method:
{
    if (inDoubleTapMode()) {
        // Drag is moving up; the further away from the gesture
        // start, the smaller the span should be, the closer,
        // the larger the span, and therefore the larger the scale
        final boolean scaleUp = (mEventBeforeOrAboveStartingGestureEvent && (mCurrSpan < mPrevSpan)) || (!mEventBeforeOrAboveStartingGestureEvent && (mCurrSpan > mPrevSpan));
        final float spanDiff = (Math.abs(1 - (mCurrSpan / mPrevSpan)) * SCALE_FACTOR);
        return mPrevSpan <= 0 ? 1 : scaleUp ? (1 + spanDiff) : (1 - spanDiff);
    }
    return mPrevSpan > 0 ? mCurrSpan / mPrevSpan : 1;
}
Body of Second Method:
{
    if (inAnchoredScaleMode()) {
        // Drag is moving up; the further away from the gesture
        // start, the smaller the span should be, the closer,
        // the larger the span, and therefore the larger the scale
        final boolean scaleUp = (mEventBeforeOrAboveStartingGestureEvent && (mCurrSpan < mPrevSpan)) || (!mEventBeforeOrAboveStartingGestureEvent && (mCurrSpan > mPrevSpan));
        final float spanDiff = (Math.abs(1 - (mCurrSpan / mPrevSpan)) * SCALE_FACTOR);
        return mPrevSpan <= 0 ? 1 : scaleUp ? (1 + spanDiff) : (1 - spanDiff);
    }
    return mPrevSpan > 0 ? mCurrSpan / mPrevSpan : 1;
}
------------------------
Find a silently evolved API code:android.media.SoundPool.autoResume:COMMENT
<android.media.SoundPool: void autoResume()>
public      final       ->public      final       native      
Method Modifier: public      final       native      
Method Modifier: Yes         Yes         No          
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * Resume all previously active streams.
 *
 * Automatically resumes all streams that were paused in previous
 * calls to autoPause().
 */

Body of Frist Method:
{
    mImpl.autoResume();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.media.tv.TvTrackInfo.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Creates a {@link TvTrackInfo} instance with the specified fields.
 *
 * @return The new {@link TvTrackInfo} instance
 */

Body of Frist Method:
{
    return new TvTrackInfo(mType, mId, mLanguage, mAudioChannelCount, mAudioSampleRate, mVideoWidth, mVideoHeight, mVideoFrameRate, mExtra);
}
Body of Second Method:
{
    return new TvTrackInfo(mType, mId, mLanguage, mDescription, mAudioChannelCount, mAudioSampleRate, mVideoWidth, mVideoHeight, mVideoFrameRate, mVideoPixelAspectRatio, mExtra);
}
------------------------
Find a silently evolved API code:android.app.Notification.Builder.processLargeLegacyIcon:COMMENT
Method Modifier: private     
Comment:// TODO: also check bounds, transparency, that sort of thing.

Body of Frist Method:
{
    if (isLegacy() && mColorUtil.isGrayscaleIcon(largeIcon)) {
        applyLargeIconBackground(contentView);
    } else {
        removeLargeIconBackground(contentView);
    }
}
Body of Second Method:
{
    if (largeIcon != null && isLegacy() && mColorUtil.isGrayscaleIcon(mContext, largeIcon)) {
        applyLargeIconBackground(contentView);
    } else {
        removeLargeIconBackground(contentView);
    }
}
------------------------
Find a silently evolved API code:android.media.AudioManager.dispatchMediaKeyEvent:COMMENT
Method Modifier: public      
Comment:/**
 * Sends a simulated key event for a media button.
 * To simulate a key press, you must first send a KeyEvent built with a
 * {@link KeyEvent#ACTION_DOWN} action, then another event with the {@link KeyEvent#ACTION_UP}
 * action.
 * <p>The key event will be sent to the current media key event consumer which registered with
 * {@link AudioManager#registerMediaButtonEventReceiver(PendingIntent)}.
 * @param keyEvent a {@link KeyEvent} instance whose key code is one of
 * {@link KeyEvent#KEYCODE_MUTE},
 * {@link KeyEvent#KEYCODE_HEADSETHOOK},
 * {@link KeyEvent#KEYCODE_MEDIA_PLAY},
 * {@link KeyEvent#KEYCODE_MEDIA_PAUSE},
 * {@link KeyEvent#KEYCODE_MEDIA_PLAY_PAUSE},
 * {@link KeyEvent#KEYCODE_MEDIA_STOP},
 * {@link KeyEvent#KEYCODE_MEDIA_NEXT},
 * {@link KeyEvent#KEYCODE_MEDIA_PREVIOUS},
 * {@link KeyEvent#KEYCODE_MEDIA_REWIND},
 * {@link KeyEvent#KEYCODE_MEDIA_RECORD},
 * {@link KeyEvent#KEYCODE_MEDIA_FAST_FORWARD},
 * {@link KeyEvent#KEYCODE_MEDIA_CLOSE},
 * {@link KeyEvent#KEYCODE_MEDIA_EJECT},
 * or {@link KeyEvent#KEYCODE_MEDIA_AUDIO_TRACK}.
 */

Body of Frist Method:
{
    MediaSessionLegacyHelper helper = MediaSessionLegacyHelper.getHelper(mContext);
    helper.sendMediaButtonEvent(keyEvent, false);
}
Body of Second Method:
{
    MediaSessionLegacyHelper helper = MediaSessionLegacyHelper.getHelper(getContext());
    helper.sendMediaButtonEvent(keyEvent, false);
}
------------------------
Find a silently evolved API code:android.widget.SimpleAdapter.getView:COMMENT
Method Modifier: public      
Comment:/**
 * @see android.widget.Adapter#getView(int, View, ViewGroup)
 */

Body of Frist Method:
{
    return createViewFromResource(position, convertView, parent, mResource);
}
Body of Second Method:
{
    return createViewFromResource(mInflater, position, convertView, parent, mResource);
}
------------------------
Find a silently evolved API code:android.graphics.drawable.RippleDrawable.setTargetDensity:COMMENT
Method Modifier: private     
Comment:/**
 * Set the density at which this drawable will be rendered.
 *
 * @param metrics The display metrics for this drawable.
 */

Body of Frist Method:
{
    if (mDensity != metrics.density) {
        mDensity = metrics.density;
        invalidateSelf();
    }
}
Body of Second Method:
{
    if (mDensity != metrics.density) {
        mDensity = metrics.density;
        invalidateSelf(false);
    }
}
------------------------
Find a silently evolved API code:android.print.PrintAttributes.copyFrom:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    mMediaSize = other.mMediaSize;
    mResolution = other.mResolution;
    mMinMargins = other.mMinMargins;
    mColorMode = other.mColorMode;
}
Body of Second Method:
{
    mMediaSize = other.mMediaSize;
    mResolution = other.mResolution;
    mMinMargins = other.mMinMargins;
    mColorMode = other.mColorMode;
    mDuplexMode = other.mDuplexMode;
}
------------------------
Find a silently evolved API code:android.widget.GridLayout.measureChildrenWithMargins:COMMENT
Method Modifier: private     
Comment:// Note: padding has already been removed from the supplied specs

Body of Frist Method:
{
    for (int i = 0, N = getChildCount(); i < N; i++) {
        View c = getChildAt(i);
        if (c.getVisibility() == View.GONE)
            continue;
        LayoutParams lp = getLayoutParams(c);
        if (firstPass) {
            measureChildWithMargins2(c, widthSpec, heightSpec, lp.width, lp.height);
            mHorizontalAxis.recordOriginalMeasurement(i);
            mVerticalAxis.recordOriginalMeasurement(i);
        } else {
            boolean horizontal = (mOrientation == HORIZONTAL);
            Spec spec = horizontal ? lp.columnSpec : lp.rowSpec;
            if (spec.alignment == FILL) {
                Interval span = spec.span;
                Axis axis = horizontal ? mHorizontalAxis : mVerticalAxis;
                int[] locations = axis.getLocations();
                int cellSize = locations[span.max] - locations[span.min];
                int viewSize = cellSize - getTotalMargin(c, horizontal);
                if (horizontal) {
                    measureChildWithMargins2(c, widthSpec, heightSpec, viewSize, lp.height);
                } else {
                    measureChildWithMargins2(c, widthSpec, heightSpec, lp.width, viewSize);
                }
            }
        }
    }
}
Body of Second Method:
{
    for (int i = 0, N = getChildCount(); i < N; i++) {
        View c = getChildAt(i);
        if (c.getVisibility() == View.GONE)
            continue;
        LayoutParams lp = getLayoutParams(c);
        if (firstPass) {
            measureChildWithMargins2(c, widthSpec, heightSpec, lp.width, lp.height);
        } else {
            boolean horizontal = (mOrientation == HORIZONTAL);
            Spec spec = horizontal ? lp.columnSpec : lp.rowSpec;
            if (spec.getAbsoluteAlignment(horizontal) == FILL) {
                Interval span = spec.span;
                Axis axis = horizontal ? mHorizontalAxis : mVerticalAxis;
                int[] locations = axis.getLocations();
                int cellSize = locations[span.max] - locations[span.min];
                int viewSize = cellSize - getTotalMargin(c, horizontal);
                if (horizontal) {
                    measureChildWithMargins2(c, widthSpec, heightSpec, viewSize, lp.height);
                } else {
                    measureChildWithMargins2(c, widthSpec, heightSpec, lp.width, viewSize);
                }
            }
        }
    }
}
------------------------
Find a silently evolved API code:android.widget.FastScroller.updateLayout:COMMENT
Method Modifier: public      
Comment:/**
 * Measures and layouts the scrollbar and decorations.
 */

Body of Frist Method:
{
    // resolving padding.
    if (mUpdatingLayout) {
        return;
    }
    mUpdatingLayout = true;
    updateContainerRect();
    layoutThumb();
    layoutTrack();
    final Rect bounds = mTempBounds;
    measurePreview(mPrimaryText, bounds);
    applyLayout(mPrimaryText, bounds);
    measurePreview(mSecondaryText, bounds);
    applyLayout(mSecondaryText, bounds);
    if (mPreviewImage != null) {
        // Apply preview image padding.
        bounds.left -= mPreviewImage.getPaddingLeft();
        bounds.top -= mPreviewImage.getPaddingTop();
        bounds.right += mPreviewImage.getPaddingRight();
        bounds.bottom += mPreviewImage.getPaddingBottom();
        applyLayout(mPreviewImage, bounds);
    }
    mUpdatingLayout = false;
}
Body of Second Method:
{
    // resolving padding.
    if (mUpdatingLayout) {
        return;
    }
    mUpdatingLayout = true;
    updateContainerRect();
    layoutThumb();
    layoutTrack();
    updateOffsetAndRange();
    final Rect bounds = mTempBounds;
    measurePreview(mPrimaryText, bounds);
    applyLayout(mPrimaryText, bounds);
    measurePreview(mSecondaryText, bounds);
    applyLayout(mSecondaryText, bounds);
    if (mPreviewImage != null) {
        // Apply preview image padding.
        bounds.left -= mPreviewImage.getPaddingLeft();
        bounds.top -= mPreviewImage.getPaddingTop();
        bounds.right += mPreviewImage.getPaddingRight();
        bounds.bottom += mPreviewImage.getPaddingBottom();
        applyLayout(mPreviewImage, bounds);
    }
    mUpdatingLayout = false;
}
------------------------
Find a silently evolved API code:android.widget.SimpleAdapter.setDropDownViewResource:COMMENT
Method Modifier: public      
Comment:/**
 * <p>Sets the layout resource to create the drop down views.</p>
 *
 * @param resource the layout resource defining the drop down views
 * @see #getDropDownView(int, android.view.View, android.view.ViewGroup)
 */

Body of Frist Method:
{
    this.mDropDownResource = resource;
}
Body of Second Method:
{
    mDropDownResource = resource;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothDevice.createInsecureRfcommSocket:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Construct an insecure RFCOMM socket ready to start an outgoing
 * connection.
 * Call #connect on the returned #BluetoothSocket to begin the connection.
 * The remote device will not be authenticated and communication on this
 * socket will not be encrypted.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}
 *
 * @param port    remote port
 * @return An RFCOMM BluetoothSocket
 * @throws IOException On error, for example Bluetooth not available, or
 * insufficient permissions.
 * @hide
 */

Body of Frist Method:
{
    return new BluetoothSocket(BluetoothSocket.TYPE_RFCOMM, -1, false, false, this, port, null);
}
Body of Second Method:
{
    if (isBluetoothEnabled() == false) {
        Log.e(TAG, "Bluetooth is not enabled");
        throw new IOException();
    }
    return new BluetoothSocket(BluetoothSocket.TYPE_RFCOMM, -1, false, false, this, port, null);
}
------------------------
Find a silently evolved API code:android.view.ViewRootImpl.drawSoftware:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * @return true if drawing was successful, false if an error occurred
 */

Body of Frist Method:
{
    // Draw with software renderer.
    final Canvas canvas;
    try {
        final int left = dirty.left;
        final int top = dirty.top;
        final int right = dirty.right;
        final int bottom = dirty.bottom;
        canvas = mSurface.lockCanvas(dirty);
        // noinspection ConstantConditions
        if (left != dirty.left || top != dirty.top || right != dirty.right || bottom != dirty.bottom) {
            attachInfo.mIgnoreDirtyState = true;
        }
        // TODO: Do this in native
        canvas.setDensity(mDensity);
    } catch (Surface.OutOfResourcesException e) {
        handleOutOfResourcesException(e);
        return false;
    } catch (IllegalArgumentException e) {
        Log.e(TAG, "Could not lock surface", e);
        // Don't assume this is due to out of memory, it could be
        // something else, and if it is something else then we could
        // kill stuff (or ourself) for no reason.
        // ask wm for a new surface next time.
        mLayoutRequested = true;
        return false;
    }
    try {
        if (DEBUG_ORIENTATION || DEBUG_DRAW) {
            Log.v(TAG, "Surface " + surface + " drawing to bitmap w=" + canvas.getWidth() + ", h=" + canvas.getHeight());
        // canvas.drawARGB(255, 255, 0, 0);
        }
        // left in the blank areas.
        if (!canvas.isOpaque() || yoff != 0 || xoff != 0) {
            canvas.drawColor(0, PorterDuff.Mode.CLEAR);
        }
        dirty.setEmpty();
        mIsAnimating = false;
        attachInfo.mDrawingTime = SystemClock.uptimeMillis();
        mView.mPrivateFlags |= View.PFLAG_DRAWN;
        if (DEBUG_DRAW) {
            Context cxt = mView.getContext();
            Log.i(TAG, "Drawing: package:" + cxt.getPackageName() + ", metrics=" + cxt.getResources().getDisplayMetrics() + ", compatibilityInfo=" + cxt.getResources().getCompatibilityInfo());
        }
        try {
            canvas.translate(-xoff, -yoff);
            if (mTranslator != null) {
                mTranslator.translateCanvas(canvas);
            }
            canvas.setScreenDensity(scalingRequired ? mNoncompatDensity : 0);
            attachInfo.mSetIgnoreDirtyState = false;
            mView.draw(canvas);
            drawAccessibilityFocusedDrawableIfNeeded(canvas);
        } finally {
            if (!attachInfo.mSetIgnoreDirtyState) {
                // Only clear the flag if it was not set during the mView.draw() call
                attachInfo.mIgnoreDirtyState = false;
            }
        }
    } finally {
        try {
            surface.unlockCanvasAndPost(canvas);
        } catch (IllegalArgumentException e) {
            Log.e(TAG, "Could not unlock surface", e);
            // ask wm for a new surface next time.
            mLayoutRequested = true;
            // noinspection ReturnInsideFinallyBlock
            return false;
        }
        if (LOCAL_LOGV) {
            Log.v(TAG, "Surface " + surface + " unlockCanvasAndPost");
        }
    }
    return true;
}
Body of Second Method:
{
    // Draw with software renderer.
    final Canvas canvas;
    try {
        final int left = dirty.left;
        final int top = dirty.top;
        final int right = dirty.right;
        final int bottom = dirty.bottom;
        canvas = mSurface.lockCanvas(dirty);
        // noinspection ConstantConditions
        if (left != dirty.left || top != dirty.top || right != dirty.right || bottom != dirty.bottom) {
            attachInfo.mIgnoreDirtyState = true;
        }
        // TODO: Do this in native
        canvas.setDensity(mDensity);
    } catch (Surface.OutOfResourcesException e) {
        handleOutOfResourcesException(e);
        return false;
    } catch (IllegalArgumentException e) {
        Log.e(TAG, "Could not lock surface", e);
        // Don't assume this is due to out of memory, it could be
        // something else, and if it is something else then we could
        // kill stuff (or ourself) for no reason.
        // ask wm for a new surface next time.
        mLayoutRequested = true;
        return false;
    }
    try {
        if (DEBUG_ORIENTATION || DEBUG_DRAW) {
            Log.v(TAG, "Surface " + surface + " drawing to bitmap w=" + canvas.getWidth() + ", h=" + canvas.getHeight());
        // canvas.drawARGB(255, 255, 0, 0);
        }
        // left in the blank areas.
        if (!canvas.isOpaque() || yoff != 0 || xoff != 0) {
            canvas.drawColor(0, PorterDuff.Mode.CLEAR);
        }
        dirty.setEmpty();
        mIsAnimating = false;
        mView.mPrivateFlags |= View.PFLAG_DRAWN;
        if (DEBUG_DRAW) {
            Context cxt = mView.getContext();
            Log.i(TAG, "Drawing: package:" + cxt.getPackageName() + ", metrics=" + cxt.getResources().getDisplayMetrics() + ", compatibilityInfo=" + cxt.getResources().getCompatibilityInfo());
        }
        try {
            canvas.translate(-xoff, -yoff);
            if (mTranslator != null) {
                mTranslator.translateCanvas(canvas);
            }
            canvas.setScreenDensity(scalingRequired ? mNoncompatDensity : 0);
            attachInfo.mSetIgnoreDirtyState = false;
            mView.draw(canvas);
            drawAccessibilityFocusedDrawableIfNeeded(canvas);
        } finally {
            if (!attachInfo.mSetIgnoreDirtyState) {
                // Only clear the flag if it was not set during the mView.draw() call
                attachInfo.mIgnoreDirtyState = false;
            }
        }
    } finally {
        try {
            surface.unlockCanvasAndPost(canvas);
        } catch (IllegalArgumentException e) {
            Log.e(TAG, "Could not unlock surface", e);
            // ask wm for a new surface next time.
            mLayoutRequested = true;
            // noinspection ReturnInsideFinallyBlock
            return false;
        }
        if (LOCAL_LOGV) {
            Log.v(TAG, "Surface " + surface + " unlockCanvasAndPost");
        }
    }
    return true;
}
------------------------
Find a silently evolved API code:android.nfc.NfcActivityManager.createBeamShareData:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Callback from NFC service, usually on binder thread
 */

Body of Frist Method:
{
    NfcAdapter.CreateNdefMessageCallback ndefCallback;
    NfcAdapter.CreateBeamUrisCallback urisCallback;
    NdefMessage message;
    Activity activity;
    Uri[] uris;
    int flags;
    synchronized (NfcActivityManager.this) {
        NfcActivityState state = findResumedActivityState();
        if (state == null)
            return null;
        ndefCallback = state.ndefMessageCallback;
        urisCallback = state.uriCallback;
        message = state.ndefMessage;
        uris = state.uris;
        flags = state.flags;
        activity = state.activity;
    }
    // Make callbacks without lock
    if (ndefCallback != null) {
        message = ndefCallback.createNdefMessage(mDefaultEvent);
    }
    if (urisCallback != null) {
        uris = urisCallback.createBeamUris(mDefaultEvent);
        if (uris != null) {
            ArrayList<Uri> validUris = new ArrayList<Uri>();
            for (Uri uri : uris) {
                if (uri == null) {
                    Log.e(TAG, "Uri not allowed to be null.");
                    continue;
                }
                String scheme = uri.getScheme();
                if (scheme == null || (!scheme.equalsIgnoreCase("file") && !scheme.equalsIgnoreCase("content"))) {
                    Log.e(TAG, "Uri needs to have " + "either scheme file or scheme content");
                    continue;
                }
                uri = ContentProvider.maybeAddUserId(uri, UserHandle.myUserId());
                validUris.add(uri);
            }
            uris = validUris.toArray(new Uri[validUris.size()]);
        }
    }
    if (uris != null && uris.length > 0) {
        for (Uri uri : uris) {
            // Grant the NFC process permission to read these URIs
            activity.grantUriPermission("com.android.nfc", uri, Intent.FLAG_GRANT_READ_URI_PERMISSION);
        }
    }
    return new BeamShareData(message, uris, UserHandle.CURRENT, flags);
}
Body of Second Method:
{
    NfcAdapter.CreateNdefMessageCallback ndefCallback;
    NfcAdapter.CreateBeamUrisCallback urisCallback;
    NdefMessage message;
    Activity activity;
    Uri[] uris;
    int flags;
    NfcEvent event = new NfcEvent(mAdapter, peerLlcpVersion);
    synchronized (NfcActivityManager.this) {
        NfcActivityState state = findResumedActivityState();
        if (state == null)
            return null;
        ndefCallback = state.ndefMessageCallback;
        urisCallback = state.uriCallback;
        message = state.ndefMessage;
        uris = state.uris;
        flags = state.flags;
        activity = state.activity;
    }
    // Make callbacks without lock
    if (ndefCallback != null) {
        message = ndefCallback.createNdefMessage(event);
    }
    if (urisCallback != null) {
        uris = urisCallback.createBeamUris(event);
        if (uris != null) {
            ArrayList<Uri> validUris = new ArrayList<Uri>();
            for (Uri uri : uris) {
                if (uri == null) {
                    Log.e(TAG, "Uri not allowed to be null.");
                    continue;
                }
                String scheme = uri.getScheme();
                if (scheme == null || (!scheme.equalsIgnoreCase("file") && !scheme.equalsIgnoreCase("content"))) {
                    Log.e(TAG, "Uri needs to have " + "either scheme file or scheme content");
                    continue;
                }
                uri = ContentProvider.maybeAddUserId(uri, UserHandle.myUserId());
                validUris.add(uri);
            }
            uris = validUris.toArray(new Uri[validUris.size()]);
        }
    }
    if (uris != null && uris.length > 0) {
        for (Uri uri : uris) {
            // Grant the NFC process permission to read these URIs
            activity.grantUriPermission("com.android.nfc", uri, Intent.FLAG_GRANT_READ_URI_PERMISSION);
        }
    }
    return new BeamShareData(message, uris, new UserHandle(UserHandle.myUserId()), flags);
}
------------------------
Find a silently evolved API code:android.media.SoundPool.setRate:COMMENT
<android.media.SoundPool: void setRate(int,float)>
public      final       ->public      final       native      
Method Modifier: public      final       native      
Method Modifier: Yes         Yes         No          
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * Change playback rate.
 *
 * The playback rate allows the application to vary the playback
 * rate (pitch) of the sound. A value of 1.0 means playback at
 * the original frequency. A value of 2.0 means playback twice
 * as fast, and a value of 0.5 means playback at half speed.
 * If the stream does not exist, it will have no effect.
 *
 * @param streamID a streamID returned by the play() function
 * @param rate playback rate (1.0 = normal playback, range 0.5 to 2.0)
 */

Body of Frist Method:
{
    mImpl.setRate(streamID, rate);
}
Body of Second Method:

------------------------
Find a silently evolved API code:javax.obex.ObexHelper.createHeader:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Creates the header part of OBEX packet based on the header provided.
 * TODO: Could use getHeaderList() to get the array of headers to include
 * and then use the high two bits to determine the the type of the object
 * and construct the byte array from that. This will make the size smaller.
 * @param head the header used to construct the byte array
 * @param nullOut <code>true</code> if the header should be set to
 * <code>null</code> once it is added to the array or
 * <code>false</code> if it should not be nulled out
 * @return the header of an OBEX packet
 */

Body of Frist Method:
{
    Long intHeader = null;
    String stringHeader = null;
    Calendar dateHeader = null;
    Byte byteHeader = null;
    StringBuffer buffer = null;
    byte[] value = null;
    byte[] result = null;
    byte[] lengthArray = new byte[2];
    int length;
    HeaderSet headImpl = null;
    ByteArrayOutputStream out = new ByteArrayOutputStream();
    headImpl = head;
    try {
        /*
             * Determine if there is a connection ID to send.  If there is,
             * then it should be the first header in the packet.
             */
        if ((headImpl.mConnectionID != null) && (headImpl.getHeader(HeaderSet.TARGET) == null)) {
            out.write((byte) HeaderSet.CONNECTION_ID);
            out.write(headImpl.mConnectionID);
        }
        // Count Header
        intHeader = (Long) headImpl.getHeader(HeaderSet.COUNT);
        if (intHeader != null) {
            out.write((byte) HeaderSet.COUNT);
            value = ObexHelper.convertToByteArray(intHeader.longValue());
            out.write(value);
            if (nullOut) {
                headImpl.setHeader(HeaderSet.COUNT, null);
            }
        }
        // Name Header
        stringHeader = (String) headImpl.getHeader(HeaderSet.NAME);
        if (stringHeader != null) {
            out.write((byte) HeaderSet.NAME);
            value = ObexHelper.convertToUnicodeByteArray(stringHeader);
            length = value.length + 3;
            lengthArray[0] = (byte) (0xFF & (length >> 8));
            lengthArray[1] = (byte) (0xFF & length);
            out.write(lengthArray);
            out.write(value);
            if (nullOut) {
                headImpl.setHeader(HeaderSet.NAME, null);
            }
        } else if (headImpl.getEmptyNameHeader()) {
            out.write((byte) HeaderSet.NAME);
            lengthArray[0] = (byte) 0x00;
            lengthArray[1] = (byte) 0x03;
            out.write(lengthArray);
        }
        // Type Header
        stringHeader = (String) headImpl.getHeader(HeaderSet.TYPE);
        if (stringHeader != null) {
            out.write((byte) HeaderSet.TYPE);
            try {
                value = stringHeader.getBytes("ISO8859_1");
            } catch (UnsupportedEncodingException e) {
                throw e;
            }
            length = value.length + 4;
            lengthArray[0] = (byte) (255 & (length >> 8));
            lengthArray[1] = (byte) (255 & length);
            out.write(lengthArray);
            out.write(value);
            out.write(0x00);
            if (nullOut) {
                headImpl.setHeader(HeaderSet.TYPE, null);
            }
        }
        // Length Header
        intHeader = (Long) headImpl.getHeader(HeaderSet.LENGTH);
        if (intHeader != null) {
            out.write((byte) HeaderSet.LENGTH);
            value = ObexHelper.convertToByteArray(intHeader.longValue());
            out.write(value);
            if (nullOut) {
                headImpl.setHeader(HeaderSet.LENGTH, null);
            }
        }
        // Time ISO Header
        dateHeader = (Calendar) headImpl.getHeader(HeaderSet.TIME_ISO_8601);
        if (dateHeader != null) {
            /*
                 * The ISO Header should take the form YYYYMMDDTHHMMSSZ.  The
                 * 'Z' will only be included if it is a UTC time.
                 */
            buffer = new StringBuffer();
            int temp = dateHeader.get(Calendar.YEAR);
            for (int i = temp; i < 1000; i = i * 10) {
                buffer.append("0");
            }
            buffer.append(temp);
            temp = dateHeader.get(Calendar.MONTH);
            if (temp < 10) {
                buffer.append("0");
            }
            buffer.append(temp);
            temp = dateHeader.get(Calendar.DAY_OF_MONTH);
            if (temp < 10) {
                buffer.append("0");
            }
            buffer.append(temp);
            buffer.append("T");
            temp = dateHeader.get(Calendar.HOUR_OF_DAY);
            if (temp < 10) {
                buffer.append("0");
            }
            buffer.append(temp);
            temp = dateHeader.get(Calendar.MINUTE);
            if (temp < 10) {
                buffer.append("0");
            }
            buffer.append(temp);
            temp = dateHeader.get(Calendar.SECOND);
            if (temp < 10) {
                buffer.append("0");
            }
            buffer.append(temp);
            if (dateHeader.getTimeZone().getID().equals("UTC")) {
                buffer.append("Z");
            }
            try {
                value = buffer.toString().getBytes("ISO8859_1");
            } catch (UnsupportedEncodingException e) {
                throw e;
            }
            length = value.length + 3;
            lengthArray[0] = (byte) (255 & (length >> 8));
            lengthArray[1] = (byte) (255 & length);
            out.write(HeaderSet.TIME_ISO_8601);
            out.write(lengthArray);
            out.write(value);
            if (nullOut) {
                headImpl.setHeader(HeaderSet.TIME_ISO_8601, null);
            }
        }
        // Time 4 Byte Header
        dateHeader = (Calendar) headImpl.getHeader(HeaderSet.TIME_4_BYTE);
        if (dateHeader != null) {
            out.write(HeaderSet.TIME_4_BYTE);
            /*
                 * Need to call getTime() twice.  The first call will return
                 * a java.util.Date object.  The second call returns the number
                 * of milliseconds since January 1, 1970.  We need to convert
                 * it to seconds since the TIME_4_BYTE expects the number of
                 * seconds since January 1, 1970.
                 */
            value = ObexHelper.convertToByteArray(dateHeader.getTime().getTime() / 1000L);
            out.write(value);
            if (nullOut) {
                headImpl.setHeader(HeaderSet.TIME_4_BYTE, null);
            }
        }
        // Description Header
        stringHeader = (String) headImpl.getHeader(HeaderSet.DESCRIPTION);
        if (stringHeader != null) {
            out.write((byte) HeaderSet.DESCRIPTION);
            value = ObexHelper.convertToUnicodeByteArray(stringHeader);
            length = value.length + 3;
            lengthArray[0] = (byte) (255 & (length >> 8));
            lengthArray[1] = (byte) (255 & length);
            out.write(lengthArray);
            out.write(value);
            if (nullOut) {
                headImpl.setHeader(HeaderSet.DESCRIPTION, null);
            }
        }
        // Target Header
        value = (byte[]) headImpl.getHeader(HeaderSet.TARGET);
        if (value != null) {
            out.write((byte) HeaderSet.TARGET);
            length = value.length + 3;
            lengthArray[0] = (byte) (255 & (length >> 8));
            lengthArray[1] = (byte) (255 & length);
            out.write(lengthArray);
            out.write(value);
            if (nullOut) {
                headImpl.setHeader(HeaderSet.TARGET, null);
            }
        }
        // HTTP Header
        value = (byte[]) headImpl.getHeader(HeaderSet.HTTP);
        if (value != null) {
            out.write((byte) HeaderSet.HTTP);
            length = value.length + 3;
            lengthArray[0] = (byte) (255 & (length >> 8));
            lengthArray[1] = (byte) (255 & length);
            out.write(lengthArray);
            out.write(value);
            if (nullOut) {
                headImpl.setHeader(HeaderSet.HTTP, null);
            }
        }
        // Who Header
        value = (byte[]) headImpl.getHeader(HeaderSet.WHO);
        if (value != null) {
            out.write((byte) HeaderSet.WHO);
            length = value.length + 3;
            lengthArray[0] = (byte) (255 & (length >> 8));
            lengthArray[1] = (byte) (255 & length);
            out.write(lengthArray);
            out.write(value);
            if (nullOut) {
                headImpl.setHeader(HeaderSet.WHO, null);
            }
        }
        // Connection ID Header
        value = (byte[]) headImpl.getHeader(HeaderSet.APPLICATION_PARAMETER);
        if (value != null) {
            out.write((byte) HeaderSet.APPLICATION_PARAMETER);
            length = value.length + 3;
            lengthArray[0] = (byte) (255 & (length >> 8));
            lengthArray[1] = (byte) (255 & length);
            out.write(lengthArray);
            out.write(value);
            if (nullOut) {
                headImpl.setHeader(HeaderSet.APPLICATION_PARAMETER, null);
            }
        }
        // Object Class Header
        value = (byte[]) headImpl.getHeader(HeaderSet.OBJECT_CLASS);
        if (value != null) {
            out.write((byte) HeaderSet.OBJECT_CLASS);
            length = value.length + 3;
            lengthArray[0] = (byte) (255 & (length >> 8));
            lengthArray[1] = (byte) (255 & length);
            out.write(lengthArray);
            out.write(value);
            if (nullOut) {
                headImpl.setHeader(HeaderSet.OBJECT_CLASS, null);
            }
        }
        // Check User Defined Headers
        for (int i = 0; i < 16; i++) {
            // Unicode String Header
            stringHeader = (String) headImpl.getHeader(i + 0x30);
            if (stringHeader != null) {
                out.write((byte) i + 0x30);
                value = ObexHelper.convertToUnicodeByteArray(stringHeader);
                length = value.length + 3;
                lengthArray[0] = (byte) (255 & (length >> 8));
                lengthArray[1] = (byte) (255 & length);
                out.write(lengthArray);
                out.write(value);
                if (nullOut) {
                    headImpl.setHeader(i + 0x30, null);
                }
            }
            // Byte Sequence Header
            value = (byte[]) headImpl.getHeader(i + 0x70);
            if (value != null) {
                out.write((byte) i + 0x70);
                length = value.length + 3;
                lengthArray[0] = (byte) (255 & (length >> 8));
                lengthArray[1] = (byte) (255 & length);
                out.write(lengthArray);
                out.write(value);
                if (nullOut) {
                    headImpl.setHeader(i + 0x70, null);
                }
            }
            // Byte Header
            byteHeader = (Byte) headImpl.getHeader(i + 0xB0);
            if (byteHeader != null) {
                out.write((byte) i + 0xB0);
                out.write(byteHeader.byteValue());
                if (nullOut) {
                    headImpl.setHeader(i + 0xB0, null);
                }
            }
            // Integer header
            intHeader = (Long) headImpl.getHeader(i + 0xF0);
            if (intHeader != null) {
                out.write((byte) i + 0xF0);
                out.write(ObexHelper.convertToByteArray(intHeader.longValue()));
                if (nullOut) {
                    headImpl.setHeader(i + 0xF0, null);
                }
            }
        }
        // Add the authentication challenge header
        if (headImpl.mAuthChall != null) {
            out.write((byte) HeaderSet.AUTH_CHALLENGE);
            length = headImpl.mAuthChall.length + 3;
            lengthArray[0] = (byte) (255 & (length >> 8));
            lengthArray[1] = (byte) (255 & length);
            out.write(lengthArray);
            out.write(headImpl.mAuthChall);
            if (nullOut) {
                headImpl.mAuthChall = null;
            }
        }
        // Add the authentication response header
        if (headImpl.mAuthResp != null) {
            out.write((byte) HeaderSet.AUTH_RESPONSE);
            length = headImpl.mAuthResp.length + 3;
            lengthArray[0] = (byte) (255 & (length >> 8));
            lengthArray[1] = (byte) (255 & length);
            out.write(lengthArray);
            out.write(headImpl.mAuthResp);
            if (nullOut) {
                headImpl.mAuthResp = null;
            }
        }
    } catch (IOException e) {
    } finally {
        result = out.toByteArray();
        try {
            out.close();
        } catch (Exception ex) {
        }
    }
    return result;
}
Body of Second Method:
{
    Long intHeader = null;
    String stringHeader = null;
    Calendar dateHeader = null;
    Byte byteHeader = null;
    StringBuffer buffer = null;
    byte[] value = null;
    byte[] result = null;
    byte[] lengthArray = new byte[2];
    int length;
    HeaderSet headImpl = null;
    ByteArrayOutputStream out = new ByteArrayOutputStream();
    headImpl = head;
    try {
        /*
             * Determine if there is a connection ID to send.  If there is,
             * then it should be the first header in the packet.
             */
        if ((headImpl.mConnectionID != null) && (headImpl.getHeader(HeaderSet.TARGET) == null)) {
            out.write((byte) HeaderSet.CONNECTION_ID);
            out.write(headImpl.mConnectionID);
        }
        // Count Header
        intHeader = (Long) headImpl.getHeader(HeaderSet.COUNT);
        if (intHeader != null) {
            out.write((byte) HeaderSet.COUNT);
            value = ObexHelper.convertToByteArray(intHeader.longValue());
            out.write(value);
            if (nullOut) {
                headImpl.setHeader(HeaderSet.COUNT, null);
            }
        }
        // Name Header
        stringHeader = (String) headImpl.getHeader(HeaderSet.NAME);
        if (stringHeader != null) {
            out.write((byte) HeaderSet.NAME);
            value = ObexHelper.convertToUnicodeByteArray(stringHeader);
            length = value.length + 3;
            lengthArray[0] = (byte) (0xFF & (length >> 8));
            lengthArray[1] = (byte) (0xFF & length);
            out.write(lengthArray);
            out.write(value);
            if (nullOut) {
                headImpl.setHeader(HeaderSet.NAME, null);
            }
        } else if (headImpl.getEmptyNameHeader()) {
            out.write((byte) HeaderSet.NAME);
            lengthArray[0] = (byte) 0x00;
            lengthArray[1] = (byte) 0x03;
            out.write(lengthArray);
        }
        // Type Header
        stringHeader = (String) headImpl.getHeader(HeaderSet.TYPE);
        if (stringHeader != null) {
            out.write((byte) HeaderSet.TYPE);
            try {
                value = stringHeader.getBytes("ISO8859_1");
            } catch (UnsupportedEncodingException e) {
                throw e;
            }
            length = value.length + 4;
            lengthArray[0] = (byte) (255 & (length >> 8));
            lengthArray[1] = (byte) (255 & length);
            out.write(lengthArray);
            out.write(value);
            out.write(0x00);
            if (nullOut) {
                headImpl.setHeader(HeaderSet.TYPE, null);
            }
        }
        // Length Header
        intHeader = (Long) headImpl.getHeader(HeaderSet.LENGTH);
        if (intHeader != null) {
            out.write((byte) HeaderSet.LENGTH);
            value = ObexHelper.convertToByteArray(intHeader.longValue());
            out.write(value);
            if (nullOut) {
                headImpl.setHeader(HeaderSet.LENGTH, null);
            }
        }
        // Time ISO Header
        dateHeader = (Calendar) headImpl.getHeader(HeaderSet.TIME_ISO_8601);
        if (dateHeader != null) {
            /*
                 * The ISO Header should take the form YYYYMMDDTHHMMSSZ.  The
                 * 'Z' will only be included if it is a UTC time.
                 */
            buffer = new StringBuffer();
            int temp = dateHeader.get(Calendar.YEAR);
            for (int i = temp; i < 1000; i = i * 10) {
                buffer.append("0");
            }
            buffer.append(temp);
            temp = dateHeader.get(Calendar.MONTH);
            if (temp < 10) {
                buffer.append("0");
            }
            buffer.append(temp);
            temp = dateHeader.get(Calendar.DAY_OF_MONTH);
            if (temp < 10) {
                buffer.append("0");
            }
            buffer.append(temp);
            buffer.append("T");
            temp = dateHeader.get(Calendar.HOUR_OF_DAY);
            if (temp < 10) {
                buffer.append("0");
            }
            buffer.append(temp);
            temp = dateHeader.get(Calendar.MINUTE);
            if (temp < 10) {
                buffer.append("0");
            }
            buffer.append(temp);
            temp = dateHeader.get(Calendar.SECOND);
            if (temp < 10) {
                buffer.append("0");
            }
            buffer.append(temp);
            if (dateHeader.getTimeZone().getID().equals("UTC")) {
                buffer.append("Z");
            }
            try {
                value = buffer.toString().getBytes("ISO8859_1");
            } catch (UnsupportedEncodingException e) {
                throw e;
            }
            length = value.length + 3;
            lengthArray[0] = (byte) (255 & (length >> 8));
            lengthArray[1] = (byte) (255 & length);
            out.write(HeaderSet.TIME_ISO_8601);
            out.write(lengthArray);
            out.write(value);
            if (nullOut) {
                headImpl.setHeader(HeaderSet.TIME_ISO_8601, null);
            }
        }
        // Time 4 Byte Header
        dateHeader = (Calendar) headImpl.getHeader(HeaderSet.TIME_4_BYTE);
        if (dateHeader != null) {
            out.write(HeaderSet.TIME_4_BYTE);
            /*
                 * Need to call getTime() twice.  The first call will return
                 * a java.util.Date object.  The second call returns the number
                 * of milliseconds since January 1, 1970.  We need to convert
                 * it to seconds since the TIME_4_BYTE expects the number of
                 * seconds since January 1, 1970.
                 */
            value = ObexHelper.convertToByteArray(dateHeader.getTime().getTime() / 1000L);
            out.write(value);
            if (nullOut) {
                headImpl.setHeader(HeaderSet.TIME_4_BYTE, null);
            }
        }
        // Description Header
        stringHeader = (String) headImpl.getHeader(HeaderSet.DESCRIPTION);
        if (stringHeader != null) {
            out.write((byte) HeaderSet.DESCRIPTION);
            value = ObexHelper.convertToUnicodeByteArray(stringHeader);
            length = value.length + 3;
            lengthArray[0] = (byte) (255 & (length >> 8));
            lengthArray[1] = (byte) (255 & length);
            out.write(lengthArray);
            out.write(value);
            if (nullOut) {
                headImpl.setHeader(HeaderSet.DESCRIPTION, null);
            }
        }
        // Target Header
        value = (byte[]) headImpl.getHeader(HeaderSet.TARGET);
        if (value != null) {
            out.write((byte) HeaderSet.TARGET);
            length = value.length + 3;
            lengthArray[0] = (byte) (255 & (length >> 8));
            lengthArray[1] = (byte) (255 & length);
            out.write(lengthArray);
            out.write(value);
            if (nullOut) {
                headImpl.setHeader(HeaderSet.TARGET, null);
            }
        }
        // HTTP Header
        value = (byte[]) headImpl.getHeader(HeaderSet.HTTP);
        if (value != null) {
            out.write((byte) HeaderSet.HTTP);
            length = value.length + 3;
            lengthArray[0] = (byte) (255 & (length >> 8));
            lengthArray[1] = (byte) (255 & length);
            out.write(lengthArray);
            out.write(value);
            if (nullOut) {
                headImpl.setHeader(HeaderSet.HTTP, null);
            }
        }
        // Who Header
        value = (byte[]) headImpl.getHeader(HeaderSet.WHO);
        if (value != null) {
            out.write((byte) HeaderSet.WHO);
            length = value.length + 3;
            lengthArray[0] = (byte) (255 & (length >> 8));
            lengthArray[1] = (byte) (255 & length);
            out.write(lengthArray);
            out.write(value);
            if (nullOut) {
                headImpl.setHeader(HeaderSet.WHO, null);
            }
        }
        // Connection ID Header
        value = (byte[]) headImpl.getHeader(HeaderSet.APPLICATION_PARAMETER);
        if (value != null) {
            out.write((byte) HeaderSet.APPLICATION_PARAMETER);
            length = value.length + 3;
            lengthArray[0] = (byte) (255 & (length >> 8));
            lengthArray[1] = (byte) (255 & length);
            out.write(lengthArray);
            out.write(value);
            if (nullOut) {
                headImpl.setHeader(HeaderSet.APPLICATION_PARAMETER, null);
            }
        }
        // Object Class Header
        value = (byte[]) headImpl.getHeader(HeaderSet.OBJECT_CLASS);
        if (value != null) {
            out.write((byte) HeaderSet.OBJECT_CLASS);
            length = value.length + 3;
            lengthArray[0] = (byte) (255 & (length >> 8));
            lengthArray[1] = (byte) (255 & length);
            out.write(lengthArray);
            out.write(value);
            if (nullOut) {
                headImpl.setHeader(HeaderSet.OBJECT_CLASS, null);
            }
        }
        // Check User Defined Headers
        for (int i = 0; i < 16; i++) {
            // Unicode String Header
            stringHeader = (String) headImpl.getHeader(i + 0x30);
            if (stringHeader != null) {
                out.write((byte) i + 0x30);
                value = ObexHelper.convertToUnicodeByteArray(stringHeader);
                length = value.length + 3;
                lengthArray[0] = (byte) (255 & (length >> 8));
                lengthArray[1] = (byte) (255 & length);
                out.write(lengthArray);
                out.write(value);
                if (nullOut) {
                    headImpl.setHeader(i + 0x30, null);
                }
            }
            // Byte Sequence Header
            value = (byte[]) headImpl.getHeader(i + 0x70);
            if (value != null) {
                out.write((byte) i + 0x70);
                length = value.length + 3;
                lengthArray[0] = (byte) (255 & (length >> 8));
                lengthArray[1] = (byte) (255 & length);
                out.write(lengthArray);
                out.write(value);
                if (nullOut) {
                    headImpl.setHeader(i + 0x70, null);
                }
            }
            // Byte Header
            byteHeader = (Byte) headImpl.getHeader(i + 0xB0);
            if (byteHeader != null) {
                out.write((byte) i + 0xB0);
                out.write(byteHeader.byteValue());
                if (nullOut) {
                    headImpl.setHeader(i + 0xB0, null);
                }
            }
            // Integer header
            intHeader = (Long) headImpl.getHeader(i + 0xF0);
            if (intHeader != null) {
                out.write((byte) i + 0xF0);
                out.write(ObexHelper.convertToByteArray(intHeader.longValue()));
                if (nullOut) {
                    headImpl.setHeader(i + 0xF0, null);
                }
            }
        }
        // Add the authentication challenge header
        if (headImpl.mAuthChall != null) {
            out.write((byte) HeaderSet.AUTH_CHALLENGE);
            length = headImpl.mAuthChall.length + 3;
            lengthArray[0] = (byte) (255 & (length >> 8));
            lengthArray[1] = (byte) (255 & length);
            out.write(lengthArray);
            out.write(headImpl.mAuthChall);
            if (nullOut) {
                headImpl.mAuthChall = null;
            }
        }
        // Add the authentication response header
        if (headImpl.mAuthResp != null) {
            out.write((byte) HeaderSet.AUTH_RESPONSE);
            length = headImpl.mAuthResp.length + 3;
            lengthArray[0] = (byte) (255 & (length >> 8));
            lengthArray[1] = (byte) (255 & length);
            out.write(lengthArray);
            out.write(headImpl.mAuthResp);
            if (nullOut) {
                headImpl.mAuthResp = null;
            }
        }
        // TODO:
        // If the SRM and SRMP header is in use, they must be send in the same OBEX packet
        // But the current structure of the obex code cannot handle this, and therefore
        // it makes sense to put them in the tail of the headers, since we then reduce the
        // chance of enabling SRM to soon. The down side is that SRM cannot be used while
        // transferring non-body headers
        // Add the SRM header
        byteHeader = (Byte) headImpl.getHeader(HeaderSet.SINGLE_RESPONSE_MODE);
        if (byteHeader != null) {
            out.write((byte) HeaderSet.SINGLE_RESPONSE_MODE);
            out.write(byteHeader.byteValue());
            if (nullOut) {
                headImpl.setHeader(HeaderSet.SINGLE_RESPONSE_MODE, null);
            }
        }
        // Add the SRM parameter header
        byteHeader = (Byte) headImpl.getHeader(HeaderSet.SINGLE_RESPONSE_MODE_PARAMETER);
        if (byteHeader != null) {
            out.write((byte) HeaderSet.SINGLE_RESPONSE_MODE_PARAMETER);
            out.write(byteHeader.byteValue());
            if (nullOut) {
                headImpl.setHeader(HeaderSet.SINGLE_RESPONSE_MODE_PARAMETER, null);
            }
        }
    } catch (IOException e) {
    } finally {
        result = out.toByteArray();
        try {
            out.close();
        } catch (Exception ex) {
        }
    }
    return result;
}
------------------------
Find a silently evolved API code:android.inputmethodservice.InputMethodService.onKeyUp:COMMENT
Method Modifier: public      
Comment:/**
 * Override this to intercept key up events before they are processed by the
 * application.  If you return true, the application will not itself
 * process the event.  If you return false, the normal application processing
 * will occur as if the IME had not seen the event at all.
 *
 * <p>The default implementation intercepts {@link KeyEvent#KEYCODE_BACK
 * KeyEvent.KEYCODE_BACK} to hide the current IME UI if it is shown.  In
 * addition, in fullscreen mode only, it will consume DPAD movement
 * events to move the cursor in the extracted text view, not allowing
 * them to perform navigation in the underlying application.
 */

Body of Frist Method:
{
    if (event.getKeyCode() == KeyEvent.KEYCODE_BACK && event.isTracking() && !event.isCanceled()) {
        return handleBack(true);
    }
    return doMovementKey(keyCode, event, MOVEMENT_UP);
}
Body of Second Method:
{
    if (event.getKeyCode() == KeyEvent.KEYCODE_BACK) {
        final ExtractEditText eet = getExtractEditTextIfVisible();
        if (eet != null && eet.handleBackInTextActionModeIfNeeded(event)) {
            return true;
        }
        if (event.isTracking() && !event.isCanceled()) {
            return handleBack(true);
        }
    }
    return doMovementKey(keyCode, event, MOVEMENT_UP);
}
------------------------
Find a silently evolved API code:android.widget.TableLayout.measureVertical:COMMENT
Method Modifier: default     
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    findLargestCells(widthMeasureSpec);
    shrinkAndStretchColumns(widthMeasureSpec);
    super.measureVertical(widthMeasureSpec, heightMeasureSpec);
}
Body of Second Method:
{
    findLargestCells(widthMeasureSpec, heightMeasureSpec);
    shrinkAndStretchColumns(widthMeasureSpec);
    super.measureVertical(widthMeasureSpec, heightMeasureSpec);
}
------------------------
Find a silently evolved API code:android.view.SurfaceView.updateWindow:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (!mHaveFrame) {
        return;
    }
    ViewRootImpl viewRoot = getViewRootImpl();
    if (viewRoot != null) {
        mTranslator = viewRoot.mTranslator;
    }
    if (mTranslator != null) {
        mSurface.setCompatibilityTranslator(mTranslator);
    }
    int myWidth = mRequestedWidth;
    if (myWidth <= 0)
        myWidth = getWidth();
    int myHeight = mRequestedHeight;
    if (myHeight <= 0)
        myHeight = getHeight();
    getLocationInWindow(mLocation);
    final boolean creating = mWindow == null;
    final boolean formatChanged = mFormat != mRequestedFormat;
    final boolean sizeChanged = mWidth != myWidth || mHeight != myHeight;
    final boolean visibleChanged = mVisible != mRequestedVisible;
    if (force || creating || formatChanged || sizeChanged || visibleChanged || mLeft != mLocation[0] || mTop != mLocation[1] || mUpdateWindowNeeded || mReportDrawNeeded || redrawNeeded) {
        if (DEBUG)
            Log.i(TAG, "Changes: creating=" + creating + " format=" + formatChanged + " size=" + sizeChanged + " visible=" + visibleChanged + " left=" + (mLeft != mLocation[0]) + " top=" + (mTop != mLocation[1]));
        try {
            final boolean visible = mVisible = mRequestedVisible;
            mLeft = mLocation[0];
            mTop = mLocation[1];
            mWidth = myWidth;
            mHeight = myHeight;
            mFormat = mRequestedFormat;
            // Scaling/Translate window's layout here because mLayout is not used elsewhere.
            // Places the window relative
            mLayout.x = mLeft;
            mLayout.y = mTop;
            mLayout.width = getWidth();
            mLayout.height = getHeight();
            if (mTranslator != null) {
                mTranslator.translateLayoutParamsInAppWindowToScreen(mLayout);
            }
            mLayout.format = mRequestedFormat;
            mLayout.flags |= WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_SCALED | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;
            if (!getContext().getResources().getCompatibilityInfo().supportsScreen()) {
                mLayout.privateFlags |= WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;
            }
            mLayout.privateFlags |= WindowManager.LayoutParams.PRIVATE_FLAG_NO_MOVE_ANIMATION;
            if (mWindow == null) {
                Display display = getDisplay();
                mWindow = new MyWindow(this);
                mLayout.type = mWindowType;
                mLayout.gravity = Gravity.START | Gravity.TOP;
                mSession.addToDisplayWithoutInputChannel(mWindow, mWindow.mSeq, mLayout, mVisible ? VISIBLE : GONE, display.getDisplayId(), mContentInsets, mStableInsets);
            }
            boolean realSizeChanged;
            boolean reportDrawNeeded;
            int relayoutResult;
            mSurfaceLock.lock();
            try {
                mUpdateWindowNeeded = false;
                reportDrawNeeded = mReportDrawNeeded;
                mReportDrawNeeded = false;
                mDrawingStopped = !visible;
                if (DEBUG)
                    Log.i(TAG, "Cur surface: " + mSurface);
                relayoutResult = mSession.relayout(mWindow, mWindow.mSeq, mLayout, mWidth, mHeight, visible ? VISIBLE : GONE, WindowManagerGlobal.RELAYOUT_DEFER_SURFACE_DESTROY, mWinFrame, mOverscanInsets, mContentInsets, mVisibleInsets, mStableInsets, mConfiguration, mNewSurface);
                if ((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0) {
                    mReportDrawNeeded = true;
                }
                if (DEBUG)
                    Log.i(TAG, "New surface: " + mNewSurface + ", vis=" + visible + ", frame=" + mWinFrame);
                mSurfaceFrame.left = 0;
                mSurfaceFrame.top = 0;
                if (mTranslator == null) {
                    mSurfaceFrame.right = mWinFrame.width();
                    mSurfaceFrame.bottom = mWinFrame.height();
                } else {
                    float appInvertedScale = mTranslator.applicationInvertedScale;
                    mSurfaceFrame.right = (int) (mWinFrame.width() * appInvertedScale + 0.5f);
                    mSurfaceFrame.bottom = (int) (mWinFrame.height() * appInvertedScale + 0.5f);
                }
                final int surfaceWidth = mSurfaceFrame.right;
                final int surfaceHeight = mSurfaceFrame.bottom;
                realSizeChanged = mLastSurfaceWidth != surfaceWidth || mLastSurfaceHeight != surfaceHeight;
                mLastSurfaceWidth = surfaceWidth;
                mLastSurfaceHeight = surfaceHeight;
            } finally {
                mSurfaceLock.unlock();
            }
            try {
                redrawNeeded |= creating | reportDrawNeeded;
                SurfaceHolder.Callback[] callbacks = null;
                final boolean surfaceChanged = (relayoutResult & WindowManagerGlobal.RELAYOUT_RES_SURFACE_CHANGED) != 0;
                if (mSurfaceCreated && (surfaceChanged || (!visible && visibleChanged))) {
                    mSurfaceCreated = false;
                    if (mSurface.isValid()) {
                        if (DEBUG)
                            Log.i(TAG, "visibleChanged -- surfaceDestroyed");
                        callbacks = getSurfaceCallbacks();
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceDestroyed(mSurfaceHolder);
                        }
                    }
                }
                mSurface.transferFrom(mNewSurface);
                if (visible && mSurface.isValid()) {
                    if (!mSurfaceCreated && (surfaceChanged || visibleChanged)) {
                        mSurfaceCreated = true;
                        mIsCreating = true;
                        if (DEBUG)
                            Log.i(TAG, "visibleChanged -- surfaceCreated");
                        if (callbacks == null) {
                            callbacks = getSurfaceCallbacks();
                        }
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceCreated(mSurfaceHolder);
                        }
                    }
                    if (creating || formatChanged || sizeChanged || visibleChanged || realSizeChanged) {
                        if (DEBUG)
                            Log.i(TAG, "surfaceChanged -- format=" + mFormat + " w=" + myWidth + " h=" + myHeight);
                        if (callbacks == null) {
                            callbacks = getSurfaceCallbacks();
                        }
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceChanged(mSurfaceHolder, mFormat, myWidth, myHeight);
                        }
                    }
                    if (redrawNeeded) {
                        if (DEBUG)
                            Log.i(TAG, "surfaceRedrawNeeded");
                        if (callbacks == null) {
                            callbacks = getSurfaceCallbacks();
                        }
                        for (SurfaceHolder.Callback c : callbacks) {
                            if (c instanceof SurfaceHolder.Callback2) {
                                ((SurfaceHolder.Callback2) c).surfaceRedrawNeeded(mSurfaceHolder);
                            }
                        }
                    }
                }
            } finally {
                mIsCreating = false;
                if (redrawNeeded) {
                    if (DEBUG)
                        Log.i(TAG, "finishedDrawing");
                    mSession.finishDrawing(mWindow);
                }
                mSession.performDeferredDestroy(mWindow);
            }
        } catch (RemoteException ex) {
        }
        if (DEBUG)
            Log.v(TAG, "Layout: x=" + mLayout.x + " y=" + mLayout.y + " w=" + mLayout.width + " h=" + mLayout.height + ", frame=" + mSurfaceFrame);
    }
}
Body of Second Method:
{
    if (!mHaveFrame) {
        return;
    }
    ViewRootImpl viewRoot = getViewRootImpl();
    if (viewRoot != null) {
        mTranslator = viewRoot.mTranslator;
    }
    if (mTranslator != null) {
        mSurface.setCompatibilityTranslator(mTranslator);
    }
    int myWidth = mRequestedWidth;
    if (myWidth <= 0)
        myWidth = getWidth();
    int myHeight = mRequestedHeight;
    if (myHeight <= 0)
        myHeight = getHeight();
    getLocationInWindow(mLocation);
    final boolean creating = mWindow == null;
    final boolean formatChanged = mFormat != mRequestedFormat;
    final boolean sizeChanged = mWidth != myWidth || mHeight != myHeight;
    final boolean visibleChanged = mVisible != mRequestedVisible;
    if (force || creating || formatChanged || sizeChanged || visibleChanged || mLeft != mLocation[0] || mTop != mLocation[1] || mUpdateWindowNeeded || mReportDrawNeeded || redrawNeeded) {
        if (DEBUG)
            Log.i(TAG, "Changes: creating=" + creating + " format=" + formatChanged + " size=" + sizeChanged + " visible=" + visibleChanged + " left=" + (mLeft != mLocation[0]) + " top=" + (mTop != mLocation[1]));
        try {
            final boolean visible = mVisible = mRequestedVisible;
            mLeft = mLocation[0];
            mTop = mLocation[1];
            mWidth = myWidth;
            mHeight = myHeight;
            mFormat = mRequestedFormat;
            // Scaling/Translate window's layout here because mLayout is not used elsewhere.
            // Places the window relative
            mLayout.x = mLeft;
            mLayout.y = mTop;
            mLayout.width = getWidth();
            mLayout.height = getHeight();
            if (mTranslator != null) {
                mTranslator.translateLayoutParamsInAppWindowToScreen(mLayout);
            }
            mLayout.format = mRequestedFormat;
            mLayout.flags |= WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_SCALED | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;
            if (!getContext().getResources().getCompatibilityInfo().supportsScreen()) {
                mLayout.privateFlags |= WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;
            }
            mLayout.privateFlags |= WindowManager.LayoutParams.PRIVATE_FLAG_NO_MOVE_ANIMATION;
            if (mWindow == null) {
                Display display = getDisplay();
                mWindow = new MyWindow(this);
                mLayout.type = mWindowType;
                mLayout.gravity = Gravity.START | Gravity.TOP;
                mSession.addToDisplayWithoutInputChannel(mWindow, mWindow.mSeq, mLayout, mVisible ? VISIBLE : GONE, display.getDisplayId(), mContentInsets, mStableInsets);
            }
            boolean realSizeChanged;
            boolean reportDrawNeeded;
            int relayoutResult;
            mSurfaceLock.lock();
            try {
                mUpdateWindowNeeded = false;
                reportDrawNeeded = mReportDrawNeeded;
                mReportDrawNeeded = false;
                mDrawingStopped = !visible;
                if (DEBUG)
                    Log.i(TAG, "Cur surface: " + mSurface);
                relayoutResult = mSession.relayout(mWindow, mWindow.mSeq, mLayout, mWidth, mHeight, visible ? VISIBLE : GONE, WindowManagerGlobal.RELAYOUT_DEFER_SURFACE_DESTROY, mWinFrame, mOverscanInsets, mContentInsets, mVisibleInsets, mStableInsets, mOutsets, mConfiguration, mNewSurface);
                if ((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0) {
                    reportDrawNeeded = true;
                }
                if (DEBUG)
                    Log.i(TAG, "New surface: " + mNewSurface + ", vis=" + visible + ", frame=" + mWinFrame);
                mSurfaceFrame.left = 0;
                mSurfaceFrame.top = 0;
                if (mTranslator == null) {
                    mSurfaceFrame.right = mWinFrame.width();
                    mSurfaceFrame.bottom = mWinFrame.height();
                } else {
                    float appInvertedScale = mTranslator.applicationInvertedScale;
                    mSurfaceFrame.right = (int) (mWinFrame.width() * appInvertedScale + 0.5f);
                    mSurfaceFrame.bottom = (int) (mWinFrame.height() * appInvertedScale + 0.5f);
                }
                final int surfaceWidth = mSurfaceFrame.right;
                final int surfaceHeight = mSurfaceFrame.bottom;
                realSizeChanged = mLastSurfaceWidth != surfaceWidth || mLastSurfaceHeight != surfaceHeight;
                mLastSurfaceWidth = surfaceWidth;
                mLastSurfaceHeight = surfaceHeight;
            } finally {
                mSurfaceLock.unlock();
            }
            try {
                redrawNeeded |= creating | reportDrawNeeded;
                SurfaceHolder.Callback[] callbacks = null;
                final boolean surfaceChanged = (relayoutResult & WindowManagerGlobal.RELAYOUT_RES_SURFACE_CHANGED) != 0;
                if (mSurfaceCreated && (surfaceChanged || (!visible && visibleChanged))) {
                    mSurfaceCreated = false;
                    if (mSurface.isValid()) {
                        if (DEBUG)
                            Log.i(TAG, "visibleChanged -- surfaceDestroyed");
                        callbacks = getSurfaceCallbacks();
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceDestroyed(mSurfaceHolder);
                        }
                    }
                }
                mSurface.transferFrom(mNewSurface);
                if (visible && mSurface.isValid()) {
                    if (!mSurfaceCreated && (surfaceChanged || visibleChanged)) {
                        mSurfaceCreated = true;
                        mIsCreating = true;
                        if (DEBUG)
                            Log.i(TAG, "visibleChanged -- surfaceCreated");
                        if (callbacks == null) {
                            callbacks = getSurfaceCallbacks();
                        }
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceCreated(mSurfaceHolder);
                        }
                    }
                    if (creating || formatChanged || sizeChanged || visibleChanged || realSizeChanged) {
                        if (DEBUG)
                            Log.i(TAG, "surfaceChanged -- format=" + mFormat + " w=" + myWidth + " h=" + myHeight);
                        if (callbacks == null) {
                            callbacks = getSurfaceCallbacks();
                        }
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceChanged(mSurfaceHolder, mFormat, myWidth, myHeight);
                        }
                    }
                    if (redrawNeeded) {
                        if (DEBUG)
                            Log.i(TAG, "surfaceRedrawNeeded");
                        if (callbacks == null) {
                            callbacks = getSurfaceCallbacks();
                        }
                        for (SurfaceHolder.Callback c : callbacks) {
                            if (c instanceof SurfaceHolder.Callback2) {
                                ((SurfaceHolder.Callback2) c).surfaceRedrawNeeded(mSurfaceHolder);
                            }
                        }
                    }
                }
            } finally {
                mIsCreating = false;
                if (redrawNeeded) {
                    if (DEBUG)
                        Log.i(TAG, "finishedDrawing");
                    mSession.finishDrawing(mWindow);
                }
                mSession.performDeferredDestroy(mWindow);
            }
        } catch (RemoteException ex) {
        }
        if (DEBUG)
            Log.v(TAG, "Layout: x=" + mLayout.x + " y=" + mLayout.y + " w=" + mLayout.width + " h=" + mLayout.height + ", frame=" + mSurfaceFrame);
    }
}
------------------------
Find a silently evolved API code:android.view.ViewRootImpl.setView:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * We have one child
 */

Body of Frist Method:
{
    synchronized (this) {
        if (mView == null) {
            mView = view;
            mAttachInfo.mDisplayState = mDisplay.getState();
            mDisplayManager.registerDisplayListener(mDisplayListener, mHandler);
            mViewLayoutDirectionInitial = mView.getRawLayoutDirection();
            mFallbackEventHandler.setView(view);
            mWindowAttributes.copyFrom(attrs);
            if (mWindowAttributes.packageName == null) {
                mWindowAttributes.packageName = mBasePackageName;
            }
            attrs = mWindowAttributes;
            // Keep track of the actual window flags supplied by the client.
            mClientWindowLayoutFlags = attrs.flags;
            setAccessibilityFocus(null, null);
            if (view instanceof RootViewSurfaceTaker) {
                mSurfaceHolderCallback = ((RootViewSurfaceTaker) view).willYouTakeTheSurface();
                if (mSurfaceHolderCallback != null) {
                    mSurfaceHolder = new TakenSurfaceHolder();
                    mSurfaceHolder.setFormat(PixelFormat.UNKNOWN);
                }
            }
            // Compute surface insets required to draw at specified Z value.
            // TODO: Use real shadow insets for a constant max Z.
            final int surfaceInset = (int) Math.ceil(view.getZ() * 2);
            attrs.surfaceInsets.set(surfaceInset, surfaceInset, surfaceInset, surfaceInset);
            CompatibilityInfo compatibilityInfo = mDisplayAdjustments.getCompatibilityInfo();
            mTranslator = compatibilityInfo.getTranslator();
            mDisplayAdjustments.setActivityToken(attrs.token);
            // If the application owns the surface, don't enable hardware acceleration
            if (mSurfaceHolder == null) {
                enableHardwareAcceleration(attrs);
            }
            boolean restore = false;
            if (mTranslator != null) {
                mSurface.setCompatibilityTranslator(mTranslator);
                restore = true;
                attrs.backup();
                mTranslator.translateWindowLayout(attrs);
            }
            if (DEBUG_LAYOUT)
                Log.d(TAG, "WindowLayout in setView:" + attrs);
            if (!compatibilityInfo.supportsScreen()) {
                attrs.privateFlags |= WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;
                mLastInCompatMode = true;
            }
            mSoftInputMode = attrs.softInputMode;
            mWindowAttributesChanged = true;
            mWindowAttributesChangesFlag = WindowManager.LayoutParams.EVERYTHING_CHANGED;
            mAttachInfo.mRootView = view;
            mAttachInfo.mScalingRequired = mTranslator != null;
            mAttachInfo.mApplicationScale = mTranslator == null ? 1.0f : mTranslator.applicationScale;
            if (panelParentView != null) {
                mAttachInfo.mPanelParentWindowToken = panelParentView.getApplicationWindowToken();
            }
            mAdded = true;
            int res;
            /* = WindowManagerImpl.ADD_OKAY; */
            // Schedule the first layout -before- adding to the window
            // manager, to make sure we do the relayout before receiving
            // any other events from the system.
            requestLayout();
            if ((mWindowAttributes.inputFeatures & WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == 0) {
                mInputChannel = new InputChannel();
            }
            try {
                mOrigWindowType = mWindowAttributes.type;
                mAttachInfo.mRecomputeGlobalAttributes = true;
                collectViewAttributes();
                res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes, getHostVisibility(), mDisplay.getDisplayId(), mAttachInfo.mContentInsets, mAttachInfo.mStableInsets, mInputChannel);
            } catch (RemoteException e) {
                mAdded = false;
                mView = null;
                mAttachInfo.mRootView = null;
                mInputChannel = null;
                mFallbackEventHandler.setView(null);
                unscheduleTraversals();
                setAccessibilityFocus(null, null);
                throw new RuntimeException("Adding window failed", e);
            } finally {
                if (restore) {
                    attrs.restore();
                }
            }
            if (mTranslator != null) {
                mTranslator.translateRectInScreenToAppWindow(mAttachInfo.mContentInsets);
            }
            mPendingOverscanInsets.set(0, 0, 0, 0);
            mPendingContentInsets.set(mAttachInfo.mContentInsets);
            mPendingStableInsets.set(mAttachInfo.mStableInsets);
            mPendingVisibleInsets.set(0, 0, 0, 0);
            if (DEBUG_LAYOUT)
                Log.v(TAG, "Added window " + mWindow);
            if (res < WindowManagerGlobal.ADD_OKAY) {
                mAttachInfo.mRootView = null;
                mAdded = false;
                mFallbackEventHandler.setView(null);
                unscheduleTraversals();
                setAccessibilityFocus(null, null);
                switch(res) {
                    case WindowManagerGlobal.ADD_BAD_APP_TOKEN:
                    case WindowManagerGlobal.ADD_BAD_SUBWINDOW_TOKEN:
                        throw new WindowManager.BadTokenException("Unable to add window -- token " + attrs.token + " is not valid; is your activity running?");
                    case WindowManagerGlobal.ADD_NOT_APP_TOKEN:
                        throw new WindowManager.BadTokenException("Unable to add window -- token " + attrs.token + " is not for an application");
                    case WindowManagerGlobal.ADD_APP_EXITING:
                        throw new WindowManager.BadTokenException("Unable to add window -- app for token " + attrs.token + " is exiting");
                    case WindowManagerGlobal.ADD_DUPLICATE_ADD:
                        throw new WindowManager.BadTokenException("Unable to add window -- window " + mWindow + " has already been added");
                    case WindowManagerGlobal.ADD_STARTING_NOT_NEEDED:
                        // right away, anyway.
                        return;
                    case WindowManagerGlobal.ADD_MULTIPLE_SINGLETON:
                        throw new WindowManager.BadTokenException("Unable to add window " + mWindow + " -- another window of this type already exists");
                    case WindowManagerGlobal.ADD_PERMISSION_DENIED:
                        throw new WindowManager.BadTokenException("Unable to add window " + mWindow + " -- permission denied for this window type");
                    case WindowManagerGlobal.ADD_INVALID_DISPLAY:
                        throw new WindowManager.InvalidDisplayException("Unable to add window " + mWindow + " -- the specified display can not be found");
                    case WindowManagerGlobal.ADD_INVALID_TYPE:
                        throw new WindowManager.InvalidDisplayException("Unable to add window " + mWindow + " -- the specified window type is not valid");
                }
                throw new RuntimeException("Unable to add window -- unknown error code " + res);
            }
            if (view instanceof RootViewSurfaceTaker) {
                mInputQueueCallback = ((RootViewSurfaceTaker) view).willYouTakeTheInputQueue();
            }
            if (mInputChannel != null) {
                if (mInputQueueCallback != null) {
                    mInputQueue = new InputQueue();
                    mInputQueueCallback.onInputQueueCreated(mInputQueue);
                }
                mInputEventReceiver = new WindowInputEventReceiver(mInputChannel, Looper.myLooper());
            }
            view.assignParent(this);
            mAddedTouchMode = (res & WindowManagerGlobal.ADD_FLAG_IN_TOUCH_MODE) != 0;
            mAppVisible = (res & WindowManagerGlobal.ADD_FLAG_APP_VISIBLE) != 0;
            if (mAccessibilityManager.isEnabled()) {
                mAccessibilityInteractionConnectionManager.ensureConnection();
            }
            if (view.getImportantForAccessibility() == View.IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
                view.setImportantForAccessibility(View.IMPORTANT_FOR_ACCESSIBILITY_YES);
            }
            // Set up the input pipeline.
            CharSequence counterSuffix = attrs.getTitle();
            mSyntheticInputStage = new SyntheticInputStage();
            InputStage viewPostImeStage = new ViewPostImeInputStage(mSyntheticInputStage);
            InputStage nativePostImeStage = new NativePostImeInputStage(viewPostImeStage, "aq:native-post-ime:" + counterSuffix);
            InputStage earlyPostImeStage = new EarlyPostImeInputStage(nativePostImeStage);
            InputStage imeStage = new ImeInputStage(earlyPostImeStage, "aq:ime:" + counterSuffix);
            InputStage viewPreImeStage = new ViewPreImeInputStage(imeStage);
            InputStage nativePreImeStage = new NativePreImeInputStage(viewPreImeStage, "aq:native-pre-ime:" + counterSuffix);
            mFirstInputStage = nativePreImeStage;
            mFirstPostImeInputStage = earlyPostImeStage;
            mPendingInputEventQueueLengthCounterName = "aq:pending:" + counterSuffix;
        }
    }
}
Body of Second Method:
{
    synchronized (this) {
        if (mView == null) {
            mView = view;
            mAttachInfo.mDisplayState = mDisplay.getState();
            mDisplayManager.registerDisplayListener(mDisplayListener, mHandler);
            mViewLayoutDirectionInitial = mView.getRawLayoutDirection();
            mFallbackEventHandler.setView(view);
            mWindowAttributes.copyFrom(attrs);
            if (mWindowAttributes.packageName == null) {
                mWindowAttributes.packageName = mBasePackageName;
            }
            attrs = mWindowAttributes;
            // Keep track of the actual window flags supplied by the client.
            mClientWindowLayoutFlags = attrs.flags;
            setAccessibilityFocus(null, null);
            if (view instanceof RootViewSurfaceTaker) {
                mSurfaceHolderCallback = ((RootViewSurfaceTaker) view).willYouTakeTheSurface();
                if (mSurfaceHolderCallback != null) {
                    mSurfaceHolder = new TakenSurfaceHolder();
                    mSurfaceHolder.setFormat(PixelFormat.UNKNOWN);
                }
            }
            // TODO: Use real shadow insets for a constant max Z.
            if (!attrs.hasManualSurfaceInsets) {
                final int surfaceInset = (int) Math.ceil(view.getZ() * 2);
                attrs.surfaceInsets.set(surfaceInset, surfaceInset, surfaceInset, surfaceInset);
            }
            CompatibilityInfo compatibilityInfo = mDisplayAdjustments.getCompatibilityInfo();
            mTranslator = compatibilityInfo.getTranslator();
            // If the application owns the surface, don't enable hardware acceleration
            if (mSurfaceHolder == null) {
                enableHardwareAcceleration(attrs);
            }
            boolean restore = false;
            if (mTranslator != null) {
                mSurface.setCompatibilityTranslator(mTranslator);
                restore = true;
                attrs.backup();
                mTranslator.translateWindowLayout(attrs);
            }
            if (DEBUG_LAYOUT)
                Log.d(TAG, "WindowLayout in setView:" + attrs);
            if (!compatibilityInfo.supportsScreen()) {
                attrs.privateFlags |= WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;
                mLastInCompatMode = true;
            }
            mSoftInputMode = attrs.softInputMode;
            mWindowAttributesChanged = true;
            mWindowAttributesChangesFlag = WindowManager.LayoutParams.EVERYTHING_CHANGED;
            mAttachInfo.mRootView = view;
            mAttachInfo.mScalingRequired = mTranslator != null;
            mAttachInfo.mApplicationScale = mTranslator == null ? 1.0f : mTranslator.applicationScale;
            if (panelParentView != null) {
                mAttachInfo.mPanelParentWindowToken = panelParentView.getApplicationWindowToken();
            }
            mAdded = true;
            int res;
            /* = WindowManagerImpl.ADD_OKAY; */
            // Schedule the first layout -before- adding to the window
            // manager, to make sure we do the relayout before receiving
            // any other events from the system.
            requestLayout();
            if ((mWindowAttributes.inputFeatures & WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == 0) {
                mInputChannel = new InputChannel();
            }
            try {
                mOrigWindowType = mWindowAttributes.type;
                mAttachInfo.mRecomputeGlobalAttributes = true;
                collectViewAttributes();
                res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes, getHostVisibility(), mDisplay.getDisplayId(), mAttachInfo.mContentInsets, mAttachInfo.mStableInsets, mAttachInfo.mOutsets, mInputChannel);
            } catch (RemoteException e) {
                mAdded = false;
                mView = null;
                mAttachInfo.mRootView = null;
                mInputChannel = null;
                mFallbackEventHandler.setView(null);
                unscheduleTraversals();
                setAccessibilityFocus(null, null);
                throw new RuntimeException("Adding window failed", e);
            } finally {
                if (restore) {
                    attrs.restore();
                }
            }
            if (mTranslator != null) {
                mTranslator.translateRectInScreenToAppWindow(mAttachInfo.mContentInsets);
            }
            mPendingOverscanInsets.set(0, 0, 0, 0);
            mPendingContentInsets.set(mAttachInfo.mContentInsets);
            mPendingStableInsets.set(mAttachInfo.mStableInsets);
            mPendingVisibleInsets.set(0, 0, 0, 0);
            if (DEBUG_LAYOUT)
                Log.v(TAG, "Added window " + mWindow);
            if (res < WindowManagerGlobal.ADD_OKAY) {
                mAttachInfo.mRootView = null;
                mAdded = false;
                mFallbackEventHandler.setView(null);
                unscheduleTraversals();
                setAccessibilityFocus(null, null);
                switch(res) {
                    case WindowManagerGlobal.ADD_BAD_APP_TOKEN:
                    case WindowManagerGlobal.ADD_BAD_SUBWINDOW_TOKEN:
                        throw new WindowManager.BadTokenException("Unable to add window -- token " + attrs.token + " is not valid; is your activity running?");
                    case WindowManagerGlobal.ADD_NOT_APP_TOKEN:
                        throw new WindowManager.BadTokenException("Unable to add window -- token " + attrs.token + " is not for an application");
                    case WindowManagerGlobal.ADD_APP_EXITING:
                        throw new WindowManager.BadTokenException("Unable to add window -- app for token " + attrs.token + " is exiting");
                    case WindowManagerGlobal.ADD_DUPLICATE_ADD:
                        throw new WindowManager.BadTokenException("Unable to add window -- window " + mWindow + " has already been added");
                    case WindowManagerGlobal.ADD_STARTING_NOT_NEEDED:
                        // right away, anyway.
                        return;
                    case WindowManagerGlobal.ADD_MULTIPLE_SINGLETON:
                        throw new WindowManager.BadTokenException("Unable to add window " + mWindow + " -- another window of this type already exists");
                    case WindowManagerGlobal.ADD_PERMISSION_DENIED:
                        throw new WindowManager.BadTokenException("Unable to add window " + mWindow + " -- permission denied for this window type");
                    case WindowManagerGlobal.ADD_INVALID_DISPLAY:
                        throw new WindowManager.InvalidDisplayException("Unable to add window " + mWindow + " -- the specified display can not be found");
                    case WindowManagerGlobal.ADD_INVALID_TYPE:
                        throw new WindowManager.InvalidDisplayException("Unable to add window " + mWindow + " -- the specified window type is not valid");
                }
                throw new RuntimeException("Unable to add window -- unknown error code " + res);
            }
            if (view instanceof RootViewSurfaceTaker) {
                mInputQueueCallback = ((RootViewSurfaceTaker) view).willYouTakeTheInputQueue();
            }
            if (mInputChannel != null) {
                if (mInputQueueCallback != null) {
                    mInputQueue = new InputQueue();
                    mInputQueueCallback.onInputQueueCreated(mInputQueue);
                }
                mInputEventReceiver = new WindowInputEventReceiver(mInputChannel, Looper.myLooper());
            }
            view.assignParent(this);
            mAddedTouchMode = (res & WindowManagerGlobal.ADD_FLAG_IN_TOUCH_MODE) != 0;
            mAppVisible = (res & WindowManagerGlobal.ADD_FLAG_APP_VISIBLE) != 0;
            if (mAccessibilityManager.isEnabled()) {
                mAccessibilityInteractionConnectionManager.ensureConnection();
            }
            if (view.getImportantForAccessibility() == View.IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
                view.setImportantForAccessibility(View.IMPORTANT_FOR_ACCESSIBILITY_YES);
            }
            // Set up the input pipeline.
            CharSequence counterSuffix = attrs.getTitle();
            mSyntheticInputStage = new SyntheticInputStage();
            InputStage viewPostImeStage = new ViewPostImeInputStage(mSyntheticInputStage);
            InputStage nativePostImeStage = new NativePostImeInputStage(viewPostImeStage, "aq:native-post-ime:" + counterSuffix);
            InputStage earlyPostImeStage = new EarlyPostImeInputStage(nativePostImeStage);
            InputStage imeStage = new ImeInputStage(earlyPostImeStage, "aq:ime:" + counterSuffix);
            InputStage viewPreImeStage = new ViewPreImeInputStage(imeStage);
            InputStage nativePreImeStage = new NativePreImeInputStage(viewPreImeStage, "aq:native-pre-ime:" + counterSuffix);
            mFirstInputStage = nativePreImeStage;
            mFirstPostImeInputStage = earlyPostImeStage;
            mPendingInputEventQueueLengthCounterName = "aq:pending:" + counterSuffix;
        }
    }
}
------------------------
Find a silently evolved API code:android.media.AudioManager.unregisterMediaButtonIntent:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    MediaSessionLegacyHelper helper = MediaSessionLegacyHelper.getHelper(mContext);
    helper.removeMediaButtonListener(pi);
}
Body of Second Method:
{
    MediaSessionLegacyHelper helper = MediaSessionLegacyHelper.getHelper(getContext());
    helper.removeMediaButtonListener(pi);
}
------------------------
Find a silently evolved API code:android.view.animation.Transformation.postCompose:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Like {@link #compose(Transformation)} but does this.postConcat(t) of
 * the transformation matrix.
 * @hide
 */

Body of Frist Method:
{
    mAlpha *= t.getAlpha();
    mMatrix.postConcat(t.getMatrix());
    if (t.mHasClipRect) {
        setClipRect(t.getClipRect());
    }
}
Body of Second Method:
{
    mAlpha *= t.getAlpha();
    mMatrix.postConcat(t.getMatrix());
    if (t.mHasClipRect) {
        Rect bounds = t.getClipRect();
        if (mHasClipRect) {
            setClipRect(mClipRect.left + bounds.left, mClipRect.top + bounds.top, mClipRect.right + bounds.right, mClipRect.bottom + bounds.bottom);
        } else {
            setClipRect(bounds);
        }
    }
}
------------------------
Find a silently evolved API code:android.preference.GenericInflater.createItem:COMMENT
Method Modifier: public      final       hidden      
Comment:/**
 * Low-level function for instantiating by name. This attempts to
 * instantiate class of the given <var>name</var> found in this
 * inflater's ClassLoader.
 *
 * <p>
 * There are two things that can happen in an error case: either the
 * exception describing the error will be thrown, or a null will be
 * returned. You must deal with both possibilities -- the former will happen
 * the first time createItem() is called for a class of a particular name,
 * the latter every time there-after for that class name.
 *
 * @param name The full name of the class to be instantiated.
 * @param attrs The XML attributes supplied for this instance.
 *
 * @return The newly instantied item, or null.
 */

Body of Frist Method:
{
    Constructor constructor = (Constructor) sConstructorMap.get(name);
    try {
        if (null == constructor) {
            // Class not found in the cache, see if it's real,
            // and try to add it
            Class clazz = mContext.getClassLoader().loadClass(prefix != null ? (prefix + name) : name);
            constructor = clazz.getConstructor(mConstructorSignature);
            sConstructorMap.put(name, constructor);
        }
        Object[] args = mConstructorArgs;
        args[1] = attrs;
        return (T) constructor.newInstance(args);
    } catch (NoSuchMethodException e) {
        InflateException ie = new InflateException(attrs.getPositionDescription() + ": Error inflating class " + (prefix != null ? (prefix + name) : name));
        ie.initCause(e);
        throw ie;
    } catch (ClassNotFoundException e) {
        // If loadClass fails, we should propagate the exception.
        throw e;
    } catch (Exception e) {
        InflateException ie = new InflateException(attrs.getPositionDescription() + ": Error inflating class " + constructor.getClass().getName());
        ie.initCause(e);
        throw ie;
    }
}
Body of Second Method:
{
    Constructor constructor = (Constructor) sConstructorMap.get(name);
    try {
        if (null == constructor) {
            // Class not found in the cache, see if it's real,
            // and try to add it
            Class clazz = mContext.getClassLoader().loadClass(prefix != null ? (prefix + name) : name);
            constructor = clazz.getConstructor(mConstructorSignature);
            constructor.setAccessible(true);
            sConstructorMap.put(name, constructor);
        }
        Object[] args = mConstructorArgs;
        args[1] = attrs;
        return (T) constructor.newInstance(args);
    } catch (NoSuchMethodException e) {
        InflateException ie = new InflateException(attrs.getPositionDescription() + ": Error inflating class " + (prefix != null ? (prefix + name) : name));
        ie.initCause(e);
        throw ie;
    } catch (ClassNotFoundException e) {
        // If loadClass fails, we should propagate the exception.
        throw e;
    } catch (Exception e) {
        InflateException ie = new InflateException(attrs.getPositionDescription() + ": Error inflating class " + constructor.getClass().getName());
        ie.initCause(e);
        throw ie;
    }
}
------------------------
Find a silently evolved API code:android.view.Display.getRefreshRate:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the refresh rate of this display in frames per second.
 */

Body of Frist Method:
{
    synchronized (this) {
        updateDisplayInfoLocked();
        return mDisplayInfo.refreshRate;
    }
}
Body of Second Method:
{
    synchronized (this) {
        updateDisplayInfoLocked();
        return mDisplayInfo.getMode().getRefreshRate();
    }
}
------------------------
Find a silently evolved API code:android.widget.DayPickerView.onRangeChanged:COMMENT
Method Modifier: public      
Comment:/**
 * Handles changes to date range.
 */

Body of Frist Method:
{
    mAdapter.setRange(mMinDate, mMaxDate);
    // Changing the min/max date changes the selection position since we
    // don't really have stable IDs. Jumps immediately to the new position.
    goTo(mSelectedDay.getTimeInMillis(), false, false, true);
}
Body of Second Method:
{
    mAdapter.setRange(mMinDate, mMaxDate);
    // Changing the min/max date changes the selection position since we
    // don't really have stable IDs. Jumps immediately to the new position.
    setDate(mSelectedDay.getTimeInMillis(), false, false);
    updateButtonVisibility(mViewPager.getCurrentItem());
}
------------------------
Find a silently evolved API code:android.graphics.Bitmap.getPixel:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the {@link Color} at the specified location. Throws an exception
 * if x or y are out of bounds (negative or >= to the width or height
 * respectively). The returned color is a non-premultiplied ARGB value.
 *
 * @param x    The x coordinate (0...width-1) of the pixel to return
 * @param y    The y coordinate (0...height-1) of the pixel to return
 * @return     The argb {@link Color} at the specified coordinate
 * @throws IllegalArgumentException if x, y exceed the bitmap's bounds
 */

Body of Frist Method:
{
    checkRecycled("Can't call getPixel() on a recycled bitmap");
    checkPixelAccess(x, y);
    return nativeGetPixel(mNativeBitmap, x, y);
}
Body of Second Method:
{
    checkRecycled("Can't call getPixel() on a recycled bitmap");
    checkPixelAccess(x, y);
    return nativeGetPixel(mFinalizer.mNativeBitmap, x, y);
}
------------------------
Find a silently evolved API code:android.app.WallpaperManager.setBitmap:COMMENT
Method Modifier: public      
Comment:/**
 * Change the current system wallpaper to a bitmap.  The given bitmap is
 * converted to a PNG and stored as the wallpaper.  On success, the intent
 * {@link Intent#ACTION_WALLPAPER_CHANGED} is broadcast.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#SET_WALLPAPER}.
 *
 * @param bitmap The bitmap to save.
 *
 * @throws IOException If an error occurs reverting to the built-in
 * wallpaper.
 */

Body of Frist Method:
{
    if (sGlobals.mService == null) {
        Log.w(TAG, "WallpaperService not running");
        return;
    }
    try {
        ParcelFileDescriptor fd = sGlobals.mService.setWallpaper(null);
        if (fd == null) {
            return;
        }
        FileOutputStream fos = null;
        try {
            fos = new ParcelFileDescriptor.AutoCloseOutputStream(fd);
            bitmap.compress(Bitmap.CompressFormat.PNG, 90, fos);
        } finally {
            if (fos != null) {
                fos.close();
            }
        }
    } catch (RemoteException e) {
    // Ignore
    }
}
Body of Second Method:
{
    if (sGlobals.mService == null) {
        Log.w(TAG, "WallpaperService not running");
        return;
    }
    try {
        ParcelFileDescriptor fd = sGlobals.mService.setWallpaper(null, mContext.getOpPackageName());
        if (fd == null) {
            return;
        }
        FileOutputStream fos = null;
        try {
            fos = new ParcelFileDescriptor.AutoCloseOutputStream(fd);
            bitmap.compress(Bitmap.CompressFormat.PNG, 90, fos);
        } finally {
            if (fos != null) {
                fos.close();
            }
        }
    } catch (RemoteException e) {
    // Ignore
    }
}
------------------------
Find a silently evolved API code:android.widget.ZoomButtonsController.setVisible:COMMENT
Method Modifier: public      
Comment:/**
 * Sets whether the zoom controls should be visible to the user.
 *
 * @param visible Whether the zoom controls should be visible to the user.
 */

Body of Frist Method:
{
    if (visible) {
        if (mOwnerView.getWindowToken() == null) {
            /*
                 * We need a window token to show ourselves, maybe the owner's
                 * window hasn't been created yet but it will have been by the
                 * time the looper is idle, so post the setVisible(true) call.
                 */
            if (!mHandler.hasMessages(MSG_POST_SET_VISIBLE)) {
                mHandler.sendEmptyMessage(MSG_POST_SET_VISIBLE);
            }
            return;
        }
        dismissControlsDelayed(ZOOM_CONTROLS_TIMEOUT);
    }
    if (mIsVisible == visible) {
        return;
    }
    mIsVisible = visible;
    if (visible) {
        if (mContainerLayoutParams.token == null) {
            mContainerLayoutParams.token = mOwnerView.getWindowToken();
        }
        mWindowManager.addView(mContainer, mContainerLayoutParams);
        if (mPostedVisibleInitializer == null) {
            mPostedVisibleInitializer = new Runnable() {

                public void run() {
                    refreshPositioningVariables();
                    if (mCallback != null) {
                        mCallback.onVisibilityChanged(true);
                    }
                }
            };
        }
        mHandler.post(mPostedVisibleInitializer);
        // Handle configuration changes when visible
        mContext.registerReceiver(mConfigurationChangedReceiver, mConfigurationChangedFilter);
        // Steal touches events from the owner
        mOwnerView.setOnTouchListener(this);
        mReleaseTouchListenerOnUp = false;
    } else {
        // Don't want to steal any more touches
        if (mTouchTargetView != null) {
            // We are still stealing the touch events for this touch
            // sequence, so release the touch listener later
            mReleaseTouchListenerOnUp = true;
        } else {
            mOwnerView.setOnTouchListener(null);
        }
        // No longer care about configuration changes
        mContext.unregisterReceiver(mConfigurationChangedReceiver);
        mWindowManager.removeView(mContainer);
        mHandler.removeCallbacks(mPostedVisibleInitializer);
        if (mCallback != null) {
            mCallback.onVisibilityChanged(false);
        }
    }
}
Body of Second Method:
{
    if (visible) {
        if (mOwnerView.getWindowToken() == null) {
            /*
                 * We need a window token to show ourselves, maybe the owner's
                 * window hasn't been created yet but it will have been by the
                 * time the looper is idle, so post the setVisible(true) call.
                 */
            if (!mHandler.hasMessages(MSG_POST_SET_VISIBLE)) {
                mHandler.sendEmptyMessage(MSG_POST_SET_VISIBLE);
            }
            return;
        }
        dismissControlsDelayed(ZOOM_CONTROLS_TIMEOUT);
    }
    if (mIsVisible == visible) {
        return;
    }
    mIsVisible = visible;
    if (visible) {
        if (mContainerLayoutParams.token == null) {
            mContainerLayoutParams.token = mOwnerView.getWindowToken();
        }
        mWindowManager.addView(mContainer, mContainerLayoutParams);
        if (mPostedVisibleInitializer == null) {
            mPostedVisibleInitializer = new Runnable() {

                public void run() {
                    refreshPositioningVariables();
                    if (mCallback != null) {
                        mCallback.onVisibilityChanged(true);
                    }
                }
            };
        }
        mHandler.post(mPostedVisibleInitializer);
        // Handle configuration changes when visible
        mContext.registerReceiver(mConfigurationChangedReceiver, mConfigurationChangedFilter);
        // Steal touches events from the owner
        mOwnerView.setOnTouchListener(this);
        mReleaseTouchListenerOnUp = false;
    } else {
        // Don't want to steal any more touches
        if (mTouchTargetView != null) {
            // We are still stealing the touch events for this touch
            // sequence, so release the touch listener later
            mReleaseTouchListenerOnUp = true;
        } else {
            mOwnerView.setOnTouchListener(null);
        }
        // No longer care about configuration changes
        mContext.unregisterReceiver(mConfigurationChangedReceiver);
        mWindowManager.removeViewImmediate(mContainer);
        mHandler.removeCallbacks(mPostedVisibleInitializer);
        if (mCallback != null) {
            mCallback.onVisibilityChanged(false);
        }
    }
}
------------------------
Find a silently evolved API code:android.media.Image.setCropRect:COMMENT
Method Modifier: public      
Comment:/**
 * Set the crop rectangle associated with this frame.
 * <p>
 * The crop rectangle specifies the region of valid pixels in the image,
 * using coordinates in the largest-resolution plane.
 */

Body of Frist Method:
{
    if (cropRect != null) {
        // make a copy
        cropRect = new Rect(cropRect);
        cropRect.intersect(0, 0, getWidth(), getHeight());
    }
    mCropRect = cropRect;
}
Body of Second Method:
{
    throwISEIfImageIsInvalid();
    if (cropRect != null) {
        // make a copy
        cropRect = new Rect(cropRect);
        if (!cropRect.intersect(0, 0, getWidth(), getHeight())) {
            cropRect.setEmpty();
        }
    }
    mCropRect = cropRect;
}
------------------------
Find a silently evolved API code:android.view.LayoutInflater.parseRequestFocus:COMMENT
Method Modifier: private     
Comment:/**
 * Parses a <code>&lt;request-focus&gt;</code> element and requests focus on
 * the containing View.
 */

Body of Frist Method:
{
    int type;
    view.requestFocus();
    final int currentDepth = parser.getDepth();
    while (((type = parser.next()) != XmlPullParser.END_TAG || parser.getDepth() > currentDepth) && type != XmlPullParser.END_DOCUMENT) {
    // Empty
    }
}
Body of Second Method:
{
    view.requestFocus();
    consumeChildElements(parser);
}
------------------------
Find a silently evolved API code:android.hardware.camera2.params.StreamConfigurationMap.checkArgumentFormatSupported:COMMENT
Method Modifier: private     
Comment:// Check that the argument is supported by #getOutputFormats or #getInputFormats

Body of Frist Method:
{
    checkArgumentFormat(format);
    int[] formats = output ? getOutputFormats() : getInputFormats();
    for (int i = 0; i < formats.length; ++i) {
        if (format == formats[i]) {
            return format;
        }
    }
    throw new IllegalArgumentException(String.format("format %x is not supported by this stream configuration map", format));
}
Body of Second Method:
{
    checkArgumentFormat(format);
    int internalFormat = imageFormatToInternal(format);
    int internalDataspace = imageFormatToDataspace(format);
    if (output) {
        if (internalDataspace == HAL_DATASPACE_DEPTH) {
            if (mDepthOutputFormats.indexOfKey(internalFormat) >= 0) {
                return format;
            }
        } else {
            if (mAllOutputFormats.indexOfKey(internalFormat) >= 0) {
                return format;
            }
        }
    } else {
        if (mInputFormats.indexOfKey(internalFormat) >= 0) {
            return format;
        }
    }
    throw new IllegalArgumentException(String.format("format %x is not supported by this stream configuration map", format));
}
------------------------
Find a silently evolved API code:android.webkit.WebView.removeJavascriptInterface:COMMENT
Method Modifier: public      
Comment:/**
 * Removes a previously injected Java object from this WebView. Note that
 * the removal will not be reflected in JavaScript until the page is next
 * (re)loaded. See {@link #addJavascriptInterface}.
 *
 * @param name the name used to expose the object in JavaScript
 */

Body of Frist Method:
{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, "removeJavascriptInterface=" + name);
    mProvider.removeJavascriptInterface(name);
}
Body of Second Method:
{
    checkThread();
    mProvider.removeJavascriptInterface(name);
}
------------------------
Find a silently evolved API code:android.app.WallpaperManager.setStream:COMMENT
Method Modifier: public      
Comment:/**
 * Change the current system wallpaper to a specific byte stream.  The
 * give InputStream is copied into persistent storage and will now be
 * used as the wallpaper.  Currently it must be either a JPEG or PNG
 * image.  On success, the intent {@link Intent#ACTION_WALLPAPER_CHANGED}
 * is broadcast.
 *
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#SET_WALLPAPER}.
 *
 * @param data A stream containing the raw data to install as a wallpaper.
 *
 * @throws IOException If an error occurs reverting to the built-in
 * wallpaper.
 */

Body of Frist Method:
{
    if (sGlobals.mService == null) {
        Log.w(TAG, "WallpaperService not running");
        return;
    }
    try {
        ParcelFileDescriptor fd = sGlobals.mService.setWallpaper(null);
        if (fd == null) {
            return;
        }
        FileOutputStream fos = null;
        try {
            fos = new ParcelFileDescriptor.AutoCloseOutputStream(fd);
            setWallpaper(data, fos);
        } finally {
            if (fos != null) {
                fos.close();
            }
        }
    } catch (RemoteException e) {
    // Ignore
    }
}
Body of Second Method:
{
    if (sGlobals.mService == null) {
        Log.w(TAG, "WallpaperService not running");
        return;
    }
    try {
        ParcelFileDescriptor fd = sGlobals.mService.setWallpaper(null, mContext.getOpPackageName());
        if (fd == null) {
            return;
        }
        FileOutputStream fos = null;
        try {
            fos = new ParcelFileDescriptor.AutoCloseOutputStream(fd);
            setWallpaper(data, fos);
        } finally {
            if (fos != null) {
                fos.close();
            }
        }
    } catch (RemoteException e) {
    // Ignore
    }
}
------------------------
Find a silently evolved API code:android.media.AudioManager.setWiredDeviceConnectionState:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Indicate wired accessory connection state change.
 * @param device type of device connected/disconnected (AudioManager.DEVICE_OUT_xxx)
 * @param state  new connection state: 1 connected, 0 disconnected
 * @param name   device name
 * {@hide}
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        service.setWiredDeviceConnectionState(device, state, name);
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in setWiredDeviceConnectionState " + e);
    }
}
Body of Second Method:
{
    IAudioService service = getService();
    try {
        service.setWiredDeviceConnectionState(type, state, address, name, mApplicationContext.getOpPackageName());
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in setWiredDeviceConnectionState " + e);
    }
}
------------------------
Find a silently evolved API code:javax.obex.ServerSession.handleGetRequest:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Handles a GET request from a client. This method will provide a
 * <code>ServerOperation</code> object to the request handler. The
 * <code>ServerOperation</code> object will handle the rest of the request.
 * It will also send replies and receive requests until the final reply
 * should be sent. When the final reply should be sent, this method will get
 * the response code to use and send the reply. The
 * <code>ServerOperation</code> object will always reply with a
 * OBEX_HTTP_CONTINUE reply. It will only reply if further information is
 * needed.
 * @param type the type of request received; either 0x03 or 0x83
 * @throws IOException if an error occurred at the transport layer
 */

Body of Frist Method:
{
    ServerOperation op = new ServerOperation(this, mInput, type, mMaxPacketLength, mListener);
    try {
        int response = validateResponseCode(mListener.onGet(op));
        if (!op.isAborted) {
            op.sendReply(response);
        }
    } catch (Exception e) {
        sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR, null);
    }
}
Body of Second Method:
{
    ServerOperation op = new ServerOperation(this, mInput, type, mMaxPacketLength, mListener);
    try {
        int response = validateResponseCode(mListener.onGet(op));
        if (!op.isAborted) {
            op.sendReply(response);
        }
    } catch (Exception e) {
        if (V)
            Log.d(TAG, "Exception occured - sending OBEX_HTTP_INTERNAL_ERROR reply", e);
        sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR, null);
    }
}
------------------------
Find a silently evolved API code:android.content.ContentProviderClient.delete:COMMENT
Method Modifier: public      
Comment:/**
 * See {@link ContentProvider#delete ContentProvider.delete}
 */

Body of Frist Method:
{
    beforeRemote();
    try {
        return mContentProvider.delete(mPackageName, url, selection, selectionArgs);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}
Body of Second Method:
{
    Preconditions.checkNotNull(url, "url");
    beforeRemote();
    try {
        return mContentProvider.delete(mPackageName, url, selection, selectionArgs);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}
------------------------
Find a silently evolved API code:android.webkit.WebView.setCertificate:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * Sets the SSL certificate for the main top-level page.
 *
 * @deprecated Calling this function has no useful effect, and will be
 * ignored in future releases.
 */

Body of Frist Method:
{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, "setCertificate=" + certificate);
    mProvider.setCertificate(certificate);
}
Body of Second Method:
{
    checkThread();
    mProvider.setCertificate(certificate);
}
------------------------
Find a silently evolved API code:android.webkit.WebView.findAllAsync:COMMENT
Method Modifier: public      
Comment:/**
 * Finds all instances of find on the page and highlights them,
 * asynchronously. Notifies any registered {@link FindListener}.
 * Successive calls to this will cancel any pending searches.
 *
 * @param find the string to find.
 * @see #setFindListener
 */

Body of Frist Method:
{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, "findAllAsync");
    mProvider.findAllAsync(find);
}
Body of Second Method:
{
    checkThread();
    mProvider.findAllAsync(find);
}
------------------------
Find a silently evolved API code:android.content.ContentProviderClient.getStreamTypes:COMMENT
Method Modifier: public      
Comment:/**
 * See {@link ContentProvider#getStreamTypes ContentProvider.getStreamTypes}
 */

Body of Frist Method:
{
    beforeRemote();
    try {
        return mContentProvider.getStreamTypes(url, mimeTypeFilter);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}
Body of Second Method:
{
    Preconditions.checkNotNull(url, "url");
    Preconditions.checkNotNull(mimeTypeFilter, "mimeTypeFilter");
    beforeRemote();
    try {
        return mContentProvider.getStreamTypes(url, mimeTypeFilter);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}
------------------------
Find a silently evolved API code:android.location.GpsMeasurement.setMultipathIndicator:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets the 'multi-path' indicator.
 */

Body of Frist Method:
{
    switch(value) {
        case MULTIPATH_INDICATOR_UNKNOWN:
        case MULTIPATH_INDICATOR_DETECTED:
        case MULTIPATH_INDICATOR_NOT_USED:
            mMultipathIndicator = value;
            break;
        default:
            Log.d(TAG, "Sanitizing invalid 'muti-path indicator': " + value);
            mMultipathIndicator = MULTIPATH_INDICATOR_UNKNOWN;
            break;
    }
}
Body of Second Method:
{
    mMultipathIndicator = value;
}
------------------------
Find a silently evolved API code:android.os.Debug.MemoryInfo.getOtherLabel:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    switch(which) {
        case 0:
            return "Dalvik Other";
        case 1:
            return "Stack";
        case 2:
            return "Cursor";
        case 3:
            return "Ashmem";
        case 4:
            return "Gfx dev";
        case 5:
            return "Other dev";
        case 6:
            return ".so mmap";
        case 7:
            return ".jar mmap";
        case 8:
            return ".apk mmap";
        case 9:
            return ".ttf mmap";
        case 10:
            return ".dex mmap";
        case 11:
            return ".oat mmap";
        case 12:
            return ".art mmap";
        case 13:
            return "Other mmap";
        case 14:
            return "EGL mtrack";
        case 15:
            return "GL mtrack";
        case 16:
            return "Other mtrack";
        case 17:
            return ".Heap";
        case 18:
            return ".LOS";
        case 19:
            return ".LinearAlloc";
        case 20:
            return ".GC";
        case 21:
            return ".JITCache";
        case 22:
            return ".Zygote";
        case 23:
            return ".NonMoving";
        case 24:
            return ".IndirectRef";
        default:
            return "????";
    }
}
Body of Second Method:
{
    switch(which) {
        case OTHER_DALVIK_OTHER:
            return "Dalvik Other";
        case OTHER_STACK:
            return "Stack";
        case OTHER_CURSOR:
            return "Cursor";
        case OTHER_ASHMEM:
            return "Ashmem";
        case OTHER_GL_DEV:
            return "Gfx dev";
        case OTHER_UNKNOWN_DEV:
            return "Other dev";
        case OTHER_SO:
            return ".so mmap";
        case OTHER_JAR:
            return ".jar mmap";
        case OTHER_APK:
            return ".apk mmap";
        case OTHER_TTF:
            return ".ttf mmap";
        case OTHER_DEX:
            return ".dex mmap";
        case OTHER_OAT:
            return ".oat mmap";
        case OTHER_ART:
            return ".art mmap";
        case OTHER_UNKNOWN_MAP:
            return "Other mmap";
        case OTHER_GRAPHICS:
            return "EGL mtrack";
        case OTHER_GL:
            return "GL mtrack";
        case OTHER_OTHER_MEMTRACK:
            return "Other mtrack";
        case OTHER_DALVIK_NORMAL:
            return ".Heap";
        case OTHER_DALVIK_LARGE:
            return ".LOS";
        case OTHER_DALVIK_LINEARALLOC:
            return ".LinearAlloc";
        case OTHER_DALVIK_ACCOUNTING:
            return ".GC";
        case OTHER_DALVIK_CODE_CACHE:
            return ".JITCache";
        case OTHER_DALVIK_ZYGOTE:
            return ".Zygote";
        case OTHER_DALVIK_NON_MOVING:
            return ".NonMoving";
        case OTHER_DALVIK_INDIRECT_REFERENCE_TABLE:
            return ".IndirectRef";
        default:
            return "????";
    }
}
------------------------
Find a silently evolved API code:android.view.accessibility.AccessibilityWindowInfo.changed:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Checks whether this window changed. The argument should be
 * another state of the same window, which is have the same id
 * and type as they never change.
 *
 * @param other The new state.
 * @return Whether something changed.
 *
 * @hide
 */

Body of Frist Method:
{
    if (other.mId != mId) {
        throw new IllegalArgumentException("Not same window.");
    }
    if (other.mType != mType) {
        throw new IllegalArgumentException("Not same type.");
    }
    if (!mBoundsInScreen.equals(mBoundsInScreen)) {
        return true;
    }
    if (mLayer != other.mLayer) {
        return true;
    }
    if (mBooleanProperties != other.mBooleanProperties) {
        return true;
    }
    if (mParentId != other.mParentId) {
        return true;
    }
    if (mChildIds == null) {
        if (other.mChildIds != null) {
            return true;
        }
    } else if (!mChildIds.equals(other.mChildIds)) {
        return true;
    }
    return false;
}
Body of Second Method:
{
    if (other.mId != mId) {
        throw new IllegalArgumentException("Not same window.");
    }
    if (other.mType != mType) {
        throw new IllegalArgumentException("Not same type.");
    }
    if (!mBoundsInScreen.equals(other.mBoundsInScreen)) {
        return true;
    }
    if (mLayer != other.mLayer) {
        return true;
    }
    if (mBooleanProperties != other.mBooleanProperties) {
        return true;
    }
    if (mParentId != other.mParentId) {
        return true;
    }
    if (mChildIds == null) {
        if (other.mChildIds != null) {
            return true;
        }
    } else if (!mChildIds.equals(other.mChildIds)) {
        return true;
    }
    return false;
}
------------------------
Find a silently evolved API code:android.os.ParcelFileDescriptor.createReliableSocketPair:COMMENT
Method Modifier: public      static      
Comment:/**
 * Create two ParcelFileDescriptors structured as a pair of sockets
 * connected to each other. The two sockets are indistinguishable.
 * <p>
 * Both ends have the ability to deliver an error message through
 * {@link #closeWithError(String)} which can be detected by the other end
 * calling {@link #checkError()}, usually after detecting an EOF.
 * This can also be used to detect remote crashes.
 */

Body of Frist Method:
{
    try {
        final FileDescriptor[] comm = createCommSocketPair();
        final FileDescriptor fd0 = new FileDescriptor();
        final FileDescriptor fd1 = new FileDescriptor();
        Os.socketpair(AF_UNIX, SOCK_STREAM, 0, fd0, fd1);
        return new ParcelFileDescriptor[] { new ParcelFileDescriptor(fd0, comm[0]), new ParcelFileDescriptor(fd1, comm[1]) };
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
}
Body of Second Method:
{
    return createReliableSocketPair(SOCK_STREAM);
}
------------------------
Find a silently evolved API code:android.net.ConnectivityManager.enforceTetherChangePermission:COMMENT
Method Modifier: public      static      final       hidden      
Comment:/**
 * {@hide
 */

Body of Frist Method:
{
    if (context.getResources().getStringArray(com.android.internal.R.array.config_mobile_hotspot_provision_app).length == 2) {
        // Have a provisioning app - must only let system apps (which check this app)
        // turn on tethering
        context.enforceCallingOrSelfPermission(android.Manifest.permission.CONNECTIVITY_INTERNAL, "ConnectivityService");
    } else {
        context.enforceCallingOrSelfPermission(android.Manifest.permission.CHANGE_NETWORK_STATE, "ConnectivityService");
    }
}
Body of Second Method:
{
    if (context.getResources().getStringArray(com.android.internal.R.array.config_mobile_hotspot_provision_app).length == 2) {
        // Have a provisioning app - must only let system apps (which check this app)
        // turn on tethering
        context.enforceCallingOrSelfPermission(android.Manifest.permission.CONNECTIVITY_INTERNAL, "ConnectivityService");
    } else {
        int uid = Binder.getCallingUid();
        Settings.checkAndNoteChangeNetworkStateOperation(context, uid, Settings.getPackageNameForUid(context, uid), true);
    }
}
------------------------
Find a silently evolved API code:android.os.FileUtils.buildValidExtFilename:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Mutate the given filename to make it valid for an ext4 filesystem,
 * replacing any invalid characters with "_".
 */

Body of Frist Method:
{
    if (TextUtils.isEmpty(name) || ".".equals(name) || "..".equals(name)) {
        return "(invalid)";
    }
    final StringBuilder res = new StringBuilder(name.length());
    for (int i = 0; i < name.length(); i++) {
        final char c = name.charAt(i);
        if (isValidExtFilenameChar(c)) {
            res.append(c);
        } else {
            res.append('_');
        }
    }
    return res.toString();
}
Body of Second Method:
{
    if (TextUtils.isEmpty(name) || ".".equals(name) || "..".equals(name)) {
        return "(invalid)";
    }
    final StringBuilder res = new StringBuilder(name.length());
    for (int i = 0; i < name.length(); i++) {
        final char c = name.charAt(i);
        if (isValidExtFilenameChar(c)) {
            res.append(c);
        } else {
            res.append('_');
        }
    }
    trimFilename(res, 255);
    return res.toString();
}
------------------------
Find a silently evolved API code:android.location.GpsMeasurement.getStateString:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Gets a string representation of the 'sync state'.
 * For internal and logging use only.
 */

Body of Frist Method:
{
    switch(mState) {
        case STATE_UNKNOWN:
            return "Unknown";
        case STATE_BIT_SYNC:
            return "BitSync";
        case STATE_CODE_LOCK:
            return "CodeLock";
        case STATE_SUBFRAME_SYNC:
            return "SubframeSync";
        case STATE_TOW_DECODED:
            return "TowDecoded";
        default:
            return "<Invalid>";
    }
}
Body of Second Method:
{
    if (mState == STATE_UNKNOWN) {
        return "Unknown";
    }
    StringBuilder builder = new StringBuilder();
    if ((mState & STATE_CODE_LOCK) == STATE_CODE_LOCK) {
        builder.append("CodeLock|");
    }
    if ((mState & STATE_BIT_SYNC) == STATE_BIT_SYNC) {
        builder.append("BitSync|");
    }
    if ((mState & STATE_SUBFRAME_SYNC) == STATE_SUBFRAME_SYNC) {
        builder.append("SubframeSync|");
    }
    if ((mState & STATE_TOW_DECODED) == STATE_TOW_DECODED) {
        builder.append("TowDecoded|");
    }
    if ((mState & STATE_MSEC_AMBIGUOUS) == STATE_MSEC_AMBIGUOUS) {
        builder.append("MsecAmbiguous");
    }
    int remainingStates = mState & ~STATE_ALL;
    if (remainingStates > 0) {
        builder.append("Other(");
        builder.append(Integer.toBinaryString(remainingStates));
        builder.append(")|");
    }
    builder.deleteCharAt(builder.length() - 1);
    return builder.toString();
}
------------------------
Find a silently evolved API code:android.widget.AbsSeekBar.setThumbPos:COMMENT
Method Modifier: private     
Comment:/**
 * Updates the thumb drawable bounds.
 *
 * @param w Width of the view, including padding
 * @param thumb Drawable used for the thumb
 * @param scale Current progress between 0 and 1
 * @param offset Vertical offset for centering. If set to
 * {@link Integer#MIN_VALUE}, the current offset will be used.
 */

Body of Frist Method:
{
    int available = w - mPaddingLeft - mPaddingRight;
    final int thumbWidth = thumb.getIntrinsicWidth();
    final int thumbHeight = thumb.getIntrinsicHeight();
    available -= thumbWidth;
    // The extra space for the thumb to move on the track
    available += mThumbOffset * 2;
    final int thumbPos = (int) (scale * available + 0.5f);
    final int top, bottom;
    if (offset == Integer.MIN_VALUE) {
        final Rect oldBounds = thumb.getBounds();
        top = oldBounds.top;
        bottom = oldBounds.bottom;
    } else {
        top = offset;
        bottom = offset + thumbHeight;
    }
    final int left = (isLayoutRtl() && mMirrorForRtl) ? available - thumbPos : thumbPos;
    final int right = left + thumbWidth;
    final Drawable background = getBackground();
    if (background != null) {
        final Rect bounds = thumb.getBounds();
        final int offsetX = mPaddingLeft - mThumbOffset;
        final int offsetY = mPaddingTop;
        background.setHotspotBounds(left + offsetX, top + offsetY, right + offsetX, bottom + offsetY);
    }
    // Canvas will be translated, so 0,0 is where we start drawing
    thumb.setBounds(left, top, right, bottom);
}
Body of Second Method:
{
    int available = w - mPaddingLeft - mPaddingRight;
    final int thumbWidth = thumb.getIntrinsicWidth();
    final int thumbHeight = thumb.getIntrinsicHeight();
    available -= thumbWidth;
    // The extra space for the thumb to move on the track
    available += mThumbOffset * 2;
    final int thumbPos = (int) (scale * available + 0.5f);
    final int top, bottom;
    if (offset == Integer.MIN_VALUE) {
        final Rect oldBounds = thumb.getBounds();
        top = oldBounds.top;
        bottom = oldBounds.bottom;
    } else {
        top = offset;
        bottom = offset + thumbHeight;
    }
    final int left = (isLayoutRtl() && mMirrorForRtl) ? available - thumbPos : thumbPos;
    final int right = left + thumbWidth;
    final Drawable background = getBackground();
    if (background != null) {
        final int offsetX = mPaddingLeft - mThumbOffset;
        final int offsetY = mPaddingTop;
        background.setHotspotBounds(left + offsetX, top + offsetY, right + offsetX, bottom + offsetY);
    }
    // Canvas will be translated, so 0,0 is where we start drawing
    thumb.setBounds(left, top, right, bottom);
}
------------------------
Find a silently evolved API code:android.os.StrictMode.setVmPolicy:COMMENT
Method Modifier: public      static      
Comment:/**
 * Sets the policy for what actions in the VM process (on any
 * thread) should be detected, as well as the penalty if such
 * actions occur.
 *
 * @param policy the policy to put into place
 */

Body of Frist Method:
{
    synchronized (StrictMode.class) {
        sVmPolicy = policy;
        sVmPolicyMask = policy.mask;
        setCloseGuardEnabled(vmClosableObjectLeaksEnabled());
        Looper looper = Looper.getMainLooper();
        if (looper != null) {
            MessageQueue mq = looper.mQueue;
            if (policy.classInstanceLimit.size() == 0 || (sVmPolicyMask & VM_PENALTY_MASK) == 0) {
                mq.removeIdleHandler(sProcessIdleHandler);
                sIsIdlerRegistered = false;
            } else if (!sIsIdlerRegistered) {
                mq.addIdleHandler(sProcessIdleHandler);
                sIsIdlerRegistered = true;
            }
        }
    }
}
Body of Second Method:
{
    synchronized (StrictMode.class) {
        sVmPolicy = policy;
        sVmPolicyMask = policy.mask;
        setCloseGuardEnabled(vmClosableObjectLeaksEnabled());
        Looper looper = Looper.getMainLooper();
        if (looper != null) {
            MessageQueue mq = looper.mQueue;
            if (policy.classInstanceLimit.size() == 0 || (sVmPolicyMask & VM_PENALTY_MASK) == 0) {
                mq.removeIdleHandler(sProcessIdleHandler);
                sIsIdlerRegistered = false;
            } else if (!sIsIdlerRegistered) {
                mq.addIdleHandler(sProcessIdleHandler);
                sIsIdlerRegistered = true;
            }
        }
        int networkPolicy = NETWORK_POLICY_ACCEPT;
        if ((sVmPolicyMask & DETECT_VM_CLEARTEXT_NETWORK) != 0) {
            if ((sVmPolicyMask & PENALTY_DEATH) != 0 || (sVmPolicyMask & PENALTY_DEATH_ON_CLEARTEXT_NETWORK) != 0) {
                networkPolicy = NETWORK_POLICY_REJECT;
            } else {
                networkPolicy = NETWORK_POLICY_LOG;
            }
        }
        final INetworkManagementService netd = INetworkManagementService.Stub.asInterface(ServiceManager.getService(Context.NETWORKMANAGEMENT_SERVICE));
        if (netd != null) {
            try {
                netd.setUidCleartextNetworkPolicy(android.os.Process.myUid(), networkPolicy);
            } catch (RemoteException ignored) {
            }
        } else if (networkPolicy != NETWORK_POLICY_ACCEPT) {
            Log.w(TAG, "Dropping requested network policy due to missing service!");
        }
    }
}
------------------------
Find a silently evolved API code:android.graphics.Bitmap.copyPixelsFromBuffer:COMMENT
Method Modifier: public      
Comment:/**
 * <p>Copy the pixels from the buffer, beginning at the current position,
 * overwriting the bitmap's pixels. The data in the buffer is not changed
 * in any way (unlike setPixels(), which converts from unpremultipled 32bit
 * to whatever the bitmap's native format is.</p>
 * <p>After this method returns, the current position of the buffer is
 * updated: the position is incremented by the number of elements read from
 * the buffer. If you need to read the bitmap from the buffer again you must
 * first rewind the buffer.</p>
 */

Body of Frist Method:
{
    checkRecycled("copyPixelsFromBuffer called on recycled bitmap");
    int elements = src.remaining();
    int shift;
    if (src instanceof ByteBuffer) {
        shift = 0;
    } else if (src instanceof ShortBuffer) {
        shift = 1;
    } else if (src instanceof IntBuffer) {
        shift = 2;
    } else {
        throw new RuntimeException("unsupported Buffer subclass");
    }
    long bufferBytes = (long) elements << shift;
    long bitmapBytes = getByteCount();
    if (bufferBytes < bitmapBytes) {
        throw new RuntimeException("Buffer not large enough for pixels");
    }
    nativeCopyPixelsFromBuffer(mNativeBitmap, src);
    // now update the buffer's position
    int position = src.position();
    position += bitmapBytes >> shift;
    src.position(position);
}
Body of Second Method:
{
    checkRecycled("copyPixelsFromBuffer called on recycled bitmap");
    int elements = src.remaining();
    int shift;
    if (src instanceof ByteBuffer) {
        shift = 0;
    } else if (src instanceof ShortBuffer) {
        shift = 1;
    } else if (src instanceof IntBuffer) {
        shift = 2;
    } else {
        throw new RuntimeException("unsupported Buffer subclass");
    }
    long bufferBytes = (long) elements << shift;
    long bitmapBytes = getByteCount();
    if (bufferBytes < bitmapBytes) {
        throw new RuntimeException("Buffer not large enough for pixels");
    }
    nativeCopyPixelsFromBuffer(mFinalizer.mNativeBitmap, src);
    // now update the buffer's position
    int position = src.position();
    position += bitmapBytes >> shift;
    src.position(position);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothAdapter.isOffloadedScanBatchingSupported:COMMENT
Method Modifier: public      
Comment:/**
 * Return true if offloaded scan batching is supported
 *
 * @return true if chipset supports on-chip scan batching
 */

Body of Frist Method:
{
    if (getState() != STATE_ON)
        return false;
    try {
        return mService.isOffloadedScanBatchingSupported();
    } catch (RemoteException e) {
        Log.e(TAG, "failed to get isOffloadedScanBatchingSupported, error: ", e);
    }
    return false;
}
Body of Second Method:
{
    if (!getLeAccess())
        return false;
    try {
        return mService.isOffloadedScanBatchingSupported();
    } catch (RemoteException e) {
        Log.e(TAG, "failed to get isOffloadedScanBatchingSupported, error: ", e);
    }
    return false;
}
------------------------
Find a silently evolved API code:android.net.NetworkPolicyManager.dumpRules:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * {@hide}
 */

Body of Frist Method:
{
    fout.write("[");
    if ((rules & RULE_REJECT_METERED) != 0) {
        fout.write("REJECT_METERED");
    }
    fout.write("]");
}
Body of Second Method:
{
    fout.write("[");
    if ((rules & RULE_REJECT_METERED) != 0) {
        fout.write("REJECT_METERED");
    } else if ((rules & RULE_REJECT_ALL) != 0) {
        fout.write("REJECT_ALL");
    }
    fout.write("]");
}
------------------------
Find a silently evolved API code:android.location.GpsMeasurement.getAccumulatedDeltaRangeStateString:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Gets a string representation of the 'Accumulated Delta Range state'.
 * For internal and logging use only.
 */

Body of Frist Method:
{
    switch(mAccumulatedDeltaRangeState) {
        case ADR_STATE_UNKNOWN:
            return "Unknown";
        case ADR_STATE_VALID:
            return "Valid";
        case ADR_STATE_RESET:
            return "Reset";
        case ADR_STATE_CYCLE_SLIP:
            return "CycleSlip";
        default:
            return "<Invalid>";
    }
}
Body of Second Method:
{
    if (mAccumulatedDeltaRangeState == ADR_STATE_UNKNOWN) {
        return "Unknown";
    }
    StringBuilder builder = new StringBuilder();
    if ((mAccumulatedDeltaRangeState & ADR_STATE_VALID) == ADR_STATE_VALID) {
        builder.append("Valid|");
    }
    if ((mAccumulatedDeltaRangeState & ADR_STATE_RESET) == ADR_STATE_RESET) {
        builder.append("Reset|");
    }
    if ((mAccumulatedDeltaRangeState & ADR_STATE_CYCLE_SLIP) == ADR_STATE_CYCLE_SLIP) {
        builder.append("CycleSlip|");
    }
    int remainingStates = mAccumulatedDeltaRangeState & ~ADR_ALL;
    if (remainingStates > 0) {
        builder.append("Other(");
        builder.append(Integer.toBinaryString(remainingStates));
        builder.append(")|");
    }
    builder.deleteCharAt(builder.length() - 1);
    return builder.toString();
}
------------------------
Find a silently evolved API code:android.content.pm.PermissionInfo.fixProtectionLevel:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (level == PROTECTION_SIGNATURE_OR_SYSTEM) {
        level = PROTECTION_SIGNATURE | PROTECTION_FLAG_SYSTEM;
    }
    return level;
}
Body of Second Method:
{
    if (level == PROTECTION_SIGNATURE_OR_SYSTEM) {
        level = PROTECTION_SIGNATURE | PROTECTION_FLAG_PRIVILEGED;
    }
    return level;
}
------------------------
Find a silently evolved API code:android.net.NetworkStats.setToString:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Return text description of {@link #set} value.
 */

Body of Frist Method:
{
    switch(set) {
        case SET_ALL:
            return "ALL";
        case SET_DEFAULT:
            return "DEFAULT";
        case SET_FOREGROUND:
            return "FOREGROUND";
        default:
            return "UNKNOWN";
    }
}
Body of Second Method:
{
    switch(set) {
        case SET_ALL:
            return "ALL";
        case SET_DEFAULT:
            return "DEFAULT";
        case SET_FOREGROUND:
            return "FOREGROUND";
        case SET_DBG_VPN_IN:
            return "DBG_VPN_IN";
        case SET_DBG_VPN_OUT:
            return "DBG_VPN_OUT";
        default:
            return "UNKNOWN";
    }
}
------------------------
Find a silently evolved API code:android.hardware.camera2.utils.TaskDrainer.beginDrain:COMMENT
Method Modifier: public      
Comment:/**
 * Do not allow any more tasks to be started; once all existing started tasks are finished,
 * fire the {@link DrainListener#onDrained} callback asynchronously.
 *
 * <p>This operation is idempotent; calling it more than once has no effect.</p>
 */

Body of Frist Method:
{
    synchronized (mLock) {
        if (!mDraining) {
            if (VERBOSE) {
                Log.v(TAG + "[" + mName + "]", "beginDrain started");
            }
            mDraining = true;
            // If all tasks that had started had already finished by now, fire #onDrained
            checkIfDrainFinished();
        } else {
            if (VERBOSE) {
                Log.v(TAG + "[" + mName + "]", "beginDrain ignored");
            }
        }
    }
}
Body of Second Method:
{
    synchronized (mLock) {
        if (!mDraining) {
            if (DEBUG) {
                Log.v(TAG + "[" + mName + "]", "beginDrain started");
            }
            mDraining = true;
            // If all tasks that had started had already finished by now, fire #onDrained
            checkIfDrainFinished();
        } else {
            if (DEBUG) {
                Log.v(TAG + "[" + mName + "]", "beginDrain ignored");
            }
        }
    }
}
------------------------
Find a silently evolved API code:android.hardware.camera2.params.StreamConfigurationMap.getPublicFormatCount:COMMENT
Method Modifier: private     
Comment:/**
 * Count the number of publicly-visible output formats
 */

Body of Frist Method:
{
    HashMap<Integer, Integer> formatsMap = getFormatsMap(output);
    int size = formatsMap.size();
    if (formatsMap.containsKey(HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED)) {
        size -= 1;
    }
    if (formatsMap.containsKey(HAL_PIXEL_FORMAT_RAW_OPAQUE)) {
        size -= 1;
    }
    return size;
}
Body of Second Method:
{
    SparseIntArray formatsMap = getFormatsMap(output);
    int size = formatsMap.size();
    if (formatsMap.indexOfKey(HAL_PIXEL_FORMAT_RAW_OPAQUE) >= 0) {
        size -= 1;
    }
    if (output) {
        size += mDepthOutputFormats.size();
    }
    return size;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothDevice.createScoSocket:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Construct a SCO socket ready to start an outgoing connection.
 * Call #connect on the returned #BluetoothSocket to begin the connection.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}
 *
 * @return a SCO BluetoothSocket
 * @throws IOException on error, for example Bluetooth not available, or
 * insufficient permissions.
 * @hide
 */

Body of Frist Method:
{
    return new BluetoothSocket(BluetoothSocket.TYPE_SCO, -1, true, true, this, -1, null);
}
Body of Second Method:
{
    if (isBluetoothEnabled() == false) {
        Log.e(TAG, "Bluetooth is not enabled");
        throw new IOException();
    }
    return new BluetoothSocket(BluetoothSocket.TYPE_SCO, -1, true, true, this, -1, null);
}
------------------------
Find a silently evolved API code:javax.obex.ObexHelper.updateHeaderSet:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Updates the HeaderSet with the headers received in the byte array
 * provided. Invalid headers are ignored.
 * <P>
 * The first two bits of an OBEX Header specifies the type of object that is
 * being sent. The table below specifies the meaning of the high bits.
 * <TABLE>
 * <TR>
 * <TH>Bits 8 and 7</TH>
 * <TH>Value</TH>
 * <TH>Description</TH>
 * </TR>
 * <TR>
 * <TD>00</TD>
 * <TD>0x00</TD>
 * <TD>Null Terminated Unicode text, prefixed with 2 byte unsigned integer</TD>
 * </TR>
 * <TR>
 * <TD>01</TD>
 * <TD>0x40</TD>
 * <TD>Byte Sequence, length prefixed with 2 byte unsigned integer</TD>
 * </TR>
 * <TR>
 * <TD>10</TD>
 * <TD>0x80</TD>
 * <TD>1 byte quantity</TD>
 * </TR>
 * <TR>
 * <TD>11</TD>
 * <TD>0xC0</TD>
 * <TD>4 byte quantity - transmitted in network byte order (high byte first</TD>
 * </TR>
 * </TABLE>
 * This method uses the information in this table to determine the type of
 * Java object to create and passes that object with the full header to
 * setHeader() to update the HeaderSet object. Invalid headers will cause an
 * exception to be thrown. When it is thrown, it is ignored.
 * @param header the HeaderSet to update
 * @param headerArray the byte array containing headers
 * @return the result of the last start body or end body header provided;
 * the first byte in the result will specify if a body or end of
 * body is received
 * @throws IOException if an invalid header was found
 */

Body of Frist Method:
{
    int index = 0;
    int length = 0;
    int headerID;
    byte[] value = null;
    byte[] body = null;
    HeaderSet headerImpl = header;
    try {
        while (index < headerArray.length) {
            headerID = 0xFF & headerArray[index];
            switch(headerID & (0xC0)) {
                /*
                     * 0x00 is a unicode null terminate string with the first
                     * two bytes after the header identifier being the length
                     */
                case 0x00:
                /*
                         * 0x40 is a byte sequence with the first
                         * two bytes after the header identifier being the length
                         */
                case 0x40:
                    boolean trimTail = true;
                    index++;
                    length = 0xFF & headerArray[index];
                    length = length << 8;
                    index++;
                    length += 0xFF & headerArray[index];
                    length -= 3;
                    index++;
                    value = new byte[length];
                    System.arraycopy(headerArray, index, value, 0, length);
                    if (length == 0 || (length > 0 && (value[length - 1] != 0))) {
                        trimTail = false;
                    }
                    switch(headerID) {
                        case HeaderSet.TYPE:
                            try {
                                // Remove trailing null
                                if (trimTail == false) {
                                    headerImpl.setHeader(headerID, new String(value, 0, value.length, "ISO8859_1"));
                                } else {
                                    headerImpl.setHeader(headerID, new String(value, 0, value.length - 1, "ISO8859_1"));
                                }
                            } catch (UnsupportedEncodingException e) {
                                throw e;
                            }
                            break;
                        case HeaderSet.AUTH_CHALLENGE:
                            headerImpl.mAuthChall = new byte[length];
                            System.arraycopy(headerArray, index, headerImpl.mAuthChall, 0, length);
                            break;
                        case HeaderSet.AUTH_RESPONSE:
                            headerImpl.mAuthResp = new byte[length];
                            System.arraycopy(headerArray, index, headerImpl.mAuthResp, 0, length);
                            break;
                        case HeaderSet.BODY:
                        /* Fall Through */
                        case HeaderSet.END_OF_BODY:
                            body = new byte[length + 1];
                            body[0] = (byte) headerID;
                            System.arraycopy(headerArray, index, body, 1, length);
                            break;
                        case HeaderSet.TIME_ISO_8601:
                            try {
                                String dateString = new String(value, "ISO8859_1");
                                Calendar temp = Calendar.getInstance();
                                if ((dateString.length() == 16) && (dateString.charAt(15) == 'Z')) {
                                    temp.setTimeZone(TimeZone.getTimeZone("UTC"));
                                }
                                temp.set(Calendar.YEAR, Integer.parseInt(dateString.substring(0, 4)));
                                temp.set(Calendar.MONTH, Integer.parseInt(dateString.substring(4, 6)));
                                temp.set(Calendar.DAY_OF_MONTH, Integer.parseInt(dateString.substring(6, 8)));
                                temp.set(Calendar.HOUR_OF_DAY, Integer.parseInt(dateString.substring(9, 11)));
                                temp.set(Calendar.MINUTE, Integer.parseInt(dateString.substring(11, 13)));
                                temp.set(Calendar.SECOND, Integer.parseInt(dateString.substring(13, 15)));
                                headerImpl.setHeader(HeaderSet.TIME_ISO_8601, temp);
                            } catch (UnsupportedEncodingException e) {
                                throw e;
                            }
                            break;
                        default:
                            if ((headerID & 0xC0) == 0x00) {
                                headerImpl.setHeader(headerID, ObexHelper.convertToUnicode(value, true));
                            } else {
                                headerImpl.setHeader(headerID, value);
                            }
                    }
                    index += length;
                    break;
                /*
                     * 0x80 is a byte header.  The only valid byte headers are
                     * the 16 user defined byte headers.
                     */
                case 0x80:
                    index++;
                    try {
                        headerImpl.setHeader(headerID, Byte.valueOf(headerArray[index]));
                    } catch (Exception e) {
                    // Not a valid header so ignore
                    }
                    index++;
                    break;
                /*
                     * 0xC0 is a 4 byte unsigned integer header and with the
                     * exception of TIME_4_BYTE will be converted to a Long
                     * and added.
                     */
                case 0xC0:
                    index++;
                    value = new byte[4];
                    System.arraycopy(headerArray, index, value, 0, 4);
                    try {
                        if (headerID != HeaderSet.TIME_4_BYTE) {
                            // need to be handled differently
                            if (headerID == HeaderSet.CONNECTION_ID) {
                                headerImpl.mConnectionID = new byte[4];
                                System.arraycopy(value, 0, headerImpl.mConnectionID, 0, 4);
                            } else {
                                headerImpl.setHeader(headerID, Long.valueOf(convertToLong(value)));
                            }
                        } else {
                            Calendar temp = Calendar.getInstance();
                            temp.setTime(new Date(convertToLong(value) * 1000L));
                            headerImpl.setHeader(HeaderSet.TIME_4_BYTE, temp);
                        }
                    } catch (Exception e) {
                        // Not a valid header so ignore
                        throw new IOException("Header was not formatted properly");
                    }
                    index += 4;
                    break;
            }
        }
    } catch (IOException e) {
        throw new IOException("Header was not formatted properly");
    }
    return body;
}
Body of Second Method:
{
    int index = 0;
    int length = 0;
    int headerID;
    byte[] value = null;
    byte[] body = null;
    HeaderSet headerImpl = header;
    try {
        while (index < headerArray.length) {
            headerID = 0xFF & headerArray[index];
            switch(headerID & (0xC0)) {
                /*
                     * 0x00 is a unicode null terminate string with the first
                     * two bytes after the header identifier being the length
                     */
                case 0x00:
                /*
                         * 0x40 is a byte sequence with the first
                         * two bytes after the header identifier being the length
                         */
                case 0x40:
                    boolean trimTail = true;
                    index++;
                    length = 0xFF & headerArray[index];
                    length = length << 8;
                    index++;
                    length += 0xFF & headerArray[index];
                    length -= 3;
                    index++;
                    value = new byte[length];
                    System.arraycopy(headerArray, index, value, 0, length);
                    if (length == 0 || (length > 0 && (value[length - 1] != 0))) {
                        trimTail = false;
                    }
                    switch(headerID) {
                        case HeaderSet.TYPE:
                            try {
                                // Remove trailing null
                                if (trimTail == false) {
                                    headerImpl.setHeader(headerID, new String(value, 0, value.length, "ISO8859_1"));
                                } else {
                                    headerImpl.setHeader(headerID, new String(value, 0, value.length - 1, "ISO8859_1"));
                                }
                            } catch (UnsupportedEncodingException e) {
                                throw e;
                            }
                            break;
                        case HeaderSet.AUTH_CHALLENGE:
                            headerImpl.mAuthChall = new byte[length];
                            System.arraycopy(headerArray, index, headerImpl.mAuthChall, 0, length);
                            break;
                        case HeaderSet.AUTH_RESPONSE:
                            headerImpl.mAuthResp = new byte[length];
                            System.arraycopy(headerArray, index, headerImpl.mAuthResp, 0, length);
                            break;
                        case HeaderSet.BODY:
                        /* Fall Through */
                        case HeaderSet.END_OF_BODY:
                            body = new byte[length + 1];
                            body[0] = (byte) headerID;
                            System.arraycopy(headerArray, index, body, 1, length);
                            break;
                        case HeaderSet.TIME_ISO_8601:
                            try {
                                String dateString = new String(value, "ISO8859_1");
                                Calendar temp = Calendar.getInstance();
                                if ((dateString.length() == 16) && (dateString.charAt(15) == 'Z')) {
                                    temp.setTimeZone(TimeZone.getTimeZone("UTC"));
                                }
                                temp.set(Calendar.YEAR, Integer.parseInt(dateString.substring(0, 4)));
                                temp.set(Calendar.MONTH, Integer.parseInt(dateString.substring(4, 6)));
                                temp.set(Calendar.DAY_OF_MONTH, Integer.parseInt(dateString.substring(6, 8)));
                                temp.set(Calendar.HOUR_OF_DAY, Integer.parseInt(dateString.substring(9, 11)));
                                temp.set(Calendar.MINUTE, Integer.parseInt(dateString.substring(11, 13)));
                                temp.set(Calendar.SECOND, Integer.parseInt(dateString.substring(13, 15)));
                                headerImpl.setHeader(HeaderSet.TIME_ISO_8601, temp);
                            } catch (UnsupportedEncodingException e) {
                                throw e;
                            }
                            break;
                        default:
                            if ((headerID & 0xC0) == 0x00) {
                                headerImpl.setHeader(headerID, ObexHelper.convertToUnicode(value, true));
                            } else {
                                headerImpl.setHeader(headerID, value);
                            }
                    }
                    index += length;
                    break;
                /*
                     * 0x80 is a byte header.  The only valid byte headers are
                     * the 16 user defined byte headers.
                     */
                case 0x80:
                    index++;
                    try {
                        headerImpl.setHeader(headerID, Byte.valueOf(headerArray[index]));
                    } catch (Exception e) {
                    // Not a valid header so ignore
                    }
                    index++;
                    break;
                /*
                     * 0xC0 is a 4 byte unsigned integer header and with the
                     * exception of TIME_4_BYTE will be converted to a Long
                     * and added.
                     */
                case 0xC0:
                    index++;
                    value = new byte[4];
                    System.arraycopy(headerArray, index, value, 0, 4);
                    try {
                        if (headerID != HeaderSet.TIME_4_BYTE) {
                            // need to be handled differently
                            if (headerID == HeaderSet.CONNECTION_ID) {
                                headerImpl.mConnectionID = new byte[4];
                                System.arraycopy(value, 0, headerImpl.mConnectionID, 0, 4);
                            } else {
                                headerImpl.setHeader(headerID, Long.valueOf(convertToLong(value)));
                            }
                        } else {
                            Calendar temp = Calendar.getInstance();
                            temp.setTime(new Date(convertToLong(value) * 1000L));
                            headerImpl.setHeader(HeaderSet.TIME_4_BYTE, temp);
                        }
                    } catch (Exception e) {
                        // Not a valid header so ignore
                        throw new IOException("Header was not formatted properly", e);
                    }
                    index += 4;
                    break;
            }
        }
    } catch (IOException e) {
        throw new IOException("Header was not formatted properly", e);
    }
    return body;
}
------------------------
Find a silently evolved API code:android.graphics.Paint.setShader:COMMENT
Method Modifier: public      
Comment:/**
 * Set or clear the shader object.
 * <p />
 * Pass null to clear any previous shader.
 * As a convenience, the parameter passed is also returned.
 *
 * @param shader May be null. the new shader to be installed in the paint
 * @return       shader
 */

Body of Frist Method:
{
    long shaderNative = 0;
    if (shader != null)
        shaderNative = shader.getNativeInstance();
    native_setShader(mNativePaint, shaderNative);
    mShader = shader;
    return shader;
}
Body of Second Method:
{
    // Defer setting the shader natively until getNativeInstance() is called
    mShader = shader;
    return shader;
}
------------------------
Find a silently evolved API code:android.content.UriMatcher.addURI:COMMENT
Method Modifier: public      
Comment:/**
 * Add a URI to match, and the code to return when this URI is
 * matched. URI nodes may be exact match string, the token "*"
 * that matches any text, or the token "#" that matches only
 * numbers.
 * <p>
 * Starting from API level {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2},
 * this method will accept a leading slash in the path.
 *
 * @param authority the authority to match
 * @param path the path to match. * may be used as a wild card for
 * any text, and # may be used as a wild card for numbers.
 * @param code the code that is returned when a URI is matched
 * against the given components. Must be positive.
 */

Body of Frist Method:
{
    if (code < 0) {
        throw new IllegalArgumentException("code " + code + " is invalid: it must be positive");
    }
    String[] tokens = null;
    if (path != null) {
        String newPath = path;
        // Strip leading slash if present.
        if (path.length() > 0 && path.charAt(0) == '/') {
            newPath = path.substring(1);
        }
        tokens = PATH_SPLIT_PATTERN.split(newPath);
    }
    int numTokens = tokens != null ? tokens.length : 0;
    UriMatcher node = this;
    for (int i = -1; i < numTokens; i++) {
        String token = i < 0 ? authority : tokens[i];
        ArrayList<UriMatcher> children = node.mChildren;
        int numChildren = children.size();
        UriMatcher child;
        int j;
        for (j = 0; j < numChildren; j++) {
            child = children.get(j);
            if (token.equals(child.mText)) {
                node = child;
                break;
            }
        }
        if (j == numChildren) {
            // Child not found, create it
            child = new UriMatcher();
            if (token.equals("#")) {
                child.mWhich = NUMBER;
            } else if (token.equals("*")) {
                child.mWhich = TEXT;
            } else {
                child.mWhich = EXACT;
            }
            child.mText = token;
            node.mChildren.add(child);
            node = child;
        }
    }
    node.mCode = code;
}
Body of Second Method:
{
    if (code < 0) {
        throw new IllegalArgumentException("code " + code + " is invalid: it must be positive");
    }
    String[] tokens = null;
    if (path != null) {
        String newPath = path;
        // Strip leading slash if present.
        if (path.length() > 0 && path.charAt(0) == '/') {
            newPath = path.substring(1);
        }
        tokens = newPath.split("/");
    }
    int numTokens = tokens != null ? tokens.length : 0;
    UriMatcher node = this;
    for (int i = -1; i < numTokens; i++) {
        String token = i < 0 ? authority : tokens[i];
        ArrayList<UriMatcher> children = node.mChildren;
        int numChildren = children.size();
        UriMatcher child;
        int j;
        for (j = 0; j < numChildren; j++) {
            child = children.get(j);
            if (token.equals(child.mText)) {
                node = child;
                break;
            }
        }
        if (j == numChildren) {
            // Child not found, create it
            child = new UriMatcher();
            if (token.equals("#")) {
                child.mWhich = NUMBER;
            } else if (token.equals("*")) {
                child.mWhich = TEXT;
            } else {
                child.mWhich = EXACT;
            }
            child.mText = token;
            node.mChildren.add(child);
            node = child;
        }
    }
    node.mCode = code;
}
------------------------
Find a silently evolved API code:android.widget.FrameLayout.onMeasure:COMMENT
Method Modifier: protected   
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    int count = getChildCount();
    final boolean measureMatchParentChildren = MeasureSpec.getMode(widthMeasureSpec) != MeasureSpec.EXACTLY || MeasureSpec.getMode(heightMeasureSpec) != MeasureSpec.EXACTLY;
    mMatchParentChildren.clear();
    int maxHeight = 0;
    int maxWidth = 0;
    int childState = 0;
    for (int i = 0; i < count; i++) {
        final View child = getChildAt(i);
        if (mMeasureAllChildren || child.getVisibility() != GONE) {
            measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0);
            final LayoutParams lp = (LayoutParams) child.getLayoutParams();
            maxWidth = Math.max(maxWidth, child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);
            maxHeight = Math.max(maxHeight, child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);
            childState = combineMeasuredStates(childState, child.getMeasuredState());
            if (measureMatchParentChildren) {
                if (lp.width == LayoutParams.MATCH_PARENT || lp.height == LayoutParams.MATCH_PARENT) {
                    mMatchParentChildren.add(child);
                }
            }
        }
    }
    // Account for padding too
    maxWidth += getPaddingLeftWithForeground() + getPaddingRightWithForeground();
    maxHeight += getPaddingTopWithForeground() + getPaddingBottomWithForeground();
    // Check against our minimum height and width
    maxHeight = Math.max(maxHeight, getSuggestedMinimumHeight());
    maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());
    // Check against our foreground's minimum height and width
    final Drawable drawable = getForeground();
    if (drawable != null) {
        maxHeight = Math.max(maxHeight, drawable.getMinimumHeight());
        maxWidth = Math.max(maxWidth, drawable.getMinimumWidth());
    }
    setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState), resolveSizeAndState(maxHeight, heightMeasureSpec, childState << MEASURED_HEIGHT_STATE_SHIFT));
    count = mMatchParentChildren.size();
    if (count > 1) {
        for (int i = 0; i < count; i++) {
            final View child = mMatchParentChildren.get(i);
            final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();
            int childWidthMeasureSpec;
            int childHeightMeasureSpec;
            if (lp.width == LayoutParams.MATCH_PARENT) {
                childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(getMeasuredWidth() - getPaddingLeftWithForeground() - getPaddingRightWithForeground() - lp.leftMargin - lp.rightMargin, MeasureSpec.EXACTLY);
            } else {
                childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec, getPaddingLeftWithForeground() + getPaddingRightWithForeground() + lp.leftMargin + lp.rightMargin, lp.width);
            }
            if (lp.height == LayoutParams.MATCH_PARENT) {
                childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(getMeasuredHeight() - getPaddingTopWithForeground() - getPaddingBottomWithForeground() - lp.topMargin - lp.bottomMargin, MeasureSpec.EXACTLY);
            } else {
                childHeightMeasureSpec = getChildMeasureSpec(heightMeasureSpec, getPaddingTopWithForeground() + getPaddingBottomWithForeground() + lp.topMargin + lp.bottomMargin, lp.height);
            }
            child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
        }
    }
}
Body of Second Method:
{
    int count = getChildCount();
    final boolean measureMatchParentChildren = MeasureSpec.getMode(widthMeasureSpec) != MeasureSpec.EXACTLY || MeasureSpec.getMode(heightMeasureSpec) != MeasureSpec.EXACTLY;
    mMatchParentChildren.clear();
    int maxHeight = 0;
    int maxWidth = 0;
    int childState = 0;
    for (int i = 0; i < count; i++) {
        final View child = getChildAt(i);
        if (mMeasureAllChildren || child.getVisibility() != GONE) {
            measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0);
            final LayoutParams lp = (LayoutParams) child.getLayoutParams();
            maxWidth = Math.max(maxWidth, child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);
            maxHeight = Math.max(maxHeight, child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);
            childState = combineMeasuredStates(childState, child.getMeasuredState());
            if (measureMatchParentChildren) {
                if (lp.width == LayoutParams.MATCH_PARENT || lp.height == LayoutParams.MATCH_PARENT) {
                    mMatchParentChildren.add(child);
                }
            }
        }
    }
    // Account for padding too
    maxWidth += getPaddingLeftWithForeground() + getPaddingRightWithForeground();
    maxHeight += getPaddingTopWithForeground() + getPaddingBottomWithForeground();
    // Check against our minimum height and width
    maxHeight = Math.max(maxHeight, getSuggestedMinimumHeight());
    maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());
    // Check against our foreground's minimum height and width
    final Drawable drawable = getForeground();
    if (drawable != null) {
        maxHeight = Math.max(maxHeight, drawable.getMinimumHeight());
        maxWidth = Math.max(maxWidth, drawable.getMinimumWidth());
    }
    setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState), resolveSizeAndState(maxHeight, heightMeasureSpec, childState << MEASURED_HEIGHT_STATE_SHIFT));
    count = mMatchParentChildren.size();
    if (count > 1) {
        for (int i = 0; i < count; i++) {
            final View child = mMatchParentChildren.get(i);
            final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();
            final int childWidthMeasureSpec;
            if (lp.width == LayoutParams.MATCH_PARENT) {
                final int width = Math.max(0, getMeasuredWidth() - getPaddingLeftWithForeground() - getPaddingRightWithForeground() - lp.leftMargin - lp.rightMargin);
                childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(width, MeasureSpec.EXACTLY);
            } else {
                childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec, getPaddingLeftWithForeground() + getPaddingRightWithForeground() + lp.leftMargin + lp.rightMargin, lp.width);
            }
            final int childHeightMeasureSpec;
            if (lp.height == LayoutParams.MATCH_PARENT) {
                final int height = Math.max(0, getMeasuredHeight() - getPaddingTopWithForeground() - getPaddingBottomWithForeground() - lp.topMargin - lp.bottomMargin);
                childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(height, MeasureSpec.EXACTLY);
            } else {
                childHeightMeasureSpec = getChildMeasureSpec(heightMeasureSpec, getPaddingTopWithForeground() + getPaddingBottomWithForeground() + lp.topMargin + lp.bottomMargin, lp.height);
            }
            child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
        }
    }
}
------------------------
Find a silently evolved API code:android.content.ContentResolver.delete:COMMENT
Method Modifier: public      final       
Comment:/**
 * Deletes row(s) specified by a content URI.
 *
 * If the content provider supports transactions, the deletion will be atomic.
 *
 * @param url The URL of the row to delete.
 * @param where A filter to apply to rows before deleting, formatted as an SQL WHERE clause
 * (excluding the WHERE itself).
 * @return The number of rows deleted.
 */

Body of Frist Method:
{
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        throw new IllegalArgumentException("Unknown URL " + url);
    }
    try {
        long startTime = SystemClock.uptimeMillis();
        int rowsDeleted = provider.delete(mPackageName, url, where, selectionArgs);
        long durationMillis = SystemClock.uptimeMillis() - startTime;
        maybeLogUpdateToEventLog(durationMillis, url, "delete", where);
        return rowsDeleted;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return -1;
    } finally {
        releaseProvider(provider);
    }
}
Body of Second Method:
{
    Preconditions.checkNotNull(url, "url");
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        throw new IllegalArgumentException("Unknown URL " + url);
    }
    try {
        long startTime = SystemClock.uptimeMillis();
        int rowsDeleted = provider.delete(mPackageName, url, where, selectionArgs);
        long durationMillis = SystemClock.uptimeMillis() - startTime;
        maybeLogUpdateToEventLog(durationMillis, url, "delete", where);
        return rowsDeleted;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return -1;
    } finally {
        releaseProvider(provider);
    }
}
------------------------
Find a silently evolved API code:android.app.Notification.BigPictureStyle.bigLargeIcon:COMMENT
Method Modifier: public      
Comment:/**
 * Override the large icon when the big notification is shown.
 */

Body of Frist Method:
{
    mBigLargeIconSet = true;
    mBigLargeIcon = b;
    return this;
}
Body of Second Method:
{
    return bigLargeIcon(b != null ? Icon.createWithBitmap(b) : null);
}
------------------------
Find a silently evolved API code:android.media.audiopolicy.AudioMix.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Combines all of the settings and return a new {@link AudioMix} object.
 * @return a new {@link AudioMix} object
 * @throws IllegalArgumentException if no {@link AudioMixingRule} has been set.
 */

Body of Frist Method:
{
    if (mRule == null) {
        throw new IllegalArgumentException("Illegal null AudioMixingRule");
    }
    if (mRouteFlags == 0) {
        // no route flags set, use default
        mRouteFlags = ROUTE_FLAG_RENDER;
    }
    if (mFormat == null) {
        int rate = AudioSystem.getPrimaryOutputSamplingRate();
        if (rate <= 0) {
            rate = 44100;
        }
        mFormat = new AudioFormat.Builder().setSampleRate(rate).build();
    }
    return new AudioMix(mRule, mFormat, mRouteFlags);
}
Body of Second Method:
{
    if (mRule == null) {
        throw new IllegalArgumentException("Illegal null AudioMixingRule");
    }
    if (mRouteFlags == 0) {
        // no route flags set, use default
        mRouteFlags = ROUTE_FLAG_RENDER;
    }
    if (mFormat == null) {
        int rate = AudioSystem.getPrimaryOutputSamplingRate();
        if (rate <= 0) {
            rate = 44100;
        }
        mFormat = new AudioFormat.Builder().setSampleRate(rate).build();
    }
    return new AudioMix(mRule, mFormat, mRouteFlags, mCallbackFlags);
}
------------------------
Find a silently evolved API code:android.content.pm.ResolveInfo.getIconResource:COMMENT
Method Modifier: public      final       
Comment:/**
 * Return the icon resource identifier to use for this match.  If the
 * match defines an icon, that is used; else if the activity defines
 * an icon, that is used; else, the application icon is used.
 *
 * @return The icon associated with this match.
 */

Body of Frist Method:
{
    if (noResourceId)
        return 0;
    if (icon != 0)
        return icon;
    final ComponentInfo ci = getComponentInfo();
    if (ci != null) {
        return ci.getIconResource();
    }
    return 0;
}
Body of Second Method:
{
    if (noResourceId)
        return 0;
    return getIconResourceInternal();
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothAdapter.listenUsingEncryptedRfcommOn:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Construct an encrypted, RFCOMM server socket.
 * Call #accept to retrieve connections to this socket.
 * @return An RFCOMM BluetoothServerSocket
 * @throws IOException On error, for example Bluetooth not available, or
 * insufficient permissions.
 * @hide
 */

Body of Frist Method:
{
    BluetoothServerSocket socket = new BluetoothServerSocket(BluetoothSocket.TYPE_RFCOMM, false, true, port);
    int errno = socket.mSocket.bindListen();
    if (errno < 0) {
        // socket.mSocket.throwErrnoNative(errno);
        throw new IOException("Error: " + errno);
    }
    return socket;
}
Body of Second Method:
{
    BluetoothServerSocket socket = new BluetoothServerSocket(BluetoothSocket.TYPE_RFCOMM, false, true, port);
    int errno = socket.mSocket.bindListen();
    if (port == SOCKET_CHANNEL_AUTO_STATIC_NO_SDP) {
        socket.setChannel(socket.mSocket.getPort());
    }
    if (errno < 0) {
        // socket.mSocket.throwErrnoNative(errno);
        throw new IOException("Error: " + errno);
    }
    return socket;
}
------------------------
Find a silently evolved API code:android.hardware.camera2.params.HighSpeedVideoConfiguration.equals:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Check if this {@link HighSpeedVideoConfiguration} is equal to another
 * {@link HighSpeedVideoConfiguration}.
 *
 * <p>Two configurations are equal if and only if each of the respective elements is equal.</p>
 *
 * @return {@code true} if the objects were equal, {@code false} otherwise
 */

Body of Frist Method:
{
    if (obj == null) {
        return false;
    }
    if (this == obj) {
        return true;
    }
    if (obj instanceof HighSpeedVideoConfiguration) {
        final HighSpeedVideoConfiguration other = (HighSpeedVideoConfiguration) obj;
        return mWidth == other.mWidth && mHeight == other.mHeight && mFpsMin == other.mFpsMin && mFpsMax == other.mFpsMax;
    }
    return false;
}
Body of Second Method:
{
    if (obj == null) {
        return false;
    }
    if (this == obj) {
        return true;
    }
    if (obj instanceof HighSpeedVideoConfiguration) {
        final HighSpeedVideoConfiguration other = (HighSpeedVideoConfiguration) obj;
        return mWidth == other.mWidth && mHeight == other.mHeight && mFpsMin == other.mFpsMin && mFpsMax == other.mFpsMax && mBatchSizeMax == other.mBatchSizeMax;
    }
    return false;
}
------------------------
Find a silently evolved API code:android.hardware.camera2.params.StreamConfigurationMap.equals:COMMENT
Method Modifier: public      
Comment:/**
 * Check if this {@link StreamConfigurationMap} is equal to another
 * {@link StreamConfigurationMap}.
 *
 * <p>Two vectors are only equal if and only if each of the respective elements is equal.</p>
 *
 * @return {@code true} if the objects were equal, {@code false} otherwise
 */

Body of Frist Method:
{
    if (obj == null) {
        return false;
    }
    if (this == obj) {
        return true;
    }
    if (obj instanceof StreamConfigurationMap) {
        final StreamConfigurationMap other = (StreamConfigurationMap) obj;
        // XX: do we care about order?
        return Arrays.equals(mConfigurations, other.mConfigurations) && Arrays.equals(mMinFrameDurations, other.mMinFrameDurations) && Arrays.equals(mStallDurations, other.mStallDurations) && Arrays.equals(mHighSpeedVideoConfigurations, other.mHighSpeedVideoConfigurations);
    }
    return false;
}
Body of Second Method:
{
    if (obj == null) {
        return false;
    }
    if (this == obj) {
        return true;
    }
    if (obj instanceof StreamConfigurationMap) {
        final StreamConfigurationMap other = (StreamConfigurationMap) obj;
        // XX: do we care about order?
        return Arrays.equals(mConfigurations, other.mConfigurations) && Arrays.equals(mMinFrameDurations, other.mMinFrameDurations) && Arrays.equals(mStallDurations, other.mStallDurations) && Arrays.equals(mDepthConfigurations, other.mDepthConfigurations) && Arrays.equals(mHighSpeedVideoConfigurations, other.mHighSpeedVideoConfigurations);
    }
    return false;
}
------------------------
Find a silently evolved API code:javax.obex.ServerSession.handleConnectRequest:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Handles a connect request from a client. This method will read the rest
 * of the request from the client. Assuming the request is valid, it will
 * create a <code>HeaderSet</code> object to pass to the
 * <code>ServerRequestHandler</code> object. After the handler processes the
 * request, this method will create a reply message to send to the server
 * with the response code provided.
 * @throws IOException if an error occurred at the transport layer
 */

Body of Frist Method:
{
    int packetLength;
    @SuppressWarnings("unused") int version;
    @SuppressWarnings("unused") int flags;
    int totalLength = 7;
    byte[] head = null;
    int code = -1;
    HeaderSet request = new HeaderSet();
    HeaderSet reply = new HeaderSet();
    int bytesReceived;
    /*
         * Read in the length of the OBEX packet, OBEX version, flags, and max
         * packet length
         */
    packetLength = mInput.read();
    packetLength = (packetLength << 8) + mInput.read();
    version = mInput.read();
    flags = mInput.read();
    mMaxPacketLength = mInput.read();
    mMaxPacketLength = (mMaxPacketLength << 8) + mInput.read();
    // should we check it?
    if (mMaxPacketLength > ObexHelper.MAX_PACKET_SIZE_INT) {
        mMaxPacketLength = ObexHelper.MAX_PACKET_SIZE_INT;
    }
    if (packetLength > ObexHelper.MAX_PACKET_SIZE_INT) {
        code = ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE;
        totalLength = 7;
    } else {
        if (packetLength > 7) {
            byte[] headers = new byte[packetLength - 7];
            bytesReceived = mInput.read(headers);
            while (bytesReceived != headers.length) {
                bytesReceived += mInput.read(headers, bytesReceived, headers.length - bytesReceived);
            }
            ObexHelper.updateHeaderSet(request, headers);
        }
        if (mListener.getConnectionId() != -1 && request.mConnectionID != null) {
            mListener.setConnectionId(ObexHelper.convertToLong(request.mConnectionID));
        } else {
            mListener.setConnectionId(1);
        }
        if (request.mAuthResp != null) {
            if (!handleAuthResp(request.mAuthResp)) {
                code = ResponseCodes.OBEX_HTTP_UNAUTHORIZED;
                mListener.onAuthenticationFailure(ObexHelper.getTagValue((byte) 0x01, request.mAuthResp));
            }
            request.mAuthResp = null;
        }
        if (code != ResponseCodes.OBEX_HTTP_UNAUTHORIZED) {
            if (request.mAuthChall != null) {
                handleAuthChall(request);
                reply.mAuthResp = new byte[request.mAuthResp.length];
                System.arraycopy(request.mAuthResp, 0, reply.mAuthResp, 0, reply.mAuthResp.length);
                request.mAuthChall = null;
                request.mAuthResp = null;
            }
            try {
                code = mListener.onConnect(request, reply);
                code = validateResponseCode(code);
                if (reply.nonce != null) {
                    mChallengeDigest = new byte[16];
                    System.arraycopy(reply.nonce, 0, mChallengeDigest, 0, 16);
                } else {
                    mChallengeDigest = null;
                }
                long id = mListener.getConnectionId();
                if (id == -1) {
                    reply.mConnectionID = null;
                } else {
                    reply.mConnectionID = ObexHelper.convertToByteArray(id);
                }
                head = ObexHelper.createHeader(reply, false);
                totalLength += head.length;
                if (totalLength > mMaxPacketLength) {
                    totalLength = 7;
                    head = null;
                    code = ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
                }
            } catch (Exception e) {
                e.printStackTrace();
                totalLength = 7;
                head = null;
                code = ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
            }
        }
    }
    // Compute Length of OBEX CONNECT packet
    byte[] length = ObexHelper.convertToByteArray(totalLength);
    /*
         * Write the OBEX CONNECT packet to the server. Byte 0: response code
         * Byte 1&2: Connect Packet Length Byte 3: OBEX Version Number
         * (Presently, 0x10) Byte 4: Flags (For TCP 0x00) Byte 5&6: Max OBEX
         * Packet Length (Defined in MAX_PACKET_SIZE) Byte 7 to n: headers
         */
    byte[] sendData = new byte[totalLength];
    sendData[0] = (byte) code;
    sendData[1] = length[2];
    sendData[2] = length[3];
    sendData[3] = (byte) 0x10;
    sendData[4] = (byte) 0x00;
    sendData[5] = (byte) (ObexHelper.MAX_PACKET_SIZE_INT >> 8);
    sendData[6] = (byte) (ObexHelper.MAX_PACKET_SIZE_INT & 0xFF);
    if (head != null) {
        System.arraycopy(head, 0, sendData, 7, head.length);
    }
    mOutput.write(sendData);
    mOutput.flush();
}
Body of Second Method:
{
    int packetLength;
    @SuppressWarnings("unused") int version;
    @SuppressWarnings("unused") int flags;
    int totalLength = 7;
    byte[] head = null;
    int code = -1;
    HeaderSet request = new HeaderSet();
    HeaderSet reply = new HeaderSet();
    int bytesReceived;
    if (V)
        Log.v(TAG, "handleConnectRequest()");
    /*
         * Read in the length of the OBEX packet, OBEX version, flags, and max
         * packet length
         */
    packetLength = mInput.read();
    packetLength = (packetLength << 8) + mInput.read();
    if (V)
        Log.v(TAG, "handleConnectRequest() - packetLength: " + packetLength);
    version = mInput.read();
    flags = mInput.read();
    mMaxPacketLength = mInput.read();
    mMaxPacketLength = (mMaxPacketLength << 8) + mInput.read();
    if (V)
        Log.v(TAG, "handleConnectRequest() - version: " + version + " MaxLength: " + mMaxPacketLength + " flags: " + flags);
    // should we check it?
    if (mMaxPacketLength > ObexHelper.MAX_PACKET_SIZE_INT) {
        mMaxPacketLength = ObexHelper.MAX_PACKET_SIZE_INT;
    }
    if (mMaxPacketLength > ObexHelper.getMaxTxPacketSize(mTransport)) {
        Log.w(TAG, "Requested MaxObexPacketSize " + mMaxPacketLength + " is larger than the max size supported by the transport: " + ObexHelper.getMaxTxPacketSize(mTransport) + " Reducing to this size.");
        mMaxPacketLength = ObexHelper.getMaxTxPacketSize(mTransport);
    }
    if (packetLength > ObexHelper.getMaxRxPacketSize(mTransport)) {
        code = ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE;
        totalLength = 7;
    } else {
        if (packetLength > 7) {
            byte[] headers = new byte[packetLength - 7];
            bytesReceived = mInput.read(headers);
            while (bytesReceived != headers.length) {
                bytesReceived += mInput.read(headers, bytesReceived, headers.length - bytesReceived);
            }
            ObexHelper.updateHeaderSet(request, headers);
        }
        if (mListener.getConnectionId() != -1 && request.mConnectionID != null) {
            mListener.setConnectionId(ObexHelper.convertToLong(request.mConnectionID));
        } else {
            mListener.setConnectionId(1);
        }
        if (request.mAuthResp != null) {
            if (!handleAuthResp(request.mAuthResp)) {
                code = ResponseCodes.OBEX_HTTP_UNAUTHORIZED;
                mListener.onAuthenticationFailure(ObexHelper.getTagValue((byte) 0x01, request.mAuthResp));
            }
            request.mAuthResp = null;
        }
        if (code != ResponseCodes.OBEX_HTTP_UNAUTHORIZED) {
            if (request.mAuthChall != null) {
                handleAuthChall(request);
                reply.mAuthResp = new byte[request.mAuthResp.length];
                System.arraycopy(request.mAuthResp, 0, reply.mAuthResp, 0, reply.mAuthResp.length);
                request.mAuthChall = null;
                request.mAuthResp = null;
            }
            try {
                code = mListener.onConnect(request, reply);
                code = validateResponseCode(code);
                if (reply.nonce != null) {
                    mChallengeDigest = new byte[16];
                    System.arraycopy(reply.nonce, 0, mChallengeDigest, 0, 16);
                } else {
                    mChallengeDigest = null;
                }
                long id = mListener.getConnectionId();
                if (id == -1) {
                    reply.mConnectionID = null;
                } else {
                    reply.mConnectionID = ObexHelper.convertToByteArray(id);
                }
                head = ObexHelper.createHeader(reply, false);
                totalLength += head.length;
                if (totalLength > mMaxPacketLength) {
                    totalLength = 7;
                    head = null;
                    code = ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
                }
            } catch (Exception e) {
                if (V)
                    Log.d(TAG, "Exception occured - sending OBEX_HTTP_INTERNAL_ERROR reply", e);
                totalLength = 7;
                head = null;
                code = ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
            }
        }
    }
    // Compute Length of OBEX CONNECT packet
    byte[] length = ObexHelper.convertToByteArray(totalLength);
    /*
         * Write the OBEX CONNECT packet to the server. Byte 0: response code
         * Byte 1&2: Connect Packet Length Byte 3: OBEX Version Number
         * (Presently, 0x10) Byte 4: Flags (For TCP 0x00) Byte 5&6: Max OBEX
         * Packet Length (Defined in MAX_PACKET_SIZE) Byte 7 to n: headers
         */
    byte[] sendData = new byte[totalLength];
    int maxRxLength = ObexHelper.getMaxRxPacketSize(mTransport);
    sendData[0] = (byte) code;
    sendData[1] = length[2];
    sendData[2] = length[3];
    sendData[3] = (byte) 0x10;
    sendData[4] = (byte) 0x00;
    sendData[5] = (byte) (maxRxLength >> 8);
    sendData[6] = (byte) (maxRxLength & 0xFF);
    if (head != null) {
        System.arraycopy(head, 0, sendData, 7, head.length);
    }
    mOutput.write(sendData);
    mOutput.flush();
}
------------------------
Find a silently evolved API code:android.database.BulkCursorToCursorAdaptor.initialize:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Initializes the adaptor.
 * Must be called before first use.
 */

Body of Frist Method:
{
    mBulkCursor = d.cursor;
    mColumns = d.columnNames;
    mRowIdColumnIndex = DatabaseUtils.findRowIdColumnIndex(mColumns);
    mWantsAllOnMoveCalls = d.wantsAllOnMoveCalls;
    mCount = d.count;
    if (d.window != null) {
        setWindow(d.window);
    }
}
Body of Second Method:
{
    mBulkCursor = d.cursor;
    mColumns = d.columnNames;
    mWantsAllOnMoveCalls = d.wantsAllOnMoveCalls;
    mCount = d.count;
    if (d.window != null) {
        setWindow(d.window);
    }
}
------------------------
Find a silently evolved API code:android.widget.TextView.getCompoundDrawablesRelative:COMMENT
Method Modifier: public      
Comment:/**
 * Returns drawables for the start, top, end, and bottom borders.
 *
 * @attr ref android.R.styleable#TextView_drawableStart
 * @attr ref android.R.styleable#TextView_drawableTop
 * @attr ref android.R.styleable#TextView_drawableEnd
 * @attr ref android.R.styleable#TextView_drawableBottom
 */

Body of Frist Method:
{
    final Drawables dr = mDrawables;
    if (dr != null) {
        return new Drawable[] { dr.mDrawableStart, dr.mDrawableTop, dr.mDrawableEnd, dr.mDrawableBottom };
    } else {
        return new Drawable[] { null, null, null, null };
    }
}
Body of Second Method:
{
    final Drawables dr = mDrawables;
    if (dr != null) {
        return new Drawable[] { dr.mDrawableStart, dr.mShowing[Drawables.TOP], dr.mDrawableEnd, dr.mShowing[Drawables.BOTTOM] };
    } else {
        return new Drawable[] { null, null, null, null };
    }
}
------------------------
Find a silently evolved API code:android.hardware.camera2.params.StreamConfigurationMap.getDurations:COMMENT
Method Modifier: private     
Comment:/**
 * Get the durations array for the kind of duration
 *
 * @see #DURATION_MIN_FRAME
 * @see #DURATION_STALL
 */

Body of Frist Method:
{
    switch(duration) {
        case DURATION_MIN_FRAME:
            return mMinFrameDurations;
        case DURATION_STALL:
            return mStallDurations;
        default:
            throw new IllegalArgumentException("duration was invalid");
    }
}
Body of Second Method:
{
    switch(duration) {
        case DURATION_MIN_FRAME:
            return (dataspace == HAL_DATASPACE_DEPTH) ? mDepthMinFrameDurations : mMinFrameDurations;
        case DURATION_STALL:
            return (dataspace == HAL_DATASPACE_DEPTH) ? mDepthStallDurations : mStallDurations;
        default:
            throw new IllegalArgumentException("duration was invalid");
    }
}
------------------------
Find a silently evolved API code:android.content.ContentProviderClient.applyBatch:COMMENT
Method Modifier: public      
Comment:/**
 * See {@link ContentProvider#applyBatch ContentProvider.applyBatch}
 */

Body of Frist Method:
{
    beforeRemote();
    try {
        return mContentProvider.applyBatch(mPackageName, operations);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}
Body of Second Method:
{
    Preconditions.checkNotNull(operations, "operations");
    beforeRemote();
    try {
        return mContentProvider.applyBatch(mPackageName, operations);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiEnterpriseConfig.setEapMethod:COMMENT
Method Modifier: public      
Comment:/**
 * Set the EAP authentication method.
 * @param  eapMethod is one {@link Eap#PEAP}, {@link Eap#TLS}, {@link Eap#TTLS} or
 * {@link Eap#PWD}
 * @throws IllegalArgumentException on an invalid eap method
 */

Body of Frist Method:
{
    switch(eapMethod) {
        /**
         * Valid methods
         */
        case Eap.TLS:
            setPhase2Method(Phase2.NONE);
        /* fall through */
        case Eap.PEAP:
        case Eap.PWD:
        case Eap.TTLS:
        case Eap.SIM:
        case Eap.AKA:
            mFields.put(EAP_KEY, Eap.strings[eapMethod]);
            mFields.put(OPP_KEY_CACHING, "1");
            break;
        default:
            throw new IllegalArgumentException("Unknown EAP method");
    }
}
Body of Second Method:
{
    switch(eapMethod) {
        /**
         * Valid methods
         */
        case Eap.TLS:
            setPhase2Method(Phase2.NONE);
        /* fall through */
        case Eap.PEAP:
        case Eap.PWD:
        case Eap.TTLS:
        case Eap.SIM:
        case Eap.AKA:
        case Eap.AKA_PRIME:
            mFields.put(EAP_KEY, Eap.strings[eapMethod]);
            mFields.put(OPP_KEY_CACHING, "1");
            break;
        default:
            throw new IllegalArgumentException("Unknown EAP method");
    }
}
------------------------
Find a silently evolved API code:android.widget.GridLayout.onLayout:COMMENT
Method Modifier: protected   
Comment:/*
     The layout operation is implemented by delegating the heavy lifting to the
     to the mHorizontalAxis and mVerticalAxis instances of the internal Axis class.
     Together they compute the locations of the vertical and horizontal lines of
     the grid (respectively!).

     This method is then left with the simpler task of applying margins, gravity
     and sizing to each child view and then placing it in its cell.
     */

Body of Frist Method:
{
    consistencyCheck();
    int targetWidth = right - left;
    int targetHeight = bottom - top;
    int paddingLeft = getPaddingLeft();
    int paddingTop = getPaddingTop();
    int paddingRight = getPaddingRight();
    int paddingBottom = getPaddingBottom();
    mHorizontalAxis.layout(targetWidth - paddingLeft - paddingRight);
    mVerticalAxis.layout(targetHeight - paddingTop - paddingBottom);
    int[] hLocations = mHorizontalAxis.getLocations();
    int[] vLocations = mVerticalAxis.getLocations();
    for (int i = 0, N = getChildCount(); i < N; i++) {
        View c = getChildAt(i);
        if (c.getVisibility() == View.GONE)
            continue;
        LayoutParams lp = getLayoutParams(c);
        Spec columnSpec = lp.columnSpec;
        Spec rowSpec = lp.rowSpec;
        Interval colSpan = columnSpec.span;
        Interval rowSpan = rowSpec.span;
        int x1 = hLocations[colSpan.min];
        int y1 = vLocations[rowSpan.min];
        int x2 = hLocations[colSpan.max];
        int y2 = vLocations[rowSpan.max];
        int cellWidth = x2 - x1;
        int cellHeight = y2 - y1;
        int pWidth = getMeasurement(c, true);
        int pHeight = getMeasurement(c, false);
        Alignment hAlign = getAlignment(columnSpec.alignment, true);
        Alignment vAlign = getAlignment(rowSpec.alignment, false);
        Bounds boundsX = mHorizontalAxis.getGroupBounds().getValue(i);
        Bounds boundsY = mVerticalAxis.getGroupBounds().getValue(i);
        // Gravity offsets: the location of the alignment group relative to its cell group.
        int gravityOffsetX = hAlign.getGravityOffset(c, cellWidth - boundsX.size(true));
        int gravityOffsetY = vAlign.getGravityOffset(c, cellHeight - boundsY.size(true));
        int leftMargin = getMargin(c, true, true);
        int topMargin = getMargin(c, false, true);
        int rightMargin = getMargin(c, true, false);
        int bottomMargin = getMargin(c, false, false);
        int sumMarginsX = leftMargin + rightMargin;
        int sumMarginsY = topMargin + bottomMargin;
        // Alignment offsets: the location of the view relative to its alignment group.
        int alignmentOffsetX = boundsX.getOffset(this, c, hAlign, pWidth + sumMarginsX, true);
        int alignmentOffsetY = boundsY.getOffset(this, c, vAlign, pHeight + sumMarginsY, false);
        int width = hAlign.getSizeInCell(c, pWidth, cellWidth - sumMarginsX);
        int height = vAlign.getSizeInCell(c, pHeight, cellHeight - sumMarginsY);
        int dx = x1 + gravityOffsetX + alignmentOffsetX;
        int cx = !isLayoutRtl() ? paddingLeft + leftMargin + dx : targetWidth - width - paddingRight - rightMargin - dx;
        int cy = paddingTop + y1 + gravityOffsetY + alignmentOffsetY + topMargin;
        if (width != c.getMeasuredWidth() || height != c.getMeasuredHeight()) {
            c.measure(makeMeasureSpec(width, EXACTLY), makeMeasureSpec(height, EXACTLY));
        }
        c.layout(cx, cy, cx + width, cy + height);
    }
}
Body of Second Method:
{
    consistencyCheck();
    int targetWidth = right - left;
    int targetHeight = bottom - top;
    int paddingLeft = getPaddingLeft();
    int paddingTop = getPaddingTop();
    int paddingRight = getPaddingRight();
    int paddingBottom = getPaddingBottom();
    mHorizontalAxis.layout(targetWidth - paddingLeft - paddingRight);
    mVerticalAxis.layout(targetHeight - paddingTop - paddingBottom);
    int[] hLocations = mHorizontalAxis.getLocations();
    int[] vLocations = mVerticalAxis.getLocations();
    for (int i = 0, N = getChildCount(); i < N; i++) {
        View c = getChildAt(i);
        if (c.getVisibility() == View.GONE)
            continue;
        LayoutParams lp = getLayoutParams(c);
        Spec columnSpec = lp.columnSpec;
        Spec rowSpec = lp.rowSpec;
        Interval colSpan = columnSpec.span;
        Interval rowSpan = rowSpec.span;
        int x1 = hLocations[colSpan.min];
        int y1 = vLocations[rowSpan.min];
        int x2 = hLocations[colSpan.max];
        int y2 = vLocations[rowSpan.max];
        int cellWidth = x2 - x1;
        int cellHeight = y2 - y1;
        int pWidth = getMeasurement(c, true);
        int pHeight = getMeasurement(c, false);
        Alignment hAlign = columnSpec.getAbsoluteAlignment(true);
        Alignment vAlign = rowSpec.getAbsoluteAlignment(false);
        Bounds boundsX = mHorizontalAxis.getGroupBounds().getValue(i);
        Bounds boundsY = mVerticalAxis.getGroupBounds().getValue(i);
        // Gravity offsets: the location of the alignment group relative to its cell group.
        int gravityOffsetX = hAlign.getGravityOffset(c, cellWidth - boundsX.size(true));
        int gravityOffsetY = vAlign.getGravityOffset(c, cellHeight - boundsY.size(true));
        int leftMargin = getMargin(c, true, true);
        int topMargin = getMargin(c, false, true);
        int rightMargin = getMargin(c, true, false);
        int bottomMargin = getMargin(c, false, false);
        int sumMarginsX = leftMargin + rightMargin;
        int sumMarginsY = topMargin + bottomMargin;
        // Alignment offsets: the location of the view relative to its alignment group.
        int alignmentOffsetX = boundsX.getOffset(this, c, hAlign, pWidth + sumMarginsX, true);
        int alignmentOffsetY = boundsY.getOffset(this, c, vAlign, pHeight + sumMarginsY, false);
        int width = hAlign.getSizeInCell(c, pWidth, cellWidth - sumMarginsX);
        int height = vAlign.getSizeInCell(c, pHeight, cellHeight - sumMarginsY);
        int dx = x1 + gravityOffsetX + alignmentOffsetX;
        int cx = !isLayoutRtl() ? paddingLeft + leftMargin + dx : targetWidth - width - paddingRight - rightMargin - dx;
        int cy = paddingTop + y1 + gravityOffsetY + alignmentOffsetY + topMargin;
        if (width != c.getMeasuredWidth() || height != c.getMeasuredHeight()) {
            c.measure(makeMeasureSpec(width, EXACTLY), makeMeasureSpec(height, EXACTLY));
        }
        c.layout(cx, cy, cx + width, cy + height);
    }
}
------------------------
Find a silently evolved API code:android.widget.NumberPicker.setMinValue:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the min value of the picker.
 *
 * @param minValue The min value inclusive.
 *
 * <strong>Note:</strong> The length of the displayed values array
 * set via {@link #setDisplayedValues(String[])} must be equal to the
 * range of selectable numbers which is equal to
 * {@link #getMaxValue()} - {@link #getMinValue()} + 1.
 */

Body of Frist Method:
{
    if (mMinValue == minValue) {
        return;
    }
    if (minValue < 0) {
        throw new IllegalArgumentException("minValue must be >= 0");
    }
    mMinValue = minValue;
    if (mMinValue > mValue) {
        mValue = mMinValue;
    }
    boolean wrapSelectorWheel = mMaxValue - mMinValue > mSelectorIndices.length;
    setWrapSelectorWheel(wrapSelectorWheel);
    initializeSelectorWheelIndices();
    updateInputTextView();
    tryComputeMaxWidth();
    invalidate();
}
Body of Second Method:
{
    if (mMinValue == minValue) {
        return;
    }
    if (minValue < 0) {
        throw new IllegalArgumentException("minValue must be >= 0");
    }
    mMinValue = minValue;
    if (mMinValue > mValue) {
        mValue = mMinValue;
    }
    updateWrapSelectorWheel();
    initializeSelectorWheelIndices();
    updateInputTextView();
    tryComputeMaxWidth();
    invalidate();
}
------------------------
Find a silently evolved API code:android.content.res.BridgeTypedArray.getDimensionPixelSize:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve a dimensional unit attribute at <var>index</var> for use
 * as a size in raw pixels.  This is the same as
 * {@link #getDimension}, except the returned value is converted to
 * integer pixels for use as a size.  A size conversion involves
 * rounding the base value, and ensuring that a non-zero base value
 * is at least one pixel in size.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute dimension value multiplied by the appropriate
 * metric and truncated to integer pixels, or defValue if not defined.
 *
 * @see #getDimension
 * @see #getDimensionPixelOffset
 */

Body of Frist Method:
{
    try {
        return getDimension(index);
    } catch (RuntimeException e) {
        String s = getString(index);
        if (s != null) {
            // looks like we were unable to resolve the dimension value
            Bridge.getLog().warning(LayoutLog.TAG_RESOURCES_FORMAT, String.format("\"%1$s\" in attribute \"%2$s\" is not a valid format.", s, mNames[index]), null);
        }
        return defValue;
    }
}
Body of Second Method:
{
    try {
        return getDimension(index, null);
    } catch (RuntimeException e) {
        String s = getString(index);
        if (s != null) {
            // looks like we were unable to resolve the dimension value
            Bridge.getLog().warning(LayoutLog.TAG_RESOURCES_FORMAT, String.format("\"%1$s\" in attribute \"%2$s\" is not a valid format.", s, mNames[index]), null);
        }
        return defValue;
    }
}
------------------------
Find a silently evolved API code:android.os.Process.startViaZygote:COMMENT
Method Modifier: private     static      
Comment:/**
 * Starts a new process via the zygote mechanism.
 *
 * @param processClass Class name whose static main() to run
 * @param niceName 'nice' process name to appear in ps
 * @param uid a POSIX uid that the new process should setuid() to
 * @param gid a POSIX gid that the new process shuold setgid() to
 * @param gids null-ok; a list of supplementary group IDs that the
 * new process should setgroup() to.
 * @param debugFlags Additional flags.
 * @param targetSdkVersion The target SDK version for the app.
 * @param seInfo null-ok SELinux information for the new process.
 * @param abi the ABI the process should use.
 * @param instructionSet null-ok the instruction set to use.
 * @param appDataDir null-ok the data directory of the app.
 * @param extraArgs Additional arguments to supply to the zygote process.
 * @return An object that describes the result of the attempt to start the process.
 * @throws ZygoteStartFailedEx if process start failed for any reason
 */

Body of Frist Method:
{
    synchronized (Process.class) {
        ArrayList<String> argsForZygote = new ArrayList<String>();
        // --runtime-init, --setuid=, --setgid=,
        // and --setgroups= must go first
        argsForZygote.add("--runtime-init");
        argsForZygote.add("--setuid=" + uid);
        argsForZygote.add("--setgid=" + gid);
        if ((debugFlags & Zygote.DEBUG_ENABLE_JNI_LOGGING) != 0) {
            argsForZygote.add("--enable-jni-logging");
        }
        if ((debugFlags & Zygote.DEBUG_ENABLE_SAFEMODE) != 0) {
            argsForZygote.add("--enable-safemode");
        }
        if ((debugFlags & Zygote.DEBUG_ENABLE_DEBUGGER) != 0) {
            argsForZygote.add("--enable-debugger");
        }
        if ((debugFlags & Zygote.DEBUG_ENABLE_CHECKJNI) != 0) {
            argsForZygote.add("--enable-checkjni");
        }
        if ((debugFlags & Zygote.DEBUG_ENABLE_ASSERT) != 0) {
            argsForZygote.add("--enable-assert");
        }
        if (mountExternal == Zygote.MOUNT_EXTERNAL_MULTIUSER) {
            argsForZygote.add("--mount-external-multiuser");
        } else if (mountExternal == Zygote.MOUNT_EXTERNAL_MULTIUSER_ALL) {
            argsForZygote.add("--mount-external-multiuser-all");
        }
        argsForZygote.add("--target-sdk-version=" + targetSdkVersion);
        // --setgroups is a comma-separated list
        if (gids != null && gids.length > 0) {
            StringBuilder sb = new StringBuilder();
            sb.append("--setgroups=");
            int sz = gids.length;
            for (int i = 0; i < sz; i++) {
                if (i != 0) {
                    sb.append(',');
                }
                sb.append(gids[i]);
            }
            argsForZygote.add(sb.toString());
        }
        if (niceName != null) {
            argsForZygote.add("--nice-name=" + niceName);
        }
        if (seInfo != null) {
            argsForZygote.add("--seinfo=" + seInfo);
        }
        if (instructionSet != null) {
            argsForZygote.add("--instruction-set=" + instructionSet);
        }
        if (appDataDir != null) {
            argsForZygote.add("--app-data-dir=" + appDataDir);
        }
        argsForZygote.add(processClass);
        if (extraArgs != null) {
            for (String arg : extraArgs) {
                argsForZygote.add(arg);
            }
        }
        return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);
    }
}
Body of Second Method:
{
    synchronized (Process.class) {
        ArrayList<String> argsForZygote = new ArrayList<String>();
        // --runtime-args, --setuid=, --setgid=,
        // and --setgroups= must go first
        argsForZygote.add("--runtime-args");
        argsForZygote.add("--setuid=" + uid);
        argsForZygote.add("--setgid=" + gid);
        if ((debugFlags & Zygote.DEBUG_ENABLE_JNI_LOGGING) != 0) {
            argsForZygote.add("--enable-jni-logging");
        }
        if ((debugFlags & Zygote.DEBUG_ENABLE_SAFEMODE) != 0) {
            argsForZygote.add("--enable-safemode");
        }
        if ((debugFlags & Zygote.DEBUG_ENABLE_DEBUGGER) != 0) {
            argsForZygote.add("--enable-debugger");
        }
        if ((debugFlags & Zygote.DEBUG_ENABLE_CHECKJNI) != 0) {
            argsForZygote.add("--enable-checkjni");
        }
        if ((debugFlags & Zygote.DEBUG_ENABLE_JIT) != 0) {
            argsForZygote.add("--enable-jit");
        }
        if ((debugFlags & Zygote.DEBUG_GENERATE_DEBUG_INFO) != 0) {
            argsForZygote.add("--generate-debug-info");
        }
        if ((debugFlags & Zygote.DEBUG_ENABLE_ASSERT) != 0) {
            argsForZygote.add("--enable-assert");
        }
        if (mountExternal == Zygote.MOUNT_EXTERNAL_DEFAULT) {
            argsForZygote.add("--mount-external-default");
        } else if (mountExternal == Zygote.MOUNT_EXTERNAL_READ) {
            argsForZygote.add("--mount-external-read");
        } else if (mountExternal == Zygote.MOUNT_EXTERNAL_WRITE) {
            argsForZygote.add("--mount-external-write");
        }
        argsForZygote.add("--target-sdk-version=" + targetSdkVersion);
        // --setgroups is a comma-separated list
        if (gids != null && gids.length > 0) {
            StringBuilder sb = new StringBuilder();
            sb.append("--setgroups=");
            int sz = gids.length;
            for (int i = 0; i < sz; i++) {
                if (i != 0) {
                    sb.append(',');
                }
                sb.append(gids[i]);
            }
            argsForZygote.add(sb.toString());
        }
        if (niceName != null) {
            argsForZygote.add("--nice-name=" + niceName);
        }
        if (seInfo != null) {
            argsForZygote.add("--seinfo=" + seInfo);
        }
        if (instructionSet != null) {
            argsForZygote.add("--instruction-set=" + instructionSet);
        }
        if (appDataDir != null) {
            argsForZygote.add("--app-data-dir=" + appDataDir);
        }
        argsForZygote.add(processClass);
        if (extraArgs != null) {
            for (String arg : extraArgs) {
                argsForZygote.add(arg);
            }
        }
        return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);
    }
}
------------------------
Find a silently evolved API code:android.media.AudioRecord.audioParamCheck:COMMENT
Method Modifier: private     
Comment:// mSampleRate is valid

Body of Frist Method:
{
    // audio source
    if ((audioSource < MediaRecorder.AudioSource.DEFAULT) || ((audioSource > MediaRecorder.getAudioSourceMax()) && (audioSource != MediaRecorder.AudioSource.FM_TUNER) && (audioSource != MediaRecorder.AudioSource.HOTWORD))) {
        throw new IllegalArgumentException("Invalid audio source.");
    }
    mRecordSource = audioSource;
    // sample rate
    if ((sampleRateInHz < 4000) || (sampleRateInHz > 48000)) {
        throw new IllegalArgumentException(sampleRateInHz + "Hz is not a supported sample rate.");
    }
    mSampleRate = sampleRateInHz;
    // audio format
    switch(audioFormat) {
        case AudioFormat.ENCODING_DEFAULT:
            mAudioFormat = AudioFormat.ENCODING_PCM_16BIT;
            break;
        case AudioFormat.ENCODING_PCM_16BIT:
        case AudioFormat.ENCODING_PCM_8BIT:
            mAudioFormat = audioFormat;
            break;
        default:
            throw new IllegalArgumentException("Unsupported sample encoding." + " Should be ENCODING_PCM_8BIT or ENCODING_PCM_16BIT.");
    }
}
Body of Second Method:
{
    // audio source
    if ((audioSource < MediaRecorder.AudioSource.DEFAULT) || ((audioSource > MediaRecorder.getAudioSourceMax()) && (audioSource != MediaRecorder.AudioSource.RADIO_TUNER) && (audioSource != MediaRecorder.AudioSource.HOTWORD))) {
        throw new IllegalArgumentException("Invalid audio source.");
    }
    mRecordSource = audioSource;
    // sample rate
    if ((sampleRateInHz < SAMPLE_RATE_HZ_MIN) || (sampleRateInHz > SAMPLE_RATE_HZ_MAX)) {
        throw new IllegalArgumentException(sampleRateInHz + "Hz is not a supported sample rate.");
    }
    mSampleRate = sampleRateInHz;
    // audio format
    switch(audioFormat) {
        case AudioFormat.ENCODING_DEFAULT:
            mAudioFormat = AudioFormat.ENCODING_PCM_16BIT;
            break;
        case AudioFormat.ENCODING_PCM_FLOAT:
        case AudioFormat.ENCODING_PCM_16BIT:
        case AudioFormat.ENCODING_PCM_8BIT:
            mAudioFormat = audioFormat;
            break;
        default:
            throw new IllegalArgumentException("Unsupported sample encoding." + " Should be ENCODING_PCM_8BIT, ENCODING_PCM_16BIT, or ENCODING_PCM_FLOAT.");
    }
}
------------------------
Find a silently evolved API code:android.content.res.BridgeTypedArray.sealArray:COMMENT
Method Modifier: public      
Comment:/**
 * Seals the array after all calls to
 * {@link #bridgeSetValue(int, String, boolean, ResourceValue)} have been done.
 * <p/>This allows to compute the list of non default values, permitting
 * {@link #getIndexCount()} to return the proper value.
 */

Body of Frist Method:
{
    // fills TypedArray.mIndices which is used to implement getIndexCount/getIndexAt
    // first count the array size
    int count = 0;
    for (int i = 0; i < mResourceData.length; i++) {
        ResourceValue data = mResourceData[i];
        if (data != null) {
            if (RenderResources.REFERENCE_NULL.equals(data.getValue())) {
                // No need to store this resource value. This saves needless checking for
                // "@null" every time  an attribute is requested.
                mResourceData[i] = null;
            } else {
                count++;
            }
        }
    }
    // allocate the table with an extra to store the size
    mIndices = new int[count + 1];
    mIndices[0] = count;
    // fill the array with the indices.
    int index = 1;
    for (int i = 0; i < mResourceData.length; i++) {
        if (mResourceData[i] != null) {
            mIndices[index++] = i;
        }
    }
}
Body of Second Method:
{
    // fills TypedArray.mIndices which is used to implement getIndexCount/getIndexAt
    // first count the array size
    int count = 0;
    ArrayList<Integer> emptyIds = null;
    for (int i = 0; i < mResourceData.length; i++) {
        ResourceValue data = mResourceData[i];
        if (data != null) {
            String dataValue = data.getValue();
            if (REFERENCE_NULL.equals(dataValue) || REFERENCE_UNDEFINED.equals(dataValue)) {
                mResourceData[i] = null;
            } else if (REFERENCE_EMPTY.equals(dataValue)) {
                mResourceData[i] = null;
                if (emptyIds == null) {
                    emptyIds = new ArrayList<Integer>(4);
                }
                emptyIds.add(i);
            } else {
                count++;
            }
        }
    }
    if (emptyIds != null) {
        mEmptyIds = new int[emptyIds.size()];
        for (int i = 0; i < emptyIds.size(); i++) {
            mEmptyIds[i] = emptyIds.get(i);
        }
    }
    // allocate the table with an extra to store the size
    mIndices = new int[count + 1];
    mIndices[0] = count;
    // fill the array with the indices.
    int index = 1;
    for (int i = 0; i < mResourceData.length; i++) {
        if (mResourceData[i] != null) {
            mIndices[index++] = i;
        }
    }
}
------------------------
Find a silently evolved API code:android.transition.Transition.addUnmatched:COMMENT
Method Modifier: private     
Comment:/**
 * Adds all values from unmatchedStart and unmatchedEnd to mStartValuesList and mEndValuesList,
 * assuming that there is no match between values in the list.
 */

Body of Frist Method:
{
    // Views that only exist in the start Scene
    for (int i = 0; i < unmatchedStart.size(); i++) {
        mStartValuesList.add(unmatchedStart.valueAt(i));
        mEndValuesList.add(null);
    }
    // Views that only exist in the end Scene
    for (int i = 0; i < unmatchedEnd.size(); i++) {
        mEndValuesList.add(unmatchedEnd.valueAt(i));
        mStartValuesList.add(null);
    }
}
Body of Second Method:
{
    // Views that only exist in the start Scene
    for (int i = 0; i < unmatchedStart.size(); i++) {
        final TransitionValues start = unmatchedStart.valueAt(i);
        if (isValidTarget(start.view)) {
            mStartValuesList.add(start);
            mEndValuesList.add(null);
        }
    }
    // Views that only exist in the end Scene
    for (int i = 0; i < unmatchedEnd.size(); i++) {
        final TransitionValues end = unmatchedEnd.valueAt(i);
        if (isValidTarget(end.view)) {
            mEndValuesList.add(end);
            mStartValuesList.add(null);
        }
    }
}
------------------------
Find a silently evolved API code:android.app.BackStackRecord.addTransitionTargets:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Prepares the enter transition by adding a non-existent view to the transition's target list
 * and setting it epicenter callback. By adding a non-existent view to the target list,
 * we can prevent any view from being targeted at the beginning of the transition.
 * We will add to the views before the end state of the transition is captured so that the
 * views will appear. At the start of the transition, we clear the list of targets so that
 * we can restore the state of the transition and use it again.
 *
 * <p>The shared element transition maps its shared elements immediately prior to
 * capturing the final state of the Transition.</p>
 */

Body of Frist Method:
{
    if (enterTransition == null && sharedElementTransition == null && overallTransition == null) {
        return null;
    }
    final ArrayList<View> enteringViews = new ArrayList<View>();
    container.getViewTreeObserver().addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {

        @Override
        public boolean onPreDraw() {
            container.getViewTreeObserver().removeOnPreDrawListener(this);
            // Don't include any newly-hidden fragments in the transition.
            excludeHiddenFragments(hiddenFragmentViews, inFragment.mContainerId, overallTransition);
            ArrayMap<String, View> namedViews = null;
            if (sharedElementTransition != null) {
                namedViews = mapSharedElementsIn(state, isBack, inFragment);
                removeTargets(sharedElementTransition, sharedElementTargets);
                sharedElementTargets.clear();
                sharedElementTargets.add(state.nonExistentView);
                sharedElementTargets.addAll(namedViews.values());
                addTargets(sharedElementTransition, sharedElementTargets);
                setEpicenterIn(namedViews, state);
                callSharedElementEnd(state, inFragment, outFragment, isBack, namedViews);
            }
            if (enterTransition != null) {
                View view = inFragment.getView();
                if (view != null) {
                    view.captureTransitioningViews(enteringViews);
                    if (namedViews != null) {
                        enteringViews.removeAll(namedViews.values());
                    }
                    enteringViews.add(state.nonExistentView);
                    // We added this earlier to prevent any views being targeted.
                    enterTransition.removeTarget(state.nonExistentView);
                    addTargets(enterTransition, enteringViews);
                }
                setSharedElementEpicenter(enterTransition, state);
            }
            return true;
        }
    });
    return enteringViews;
}
Body of Second Method:
{
    if (enterTransition == null && sharedElementTransition == null && overallTransition == null) {
        return null;
    }
    final ArrayList<View> enteringViews = new ArrayList<View>();
    container.getViewTreeObserver().addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {

        @Override
        public boolean onPreDraw() {
            container.getViewTreeObserver().removeOnPreDrawListener(this);
            // Don't include any newly-hidden fragments in the transition.
            if (inFragment != null) {
                excludeHiddenFragments(hiddenFragmentViews, inFragment.mContainerId, overallTransition);
            }
            ArrayMap<String, View> namedViews = null;
            if (sharedElementTransition != null) {
                namedViews = mapSharedElementsIn(state, isBack, inFragment);
                removeTargets(sharedElementTransition, sharedElementTargets);
                setSharedElementTargets(sharedElementTransition, state.nonExistentView, namedViews, sharedElementTargets);
                setEpicenterIn(namedViews, state);
                callSharedElementEnd(state, inFragment, outFragment, isBack, namedViews);
            }
            if (enterTransition != null) {
                enterTransition.removeTarget(state.nonExistentView);
                View view = inFragment.getView();
                if (view != null) {
                    view.captureTransitioningViews(enteringViews);
                    if (namedViews != null) {
                        enteringViews.removeAll(namedViews.values());
                    }
                    enteringViews.add(state.nonExistentView);
                    // We added this earlier to prevent any views being targeted.
                    addTargets(enterTransition, enteringViews);
                }
                setSharedElementEpicenter(enterTransition, state);
            }
            return true;
        }
    });
    return enteringViews;
}
------------------------
Find a silently evolved API code:android.app.Notification.Builder.buildUnstyled:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Apply the unstyled operations and return a new {@link Notification} object.
 * @hide
 */

Body of Frist Method:
{
    Notification n = new Notification();
    n.when = mWhen;
    n.icon = mSmallIcon;
    n.iconLevel = mSmallIconLevel;
    n.number = mNumber;
    n.color = sanitizeColor();
    setBuilderContentView(n, makeContentView());
    n.contentIntent = mContentIntent;
    n.deleteIntent = mDeleteIntent;
    n.fullScreenIntent = mFullScreenIntent;
    n.tickerText = mTickerText;
    n.tickerView = makeTickerView();
    n.largeIcon = mLargeIcon;
    n.sound = mSound;
    n.audioStreamType = mAudioStreamType;
    n.audioAttributes = mAudioAttributes;
    n.vibrate = mVibrate;
    n.ledARGB = mLedArgb;
    n.ledOnMS = mLedOnMs;
    n.ledOffMS = mLedOffMs;
    n.defaults = mDefaults;
    n.flags = mFlags;
    setBuilderBigContentView(n, makeBigContentView());
    setBuilderHeadsUpContentView(n, makeHeadsUpContentView());
    if (mLedOnMs != 0 || mLedOffMs != 0) {
        n.flags |= FLAG_SHOW_LIGHTS;
    }
    if ((mDefaults & DEFAULT_LIGHTS) != 0) {
        n.flags |= FLAG_SHOW_LIGHTS;
    }
    n.category = mCategory;
    n.mGroupKey = mGroupKey;
    n.mSortKey = mSortKey;
    n.priority = mPriority;
    if (mActions.size() > 0) {
        n.actions = new Action[mActions.size()];
        mActions.toArray(n.actions);
    }
    n.visibility = mVisibility;
    if (mPublicVersion != null) {
        n.publicVersion = new Notification();
        mPublicVersion.cloneInto(n.publicVersion, true);
    }
    // Note: If you're adding new fields, also update restoreFromNotitification().
    return n;
}
Body of Second Method:
{
    Notification n = new Notification();
    n.when = mWhen;
    n.mSmallIcon = mSmallIcon;
    if (mSmallIcon != null && mSmallIcon.getType() == Icon.TYPE_RESOURCE) {
        n.icon = mSmallIcon.getResId();
    }
    n.iconLevel = mSmallIconLevel;
    n.number = mNumber;
    n.color = sanitizeColor();
    setBuilderContentView(n, makeContentView());
    n.contentIntent = mContentIntent;
    n.deleteIntent = mDeleteIntent;
    n.fullScreenIntent = mFullScreenIntent;
    n.tickerText = mTickerText;
    n.tickerView = makeTickerView();
    n.mLargeIcon = mLargeIcon;
    if (mLargeIcon != null && mLargeIcon.getType() == Icon.TYPE_BITMAP) {
        n.largeIcon = mLargeIcon.getBitmap();
    }
    n.sound = mSound;
    n.audioStreamType = mAudioStreamType;
    n.audioAttributes = mAudioAttributes;
    n.vibrate = mVibrate;
    n.ledARGB = mLedArgb;
    n.ledOnMS = mLedOnMs;
    n.ledOffMS = mLedOffMs;
    n.defaults = mDefaults;
    n.flags = mFlags;
    setBuilderBigContentView(n, makeBigContentView());
    setBuilderHeadsUpContentView(n, makeHeadsUpContentView());
    if (mLedOnMs != 0 || mLedOffMs != 0) {
        n.flags |= FLAG_SHOW_LIGHTS;
    }
    if ((mDefaults & DEFAULT_LIGHTS) != 0) {
        n.flags |= FLAG_SHOW_LIGHTS;
    }
    n.category = mCategory;
    n.mGroupKey = mGroupKey;
    n.mSortKey = mSortKey;
    n.priority = mPriority;
    if (mActions.size() > 0) {
        n.actions = new Action[mActions.size()];
        mActions.toArray(n.actions);
    }
    n.visibility = mVisibility;
    if (mPublicVersion != null) {
        n.publicVersion = new Notification();
        mPublicVersion.cloneInto(n.publicVersion, true);
    }
    // Note: If you're adding new fields, also update restoreFromNotitification().
    return n;
}
------------------------
Find a silently evolved API code:android.graphics.Bitmap.getPixels:COMMENT
Method Modifier: public      
Comment:/**
 * Returns in pixels[] a copy of the data in the bitmap. Each value is
 * a packed int representing a {@link Color}. The stride parameter allows
 * the caller to allow for gaps in the returned pixels array between
 * rows. For normal packed results, just pass width for the stride value.
 * The returned colors are non-premultiplied ARGB values.
 *
 * @param pixels   The array to receive the bitmap's colors
 * @param offset   The first index to write into pixels[]
 * @param stride   The number of entries in pixels[] to skip between
 * rows (must be >= bitmap's width). Can be negative.
 * @param x        The x coordinate of the first pixel to read from
 * the bitmap
 * @param y        The y coordinate of the first pixel to read from
 * the bitmap
 * @param width    The number of pixels to read from each row
 * @param height   The number of rows to read
 *
 * @throws IllegalArgumentException if x, y, width, height exceed the
 * bounds of the bitmap, or if abs(stride) < width.
 * @throws ArrayIndexOutOfBoundsException if the pixels array is too small
 * to receive the specified number of pixels.
 */

Body of Frist Method:
{
    checkRecycled("Can't call getPixels() on a recycled bitmap");
    if (width == 0 || height == 0) {
        // nothing to do
        return;
    }
    checkPixelsAccess(x, y, width, height, offset, stride, pixels);
    nativeGetPixels(mNativeBitmap, pixels, offset, stride, x, y, width, height);
}
Body of Second Method:
{
    checkRecycled("Can't call getPixels() on a recycled bitmap");
    if (width == 0 || height == 0) {
        // nothing to do
        return;
    }
    checkPixelsAccess(x, y, width, height, offset, stride, pixels);
    nativeGetPixels(mFinalizer.mNativeBitmap, pixels, offset, stride, x, y, width, height);
}
------------------------
Find a silently evolved API code:android.widget.Gallery.onKeyDown:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * Handles left, right, and clicking
 * @see android.view.View#onKeyDown
 */

Body of Frist Method:
{
    switch(keyCode) {
        case KeyEvent.KEYCODE_DPAD_LEFT:
            if (movePrevious()) {
                playSoundEffect(SoundEffectConstants.NAVIGATION_LEFT);
                return true;
            }
            break;
        case KeyEvent.KEYCODE_DPAD_RIGHT:
            if (moveNext()) {
                playSoundEffect(SoundEffectConstants.NAVIGATION_RIGHT);
                return true;
            }
            break;
        case KeyEvent.KEYCODE_DPAD_CENTER:
        case KeyEvent.KEYCODE_ENTER:
            mReceivedInvokeKeyDown = true;
    }
    return super.onKeyDown(keyCode, event);
}
Body of Second Method:
{
    switch(keyCode) {
        case KeyEvent.KEYCODE_DPAD_LEFT:
            if (moveDirection(-1)) {
                playSoundEffect(SoundEffectConstants.NAVIGATION_LEFT);
                return true;
            }
            break;
        case KeyEvent.KEYCODE_DPAD_RIGHT:
            if (moveDirection(1)) {
                playSoundEffect(SoundEffectConstants.NAVIGATION_RIGHT);
                return true;
            }
            break;
        case KeyEvent.KEYCODE_DPAD_CENTER:
        case KeyEvent.KEYCODE_ENTER:
            mReceivedInvokeKeyDown = true;
    }
    return super.onKeyDown(keyCode, event);
}
------------------------
Find a silently evolved API code:android.text.SpannableStringBuilder.getSpanEnd:COMMENT
Method Modifier: public      
Comment:/**
 * Return the buffer offset of the end of the specified
 * markup object, or -1 if it is not attached to this buffer.
 */

Body of Frist Method:
{
    int count = mSpanCount;
    Object[] spans = mSpans;
    for (int i = count - 1; i >= 0; i--) {
        if (spans[i] == what) {
            int where = mSpanEnds[i];
            if (where > mGapStart)
                where -= mGapLength;
            return where;
        }
    }
    return -1;
}
Body of Second Method:
{
    if (mIndexOfSpan == null)
        return -1;
    Integer i = mIndexOfSpan.get(what);
    return i == null ? -1 : resolveGap(mSpanEnds[i]);
}
------------------------
Find a silently evolved API code:android.text.format.DateFormat.getDateFormatOrder:COMMENT
Method Modifier: public      static      
Comment:/**
 * Gets the current date format stored as a char array. Returns a 3 element
 * array containing the day ({@code 'd'}), month ({@code 'M'}), and year ({@code 'y'}))
 * in the order specified by the user's format preference.  Note that this order is
 * <i>only</i> appropriate for all-numeric dates; spelled-out (MEDIUM and LONG)
 * dates will generally contain other punctuation, spaces, or words,
 * not just the day, month, and year, and not necessarily in the same
 * order returned here.
 */

Body of Frist Method:
{
    return ICU.getDateFormatOrder(getDateFormatString(context));
}
Body of Second Method:
{
    return ICU.getDateFormatOrder(getDateFormatString());
}
------------------------
Find a silently evolved API code:android.media.AudioManager.forceVolumeControlStream:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * forces the stream controlled by hard volume keys
 * specifying streamType == -1 releases control to the
 * logic.
 *
 * @hide
 */

Body of Frist Method:
{
    if (mUseMasterVolume) {
        return;
    }
    IAudioService service = getService();
    try {
        service.forceVolumeControlStream(streamType, mICallBack);
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in forceVolumeControlStream", e);
    }
}
Body of Second Method:
{
    IAudioService service = getService();
    try {
        service.forceVolumeControlStream(streamType, mICallBack);
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in forceVolumeControlStream", e);
    }
}
------------------------
Find a silently evolved API code:android.transition.TransitionManager.changeScene:COMMENT
Method Modifier: private     static      
Comment:/**
 * This is where all of the work of a transition/scene-change is
 * orchestrated. This method captures the start values for the given
 * transition, exits the current Scene, enters the new scene, captures
 * the end values for the transition, and finally plays the
 * resulting values-populated transition.
 *
 * @param scene The scene being entered
 * @param transition The transition to play for this scene change
 */

Body of Frist Method:
{
    final ViewGroup sceneRoot = scene.getSceneRoot();
    Transition transitionClone = null;
    if (transition != null) {
        transitionClone = transition.clone();
        transitionClone.setSceneRoot(sceneRoot);
    }
    Scene oldScene = Scene.getCurrentScene(sceneRoot);
    if (oldScene != null && transitionClone != null && oldScene.isCreatedFromLayoutResource()) {
        transitionClone.setCanRemoveViews(true);
    }
    sceneChangeSetup(sceneRoot, transitionClone);
    scene.enter();
    sceneChangeRunTransition(sceneRoot, transitionClone);
}
Body of Second Method:
{
    final ViewGroup sceneRoot = scene.getSceneRoot();
    if (!sPendingTransitions.contains(sceneRoot)) {
        sPendingTransitions.add(sceneRoot);
        Transition transitionClone = null;
        if (transition != null) {
            transitionClone = transition.clone();
            transitionClone.setSceneRoot(sceneRoot);
        }
        Scene oldScene = Scene.getCurrentScene(sceneRoot);
        if (oldScene != null && transitionClone != null && oldScene.isCreatedFromLayoutResource()) {
            transitionClone.setCanRemoveViews(true);
        }
        sceneChangeSetup(sceneRoot, transitionClone);
        scene.enter();
        sceneChangeRunTransition(sceneRoot, transitionClone);
    }
}
------------------------
Find a silently evolved API code:android.telephony.ServiceState.setFromNotifierBundle:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Set ServiceState based on intent notifier map.
 *
 * @param m intent notifier map
 * @hide
 */

Body of Frist Method:
{
    mVoiceRegState = m.getInt("voiceRegState");
    mDataRegState = m.getInt("dataRegState");
    mVoiceRoamingType = m.getInt("voiceRoamingType");
    mDataRoamingType = m.getInt("dataRoamingType");
    mVoiceOperatorAlphaLong = m.getString("operator-alpha-long");
    mVoiceOperatorAlphaShort = m.getString("operator-alpha-short");
    mVoiceOperatorNumeric = m.getString("operator-numeric");
    mDataOperatorAlphaLong = m.getString("data-operator-alpha-long");
    mDataOperatorAlphaShort = m.getString("data-operator-alpha-short");
    mDataOperatorNumeric = m.getString("data-operator-numeric");
    mIsManualNetworkSelection = m.getBoolean("manual");
    mRilVoiceRadioTechnology = m.getInt("radioTechnology");
    mRilDataRadioTechnology = m.getInt("dataRadioTechnology");
    mCssIndicator = m.getBoolean("cssIndicator");
    mNetworkId = m.getInt("networkId");
    mSystemId = m.getInt("systemId");
    mCdmaRoamingIndicator = m.getInt("cdmaRoamingIndicator");
    mCdmaDefaultRoamingIndicator = m.getInt("cdmaDefaultRoamingIndicator");
    mIsEmergencyOnly = m.getBoolean("emergencyOnly");
}
Body of Second Method:
{
    mVoiceRegState = m.getInt("voiceRegState");
    mDataRegState = m.getInt("dataRegState");
    mVoiceRoamingType = m.getInt("voiceRoamingType");
    mDataRoamingType = m.getInt("dataRoamingType");
    mVoiceOperatorAlphaLong = m.getString("operator-alpha-long");
    mVoiceOperatorAlphaShort = m.getString("operator-alpha-short");
    mVoiceOperatorNumeric = m.getString("operator-numeric");
    mDataOperatorAlphaLong = m.getString("data-operator-alpha-long");
    mDataOperatorAlphaShort = m.getString("data-operator-alpha-short");
    mDataOperatorNumeric = m.getString("data-operator-numeric");
    mIsManualNetworkSelection = m.getBoolean("manual");
    mRilVoiceRadioTechnology = m.getInt("radioTechnology");
    mRilDataRadioTechnology = m.getInt("dataRadioTechnology");
    mCssIndicator = m.getBoolean("cssIndicator");
    mNetworkId = m.getInt("networkId");
    mSystemId = m.getInt("systemId");
    mCdmaRoamingIndicator = m.getInt("cdmaRoamingIndicator");
    mCdmaDefaultRoamingIndicator = m.getInt("cdmaDefaultRoamingIndicator");
    mIsEmergencyOnly = m.getBoolean("emergencyOnly");
    mIsDataRoamingFromRegistration = m.getBoolean("isDataRoamingFromRegistration");
}
------------------------
Find a silently evolved API code:android.media.MediaCodecInfo.VideoCapabilities.getSupportedWidthsFor:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the range of supported video widths for a video height.
 * @param height the height of the video
 */

Body of Frist Method:
{
    try {
        Range<Integer> range = mWidthRange;
        if (!mHeightRange.contains(height) || (height % mHeightAlignment) != 0) {
            throw new IllegalArgumentException("unsupported height");
        }
        final int heightInBlocks = Utils.divUp(height, mBlockHeight);
        // constrain by block count and by block aspect ratio
        final int minWidthInBlocks = Math.max(Utils.divUp(mBlockCountRange.getLower(), heightInBlocks), (int) Math.ceil(mBlockAspectRatioRange.getLower().doubleValue() * heightInBlocks));
        final int maxWidthInBlocks = Math.min(mBlockCountRange.getUpper() / heightInBlocks, (int) (mBlockAspectRatioRange.getUpper().doubleValue() * heightInBlocks));
        range = range.intersect((minWidthInBlocks - 1) * mBlockWidth + mWidthAlignment, maxWidthInBlocks * mBlockWidth);
        // constrain by smaller dimension limit
        if (height > mSmallerDimensionUpperLimit) {
            range = range.intersect(1, mSmallerDimensionUpperLimit);
        }
        // constrain by aspect ratio
        range = range.intersect((int) Math.ceil(mAspectRatioRange.getLower().doubleValue() * height), (int) (mAspectRatioRange.getUpper().doubleValue() * height));
        return range;
    } catch (IllegalArgumentException e) {
        // should not be here
        Log.w(TAG, "could not get supported widths for " + height, e);
        throw new IllegalArgumentException("unsupported height");
    }
}
Body of Second Method:
{
    try {
        Range<Integer> range = mWidthRange;
        if (!mHeightRange.contains(height) || (height % mHeightAlignment) != 0) {
            throw new IllegalArgumentException("unsupported height");
        }
        final int heightInBlocks = Utils.divUp(height, mBlockHeight);
        // constrain by block count and by block aspect ratio
        final int minWidthInBlocks = Math.max(Utils.divUp(mBlockCountRange.getLower(), heightInBlocks), (int) Math.ceil(mBlockAspectRatioRange.getLower().doubleValue() * heightInBlocks));
        final int maxWidthInBlocks = Math.min(mBlockCountRange.getUpper() / heightInBlocks, (int) (mBlockAspectRatioRange.getUpper().doubleValue() * heightInBlocks));
        range = range.intersect((minWidthInBlocks - 1) * mBlockWidth + mWidthAlignment, maxWidthInBlocks * mBlockWidth);
        // constrain by smaller dimension limit
        if (height > mSmallerDimensionUpperLimit) {
            range = range.intersect(1, mSmallerDimensionUpperLimit);
        }
        // constrain by aspect ratio
        range = range.intersect((int) Math.ceil(mAspectRatioRange.getLower().doubleValue() * height), (int) (mAspectRatioRange.getUpper().doubleValue() * height));
        return range;
    } catch (IllegalArgumentException e) {
        // height is not supported because there are no suitable widths
        Log.v(TAG, "could not get supported widths for " + height);
        throw new IllegalArgumentException("unsupported height");
    }
}
------------------------
Find a silently evolved API code:android.net.http.HttpResponseCache.delete:COMMENT
Method Modifier: public      
Comment:/**
 * Uninstalls the cache and deletes all of its stored contents.
 */

Body of Frist Method:
{
    if (ResponseCache.getDefault() == this.delegate) {
        ResponseCache.setDefault(null);
    }
    delegate.delete();
}
Body of Second Method:
{
    if (ResponseCache.getDefault() == this) {
        ResponseCache.setDefault(null);
    }
    delegate.delete();
}
------------------------
Find a silently evolved API code:android.hardware.camera2.utils.TaskDrainer.taskStarted:COMMENT
Method Modifier: public      
Comment:/**
 * Mark an asynchronous task as having started.
 *
 * <p>A task cannot be started more than once without first having finished. Once
 * draining begins with {@link #beginDrain}, no new tasks can be started.</p>
 *
 * @param task a key to identify a task
 *
 * @see #taskFinished
 * @see #beginDrain
 *
 * @throws IllegalStateException
 * If attempting to start a task which is already started (and not finished),
 * or if attempting to start a task after draining has begun.
 */

Body of Frist Method:
{
    synchronized (mLock) {
        if (VERBOSE) {
            Log.v(TAG + "[" + mName + "]", "taskStarted " + task);
        }
        if (mDraining) {
            throw new IllegalStateException("Can't start more tasks after draining has begun");
        }
        if (!mTaskSet.add(task)) {
            throw new IllegalStateException("Task " + task + " was already started");
        }
    }
}
Body of Second Method:
{
    synchronized (mLock) {
        if (DEBUG) {
            Log.v(TAG + "[" + mName + "]", "taskStarted " + task);
        }
        if (mDraining) {
            throw new IllegalStateException("Can't start more tasks after draining has begun");
        }
        if (!mTaskSet.add(task)) {
            throw new IllegalStateException("Task " + task + " was already started");
        }
    }
}
------------------------
Find a silently evolved API code:android.media.AudioTrack.setPlaybackPositionUpdateListener:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the listener the AudioTrack notifies when a previously set marker is reached or
 * for each periodic playback head position update.
 * Use this method to receive AudioTrack events in the Handler associated with another
 * thread than the one in which you created the AudioTrack instance.
 * @param listener
 * @param handler the Handler that will receive the event notification messages.
 */

Body of Frist Method:
{
    if (listener != null) {
        mEventHandlerDelegate = new NativeEventHandlerDelegate(this, listener, handler);
    } else {
        mEventHandlerDelegate = null;
    }
}
Body of Second Method:
{
    if (listener != null) {
        mEventHandlerDelegate = new NativePositionEventHandlerDelegate(this, listener, handler);
    } else {
        mEventHandlerDelegate = null;
    }
}
------------------------
Find a silently evolved API code:android.os.Environment.getExternalStorageState:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns the current state of the primary "external" storage device.
 *
 * @see #getExternalStorageDirectory()
 * @return one of {@link #MEDIA_UNKNOWN}, {@link #MEDIA_REMOVED},
 * {@link #MEDIA_UNMOUNTED}, {@link #MEDIA_CHECKING},
 * {@link #MEDIA_NOFS}, {@link #MEDIA_MOUNTED},
 * {@link #MEDIA_MOUNTED_READ_ONLY}, {@link #MEDIA_SHARED},
 * {@link #MEDIA_BAD_REMOVAL}, or {@link #MEDIA_UNMOUNTABLE}.
 */

Body of Frist Method:
{
    final File externalDir = sCurrentUser.getExternalDirsForApp()[0];
    return getExternalStorageState(externalDir);
}
Body of Second Method:
{
    final File externalDir = sCurrentUser.getExternalDirs()[0];
    return getExternalStorageState(externalDir);
}
------------------------
Find a silently evolved API code:android.accounts.AccountManager.getAccountsByTypeForPackage:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the accounts visible to the specified package, in an environment where some apps
 * are not authorized to view all accounts. This method can only be called by system apps.
 * @param type The type of accounts to return, null to retrieve all accounts
 * @param packageName The package name of the app for which the accounts are to be returned
 * @return An array of {@link Account}, one per matching account.  Empty
 * (never null) if no accounts of the specified type have been added.
 */

Body of Frist Method:
{
    try {
        return mService.getAccountsByTypeForPackage(type, packageName);
    } catch (RemoteException re) {
        // possible security exception
        throw new RuntimeException(re);
    }
}
Body of Second Method:
{
    try {
        return mService.getAccountsByTypeForPackage(type, packageName, mContext.getOpPackageName());
    } catch (RemoteException re) {
        // won't ever happen
        throw new RuntimeException(re);
    }
}
------------------------
Find a silently evolved API code:android.net.RouteInfo.matches:COMMENT
Method Modifier: public      
Comment:/**
 * Determines whether the destination and prefix of this route includes the specified
 * address.
 *
 * @param destination A {@link InetAddress} to test to see if it would match this route.
 * @return {@code true} if the destination and prefix length cover the given address.
 */

Body of Frist Method:
{
    if (destination == null)
        return false;
    // match the route destination and destination with prefix length
    InetAddress dstNet = NetworkUtils.getNetworkPart(destination, mDestination.getPrefixLength());
    return mDestination.getAddress().equals(dstNet);
}
Body of Second Method:
{
    return mDestination.contains(destination);
}
------------------------
Find a silently evolved API code:android.app.ActivityOptions.update:COMMENT
Method Modifier: public      
Comment:/**
 * Update the current values in this ActivityOptions from those supplied
 * in <var>otherOptions</var>.  Any values
 * defined in <var>otherOptions</var> replace those in the base options.
 */

Body of Frist Method:
{
    if (otherOptions.mPackageName != null) {
        mPackageName = otherOptions.mPackageName;
    }
    mTransitionReceiver = null;
    mSharedElementNames = null;
    mIsReturning = false;
    mResultData = null;
    mResultCode = 0;
    mExitCoordinatorIndex = 0;
    mAnimationType = otherOptions.mAnimationType;
    switch(otherOptions.mAnimationType) {
        case ANIM_CUSTOM:
            mCustomEnterResId = otherOptions.mCustomEnterResId;
            mCustomExitResId = otherOptions.mCustomExitResId;
            mThumbnail = null;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = otherOptions.mAnimationStartedListener;
            break;
        case ANIM_CUSTOM_IN_PLACE:
            mCustomInPlaceResId = otherOptions.mCustomInPlaceResId;
            break;
        case ANIM_SCALE_UP:
            mStartX = otherOptions.mStartX;
            mStartY = otherOptions.mStartY;
            mWidth = otherOptions.mWidth;
            mHeight = otherOptions.mHeight;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = null;
            break;
        case ANIM_THUMBNAIL_SCALE_UP:
        case ANIM_THUMBNAIL_SCALE_DOWN:
        case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
        case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
            mThumbnail = otherOptions.mThumbnail;
            mStartX = otherOptions.mStartX;
            mStartY = otherOptions.mStartY;
            mWidth = otherOptions.mWidth;
            mHeight = otherOptions.mHeight;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = otherOptions.mAnimationStartedListener;
            break;
        case ANIM_SCENE_TRANSITION:
            mTransitionReceiver = otherOptions.mTransitionReceiver;
            mSharedElementNames = otherOptions.mSharedElementNames;
            mIsReturning = otherOptions.mIsReturning;
            mThumbnail = null;
            mAnimationStartedListener = null;
            mResultData = otherOptions.mResultData;
            mResultCode = otherOptions.mResultCode;
            mExitCoordinatorIndex = otherOptions.mExitCoordinatorIndex;
            break;
    }
}
Body of Second Method:
{
    if (otherOptions.mPackageName != null) {
        mPackageName = otherOptions.mPackageName;
    }
    mUsageTimeReport = otherOptions.mUsageTimeReport;
    mTransitionReceiver = null;
    mSharedElementNames = null;
    mIsReturning = false;
    mResultData = null;
    mResultCode = 0;
    mExitCoordinatorIndex = 0;
    mAnimationType = otherOptions.mAnimationType;
    switch(otherOptions.mAnimationType) {
        case ANIM_CUSTOM:
            mCustomEnterResId = otherOptions.mCustomEnterResId;
            mCustomExitResId = otherOptions.mCustomExitResId;
            mThumbnail = null;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = otherOptions.mAnimationStartedListener;
            break;
        case ANIM_CUSTOM_IN_PLACE:
            mCustomInPlaceResId = otherOptions.mCustomInPlaceResId;
            break;
        case ANIM_SCALE_UP:
            mStartX = otherOptions.mStartX;
            mStartY = otherOptions.mStartY;
            mWidth = otherOptions.mWidth;
            mHeight = otherOptions.mHeight;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = null;
            break;
        case ANIM_THUMBNAIL_SCALE_UP:
        case ANIM_THUMBNAIL_SCALE_DOWN:
        case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
        case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
            mThumbnail = otherOptions.mThumbnail;
            mStartX = otherOptions.mStartX;
            mStartY = otherOptions.mStartY;
            mWidth = otherOptions.mWidth;
            mHeight = otherOptions.mHeight;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = otherOptions.mAnimationStartedListener;
            break;
        case ANIM_SCENE_TRANSITION:
            mTransitionReceiver = otherOptions.mTransitionReceiver;
            mSharedElementNames = otherOptions.mSharedElementNames;
            mIsReturning = otherOptions.mIsReturning;
            mThumbnail = null;
            mAnimationStartedListener = null;
            mResultData = otherOptions.mResultData;
            mResultCode = otherOptions.mResultCode;
            mExitCoordinatorIndex = otherOptions.mExitCoordinatorIndex;
            break;
    }
}
------------------------
Find a silently evolved API code:android.webkit.WebView.findAll:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * Finds all instances of find on the page and highlights them.
 * Notifies any registered {@link FindListener}.
 *
 * @param find the string to find
 * @return the number of occurances of the String "find" that were found
 * @deprecated {@link #findAllAsync} is preferred.
 * @see #setFindListener
 */

Body of Frist Method:
{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, "findAll");
    StrictMode.noteSlowCall("findAll blocks UI: prefer findAllAsync");
    return mProvider.findAll(find);
}
Body of Second Method:
{
    checkThread();
    StrictMode.noteSlowCall("findAll blocks UI: prefer findAllAsync");
    return mProvider.findAll(find);
}
------------------------
Find a silently evolved API code:javax.obex.ClientOperation.startProcessing:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * This method starts the processing thread results. It will send the
 * initial request. If the response takes more then one packet, a thread
 * will be started to handle additional requests
 * @throws IOException if an IO error occurs
 */

Body of Frist Method:
{
    if (mPrivateInput == null) {
        mPrivateInput = new PrivateInputStream(this);
    }
    boolean more = true;
    if (mGetOperation) {
        if (!mOperationDone) {
            if (!mGetFinalFlag) {
                mReplyHeader.responseCode = ResponseCodes.OBEX_HTTP_CONTINUE;
                while ((more) && (mReplyHeader.responseCode == ResponseCodes.OBEX_HTTP_CONTINUE)) {
                    more = sendRequest(0x03);
                }
                if (mReplyHeader.responseCode == ResponseCodes.OBEX_HTTP_CONTINUE) {
                    mParent.sendRequest(0x83, null, mReplyHeader, mPrivateInput);
                }
                if (mReplyHeader.responseCode != ResponseCodes.OBEX_HTTP_CONTINUE) {
                    mOperationDone = true;
                }
            } else {
                more = sendRequest(0x83);
                if (more) {
                    throw new IOException("FINAL_GET forced but data did not fit into single packet!");
                }
                mOperationDone = true;
            }
        }
    } else {
        if (!mOperationDone) {
            mReplyHeader.responseCode = ResponseCodes.OBEX_HTTP_CONTINUE;
            while ((more) && (mReplyHeader.responseCode == ResponseCodes.OBEX_HTTP_CONTINUE)) {
                more = sendRequest(0x02);
            }
        }
        if (mReplyHeader.responseCode == ResponseCodes.OBEX_HTTP_CONTINUE) {
            mParent.sendRequest(0x82, null, mReplyHeader, mPrivateInput);
        }
        if (mReplyHeader.responseCode != ResponseCodes.OBEX_HTTP_CONTINUE) {
            mOperationDone = true;
        }
    }
}
Body of Second Method:
{
    if (mPrivateInput == null) {
        mPrivateInput = new PrivateInputStream(this);
    }
    boolean more = true;
    if (mGetOperation) {
        if (!mOperationDone) {
            mReplyHeader.responseCode = ResponseCodes.OBEX_HTTP_CONTINUE;
            while ((more) && (mReplyHeader.responseCode == ResponseCodes.OBEX_HTTP_CONTINUE)) {
                more = sendRequest(ObexHelper.OBEX_OPCODE_GET);
            }
            // reply.
            if (mReplyHeader.responseCode == ResponseCodes.OBEX_HTTP_CONTINUE) {
                mParent.sendRequest(ObexHelper.OBEX_OPCODE_GET_FINAL, null, mReplyHeader, mPrivateInput, mSrmActive);
            }
            if (mReplyHeader.responseCode != ResponseCodes.OBEX_HTTP_CONTINUE) {
                mOperationDone = true;
            } else {
                checkForSrm();
            }
        }
    } else {
        // PUT operation
        if (!mOperationDone) {
            mReplyHeader.responseCode = ResponseCodes.OBEX_HTTP_CONTINUE;
            while ((more) && (mReplyHeader.responseCode == ResponseCodes.OBEX_HTTP_CONTINUE)) {
                more = sendRequest(ObexHelper.OBEX_OPCODE_PUT);
            }
        }
        if (mReplyHeader.responseCode == ResponseCodes.OBEX_HTTP_CONTINUE) {
            mParent.sendRequest(ObexHelper.OBEX_OPCODE_PUT_FINAL, null, mReplyHeader, mPrivateInput, mSrmActive);
        }
        if (mReplyHeader.responseCode != ResponseCodes.OBEX_HTTP_CONTINUE) {
            mOperationDone = true;
        }
    }
}
------------------------
Find a silently evolved API code:android.content.Intent.toShortString:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    boolean first = true;
    if (mAction != null) {
        b.append("act=").append(mAction);
        first = false;
    }
    if (mCategories != null) {
        if (!first) {
            b.append(' ');
        }
        first = false;
        b.append("cat=[");
        for (int i = 0; i < mCategories.size(); i++) {
            if (i > 0)
                b.append(',');
            b.append(mCategories.valueAt(i));
        }
        b.append("]");
    }
    if (mData != null) {
        if (!first) {
            b.append(' ');
        }
        first = false;
        b.append("dat=");
        if (secure) {
            b.append(mData.toSafeString());
        } else {
            b.append(mData);
        }
    }
    if (mType != null) {
        if (!first) {
            b.append(' ');
        }
        first = false;
        b.append("typ=").append(mType);
    }
    if (mFlags != 0) {
        if (!first) {
            b.append(' ');
        }
        first = false;
        b.append("flg=0x").append(Integer.toHexString(mFlags));
    }
    if (mPackage != null) {
        if (!first) {
            b.append(' ');
        }
        first = false;
        b.append("pkg=").append(mPackage);
    }
    if (comp && mComponent != null) {
        if (!first) {
            b.append(' ');
        }
        first = false;
        b.append("cmp=").append(mComponent.flattenToShortString());
    }
    if (mSourceBounds != null) {
        if (!first) {
            b.append(' ');
        }
        first = false;
        b.append("bnds=").append(mSourceBounds.toShortString());
    }
    if (mClipData != null) {
        if (!first) {
            b.append(' ');
        }
        first = false;
        if (clip) {
            b.append("clip={");
            mClipData.toShortString(b);
            b.append('}');
        } else {
            b.append("(has clip)");
        }
    }
    if (extras && mExtras != null) {
        if (!first) {
            b.append(' ');
        }
        first = false;
        b.append("(has extras)");
    }
    if (mContentUserHint != UserHandle.USER_CURRENT) {
        if (!first) {
            b.append(' ');
        }
        first = false;
        b.append("u=").append(mContentUserHint);
    }
    if (mSelector != null) {
        b.append(" sel=");
        mSelector.toShortString(b, secure, comp, extras, clip);
        b.append("}");
    }
}
Body of Second Method:
{
    boolean first = true;
    if (mAction != null) {
        b.append("act=").append(mAction);
        first = false;
    }
    if (mCategories != null) {
        if (!first) {
            b.append(' ');
        }
        first = false;
        b.append("cat=[");
        for (int i = 0; i < mCategories.size(); i++) {
            if (i > 0)
                b.append(',');
            b.append(mCategories.valueAt(i));
        }
        b.append("]");
    }
    if (mData != null) {
        if (!first) {
            b.append(' ');
        }
        first = false;
        b.append("dat=");
        if (secure) {
            b.append(mData.toSafeString());
        } else {
            b.append(mData);
        }
    }
    if (mType != null) {
        if (!first) {
            b.append(' ');
        }
        first = false;
        b.append("typ=").append(mType);
    }
    if (mFlags != 0) {
        if (!first) {
            b.append(' ');
        }
        first = false;
        b.append("flg=0x").append(Integer.toHexString(mFlags));
    }
    if (mPackage != null) {
        if (!first) {
            b.append(' ');
        }
        first = false;
        b.append("pkg=").append(mPackage);
    }
    if (comp && mComponent != null) {
        if (!first) {
            b.append(' ');
        }
        first = false;
        b.append("cmp=").append(mComponent.flattenToShortString());
    }
    if (mSourceBounds != null) {
        if (!first) {
            b.append(' ');
        }
        first = false;
        b.append("bnds=").append(mSourceBounds.toShortString());
    }
    if (mClipData != null) {
        if (!first) {
            b.append(' ');
        }
        b.append("clip={");
        if (clip) {
            mClipData.toShortString(b);
        } else {
            if (mClipData.getDescription() != null) {
                first = !mClipData.getDescription().toShortStringTypesOnly(b);
            } else {
                first = true;
            }
            mClipData.toShortStringShortItems(b, first);
        }
        first = false;
        b.append('}');
    }
    if (extras && mExtras != null) {
        if (!first) {
            b.append(' ');
        }
        first = false;
        b.append("(has extras)");
    }
    if (mContentUserHint != UserHandle.USER_CURRENT) {
        if (!first) {
            b.append(' ');
        }
        first = false;
        b.append("u=").append(mContentUserHint);
    }
    if (mSelector != null) {
        b.append(" sel=");
        mSelector.toShortString(b, secure, comp, extras, clip);
        b.append("}");
    }
}
------------------------
Find a silently evolved API code:android.view.ViewGroup_Delegate.drawChild:COMMENT
Method Modifier: default     static      
Comment:/**
 * Overrides the original drawChild call in ViewGroup to draw the shadow.
 */

Body of Frist Method:
{
    boolean retVal = thisVG.drawChild_Original(canvas, child, drawingTime);
    if (child.getZ() > thisVG.getZ()) {
        ViewOutlineProvider outlineProvider = child.getOutlineProvider();
        Outline outline = new Outline();
        outlineProvider.getOutline(child, outline);
        if (outline.mPath != null || (outline.mRect != null && !outline.mRect.isEmpty())) {
            int restoreTo = transformCanvas(thisVG, canvas, child);
            drawShadow(thisVG, canvas, child, outline);
            canvas.restoreToCount(restoreTo);
        }
    }
    return retVal;
}
Body of Second Method:
{
    if (child.getZ() > thisVG.getZ()) {
        // The background's bounds are set lazily. Make sure they are set correctly so that
        // the outline obtained is correct.
        child.setBackgroundBounds();
        ViewOutlineProvider outlineProvider = child.getOutlineProvider();
        Outline outline = child.mAttachInfo.mTmpOutline;
        outlineProvider.getOutline(child, outline);
        if (outline.mPath != null || (outline.mRect != null && !outline.mRect.isEmpty())) {
            int restoreTo = transformCanvas(thisVG, canvas, child);
            drawShadow(thisVG, canvas, child, outline);
            canvas.restoreToCount(restoreTo);
        }
    }
    return thisVG.drawChild_Original(canvas, child, drawingTime);
}
------------------------
Find a silently evolved API code:android.app.WallpaperManager.setDisplayPadding:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Specify extra padding that the wallpaper should have outside of the display.
 * That is, the given padding supplies additional pixels the wallpaper should extend
 * outside of the display itself.
 * @param padding The number of pixels the wallpaper should extend beyond the display,
 * on its left, top, right, and bottom sides.
 * @hide
 */

Body of Frist Method:
{
    try {
        if (sGlobals.mService == null) {
            Log.w(TAG, "WallpaperService not running");
        } else {
            sGlobals.mService.setDisplayPadding(padding);
        }
    } catch (RemoteException e) {
    // Ignore
    }
}
Body of Second Method:
{
    try {
        if (sGlobals.mService == null) {
            Log.w(TAG, "WallpaperService not running");
        } else {
            sGlobals.mService.setDisplayPadding(padding, mContext.getOpPackageName());
        }
    } catch (RemoteException e) {
    // Ignore
    }
}
------------------------
Find a silently evolved API code:android.hardware.camera2.legacy.LegacyFocusStateMapper.processRequestTriggers:COMMENT
Method Modifier: public      
Comment:/**
 * Process the AF triggers from the request as a camera1 autofocus routine.
 *
 * <p>This method should be called after the parameters are {@link LegacyRequestMapper mapped}
 * with the request.</p>
 *
 * <p>Callbacks are processed in the background, and the next call to {@link #mapResultTriggers}
 * will have the latest AF state as reflected by the camera1 callbacks.</p>
 *
 * <p>None of the arguments will be mutated.</p>
 *
 * @param captureRequest a non-{@code null} request
 * @param parameters a non-{@code null} parameters corresponding to this request (read-only)
 */

Body of Frist Method:
{
    checkNotNull(captureRequest, "captureRequest must not be null");
    /*
         * control.afTrigger
         */
    int afTrigger = ParamsUtils.getOrDefault(captureRequest, CONTROL_AF_TRIGGER, CONTROL_AF_TRIGGER_IDLE);
    final String afMode = parameters.getFocusMode();
    if (!Objects.equals(mAfModePrevious, afMode)) {
        if (VERBOSE) {
            Log.v(TAG, "processRequestTriggers - AF mode switched from " + mAfModePrevious + " to " + afMode);
        }
        synchronized (mLock) {
            ++mAfRun;
            mAfState = CONTROL_AF_STATE_INACTIVE;
        }
        mCamera.cancelAutoFocus();
    }
    mAfModePrevious = afMode;
    // Passive AF Scanning
    {
        final int currentAfRun;
        synchronized (mLock) {
            currentAfRun = mAfRun;
        }
        Camera.AutoFocusMoveCallback afMoveCallback = new Camera.AutoFocusMoveCallback() {

            @Override
            public void onAutoFocusMoving(boolean start, Camera camera) {
                synchronized (mLock) {
                    int latestAfRun = mAfRun;
                    if (VERBOSE) {
                        Log.v(TAG, "onAutoFocusMoving - start " + start + " latest AF run " + latestAfRun + ", last AF run " + currentAfRun);
                    }
                    if (currentAfRun != latestAfRun) {
                        Log.d(TAG, "onAutoFocusMoving - ignoring move callbacks from old af run" + currentAfRun);
                        return;
                    }
                    int newAfState = start ? CONTROL_AF_STATE_PASSIVE_SCAN : CONTROL_AF_STATE_PASSIVE_FOCUSED;
                    switch(afMode) {
                        case Parameters.FOCUS_MODE_CONTINUOUS_PICTURE:
                        case Parameters.FOCUS_MODE_CONTINUOUS_VIDEO:
                            break;
                        // This callback should never be sent in any other AF mode
                        default:
                            Log.w(TAG, "onAutoFocus - got unexpected onAutoFocus in mode " + afMode);
                    }
                    mAfState = newAfState;
                }
            }
        };
        // Only set move callback if we can call autofocus.
        switch(afMode) {
            case Parameters.FOCUS_MODE_AUTO:
            case Parameters.FOCUS_MODE_MACRO:
            case Parameters.FOCUS_MODE_CONTINUOUS_PICTURE:
            case Parameters.FOCUS_MODE_CONTINUOUS_VIDEO:
                mCamera.setAutoFocusMoveCallback(afMoveCallback);
        }
    }
    // AF Locking
    switch(afTrigger) {
        case CONTROL_AF_TRIGGER_START:
            int afStateAfterStart;
            switch(afMode) {
                case Parameters.FOCUS_MODE_AUTO:
                case Parameters.FOCUS_MODE_MACRO:
                    afStateAfterStart = CONTROL_AF_STATE_ACTIVE_SCAN;
                    break;
                case Parameters.FOCUS_MODE_CONTINUOUS_PICTURE:
                case Parameters.FOCUS_MODE_CONTINUOUS_VIDEO:
                    afStateAfterStart = CONTROL_AF_STATE_PASSIVE_SCAN;
                    break;
                default:
                    // EDOF, INFINITY
                    afStateAfterStart = CONTROL_AF_STATE_INACTIVE;
            }
            final int currentAfRun;
            synchronized (mLock) {
                currentAfRun = ++mAfRun;
                mAfState = afStateAfterStart;
            }
            if (VERBOSE) {
                Log.v(TAG, "processRequestTriggers - got AF_TRIGGER_START, " + "new AF run is " + currentAfRun);
            }
            // Avoid calling autofocus unless we are in a state that supports calling this.
            if (afStateAfterStart == CONTROL_AF_STATE_INACTIVE) {
                break;
            }
            mCamera.autoFocus(new Camera.AutoFocusCallback() {

                @Override
                public void onAutoFocus(boolean success, Camera camera) {
                    synchronized (mLock) {
                        int latestAfRun = mAfRun;
                        if (VERBOSE) {
                            Log.v(TAG, "onAutoFocus - success " + success + " latest AF run " + latestAfRun + ", last AF run " + currentAfRun);
                        }
                        // Ignore old auto-focus results, since another trigger was requested
                        if (latestAfRun != currentAfRun) {
                            Log.d(TAG, String.format("onAutoFocus - ignoring AF callback " + "(old run %d, new run %d)", currentAfRun, latestAfRun));
                            return;
                        }
                        int newAfState = success ? CONTROL_AF_STATE_FOCUSED_LOCKED : CONTROL_AF_STATE_NOT_FOCUSED_LOCKED;
                        switch(afMode) {
                            case Parameters.FOCUS_MODE_AUTO:
                            case Parameters.FOCUS_MODE_CONTINUOUS_PICTURE:
                            case Parameters.FOCUS_MODE_CONTINUOUS_VIDEO:
                            case Parameters.FOCUS_MODE_MACRO:
                                break;
                            // This callback should never be sent in any other AF mode
                            default:
                                Log.w(TAG, "onAutoFocus - got unexpected onAutoFocus in mode " + afMode);
                        }
                        mAfState = newAfState;
                    }
                }
            });
            break;
        case CONTROL_AF_TRIGGER_CANCEL:
            synchronized (mLock) {
                int updatedAfRun;
                synchronized (mLock) {
                    updatedAfRun = ++mAfRun;
                    mAfState = CONTROL_AF_STATE_INACTIVE;
                }
                mCamera.cancelAutoFocus();
                if (VERBOSE) {
                    Log.v(TAG, "processRequestTriggers - got AF_TRIGGER_CANCEL, " + "new AF run is " + updatedAfRun);
                }
            }
            break;
        case CONTROL_AF_TRIGGER_IDLE:
            // No action necessary. The callbacks will handle transitions.
            break;
        default:
            Log.w(TAG, "processRequestTriggers - ignoring unknown control.afTrigger = " + afTrigger);
    }
}
Body of Second Method:
{
    checkNotNull(captureRequest, "captureRequest must not be null");
    /*
         * control.afTrigger
         */
    int afTrigger = ParamsUtils.getOrDefault(captureRequest, CONTROL_AF_TRIGGER, CONTROL_AF_TRIGGER_IDLE);
    final String afMode = parameters.getFocusMode();
    if (!Objects.equals(mAfModePrevious, afMode)) {
        if (DEBUG) {
            Log.v(TAG, "processRequestTriggers - AF mode switched from " + mAfModePrevious + " to " + afMode);
        }
        synchronized (mLock) {
            ++mAfRun;
            mAfState = CONTROL_AF_STATE_INACTIVE;
        }
        mCamera.cancelAutoFocus();
    }
    mAfModePrevious = afMode;
    // Passive AF Scanning
    {
        final int currentAfRun;
        synchronized (mLock) {
            currentAfRun = mAfRun;
        }
        Camera.AutoFocusMoveCallback afMoveCallback = new Camera.AutoFocusMoveCallback() {

            @Override
            public void onAutoFocusMoving(boolean start, Camera camera) {
                synchronized (mLock) {
                    int latestAfRun = mAfRun;
                    if (DEBUG) {
                        Log.v(TAG, "onAutoFocusMoving - start " + start + " latest AF run " + latestAfRun + ", last AF run " + currentAfRun);
                    }
                    if (currentAfRun != latestAfRun) {
                        Log.d(TAG, "onAutoFocusMoving - ignoring move callbacks from old af run" + currentAfRun);
                        return;
                    }
                    int newAfState = start ? CONTROL_AF_STATE_PASSIVE_SCAN : CONTROL_AF_STATE_PASSIVE_FOCUSED;
                    switch(afMode) {
                        case Parameters.FOCUS_MODE_CONTINUOUS_PICTURE:
                        case Parameters.FOCUS_MODE_CONTINUOUS_VIDEO:
                            break;
                        // This callback should never be sent in any other AF mode
                        default:
                            Log.w(TAG, "onAutoFocus - got unexpected onAutoFocus in mode " + afMode);
                    }
                    mAfState = newAfState;
                }
            }
        };
        // Only set move callback if we can call autofocus.
        switch(afMode) {
            case Parameters.FOCUS_MODE_AUTO:
            case Parameters.FOCUS_MODE_MACRO:
            case Parameters.FOCUS_MODE_CONTINUOUS_PICTURE:
            case Parameters.FOCUS_MODE_CONTINUOUS_VIDEO:
                mCamera.setAutoFocusMoveCallback(afMoveCallback);
        }
    }
    // AF Locking
    switch(afTrigger) {
        case CONTROL_AF_TRIGGER_START:
            int afStateAfterStart;
            switch(afMode) {
                case Parameters.FOCUS_MODE_AUTO:
                case Parameters.FOCUS_MODE_MACRO:
                    afStateAfterStart = CONTROL_AF_STATE_ACTIVE_SCAN;
                    break;
                case Parameters.FOCUS_MODE_CONTINUOUS_PICTURE:
                case Parameters.FOCUS_MODE_CONTINUOUS_VIDEO:
                    afStateAfterStart = CONTROL_AF_STATE_PASSIVE_SCAN;
                    break;
                default:
                    // EDOF, INFINITY
                    afStateAfterStart = CONTROL_AF_STATE_INACTIVE;
            }
            final int currentAfRun;
            synchronized (mLock) {
                currentAfRun = ++mAfRun;
                mAfState = afStateAfterStart;
            }
            if (DEBUG) {
                Log.v(TAG, "processRequestTriggers - got AF_TRIGGER_START, " + "new AF run is " + currentAfRun);
            }
            // Avoid calling autofocus unless we are in a state that supports calling this.
            if (afStateAfterStart == CONTROL_AF_STATE_INACTIVE) {
                break;
            }
            mCamera.autoFocus(new Camera.AutoFocusCallback() {

                @Override
                public void onAutoFocus(boolean success, Camera camera) {
                    synchronized (mLock) {
                        int latestAfRun = mAfRun;
                        if (DEBUG) {
                            Log.v(TAG, "onAutoFocus - success " + success + " latest AF run " + latestAfRun + ", last AF run " + currentAfRun);
                        }
                        // Ignore old auto-focus results, since another trigger was requested
                        if (latestAfRun != currentAfRun) {
                            Log.d(TAG, String.format("onAutoFocus - ignoring AF callback " + "(old run %d, new run %d)", currentAfRun, latestAfRun));
                            return;
                        }
                        int newAfState = success ? CONTROL_AF_STATE_FOCUSED_LOCKED : CONTROL_AF_STATE_NOT_FOCUSED_LOCKED;
                        switch(afMode) {
                            case Parameters.FOCUS_MODE_AUTO:
                            case Parameters.FOCUS_MODE_CONTINUOUS_PICTURE:
                            case Parameters.FOCUS_MODE_CONTINUOUS_VIDEO:
                            case Parameters.FOCUS_MODE_MACRO:
                                break;
                            // This callback should never be sent in any other AF mode
                            default:
                                Log.w(TAG, "onAutoFocus - got unexpected onAutoFocus in mode " + afMode);
                        }
                        mAfState = newAfState;
                    }
                }
            });
            break;
        case CONTROL_AF_TRIGGER_CANCEL:
            synchronized (mLock) {
                int updatedAfRun;
                synchronized (mLock) {
                    updatedAfRun = ++mAfRun;
                    mAfState = CONTROL_AF_STATE_INACTIVE;
                }
                mCamera.cancelAutoFocus();
                if (DEBUG) {
                    Log.v(TAG, "processRequestTriggers - got AF_TRIGGER_CANCEL, " + "new AF run is " + updatedAfRun);
                }
            }
            break;
        case CONTROL_AF_TRIGGER_IDLE:
            // No action necessary. The callbacks will handle transitions.
            break;
        default:
            Log.w(TAG, "processRequestTriggers - ignoring unknown control.afTrigger = " + afTrigger);
    }
}
------------------------
Find a silently evolved API code:android.app.Notification.lightenPayload:COMMENT
Method Modifier: public      final       hidden      
Comment:/**
 * Removes heavyweight parts of the Notification object for archival or for sending to
 * listeners when the full contents are not necessary.
 * @hide
 */

Body of Frist Method:
{
    tickerView = null;
    contentView = null;
    bigContentView = null;
    headsUpContentView = null;
    largeIcon = null;
    if (extras != null) {
        extras.remove(Notification.EXTRA_LARGE_ICON);
        extras.remove(Notification.EXTRA_LARGE_ICON_BIG);
        extras.remove(Notification.EXTRA_PICTURE);
        extras.remove(Notification.EXTRA_BIG_TEXT);
        // Prevent light notifications from being rebuilt.
        extras.remove(Builder.EXTRA_NEEDS_REBUILD);
    }
}
Body of Second Method:
{
    tickerView = null;
    contentView = null;
    bigContentView = null;
    headsUpContentView = null;
    mLargeIcon = null;
    if (extras != null) {
        extras.remove(Notification.EXTRA_LARGE_ICON);
        extras.remove(Notification.EXTRA_LARGE_ICON_BIG);
        extras.remove(Notification.EXTRA_PICTURE);
        extras.remove(Notification.EXTRA_BIG_TEXT);
        // Prevent light notifications from being rebuilt.
        extras.remove(Builder.EXTRA_NEEDS_REBUILD);
    }
}
------------------------
Find a silently evolved API code:android.net.Uri.toSafeString:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Return a string representation of the URI that is safe to print
 * to logs and other places where PII should be avoided.
 * @hide
 */

Body of Frist Method:
{
    String scheme = getScheme();
    String ssp = getSchemeSpecificPart();
    if (scheme != null) {
        if (scheme.equalsIgnoreCase("tel") || scheme.equalsIgnoreCase("sip") || scheme.equalsIgnoreCase("sms") || scheme.equalsIgnoreCase("smsto") || scheme.equalsIgnoreCase("mailto")) {
            StringBuilder builder = new StringBuilder(64);
            builder.append(scheme);
            builder.append(':');
            if (ssp != null) {
                for (int i = 0; i < ssp.length(); i++) {
                    char c = ssp.charAt(i);
                    if (c == '-' || c == '@' || c == '.') {
                        builder.append(c);
                    } else {
                        builder.append('x');
                    }
                }
            }
            return builder.toString();
        }
    }
    // Not a sensitive scheme, but let's still be conservative about
    // the data we include -- only the ssp, not the query params or
    // fragment, because those can often have sensitive info.
    StringBuilder builder = new StringBuilder(64);
    if (scheme != null) {
        builder.append(scheme);
        builder.append(':');
    }
    if (ssp != null) {
        builder.append(ssp);
    }
    return builder.toString();
}
Body of Second Method:
{
    String scheme = getScheme();
    String ssp = getSchemeSpecificPart();
    if (scheme != null) {
        if (scheme.equalsIgnoreCase("tel") || scheme.equalsIgnoreCase("sip") || scheme.equalsIgnoreCase("sms") || scheme.equalsIgnoreCase("smsto") || scheme.equalsIgnoreCase("mailto")) {
            StringBuilder builder = new StringBuilder(64);
            builder.append(scheme);
            builder.append(':');
            if (ssp != null) {
                for (int i = 0; i < ssp.length(); i++) {
                    char c = ssp.charAt(i);
                    if (c == '-' || c == '@' || c == '.') {
                        builder.append(c);
                    } else {
                        builder.append('x');
                    }
                }
            }
            return builder.toString();
        } else if (scheme.equalsIgnoreCase("http") || scheme.equalsIgnoreCase("https") || scheme.equalsIgnoreCase("ftp")) {
            ssp = "//" + ((getHost() != null) ? getHost() : "") + ((getPort() != -1) ? (":" + getPort()) : "") + "/...";
        }
    }
    // Not a sensitive scheme, but let's still be conservative about
    // the data we include -- only the ssp, not the query params or
    // fragment, because those can often have sensitive info.
    StringBuilder builder = new StringBuilder(64);
    if (scheme != null) {
        builder.append(scheme);
        builder.append(':');
    }
    if (ssp != null) {
        builder.append(ssp);
    }
    return builder.toString();
}
------------------------
Find a silently evolved API code:android.location.GpsClock.getTypeString:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Gets a string representation of the 'type'.
 * For internal and logging use only.
 */

Body of Frist Method:
{
    switch(mType) {
        case TYPE_UNKNOWN:
            return "Unknown";
        case TYPE_GPS_TIME:
            return "GpsTime";
        case TYPE_LOCAL_HW_TIME:
            return "LocalHwClock";
        default:
            return "<Invalid>";
    }
}
Body of Second Method:
{
    switch(mType) {
        case TYPE_UNKNOWN:
            return "Unknown";
        case TYPE_GPS_TIME:
            return "GpsTime";
        case TYPE_LOCAL_HW_TIME:
            return "LocalHwClock";
        default:
            return "<Invalid:" + mType + ">";
    }
}
------------------------
Find a silently evolved API code:android.text.SpannableStringBuilder.getSpans:COMMENT
Method Modifier: public      
Comment:/**
 * Return an array of the spans of the specified type that overlap
 * the specified range of the buffer.  The kind may be Object.class to get
 * a list of all the spans regardless of type.
 */

Body of Frist Method:
{
    if (kind == null)
        return ArrayUtils.emptyArray(kind);
    int spanCount = mSpanCount;
    Object[] spans = mSpans;
    int[] starts = mSpanStarts;
    int[] ends = mSpanEnds;
    int[] flags = mSpanFlags;
    int gapstart = mGapStart;
    int gaplen = mGapLength;
    int count = 0;
    T[] ret = null;
    T ret1 = null;
    for (int i = 0; i < spanCount; i++) {
        int spanStart = starts[i];
        if (spanStart > gapstart) {
            spanStart -= gaplen;
        }
        if (spanStart > queryEnd) {
            continue;
        }
        int spanEnd = ends[i];
        if (spanEnd > gapstart) {
            spanEnd -= gaplen;
        }
        if (spanEnd < queryStart) {
            continue;
        }
        if (spanStart != spanEnd && queryStart != queryEnd) {
            if (spanStart == queryEnd)
                continue;
            if (spanEnd == queryStart)
                continue;
        }
        // Expensive test, should be performed after the previous tests
        if (!kind.isInstance(spans[i]))
            continue;
        if (count == 0) {
            // Safe conversion thanks to the isInstance test above
            ret1 = (T) spans[i];
            count++;
        } else {
            if (count == 1) {
                // Safe conversion, but requires a suppressWarning
                ret = (T[]) Array.newInstance(kind, spanCount - i + 1);
                ret[0] = ret1;
            }
            int prio = flags[i] & SPAN_PRIORITY;
            if (prio != 0) {
                int j;
                for (j = 0; j < count; j++) {
                    int p = getSpanFlags(ret[j]) & SPAN_PRIORITY;
                    if (prio > p) {
                        break;
                    }
                }
                System.arraycopy(ret, j, ret, j + 1, count - j);
                // Safe conversion thanks to the isInstance test above
                ret[j] = (T) spans[i];
                count++;
            } else {
                // Safe conversion thanks to the isInstance test above
                ret[count++] = (T) spans[i];
            }
        }
    }
    if (count == 0) {
        return ArrayUtils.emptyArray(kind);
    }
    if (count == 1) {
        // Safe conversion, but requires a suppressWarning
        ret = (T[]) Array.newInstance(kind, 1);
        ret[0] = ret1;
        return ret;
    }
    if (count == ret.length) {
        return ret;
    }
    // Safe conversion, but requires a suppressWarning
    T[] nret = (T[]) Array.newInstance(kind, count);
    System.arraycopy(ret, 0, nret, 0, count);
    return nret;
}
Body of Second Method:
{
    if (kind == null || mSpanCount == 0)
        return ArrayUtils.emptyArray(kind);
    int count = countSpans(queryStart, queryEnd, kind, treeRoot());
    if (count == 0) {
        return ArrayUtils.emptyArray(kind);
    }
    // Safe conversion, but requires a suppressWarning
    T[] ret = (T[]) Array.newInstance(kind, count);
    getSpansRec(queryStart, queryEnd, kind, treeRoot(), ret, 0);
    return ret;
}
------------------------
Find a silently evolved API code:android.widget.ProgressBar.tileify:COMMENT
Method Modifier: private     
Comment:/**
 * Converts a drawable to a tiled version of itself. It will recursively
 * traverse layer and state list drawables.
 */

Body of Frist Method:
{
    if (drawable instanceof LayerDrawable) {
        LayerDrawable background = (LayerDrawable) drawable;
        final int N = background.getNumberOfLayers();
        Drawable[] outDrawables = new Drawable[N];
        for (int i = 0; i < N; i++) {
            int id = background.getId(i);
            outDrawables[i] = tileify(background.getDrawable(i), (id == R.id.progress || id == R.id.secondaryProgress));
        }
        LayerDrawable newBg = new LayerDrawable(outDrawables);
        for (int i = 0; i < N; i++) {
            newBg.setId(i, background.getId(i));
        }
        return newBg;
    } else if (drawable instanceof StateListDrawable) {
        StateListDrawable in = (StateListDrawable) drawable;
        StateListDrawable out = new StateListDrawable();
        int numStates = in.getStateCount();
        for (int i = 0; i < numStates; i++) {
            out.addState(in.getStateSet(i), tileify(in.getStateDrawable(i), clip));
        }
        return out;
    } else if (drawable instanceof BitmapDrawable) {
        final BitmapDrawable bitmap = (BitmapDrawable) drawable;
        final Bitmap tileBitmap = bitmap.getBitmap();
        if (mSampleTile == null) {
            mSampleTile = tileBitmap;
        }
        final ShapeDrawable shapeDrawable = new ShapeDrawable(getDrawableShape());
        final BitmapShader bitmapShader = new BitmapShader(tileBitmap, Shader.TileMode.REPEAT, Shader.TileMode.CLAMP);
        shapeDrawable.getPaint().setShader(bitmapShader);
        // Ensure the tint and filter are propagated in the correct order.
        shapeDrawable.setTintList(bitmap.getTint());
        shapeDrawable.setTintMode(bitmap.getTintMode());
        shapeDrawable.setColorFilter(bitmap.getColorFilter());
        return clip ? new ClipDrawable(shapeDrawable, Gravity.LEFT, ClipDrawable.HORIZONTAL) : shapeDrawable;
    }
    return drawable;
}
Body of Second Method:
{
    if (drawable instanceof LayerDrawable) {
        final LayerDrawable orig = (LayerDrawable) drawable;
        final int N = orig.getNumberOfLayers();
        final Drawable[] outDrawables = new Drawable[N];
        for (int i = 0; i < N; i++) {
            final int id = orig.getId(i);
            outDrawables[i] = tileify(orig.getDrawable(i), (id == R.id.progress || id == R.id.secondaryProgress));
        }
        final LayerDrawable clone = new LayerDrawable(outDrawables);
        for (int i = 0; i < N; i++) {
            clone.setId(i, orig.getId(i));
            clone.setLayerGravity(i, orig.getLayerGravity(i));
            clone.setLayerWidth(i, orig.getLayerWidth(i));
            clone.setLayerHeight(i, orig.getLayerHeight(i));
            clone.setLayerInsetLeft(i, orig.getLayerInsetLeft(i));
            clone.setLayerInsetRight(i, orig.getLayerInsetRight(i));
            clone.setLayerInsetTop(i, orig.getLayerInsetTop(i));
            clone.setLayerInsetBottom(i, orig.getLayerInsetBottom(i));
            clone.setLayerInsetStart(i, orig.getLayerInsetStart(i));
            clone.setLayerInsetEnd(i, orig.getLayerInsetEnd(i));
        }
        return clone;
    }
    if (drawable instanceof StateListDrawable) {
        final StateListDrawable in = (StateListDrawable) drawable;
        final StateListDrawable out = new StateListDrawable();
        final int N = in.getStateCount();
        for (int i = 0; i < N; i++) {
            out.addState(in.getStateSet(i), tileify(in.getStateDrawable(i), clip));
        }
        return out;
    }
    if (drawable instanceof BitmapDrawable) {
        final BitmapDrawable bitmap = (BitmapDrawable) drawable;
        final Bitmap tileBitmap = bitmap.getBitmap();
        if (mSampleTile == null) {
            mSampleTile = tileBitmap;
        }
        final BitmapDrawable clone = (BitmapDrawable) bitmap.getConstantState().newDrawable();
        clone.setTileModeXY(Shader.TileMode.REPEAT, Shader.TileMode.CLAMP);
        if (clip) {
            return new ClipDrawable(clone, Gravity.LEFT, ClipDrawable.HORIZONTAL);
        } else {
            return clone;
        }
    }
    return drawable;
}
------------------------
Find a silently evolved API code:android.text.SpannableStringBuilder.getSpanFlags:COMMENT
Method Modifier: public      
Comment:/**
 * Return the flags of the end of the specified
 * markup object, or 0 if it is not attached to this buffer.
 */

Body of Frist Method:
{
    int count = mSpanCount;
    Object[] spans = mSpans;
    for (int i = count - 1; i >= 0; i--) {
        if (spans[i] == what) {
            return mSpanFlags[i];
        }
    }
    return 0;
}
Body of Second Method:
{
    if (mIndexOfSpan == null)
        return 0;
    Integer i = mIndexOfSpan.get(what);
    return i == null ? 0 : mSpanFlags[i];
}
------------------------
Find a silently evolved API code:android.content.BroadcastReceiver.PendingResult.sendFinished:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    synchronized (this) {
        if (mFinished) {
            throw new IllegalStateException("Broadcast already finished");
        }
        mFinished = true;
        try {
            if (mResultExtras != null) {
                mResultExtras.setAllowFds(false);
            }
            if (mOrderedHint) {
                am.finishReceiver(mToken, mResultCode, mResultData, mResultExtras, mAbortBroadcast);
            } else {
                // This broadcast was sent to a component; it is not ordered,
                // but we still need to tell the activity manager we are done.
                am.finishReceiver(mToken, 0, null, null, false);
            }
        } catch (RemoteException ex) {
        }
    }
}
Body of Second Method:
{
    synchronized (this) {
        if (mFinished) {
            throw new IllegalStateException("Broadcast already finished");
        }
        mFinished = true;
        try {
            if (mResultExtras != null) {
                mResultExtras.setAllowFds(false);
            }
            if (mOrderedHint) {
                am.finishReceiver(mToken, mResultCode, mResultData, mResultExtras, mAbortBroadcast, mFlags);
            } else {
                // This broadcast was sent to a component; it is not ordered,
                // but we still need to tell the activity manager we are done.
                am.finishReceiver(mToken, 0, null, null, false, mFlags);
            }
        } catch (RemoteException ex) {
        }
    }
}
------------------------
Find a silently evolved API code:android.widget.TextView.setExtractedText:COMMENT
Method Modifier: public      
Comment:/**
 * Apply to this text view the given extracted text, as previously
 * returned by {@link #extractText(ExtractedTextRequest, ExtractedText)}.
 */

Body of Frist Method:
{
    Editable content = getEditableText();
    if (text.text != null) {
        if (content == null) {
            setText(text.text, TextView.BufferType.EDITABLE);
        } else if (text.partialStartOffset < 0) {
            removeParcelableSpans(content, 0, content.length());
            content.replace(0, content.length(), text.text);
        } else {
            final int N = content.length();
            int start = text.partialStartOffset;
            if (start > N)
                start = N;
            int end = text.partialEndOffset;
            if (end > N)
                end = N;
            removeParcelableSpans(content, start, end);
            content.replace(start, end, text.text);
        }
    }
    // Now set the selection position...  make sure it is in range, to
    // avoid crashes.  If this is a partial update, it is possible that
    // the underlying text may have changed, causing us problems here.
    // Also we just don't want to trust clients to do the right thing.
    Spannable sp = (Spannable) getText();
    final int N = sp.length();
    int start = text.selectionStart;
    if (start < 0)
        start = 0;
    else if (start > N)
        start = N;
    int end = text.selectionEnd;
    if (end < 0)
        end = 0;
    else if (end > N)
        end = N;
    Selection.setSelection(sp, start, end);
    // Finally, update the selection mode.
    if ((text.flags & ExtractedText.FLAG_SELECTING) != 0) {
        MetaKeyKeyListener.startSelecting(this, sp);
    } else {
        MetaKeyKeyListener.stopSelecting(this, sp);
    }
}
Body of Second Method:
{
    Editable content = getEditableText();
    if (text.text != null) {
        if (content == null) {
            setText(text.text, TextView.BufferType.EDITABLE);
        } else {
            int start = 0;
            int end = content.length();
            if (text.partialStartOffset >= 0) {
                final int N = content.length();
                start = text.partialStartOffset;
                if (start > N)
                    start = N;
                end = text.partialEndOffset;
                if (end > N)
                    end = N;
            }
            removeParcelableSpans(content, start, end);
            if (TextUtils.equals(content.subSequence(start, end), text.text)) {
                if (text.text instanceof Spanned) {
                    // OK to copy spans only.
                    TextUtils.copySpansFrom((Spanned) text.text, start, end, Object.class, content, start);
                }
            } else {
                content.replace(start, end, text.text);
            }
        }
    }
    // Now set the selection position...  make sure it is in range, to
    // avoid crashes.  If this is a partial update, it is possible that
    // the underlying text may have changed, causing us problems here.
    // Also we just don't want to trust clients to do the right thing.
    Spannable sp = (Spannable) getText();
    final int N = sp.length();
    int start = text.selectionStart;
    if (start < 0)
        start = 0;
    else if (start > N)
        start = N;
    int end = text.selectionEnd;
    if (end < 0)
        end = 0;
    else if (end > N)
        end = N;
    Selection.setSelection(sp, start, end);
    // Finally, update the selection mode.
    if ((text.flags & ExtractedText.FLAG_SELECTING) != 0) {
        MetaKeyKeyListener.startSelecting(this, sp);
    } else {
        MetaKeyKeyListener.stopSelecting(this, sp);
    }
}
------------------------
Find a silently evolved API code:android.view.TextureView.setSurfaceTexture:COMMENT
Method Modifier: public      
Comment:/**
 * Set the {@link SurfaceTexture} for this view to use. If a {@link
 * SurfaceTexture} is already being used by this view, it is immediately
 * released and not be usable any more.  The {@link
 * SurfaceTextureListener#onSurfaceTextureDestroyed} callback is <b>not</b>
 * called for the previous {@link SurfaceTexture}.  Similarly, the {@link
 * SurfaceTextureListener#onSurfaceTextureAvailable} callback is <b>not</b>
 * called for the {@link SurfaceTexture} passed to setSurfaceTexture.
 *
 * The {@link SurfaceTexture} object must be detached from all OpenGL ES
 * contexts prior to calling this method.
 *
 * @param surfaceTexture The {@link SurfaceTexture} that the view should use.
 * @see SurfaceTexture#detachFromGLContext()
 */

Body of Frist Method:
{
    if (surfaceTexture == null) {
        throw new NullPointerException("surfaceTexture must not be null");
    }
    if (mSurface != null) {
        mSurface.release();
    }
    mSurface = surfaceTexture;
    mUpdateSurface = true;
    invalidateParentIfNeeded();
}
Body of Second Method:
{
    if (surfaceTexture == null) {
        throw new NullPointerException("surfaceTexture must not be null");
    }
    if (surfaceTexture == mSurface) {
        throw new IllegalArgumentException("Trying to setSurfaceTexture to " + "the same SurfaceTexture that's already set.");
    }
    if (surfaceTexture.isReleased()) {
        throw new IllegalArgumentException("Cannot setSurfaceTexture to a " + "released SurfaceTexture");
    }
    if (mSurface != null) {
        mSurface.release();
    }
    mSurface = surfaceTexture;
    /*
         * If the view is visible and we already made a layer, update the
         * listener in the new surface to use the existing listener in the view.
         * Otherwise this will be called when the view becomes visible or the
         * layer is created
         */
    if (((mViewFlags & VISIBILITY_MASK) == VISIBLE) && mLayer != null) {
        mSurface.setOnFrameAvailableListener(mUpdateListener, mAttachInfo.mHandler);
    }
    mUpdateSurface = true;
    invalidateParentIfNeeded();
}
------------------------
Find a silently evolved API code:android.webkit.WebView.saveState:COMMENT
Method Modifier: public      
Comment:/**
 * Saves the state of this WebView used in
 * {@link android.app.Activity#onSaveInstanceState}. Please note that this
 * method no longer stores the display data for this WebView. The previous
 * behavior could potentially leak files if {@link #restoreState} was never
 * called.
 *
 * @param outState the Bundle to store this WebView's state
 * @return the same copy of the back/forward list used to save the state. If
 * saveState fails, the returned list will be null.
 */

Body of Frist Method:
{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, "saveState");
    return mProvider.saveState(outState);
}
Body of Second Method:
{
    checkThread();
    return mProvider.saveState(outState);
}
------------------------
Find a silently evolved API code:android.telephony.SubscriptionManager.getActiveSubscriptionInfoCount:COMMENT
Method Modifier: public      
Comment:/**
 * @return the current number of active subscriptions. There is no guarantee the value
 * returned by this method will be the same as the length of the list returned by
 * {@link #getActiveSubscriptionInfoList}.
 */

Body of Frist Method:
{
    int result = 0;
    try {
        ISub iSub = ISub.Stub.asInterface(ServiceManager.getService("isub"));
        if (iSub != null) {
            result = iSub.getActiveSubInfoCount();
        }
    } catch (RemoteException ex) {
    // ignore it
    }
    return result;
}
Body of Second Method:
{
    int result = 0;
    try {
        ISub iSub = ISub.Stub.asInterface(ServiceManager.getService("isub"));
        if (iSub != null) {
            result = iSub.getActiveSubInfoCount(mContext.getOpPackageName());
        }
    } catch (RemoteException ex) {
    // ignore it
    }
    return result;
}
------------------------
Find a silently evolved API code:android.media.AudioManager.handleKeyUp:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    int keyCode = event.getKeyCode();
    switch(keyCode) {
        case KeyEvent.KEYCODE_VOLUME_UP:
        case KeyEvent.KEYCODE_VOLUME_DOWN:
            /*
                 * Play a sound. This is done on key up since we don't want the
                 * sound to play when a user holds down volume down to mute.
                 */
            if (mUseVolumeKeySounds) {
                if (mUseMasterVolume) {
                    adjustMasterVolume(ADJUST_SAME, FLAG_PLAY_SOUND);
                } else {
                    int flags = FLAG_PLAY_SOUND;
                    adjustSuggestedStreamVolume(ADJUST_SAME, stream, flags);
                }
            }
            mVolumeKeyUpTime = SystemClock.uptimeMillis();
            break;
        case KeyEvent.KEYCODE_VOLUME_MUTE:
            MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(event, false);
            break;
    }
}
Body of Second Method:
{
    int keyCode = event.getKeyCode();
    switch(keyCode) {
        case KeyEvent.KEYCODE_VOLUME_UP:
        case KeyEvent.KEYCODE_VOLUME_DOWN:
            /*
                 * Play a sound. This is done on key up since we don't want the
                 * sound to play when a user holds down volume down to mute.
                 */
            if (mUseVolumeKeySounds) {
                adjustSuggestedStreamVolume(ADJUST_SAME, stream, FLAG_PLAY_SOUND);
            }
            mVolumeKeyUpTime = SystemClock.uptimeMillis();
            break;
        case KeyEvent.KEYCODE_VOLUME_MUTE:
            MediaSessionLegacyHelper.getHelper(getContext()).sendVolumeKeyEvent(event, false);
            break;
    }
}
------------------------
Find a silently evolved API code:android.media.SoundPool.resume:COMMENT
<android.media.SoundPool: void resume(int)>
public      final       ->public      final       native      
Method Modifier: public      final       native      
Method Modifier: Yes         Yes         No          
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * Resume a playback stream.
 *
 * Resume the stream specified by the streamID. This
 * is the value returned by the play() function. If the stream
 * is paused, this will resume playback. If the stream was not
 * previously paused, calling this function will have no effect.
 *
 * @param streamID a streamID returned by the play() function
 */

Body of Frist Method:
{
    mImpl.resume(streamID);
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.location.GpsNavigationMessage.setType:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets the type of the navigation message.
 */

Body of Frist Method:
{
    switch(value) {
        case TYPE_UNKNOWN:
        case TYPE_L1CA:
        case TYPE_L2CNAV:
        case TYPE_L5CNAV:
        case TYPE_CNAV2:
            mType = value;
            break;
        default:
            Log.d(TAG, "Sanitizing invalid 'type': " + value);
            mType = TYPE_UNKNOWN;
            break;
    }
}
Body of Second Method:
{
    mType = value;
}
------------------------
Find a silently evolved API code:android.os.StrictMode.onVmPolicyViolation:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    final boolean penaltyDropbox = (sVmPolicyMask & PENALTY_DROPBOX) != 0;
    final boolean penaltyDeath = (sVmPolicyMask & PENALTY_DEATH) != 0;
    final boolean penaltyLog = (sVmPolicyMask & PENALTY_LOG) != 0;
    final ViolationInfo info = new ViolationInfo(originStack, sVmPolicyMask);
    // Erase stuff not relevant for process-wide violations
    info.numAnimationsRunning = 0;
    info.tags = null;
    info.broadcastIntentAction = null;
    final Integer fingerprint = info.hashCode();
    final long now = SystemClock.uptimeMillis();
    long lastViolationTime = 0;
    long timeSinceLastViolationMillis = Long.MAX_VALUE;
    synchronized (sLastVmViolationTime) {
        if (sLastVmViolationTime.containsKey(fingerprint)) {
            lastViolationTime = sLastVmViolationTime.get(fingerprint);
            timeSinceLastViolationMillis = now - lastViolationTime;
        }
        if (timeSinceLastViolationMillis > MIN_LOG_INTERVAL_MS) {
            sLastVmViolationTime.put(fingerprint, now);
        }
    }
    if (penaltyLog && timeSinceLastViolationMillis > MIN_LOG_INTERVAL_MS) {
        Log.e(TAG, message, originStack);
    }
    int violationMaskSubset = PENALTY_DROPBOX | (ALL_VM_DETECT_BITS & sVmPolicyMask);
    if (penaltyDropbox && !penaltyDeath) {
        // Common case for userdebug/eng builds.  If no death and
        // just dropboxing, we can do the ActivityManager call
        // asynchronously.
        dropboxViolationAsync(violationMaskSubset, info);
        return;
    }
    if (penaltyDropbox && lastViolationTime == 0) {
        // The violationMask, passed to ActivityManager, is a
        // subset of the original StrictMode policy bitmask, with
        // only the bit violated and penalty bits to be executed
        // by the ActivityManagerService remaining set.
        final int savedPolicyMask = getThreadPolicyMask();
        try {
            // First, remove any policy before we call into the Activity Manager,
            // otherwise we'll infinite recurse as we try to log policy violations
            // to disk, thus violating policy, thus requiring logging, etc...
            // We restore the current policy below, in the finally block.
            setThreadPolicyMask(0);
            ActivityManagerNative.getDefault().handleApplicationStrictModeViolation(RuntimeInit.getApplicationObject(), violationMaskSubset, info);
        } catch (RemoteException e) {
            Log.e(TAG, "RemoteException trying to handle StrictMode violation", e);
        } finally {
            // Restore the policy.
            setThreadPolicyMask(savedPolicyMask);
        }
    }
    if (penaltyDeath) {
        System.err.println("StrictMode VmPolicy violation with POLICY_DEATH; shutting down.");
        Process.killProcess(Process.myPid());
        System.exit(10);
    }
}
Body of Second Method:
{
    onVmPolicyViolation(message, originStack, false);
}
------------------------
Find a silently evolved API code:android.graphics.Canvas.drawLine:COMMENT
Method Modifier: public      
Comment:/**
 * Draw a line segment with the specified start and stop x,y coordinates,
 * using the specified paint.
 *
 * <p>Note that since a line is always "framed", the Style is ignored in the paint.</p>
 *
 * <p>Degenerate lines (length is 0) will not be drawn.</p>
 *
 * @param startX The x-coordinate of the start point of the line
 * @param startY The y-coordinate of the start point of the line
 * @param paint  The paint used to draw the line
 */

Body of Frist Method:
{
    native_drawLine(mNativeCanvasWrapper, startX, startY, stopX, stopY, paint.mNativePaint);
}
Body of Second Method:
{
    native_drawLine(mNativeCanvasWrapper, startX, startY, stopX, stopY, paint.getNativeInstance());
}
------------------------
Find a silently evolved API code:android.security.Credentials.deleteAllTypesForAlias:COMMENT
<android.security.Credentials: boolean deleteAllTypesForAlias(KeyStore,String)>
default     static      hidden      ->public      static      hidden      
Method Modifier: public      default     static      hidden      
Method Modifier: No          Yes         Yes         Yes         
Method Updated:  Yes         No          Yes         Yes         
Comment:/**
 * Delete all types (private key, certificate, CA certificate) for a
 * particular {@code alias}. All three can exist for any given alias.
 * Returns {@code true} if there was at least one of those types.
 */

Body of Frist Method:
{
    /*
         * Make sure every type is deleted. There can be all three types, so
         * don't use a conditional here.
         */
    return keystore.delKey(Credentials.USER_PRIVATE_KEY + alias) | deleteCertificateTypesForAlias(keystore, alias);
}
Body of Second Method:
{
    /*
         * Make sure every type is deleted. There can be all three types, so
         * don't use a conditional here.
         */
    return keystore.delete(Credentials.USER_PRIVATE_KEY + alias) | keystore.delete(Credentials.USER_SECRET_KEY + alias) | deleteCertificateTypesForAlias(keystore, alias);
}
------------------------
Find a silently evolved API code:android.graphics.drawable.VectorDrawable.getPixelSize:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * The size of a pixel when scaled from the intrinsic dimension to the viewport dimension.
 * This is used to calculate the path animation accuracy.
 *
 * @hide
 */

Body of Frist Method:
{
    if (mVectorState == null && mVectorState.mVPathRenderer == null || mVectorState.mVPathRenderer.mBaseWidth == 0 || mVectorState.mVPathRenderer.mBaseHeight == 0 || mVectorState.mVPathRenderer.mViewportHeight == 0 || mVectorState.mVPathRenderer.mViewportWidth == 0) {
        // fall back to 1:1 pixel mapping.
        return 1;
    }
    float intrinsicWidth = mVectorState.mVPathRenderer.mBaseWidth;
    float intrinsicHeight = mVectorState.mVPathRenderer.mBaseHeight;
    float viewportWidth = mVectorState.mVPathRenderer.mViewportWidth;
    float viewportHeight = mVectorState.mVPathRenderer.mViewportHeight;
    float scaleX = viewportWidth / intrinsicWidth;
    float scaleY = viewportHeight / intrinsicHeight;
    return Math.min(scaleX, scaleY);
}
Body of Second Method:
{
    if (mVectorState == null || mVectorState.mVPathRenderer == null || mVectorState.mVPathRenderer.mBaseWidth == 0 || mVectorState.mVPathRenderer.mBaseHeight == 0 || mVectorState.mVPathRenderer.mViewportHeight == 0 || mVectorState.mVPathRenderer.mViewportWidth == 0) {
        // fall back to 1:1 pixel mapping.
        return 1;
    }
    float intrinsicWidth = mVectorState.mVPathRenderer.mBaseWidth;
    float intrinsicHeight = mVectorState.mVPathRenderer.mBaseHeight;
    float viewportWidth = mVectorState.mVPathRenderer.mViewportWidth;
    float viewportHeight = mVectorState.mVPathRenderer.mViewportHeight;
    float scaleX = viewportWidth / intrinsicWidth;
    float scaleY = viewportHeight / intrinsicHeight;
    return Math.min(scaleX, scaleY);
}
------------------------
Find a silently evolved API code:android.os.ParcelFileDescriptor.detachFd:COMMENT
Method Modifier: public      
Comment:/**
 * Return the native fd int for this ParcelFileDescriptor and detach it from
 * the object here. You are now responsible for closing the fd in native
 * code.
 * <p>
 * You should not detach when the original creator of the descriptor is
 * expecting a reliable signal through {@link #close()} or
 * {@link #closeWithError(String)}.
 *
 * @see #canDetectErrors()
 */

Body of Frist Method:
{
    if (mWrapped != null) {
        return mWrapped.detachFd();
    } else {
        if (mClosed) {
            throw new IllegalStateException("Already closed");
        }
        final int fd = getFd();
        Parcel.clearFileDescriptor(mFd);
        writeCommStatusAndClose(Status.DETACHED, null);
        return fd;
    }
}
Body of Second Method:
{
    if (mWrapped != null) {
        return mWrapped.detachFd();
    } else {
        if (mClosed) {
            throw new IllegalStateException("Already closed");
        }
        final int fd = getFd();
        Parcel.clearFileDescriptor(mFd);
        writeCommStatusAndClose(Status.DETACHED, null);
        mClosed = true;
        mGuard.close();
        releaseResources();
        return fd;
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiManager.getConfiguredNetworks:COMMENT
Method Modifier: public      
Comment:/**
 * Return a list of all the networks configured in the supplicant.
 * Not all fields of WifiConfiguration are returned. Only the following
 * fields are filled in:
 * <ul>
 * <li>networkId</li>
 * <li>SSID</li>
 * <li>BSSID</li>
 * <li>priority</li>
 * <li>allowedProtocols</li>
 * <li>allowedKeyManagement</li>
 * <li>allowedAuthAlgorithms</li>
 * <li>allowedPairwiseCiphers</li>
 * <li>allowedGroupCiphers</li>
 * </ul>
 * @return a list of network configurations in the form of a list
 * of {@link WifiConfiguration} objects. Upon failure to fetch or
 * when when Wi-Fi is turned off, it can be null.
 */

Body of Frist Method:
{
    try {
        return mService.getConfiguredNetworks();
    } catch (RemoteException e) {
        return null;
    }
}
Body of Second Method:
{
    try {
        return mService.getConfiguredNetworks();
    } catch (RemoteException e) {
        Log.w(TAG, "Caught RemoteException trying to get configured networks: " + e);
        return null;
    }
}
------------------------
Find a silently evolved API code:android.widget.NumberPicker.setWrapSelectorWheel:COMMENT
Method Modifier: public      
Comment:/**
 * Sets whether the selector wheel shown during flinging/scrolling should
 * wrap around the {@link NumberPicker#getMinValue()} and
 * {@link NumberPicker#getMaxValue()} values.
 * <p>
 * By default if the range (max - min) is more than the number of items shown
 * on the selector wheel the selector wheel wrapping is enabled.
 * </p>
 * <p>
 * <strong>Note:</strong> If the number of items, i.e. the range (
 * {@link #getMaxValue()} - {@link #getMinValue()}) is less than
 * the number of items shown on the selector wheel, the selector wheel will
 * not wrap. Hence, in such a case calling this method is a NOP.
 * </p>
 *
 * @param wrapSelectorWheel Whether to wrap.
 */

Body of Frist Method:
{
    final boolean wrappingAllowed = (mMaxValue - mMinValue) >= mSelectorIndices.length;
    if ((!wrapSelectorWheel || wrappingAllowed) && wrapSelectorWheel != mWrapSelectorWheel) {
        mWrapSelectorWheel = wrapSelectorWheel;
    }
}
Body of Second Method:
{
    mWrapSelectorWheelPreferred = wrapSelectorWheel;
    updateWrapSelectorWheel();
}
------------------------
Find a silently evolved API code:android.media.ImageReader.acquireNextImage:COMMENT
Method Modifier: public      
Comment:/**
 * <p>
 * Acquire the next Image from the ImageReader's queue. Returns {@code null} if
 * no new image is available.
 * </p>
 *
 * <p><i>Warning:</i> Consider using {@link #acquireLatestImage()} instead, as it will
 * automatically release older images, and allow slower-running processing routines to catch
 * up to the newest frame. Usage of {@link #acquireNextImage} is recommended for
 * batch/background processing. Incorrectly using this function can cause images to appear
 * with an ever-increasing delay, followed by a complete stall where no new images seem to
 * appear.
 * </p>
 *
 * <p>
 * This operation will fail by throwing an {@link IllegalStateException} if
 * {@code maxImages} have been acquired with {@link #acquireNextImage} or
 * {@link #acquireLatestImage}. In particular a sequence of {@link #acquireNextImage} or
 * {@link #acquireLatestImage} calls greater than {@link #getMaxImages maxImages} without
 * calling {@link Image#close} in-between will exhaust the underlying queue. At such a time,
 * {@link IllegalStateException} will be thrown until more images are released with
 * {@link Image#close}.
 * </p>
 *
 * @return a new frame of image data, or {@code null} if no image data is available.
 * @throws IllegalStateException if {@code maxImages} images are currently acquired
 * @see #acquireLatestImage
 */

Body of Frist Method:
{
    SurfaceImage si = new SurfaceImage();
    int status = acquireNextSurfaceImage(si);
    switch(status) {
        case ACQUIRE_SUCCESS:
            return si;
        case ACQUIRE_NO_BUFS:
            return null;
        case ACQUIRE_MAX_IMAGES:
            throw new IllegalStateException(String.format("maxImages (%d) has already been acquired, " + "call #close before acquiring more.", mMaxImages));
        default:
            throw new AssertionError("Unknown nativeImageSetup return code " + status);
    }
}
Body of Second Method:
{
    // Initialize with reader format, but can be overwritten by native if the image
    // format is different from the reader format.
    SurfaceImage si = new SurfaceImage(mFormat);
    int status = acquireNextSurfaceImage(si);
    switch(status) {
        case ACQUIRE_SUCCESS:
            return si;
        case ACQUIRE_NO_BUFS:
            return null;
        case ACQUIRE_MAX_IMAGES:
            throw new IllegalStateException(String.format("maxImages (%d) has already been acquired, " + "call #close before acquiring more.", mMaxImages));
        default:
            throw new AssertionError("Unknown nativeImageSetup return code " + status);
    }
}
------------------------
Find a silently evolved API code:android.widget.TextView.setUndoManager:COMMENT
Method Modifier: public      final       hidden      
Comment:/**
 * Associate an {@link android.content.UndoManager} with this TextView.  Once
 * done, all edit operations on the TextView will result in appropriate
 * {@link android.content.UndoOperation} objects pushed on the given UndoManager's
 * stack.
 *
 * @param undoManager The {@link android.content.UndoManager} to associate with
 * this TextView, or null to clear any existing association.
 * @param tag String tag identifying this particular TextView owner in the
 * UndoManager.  This is used to keep the correct association with the
 * {@link android.content.UndoOwner} of any operations inside of the UndoManager.
 *
 * @hide
 */

Body of Frist Method:
{
    if (undoManager != null) {
        createEditorIfNeeded();
        mEditor.mUndoManager = undoManager;
        mEditor.mUndoOwner = undoManager.getOwner(tag, this);
        mEditor.mUndoInputFilter = new Editor.UndoInputFilter(mEditor);
        if (!(mText instanceof Editable)) {
            setText(mText, BufferType.EDITABLE);
        }
        setFilters((Editable) mText, mFilters);
    } else if (mEditor != null) {
        // XXX need to destroy all associated state.
        mEditor.mUndoManager = null;
        mEditor.mUndoOwner = null;
        mEditor.mUndoInputFilter = null;
    }
}
Body of Second Method:
{
    // Likewise it will need to be able to restore the default UndoManager.
    throw new UnsupportedOperationException("not implemented");
}
------------------------
Find a silently evolved API code:javax.obex.HeaderSet.setHeader:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets the value of the header identifier to the value provided. The type
 * of object must correspond to the Java type defined in the description of
 * this interface. If <code>null</code> is passed as the
 * <code>headerValue</code> then the header will be removed from the set of
 * headers to include in the next request.
 * @param headerID the identifier to include in the message
 * @param headerValue the value of the header identifier
 * @throws IllegalArgumentException if the header identifier provided is not
 * one defined in this interface or a user-defined header; if the
 * type of <code>headerValue</code> is not the correct Java type as
 * defined in the description of this interface\
 */

Body of Frist Method:
{
    long temp = -1;
    switch(headerID) {
        case COUNT:
            if (!(headerValue instanceof Long)) {
                if (headerValue == null) {
                    mCount = null;
                    break;
                }
                throw new IllegalArgumentException("Count must be a Long");
            }
            temp = ((Long) headerValue).longValue();
            if ((temp < 0L) || (temp > 0xFFFFFFFFL)) {
                throw new IllegalArgumentException("Count must be between 0 and 0xFFFFFFFF");
            }
            mCount = (Long) headerValue;
            break;
        case NAME:
            if ((headerValue != null) && (!(headerValue instanceof String))) {
                throw new IllegalArgumentException("Name must be a String");
            }
            mEmptyName = false;
            mName = (String) headerValue;
            break;
        case TYPE:
            if ((headerValue != null) && (!(headerValue instanceof String))) {
                throw new IllegalArgumentException("Type must be a String");
            }
            mType = (String) headerValue;
            break;
        case LENGTH:
            if (!(headerValue instanceof Long)) {
                if (headerValue == null) {
                    mLength = null;
                    break;
                }
                throw new IllegalArgumentException("Length must be a Long");
            }
            temp = ((Long) headerValue).longValue();
            if ((temp < 0L) || (temp > 0xFFFFFFFFL)) {
                throw new IllegalArgumentException("Length must be between 0 and 0xFFFFFFFF");
            }
            mLength = (Long) headerValue;
            break;
        case TIME_ISO_8601:
            if ((headerValue != null) && (!(headerValue instanceof Calendar))) {
                throw new IllegalArgumentException("Time ISO 8601 must be a Calendar");
            }
            mIsoTime = (Calendar) headerValue;
            break;
        case TIME_4_BYTE:
            if ((headerValue != null) && (!(headerValue instanceof Calendar))) {
                throw new IllegalArgumentException("Time 4 Byte must be a Calendar");
            }
            mByteTime = (Calendar) headerValue;
            break;
        case DESCRIPTION:
            if ((headerValue != null) && (!(headerValue instanceof String))) {
                throw new IllegalArgumentException("Description must be a String");
            }
            mDescription = (String) headerValue;
            break;
        case TARGET:
            if (headerValue == null) {
                mTarget = null;
            } else {
                if (!(headerValue instanceof byte[])) {
                    throw new IllegalArgumentException("Target must be a byte array");
                } else {
                    mTarget = new byte[((byte[]) headerValue).length];
                    System.arraycopy(headerValue, 0, mTarget, 0, mTarget.length);
                }
            }
            break;
        case HTTP:
            if (headerValue == null) {
                mHttpHeader = null;
            } else {
                if (!(headerValue instanceof byte[])) {
                    throw new IllegalArgumentException("HTTP must be a byte array");
                } else {
                    mHttpHeader = new byte[((byte[]) headerValue).length];
                    System.arraycopy(headerValue, 0, mHttpHeader, 0, mHttpHeader.length);
                }
            }
            break;
        case WHO:
            if (headerValue == null) {
                mWho = null;
            } else {
                if (!(headerValue instanceof byte[])) {
                    throw new IllegalArgumentException("WHO must be a byte array");
                } else {
                    mWho = new byte[((byte[]) headerValue).length];
                    System.arraycopy(headerValue, 0, mWho, 0, mWho.length);
                }
            }
            break;
        case OBJECT_CLASS:
            if (headerValue == null) {
                mObjectClass = null;
            } else {
                if (!(headerValue instanceof byte[])) {
                    throw new IllegalArgumentException("Object Class must be a byte array");
                } else {
                    mObjectClass = new byte[((byte[]) headerValue).length];
                    System.arraycopy(headerValue, 0, mObjectClass, 0, mObjectClass.length);
                }
            }
            break;
        case APPLICATION_PARAMETER:
            if (headerValue == null) {
                mAppParam = null;
            } else {
                if (!(headerValue instanceof byte[])) {
                    throw new IllegalArgumentException("Application Parameter must be a byte array");
                } else {
                    mAppParam = new byte[((byte[]) headerValue).length];
                    System.arraycopy(headerValue, 0, mAppParam, 0, mAppParam.length);
                }
            }
            break;
        default:
            // Verify that it was not a Unicode String user Defined
            if ((headerID >= 0x30) && (headerID <= 0x3F)) {
                if ((headerValue != null) && (!(headerValue instanceof String))) {
                    throw new IllegalArgumentException("Unicode String User Defined must be a String");
                }
                mUnicodeUserDefined[headerID - 0x30] = (String) headerValue;
                break;
            }
            // Verify that it was not a byte sequence user defined value
            if ((headerID >= 0x70) && (headerID <= 0x7F)) {
                if (headerValue == null) {
                    mSequenceUserDefined[headerID - 0x70] = null;
                } else {
                    if (!(headerValue instanceof byte[])) {
                        throw new IllegalArgumentException("Byte Sequence User Defined must be a byte array");
                    } else {
                        mSequenceUserDefined[headerID - 0x70] = new byte[((byte[]) headerValue).length];
                        System.arraycopy(headerValue, 0, mSequenceUserDefined[headerID - 0x70], 0, mSequenceUserDefined[headerID - 0x70].length);
                    }
                }
                break;
            }
            // Verify that it was not a Byte user Defined
            if ((headerID >= 0xB0) && (headerID <= 0xBF)) {
                if ((headerValue != null) && (!(headerValue instanceof Byte))) {
                    throw new IllegalArgumentException("ByteUser Defined must be a Byte");
                }
                mByteUserDefined[headerID - 0xB0] = (Byte) headerValue;
                break;
            }
            // defined header
            if ((headerID >= 0xF0) && (headerID <= 0xFF)) {
                if (!(headerValue instanceof Long)) {
                    if (headerValue == null) {
                        mIntegerUserDefined[headerID - 0xF0] = null;
                        break;
                    }
                    throw new IllegalArgumentException("Integer User Defined must be a Long");
                }
                temp = ((Long) headerValue).longValue();
                if ((temp < 0L) || (temp > 0xFFFFFFFFL)) {
                    throw new IllegalArgumentException("Integer User Defined must be between 0 and 0xFFFFFFFF");
                }
                mIntegerUserDefined[headerID - 0xF0] = (Long) headerValue;
                break;
            }
            throw new IllegalArgumentException("Invalid Header Identifier");
    }
}
Body of Second Method:
{
    long temp = -1;
    switch(headerID) {
        case COUNT:
            if (!(headerValue instanceof Long)) {
                if (headerValue == null) {
                    mCount = null;
                    break;
                }
                throw new IllegalArgumentException("Count must be a Long");
            }
            temp = ((Long) headerValue).longValue();
            if ((temp < 0L) || (temp > 0xFFFFFFFFL)) {
                throw new IllegalArgumentException("Count must be between 0 and 0xFFFFFFFF");
            }
            mCount = (Long) headerValue;
            break;
        case NAME:
            if ((headerValue != null) && (!(headerValue instanceof String))) {
                throw new IllegalArgumentException("Name must be a String");
            }
            mEmptyName = false;
            mName = (String) headerValue;
            break;
        case TYPE:
            if ((headerValue != null) && (!(headerValue instanceof String))) {
                throw new IllegalArgumentException("Type must be a String");
            }
            mType = (String) headerValue;
            break;
        case LENGTH:
            if (!(headerValue instanceof Long)) {
                if (headerValue == null) {
                    mLength = null;
                    break;
                }
                throw new IllegalArgumentException("Length must be a Long");
            }
            temp = ((Long) headerValue).longValue();
            if ((temp < 0L) || (temp > 0xFFFFFFFFL)) {
                throw new IllegalArgumentException("Length must be between 0 and 0xFFFFFFFF");
            }
            mLength = (Long) headerValue;
            break;
        case TIME_ISO_8601:
            if ((headerValue != null) && (!(headerValue instanceof Calendar))) {
                throw new IllegalArgumentException("Time ISO 8601 must be a Calendar");
            }
            mIsoTime = (Calendar) headerValue;
            break;
        case TIME_4_BYTE:
            if ((headerValue != null) && (!(headerValue instanceof Calendar))) {
                throw new IllegalArgumentException("Time 4 Byte must be a Calendar");
            }
            mByteTime = (Calendar) headerValue;
            break;
        case DESCRIPTION:
            if ((headerValue != null) && (!(headerValue instanceof String))) {
                throw new IllegalArgumentException("Description must be a String");
            }
            mDescription = (String) headerValue;
            break;
        case TARGET:
            if (headerValue == null) {
                mTarget = null;
            } else {
                if (!(headerValue instanceof byte[])) {
                    throw new IllegalArgumentException("Target must be a byte array");
                } else {
                    mTarget = new byte[((byte[]) headerValue).length];
                    System.arraycopy(headerValue, 0, mTarget, 0, mTarget.length);
                }
            }
            break;
        case HTTP:
            if (headerValue == null) {
                mHttpHeader = null;
            } else {
                if (!(headerValue instanceof byte[])) {
                    throw new IllegalArgumentException("HTTP must be a byte array");
                } else {
                    mHttpHeader = new byte[((byte[]) headerValue).length];
                    System.arraycopy(headerValue, 0, mHttpHeader, 0, mHttpHeader.length);
                }
            }
            break;
        case WHO:
            if (headerValue == null) {
                mWho = null;
            } else {
                if (!(headerValue instanceof byte[])) {
                    throw new IllegalArgumentException("WHO must be a byte array");
                } else {
                    mWho = new byte[((byte[]) headerValue).length];
                    System.arraycopy(headerValue, 0, mWho, 0, mWho.length);
                }
            }
            break;
        case OBJECT_CLASS:
            if (headerValue == null) {
                mObjectClass = null;
            } else {
                if (!(headerValue instanceof byte[])) {
                    throw new IllegalArgumentException("Object Class must be a byte array");
                } else {
                    mObjectClass = new byte[((byte[]) headerValue).length];
                    System.arraycopy(headerValue, 0, mObjectClass, 0, mObjectClass.length);
                }
            }
            break;
        case APPLICATION_PARAMETER:
            if (headerValue == null) {
                mAppParam = null;
            } else {
                if (!(headerValue instanceof byte[])) {
                    throw new IllegalArgumentException("Application Parameter must be a byte array");
                } else {
                    mAppParam = new byte[((byte[]) headerValue).length];
                    System.arraycopy(headerValue, 0, mAppParam, 0, mAppParam.length);
                }
            }
            break;
        case SINGLE_RESPONSE_MODE:
            if (headerValue == null) {
                mSingleResponseMode = null;
            } else {
                if (!(headerValue instanceof Byte)) {
                    throw new IllegalArgumentException("Single Response Mode must be a Byte");
                } else {
                    mSingleResponseMode = (Byte) headerValue;
                }
            }
            break;
        case SINGLE_RESPONSE_MODE_PARAMETER:
            if (headerValue == null) {
                mSrmParam = null;
            } else {
                if (!(headerValue instanceof Byte)) {
                    throw new IllegalArgumentException("Single Response Mode Parameter must be a Byte");
                } else {
                    mSrmParam = (Byte) headerValue;
                }
            }
            break;
        default:
            // Verify that it was not a Unicode String user Defined
            if ((headerID >= 0x30) && (headerID <= 0x3F)) {
                if ((headerValue != null) && (!(headerValue instanceof String))) {
                    throw new IllegalArgumentException("Unicode String User Defined must be a String");
                }
                mUnicodeUserDefined[headerID - 0x30] = (String) headerValue;
                break;
            }
            // Verify that it was not a byte sequence user defined value
            if ((headerID >= 0x70) && (headerID <= 0x7F)) {
                if (headerValue == null) {
                    mSequenceUserDefined[headerID - 0x70] = null;
                } else {
                    if (!(headerValue instanceof byte[])) {
                        throw new IllegalArgumentException("Byte Sequence User Defined must be a byte array");
                    } else {
                        mSequenceUserDefined[headerID - 0x70] = new byte[((byte[]) headerValue).length];
                        System.arraycopy(headerValue, 0, mSequenceUserDefined[headerID - 0x70], 0, mSequenceUserDefined[headerID - 0x70].length);
                    }
                }
                break;
            }
            // Verify that it was not a Byte user Defined
            if ((headerID >= 0xB0) && (headerID <= 0xBF)) {
                if ((headerValue != null) && (!(headerValue instanceof Byte))) {
                    throw new IllegalArgumentException("ByteUser Defined must be a Byte");
                }
                mByteUserDefined[headerID - 0xB0] = (Byte) headerValue;
                break;
            }
            // defined header
            if ((headerID >= 0xF0) && (headerID <= 0xFF)) {
                if (!(headerValue instanceof Long)) {
                    if (headerValue == null) {
                        mIntegerUserDefined[headerID - 0xF0] = null;
                        break;
                    }
                    throw new IllegalArgumentException("Integer User Defined must be a Long");
                }
                temp = ((Long) headerValue).longValue();
                if ((temp < 0L) || (temp > 0xFFFFFFFFL)) {
                    throw new IllegalArgumentException("Integer User Defined must be between 0 and 0xFFFFFFFF");
                }
                mIntegerUserDefined[headerID - 0xF0] = (Long) headerValue;
                break;
            }
            throw new IllegalArgumentException("Invalid Header Identifier");
    }
}
------------------------
Find a silently evolved API code:android.graphics.drawable.Drawable.createFromXmlInner:COMMENT
Method Modifier: public      static      
Comment:/**
 * Create a drawable from inside an XML document using an optional
 * {@link Theme}. Called on a parser positioned at a tag in an XML
 * document, tries to create a Drawable from that tag. Returns {@code null}
 * if the tag is not a valid drawable.
 */

Body of Frist Method:
{
    final Drawable drawable;
    final String name = parser.getName();
    switch(name) {
        case "selector":
            drawable = new StateListDrawable();
            break;
        case "animated-selector":
            drawable = new AnimatedStateListDrawable();
            break;
        case "level-list":
            drawable = new LevelListDrawable();
            break;
        case "layer-list":
            drawable = new LayerDrawable();
            break;
        case "transition":
            drawable = new TransitionDrawable();
            break;
        case "ripple":
            drawable = new RippleDrawable();
            break;
        case "color":
            drawable = new ColorDrawable();
            break;
        case "shape":
            drawable = new GradientDrawable();
            break;
        case "vector":
            drawable = new VectorDrawable();
            break;
        case "animated-vector":
            drawable = new AnimatedVectorDrawable();
            break;
        case "scale":
            drawable = new ScaleDrawable();
            break;
        case "clip":
            drawable = new ClipDrawable();
            break;
        case "rotate":
            drawable = new RotateDrawable();
            break;
        case "animated-rotate":
            drawable = new AnimatedRotateDrawable();
            break;
        case "animation-list":
            drawable = new AnimationDrawable();
            break;
        case "inset":
            drawable = new InsetDrawable();
            break;
        case "bitmap":
            drawable = new BitmapDrawable(r);
            if (r != null) {
                ((BitmapDrawable) drawable).setTargetDensity(r.getDisplayMetrics());
            }
            break;
        case "nine-patch":
            drawable = new NinePatchDrawable();
            if (r != null) {
                ((NinePatchDrawable) drawable).setTargetDensity(r.getDisplayMetrics());
            }
            break;
        default:
            throw new XmlPullParserException(parser.getPositionDescription() + ": invalid drawable tag " + name);
    }
    drawable.inflate(r, parser, attrs, theme);
    return drawable;
}
Body of Second Method:
{
    final Drawable drawable;
    final String name = parser.getName();
    switch(name) {
        case "selector":
            drawable = new StateListDrawable();
            break;
        case "animated-selector":
            drawable = new AnimatedStateListDrawable();
            break;
        case "level-list":
            drawable = new LevelListDrawable();
            break;
        case "layer-list":
            drawable = new LayerDrawable();
            break;
        case "transition":
            drawable = new TransitionDrawable();
            break;
        case "ripple":
            drawable = new RippleDrawable();
            break;
        case "color":
            drawable = new ColorDrawable();
            break;
        case "shape":
            drawable = new GradientDrawable();
            break;
        case "vector":
            drawable = new VectorDrawable();
            break;
        case "animated-vector":
            drawable = new AnimatedVectorDrawable();
            break;
        case "scale":
            drawable = new ScaleDrawable();
            break;
        case "clip":
            drawable = new ClipDrawable();
            break;
        case "rotate":
            drawable = new RotateDrawable();
            break;
        case "animated-rotate":
            drawable = new AnimatedRotateDrawable();
            break;
        case "animation-list":
            drawable = new AnimationDrawable();
            break;
        case "inset":
            drawable = new InsetDrawable();
            break;
        case "bitmap":
            drawable = new BitmapDrawable();
            break;
        case "nine-patch":
            drawable = new NinePatchDrawable();
            break;
        default:
            throw new XmlPullParserException(parser.getPositionDescription() + ": invalid drawable tag " + name);
    }
    drawable.inflate(r, parser, attrs, theme);
    return drawable;
}
------------------------
Find a silently evolved API code:android.telephony.SubscriptionManager.getPhoneId:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (!isValidSubscriptionId(subId)) {
        logd("[getPhoneId]- fail");
        return INVALID_PHONE_INDEX;
    }
    int result = INVALID_PHONE_INDEX;
    try {
        ISub iSub = ISub.Stub.asInterface(ServiceManager.getService("isub"));
        if (iSub != null) {
            result = iSub.getPhoneId(subId);
        }
    } catch (RemoteException ex) {
    // ignore it
    }
    if (VDBG)
        logd("[getPhoneId]- phoneId=" + result);
    return result;
}
Body of Second Method:
{
    if (!isValidSubscriptionId(subId)) {
        if (DBG) {
            logd("[getPhoneId]- fail");
        }
        return INVALID_PHONE_INDEX;
    }
    int result = INVALID_PHONE_INDEX;
    try {
        ISub iSub = ISub.Stub.asInterface(ServiceManager.getService("isub"));
        if (iSub != null) {
            result = iSub.getPhoneId(subId);
        }
    } catch (RemoteException ex) {
    // ignore it
    }
    if (VDBG)
        logd("[getPhoneId]- phoneId=" + result);
    return result;
}
------------------------
Find a silently evolved API code:android.media.AudioManager.isBluetoothScoAvailableOffCall:COMMENT
Method Modifier: public      
Comment:/**
 * Indicates if current platform supports use of SCO for off call use cases.
 * Application wanted to use bluetooth SCO audio when the phone is not in call
 * must first call this method to make sure that the platform supports this
 * feature.
 * @return true if bluetooth SCO can be used for audio when not in call
 * false otherwise
 * @see #startBluetoothSco()
 */

Body of Frist Method:
{
    return mContext.getResources().getBoolean(com.android.internal.R.bool.config_bluetooth_sco_off_call);
}
Body of Second Method:
{
    return getContext().getResources().getBoolean(com.android.internal.R.bool.config_bluetooth_sco_off_call);
}
------------------------
Find a silently evolved API code:android.app.usage.UsageStats.add:COMMENT
Method Modifier: public      
Comment:/**
 * Add the statistics from the right {@link UsageStats} to the left. The package name for
 * both {@link UsageStats} objects must be the same.
 * @param right The {@link UsageStats} object to merge into this one.
 * @throws java.lang.IllegalArgumentException if the package names of the two
 * {@link UsageStats} objects are different.
 */

Body of Frist Method:
{
    if (!mPackageName.equals(right.mPackageName)) {
        throw new IllegalArgumentException("Can't merge UsageStats for package '" + mPackageName + "' with UsageStats for package '" + right.mPackageName + "'.");
    }
    if (right.mEndTimeStamp > mEndTimeStamp) {
        mLastEvent = right.mLastEvent;
        mEndTimeStamp = right.mEndTimeStamp;
        mLastTimeUsed = right.mLastTimeUsed;
    }
    mBeginTimeStamp = Math.min(mBeginTimeStamp, right.mBeginTimeStamp);
    mTotalTimeInForeground += right.mTotalTimeInForeground;
    mLaunchCount += right.mLaunchCount;
}
Body of Second Method:
{
    if (!mPackageName.equals(right.mPackageName)) {
        throw new IllegalArgumentException("Can't merge UsageStats for package '" + mPackageName + "' with UsageStats for package '" + right.mPackageName + "'.");
    }
    if (right.mEndTimeStamp > mEndTimeStamp) {
        mLastEvent = right.mLastEvent;
        mEndTimeStamp = right.mEndTimeStamp;
        mLastTimeUsed = right.mLastTimeUsed;
        mBeginIdleTime = right.mBeginIdleTime;
        mLastTimeSystemUsed = right.mLastTimeSystemUsed;
    }
    mBeginTimeStamp = Math.min(mBeginTimeStamp, right.mBeginTimeStamp);
    mTotalTimeInForeground += right.mTotalTimeInForeground;
    mLaunchCount += right.mLaunchCount;
}
------------------------
Find a silently evolved API code:android.graphics.Bitmap.sameAs:COMMENT
Method Modifier: public      
Comment:/**
 * Given another bitmap, return true if it has the same dimensions, config,
 * and pixel data as this bitmap. If any of those differ, return false.
 * If other is null, return false.
 */

Body of Frist Method:
{
    return this == other || (other != null && nativeSameAs(mNativeBitmap, other.mNativeBitmap));
}
Body of Second Method:
{
    checkRecycled("Can't call sameAs on a recycled bitmap!");
    if (this == other)
        return true;
    if (other == null)
        return false;
    if (other.isRecycled()) {
        throw new IllegalArgumentException("Can't compare to a recycled bitmap!");
    }
    return nativeSameAs(mFinalizer.mNativeBitmap, other.mFinalizer.mNativeBitmap);
}
------------------------
Find a silently evolved API code:android.hardware.camera2.legacy.LegacyExceptionUtils.throwOnError:COMMENT
Method Modifier: public      static      
Comment:/**
 * Throw error codes used by legacy device methods as exceptions.
 *
 * <p>Non-negative return values are passed through, negative return values are thrown as
 * exceptions.</p>
 *
 * @param errorFlag error to throw as an exception.
 * @throws {@link BufferQueueAbandonedException} for {@link CameraBinderDecorator#ENODEV}.
 * @throws {@link UnsupportedOperationException} for an unknown negative error code.
 * @return {@code errorFlag} if the value was non-negative, throws otherwise.
 */

Body of Frist Method:
{
    switch(errorFlag) {
        case CameraBinderDecorator.NO_ERROR:
            {
                return CameraBinderDecorator.NO_ERROR;
            }
        case CameraBinderDecorator.ENODEV:
            {
                throw new BufferQueueAbandonedException();
            }
    }
    if (errorFlag < 0) {
        throw new UnsupportedOperationException("Unknown error " + errorFlag);
    }
    return errorFlag;
}
Body of Second Method:
{
    switch(errorFlag) {
        case CameraBinderDecorator.NO_ERROR:
            {
                return CameraBinderDecorator.NO_ERROR;
            }
        case CameraBinderDecorator.BAD_VALUE:
            {
                throw new BufferQueueAbandonedException();
            }
    }
    if (errorFlag < 0) {
        throw new UnsupportedOperationException("Unknown error " + errorFlag);
    }
    return errorFlag;
}
------------------------
Find a silently evolved API code:android.hardware.camera2.CameraMetadata.getKeysStatic:COMMENT
Method Modifier: default     static      
Comment:/*package*/

Body of Frist Method:
{
    if (VERBOSE)
        Log.v(TAG, "getKeysStatic for " + type);
    // TotalCaptureResult does not have any of the keys on it, use CaptureResult instead
    if (type.equals(TotalCaptureResult.class)) {
        type = CaptureResult.class;
    }
    if (filterTags != null) {
        Arrays.sort(filterTags);
    }
    ArrayList<TKey> keyList = new ArrayList<TKey>();
    Field[] fields = type.getDeclaredFields();
    for (Field field : fields) {
        // Filter for Keys that are public
        if (field.getType().isAssignableFrom(keyClass) && (field.getModifiers() & Modifier.PUBLIC) != 0) {
            TKey key;
            try {
                key = (TKey) field.get(instance);
            } catch (IllegalAccessException e) {
                throw new AssertionError("Can't get IllegalAccessException", e);
            } catch (IllegalArgumentException e) {
                throw new AssertionError("Can't get IllegalArgumentException", e);
            }
            if (instance == null || instance.getProtected(key) != null) {
                if (shouldKeyBeAdded(key, field, filterTags)) {
                    keyList.add(key);
                    if (VERBOSE) {
                        Log.v(TAG, "getKeysStatic - key was added - " + key);
                    }
                } else if (VERBOSE) {
                    Log.v(TAG, "getKeysStatic - key was filtered - " + key);
                }
            }
        }
    }
    return keyList;
}
Body of Second Method:
{
    if (DEBUG)
        Log.v(TAG, "getKeysStatic for " + type);
    // TotalCaptureResult does not have any of the keys on it, use CaptureResult instead
    if (type.equals(TotalCaptureResult.class)) {
        type = CaptureResult.class;
    }
    if (filterTags != null) {
        Arrays.sort(filterTags);
    }
    ArrayList<TKey> keyList = new ArrayList<TKey>();
    Field[] fields = type.getDeclaredFields();
    for (Field field : fields) {
        // Filter for Keys that are public
        if (field.getType().isAssignableFrom(keyClass) && (field.getModifiers() & Modifier.PUBLIC) != 0) {
            TKey key;
            try {
                key = (TKey) field.get(instance);
            } catch (IllegalAccessException e) {
                throw new AssertionError("Can't get IllegalAccessException", e);
            } catch (IllegalArgumentException e) {
                throw new AssertionError("Can't get IllegalArgumentException", e);
            }
            if (instance == null || instance.getProtected(key) != null) {
                if (shouldKeyBeAdded(key, field, filterTags)) {
                    keyList.add(key);
                    if (DEBUG) {
                        Log.v(TAG, "getKeysStatic - key was added - " + key);
                    }
                } else if (DEBUG) {
                    Log.v(TAG, "getKeysStatic - key was filtered - " + key);
                }
            }
        }
    }
    ArrayList<TKey> vendorKeys = CameraMetadataNative.getAllVendorKeys(keyClass);
    if (vendorKeys != null) {
        for (TKey k : vendorKeys) {
            String keyName;
            if (k instanceof CaptureRequest.Key<?>) {
                keyName = ((CaptureRequest.Key<?>) k).getName();
            } else if (k instanceof CaptureResult.Key<?>) {
                keyName = ((CaptureResult.Key<?>) k).getName();
            } else if (k instanceof CameraCharacteristics.Key<?>) {
                keyName = ((CameraCharacteristics.Key<?>) k).getName();
            } else {
                continue;
            }
            if (filterTags == null || Arrays.binarySearch(filterTags, CameraMetadataNative.getTag(keyName)) >= 0) {
                keyList.add(k);
            }
        }
    }
    return keyList;
}
------------------------
Find a silently evolved API code:android.media.MediaDrm.ProvisionRequest.getData:COMMENT
Method Modifier: public      
Comment:/**
 * Get the opaque message data
 */

Body of Frist Method:
{
    return mData;
}
Body of Second Method:
{
    if (mData == null) {
        // is needed here to guarantee @NonNull annotation.
        throw new RuntimeException("ProvisionRequest is not initialized");
    }
    return mData;
}
------------------------
Find a silently evolved API code:android.view.accessibility.AccessibilityRecord.clear:COMMENT
Method Modifier: default     
Comment:/**
 * Clears the state of this instance.
 */

Body of Frist Method:
{
    mSealed = false;
    mBooleanProperties = 0;
    mCurrentItemIndex = UNDEFINED;
    mItemCount = UNDEFINED;
    mFromIndex = UNDEFINED;
    mToIndex = UNDEFINED;
    mScrollX = UNDEFINED;
    mScrollY = UNDEFINED;
    mMaxScrollX = UNDEFINED;
    mMaxScrollY = UNDEFINED;
    mAddedCount = UNDEFINED;
    mRemovedCount = UNDEFINED;
    mClassName = null;
    mContentDescription = null;
    mBeforeText = null;
    mParcelableData = null;
    mText.clear();
    mSourceNodeId = AccessibilityNodeInfo.makeNodeId(UNDEFINED, UNDEFINED);
    mSourceWindowId = UNDEFINED;
    mConnectionId = UNDEFINED;
}
Body of Second Method:
{
    mSealed = false;
    mBooleanProperties = 0;
    mCurrentItemIndex = UNDEFINED;
    mItemCount = UNDEFINED;
    mFromIndex = UNDEFINED;
    mToIndex = UNDEFINED;
    mScrollX = UNDEFINED;
    mScrollY = UNDEFINED;
    mMaxScrollX = UNDEFINED;
    mMaxScrollY = UNDEFINED;
    mAddedCount = UNDEFINED;
    mRemovedCount = UNDEFINED;
    mClassName = null;
    mContentDescription = null;
    mBeforeText = null;
    mParcelableData = null;
    mText.clear();
    clearSourceNode();
    mSourceWindowId = UNDEFINED;
    mConnectionId = UNDEFINED;
}
------------------------
Find a silently evolved API code:android.app.Fragment.getActivity:COMMENT
Method Modifier: public      final       
Comment:/**
 * Return the Activity this fragment is currently associated with.
 */

Body of Frist Method:
{
    return mActivity;
}
Body of Second Method:
{
    return mHost == null ? null : mHost.getActivity();
}
------------------------
Find a silently evolved API code:android.view.inputmethod.InputMethodSubtype.getDisplayName:COMMENT
Method Modifier: public      
Comment:/**
 * @param context Context will be used for getting Locale and PackageManager.
 * @param packageName The package name of the IME
 * @param appInfo The application info of the IME
 * @return a display name for this subtype. The string resource of the label (mSubtypeNameResId)
 * may have exactly one %s in it. If there is, the %s part will be replaced with the locale's
 * display name by the formatter. If there is not, this method returns the string specified by
 * mSubtypeNameResId. If mSubtypeNameResId is not specified (== 0), it's up to the framework to
 * generate an appropriate display name.
 */

Body of Frist Method:
{
    final Locale locale = constructLocaleFromString(mSubtypeLocale);
    final String localeStr = locale != null ? locale.getDisplayName() : mSubtypeLocale;
    if (mSubtypeNameResId == 0) {
        return localeStr;
    }
    final CharSequence subtypeName = context.getPackageManager().getText(packageName, mSubtypeNameResId, appInfo);
    if (!TextUtils.isEmpty(subtypeName)) {
        final String replacementString = containsExtraValueKey(EXTRA_KEY_UNTRANSLATABLE_STRING_IN_SUBTYPE_NAME) ? getExtraValueOf(EXTRA_KEY_UNTRANSLATABLE_STRING_IN_SUBTYPE_NAME) : localeStr;
        try {
            return String.format(subtypeName.toString(), replacementString != null ? replacementString : "");
        } catch (IllegalFormatException e) {
            Slog.w(TAG, "Found illegal format in subtype name(" + subtypeName + "): " + e);
            return "";
        }
    } else {
        return localeStr;
    }
}
Body of Second Method:
{
    final Locale locale = getLocaleObject();
    final String localeStr = locale != null ? locale.getDisplayName() : mSubtypeLocale;
    if (mSubtypeNameResId == 0) {
        return localeStr;
    }
    final CharSequence subtypeName = context.getPackageManager().getText(packageName, mSubtypeNameResId, appInfo);
    if (!TextUtils.isEmpty(subtypeName)) {
        final String replacementString = containsExtraValueKey(EXTRA_KEY_UNTRANSLATABLE_STRING_IN_SUBTYPE_NAME) ? getExtraValueOf(EXTRA_KEY_UNTRANSLATABLE_STRING_IN_SUBTYPE_NAME) : localeStr;
        try {
            return String.format(subtypeName.toString(), replacementString != null ? replacementString : "");
        } catch (IllegalFormatException e) {
            Slog.w(TAG, "Found illegal format in subtype name(" + subtypeName + "): " + e);
            return "";
        }
    } else {
        return localeStr;
    }
}
------------------------
Find a silently evolved API code:android.os.PersistableBundle.restoreFromXml:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    final int outerDepth = in.getDepth();
    final String startTag = in.getName();
    final String[] tagName = new String[1];
    int event;
    while (((event = in.next()) != XmlPullParser.END_DOCUMENT) && (event != XmlPullParser.END_TAG || in.getDepth() < outerDepth)) {
        if (event == XmlPullParser.START_TAG) {
            return new PersistableBundle((Map<String, Object>) XmlUtils.readThisMapXml(in, startTag, tagName, new MyReadMapCallback()));
        }
    }
    return EMPTY;
}
Body of Second Method:
{
    final int outerDepth = in.getDepth();
    final String startTag = in.getName();
    final String[] tagName = new String[1];
    int event;
    while (((event = in.next()) != XmlPullParser.END_DOCUMENT) && (event != XmlPullParser.END_TAG || in.getDepth() < outerDepth)) {
        if (event == XmlPullParser.START_TAG) {
            return new PersistableBundle((ArrayMap<String, Object>) XmlUtils.readThisArrayMapXml(in, startTag, tagName, new MyReadMapCallback()));
        }
    }
    return EMPTY;
}
------------------------
Find a silently evolved API code:android.view.LayoutInflater.createView:COMMENT
Method Modifier: public      final       
Comment:/**
 * Low-level function for instantiating a view by name. This attempts to
 * instantiate a view class of the given <var>name</var> found in this
 * LayoutInflater's ClassLoader.
 *
 * <p>
 * There are two things that can happen in an error case: either the
 * exception describing the error will be thrown, or a null will be
 * returned. You must deal with both possibilities -- the former will happen
 * the first time createView() is called for a class of a particular name,
 * the latter every time there-after for that class name.
 *
 * @param name The full name of the class to be instantiated.
 * @param attrs The XML attributes supplied for this instance.
 *
 * @return View The newly instantiated view, or null.
 */

Body of Frist Method:
{
    Constructor<? extends View> constructor = sConstructorMap.get(name);
    Class<? extends View> clazz = null;
    try {
        Trace.traceBegin(Trace.TRACE_TAG_VIEW, name);
        if (constructor == null) {
            // Class not found in the cache, see if it's real, and try to add it
            clazz = mContext.getClassLoader().loadClass(prefix != null ? (prefix + name) : name).asSubclass(View.class);
            if (mFilter != null && clazz != null) {
                boolean allowed = mFilter.onLoadClass(clazz);
                if (!allowed) {
                    failNotAllowed(name, prefix, attrs);
                }
            }
            constructor = clazz.getConstructor(mConstructorSignature);
            sConstructorMap.put(name, constructor);
        } else {
            // If we have a filter, apply it to cached constructor
            if (mFilter != null) {
                // Have we seen this name before?
                Boolean allowedState = mFilterMap.get(name);
                if (allowedState == null) {
                    // New class -- remember whether it is allowed
                    clazz = mContext.getClassLoader().loadClass(prefix != null ? (prefix + name) : name).asSubclass(View.class);
                    boolean allowed = clazz != null && mFilter.onLoadClass(clazz);
                    mFilterMap.put(name, allowed);
                    if (!allowed) {
                        failNotAllowed(name, prefix, attrs);
                    }
                } else if (allowedState.equals(Boolean.FALSE)) {
                    failNotAllowed(name, prefix, attrs);
                }
            }
        }
        Object[] args = mConstructorArgs;
        args[1] = attrs;
        constructor.setAccessible(true);
        final View view = constructor.newInstance(args);
        if (view instanceof ViewStub) {
            // Use the same context when inflating ViewStub later.
            final ViewStub viewStub = (ViewStub) view;
            viewStub.setLayoutInflater(cloneInContext((Context) args[0]));
        }
        return view;
    } catch (NoSuchMethodException e) {
        InflateException ie = new InflateException(attrs.getPositionDescription() + ": Error inflating class " + (prefix != null ? (prefix + name) : name));
        ie.initCause(e);
        throw ie;
    } catch (ClassCastException e) {
        // If loaded class is not a View subclass
        InflateException ie = new InflateException(attrs.getPositionDescription() + ": Class is not a View " + (prefix != null ? (prefix + name) : name));
        ie.initCause(e);
        throw ie;
    } catch (ClassNotFoundException e) {
        // If loadClass fails, we should propagate the exception.
        throw e;
    } catch (Exception e) {
        InflateException ie = new InflateException(attrs.getPositionDescription() + ": Error inflating class " + (clazz == null ? "<unknown>" : clazz.getName()));
        ie.initCause(e);
        throw ie;
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_VIEW);
    }
}
Body of Second Method:
{
    Constructor<? extends View> constructor = sConstructorMap.get(name);
    Class<? extends View> clazz = null;
    try {
        Trace.traceBegin(Trace.TRACE_TAG_VIEW, name);
        if (constructor == null) {
            // Class not found in the cache, see if it's real, and try to add it
            clazz = mContext.getClassLoader().loadClass(prefix != null ? (prefix + name) : name).asSubclass(View.class);
            if (mFilter != null && clazz != null) {
                boolean allowed = mFilter.onLoadClass(clazz);
                if (!allowed) {
                    failNotAllowed(name, prefix, attrs);
                }
            }
            constructor = clazz.getConstructor(mConstructorSignature);
            constructor.setAccessible(true);
            sConstructorMap.put(name, constructor);
        } else {
            // If we have a filter, apply it to cached constructor
            if (mFilter != null) {
                // Have we seen this name before?
                Boolean allowedState = mFilterMap.get(name);
                if (allowedState == null) {
                    // New class -- remember whether it is allowed
                    clazz = mContext.getClassLoader().loadClass(prefix != null ? (prefix + name) : name).asSubclass(View.class);
                    boolean allowed = clazz != null && mFilter.onLoadClass(clazz);
                    mFilterMap.put(name, allowed);
                    if (!allowed) {
                        failNotAllowed(name, prefix, attrs);
                    }
                } else if (allowedState.equals(Boolean.FALSE)) {
                    failNotAllowed(name, prefix, attrs);
                }
            }
        }
        Object[] args = mConstructorArgs;
        args[1] = attrs;
        final View view = constructor.newInstance(args);
        if (view instanceof ViewStub) {
            // Use the same context when inflating ViewStub later.
            final ViewStub viewStub = (ViewStub) view;
            viewStub.setLayoutInflater(cloneInContext((Context) args[0]));
        }
        return view;
    } catch (NoSuchMethodException e) {
        InflateException ie = new InflateException(attrs.getPositionDescription() + ": Error inflating class " + (prefix != null ? (prefix + name) : name));
        ie.initCause(e);
        throw ie;
    } catch (ClassCastException e) {
        // If loaded class is not a View subclass
        InflateException ie = new InflateException(attrs.getPositionDescription() + ": Class is not a View " + (prefix != null ? (prefix + name) : name));
        ie.initCause(e);
        throw ie;
    } catch (ClassNotFoundException e) {
        // If loadClass fails, we should propagate the exception.
        throw e;
    } catch (Exception e) {
        InflateException ie = new InflateException(attrs.getPositionDescription() + ": Error inflating class " + (clazz == null ? "<unknown>" : clazz.getName()));
        ie.initCause(e);
        throw ie;
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_VIEW);
    }
}
------------------------
Find a silently evolved API code:android.app.ActivityManager.checkComponentPermission:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    // Root, system server get to do everything.
    if (uid == 0 || uid == Process.SYSTEM_UID) {
        return PackageManager.PERMISSION_GRANTED;
    }
    // Isolated processes don't get any permissions.
    if (UserHandle.isIsolated(uid)) {
        return PackageManager.PERMISSION_DENIED;
    }
    // blanket access to it regardless of the permissions it requires.
    if (owningUid >= 0 && UserHandle.isSameApp(uid, owningUid)) {
        return PackageManager.PERMISSION_GRANTED;
    }
    // If the target is not exported, then nobody else can get to it.
    if (!exported) {
        /*
            RuntimeException here = new RuntimeException("here");
            here.fillInStackTrace();
            Slog.w(TAG, "Permission denied: checkComponentPermission() owningUid=" + owningUid,
                    here);
            */
        return PackageManager.PERMISSION_DENIED;
    }
    if (permission == null) {
        return PackageManager.PERMISSION_GRANTED;
    }
    try {
        return AppGlobals.getPackageManager().checkUidPermission(permission, uid);
    } catch (RemoteException e) {
        // Should never happen, but if it does... deny!
        Slog.e(TAG, "PackageManager is dead?!?", e);
    }
    return PackageManager.PERMISSION_DENIED;
}
Body of Second Method:
{
    // Root, system server get to do everything.
    final int appId = UserHandle.getAppId(uid);
    if (appId == Process.ROOT_UID || appId == Process.SYSTEM_UID) {
        return PackageManager.PERMISSION_GRANTED;
    }
    // Isolated processes don't get any permissions.
    if (UserHandle.isIsolated(uid)) {
        return PackageManager.PERMISSION_DENIED;
    }
    // blanket access to it regardless of the permissions it requires.
    if (owningUid >= 0 && UserHandle.isSameApp(uid, owningUid)) {
        return PackageManager.PERMISSION_GRANTED;
    }
    // If the target is not exported, then nobody else can get to it.
    if (!exported) {
        /*
            RuntimeException here = new RuntimeException("here");
            here.fillInStackTrace();
            Slog.w(TAG, "Permission denied: checkComponentPermission() owningUid=" + owningUid,
                    here);
            */
        return PackageManager.PERMISSION_DENIED;
    }
    if (permission == null) {
        return PackageManager.PERMISSION_GRANTED;
    }
    try {
        return AppGlobals.getPackageManager().checkUidPermission(permission, uid);
    } catch (RemoteException e) {
        // Should never happen, but if it does... deny!
        Slog.e(TAG, "PackageManager is dead?!?", e);
    }
    return PackageManager.PERMISSION_DENIED;
}
------------------------
Find a silently evolved API code:android.app.Notification.Builder.applyStandardTemplate:COMMENT
Method Modifier: private     
Comment:/**
 * @param hasProgress whether the progress bar should be shown and set
 */

Body of Frist Method:
{
    RemoteViews contentView = new BuilderRemoteViews(mContext.getApplicationInfo(), resId);
    resetStandardTemplate(contentView);
    boolean showLine3 = false;
    boolean showLine2 = false;
    boolean contentTextInLine2 = false;
    if (mLargeIcon != null) {
        contentView.setImageViewBitmap(R.id.icon, mLargeIcon);
        processLargeLegacyIcon(mLargeIcon, contentView);
        contentView.setImageViewResource(R.id.right_icon, mSmallIcon);
        contentView.setViewVisibility(R.id.right_icon, View.VISIBLE);
        processSmallRightIcon(mSmallIcon, contentView);
    } else {
        // small icon at left
        contentView.setImageViewResource(R.id.icon, mSmallIcon);
        contentView.setViewVisibility(R.id.icon, View.VISIBLE);
        processSmallIconAsLarge(mSmallIcon, contentView);
    }
    if (mContentTitle != null) {
        contentView.setTextViewText(R.id.title, processLegacyText(mContentTitle));
    }
    if (mContentText != null) {
        contentView.setTextViewText(R.id.text, processLegacyText(mContentText));
        showLine3 = true;
    }
    if (mContentInfo != null) {
        contentView.setTextViewText(R.id.info, processLegacyText(mContentInfo));
        contentView.setViewVisibility(R.id.info, View.VISIBLE);
        showLine3 = true;
    } else if (mNumber > 0) {
        final int tooBig = mContext.getResources().getInteger(R.integer.status_bar_notification_info_maxnum);
        if (mNumber > tooBig) {
            contentView.setTextViewText(R.id.info, processLegacyText(mContext.getResources().getString(R.string.status_bar_notification_info_overflow)));
        } else {
            NumberFormat f = NumberFormat.getIntegerInstance();
            contentView.setTextViewText(R.id.info, processLegacyText(f.format(mNumber)));
        }
        contentView.setViewVisibility(R.id.info, View.VISIBLE);
        showLine3 = true;
    } else {
        contentView.setViewVisibility(R.id.info, View.GONE);
    }
    // Need to show three lines?
    if (mSubText != null) {
        contentView.setTextViewText(R.id.text, processLegacyText(mSubText));
        if (mContentText != null) {
            contentView.setTextViewText(R.id.text2, processLegacyText(mContentText));
            contentView.setViewVisibility(R.id.text2, View.VISIBLE);
            showLine2 = true;
            contentTextInLine2 = true;
        } else {
            contentView.setViewVisibility(R.id.text2, View.GONE);
        }
    } else {
        contentView.setViewVisibility(R.id.text2, View.GONE);
        if (hasProgress && (mProgressMax != 0 || mProgressIndeterminate)) {
            contentView.setViewVisibility(R.id.progress, View.VISIBLE);
            contentView.setProgressBar(R.id.progress, mProgressMax, mProgress, mProgressIndeterminate);
            contentView.setProgressBackgroundTintList(R.id.progress, ColorStateList.valueOf(mContext.getResources().getColor(R.color.notification_progress_background_color)));
            if (mColor != COLOR_DEFAULT) {
                ColorStateList colorStateList = ColorStateList.valueOf(mColor);
                contentView.setProgressTintList(R.id.progress, colorStateList);
                contentView.setProgressIndeterminateTintList(R.id.progress, colorStateList);
            }
            showLine2 = true;
        } else {
            contentView.setViewVisibility(R.id.progress, View.GONE);
        }
    }
    if (showLine2) {
        // need to shrink all the type to make sure everything fits
        shrinkLine3Text(contentView);
    }
    if (showsTimeOrChronometer()) {
        if (mUseChronometer) {
            contentView.setViewVisibility(R.id.chronometer, View.VISIBLE);
            contentView.setLong(R.id.chronometer, "setBase", mWhen + (SystemClock.elapsedRealtime() - System.currentTimeMillis()));
            contentView.setBoolean(R.id.chronometer, "setStarted", true);
        } else {
            contentView.setViewVisibility(R.id.time, View.VISIBLE);
            contentView.setLong(R.id.time, "setTime", mWhen);
        }
    }
    // Adjust padding depending on line count and font size.
    contentView.setViewPadding(R.id.line1, 0, calculateTopPadding(mContext, mHasThreeLines, mContext.getResources().getConfiguration().fontScale), 0, 0);
    // We want to add badge to first line of text.
    boolean addedBadge = addProfileBadge(contentView, contentTextInLine2 ? R.id.profile_badge_line2 : R.id.profile_badge_line3);
    // If we added the badge to line 3 then we should show line 3.
    if (addedBadge && !contentTextInLine2) {
        showLine3 = true;
    }
    // Note getStandardView may hide line 3 again.
    contentView.setViewVisibility(R.id.line3, showLine3 ? View.VISIBLE : View.GONE);
    contentView.setViewVisibility(R.id.overflow_divider, showLine3 ? View.VISIBLE : View.GONE);
    return contentView;
}
Body of Second Method:
{
    RemoteViews contentView = new BuilderRemoteViews(mContext.getApplicationInfo(), resId);
    resetStandardTemplate(contentView);
    boolean showLine3 = false;
    boolean showLine2 = false;
    boolean contentTextInLine2 = false;
    if (mLargeIcon != null) {
        contentView.setImageViewIcon(R.id.icon, mLargeIcon);
        processLargeLegacyIcon(mLargeIcon, contentView);
        contentView.setImageViewIcon(R.id.right_icon, mSmallIcon);
        contentView.setViewVisibility(R.id.right_icon, View.VISIBLE);
        processSmallRightIcon(mSmallIcon, contentView);
    } else {
        // small icon at left
        contentView.setImageViewIcon(R.id.icon, mSmallIcon);
        contentView.setViewVisibility(R.id.icon, View.VISIBLE);
        processSmallIconAsLarge(mSmallIcon, contentView);
    }
    if (mContentTitle != null) {
        contentView.setTextViewText(R.id.title, processLegacyText(mContentTitle));
    }
    if (mContentText != null) {
        contentView.setTextViewText(R.id.text, processLegacyText(mContentText));
        showLine3 = true;
    }
    if (mContentInfo != null) {
        contentView.setTextViewText(R.id.info, processLegacyText(mContentInfo));
        contentView.setViewVisibility(R.id.info, View.VISIBLE);
        showLine3 = true;
    } else if (mNumber > 0) {
        final int tooBig = mContext.getResources().getInteger(R.integer.status_bar_notification_info_maxnum);
        if (mNumber > tooBig) {
            contentView.setTextViewText(R.id.info, processLegacyText(mContext.getResources().getString(R.string.status_bar_notification_info_overflow)));
        } else {
            NumberFormat f = NumberFormat.getIntegerInstance();
            contentView.setTextViewText(R.id.info, processLegacyText(f.format(mNumber)));
        }
        contentView.setViewVisibility(R.id.info, View.VISIBLE);
        showLine3 = true;
    } else {
        contentView.setViewVisibility(R.id.info, View.GONE);
    }
    // Need to show three lines?
    if (mSubText != null) {
        contentView.setTextViewText(R.id.text, processLegacyText(mSubText));
        if (mContentText != null) {
            contentView.setTextViewText(R.id.text2, processLegacyText(mContentText));
            contentView.setViewVisibility(R.id.text2, View.VISIBLE);
            showLine2 = true;
            contentTextInLine2 = true;
        } else {
            contentView.setViewVisibility(R.id.text2, View.GONE);
        }
    } else {
        contentView.setViewVisibility(R.id.text2, View.GONE);
        if (hasProgress && (mProgressMax != 0 || mProgressIndeterminate)) {
            contentView.setViewVisibility(R.id.progress, View.VISIBLE);
            contentView.setProgressBar(R.id.progress, mProgressMax, mProgress, mProgressIndeterminate);
            contentView.setProgressBackgroundTintList(R.id.progress, ColorStateList.valueOf(mContext.getColor(R.color.notification_progress_background_color)));
            if (mColor != COLOR_DEFAULT) {
                ColorStateList colorStateList = ColorStateList.valueOf(mColor);
                contentView.setProgressTintList(R.id.progress, colorStateList);
                contentView.setProgressIndeterminateTintList(R.id.progress, colorStateList);
            }
            showLine2 = true;
        } else {
            contentView.setViewVisibility(R.id.progress, View.GONE);
        }
    }
    if (showLine2) {
        // need to shrink all the type to make sure everything fits
        shrinkLine3Text(contentView);
    }
    if (showsTimeOrChronometer()) {
        if (mUseChronometer) {
            contentView.setViewVisibility(R.id.chronometer, View.VISIBLE);
            contentView.setLong(R.id.chronometer, "setBase", mWhen + (SystemClock.elapsedRealtime() - System.currentTimeMillis()));
            contentView.setBoolean(R.id.chronometer, "setStarted", true);
        } else {
            contentView.setViewVisibility(R.id.time, View.VISIBLE);
            contentView.setLong(R.id.time, "setTime", mWhen);
        }
    }
    // Adjust padding depending on line count and font size.
    contentView.setViewPadding(R.id.line1, 0, calculateTopPadding(mContext, mHasThreeLines, mContext.getResources().getConfiguration().fontScale), 0, 0);
    // We want to add badge to first line of text.
    boolean addedBadge = addProfileBadge(contentView, contentTextInLine2 ? R.id.profile_badge_line2 : R.id.profile_badge_line3);
    // If we added the badge to line 3 then we should show line 3.
    if (addedBadge && !contentTextInLine2) {
        showLine3 = true;
    }
    // Note getStandardView may hide line 3 again.
    contentView.setViewVisibility(R.id.line3, showLine3 ? View.VISIBLE : View.GONE);
    contentView.setViewVisibility(R.id.overflow_divider, showLine3 ? View.VISIBLE : View.GONE);
    return contentView;
}
------------------------
Find a silently evolved API code:android.graphics.ImageFormat.isPublicFormat:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Determine whether or not this is a public-visible {@code format}.
 *
 * <p>In particular, {@code @hide} formats will return {@code false}.</p>
 *
 * <p>Any other formats (including UNKNOWN) will return {@code false}.</p>
 *
 * @param format an integer format
 * @return a boolean
 *
 * @hide
 */

Body of Frist Method:
{
    switch(format) {
        case RGB_565:
        case NV16:
        case YUY2:
        case YV12:
        case JPEG:
        case NV21:
        case YUV_420_888:
        case RAW_SENSOR:
        case RAW10:
            return true;
    }
    return false;
}
Body of Second Method:
{
    switch(format) {
        case RGB_565:
        case NV16:
        case YUY2:
        case YV12:
        case JPEG:
        case NV21:
        case YUV_420_888:
        case YUV_422_888:
        case YUV_444_888:
        case FLEX_RGB_888:
        case FLEX_RGBA_8888:
        case RAW_SENSOR:
        case RAW10:
        case RAW12:
        case DEPTH16:
        case DEPTH_POINT_CLOUD:
        case PRIVATE:
            return true;
    }
    return false;
}
------------------------
Find a silently evolved API code:android.hardware.location.GeofenceHardwareImpl.reportGeofenceTransition:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Used to report geofence transitions
 */

Body of Frist Method:
{
    if (location == null) {
        Log.e(TAG, String.format("Invalid Geofence Transition: location=%p", location));
        return;
    }
    if (DEBUG) {
        Log.d(TAG, "GeofenceTransition| " + location + ", transition:" + transition + ", transitionTimestamp:" + transitionTimestamp + ", monitoringType:" + monitoringType + ", sourcesUsed:" + sourcesUsed);
    }
    GeofenceTransition geofenceTransition = new GeofenceTransition(geofenceId, transition, transitionTimestamp, location, monitoringType, sourcesUsed);
    acquireWakeLock();
    Message message = mGeofenceHandler.obtainMessage(GEOFENCE_TRANSITION_CALLBACK, geofenceTransition);
    message.sendToTarget();
}
Body of Second Method:
{
    if (location == null) {
        Log.e(TAG, String.format("Invalid Geofence Transition: location=null"));
        return;
    }
    if (DEBUG) {
        Log.d(TAG, "GeofenceTransition| " + location + ", transition:" + transition + ", transitionTimestamp:" + transitionTimestamp + ", monitoringType:" + monitoringType + ", sourcesUsed:" + sourcesUsed);
    }
    GeofenceTransition geofenceTransition = new GeofenceTransition(geofenceId, transition, transitionTimestamp, location, monitoringType, sourcesUsed);
    acquireWakeLock();
    Message message = mGeofenceHandler.obtainMessage(GEOFENCE_TRANSITION_CALLBACK, geofenceTransition);
    message.sendToTarget();
}
------------------------
Find a silently evolved API code:android.graphics.Bitmap.setHasMipMap:COMMENT
Method Modifier: public      final       
Comment:/**
 * Set a hint for the renderer responsible for drawing this bitmap
 * indicating that it should attempt to use mipmaps when this bitmap
 * is drawn scaled down.
 *
 * If you know that you are going to draw this bitmap at less than
 * 50% of its original size, you may be able to obtain a higher
 * quality by turning this property on.
 *
 * Note that if the renderer respects this hint it might have to
 * allocate extra memory to hold the mipmap levels for this bitmap.
 *
 * This property is only a suggestion that can be ignored by the
 * renderer. It is not guaranteed to have any effect.
 *
 * @param hasMipMap indicates whether the renderer should attempt
 * to use mipmaps
 *
 * @see #hasMipMap()
 */

Body of Frist Method:
{
    nativeSetHasMipMap(mNativeBitmap, hasMipMap);
}
Body of Second Method:
{
    checkRecycled("setHasMipMap called on a recycled bitmap");
    nativeSetHasMipMap(mFinalizer.mNativeBitmap, hasMipMap);
}
------------------------
Find a silently evolved API code:android.os.UserManager.setUserRestriction:COMMENT
Method Modifier: public      hidden      deprecated  
Comment:/**
 * @hide
 * Sets the value of a specific restriction on a specific user.
 * Requires the MANAGE_USERS permission.
 * @param key the key of the restriction
 * @param value the value for the restriction
 * @param userHandle the user whose restriction is to be changed.
 * @deprecated use {@link android.app.admin.DevicePolicyManager#addUserRestriction(
 * android.content.ComponentName, String)} or
 * {@link android.app.admin.DevicePolicyManager#clearUserRestriction(
 * android.content.ComponentName, String)} instead.
 */

Body of Frist Method:
{
    Bundle bundle = getUserRestrictions(userHandle);
    bundle.putBoolean(key, value);
    setUserRestrictions(bundle, userHandle);
}
Body of Second Method:
{
    try {
        mService.setUserRestriction(key, value, userHandle.getIdentifier());
    } catch (RemoteException re) {
        Log.w(TAG, "Could not set user restriction", re);
    }
}
------------------------
Find a silently evolved API code:android.app.AlarmManager.setInexactRepeating:COMMENT
Method Modifier: public      
Comment:/**
 * Schedule a repeating alarm that has inexact trigger time requirements;
 * for example, an alarm that repeats every hour, but not necessarily at
 * the top of every hour.  These alarms are more power-efficient than
 * the strict recurrences traditionally supplied by {@link #setRepeating}, since the
 * system can adjust alarms' delivery times to cause them to fire simultaneously,
 * avoiding waking the device from sleep more than necessary.
 *
 * <p>Your alarm's first trigger will not be before the requested time,
 * but it might not occur for almost a full interval after that time.  In
 * addition, while the overall period of the repeating alarm will be as
 * requested, the time between any two successive firings of the alarm
 * may vary.  If your application demands very low jitter, use
 * one-shot alarms with an appropriate window instead; see {@link
 * #setWindow(int, long, long, PendingIntent)} and
 * {@link #setExact(int, long, PendingIntent)}.
 *
 * <p class="note">
 * As of API 19, all repeating alarms are inexact.  Because this method has
 * been available since API 3, your application can safely call it and be
 * assured that it will get similar behavior on both current and older versions
 * of Android.
 *
 * @param type One of {@link #ELAPSED_REALTIME}, {@link #ELAPSED_REALTIME_WAKEUP},
 * {@link #RTC}, or {@link #RTC_WAKEUP}.
 * @param triggerAtMillis time in milliseconds that the alarm should first
 * go off, using the appropriate clock (depending on the alarm type).  This
 * is inexact: the alarm will not fire before this time, but there may be a
 * delay of almost an entire alarm interval before the first invocation of
 * the alarm.
 * @param intervalMillis interval in milliseconds between subsequent repeats
 * of the alarm.  Prior to API 19, if this is one of INTERVAL_FIFTEEN_MINUTES,
 * INTERVAL_HALF_HOUR, INTERVAL_HOUR, INTERVAL_HALF_DAY, or INTERVAL_DAY
 * then the alarm will be phase-aligned with other alarms to reduce the
 * number of wakeups.  Otherwise, the alarm will be set as though the
 * application had called {@link #setRepeating}.  As of API 19, all repeating
 * alarms will be inexact and subject to batching with other alarms regardless
 * of their stated repeat interval.
 * @param operation Action to perform when the alarm goes off;
 * typically comes from {@link PendingIntent#getBroadcast
 * IntentSender.getBroadcast()}.
 *
 * @see android.os.Handler
 * @see #set
 * @see #cancel
 * @see android.content.Context#sendBroadcast
 * @see android.content.Context#registerReceiver
 * @see android.content.Intent#filterEquals
 * @see #ELAPSED_REALTIME
 * @see #ELAPSED_REALTIME_WAKEUP
 * @see #RTC
 * @see #RTC_WAKEUP
 * @see #INTERVAL_FIFTEEN_MINUTES
 * @see #INTERVAL_HALF_HOUR
 * @see #INTERVAL_HOUR
 * @see #INTERVAL_HALF_DAY
 * @see #INTERVAL_DAY
 */

Body of Frist Method:
{
    setImpl(type, triggerAtMillis, WINDOW_HEURISTIC, intervalMillis, operation, null, null);
}
Body of Second Method:
{
    setImpl(type, triggerAtMillis, WINDOW_HEURISTIC, intervalMillis, 0, operation, null, null);
}
------------------------
Find a silently evolved API code:android.text.Layout.drawText:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    int previousLineBottom = getLineTop(firstLine);
    int previousLineEnd = getLineStart(firstLine);
    ParagraphStyle[] spans = NO_PARA_SPANS;
    int spanEnd = 0;
    TextPaint paint = mPaint;
    CharSequence buf = mText;
    Alignment paraAlign = mAlignment;
    TabStops tabStops = null;
    boolean tabStopsIsInitialized = false;
    TextLine tl = TextLine.obtain();
    // The baseline is the top of the following line minus the current line's descent.
    for (int i = firstLine; i <= lastLine; i++) {
        int start = previousLineEnd;
        previousLineEnd = getLineStart(i + 1);
        int end = getLineVisibleEnd(i, start, previousLineEnd);
        int ltop = previousLineBottom;
        int lbottom = getLineTop(i + 1);
        previousLineBottom = lbottom;
        int lbaseline = lbottom - getLineDescent(i);
        int dir = getParagraphDirection(i);
        int left = 0;
        int right = mWidth;
        if (mSpannedText) {
            Spanned sp = (Spanned) buf;
            int textLength = buf.length();
            boolean isFirstParaLine = (start == 0 || buf.charAt(start - 1) == '\n');
            // our problem.
            if (start >= spanEnd && (i == firstLine || isFirstParaLine)) {
                spanEnd = sp.nextSpanTransition(start, textLength, ParagraphStyle.class);
                spans = getParagraphSpans(sp, start, spanEnd, ParagraphStyle.class);
                paraAlign = mAlignment;
                for (int n = spans.length - 1; n >= 0; n--) {
                    if (spans[n] instanceof AlignmentSpan) {
                        paraAlign = ((AlignmentSpan) spans[n]).getAlignment();
                        break;
                    }
                }
                tabStopsIsInitialized = false;
            }
            // Draw all leading margin spans.  Adjust left or right according
            // to the paragraph direction of the line.
            final int length = spans.length;
            boolean useFirstLineMargin = isFirstParaLine;
            for (int n = 0; n < length; n++) {
                if (spans[n] instanceof LeadingMarginSpan2) {
                    int count = ((LeadingMarginSpan2) spans[n]).getLeadingMarginLineCount();
                    int startLine = getLineForOffset(sp.getSpanStart(spans[n]));
                    // the count that is greatest
                    if (i < startLine + count) {
                        useFirstLineMargin = true;
                        break;
                    }
                }
            }
            for (int n = 0; n < length; n++) {
                if (spans[n] instanceof LeadingMarginSpan) {
                    LeadingMarginSpan margin = (LeadingMarginSpan) spans[n];
                    if (dir == DIR_RIGHT_TO_LEFT) {
                        margin.drawLeadingMargin(canvas, paint, right, dir, ltop, lbaseline, lbottom, buf, start, end, isFirstParaLine, this);
                        right -= margin.getLeadingMargin(useFirstLineMargin);
                    } else {
                        margin.drawLeadingMargin(canvas, paint, left, dir, ltop, lbaseline, lbottom, buf, start, end, isFirstParaLine, this);
                        left += margin.getLeadingMargin(useFirstLineMargin);
                    }
                }
            }
        }
        boolean hasTabOrEmoji = getLineContainsTab(i);
        // Can't tell if we have tabs for sure, currently
        if (hasTabOrEmoji && !tabStopsIsInitialized) {
            if (tabStops == null) {
                tabStops = new TabStops(TAB_INCREMENT, spans);
            } else {
                tabStops.reset(TAB_INCREMENT, spans);
            }
            tabStopsIsInitialized = true;
        }
        // Determine whether the line aligns to normal, opposite, or center.
        Alignment align = paraAlign;
        if (align == Alignment.ALIGN_LEFT) {
            align = (dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_NORMAL : Alignment.ALIGN_OPPOSITE;
        } else if (align == Alignment.ALIGN_RIGHT) {
            align = (dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_OPPOSITE : Alignment.ALIGN_NORMAL;
        }
        int x;
        if (align == Alignment.ALIGN_NORMAL) {
            if (dir == DIR_LEFT_TO_RIGHT) {
                x = left;
            } else {
                x = right;
            }
        } else {
            int max = (int) getLineExtent(i, tabStops, false);
            if (align == Alignment.ALIGN_OPPOSITE) {
                if (dir == DIR_LEFT_TO_RIGHT) {
                    x = right - max;
                } else {
                    x = left - max;
                }
            } else {
                // Alignment.ALIGN_CENTER
                max = max & ~1;
                x = (right + left - max) >> 1;
            }
        }
        Directions directions = getLineDirections(i);
        if (directions == DIRS_ALL_LEFT_TO_RIGHT && !mSpannedText && !hasTabOrEmoji) {
            // XXX: assumes there's nothing additional to be done
            canvas.drawText(buf, start, end, x, lbaseline, paint);
        } else {
            tl.set(paint, buf, start, end, dir, directions, hasTabOrEmoji, tabStops);
            tl.draw(canvas, x, ltop, lbaseline, lbottom);
        }
    }
    TextLine.recycle(tl);
}
Body of Second Method:
{
    int previousLineBottom = getLineTop(firstLine);
    int previousLineEnd = getLineStart(firstLine);
    ParagraphStyle[] spans = NO_PARA_SPANS;
    int spanEnd = 0;
    TextPaint paint = mPaint;
    CharSequence buf = mText;
    Alignment paraAlign = mAlignment;
    TabStops tabStops = null;
    boolean tabStopsIsInitialized = false;
    TextLine tl = TextLine.obtain();
    // The baseline is the top of the following line minus the current line's descent.
    for (int lineNum = firstLine; lineNum <= lastLine; lineNum++) {
        int start = previousLineEnd;
        previousLineEnd = getLineStart(lineNum + 1);
        int end = getLineVisibleEnd(lineNum, start, previousLineEnd);
        int ltop = previousLineBottom;
        int lbottom = getLineTop(lineNum + 1);
        previousLineBottom = lbottom;
        int lbaseline = lbottom - getLineDescent(lineNum);
        int dir = getParagraphDirection(lineNum);
        int left = 0;
        int right = mWidth;
        if (mSpannedText) {
            Spanned sp = (Spanned) buf;
            int textLength = buf.length();
            boolean isFirstParaLine = (start == 0 || buf.charAt(start - 1) == '\n');
            // our problem.
            if (start >= spanEnd && (lineNum == firstLine || isFirstParaLine)) {
                spanEnd = sp.nextSpanTransition(start, textLength, ParagraphStyle.class);
                spans = getParagraphSpans(sp, start, spanEnd, ParagraphStyle.class);
                paraAlign = mAlignment;
                for (int n = spans.length - 1; n >= 0; n--) {
                    if (spans[n] instanceof AlignmentSpan) {
                        paraAlign = ((AlignmentSpan) spans[n]).getAlignment();
                        break;
                    }
                }
                tabStopsIsInitialized = false;
            }
            // Draw all leading margin spans.  Adjust left or right according
            // to the paragraph direction of the line.
            final int length = spans.length;
            boolean useFirstLineMargin = isFirstParaLine;
            for (int n = 0; n < length; n++) {
                if (spans[n] instanceof LeadingMarginSpan2) {
                    int count = ((LeadingMarginSpan2) spans[n]).getLeadingMarginLineCount();
                    int startLine = getLineForOffset(sp.getSpanStart(spans[n]));
                    // the count that is greatest
                    if (lineNum < startLine + count) {
                        useFirstLineMargin = true;
                        break;
                    }
                }
            }
            for (int n = 0; n < length; n++) {
                if (spans[n] instanceof LeadingMarginSpan) {
                    LeadingMarginSpan margin = (LeadingMarginSpan) spans[n];
                    if (dir == DIR_RIGHT_TO_LEFT) {
                        margin.drawLeadingMargin(canvas, paint, right, dir, ltop, lbaseline, lbottom, buf, start, end, isFirstParaLine, this);
                        right -= margin.getLeadingMargin(useFirstLineMargin);
                    } else {
                        margin.drawLeadingMargin(canvas, paint, left, dir, ltop, lbaseline, lbottom, buf, start, end, isFirstParaLine, this);
                        left += margin.getLeadingMargin(useFirstLineMargin);
                    }
                }
            }
        }
        boolean hasTabOrEmoji = getLineContainsTab(lineNum);
        // Can't tell if we have tabs for sure, currently
        if (hasTabOrEmoji && !tabStopsIsInitialized) {
            if (tabStops == null) {
                tabStops = new TabStops(TAB_INCREMENT, spans);
            } else {
                tabStops.reset(TAB_INCREMENT, spans);
            }
            tabStopsIsInitialized = true;
        }
        // Determine whether the line aligns to normal, opposite, or center.
        Alignment align = paraAlign;
        if (align == Alignment.ALIGN_LEFT) {
            align = (dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_NORMAL : Alignment.ALIGN_OPPOSITE;
        } else if (align == Alignment.ALIGN_RIGHT) {
            align = (dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_OPPOSITE : Alignment.ALIGN_NORMAL;
        }
        int x;
        if (align == Alignment.ALIGN_NORMAL) {
            if (dir == DIR_LEFT_TO_RIGHT) {
                x = left + getIndentAdjust(lineNum, Alignment.ALIGN_LEFT);
            } else {
                x = right + getIndentAdjust(lineNum, Alignment.ALIGN_RIGHT);
            }
        } else {
            int max = (int) getLineExtent(lineNum, tabStops, false);
            if (align == Alignment.ALIGN_OPPOSITE) {
                if (dir == DIR_LEFT_TO_RIGHT) {
                    x = right - max + getIndentAdjust(lineNum, Alignment.ALIGN_RIGHT);
                } else {
                    x = left - max + getIndentAdjust(lineNum, Alignment.ALIGN_LEFT);
                }
            } else {
                // Alignment.ALIGN_CENTER
                max = max & ~1;
                x = ((right + left - max) >> 1) + getIndentAdjust(lineNum, Alignment.ALIGN_CENTER);
            }
        }
        paint.setHyphenEdit(getHyphen(lineNum));
        Directions directions = getLineDirections(lineNum);
        if (directions == DIRS_ALL_LEFT_TO_RIGHT && !mSpannedText && !hasTabOrEmoji) {
            // XXX: assumes there's nothing additional to be done
            canvas.drawText(buf, start, end, x, lbaseline, paint);
        } else {
            tl.set(paint, buf, start, end, dir, directions, hasTabOrEmoji, tabStops);
            tl.draw(canvas, x, ltop, lbaseline, lbottom);
        }
        paint.setHyphenEdit(0);
    }
    TextLine.recycle(tl);
}
------------------------
Find a silently evolved API code:android.renderscript.Element.createVector:COMMENT
Method Modifier: public      static      
Comment:/**
 * Create a custom vector element of the specified DataType and vector size.
 * DataKind will be set to USER. Only primitive types (FLOAT_32, FLOAT_64,
 * SIGNED_8, SIGNED_16, SIGNED_32, SIGNED_64, UNSIGNED_8, UNSIGNED_16,
 * UNSIGNED_32, UNSIGNED_64, BOOLEAN) are supported.
 *
 * @param rs The context associated with the new Element.
 * @param dt The DataType for the new Element.
 * @param size Vector size for the new Element.  Range 2-4 inclusive
 * supported.
 *
 * @return Element
 */

Body of Frist Method:
{
    if (size < 2 || size > 4) {
        throw new RSIllegalArgumentException("Vector size out of range 2-4.");
    }
    switch(dt) {
        // Support only primitive integer/float/boolean types as vectors.
        case FLOAT_32:
        case FLOAT_64:
        case SIGNED_8:
        case SIGNED_16:
        case SIGNED_32:
        case SIGNED_64:
        case UNSIGNED_8:
        case UNSIGNED_16:
        case UNSIGNED_32:
        case UNSIGNED_64:
        case BOOLEAN:
            {
                DataKind dk = DataKind.USER;
                boolean norm = false;
                long id = rs.nElementCreate(dt.mID, dk.mID, norm, size);
                return new Element(id, rs, dt, dk, norm, size);
            }
        default:
            {
                throw new RSIllegalArgumentException("Cannot create vector of " + "non-primitive type.");
            }
    }
}
Body of Second Method:
{
    if (size < 2 || size > 4) {
        throw new RSIllegalArgumentException("Vector size out of range 2-4.");
    }
    switch(dt) {
        // Support only primitive integer/float/boolean types as vectors.
        case FLOAT_16:
        case FLOAT_32:
        case FLOAT_64:
        case SIGNED_8:
        case SIGNED_16:
        case SIGNED_32:
        case SIGNED_64:
        case UNSIGNED_8:
        case UNSIGNED_16:
        case UNSIGNED_32:
        case UNSIGNED_64:
        case BOOLEAN:
            {
                DataKind dk = DataKind.USER;
                boolean norm = false;
                long id = rs.nElementCreate(dt.mID, dk.mID, norm, size);
                return new Element(id, rs, dt, dk, norm, size);
            }
        default:
            {
                throw new RSIllegalArgumentException("Cannot create vector of " + "non-primitive type.");
            }
    }
}
------------------------
Find a silently evolved API code:android.print.PrinterCapabilitiesInfo.getDefaults:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the default print attributes.
 *
 * @return The default attributes.
 */

Body of Frist Method:
{
    PrintAttributes.Builder builder = new PrintAttributes.Builder();
    builder.setMinMargins(mMinMargins);
    final int mediaSizeIndex = mDefaults[PROPERTY_MEDIA_SIZE];
    if (mediaSizeIndex >= 0) {
        builder.setMediaSize(mMediaSizes.get(mediaSizeIndex));
    }
    final int resolutionIndex = mDefaults[PROPERTY_RESOLUTION];
    if (resolutionIndex >= 0) {
        builder.setResolution(mResolutions.get(resolutionIndex));
    }
    final int colorMode = mDefaults[PROPERTY_COLOR_MODE];
    if (colorMode > 0) {
        builder.setColorMode(colorMode);
    }
    return builder.build();
}
Body of Second Method:
{
    PrintAttributes.Builder builder = new PrintAttributes.Builder();
    builder.setMinMargins(mMinMargins);
    final int mediaSizeIndex = mDefaults[PROPERTY_MEDIA_SIZE];
    if (mediaSizeIndex >= 0) {
        builder.setMediaSize(mMediaSizes.get(mediaSizeIndex));
    }
    final int resolutionIndex = mDefaults[PROPERTY_RESOLUTION];
    if (resolutionIndex >= 0) {
        builder.setResolution(mResolutions.get(resolutionIndex));
    }
    final int colorMode = mDefaults[PROPERTY_COLOR_MODE];
    if (colorMode > 0) {
        builder.setColorMode(colorMode);
    }
    final int duplexMode = mDefaults[PROPERTY_DUPLEX_MODE];
    if (duplexMode > 0) {
        builder.setDuplexMode(duplexMode);
    }
    return builder.build();
}
------------------------
Find a silently evolved API code:android.view.accessibility.AccessibilityRecord.setSealed:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets if this instance is sealed.
 *
 * @param sealed Whether is sealed.
 *
 * @hide
 */

Body of Frist Method:
{
    mSealed = sealed;
}
Body of Second Method:
{
    mSealed = sealed;
    if (mSourceNode != null) {
        mSourceNode.setSealed(sealed);
    }
}
------------------------
Find a silently evolved API code:android.print.PrintAttributes.clear:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    mMediaSize = null;
    mResolution = null;
    mMinMargins = null;
    mColorMode = 0;
}
Body of Second Method:
{
    mMediaSize = null;
    mResolution = null;
    mMinMargins = null;
    mColorMode = 0;
    mDuplexMode = DUPLEX_MODE_NONE;
}
------------------------
Find a silently evolved API code:android.telephony.SubscriptionManager.getActiveSubscriptionInfoForSimSlotIndex:COMMENT
Method Modifier: public      
Comment:/**
 * Get the active SubscriptionInfo associated with the slotIdx
 * @param slotIdx the slot which the subscription is inserted
 * @return SubscriptionInfo, maybe null if its not active
 */

Body of Frist Method:
{
    if (VDBG)
        logd("[getActiveSubscriptionInfoForSimSlotIndex]+ slotIdx=" + slotIdx);
    if (!isValidSlotId(slotIdx)) {
        logd("[getActiveSubscriptionInfoForSimSlotIndex]- invalid slotIdx");
        return null;
    }
    SubscriptionInfo result = null;
    try {
        ISub iSub = ISub.Stub.asInterface(ServiceManager.getService("isub"));
        if (iSub != null) {
            result = iSub.getActiveSubscriptionInfoForSimSlotIndex(slotIdx);
        }
    } catch (RemoteException ex) {
    // ignore it
    }
    return result;
}
Body of Second Method:
{
    if (VDBG)
        logd("[getActiveSubscriptionInfoForSimSlotIndex]+ slotIdx=" + slotIdx);
    if (!isValidSlotId(slotIdx)) {
        logd("[getActiveSubscriptionInfoForSimSlotIndex]- invalid slotIdx");
        return null;
    }
    SubscriptionInfo result = null;
    try {
        ISub iSub = ISub.Stub.asInterface(ServiceManager.getService("isub"));
        if (iSub != null) {
            result = iSub.getActiveSubscriptionInfoForSimSlotIndex(slotIdx, mContext.getOpPackageName());
        }
    } catch (RemoteException ex) {
    // ignore it
    }
    return result;
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiInfo.updatePacketRates:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * TODO: get actual timestamp and calculate true rates
 * @hide
 */

Body of Frist Method:
{
    if (stats != null) {
        long txgood = stats.txmpdu_be + stats.txmpdu_bk + stats.txmpdu_vi + stats.txmpdu_vo;
        long txretries = stats.retries_be + stats.retries_bk + stats.retries_vi + stats.retries_vo;
        long rxgood = stats.rxmpdu_be + stats.rxmpdu_bk + stats.rxmpdu_vi + stats.rxmpdu_vo;
        long txbad = stats.lostmpdu_be + stats.lostmpdu_bk + stats.lostmpdu_vi + stats.lostmpdu_vo;
        txBadRate = (txBadRate * 0.5) + ((double) (txbad - txBad) * 0.5);
        txSuccessRate = (txSuccessRate * 0.5) + ((double) (txgood - txSuccess) * 0.5);
        rxSuccessRate = (rxSuccessRate * 0.5) + ((double) (rxgood - rxSuccess) * 0.5);
        txRetriesRate = (txRetriesRate * 0.5) + ((double) (txretries - txRetries) * 0.5);
        txBad = txbad;
        txSuccess = txgood;
        rxSuccess = rxgood;
        txRetries = txretries;
    } else {
        txBad = 0;
        txSuccess = 0;
        rxSuccess = 0;
        txRetries = 0;
        txBadRate = 0;
        txSuccessRate = 0;
        rxSuccessRate = 0;
        txRetriesRate = 0;
    }
}
Body of Second Method:
{
    if (stats != null) {
        long txgood = stats.txmpdu_be + stats.txmpdu_bk + stats.txmpdu_vi + stats.txmpdu_vo;
        long txretries = stats.retries_be + stats.retries_bk + stats.retries_vi + stats.retries_vo;
        long rxgood = stats.rxmpdu_be + stats.rxmpdu_bk + stats.rxmpdu_vi + stats.rxmpdu_vo;
        long txbad = stats.lostmpdu_be + stats.lostmpdu_bk + stats.lostmpdu_vi + stats.lostmpdu_vo;
        if (txBad <= txbad && txSuccess <= txgood && rxSuccess <= rxgood && txRetries <= txretries) {
            txBadRate = (txBadRate * 0.5) + ((double) (txbad - txBad) * 0.5);
            txSuccessRate = (txSuccessRate * 0.5) + ((double) (txgood - txSuccess) * 0.5);
            rxSuccessRate = (rxSuccessRate * 0.5) + ((double) (rxgood - rxSuccess) * 0.5);
            txRetriesRate = (txRetriesRate * 0.5) + ((double) (txretries - txRetries) * 0.5);
        } else {
            txBadRate = 0;
            txSuccessRate = 0;
            rxSuccessRate = 0;
            txRetriesRate = 0;
        }
        txBad = txbad;
        txSuccess = txgood;
        rxSuccess = rxgood;
        txRetries = txretries;
    } else {
        txBad = 0;
        txSuccess = 0;
        rxSuccess = 0;
        txRetries = 0;
        txBadRate = 0;
        txSuccessRate = 0;
        rxSuccessRate = 0;
        txRetriesRate = 0;
    }
}
------------------------
Find a silently evolved API code:android.graphics.Bitmap.copy:COMMENT
Method Modifier: public      
Comment:/**
 * Tries to make a new bitmap based on the dimensions of this bitmap,
 * setting the new bitmap's config to the one specified, and then copying
 * this bitmap's pixels into the new bitmap. If the conversion is not
 * supported, or the allocator fails, then this returns NULL.  The returned
 * bitmap initially has the same density as the original.
 *
 * @param config    The desired config for the resulting bitmap
 * @param isMutable True if the resulting bitmap should be mutable (i.e.
 * its pixels can be modified)
 * @return the new bitmap, or null if the copy could not be made.
 */

Body of Frist Method:
{
    checkRecycled("Can't copy a recycled bitmap");
    Bitmap b = nativeCopy(mNativeBitmap, config.nativeInt, isMutable);
    if (b != null) {
        b.setPremultiplied(mRequestPremultiplied);
        b.mDensity = mDensity;
    }
    return b;
}
Body of Second Method:
{
    checkRecycled("Can't copy a recycled bitmap");
    Bitmap b = nativeCopy(mFinalizer.mNativeBitmap, config.nativeInt, isMutable);
    if (b != null) {
        b.setPremultiplied(mRequestPremultiplied);
        b.mDensity = mDensity;
    }
    return b;
}
------------------------
Find a silently evolved API code:javax.obex.ClientOperation.streamClosed:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Called when the output or input stream is closed.
 * @param inStream <code>true</code> if the input stream is closed;
 * <code>false</code> if the output stream is closed
 * @throws IOException if an IO error occurs
 */

Body of Frist Method:
{
    if (!mGetOperation) {
        if ((!inStream) && (!mOperationDone)) {
            // to deal with outputstream in put operation
            boolean more = true;
            if ((mPrivateOutput != null) && (mPrivateOutput.size() <= 0)) {
                byte[] headerArray = ObexHelper.createHeader(mRequestHeader, false);
                if (headerArray.length <= 0)
                    more = false;
            }
            // If have not sent any data so send  all now
            if (mReplyHeader.responseCode == -1) {
                mReplyHeader.responseCode = ResponseCodes.OBEX_HTTP_CONTINUE;
            }
            while ((more) && (mReplyHeader.responseCode == ResponseCodes.OBEX_HTTP_CONTINUE)) {
                more = sendRequest(0x02);
            }
            /*
                 * According to the IrOBEX specification, after the final put, you
                 * only have a single reply to send.  so we don't need the while
                 * loop.
                 */
            while (mReplyHeader.responseCode == ResponseCodes.OBEX_HTTP_CONTINUE) {
                sendRequest(0x82);
            }
            mOperationDone = true;
        } else if ((inStream) && (mOperationDone)) {
            // how to deal with input stream in put stream ?
            mOperationDone = true;
        }
    } else {
        if ((inStream) && (!mOperationDone)) {
            if (mReplyHeader.responseCode == -1) {
                mReplyHeader.responseCode = ResponseCodes.OBEX_HTTP_CONTINUE;
            }
            while (mReplyHeader.responseCode == ResponseCodes.OBEX_HTTP_CONTINUE) {
                if (!sendRequest(0x83)) {
                    break;
                }
            }
            while (mReplyHeader.responseCode == ResponseCodes.OBEX_HTTP_CONTINUE) {
                mParent.sendRequest(0x83, null, mReplyHeader, mPrivateInput);
            }
            mOperationDone = true;
        } else if ((!inStream) && (!mOperationDone)) {
            // to deal with outputstream in get operation
            // part of the data may have been sent in continueOperation.
            boolean more = true;
            if ((mPrivateOutput != null) && (mPrivateOutput.size() <= 0)) {
                byte[] headerArray = ObexHelper.createHeader(mRequestHeader, false);
                if (headerArray.length <= 0)
                    more = false;
            }
            if (mPrivateInput == null) {
                mPrivateInput = new PrivateInputStream(this);
            }
            if ((mPrivateOutput != null) && (mPrivateOutput.size() <= 0))
                more = false;
            mReplyHeader.responseCode = ResponseCodes.OBEX_HTTP_CONTINUE;
            while ((more) && (mReplyHeader.responseCode == ResponseCodes.OBEX_HTTP_CONTINUE)) {
                more = sendRequest(0x03);
            }
            sendRequest(0x83);
            // parent.sendRequest(0x83, null, replyHeaders, privateInput);
            if (mReplyHeader.responseCode != ResponseCodes.OBEX_HTTP_CONTINUE) {
                mOperationDone = true;
            }
        }
    }
}
Body of Second Method:
{
    if (!mGetOperation) {
        if ((!inStream) && (!mOperationDone)) {
            // to deal with outputstream in put operation
            boolean more = true;
            if ((mPrivateOutput != null) && (mPrivateOutput.size() <= 0)) {
                byte[] headerArray = ObexHelper.createHeader(mRequestHeader, false);
                if (headerArray.length <= 0)
                    more = false;
            }
            // If have not sent any data so send  all now
            if (mReplyHeader.responseCode == -1) {
                mReplyHeader.responseCode = ResponseCodes.OBEX_HTTP_CONTINUE;
            }
            while ((more) && (mReplyHeader.responseCode == ResponseCodes.OBEX_HTTP_CONTINUE)) {
                more = sendRequest(ObexHelper.OBEX_OPCODE_PUT);
            }
            /*
                 * According to the IrOBEX specification, after the final put, you
                 * only have a single reply to send.  so we don't need the while
                 * loop.
                 */
            while (mReplyHeader.responseCode == ResponseCodes.OBEX_HTTP_CONTINUE) {
                sendRequest(ObexHelper.OBEX_OPCODE_PUT_FINAL);
            }
            mOperationDone = true;
        } else if ((inStream) && (mOperationDone)) {
            // how to deal with input stream in put stream ?
            mOperationDone = true;
        }
    } else {
        if ((inStream) && (!mOperationDone)) {
            if (mReplyHeader.responseCode == -1) {
                mReplyHeader.responseCode = ResponseCodes.OBEX_HTTP_CONTINUE;
            }
            while (mReplyHeader.responseCode == ResponseCodes.OBEX_HTTP_CONTINUE && !mOperationDone) {
                if (!sendRequest(ObexHelper.OBEX_OPCODE_GET_FINAL)) {
                    break;
                }
            }
            while (mReplyHeader.responseCode == ResponseCodes.OBEX_HTTP_CONTINUE && !mOperationDone) {
                mParent.sendRequest(ObexHelper.OBEX_OPCODE_GET_FINAL, null, mReplyHeader, mPrivateInput, false);
            // Regardless of the SRM state, wait for the response.
            }
            mOperationDone = true;
        } else if ((!inStream) && (!mOperationDone)) {
            // to deal with outputstream in get operation
            // part of the data may have been sent in continueOperation.
            boolean more = true;
            if ((mPrivateOutput != null) && (mPrivateOutput.size() <= 0)) {
                byte[] headerArray = ObexHelper.createHeader(mRequestHeader, false);
                if (headerArray.length <= 0)
                    more = false;
            }
            if (mPrivateInput == null) {
                mPrivateInput = new PrivateInputStream(this);
            }
            if ((mPrivateOutput != null) && (mPrivateOutput.size() <= 0))
                more = false;
            mReplyHeader.responseCode = ResponseCodes.OBEX_HTTP_CONTINUE;
            while ((more) && (mReplyHeader.responseCode == ResponseCodes.OBEX_HTTP_CONTINUE)) {
                more = sendRequest(ObexHelper.OBEX_OPCODE_GET);
            }
            sendRequest(ObexHelper.OBEX_OPCODE_GET_FINAL);
            // parent.sendRequest(0x83, null, replyHeaders, privateInput);
            if (mReplyHeader.responseCode != ResponseCodes.OBEX_HTTP_CONTINUE) {
                mOperationDone = true;
            }
        }
    }
}
------------------------
Find a silently evolved API code:android.telephony.SubscriptionManager.getAllSubscriptionInfoList:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @return List of all SubscriptionInfo records in database,
 * include those that were inserted before, maybe empty but not null.
 * @hide
 */

Body of Frist Method:
{
    if (VDBG)
        logd("[getAllSubscriptionInfoList]+");
    List<SubscriptionInfo> result = null;
    try {
        ISub iSub = ISub.Stub.asInterface(ServiceManager.getService("isub"));
        if (iSub != null) {
            result = iSub.getAllSubInfoList();
        }
    } catch (RemoteException ex) {
    // ignore it
    }
    if (result == null) {
        result = new ArrayList<SubscriptionInfo>();
    }
    return result;
}
Body of Second Method:
{
    if (VDBG)
        logd("[getAllSubscriptionInfoList]+");
    List<SubscriptionInfo> result = null;
    try {
        ISub iSub = ISub.Stub.asInterface(ServiceManager.getService("isub"));
        if (iSub != null) {
            result = iSub.getAllSubInfoList(mContext.getOpPackageName());
        }
    } catch (RemoteException ex) {
    // ignore it
    }
    if (result == null) {
        result = new ArrayList<SubscriptionInfo>();
    }
    return result;
}
------------------------
Find a silently evolved API code:android.widget.TextView.getCompoundPaddingRight:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the right padding of the view, plus space for the right
 * Drawable if any.
 */

Body of Frist Method:
{
    final Drawables dr = mDrawables;
    if (dr == null || dr.mDrawableRight == null) {
        return mPaddingRight;
    } else {
        return mPaddingRight + dr.mDrawablePadding + dr.mDrawableSizeRight;
    }
}
Body of Second Method:
{
    final Drawables dr = mDrawables;
    if (dr == null || dr.mShowing[Drawables.RIGHT] == null) {
        return mPaddingRight;
    } else {
        return mPaddingRight + dr.mDrawablePadding + dr.mDrawableSizeRight;
    }
}
------------------------
Find a silently evolved API code:android.graphics.Canvas.drawVertices:COMMENT
Method Modifier: public      
Comment:/**
 * Draw the array of vertices, interpreted as triangles (based on mode). The
 * verts array is required, and specifies the x,y pairs for each vertex. If
 * texs is non-null, then it is used to specify the coordinate in shader
 * coordinates to use at each vertex (the paint must have a shader in this
 * case). If there is no texs array, but there is a color array, then each
 * color is interpolated across its corresponding triangle in a gradient. If
 * both texs and colors arrays are present, then they behave as before, but
 * the resulting color at each pixels is the result of multiplying the
 * colors from the shader and the color-gradient together. The indices array
 * is optional, but if it is present, then it is used to specify the index
 * of each triangle, rather than just walking through the arrays in order.
 *
 * @param mode How to interpret the array of vertices
 * @param vertexCount The number of values in the vertices array (and
 * corresponding texs and colors arrays if non-null). Each logical
 * vertex is two values (x, y), vertexCount must be a multiple of 2.
 * @param verts Array of vertices for the mesh
 * @param vertOffset Number of values in the verts to skip before drawing.
 * @param texs May be null. If not null, specifies the coordinates to sample
 * into the current shader (e.g. bitmap tile or gradient)
 * @param texOffset Number of values in texs to skip before drawing.
 * @param colors May be null. If not null, specifies a color for each
 * vertex, to be interpolated across the triangle.
 * @param colorOffset Number of values in colors to skip before drawing.
 * @param indices If not null, array of indices to reference into the
 * vertex (texs, colors) array.
 * @param indexCount number of entries in the indices array (if not null).
 * @param paint Specifies the shader to use if the texs array is non-null.
 */

Body of Frist Method:
{
    checkRange(verts.length, vertOffset, vertexCount);
    if (texs != null) {
        checkRange(texs.length, texOffset, vertexCount);
    }
    if (colors != null) {
        checkRange(colors.length, colorOffset, vertexCount / 2);
    }
    if (indices != null) {
        checkRange(indices.length, indexOffset, indexCount);
    }
    nativeDrawVertices(mNativeCanvasWrapper, mode.nativeInt, vertexCount, verts, vertOffset, texs, texOffset, colors, colorOffset, indices, indexOffset, indexCount, paint.mNativePaint);
}
Body of Second Method:
{
    checkRange(verts.length, vertOffset, vertexCount);
    if (isHardwareAccelerated()) {
        return;
    }
    if (texs != null) {
        checkRange(texs.length, texOffset, vertexCount);
    }
    if (colors != null) {
        checkRange(colors.length, colorOffset, vertexCount / 2);
    }
    if (indices != null) {
        checkRange(indices.length, indexOffset, indexCount);
    }
    nativeDrawVertices(mNativeCanvasWrapper, mode.nativeInt, vertexCount, verts, vertOffset, texs, texOffset, colors, colorOffset, indices, indexOffset, indexCount, paint.getNativeInstance());
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiActivityEnergyInfo.isValid:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @return if the record is valid
 */

Body of Frist Method:
{
    return ((getControllerTxTimeMillis() != 0) || (getControllerRxTimeMillis() != 0) || (getControllerIdleTimeMillis() != 0));
}
Body of Second Method:
{
    return ((mControllerTxTimeMs != 0) || (mControllerRxTimeMs != 0) || (mControllerIdleTimeMs != 0));
}
------------------------
Find a silently evolved API code:android.graphics.drawable.RippleDrawable.clearHotspots:COMMENT
Method Modifier: private     
Comment:/**
 * Cancels and removes the active ripple, all exiting ripples, and the
 * background. Nothing will be drawn after this method is called.
 */

Body of Frist Method:
{
    if (mRipple != null) {
        mRipple.cancel();
        mRipple = null;
        mRippleActive = false;
    }
    if (mBackground != null) {
        mBackground.cancel();
        mBackground = null;
        mBackgroundActive = false;
    }
    cancelExitingRipples();
    invalidateSelf();
}
Body of Second Method:
{
    if (mRipple != null) {
        mRipple.end();
        mRipple = null;
        mRippleActive = false;
    }
    if (mBackground != null) {
        mBackground.end();
        mBackground = null;
        mBackgroundActive = false;
    }
    cancelExitingRipples();
}
------------------------
Find a silently evolved API code:android.text.BoringLayout.init:COMMENT
Method Modifier: default     
Comment:/* package */

Body of Frist Method:
{
    int spacing;
    if (source instanceof String && align == Layout.Alignment.ALIGN_NORMAL) {
        mDirect = source.toString();
    } else {
        mDirect = null;
    }
    mPaint = paint;
    if (includepad) {
        spacing = metrics.bottom - metrics.top;
    } else {
        spacing = metrics.descent - metrics.ascent;
    }
    mBottom = spacing;
    if (includepad) {
        mDesc = spacing + metrics.top;
    } else {
        mDesc = spacing + metrics.ascent;
    }
    if (trustWidth) {
        mMax = metrics.width;
    } else {
        /*
             * If we have ellipsized, we have to actually calculate the
             * width because the width that was passed in was for the
             * full text, not the ellipsized form.
             */
        TextLine line = TextLine.obtain();
        line.set(paint, source, 0, source.length(), Layout.DIR_LEFT_TO_RIGHT, Layout.DIRS_ALL_LEFT_TO_RIGHT, false, null);
        mMax = (int) FloatMath.ceil(line.metrics(null));
        TextLine.recycle(line);
    }
    if (includepad) {
        mTopPadding = metrics.top - metrics.ascent;
        mBottomPadding = metrics.bottom - metrics.descent;
    }
}
Body of Second Method:
{
    int spacing;
    if (source instanceof String && align == Layout.Alignment.ALIGN_NORMAL) {
        mDirect = source.toString();
    } else {
        mDirect = null;
    }
    mPaint = paint;
    if (includepad) {
        spacing = metrics.bottom - metrics.top;
    } else {
        spacing = metrics.descent - metrics.ascent;
    }
    mBottom = spacing;
    if (includepad) {
        mDesc = spacing + metrics.top;
    } else {
        mDesc = spacing + metrics.ascent;
    }
    if (trustWidth) {
        mMax = metrics.width;
    } else {
        /*
             * If we have ellipsized, we have to actually calculate the
             * width because the width that was passed in was for the
             * full text, not the ellipsized form.
             */
        TextLine line = TextLine.obtain();
        line.set(paint, source, 0, source.length(), Layout.DIR_LEFT_TO_RIGHT, Layout.DIRS_ALL_LEFT_TO_RIGHT, false, null);
        mMax = (int) Math.ceil(line.metrics(null));
        TextLine.recycle(line);
    }
    if (includepad) {
        mTopPadding = metrics.top - metrics.ascent;
        mBottomPadding = metrics.bottom - metrics.descent;
    }
}
------------------------
Find a silently evolved API code:android.app.Fragment.getResources:COMMENT
Method Modifier: public      final       
Comment:/**
 * Return <code>getActivity().getResources()</code>.
 */

Body of Frist Method:
{
    if (mActivity == null) {
        throw new IllegalStateException("Fragment " + this + " not attached to Activity");
    }
    return mActivity.getResources();
}
Body of Second Method:
{
    if (mHost == null) {
        throw new IllegalStateException("Fragment " + this + " not attached to Activity");
    }
    return mHost.getContext().getResources();
}
------------------------
Find a silently evolved API code:android.widget.TableRow.getColumnsWidths:COMMENT
Method Modifier: default     hidden      
Comment:/**
 * <p>Measures the preferred width of each child, including its margins.</p>
 *
 * @param widthMeasureSpec the width constraint imposed by our parent
 *
 * @return an array of integers corresponding to the width of each cell, or
 * column, in this row
 * {@hide}
 */

Body of Frist Method:
{
    final int numColumns = getVirtualChildCount();
    if (mColumnWidths == null || numColumns != mColumnWidths.length) {
        mColumnWidths = new int[numColumns];
    }
    final int[] columnWidths = mColumnWidths;
    for (int i = 0; i < numColumns; i++) {
        final View child = getVirtualChildAt(i);
        if (child != null && child.getVisibility() != GONE) {
            final LayoutParams layoutParams = (LayoutParams) child.getLayoutParams();
            if (layoutParams.span == 1) {
                int spec;
                switch(layoutParams.width) {
                    case LayoutParams.WRAP_CONTENT:
                        spec = getChildMeasureSpec(widthMeasureSpec, 0, LayoutParams.WRAP_CONTENT);
                        break;
                    case LayoutParams.MATCH_PARENT:
                        spec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);
                        break;
                    default:
                        spec = MeasureSpec.makeMeasureSpec(layoutParams.width, MeasureSpec.EXACTLY);
                }
                child.measure(spec, spec);
                final int width = child.getMeasuredWidth() + layoutParams.leftMargin + layoutParams.rightMargin;
                columnWidths[i] = width;
            } else {
                columnWidths[i] = 0;
            }
        } else {
            columnWidths[i] = 0;
        }
    }
    return columnWidths;
}
Body of Second Method:
{
    final int numColumns = getVirtualChildCount();
    if (mColumnWidths == null || numColumns != mColumnWidths.length) {
        mColumnWidths = new int[numColumns];
    }
    final int[] columnWidths = mColumnWidths;
    for (int i = 0; i < numColumns; i++) {
        final View child = getVirtualChildAt(i);
        if (child != null && child.getVisibility() != GONE) {
            final LayoutParams layoutParams = (LayoutParams) child.getLayoutParams();
            if (layoutParams.span == 1) {
                int spec;
                switch(layoutParams.width) {
                    case LayoutParams.WRAP_CONTENT:
                        spec = getChildMeasureSpec(widthMeasureSpec, 0, LayoutParams.WRAP_CONTENT);
                        break;
                    case LayoutParams.MATCH_PARENT:
                        spec = MeasureSpec.makeSafeMeasureSpec(MeasureSpec.getSize(heightMeasureSpec), MeasureSpec.UNSPECIFIED);
                        break;
                    default:
                        spec = MeasureSpec.makeMeasureSpec(layoutParams.width, MeasureSpec.EXACTLY);
                }
                child.measure(spec, spec);
                final int width = child.getMeasuredWidth() + layoutParams.leftMargin + layoutParams.rightMargin;
                columnWidths[i] = width;
            } else {
                columnWidths[i] = 0;
            }
        } else {
            columnWidths[i] = 0;
        }
    }
    return columnWidths;
}
------------------------
Find a silently evolved API code:android.webkit.WebView.showFindDialog:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * Starts an ActionMode for finding text in this WebView.  Only works if this
 * WebView is attached to the view system.
 *
 * @param text if non-null, will be the initial text to search for.
 * Otherwise, the last String searched for in this WebView will
 * be used to start.
 * @param showIme if true, show the IME, assuming the user will begin typing.
 * If false and text is non-null, perform a find all.
 * @return true if the find dialog is shown, false otherwise
 * @deprecated This method does not work reliably on all Android versions;
 * implementing a custom find dialog using WebView.findAllAsync()
 * provides a more robust solution.
 */

Body of Frist Method:
{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, "showFindDialog");
    return mProvider.showFindDialog(text, showIme);
}
Body of Second Method:
{
    checkThread();
    return mProvider.showFindDialog(text, showIme);
}
------------------------
Find a silently evolved API code:android.content.ContentProviderClient.insert:COMMENT
Method Modifier: public      
Comment:/**
 * See {@link ContentProvider#insert ContentProvider.insert}
 */

Body of Frist Method:
{
    beforeRemote();
    try {
        return mContentProvider.insert(mPackageName, url, initialValues);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}
Body of Second Method:
{
    Preconditions.checkNotNull(url, "url");
    beforeRemote();
    try {
        return mContentProvider.insert(mPackageName, url, initialValues);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}
------------------------
Find a silently evolved API code:javax.obex.ObexSession.handleAuthChall:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Called when the server received an authentication challenge header. This
 * will cause the authenticator to handle the authentication challenge.
 * @param header the header with the authentication challenge
 * @return <code>true</code> if the last request should be resent;
 * <code>false</code> if the last request should not be resent
 * @throws IOException
 */

Body of Frist Method:
{
    if (mAuthenticator == null) {
        return false;
    }
    /*
         * An authentication challenge is made up of one required and two
         * optional tag length value triplets. The tag 0x00 is required to be in
         * the authentication challenge and it represents the challenge digest
         * that was received. The tag 0x01 is the options tag. This tag tracks
         * if user ID is required and if full access will be granted. The tag
         * 0x02 is the realm, which provides a description of which user name
         * and password to use.
         */
    byte[] challenge = ObexHelper.getTagValue((byte) 0x00, header.mAuthChall);
    byte[] option = ObexHelper.getTagValue((byte) 0x01, header.mAuthChall);
    byte[] description = ObexHelper.getTagValue((byte) 0x02, header.mAuthChall);
    String realm = null;
    if (description != null) {
        byte[] realmString = new byte[description.length - 1];
        System.arraycopy(description, 1, realmString, 0, realmString.length);
        switch(description[0] & 0xFF) {
            case ObexHelper.OBEX_AUTH_REALM_CHARSET_ASCII:
            // Fall through
            case ObexHelper.OBEX_AUTH_REALM_CHARSET_ISO_8859_1:
                // ISO-8859-1 encoding
                try {
                    realm = new String(realmString, "ISO8859_1");
                } catch (Exception e) {
                    throw new IOException("Unsupported Encoding Scheme");
                }
                break;
            case ObexHelper.OBEX_AUTH_REALM_CHARSET_UNICODE:
                // UNICODE Encoding
                realm = ObexHelper.convertToUnicode(realmString, false);
                break;
            default:
                throw new IOException("Unsupported Encoding Scheme");
        }
    }
    boolean isUserIDRequired = false;
    boolean isFullAccess = true;
    if (option != null) {
        if ((option[0] & 0x01) != 0) {
            isUserIDRequired = true;
        }
        if ((option[0] & 0x02) != 0) {
            isFullAccess = false;
        }
    }
    PasswordAuthentication result = null;
    header.mAuthChall = null;
    try {
        result = mAuthenticator.onAuthenticationChallenge(realm, isUserIDRequired, isFullAccess);
    } catch (Exception e) {
        return false;
    }
    /*
         * If no password is provided then we not resent the request
         */
    if (result == null) {
        return false;
    }
    byte[] password = result.getPassword();
    if (password == null) {
        return false;
    }
    byte[] userName = result.getUserName();
    /*
         * Create the authentication response header. It includes 1 required and
         * 2 option tag length value triples. The required triple has a tag of
         * 0x00 and is the response digest. The first optional tag is 0x01 and
         * represents the user ID. If no user ID is provided, then no user ID
         * will be sent. The second optional tag is 0x02 and is the challenge
         * that was received. This will always be sent
         */
    if (userName != null) {
        header.mAuthResp = new byte[38 + userName.length];
        header.mAuthResp[36] = (byte) 0x01;
        header.mAuthResp[37] = (byte) userName.length;
        System.arraycopy(userName, 0, header.mAuthResp, 38, userName.length);
    } else {
        header.mAuthResp = new byte[36];
    }
    // Create the secret String
    byte[] digest = new byte[challenge.length + password.length + 1];
    System.arraycopy(challenge, 0, digest, 0, challenge.length);
    // Insert colon between challenge and password
    digest[challenge.length] = (byte) 0x3A;
    System.arraycopy(password, 0, digest, challenge.length + 1, password.length);
    // Add the Response Digest
    header.mAuthResp[0] = (byte) 0x00;
    header.mAuthResp[1] = (byte) 0x10;
    System.arraycopy(ObexHelper.computeMd5Hash(digest), 0, header.mAuthResp, 2, 16);
    // Add the challenge
    header.mAuthResp[18] = (byte) 0x02;
    header.mAuthResp[19] = (byte) 0x10;
    System.arraycopy(challenge, 0, header.mAuthResp, 20, 16);
    return true;
}
Body of Second Method:
{
    if (mAuthenticator == null) {
        return false;
    }
    /*
         * An authentication challenge is made up of one required and two
         * optional tag length value triplets. The tag 0x00 is required to be in
         * the authentication challenge and it represents the challenge digest
         * that was received. The tag 0x01 is the options tag. This tag tracks
         * if user ID is required and if full access will be granted. The tag
         * 0x02 is the realm, which provides a description of which user name
         * and password to use.
         */
    byte[] challenge = ObexHelper.getTagValue((byte) 0x00, header.mAuthChall);
    byte[] option = ObexHelper.getTagValue((byte) 0x01, header.mAuthChall);
    byte[] description = ObexHelper.getTagValue((byte) 0x02, header.mAuthChall);
    String realm = null;
    if (description != null) {
        byte[] realmString = new byte[description.length - 1];
        System.arraycopy(description, 1, realmString, 0, realmString.length);
        switch(description[0] & 0xFF) {
            case ObexHelper.OBEX_AUTH_REALM_CHARSET_ASCII:
            // Fall through
            case ObexHelper.OBEX_AUTH_REALM_CHARSET_ISO_8859_1:
                // ISO-8859-1 encoding
                try {
                    realm = new String(realmString, "ISO8859_1");
                } catch (Exception e) {
                    throw new IOException("Unsupported Encoding Scheme");
                }
                break;
            case ObexHelper.OBEX_AUTH_REALM_CHARSET_UNICODE:
                // UNICODE Encoding
                realm = ObexHelper.convertToUnicode(realmString, false);
                break;
            default:
                throw new IOException("Unsupported Encoding Scheme");
        }
    }
    boolean isUserIDRequired = false;
    boolean isFullAccess = true;
    if (option != null) {
        if ((option[0] & 0x01) != 0) {
            isUserIDRequired = true;
        }
        if ((option[0] & 0x02) != 0) {
            isFullAccess = false;
        }
    }
    PasswordAuthentication result = null;
    header.mAuthChall = null;
    try {
        result = mAuthenticator.onAuthenticationChallenge(realm, isUserIDRequired, isFullAccess);
    } catch (Exception e) {
        if (V)
            Log.d(TAG, "Exception occured - returning false", e);
        return false;
    }
    /*
         * If no password is provided then we not resent the request
         */
    if (result == null) {
        return false;
    }
    byte[] password = result.getPassword();
    if (password == null) {
        return false;
    }
    byte[] userName = result.getUserName();
    /*
         * Create the authentication response header. It includes 1 required and
         * 2 option tag length value triples. The required triple has a tag of
         * 0x00 and is the response digest. The first optional tag is 0x01 and
         * represents the user ID. If no user ID is provided, then no user ID
         * will be sent. The second optional tag is 0x02 and is the challenge
         * that was received. This will always be sent
         */
    if (userName != null) {
        header.mAuthResp = new byte[38 + userName.length];
        header.mAuthResp[36] = (byte) 0x01;
        header.mAuthResp[37] = (byte) userName.length;
        System.arraycopy(userName, 0, header.mAuthResp, 38, userName.length);
    } else {
        header.mAuthResp = new byte[36];
    }
    // Create the secret String
    byte[] digest = new byte[challenge.length + password.length + 1];
    System.arraycopy(challenge, 0, digest, 0, challenge.length);
    // Insert colon between challenge and password
    digest[challenge.length] = (byte) 0x3A;
    System.arraycopy(password, 0, digest, challenge.length + 1, password.length);
    // Add the Response Digest
    header.mAuthResp[0] = (byte) 0x00;
    header.mAuthResp[1] = (byte) 0x10;
    System.arraycopy(ObexHelper.computeMd5Hash(digest), 0, header.mAuthResp, 2, 16);
    // Add the challenge
    header.mAuthResp[18] = (byte) 0x02;
    header.mAuthResp[19] = (byte) 0x10;
    System.arraycopy(challenge, 0, header.mAuthResp, 20, 16);
    return true;
}
------------------------
Find a silently evolved API code:android.telephony.SubscriptionManager.getActiveSubscriptionInfo:COMMENT
Method Modifier: public      
Comment:/**
 * Get the active SubscriptionInfo with the subId key
 * @param subId The unique SubscriptionInfo key in database
 * @return SubscriptionInfo, maybe null if its not active.
 */

Body of Frist Method:
{
    if (VDBG)
        logd("[getActiveSubscriptionInfo]+ subId=" + subId);
    if (!isValidSubscriptionId(subId)) {
        logd("[getActiveSubscriptionInfo]- invalid subId");
        return null;
    }
    SubscriptionInfo subInfo = null;
    try {
        ISub iSub = ISub.Stub.asInterface(ServiceManager.getService("isub"));
        if (iSub != null) {
            subInfo = iSub.getActiveSubscriptionInfo(subId);
        }
    } catch (RemoteException ex) {
    // ignore it
    }
    return subInfo;
}
Body of Second Method:
{
    if (VDBG)
        logd("[getActiveSubscriptionInfo]+ subId=" + subId);
    if (!isValidSubscriptionId(subId)) {
        if (DBG) {
            logd("[getActiveSubscriptionInfo]- invalid subId");
        }
        return null;
    }
    SubscriptionInfo subInfo = null;
    try {
        ISub iSub = ISub.Stub.asInterface(ServiceManager.getService("isub"));
        if (iSub != null) {
            subInfo = iSub.getActiveSubscriptionInfo(subId, mContext.getOpPackageName());
        }
    } catch (RemoteException ex) {
    // ignore it
    }
    return subInfo;
}
------------------------
Find a silently evolved API code:android.widget.LinearLayout.measureHorizontal:COMMENT
Method Modifier: default     
Comment:/**
 * Measures the children when the orientation of this LinearLayout is set
 * to {@link #HORIZONTAL}.
 *
 * @param widthMeasureSpec Horizontal space requirements as imposed by the parent.
 * @param heightMeasureSpec Vertical space requirements as imposed by the parent.
 *
 * @see #getOrientation()
 * @see #setOrientation(int)
 * @see #onMeasure(int, int)
 */

Body of Frist Method:
{
    mTotalLength = 0;
    int maxHeight = 0;
    int childState = 0;
    int alternativeMaxHeight = 0;
    int weightedMaxHeight = 0;
    boolean allFillParent = true;
    float totalWeight = 0;
    final int count = getVirtualChildCount();
    final int widthMode = MeasureSpec.getMode(widthMeasureSpec);
    final int heightMode = MeasureSpec.getMode(heightMeasureSpec);
    boolean matchHeight = false;
    boolean skippedMeasure = false;
    if (mMaxAscent == null || mMaxDescent == null) {
        mMaxAscent = new int[VERTICAL_GRAVITY_COUNT];
        mMaxDescent = new int[VERTICAL_GRAVITY_COUNT];
    }
    final int[] maxAscent = mMaxAscent;
    final int[] maxDescent = mMaxDescent;
    maxAscent[0] = maxAscent[1] = maxAscent[2] = maxAscent[3] = -1;
    maxDescent[0] = maxDescent[1] = maxDescent[2] = maxDescent[3] = -1;
    final boolean baselineAligned = mBaselineAligned;
    final boolean useLargestChild = mUseLargestChild;
    final boolean isExactly = widthMode == MeasureSpec.EXACTLY;
    int largestChildWidth = Integer.MIN_VALUE;
    // See how wide everyone is. Also remember max height.
    for (int i = 0; i < count; ++i) {
        final View child = getVirtualChildAt(i);
        if (child == null) {
            mTotalLength += measureNullChild(i);
            continue;
        }
        if (child.getVisibility() == GONE) {
            i += getChildrenSkipCount(child, i);
            continue;
        }
        if (hasDividerBeforeChildAt(i)) {
            mTotalLength += mDividerWidth;
        }
        final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
        totalWeight += lp.weight;
        if (widthMode == MeasureSpec.EXACTLY && lp.width == 0 && lp.weight > 0) {
            // there is any leftover space.
            if (isExactly) {
                mTotalLength += lp.leftMargin + lp.rightMargin;
            } else {
                final int totalLength = mTotalLength;
                mTotalLength = Math.max(totalLength, totalLength + lp.leftMargin + lp.rightMargin);
            }
            // later (and re-measure).
            if (baselineAligned) {
                final int freeSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);
                child.measure(freeSpec, freeSpec);
            } else {
                skippedMeasure = true;
            }
        } else {
            int oldWidth = Integer.MIN_VALUE;
            if (lp.width == 0 && lp.weight > 0) {
                // widthMode is either UNSPECIFIED or AT_MOST, and this
                // child
                // wanted to stretch to fill available space. Translate that to
                // WRAP_CONTENT so that it does not end up with a width of 0
                oldWidth = 0;
                lp.width = LayoutParams.WRAP_CONTENT;
            }
            // Determine how big this child would like to be. If this or
            // previous children have given a weight, then we allow it to
            // use all available space (and we will shrink things later
            // if needed).
            measureChildBeforeLayout(child, i, widthMeasureSpec, totalWeight == 0 ? mTotalLength : 0, heightMeasureSpec, 0);
            if (oldWidth != Integer.MIN_VALUE) {
                lp.width = oldWidth;
            }
            final int childWidth = child.getMeasuredWidth();
            if (isExactly) {
                mTotalLength += childWidth + lp.leftMargin + lp.rightMargin + getNextLocationOffset(child);
            } else {
                final int totalLength = mTotalLength;
                mTotalLength = Math.max(totalLength, totalLength + childWidth + lp.leftMargin + lp.rightMargin + getNextLocationOffset(child));
            }
            if (useLargestChild) {
                largestChildWidth = Math.max(childWidth, largestChildWidth);
            }
        }
        boolean matchHeightLocally = false;
        if (heightMode != MeasureSpec.EXACTLY && lp.height == LayoutParams.MATCH_PARENT) {
            // The height of the linear layout will scale, and at least one
            // child said it wanted to match our height. Set a flag indicating that
            // we need to remeasure at least that view when we know our height.
            matchHeight = true;
            matchHeightLocally = true;
        }
        final int margin = lp.topMargin + lp.bottomMargin;
        final int childHeight = child.getMeasuredHeight() + margin;
        childState = combineMeasuredStates(childState, child.getMeasuredState());
        if (baselineAligned) {
            final int childBaseline = child.getBaseline();
            if (childBaseline != -1) {
                // Translates the child's vertical gravity into an index
                // in the range 0..VERTICAL_GRAVITY_COUNT
                final int gravity = (lp.gravity < 0 ? mGravity : lp.gravity) & Gravity.VERTICAL_GRAVITY_MASK;
                final int index = ((gravity >> Gravity.AXIS_Y_SHIFT) & ~Gravity.AXIS_SPECIFIED) >> 1;
                maxAscent[index] = Math.max(maxAscent[index], childBaseline);
                maxDescent[index] = Math.max(maxDescent[index], childHeight - childBaseline);
            }
        }
        maxHeight = Math.max(maxHeight, childHeight);
        allFillParent = allFillParent && lp.height == LayoutParams.MATCH_PARENT;
        if (lp.weight > 0) {
            /*
                 * Heights of weighted Views are bogus if we end up
                 * remeasuring, so keep them separate.
                 */
            weightedMaxHeight = Math.max(weightedMaxHeight, matchHeightLocally ? margin : childHeight);
        } else {
            alternativeMaxHeight = Math.max(alternativeMaxHeight, matchHeightLocally ? margin : childHeight);
        }
        i += getChildrenSkipCount(child, i);
    }
    if (mTotalLength > 0 && hasDividerBeforeChildAt(count)) {
        mTotalLength += mDividerWidth;
    }
    // the most common case
    if (maxAscent[INDEX_TOP] != -1 || maxAscent[INDEX_CENTER_VERTICAL] != -1 || maxAscent[INDEX_BOTTOM] != -1 || maxAscent[INDEX_FILL] != -1) {
        final int ascent = Math.max(maxAscent[INDEX_FILL], Math.max(maxAscent[INDEX_CENTER_VERTICAL], Math.max(maxAscent[INDEX_TOP], maxAscent[INDEX_BOTTOM])));
        final int descent = Math.max(maxDescent[INDEX_FILL], Math.max(maxDescent[INDEX_CENTER_VERTICAL], Math.max(maxDescent[INDEX_TOP], maxDescent[INDEX_BOTTOM])));
        maxHeight = Math.max(maxHeight, ascent + descent);
    }
    if (useLargestChild && (widthMode == MeasureSpec.AT_MOST || widthMode == MeasureSpec.UNSPECIFIED)) {
        mTotalLength = 0;
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child == null) {
                mTotalLength += measureNullChild(i);
                continue;
            }
            if (child.getVisibility() == GONE) {
                i += getChildrenSkipCount(child, i);
                continue;
            }
            final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
            if (isExactly) {
                mTotalLength += largestChildWidth + lp.leftMargin + lp.rightMargin + getNextLocationOffset(child);
            } else {
                final int totalLength = mTotalLength;
                mTotalLength = Math.max(totalLength, totalLength + largestChildWidth + lp.leftMargin + lp.rightMargin + getNextLocationOffset(child));
            }
        }
    }
    // Add in our padding
    mTotalLength += mPaddingLeft + mPaddingRight;
    int widthSize = mTotalLength;
    // Check against our minimum width
    widthSize = Math.max(widthSize, getSuggestedMinimumWidth());
    // Reconcile our calculated size with the widthMeasureSpec
    int widthSizeAndState = resolveSizeAndState(widthSize, widthMeasureSpec, 0);
    widthSize = widthSizeAndState & MEASURED_SIZE_MASK;
    // Either expand children with weight to take up available space or
    // shrink them if they extend beyond our current bounds. If we skipped
    // measurement on any children, we need to measure them now.
    int delta = widthSize - mTotalLength;
    if (skippedMeasure || delta != 0 && totalWeight > 0.0f) {
        float weightSum = mWeightSum > 0.0f ? mWeightSum : totalWeight;
        maxAscent[0] = maxAscent[1] = maxAscent[2] = maxAscent[3] = -1;
        maxDescent[0] = maxDescent[1] = maxDescent[2] = maxDescent[3] = -1;
        maxHeight = -1;
        mTotalLength = 0;
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child == null || child.getVisibility() == View.GONE) {
                continue;
            }
            final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
            float childExtra = lp.weight;
            if (childExtra > 0) {
                // Child said it could absorb extra space -- give him his share
                int share = (int) (childExtra * delta / weightSum);
                weightSum -= childExtra;
                delta -= share;
                final int childHeightMeasureSpec = getChildMeasureSpec(heightMeasureSpec, mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin, lp.height);
                // child has been previously measured
                if ((lp.width != 0) || (widthMode != MeasureSpec.EXACTLY)) {
                    // child was measured once already above ... base new measurement
                    // on stored values
                    int childWidth = child.getMeasuredWidth() + share;
                    if (childWidth < 0) {
                        childWidth = 0;
                    }
                    child.measure(MeasureSpec.makeMeasureSpec(childWidth, MeasureSpec.EXACTLY), childHeightMeasureSpec);
                } else {
                    // child was skipped in the loop above. Measure for this first time here
                    child.measure(MeasureSpec.makeMeasureSpec(share > 0 ? share : 0, MeasureSpec.EXACTLY), childHeightMeasureSpec);
                }
                // Child may now not fit in horizontal dimension.
                childState = combineMeasuredStates(childState, child.getMeasuredState() & MEASURED_STATE_MASK);
            }
            if (isExactly) {
                mTotalLength += child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin + getNextLocationOffset(child);
            } else {
                final int totalLength = mTotalLength;
                mTotalLength = Math.max(totalLength, totalLength + child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin + getNextLocationOffset(child));
            }
            boolean matchHeightLocally = heightMode != MeasureSpec.EXACTLY && lp.height == LayoutParams.MATCH_PARENT;
            final int margin = lp.topMargin + lp.bottomMargin;
            int childHeight = child.getMeasuredHeight() + margin;
            maxHeight = Math.max(maxHeight, childHeight);
            alternativeMaxHeight = Math.max(alternativeMaxHeight, matchHeightLocally ? margin : childHeight);
            allFillParent = allFillParent && lp.height == LayoutParams.MATCH_PARENT;
            if (baselineAligned) {
                final int childBaseline = child.getBaseline();
                if (childBaseline != -1) {
                    // Translates the child's vertical gravity into an index in the range 0..2
                    final int gravity = (lp.gravity < 0 ? mGravity : lp.gravity) & Gravity.VERTICAL_GRAVITY_MASK;
                    final int index = ((gravity >> Gravity.AXIS_Y_SHIFT) & ~Gravity.AXIS_SPECIFIED) >> 1;
                    maxAscent[index] = Math.max(maxAscent[index], childBaseline);
                    maxDescent[index] = Math.max(maxDescent[index], childHeight - childBaseline);
                }
            }
        }
        // Add in our padding
        mTotalLength += mPaddingLeft + mPaddingRight;
        // the most common case
        if (maxAscent[INDEX_TOP] != -1 || maxAscent[INDEX_CENTER_VERTICAL] != -1 || maxAscent[INDEX_BOTTOM] != -1 || maxAscent[INDEX_FILL] != -1) {
            final int ascent = Math.max(maxAscent[INDEX_FILL], Math.max(maxAscent[INDEX_CENTER_VERTICAL], Math.max(maxAscent[INDEX_TOP], maxAscent[INDEX_BOTTOM])));
            final int descent = Math.max(maxDescent[INDEX_FILL], Math.max(maxDescent[INDEX_CENTER_VERTICAL], Math.max(maxDescent[INDEX_TOP], maxDescent[INDEX_BOTTOM])));
            maxHeight = Math.max(maxHeight, ascent + descent);
        }
    } else {
        alternativeMaxHeight = Math.max(alternativeMaxHeight, weightedMaxHeight);
        // Children will have already been measured once.
        if (useLargestChild && widthMode != MeasureSpec.EXACTLY) {
            for (int i = 0; i < count; i++) {
                final View child = getVirtualChildAt(i);
                if (child == null || child.getVisibility() == View.GONE) {
                    continue;
                }
                final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
                float childExtra = lp.weight;
                if (childExtra > 0) {
                    child.measure(MeasureSpec.makeMeasureSpec(largestChildWidth, MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(child.getMeasuredHeight(), MeasureSpec.EXACTLY));
                }
            }
        }
    }
    if (!allFillParent && heightMode != MeasureSpec.EXACTLY) {
        maxHeight = alternativeMaxHeight;
    }
    maxHeight += mPaddingTop + mPaddingBottom;
    // Check against our minimum height
    maxHeight = Math.max(maxHeight, getSuggestedMinimumHeight());
    setMeasuredDimension(widthSizeAndState | (childState & MEASURED_STATE_MASK), resolveSizeAndState(maxHeight, heightMeasureSpec, (childState << MEASURED_HEIGHT_STATE_SHIFT)));
    if (matchHeight) {
        forceUniformHeight(count, widthMeasureSpec);
    }
}
Body of Second Method:
{
    mTotalLength = 0;
    int maxHeight = 0;
    int childState = 0;
    int alternativeMaxHeight = 0;
    int weightedMaxHeight = 0;
    boolean allFillParent = true;
    float totalWeight = 0;
    final int count = getVirtualChildCount();
    final int widthMode = MeasureSpec.getMode(widthMeasureSpec);
    final int heightMode = MeasureSpec.getMode(heightMeasureSpec);
    boolean matchHeight = false;
    boolean skippedMeasure = false;
    if (mMaxAscent == null || mMaxDescent == null) {
        mMaxAscent = new int[VERTICAL_GRAVITY_COUNT];
        mMaxDescent = new int[VERTICAL_GRAVITY_COUNT];
    }
    final int[] maxAscent = mMaxAscent;
    final int[] maxDescent = mMaxDescent;
    maxAscent[0] = maxAscent[1] = maxAscent[2] = maxAscent[3] = -1;
    maxDescent[0] = maxDescent[1] = maxDescent[2] = maxDescent[3] = -1;
    final boolean baselineAligned = mBaselineAligned;
    final boolean useLargestChild = mUseLargestChild;
    final boolean isExactly = widthMode == MeasureSpec.EXACTLY;
    int largestChildWidth = Integer.MIN_VALUE;
    // See how wide everyone is. Also remember max height.
    for (int i = 0; i < count; ++i) {
        final View child = getVirtualChildAt(i);
        if (child == null) {
            mTotalLength += measureNullChild(i);
            continue;
        }
        if (child.getVisibility() == GONE) {
            i += getChildrenSkipCount(child, i);
            continue;
        }
        if (hasDividerBeforeChildAt(i)) {
            mTotalLength += mDividerWidth;
        }
        final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
        totalWeight += lp.weight;
        if (widthMode == MeasureSpec.EXACTLY && lp.width == 0 && lp.weight > 0) {
            // there is any leftover space.
            if (isExactly) {
                mTotalLength += lp.leftMargin + lp.rightMargin;
            } else {
                final int totalLength = mTotalLength;
                mTotalLength = Math.max(totalLength, totalLength + lp.leftMargin + lp.rightMargin);
            }
            // later (and re-measure).
            if (baselineAligned) {
                final int freeWidthSpec = MeasureSpec.makeSafeMeasureSpec(MeasureSpec.getSize(widthMeasureSpec), MeasureSpec.UNSPECIFIED);
                final int freeHeightSpec = MeasureSpec.makeSafeMeasureSpec(MeasureSpec.getSize(heightMeasureSpec), MeasureSpec.UNSPECIFIED);
                child.measure(freeWidthSpec, freeHeightSpec);
            } else {
                skippedMeasure = true;
            }
        } else {
            int oldWidth = Integer.MIN_VALUE;
            if (lp.width == 0 && lp.weight > 0) {
                // widthMode is either UNSPECIFIED or AT_MOST, and this
                // child
                // wanted to stretch to fill available space. Translate that to
                // WRAP_CONTENT so that it does not end up with a width of 0
                oldWidth = 0;
                lp.width = LayoutParams.WRAP_CONTENT;
            }
            // Determine how big this child would like to be. If this or
            // previous children have given a weight, then we allow it to
            // use all available space (and we will shrink things later
            // if needed).
            measureChildBeforeLayout(child, i, widthMeasureSpec, totalWeight == 0 ? mTotalLength : 0, heightMeasureSpec, 0);
            if (oldWidth != Integer.MIN_VALUE) {
                lp.width = oldWidth;
            }
            final int childWidth = child.getMeasuredWidth();
            if (isExactly) {
                mTotalLength += childWidth + lp.leftMargin + lp.rightMargin + getNextLocationOffset(child);
            } else {
                final int totalLength = mTotalLength;
                mTotalLength = Math.max(totalLength, totalLength + childWidth + lp.leftMargin + lp.rightMargin + getNextLocationOffset(child));
            }
            if (useLargestChild) {
                largestChildWidth = Math.max(childWidth, largestChildWidth);
            }
        }
        boolean matchHeightLocally = false;
        if (heightMode != MeasureSpec.EXACTLY && lp.height == LayoutParams.MATCH_PARENT) {
            // The height of the linear layout will scale, and at least one
            // child said it wanted to match our height. Set a flag indicating that
            // we need to remeasure at least that view when we know our height.
            matchHeight = true;
            matchHeightLocally = true;
        }
        final int margin = lp.topMargin + lp.bottomMargin;
        final int childHeight = child.getMeasuredHeight() + margin;
        childState = combineMeasuredStates(childState, child.getMeasuredState());
        if (baselineAligned) {
            final int childBaseline = child.getBaseline();
            if (childBaseline != -1) {
                // Translates the child's vertical gravity into an index
                // in the range 0..VERTICAL_GRAVITY_COUNT
                final int gravity = (lp.gravity < 0 ? mGravity : lp.gravity) & Gravity.VERTICAL_GRAVITY_MASK;
                final int index = ((gravity >> Gravity.AXIS_Y_SHIFT) & ~Gravity.AXIS_SPECIFIED) >> 1;
                maxAscent[index] = Math.max(maxAscent[index], childBaseline);
                maxDescent[index] = Math.max(maxDescent[index], childHeight - childBaseline);
            }
        }
        maxHeight = Math.max(maxHeight, childHeight);
        allFillParent = allFillParent && lp.height == LayoutParams.MATCH_PARENT;
        if (lp.weight > 0) {
            /*
                 * Heights of weighted Views are bogus if we end up
                 * remeasuring, so keep them separate.
                 */
            weightedMaxHeight = Math.max(weightedMaxHeight, matchHeightLocally ? margin : childHeight);
        } else {
            alternativeMaxHeight = Math.max(alternativeMaxHeight, matchHeightLocally ? margin : childHeight);
        }
        i += getChildrenSkipCount(child, i);
    }
    if (mTotalLength > 0 && hasDividerBeforeChildAt(count)) {
        mTotalLength += mDividerWidth;
    }
    // the most common case
    if (maxAscent[INDEX_TOP] != -1 || maxAscent[INDEX_CENTER_VERTICAL] != -1 || maxAscent[INDEX_BOTTOM] != -1 || maxAscent[INDEX_FILL] != -1) {
        final int ascent = Math.max(maxAscent[INDEX_FILL], Math.max(maxAscent[INDEX_CENTER_VERTICAL], Math.max(maxAscent[INDEX_TOP], maxAscent[INDEX_BOTTOM])));
        final int descent = Math.max(maxDescent[INDEX_FILL], Math.max(maxDescent[INDEX_CENTER_VERTICAL], Math.max(maxDescent[INDEX_TOP], maxDescent[INDEX_BOTTOM])));
        maxHeight = Math.max(maxHeight, ascent + descent);
    }
    if (useLargestChild && (widthMode == MeasureSpec.AT_MOST || widthMode == MeasureSpec.UNSPECIFIED)) {
        mTotalLength = 0;
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child == null) {
                mTotalLength += measureNullChild(i);
                continue;
            }
            if (child.getVisibility() == GONE) {
                i += getChildrenSkipCount(child, i);
                continue;
            }
            final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
            if (isExactly) {
                mTotalLength += largestChildWidth + lp.leftMargin + lp.rightMargin + getNextLocationOffset(child);
            } else {
                final int totalLength = mTotalLength;
                mTotalLength = Math.max(totalLength, totalLength + largestChildWidth + lp.leftMargin + lp.rightMargin + getNextLocationOffset(child));
            }
        }
    }
    // Add in our padding
    mTotalLength += mPaddingLeft + mPaddingRight;
    int widthSize = mTotalLength;
    // Check against our minimum width
    widthSize = Math.max(widthSize, getSuggestedMinimumWidth());
    // Reconcile our calculated size with the widthMeasureSpec
    int widthSizeAndState = resolveSizeAndState(widthSize, widthMeasureSpec, 0);
    widthSize = widthSizeAndState & MEASURED_SIZE_MASK;
    // Either expand children with weight to take up available space or
    // shrink them if they extend beyond our current bounds. If we skipped
    // measurement on any children, we need to measure them now.
    int delta = widthSize - mTotalLength;
    if (skippedMeasure || delta != 0 && totalWeight > 0.0f) {
        float weightSum = mWeightSum > 0.0f ? mWeightSum : totalWeight;
        maxAscent[0] = maxAscent[1] = maxAscent[2] = maxAscent[3] = -1;
        maxDescent[0] = maxDescent[1] = maxDescent[2] = maxDescent[3] = -1;
        maxHeight = -1;
        mTotalLength = 0;
        for (int i = 0; i < count; ++i) {
            final View child = getVirtualChildAt(i);
            if (child == null || child.getVisibility() == View.GONE) {
                continue;
            }
            final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
            float childExtra = lp.weight;
            if (childExtra > 0) {
                // Child said it could absorb extra space -- give him his share
                int share = (int) (childExtra * delta / weightSum);
                weightSum -= childExtra;
                delta -= share;
                final int childHeightMeasureSpec = getChildMeasureSpec(heightMeasureSpec, mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin, lp.height);
                // child has been previously measured
                if ((lp.width != 0) || (widthMode != MeasureSpec.EXACTLY)) {
                    // child was measured once already above ... base new measurement
                    // on stored values
                    int childWidth = child.getMeasuredWidth() + share;
                    if (childWidth < 0) {
                        childWidth = 0;
                    }
                    child.measure(MeasureSpec.makeMeasureSpec(childWidth, MeasureSpec.EXACTLY), childHeightMeasureSpec);
                } else {
                    // child was skipped in the loop above. Measure for this first time here
                    child.measure(MeasureSpec.makeMeasureSpec(share > 0 ? share : 0, MeasureSpec.EXACTLY), childHeightMeasureSpec);
                }
                // Child may now not fit in horizontal dimension.
                childState = combineMeasuredStates(childState, child.getMeasuredState() & MEASURED_STATE_MASK);
            }
            if (isExactly) {
                mTotalLength += child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin + getNextLocationOffset(child);
            } else {
                final int totalLength = mTotalLength;
                mTotalLength = Math.max(totalLength, totalLength + child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin + getNextLocationOffset(child));
            }
            boolean matchHeightLocally = heightMode != MeasureSpec.EXACTLY && lp.height == LayoutParams.MATCH_PARENT;
            final int margin = lp.topMargin + lp.bottomMargin;
            int childHeight = child.getMeasuredHeight() + margin;
            maxHeight = Math.max(maxHeight, childHeight);
            alternativeMaxHeight = Math.max(alternativeMaxHeight, matchHeightLocally ? margin : childHeight);
            allFillParent = allFillParent && lp.height == LayoutParams.MATCH_PARENT;
            if (baselineAligned) {
                final int childBaseline = child.getBaseline();
                if (childBaseline != -1) {
                    // Translates the child's vertical gravity into an index in the range 0..2
                    final int gravity = (lp.gravity < 0 ? mGravity : lp.gravity) & Gravity.VERTICAL_GRAVITY_MASK;
                    final int index = ((gravity >> Gravity.AXIS_Y_SHIFT) & ~Gravity.AXIS_SPECIFIED) >> 1;
                    maxAscent[index] = Math.max(maxAscent[index], childBaseline);
                    maxDescent[index] = Math.max(maxDescent[index], childHeight - childBaseline);
                }
            }
        }
        // Add in our padding
        mTotalLength += mPaddingLeft + mPaddingRight;
        // the most common case
        if (maxAscent[INDEX_TOP] != -1 || maxAscent[INDEX_CENTER_VERTICAL] != -1 || maxAscent[INDEX_BOTTOM] != -1 || maxAscent[INDEX_FILL] != -1) {
            final int ascent = Math.max(maxAscent[INDEX_FILL], Math.max(maxAscent[INDEX_CENTER_VERTICAL], Math.max(maxAscent[INDEX_TOP], maxAscent[INDEX_BOTTOM])));
            final int descent = Math.max(maxDescent[INDEX_FILL], Math.max(maxDescent[INDEX_CENTER_VERTICAL], Math.max(maxDescent[INDEX_TOP], maxDescent[INDEX_BOTTOM])));
            maxHeight = Math.max(maxHeight, ascent + descent);
        }
    } else {
        alternativeMaxHeight = Math.max(alternativeMaxHeight, weightedMaxHeight);
        // Children will have already been measured once.
        if (useLargestChild && widthMode != MeasureSpec.EXACTLY) {
            for (int i = 0; i < count; i++) {
                final View child = getVirtualChildAt(i);
                if (child == null || child.getVisibility() == View.GONE) {
                    continue;
                }
                final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams();
                float childExtra = lp.weight;
                if (childExtra > 0) {
                    child.measure(MeasureSpec.makeMeasureSpec(largestChildWidth, MeasureSpec.EXACTLY), MeasureSpec.makeMeasureSpec(child.getMeasuredHeight(), MeasureSpec.EXACTLY));
                }
            }
        }
    }
    if (!allFillParent && heightMode != MeasureSpec.EXACTLY) {
        maxHeight = alternativeMaxHeight;
    }
    maxHeight += mPaddingTop + mPaddingBottom;
    // Check against our minimum height
    maxHeight = Math.max(maxHeight, getSuggestedMinimumHeight());
    setMeasuredDimension(widthSizeAndState | (childState & MEASURED_STATE_MASK), resolveSizeAndState(maxHeight, heightMeasureSpec, (childState << MEASURED_HEIGHT_STATE_SHIFT)));
    if (matchHeight) {
        forceUniformHeight(count, widthMeasureSpec);
    }
}
------------------------
Find a silently evolved API code:android.os.Environment.getExternalStorageDirectory:COMMENT
Method Modifier: public      static      
Comment:/**
 * Return the primary external storage directory. This directory may not
 * currently be accessible if it has been mounted by the user on their
 * computer, has been removed from the device, or some other problem has
 * happened. You can determine its current state with
 * {@link #getExternalStorageState()}.
 * <p>
 * <em>Note: don't be confused by the word "external" here. This directory
 * can better be thought as media/shared storage. It is a filesystem that
 * can hold a relatively large amount of data and that is shared across all
 * applications (does not enforce permissions). Traditionally this is an SD
 * card, but it may also be implemented as built-in storage in a device that
 * is distinct from the protected internal storage and can be mounted as a
 * filesystem on a computer.</em>
 * <p>
 * On devices with multiple users (as described by {@link UserManager}),
 * each user has their own isolated external storage. Applications only have
 * access to the external storage for the user they're running as.
 * <p>
 * In devices with multiple "external" storage directories, this directory
 * represents the "primary" external storage that the user will interact
 * with. Access to secondary storage is available through
 * <p>
 * Applications should not directly use this top-level directory, in order
 * to avoid polluting the user's root namespace. Any files that are private
 * to the application should be placed in a directory returned by
 * {@link android.content.Context#getExternalFilesDir
 * Context.getExternalFilesDir}, which the system will take care of deleting
 * if the application is uninstalled. Other shared files should be placed in
 * one of the directories returned by
 * {@link #getExternalStoragePublicDirectory}.
 * <p>
 * Writing to this path requires the
 * {@link android.Manifest.permission#WRITE_EXTERNAL_STORAGE} permission,
 * and starting in read access requires the
 * {@link android.Manifest.permission#READ_EXTERNAL_STORAGE} permission,
 * which is automatically granted if you hold the write permission.
 * <p>
 * Starting in {@link android.os.Build.VERSION_CODES#KITKAT}, if your
 * application only needs to store internal data, consider using
 * {@link Context#getExternalFilesDir(String)} or
 * {@link Context#getExternalCacheDir()}, which require no permissions to
 * read or write.
 * <p>
 * This path may change between platform versions, so applications should
 * only persist relative paths.
 * <p>
 * Here is an example of typical code to monitor the state of external
 * storage:
 * <p>
 * {@sample
 * development/samples/ApiDemos/src/com/example/android/apis/content/ExternalStorage.java
 * monitor_storage}
 *
 * @see #getExternalStorageState()
 * @see #isExternalStorageRemovable()
 */

Body of Frist Method:
{
    throwIfUserRequired();
    return sCurrentUser.getExternalDirsForApp()[0];
}
Body of Second Method:
{
    throwIfUserRequired();
    return sCurrentUser.getExternalDirs()[0];
}
------------------------
Find a silently evolved API code:android.graphics.drawable.LayerDrawable.updateStateFromTypedArray:COMMENT
Method Modifier: private     
Comment:/**
 * Initializes the constant state from the values in the typed array.
 */

Body of Frist Method:
{
    final LayerState state = mLayerState;
    // Account for any configuration changes.
    state.mChangingConfigurations |= a.getChangingConfigurations();
    // Extract the theme attributes, if any.
    state.mThemeAttrs = a.extractThemeAttrs();
    mOpacityOverride = a.getInt(R.styleable.LayerDrawable_opacity, mOpacityOverride);
    state.mAutoMirrored = a.getBoolean(R.styleable.LayerDrawable_autoMirrored, state.mAutoMirrored);
    state.mPaddingMode = a.getInteger(R.styleable.LayerDrawable_paddingMode, state.mPaddingMode);
}
Body of Second Method:
{
    final LayerState state = mLayerState;
    // Account for any configuration changes.
    state.mChangingConfigurations |= a.getChangingConfigurations();
    // Extract the theme attributes, if any.
    state.mThemeAttrs = a.extractThemeAttrs();
    final int N = a.getIndexCount();
    for (int i = 0; i < N; i++) {
        int attr = a.getIndex(i);
        switch(attr) {
            case R.styleable.LayerDrawable_opacity:
                state.mOpacityOverride = a.getInt(attr, state.mOpacityOverride);
                break;
            case R.styleable.LayerDrawable_paddingTop:
                state.mPaddingTop = a.getDimensionPixelOffset(attr, state.mPaddingTop);
                break;
            case R.styleable.LayerDrawable_paddingBottom:
                state.mPaddingBottom = a.getDimensionPixelOffset(attr, state.mPaddingBottom);
                break;
            case R.styleable.LayerDrawable_paddingLeft:
                state.mPaddingLeft = a.getDimensionPixelOffset(attr, state.mPaddingLeft);
                break;
            case R.styleable.LayerDrawable_paddingRight:
                state.mPaddingRight = a.getDimensionPixelOffset(attr, state.mPaddingRight);
                break;
            case R.styleable.LayerDrawable_paddingStart:
                state.mPaddingStart = a.getDimensionPixelOffset(attr, state.mPaddingStart);
                break;
            case R.styleable.LayerDrawable_paddingEnd:
                state.mPaddingEnd = a.getDimensionPixelOffset(attr, state.mPaddingEnd);
                break;
            case R.styleable.LayerDrawable_autoMirrored:
                state.mAutoMirrored = a.getBoolean(attr, state.mAutoMirrored);
                break;
            case R.styleable.LayerDrawable_paddingMode:
                state.mPaddingMode = a.getInteger(attr, state.mPaddingMode);
                break;
        }
    }
}
------------------------
Find a silently evolved API code:android.text.TextUtils.writeToParcel:COMMENT
Method Modifier: public      static      
Comment:/**
 * Flatten a CharSequence and whatever styles can be copied across processes
 * into the parcel.
 */

Body of Frist Method:
{
    if (cs instanceof Spanned) {
        p.writeInt(0);
        p.writeString(cs.toString());
        Spanned sp = (Spanned) cs;
        Object[] os = sp.getSpans(0, cs.length(), Object.class);
        for (int i = 0; i < os.length; i++) {
            Object o = os[i];
            Object prop = os[i];
            if (prop instanceof CharacterStyle) {
                prop = ((CharacterStyle) prop).getUnderlying();
            }
            if (prop instanceof ParcelableSpan) {
                ParcelableSpan ps = (ParcelableSpan) prop;
                int spanTypeId = ps.getSpanTypeId();
                if (spanTypeId < FIRST_SPAN || spanTypeId > LAST_SPAN) {
                    Log.e(TAG, "external class \"" + ps.getClass().getSimpleName() + "\" is attempting to use the frameworks-only ParcelableSpan" + " interface");
                } else {
                    p.writeInt(spanTypeId);
                    ps.writeToParcel(p, parcelableFlags);
                    writeWhere(p, sp, o);
                }
            }
        }
        p.writeInt(0);
    } else {
        p.writeInt(1);
        if (cs != null) {
            p.writeString(cs.toString());
        } else {
            p.writeString(null);
        }
    }
}
Body of Second Method:
{
    if (cs instanceof Spanned) {
        p.writeInt(0);
        p.writeString(cs.toString());
        Spanned sp = (Spanned) cs;
        Object[] os = sp.getSpans(0, cs.length(), Object.class);
        for (int i = 0; i < os.length; i++) {
            Object o = os[i];
            Object prop = os[i];
            if (prop instanceof CharacterStyle) {
                prop = ((CharacterStyle) prop).getUnderlying();
            }
            if (prop instanceof ParcelableSpan) {
                final ParcelableSpan ps = (ParcelableSpan) prop;
                final int spanTypeId = ps.getSpanTypeIdInternal();
                if (spanTypeId < FIRST_SPAN || spanTypeId > LAST_SPAN) {
                    Log.e(TAG, "External class \"" + ps.getClass().getSimpleName() + "\" is attempting to use the frameworks-only ParcelableSpan" + " interface");
                } else {
                    p.writeInt(spanTypeId);
                    ps.writeToParcelInternal(p, parcelableFlags);
                    writeWhere(p, sp, o);
                }
            }
        }
        p.writeInt(0);
    } else {
        p.writeInt(1);
        if (cs != null) {
            p.writeString(cs.toString());
        } else {
            p.writeString(null);
        }
    }
}
------------------------
Find a silently evolved API code:android.view.ScaleGestureDetector.setQuickScaleEnabled:COMMENT
Method Modifier: public      
Comment:/**
 * Set whether the associated {@link OnScaleGestureListener} should receive onScale callbacks
 * when the user performs a doubleTap followed by a swipe. Note that this is enabled by default
 * if the app targets API 19 and newer.
 * @param scales true to enable quick scaling, false to disable
 */

Body of Frist Method:
{
    mQuickScaleEnabled = scales;
    if (mQuickScaleEnabled && mGestureDetector == null) {
        GestureDetector.SimpleOnGestureListener gestureListener = new GestureDetector.SimpleOnGestureListener() {

            @Override
            public boolean onDoubleTap(MotionEvent e) {
                // Double tap: start watching for a swipe
                mDoubleTapEvent = e;
                mDoubleTapMode = DOUBLE_TAP_MODE_IN_PROGRESS;
                return true;
            }
        };
        mGestureDetector = new GestureDetector(mContext, gestureListener, mHandler);
    }
}
Body of Second Method:
{
    mQuickScaleEnabled = scales;
    if (mQuickScaleEnabled && mGestureDetector == null) {
        GestureDetector.SimpleOnGestureListener gestureListener = new GestureDetector.SimpleOnGestureListener() {

            @Override
            public boolean onDoubleTap(MotionEvent e) {
                // Double tap: start watching for a swipe
                mAnchoredScaleStartX = e.getX();
                mAnchoredScaleStartY = e.getY();
                mAnchoredScaleMode = ANCHORED_SCALE_MODE_DOUBLE_TAP;
                return true;
            }
        };
        mGestureDetector = new GestureDetector(mContext, gestureListener, mHandler);
    }
}
------------------------
Find a silently evolved API code:android.content.ContentResolver.takePersistableUriPermission:COMMENT
Method Modifier: public      
Comment:/**
 * Take a persistable URI permission grant that has been offered. Once
 * taken, the permission grant will be remembered across device reboots.
 * Only URI permissions granted with
 * {@link Intent#FLAG_GRANT_PERSISTABLE_URI_PERMISSION} can be persisted. If
 * the grant has already been persisted, taking it again will touch
 * {@link UriPermission#getPersistedTime()}.
 *
 * @see #getPersistedUriPermissions()
 */

Body of Frist Method:
{
    try {
        ActivityManagerNative.getDefault().takePersistableUriPermission(ContentProvider.getUriWithoutUserId(uri), modeFlags, resolveUserId(uri));
    } catch (RemoteException e) {
    }
}
Body of Second Method:
{
    Preconditions.checkNotNull(uri, "uri");
    try {
        ActivityManagerNative.getDefault().takePersistableUriPermission(ContentProvider.getUriWithoutUserId(uri), modeFlags, resolveUserId(uri));
    } catch (RemoteException e) {
    }
}
------------------------
Find a silently evolved API code:android.renderscript.Mesh.Builder.create:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * @deprecated in API 16
 * Create a Mesh object from the current state of the builder
 */

Body of Frist Method:
{
    mRS.validate();
    long[] vtx = new long[mVertexTypeCount];
    long[] idx = new long[mIndexTypes.size()];
    int[] prim = new int[mIndexTypes.size()];
    Allocation[] vertexBuffers = new Allocation[mVertexTypeCount];
    Allocation[] indexBuffers = new Allocation[mIndexTypes.size()];
    Primitive[] primitives = new Primitive[mIndexTypes.size()];
    for (int ct = 0; ct < mVertexTypeCount; ct++) {
        Allocation alloc = null;
        Entry entry = mVertexTypes[ct];
        if (entry.t != null) {
            alloc = Allocation.createTyped(mRS, entry.t, mUsage);
        } else if (entry.e != null) {
            alloc = Allocation.createSized(mRS, entry.e, entry.size, mUsage);
        }
        vertexBuffers[ct] = alloc;
        vtx[ct] = alloc.getID(mRS);
    }
    for (int ct = 0; ct < mIndexTypes.size(); ct++) {
        Allocation alloc = null;
        Entry entry = (Entry) mIndexTypes.elementAt(ct);
        if (entry.t != null) {
            alloc = Allocation.createTyped(mRS, entry.t, mUsage);
        } else if (entry.e != null) {
            alloc = Allocation.createSized(mRS, entry.e, entry.size, mUsage);
        }
        long allocID = (alloc == null) ? 0 : alloc.getID(mRS);
        indexBuffers[ct] = alloc;
        primitives[ct] = entry.prim;
        idx[ct] = allocID;
        prim[ct] = entry.prim.mID;
    }
    long id = mRS.nMeshCreate(vtx, idx, prim);
    Mesh newMesh = new Mesh(id, mRS);
    newMesh.mVertexBuffers = vertexBuffers;
    newMesh.mIndexBuffers = indexBuffers;
    newMesh.mPrimitives = primitives;
    return newMesh;
}
Body of Second Method:
{
    mRS.validate();
    long[] vtx = new long[mVertexTypeCount];
    long[] idx = new long[mIndexTypes.size()];
    int[] prim = new int[mIndexTypes.size()];
    Allocation[] vertexBuffers = new Allocation[mVertexTypeCount];
    Allocation[] indexBuffers = new Allocation[mIndexTypes.size()];
    Primitive[] primitives = new Primitive[mIndexTypes.size()];
    for (int ct = 0; ct < mVertexTypeCount; ct++) {
        Allocation alloc = null;
        Entry entry = mVertexTypes[ct];
        if (entry.t != null) {
            alloc = Allocation.createTyped(mRS, entry.t, mUsage);
        } else if (entry.e != null) {
            alloc = Allocation.createSized(mRS, entry.e, entry.size, mUsage);
        } else {
            // Should never happen because the builder will always set one
            throw new IllegalStateException("Builder corrupt, no valid element in entry.");
        }
        vertexBuffers[ct] = alloc;
        vtx[ct] = alloc.getID(mRS);
    }
    for (int ct = 0; ct < mIndexTypes.size(); ct++) {
        Allocation alloc = null;
        Entry entry = (Entry) mIndexTypes.elementAt(ct);
        if (entry.t != null) {
            alloc = Allocation.createTyped(mRS, entry.t, mUsage);
        } else if (entry.e != null) {
            alloc = Allocation.createSized(mRS, entry.e, entry.size, mUsage);
        } else {
            // Should never happen because the builder will always set one
            throw new IllegalStateException("Builder corrupt, no valid element in entry.");
        }
        long allocID = (alloc == null) ? 0 : alloc.getID(mRS);
        indexBuffers[ct] = alloc;
        primitives[ct] = entry.prim;
        idx[ct] = allocID;
        prim[ct] = entry.prim.mID;
    }
    long id = mRS.nMeshCreate(vtx, idx, prim);
    Mesh newMesh = new Mesh(id, mRS);
    newMesh.mVertexBuffers = vertexBuffers;
    newMesh.mIndexBuffers = indexBuffers;
    newMesh.mPrimitives = primitives;
    return newMesh;
}
------------------------
Find a silently evolved API code:android.widget.TextView.makeNewLayout:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * The width passed in is now the desired layout width,
 * not the full view width with padding.
 * {@hide}
 */

Body of Frist Method:
{
    stopMarquee();
    // Update "old" cached values
    mOldMaximum = mMaximum;
    mOldMaxMode = mMaxMode;
    mHighlightPathBogus = true;
    if (wantWidth < 0) {
        wantWidth = 0;
    }
    if (hintWidth < 0) {
        hintWidth = 0;
    }
    Layout.Alignment alignment = getLayoutAlignment();
    final boolean testDirChange = mSingleLine && mLayout != null && (alignment == Layout.Alignment.ALIGN_NORMAL || alignment == Layout.Alignment.ALIGN_OPPOSITE);
    int oldDir = 0;
    if (testDirChange)
        oldDir = mLayout.getParagraphDirection(0);
    boolean shouldEllipsize = mEllipsize != null && getKeyListener() == null;
    final boolean switchEllipsize = mEllipsize == TruncateAt.MARQUEE && mMarqueeFadeMode != MARQUEE_FADE_NORMAL;
    TruncateAt effectiveEllipsize = mEllipsize;
    if (mEllipsize == TruncateAt.MARQUEE && mMarqueeFadeMode == MARQUEE_FADE_SWITCH_SHOW_ELLIPSIS) {
        effectiveEllipsize = TruncateAt.END_SMALL;
    }
    if (mTextDir == null) {
        mTextDir = getTextDirectionHeuristic();
    }
    mLayout = makeSingleLayout(wantWidth, boring, ellipsisWidth, alignment, shouldEllipsize, effectiveEllipsize, effectiveEllipsize == mEllipsize);
    if (switchEllipsize) {
        TruncateAt oppositeEllipsize = effectiveEllipsize == TruncateAt.MARQUEE ? TruncateAt.END : TruncateAt.MARQUEE;
        mSavedMarqueeModeLayout = makeSingleLayout(wantWidth, boring, ellipsisWidth, alignment, shouldEllipsize, oppositeEllipsize, effectiveEllipsize != mEllipsize);
    }
    shouldEllipsize = mEllipsize != null;
    mHintLayout = null;
    if (mHint != null) {
        if (shouldEllipsize)
            hintWidth = wantWidth;
        if (hintBoring == UNKNOWN_BORING) {
            hintBoring = BoringLayout.isBoring(mHint, mTextPaint, mTextDir, mHintBoring);
            if (hintBoring != null) {
                mHintBoring = hintBoring;
            }
        }
        if (hintBoring != null) {
            if (hintBoring.width <= hintWidth && (!shouldEllipsize || hintBoring.width <= ellipsisWidth)) {
                if (mSavedHintLayout != null) {
                    mHintLayout = mSavedHintLayout.replaceOrMake(mHint, mTextPaint, hintWidth, alignment, mSpacingMult, mSpacingAdd, hintBoring, mIncludePad);
                } else {
                    mHintLayout = BoringLayout.make(mHint, mTextPaint, hintWidth, alignment, mSpacingMult, mSpacingAdd, hintBoring, mIncludePad);
                }
                mSavedHintLayout = (BoringLayout) mHintLayout;
            } else if (shouldEllipsize && hintBoring.width <= hintWidth) {
                if (mSavedHintLayout != null) {
                    mHintLayout = mSavedHintLayout.replaceOrMake(mHint, mTextPaint, hintWidth, alignment, mSpacingMult, mSpacingAdd, hintBoring, mIncludePad, mEllipsize, ellipsisWidth);
                } else {
                    mHintLayout = BoringLayout.make(mHint, mTextPaint, hintWidth, alignment, mSpacingMult, mSpacingAdd, hintBoring, mIncludePad, mEllipsize, ellipsisWidth);
                }
            } else if (shouldEllipsize) {
                mHintLayout = new StaticLayout(mHint, 0, mHint.length(), mTextPaint, hintWidth, alignment, mTextDir, mSpacingMult, mSpacingAdd, mIncludePad, mEllipsize, ellipsisWidth, mMaxMode == LINES ? mMaximum : Integer.MAX_VALUE);
            } else {
                mHintLayout = new StaticLayout(mHint, mTextPaint, hintWidth, alignment, mTextDir, mSpacingMult, mSpacingAdd, mIncludePad);
            }
        } else if (shouldEllipsize) {
            mHintLayout = new StaticLayout(mHint, 0, mHint.length(), mTextPaint, hintWidth, alignment, mTextDir, mSpacingMult, mSpacingAdd, mIncludePad, mEllipsize, ellipsisWidth, mMaxMode == LINES ? mMaximum : Integer.MAX_VALUE);
        } else {
            mHintLayout = new StaticLayout(mHint, mTextPaint, hintWidth, alignment, mTextDir, mSpacingMult, mSpacingAdd, mIncludePad);
        }
    }
    if (bringIntoView || (testDirChange && oldDir != mLayout.getParagraphDirection(0))) {
        registerForPreDraw();
    }
    if (mEllipsize == TextUtils.TruncateAt.MARQUEE) {
        if (!compressText(ellipsisWidth)) {
            final int height = mLayoutParams.height;
            // start the marquee immediately
            if (height != LayoutParams.WRAP_CONTENT && height != LayoutParams.MATCH_PARENT) {
                startMarquee();
            } else {
                // Defer the start of the marquee until we know our width (see setFrame())
                mRestartMarquee = true;
            }
        }
    }
    // CursorControllers need a non-null mLayout
    if (mEditor != null)
        mEditor.prepareCursorControllers();
}
Body of Second Method:
{
    stopMarquee();
    // Update "old" cached values
    mOldMaximum = mMaximum;
    mOldMaxMode = mMaxMode;
    mHighlightPathBogus = true;
    if (wantWidth < 0) {
        wantWidth = 0;
    }
    if (hintWidth < 0) {
        hintWidth = 0;
    }
    Layout.Alignment alignment = getLayoutAlignment();
    final boolean testDirChange = mSingleLine && mLayout != null && (alignment == Layout.Alignment.ALIGN_NORMAL || alignment == Layout.Alignment.ALIGN_OPPOSITE);
    int oldDir = 0;
    if (testDirChange)
        oldDir = mLayout.getParagraphDirection(0);
    boolean shouldEllipsize = mEllipsize != null && getKeyListener() == null;
    final boolean switchEllipsize = mEllipsize == TruncateAt.MARQUEE && mMarqueeFadeMode != MARQUEE_FADE_NORMAL;
    TruncateAt effectiveEllipsize = mEllipsize;
    if (mEllipsize == TruncateAt.MARQUEE && mMarqueeFadeMode == MARQUEE_FADE_SWITCH_SHOW_ELLIPSIS) {
        effectiveEllipsize = TruncateAt.END_SMALL;
    }
    if (mTextDir == null) {
        mTextDir = getTextDirectionHeuristic();
    }
    mLayout = makeSingleLayout(wantWidth, boring, ellipsisWidth, alignment, shouldEllipsize, effectiveEllipsize, effectiveEllipsize == mEllipsize);
    if (switchEllipsize) {
        TruncateAt oppositeEllipsize = effectiveEllipsize == TruncateAt.MARQUEE ? TruncateAt.END : TruncateAt.MARQUEE;
        mSavedMarqueeModeLayout = makeSingleLayout(wantWidth, boring, ellipsisWidth, alignment, shouldEllipsize, oppositeEllipsize, effectiveEllipsize != mEllipsize);
    }
    shouldEllipsize = mEllipsize != null;
    mHintLayout = null;
    if (mHint != null) {
        if (shouldEllipsize)
            hintWidth = wantWidth;
        if (hintBoring == UNKNOWN_BORING) {
            hintBoring = BoringLayout.isBoring(mHint, mTextPaint, mTextDir, mHintBoring);
            if (hintBoring != null) {
                mHintBoring = hintBoring;
            }
        }
        if (hintBoring != null) {
            if (hintBoring.width <= hintWidth && (!shouldEllipsize || hintBoring.width <= ellipsisWidth)) {
                if (mSavedHintLayout != null) {
                    mHintLayout = mSavedHintLayout.replaceOrMake(mHint, mTextPaint, hintWidth, alignment, mSpacingMult, mSpacingAdd, hintBoring, mIncludePad);
                } else {
                    mHintLayout = BoringLayout.make(mHint, mTextPaint, hintWidth, alignment, mSpacingMult, mSpacingAdd, hintBoring, mIncludePad);
                }
                mSavedHintLayout = (BoringLayout) mHintLayout;
            } else if (shouldEllipsize && hintBoring.width <= hintWidth) {
                if (mSavedHintLayout != null) {
                    mHintLayout = mSavedHintLayout.replaceOrMake(mHint, mTextPaint, hintWidth, alignment, mSpacingMult, mSpacingAdd, hintBoring, mIncludePad, mEllipsize, ellipsisWidth);
                } else {
                    mHintLayout = BoringLayout.make(mHint, mTextPaint, hintWidth, alignment, mSpacingMult, mSpacingAdd, hintBoring, mIncludePad, mEllipsize, ellipsisWidth);
                }
            }
        }
        // TODO: code duplication with makeSingleLayout()
        if (mHintLayout == null) {
            StaticLayout.Builder builder = StaticLayout.Builder.obtain(mHint, 0, mHint.length(), mTextPaint, hintWidth).setAlignment(alignment).setTextDirection(mTextDir).setLineSpacing(mSpacingAdd, mSpacingMult).setIncludePad(mIncludePad).setBreakStrategy(mBreakStrategy).setHyphenationFrequency(mHyphenationFrequency);
            if (shouldEllipsize) {
                builder.setEllipsize(mEllipsize).setEllipsizedWidth(ellipsisWidth).setMaxLines(mMaxMode == LINES ? mMaximum : Integer.MAX_VALUE);
            }
            mHintLayout = builder.build();
        }
    }
    if (bringIntoView || (testDirChange && oldDir != mLayout.getParagraphDirection(0))) {
        registerForPreDraw();
    }
    if (mEllipsize == TextUtils.TruncateAt.MARQUEE) {
        if (!compressText(ellipsisWidth)) {
            final int height = mLayoutParams.height;
            // start the marquee immediately
            if (height != LayoutParams.WRAP_CONTENT && height != LayoutParams.MATCH_PARENT) {
                startMarquee();
            } else {
                // Defer the start of the marquee until we know our width (see setFrame())
                mRestartMarquee = true;
            }
        }
    }
    // CursorControllers need a non-null mLayout
    if (mEditor != null)
        mEditor.prepareCursorControllers();
}
------------------------
Find a silently evolved API code:android.media.SoundPool.autoPause:COMMENT
<android.media.SoundPool: void autoPause()>
public      final       ->public      final       native      
Method Modifier: public      final       native      
Method Modifier: Yes         Yes         No          
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * Pause all active streams.
 *
 * Pause all streams that are currently playing. This function
 * iterates through all the active streams and pauses any that
 * are playing. It also sets a flag so that any streams that
 * are playing can be resumed by calling autoResume().
 */

Body of Frist Method:
{
    mImpl.autoPause();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.app.Notification.Builder.populateExtras:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Capture, in the provided bundle, semantic information used in the construction of
 * this Notification object.
 * @hide
 */

Body of Frist Method:
{
    // Store original information used in the construction of this object
    extras.putInt(EXTRA_ORIGINATING_USERID, mOriginatingUserId);
    extras.putParcelable(EXTRA_REBUILD_CONTEXT_APPLICATION_INFO, mContext.getApplicationInfo());
    extras.putCharSequence(EXTRA_TITLE, mContentTitle);
    extras.putCharSequence(EXTRA_TEXT, mContentText);
    extras.putCharSequence(EXTRA_SUB_TEXT, mSubText);
    extras.putCharSequence(EXTRA_INFO_TEXT, mContentInfo);
    extras.putInt(EXTRA_SMALL_ICON, mSmallIcon);
    extras.putInt(EXTRA_PROGRESS, mProgress);
    extras.putInt(EXTRA_PROGRESS_MAX, mProgressMax);
    extras.putBoolean(EXTRA_PROGRESS_INDETERMINATE, mProgressIndeterminate);
    extras.putBoolean(EXTRA_SHOW_CHRONOMETER, mUseChronometer);
    extras.putBoolean(EXTRA_SHOW_WHEN, mShowWhen);
    if (mLargeIcon != null) {
        extras.putParcelable(EXTRA_LARGE_ICON, mLargeIcon);
    }
    if (!mPeople.isEmpty()) {
        extras.putStringArray(EXTRA_PEOPLE, mPeople.toArray(new String[mPeople.size()]));
    }
// NOTE: If you're adding new extras also update restoreFromNotification().
}
Body of Second Method:
{
    // Store original information used in the construction of this object
    extras.putInt(EXTRA_ORIGINATING_USERID, mOriginatingUserId);
    extras.putParcelable(EXTRA_REBUILD_CONTEXT_APPLICATION_INFO, mContext.getApplicationInfo());
    extras.putCharSequence(EXTRA_TITLE, mContentTitle);
    extras.putCharSequence(EXTRA_TEXT, mContentText);
    extras.putCharSequence(EXTRA_SUB_TEXT, mSubText);
    extras.putCharSequence(EXTRA_INFO_TEXT, mContentInfo);
    extras.putParcelable(EXTRA_SMALL_ICON, mSmallIcon);
    extras.putInt(EXTRA_PROGRESS, mProgress);
    extras.putInt(EXTRA_PROGRESS_MAX, mProgressMax);
    extras.putBoolean(EXTRA_PROGRESS_INDETERMINATE, mProgressIndeterminate);
    extras.putBoolean(EXTRA_SHOW_CHRONOMETER, mUseChronometer);
    extras.putBoolean(EXTRA_SHOW_WHEN, mShowWhen);
    if (mLargeIcon != null) {
        extras.putParcelable(EXTRA_LARGE_ICON, mLargeIcon);
    }
    if (!mPeople.isEmpty()) {
        extras.putStringArray(EXTRA_PEOPLE, mPeople.toArray(new String[mPeople.size()]));
    }
// NOTE: If you're adding new extras also update restoreFromNotification().
}
------------------------
Find a silently evolved API code:android.content.ContentProvider.enforceWritePermissionInner:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * {@hide}
 */

Body of Frist Method:
{
    final Context context = getContext();
    final int pid = Binder.getCallingPid();
    final int uid = Binder.getCallingUid();
    String missingPerm = null;
    if (UserHandle.isSameApp(uid, mMyUid)) {
        return;
    }
    if (mExported && checkUser(pid, uid, context)) {
        final String componentPerm = getWritePermission();
        if (componentPerm != null) {
            if (context.checkPermission(componentPerm, pid, uid, callerToken) == PERMISSION_GRANTED) {
                return;
            } else {
                missingPerm = componentPerm;
            }
        }
        // track if unprotected write is allowed; any denied
        // <path-permission> below removes this ability
        boolean allowDefaultWrite = (componentPerm == null);
        final PathPermission[] pps = getPathPermissions();
        if (pps != null) {
            final String path = uri.getPath();
            for (PathPermission pp : pps) {
                final String pathPerm = pp.getWritePermission();
                if (pathPerm != null && pp.match(path)) {
                    if (context.checkPermission(pathPerm, pid, uid, callerToken) == PERMISSION_GRANTED) {
                        return;
                    } else {
                        // any denied <path-permission> means we lose
                        // default <provider> access.
                        allowDefaultWrite = false;
                        missingPerm = pathPerm;
                    }
                }
            }
        }
        // <provider> permission, then allow access.
        if (allowDefaultWrite)
            return;
    }
    // last chance, check against any uri grants
    if (context.checkUriPermission(uri, pid, uid, Intent.FLAG_GRANT_WRITE_URI_PERMISSION, callerToken) == PERMISSION_GRANTED) {
        return;
    }
    final String failReason = mExported ? " requires " + missingPerm + ", or grantUriPermission()" : " requires the provider be exported, or grantUriPermission()";
    throw new SecurityException("Permission Denial: writing " + ContentProvider.this.getClass().getName() + " uri " + uri + " from pid=" + pid + ", uid=" + uid + failReason);
}
Body of Second Method:
{
    final Context context = getContext();
    final int pid = Binder.getCallingPid();
    final int uid = Binder.getCallingUid();
    String missingPerm = null;
    int strongestMode = MODE_ALLOWED;
    if (UserHandle.isSameApp(uid, mMyUid)) {
        return MODE_ALLOWED;
    }
    if (mExported && checkUser(pid, uid, context)) {
        final String componentPerm = getWritePermission();
        if (componentPerm != null) {
            final int mode = checkPermissionAndAppOp(componentPerm, callingPkg, callerToken);
            if (mode == MODE_ALLOWED) {
                return MODE_ALLOWED;
            } else {
                missingPerm = componentPerm;
                strongestMode = Math.max(strongestMode, mode);
            }
        }
        // track if unprotected write is allowed; any denied
        // <path-permission> below removes this ability
        boolean allowDefaultWrite = (componentPerm == null);
        final PathPermission[] pps = getPathPermissions();
        if (pps != null) {
            final String path = uri.getPath();
            for (PathPermission pp : pps) {
                final String pathPerm = pp.getWritePermission();
                if (pathPerm != null && pp.match(path)) {
                    final int mode = checkPermissionAndAppOp(pathPerm, callingPkg, callerToken);
                    if (mode == MODE_ALLOWED) {
                        return MODE_ALLOWED;
                    } else {
                        // any denied <path-permission> means we lose
                        // default <provider> access.
                        allowDefaultWrite = false;
                        missingPerm = pathPerm;
                        strongestMode = Math.max(strongestMode, mode);
                    }
                }
            }
        }
        // <provider> permission, then allow access.
        if (allowDefaultWrite)
            return MODE_ALLOWED;
    }
    // last chance, check against any uri grants
    if (context.checkUriPermission(uri, pid, uid, Intent.FLAG_GRANT_WRITE_URI_PERMISSION, callerToken) == PERMISSION_GRANTED) {
        return MODE_ALLOWED;
    }
    // ignored through; otherwise we assume it should be a real error below.
    if (strongestMode == MODE_IGNORED) {
        return MODE_IGNORED;
    }
    final String failReason = mExported ? " requires " + missingPerm + ", or grantUriPermission()" : " requires the provider be exported, or grantUriPermission()";
    throw new SecurityException("Permission Denial: writing " + ContentProvider.this.getClass().getName() + " uri " + uri + " from pid=" + pid + ", uid=" + uid + failReason);
}
------------------------
Find a silently evolved API code:android.widget.FastScroller.measureViewToSide:COMMENT
Method Modifier: private     
Comment:/**
 * Measures the bounds for a view that should be laid out against the edge
 * of an adjacent view. If no adjacent view is provided, lays out against
 * the list edge.
 *
 * @param view The view to measure for layout.
 * @param adjacent (Optional) The adjacent view, may be null to align to the
 * list edge.
 * @param margins Layout margins to apply to the view.
 * @param out Rectangle into which measured bounds are placed.
 */

Body of Frist Method:
{
    final int marginLeft;
    final int marginTop;
    final int marginRight;
    if (margins == null) {
        marginLeft = 0;
        marginTop = 0;
        marginRight = 0;
    } else {
        marginLeft = margins.left;
        marginTop = margins.top;
        marginRight = margins.right;
    }
    final Rect container = mContainerRect;
    final int containerWidth = container.width();
    final int maxWidth;
    if (adjacent == null) {
        maxWidth = containerWidth;
    } else if (mLayoutFromRight) {
        maxWidth = adjacent.getLeft();
    } else {
        maxWidth = containerWidth - adjacent.getRight();
    }
    final int adjMaxWidth = maxWidth - marginLeft - marginRight;
    final int widthMeasureSpec = MeasureSpec.makeMeasureSpec(adjMaxWidth, MeasureSpec.AT_MOST);
    final int heightMeasureSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);
    view.measure(widthMeasureSpec, heightMeasureSpec);
    // Align to the left or right.
    final int width = Math.min(adjMaxWidth, view.getMeasuredWidth());
    final int left;
    final int right;
    if (mLayoutFromRight) {
        right = (adjacent == null ? container.right : adjacent.getLeft()) - marginRight;
        left = right - width;
    } else {
        left = (adjacent == null ? container.left : adjacent.getRight()) + marginLeft;
        right = left + width;
    }
    // Don't adjust the vertical position.
    final int top = marginTop;
    final int bottom = top + view.getMeasuredHeight();
    out.set(left, top, right, bottom);
}
Body of Second Method:
{
    final int marginLeft;
    final int marginTop;
    final int marginRight;
    if (margins == null) {
        marginLeft = 0;
        marginTop = 0;
        marginRight = 0;
    } else {
        marginLeft = margins.left;
        marginTop = margins.top;
        marginRight = margins.right;
    }
    final Rect container = mContainerRect;
    final int containerWidth = container.width();
    final int maxWidth;
    if (adjacent == null) {
        maxWidth = containerWidth;
    } else if (mLayoutFromRight) {
        maxWidth = adjacent.getLeft();
    } else {
        maxWidth = containerWidth - adjacent.getRight();
    }
    final int adjMaxHeight = Math.max(0, container.height());
    final int adjMaxWidth = Math.max(0, maxWidth - marginLeft - marginRight);
    final int widthMeasureSpec = MeasureSpec.makeMeasureSpec(adjMaxWidth, MeasureSpec.AT_MOST);
    final int heightMeasureSpec = MeasureSpec.makeSafeMeasureSpec(adjMaxHeight, MeasureSpec.UNSPECIFIED);
    view.measure(widthMeasureSpec, heightMeasureSpec);
    // Align to the left or right.
    final int width = Math.min(adjMaxWidth, view.getMeasuredWidth());
    final int left;
    final int right;
    if (mLayoutFromRight) {
        right = (adjacent == null ? container.right : adjacent.getLeft()) - marginRight;
        left = right - width;
    } else {
        left = (adjacent == null ? container.left : adjacent.getRight()) + marginLeft;
        right = left + width;
    }
    // Don't adjust the vertical position.
    final int top = marginTop;
    final int bottom = top + view.getMeasuredHeight();
    out.set(left, top, right, bottom);
}
------------------------
Find a silently evolved API code:android.widget.TextView.setCompoundDrawables:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the Drawables (if any) to appear to the left of, above, to the
 * right of, and below the text. Use {@code null} if you do not want a
 * Drawable there. The Drawables must already have had
 * {@link Drawable#setBounds} called.
 * <p>
 * Calling this method will overwrite any Drawables previously set using
 * {@link #setCompoundDrawablesRelative} or related methods.
 *
 * @attr ref android.R.styleable#TextView_drawableLeft
 * @attr ref android.R.styleable#TextView_drawableTop
 * @attr ref android.R.styleable#TextView_drawableRight
 * @attr ref android.R.styleable#TextView_drawableBottom
 */

Body of Frist Method:
{
    Drawables dr = mDrawables;
    // We're switching to absolute, discard relative.
    if (dr != null) {
        if (dr.mDrawableStart != null)
            dr.mDrawableStart.setCallback(null);
        dr.mDrawableStart = null;
        if (dr.mDrawableEnd != null)
            dr.mDrawableEnd.setCallback(null);
        dr.mDrawableEnd = null;
        dr.mDrawableSizeStart = dr.mDrawableHeightStart = 0;
        dr.mDrawableSizeEnd = dr.mDrawableHeightEnd = 0;
    }
    final boolean drawables = left != null || top != null || right != null || bottom != null;
    if (!drawables) {
        // Clearing drawables...  can we free the data structure?
        if (dr != null) {
            if (dr.mDrawablePadding == 0) {
                mDrawables = null;
            } else {
                // out all of the fields in the existing structure.
                if (dr.mDrawableLeft != null)
                    dr.mDrawableLeft.setCallback(null);
                dr.mDrawableLeft = null;
                if (dr.mDrawableTop != null)
                    dr.mDrawableTop.setCallback(null);
                dr.mDrawableTop = null;
                if (dr.mDrawableRight != null)
                    dr.mDrawableRight.setCallback(null);
                dr.mDrawableRight = null;
                if (dr.mDrawableBottom != null)
                    dr.mDrawableBottom.setCallback(null);
                dr.mDrawableBottom = null;
                dr.mDrawableSizeLeft = dr.mDrawableHeightLeft = 0;
                dr.mDrawableSizeRight = dr.mDrawableHeightRight = 0;
                dr.mDrawableSizeTop = dr.mDrawableWidthTop = 0;
                dr.mDrawableSizeBottom = dr.mDrawableWidthBottom = 0;
            }
        }
    } else {
        if (dr == null) {
            mDrawables = dr = new Drawables(getContext());
        }
        mDrawables.mOverride = false;
        if (dr.mDrawableLeft != left && dr.mDrawableLeft != null) {
            dr.mDrawableLeft.setCallback(null);
        }
        dr.mDrawableLeft = left;
        if (dr.mDrawableTop != top && dr.mDrawableTop != null) {
            dr.mDrawableTop.setCallback(null);
        }
        dr.mDrawableTop = top;
        if (dr.mDrawableRight != right && dr.mDrawableRight != null) {
            dr.mDrawableRight.setCallback(null);
        }
        dr.mDrawableRight = right;
        if (dr.mDrawableBottom != bottom && dr.mDrawableBottom != null) {
            dr.mDrawableBottom.setCallback(null);
        }
        dr.mDrawableBottom = bottom;
        final Rect compoundRect = dr.mCompoundRect;
        int[] state;
        state = getDrawableState();
        if (left != null) {
            left.setState(state);
            left.copyBounds(compoundRect);
            left.setCallback(this);
            dr.mDrawableSizeLeft = compoundRect.width();
            dr.mDrawableHeightLeft = compoundRect.height();
        } else {
            dr.mDrawableSizeLeft = dr.mDrawableHeightLeft = 0;
        }
        if (right != null) {
            right.setState(state);
            right.copyBounds(compoundRect);
            right.setCallback(this);
            dr.mDrawableSizeRight = compoundRect.width();
            dr.mDrawableHeightRight = compoundRect.height();
        } else {
            dr.mDrawableSizeRight = dr.mDrawableHeightRight = 0;
        }
        if (top != null) {
            top.setState(state);
            top.copyBounds(compoundRect);
            top.setCallback(this);
            dr.mDrawableSizeTop = compoundRect.height();
            dr.mDrawableWidthTop = compoundRect.width();
        } else {
            dr.mDrawableSizeTop = dr.mDrawableWidthTop = 0;
        }
        if (bottom != null) {
            bottom.setState(state);
            bottom.copyBounds(compoundRect);
            bottom.setCallback(this);
            dr.mDrawableSizeBottom = compoundRect.height();
            dr.mDrawableWidthBottom = compoundRect.width();
        } else {
            dr.mDrawableSizeBottom = dr.mDrawableWidthBottom = 0;
        }
    }
    // Save initial left/right drawables
    if (dr != null) {
        dr.mDrawableLeftInitial = left;
        dr.mDrawableRightInitial = right;
    }
    resetResolvedDrawables();
    resolveDrawables();
    invalidate();
    requestLayout();
}
Body of Second Method:
{
    Drawables dr = mDrawables;
    // We're switching to absolute, discard relative.
    if (dr != null) {
        if (dr.mDrawableStart != null)
            dr.mDrawableStart.setCallback(null);
        dr.mDrawableStart = null;
        if (dr.mDrawableEnd != null)
            dr.mDrawableEnd.setCallback(null);
        dr.mDrawableEnd = null;
        dr.mDrawableSizeStart = dr.mDrawableHeightStart = 0;
        dr.mDrawableSizeEnd = dr.mDrawableHeightEnd = 0;
    }
    final boolean drawables = left != null || top != null || right != null || bottom != null;
    if (!drawables) {
        // Clearing drawables...  can we free the data structure?
        if (dr != null) {
            if (dr.mDrawablePadding == 0) {
                mDrawables = null;
            } else {
                // out all of the fields in the existing structure.
                for (int i = dr.mShowing.length - 1; i >= 0; i--) {
                    if (dr.mShowing[i] != null) {
                        dr.mShowing[i].setCallback(null);
                    }
                    dr.mShowing[i] = null;
                }
                dr.mDrawableSizeLeft = dr.mDrawableHeightLeft = 0;
                dr.mDrawableSizeRight = dr.mDrawableHeightRight = 0;
                dr.mDrawableSizeTop = dr.mDrawableWidthTop = 0;
                dr.mDrawableSizeBottom = dr.mDrawableWidthBottom = 0;
            }
        }
    } else {
        if (dr == null) {
            mDrawables = dr = new Drawables(getContext());
        }
        mDrawables.mOverride = false;
        if (dr.mShowing[Drawables.LEFT] != left && dr.mShowing[Drawables.LEFT] != null) {
            dr.mShowing[Drawables.LEFT].setCallback(null);
        }
        dr.mShowing[Drawables.LEFT] = left;
        if (dr.mShowing[Drawables.TOP] != top && dr.mShowing[Drawables.TOP] != null) {
            dr.mShowing[Drawables.TOP].setCallback(null);
        }
        dr.mShowing[Drawables.TOP] = top;
        if (dr.mShowing[Drawables.RIGHT] != right && dr.mShowing[Drawables.RIGHT] != null) {
            dr.mShowing[Drawables.RIGHT].setCallback(null);
        }
        dr.mShowing[Drawables.RIGHT] = right;
        if (dr.mShowing[Drawables.BOTTOM] != bottom && dr.mShowing[Drawables.BOTTOM] != null) {
            dr.mShowing[Drawables.BOTTOM].setCallback(null);
        }
        dr.mShowing[Drawables.BOTTOM] = bottom;
        final Rect compoundRect = dr.mCompoundRect;
        int[] state;
        state = getDrawableState();
        if (left != null) {
            left.setState(state);
            left.copyBounds(compoundRect);
            left.setCallback(this);
            dr.mDrawableSizeLeft = compoundRect.width();
            dr.mDrawableHeightLeft = compoundRect.height();
        } else {
            dr.mDrawableSizeLeft = dr.mDrawableHeightLeft = 0;
        }
        if (right != null) {
            right.setState(state);
            right.copyBounds(compoundRect);
            right.setCallback(this);
            dr.mDrawableSizeRight = compoundRect.width();
            dr.mDrawableHeightRight = compoundRect.height();
        } else {
            dr.mDrawableSizeRight = dr.mDrawableHeightRight = 0;
        }
        if (top != null) {
            top.setState(state);
            top.copyBounds(compoundRect);
            top.setCallback(this);
            dr.mDrawableSizeTop = compoundRect.height();
            dr.mDrawableWidthTop = compoundRect.width();
        } else {
            dr.mDrawableSizeTop = dr.mDrawableWidthTop = 0;
        }
        if (bottom != null) {
            bottom.setState(state);
            bottom.copyBounds(compoundRect);
            bottom.setCallback(this);
            dr.mDrawableSizeBottom = compoundRect.height();
            dr.mDrawableWidthBottom = compoundRect.width();
        } else {
            dr.mDrawableSizeBottom = dr.mDrawableWidthBottom = 0;
        }
    }
    // Save initial left/right drawables
    if (dr != null) {
        dr.mDrawableLeftInitial = left;
        dr.mDrawableRightInitial = right;
    }
    resetResolvedDrawables();
    resolveDrawables();
    applyCompoundDrawableTint();
    invalidate();
    requestLayout();
}
------------------------
Find a silently evolved API code:android.view.InputEventConsistencyVerifier.reset:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Resets the state of the input event consistency verifier.
 */

Body of Frist Method:
{
    mLastEventSeq = -1;
    mLastNestingLevel = 0;
    mTrackballDown = false;
    mTrackballUnhandled = false;
    mTouchEventStreamPointers = 0;
    mTouchEventStreamIsTainted = false;
    mTouchEventStreamUnhandled = false;
    mHoverEntered = false;
    while (mKeyStateList != null) {
        final KeyState state = mKeyStateList;
        mKeyStateList = state.next;
        state.recycle();
    }
}
Body of Second Method:
{
    mLastEventSeq = -1;
    mLastNestingLevel = 0;
    mTrackballDown = false;
    mTrackballUnhandled = false;
    mTouchEventStreamPointers = 0;
    mTouchEventStreamIsTainted = false;
    mTouchEventStreamUnhandled = false;
    mHoverEntered = false;
    mButtonsPressed = 0;
    while (mKeyStateList != null) {
        final KeyState state = mKeyStateList;
        mKeyStateList = state.next;
        state.recycle();
    }
}
------------------------
Find a silently evolved API code:android.animation.AnimatorInflater.parseAnimatorFromTypeArray:COMMENT
Method Modifier: private     static      
Comment:/**
 * @param anim The animator, must not be null
 * @param arrayAnimator Incoming typed array for Animator's attributes.
 * @param arrayObjectAnimator Incoming typed array for Object Animator's
 * attributes.
 * @param pixelSize The relative pixel size, used to calculate the
 * maximum error for path animations.
 */

Body of Frist Method:
{
    long duration = arrayAnimator.getInt(R.styleable.Animator_duration, 300);
    long startDelay = arrayAnimator.getInt(R.styleable.Animator_startOffset, 0);
    int valueType = arrayAnimator.getInt(R.styleable.Animator_valueType, VALUE_TYPE_FLOAT);
    TypeEvaluator evaluator = null;
    boolean getFloats = (valueType == VALUE_TYPE_FLOAT);
    TypedValue tvFrom = arrayAnimator.peekValue(R.styleable.Animator_valueFrom);
    boolean hasFrom = (tvFrom != null);
    int fromType = hasFrom ? tvFrom.type : 0;
    TypedValue tvTo = arrayAnimator.peekValue(R.styleable.Animator_valueTo);
    boolean hasTo = (tvTo != null);
    int toType = hasTo ? tvTo.type : 0;
    // integer and float.
    if (valueType == VALUE_TYPE_PATH) {
        evaluator = setupAnimatorForPath(anim, arrayAnimator);
    } else {
        // Integer and float value types are handled here.
        if ((hasFrom && (fromType >= TypedValue.TYPE_FIRST_COLOR_INT) && (fromType <= TypedValue.TYPE_LAST_COLOR_INT)) || (hasTo && (toType >= TypedValue.TYPE_FIRST_COLOR_INT) && (toType <= TypedValue.TYPE_LAST_COLOR_INT))) {
            // special case for colors: ignore valueType and get ints
            getFloats = false;
            evaluator = ArgbEvaluator.getInstance();
        }
        setupValues(anim, arrayAnimator, getFloats, hasFrom, fromType, hasTo, toType);
    }
    anim.setDuration(duration);
    anim.setStartDelay(startDelay);
    if (arrayAnimator.hasValue(R.styleable.Animator_repeatCount)) {
        anim.setRepeatCount(arrayAnimator.getInt(R.styleable.Animator_repeatCount, 0));
    }
    if (arrayAnimator.hasValue(R.styleable.Animator_repeatMode)) {
        anim.setRepeatMode(arrayAnimator.getInt(R.styleable.Animator_repeatMode, ValueAnimator.RESTART));
    }
    if (evaluator != null) {
        anim.setEvaluator(evaluator);
    }
    if (arrayObjectAnimator != null) {
        setupObjectAnimator(anim, arrayObjectAnimator, getFloats, pixelSize);
    }
}
Body of Second Method:
{
    long duration = arrayAnimator.getInt(R.styleable.Animator_duration, 300);
    long startDelay = arrayAnimator.getInt(R.styleable.Animator_startOffset, 0);
    int valueType = arrayAnimator.getInt(R.styleable.Animator_valueType, VALUE_TYPE_UNDEFINED);
    if (valueType == VALUE_TYPE_UNDEFINED) {
        valueType = inferValueTypeFromValues(arrayAnimator, R.styleable.Animator_valueFrom, R.styleable.Animator_valueTo);
    }
    PropertyValuesHolder pvh = getPVH(arrayAnimator, valueType, R.styleable.Animator_valueFrom, R.styleable.Animator_valueTo, "");
    if (pvh != null) {
        anim.setValues(pvh);
    }
    anim.setDuration(duration);
    anim.setStartDelay(startDelay);
    if (arrayAnimator.hasValue(R.styleable.Animator_repeatCount)) {
        anim.setRepeatCount(arrayAnimator.getInt(R.styleable.Animator_repeatCount, 0));
    }
    if (arrayAnimator.hasValue(R.styleable.Animator_repeatMode)) {
        anim.setRepeatMode(arrayAnimator.getInt(R.styleable.Animator_repeatMode, ValueAnimator.RESTART));
    }
    if (arrayObjectAnimator != null) {
        setupObjectAnimator(anim, arrayObjectAnimator, valueType == VALUE_TYPE_FLOAT, pixelSize);
    }
}
------------------------
Find a silently evolved API code:android.app.Fragment.initState:COMMENT
Method Modifier: default     
Comment:/**
 * Called by the fragment manager once this fragment has been removed,
 * so that we don't have any left-over state if the application decides
 * to re-use the instance.  This only clears state that the framework
 * internally manages, not things the application sets.
 */

Body of Frist Method:
{
    mIndex = -1;
    mWho = null;
    mAdded = false;
    mRemoving = false;
    mResumed = false;
    mFromLayout = false;
    mInLayout = false;
    mRestored = false;
    mBackStackNesting = 0;
    mFragmentManager = null;
    mChildFragmentManager = null;
    mActivity = null;
    mFragmentId = 0;
    mContainerId = 0;
    mTag = null;
    mHidden = false;
    mDetached = false;
    mRetaining = false;
    mLoaderManager = null;
    mLoadersStarted = false;
    mCheckedForLoaderManager = false;
}
Body of Second Method:
{
    mIndex = -1;
    mWho = null;
    mAdded = false;
    mRemoving = false;
    mResumed = false;
    mFromLayout = false;
    mInLayout = false;
    mRestored = false;
    mBackStackNesting = 0;
    mFragmentManager = null;
    mChildFragmentManager = null;
    mHost = null;
    mFragmentId = 0;
    mContainerId = 0;
    mTag = null;
    mHidden = false;
    mDetached = false;
    mRetaining = false;
    mLoaderManager = null;
    mLoadersStarted = false;
    mCheckedForLoaderManager = false;
}
------------------------
Find a silently evolved API code:android.media.MediaDrm.KeyRequest.getData:COMMENT
Method Modifier: public      
Comment:/**
 * Get the opaque message data
 */

Body of Frist Method:
{
    return mData;
}
Body of Second Method:
{
    if (mData == null) {
        // is needed here to guarantee @NonNull annotation.
        throw new RuntimeException("KeyRequest is not initialized");
    }
    return mData;
}
------------------------
Find a silently evolved API code:android.database.DatabaseUtils.getHexCollationKey:COMMENT
Method Modifier: public      static      
Comment:/**
 * return the collation key in hex format
 * @param name
 * @return the collation key in hex format
 */

Body of Frist Method:
{
    byte[] arr = getCollationKeyInBytes(name);
    char[] keys = Hex.encodeHex(arr);
    return new String(keys, 0, getKeyLen(arr) * 2);
}
Body of Second Method:
{
    byte[] arr = getCollationKeyInBytes(name);
    char[] keys = encodeHex(arr);
    return new String(keys, 0, getKeyLen(arr) * 2);
}
------------------------
Find a silently evolved API code:android.hardware.camera2.params.StreamConfigurationMap.getPublicFormats:COMMENT
Method Modifier: private     
Comment:/**
 * Get the list of publically visible output formats; does not include IMPL_DEFINED
 */

Body of Frist Method:
{
    int[] formats = new int[getPublicFormatCount(output)];
    int i = 0;
    for (int format : getFormatsMap(output).keySet()) {
        if (format != HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED && format != HAL_PIXEL_FORMAT_RAW_OPAQUE) {
            formats[i++] = format;
        }
    }
    if (formats.length != i) {
        throw new AssertionError("Too few formats " + i + ", expected " + formats.length);
    }
    return imageFormatToPublic(formats);
}
Body of Second Method:
{
    int[] formats = new int[getPublicFormatCount(output)];
    int i = 0;
    SparseIntArray map = getFormatsMap(output);
    for (int j = 0; j < map.size(); j++) {
        int format = map.keyAt(j);
        if (format != HAL_PIXEL_FORMAT_RAW_OPAQUE) {
            formats[i++] = imageFormatToPublic(format);
        }
    }
    if (output) {
        for (int j = 0; j < mDepthOutputFormats.size(); j++) {
            formats[i++] = depthFormatToPublic(mDepthOutputFormats.keyAt(j));
        }
    }
    if (formats.length != i) {
        throw new AssertionError("Too few formats " + i + ", expected " + formats.length);
    }
    return formats;
}
------------------------
Find a silently evolved API code:android.speech.tts.UtteranceProgressListener.from:COMMENT
Method Modifier: default     static      hidden      
Comment:/**
 * Wraps an old deprecated OnUtteranceCompletedListener with a shiny new
 * progress listener.
 *
 * @hide
 */

Body of Frist Method:
{
    return new UtteranceProgressListener() {

        @Override
        public synchronized void onDone(String utteranceId) {
            listener.onUtteranceCompleted(utteranceId);
        }

        @Override
        public void onError(String utteranceId) {
            listener.onUtteranceCompleted(utteranceId);
        }

        @Override
        public void onStart(String utteranceId) {
        // Left unimplemented, has no equivalent in the old
        // API.
        }
    };
}
Body of Second Method:
{
    return new UtteranceProgressListener() {

        @Override
        public synchronized void onDone(String utteranceId) {
            listener.onUtteranceCompleted(utteranceId);
        }

        @Override
        public void onError(String utteranceId) {
            listener.onUtteranceCompleted(utteranceId);
        }

        @Override
        public void onStart(String utteranceId) {
        // Left unimplemented, has no equivalent in the old
        // API.
        }

        @Override
        public void onStop(String utteranceId, boolean interrupted) {
            listener.onUtteranceCompleted(utteranceId);
        }
    };
}
------------------------
Find a silently evolved API code:android.graphics.Canvas.drawCircle:COMMENT
Method Modifier: public      
Comment:/**
 * Draw the specified circle using the specified paint. If radius is <= 0,
 * then nothing will be drawn. The circle will be filled or framed based
 * on the Style in the paint.
 *
 * @param cx     The x-coordinate of the center of the cirle to be drawn
 * @param cy     The y-coordinate of the center of the cirle to be drawn
 * @param radius The radius of the cirle to be drawn
 * @param paint  The paint used to draw the circle
 */

Body of Frist Method:
{
    native_drawCircle(mNativeCanvasWrapper, cx, cy, radius, paint.mNativePaint);
}
Body of Second Method:
{
    native_drawCircle(mNativeCanvasWrapper, cx, cy, radius, paint.getNativeInstance());
}
------------------------
Find a silently evolved API code:android.transition.Fade.createAnimation:COMMENT
Method Modifier: private     
Comment:/**
 * Utility method to handle creating and running the Animator.
 */

Body of Frist Method:
{
    if (startAlpha == endAlpha) {
        return null;
    }
    view.setTransitionAlpha(startAlpha);
    final ObjectAnimator anim = ObjectAnimator.ofFloat(view, "transitionAlpha", endAlpha);
    if (DBG) {
        Log.d(LOG_TAG, "Created animator " + anim);
    }
    FadeAnimatorListener listener = new FadeAnimatorListener(view);
    anim.addListener(listener);
    anim.addPauseListener(listener);
    return anim;
}
Body of Second Method:
{
    if (startAlpha == endAlpha) {
        return null;
    }
    view.setTransitionAlpha(startAlpha);
    final ObjectAnimator anim = ObjectAnimator.ofFloat(view, "transitionAlpha", endAlpha);
    if (DBG) {
        Log.d(LOG_TAG, "Created animator " + anim);
    }
    final FadeAnimatorListener listener = new FadeAnimatorListener(view);
    anim.addListener(listener);
    anim.addPauseListener(listener);
    addListener(new TransitionListenerAdapter() {

        @Override
        public void onTransitionEnd(Transition transition) {
            view.setTransitionAlpha(1);
        }
    });
    return anim;
}
------------------------
Find a silently evolved API code:android.graphics.FontFamily_Delegate.loadFont:COMMENT
Method Modifier: default     static      
Comment:/*package*/

Body of Frist Method:
{
    if (path.startsWith(SYSTEM_FONTS)) {
        String relativePath = path.substring(SYSTEM_FONTS.length());
        File f = new File(sFontLocation, relativePath);
        try {
            return Font.createFont(Font.TRUETYPE_FONT, f);
        } catch (Exception e) {
            if (path.endsWith(".otf") && e instanceof FontFormatException) {
                // warning.
                return null;
            }
            Bridge.getLog().fidelityWarning(LayoutLog.TAG_BROKEN, String.format("Unable to load font %1$s", relativePath), e, null);
        }
    } else {
        Bridge.getLog().fidelityWarning(LayoutLog.TAG_UNSUPPORTED, "Only platform fonts located in " + SYSTEM_FONTS + "can be loaded.", null, null);
    }
    return null;
}
Body of Second Method:
{
    if (path.startsWith(SYSTEM_FONTS)) {
        String relativePath = path.substring(SYSTEM_FONTS.length());
        File f = new File(sFontLocation, relativePath);
        try {
            return Font.createFont(Font.TRUETYPE_FONT, f);
        } catch (Exception e) {
            if (path.endsWith(EXTENSION_OTF) && e instanceof FontFormatException) {
                // warning.
                return null;
            }
            Bridge.getLog().fidelityWarning(LayoutLog.TAG_BROKEN, String.format("Unable to load font %1$s", relativePath), e, null);
        }
    } else {
        Bridge.getLog().fidelityWarning(LayoutLog.TAG_UNSUPPORTED, "Only platform fonts located in " + SYSTEM_FONTS + "can be loaded.", null, null);
    }
    return null;
}
------------------------
Find a silently evolved API code:android.net.Network.maybeInitHttpClient:COMMENT
Method Modifier: private     
Comment:// out) ConnectionPools.

Body of Frist Method:
{
    synchronized (mLock) {
        if (mHostResolver == null) {
            mHostResolver = new HostResolver() {

                @Override
                public InetAddress[] getAllByName(String host) throws UnknownHostException {
                    return Network.this.getAllByName(host);
                }
            };
        }
        if (mConnectionPool == null) {
            mConnectionPool = new ConnectionPool(httpMaxConnections, httpKeepAliveDurationMs);
        }
    }
}
Body of Second Method:
{
    synchronized (mLock) {
        if (mNetwork == null) {
            mNetwork = new com.android.okhttp.internal.Network() {

                @Override
                public InetAddress[] resolveInetAddresses(String host) throws UnknownHostException {
                    return Network.this.getAllByName(host);
                }
            };
        }
        if (mConnectionPool == null) {
            mConnectionPool = new ConnectionPool(httpMaxConnections, httpKeepAliveDurationMs);
        }
    }
}
------------------------
Find a silently evolved API code:android.animation.LayoutTransition.runChangeTransition:COMMENT
Method Modifier: private     
Comment:/**
 * This function sets up animations on all of the views that change during layout.
 * For every child in the parent, we create a change animation of the appropriate
 * type (appearing, disappearing, or changing) and ask it to populate its start values from its
 * target view. We add layout listeners to all child views and listen for changes. For
 * those views that change, we populate the end values for those animations and start them.
 * Animations are not run on unchanging views.
 *
 * @param parent The container which is undergoing a change.
 * @param newView The view being added to or removed from the parent. May be null if the
 * changeReason is CHANGING.
 * @param changeReason A value of APPEARING, DISAPPEARING, or CHANGING, indicating whether the
 * transition is occurring because an item is being added to or removed from the parent, or
 * if it is running in response to a layout operation (that is, if the value is CHANGING).
 */

Body of Frist Method:
{
    Animator baseAnimator = null;
    Animator parentAnimator = null;
    final long duration;
    switch(changeReason) {
        case APPEARING:
            baseAnimator = mChangingAppearingAnim;
            duration = mChangingAppearingDuration;
            parentAnimator = defaultChangeIn;
            break;
        case DISAPPEARING:
            baseAnimator = mChangingDisappearingAnim;
            duration = mChangingDisappearingDuration;
            parentAnimator = defaultChangeOut;
            break;
        case CHANGING:
            baseAnimator = mChangingAnim;
            duration = mChangingDuration;
            parentAnimator = defaultChange;
            break;
        default:
            // Shouldn't reach here
            duration = 0;
            break;
    }
    // If the animation is null, there's nothing to do
    if (baseAnimator == null) {
        return;
    }
    // reset the inter-animation delay, in case we use it later
    staggerDelay = 0;
    // used for later cleanup
    final ViewTreeObserver observer = parent.getViewTreeObserver();
    if (!observer.isAlive()) {
        // If the observer's not in a good state, skip the transition
        return;
    }
    int numChildren = parent.getChildCount();
    for (int i = 0; i < numChildren; ++i) {
        final View child = parent.getChildAt(i);
        // only animate the views not being added or removed
        if (child != newView) {
            setupChangeAnimation(parent, changeReason, baseAnimator, duration, child);
        }
    }
    if (mAnimateParentHierarchy) {
        ViewGroup tempParent = parent;
        while (tempParent != null) {
            ViewParent parentParent = tempParent.getParent();
            if (parentParent instanceof ViewGroup) {
                setupChangeAnimation((ViewGroup) parentParent, changeReason, parentAnimator, duration, tempParent);
                tempParent = (ViewGroup) parentParent;
            } else {
                tempParent = null;
            }
        }
    }
    // This is the cleanup step. When we get this rendering event, we know that all of
    // the appropriate animations have been set up and run. Now we can clear out the
    // layout listeners.
    observer.addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {

        public boolean onPreDraw() {
            parent.getViewTreeObserver().removeOnPreDrawListener(this);
            int count = layoutChangeListenerMap.size();
            if (count > 0) {
                Collection<View> views = layoutChangeListenerMap.keySet();
                for (View view : views) {
                    View.OnLayoutChangeListener listener = layoutChangeListenerMap.get(view);
                    view.removeOnLayoutChangeListener(listener);
                }
            }
            layoutChangeListenerMap.clear();
            return true;
        }
    });
}
Body of Second Method:
{
    Animator baseAnimator = null;
    Animator parentAnimator = null;
    final long duration;
    switch(changeReason) {
        case APPEARING:
            baseAnimator = mChangingAppearingAnim;
            duration = mChangingAppearingDuration;
            parentAnimator = defaultChangeIn;
            break;
        case DISAPPEARING:
            baseAnimator = mChangingDisappearingAnim;
            duration = mChangingDisappearingDuration;
            parentAnimator = defaultChangeOut;
            break;
        case CHANGING:
            baseAnimator = mChangingAnim;
            duration = mChangingDuration;
            parentAnimator = defaultChange;
            break;
        default:
            // Shouldn't reach here
            duration = 0;
            break;
    }
    // If the animation is null, there's nothing to do
    if (baseAnimator == null) {
        return;
    }
    // reset the inter-animation delay, in case we use it later
    staggerDelay = 0;
    final ViewTreeObserver observer = parent.getViewTreeObserver();
    if (!observer.isAlive()) {
        // If the observer's not in a good state, skip the transition
        return;
    }
    int numChildren = parent.getChildCount();
    for (int i = 0; i < numChildren; ++i) {
        final View child = parent.getChildAt(i);
        // only animate the views not being added or removed
        if (child != newView) {
            setupChangeAnimation(parent, changeReason, baseAnimator, duration, child);
        }
    }
    if (mAnimateParentHierarchy) {
        ViewGroup tempParent = parent;
        while (tempParent != null) {
            ViewParent parentParent = tempParent.getParent();
            if (parentParent instanceof ViewGroup) {
                setupChangeAnimation((ViewGroup) parentParent, changeReason, parentAnimator, duration, tempParent);
                tempParent = (ViewGroup) parentParent;
            } else {
                tempParent = null;
            }
        }
    }
    // This is the cleanup step. When we get this rendering event, we know that all of
    // the appropriate animations have been set up and run. Now we can clear out the
    // layout listeners.
    CleanupCallback callback = new CleanupCallback(layoutChangeListenerMap, parent);
    observer.addOnPreDrawListener(callback);
    parent.addOnAttachStateChangeListener(callback);
}
------------------------
Find a silently evolved API code:javax.obex.HeaderSet.getHeader:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Retrieves the value of the header identifier provided. The type of the
 * Object returned is defined in the description of this interface.
 * @param headerID the header identifier whose value is to be returned
 * @return the value of the header provided or <code>null</code> if the
 * header identifier specified is not part of this
 * <code>HeaderSet</code> object
 * @throws IllegalArgumentException if the <code>headerID</code> is not one
 * defined in this interface or any of the user-defined headers
 * @throws IOException if an error occurred in the transport layer during
 * the operation or if the connection has been closed
 */

Body of Frist Method:
{
    switch(headerID) {
        case COUNT:
            return mCount;
        case NAME:
            return mName;
        case TYPE:
            return mType;
        case LENGTH:
            return mLength;
        case TIME_ISO_8601:
            return mIsoTime;
        case TIME_4_BYTE:
            return mByteTime;
        case DESCRIPTION:
            return mDescription;
        case TARGET:
            return mTarget;
        case HTTP:
            return mHttpHeader;
        case WHO:
            return mWho;
        case CONNECTION_ID:
            return mConnectionID;
        case OBJECT_CLASS:
            return mObjectClass;
        case APPLICATION_PARAMETER:
            return mAppParam;
        default:
            // Verify that it was not a Unicode String user Defined
            if ((headerID >= 0x30) && (headerID <= 0x3F)) {
                return mUnicodeUserDefined[headerID - 0x30];
            }
            // Verify that it was not a byte sequence user defined header
            if ((headerID >= 0x70) && (headerID <= 0x7F)) {
                return mSequenceUserDefined[headerID - 0x70];
            }
            // Verify that it was not a byte user defined header
            if ((headerID >= 0xB0) && (headerID <= 0xBF)) {
                return mByteUserDefined[headerID - 0xB0];
            }
            // Verify that it was not a integer user defined header
            if ((headerID >= 0xF0) && (headerID <= 0xFF)) {
                return mIntegerUserDefined[headerID - 0xF0];
            }
            throw new IllegalArgumentException("Invalid Header Identifier");
    }
}
Body of Second Method:
{
    switch(headerID) {
        case COUNT:
            return mCount;
        case NAME:
            return mName;
        case TYPE:
            return mType;
        case LENGTH:
            return mLength;
        case TIME_ISO_8601:
            return mIsoTime;
        case TIME_4_BYTE:
            return mByteTime;
        case DESCRIPTION:
            return mDescription;
        case TARGET:
            return mTarget;
        case HTTP:
            return mHttpHeader;
        case WHO:
            return mWho;
        case CONNECTION_ID:
            return mConnectionID;
        case OBJECT_CLASS:
            return mObjectClass;
        case APPLICATION_PARAMETER:
            return mAppParam;
        case SINGLE_RESPONSE_MODE:
            return mSingleResponseMode;
        case SINGLE_RESPONSE_MODE_PARAMETER:
            return mSrmParam;
        default:
            // Verify that it was not a Unicode String user Defined
            if ((headerID >= 0x30) && (headerID <= 0x3F)) {
                return mUnicodeUserDefined[headerID - 0x30];
            }
            // Verify that it was not a byte sequence user defined header
            if ((headerID >= 0x70) && (headerID <= 0x7F)) {
                return mSequenceUserDefined[headerID - 0x70];
            }
            // Verify that it was not a byte user defined header
            if ((headerID >= 0xB0) && (headerID <= 0xBF)) {
                return mByteUserDefined[headerID - 0xB0];
            }
            // Verify that it was not a integer user defined header
            if ((headerID >= 0xF0) && (headerID <= 0xFF)) {
                return mIntegerUserDefined[headerID - 0xF0];
            }
            throw new IllegalArgumentException("Invalid Header Identifier");
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothAdapter.getBluetoothLeScanner:COMMENT
Method Modifier: public      
Comment:/**
 * Returns a {@link BluetoothLeScanner} object for Bluetooth LE scan operations.
 */

Body of Frist Method:
{
    if (getState() != STATE_ON) {
        return null;
    }
    synchronized (mLock) {
        if (sBluetoothLeScanner == null) {
            sBluetoothLeScanner = new BluetoothLeScanner(mManagerService);
        }
    }
    return sBluetoothLeScanner;
}
Body of Second Method:
{
    if (!getLeAccess())
        return null;
    synchronized (mLock) {
        if (sBluetoothLeScanner == null) {
            sBluetoothLeScanner = new BluetoothLeScanner(mManagerService);
        }
    }
    return sBluetoothLeScanner;
}
------------------------
Find a silently evolved API code:android.transition.TransitionInflater.inflateTransition:COMMENT
Method Modifier: public      
Comment:/**
 * Loads a {@link Transition} object from a resource
 *
 * @param resource The resource id of the transition to load
 * @return The loaded Transition object
 * @throws android.content.res.Resources.NotFoundException when the
 * transition cannot be loaded
 */

Body of Frist Method:
{
    XmlResourceParser parser = mContext.getResources().getXml(resource);
    try {
        return createTransitionFromXml(parser, Xml.asAttributeSet(parser), null);
    } catch (XmlPullParserException e) {
        InflateException ex = new InflateException(e.getMessage());
        ex.initCause(e);
        throw ex;
    } catch (IOException e) {
        InflateException ex = new InflateException(parser.getPositionDescription() + ": " + e.getMessage());
        ex.initCause(e);
        throw ex;
    } finally {
        parser.close();
    }
}
Body of Second Method:
{
    // noinspection ResourceType
    XmlResourceParser parser = mContext.getResources().getXml(resource);
    try {
        return createTransitionFromXml(parser, Xml.asAttributeSet(parser), null);
    } catch (XmlPullParserException e) {
        InflateException ex = new InflateException(e.getMessage());
        ex.initCause(e);
        throw ex;
    } catch (IOException e) {
        InflateException ex = new InflateException(parser.getPositionDescription() + ": " + e.getMessage());
        ex.initCause(e);
        throw ex;
    } finally {
        parser.close();
    }
}
------------------------
Find a silently evolved API code:android.transition.Transition.isValidTarget:COMMENT
Method Modifier: default     
Comment:/**
 * Internal utility method for checking whether a given view/id
 * is valid for this transition, where "valid" means that either
 * the Transition has no target/targetId list (the default, in which
 * cause the transition should act on all views in the hiearchy), or
 * the given view is in the target list or the view id is in the
 * targetId list. If the target parameter is null, then the target list
 * is not checked (this is in the case of ListView items, where the
 * views are ignored and only the ids are used).
 */

Body of Frist Method:
{
    int targetId = target.getId();
    if (mTargetIdExcludes != null && mTargetIdExcludes.contains(targetId)) {
        return false;
    }
    if (mTargetExcludes != null && mTargetExcludes.contains(target)) {
        return false;
    }
    if (mTargetTypeExcludes != null && target != null) {
        int numTypes = mTargetTypeExcludes.size();
        for (int i = 0; i < numTypes; ++i) {
            Class type = mTargetTypeExcludes.get(i);
            if (type.isInstance(target)) {
                return false;
            }
        }
    }
    if (mTargetNameExcludes != null && target != null && target.getTransitionName() != null) {
        if (mTargetNameExcludes.contains(target.getTransitionName())) {
            return false;
        }
    }
    if (mTargetIds.size() == 0 && mTargets.size() == 0 && (mTargetTypes == null || mTargetTypes.isEmpty()) && (mTargetNames == null || mTargetNames.isEmpty())) {
        return true;
    }
    if (mTargetIds.contains(targetId) || mTargets.contains(target)) {
        return true;
    }
    if (mTargetNames != null && mTargetNames.contains(target.getTransitionName())) {
        return true;
    }
    if (mTargetTypes != null) {
        for (int i = 0; i < mTargetTypes.size(); ++i) {
            if (mTargetTypes.get(i).isInstance(target)) {
                return true;
            }
        }
    }
    return false;
}
Body of Second Method:
{
    if (target == null) {
        return false;
    }
    int targetId = target.getId();
    if (mTargetIdExcludes != null && mTargetIdExcludes.contains(targetId)) {
        return false;
    }
    if (mTargetExcludes != null && mTargetExcludes.contains(target)) {
        return false;
    }
    if (mTargetTypeExcludes != null && target != null) {
        int numTypes = mTargetTypeExcludes.size();
        for (int i = 0; i < numTypes; ++i) {
            Class type = mTargetTypeExcludes.get(i);
            if (type.isInstance(target)) {
                return false;
            }
        }
    }
    if (mTargetNameExcludes != null && target != null && target.getTransitionName() != null) {
        if (mTargetNameExcludes.contains(target.getTransitionName())) {
            return false;
        }
    }
    if (mTargetIds.size() == 0 && mTargets.size() == 0 && (mTargetTypes == null || mTargetTypes.isEmpty()) && (mTargetNames == null || mTargetNames.isEmpty())) {
        return true;
    }
    if (mTargetIds.contains(targetId) || mTargets.contains(target)) {
        return true;
    }
    if (mTargetNames != null && mTargetNames.contains(target.getTransitionName())) {
        return true;
    }
    if (mTargetTypes != null) {
        for (int i = 0; i < mTargetTypes.size(); ++i) {
            if (mTargetTypes.get(i).isInstance(target)) {
                return true;
            }
        }
    }
    return false;
}
------------------------
Find a silently evolved API code:android.webkit.WebViewDelegate.callDrawGlFunction:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Calls the function specified with the nativeDrawGLFunctor functor pointer. This
 * functionality is used by the WebView for calling into their renderer from the
 * framework display lists.
 *
 * @param canvas a hardware accelerated canvas (see {@link Canvas#isHardwareAccelerated()})
 * @param nativeDrawGLFunctor the pointer to the native functor that implements
 * system/core/include/utils/Functor.h
 * @throws IllegalArgumentException if the canvas is not hardware accelerated
 */

Body of Frist Method:
{
    if (!(canvas instanceof HardwareCanvas)) {
        // Canvas#isHardwareAccelerated() is only true for subclasses of HardwareCanvas.
        throw new IllegalArgumentException(canvas.getClass().getName() + " is not hardware accelerated");
    }
    ((HardwareCanvas) canvas).callDrawGLFunction2(nativeDrawGLFunctor);
}
Body of Second Method:
{
    if (!(canvas instanceof DisplayListCanvas)) {
        // Canvas#isHardwareAccelerated() is only true for subclasses of HardwareCanvas.
        throw new IllegalArgumentException(canvas.getClass().getName() + " is not a DisplayList canvas");
    }
    ((DisplayListCanvas) canvas).callDrawGLFunction2(nativeDrawGLFunctor);
}
------------------------
Find a silently evolved API code:android.webkit.WebView.restoreState:COMMENT
Method Modifier: public      
Comment:/**
 * Restores the state of this WebView from the given Bundle. This method is
 * intended for use in {@link android.app.Activity#onRestoreInstanceState}
 * and should be called to restore the state of this WebView. If
 * it is called after this WebView has had a chance to build state (load
 * pages, create a back/forward list, etc.) there may be undesirable
 * side-effects. Please note that this method no longer restores the
 * display data for this WebView.
 *
 * @param inState the incoming Bundle of state
 * @return the restored back/forward list or null if restoreState failed
 */

Body of Frist Method:
{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, "restoreState");
    return mProvider.restoreState(inState);
}
Body of Second Method:
{
    checkThread();
    return mProvider.restoreState(inState);
}
------------------------
Find a silently evolved API code:android.media.browse.MediaBrowser.unsubscribe:COMMENT
Method Modifier: public      
Comment:/**
 * Unsubscribes for changes to the children of the specified media id.
 * <p>
 * The query callback will no longer be invoked for results associated with
 * this id once this method returns.
 * </p>
 *
 * @param parentId The id of the parent media item whose list of children
 * will be unsubscribed.
 */

Body of Frist Method:
{
    // Check arguments.
    if (parentId == null) {
        throw new IllegalArgumentException("parentId is null");
    }
    // Remove from our list.
    final Subscription sub = mSubscriptions.remove(parentId);
    // Tell the service if necessary.
    if (mState == CONNECT_STATE_CONNECTED && sub != null) {
        try {
            mServiceBinder.removeSubscription(parentId, mServiceCallbacks);
        } catch (RemoteException ex) {
            // Process is crashing.  We will disconnect, and upon reconnect we will
            // automatically reregister. So nothing to do here.
            Log.d(TAG, "removeSubscription failed with RemoteException parentId=" + parentId);
        }
    }
}
Body of Second Method:
{
    // Check arguments.
    if (TextUtils.isEmpty(parentId)) {
        throw new IllegalArgumentException("parentId is empty.");
    }
    // Remove from our list.
    final Subscription sub = mSubscriptions.remove(parentId);
    // Tell the service if necessary.
    if (mState == CONNECT_STATE_CONNECTED && sub != null) {
        try {
            mServiceBinder.removeSubscription(parentId, mServiceCallbacks);
        } catch (RemoteException ex) {
            // Process is crashing.  We will disconnect, and upon reconnect we will
            // automatically reregister. So nothing to do here.
            Log.d(TAG, "removeSubscription failed with RemoteException parentId=" + parentId);
        }
    }
}
------------------------
Find a silently evolved API code:android.widget.Spinner.setPopupBackgroundResource:COMMENT
Method Modifier: public      
Comment:/**
 * Set the background drawable for the spinner's popup window of choices.
 * Only valid in {@link #MODE_DROPDOWN}; this method is a no-op in other modes.
 *
 * @param resId Resource ID of a background drawable
 *
 * @attr ref android.R.styleable#Spinner_popupBackground
 */

Body of Frist Method:
{
    setPopupBackgroundDrawable(getContext().getDrawable(resId));
}
Body of Second Method:
{
    setPopupBackgroundDrawable(getPopupContext().getDrawable(resId));
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothAdapter.closeProfileProxy:COMMENT
Method Modifier: public      
Comment:/**
 * Close the connection of the profile proxy to the Service.
 *
 * <p> Clients should call this when they are no longer using
 * the proxy obtained from {@link #getProfileProxy}.
 * Profile can be one of  {@link BluetoothProfile#HEALTH}, {@link BluetoothProfile#HEADSET} or
 * {@link BluetoothProfile#A2DP}
 *
 * @param profile
 * @param proxy Profile proxy object
 */

Body of Frist Method:
{
    if (proxy == null)
        return;
    switch(profile) {
        case BluetoothProfile.HEADSET:
            BluetoothHeadset headset = (BluetoothHeadset) proxy;
            headset.close();
            break;
        case BluetoothProfile.A2DP:
            BluetoothA2dp a2dp = (BluetoothA2dp) proxy;
            a2dp.close();
            break;
        case BluetoothProfile.A2DP_SINK:
            BluetoothA2dpSink a2dpSink = (BluetoothA2dpSink) proxy;
            a2dpSink.close();
            break;
        case BluetoothProfile.AVRCP_CONTROLLER:
            BluetoothAvrcpController avrcp = (BluetoothAvrcpController) proxy;
            avrcp.close();
            break;
        case BluetoothProfile.INPUT_DEVICE:
            BluetoothInputDevice iDev = (BluetoothInputDevice) proxy;
            iDev.close();
            break;
        case BluetoothProfile.PAN:
            BluetoothPan pan = (BluetoothPan) proxy;
            pan.close();
            break;
        case BluetoothProfile.HEALTH:
            BluetoothHealth health = (BluetoothHealth) proxy;
            health.close();
            break;
        case BluetoothProfile.GATT:
            BluetoothGatt gatt = (BluetoothGatt) proxy;
            gatt.close();
            break;
        case BluetoothProfile.GATT_SERVER:
            BluetoothGattServer gattServer = (BluetoothGattServer) proxy;
            gattServer.close();
            break;
        case BluetoothProfile.MAP:
            BluetoothMap map = (BluetoothMap) proxy;
            map.close();
            break;
        case BluetoothProfile.HEADSET_CLIENT:
            BluetoothHeadsetClient headsetClient = (BluetoothHeadsetClient) proxy;
            headsetClient.close();
            break;
    }
}
Body of Second Method:
{
    if (proxy == null)
        return;
    switch(profile) {
        case BluetoothProfile.HEADSET:
            BluetoothHeadset headset = (BluetoothHeadset) proxy;
            headset.close();
            break;
        case BluetoothProfile.A2DP:
            BluetoothA2dp a2dp = (BluetoothA2dp) proxy;
            a2dp.close();
            break;
        case BluetoothProfile.A2DP_SINK:
            BluetoothA2dpSink a2dpSink = (BluetoothA2dpSink) proxy;
            a2dpSink.close();
            break;
        case BluetoothProfile.AVRCP_CONTROLLER:
            BluetoothAvrcpController avrcp = (BluetoothAvrcpController) proxy;
            avrcp.close();
            break;
        case BluetoothProfile.INPUT_DEVICE:
            BluetoothInputDevice iDev = (BluetoothInputDevice) proxy;
            iDev.close();
            break;
        case BluetoothProfile.PAN:
            BluetoothPan pan = (BluetoothPan) proxy;
            pan.close();
            break;
        case BluetoothProfile.HEALTH:
            BluetoothHealth health = (BluetoothHealth) proxy;
            health.close();
            break;
        case BluetoothProfile.GATT:
            BluetoothGatt gatt = (BluetoothGatt) proxy;
            gatt.close();
            break;
        case BluetoothProfile.GATT_SERVER:
            BluetoothGattServer gattServer = (BluetoothGattServer) proxy;
            gattServer.close();
            break;
        case BluetoothProfile.MAP:
            BluetoothMap map = (BluetoothMap) proxy;
            map.close();
            break;
        case BluetoothProfile.HEADSET_CLIENT:
            BluetoothHeadsetClient headsetClient = (BluetoothHeadsetClient) proxy;
            headsetClient.close();
            break;
        case BluetoothProfile.SAP:
            BluetoothSap sap = (BluetoothSap) proxy;
            sap.close();
            break;
    }
}
------------------------
Find a silently evolved API code:android.media.Image.getCropRect:COMMENT
Method Modifier: public      
Comment:/**
 * Get the crop rectangle associated with this frame.
 * <p>
 * The crop rectangle specifies the region of valid pixels in the image,
 * using coordinates in the largest-resolution plane.
 */

Body of Frist Method:
{
    if (mCropRect == null) {
        return new Rect(0, 0, getWidth(), getHeight());
    } else {
        // return a copy
        return new Rect(mCropRect);
    }
}
Body of Second Method:
{
    throwISEIfImageIsInvalid();
    if (mCropRect == null) {
        return new Rect(0, 0, getWidth(), getHeight());
    } else {
        // return a copy
        return new Rect(mCropRect);
    }
}
------------------------
Find a silently evolved API code:android.graphics.ImageFormat.getBitsPerPixel:COMMENT
Method Modifier: public      static      
Comment:/**
 * Use this function to retrieve the number of bits per pixel of an
 * ImageFormat.
 *
 * @param format
 * @return the number of bits per pixel of the given format or -1 if the
 * format doesn't exist or is not supported.
 */

Body of Frist Method:
{
    switch(format) {
        case RGB_565:
            return 16;
        case NV16:
            return 16;
        case YUY2:
            return 16;
        case YV12:
            return 12;
        case Y8:
            return 8;
        case Y16:
            return 16;
        case NV21:
            return 12;
        case YUV_420_888:
            return 12;
        case RAW_SENSOR:
            return 16;
        case RAW10:
            return 10;
    }
    return -1;
}
Body of Second Method:
{
    switch(format) {
        case RGB_565:
            return 16;
        case NV16:
            return 16;
        case YUY2:
            return 16;
        case YV12:
            return 12;
        case Y8:
            return 8;
        case Y16:
        case DEPTH16:
            return 16;
        case NV21:
            return 12;
        case YUV_420_888:
            return 12;
        case YUV_422_888:
            return 16;
        case YUV_444_888:
            return 24;
        case FLEX_RGB_888:
            return 24;
        case FLEX_RGBA_8888:
            return 32;
        case RAW_SENSOR:
            return 16;
        case RAW10:
            return 10;
        case RAW12:
            return 12;
    }
    return -1;
}
------------------------
Find a silently evolved API code:android.graphics.Canvas.drawLines:COMMENT
Method Modifier: public      
Comment:/**
 * Draw a series of lines. Each line is taken from 4 consecutive values
 * in the pts array. Thus to draw 1 line, the array must contain at least 4
 * values. This is logically the same as drawing the array as follows:
 * drawLine(pts[0], pts[1], pts[2], pts[3]) followed by
 * drawLine(pts[4], pts[5], pts[6], pts[7]) and so on.
 *
 * @param pts      Array of points to draw [x0 y0 x1 y1 x2 y2 ...]
 * @param offset   Number of values in the array to skip before drawing.
 * @param count    The number of values in the array to process, after
 * skipping "offset" of them. Since each line uses 4 values,
 * the number of "lines" that are drawn is really
 * (count >> 2).
 * @param paint    The paint used to draw the points
 */

Body of Frist Method:
{
    native_drawLines(mNativeCanvasWrapper, pts, offset, count, paint.mNativePaint);
}
Body of Second Method:
{
    native_drawLines(mNativeCanvasWrapper, pts, offset, count, paint.getNativeInstance());
}
------------------------
Find a silently evolved API code:android.net.wifi.RttManager.ParcelableRttResults.writeToParcel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Implement the Parcelable interface {@hide}
 */

Body of Frist Method:
{
    if (mResults != null) {
        dest.writeInt(mResults.length);
        for (RttResult result : mResults) {
            dest.writeString(result.bssid);
            dest.writeInt(result.status);
            dest.writeInt(result.requestType);
            dest.writeLong(result.ts);
            dest.writeInt(result.rssi);
            dest.writeInt(result.rssi_spread);
            dest.writeInt(result.tx_rate);
            dest.writeLong(result.rtt_ns);
            dest.writeLong(result.rtt_sd_ns);
            dest.writeLong(result.rtt_spread_ns);
            dest.writeInt(result.distance_cm);
            dest.writeInt(result.distance_sd_cm);
            dest.writeInt(result.distance_spread_cm);
        }
    } else {
        dest.writeInt(0);
    }
}
Body of Second Method:
{
    if (mResults != null) {
        dest.writeInt(mResults.length);
        for (RttResult result : mResults) {
            dest.writeString(result.bssid);
            dest.writeInt(result.burstNumber);
            dest.writeInt(result.measurementFrameNumber);
            dest.writeInt(result.successMeasurementFrameNumber);
            dest.writeInt(result.frameNumberPerBurstPeer);
            dest.writeInt(result.status);
            dest.writeInt(result.measurementType);
            dest.writeInt(result.retryAfterDuration);
            dest.writeLong(result.ts);
            dest.writeInt(result.rssi);
            dest.writeInt(result.rssiSpread);
            dest.writeInt(result.txRate);
            dest.writeLong(result.rtt);
            dest.writeLong(result.rttStandardDeviation);
            dest.writeLong(result.rttSpread);
            dest.writeInt(result.distance);
            dest.writeInt(result.distanceStandardDeviation);
            dest.writeInt(result.distanceSpread);
            dest.writeInt(result.burstDuration);
            dest.writeInt(result.negotiatedBurstNum);
            dest.writeByte(result.LCI.id);
            if (result.LCI.id != (byte) 0xFF) {
                dest.writeByte((byte) result.LCI.data.length);
                dest.writeByteArray(result.LCI.data);
            }
            dest.writeByte(result.LCR.id);
            if (result.LCR.id != (byte) 0xFF) {
                dest.writeInt((byte) result.LCR.data.length);
                dest.writeByte(result.LCR.id);
            }
        }
    } else {
        dest.writeInt(0);
    }
}
------------------------
Find a silently evolved API code:android.app.Activity.onWindowStartingActionMode:COMMENT
Method Modifier: public      
Comment:/**
 * Give the Activity a chance to control the UI for an action mode requested
 * by the system.
 *
 * <p>Note: If you are looking for a notification callback that an action mode
 * has been started for this activity, see {@link #onActionModeStarted(ActionMode)}.</p>
 *
 * @param callback The callback that should control the new action mode
 * @return The new action mode, or <code>null</code> if the activity does not want to
 * provide special handling for this action mode. (It will be handled by the system.)
 */

Body of Frist Method:
{
    initWindowDecorActionBar();
    if (mActionBar != null) {
        return mActionBar.startActionMode(callback);
    }
    return null;
}
Body of Second Method:
{
    // Only Primary ActionModes are represented in the ActionBar.
    if (mActionModeTypeStarting == ActionMode.TYPE_PRIMARY) {
        initWindowDecorActionBar();
        if (mActionBar != null) {
            return mActionBar.startActionMode(callback);
        }
    }
    return null;
}
------------------------
Find a silently evolved API code:android.inputmethodservice.InputMethodService.dump:COMMENT
Method Modifier: protected   
Comment:/**
 * Performs a dump of the InputMethodService's internal state.  Override
 * to add your own information to the dump.
 */

Body of Frist Method:
{
    final Printer p = new PrintWriterPrinter(fout);
    p.println("Input method service state for " + this + ":");
    p.println("  mWindowCreated=" + mWindowCreated + " mWindowAdded=" + mWindowAdded);
    p.println("  mWindowVisible=" + mWindowVisible + " mWindowWasVisible=" + mWindowWasVisible + " mInShowWindow=" + mInShowWindow);
    p.println("  Configuration=" + getResources().getConfiguration());
    p.println("  mToken=" + mToken);
    p.println("  mInputBinding=" + mInputBinding);
    p.println("  mInputConnection=" + mInputConnection);
    p.println("  mStartedInputConnection=" + mStartedInputConnection);
    p.println("  mInputStarted=" + mInputStarted + " mInputViewStarted=" + mInputViewStarted + " mCandidatesViewStarted=" + mCandidatesViewStarted);
    if (mInputEditorInfo != null) {
        p.println("  mInputEditorInfo:");
        mInputEditorInfo.dump(p, "    ");
    } else {
        p.println("  mInputEditorInfo: null");
    }
    p.println("  mShowInputRequested=" + mShowInputRequested + " mLastShowInputRequested=" + mLastShowInputRequested + " mShowInputForced=" + mShowInputForced + " mShowInputFlags=0x" + Integer.toHexString(mShowInputFlags));
    p.println("  mCandidatesVisibility=" + mCandidatesVisibility + " mFullscreenApplied=" + mFullscreenApplied + " mIsFullscreen=" + mIsFullscreen + " mExtractViewHidden=" + mExtractViewHidden);
    if (mExtractedText != null) {
        p.println("  mExtractedText:");
        p.println("    text=" + mExtractedText.text.length() + " chars" + " startOffset=" + mExtractedText.startOffset);
        p.println("    selectionStart=" + mExtractedText.selectionStart + " selectionEnd=" + mExtractedText.selectionEnd + " flags=0x" + Integer.toHexString(mExtractedText.flags));
    } else {
        p.println("  mExtractedText: null");
    }
    p.println("  mExtractedToken=" + mExtractedToken);
    p.println("  mIsInputViewShown=" + mIsInputViewShown + " mStatusIcon=" + mStatusIcon);
    p.println("Last computed insets:");
    p.println("  contentTopInsets=" + mTmpInsets.contentTopInsets + " visibleTopInsets=" + mTmpInsets.visibleTopInsets + " touchableInsets=" + mTmpInsets.touchableInsets + " touchableRegion=" + mTmpInsets.touchableRegion);
}
Body of Second Method:
{
    final Printer p = new PrintWriterPrinter(fout);
    p.println("Input method service state for " + this + ":");
    p.println("  mWindowCreated=" + mWindowCreated + " mWindowAdded=" + mWindowAdded);
    p.println("  mWindowVisible=" + mWindowVisible + " mWindowWasVisible=" + mWindowWasVisible + " mInShowWindow=" + mInShowWindow);
    p.println("  Configuration=" + getResources().getConfiguration());
    p.println("  mToken=" + mToken);
    p.println("  mInputBinding=" + mInputBinding);
    p.println("  mInputConnection=" + mInputConnection);
    p.println("  mStartedInputConnection=" + mStartedInputConnection);
    p.println("  mInputStarted=" + mInputStarted + " mInputViewStarted=" + mInputViewStarted + " mCandidatesViewStarted=" + mCandidatesViewStarted);
    if (mInputEditorInfo != null) {
        p.println("  mInputEditorInfo:");
        mInputEditorInfo.dump(p, "    ");
    } else {
        p.println("  mInputEditorInfo: null");
    }
    p.println("  mShowInputRequested=" + mShowInputRequested + " mLastShowInputRequested=" + mLastShowInputRequested + " mShowInputForced=" + mShowInputForced + " mShowInputFlags=0x" + Integer.toHexString(mShowInputFlags));
    p.println("  mCandidatesVisibility=" + mCandidatesVisibility + " mFullscreenApplied=" + mFullscreenApplied + " mIsFullscreen=" + mIsFullscreen + " mExtractViewHidden=" + mExtractViewHidden);
    if (mExtractedText != null) {
        p.println("  mExtractedText:");
        p.println("    text=" + mExtractedText.text.length() + " chars" + " startOffset=" + mExtractedText.startOffset);
        p.println("    selectionStart=" + mExtractedText.selectionStart + " selectionEnd=" + mExtractedText.selectionEnd + " flags=0x" + Integer.toHexString(mExtractedText.flags));
    } else {
        p.println("  mExtractedText: null");
    }
    p.println("  mExtractedToken=" + mExtractedToken);
    p.println("  mIsInputViewShown=" + mIsInputViewShown + " mStatusIcon=" + mStatusIcon);
    p.println("Last computed insets:");
    p.println("  contentTopInsets=" + mTmpInsets.contentTopInsets + " visibleTopInsets=" + mTmpInsets.visibleTopInsets + " touchableInsets=" + mTmpInsets.touchableInsets + " touchableRegion=" + mTmpInsets.touchableRegion);
    p.println(" mShouldClearInsetOfPreviousIme=" + mShouldClearInsetOfPreviousIme);
}
------------------------
Find a silently evolved API code:android.net.NetworkUtils.runDhcp:COMMENT
<android.net.NetworkUtils: boolean runDhcp(String,DhcpResults)>
public      static      native      hidden      ->public      static      hidden      
Method Modifier: public      static      native      hidden      
Method Modifier: Yes         Yes         Yes         Yes         
Method Updated:  Yes         Yes         No          Yes         
Comment:/**
 * Start the DHCP client daemon, in order to have it request addresses
 * for the named interface, and then configure the interface with those
 * addresses. This call blocks until it obtains a result (either success
 * or failure) from the daemon.
 * @param interfaceName the name of the interface to configure
 * @param dhcpResults if the request succeeds, this object is filled in with
 * the IP address information.
 * @return {@code true} for success, {@code false} for failure
 */

Body of Frist Method:

Body of Second Method:
{
    return startDhcp(interfaceName) && getDhcpResults(interfaceName, dhcpResults);
}
------------------------
Find a silently evolved API code:android.graphics.Canvas.drawPath:COMMENT
Method Modifier: public      
Comment:/**
 * Draw the specified path using the specified paint. The path will be
 * filled or framed based on the Style in the paint.
 *
 * @param path  The path to be drawn
 * @param paint The paint used to draw the path
 */

Body of Frist Method:
{
    native_drawPath(mNativeCanvasWrapper, path.ni(), paint.mNativePaint);
}
Body of Second Method:
{
    native_drawPath(mNativeCanvasWrapper, path.ni(), paint.getNativeInstance());
}
------------------------
Find a silently evolved API code:android.app.Notification.Builder.processSmallIconAsLarge:COMMENT
Method Modifier: private     
Comment:/**
 * Apply any necessary background to smallIcons being used in the largeIcon spot.
 */

Body of Frist Method:
{
    if (!isLegacy()) {
        contentView.setDrawableParameters(R.id.icon, false, -1, 0xFFFFFFFF, PorterDuff.Mode.SRC_ATOP, -1);
    }
    if (!isLegacy() || mColorUtil.isGrayscaleIcon(mContext, largeIconId)) {
        applyLargeIconBackground(contentView);
    }
}
Body of Second Method:
{
    if (!isLegacy()) {
        contentView.setDrawableParameters(R.id.icon, false, -1, 0xFFFFFFFF, PorterDuff.Mode.SRC_ATOP, -1);
        applyLargeIconBackground(contentView);
    } else {
        if (mColorUtil.isGrayscaleIcon(mContext, largeIcon)) {
            applyLargeIconBackground(contentView);
        }
    }
}
------------------------
Find a silently evolved API code:android.graphics.drawable.RippleDrawable.updateStateFromTypedArray:COMMENT
Method Modifier: private     
Comment:/**
 * Initializes the constant state from the values in the typed array.
 */

Body of Frist Method:
{
    final RippleState state = mState;
    // Account for any configuration changes.
    state.mChangingConfigurations |= a.getChangingConfigurations();
    // Extract the theme attributes, if any.
    state.mTouchThemeAttrs = a.extractThemeAttrs();
    final ColorStateList color = a.getColorStateList(R.styleable.RippleDrawable_color);
    if (color != null) {
        mState.mColor = color;
    }
    verifyRequiredAttributes(a);
}
Body of Second Method:
{
    final RippleState state = mState;
    // Account for any configuration changes.
    state.mChangingConfigurations |= a.getChangingConfigurations();
    // Extract the theme attributes, if any.
    state.mTouchThemeAttrs = a.extractThemeAttrs();
    final ColorStateList color = a.getColorStateList(R.styleable.RippleDrawable_color);
    if (color != null) {
        mState.mColor = color;
    }
    mState.mMaxRadius = a.getDimensionPixelSize(R.styleable.RippleDrawable_radius, mState.mMaxRadius);
    verifyRequiredAttributes(a);
}
------------------------
Find a silently evolved API code:android.speech.tts.TextToSpeech.getDefaultVoice:COMMENT
Method Modifier: public      
Comment:/**
 * Returns a Voice instance that's the default voice for the default Text-to-speech language.
 * @return The default voice instance for the default language, or {@code null} if not set or
 * on error.
 */

Body of Frist Method:
{
    return runAction(new Action<Voice>() {

        @Override
        public Voice run(ITextToSpeechService service) throws RemoteException {
            String[] defaultLanguage = service.getClientDefaultLanguage();
            if (defaultLanguage == null || defaultLanguage.length == 0) {
                Log.e(TAG, "service.getClientDefaultLanguage() returned empty array");
                return null;
            }
            String language = defaultLanguage[0];
            String country = (defaultLanguage.length > 1) ? defaultLanguage[1] : "";
            String variant = (defaultLanguage.length > 2) ? defaultLanguage[2] : "";
            // Sanitize the locale using isLanguageAvailable.
            int result = service.isLanguageAvailable(language, country, variant);
            if (result >= LANG_AVAILABLE) {
                if (result < LANG_COUNTRY_VAR_AVAILABLE) {
                    variant = "";
                    if (result < LANG_COUNTRY_AVAILABLE) {
                        country = "";
                    }
                }
            } else {
                // The default language is not supported.
                return null;
            }
            // Get the default voice name
            String voiceName = service.getDefaultVoiceNameFor(language, country, variant);
            if (TextUtils.isEmpty(voiceName)) {
                return null;
            }
            // Find it
            List<Voice> voices = service.getVoices();
            if (voices == null) {
                return null;
            }
            for (Voice voice : voices) {
                if (voice.getName().equals(voiceName)) {
                    return voice;
                }
            }
            return null;
        }
    }, null, "getDefaultVoice");
}
Body of Second Method:
{
    return runAction(new Action<Voice>() {

        @Override
        public Voice run(ITextToSpeechService service) throws RemoteException {
            String[] defaultLanguage = service.getClientDefaultLanguage();
            if (defaultLanguage == null || defaultLanguage.length == 0) {
                Log.e(TAG, "service.getClientDefaultLanguage() returned empty array");
                return null;
            }
            String language = defaultLanguage[0];
            String country = (defaultLanguage.length > 1) ? defaultLanguage[1] : "";
            String variant = (defaultLanguage.length > 2) ? defaultLanguage[2] : "";
            // Sanitize the locale using isLanguageAvailable.
            int result = service.isLanguageAvailable(language, country, variant);
            if (result < LANG_AVAILABLE) {
                // The default language is not supported.
                return null;
            }
            // Get the default voice name
            String voiceName = service.getDefaultVoiceNameFor(language, country, variant);
            if (TextUtils.isEmpty(voiceName)) {
                return null;
            }
            // Find it
            List<Voice> voices = service.getVoices();
            if (voices == null) {
                return null;
            }
            for (Voice voice : voices) {
                if (voice.getName().equals(voiceName)) {
                    return voice;
                }
            }
            return null;
        }
    }, null, "getDefaultVoice");
}
------------------------
Find a silently evolved API code:android.app.Notification.Builder.processSmallRightIcon:COMMENT
Method Modifier: private     
Comment:/**
 * Recolor small icons when used in the R.id.right_icon slot.
 */

Body of Frist Method:
{
    if (!isLegacy()) {
        contentView.setDrawableParameters(R.id.right_icon, false, -1, 0xFFFFFFFF, PorterDuff.Mode.SRC_ATOP, -1);
    }
    if (!isLegacy() || mColorUtil.isGrayscaleIcon(mContext, smallIconDrawableId)) {
        contentView.setInt(R.id.right_icon, "setBackgroundResource", R.drawable.notification_icon_legacy_bg);
        contentView.setDrawableParameters(R.id.right_icon, true, -1, resolveColor(), PorterDuff.Mode.SRC_ATOP, -1);
    }
}
Body of Second Method:
{
    if (!isLegacy()) {
        contentView.setDrawableParameters(R.id.right_icon, false, -1, 0xFFFFFFFF, PorterDuff.Mode.SRC_ATOP, -1);
    }
    final boolean gray = isLegacy() && smallIcon.getType() == Icon.TYPE_RESOURCE && mColorUtil.isGrayscaleIcon(mContext, smallIcon.getResId());
    if (!isLegacy() || gray) {
        contentView.setInt(R.id.right_icon, "setBackgroundResource", R.drawable.notification_icon_legacy_bg);
        contentView.setDrawableParameters(R.id.right_icon, true, -1, resolveColor(), PorterDuff.Mode.SRC_ATOP, -1);
    }
}
------------------------
Find a silently evolved API code:android.media.ImageReader.acquireNextSurfaceImage:COMMENT
Method Modifier: private     
Comment:/**
 * Attempts to acquire the next image from the underlying native implementation.
 *
 * <p>
 * Note that unexpected failures will throw at the JNI level.
 * </p>
 *
 * @param si A blank SurfaceImage.
 * @return One of the {@code ACQUIRE_*} codes that determine success or failure.
 *
 * @see #ACQUIRE_MAX_IMAGES
 * @see #ACQUIRE_NO_BUFS
 * @see #ACQUIRE_SUCCESS
 */

Body of Frist Method:
{
    int status = nativeImageSetup(si);
    switch(status) {
        case ACQUIRE_SUCCESS:
            si.createSurfacePlanes();
            si.setImageValid(true);
        case ACQUIRE_NO_BUFS:
        case ACQUIRE_MAX_IMAGES:
            break;
        default:
            throw new AssertionError("Unknown nativeImageSetup return code " + status);
    }
    return status;
}
Body of Second Method:
{
    int status = nativeImageSetup(si);
    switch(status) {
        case ACQUIRE_SUCCESS:
            si.createSurfacePlanes();
            si.mIsImageValid = true;
        case ACQUIRE_NO_BUFS:
        case ACQUIRE_MAX_IMAGES:
            break;
        default:
            throw new AssertionError("Unknown nativeImageSetup return code " + status);
    }
    return status;
}
------------------------
Find a silently evolved API code:android.app.Fragment.getLoaderManager:COMMENT
Method Modifier: public      
Comment:/**
 * Return the LoaderManager for this fragment, creating it if needed.
 */

Body of Frist Method:
{
    if (mLoaderManager != null) {
        return mLoaderManager;
    }
    if (mActivity == null) {
        throw new IllegalStateException("Fragment " + this + " not attached to Activity");
    }
    mCheckedForLoaderManager = true;
    mLoaderManager = mActivity.getLoaderManager(mWho, mLoadersStarted, true);
    return mLoaderManager;
}
Body of Second Method:
{
    if (mLoaderManager != null) {
        return mLoaderManager;
    }
    if (mHost == null) {
        throw new IllegalStateException("Fragment " + this + " not attached to Activity");
    }
    mCheckedForLoaderManager = true;
    mLoaderManager = mHost.getLoaderManager(mWho, mLoadersStarted, true);
    return mLoaderManager;
}
------------------------
Find a silently evolved API code:android.webkit.WebView.createPrintDocumentAdapter:COMMENT
Method Modifier: public      
Comment:/**
 * Creates a PrintDocumentAdapter that provides the content of this Webview for printing.
 *
 * The adapter works by converting the Webview contents to a PDF stream. The Webview cannot
 * be drawn during the conversion process - any such draws are undefined. It is recommended
 * to use a dedicated off screen Webview for the printing. If necessary, an application may
 * temporarily hide a visible WebView by using a custom PrintDocumentAdapter instance
 * wrapped around the object returned and observing the onStart and onFinish methods. See
 * {@link android.print.PrintDocumentAdapter} for more information.
 *
 * @param documentName  The user-facing name of the printed document. See
 * {@link android.print.PrintDocumentInfo}
 */

Body of Frist Method:
{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, "createPrintDocumentAdapter");
    return mProvider.createPrintDocumentAdapter(documentName);
}
Body of Second Method:
{
    checkThread();
    return mProvider.createPrintDocumentAdapter(documentName);
}
------------------------
Find a silently evolved API code:android.webkit.WebView.restorePicture:COMMENT
Method Modifier: public      hidden      deprecated  
Comment:/**
 * Restores the display data that was saved in {@link #savePicture}. Used in
 * conjunction with {@link #restoreState}. Note that this will not work if
 * this WebView is hardware accelerated.
 *
 * @param b a Bundle containing the saved display data
 * @param src the file where the picture data was stored
 * @return true if the picture was successfully restored
 * @deprecated This method is now obsolete.
 * @hide Since API level {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1}
 */

Body of Frist Method:
{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, "restorePicture=" + src.getName());
    return mProvider.restorePicture(b, src);
}
Body of Second Method:
{
    checkThread();
    return mProvider.restorePicture(b, src);
}
------------------------
Find a silently evolved API code:android.transition.TransitionInflater.inflateTransitionManager:COMMENT
Method Modifier: public      
Comment:/**
 * Loads a {@link TransitionManager} object from a resource
 *
 * @param resource The resource id of the transition manager to load
 * @return The loaded TransitionManager object
 * @throws android.content.res.Resources.NotFoundException when the
 * transition manager cannot be loaded
 */

Body of Frist Method:
{
    XmlResourceParser parser = mContext.getResources().getXml(resource);
    try {
        return createTransitionManagerFromXml(parser, Xml.asAttributeSet(parser), sceneRoot);
    } catch (XmlPullParserException e) {
        InflateException ex = new InflateException(e.getMessage());
        ex.initCause(e);
        throw ex;
    } catch (IOException e) {
        InflateException ex = new InflateException(parser.getPositionDescription() + ": " + e.getMessage());
        ex.initCause(e);
        throw ex;
    } finally {
        parser.close();
    }
}
Body of Second Method:
{
    // noinspection ResourceType
    XmlResourceParser parser = mContext.getResources().getXml(resource);
    try {
        return createTransitionManagerFromXml(parser, Xml.asAttributeSet(parser), sceneRoot);
    } catch (XmlPullParserException e) {
        InflateException ex = new InflateException(e.getMessage());
        ex.initCause(e);
        throw ex;
    } catch (IOException e) {
        InflateException ex = new InflateException(parser.getPositionDescription() + ": " + e.getMessage());
        ex.initCause(e);
        throw ex;
    } finally {
        parser.close();
    }
}
------------------------
Find a silently evolved API code:android.app.Fragment.dump:COMMENT
Method Modifier: public      
Comment:/**
 * Print the Fragments's state into the given stream.
 *
 * @param prefix Text to print at the front of each line.
 * @param fd The raw file descriptor that the dump is being sent to.
 * @param writer The PrintWriter to which you should dump your state.  This will be
 * closed for you after you return.
 * @param args additional arguments to the dump request.
 */

Body of Frist Method:
{
    writer.print(prefix);
    writer.print("mFragmentId=#");
    writer.print(Integer.toHexString(mFragmentId));
    writer.print(" mContainerId=#");
    writer.print(Integer.toHexString(mContainerId));
    writer.print(" mTag=");
    writer.println(mTag);
    writer.print(prefix);
    writer.print("mState=");
    writer.print(mState);
    writer.print(" mIndex=");
    writer.print(mIndex);
    writer.print(" mWho=");
    writer.print(mWho);
    writer.print(" mBackStackNesting=");
    writer.println(mBackStackNesting);
    writer.print(prefix);
    writer.print("mAdded=");
    writer.print(mAdded);
    writer.print(" mRemoving=");
    writer.print(mRemoving);
    writer.print(" mResumed=");
    writer.print(mResumed);
    writer.print(" mFromLayout=");
    writer.print(mFromLayout);
    writer.print(" mInLayout=");
    writer.println(mInLayout);
    writer.print(prefix);
    writer.print("mHidden=");
    writer.print(mHidden);
    writer.print(" mDetached=");
    writer.print(mDetached);
    writer.print(" mMenuVisible=");
    writer.print(mMenuVisible);
    writer.print(" mHasMenu=");
    writer.println(mHasMenu);
    writer.print(prefix);
    writer.print("mRetainInstance=");
    writer.print(mRetainInstance);
    writer.print(" mRetaining=");
    writer.print(mRetaining);
    writer.print(" mUserVisibleHint=");
    writer.println(mUserVisibleHint);
    if (mFragmentManager != null) {
        writer.print(prefix);
        writer.print("mFragmentManager=");
        writer.println(mFragmentManager);
    }
    if (mActivity != null) {
        writer.print(prefix);
        writer.print("mActivity=");
        writer.println(mActivity);
    }
    if (mParentFragment != null) {
        writer.print(prefix);
        writer.print("mParentFragment=");
        writer.println(mParentFragment);
    }
    if (mArguments != null) {
        writer.print(prefix);
        writer.print("mArguments=");
        writer.println(mArguments);
    }
    if (mSavedFragmentState != null) {
        writer.print(prefix);
        writer.print("mSavedFragmentState=");
        writer.println(mSavedFragmentState);
    }
    if (mSavedViewState != null) {
        writer.print(prefix);
        writer.print("mSavedViewState=");
        writer.println(mSavedViewState);
    }
    if (mTarget != null) {
        writer.print(prefix);
        writer.print("mTarget=");
        writer.print(mTarget);
        writer.print(" mTargetRequestCode=");
        writer.println(mTargetRequestCode);
    }
    if (mNextAnim != 0) {
        writer.print(prefix);
        writer.print("mNextAnim=");
        writer.println(mNextAnim);
    }
    if (mContainer != null) {
        writer.print(prefix);
        writer.print("mContainer=");
        writer.println(mContainer);
    }
    if (mView != null) {
        writer.print(prefix);
        writer.print("mView=");
        writer.println(mView);
    }
    if (mAnimatingAway != null) {
        writer.print(prefix);
        writer.print("mAnimatingAway=");
        writer.println(mAnimatingAway);
        writer.print(prefix);
        writer.print("mStateAfterAnimating=");
        writer.println(mStateAfterAnimating);
    }
    if (mLoaderManager != null) {
        writer.print(prefix);
        writer.println("Loader Manager:");
        mLoaderManager.dump(prefix + "  ", fd, writer, args);
    }
    if (mChildFragmentManager != null) {
        writer.print(prefix);
        writer.println("Child " + mChildFragmentManager + ":");
        mChildFragmentManager.dump(prefix + "  ", fd, writer, args);
    }
}
Body of Second Method:
{
    writer.print(prefix);
    writer.print("mFragmentId=#");
    writer.print(Integer.toHexString(mFragmentId));
    writer.print(" mContainerId=#");
    writer.print(Integer.toHexString(mContainerId));
    writer.print(" mTag=");
    writer.println(mTag);
    writer.print(prefix);
    writer.print("mState=");
    writer.print(mState);
    writer.print(" mIndex=");
    writer.print(mIndex);
    writer.print(" mWho=");
    writer.print(mWho);
    writer.print(" mBackStackNesting=");
    writer.println(mBackStackNesting);
    writer.print(prefix);
    writer.print("mAdded=");
    writer.print(mAdded);
    writer.print(" mRemoving=");
    writer.print(mRemoving);
    writer.print(" mResumed=");
    writer.print(mResumed);
    writer.print(" mFromLayout=");
    writer.print(mFromLayout);
    writer.print(" mInLayout=");
    writer.println(mInLayout);
    writer.print(prefix);
    writer.print("mHidden=");
    writer.print(mHidden);
    writer.print(" mDetached=");
    writer.print(mDetached);
    writer.print(" mMenuVisible=");
    writer.print(mMenuVisible);
    writer.print(" mHasMenu=");
    writer.println(mHasMenu);
    writer.print(prefix);
    writer.print("mRetainInstance=");
    writer.print(mRetainInstance);
    writer.print(" mRetaining=");
    writer.print(mRetaining);
    writer.print(" mUserVisibleHint=");
    writer.println(mUserVisibleHint);
    if (mFragmentManager != null) {
        writer.print(prefix);
        writer.print("mFragmentManager=");
        writer.println(mFragmentManager);
    }
    if (mHost != null) {
        writer.print(prefix);
        writer.print("mHost=");
        writer.println(mHost);
    }
    if (mParentFragment != null) {
        writer.print(prefix);
        writer.print("mParentFragment=");
        writer.println(mParentFragment);
    }
    if (mArguments != null) {
        writer.print(prefix);
        writer.print("mArguments=");
        writer.println(mArguments);
    }
    if (mSavedFragmentState != null) {
        writer.print(prefix);
        writer.print("mSavedFragmentState=");
        writer.println(mSavedFragmentState);
    }
    if (mSavedViewState != null) {
        writer.print(prefix);
        writer.print("mSavedViewState=");
        writer.println(mSavedViewState);
    }
    if (mTarget != null) {
        writer.print(prefix);
        writer.print("mTarget=");
        writer.print(mTarget);
        writer.print(" mTargetRequestCode=");
        writer.println(mTargetRequestCode);
    }
    if (mNextAnim != 0) {
        writer.print(prefix);
        writer.print("mNextAnim=");
        writer.println(mNextAnim);
    }
    if (mContainer != null) {
        writer.print(prefix);
        writer.print("mContainer=");
        writer.println(mContainer);
    }
    if (mView != null) {
        writer.print(prefix);
        writer.print("mView=");
        writer.println(mView);
    }
    if (mAnimatingAway != null) {
        writer.print(prefix);
        writer.print("mAnimatingAway=");
        writer.println(mAnimatingAway);
        writer.print(prefix);
        writer.print("mStateAfterAnimating=");
        writer.println(mStateAfterAnimating);
    }
    if (mLoaderManager != null) {
        writer.print(prefix);
        writer.println("Loader Manager:");
        mLoaderManager.dump(prefix + "  ", fd, writer, args);
    }
    if (mChildFragmentManager != null) {
        writer.print(prefix);
        writer.println("Child " + mChildFragmentManager + ":");
        mChildFragmentManager.dump(prefix + "  ", fd, writer, args);
    }
}
------------------------
Find a silently evolved API code:android.animation.ValueAnimator.delayedAnimationFrame:COMMENT
Method Modifier: private     
Comment:/**
 * Internal function called to process an animation frame on an animation that is currently
 * sleeping through its <code>startDelay</code> phase. The return value indicates whether it
 * should be woken up and put on the active animations queue.
 *
 * @param currentTime The current animation time, used to calculate whether the animation
 * has exceeded its <code>startDelay</code> and should be started.
 * @return True if the animation's <code>startDelay</code> has been exceeded and the animation
 * should be added to the set of active animations.
 */

Body of Frist Method:
{
    if (!mStartedDelay) {
        mStartedDelay = true;
        mDelayStartTime = currentTime;
    }
    if (mPaused) {
        if (mPauseTime < 0) {
            mPauseTime = currentTime;
        }
        return false;
    } else if (mResumed) {
        mResumed = false;
        if (mPauseTime > 0) {
            // Offset by the duration that the animation was paused
            mDelayStartTime += (currentTime - mPauseTime);
        }
    }
    long deltaTime = currentTime - mDelayStartTime;
    if (deltaTime > mStartDelay) {
        // startDelay ended - start the anim and record the
        // mStartTime appropriately
        mStartTime = currentTime - (deltaTime - mStartDelay);
        mPlayingState = RUNNING;
        return true;
    }
    return false;
}
Body of Second Method:
{
    if (!mStartedDelay) {
        mStartedDelay = true;
        mDelayStartTime = currentTime;
    }
    if (mPaused) {
        if (mPauseTime < 0) {
            mPauseTime = currentTime;
        }
        return false;
    } else if (mResumed) {
        mResumed = false;
        if (mPauseTime > 0) {
            // Offset by the duration that the animation was paused
            mDelayStartTime += (currentTime - mPauseTime);
        }
    }
    long deltaTime = currentTime - mDelayStartTime;
    if (deltaTime > mStartDelay) {
        // startDelay ended - start the anim and record the mStartTime appropriately
        mStartTime = mDelayStartTime + mStartDelay;
        // do not allow start time to be compensated for jank
        mStartTimeCommitted = true;
        mPlayingState = RUNNING;
        return true;
    }
    return false;
}
------------------------
Find a silently evolved API code:android.util.AtomicFile.startWrite:COMMENT
Method Modifier: public      
Comment:/**
 * Start a new write operation on the file.  This returns a FileOutputStream
 * to which you can write the new file data.  The existing file is replaced
 * with the new data.  You <em>must not</em> directly close the given
 * FileOutputStream; instead call either {@link #finishWrite(FileOutputStream)}
 * or {@link #failWrite(FileOutputStream)}.
 *
 * <p>Note that if another thread is currently performing
 * a write, this will simply replace whatever that thread is writing
 * with the new file being written by this thread, and when the other
 * thread finishes the write the new write operation will no longer be
 * safe (or will be lost).  You must do your own threading protection for
 * access to AtomicFile.
 */

Body of Frist Method:
{
    // Rename the current file so it may be used as a backup during the next read
    if (mBaseName.exists()) {
        if (!mBackupName.exists()) {
            if (!mBaseName.renameTo(mBackupName)) {
                Log.w("AtomicFile", "Couldn't rename file " + mBaseName + " to backup file " + mBackupName);
            }
        } else {
            mBaseName.delete();
        }
    }
    FileOutputStream str = null;
    try {
        str = new FileOutputStream(mBaseName);
    } catch (FileNotFoundException e) {
        File parent = mBaseName.getParentFile();
        if (!parent.mkdir()) {
            throw new IOException("Couldn't create directory " + mBaseName);
        }
        FileUtils.setPermissions(parent.getPath(), FileUtils.S_IRWXU | FileUtils.S_IRWXG | FileUtils.S_IXOTH, -1, -1);
        try {
            str = new FileOutputStream(mBaseName);
        } catch (FileNotFoundException e2) {
            throw new IOException("Couldn't create " + mBaseName);
        }
    }
    return str;
}
Body of Second Method:
{
    // Rename the current file so it may be used as a backup during the next read
    if (mBaseName.exists()) {
        if (!mBackupName.exists()) {
            if (!mBaseName.renameTo(mBackupName)) {
                Log.w("AtomicFile", "Couldn't rename file " + mBaseName + " to backup file " + mBackupName);
            }
        } else {
            mBaseName.delete();
        }
    }
    FileOutputStream str = null;
    try {
        str = new FileOutputStream(mBaseName);
    } catch (FileNotFoundException e) {
        File parent = mBaseName.getParentFile();
        if (!parent.mkdirs()) {
            throw new IOException("Couldn't create directory " + mBaseName);
        }
        FileUtils.setPermissions(parent.getPath(), FileUtils.S_IRWXU | FileUtils.S_IRWXG | FileUtils.S_IXOTH, -1, -1);
        try {
            str = new FileOutputStream(mBaseName);
        } catch (FileNotFoundException e2) {
            throw new IOException("Couldn't create " + mBaseName);
        }
    }
    return str;
}
------------------------
Find a silently evolved API code:android.webkit.WebView.findNext:COMMENT
Method Modifier: public      
Comment:/**
 * Highlights and scrolls to the next match found by
 * {@link #findAllAsync}, wrapping around page boundaries as necessary.
 * Notifies any registered {@link FindListener}. If {@link #findAllAsync(String)}
 * has not been called yet, or if {@link #clearMatches} has been called since the
 * last find operation, this function does nothing.
 *
 * @param forward the direction to search
 * @see #setFindListener
 */

Body of Frist Method:
{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, "findNext");
    mProvider.findNext(forward);
}
Body of Second Method:
{
    checkThread();
    mProvider.findNext(forward);
}
------------------------
Find a silently evolved API code:android.widget.GridView.arrowScroll:COMMENT
Method Modifier: default     
Comment:/**
 * Scrolls to the next or previous item, horizontally or vertically.
 *
 * @param direction either {@link View#FOCUS_LEFT}, {@link View#FOCUS_RIGHT},
 * {@link View#FOCUS_UP} or {@link View#FOCUS_DOWN}
 *
 * @return whether selection was moved
 */

Body of Frist Method:
{
    final int selectedPosition = mSelectedPosition;
    final int numColumns = mNumColumns;
    int startOfRowPos;
    int endOfRowPos;
    boolean moved = false;
    if (!mStackFromBottom) {
        startOfRowPos = (selectedPosition / numColumns) * numColumns;
        endOfRowPos = Math.min(startOfRowPos + numColumns - 1, mItemCount - 1);
    } else {
        final int invertedSelection = mItemCount - 1 - selectedPosition;
        endOfRowPos = mItemCount - 1 - (invertedSelection / numColumns) * numColumns;
        startOfRowPos = Math.max(0, endOfRowPos - numColumns + 1);
    }
    switch(direction) {
        case FOCUS_UP:
            if (startOfRowPos > 0) {
                mLayoutMode = LAYOUT_MOVE_SELECTION;
                setSelectionInt(Math.max(0, selectedPosition - numColumns));
                moved = true;
            }
            break;
        case FOCUS_DOWN:
            if (endOfRowPos < mItemCount - 1) {
                mLayoutMode = LAYOUT_MOVE_SELECTION;
                setSelectionInt(Math.min(selectedPosition + numColumns, mItemCount - 1));
                moved = true;
            }
            break;
        case FOCUS_LEFT:
            if (selectedPosition > startOfRowPos) {
                mLayoutMode = LAYOUT_MOVE_SELECTION;
                setSelectionInt(Math.max(0, selectedPosition - 1));
                moved = true;
            }
            break;
        case FOCUS_RIGHT:
            if (selectedPosition < endOfRowPos) {
                mLayoutMode = LAYOUT_MOVE_SELECTION;
                setSelectionInt(Math.min(selectedPosition + 1, mItemCount - 1));
                moved = true;
            }
            break;
    }
    if (moved) {
        playSoundEffect(SoundEffectConstants.getContantForFocusDirection(direction));
        invokeOnItemScrollListener();
    }
    if (moved) {
        awakenScrollBars();
    }
    return moved;
}
Body of Second Method:
{
    final int selectedPosition = mSelectedPosition;
    final int numColumns = mNumColumns;
    int startOfRowPos;
    int endOfRowPos;
    boolean moved = false;
    if (!mStackFromBottom) {
        startOfRowPos = (selectedPosition / numColumns) * numColumns;
        endOfRowPos = Math.min(startOfRowPos + numColumns - 1, mItemCount - 1);
    } else {
        final int invertedSelection = mItemCount - 1 - selectedPosition;
        endOfRowPos = mItemCount - 1 - (invertedSelection / numColumns) * numColumns;
        startOfRowPos = Math.max(0, endOfRowPos - numColumns + 1);
    }
    switch(direction) {
        case FOCUS_UP:
            if (startOfRowPos > 0) {
                mLayoutMode = LAYOUT_MOVE_SELECTION;
                setSelectionInt(Math.max(0, selectedPosition - numColumns));
                moved = true;
            }
            break;
        case FOCUS_DOWN:
            if (endOfRowPos < mItemCount - 1) {
                mLayoutMode = LAYOUT_MOVE_SELECTION;
                setSelectionInt(Math.min(selectedPosition + numColumns, mItemCount - 1));
                moved = true;
            }
            break;
    }
    final boolean isLayoutRtl = isLayoutRtl();
    if (selectedPosition > startOfRowPos && ((direction == FOCUS_LEFT && !isLayoutRtl) || (direction == FOCUS_RIGHT && isLayoutRtl))) {
        mLayoutMode = LAYOUT_MOVE_SELECTION;
        setSelectionInt(Math.max(0, selectedPosition - 1));
        moved = true;
    } else if (selectedPosition < endOfRowPos && ((direction == FOCUS_LEFT && isLayoutRtl) || (direction == FOCUS_RIGHT && !isLayoutRtl))) {
        mLayoutMode = LAYOUT_MOVE_SELECTION;
        setSelectionInt(Math.min(selectedPosition + 1, mItemCount - 1));
        moved = true;
    }
    if (moved) {
        playSoundEffect(SoundEffectConstants.getContantForFocusDirection(direction));
        invokeOnItemScrollListener();
    }
    if (moved) {
        awakenScrollBars();
    }
    return moved;
}
------------------------
Find a silently evolved API code:android.speech.tts.TextToSpeechService.SynthHandler.stopForApp:COMMENT
Method Modifier: public      
Comment:/**
 * Stops all speech output and removes any utterances still in the queue for
 * the calling app.
 *
 * Called on a service binder thread.
 */

Body of Frist Method:
{
    if (callerIdentity == null) {
        return TextToSpeech.ERROR;
    }
    removeCallbacksAndMessages(callerIdentity);
    // This stops writing data to the file / or publishing
    // items to the audio playback handler.
    // 
    // Note that the current speech item must be removed only if it
    // belongs to the callingApp, else the item will be "orphaned" and
    // not stopped correctly if a stop request comes along for the item
    // from the app it belongs to.
    SpeechItem current = maybeRemoveCurrentSpeechItem(callerIdentity);
    if (current != null) {
        current.stop();
    }
    // Remove any enqueued audio too.
    mAudioPlaybackHandler.stopForApp(callerIdentity);
    return TextToSpeech.SUCCESS;
}
Body of Second Method:
{
    if (callerIdentity == null) {
        return TextToSpeech.ERROR;
    }
    // Flush pending messages from callerIdentity
    startFlushingSpeechItems(callerIdentity);
    // This stops writing data to the file / or publishing
    // items to the audio playback handler.
    // 
    // Note that the current speech item must be removed only if it
    // belongs to the callingApp, else the item will be "orphaned" and
    // not stopped correctly if a stop request comes along for the item
    // from the app it belongs to.
    SpeechItem current = maybeRemoveCurrentSpeechItem(callerIdentity);
    if (current != null) {
        current.stop();
    }
    // Remove any enqueued audio too.
    mAudioPlaybackHandler.stopForApp(callerIdentity);
    // Stop flushing pending messages
    Runnable runnable = new Runnable() {

        @Override
        public void run() {
            endFlushingSpeechItems(callerIdentity);
        }
    };
    sendMessage(Message.obtain(this, runnable));
    return TextToSpeech.SUCCESS;
}
------------------------
Find a silently evolved API code:android.media.MediaFormat.setLong:COMMENT
Method Modifier: public      final       
Comment:/**
 * Sets the value of a long key.
 */

Body of Frist Method:
{
    mMap.put(name, new Long(value));
}
Body of Second Method:
{
    mMap.put(name, Long.valueOf(value));
}
------------------------
Find a silently evolved API code:android.app.FragmentManagerImpl.execPendingActions:COMMENT
Method Modifier: public      
Comment:/**
 * Only call from main thread!
 */

Body of Frist Method:
{
    if (mExecutingActions) {
        throw new IllegalStateException("Recursive entry to executePendingTransactions");
    }
    if (Looper.myLooper() != mActivity.mHandler.getLooper()) {
        throw new IllegalStateException("Must be called from main thread of process");
    }
    boolean didSomething = false;
    while (true) {
        int numActions;
        synchronized (this) {
            if (mPendingActions == null || mPendingActions.size() == 0) {
                break;
            }
            numActions = mPendingActions.size();
            if (mTmpActions == null || mTmpActions.length < numActions) {
                mTmpActions = new Runnable[numActions];
            }
            mPendingActions.toArray(mTmpActions);
            mPendingActions.clear();
            mActivity.mHandler.removeCallbacks(mExecCommit);
        }
        mExecutingActions = true;
        for (int i = 0; i < numActions; i++) {
            mTmpActions[i].run();
            mTmpActions[i] = null;
        }
        mExecutingActions = false;
        didSomething = true;
    }
    if (mHavePendingDeferredStart) {
        boolean loadersRunning = false;
        for (int i = 0; i < mActive.size(); i++) {
            Fragment f = mActive.get(i);
            if (f != null && f.mLoaderManager != null) {
                loadersRunning |= f.mLoaderManager.hasRunningLoaders();
            }
        }
        if (!loadersRunning) {
            mHavePendingDeferredStart = false;
            startPendingDeferredFragments();
        }
    }
    return didSomething;
}
Body of Second Method:
{
    if (mExecutingActions) {
        throw new IllegalStateException("Recursive entry to executePendingTransactions");
    }
    if (Looper.myLooper() != mHost.getHandler().getLooper()) {
        throw new IllegalStateException("Must be called from main thread of process");
    }
    boolean didSomething = false;
    while (true) {
        int numActions;
        synchronized (this) {
            if (mPendingActions == null || mPendingActions.size() == 0) {
                break;
            }
            numActions = mPendingActions.size();
            if (mTmpActions == null || mTmpActions.length < numActions) {
                mTmpActions = new Runnable[numActions];
            }
            mPendingActions.toArray(mTmpActions);
            mPendingActions.clear();
            mHost.getHandler().removeCallbacks(mExecCommit);
        }
        mExecutingActions = true;
        for (int i = 0; i < numActions; i++) {
            mTmpActions[i].run();
            mTmpActions[i] = null;
        }
        mExecutingActions = false;
        didSomething = true;
    }
    if (mHavePendingDeferredStart) {
        boolean loadersRunning = false;
        for (int i = 0; i < mActive.size(); i++) {
            Fragment f = mActive.get(i);
            if (f != null && f.mLoaderManager != null) {
                loadersRunning |= f.mLoaderManager.hasRunningLoaders();
            }
        }
        if (!loadersRunning) {
            mHavePendingDeferredStart = false;
            startPendingDeferredFragments();
        }
    }
    return didSomething;
}
------------------------
Find a silently evolved API code:android.media.AudioManager.startBluetoothSco:COMMENT
Method Modifier: public      
Comment:/**
 * Start bluetooth SCO audio connection.
 * <p>Requires Permission:
 * {@link android.Manifest.permission#MODIFY_AUDIO_SETTINGS}.
 * <p>This method can be used by applications wanting to send and received audio
 * to/from a bluetooth SCO headset while the phone is not in call.
 * <p>As the SCO connection establishment can take several seconds,
 * applications should not rely on the connection to be available when the method
 * returns but instead register to receive the intent {@link #ACTION_SCO_AUDIO_STATE_UPDATED}
 * and wait for the state to be {@link #SCO_AUDIO_STATE_CONNECTED}.
 * <p>As the ACTION_SCO_AUDIO_STATE_UPDATED intent is sticky, the application can check the SCO
 * audio state before calling startBluetoothSco() by reading the intent returned by the receiver
 * registration. If the state is already CONNECTED, no state change will be received via the
 * intent after calling startBluetoothSco(). It is however useful to call startBluetoothSco()
 * so that the connection stays active in case the current initiator stops the connection.
 * <p>Unless the connection is already active as described above, the state will always
 * transition from DISCONNECTED to CONNECTING and then either to CONNECTED if the connection
 * succeeds or back to DISCONNECTED if the connection fails (e.g no headset is connected).
 * <p>When finished with the SCO connection or if the establishment fails, the application must
 * call {@link #stopBluetoothSco()} to clear the request and turn down the bluetooth connection.
 * <p>Even if a SCO connection is established, the following restrictions apply on audio
 * output streams so that they can be routed to SCO headset:
 * <ul>
 * <li> the stream type must be {@link #STREAM_VOICE_CALL} </li>
 * <li> the format must be mono </li>
 * <li> the sampling must be 16kHz or 8kHz </li>
 * </ul>
 * <p>The following restrictions apply on input streams:
 * <ul>
 * <li> the format must be mono </li>
 * <li> the sampling must be 8kHz </li>
 * </ul>
 * <p>Note that the phone application always has the priority on the usage of the SCO
 * connection for telephony. If this method is called while the phone is in call
 * it will be ignored. Similarly, if a call is received or sent while an application
 * is using the SCO connection, the connection will be lost for the application and NOT
 * returned automatically when the call ends.
 * <p>NOTE: up to and including API version
 * {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1}, this method initiates a virtual
 * voice call to the bluetooth headset.
 * After API version {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2} only a raw SCO audio
 * connection is established.
 * @see #stopBluetoothSco()
 * @see #ACTION_SCO_AUDIO_STATE_UPDATED
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        service.startBluetoothSco(mICallBack, mContext.getApplicationInfo().targetSdkVersion);
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in startBluetoothSco", e);
    }
}
Body of Second Method:
{
    IAudioService service = getService();
    try {
        service.startBluetoothSco(mICallBack, getContext().getApplicationInfo().targetSdkVersion);
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in startBluetoothSco", e);
    }
}
------------------------
Find a silently evolved API code:android.widget.LinearLayout.hasDividerBeforeChildAt:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * Determines where to position dividers between children.
 *
 * @param childIndex Index of child to check for preceding divider
 * @return true if there should be a divider before the child at childIndex
 * @hide Pending API consideration. Currently only used internally by the system.
 */

Body of Frist Method:
{
    if (childIndex == 0) {
        return (mShowDividers & SHOW_DIVIDER_BEGINNING) != 0;
    } else if (childIndex == getChildCount()) {
        return (mShowDividers & SHOW_DIVIDER_END) != 0;
    } else if ((mShowDividers & SHOW_DIVIDER_MIDDLE) != 0) {
        boolean hasVisibleViewBefore = false;
        for (int i = childIndex - 1; i >= 0; i--) {
            if (getChildAt(i).getVisibility() != GONE) {
                hasVisibleViewBefore = true;
                break;
            }
        }
        return hasVisibleViewBefore;
    }
    return false;
}
Body of Second Method:
{
    if (childIndex == getVirtualChildCount()) {
        // Check whether the end divider should draw.
        return (mShowDividers & SHOW_DIVIDER_END) != 0;
    }
    boolean allViewsAreGoneBefore = allViewsAreGoneBefore(childIndex);
    if (allViewsAreGoneBefore) {
        // This is the first view that's not gone, check if beginning divider is enabled.
        return (mShowDividers & SHOW_DIVIDER_BEGINNING) != 0;
    } else {
        return (mShowDividers & SHOW_DIVIDER_MIDDLE) != 0;
    }
}
------------------------
Find a silently evolved API code:android.content.ContentResolver.releasePersistableUriPermission:COMMENT
Method Modifier: public      
Comment:/**
 * Relinquish a persisted URI permission grant. The URI must have been
 * previously made persistent with
 * {@link #takePersistableUriPermission(Uri, int)}. Any non-persistent
 * grants to the calling package will remain intact.
 *
 * @see #getPersistedUriPermissions()
 */

Body of Frist Method:
{
    try {
        ActivityManagerNative.getDefault().releasePersistableUriPermission(ContentProvider.getUriWithoutUserId(uri), modeFlags, resolveUserId(uri));
    } catch (RemoteException e) {
    }
}
Body of Second Method:
{
    Preconditions.checkNotNull(uri, "uri");
    try {
        ActivityManagerNative.getDefault().releasePersistableUriPermission(ContentProvider.getUriWithoutUserId(uri), modeFlags, resolveUserId(uri));
    } catch (RemoteException e) {
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothAdapter.enable:COMMENT
Method Modifier: public      
Comment:/**
 * Turn on the local Bluetooth adapter&mdash;do not use without explicit
 * user action to turn on Bluetooth.
 * <p>This powers on the underlying Bluetooth hardware, and starts all
 * Bluetooth system services.
 * <p class="caution"><strong>Bluetooth should never be enabled without
 * direct user consent</strong>. If you want to turn on Bluetooth in order
 * to create a wireless connection, you should use the {@link
 * #ACTION_REQUEST_ENABLE} Intent, which will raise a dialog that requests
 * user permission to turn on Bluetooth. The {@link #enable()} method is
 * provided only for applications that include a user interface for changing
 * system settings, such as a "power manager" app.</p>
 * <p>This is an asynchronous call: it will return immediately, and
 * clients should listen for {@link #ACTION_STATE_CHANGED}
 * to be notified of subsequent adapter state changes. If this call returns
 * true, then the adapter state will immediately transition from {@link
 * #STATE_OFF} to {@link #STATE_TURNING_ON}, and some time
 * later transition to either {@link #STATE_OFF} or {@link
 * #STATE_ON}. If this call returns false then there was an
 * immediate problem that will prevent the adapter from being turned on -
 * such as Airplane mode, or the adapter is already turned on.
 * <p>Requires the {@link android.Manifest.permission#BLUETOOTH_ADMIN}
 * permission
 *
 * @return true to indicate adapter startup has begun, or false on
 * immediate error
 */

Body of Frist Method:
{
    if (isEnabled() == true) {
        if (DBG)
            Log.d(TAG, "enable(): BT is already enabled..!");
        return true;
    }
    try {
        return mManagerService.enable();
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
Body of Second Method:
{
    int state = STATE_OFF;
    if (isEnabled() == true) {
        if (DBG)
            Log.d(TAG, "enable(): BT is already enabled..!");
        return true;
    }
    // Use service interface to get the exact state
    if (mService != null) {
        try {
            state = mService.getState();
        } catch (RemoteException e) {
            Log.e(TAG, "", e);
        }
    }
    if (state == BluetoothAdapter.STATE_BLE_ON) {
        Log.e(TAG, "BT is in BLE_ON State");
        notifyUserAction(true);
        return true;
    }
    try {
        return mManagerService.enable();
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
------------------------
Find a silently evolved API code:android.webkit.WebView.savePicture:COMMENT
Method Modifier: public      hidden      deprecated  
Comment:/**
 * Saves the current display data to the Bundle given. Used in conjunction
 * with {@link #saveState}.
 * @param b a Bundle to store the display data
 * @param dest the file to store the serialized picture data. Will be
 * overwritten with this WebView's picture data.
 * @return true if the picture was successfully saved
 * @deprecated This method is now obsolete.
 * @hide Since API level {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1}
 */

Body of Frist Method:
{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, "savePicture=" + dest.getName());
    return mProvider.savePicture(b, dest);
}
Body of Second Method:
{
    checkThread();
    return mProvider.savePicture(b, dest);
}
------------------------
Find a silently evolved API code:android.net.http.HttpResponseCache.close:COMMENT
Method Modifier: public      
Comment:/**
 * Uninstalls the cache and releases any active resources. Stored contents
 * will remain on the filesystem.
 */

Body of Frist Method:
{
    if (ResponseCache.getDefault() == this.delegate) {
        ResponseCache.setDefault(null);
    }
    delegate.close();
}
Body of Second Method:
{
    if (ResponseCache.getDefault() == this) {
        ResponseCache.setDefault(null);
    }
    delegate.close();
}
------------------------
Find a silently evolved API code:android.widget.MediaController.disableUnsupportedButtons:COMMENT
Method Modifier: private     
Comment:/**
 * Disable pause or seek buttons if the stream cannot be paused or seeked.
 * This requires the control interface to be a MediaPlayerControlExt
 */

Body of Frist Method:
{
    try {
        if (mPauseButton != null && !mPlayer.canPause()) {
            mPauseButton.setEnabled(false);
        }
        if (mRewButton != null && !mPlayer.canSeekBackward()) {
            mRewButton.setEnabled(false);
        }
        if (mFfwdButton != null && !mPlayer.canSeekForward()) {
            mFfwdButton.setEnabled(false);
        }
    } catch (IncompatibleClassChangeError ex) {
    // We were given an old version of the interface, that doesn't have
    // the canPause/canSeekXYZ methods. This is OK, it just means we
    // assume the media can be paused and seeked, and so we don't disable
    // the buttons.
    }
}
Body of Second Method:
{
    try {
        if (mPauseButton != null && !mPlayer.canPause()) {
            mPauseButton.setEnabled(false);
        }
        if (mRewButton != null && !mPlayer.canSeekBackward()) {
            mRewButton.setEnabled(false);
        }
        if (mFfwdButton != null && !mPlayer.canSeekForward()) {
            mFfwdButton.setEnabled(false);
        }
        // shouldn't arise in existing applications.
        if (mProgress != null && !mPlayer.canSeekBackward() && !mPlayer.canSeekForward()) {
            mProgress.setEnabled(false);
        }
    } catch (IncompatibleClassChangeError ex) {
    // We were given an old version of the interface, that doesn't have
    // the canPause/canSeekXYZ methods. This is OK, it just means we
    // assume the media can be paused and seeked, and so we don't disable
    // the buttons.
    }
}
------------------------
Find a silently evolved API code:android.graphics.Bitmap.getConfig:COMMENT
Method Modifier: public      final       
Comment:/**
 * If the bitmap's internal config is in one of the public formats, return
 * that config, otherwise return null.
 */

Body of Frist Method:
{
    return Config.nativeToConfig(nativeConfig(mNativeBitmap));
}
Body of Second Method:
{
    if (mRecycled) {
        Log.w(TAG, "Called getConfig() on a recycle()'d bitmap! This is undefined behavior!");
    }
    return Config.nativeToConfig(nativeConfig(mFinalizer.mNativeBitmap));
}
------------------------
Find a silently evolved API code:android.graphics.Bitmap.recycle:COMMENT
Method Modifier: public      
Comment:/**
 * Free the native object associated with this bitmap, and clear the
 * reference to the pixel data. This will not free the pixel data synchronously;
 * it simply allows it to be garbage collected if there are no other references.
 * The bitmap is marked as "dead", meaning it will throw an exception if
 * getPixels() or setPixels() is called, and will draw nothing. This operation
 * cannot be reversed, so it should only be called if you are sure there are no
 * further uses for the bitmap. This is an advanced call, and normally need
 * not be called, since the normal GC process will free up this memory when
 * there are no more references to this bitmap.
 */

Body of Frist Method:
{
    if (!mRecycled && mFinalizer.mNativeBitmap != 0) {
        if (nativeRecycle(mNativeBitmap)) {
            // return value indicates whether native pixel object was actually recycled.
            // false indicates that it is still in use at the native level and these
            // objects should not be collected now. They will be collected later when the
            // Bitmap itself is collected.
            mBuffer = null;
            mNinePatchChunk = null;
        }
        mRecycled = true;
    }
}
Body of Second Method:
{
    if (!mRecycled && mFinalizer.mNativeBitmap != 0) {
        if (nativeRecycle(mFinalizer.mNativeBitmap)) {
            // return value indicates whether native pixel object was actually recycled.
            // false indicates that it is still in use at the native level and these
            // objects should not be collected now. They will be collected later when the
            // Bitmap itself is collected.
            mBuffer = null;
            mNinePatchChunk = null;
        }
        mRecycled = true;
    }
}
------------------------
Find a silently evolved API code:android.app.Instrumentation.execStartActivitiesAsUser:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Like {@link #execStartActivity(Context, IBinder, IBinder, Activity, Intent, int, Bundle)},
 * but accepts an array of activities to be started.  Note that active
 * {@link ActivityMonitor} objects only match against the first activity in
 * the array.
 *
 * {@hide}
 */

Body of Frist Method:
{
    IApplicationThread whoThread = (IApplicationThread) contextThread;
    if (mActivityMonitors != null) {
        synchronized (mSync) {
            final int N = mActivityMonitors.size();
            for (int i = 0; i < N; i++) {
                final ActivityMonitor am = mActivityMonitors.get(i);
                if (am.match(who, null, intents[0])) {
                    am.mHits++;
                    if (am.isBlocking()) {
                        return;
                    }
                    break;
                }
            }
        }
    }
    try {
        String[] resolvedTypes = new String[intents.length];
        for (int i = 0; i < intents.length; i++) {
            intents[i].migrateExtraStreamToClipData();
            intents[i].prepareToLeaveProcess();
            resolvedTypes[i] = intents[i].resolveTypeIfNeeded(who.getContentResolver());
        }
        int result = ActivityManagerNative.getDefault().startActivities(whoThread, who.getBasePackageName(), intents, resolvedTypes, token, options, userId);
        checkStartActivityResult(result, intents[0]);
    } catch (RemoteException e) {
    }
}
Body of Second Method:
{
    IApplicationThread whoThread = (IApplicationThread) contextThread;
    if (mActivityMonitors != null) {
        synchronized (mSync) {
            final int N = mActivityMonitors.size();
            for (int i = 0; i < N; i++) {
                final ActivityMonitor am = mActivityMonitors.get(i);
                if (am.match(who, null, intents[0])) {
                    am.mHits++;
                    if (am.isBlocking()) {
                        return;
                    }
                    break;
                }
            }
        }
    }
    try {
        String[] resolvedTypes = new String[intents.length];
        for (int i = 0; i < intents.length; i++) {
            intents[i].migrateExtraStreamToClipData();
            intents[i].prepareToLeaveProcess();
            resolvedTypes[i] = intents[i].resolveTypeIfNeeded(who.getContentResolver());
        }
        int result = ActivityManagerNative.getDefault().startActivities(whoThread, who.getBasePackageName(), intents, resolvedTypes, token, options, userId);
        checkStartActivityResult(result, intents[0]);
    } catch (RemoteException e) {
        throw new RuntimeException("Failure from system", e);
    }
}
------------------------
Find a silently evolved API code:android.telephony.SubscriptionManager.getActiveSubscriptionInfoList:COMMENT
Method Modifier: public      
Comment:/**
 * Get the SubscriptionInfo(s) of the currently inserted SIM(s). The records will be sorted
 * by {@link SubscriptionInfo#getSimSlotIndex} then by {@link SubscriptionInfo#getSubscriptionId}.
 *
 * @return Sorted list of the currently {@link SubscriptionInfo} records available on the device.
 * <ul>
 * <li>
 * If null is returned the current state is unknown but if a {@link OnSubscriptionsChangedListener}
 * has been registered {@link OnSubscriptionsChangedListener#onSubscriptionsChanged} will be
 * invoked in the future.
 * </li>
 * <li>
 * If the list is empty then there are no {@link SubscriptionInfo} records currently available.
 * </li>
 * <li>
 * if the list is non-empty the list is sorted by {@link SubscriptionInfo#getSimSlotIndex}
 * then by {@link SubscriptionInfo#getSubscriptionId}.
 * </li>
 * </ul>
 */

Body of Frist Method:
{
    List<SubscriptionInfo> result = null;
    try {
        ISub iSub = ISub.Stub.asInterface(ServiceManager.getService("isub"));
        if (iSub != null) {
            result = iSub.getActiveSubscriptionInfoList();
        }
    } catch (RemoteException ex) {
    // ignore it
    }
    return result;
}
Body of Second Method:
{
    List<SubscriptionInfo> result = null;
    try {
        ISub iSub = ISub.Stub.asInterface(ServiceManager.getService("isub"));
        if (iSub != null) {
            result = iSub.getActiveSubscriptionInfoList(mContext.getOpPackageName());
        }
    } catch (RemoteException ex) {
    // ignore it
    }
    return result;
}
------------------------
Find a silently evolved API code:android.app.Fragment.isAdded:COMMENT
Method Modifier: public      final       
Comment:/**
 * Return true if the fragment is currently added to its activity.
 */

Body of Frist Method:
{
    return mActivity != null && mAdded;
}
Body of Second Method:
{
    return mHost != null && mAdded;
}
------------------------
Find a silently evolved API code:android.view.HardwareLayer.setLayerPaint:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Update the paint used when drawing this layer.
 *
 * @param paint The paint used when the layer is drawn into the destination canvas.
 * @see View#setLayerPaint(android.graphics.Paint)
 */

Body of Frist Method:
{
    nSetLayerPaint(mFinalizer.get(), paint.mNativePaint);
    mRenderer.pushLayerUpdate(this);
}
Body of Second Method:
{
    nSetLayerPaint(mFinalizer.get(), paint.getNativeInstance());
    mRenderer.pushLayerUpdate(this);
}
------------------------
Find a silently evolved API code:android.media.AudioManager.getStreamVolume:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the current volume index for a particular stream.
 *
 * @param streamType The stream type whose volume index is returned.
 * @return The current volume index for the stream.
 * @see #getStreamMaxVolume(int)
 * @see #setStreamVolume(int, int, int)
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        if (mUseMasterVolume) {
            return service.getMasterVolume();
        } else {
            return service.getStreamVolume(streamType);
        }
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in getStreamVolume", e);
        return 0;
    }
}
Body of Second Method:
{
    IAudioService service = getService();
    try {
        return service.getStreamVolume(streamType);
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in getStreamVolume", e);
        return 0;
    }
}
------------------------
Find a silently evolved API code:android.hardware.camera2.CaptureRequest.readFromParcel:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Expand this object from a Parcel.
 * Hidden since this breaks the immutability of CaptureRequest, but is
 * needed to receive CaptureRequests with aidl.
 *
 * @param in The parcel from which the object should be read
 * @hide
 */

Body of Frist Method:
{
    mSettings.readFromParcel(in);
    mSurfaceSet.clear();
    Parcelable[] parcelableArray = in.readParcelableArray(Surface.class.getClassLoader());
    if (parcelableArray == null) {
        return;
    }
    for (Parcelable p : parcelableArray) {
        Surface s = (Surface) p;
        mSurfaceSet.add(s);
    }
}
Body of Second Method:
{
    mSettings.readFromParcel(in);
    mSurfaceSet.clear();
    Parcelable[] parcelableArray = in.readParcelableArray(Surface.class.getClassLoader());
    if (parcelableArray == null) {
        return;
    }
    for (Parcelable p : parcelableArray) {
        Surface s = (Surface) p;
        mSurfaceSet.add(s);
    }
    mIsReprocess = (in.readInt() == 0) ? false : true;
    mReprocessableSessionId = CameraCaptureSession.SESSION_ID_NONE;
}
------------------------
Find a silently evolved API code:android.preference.Preference.persistString:COMMENT
Method Modifier: protected   
Comment:/**
 * Attempts to persist a String to the {@link android.content.SharedPreferences}.
 * <p>
 * This will check if this Preference is persistent, get an editor from
 * the {@link PreferenceManager}, put in the string, and check if we should commit (and
 * commit if so).
 *
 * @param value The value to persist.
 * @return True if the Preference is persistent. (This is not whether the
 * value was persisted, since we may not necessarily commit if there
 * will be a batch commit later.)
 * @see #getPersistedString(String)
 */

Body of Frist Method:
{
    if (shouldPersist()) {
        // Shouldn't store null
        if (value == getPersistedString(null)) {
            // It's already there, so the same as persisting
            return true;
        }
        SharedPreferences.Editor editor = mPreferenceManager.getEditor();
        editor.putString(mKey, value);
        tryCommit(editor);
        return true;
    }
    return false;
}
Body of Second Method:
{
    if (shouldPersist()) {
        // Shouldn't store null
        if (TextUtils.equals(value, getPersistedString(null))) {
            // It's already there, so the same as persisting
            return true;
        }
        SharedPreferences.Editor editor = mPreferenceManager.getEditor();
        editor.putString(mKey, value);
        tryCommit(editor);
        return true;
    }
    return false;
}
------------------------
Find a silently evolved API code:android.graphics.drawable.LayerDrawable.inflateLayers:COMMENT
Method Modifier: private     
Comment:/**
 * Inflates child layers using the specified parser.
 */

Body of Frist Method:
{
    final LayerState state = mLayerState;
    final int innerDepth = parser.getDepth() + 1;
    int type;
    int depth;
    while ((type = parser.next()) != XmlPullParser.END_DOCUMENT && ((depth = parser.getDepth()) >= innerDepth || type != XmlPullParser.END_TAG)) {
        if (type != XmlPullParser.START_TAG) {
            continue;
        }
        if (depth > innerDepth || !parser.getName().equals("item")) {
            continue;
        }
        final ChildDrawable layer = new ChildDrawable();
        final TypedArray a = obtainAttributes(r, theme, attrs, R.styleable.LayerDrawableItem);
        updateLayerFromTypedArray(layer, a);
        a.recycle();
        if (layer.mDrawable == null) {
            while ((type = parser.next()) == XmlPullParser.TEXT) {
            }
            if (type != XmlPullParser.START_TAG) {
                throw new XmlPullParserException(parser.getPositionDescription() + ": <item> tag requires a 'drawable' attribute or " + "child tag defining a drawable");
            }
            layer.mDrawable = Drawable.createFromXmlInner(r, parser, attrs, theme);
        }
        if (layer.mDrawable != null) {
            state.mChildrenChangingConfigurations |= layer.mDrawable.getChangingConfigurations();
            layer.mDrawable.setCallback(this);
        }
        addLayer(layer);
    }
}
Body of Second Method:
{
    final LayerState state = mLayerState;
    final int innerDepth = parser.getDepth() + 1;
    int type;
    int depth;
    while ((type = parser.next()) != XmlPullParser.END_DOCUMENT && ((depth = parser.getDepth()) >= innerDepth || type != XmlPullParser.END_TAG)) {
        if (type != XmlPullParser.START_TAG) {
            continue;
        }
        if (depth > innerDepth || !parser.getName().equals("item")) {
            continue;
        }
        final ChildDrawable layer = new ChildDrawable();
        final TypedArray a = obtainAttributes(r, theme, attrs, R.styleable.LayerDrawableItem);
        updateLayerFromTypedArray(layer, a);
        a.recycle();
        // element.
        if (layer.mDrawable == null && (layer.mThemeAttrs == null || layer.mThemeAttrs[R.styleable.LayerDrawableItem_drawable] == 0)) {
            while ((type = parser.next()) == XmlPullParser.TEXT) {
            }
            if (type != XmlPullParser.START_TAG) {
                throw new XmlPullParserException(parser.getPositionDescription() + ": <item> tag requires a 'drawable' attribute or " + "child tag defining a drawable");
            }
            layer.mDrawable = Drawable.createFromXmlInner(r, parser, attrs, theme);
        }
        if (layer.mDrawable != null) {
            state.mChildrenChangingConfigurations |= layer.mDrawable.getChangingConfigurations();
            layer.mDrawable.setCallback(this);
        }
        addLayer(layer);
    }
}
------------------------
Find a silently evolved API code:android.webkit.WebView.onPause:COMMENT
Method Modifier: public      
Comment:/**
 * Pauses any extra processing associated with this WebView and its
 * associated DOM, plugins, JavaScript etc. For example, if this WebView is
 * taken offscreen, this could be called to reduce unnecessary CPU or
 * network traffic. When this WebView is again "active", call onResume().
 * Note that this differs from pauseTimers(), which affects all WebViews.
 */

Body of Frist Method:
{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, "onPause");
    mProvider.onPause();
}
Body of Second Method:
{
    checkThread();
    mProvider.onPause();
}
------------------------
Find a silently evolved API code:android.os.ParcelFileDescriptor.open:COMMENT
Method Modifier: public      static      
Comment:/**
 * Create a new ParcelFileDescriptor accessing a given file.
 *
 * @param file The file to be opened.
 * @param mode The desired access mode, must be one of
 * {@link #MODE_READ_ONLY}, {@link #MODE_WRITE_ONLY}, or
 * {@link #MODE_READ_WRITE}; may also be any combination of
 * {@link #MODE_CREATE}, {@link #MODE_TRUNCATE},
 * {@link #MODE_WORLD_READABLE}, and
 * {@link #MODE_WORLD_WRITEABLE}.
 * @param handler to call listener from; must not be null.
 * @param listener to be invoked when the returned descriptor has been
 * closed; must not be null.
 * @return a new ParcelFileDescriptor pointing to the given file.
 * @throws FileNotFoundException if the given file does not exist or can not
 * be opened with the requested mode.
 * @see #parseMode(String)
 */

Body of Frist Method:
{
    if (handler == null) {
        throw new IllegalArgumentException("Handler must not be null");
    }
    if (listener == null) {
        throw new IllegalArgumentException("Listener must not be null");
    }
    final FileDescriptor fd = openInternal(file, mode);
    if (fd == null)
        return null;
    final FileDescriptor[] comm = createCommSocketPair();
    final ParcelFileDescriptor pfd = new ParcelFileDescriptor(fd, comm[0]);
    // Kick off thread to watch for status updates
    IoUtils.setBlocking(comm[1], true);
    final ListenerBridge bridge = new ListenerBridge(comm[1], handler.getLooper(), listener);
    bridge.start();
    return pfd;
}
Body of Second Method:
{
    if (handler == null) {
        throw new IllegalArgumentException("Handler must not be null");
    }
    if (listener == null) {
        throw new IllegalArgumentException("Listener must not be null");
    }
    final FileDescriptor fd = openInternal(file, mode);
    if (fd == null)
        return null;
    final FileDescriptor[] comm = createCommSocketPair();
    final ParcelFileDescriptor pfd = new ParcelFileDescriptor(fd, comm[0]);
    final MessageQueue queue = handler.getLooper().getQueue();
    queue.addOnFileDescriptorEventListener(comm[1], OnFileDescriptorEventListener.EVENT_INPUT, new OnFileDescriptorEventListener() {

        @Override
        public int onFileDescriptorEvents(FileDescriptor fd, int events) {
            Status status = null;
            if ((events & OnFileDescriptorEventListener.EVENT_INPUT) != 0) {
                final byte[] buf = new byte[MAX_STATUS];
                status = readCommStatus(fd, buf);
            } else if ((events & OnFileDescriptorEventListener.EVENT_ERROR) != 0) {
                status = new Status(Status.DEAD);
            }
            if (status != null) {
                queue.removeOnFileDescriptorEventListener(fd);
                IoUtils.closeQuietly(fd);
                listener.onClose(status.asIOException());
                return 0;
            }
            return EVENT_INPUT;
        }
    });
    return pfd;
}
------------------------
Find a silently evolved API code:android.telephony.ServiceState.isGsm:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return radioTechnology == RIL_RADIO_TECHNOLOGY_GPRS || radioTechnology == RIL_RADIO_TECHNOLOGY_EDGE || radioTechnology == RIL_RADIO_TECHNOLOGY_UMTS || radioTechnology == RIL_RADIO_TECHNOLOGY_HSDPA || radioTechnology == RIL_RADIO_TECHNOLOGY_HSUPA || radioTechnology == RIL_RADIO_TECHNOLOGY_HSPA || radioTechnology == RIL_RADIO_TECHNOLOGY_LTE || radioTechnology == RIL_RADIO_TECHNOLOGY_HSPAP || radioTechnology == RIL_RADIO_TECHNOLOGY_GSM || radioTechnology == RIL_RADIO_TECHNOLOGY_TD_SCDMA;
}
Body of Second Method:
{
    return radioTechnology == RIL_RADIO_TECHNOLOGY_GPRS || radioTechnology == RIL_RADIO_TECHNOLOGY_EDGE || radioTechnology == RIL_RADIO_TECHNOLOGY_UMTS || radioTechnology == RIL_RADIO_TECHNOLOGY_HSDPA || radioTechnology == RIL_RADIO_TECHNOLOGY_HSUPA || radioTechnology == RIL_RADIO_TECHNOLOGY_HSPA || radioTechnology == RIL_RADIO_TECHNOLOGY_LTE || radioTechnology == RIL_RADIO_TECHNOLOGY_HSPAP || radioTechnology == RIL_RADIO_TECHNOLOGY_GSM || radioTechnology == RIL_RADIO_TECHNOLOGY_TD_SCDMA || radioTechnology == RIL_RADIO_TECHNOLOGY_IWLAN;
}
------------------------
Find a silently evolved API code:android.app.ActivityManager.RunningAppProcessInfo.procStateToImportance:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (procState >= ActivityManager.PROCESS_STATE_HOME) {
        return ActivityManager.RunningAppProcessInfo.IMPORTANCE_BACKGROUND;
    } else if (procState >= ActivityManager.PROCESS_STATE_SERVICE) {
        return ActivityManager.RunningAppProcessInfo.IMPORTANCE_SERVICE;
    } else if (procState > ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) {
        return ActivityManager.RunningAppProcessInfo.IMPORTANCE_CANT_SAVE_STATE;
    } else if (procState >= ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
        return ActivityManager.RunningAppProcessInfo.IMPORTANCE_PERCEPTIBLE;
    } else if (procState >= ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND) {
        return ActivityManager.RunningAppProcessInfo.IMPORTANCE_VISIBLE;
    } else {
        return ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND;
    }
}
Body of Second Method:
{
    if (procState == PROCESS_STATE_NONEXISTENT) {
        return IMPORTANCE_GONE;
    } else if (procState >= PROCESS_STATE_HOME) {
        return IMPORTANCE_BACKGROUND;
    } else if (procState >= PROCESS_STATE_SERVICE) {
        return IMPORTANCE_SERVICE;
    } else if (procState > PROCESS_STATE_HEAVY_WEIGHT) {
        return IMPORTANCE_CANT_SAVE_STATE;
    } else if (procState >= PROCESS_STATE_IMPORTANT_BACKGROUND) {
        return IMPORTANCE_PERCEPTIBLE;
    } else if (procState >= PROCESS_STATE_IMPORTANT_FOREGROUND) {
        return IMPORTANCE_VISIBLE;
    } else if (procState >= PROCESS_STATE_TOP_SLEEPING) {
        return IMPORTANCE_TOP_SLEEPING;
    } else if (procState >= PROCESS_STATE_FOREGROUND_SERVICE) {
        return IMPORTANCE_FOREGROUND_SERVICE;
    } else {
        return IMPORTANCE_FOREGROUND;
    }
}
------------------------
Find a silently evolved API code:android.app.WallpaperManager.forgetLoadedWallpaper:COMMENT
Method Modifier: public      
Comment:/**
 * Remove all internal references to the last loaded wallpaper.  Useful
 * for apps that want to reduce memory usage when they only temporarily
 * need to have the wallpaper.  After calling, the next request for the
 * wallpaper will require reloading it again from disk.
 */

Body of Frist Method:
{
    sGlobals.forgetLoadedWallpaper();
}
Body of Second Method:
{
    if (isWallpaperSupported()) {
        sGlobals.forgetLoadedWallpaper();
    }
}
------------------------
Find a silently evolved API code:android.media.MediaFormat.setInteger:COMMENT
Method Modifier: public      final       
Comment:/**
 * Sets the value of an integer key.
 */

Body of Frist Method:
{
    mMap.put(name, new Integer(value));
}
Body of Second Method:
{
    mMap.put(name, Integer.valueOf(value));
}
------------------------
Find a silently evolved API code:android.graphics.drawable.NinePatchDrawable.updateStateFromTypedArray:COMMENT
Method Modifier: private     
Comment:/**
 * Updates the constant state from the values in the typed array.
 */

Body of Frist Method:
{
    final Resources r = a.getResources();
    final NinePatchState state = mNinePatchState;
    // Account for any configuration changes.
    state.mChangingConfigurations |= a.getChangingConfigurations();
    // Extract the theme attributes, if any.
    state.mThemeAttrs = a.extractThemeAttrs();
    state.mDither = a.getBoolean(R.styleable.NinePatchDrawable_dither, state.mDither);
    final int srcResId = a.getResourceId(R.styleable.NinePatchDrawable_src, 0);
    if (srcResId != 0) {
        final BitmapFactory.Options options = new BitmapFactory.Options();
        options.inDither = !state.mDither;
        options.inScreenDensity = r.getDisplayMetrics().noncompatDensityDpi;
        final Rect padding = new Rect();
        final Rect opticalInsets = new Rect();
        Bitmap bitmap = null;
        try {
            final TypedValue value = new TypedValue();
            final InputStream is = r.openRawResource(srcResId, value);
            bitmap = BitmapFactory.decodeResourceStream(r, value, is, padding, options);
            is.close();
        } catch (IOException e) {
        // Ignore
        }
        if (bitmap == null) {
            throw new XmlPullParserException(a.getPositionDescription() + ": <nine-patch> requires a valid src attribute");
        } else if (bitmap.getNinePatchChunk() == null) {
            throw new XmlPullParserException(a.getPositionDescription() + ": <nine-patch> requires a valid 9-patch source image");
        }
        bitmap.getOpticalInsets(opticalInsets);
        state.mNinePatch = new NinePatch(bitmap, bitmap.getNinePatchChunk());
        state.mPadding = padding;
        state.mOpticalInsets = Insets.of(opticalInsets);
    }
    state.mAutoMirrored = a.getBoolean(R.styleable.NinePatchDrawable_autoMirrored, state.mAutoMirrored);
    state.mBaseAlpha = a.getFloat(R.styleable.NinePatchDrawable_alpha, state.mBaseAlpha);
    final int tintMode = a.getInt(R.styleable.NinePatchDrawable_tintMode, -1);
    if (tintMode != -1) {
        state.mTintMode = Drawable.parseTintMode(tintMode, Mode.SRC_IN);
    }
    final ColorStateList tint = a.getColorStateList(R.styleable.NinePatchDrawable_tint);
    if (tint != null) {
        state.mTint = tint;
    }
    // Update local properties.
    initializeWithState(state, r);
    // Push density applied by setNinePatchState into state.
    state.mTargetDensity = mTargetDensity;
}
Body of Second Method:
{
    final Resources r = a.getResources();
    final NinePatchState state = mNinePatchState;
    // Account for any configuration changes.
    state.mChangingConfigurations |= a.getChangingConfigurations();
    // Extract the theme attributes, if any.
    state.mThemeAttrs = a.extractThemeAttrs();
    state.mDither = a.getBoolean(R.styleable.NinePatchDrawable_dither, state.mDither);
    final int srcResId = a.getResourceId(R.styleable.NinePatchDrawable_src, 0);
    if (srcResId != 0) {
        final BitmapFactory.Options options = new BitmapFactory.Options();
        options.inDither = !state.mDither;
        options.inScreenDensity = r.getDisplayMetrics().noncompatDensityDpi;
        final Rect padding = new Rect();
        final Rect opticalInsets = new Rect();
        Bitmap bitmap = null;
        try {
            final TypedValue value = new TypedValue();
            final InputStream is = r.openRawResource(srcResId, value);
            bitmap = BitmapFactory.decodeResourceStream(r, value, is, padding, options);
            is.close();
        } catch (IOException e) {
        // Ignore
        }
        if (bitmap == null) {
            throw new XmlPullParserException(a.getPositionDescription() + ": <nine-patch> requires a valid src attribute");
        } else if (bitmap.getNinePatchChunk() == null) {
            throw new XmlPullParserException(a.getPositionDescription() + ": <nine-patch> requires a valid 9-patch source image");
        }
        bitmap.getOpticalInsets(opticalInsets);
        state.mNinePatch = new NinePatch(bitmap, bitmap.getNinePatchChunk());
        state.mPadding = padding;
        state.mOpticalInsets = Insets.of(opticalInsets);
    }
    state.mAutoMirrored = a.getBoolean(R.styleable.NinePatchDrawable_autoMirrored, state.mAutoMirrored);
    state.mBaseAlpha = a.getFloat(R.styleable.NinePatchDrawable_alpha, state.mBaseAlpha);
    final int tintMode = a.getInt(R.styleable.NinePatchDrawable_tintMode, -1);
    if (tintMode != -1) {
        state.mTintMode = Drawable.parseTintMode(tintMode, Mode.SRC_IN);
    }
    final ColorStateList tint = a.getColorStateList(R.styleable.NinePatchDrawable_tint);
    if (tint != null) {
        state.mTint = tint;
    }
    final int densityDpi = r.getDisplayMetrics().densityDpi;
    state.mTargetDensity = densityDpi == 0 ? DisplayMetrics.DENSITY_DEFAULT : densityDpi;
}
------------------------
Find a silently evolved API code:android.content.ContentProviderClient.call:COMMENT
Method Modifier: public      
Comment:/**
 * See {@link ContentProvider#call(String, String, Bundle)}
 */

Body of Frist Method:
{
    beforeRemote();
    try {
        return mContentProvider.call(mPackageName, method, arg, extras);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}
Body of Second Method:
{
    Preconditions.checkNotNull(method, "method");
    beforeRemote();
    try {
        return mContentProvider.call(mPackageName, method, arg, extras);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}
------------------------
Find a silently evolved API code:android.app.Fragment.getLayoutInflater:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide Hack so that DialogFragment can make its Dialog before creating
 * its views, and the view construction can use the dialog's context for
 * inflation.  Maybe this should become a public API. Note sure.
 */

Body of Frist Method:
{
    // Newer platform versions use the child fragment manager's LayoutInflaterFactory.
    if (mActivity.getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.LOLLIPOP) {
        LayoutInflater result = mActivity.getLayoutInflater().cloneInContext(mActivity);
        // Init if needed; use raw implementation below.
        getChildFragmentManager();
        result.setPrivateFactory(mChildFragmentManager.getLayoutInflaterFactory());
        return result;
    } else {
        return mActivity.getLayoutInflater();
    }
}
Body of Second Method:
{
    final LayoutInflater result = mHost.onGetLayoutInflater();
    if (mHost.onUseFragmentManagerInflaterFactory()) {
        // Init if needed; use raw implementation below.
        getChildFragmentManager();
        result.setPrivateFactory(mChildFragmentManager.getLayoutInflaterFactory());
    }
    return result;
}
------------------------
Find a silently evolved API code:android.app.AlarmManager.setAlarmClock:COMMENT
Method Modifier: public      
Comment:/**
 * Schedule an alarm that represents an alarm clock.
 *
 * The system may choose to display information about this alarm to the user.
 *
 * <p>
 * This method is like {@link #setExact(int, long, PendingIntent)}, but implies
 * {@link #RTC_WAKEUP}.
 *
 * @param info
 * @param operation Action to perform when the alarm goes off;
 * typically comes from {@link PendingIntent#getBroadcast
 * IntentSender.getBroadcast()}.
 *
 * @see #set
 * @see #setRepeating
 * @see #setWindow
 * @see #setExact
 * @see #cancel
 * @see #getNextAlarmClock()
 * @see android.content.Context#sendBroadcast
 * @see android.content.Context#registerReceiver
 * @see android.content.Intent#filterEquals
 */

Body of Frist Method:
{
    setImpl(RTC_WAKEUP, info.getTriggerTime(), WINDOW_EXACT, 0, operation, null, info);
}
Body of Second Method:
{
    setImpl(RTC_WAKEUP, info.getTriggerTime(), WINDOW_EXACT, 0, 0, operation, null, info);
}
------------------------
Find a silently evolved API code:android.os.ParcelFileDescriptor.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 * If {@link Parcelable#PARCELABLE_WRITE_RETURN_VALUE} is set in flags,
 * the file descriptor will be closed after a copy is written to the Parcel.
 */

Body of Frist Method:
{
    // in frameworks/native/libs/binder/Parcel.cpp
    if (mWrapped != null) {
        try {
            mWrapped.writeToParcel(out, flags);
        } finally {
            releaseResources();
        }
    } else {
        out.writeFileDescriptor(mFd);
        if (mCommFd != null) {
            out.writeInt(1);
            out.writeFileDescriptor(mCommFd);
        } else {
            out.writeInt(0);
        }
        if ((flags & PARCELABLE_WRITE_RETURN_VALUE) != 0 && !mClosed) {
            // Not a real close, so emit no status
            closeWithStatus(Status.SILENCE, null);
        }
    }
}
Body of Second Method:
{
    if (mWrapped != null) {
        try {
            mWrapped.writeToParcel(out, flags);
        } finally {
            releaseResources();
        }
    } else {
        if (mCommFd != null) {
            out.writeInt(1);
            out.writeFileDescriptor(mFd);
            out.writeFileDescriptor(mCommFd);
        } else {
            out.writeInt(0);
            out.writeFileDescriptor(mFd);
        }
        if ((flags & PARCELABLE_WRITE_RETURN_VALUE) != 0 && !mClosed) {
            // Not a real close, so emit no status
            closeWithStatus(Status.SILENCE, null);
        }
    }
}
------------------------
Find a silently evolved API code:android.app.Activity.onBackPressed:COMMENT
Method Modifier: public      
Comment:/**
 * Called when the activity has detected the user's press of the back
 * key.  The default implementation simply finishes the current activity,
 * but you can override this to do whatever you want.
 */

Body of Frist Method:
{
    if (mActionBar != null && mActionBar.collapseActionView()) {
        return;
    }
    if (!mFragments.popBackStackImmediate()) {
        finishAfterTransition();
    }
}
Body of Second Method:
{
    if (mActionBar != null && mActionBar.collapseActionView()) {
        return;
    }
    if (!mFragments.getFragmentManager().popBackStackImmediate()) {
        finishAfterTransition();
    }
}
------------------------
Find a silently evolved API code:android.widget.OverScroller.getCurrVelocity:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the absolute value of the current velocity.
 *
 * @return The original velocity less the deceleration, norm of the X and Y velocity vector.
 */

Body of Frist Method:
{
    float squaredNorm = mScrollerX.mCurrVelocity * mScrollerX.mCurrVelocity;
    squaredNorm += mScrollerY.mCurrVelocity * mScrollerY.mCurrVelocity;
    return FloatMath.sqrt(squaredNorm);
}
Body of Second Method:
{
    return (float) Math.hypot(mScrollerX.mCurrVelocity, mScrollerY.mCurrVelocity);
}
------------------------
Find a silently evolved API code:android.location.GpsClock.setType:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets the type of time reported.
 */

Body of Frist Method:
{
    switch(value) {
        case TYPE_UNKNOWN:
        case TYPE_GPS_TIME:
        case TYPE_LOCAL_HW_TIME:
            mType = value;
            break;
        default:
            Log.d(TAG, "Sanitizing invalid 'type': " + value);
            mType = TYPE_UNKNOWN;
            break;
    }
}
Body of Second Method:
{
    mType = value;
}
------------------------
Find a silently evolved API code:android.widget.TextView.getCompoundPaddingBottom:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the bottom padding of the view, plus space for the bottom
 * Drawable if any.
 */

Body of Frist Method:
{
    final Drawables dr = mDrawables;
    if (dr == null || dr.mDrawableBottom == null) {
        return mPaddingBottom;
    } else {
        return mPaddingBottom + dr.mDrawablePadding + dr.mDrawableSizeBottom;
    }
}
Body of Second Method:
{
    final Drawables dr = mDrawables;
    if (dr == null || dr.mShowing[Drawables.BOTTOM] == null) {
        return mPaddingBottom;
    } else {
        return mPaddingBottom + dr.mDrawablePadding + dr.mDrawableSizeBottom;
    }
}
------------------------
Find a silently evolved API code:android.telephony.SubscriptionManager.getAllSubscriptionInfoCount:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @return the count of all subscriptions in the database, this includes
 * all subscriptions that have been seen.
 * @hide
 */

Body of Frist Method:
{
    if (VDBG)
        logd("[getAllSubscriptionInfoCount]+");
    int result = 0;
    try {
        ISub iSub = ISub.Stub.asInterface(ServiceManager.getService("isub"));
        if (iSub != null) {
            result = iSub.getAllSubInfoCount();
        }
    } catch (RemoteException ex) {
    // ignore it
    }
    return result;
}
Body of Second Method:
{
    if (VDBG)
        logd("[getAllSubscriptionInfoCount]+");
    int result = 0;
    try {
        ISub iSub = ISub.Stub.asInterface(ServiceManager.getService("isub"));
        if (iSub != null) {
            result = iSub.getAllSubInfoCount(mContext.getOpPackageName());
        }
    } catch (RemoteException ex) {
    // ignore it
    }
    return result;
}
------------------------
Find a silently evolved API code:android.hardware.camera2.utils.CameraBinderDecorator.throwOnError:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Throw error codes returned by the camera service as exceptions.
 *
 * @param errorFlag error to throw as an exception.
 */

Body of Frist Method:
{
    switch(errorFlag) {
        case NO_ERROR:
            return;
        case PERMISSION_DENIED:
            throw new SecurityException("Lacking privileges to access camera service");
        case ALREADY_EXISTS:
            // just means we tried to do an operation that already completed.
            return;
        case BAD_VALUE:
            throw new IllegalArgumentException("Bad argument passed to camera service");
        case DEAD_OBJECT:
            throw new CameraRuntimeException(CAMERA_DISCONNECTED);
        case TIMED_OUT:
            throw new CameraRuntimeException(CAMERA_ERROR, "Operation timed out in camera service");
        case EACCES:
            throw new CameraRuntimeException(CAMERA_DISABLED);
        case EBUSY:
            throw new CameraRuntimeException(CAMERA_IN_USE);
        case EUSERS:
            throw new CameraRuntimeException(MAX_CAMERAS_IN_USE);
        case ENODEV:
            throw new CameraRuntimeException(CAMERA_DISCONNECTED);
        case EOPNOTSUPP:
            throw new CameraRuntimeException(CAMERA_DEPRECATED_HAL);
        case INVALID_OPERATION:
            throw new CameraRuntimeException(CAMERA_ERROR, "Illegal state encountered in camera service.");
    }
    /**
     * Trap the rest of the negative return values. If we have known
     * error codes i.e. ALREADY_EXISTS that aren't really runtime
     * errors, then add them to the top switch statement
     */
    if (errorFlag < 0) {
        throw new UnsupportedOperationException(String.format("Unknown error %d", errorFlag));
    }
}
Body of Second Method:
{
    switch(errorFlag) {
        case NO_ERROR:
            return;
        case PERMISSION_DENIED:
            throw new SecurityException("Lacking privileges to access camera service");
        case ALREADY_EXISTS:
            // just means we tried to do an operation that already completed.
            return;
        case BAD_VALUE:
            throw new IllegalArgumentException("Bad argument passed to camera service");
        case DEAD_OBJECT:
            throw new CameraRuntimeException(CAMERA_DISCONNECTED);
        case TIMED_OUT:
            throw new CameraRuntimeException(CAMERA_ERROR, "Operation timed out in camera service");
        case EACCES:
            throw new CameraRuntimeException(CAMERA_DISABLED);
        case EBUSY:
            throw new CameraRuntimeException(CAMERA_IN_USE);
        case EUSERS:
            throw new CameraRuntimeException(MAX_CAMERAS_IN_USE);
        case ENODEV:
            throw new CameraRuntimeException(CAMERA_DISCONNECTED);
        case EOPNOTSUPP:
            throw new CameraRuntimeException(CAMERA_DEPRECATED_HAL);
        case INVALID_OPERATION:
            throw new CameraRuntimeException(CAMERA_ERROR, "Illegal state encountered in camera service.");
    }
    /**
     * Trap the rest of the negative return values. If we have known
     * error codes i.e. ALREADY_EXISTS that aren't really runtime
     * errors, then add them to the top switch statement
     */
    if (errorFlag < 0) {
        throw new CameraRuntimeException(CAMERA_ERROR, String.format("Unknown camera device error %d", errorFlag));
    }
}
------------------------
Find a silently evolved API code:android.widget.RemoteViews.apply:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    RemoteViews rvToApply = getRemoteViewsToApply(context);
    View result;
    // RemoteViews may be built by an application installed in another
    // user. So build a context that loads resources from that user but
    // still returns the current users userId so settings like data / time formats
    // are loaded without requiring cross user persmissions.
    final Context contextForResources = getContextForResources(context);
    Context inflationContext = new ContextWrapper(context) {

        @Override
        public Resources getResources() {
            return contextForResources.getResources();
        }

        @Override
        public Resources.Theme getTheme() {
            return contextForResources.getTheme();
        }
    };
    LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    // Clone inflater so we load resources from correct context and
    // we don't add a filter to the static version returned by getSystemService.
    inflater = inflater.cloneInContext(inflationContext);
    inflater.setFilter(this);
    result = inflater.inflate(rvToApply.getLayoutId(), parent, false);
    rvToApply.performApply(result, parent, handler);
    return result;
}
Body of Second Method:
{
    RemoteViews rvToApply = getRemoteViewsToApply(context);
    View result;
    // RemoteViews may be built by an application installed in another
    // user. So build a context that loads resources from that user but
    // still returns the current users userId so settings like data / time formats
    // are loaded without requiring cross user persmissions.
    final Context contextForResources = getContextForResources(context);
    Context inflationContext = new ContextWrapper(context) {

        @Override
        public Resources getResources() {
            return contextForResources.getResources();
        }

        @Override
        public Resources.Theme getTheme() {
            return contextForResources.getTheme();
        }

        @Override
        public String getPackageName() {
            return contextForResources.getPackageName();
        }
    };
    LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    // Clone inflater so we load resources from correct context and
    // we don't add a filter to the static version returned by getSystemService.
    inflater = inflater.cloneInContext(inflationContext);
    inflater.setFilter(this);
    result = inflater.inflate(rvToApply.getLayoutId(), parent, false);
    rvToApply.performApply(result, parent, handler);
    return result;
}
------------------------
Find a silently evolved API code:android.graphics.drawable.RippleDrawable.tryRippleExit:COMMENT
Method Modifier: private     
Comment:/**
 * Attempts to start an exit animation for the active hotspot. Fails if
 * there is no active hotspot.
 */

Body of Frist Method:
{
    if (mRipple != null) {
        if (mExitingRipples == null) {
            mExitingRipples = new Ripple[MAX_RIPPLES];
        }
        mExitingRipples[mExitingRipplesCount++] = mRipple;
        mRipple.exit();
        mRipple = null;
    }
}
Body of Second Method:
{
    if (mRipple != null) {
        if (mExitingRipples == null) {
            mExitingRipples = new RippleForeground[MAX_RIPPLES];
        }
        mExitingRipples[mExitingRipplesCount++] = mRipple;
        mRipple.exit();
        mRipple = null;
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothAdapter.isOffloadedFilteringSupported:COMMENT
Method Modifier: public      
Comment:/**
 * Return true if offloaded filters are supported
 *
 * @return true if chipset supports on-chip filtering
 */

Body of Frist Method:
{
    if (getState() != STATE_ON)
        return false;
    try {
        return mService.isOffloadedFilteringSupported();
    } catch (RemoteException e) {
        Log.e(TAG, "failed to get isOffloadedFilteringSupported, error: ", e);
    }
    return false;
}
Body of Second Method:
{
    if (!getLeAccess())
        return false;
    try {
        return mService.isOffloadedFilteringSupported();
    } catch (RemoteException e) {
        Log.e(TAG, "failed to get isOffloadedFilteringSupported, error: ", e);
    }
    return false;
}
------------------------
Find a silently evolved API code:android.app.SearchDialog.createContentView:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * We recreate the dialog view each time it becomes visible so as to limit
 * the scope of any problems with the contained resources.
 */

Body of Frist Method:
{
    setContentView(com.android.internal.R.layout.search_bar);
    // get the view elements for local access
    SearchBar searchBar = (SearchBar) findViewById(com.android.internal.R.id.search_bar);
    searchBar.setSearchDialog(this);
    mSearchView = (SearchView) findViewById(com.android.internal.R.id.search_view);
    mSearchView.setIconified(false);
    mSearchView.setOnCloseListener(mOnCloseListener);
    mSearchView.setOnQueryTextListener(mOnQueryChangeListener);
    mSearchView.setOnSuggestionListener(mOnSuggestionSelectionListener);
    mSearchView.onActionViewExpanded();
    mCloseSearch = findViewById(com.android.internal.R.id.closeButton);
    mCloseSearch.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            dismiss();
        }
    });
    // TODO: Move the badge logic to SearchView or move the badge to search_bar.xml
    mBadgeLabel = (TextView) mSearchView.findViewById(com.android.internal.R.id.search_badge);
    mSearchAutoComplete = (AutoCompleteTextView) mSearchView.findViewById(com.android.internal.R.id.search_src_text);
    mAppIcon = (ImageView) findViewById(com.android.internal.R.id.search_app_icon);
    mSearchPlate = mSearchView.findViewById(com.android.internal.R.id.search_plate);
    mWorkingSpinner = getContext().getDrawable(com.android.internal.R.drawable.search_spinner);
    // TODO: Restore the spinner for slow suggestion lookups
    // mSearchAutoComplete.setCompoundDrawablesWithIntrinsicBounds(
    // null, null, mWorkingSpinner, null);
    setWorking(false);
    // pre-hide all the extraneous elements
    mBadgeLabel.setVisibility(View.GONE);
    // Additional adjustments to make Dialog work for Search
    mSearchAutoCompleteImeOptions = mSearchAutoComplete.getImeOptions();
}
Body of Second Method:
{
    setContentView(com.android.internal.R.layout.search_bar);
    // get the view elements for local access
    mSearchView = (SearchView) findViewById(com.android.internal.R.id.search_view);
    mSearchView.setIconified(false);
    mSearchView.setOnCloseListener(mOnCloseListener);
    mSearchView.setOnQueryTextListener(mOnQueryChangeListener);
    mSearchView.setOnSuggestionListener(mOnSuggestionSelectionListener);
    mSearchView.onActionViewExpanded();
    mCloseSearch = findViewById(com.android.internal.R.id.closeButton);
    mCloseSearch.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            dismiss();
        }
    });
    // TODO: Move the badge logic to SearchView or move the badge to search_bar.xml
    mBadgeLabel = (TextView) mSearchView.findViewById(com.android.internal.R.id.search_badge);
    mSearchAutoComplete = (AutoCompleteTextView) mSearchView.findViewById(com.android.internal.R.id.search_src_text);
    mAppIcon = (ImageView) findViewById(com.android.internal.R.id.search_app_icon);
    mSearchPlate = mSearchView.findViewById(com.android.internal.R.id.search_plate);
    mWorkingSpinner = getContext().getDrawable(com.android.internal.R.drawable.search_spinner);
    // TODO: Restore the spinner for slow suggestion lookups
    // mSearchAutoComplete.setCompoundDrawablesWithIntrinsicBounds(
    // null, null, mWorkingSpinner, null);
    setWorking(false);
    // pre-hide all the extraneous elements
    mBadgeLabel.setVisibility(View.GONE);
    // Additional adjustments to make Dialog work for Search
    mSearchAutoCompleteImeOptions = mSearchAutoComplete.getImeOptions();
}
------------------------
Find a silently evolved API code:android.graphics.pdf.PdfRenderer.Page.render:COMMENT
Method Modifier: public      
Comment:/**
 * Renders a page to a bitmap.
 * <p>
 * You may optionally specify a rectangular clip in the bitmap bounds. No rendering
 * outside the clip will be performed, hence it is your responsibility to initialize
 * the bitmap outside the clip.
 * </p>
 * <p>
 * You may optionally specify a matrix to transform the content from page coordinates
 * which are in points (1/72") to bitmap coordinates which are in pixels. If this
 * matrix is not provided this method will apply a transformation that will fit the
 * whole page to the destination clip if provided or the destination bitmap if no
 * clip is provided.
 * </p>
 * <p>
 * The clip and transformation are useful for implementing tile rendering where the
 * destination bitmap contains a portion of the image, for example when zooming.
 * Another useful application is for printing where the size of the bitmap holding
 * the page is too large and a client can render the page in stripes.
 * </p>
 * <p>
 * <strong>Note: </strong> The destination bitmap format must be
 * {@link Config#ARGB_8888 ARGB}.
 * </p>
 * <p>
 * <strong>Note: </strong> The optional transformation matrix must be affine as per
 * {@link android.graphics.Matrix#isAffine() Matrix.isAffine()}. Hence, you can specify
 * rotation, scaling, translation but not a perspective transformation.
 * </p>
 *
 * @param destination Destination bitmap to which to render.
 * @param destClip Optional clip in the bitmap bounds.
 * @param transform Optional transformation to apply when rendering.
 * @param renderMode The render mode.
 *
 * @see #RENDER_MODE_FOR_DISPLAY
 * @see #RENDER_MODE_FOR_PRINT
 */

Body of Frist Method:
{
    if (destination.getConfig() != Config.ARGB_8888) {
        throw new IllegalArgumentException("Unsupported pixel format");
    }
    if (destClip != null) {
        if (destClip.left < 0 || destClip.top < 0 || destClip.right > destination.getWidth() || destClip.bottom > destination.getHeight()) {
            throw new IllegalArgumentException("destBounds not in destination");
        }
    }
    if (transform != null && !transform.isAffine()) {
        throw new IllegalArgumentException("transform not affine");
    }
    if (renderMode != RENDER_MODE_FOR_PRINT && renderMode != RENDER_MODE_FOR_DISPLAY) {
        throw new IllegalArgumentException("Unsupported render mode");
    }
    if (renderMode == RENDER_MODE_FOR_PRINT && renderMode == RENDER_MODE_FOR_DISPLAY) {
        throw new IllegalArgumentException("Only single render mode supported");
    }
    final int contentLeft = (destClip != null) ? destClip.left : 0;
    final int contentTop = (destClip != null) ? destClip.top : 0;
    final int contentRight = (destClip != null) ? destClip.right : destination.getWidth();
    final int contentBottom = (destClip != null) ? destClip.bottom : destination.getHeight();
    final long transformPtr = (transform != null) ? transform.native_instance : 0;
    nativeRenderPage(mNativeDocument, mNativePage, destination.mNativeBitmap, contentLeft, contentTop, contentRight, contentBottom, transformPtr, renderMode);
}
Body of Second Method:
{
    if (destination.getConfig() != Config.ARGB_8888) {
        throw new IllegalArgumentException("Unsupported pixel format");
    }
    if (destClip != null) {
        if (destClip.left < 0 || destClip.top < 0 || destClip.right > destination.getWidth() || destClip.bottom > destination.getHeight()) {
            throw new IllegalArgumentException("destBounds not in destination");
        }
    }
    if (transform != null && !transform.isAffine()) {
        throw new IllegalArgumentException("transform not affine");
    }
    if (renderMode != RENDER_MODE_FOR_PRINT && renderMode != RENDER_MODE_FOR_DISPLAY) {
        throw new IllegalArgumentException("Unsupported render mode");
    }
    if (renderMode == RENDER_MODE_FOR_PRINT && renderMode == RENDER_MODE_FOR_DISPLAY) {
        throw new IllegalArgumentException("Only single render mode supported");
    }
    final int contentLeft = (destClip != null) ? destClip.left : 0;
    final int contentTop = (destClip != null) ? destClip.top : 0;
    final int contentRight = (destClip != null) ? destClip.right : destination.getWidth();
    final int contentBottom = (destClip != null) ? destClip.bottom : destination.getHeight();
    final long transformPtr = (transform != null) ? transform.native_instance : 0;
    nativeRenderPage(mNativeDocument, mNativePage, destination, contentLeft, contentTop, contentRight, contentBottom, transformPtr, renderMode);
}
------------------------
Find a silently evolved API code:android.renderscript.AllocationAdapter.setLOD:COMMENT
Method Modifier: public      
Comment:/**
 * Set the active LOD.  The LOD must be within the range for the
 * type being adapted.  The base allocation must have mipmaps.
 *
 * Because this changes the dimensions of the adapter the
 * current Y and Z will be reset.
 *
 * @param lod The LOD to make active.
 */

Body of Frist Method:
{
    if (!mAdaptedAllocation.getType().hasMipmaps()) {
        throw new RSInvalidStateException("Cannot set LOD when the allocation type does not include mipmaps.");
    }
    if (!mConstrainedLOD) {
        throw new RSInvalidStateException("Cannot set LOD when the adapter includes mipmaps.");
    }
    initLOD(lod);
}
Body of Second Method:
{
    if (!mAdaptedAllocation.getType().hasMipmaps()) {
        throw new RSInvalidStateException("Cannot set LOD when the allocation type does not include mipmaps.");
    }
    if (mWindow.hasMipmaps()) {
        throw new RSInvalidStateException("Cannot set LOD when the adapter includes mipmaps.");
    }
    initLOD(lod);
    mSelectedLOD = lod;
    updateOffsets();
}
------------------------
Find a silently evolved API code:android.view.ViewRootImpl.setDrawDuringWindowsAnimating:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    mDrawDuringWindowsAnimating = value;
    if (value) {
        handleDispatchDoneAnimating();
    }
}
Body of Second Method:
{
    mDrawDuringWindowsAnimating = value;
    if (value) {
        handleDispatchWindowAnimationStopped();
    }
}
------------------------
Find a silently evolved API code:android.renderscript.AllocationAdapter.setFace:COMMENT
Method Modifier: public      
Comment:/**
 * Set the active Face.  The base allocation must be of a type
 * that includes faces.
 *
 * @param cf The face to make active.
 */

Body of Frist Method:
{
    if (!mAdaptedAllocation.getType().hasFaces()) {
        throw new RSInvalidStateException("Cannot set Face when the allocation type does not include faces.");
    }
    if (!mConstrainedFace) {
        throw new RSInvalidStateException("Cannot set LOD when the adapter includes mipmaps.");
    }
    if (cf == null) {
        throw new RSIllegalArgumentException("Cannot set null face.");
    }
    mSelectedFace = cf;
}
Body of Second Method:
{
    if (!mAdaptedAllocation.getType().hasFaces()) {
        throw new RSInvalidStateException("Cannot set Face when the allocation type does not include faces.");
    }
    if (mWindow.hasFaces()) {
        throw new RSInvalidStateException("Cannot set face when the adapter includes faces.");
    }
    if (cf == null) {
        throw new RSIllegalArgumentException("Cannot set null face.");
    }
    mSelectedFace = cf;
    updateOffsets();
}
------------------------
Find a silently evolved API code:android.content.pm.ParceledListSlice.writeToParcel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Write this to another Parcel. Note that this discards the internal Parcel
 * and should not be used anymore. This is so we can pass this to a Binder
 * where we won't have a chance to call recycle on this.
 */

Body of Frist Method:
{
    final int N = mList.size();
    final int callFlags = flags;
    dest.writeInt(N);
    if (DEBUG)
        Log.d(TAG, "Writing " + N + " items");
    if (N > 0) {
        final Class<?> listElementClass = mList.get(0).getClass();
        dest.writeParcelableCreator(mList.get(0));
        int i = 0;
        while (i < N && dest.dataSize() < MAX_FIRST_IPC_SIZE) {
            dest.writeInt(1);
            final T parcelable = mList.get(i);
            verifySameType(listElementClass, parcelable.getClass());
            parcelable.writeToParcel(dest, callFlags);
            if (DEBUG)
                Log.d(TAG, "Wrote inline #" + i + ": " + mList.get(i));
            i++;
        }
        if (i < N) {
            dest.writeInt(0);
            Binder retriever = new Binder() {

                @Override
                protected boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException {
                    if (code != FIRST_CALL_TRANSACTION) {
                        return super.onTransact(code, data, reply, flags);
                    }
                    int i = data.readInt();
                    if (DEBUG)
                        Log.d(TAG, "Writing more @" + i + " of " + N);
                    while (i < N && reply.dataSize() < MAX_IPC_SIZE) {
                        reply.writeInt(1);
                        final T parcelable = mList.get(i);
                        verifySameType(listElementClass, parcelable.getClass());
                        parcelable.writeToParcel(reply, callFlags);
                        if (DEBUG)
                            Log.d(TAG, "Wrote extra #" + i + ": " + mList.get(i));
                        i++;
                    }
                    if (i < N) {
                        if (DEBUG)
                            Log.d(TAG, "Breaking @" + i + " of " + N);
                        reply.writeInt(0);
                    }
                    return true;
                }
            };
            if (DEBUG)
                Log.d(TAG, "Breaking @" + i + " of " + N + ": retriever=" + retriever);
            dest.writeStrongBinder(retriever);
        }
    }
}
Body of Second Method:
{
    final int N = mList.size();
    final int callFlags = flags;
    dest.writeInt(N);
    if (DEBUG)
        Log.d(TAG, "Writing " + N + " items");
    if (N > 0) {
        final Class<?> listElementClass = mList.get(0).getClass();
        dest.writeParcelableCreator(mList.get(0));
        int i = 0;
        while (i < N && dest.dataSize() < MAX_IPC_SIZE) {
            dest.writeInt(1);
            final T parcelable = mList.get(i);
            verifySameType(listElementClass, parcelable.getClass());
            parcelable.writeToParcel(dest, callFlags);
            if (DEBUG)
                Log.d(TAG, "Wrote inline #" + i + ": " + mList.get(i));
            i++;
        }
        if (i < N) {
            dest.writeInt(0);
            Binder retriever = new Binder() {

                @Override
                protected boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException {
                    if (code != FIRST_CALL_TRANSACTION) {
                        return super.onTransact(code, data, reply, flags);
                    }
                    int i = data.readInt();
                    if (DEBUG)
                        Log.d(TAG, "Writing more @" + i + " of " + N);
                    while (i < N && reply.dataSize() < MAX_IPC_SIZE) {
                        reply.writeInt(1);
                        final T parcelable = mList.get(i);
                        verifySameType(listElementClass, parcelable.getClass());
                        parcelable.writeToParcel(reply, callFlags);
                        if (DEBUG)
                            Log.d(TAG, "Wrote extra #" + i + ": " + mList.get(i));
                        i++;
                    }
                    if (i < N) {
                        if (DEBUG)
                            Log.d(TAG, "Breaking @" + i + " of " + N);
                        reply.writeInt(0);
                    }
                    return true;
                }
            };
            if (DEBUG)
                Log.d(TAG, "Breaking @" + i + " of " + N + ": retriever=" + retriever);
            dest.writeStrongBinder(retriever);
        }
    }
}
------------------------
Find a silently evolved API code:android.webkit.WebView.postUrl:COMMENT
Method Modifier: public      
Comment:/**
 * Loads the URL with postData using "POST" method into this WebView. If url
 * is not a network URL, it will be loaded with {@link #loadUrl(String)}
 * instead, ignoring the postData param.
 *
 * @param url the URL of the resource to load
 * @param postData the data will be passed to "POST" request, which must be
 * be "application/x-www-form-urlencoded" encoded.
 */

Body of Frist Method:
{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, "postUrl=" + url);
    if (URLUtil.isNetworkUrl(url)) {
        mProvider.postUrl(url, postData);
    } else {
        mProvider.loadUrl(url);
    }
}
Body of Second Method:
{
    checkThread();
    if (URLUtil.isNetworkUrl(url)) {
        mProvider.postUrl(url, postData);
    } else {
        mProvider.loadUrl(url);
    }
}
------------------------
Find a silently evolved API code:android.hardware.camera2.params.StreamConfigurationMap.hashCode:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    // XX: do we care about order?
    return HashCodeHelpers.hashCode(mConfigurations, mMinFrameDurations, mStallDurations, mHighSpeedVideoConfigurations);
}
Body of Second Method:
{
    // XX: do we care about order?
    return HashCodeHelpers.hashCodeGeneric(mConfigurations, mMinFrameDurations, mStallDurations, mDepthConfigurations, mHighSpeedVideoConfigurations);
}
------------------------
Find a silently evolved API code:android.telephony.SubscriptionManager.addOnSubscriptionsChangedListener:COMMENT
Method Modifier: public      
Comment:/**
 * Register for changes to the list of active {@link SubscriptionInfo} records or to the
 * individual records themselves. When a change occurs the onSubscriptionsChanged method of
 * the listener will be invoked immediately if there has been a notification.
 *
 * @param listener an instance of {@link OnSubscriptionsChangedListener} with
 * onSubscriptionsChanged overridden.
 */

Body of Frist Method:
{
    String pkgForDebug = mContext != null ? mContext.getPackageName() : "<unknown>";
    if (DBG) {
        logd("register OnSubscriptionsChangedListener pkgForDebug=" + pkgForDebug + " listener=" + listener);
    }
    try {
        // We use the TelephonyRegistry as it runs in the system and thus is always
        // available. Where as SubscriptionController could crash and not be available
        ITelephonyRegistry tr = ITelephonyRegistry.Stub.asInterface(ServiceManager.getService("telephony.registry"));
        if (tr != null) {
            tr.addOnSubscriptionsChangedListener(pkgForDebug, listener.callback);
        }
    } catch (RemoteException ex) {
    // Should not happen
    }
}
Body of Second Method:
{
    String pkgForDebug = mContext != null ? mContext.getOpPackageName() : "<unknown>";
    if (DBG) {
        logd("register OnSubscriptionsChangedListener pkgForDebug=" + pkgForDebug + " listener=" + listener);
    }
    try {
        // We use the TelephonyRegistry as it runs in the system and thus is always
        // available. Where as SubscriptionController could crash and not be available
        ITelephonyRegistry tr = ITelephonyRegistry.Stub.asInterface(ServiceManager.getService("telephony.registry"));
        if (tr != null) {
            tr.addOnSubscriptionsChangedListener(pkgForDebug, listener.callback);
        }
    } catch (RemoteException ex) {
    // Should not happen
    }
}
------------------------
Find a silently evolved API code:android.widget.RelativeLayout.getChildMeasureSpec:COMMENT
Method Modifier: private     
Comment:/**
 * Get a measure spec that accounts for all of the constraints on this view.
 * This includes size constraints imposed by the RelativeLayout as well as
 * the View's desired dimension.
 *
 * @param childStart The left or top field of the child's layout params
 * @param childEnd The right or bottom field of the child's layout params
 * @param childSize The child's desired size (the width or height field of
 * the child's layout params)
 * @param startMargin The left or top margin
 * @param endMargin The right or bottom margin
 * @param startPadding mPaddingLeft or mPaddingTop
 * @param endPadding mPaddingRight or mPaddingBottom
 * @param mySize The width or height of this view (the RelativeLayout)
 * @return MeasureSpec for the child
 */

Body of Frist Method:
{
    int childSpecMode = 0;
    int childSpecSize = 0;
    // RelativeLayout's measure spec."
    if (mySize < 0 && !mAllowBrokenMeasureSpecs) {
        if (childStart != VALUE_NOT_SET && childEnd != VALUE_NOT_SET) {
            // Constraints fixed both edges, so child has an exact size.
            childSpecSize = Math.max(0, childEnd - childStart);
            childSpecMode = MeasureSpec.EXACTLY;
        } else if (childSize >= 0) {
            // The child specified an exact size.
            childSpecSize = childSize;
            childSpecMode = MeasureSpec.EXACTLY;
        } else {
            // Allow the child to be whatever size it wants.
            childSpecSize = 0;
            childSpecMode = MeasureSpec.UNSPECIFIED;
        }
        return MeasureSpec.makeMeasureSpec(childSpecSize, childSpecMode);
    }
    // Figure out start and end bounds.
    int tempStart = childStart;
    int tempEnd = childEnd;
    // view's margins and our padding
    if (tempStart == VALUE_NOT_SET) {
        tempStart = startPadding + startMargin;
    }
    if (tempEnd == VALUE_NOT_SET) {
        tempEnd = mySize - endPadding - endMargin;
    }
    // Figure out maximum size available to this view
    int maxAvailable = tempEnd - tempStart;
    if (childStart != VALUE_NOT_SET && childEnd != VALUE_NOT_SET) {
        // Constraints fixed both edges, so child must be an exact size
        childSpecMode = MeasureSpec.EXACTLY;
        childSpecSize = maxAvailable;
    } else {
        if (childSize >= 0) {
            // Child wanted an exact size. Give as much as possible
            childSpecMode = MeasureSpec.EXACTLY;
            if (maxAvailable >= 0) {
                // We have a maxmum size in this dimension.
                childSpecSize = Math.min(maxAvailable, childSize);
            } else {
                // We can grow in this dimension.
                childSpecSize = childSize;
            }
        } else if (childSize == LayoutParams.MATCH_PARENT) {
            // Child wanted to be as big as possible. Give all available
            // space
            childSpecMode = MeasureSpec.EXACTLY;
            childSpecSize = maxAvailable;
        } else if (childSize == LayoutParams.WRAP_CONTENT) {
            // our max size
            if (maxAvailable >= 0) {
                // We have a maximum size in this dimension.
                childSpecMode = MeasureSpec.AT_MOST;
                childSpecSize = maxAvailable;
            } else {
                // We can grow in this dimension. Child can be as big as it
                // wants
                childSpecMode = MeasureSpec.UNSPECIFIED;
                childSpecSize = 0;
            }
        }
    }
    return MeasureSpec.makeMeasureSpec(childSpecSize, childSpecMode);
}
Body of Second Method:
{
    int childSpecMode = 0;
    int childSpecSize = 0;
    // Negative values in a mySize value in RelativeLayout
    // measurement is code for, "we got an unspecified mode in the
    // RelativeLayout's measure spec."
    final boolean isUnspecified = mySize < 0;
    if (isUnspecified && !mAllowBrokenMeasureSpecs) {
        if (childStart != VALUE_NOT_SET && childEnd != VALUE_NOT_SET) {
            // Constraints fixed both edges, so child has an exact size.
            childSpecSize = Math.max(0, childEnd - childStart);
            childSpecMode = MeasureSpec.EXACTLY;
        } else if (childSize >= 0) {
            // The child specified an exact size.
            childSpecSize = childSize;
            childSpecMode = MeasureSpec.EXACTLY;
        } else {
            // Allow the child to be whatever size it wants.
            childSpecSize = 0;
            childSpecMode = MeasureSpec.UNSPECIFIED;
        }
        return MeasureSpec.makeMeasureSpec(childSpecSize, childSpecMode);
    }
    // Figure out start and end bounds.
    int tempStart = childStart;
    int tempEnd = childEnd;
    // view's margins and our padding
    if (tempStart == VALUE_NOT_SET) {
        tempStart = startPadding + startMargin;
    }
    if (tempEnd == VALUE_NOT_SET) {
        tempEnd = mySize - endPadding - endMargin;
    }
    // Figure out maximum size available to this view
    final int maxAvailable = tempEnd - tempStart;
    if (childStart != VALUE_NOT_SET && childEnd != VALUE_NOT_SET) {
        // Constraints fixed both edges, so child must be an exact size.
        childSpecMode = isUnspecified ? MeasureSpec.UNSPECIFIED : MeasureSpec.EXACTLY;
        childSpecSize = Math.max(0, maxAvailable);
    } else {
        if (childSize >= 0) {
            // Child wanted an exact size. Give as much as possible.
            childSpecMode = MeasureSpec.EXACTLY;
            if (maxAvailable >= 0) {
                // We have a maximum size in this dimension.
                childSpecSize = Math.min(maxAvailable, childSize);
            } else {
                // We can grow in this dimension.
                childSpecSize = childSize;
            }
        } else if (childSize == LayoutParams.MATCH_PARENT) {
            // Child wanted to be as big as possible. Give all available
            // space.
            childSpecMode = isUnspecified ? MeasureSpec.UNSPECIFIED : MeasureSpec.EXACTLY;
            childSpecSize = Math.max(0, maxAvailable);
        } else if (childSize == LayoutParams.WRAP_CONTENT) {
            // available space if we know our max size.
            if (maxAvailable >= 0) {
                // We have a maximum size in this dimension.
                childSpecMode = MeasureSpec.AT_MOST;
                childSpecSize = maxAvailable;
            } else {
                // We can grow in this dimension. Child can be as big as it
                // wants.
                childSpecMode = MeasureSpec.UNSPECIFIED;
                childSpecSize = 0;
            }
        }
    }
    return MeasureSpec.makeMeasureSpec(childSpecSize, childSpecMode);
}
------------------------
Find a silently evolved API code:android.graphics.drawable.LayerDrawable.clearMutated:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    super.clearMutated();
    final ChildDrawable[] array = mLayerState.mChildren;
    final int N = mLayerState.mNum;
    for (int i = 0; i < N; i++) {
        array[i].mDrawable.clearMutated();
    }
    mMutated = false;
}
Body of Second Method:
{
    super.clearMutated();
    final ChildDrawable[] array = mLayerState.mChildren;
    final int N = mLayerState.mNum;
    for (int i = 0; i < N; i++) {
        final Drawable dr = array[i].mDrawable;
        if (dr != null) {
            dr.clearMutated();
        }
    }
    mMutated = false;
}
------------------------
Find a silently evolved API code:android.graphics.drawable.GradientDrawable.updateStateFromTypedArray:COMMENT
Method Modifier: private     
Comment:/**
 * Updates the constant state from the values in the typed array.
 */

Body of Frist Method:
{
    final GradientState state = mGradientState;
    // Account for any configuration changes.
    state.mChangingConfigurations |= a.getChangingConfigurations();
    // Extract the theme attributes, if any.
    state.mThemeAttrs = a.extractThemeAttrs();
    state.mShape = a.getInt(R.styleable.GradientDrawable_shape, state.mShape);
    state.mDither = a.getBoolean(R.styleable.GradientDrawable_dither, state.mDither);
    if (state.mShape == RING) {
        state.mInnerRadius = a.getDimensionPixelSize(R.styleable.GradientDrawable_innerRadius, state.mInnerRadius);
        if (state.mInnerRadius == -1) {
            state.mInnerRadiusRatio = a.getFloat(R.styleable.GradientDrawable_innerRadiusRatio, state.mInnerRadiusRatio);
        }
        state.mThickness = a.getDimensionPixelSize(R.styleable.GradientDrawable_thickness, state.mThickness);
        if (state.mThickness == -1) {
            state.mThicknessRatio = a.getFloat(R.styleable.GradientDrawable_thicknessRatio, state.mThicknessRatio);
        }
        state.mUseLevelForShape = a.getBoolean(R.styleable.GradientDrawable_useLevel, state.mUseLevelForShape);
    }
    final int tintMode = a.getInt(R.styleable.GradientDrawable_tintMode, -1);
    if (tintMode != -1) {
        state.mTintMode = Drawable.parseTintMode(tintMode, PorterDuff.Mode.SRC_IN);
    }
    final ColorStateList tint = a.getColorStateList(R.styleable.GradientDrawable_tint);
    if (tint != null) {
        state.mTint = tint;
    }
    mTintFilter = updateTintFilter(mTintFilter, state.mTint, state.mTintMode);
}
Body of Second Method:
{
    final GradientState state = mGradientState;
    // Account for any configuration changes.
    state.mChangingConfigurations |= a.getChangingConfigurations();
    // Extract the theme attributes, if any.
    state.mThemeAttrs = a.extractThemeAttrs();
    state.mShape = a.getInt(R.styleable.GradientDrawable_shape, state.mShape);
    state.mDither = a.getBoolean(R.styleable.GradientDrawable_dither, state.mDither);
    if (state.mShape == RING) {
        state.mInnerRadius = a.getDimensionPixelSize(R.styleable.GradientDrawable_innerRadius, state.mInnerRadius);
        if (state.mInnerRadius == -1) {
            state.mInnerRadiusRatio = a.getFloat(R.styleable.GradientDrawable_innerRadiusRatio, state.mInnerRadiusRatio);
        }
        state.mThickness = a.getDimensionPixelSize(R.styleable.GradientDrawable_thickness, state.mThickness);
        if (state.mThickness == -1) {
            state.mThicknessRatio = a.getFloat(R.styleable.GradientDrawable_thicknessRatio, state.mThicknessRatio);
        }
        state.mUseLevelForShape = a.getBoolean(R.styleable.GradientDrawable_useLevel, state.mUseLevelForShape);
    }
    final int tintMode = a.getInt(R.styleable.GradientDrawable_tintMode, -1);
    if (tintMode != -1) {
        state.mTintMode = Drawable.parseTintMode(tintMode, PorterDuff.Mode.SRC_IN);
    }
    final ColorStateList tint = a.getColorStateList(R.styleable.GradientDrawable_tint);
    if (tint != null) {
        state.mTint = tint;
    }
    final int insetLeft = a.getDimensionPixelSize(R.styleable.GradientDrawable_opticalInsetLeft, state.mOpticalInsets.left);
    final int insetTop = a.getDimensionPixelSize(R.styleable.GradientDrawable_opticalInsetTop, state.mOpticalInsets.top);
    final int insetRight = a.getDimensionPixelSize(R.styleable.GradientDrawable_opticalInsetRight, state.mOpticalInsets.right);
    final int insetBottom = a.getDimensionPixelSize(R.styleable.GradientDrawable_opticalInsetBottom, state.mOpticalInsets.bottom);
    state.mOpticalInsets = Insets.of(insetLeft, insetTop, insetRight, insetBottom);
}
------------------------
Find a silently evolved API code:android.app.AlarmManager.setRepeating:COMMENT
Method Modifier: public      
Comment:/**
 * Schedule a repeating alarm.  <b>Note: for timing operations (ticks,
 * timeouts, etc) it is easier and much more efficient to use
 * {@link android.os.Handler}.</b>  If there is already an alarm scheduled
 * for the same IntentSender, it will first be canceled.
 *
 * <p>Like {@link #set}, except you can also supply a period at which
 * the alarm will automatically repeat.  This alarm continues
 * repeating until explicitly removed with {@link #cancel}.  If the stated
 * trigger time is in the past, the alarm will be triggered immediately, with an
 * alarm count depending on how far in the past the trigger time is relative
 * to the repeat interval.
 *
 * <p>If an alarm is delayed (by system sleep, for example, for non
 * _WAKEUP alarm types), a skipped repeat will be delivered as soon as
 * possible.  After that, future alarms will be delivered according to the
 * original schedule; they do not drift over time.  For example, if you have
 * set a recurring alarm for the top of every hour but the phone was asleep
 * from 7:45 until 8:45, an alarm will be sent as soon as the phone awakens,
 * then the next alarm will be sent at 9:00.
 *
 * <p>If your application wants to allow the delivery times to drift in
 * order to guarantee that at least a certain time interval always elapses
 * between alarms, then the approach to take is to use one-time alarms,
 * scheduling the next one yourself when handling each alarm delivery.
 *
 * <p class="note">
 * <b>Note:</b> as of API 19, all repeating alarms are inexact.  If your
 * application needs precise delivery times then it must use one-time
 * exact alarms, rescheduling each time as described above. Legacy applications
 * whose {@code targetSdkVersion} is earlier than API 19 will continue to have all
 * of their alarms, including repeating alarms, treated as exact.
 *
 * @param type One of {@link #ELAPSED_REALTIME}, {@link #ELAPSED_REALTIME_WAKEUP},
 * {@link #RTC}, or {@link #RTC_WAKEUP}.
 * @param triggerAtMillis time in milliseconds that the alarm should first
 * go off, using the appropriate clock (depending on the alarm type).
 * @param intervalMillis interval in milliseconds between subsequent repeats
 * of the alarm.
 * @param operation Action to perform when the alarm goes off;
 * typically comes from {@link PendingIntent#getBroadcast
 * IntentSender.getBroadcast()}.
 *
 * @see android.os.Handler
 * @see #set
 * @see #setExact
 * @see #setWindow
 * @see #cancel
 * @see android.content.Context#sendBroadcast
 * @see android.content.Context#registerReceiver
 * @see android.content.Intent#filterEquals
 * @see #ELAPSED_REALTIME
 * @see #ELAPSED_REALTIME_WAKEUP
 * @see #RTC
 * @see #RTC_WAKEUP
 */

Body of Frist Method:
{
    setImpl(type, triggerAtMillis, legacyExactLength(), intervalMillis, operation, null, null);
}
Body of Second Method:
{
    setImpl(type, triggerAtMillis, legacyExactLength(), intervalMillis, 0, operation, null, null);
}
------------------------
Find a silently evolved API code:android.app.AlarmManager.setExact:COMMENT
Method Modifier: public      
Comment:/**
 * Schedule an alarm to be delivered precisely at the stated time.
 *
 * <p>
 * This method is like {@link #set(int, long, PendingIntent)}, but does not permit
 * the OS to adjust the delivery time.  The alarm will be delivered as nearly as
 * possible to the requested trigger time.
 *
 * <p>
 * <b>Note:</b> only alarms for which there is a strong demand for exact-time
 * delivery (such as an alarm clock ringing at the requested time) should be
 * scheduled as exact.  Applications are strongly discouraged from using exact
 * alarms unnecessarily as they reduce the OS's ability to minimize battery use.
 *
 * @param type One of {@link #ELAPSED_REALTIME}, {@link #ELAPSED_REALTIME_WAKEUP},
 * {@link #RTC}, or {@link #RTC_WAKEUP}.
 * @param triggerAtMillis time in milliseconds that the alarm should go
 * off, using the appropriate clock (depending on the alarm type).
 * @param operation Action to perform when the alarm goes off;
 * typically comes from {@link PendingIntent#getBroadcast
 * IntentSender.getBroadcast()}.
 *
 * @see #set
 * @see #setRepeating
 * @see #setWindow
 * @see #cancel
 * @see android.content.Context#sendBroadcast
 * @see android.content.Context#registerReceiver
 * @see android.content.Intent#filterEquals
 * @see #ELAPSED_REALTIME
 * @see #ELAPSED_REALTIME_WAKEUP
 * @see #RTC
 * @see #RTC_WAKEUP
 */

Body of Frist Method:
{
    setImpl(type, triggerAtMillis, WINDOW_EXACT, 0, operation, null, null);
}
Body of Second Method:
{
    setImpl(type, triggerAtMillis, WINDOW_EXACT, 0, 0, operation, null, null);
}
------------------------
Find a silently evolved API code:android.widget.DayPickerView.getMostVisiblePosition:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the position of the view that is most prominently displayed within the list view.
 */

Body of Frist Method:
{
    final int firstPosition = getFirstVisiblePosition();
    final int height = getHeight();
    int maxDisplayedHeight = 0;
    int mostVisibleIndex = 0;
    int i = 0;
    int bottom = 0;
    while (bottom < height) {
        View child = getChildAt(i);
        if (child == null) {
            break;
        }
        bottom = child.getBottom();
        int displayedHeight = Math.min(bottom, height) - Math.max(0, child.getTop());
        if (displayedHeight > maxDisplayedHeight) {
            mostVisibleIndex = i;
            maxDisplayedHeight = displayedHeight;
        }
        i++;
    }
    return firstPosition + mostVisibleIndex;
}
Body of Second Method:
{
    return mViewPager.getCurrentItem();
}
------------------------
Find a silently evolved API code:android.widget.TextView.getTypefaceStyle:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return mTextPaint.getTypeface().getStyle();
}
Body of Second Method:
{
    Typeface typeface = mTextPaint.getTypeface();
    return typeface != null ? typeface.getStyle() : Typeface.NORMAL;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothSocket.bindListen:COMMENT
Method Modifier: default     
Comment:/*package*/

Body of Frist Method:
{
    int ret;
    if (mSocketState == SocketState.CLOSED)
        return EBADFD;
    IBluetooth bluetoothProxy = BluetoothAdapter.getDefaultAdapter().getBluetoothService(null);
    if (bluetoothProxy == null) {
        Log.e(TAG, "bindListen fail, reason: bluetooth is off");
        return -1;
    }
    try {
        mPfd = bluetoothProxy.createSocketChannel(mType, mServiceName, mUuid, mPort, getSecurityFlags());
    } catch (RemoteException e) {
        Log.e(TAG, Log.getStackTraceString(new Throwable()));
        return -1;
    }
    // read out port number
    try {
        synchronized (this) {
            if (DBG)
                Log.d(TAG, "bindListen(), SocketState: " + mSocketState + ", mPfd: " + mPfd);
            if (mSocketState != SocketState.INIT)
                return EBADFD;
            if (mPfd == null)
                return -1;
            FileDescriptor fd = mPfd.getFileDescriptor();
            if (DBG)
                Log.d(TAG, "bindListen(), new LocalSocket ");
            mSocket = new LocalSocket(fd);
            if (DBG)
                Log.d(TAG, "bindListen(), new LocalSocket.getInputStream() ");
            mSocketIS = mSocket.getInputStream();
            mSocketOS = mSocket.getOutputStream();
        }
        if (DBG)
            Log.d(TAG, "bindListen(), readInt mSocketIS: " + mSocketIS);
        int channel = readInt(mSocketIS);
        synchronized (this) {
            if (mSocketState == SocketState.INIT)
                mSocketState = SocketState.LISTENING;
        }
        if (DBG)
            Log.d(TAG, "channel: " + channel);
        if (mPort == -1) {
            mPort = channel;
        }
        // else ASSERT(mPort == channel)
        ret = 0;
    } catch (IOException e) {
        if (mPfd != null) {
            try {
                mPfd.close();
            } catch (IOException e1) {
                Log.e(TAG, "bindListen, close mPfd: " + e1);
            }
            mPfd = null;
        }
        Log.e(TAG, "bindListen, fail to get port number, exception: " + e);
        return -1;
    }
    return ret;
}
Body of Second Method:
{
    int ret;
    if (mSocketState == SocketState.CLOSED)
        return EBADFD;
    IBluetooth bluetoothProxy = BluetoothAdapter.getDefaultAdapter().getBluetoothService(null);
    if (bluetoothProxy == null) {
        Log.e(TAG, "bindListen fail, reason: bluetooth is off");
        return -1;
    }
    try {
        mPfd = bluetoothProxy.createSocketChannel(mType, mServiceName, mUuid, mPort, getSecurityFlags());
    } catch (RemoteException e) {
        Log.e(TAG, Log.getStackTraceString(new Throwable()));
        return -1;
    }
    // read out port number
    try {
        synchronized (this) {
            if (DBG)
                Log.d(TAG, "bindListen(), SocketState: " + mSocketState + ", mPfd: " + mPfd);
            if (mSocketState != SocketState.INIT)
                return EBADFD;
            if (mPfd == null)
                return -1;
            FileDescriptor fd = mPfd.getFileDescriptor();
            if (DBG)
                Log.d(TAG, "bindListen(), new LocalSocket ");
            mSocket = new LocalSocket(fd);
            if (DBG)
                Log.d(TAG, "bindListen(), new LocalSocket.getInputStream() ");
            mSocketIS = mSocket.getInputStream();
            mSocketOS = mSocket.getOutputStream();
        }
        if (DBG)
            Log.d(TAG, "bindListen(), readInt mSocketIS: " + mSocketIS);
        int channel = readInt(mSocketIS);
        synchronized (this) {
            if (mSocketState == SocketState.INIT)
                mSocketState = SocketState.LISTENING;
        }
        if (DBG)
            Log.d(TAG, "channel: " + channel);
        if (mPort <= -1) {
            mPort = channel;
        }
        // else ASSERT(mPort == channel)
        ret = 0;
    } catch (IOException e) {
        if (mPfd != null) {
            try {
                mPfd.close();
            } catch (IOException e1) {
                Log.e(TAG, "bindListen, close mPfd: " + e1);
            }
            mPfd = null;
        }
        Log.e(TAG, "bindListen, fail to get port number, exception: " + e);
        return -1;
    }
    return ret;
}
------------------------
Find a silently evolved API code:android.view.InputEventConsistencyVerifier.onGenericMotionEvent:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Checks a generic motion event.
 * @param event The event.
 * @param nestingLevel The nesting level: 0 if called from the base class,
 * or 1 from a subclass.  If the event was already checked by this consistency verifier
 * at a higher nesting level, it will not be checked again.  Used to handle the situation
 * where a subclass dispatching method delegates to its superclass's dispatching method
 * and both dispatching methods call into the consistency verifier.
 */

Body of Frist Method:
{
    if (!startEvent(event, nestingLevel, EVENT_TYPE_GENERIC_MOTION)) {
        return;
    }
    try {
        ensureMetaStateIsNormalized(event.getMetaState());
        final int action = event.getAction();
        final int source = event.getSource();
        if ((source & InputDevice.SOURCE_CLASS_POINTER) != 0) {
            switch(action) {
                case MotionEvent.ACTION_HOVER_ENTER:
                    ensurePointerCountIsOneForThisAction(event);
                    mHoverEntered = true;
                    break;
                case MotionEvent.ACTION_HOVER_MOVE:
                    ensurePointerCountIsOneForThisAction(event);
                    break;
                case MotionEvent.ACTION_HOVER_EXIT:
                    ensurePointerCountIsOneForThisAction(event);
                    if (!mHoverEntered) {
                        problem("ACTION_HOVER_EXIT without prior ACTION_HOVER_ENTER");
                    }
                    mHoverEntered = false;
                    break;
                case MotionEvent.ACTION_SCROLL:
                    ensureHistorySizeIsZeroForThisAction(event);
                    ensurePointerCountIsOneForThisAction(event);
                    break;
                default:
                    problem("Invalid action for generic pointer event.");
                    break;
            }
        } else if ((source & InputDevice.SOURCE_CLASS_JOYSTICK) != 0) {
            switch(action) {
                case MotionEvent.ACTION_MOVE:
                    ensurePointerCountIsOneForThisAction(event);
                    break;
                default:
                    problem("Invalid action for generic joystick event.");
                    break;
            }
        }
    } finally {
        finishEvent();
    }
}
Body of Second Method:
{
    if (!startEvent(event, nestingLevel, EVENT_TYPE_GENERIC_MOTION)) {
        return;
    }
    try {
        ensureMetaStateIsNormalized(event.getMetaState());
        final int action = event.getAction();
        final int source = event.getSource();
        final int buttonState = event.getButtonState();
        final int actionButton = event.getActionButton();
        if ((source & InputDevice.SOURCE_CLASS_POINTER) != 0) {
            switch(action) {
                case MotionEvent.ACTION_HOVER_ENTER:
                    ensurePointerCountIsOneForThisAction(event);
                    mHoverEntered = true;
                    break;
                case MotionEvent.ACTION_HOVER_MOVE:
                    ensurePointerCountIsOneForThisAction(event);
                    break;
                case MotionEvent.ACTION_HOVER_EXIT:
                    ensurePointerCountIsOneForThisAction(event);
                    if (!mHoverEntered) {
                        problem("ACTION_HOVER_EXIT without prior ACTION_HOVER_ENTER");
                    }
                    mHoverEntered = false;
                    break;
                case MotionEvent.ACTION_SCROLL:
                    ensureHistorySizeIsZeroForThisAction(event);
                    ensurePointerCountIsOneForThisAction(event);
                    break;
                case MotionEvent.ACTION_BUTTON_PRESS:
                    ensureActionButtonIsNonZeroForThisAction(event);
                    if ((mButtonsPressed & actionButton) != 0) {
                        problem("Action button for ACTION_BUTTON_PRESS event is " + actionButton + ", but it has already been pressed and " + "has yet to be released.");
                    }
                    mButtonsPressed |= actionButton;
                    // pressed to prevent spurious errors.
                    if (actionButton == MotionEvent.BUTTON_STYLUS_PRIMARY && (buttonState & MotionEvent.BUTTON_SECONDARY) != 0) {
                        mButtonsPressed |= MotionEvent.BUTTON_SECONDARY;
                    } else if (actionButton == MotionEvent.BUTTON_STYLUS_SECONDARY && (buttonState & MotionEvent.BUTTON_TERTIARY) != 0) {
                        mButtonsPressed |= MotionEvent.BUTTON_TERTIARY;
                    }
                    if (mButtonsPressed != buttonState) {
                        problem(String.format("Reported button state differs from " + "expected button state based on press and release events. " + "Is 0x%08x but expected 0x%08x.", buttonState, mButtonsPressed));
                    }
                    break;
                case MotionEvent.ACTION_BUTTON_RELEASE:
                    ensureActionButtonIsNonZeroForThisAction(event);
                    if ((mButtonsPressed & actionButton) != actionButton) {
                        problem("Action button for ACTION_BUTTON_RELEASE event is " + actionButton + ", but it was either never pressed or has " + "already been released.");
                    }
                    mButtonsPressed &= ~actionButton;
                    // released to prevent spurious errors.
                    if (actionButton == MotionEvent.BUTTON_STYLUS_PRIMARY && (buttonState & MotionEvent.BUTTON_SECONDARY) == 0) {
                        mButtonsPressed &= ~MotionEvent.BUTTON_SECONDARY;
                    } else if (actionButton == MotionEvent.BUTTON_STYLUS_SECONDARY && (buttonState & MotionEvent.BUTTON_TERTIARY) == 0) {
                        mButtonsPressed &= ~MotionEvent.BUTTON_TERTIARY;
                    }
                    if (mButtonsPressed != buttonState) {
                        problem(String.format("Reported button state differs from " + "expected button state based on press and release events. " + "Is 0x%08x but expected 0x%08x.", buttonState, mButtonsPressed));
                    }
                    break;
                default:
                    problem("Invalid action for generic pointer event.");
                    break;
            }
        } else if ((source & InputDevice.SOURCE_CLASS_JOYSTICK) != 0) {
            switch(action) {
                case MotionEvent.ACTION_MOVE:
                    ensurePointerCountIsOneForThisAction(event);
                    break;
                default:
                    problem("Invalid action for generic joystick event.");
                    break;
            }
        }
    } finally {
        finishEvent();
    }
}
------------------------
Find a silently evolved API code:android.media.RemoteDisplay.listen:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Starts listening for displays to be connected on the specified interface.
 *
 * @param iface The interface address and port in the form "x.x.x.x:y".
 * @param listener The listener to invoke when displays are connected or disconnected.
 * @param handler The handler on which to invoke the listener.
 */

Body of Frist Method:
{
    if (iface == null) {
        throw new IllegalArgumentException("iface must not be null");
    }
    if (listener == null) {
        throw new IllegalArgumentException("listener must not be null");
    }
    if (handler == null) {
        throw new IllegalArgumentException("handler must not be null");
    }
    RemoteDisplay display = new RemoteDisplay(listener, handler);
    display.startListening(iface);
    return display;
}
Body of Second Method:
{
    if (iface == null) {
        throw new IllegalArgumentException("iface must not be null");
    }
    if (listener == null) {
        throw new IllegalArgumentException("listener must not be null");
    }
    if (handler == null) {
        throw new IllegalArgumentException("handler must not be null");
    }
    RemoteDisplay display = new RemoteDisplay(listener, handler, opPackageName);
    display.startListening(iface);
    return display;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothSocket.read:COMMENT
Method Modifier: default     
Comment:/*package*/

Body of Frist Method:
{
    if (mSocketIS == null)
        throw new IOException("read is called on null InputStream");
    if (VDBG)
        Log.d(TAG, "read in:  " + mSocketIS + " len: " + length);
    int ret = mSocketIS.read(b, offset, length);
    if (ret < 0)
        throw new IOException("bt socket closed, read return: " + ret);
    if (VDBG)
        Log.d(TAG, "read out:  " + mSocketIS + " ret: " + ret);
    return ret;
}
Body of Second Method:
{
    int ret = 0;
    if (VDBG)
        Log.d(TAG, "read in:  " + mSocketIS + " len: " + length);
    if (mType == TYPE_L2CAP) {
        int bytesToRead = length;
        if (VDBG)
            Log.v(TAG, "l2cap: read(): offset: " + offset + " length:" + length + "mL2capBuffer= " + mL2capBuffer);
        if (mL2capBuffer == null) {
            createL2capRxBuffer();
        }
        if (mL2capBuffer.remaining() == 0) {
            if (VDBG)
                Log.v(TAG, "l2cap buffer empty, refilling...");
            if (fillL2capRxBuffer() == -1) {
                return -1;
            }
        }
        if (bytesToRead > mL2capBuffer.remaining()) {
            bytesToRead = mL2capBuffer.remaining();
        }
        if (VDBG)
            Log.v(TAG, "get(): offset: " + offset + " bytesToRead: " + bytesToRead);
        mL2capBuffer.get(b, offset, bytesToRead);
        ret = bytesToRead;
    } else {
        if (VDBG)
            Log.v(TAG, "default: read(): offset: " + offset + " length:" + length);
        ret = mSocketIS.read(b, offset, length);
    }
    if (ret < 0)
        throw new IOException("bt socket closed, read return: " + ret);
    if (VDBG)
        Log.d(TAG, "read out:  " + mSocketIS + " ret: " + ret);
    return ret;
}
------------------------
Find a silently evolved API code:android.media.MediaDrm.Certificate.getContent:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the PEM-encoded certificate chain
 */

Body of Frist Method:
{
    return mCertificateData;
}
Body of Second Method:
{
    if (mCertificateData == null) {
        // is needed here to guarantee @NonNull annotation.
        throw new RuntimeException("Cerfificate is not initialized");
    }
    return mCertificateData;
}
------------------------
Find a silently evolved API code:javax.obex.ServerSession.handleDisconnectRequest:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Handles a disconnect request from a client. This method will read the
 * rest of the request from the client. Assuming the request is valid, it
 * will create a <code>HeaderSet</code> object to pass to the
 * <code>ServerRequestHandler</code> object. After the handler processes the
 * request, this method will create a reply message to send to the server.
 * @throws IOException if an error occurred at the transport layer
 */

Body of Frist Method:
{
    int length;
    int code = ResponseCodes.OBEX_HTTP_OK;
    int totalLength = 3;
    byte[] head = null;
    int bytesReceived;
    HeaderSet request = new HeaderSet();
    HeaderSet reply = new HeaderSet();
    length = mInput.read();
    length = (length << 8) + mInput.read();
    if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
        code = ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE;
        totalLength = 3;
    } else {
        if (length > 3) {
            byte[] headers = new byte[length - 3];
            bytesReceived = mInput.read(headers);
            while (bytesReceived != headers.length) {
                bytesReceived += mInput.read(headers, bytesReceived, headers.length - bytesReceived);
            }
            ObexHelper.updateHeaderSet(request, headers);
        }
        if (mListener.getConnectionId() != -1 && request.mConnectionID != null) {
            mListener.setConnectionId(ObexHelper.convertToLong(request.mConnectionID));
        } else {
            mListener.setConnectionId(1);
        }
        if (request.mAuthResp != null) {
            if (!handleAuthResp(request.mAuthResp)) {
                code = ResponseCodes.OBEX_HTTP_UNAUTHORIZED;
                mListener.onAuthenticationFailure(ObexHelper.getTagValue((byte) 0x01, request.mAuthResp));
            }
            request.mAuthResp = null;
        }
        if (code != ResponseCodes.OBEX_HTTP_UNAUTHORIZED) {
            if (request.mAuthChall != null) {
                handleAuthChall(request);
                request.mAuthChall = null;
            }
            try {
                mListener.onDisconnect(request, reply);
            } catch (Exception e) {
                sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR, null);
                return;
            }
            long id = mListener.getConnectionId();
            if (id == -1) {
                reply.mConnectionID = null;
            } else {
                reply.mConnectionID = ObexHelper.convertToByteArray(id);
            }
            head = ObexHelper.createHeader(reply, false);
            totalLength += head.length;
            if (totalLength > mMaxPacketLength) {
                totalLength = 3;
                head = null;
                code = ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
            }
        }
    }
    // Compute Length of OBEX CONNECT packet
    byte[] replyData;
    if (head != null) {
        replyData = new byte[3 + head.length];
    } else {
        replyData = new byte[3];
    }
    replyData[0] = (byte) code;
    replyData[1] = (byte) (totalLength >> 8);
    replyData[2] = (byte) totalLength;
    if (head != null) {
        System.arraycopy(head, 0, replyData, 3, head.length);
    }
    /*
         * Write the OBEX DISCONNECT packet to the server. Byte 0: response code
         * Byte 1&2: Connect Packet Length Byte 3 to n: headers
         */
    mOutput.write(replyData);
    mOutput.flush();
}
Body of Second Method:
{
    int length;
    int code = ResponseCodes.OBEX_HTTP_OK;
    int totalLength = 3;
    byte[] head = null;
    int bytesReceived;
    HeaderSet request = new HeaderSet();
    HeaderSet reply = new HeaderSet();
    length = mInput.read();
    length = (length << 8) + mInput.read();
    if (length > ObexHelper.getMaxRxPacketSize(mTransport)) {
        code = ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE;
        totalLength = 3;
    } else {
        if (length > 3) {
            byte[] headers = new byte[length - 3];
            bytesReceived = mInput.read(headers);
            while (bytesReceived != headers.length) {
                bytesReceived += mInput.read(headers, bytesReceived, headers.length - bytesReceived);
            }
            ObexHelper.updateHeaderSet(request, headers);
        }
        if (mListener.getConnectionId() != -1 && request.mConnectionID != null) {
            mListener.setConnectionId(ObexHelper.convertToLong(request.mConnectionID));
        } else {
            mListener.setConnectionId(1);
        }
        if (request.mAuthResp != null) {
            if (!handleAuthResp(request.mAuthResp)) {
                code = ResponseCodes.OBEX_HTTP_UNAUTHORIZED;
                mListener.onAuthenticationFailure(ObexHelper.getTagValue((byte) 0x01, request.mAuthResp));
            }
            request.mAuthResp = null;
        }
        if (code != ResponseCodes.OBEX_HTTP_UNAUTHORIZED) {
            if (request.mAuthChall != null) {
                handleAuthChall(request);
                request.mAuthChall = null;
            }
            try {
                mListener.onDisconnect(request, reply);
            } catch (Exception e) {
                if (V)
                    Log.d(TAG, "Exception occured - sending OBEX_HTTP_INTERNAL_ERROR reply", e);
                sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR, null);
                return;
            }
            long id = mListener.getConnectionId();
            if (id == -1) {
                reply.mConnectionID = null;
            } else {
                reply.mConnectionID = ObexHelper.convertToByteArray(id);
            }
            head = ObexHelper.createHeader(reply, false);
            totalLength += head.length;
            if (totalLength > mMaxPacketLength) {
                totalLength = 3;
                head = null;
                code = ResponseCodes.OBEX_HTTP_INTERNAL_ERROR;
            }
        }
    }
    // Compute Length of OBEX CONNECT packet
    byte[] replyData;
    if (head != null) {
        replyData = new byte[3 + head.length];
    } else {
        replyData = new byte[3];
    }
    replyData[0] = (byte) code;
    replyData[1] = (byte) (totalLength >> 8);
    replyData[2] = (byte) totalLength;
    if (head != null) {
        System.arraycopy(head, 0, replyData, 3, head.length);
    }
    /*
         * Write the OBEX DISCONNECT packet to the server. Byte 0: response code
         * Byte 1&2: Connect Packet Length Byte 3 to n: headers
         */
    mOutput.write(replyData);
    mOutput.flush();
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiActivityEnergyInfo.getControllerIdleTimeMillis:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @return idle time in ms
 */

Body of Frist Method:
{
    return (int) mControllerIdleTimeMs;
}
Body of Second Method:
{
    return mControllerIdleTimeMs;
}
------------------------
Find a silently evolved API code:android.media.AudioTrack.isMultichannelConfigSupported:COMMENT
Method Modifier: private     static      
Comment:/**
 * Convenience method to check that the channel configuration (a.k.a channel mask) is supported
 * @param channelConfig the mask to validate
 * @return false if the AudioTrack can't be used with such a mask
 */

Body of Frist Method:
{
    // check for unsupported channels
    if ((channelConfig & SUPPORTED_OUT_CHANNELS) != channelConfig) {
        loge("Channel configuration features unsupported channels");
        return false;
    }
    final int channelCount = Integer.bitCount(channelConfig);
    if (channelCount > CHANNEL_COUNT_MAX) {
        loge("Channel configuration contains too many channels " + channelCount + ">" + CHANNEL_COUNT_MAX);
        return false;
    }
    // check for unsupported multichannel combinations:
    // - FL/FR must be present
    // - L/R channels must be paired (e.g. no single L channel)
    final int frontPair = AudioFormat.CHANNEL_OUT_FRONT_LEFT | AudioFormat.CHANNEL_OUT_FRONT_RIGHT;
    if ((channelConfig & frontPair) != frontPair) {
        loge("Front channels must be present in multichannel configurations");
        return false;
    }
    final int backPair = AudioFormat.CHANNEL_OUT_BACK_LEFT | AudioFormat.CHANNEL_OUT_BACK_RIGHT;
    if ((channelConfig & backPair) != 0) {
        if ((channelConfig & backPair) != backPair) {
            loge("Rear channels can't be used independently");
            return false;
        }
    }
    final int sidePair = AudioFormat.CHANNEL_OUT_SIDE_LEFT | AudioFormat.CHANNEL_OUT_SIDE_RIGHT;
    if ((channelConfig & sidePair) != 0 && (channelConfig & sidePair) != sidePair) {
        loge("Side channels can't be used independently");
        return false;
    }
    return true;
}
Body of Second Method:
{
    // check for unsupported channels
    if ((channelConfig & SUPPORTED_OUT_CHANNELS) != channelConfig) {
        loge("Channel configuration features unsupported channels");
        return false;
    }
    final int channelCount = AudioFormat.channelCountFromOutChannelMask(channelConfig);
    if (channelCount > CHANNEL_COUNT_MAX) {
        loge("Channel configuration contains too many channels " + channelCount + ">" + CHANNEL_COUNT_MAX);
        return false;
    }
    // check for unsupported multichannel combinations:
    // - FL/FR must be present
    // - L/R channels must be paired (e.g. no single L channel)
    final int frontPair = AudioFormat.CHANNEL_OUT_FRONT_LEFT | AudioFormat.CHANNEL_OUT_FRONT_RIGHT;
    if ((channelConfig & frontPair) != frontPair) {
        loge("Front channels must be present in multichannel configurations");
        return false;
    }
    final int backPair = AudioFormat.CHANNEL_OUT_BACK_LEFT | AudioFormat.CHANNEL_OUT_BACK_RIGHT;
    if ((channelConfig & backPair) != 0) {
        if ((channelConfig & backPair) != backPair) {
            loge("Rear channels can't be used independently");
            return false;
        }
    }
    final int sidePair = AudioFormat.CHANNEL_OUT_SIDE_LEFT | AudioFormat.CHANNEL_OUT_SIDE_RIGHT;
    if ((channelConfig & sidePair) != 0 && (channelConfig & sidePair) != sidePair) {
        loge("Side channels can't be used independently");
        return false;
    }
    return true;
}
------------------------
Find a silently evolved API code:android.os.storage.StorageVolume.getDescription:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns a user visible description of the volume.
 *
 * @return the volume description
 */

Body of Frist Method:
{
    return context.getResources().getString(mDescriptionId);
}
Body of Second Method:
{
    return mDescription;
}
------------------------
Find a silently evolved API code:android.os.StrictMode.VmPolicy.Builder.detectAll:COMMENT
Method Modifier: public      
Comment:/**
 * Detect everything that's potentially suspect.
 *
 * <p>In the Honeycomb release this includes leaks of
 * SQLite cursors, Activities, and other closable objects
 * but will likely expand in future releases.
 */

Body of Frist Method:
{
    return enable(DETECT_VM_ACTIVITY_LEAKS | DETECT_VM_CURSOR_LEAKS | DETECT_VM_CLOSABLE_LEAKS | DETECT_VM_REGISTRATION_LEAKS | DETECT_VM_FILE_URI_EXPOSURE);
}
Body of Second Method:
{
    int flags = DETECT_VM_ACTIVITY_LEAKS | DETECT_VM_CURSOR_LEAKS | DETECT_VM_CLOSABLE_LEAKS | DETECT_VM_REGISTRATION_LEAKS | DETECT_VM_FILE_URI_EXPOSURE;
    // for apps to mark sockets that should be ignored
    if (SystemProperties.getBoolean(CLEARTEXT_PROPERTY, false)) {
        flags |= DETECT_VM_CLEARTEXT_NETWORK;
    }
    return enable(flags);
}
------------------------
Find a silently evolved API code:android.transition.Transition.playTransition:COMMENT
Method Modifier: default     
Comment:/**
 * Called by TransitionManager to play the transition. This calls
 * createAnimators() to set things up and create all of the animations and then
 * runAnimations() to actually start the animations.
 */

Body of Frist Method:
{
    mStartValuesList = new ArrayList<TransitionValues>();
    mEndValuesList = new ArrayList<TransitionValues>();
    matchStartAndEnd(mStartValues, mEndValues);
    ArrayMap<Animator, AnimationInfo> runningAnimators = getRunningAnimators();
    int numOldAnims = runningAnimators.size();
    WindowId windowId = sceneRoot.getWindowId();
    for (int i = numOldAnims - 1; i >= 0; i--) {
        Animator anim = runningAnimators.keyAt(i);
        if (anim != null) {
            AnimationInfo oldInfo = runningAnimators.get(anim);
            if (oldInfo != null && oldInfo.view != null && oldInfo.windowId == windowId) {
                TransitionValues oldValues = oldInfo.values;
                View oldView = oldInfo.view;
                TransitionValues startValues = getTransitionValues(oldView, true);
                TransitionValues endValues = getMatchedTransitionValues(oldView, true);
                boolean cancel = (startValues != null || endValues != null) && oldInfo.transition.areValuesChanged(oldValues, endValues);
                if (cancel) {
                    if (anim.isRunning() || anim.isStarted()) {
                        if (DBG) {
                            Log.d(LOG_TAG, "Canceling anim " + anim);
                        }
                        anim.cancel();
                    } else {
                        if (DBG) {
                            Log.d(LOG_TAG, "removing anim from info list: " + anim);
                        }
                        runningAnimators.remove(anim);
                    }
                }
            }
        }
    }
    createAnimators(sceneRoot, mStartValues, mEndValues, mStartValuesList, mEndValuesList);
    runAnimators();
}
Body of Second Method:
{
    mStartValuesList = new ArrayList<TransitionValues>();
    mEndValuesList = new ArrayList<TransitionValues>();
    matchStartAndEnd(mStartValues, mEndValues);
    ArrayMap<Animator, AnimationInfo> runningAnimators = getRunningAnimators();
    int numOldAnims = runningAnimators.size();
    WindowId windowId = sceneRoot.getWindowId();
    for (int i = numOldAnims - 1; i >= 0; i--) {
        Animator anim = runningAnimators.keyAt(i);
        if (anim != null) {
            AnimationInfo oldInfo = runningAnimators.get(anim);
            if (oldInfo != null && oldInfo.view != null && oldInfo.windowId == windowId) {
                TransitionValues oldValues = oldInfo.values;
                View oldView = oldInfo.view;
                TransitionValues startValues = getTransitionValues(oldView, true);
                TransitionValues endValues = getMatchedTransitionValues(oldView, true);
                if (startValues == null && endValues == null) {
                    endValues = mEndValues.viewValues.get(oldView);
                }
                boolean cancel = (startValues != null || endValues != null) && oldInfo.transition.isTransitionRequired(oldValues, endValues);
                if (cancel) {
                    if (anim.isRunning() || anim.isStarted()) {
                        if (DBG) {
                            Log.d(LOG_TAG, "Canceling anim " + anim);
                        }
                        anim.cancel();
                    } else {
                        if (DBG) {
                            Log.d(LOG_TAG, "removing anim from info list: " + anim);
                        }
                        runningAnimators.remove(anim);
                    }
                }
            }
        }
    }
    createAnimators(sceneRoot, mStartValues, mEndValues, mStartValuesList, mEndValuesList);
    runAnimators();
}
------------------------
Find a silently evolved API code:android.content.ContentResolver.call:COMMENT
Method Modifier: public      final       
Comment:/**
 * Call a provider-defined method.  This can be used to implement
 * read or write interfaces which are cheaper than using a Cursor and/or
 * do not fit into the traditional table model.
 *
 * @param method provider-defined method name to call.  Opaque to
 * framework, but must be non-null.
 * @param arg provider-defined String argument.  May be null.
 * @param extras provider-defined Bundle argument.  May be null.
 * @return a result Bundle, possibly null.  Will be null if the ContentProvider
 * does not implement call.
 * @throws NullPointerException if uri or method is null
 * @throws IllegalArgumentException if uri is not known
 */

Body of Frist Method:
{
    if (uri == null) {
        throw new NullPointerException("uri == null");
    }
    if (method == null) {
        throw new NullPointerException("method == null");
    }
    IContentProvider provider = acquireProvider(uri);
    if (provider == null) {
        throw new IllegalArgumentException("Unknown URI " + uri);
    }
    try {
        return provider.call(mPackageName, method, arg, extras);
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } finally {
        releaseProvider(provider);
    }
}
Body of Second Method:
{
    Preconditions.checkNotNull(uri, "uri");
    Preconditions.checkNotNull(method, "method");
    IContentProvider provider = acquireProvider(uri);
    if (provider == null) {
        throw new IllegalArgumentException("Unknown URI " + uri);
    }
    try {
        return provider.call(mPackageName, method, arg, extras);
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } finally {
        releaseProvider(provider);
    }
}
------------------------
Find a silently evolved API code:javax.obex.ClientOperation.continueOperation:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Continues the operation since there is no data to read.
 * @param sendEmpty <code>true</code> if the operation should send an empty
 * packet or not send anything if there is no data to send
 * @param inStream <code>true</code> if the stream is input stream or is
 * output stream
 * @throws IOException if an IO error occurs
 */

Body of Frist Method:
{
    if (mGetOperation) {
        if ((inStream) && (!mOperationDone)) {
            // to deal with inputstream in get operation
            mParent.sendRequest(0x83, null, mReplyHeader, mPrivateInput);
            /*
                  * Determine if that was not the last packet in the operation
                  */
            if (mReplyHeader.responseCode != ResponseCodes.OBEX_HTTP_CONTINUE) {
                mOperationDone = true;
            }
            return true;
        } else if ((!inStream) && (!mOperationDone)) {
            if (mPrivateInput == null) {
                mPrivateInput = new PrivateInputStream(this);
            }
            if (!mGetFinalFlag) {
                sendRequest(0x03);
            } else {
                sendRequest(0x83);
                if (mReplyHeader.responseCode != ResponseCodes.OBEX_HTTP_CONTINUE) {
                    mOperationDone = true;
                }
            }
            return true;
        } else if (mOperationDone) {
            return false;
        }
    } else {
        if ((!inStream) && (!mOperationDone)) {
            // to deal with outputstream in put operation
            if (mReplyHeader.responseCode == -1) {
                mReplyHeader.responseCode = ResponseCodes.OBEX_HTTP_CONTINUE;
            }
            sendRequest(0x02);
            return true;
        } else if ((inStream) && (!mOperationDone)) {
            // How to deal with inputstream  in put operation ?
            return false;
        } else if (mOperationDone) {
            return false;
        }
    }
    return false;
}
Body of Second Method:
{
    if (mGetOperation) {
        if ((inStream) && (!mOperationDone)) {
            // to deal with inputstream in get operation
            mParent.sendRequest(ObexHelper.OBEX_OPCODE_GET_FINAL, null, mReplyHeader, mPrivateInput, mSrmActive);
            /*
                  * Determine if that was not the last packet in the operation
                  */
            if (mReplyHeader.responseCode != ResponseCodes.OBEX_HTTP_CONTINUE) {
                mOperationDone = true;
            } else {
                checkForSrm();
            }
            return true;
        } else if ((!inStream) && (!mOperationDone)) {
            if (mPrivateInput == null) {
                mPrivateInput = new PrivateInputStream(this);
            }
            sendRequest(ObexHelper.OBEX_OPCODE_GET);
            return true;
        } else if (mOperationDone) {
            return false;
        }
    } else {
        // PUT operation
        if ((!inStream) && (!mOperationDone)) {
            // to deal with outputstream in put operation
            if (mReplyHeader.responseCode == -1) {
                mReplyHeader.responseCode = ResponseCodes.OBEX_HTTP_CONTINUE;
            }
            sendRequest(ObexHelper.OBEX_OPCODE_PUT);
            return true;
        } else if ((inStream) && (!mOperationDone)) {
            // How to deal with inputstream  in put operation ?
            return false;
        } else if (mOperationDone) {
            return false;
        }
    }
    return false;
}
------------------------
Find a silently evolved API code:android.graphics.Bitmap.getRowBytes:COMMENT
Method Modifier: public      final       
Comment:/**
 * Return the number of bytes between rows in the bitmap's pixels. Note that
 * this refers to the pixels as stored natively by the bitmap. If you call
 * getPixels() or setPixels(), then the pixels are uniformly treated as
 * 32bit values, packed according to the Color class.
 *
 * <p>As of {@link android.os.Build.VERSION_CODES#KITKAT}, this method
 * should not be used to calculate the memory usage of the bitmap. Instead,
 * see {@link #getAllocationByteCount()}.
 *
 * @return number of bytes between rows of the native bitmap pixels.
 */

Body of Frist Method:
{
    return nativeRowBytes(mNativeBitmap);
}
Body of Second Method:
{
    if (mRecycled) {
        Log.w(TAG, "Called getRowBytes() on a recycle()'d bitmap! This is undefined behavior!");
    }
    return nativeRowBytes(mFinalizer.mNativeBitmap);
}
------------------------
Find a silently evolved API code:android.graphics.Bitmap.getWidth:COMMENT
Method Modifier: public      final       
Comment:/**
 * Returns the bitmap's width
 */

Body of Frist Method:
{
    return mWidth;
}
Body of Second Method:
{
    if (mRecycled) {
        Log.w(TAG, "Called getWidth() on a recycle()'d bitmap! This is undefined behavior!");
    }
    return mWidth;
}
------------------------
Find a silently evolved API code:android.animation.ValueAnimator.reverse:COMMENT
Method Modifier: public      
Comment:/**
 * Plays the ValueAnimator in reverse. If the animation is already running,
 * it will stop itself and play backwards from the point reached when reverse was called.
 * If the animation is not currently running, then it will start from the end and
 * play backwards. This behavior is only set for the current animation; future playing
 * of the animation will use the default behavior of playing forward.
 */

Body of Frist Method:
{
    mPlayingBackwards = !mPlayingBackwards;
    if (mPlayingState == RUNNING) {
        long currentTime = AnimationUtils.currentAnimationTimeMillis();
        long currentPlayTime = currentTime - mStartTime;
        long timeLeft = mDuration - currentPlayTime;
        mStartTime = currentTime - timeLeft;
        mReversing = !mReversing;
    } else if (mStarted) {
        end();
    } else {
        start(true);
    }
}
Body of Second Method:
{
    mPlayingBackwards = !mPlayingBackwards;
    if (mPlayingState == RUNNING) {
        long currentTime = AnimationUtils.currentAnimationTimeMillis();
        long currentPlayTime = currentTime - mStartTime;
        long timeLeft = mDuration - currentPlayTime;
        mStartTime = currentTime - timeLeft;
        // do not allow start time to be compensated for jank
        mStartTimeCommitted = true;
        mReversing = !mReversing;
    } else if (mStarted) {
        end();
    } else {
        start(true);
    }
}
------------------------
Find a silently evolved API code:android.media.MediaDrm.Certificate.getWrappedPrivateKey:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the wrapped private key data
 */

Body of Frist Method:
{
    return mWrappedKey;
}
Body of Second Method:
{
    if (mWrappedKey == null) {
        // is needed here to guarantee @NonNull annotation.
        throw new RuntimeException("Cerfificate is not initialized");
    }
    return mWrappedKey;
}
------------------------
Find a silently evolved API code:android.graphics.Bitmap.hasAlpha:COMMENT
Method Modifier: public      final       
Comment:/**
 * Returns true if the bitmap's config supports per-pixel alpha, and
 * if the pixels may contain non-opaque alpha values. For some configs,
 * this is always false (e.g. RGB_565), since they do not support per-pixel
 * alpha. However, for configs that do, the bitmap may be flagged to be
 * known that all of its pixels are opaque. In this case hasAlpha() will
 * also return false. If a config such as ARGB_8888 is not so flagged,
 * it will return true by default.
 */

Body of Frist Method:
{
    return nativeHasAlpha(mNativeBitmap);
}
Body of Second Method:
{
    if (mRecycled) {
        Log.w(TAG, "Called hasAlpha() on a recycle()'d bitmap! This is undefined behavior!");
    }
    return nativeHasAlpha(mFinalizer.mNativeBitmap);
}
------------------------
Find a silently evolved API code:android.widget.Spinner.setUpChild:COMMENT
Method Modifier: private     
Comment:/**
 * Helper for makeAndAddView to set the position of a view
 * and fill out its layout paramters.
 *
 * @param child The view to position
 * @param addChild true if the child should be added to the Spinner during setup
 */

Body of Frist Method:
{
    // Respect layout params that are already in the view. Otherwise
    // make some up...
    ViewGroup.LayoutParams lp = child.getLayoutParams();
    if (lp == null) {
        lp = generateDefaultLayoutParams();
    }
    if (addChild) {
        addViewInLayout(child, 0, lp);
    }
    child.setSelected(hasFocus());
    if (mDisableChildrenWhenDisabled) {
        child.setEnabled(isEnabled());
    }
    // Get measure specs
    int childHeightSpec = ViewGroup.getChildMeasureSpec(mHeightMeasureSpec, mSpinnerPadding.top + mSpinnerPadding.bottom, lp.height);
    int childWidthSpec = ViewGroup.getChildMeasureSpec(mWidthMeasureSpec, mSpinnerPadding.left + mSpinnerPadding.right, lp.width);
    // Measure child
    child.measure(childWidthSpec, childHeightSpec);
    int childLeft;
    int childRight;
    // Position vertically based on gravity setting
    int childTop = mSpinnerPadding.top + ((getMeasuredHeight() - mSpinnerPadding.bottom - mSpinnerPadding.top - child.getMeasuredHeight()) / 2);
    int childBottom = childTop + child.getMeasuredHeight();
    int width = child.getMeasuredWidth();
    childLeft = 0;
    childRight = childLeft + width;
    child.layout(childLeft, childTop, childRight, childBottom);
}
Body of Second Method:
{
    // Respect layout params that are already in the view. Otherwise
    // make some up...
    ViewGroup.LayoutParams lp = child.getLayoutParams();
    if (lp == null) {
        lp = generateDefaultLayoutParams();
    }
    addViewInLayout(child, 0, lp);
    child.setSelected(hasFocus());
    if (mDisableChildrenWhenDisabled) {
        child.setEnabled(isEnabled());
    }
    // Get measure specs
    int childHeightSpec = ViewGroup.getChildMeasureSpec(mHeightMeasureSpec, mSpinnerPadding.top + mSpinnerPadding.bottom, lp.height);
    int childWidthSpec = ViewGroup.getChildMeasureSpec(mWidthMeasureSpec, mSpinnerPadding.left + mSpinnerPadding.right, lp.width);
    // Measure child
    child.measure(childWidthSpec, childHeightSpec);
    int childLeft;
    int childRight;
    // Position vertically based on gravity setting
    int childTop = mSpinnerPadding.top + ((getMeasuredHeight() - mSpinnerPadding.bottom - mSpinnerPadding.top - child.getMeasuredHeight()) / 2);
    int childBottom = childTop + child.getMeasuredHeight();
    int width = child.getMeasuredWidth();
    childLeft = 0;
    childRight = childLeft + width;
    child.layout(childLeft, childTop, childRight, childBottom);
    if (!addChild) {
        removeViewInLayout(child);
    }
}
------------------------
Find a silently evolved API code:android.widget.NumberPicker.setMaxValue:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the max value of the picker.
 *
 * @param maxValue The max value inclusive.
 *
 * <strong>Note:</strong> The length of the displayed values array
 * set via {@link #setDisplayedValues(String[])} must be equal to the
 * range of selectable numbers which is equal to
 * {@link #getMaxValue()} - {@link #getMinValue()} + 1.
 */

Body of Frist Method:
{
    if (mMaxValue == maxValue) {
        return;
    }
    if (maxValue < 0) {
        throw new IllegalArgumentException("maxValue must be >= 0");
    }
    mMaxValue = maxValue;
    if (mMaxValue < mValue) {
        mValue = mMaxValue;
    }
    boolean wrapSelectorWheel = mMaxValue - mMinValue > mSelectorIndices.length;
    setWrapSelectorWheel(wrapSelectorWheel);
    initializeSelectorWheelIndices();
    updateInputTextView();
    tryComputeMaxWidth();
    invalidate();
}
Body of Second Method:
{
    if (mMaxValue == maxValue) {
        return;
    }
    if (maxValue < 0) {
        throw new IllegalArgumentException("maxValue must be >= 0");
    }
    mMaxValue = maxValue;
    if (mMaxValue < mValue) {
        mValue = mMaxValue;
    }
    updateWrapSelectorWheel();
    initializeSelectorWheelIndices();
    updateInputTextView();
    tryComputeMaxWidth();
    invalidate();
}
------------------------
Find a silently evolved API code:android.os.storage.StorageVolume.getFatVolumeId:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Parse and return volume UUID as FAT volume ID, or return -1 if unable to
 * parse or UUID is unknown.
 */

Body of Frist Method:
{
    if (mUuid == null || mUuid.length() != 9) {
        return -1;
    }
    try {
        return (int) Long.parseLong(mUuid.replace("-", ""), 16);
    } catch (NumberFormatException e) {
        return -1;
    }
}
Body of Second Method:
{
    if (mFsUuid == null || mFsUuid.length() != 9) {
        return -1;
    }
    try {
        return (int) Long.parseLong(mFsUuid.replace("-", ""), 16);
    } catch (NumberFormatException e) {
        return -1;
    }
}
------------------------
Find a silently evolved API code:android.telephony.DisconnectCause.toString:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Returns descriptive string for the specified disconnect cause.
 */

Body of Frist Method:
{
    switch(cause) {
        case NOT_DISCONNECTED:
            return "NOT_DISCONNECTED";
        case INCOMING_MISSED:
            return "INCOMING_MISSED";
        case NORMAL:
            return "NORMAL";
        case LOCAL:
            return "LOCAL";
        case BUSY:
            return "BUSY";
        case CONGESTION:
            return "CONGESTION";
        case INVALID_NUMBER:
            return "INVALID_NUMBER";
        case NUMBER_UNREACHABLE:
            return "NUMBER_UNREACHABLE";
        case SERVER_UNREACHABLE:
            return "SERVER_UNREACHABLE";
        case INVALID_CREDENTIALS:
            return "INVALID_CREDENTIALS";
        case OUT_OF_NETWORK:
            return "OUT_OF_NETWORK";
        case SERVER_ERROR:
            return "SERVER_ERROR";
        case TIMED_OUT:
            return "TIMED_OUT";
        case LOST_SIGNAL:
            return "LOST_SIGNAL";
        case LIMIT_EXCEEDED:
            return "LIMIT_EXCEEDED";
        case INCOMING_REJECTED:
            return "INCOMING_REJECTED";
        case POWER_OFF:
            return "POWER_OFF";
        case OUT_OF_SERVICE:
            return "OUT_OF_SERVICE";
        case ICC_ERROR:
            return "ICC_ERROR";
        case CALL_BARRED:
            return "CALL_BARRED";
        case FDN_BLOCKED:
            return "FDN_BLOCKED";
        case CS_RESTRICTED:
            return "CS_RESTRICTED";
        case CS_RESTRICTED_NORMAL:
            return "CS_RESTRICTED_NORMAL";
        case CS_RESTRICTED_EMERGENCY:
            return "CS_RESTRICTED_EMERGENCY";
        case UNOBTAINABLE_NUMBER:
            return "UNOBTAINABLE_NUMBER";
        case CDMA_LOCKED_UNTIL_POWER_CYCLE:
            return "CDMA_LOCKED_UNTIL_POWER_CYCLE";
        case CDMA_DROP:
            return "CDMA_DROP";
        case CDMA_INTERCEPT:
            return "CDMA_INTERCEPT";
        case CDMA_REORDER:
            return "CDMA_REORDER";
        case CDMA_SO_REJECT:
            return "CDMA_SO_REJECT";
        case CDMA_RETRY_ORDER:
            return "CDMA_RETRY_ORDER";
        case CDMA_ACCESS_FAILURE:
            return "CDMA_ACCESS_FAILURE";
        case CDMA_PREEMPTED:
            return "CDMA_PREEMPTED";
        case CDMA_NOT_EMERGENCY:
            return "CDMA_NOT_EMERGENCY";
        case CDMA_ACCESS_BLOCKED:
            return "CDMA_ACCESS_BLOCKED";
        case EMERGENCY_ONLY:
            return "EMERGENCY_ONLY";
        case NO_PHONE_NUMBER_SUPPLIED:
            return "NO_PHONE_NUMBER_SUPPLIED";
        case DIALED_MMI:
            return "DIALED_MMI";
        case VOICEMAIL_NUMBER_MISSING:
            return "VOICEMAIL_NUMBER_MISSING";
        case CDMA_CALL_LOST:
            return "CDMA_CALL_LOST";
        case EXITED_ECM:
            return "EXITED_ECM";
        case DIAL_MODIFIED_TO_USSD:
            return "DIAL_MODIFIED_TO_USSD";
        case DIAL_MODIFIED_TO_SS:
            return "DIAL_MODIFIED_TO_SS";
        case DIAL_MODIFIED_TO_DIAL:
            return "DIAL_MODIFIED_TO_DIAL";
        case ERROR_UNSPECIFIED:
            return "ERROR_UNSPECIFIED";
        case OUTGOING_FAILURE:
            return "OUTGOING_FAILURE";
        case OUTGOING_CANCELED:
            return "OUTGOING_CANCELED";
        case IMS_MERGED_SUCCESSFULLY:
            return "IMS_MERGED_SUCCESSFULLY";
        default:
            return "INVALID: " + cause;
    }
}
Body of Second Method:
{
    switch(cause) {
        case NOT_DISCONNECTED:
            return "NOT_DISCONNECTED";
        case INCOMING_MISSED:
            return "INCOMING_MISSED";
        case NORMAL:
            return "NORMAL";
        case LOCAL:
            return "LOCAL";
        case BUSY:
            return "BUSY";
        case CONGESTION:
            return "CONGESTION";
        case INVALID_NUMBER:
            return "INVALID_NUMBER";
        case NUMBER_UNREACHABLE:
            return "NUMBER_UNREACHABLE";
        case SERVER_UNREACHABLE:
            return "SERVER_UNREACHABLE";
        case INVALID_CREDENTIALS:
            return "INVALID_CREDENTIALS";
        case OUT_OF_NETWORK:
            return "OUT_OF_NETWORK";
        case SERVER_ERROR:
            return "SERVER_ERROR";
        case TIMED_OUT:
            return "TIMED_OUT";
        case LOST_SIGNAL:
            return "LOST_SIGNAL";
        case LIMIT_EXCEEDED:
            return "LIMIT_EXCEEDED";
        case INCOMING_REJECTED:
            return "INCOMING_REJECTED";
        case POWER_OFF:
            return "POWER_OFF";
        case OUT_OF_SERVICE:
            return "OUT_OF_SERVICE";
        case ICC_ERROR:
            return "ICC_ERROR";
        case CALL_BARRED:
            return "CALL_BARRED";
        case FDN_BLOCKED:
            return "FDN_BLOCKED";
        case CS_RESTRICTED:
            return "CS_RESTRICTED";
        case CS_RESTRICTED_NORMAL:
            return "CS_RESTRICTED_NORMAL";
        case CS_RESTRICTED_EMERGENCY:
            return "CS_RESTRICTED_EMERGENCY";
        case UNOBTAINABLE_NUMBER:
            return "UNOBTAINABLE_NUMBER";
        case CDMA_LOCKED_UNTIL_POWER_CYCLE:
            return "CDMA_LOCKED_UNTIL_POWER_CYCLE";
        case CDMA_DROP:
            return "CDMA_DROP";
        case CDMA_INTERCEPT:
            return "CDMA_INTERCEPT";
        case CDMA_REORDER:
            return "CDMA_REORDER";
        case CDMA_SO_REJECT:
            return "CDMA_SO_REJECT";
        case CDMA_RETRY_ORDER:
            return "CDMA_RETRY_ORDER";
        case CDMA_ACCESS_FAILURE:
            return "CDMA_ACCESS_FAILURE";
        case CDMA_PREEMPTED:
            return "CDMA_PREEMPTED";
        case CDMA_NOT_EMERGENCY:
            return "CDMA_NOT_EMERGENCY";
        case CDMA_ACCESS_BLOCKED:
            return "CDMA_ACCESS_BLOCKED";
        case EMERGENCY_ONLY:
            return "EMERGENCY_ONLY";
        case NO_PHONE_NUMBER_SUPPLIED:
            return "NO_PHONE_NUMBER_SUPPLIED";
        case DIALED_MMI:
            return "DIALED_MMI";
        case VOICEMAIL_NUMBER_MISSING:
            return "VOICEMAIL_NUMBER_MISSING";
        case CDMA_CALL_LOST:
            return "CDMA_CALL_LOST";
        case EXITED_ECM:
            return "EXITED_ECM";
        case DIAL_MODIFIED_TO_USSD:
            return "DIAL_MODIFIED_TO_USSD";
        case DIAL_MODIFIED_TO_SS:
            return "DIAL_MODIFIED_TO_SS";
        case DIAL_MODIFIED_TO_DIAL:
            return "DIAL_MODIFIED_TO_DIAL";
        case ERROR_UNSPECIFIED:
            return "ERROR_UNSPECIFIED";
        case OUTGOING_FAILURE:
            return "OUTGOING_FAILURE";
        case OUTGOING_CANCELED:
            return "OUTGOING_CANCELED";
        case IMS_MERGED_SUCCESSFULLY:
            return "IMS_MERGED_SUCCESSFULLY";
        case CDMA_ALREADY_ACTIVATED:
            return "CDMA_ALREADY_ACTIVATED";
        default:
            return "INVALID: " + cause;
    }
}
------------------------
Find a silently evolved API code:android.print.PrinterCapabilitiesInfo.copyFrom:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (this == other) {
        return;
    }
    mMinMargins = other.mMinMargins;
    if (other.mMediaSizes != null) {
        if (mMediaSizes != null) {
            mMediaSizes.clear();
            mMediaSizes.addAll(other.mMediaSizes);
        } else {
            mMediaSizes = new ArrayList<MediaSize>(other.mMediaSizes);
        }
    } else {
        mMediaSizes = null;
    }
    if (other.mResolutions != null) {
        if (mResolutions != null) {
            mResolutions.clear();
            mResolutions.addAll(other.mResolutions);
        } else {
            mResolutions = new ArrayList<Resolution>(other.mResolutions);
        }
    } else {
        mResolutions = null;
    }
    mColorModes = other.mColorModes;
    final int defaultCount = other.mDefaults.length;
    for (int i = 0; i < defaultCount; i++) {
        mDefaults[i] = other.mDefaults[i];
    }
}
Body of Second Method:
{
    if (this == other) {
        return;
    }
    mMinMargins = other.mMinMargins;
    if (other.mMediaSizes != null) {
        if (mMediaSizes != null) {
            mMediaSizes.clear();
            mMediaSizes.addAll(other.mMediaSizes);
        } else {
            mMediaSizes = new ArrayList<MediaSize>(other.mMediaSizes);
        }
    } else {
        mMediaSizes = null;
    }
    if (other.mResolutions != null) {
        if (mResolutions != null) {
            mResolutions.clear();
            mResolutions.addAll(other.mResolutions);
        } else {
            mResolutions = new ArrayList<Resolution>(other.mResolutions);
        }
    } else {
        mResolutions = null;
    }
    mColorModes = other.mColorModes;
    mDuplexModes = other.mDuplexModes;
    final int defaultCount = other.mDefaults.length;
    for (int i = 0; i < defaultCount; i++) {
        mDefaults[i] = other.mDefaults[i];
    }
}
------------------------
Find a silently evolved API code:android.content.ContentProviderClient.uncanonicalize:COMMENT
Method Modifier: public      final       
Comment:/**
 * See {@link ContentProvider#uncanonicalize}
 */

Body of Frist Method:
{
    beforeRemote();
    try {
        return mContentProvider.uncanonicalize(mPackageName, url);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}
Body of Second Method:
{
    Preconditions.checkNotNull(url, "url");
    beforeRemote();
    try {
        return mContentProvider.uncanonicalize(mPackageName, url);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}
------------------------
Find a silently evolved API code:android.widget.Scroller.fling:COMMENT
Method Modifier: public      
Comment:/**
 * Start scrolling based on a fling gesture. The distance travelled will
 * depend on the initial velocity of the fling.
 *
 * @param startX Starting point of the scroll (X)
 * @param startY Starting point of the scroll (Y)
 * @param velocityX Initial velocity of the fling (X) measured in pixels per
 * second.
 * @param velocityY Initial velocity of the fling (Y) measured in pixels per
 * second
 * @param minX Minimum X value. The scroller will not scroll past this
 * point.
 * @param maxX Maximum X value. The scroller will not scroll past this
 * point.
 * @param minY Minimum Y value. The scroller will not scroll past this
 * point.
 * @param maxY Maximum Y value. The scroller will not scroll past this
 * point.
 */

Body of Frist Method:
{
    // Continue a scroll or fling in progress
    if (mFlywheel && !mFinished) {
        float oldVel = getCurrVelocity();
        float dx = (float) (mFinalX - mStartX);
        float dy = (float) (mFinalY - mStartY);
        float hyp = FloatMath.sqrt(dx * dx + dy * dy);
        float ndx = dx / hyp;
        float ndy = dy / hyp;
        float oldVelocityX = ndx * oldVel;
        float oldVelocityY = ndy * oldVel;
        if (Math.signum(velocityX) == Math.signum(oldVelocityX) && Math.signum(velocityY) == Math.signum(oldVelocityY)) {
            velocityX += oldVelocityX;
            velocityY += oldVelocityY;
        }
    }
    mMode = FLING_MODE;
    mFinished = false;
    float velocity = FloatMath.sqrt(velocityX * velocityX + velocityY * velocityY);
    mVelocity = velocity;
    mDuration = getSplineFlingDuration(velocity);
    mStartTime = AnimationUtils.currentAnimationTimeMillis();
    mStartX = startX;
    mStartY = startY;
    float coeffX = velocity == 0 ? 1.0f : velocityX / velocity;
    float coeffY = velocity == 0 ? 1.0f : velocityY / velocity;
    double totalDistance = getSplineFlingDistance(velocity);
    mDistance = (int) (totalDistance * Math.signum(velocity));
    mMinX = minX;
    mMaxX = maxX;
    mMinY = minY;
    mMaxY = maxY;
    mFinalX = startX + (int) Math.round(totalDistance * coeffX);
    // Pin to mMinX <= mFinalX <= mMaxX
    mFinalX = Math.min(mFinalX, mMaxX);
    mFinalX = Math.max(mFinalX, mMinX);
    mFinalY = startY + (int) Math.round(totalDistance * coeffY);
    // Pin to mMinY <= mFinalY <= mMaxY
    mFinalY = Math.min(mFinalY, mMaxY);
    mFinalY = Math.max(mFinalY, mMinY);
}
Body of Second Method:
{
    // Continue a scroll or fling in progress
    if (mFlywheel && !mFinished) {
        float oldVel = getCurrVelocity();
        float dx = (float) (mFinalX - mStartX);
        float dy = (float) (mFinalY - mStartY);
        float hyp = (float) Math.hypot(dx, dy);
        float ndx = dx / hyp;
        float ndy = dy / hyp;
        float oldVelocityX = ndx * oldVel;
        float oldVelocityY = ndy * oldVel;
        if (Math.signum(velocityX) == Math.signum(oldVelocityX) && Math.signum(velocityY) == Math.signum(oldVelocityY)) {
            velocityX += oldVelocityX;
            velocityY += oldVelocityY;
        }
    }
    mMode = FLING_MODE;
    mFinished = false;
    float velocity = (float) Math.hypot(velocityX, velocityY);
    mVelocity = velocity;
    mDuration = getSplineFlingDuration(velocity);
    mStartTime = AnimationUtils.currentAnimationTimeMillis();
    mStartX = startX;
    mStartY = startY;
    float coeffX = velocity == 0 ? 1.0f : velocityX / velocity;
    float coeffY = velocity == 0 ? 1.0f : velocityY / velocity;
    double totalDistance = getSplineFlingDistance(velocity);
    mDistance = (int) (totalDistance * Math.signum(velocity));
    mMinX = minX;
    mMaxX = maxX;
    mMinY = minY;
    mMaxY = maxY;
    mFinalX = startX + (int) Math.round(totalDistance * coeffX);
    // Pin to mMinX <= mFinalX <= mMaxX
    mFinalX = Math.min(mFinalX, mMaxX);
    mFinalX = Math.max(mFinalX, mMinX);
    mFinalY = startY + (int) Math.round(totalDistance * coeffY);
    // Pin to mMinY <= mFinalY <= mMaxY
    mFinalY = Math.min(mFinalY, mMaxY);
    mFinalY = Math.max(mFinalY, mMinY);
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiManager.getControllerActivityEnergyInfo:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Return the record of {@link WifiActivityEnergyInfo} object that
 * has the activity and energy info. This can be used to ascertain what
 * the controller has been up to, since the last sample.
 * @param updateType Type of info, cached vs refreshed.
 *
 * @return a record with {@link WifiActivityEnergyInfo} or null if
 * report is unavailable or unsupported
 * @hide
 */

Body of Frist Method:
{
    if (mService == null)
        return null;
    try {
        WifiActivityEnergyInfo record;
        if (!isEnhancedPowerReportingSupported()) {
            return null;
        }
        synchronized (this) {
            record = mService.reportActivityInfo();
            if (record.isValid()) {
                return record;
            } else {
                return null;
            }
        }
    } catch (RemoteException e) {
        Log.e(TAG, "getControllerActivityEnergyInfo: " + e);
    }
    return null;
}
Body of Second Method:
{
    if (mService == null)
        return null;
    try {
        WifiActivityEnergyInfo record;
        if (!isEnhancedPowerReportingSupported()) {
            return null;
        }
        synchronized (this) {
            record = mService.reportActivityInfo();
            if (record != null && record.isValid()) {
                return record;
            } else {
                return null;
            }
        }
    } catch (RemoteException e) {
        Log.e(TAG, "getControllerActivityEnergyInfo: " + e);
    }
    return null;
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiScanner.ScanSettings.writeToParcel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Implement the Parcelable interface {@hide}
 */

Body of Frist Method:
{
    dest.writeInt(band);
    dest.writeInt(periodInMs);
    dest.writeInt(reportEvents);
    dest.writeInt(numBssidsPerScan);
    if (channels != null) {
        dest.writeInt(channels.length);
        for (int i = 0; i < channels.length; i++) {
            dest.writeInt(channels[i].frequency);
            dest.writeInt(channels[i].dwellTimeMS);
            dest.writeInt(channels[i].passive ? 1 : 0);
        }
    } else {
        dest.writeInt(0);
    }
}
Body of Second Method:
{
    dest.writeInt(band);
    dest.writeInt(periodInMs);
    dest.writeInt(reportEvents);
    dest.writeInt(numBssidsPerScan);
    dest.writeInt(maxScansToCache);
    if (channels != null) {
        dest.writeInt(channels.length);
        for (int i = 0; i < channels.length; i++) {
            dest.writeInt(channels[i].frequency);
            dest.writeInt(channels[i].dwellTimeMS);
            dest.writeInt(channels[i].passive ? 1 : 0);
        }
    } else {
        dest.writeInt(0);
    }
}
------------------------
Find a silently evolved API code:android.location.GpsMeasurement.setLossOfLock:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets the 'loss of lock' status.
 */

Body of Frist Method:
{
    switch(value) {
        case LOSS_OF_LOCK_UNKNOWN:
        case LOSS_OF_LOCK_OK:
        case LOSS_OF_LOCK_CYCLE_SLIP:
            mLossOfLock = value;
            break;
        default:
            Log.d(TAG, "Sanitizing invalid 'loss of lock': " + value);
            mLossOfLock = LOSS_OF_LOCK_UNKNOWN;
            break;
    }
}
Body of Second Method:
{
    mLossOfLock = value;
}
------------------------
Find a silently evolved API code:android.media.SoundPool.release:COMMENT
Method Modifier: public      final       
Comment:/**
 * Release the SoundPool resources.
 *
 * Release all memory and native resources used by the SoundPool
 * object. The SoundPool can no longer be used and the reference
 * should be set to null.
 */

Body of Frist Method:
{
    mImpl.release();
}
Body of Second Method:
{
    try {
        mAppOps.stopWatchingMode(mAppOpsCallback);
    } catch (RemoteException e) {
    // nothing to do here, the SoundPool is being released anyway
    }
    native_release();
}
------------------------
Find a silently evolved API code:android.text.format.Formatter.formatShortFileSize:COMMENT
Method Modifier: public      static      
Comment:/**
 * Like {@link #formatFileSize}, but trying to generate shorter numbers
 * (showing fewer digits of precision).
 */

Body of Frist Method:
{
    return formatFileSize(context, number, true);
}
Body of Second Method:
{
    if (context == null) {
        return "";
    }
    final BytesResult res = formatBytes(context.getResources(), sizeBytes, FLAG_SHORTER);
    return bidiWrap(context, context.getString(com.android.internal.R.string.fileSizeSuffix, res.value, res.units));
}
------------------------
Find a silently evolved API code:android.webkit.WebView.setPictureListener:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * Sets the Picture listener. This is an interface used to receive
 * notifications of a new Picture.
 *
 * @param listener an implementation of WebView.PictureListener
 * @deprecated This method is now obsolete.
 */

Body of Frist Method:
{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, "setPictureListener=" + listener);
    mProvider.setPictureListener(listener);
}
Body of Second Method:
{
    checkThread();
    mProvider.setPictureListener(listener);
}
------------------------
Find a silently evolved API code:android.media.AudioManager.adjustStreamVolume:COMMENT
Method Modifier: public      
Comment:/**
 * Adjusts the volume of a particular stream by one step in a direction.
 * <p>
 * This method should only be used by applications that replace the platform-wide
 * management of audio settings or the main telephony application.
 *
 * @param streamType The stream type to adjust. One of {@link #STREAM_VOICE_CALL},
 * {@link #STREAM_SYSTEM}, {@link #STREAM_RING}, {@link #STREAM_MUSIC} or
 * {@link #STREAM_ALARM}
 * @param direction The direction to adjust the volume. One of
 * {@link #ADJUST_LOWER}, {@link #ADJUST_RAISE}, or
 * {@link #ADJUST_SAME}.
 * @param flags One or more flags.
 * @see #adjustVolume(int, int)
 * @see #setStreamVolume(int, int, int)
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        if (mUseMasterVolume) {
            service.adjustMasterVolume(direction, flags, mContext.getOpPackageName());
        } else {
            service.adjustStreamVolume(streamType, direction, flags, mContext.getOpPackageName());
        }
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in adjustStreamVolume", e);
    }
}
Body of Second Method:
{
    IAudioService service = getService();
    try {
        service.adjustStreamVolume(streamType, direction, flags, getContext().getOpPackageName());
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in adjustStreamVolume", e);
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiConfiguration.getAuthType:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (isValid() == false) {
        throw new IllegalStateException("Invalid configuration");
    }
    if (allowedKeyManagement.get(KeyMgmt.WPA_PSK)) {
        return KeyMgmt.WPA_PSK;
    } else if (allowedKeyManagement.get(KeyMgmt.WPA2_PSK)) {
        return KeyMgmt.WPA2_PSK;
    } else if (allowedKeyManagement.get(KeyMgmt.WPA_EAP)) {
        return KeyMgmt.WPA_EAP;
    } else if (allowedKeyManagement.get(KeyMgmt.IEEE8021X)) {
        return KeyMgmt.IEEE8021X;
    }
    return KeyMgmt.NONE;
}
Body of Second Method:
{
    if (allowedKeyManagement.cardinality() > 1) {
        throw new IllegalStateException("More than one auth type set");
    }
    if (allowedKeyManagement.get(KeyMgmt.WPA_PSK)) {
        return KeyMgmt.WPA_PSK;
    } else if (allowedKeyManagement.get(KeyMgmt.WPA2_PSK)) {
        return KeyMgmt.WPA2_PSK;
    } else if (allowedKeyManagement.get(KeyMgmt.WPA_EAP)) {
        return KeyMgmt.WPA_EAP;
    } else if (allowedKeyManagement.get(KeyMgmt.IEEE8021X)) {
        return KeyMgmt.IEEE8021X;
    }
    return KeyMgmt.NONE;
}
------------------------
Find a silently evolved API code:android.nfc.NfcActivityManager.onNdefPushComplete:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Callback from NFC service, usually on binder thread
 */

Body of Frist Method:
{
    NfcAdapter.OnNdefPushCompleteCallback callback;
    synchronized (NfcActivityManager.this) {
        NfcActivityState state = findResumedActivityState();
        if (state == null)
            return;
        callback = state.onNdefPushCompleteCallback;
    }
    // Make callback without lock
    if (callback != null) {
        callback.onNdefPushComplete(mDefaultEvent);
    }
}
Body of Second Method:
{
    NfcAdapter.OnNdefPushCompleteCallback callback;
    synchronized (NfcActivityManager.this) {
        NfcActivityState state = findResumedActivityState();
        if (state == null)
            return;
        callback = state.onNdefPushCompleteCallback;
    }
    NfcEvent event = new NfcEvent(mAdapter, peerLlcpVersion);
    // Make callback without lock
    if (callback != null) {
        callback.onNdefPushComplete(event);
    }
}
------------------------
Find a silently evolved API code:android.graphics.Bitmap.hasMipMap:COMMENT
Method Modifier: public      final       
Comment:/**
 * Indicates whether the renderer responsible for drawing this
 * bitmap should attempt to use mipmaps when this bitmap is drawn
 * scaled down.
 *
 * If you know that you are going to draw this bitmap at less than
 * 50% of its original size, you may be able to obtain a higher
 * quality
 *
 * This property is only a suggestion that can be ignored by the
 * renderer. It is not guaranteed to have any effect.
 *
 * @return true if the renderer should attempt to use mipmaps,
 * false otherwise
 *
 * @see #setHasMipMap(boolean)
 */

Body of Frist Method:
{
    return nativeHasMipMap(mNativeBitmap);
}
Body of Second Method:
{
    if (mRecycled) {
        Log.w(TAG, "Called hasMipMap() on a recycle()'d bitmap! This is undefined behavior!");
    }
    return nativeHasMipMap(mFinalizer.mNativeBitmap);
}
------------------------
Find a silently evolved API code:android.net.LinkProperties.isProvisioned:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns true if this link is provisioned for global connectivity,
 * for at least one Internet Protocol family.
 *
 * @return {@code true} if the link is provisioned, {@code false} otherwise.
 * @hide
 */

Body of Frist Method:
{
    return (hasIPv4() || hasIPv6());
}
Body of Second Method:
{
    return (isIPv4Provisioned() || isIPv6Provisioned());
}
------------------------
Find a silently evolved API code:javax.obex.ClientOperation.getType:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns the type of content that the resource connected to is providing.
 * E.g. if the connection is via HTTP, then the value of the content-type
 * header field is returned.
 * @return the content type of the resource that the URL references, or
 * <code>null</code> if not known
 */

Body of Frist Method:
{
    try {
        return (String) mReplyHeader.getHeader(HeaderSet.TYPE);
    } catch (IOException e) {
        return null;
    }
}
Body of Second Method:
{
    try {
        return (String) mReplyHeader.getHeader(HeaderSet.TYPE);
    } catch (IOException e) {
        if (V)
            Log.d(TAG, "Exception occured - returning null", e);
        return null;
    }
}
------------------------
Find a silently evolved API code:android.app.BackStackRecord.beginTransition:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * When custom fragment transitions are used, this sets up the state for each transition
 * and begins the transition. A different transition is started for each fragment container
 * and consists of up to 3 different transitions: the exit transition, a shared element
 * transition and an enter transition.
 *
 * <p>The exit transition operates against the leaf nodes of the first fragment
 * with a view that was removed. If no such fragment was removed, then no exit
 * transition is executed. The exit transition comes from the outgoing fragment.</p>
 *
 * <p>The enter transition operates against the last fragment that was added. If
 * that fragment does not have a view or no fragment was added, then no enter
 * transition is executed. The enter transition comes from the incoming fragment.</p>
 *
 * <p>The shared element transition operates against all views and comes either
 * from the outgoing fragment or the incoming fragment, depending on whether this
 * is going forward or popping the back stack. When going forward, the incoming
 * fragment's enter shared element transition is used, but when going back, the
 * outgoing fragment's return shared element transition is used. Shared element
 * transitions only operate if there is both an incoming and outgoing fragment.</p>
 *
 * @param firstOutFragments The list of first fragments to be removed, keyed on the
 * container ID.
 * @param lastInFragments The list of last fragments to be added, keyed on the
 * container ID.
 * @param isBack true if this is popping the back stack or false if this is a
 * forward operation.
 * @return The TransitionState used to complete the operation of the transition
 * in {@link #setNameOverrides(android.app.BackStackRecord.TransitionState, java.util.ArrayList,
 * java.util.ArrayList)}.
 */

Body of Frist Method:
{
    TransitionState state = new TransitionState();
    // Adding a non-existent target view makes sure that the transitions don't target
    // any views by default. They'll only target the views we tell add. If we don't
    // add any, then no views will be targeted.
    state.nonExistentView = new View(mManager.mActivity);
    // Go over all leaving fragments.
    for (int i = 0; i < firstOutFragments.size(); i++) {
        int containerId = firstOutFragments.keyAt(i);
        configureTransitions(containerId, state, isBack, firstOutFragments, lastInFragments);
    }
    // Now go over all entering fragments that didn't have a leaving fragment.
    for (int i = 0; i < lastInFragments.size(); i++) {
        int containerId = lastInFragments.keyAt(i);
        if (firstOutFragments.get(containerId) == null) {
            configureTransitions(containerId, state, isBack, firstOutFragments, lastInFragments);
        }
    }
    return state;
}
Body of Second Method:
{
    TransitionState state = new TransitionState();
    // Adding a non-existent target view makes sure that the transitions don't target
    // any views by default. They'll only target the views we tell add. If we don't
    // add any, then no views will be targeted.
    state.nonExistentView = new View(mManager.mHost.getContext());
    // Go over all leaving fragments.
    for (int i = 0; i < firstOutFragments.size(); i++) {
        int containerId = firstOutFragments.keyAt(i);
        configureTransitions(containerId, state, isBack, firstOutFragments, lastInFragments);
    }
    // Now go over all entering fragments that didn't have a leaving fragment.
    for (int i = 0; i < lastInFragments.size(); i++) {
        int containerId = lastInFragments.keyAt(i);
        if (firstOutFragments.get(containerId) == null) {
            configureTransitions(containerId, state, isBack, firstOutFragments, lastInFragments);
        }
    }
    return state;
}
------------------------
Find a silently evolved API code:android.widget.ListPopupWindow.buildDropDown:COMMENT
Method Modifier: private     
Comment:/**
 * <p>Builds the popup window's content and returns the height the popup
 * should have. Returns -1 when the content already exists.</p>
 *
 * @return the content's height or -1 if content already exists
 */

Body of Frist Method:
{
    ViewGroup dropDownView;
    int otherHeights = 0;
    if (mDropDownList == null) {
        Context context = mContext;
        /**
         * This Runnable exists for the sole purpose of checking if the view layout has got
         * completed and if so call showDropDown to display the drop down. This is used to show
         * the drop down as soon as possible after user opens up the search dialog, without
         * waiting for the normal UI pipeline to do it's job which is slower than this method.
         */
        mShowDropDownRunnable = new Runnable() {

            public void run() {
                // View layout should be all done before displaying the drop down.
                View view = getAnchorView();
                if (view != null && view.getWindowToken() != null) {
                    show();
                }
            }
        };
        mDropDownList = new DropDownListView(context, !mModal);
        if (mDropDownListHighlight != null) {
            mDropDownList.setSelector(mDropDownListHighlight);
        }
        mDropDownList.setAdapter(mAdapter);
        mDropDownList.setOnItemClickListener(mItemClickListener);
        mDropDownList.setFocusable(true);
        mDropDownList.setFocusableInTouchMode(true);
        mDropDownList.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {

            public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {
                if (position != -1) {
                    DropDownListView dropDownList = mDropDownList;
                    if (dropDownList != null) {
                        dropDownList.mListSelectionHidden = false;
                    }
                }
            }

            public void onNothingSelected(AdapterView<?> parent) {
            }
        });
        mDropDownList.setOnScrollListener(mScrollListener);
        if (mItemSelectedListener != null) {
            mDropDownList.setOnItemSelectedListener(mItemSelectedListener);
        }
        dropDownView = mDropDownList;
        View hintView = mPromptView;
        if (hintView != null) {
            // if a hint has been specified, we accomodate more space for it and
            // add a text view in the drop down menu, at the bottom of the list
            LinearLayout hintContainer = new LinearLayout(context);
            hintContainer.setOrientation(LinearLayout.VERTICAL);
            LinearLayout.LayoutParams hintParams = new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, 0, 1.0f);
            switch(mPromptPosition) {
                case POSITION_PROMPT_BELOW:
                    hintContainer.addView(dropDownView, hintParams);
                    hintContainer.addView(hintView);
                    break;
                case POSITION_PROMPT_ABOVE:
                    hintContainer.addView(hintView);
                    hintContainer.addView(dropDownView, hintParams);
                    break;
                default:
                    Log.e(TAG, "Invalid hint position " + mPromptPosition);
                    break;
            }
            // measure the hint's height to find how much more vertical space
            // we need to add to the drop down's height
            int widthSpec = MeasureSpec.makeMeasureSpec(mDropDownWidth, MeasureSpec.AT_MOST);
            int heightSpec = MeasureSpec.UNSPECIFIED;
            hintView.measure(widthSpec, heightSpec);
            hintParams = (LinearLayout.LayoutParams) hintView.getLayoutParams();
            otherHeights = hintView.getMeasuredHeight() + hintParams.topMargin + hintParams.bottomMargin;
            dropDownView = hintContainer;
        }
        mPopup.setContentView(dropDownView);
    } else {
        dropDownView = (ViewGroup) mPopup.getContentView();
        final View view = mPromptView;
        if (view != null) {
            LinearLayout.LayoutParams hintParams = (LinearLayout.LayoutParams) view.getLayoutParams();
            otherHeights = view.getMeasuredHeight() + hintParams.topMargin + hintParams.bottomMargin;
        }
    }
    // getMaxAvailableHeight() subtracts the padding, so we put it back
    // to get the available height for the whole window
    int padding = 0;
    Drawable background = mPopup.getBackground();
    if (background != null) {
        background.getPadding(mTempRect);
        padding = mTempRect.top + mTempRect.bottom;
        // background so that content will line up.
        if (!mDropDownVerticalOffsetSet) {
            mDropDownVerticalOffset = -mTempRect.top;
        }
    } else {
        mTempRect.setEmpty();
    }
    // Max height available on the screen for a popup.
    boolean ignoreBottomDecorations = mPopup.getInputMethodMode() == PopupWindow.INPUT_METHOD_NOT_NEEDED;
    final int maxHeight = mPopup.getMaxAvailableHeight(getAnchorView(), mDropDownVerticalOffset, ignoreBottomDecorations);
    if (mDropDownAlwaysVisible || mDropDownHeight == ViewGroup.LayoutParams.MATCH_PARENT) {
        return maxHeight + padding;
    }
    final int childWidthSpec;
    switch(mDropDownWidth) {
        case ViewGroup.LayoutParams.WRAP_CONTENT:
            childWidthSpec = MeasureSpec.makeMeasureSpec(mContext.getResources().getDisplayMetrics().widthPixels - (mTempRect.left + mTempRect.right), MeasureSpec.AT_MOST);
            break;
        case ViewGroup.LayoutParams.MATCH_PARENT:
            childWidthSpec = MeasureSpec.makeMeasureSpec(mContext.getResources().getDisplayMetrics().widthPixels - (mTempRect.left + mTempRect.right), MeasureSpec.EXACTLY);
            break;
        default:
            childWidthSpec = MeasureSpec.makeMeasureSpec(mDropDownWidth, MeasureSpec.EXACTLY);
            break;
    }
    final int listContent = mDropDownList.measureHeightOfChildren(childWidthSpec, 0, ListView.NO_POSITION, maxHeight - otherHeights, -1);
    // the popup if it is not needed
    if (listContent > 0)
        otherHeights += padding;
    return listContent + otherHeights;
}
Body of Second Method:
{
    ViewGroup dropDownView;
    int otherHeights = 0;
    if (mDropDownList == null) {
        Context context = mContext;
        /**
         * This Runnable exists for the sole purpose of checking if the view layout has got
         * completed and if so call showDropDown to display the drop down. This is used to show
         * the drop down as soon as possible after user opens up the search dialog, without
         * waiting for the normal UI pipeline to do it's job which is slower than this method.
         */
        mShowDropDownRunnable = new Runnable() {

            public void run() {
                // View layout should be all done before displaying the drop down.
                View view = getAnchorView();
                if (view != null && view.getWindowToken() != null) {
                    show();
                }
            }
        };
        mDropDownList = new DropDownListView(context, !mModal);
        if (mDropDownListHighlight != null) {
            mDropDownList.setSelector(mDropDownListHighlight);
        }
        mDropDownList.setAdapter(mAdapter);
        mDropDownList.setOnItemClickListener(mItemClickListener);
        mDropDownList.setFocusable(true);
        mDropDownList.setFocusableInTouchMode(true);
        mDropDownList.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {

            public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {
                if (position != -1) {
                    DropDownListView dropDownList = mDropDownList;
                    if (dropDownList != null) {
                        dropDownList.mListSelectionHidden = false;
                    }
                }
            }

            public void onNothingSelected(AdapterView<?> parent) {
            }
        });
        mDropDownList.setOnScrollListener(mScrollListener);
        if (mItemSelectedListener != null) {
            mDropDownList.setOnItemSelectedListener(mItemSelectedListener);
        }
        dropDownView = mDropDownList;
        View hintView = mPromptView;
        if (hintView != null) {
            // if a hint has been specified, we accomodate more space for it and
            // add a text view in the drop down menu, at the bottom of the list
            LinearLayout hintContainer = new LinearLayout(context);
            hintContainer.setOrientation(LinearLayout.VERTICAL);
            LinearLayout.LayoutParams hintParams = new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, 0, 1.0f);
            switch(mPromptPosition) {
                case POSITION_PROMPT_BELOW:
                    hintContainer.addView(dropDownView, hintParams);
                    hintContainer.addView(hintView);
                    break;
                case POSITION_PROMPT_ABOVE:
                    hintContainer.addView(hintView);
                    hintContainer.addView(dropDownView, hintParams);
                    break;
                default:
                    Log.e(TAG, "Invalid hint position " + mPromptPosition);
                    break;
            }
            // Measure the hint's height to find how much more vertical
            // space we need to add to the drop down's height.
            final int widthSize;
            final int widthMode;
            if (mDropDownWidth >= 0) {
                widthMode = MeasureSpec.AT_MOST;
                widthSize = mDropDownWidth;
            } else {
                widthMode = MeasureSpec.UNSPECIFIED;
                widthSize = 0;
            }
            final int widthSpec = MeasureSpec.makeMeasureSpec(widthSize, widthMode);
            final int heightSpec = MeasureSpec.UNSPECIFIED;
            hintView.measure(widthSpec, heightSpec);
            hintParams = (LinearLayout.LayoutParams) hintView.getLayoutParams();
            otherHeights = hintView.getMeasuredHeight() + hintParams.topMargin + hintParams.bottomMargin;
            dropDownView = hintContainer;
        }
        mPopup.setContentView(dropDownView);
    } else {
        dropDownView = (ViewGroup) mPopup.getContentView();
        final View view = mPromptView;
        if (view != null) {
            LinearLayout.LayoutParams hintParams = (LinearLayout.LayoutParams) view.getLayoutParams();
            otherHeights = view.getMeasuredHeight() + hintParams.topMargin + hintParams.bottomMargin;
        }
    }
    // getMaxAvailableHeight() subtracts the padding, so we put it back
    // to get the available height for the whole window
    int padding = 0;
    Drawable background = mPopup.getBackground();
    if (background != null) {
        background.getPadding(mTempRect);
        padding = mTempRect.top + mTempRect.bottom;
        // background so that content will line up.
        if (!mDropDownVerticalOffsetSet) {
            mDropDownVerticalOffset = -mTempRect.top;
        }
    } else {
        mTempRect.setEmpty();
    }
    // Max height available on the screen for a popup.
    boolean ignoreBottomDecorations = mPopup.getInputMethodMode() == PopupWindow.INPUT_METHOD_NOT_NEEDED;
    final int maxHeight = mPopup.getMaxAvailableHeight(getAnchorView(), mDropDownVerticalOffset, ignoreBottomDecorations);
    if (mDropDownAlwaysVisible || mDropDownHeight == ViewGroup.LayoutParams.MATCH_PARENT) {
        return maxHeight + padding;
    }
    final int childWidthSpec;
    switch(mDropDownWidth) {
        case ViewGroup.LayoutParams.WRAP_CONTENT:
            childWidthSpec = MeasureSpec.makeMeasureSpec(mContext.getResources().getDisplayMetrics().widthPixels - (mTempRect.left + mTempRect.right), MeasureSpec.AT_MOST);
            break;
        case ViewGroup.LayoutParams.MATCH_PARENT:
            childWidthSpec = MeasureSpec.makeMeasureSpec(mContext.getResources().getDisplayMetrics().widthPixels - (mTempRect.left + mTempRect.right), MeasureSpec.EXACTLY);
            break;
        default:
            childWidthSpec = MeasureSpec.makeMeasureSpec(mDropDownWidth, MeasureSpec.EXACTLY);
            break;
    }
    final int listContent = mDropDownList.measureHeightOfChildren(childWidthSpec, 0, ListView.NO_POSITION, maxHeight - otherHeights, -1);
    // the popup if it is not needed
    if (listContent > 0)
        otherHeights += padding;
    return listContent + otherHeights;
}
------------------------
Find a silently evolved API code:android.net.NetworkStats.setToCheckinString:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Return text description of {@link #set} value.
 */

Body of Frist Method:
{
    switch(set) {
        case SET_ALL:
            return "all";
        case SET_DEFAULT:
            return "def";
        case SET_FOREGROUND:
            return "fg";
        default:
            return "unk";
    }
}
Body of Second Method:
{
    switch(set) {
        case SET_ALL:
            return "all";
        case SET_DEFAULT:
            return "def";
        case SET_FOREGROUND:
            return "fg";
        case SET_DBG_VPN_IN:
            return "vpnin";
        case SET_DBG_VPN_OUT:
            return "vpnout";
        default:
            return "unk";
    }
}
------------------------
Find a silently evolved API code:android.renderscript.Type.Builder.create:COMMENT
Method Modifier: public      
Comment:/**
 * Validate structure and create a new Type.
 *
 * @return Type
 */

Body of Frist Method:
{
    if (mDimZ > 0) {
        if ((mDimX < 1) || (mDimY < 1)) {
            throw new RSInvalidStateException("Both X and Y dimension required when Z is present.");
        }
        if (mDimFaces) {
            throw new RSInvalidStateException("Cube maps not supported with 3D types.");
        }
    }
    if (mDimY > 0) {
        if (mDimX < 1) {
            throw new RSInvalidStateException("X dimension required when Y is present.");
        }
    }
    if (mDimFaces) {
        if (mDimY < 1) {
            throw new RSInvalidStateException("Cube maps require 2D Types.");
        }
    }
    if (mYuv != 0) {
        if ((mDimZ != 0) || mDimFaces || mDimMipmaps) {
            throw new RSInvalidStateException("YUV only supports basic 2D.");
        }
    }
    long id = mRS.nTypeCreate(mElement.getID(mRS), mDimX, mDimY, mDimZ, mDimMipmaps, mDimFaces, mYuv);
    Type t = new Type(id, mRS);
    t.mElement = mElement;
    t.mDimX = mDimX;
    t.mDimY = mDimY;
    t.mDimZ = mDimZ;
    t.mDimMipmaps = mDimMipmaps;
    t.mDimFaces = mDimFaces;
    t.mDimYuv = mYuv;
    t.calcElementCount();
    return t;
}
Body of Second Method:
{
    if (mDimZ > 0) {
        if ((mDimX < 1) || (mDimY < 1)) {
            throw new RSInvalidStateException("Both X and Y dimension required when Z is present.");
        }
        if (mDimFaces) {
            throw new RSInvalidStateException("Cube maps not supported with 3D types.");
        }
    }
    if (mDimY > 0) {
        if (mDimX < 1) {
            throw new RSInvalidStateException("X dimension required when Y is present.");
        }
    }
    if (mDimFaces) {
        if (mDimY < 1) {
            throw new RSInvalidStateException("Cube maps require 2D Types.");
        }
    }
    if (mYuv != 0) {
        if ((mDimZ != 0) || mDimFaces || mDimMipmaps) {
            throw new RSInvalidStateException("YUV only supports basic 2D.");
        }
    }
    int[] arrays = null;
    for (int ct = mMaxArrays - 1; ct >= 0; ct--) {
        if (mArray[ct] != 0 && arrays == null) {
            arrays = new int[ct];
        }
        if ((mArray[ct] == 0) && (arrays != null)) {
            throw new RSInvalidStateException("Array dimensions must be contigous from 0.");
        }
    }
    long id = mRS.nTypeCreate(mElement.getID(mRS), mDimX, mDimY, mDimZ, mDimMipmaps, mDimFaces, mYuv);
    Type t = new Type(id, mRS);
    t.mElement = mElement;
    t.mDimX = mDimX;
    t.mDimY = mDimY;
    t.mDimZ = mDimZ;
    t.mDimMipmaps = mDimMipmaps;
    t.mDimFaces = mDimFaces;
    t.mDimYuv = mYuv;
    t.mArrays = arrays;
    t.calcElementCount();
    return t;
}
------------------------
Find a silently evolved API code:android.graphics.Bitmap.getDensity:COMMENT
Method Modifier: public      
Comment:/**
 * <p>Returns the density for this bitmap.</p>
 *
 * <p>The default density is the same density as the current display,
 * unless the current application does not support different screen
 * densities in which case it is
 * {@link android.util.DisplayMetrics#DENSITY_DEFAULT}.  Note that
 * compatibility mode is determined by the application that was initially
 * loaded into a process -- applications that share the same process should
 * all have the same compatibility, or ensure they explicitly set the
 * density of their bitmaps appropriately.</p>
 *
 * @return A scaling factor of the default density or {@link #DENSITY_NONE}
 * if the scaling factor is unknown.
 *
 * @see #setDensity(int)
 * @see android.util.DisplayMetrics#DENSITY_DEFAULT
 * @see android.util.DisplayMetrics#densityDpi
 * @see #DENSITY_NONE
 */

Body of Frist Method:
{
    return mDensity;
}
Body of Second Method:
{
    if (mRecycled) {
        Log.w(TAG, "Called getDensity() on a recycle()'d bitmap! This is undefined behavior!");
    }
    return mDensity;
}
------------------------
Find a silently evolved API code:android.graphics.Bitmap.setPixel:COMMENT
Method Modifier: public      
Comment:/**
 * <p>Write the specified {@link Color} into the bitmap (assuming it is
 * mutable) at the x,y coordinate. The color must be a
 * non-premultiplied ARGB value.</p>
 *
 * @param x     The x coordinate of the pixel to replace (0...width-1)
 * @param y     The y coordinate of the pixel to replace (0...height-1)
 * @param color The ARGB color to write into the bitmap
 *
 * @throws IllegalStateException if the bitmap is not mutable
 * @throws IllegalArgumentException if x, y are outside of the bitmap's
 * bounds.
 */

Body of Frist Method:
{
    checkRecycled("Can't call setPixel() on a recycled bitmap");
    if (!isMutable()) {
        throw new IllegalStateException();
    }
    checkPixelAccess(x, y);
    nativeSetPixel(mNativeBitmap, x, y, color);
}
Body of Second Method:
{
    checkRecycled("Can't call setPixel() on a recycled bitmap");
    if (!isMutable()) {
        throw new IllegalStateException();
    }
    checkPixelAccess(x, y);
    nativeSetPixel(mFinalizer.mNativeBitmap, x, y, color);
}
------------------------
Find a silently evolved API code:android.view.LayoutInflater.parseViewTag:COMMENT
Method Modifier: private     
Comment:/**
 * Parses a <code>&lt;tag&gt;</code> element and sets a keyed tag on the
 * containing View.
 */

Body of Frist Method:
{
    int type;
    final TypedArray ta = mContext.obtainStyledAttributes(attrs, com.android.internal.R.styleable.ViewTag);
    final int key = ta.getResourceId(com.android.internal.R.styleable.ViewTag_id, 0);
    final CharSequence value = ta.getText(com.android.internal.R.styleable.ViewTag_value);
    view.setTag(key, value);
    ta.recycle();
    final int currentDepth = parser.getDepth();
    while (((type = parser.next()) != XmlPullParser.END_TAG || parser.getDepth() > currentDepth) && type != XmlPullParser.END_DOCUMENT) {
    // Empty
    }
}
Body of Second Method:
{
    final Context context = view.getContext();
    final TypedArray ta = context.obtainStyledAttributes(attrs, R.styleable.ViewTag);
    final int key = ta.getResourceId(R.styleable.ViewTag_id, 0);
    final CharSequence value = ta.getText(R.styleable.ViewTag_value);
    view.setTag(key, value);
    ta.recycle();
    consumeChildElements(parser);
}
------------------------
Find a silently evolved API code:android.location.GpsMeasurement.getMultipathIndicatorString:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Gets a string representation of the 'multi-path indicator'.
 * For internal and logging use only.
 */

Body of Frist Method:
{
    switch(mMultipathIndicator) {
        case MULTIPATH_INDICATOR_UNKNOWN:
            return "Unknown";
        case MULTIPATH_INDICATOR_DETECTED:
            return "Detected";
        case MULTIPATH_INDICATOR_NOT_USED:
            return "NotUsed";
        default:
            return "<Invalid>";
    }
}
Body of Second Method:
{
    switch(mMultipathIndicator) {
        case MULTIPATH_INDICATOR_UNKNOWN:
            return "Unknown";
        case MULTIPATH_INDICATOR_DETECTED:
            return "Detected";
        case MULTIPATH_INDICATOR_NOT_USED:
            return "NotUsed";
        default:
            return "<Invalid:" + mMultipathIndicator + ">";
    }
}
------------------------
Find a silently evolved API code:android.app.SearchManager.getAssistIntent:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Gets an intent for launching installed assistant activity, or null if not available.
 * @return The assist intent.
 *
 * @hide
 */

Body of Frist Method:
{
    try {
        if (mService == null) {
            return null;
        }
        ComponentName comp = mService.getAssistIntent(userHandle);
        if (comp == null) {
            return null;
        }
        Intent intent = new Intent(Intent.ACTION_ASSIST);
        intent.setComponent(comp);
        if (inclContext) {
            IActivityManager am = ActivityManagerNative.getDefault();
            Bundle extras = am.getAssistContextExtras(0);
            if (extras != null) {
                intent.replaceExtras(extras);
            }
        }
        return intent;
    } catch (RemoteException re) {
        Log.e(TAG, "getAssistIntent() failed: " + re);
        return null;
    }
}
Body of Second Method:
{
    try {
        Intent intent = new Intent(Intent.ACTION_ASSIST);
        if (inclContext) {
            IActivityManager am = ActivityManagerNative.getDefault();
            Bundle extras = am.getAssistContextExtras(ActivityManager.ASSIST_CONTEXT_BASIC);
            if (extras != null) {
                intent.replaceExtras(extras);
            }
        }
        return intent;
    } catch (RemoteException re) {
        Log.e(TAG, "getAssistIntent() failed: " + re);
        return null;
    }
}
------------------------
Find a silently evolved API code:android.media.AudioManager.listAudioPatches:COMMENT
<android.media.AudioManager: int listAudioPatches(ArrayList<AudioPatch>)>
public      hidden      ->public      static      hidden      
Method Modifier: public      static      hidden      
Method Modifier: Yes         No          Yes         
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * List all existing connections between audio ports.
 * @param patches An AudioPatch array where the list will be returned.
 * @hide
 */

Body of Frist Method:
{
    return updateAudioPortCache(null, patches);
}
Body of Second Method:
{
    return updateAudioPortCache(null, patches, null);
}
------------------------
Find a silently evolved API code:android.media.AudioManager.handleKeyDown:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    int keyCode = event.getKeyCode();
    switch(keyCode) {
        case KeyEvent.KEYCODE_VOLUME_UP:
        case KeyEvent.KEYCODE_VOLUME_DOWN:
            /*
                 * Adjust the volume in on key down since it is more
                 * responsive to the user.
                 */
            int flags = FLAG_SHOW_UI | FLAG_VIBRATE;
            if (mUseMasterVolume) {
                adjustMasterVolume(keyCode == KeyEvent.KEYCODE_VOLUME_UP ? ADJUST_RAISE : ADJUST_LOWER, flags);
            } else {
                adjustSuggestedStreamVolume(keyCode == KeyEvent.KEYCODE_VOLUME_UP ? ADJUST_RAISE : ADJUST_LOWER, stream, flags);
            }
            break;
        case KeyEvent.KEYCODE_VOLUME_MUTE:
            if (event.getRepeatCount() == 0) {
                MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(event, false);
            }
            break;
    }
}
Body of Second Method:
{
    int keyCode = event.getKeyCode();
    switch(keyCode) {
        case KeyEvent.KEYCODE_VOLUME_UP:
        case KeyEvent.KEYCODE_VOLUME_DOWN:
            /*
                 * Adjust the volume in on key down since it is more
                 * responsive to the user.
                 */
            adjustSuggestedStreamVolume(keyCode == KeyEvent.KEYCODE_VOLUME_UP ? ADJUST_RAISE : ADJUST_LOWER, stream, FLAG_SHOW_UI | FLAG_VIBRATE);
            break;
        case KeyEvent.KEYCODE_VOLUME_MUTE:
            if (event.getRepeatCount() == 0) {
                MediaSessionLegacyHelper.getHelper(getContext()).sendVolumeKeyEvent(event, false);
            }
            break;
    }
}
------------------------
Find a silently evolved API code:android.text.SpannableStringBuilder.nextSpanTransition:COMMENT
Method Modifier: public      
Comment:/**
 * Return the next offset after <code>start</code> but less than or
 * equal to <code>limit</code> where a span of the specified type
 * begins or ends.
 */

Body of Frist Method:
{
    int count = mSpanCount;
    Object[] spans = mSpans;
    int[] starts = mSpanStarts;
    int[] ends = mSpanEnds;
    int gapstart = mGapStart;
    int gaplen = mGapLength;
    if (kind == null) {
        kind = Object.class;
    }
    for (int i = 0; i < count; i++) {
        int st = starts[i];
        int en = ends[i];
        if (st > gapstart)
            st -= gaplen;
        if (en > gapstart)
            en -= gaplen;
        if (st > start && st < limit && kind.isInstance(spans[i]))
            limit = st;
        if (en > start && en < limit && kind.isInstance(spans[i]))
            limit = en;
    }
    return limit;
}
Body of Second Method:
{
    if (mSpanCount == 0)
        return limit;
    if (kind == null) {
        kind = Object.class;
    }
    return nextSpanTransitionRec(start, limit, kind, treeRoot());
}
------------------------
Find a silently evolved API code:android.webkit.WebView.freeMemory:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * Informs this WebView that memory is low so that it can free any available
 * memory.
 * @deprecated Memory caches are automatically dropped when no longer needed, and in response
 * to system memory pressure.
 */

Body of Frist Method:
{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, "freeMemory");
    mProvider.freeMemory();
}
Body of Second Method:
{
    checkThread();
    mProvider.freeMemory();
}
------------------------
Find a silently evolved API code:android.location.GpsNavigationMessage.set:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets all contents to the values stored in the provided object.
 */

Body of Frist Method:
{
    mType = navigationMessage.mType;
    mPrn = navigationMessage.mPrn;
    mMessageId = navigationMessage.mMessageId;
    mSubmessageId = navigationMessage.mSubmessageId;
    mData = navigationMessage.mData;
}
Body of Second Method:
{
    mType = navigationMessage.mType;
    mPrn = navigationMessage.mPrn;
    mMessageId = navigationMessage.mMessageId;
    mSubmessageId = navigationMessage.mSubmessageId;
    mData = navigationMessage.mData;
    mStatus = navigationMessage.mStatus;
}
------------------------
Find a silently evolved API code:android.view.accessibility.AccessibilityEvent.eventTypeToString:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns the string representation of an event type. For example,
 * {@link #TYPE_VIEW_CLICKED} is represented by the string TYPE_VIEW_CLICKED.
 *
 * @param eventType The event type
 * @return The string representation.
 */

Body of Frist Method:
{
    if (eventType == TYPES_ALL_MASK) {
        return "TYPES_ALL_MASK";
    }
    StringBuilder builder = new StringBuilder();
    int eventTypeCount = 0;
    while (eventType != 0) {
        final int eventTypeFlag = 1 << Integer.numberOfTrailingZeros(eventType);
        eventType &= ~eventTypeFlag;
        switch(eventTypeFlag) {
            case TYPE_VIEW_CLICKED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_VIEW_CLICKED");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_LONG_CLICKED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_VIEW_LONG_CLICKED");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_SELECTED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_VIEW_SELECTED");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_FOCUSED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_VIEW_FOCUSED");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_TEXT_CHANGED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_VIEW_TEXT_CHANGED");
                    eventTypeCount++;
                }
                break;
            case TYPE_WINDOW_STATE_CHANGED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_WINDOW_STATE_CHANGED");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_HOVER_ENTER:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_VIEW_HOVER_ENTER");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_HOVER_EXIT:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_VIEW_HOVER_EXIT");
                    eventTypeCount++;
                }
                break;
            case TYPE_NOTIFICATION_STATE_CHANGED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_NOTIFICATION_STATE_CHANGED");
                    eventTypeCount++;
                }
                break;
            case TYPE_TOUCH_EXPLORATION_GESTURE_START:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_TOUCH_EXPLORATION_GESTURE_START");
                    eventTypeCount++;
                }
                break;
            case TYPE_TOUCH_EXPLORATION_GESTURE_END:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_TOUCH_EXPLORATION_GESTURE_END");
                    eventTypeCount++;
                }
                break;
            case TYPE_WINDOW_CONTENT_CHANGED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_WINDOW_CONTENT_CHANGED");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_TEXT_SELECTION_CHANGED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_VIEW_TEXT_SELECTION_CHANGED");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_SCROLLED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_VIEW_SCROLLED");
                    eventTypeCount++;
                }
                break;
            case TYPE_ANNOUNCEMENT:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_ANNOUNCEMENT");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_ACCESSIBILITY_FOCUSED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_VIEW_ACCESSIBILITY_FOCUSED");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_TEXT_TRAVERSED_AT_MOVEMENT_GRANULARITY:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_VIEW_TEXT_TRAVERSED_AT_MOVEMENT_GRANULARITY");
                    eventTypeCount++;
                }
                break;
            case TYPE_GESTURE_DETECTION_START:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_GESTURE_DETECTION_START");
                    eventTypeCount++;
                }
                break;
            case TYPE_GESTURE_DETECTION_END:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_GESTURE_DETECTION_END");
                    eventTypeCount++;
                }
                break;
            case TYPE_TOUCH_INTERACTION_START:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_TOUCH_INTERACTION_START");
                    eventTypeCount++;
                }
                break;
            case TYPE_TOUCH_INTERACTION_END:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_TOUCH_INTERACTION_END");
                    eventTypeCount++;
                }
                break;
            case TYPE_WINDOWS_CHANGED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_WINDOWS_CHANGED");
                    eventTypeCount++;
                }
                break;
        }
    }
    if (eventTypeCount > 1) {
        builder.insert(0, '[');
        builder.append(']');
    }
    return builder.toString();
}
Body of Second Method:
{
    if (eventType == TYPES_ALL_MASK) {
        return "TYPES_ALL_MASK";
    }
    StringBuilder builder = new StringBuilder();
    int eventTypeCount = 0;
    while (eventType != 0) {
        final int eventTypeFlag = 1 << Integer.numberOfTrailingZeros(eventType);
        eventType &= ~eventTypeFlag;
        switch(eventTypeFlag) {
            case TYPE_VIEW_CLICKED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_VIEW_CLICKED");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_LONG_CLICKED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_VIEW_LONG_CLICKED");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_SELECTED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_VIEW_SELECTED");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_FOCUSED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_VIEW_FOCUSED");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_TEXT_CHANGED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_VIEW_TEXT_CHANGED");
                    eventTypeCount++;
                }
                break;
            case TYPE_WINDOW_STATE_CHANGED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_WINDOW_STATE_CHANGED");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_HOVER_ENTER:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_VIEW_HOVER_ENTER");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_HOVER_EXIT:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_VIEW_HOVER_EXIT");
                    eventTypeCount++;
                }
                break;
            case TYPE_NOTIFICATION_STATE_CHANGED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_NOTIFICATION_STATE_CHANGED");
                    eventTypeCount++;
                }
                break;
            case TYPE_TOUCH_EXPLORATION_GESTURE_START:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_TOUCH_EXPLORATION_GESTURE_START");
                    eventTypeCount++;
                }
                break;
            case TYPE_TOUCH_EXPLORATION_GESTURE_END:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_TOUCH_EXPLORATION_GESTURE_END");
                    eventTypeCount++;
                }
                break;
            case TYPE_WINDOW_CONTENT_CHANGED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_WINDOW_CONTENT_CHANGED");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_TEXT_SELECTION_CHANGED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_VIEW_TEXT_SELECTION_CHANGED");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_SCROLLED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_VIEW_SCROLLED");
                    eventTypeCount++;
                }
                break;
            case TYPE_ANNOUNCEMENT:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_ANNOUNCEMENT");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_ACCESSIBILITY_FOCUSED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_VIEW_ACCESSIBILITY_FOCUSED");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_VIEW_ACCESSIBILITY_FOCUS_CLEARED");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_TEXT_TRAVERSED_AT_MOVEMENT_GRANULARITY:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_VIEW_TEXT_TRAVERSED_AT_MOVEMENT_GRANULARITY");
                    eventTypeCount++;
                }
                break;
            case TYPE_GESTURE_DETECTION_START:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_GESTURE_DETECTION_START");
                    eventTypeCount++;
                }
                break;
            case TYPE_GESTURE_DETECTION_END:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_GESTURE_DETECTION_END");
                    eventTypeCount++;
                }
                break;
            case TYPE_TOUCH_INTERACTION_START:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_TOUCH_INTERACTION_START");
                    eventTypeCount++;
                }
                break;
            case TYPE_TOUCH_INTERACTION_END:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_TOUCH_INTERACTION_END");
                    eventTypeCount++;
                }
                break;
            case TYPE_WINDOWS_CHANGED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_WINDOWS_CHANGED");
                    eventTypeCount++;
                }
                break;
            case TYPE_VIEW_CONTEXT_CLICKED:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_VIEW_CONTEXT_CLICKED");
                    eventTypeCount++;
                }
                break;
            case TYPE_ASSIST_READING_CONTEXT:
                {
                    if (eventTypeCount > 0) {
                        builder.append(", ");
                    }
                    builder.append("TYPE_ASSIST_READING_CONTEXT");
                    eventTypeCount++;
                }
                break;
        }
    }
    if (eventTypeCount > 1) {
        builder.insert(0, '[');
        builder.append(']');
    }
    return builder.toString();
}
------------------------
Find a silently evolved API code:android.text.MeasuredText.setPara:COMMENT
Method Modifier: default     hidden      
Comment:/**
 * Analyzes text for bidirectional runs.  Allocates working buffers.
 */

Body of Frist Method:
{
    mText = text;
    mTextStart = start;
    int len = end - start;
    mLen = len;
    mPos = 0;
    if (mWidths == null || mWidths.length < len) {
        mWidths = ArrayUtils.newUnpaddedFloatArray(len);
    }
    if (mChars == null || mChars.length < len) {
        mChars = ArrayUtils.newUnpaddedCharArray(len);
    }
    TextUtils.getChars(text, start, end, mChars, 0);
    if (text instanceof Spanned) {
        Spanned spanned = (Spanned) text;
        ReplacementSpan[] spans = spanned.getSpans(start, end, ReplacementSpan.class);
        for (int i = 0; i < spans.length; i++) {
            int startInPara = spanned.getSpanStart(spans[i]) - start;
            int endInPara = spanned.getSpanEnd(spans[i]) - start;
            // The span interval may be larger and must be restricted to [start, end[
            if (startInPara < 0)
                startInPara = 0;
            if (endInPara > len)
                endInPara = len;
            for (int j = startInPara; j < endInPara; j++) {
                // object replacement character
                mChars[j] = '\uFFFC';
            }
        }
    }
    if ((textDir == TextDirectionHeuristics.LTR || textDir == TextDirectionHeuristics.FIRSTSTRONG_LTR || textDir == TextDirectionHeuristics.ANYRTL_LTR) && TextUtils.doesNotNeedBidi(mChars, 0, len)) {
        mDir = Layout.DIR_LEFT_TO_RIGHT;
        mEasy = true;
    } else {
        if (mLevels == null || mLevels.length < len) {
            mLevels = ArrayUtils.newUnpaddedByteArray(len);
        }
        int bidiRequest;
        if (textDir == TextDirectionHeuristics.LTR) {
            bidiRequest = Layout.DIR_REQUEST_LTR;
        } else if (textDir == TextDirectionHeuristics.RTL) {
            bidiRequest = Layout.DIR_REQUEST_RTL;
        } else if (textDir == TextDirectionHeuristics.FIRSTSTRONG_LTR) {
            bidiRequest = Layout.DIR_REQUEST_DEFAULT_LTR;
        } else if (textDir == TextDirectionHeuristics.FIRSTSTRONG_RTL) {
            bidiRequest = Layout.DIR_REQUEST_DEFAULT_RTL;
        } else {
            boolean isRtl = textDir.isRtl(mChars, 0, len);
            bidiRequest = isRtl ? Layout.DIR_REQUEST_RTL : Layout.DIR_REQUEST_LTR;
        }
        mDir = AndroidBidi.bidi(bidiRequest, mChars, mLevels, len, false);
        mEasy = false;
    }
}
Body of Second Method:
{
    mBuilder = builder;
    mText = text;
    mTextStart = start;
    int len = end - start;
    mLen = len;
    mPos = 0;
    if (mWidths == null || mWidths.length < len) {
        mWidths = ArrayUtils.newUnpaddedFloatArray(len);
    }
    if (mChars == null || mChars.length < len) {
        mChars = ArrayUtils.newUnpaddedCharArray(len);
    }
    TextUtils.getChars(text, start, end, mChars, 0);
    if (text instanceof Spanned) {
        Spanned spanned = (Spanned) text;
        ReplacementSpan[] spans = spanned.getSpans(start, end, ReplacementSpan.class);
        for (int i = 0; i < spans.length; i++) {
            int startInPara = spanned.getSpanStart(spans[i]) - start;
            int endInPara = spanned.getSpanEnd(spans[i]) - start;
            // The span interval may be larger and must be restricted to [start, end[
            if (startInPara < 0)
                startInPara = 0;
            if (endInPara > len)
                endInPara = len;
            for (int j = startInPara; j < endInPara; j++) {
                // object replacement character
                mChars[j] = '\uFFFC';
            }
        }
    }
    if ((textDir == TextDirectionHeuristics.LTR || textDir == TextDirectionHeuristics.FIRSTSTRONG_LTR || textDir == TextDirectionHeuristics.ANYRTL_LTR) && TextUtils.doesNotNeedBidi(mChars, 0, len)) {
        mDir = Layout.DIR_LEFT_TO_RIGHT;
        mEasy = true;
    } else {
        if (mLevels == null || mLevels.length < len) {
            mLevels = ArrayUtils.newUnpaddedByteArray(len);
        }
        int bidiRequest;
        if (textDir == TextDirectionHeuristics.LTR) {
            bidiRequest = Layout.DIR_REQUEST_LTR;
        } else if (textDir == TextDirectionHeuristics.RTL) {
            bidiRequest = Layout.DIR_REQUEST_RTL;
        } else if (textDir == TextDirectionHeuristics.FIRSTSTRONG_LTR) {
            bidiRequest = Layout.DIR_REQUEST_DEFAULT_LTR;
        } else if (textDir == TextDirectionHeuristics.FIRSTSTRONG_RTL) {
            bidiRequest = Layout.DIR_REQUEST_DEFAULT_RTL;
        } else {
            boolean isRtl = textDir.isRtl(mChars, 0, len);
            bidiRequest = isRtl ? Layout.DIR_REQUEST_RTL : Layout.DIR_REQUEST_LTR;
        }
        mDir = AndroidBidi.bidi(bidiRequest, mChars, mLevels, len, false);
        mEasy = false;
    }
}
------------------------
Find a silently evolved API code:android.app.admin.DeviceAdminReceiver.onReceive:COMMENT
Method Modifier: public      
Comment:/**
 * Intercept standard device administrator broadcasts.  Implementations
 * should not override this method; it is better to implement the
 * convenience callbacks for each action.
 */

Body of Frist Method:
{
    String action = intent.getAction();
    if (ACTION_PASSWORD_CHANGED.equals(action)) {
        onPasswordChanged(context, intent);
    } else if (ACTION_PASSWORD_FAILED.equals(action)) {
        onPasswordFailed(context, intent);
    } else if (ACTION_PASSWORD_SUCCEEDED.equals(action)) {
        onPasswordSucceeded(context, intent);
    } else if (ACTION_DEVICE_ADMIN_ENABLED.equals(action)) {
        onEnabled(context, intent);
    } else if (ACTION_DEVICE_ADMIN_DISABLE_REQUESTED.equals(action)) {
        CharSequence res = onDisableRequested(context, intent);
        if (res != null) {
            Bundle extras = getResultExtras(true);
            extras.putCharSequence(EXTRA_DISABLE_WARNING, res);
        }
    } else if (ACTION_DEVICE_ADMIN_DISABLED.equals(action)) {
        onDisabled(context, intent);
    } else if (ACTION_PASSWORD_EXPIRING.equals(action)) {
        onPasswordExpiring(context, intent);
    } else if (ACTION_PROFILE_PROVISIONING_COMPLETE.equals(action)) {
        onProfileProvisioningComplete(context, intent);
    } else if (ACTION_LOCK_TASK_ENTERING.equals(action)) {
        String pkg = intent.getStringExtra(EXTRA_LOCK_TASK_PACKAGE);
        onLockTaskModeEntering(context, intent, pkg);
    } else if (ACTION_LOCK_TASK_EXITING.equals(action)) {
        onLockTaskModeExiting(context, intent);
    }
}
Body of Second Method:
{
    String action = intent.getAction();
    if (ACTION_PASSWORD_CHANGED.equals(action)) {
        onPasswordChanged(context, intent);
    } else if (ACTION_PASSWORD_FAILED.equals(action)) {
        onPasswordFailed(context, intent);
    } else if (ACTION_PASSWORD_SUCCEEDED.equals(action)) {
        onPasswordSucceeded(context, intent);
    } else if (ACTION_DEVICE_ADMIN_ENABLED.equals(action)) {
        onEnabled(context, intent);
    } else if (ACTION_DEVICE_ADMIN_DISABLE_REQUESTED.equals(action)) {
        CharSequence res = onDisableRequested(context, intent);
        if (res != null) {
            Bundle extras = getResultExtras(true);
            extras.putCharSequence(EXTRA_DISABLE_WARNING, res);
        }
    } else if (ACTION_DEVICE_ADMIN_DISABLED.equals(action)) {
        onDisabled(context, intent);
    } else if (ACTION_PASSWORD_EXPIRING.equals(action)) {
        onPasswordExpiring(context, intent);
    } else if (ACTION_PROFILE_PROVISIONING_COMPLETE.equals(action)) {
        onProfileProvisioningComplete(context, intent);
    } else if (ACTION_CHOOSE_PRIVATE_KEY_ALIAS.equals(action)) {
        int uid = intent.getIntExtra(EXTRA_CHOOSE_PRIVATE_KEY_SENDER_UID, -1);
        Uri uri = intent.getParcelableExtra(EXTRA_CHOOSE_PRIVATE_KEY_URI);
        String alias = intent.getStringExtra(EXTRA_CHOOSE_PRIVATE_KEY_ALIAS);
        String chosenAlias = onChoosePrivateKeyAlias(context, intent, uid, uri, alias);
        setResultData(chosenAlias);
    } else if (ACTION_LOCK_TASK_ENTERING.equals(action)) {
        String pkg = intent.getStringExtra(EXTRA_LOCK_TASK_PACKAGE);
        onLockTaskModeEntering(context, intent, pkg);
    } else if (ACTION_LOCK_TASK_EXITING.equals(action)) {
        onLockTaskModeExiting(context, intent);
    } else if (ACTION_READY_FOR_USER_INITIALIZATION.equals(action)) {
        onReadyForUserInitialization(context, intent);
    } else if (ACTION_NOTIFY_PENDING_SYSTEM_UPDATE.equals(action)) {
        long receivedTime = intent.getLongExtra(EXTRA_SYSTEM_UPDATE_RECEIVED_TIME, -1);
        onSystemUpdatePending(context, intent, receivedTime);
    }
}
------------------------
Find a silently evolved API code:android.location.GpsNavigationMessage.getTypeString:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Gets a string representation of the 'type'.
 * For internal and logging use only.
 */

Body of Frist Method:
{
    switch(mType) {
        case TYPE_UNKNOWN:
            return "Unknown";
        case TYPE_L1CA:
            return "L1 C/A";
        case TYPE_L2CNAV:
            return "L2-CNAV";
        case TYPE_L5CNAV:
            return "L5-CNAV";
        case TYPE_CNAV2:
            return "CNAV-2";
        default:
            return "<Invalid>";
    }
}
Body of Second Method:
{
    switch(mType) {
        case TYPE_UNKNOWN:
            return "Unknown";
        case TYPE_L1CA:
            return "L1 C/A";
        case TYPE_L2CNAV:
            return "L2-CNAV";
        case TYPE_L5CNAV:
            return "L5-CNAV";
        case TYPE_CNAV2:
            return "CNAV-2";
        default:
            return "<Invalid:" + mType + ">";
    }
}
------------------------
Find a silently evolved API code:android.media.AudioManager.getLastAudibleStreamVolume:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get last audible volume before stream was muted.
 *
 * @hide
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        if (mUseMasterVolume) {
            return service.getLastAudibleMasterVolume();
        } else {
            return service.getLastAudibleStreamVolume(streamType);
        }
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in getLastAudibleStreamVolume", e);
        return 0;
    }
}
Body of Second Method:
{
    IAudioService service = getService();
    try {
        return service.getLastAudibleStreamVolume(streamType);
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in getLastAudibleStreamVolume", e);
        return 0;
    }
}
------------------------
Find a silently evolved API code:android.location.GpsMeasurement.setState:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets the sync state.
 */

Body of Frist Method:
{
    switch(value) {
        case STATE_UNKNOWN:
        case STATE_BIT_SYNC:
        case STATE_CODE_LOCK:
        case STATE_SUBFRAME_SYNC:
        case STATE_TOW_DECODED:
            mState = value;
            break;
        default:
            Log.d(TAG, "Sanitizing invalid 'sync state': " + value);
            mState = STATE_UNKNOWN;
            break;
    }
}
Body of Second Method:
{
    mState = value;
}
------------------------
Find a silently evolved API code:android.net.http.HttpResponseCache.maxSize:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the maximum number of bytes that this cache should use to store
 * its data.
 */

Body of Frist Method:
{
    return delegate.getMaxSize();
}
Body of Second Method:
{
    return delegate.maxSize();
}
------------------------
Find a silently evolved API code:android.graphics.drawable.RippleDrawable.draw:COMMENT
Method Modifier: public      
Comment:/**
 * Optimized for drawing ripples with a mask layer and optional content.
 */

Body of Frist Method:
{
    // Clip to the dirty bounds, which will be the drawable bounds if we
    // have a mask or content and the ripple bounds if we're projecting.
    final Rect bounds = getDirtyBounds();
    final int saveCount = canvas.save(Canvas.CLIP_SAVE_FLAG);
    canvas.clipRect(bounds);
    drawContent(canvas);
    drawBackgroundAndRipples(canvas);
    canvas.restoreToCount(saveCount);
}
Body of Second Method:
{
    pruneRipples();
    // Clip to the dirty bounds, which will be the drawable bounds if we
    // have a mask or content and the ripple bounds if we're projecting.
    final Rect bounds = getDirtyBounds();
    final int saveCount = canvas.save(Canvas.CLIP_SAVE_FLAG);
    canvas.clipRect(bounds);
    drawContent(canvas);
    drawBackgroundAndRipples(canvas);
    canvas.restoreToCount(saveCount);
}
------------------------
Find a silently evolved API code:android.os.BatteryManager.queryProperty:COMMENT
Method Modifier: private     
Comment:/**
 * Query a battery property from the batteryproperties service.
 *
 * Returns the requested value, or Long.MIN_VALUE if property not
 * supported on this system or on other error.
 */

Body of Frist Method:
{
    long ret;
    if (mBatteryPropertiesRegistrar == null) {
        IBinder b = ServiceManager.getService("batteryproperties");
        mBatteryPropertiesRegistrar = IBatteryPropertiesRegistrar.Stub.asInterface(b);
        if (mBatteryPropertiesRegistrar == null)
            return Long.MIN_VALUE;
    }
    try {
        BatteryProperty prop = new BatteryProperty();
        if (mBatteryPropertiesRegistrar.getProperty(id, prop) == 0)
            ret = prop.getLong();
        else
            ret = Long.MIN_VALUE;
    } catch (RemoteException e) {
        ret = Long.MIN_VALUE;
    }
    return ret;
}
Body of Second Method:
{
    long ret;
    if (mBatteryPropertiesRegistrar == null) {
        return Long.MIN_VALUE;
    }
    try {
        BatteryProperty prop = new BatteryProperty();
        if (mBatteryPropertiesRegistrar.getProperty(id, prop) == 0)
            ret = prop.getLong();
        else
            ret = Long.MIN_VALUE;
    } catch (RemoteException e) {
        ret = Long.MIN_VALUE;
    }
    return ret;
}
------------------------
Find a silently evolved API code:android.widget.TimePickerClockDelegate.updateDisplay:COMMENT
Method Modifier: private     
Comment:/**
 * Update the hours, minutes, and AM/PM displays with the typed times. If the typedTimes is
 * empty, either show an empty display (filled with the placeholder text), or update from the
 * timepicker's values.
 *
 * @param allowEmptyDisplay if true, then if the typedTimes is empty, use the placeholder text.
 * Otherwise, revert to the timepicker's values.
 */

Body of Frist Method:
{
    if (!allowEmptyDisplay && mTypedTimes.isEmpty()) {
        int hour = mRadialTimePickerView.getCurrentHour();
        int minute = mRadialTimePickerView.getCurrentMinute();
        updateHeaderHour(hour, false);
        updateHeaderMinute(minute, false);
        if (!mIs24HourView) {
            updateAmPmLabelStates(hour < 12 ? AM : PM);
        }
        setCurrentItemShowing(mRadialTimePickerView.getCurrentItemShowing(), true, true);
        onValidationChanged(true);
    } else {
        boolean[] enteredZeros = { false, false };
        int[] values = getEnteredTime(enteredZeros);
        String hourFormat = enteredZeros[0] ? "%02d" : "%2d";
        String minuteFormat = (enteredZeros[1]) ? "%02d" : "%2d";
        String hourStr = (values[0] == -1) ? mDoublePlaceholderText : String.format(hourFormat, values[0]).replace(' ', mPlaceholderText);
        String minuteStr = (values[1] == -1) ? mDoublePlaceholderText : String.format(minuteFormat, values[1]).replace(' ', mPlaceholderText);
        mHourView.setText(hourStr);
        mHourView.setSelected(false);
        mMinuteView.setText(minuteStr);
        mMinuteView.setSelected(false);
        if (!mIs24HourView) {
            updateAmPmLabelStates(values[2]);
        }
    }
}
Body of Second Method:
{
    if (!allowEmptyDisplay && mTypedTimes.isEmpty()) {
        int hour = mRadialTimePickerView.getCurrentHour();
        int minute = mRadialTimePickerView.getCurrentMinute();
        updateHeaderHour(hour, false);
        updateHeaderMinute(minute, false);
        if (!mIs24HourView) {
            updateAmPmLabelStates(hour < 12 ? AM : PM);
        }
        setCurrentItemShowing(mRadialTimePickerView.getCurrentItemShowing(), true, true);
        onValidationChanged(true);
    } else {
        boolean[] enteredZeros = { false, false };
        int[] values = getEnteredTime(enteredZeros);
        String hourFormat = enteredZeros[0] ? "%02d" : "%2d";
        String minuteFormat = (enteredZeros[1]) ? "%02d" : "%2d";
        String hourStr = (values[0] == -1) ? mDoublePlaceholderText : String.format(hourFormat, values[0]).replace(' ', mPlaceholderText);
        String minuteStr = (values[1] == -1) ? mDoublePlaceholderText : String.format(minuteFormat, values[1]).replace(' ', mPlaceholderText);
        mHourView.setText(hourStr);
        mHourView.setActivated(false);
        mMinuteView.setText(minuteStr);
        mMinuteView.setActivated(false);
        if (!mIs24HourView) {
            updateAmPmLabelStates(values[2]);
        }
    }
}
------------------------
Find a silently evolved API code:android.widget.AdapterView.getPositionForView:COMMENT
Method Modifier: public      
Comment:/**
 * Get the position within the adapter's data set for the view, where view is a an adapter item
 * or a descendant of an adapter item.
 *
 * @param view an adapter item, or a descendant of an adapter item. This must be visible in this
 * AdapterView at the time of the call.
 * @return the position within the adapter's data set of the view, or {@link #INVALID_POSITION}
 * if the view does not correspond to a list item (or it is not currently visible).
 */

Body of Frist Method:
{
    View listItem = view;
    try {
        View v;
        while (!(v = (View) listItem.getParent()).equals(this)) {
            listItem = v;
        }
    } catch (ClassCastException e) {
        // We made it up to the window without find this list view
        return INVALID_POSITION;
    }
    // Search the children for the list item
    final int childCount = getChildCount();
    for (int i = 0; i < childCount; i++) {
        if (getChildAt(i).equals(listItem)) {
            return mFirstPosition + i;
        }
    }
    // Child not found!
    return INVALID_POSITION;
}
Body of Second Method:
{
    View listItem = view;
    try {
        View v;
        while ((v = (View) listItem.getParent()) != null && !v.equals(this)) {
            listItem = v;
        }
    } catch (ClassCastException e) {
        // We made it up to the window without find this list view
        return INVALID_POSITION;
    }
    if (listItem != null) {
        // Search the children for the list item
        final int childCount = getChildCount();
        for (int i = 0; i < childCount; i++) {
            if (getChildAt(i).equals(listItem)) {
                return mFirstPosition + i;
            }
        }
    }
    // Child not found!
    return INVALID_POSITION;
}
------------------------
Find a silently evolved API code:android.widget.AdapterView.performItemClick:COMMENT
Method Modifier: public      
Comment:/**
 * Call the OnItemClickListener, if it is defined. Performs all normal
 * actions associated with clicking: reporting accessibility event, playing
 * a sound, etc.
 *
 * @param view The view within the AdapterView that was clicked.
 * @param position The position of the view in the adapter.
 * @param id The row id of the item that was clicked.
 * @return True if there was an assigned OnItemClickListener that was
 * called, false otherwise is returned.
 */

Body of Frist Method:
{
    if (mOnItemClickListener != null) {
        playSoundEffect(SoundEffectConstants.CLICK);
        mOnItemClickListener.onItemClick(this, view, position, id);
        if (view != null) {
            view.sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);
        }
        return true;
    }
    return false;
}
Body of Second Method:
{
    final boolean result;
    if (mOnItemClickListener != null) {
        playSoundEffect(SoundEffectConstants.CLICK);
        mOnItemClickListener.onItemClick(this, view, position, id);
        result = true;
    } else {
        result = false;
    }
    if (view != null) {
        view.sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);
    }
    return result;
}
------------------------
Find a silently evolved API code:android.view.accessibility.AccessibilityEvent.readAccessibilityRecordFromParcel:COMMENT
Method Modifier: private     
Comment:/**
 * Reads an {@link AccessibilityRecord} from a parcel.
 *
 * @param record The record to initialize.
 * @param parcel The parcel to read from.
 */

Body of Frist Method:
{
    record.mBooleanProperties = parcel.readInt();
    record.mCurrentItemIndex = parcel.readInt();
    record.mItemCount = parcel.readInt();
    record.mFromIndex = parcel.readInt();
    record.mToIndex = parcel.readInt();
    record.mScrollX = parcel.readInt();
    record.mScrollY = parcel.readInt();
    record.mMaxScrollX = parcel.readInt();
    record.mMaxScrollY = parcel.readInt();
    record.mAddedCount = parcel.readInt();
    record.mRemovedCount = parcel.readInt();
    record.mClassName = TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(parcel);
    record.mContentDescription = TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(parcel);
    record.mBeforeText = TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(parcel);
    record.mParcelableData = parcel.readParcelable(null);
    parcel.readList(record.mText, null);
    record.mSourceWindowId = parcel.readInt();
    record.mSourceNodeId = parcel.readLong();
    record.mSealed = (parcel.readInt() == 1);
}
Body of Second Method:
{
    record.mBooleanProperties = parcel.readInt();
    record.mCurrentItemIndex = parcel.readInt();
    record.mItemCount = parcel.readInt();
    record.mFromIndex = parcel.readInt();
    record.mToIndex = parcel.readInt();
    record.mScrollX = parcel.readInt();
    record.mScrollY = parcel.readInt();
    record.mMaxScrollX = parcel.readInt();
    record.mMaxScrollY = parcel.readInt();
    record.mAddedCount = parcel.readInt();
    record.mRemovedCount = parcel.readInt();
    record.mClassName = TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(parcel);
    record.mContentDescription = TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(parcel);
    record.mBeforeText = TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(parcel);
    record.mParcelableData = parcel.readParcelable(null);
    parcel.readList(record.mText, null);
    record.mSourceWindowId = parcel.readInt();
    record.mSourceNode = parcel.readParcelable(null);
    record.mSealed = (parcel.readInt() == 1);
}
------------------------
Find a silently evolved API code:android.widget.TableLayout.findLargestCells:COMMENT
Method Modifier: private     
Comment:/**
 * <p>Finds the largest cell in each column. For each column, the width of
 * the largest cell is applied to all the other cells.</p>
 *
 * @param widthMeasureSpec the measure constraint imposed by our parent
 */

Body of Frist Method:
{
    boolean firstRow = true;
    // find the maximum width for each column
    // the total number of columns is dynamically changed if we find
    // wider rows as we go through the children
    // the array is reused for each layout operation; the array can grow
    // but never shrinks. Unused extra cells in the array are just ignored
    // this behavior avoids to unnecessary grow the array after the first
    // layout operation
    final int count = getChildCount();
    for (int i = 0; i < count; i++) {
        final View child = getChildAt(i);
        if (child.getVisibility() == GONE) {
            continue;
        }
        if (child instanceof TableRow) {
            final TableRow row = (TableRow) child;
            // forces the row's height
            final ViewGroup.LayoutParams layoutParams = row.getLayoutParams();
            layoutParams.height = LayoutParams.WRAP_CONTENT;
            final int[] widths = row.getColumnsWidths(widthMeasureSpec);
            final int newLength = widths.length;
            // this is the first row, we just need to copy the values
            if (firstRow) {
                if (mMaxWidths == null || mMaxWidths.length != newLength) {
                    mMaxWidths = new int[newLength];
                }
                System.arraycopy(widths, 0, mMaxWidths, 0, newLength);
                firstRow = false;
            } else {
                int length = mMaxWidths.length;
                final int difference = newLength - length;
                // we just grow the array and copy the values
                if (difference > 0) {
                    final int[] oldMaxWidths = mMaxWidths;
                    mMaxWidths = new int[newLength];
                    System.arraycopy(oldMaxWidths, 0, mMaxWidths, 0, oldMaxWidths.length);
                    System.arraycopy(widths, oldMaxWidths.length, mMaxWidths, oldMaxWidths.length, difference);
                }
                // the row is narrower or of the same width as the previous
                // rows, so we find the maximum width for each column
                // if the row is narrower than the previous ones,
                // difference will be negative
                final int[] maxWidths = mMaxWidths;
                length = Math.min(length, newLength);
                for (int j = 0; j < length; j++) {
                    maxWidths[j] = Math.max(maxWidths[j], widths[j]);
                }
            }
        }
    }
}
Body of Second Method:
{
    boolean firstRow = true;
    // find the maximum width for each column
    // the total number of columns is dynamically changed if we find
    // wider rows as we go through the children
    // the array is reused for each layout operation; the array can grow
    // but never shrinks. Unused extra cells in the array are just ignored
    // this behavior avoids to unnecessary grow the array after the first
    // layout operation
    final int count = getChildCount();
    for (int i = 0; i < count; i++) {
        final View child = getChildAt(i);
        if (child.getVisibility() == GONE) {
            continue;
        }
        if (child instanceof TableRow) {
            final TableRow row = (TableRow) child;
            // forces the row's height
            final ViewGroup.LayoutParams layoutParams = row.getLayoutParams();
            layoutParams.height = LayoutParams.WRAP_CONTENT;
            final int[] widths = row.getColumnsWidths(widthMeasureSpec, heightMeasureSpec);
            final int newLength = widths.length;
            // this is the first row, we just need to copy the values
            if (firstRow) {
                if (mMaxWidths == null || mMaxWidths.length != newLength) {
                    mMaxWidths = new int[newLength];
                }
                System.arraycopy(widths, 0, mMaxWidths, 0, newLength);
                firstRow = false;
            } else {
                int length = mMaxWidths.length;
                final int difference = newLength - length;
                // we just grow the array and copy the values
                if (difference > 0) {
                    final int[] oldMaxWidths = mMaxWidths;
                    mMaxWidths = new int[newLength];
                    System.arraycopy(oldMaxWidths, 0, mMaxWidths, 0, oldMaxWidths.length);
                    System.arraycopy(widths, oldMaxWidths.length, mMaxWidths, oldMaxWidths.length, difference);
                }
                // the row is narrower or of the same width as the previous
                // rows, so we find the maximum width for each column
                // if the row is narrower than the previous ones,
                // difference will be negative
                final int[] maxWidths = mMaxWidths;
                length = Math.min(length, newLength);
                for (int j = 0; j < length; j++) {
                    maxWidths[j] = Math.max(maxWidths[j], widths[j]);
                }
            }
        }
    }
}
------------------------
Find a silently evolved API code:android.os.PowerManager.validateWakeLockParameters:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    switch(levelAndFlags & WAKE_LOCK_LEVEL_MASK) {
        case PARTIAL_WAKE_LOCK:
        case SCREEN_DIM_WAKE_LOCK:
        case SCREEN_BRIGHT_WAKE_LOCK:
        case FULL_WAKE_LOCK:
        case PROXIMITY_SCREEN_OFF_WAKE_LOCK:
        case DOZE_WAKE_LOCK:
            break;
        default:
            throw new IllegalArgumentException("Must specify a valid wake lock level.");
    }
    if (tag == null) {
        throw new IllegalArgumentException("The tag must not be null.");
    }
}
Body of Second Method:
{
    switch(levelAndFlags & WAKE_LOCK_LEVEL_MASK) {
        case PARTIAL_WAKE_LOCK:
        case SCREEN_DIM_WAKE_LOCK:
        case SCREEN_BRIGHT_WAKE_LOCK:
        case FULL_WAKE_LOCK:
        case PROXIMITY_SCREEN_OFF_WAKE_LOCK:
        case DOZE_WAKE_LOCK:
        case DRAW_WAKE_LOCK:
            break;
        default:
            throw new IllegalArgumentException("Must specify a valid wake lock level.");
    }
    if (tag == null) {
        throw new IllegalArgumentException("The tag must not be null.");
    }
}
------------------------
Find a silently evolved API code:android.speech.tts.TextToSpeechService.SynthHandler.enqueueSpeechItem:COMMENT
Method Modifier: public      
Comment:/**
 * Adds a speech item to the queue.
 *
 * Called on a service binder thread.
 */

Body of Frist Method:
{
    UtteranceProgressDispatcher utterenceProgress = null;
    if (speechItem instanceof UtteranceProgressDispatcher) {
        utterenceProgress = (UtteranceProgressDispatcher) speechItem;
    }
    if (!speechItem.isValid()) {
        if (utterenceProgress != null) {
            utterenceProgress.dispatchOnError(TextToSpeech.ERROR_INVALID_REQUEST);
        }
        return TextToSpeech.ERROR;
    }
    if (queueMode == TextToSpeech.QUEUE_FLUSH) {
        stopForApp(speechItem.getCallerIdentity());
    } else if (queueMode == TextToSpeech.QUEUE_DESTROY) {
        stopAll();
    }
    Runnable runnable = new Runnable() {

        @Override
        public void run() {
            setCurrentSpeechItem(speechItem);
            speechItem.play();
            setCurrentSpeechItem(null);
        }
    };
    Message msg = Message.obtain(this, runnable);
    // The obj is used to remove all callbacks from the given app in
    // stopForApp(String).
    // 
    // Note that this string is interned, so the == comparison works.
    msg.obj = speechItem.getCallerIdentity();
    if (sendMessage(msg)) {
        return TextToSpeech.SUCCESS;
    } else {
        Log.w(TAG, "SynthThread has quit");
        if (utterenceProgress != null) {
            utterenceProgress.dispatchOnError(TextToSpeech.ERROR_SERVICE);
        }
        return TextToSpeech.ERROR;
    }
}
Body of Second Method:
{
    UtteranceProgressDispatcher utterenceProgress = null;
    if (speechItem instanceof UtteranceProgressDispatcher) {
        utterenceProgress = (UtteranceProgressDispatcher) speechItem;
    }
    if (!speechItem.isValid()) {
        if (utterenceProgress != null) {
            utterenceProgress.dispatchOnError(TextToSpeech.ERROR_INVALID_REQUEST);
        }
        return TextToSpeech.ERROR;
    }
    if (queueMode == TextToSpeech.QUEUE_FLUSH) {
        stopForApp(speechItem.getCallerIdentity());
    } else if (queueMode == TextToSpeech.QUEUE_DESTROY) {
        stopAll();
    }
    Runnable runnable = new Runnable() {

        @Override
        public void run() {
            if (isFlushed(speechItem)) {
                speechItem.stop();
            } else {
                setCurrentSpeechItem(speechItem);
                speechItem.play();
                setCurrentSpeechItem(null);
            }
        }
    };
    Message msg = Message.obtain(this, runnable);
    // The obj is used to remove all callbacks from the given app in
    // stopForApp(String).
    // 
    // Note that this string is interned, so the == comparison works.
    msg.obj = speechItem.getCallerIdentity();
    if (sendMessage(msg)) {
        return TextToSpeech.SUCCESS;
    } else {
        Log.w(TAG, "SynthThread has quit");
        if (utterenceProgress != null) {
            utterenceProgress.dispatchOnError(TextToSpeech.ERROR_SERVICE);
        }
        return TextToSpeech.ERROR;
    }
}
------------------------
Find a silently evolved API code:android.graphics.drawable.AnimationDrawable.setVisible:COMMENT
Method Modifier: public      
Comment:/**
 * Sets whether this AnimationDrawable is visible.
 * <p>
 * When the drawable becomes invisible, it will pause its animation. A
 * subsequent change to visible with <code>restart</code> set to true will
 * restart the animation from the first frame. If <code>restart</code> is
 * false, the animation will resume from the most recent frame.
 *
 * @param visible true if visible, false otherwise
 * @param restart when visible, true to force the animation to restart
 * from the first frame
 * @return true if the new visibility is different than its previous state
 */

Body of Frist Method:
{
    final boolean changed = super.setVisible(visible, restart);
    if (visible) {
        if (restart || changed) {
            boolean startFromZero = restart || mCurFrame < 0 || mCurFrame >= mAnimationState.getChildCount();
            setFrame(startFromZero ? 0 : mCurFrame, true, mAnimating);
        }
    } else {
        unscheduleSelf(this);
    }
    return changed;
}
Body of Second Method:
{
    final boolean changed = super.setVisible(visible, restart);
    if (visible) {
        if (restart || changed) {
            boolean startFromZero = restart || !mRunning || mCurFrame >= mAnimationState.getChildCount();
            setFrame(startFromZero ? 0 : mCurFrame, true, mAnimating);
        }
    } else {
        unscheduleSelf(this);
    }
    return changed;
}
------------------------
Find a silently evolved API code:android.print.PrintAttributes.asPortrait:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Gets a new print attributes instance which is in portrait orientation,
 * which is the media size is in portrait and all orientation dependent
 * attributes such as resolution and margins are properly adjusted.
 *
 * @return New instance in portrait orientation if this one is in
 * landscape, otherwise this instance.
 *
 * @hide
 */

Body of Frist Method:
{
    if (isPortrait()) {
        return this;
    }
    PrintAttributes attributes = new PrintAttributes();
    // Rotate the media size.
    attributes.setMediaSize(getMediaSize().asPortrait());
    // Rotate the resolution.
    Resolution oldResolution = getResolution();
    Resolution newResolution = new Resolution(oldResolution.getId(), oldResolution.getLabel(), oldResolution.getVerticalDpi(), oldResolution.getHorizontalDpi());
    attributes.setResolution(newResolution);
    // Do not rotate the physical margins.
    attributes.setMinMargins(getMinMargins());
    attributes.setColorMode(getColorMode());
    return attributes;
}
Body of Second Method:
{
    if (isPortrait()) {
        return this;
    }
    PrintAttributes attributes = new PrintAttributes();
    // Rotate the media size.
    attributes.setMediaSize(getMediaSize().asPortrait());
    // Rotate the resolution.
    Resolution oldResolution = getResolution();
    Resolution newResolution = new Resolution(oldResolution.getId(), oldResolution.getLabel(), oldResolution.getVerticalDpi(), oldResolution.getHorizontalDpi());
    attributes.setResolution(newResolution);
    // Do not rotate the physical margins.
    attributes.setMinMargins(getMinMargins());
    attributes.setColorMode(getColorMode());
    attributes.setDuplexMode(getDuplexMode());
    return attributes;
}
------------------------
Find a silently evolved API code:android.content.ContentResolver.getStreamTypes:COMMENT
Method Modifier: public      
Comment:/**
 * Query for the possible MIME types for the representations the given
 * content URL can be returned when opened as as stream with
 * {@link #openTypedAssetFileDescriptor}.  Note that the types here are
 * not necessarily a superset of the type returned by {@link #getType} --
 * many content providers cannot return a raw stream for the structured
 * data that they contain.
 *
 * @param url A Uri identifying content (either a list or specific type),
 * using the content:// scheme.
 * @param mimeTypeFilter The desired MIME type.  This may be a pattern,
 * such as *&#47;*, to query for all available MIME types that match the
 * pattern.
 * @return Returns an array of MIME type strings for all available
 * data streams that match the given mimeTypeFilter.  If there are none,
 * null is returned.
 */

Body of Frist Method:
{
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        return null;
    }
    try {
        return provider.getStreamTypes(url, mimeTypeFilter);
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } finally {
        releaseProvider(provider);
    }
}
Body of Second Method:
{
    Preconditions.checkNotNull(url, "url");
    Preconditions.checkNotNull(mimeTypeFilter, "mimeTypeFilter");
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        return null;
    }
    try {
        return provider.getStreamTypes(url, mimeTypeFilter);
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return null;
    } finally {
        releaseProvider(provider);
    }
}
------------------------
Find a silently evolved API code:android.content.res.BridgeTypedArray.getInt:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the integer value for the attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined.
 *
 * @return Attribute int value, or defValue if not defined.
 */

Body of Frist Method:
{
    String s = getString(index);
    try {
        if (s != null) {
            return XmlUtils.convertValueToInt(s, defValue);
        }
    } catch (NumberFormatException e) {
        Bridge.getLog().warning(LayoutLog.TAG_RESOURCES_FORMAT, String.format("\"%1$s\" in attribute \"%2$s\" is not a valid integer", s, mNames[index]), null);
        return defValue;
    }
    return defValue;
}
Body of Second Method:
{
    String s = getString(index);
    try {
        return convertValueToInt(s, defValue);
    } catch (NumberFormatException e) {
        Bridge.getLog().warning(LayoutLog.TAG_RESOURCES_FORMAT, String.format("\"%1$s\" in attribute \"%2$s\" is not a valid integer", s, mNames[index]), null);
    }
    return defValue;
}
------------------------
Find a silently evolved API code:android.renderscript.Mesh.TriangleMeshBuilder.create:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * @deprecated in API 16
 * Creates the mesh object from the current state of the builder
 *
 * @param uploadToBufferObject specifies whether the vertex data
 * is to be uploaded into the buffer
 * object indicating that it's likely
 * not going to be modified and
 * rendered many times.
 * Alternatively, it indicates the
 * mesh data will be updated
 * frequently and remain in script
 * accessible memory
 */

Body of Frist Method:
{
    Element.Builder b = new Element.Builder(mRS);
    b.add(Element.createVector(mRS, Element.DataType.FLOAT_32, mVtxSize), "position");
    if ((mFlags & COLOR) != 0) {
        b.add(Element.F32_4(mRS), "color");
    }
    if ((mFlags & TEXTURE_0) != 0) {
        b.add(Element.F32_2(mRS), "texture0");
    }
    if ((mFlags & NORMAL) != 0) {
        b.add(Element.F32_3(mRS), "normal");
    }
    mElement = b.create();
    int usage = Allocation.USAGE_SCRIPT;
    if (uploadToBufferObject) {
        usage |= Allocation.USAGE_GRAPHICS_VERTEX;
    }
    Builder smb = new Builder(mRS, usage);
    smb.addVertexType(mElement, mMaxIndex);
    smb.addIndexSetType(Element.U16(mRS), mIndexCount, Primitive.TRIANGLE);
    Mesh sm = smb.create();
    sm.getVertexAllocation(0).copy1DRangeFromUnchecked(0, mMaxIndex, mVtxData);
    if (uploadToBufferObject) {
        if (uploadToBufferObject) {
            sm.getVertexAllocation(0).syncAll(Allocation.USAGE_SCRIPT);
        }
    }
    sm.getIndexSetAllocation(0).copy1DRangeFromUnchecked(0, mIndexCount, mIndexData);
    if (uploadToBufferObject) {
        sm.getIndexSetAllocation(0).syncAll(Allocation.USAGE_SCRIPT);
    }
    return sm;
}
Body of Second Method:
{
    Element.Builder b = new Element.Builder(mRS);
    b.add(Element.createVector(mRS, Element.DataType.FLOAT_32, mVtxSize), "position");
    if ((mFlags & COLOR) != 0) {
        b.add(Element.F32_4(mRS), "color");
    }
    if ((mFlags & TEXTURE_0) != 0) {
        b.add(Element.F32_2(mRS), "texture0");
    }
    if ((mFlags & NORMAL) != 0) {
        b.add(Element.F32_3(mRS), "normal");
    }
    mElement = b.create();
    int usage = Allocation.USAGE_SCRIPT;
    if (uploadToBufferObject) {
        usage |= Allocation.USAGE_GRAPHICS_VERTEX;
    }
    Builder smb = new Builder(mRS, usage);
    smb.addVertexType(mElement, mMaxIndex);
    smb.addIndexSetType(Element.U16(mRS), mIndexCount, Primitive.TRIANGLE);
    Mesh sm = smb.create();
    sm.getVertexAllocation(0).copy1DRangeFromUnchecked(0, mMaxIndex, mVtxData);
    if (uploadToBufferObject) {
        sm.getVertexAllocation(0).syncAll(Allocation.USAGE_SCRIPT);
    }
    sm.getIndexSetAllocation(0).copy1DRangeFromUnchecked(0, mIndexCount, mIndexData);
    if (uploadToBufferObject) {
        sm.getIndexSetAllocation(0).syncAll(Allocation.USAGE_SCRIPT);
    }
    return sm;
}
------------------------
Find a silently evolved API code:android.graphics.ColorMatrix.setRotate:COMMENT
Method Modifier: public      
Comment:/**
 * Set the rotation on a color axis by the specified values.
 * <p>
 * <code>axis=0</code> correspond to a rotation around the RED color
 * <code>axis=1</code> correspond to a rotation around the GREEN color
 * <code>axis=2</code> correspond to a rotation around the BLUE color
 * </p>
 */

Body of Frist Method:
{
    reset();
    float radians = degrees * (float) Math.PI / 180;
    float cosine = FloatMath.cos(radians);
    float sine = FloatMath.sin(radians);
    switch(axis) {
        // Rotation around the red color
        case 0:
            mArray[6] = mArray[12] = cosine;
            mArray[7] = sine;
            mArray[11] = -sine;
            break;
        // Rotation around the green color
        case 1:
            mArray[0] = mArray[12] = cosine;
            mArray[2] = -sine;
            mArray[10] = sine;
            break;
        // Rotation around the blue color
        case 2:
            mArray[0] = mArray[6] = cosine;
            mArray[1] = sine;
            mArray[5] = -sine;
            break;
        default:
            throw new RuntimeException();
    }
}
Body of Second Method:
{
    reset();
    double radians = degrees * Math.PI / 180d;
    float cosine = (float) Math.cos(radians);
    float sine = (float) Math.sin(radians);
    switch(axis) {
        // Rotation around the red color
        case 0:
            mArray[6] = mArray[12] = cosine;
            mArray[7] = sine;
            mArray[11] = -sine;
            break;
        // Rotation around the green color
        case 1:
            mArray[0] = mArray[12] = cosine;
            mArray[2] = -sine;
            mArray[10] = sine;
            break;
        // Rotation around the blue color
        case 2:
            mArray[0] = mArray[6] = cosine;
            mArray[1] = sine;
            mArray[5] = -sine;
            break;
        default:
            throw new RuntimeException();
    }
}
------------------------
Find a silently evolved API code:android.renderscript.AllocationAdapter.setZ:COMMENT
Method Modifier: public      
Comment:/**
 * Set the active Z.  The z value must be within the range for
 * the allocation being adapted.  The base allocation must
 * contain the Z dimension.
 *
 * @param z The z to make active.
 */

Body of Frist Method:
{
    if (mAdaptedAllocation.getType().getZ() == 0) {
        throw new RSInvalidStateException("Cannot set Z when the allocation type does not include Z dim.");
    }
    if (mAdaptedAllocation.getType().getZ() <= z) {
        throw new RSInvalidStateException("Cannot set Z greater than dimension of allocation.");
    }
    if (!mConstrainedZ) {
        throw new RSInvalidStateException("Cannot set Z when the adapter includes Z.");
    }
    mSelectedZ = z;
}
Body of Second Method:
{
    if (mAdaptedAllocation.getType().getZ() == 0) {
        throw new RSInvalidStateException("Cannot set Z when the allocation type does not include Z dim.");
    }
    if (mAdaptedAllocation.getType().getZ() <= z) {
        throw new RSInvalidStateException("Cannot set Z greater than dimension of allocation.");
    }
    if (mWindow.getZ() == mAdaptedAllocation.getType().getZ()) {
        throw new RSInvalidStateException("Cannot set Z when the adapter includes Z.");
    }
    if ((mWindow.getZ() + z) >= mAdaptedAllocation.getType().getZ()) {
        throw new RSInvalidStateException("Cannot set (Z + window) which would be larger than dimension of allocation.");
    }
    mSelectedZ = z;
    updateOffsets();
}
------------------------
Find a silently evolved API code:android.renderscript.AllocationAdapter.setY:COMMENT
Method Modifier: public      
Comment:/**
 * Set the active Y.  The y value must be within the range for
 * the allocation being adapted.  The base allocation must
 * contain the Y dimension.
 *
 * @param y The y to make active.
 */

Body of Frist Method:
{
    if (mAdaptedAllocation.getType().getY() == 0) {
        throw new RSInvalidStateException("Cannot set Y when the allocation type does not include Y dim.");
    }
    if (mAdaptedAllocation.getType().getY() <= y) {
        throw new RSInvalidStateException("Cannot set Y greater than dimension of allocation.");
    }
    if (!mConstrainedY) {
        throw new RSInvalidStateException("Cannot set Y when the adapter includes Y.");
    }
    mSelectedY = y;
}
Body of Second Method:
{
    if (mAdaptedAllocation.getType().getY() == 0) {
        throw new RSInvalidStateException("Cannot set Y when the allocation type does not include Y dim.");
    }
    if (mAdaptedAllocation.getType().getY() <= y) {
        throw new RSInvalidStateException("Cannot set Y greater than dimension of allocation.");
    }
    if (mWindow.getY() == mAdaptedAllocation.getType().getY()) {
        throw new RSInvalidStateException("Cannot set Y when the adapter includes Y.");
    }
    if ((mWindow.getY() + y) >= mAdaptedAllocation.getType().getY()) {
        throw new RSInvalidStateException("Cannot set (Y + window) which would be larger than dimension of allocation.");
    }
    mSelectedY = y;
    updateOffsets();
}
------------------------
Find a silently evolved API code:android.graphics.Bitmap.getHeight:COMMENT
Method Modifier: public      final       
Comment:/**
 * Returns the bitmap's height
 */

Body of Frist Method:
{
    return mHeight;
}
Body of Second Method:
{
    if (mRecycled) {
        Log.w(TAG, "Called getHeight() on a recycle()'d bitmap! This is undefined behavior!");
    }
    return mHeight;
}
------------------------
Find a silently evolved API code:android.widget.FastScroller.setThumbPos:COMMENT
Method Modifier: private     
Comment:/**
 * Positions the thumb and preview widgets.
 *
 * @param position The position, between 0 and 1, along the track at which
 * to place the thumb.
 */

Body of Frist Method:
{
    final Rect container = mContainerRect;
    final int top = container.top;
    final int bottom = container.bottom;
    final View trackImage = mTrackImage;
    final View thumbImage = mThumbImage;
    final float min = trackImage.getTop();
    final float max = trackImage.getBottom();
    final float offset = min;
    final float range = max - min;
    final float thumbMiddle = position * range + offset;
    thumbImage.setTranslationY(thumbMiddle - thumbImage.getHeight() / 2);
    final View previewImage = mPreviewImage;
    final float previewHalfHeight = previewImage.getHeight() / 2f;
    final float previewPos;
    switch(mOverlayPosition) {
        case OVERLAY_AT_THUMB:
            previewPos = thumbMiddle;
            break;
        case OVERLAY_ABOVE_THUMB:
            previewPos = thumbMiddle - previewHalfHeight;
            break;
        case OVERLAY_FLOATING:
        default:
            previewPos = 0;
            break;
    }
    // Center the preview on the thumb, constrained to the list bounds.
    final float minP = top + previewHalfHeight;
    final float maxP = bottom - previewHalfHeight;
    final float previewMiddle = MathUtils.constrain(previewPos, minP, maxP);
    final float previewTop = previewMiddle - previewHalfHeight;
    previewImage.setTranslationY(previewTop);
    mPrimaryText.setTranslationY(previewTop);
    mSecondaryText.setTranslationY(previewTop);
}
Body of Second Method:
{
    final float thumbMiddle = position * mThumbRange + mThumbOffset;
    mThumbImage.setTranslationY(thumbMiddle - mThumbImage.getHeight() / 2f);
    final View previewImage = mPreviewImage;
    final float previewHalfHeight = previewImage.getHeight() / 2f;
    final float previewPos;
    switch(mOverlayPosition) {
        case OVERLAY_AT_THUMB:
            previewPos = thumbMiddle;
            break;
        case OVERLAY_ABOVE_THUMB:
            previewPos = thumbMiddle - previewHalfHeight;
            break;
        case OVERLAY_FLOATING:
        default:
            previewPos = 0;
            break;
    }
    // Center the preview on the thumb, constrained to the list bounds.
    final Rect container = mContainerRect;
    final int top = container.top;
    final int bottom = container.bottom;
    final float minP = top + previewHalfHeight;
    final float maxP = bottom - previewHalfHeight;
    final float previewMiddle = MathUtils.constrain(previewPos, minP, maxP);
    final float previewTop = previewMiddle - previewHalfHeight;
    previewImage.setTranslationY(previewTop);
    mPrimaryText.setTranslationY(previewTop);
    mSecondaryText.setTranslationY(previewTop);
}
------------------------
Find a silently evolved API code:android.os.storage.IMountServiceListener.Stub.Proxy.onUsbMassStorageConnectionChanged:COMMENT
Method Modifier: public      
Comment:/**
 * Detection state of USB Mass Storage has changed
 *
 * @param available true if a UMS host is connected.
 */

Body of Frist Method:
{
    Parcel _data = Parcel.obtain();
    Parcel _reply = Parcel.obtain();
    try {
        _data.writeInterfaceToken(DESCRIPTOR);
        _data.writeInt(((connected) ? (1) : (0)));
        mRemote.transact(Stub.TRANSACTION_onUsbMassStorageConnectionChanged, _data, _reply, 0);
        _reply.readException();
    } finally {
        _reply.recycle();
        _data.recycle();
    }
}
Body of Second Method:
{
    Parcel _data = Parcel.obtain();
    Parcel _reply = Parcel.obtain();
    try {
        _data.writeInterfaceToken(DESCRIPTOR);
        _data.writeInt(((connected) ? (1) : (0)));
        mRemote.transact(Stub.TRANSACTION_onUsbMassStorageConnectionChanged, _data, _reply, android.os.IBinder.FLAG_ONEWAY);
        _reply.readException();
    } finally {
        _reply.recycle();
        _data.recycle();
    }
}
------------------------
Find a silently evolved API code:android.widget.VideoView.release:COMMENT
Method Modifier: private     
Comment:/*
     * release the media player in any state
     */

Body of Frist Method:
{
    if (mMediaPlayer != null) {
        mMediaPlayer.reset();
        mMediaPlayer.release();
        mMediaPlayer = null;
        mPendingSubtitleTracks.clear();
        mCurrentState = STATE_IDLE;
        if (cleartargetstate) {
            mTargetState = STATE_IDLE;
        }
    }
}
Body of Second Method:
{
    if (mMediaPlayer != null) {
        mMediaPlayer.reset();
        mMediaPlayer.release();
        mMediaPlayer = null;
        mPendingSubtitleTracks.clear();
        mCurrentState = STATE_IDLE;
        if (cleartargetstate) {
            mTargetState = STATE_IDLE;
        }
        AudioManager am = (AudioManager) mContext.getSystemService(Context.AUDIO_SERVICE);
        am.abandonAudioFocus(null);
    }
}
------------------------
Find a silently evolved API code:android.media.AudioManager.setRingerModeInternal:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Only useful for volume controllers.
 * @hide
 */

Body of Frist Method:
{
    try {
        getService().setRingerModeInternal(ringerMode, mContext.getOpPackageName());
    } catch (RemoteException e) {
        Log.w(TAG, "Error calling setRingerModeInternal", e);
    }
}
Body of Second Method:
{
    try {
        getService().setRingerModeInternal(ringerMode, getContext().getOpPackageName());
    } catch (RemoteException e) {
        Log.w(TAG, "Error calling setRingerModeInternal", e);
    }
}
------------------------
Find a silently evolved API code:android.transition.Transition.createAnimators:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * This method, essentially a wrapper around all calls to createAnimator for all
 * possible target views, is called with the entire set of start/end
 * values. The implementation in Transition iterates through these lists
 * and calls {@link #createAnimator(ViewGroup, TransitionValues, TransitionValues)}
 * with each set of start/end values on this transition. The
 * TransitionSet subclass overrides this method and delegates it to
 * each of its children in succession.
 *
 * @hide
 */

Body of Frist Method:
{
    if (DBG) {
        Log.d(LOG_TAG, "createAnimators() for " + this);
    }
    ArrayMap<Animator, AnimationInfo> runningAnimators = getRunningAnimators();
    long minStartDelay = Long.MAX_VALUE;
    int minAnimator = mAnimators.size();
    SparseLongArray startDelays = new SparseLongArray();
    int startValuesListCount = startValuesList.size();
    for (int i = 0; i < startValuesListCount; ++i) {
        TransitionValues start = startValuesList.get(i);
        TransitionValues end = endValuesList.get(i);
        if (start != null && !start.targetedTransitions.contains(this)) {
            start = null;
        }
        if (end != null && !end.targetedTransitions.contains(this)) {
            end = null;
        }
        if (start == null && end == null) {
            continue;
        }
        // Only bother trying to animate with values that differ between start/end
        boolean isChanged = start == null || end == null || areValuesChanged(start, end);
        if (isChanged) {
            if (DBG) {
                View view = (end != null) ? end.view : start.view;
                Log.d(LOG_TAG, "  differing start/end values for view " + view);
                if (start == null || end == null) {
                    Log.d(LOG_TAG, "    " + ((start == null) ? "start null, end non-null" : "start non-null, end null"));
                } else {
                    for (String key : start.values.keySet()) {
                        Object startValue = start.values.get(key);
                        Object endValue = end.values.get(key);
                        if (startValue != endValue && !startValue.equals(endValue)) {
                            Log.d(LOG_TAG, "    " + key + ": start(" + startValue + "), end(" + endValue + ")");
                        }
                    }
                }
            }
            // TODO: what to do about targetIds and itemIds?
            Animator animator = createAnimator(sceneRoot, start, end);
            if (animator != null) {
                // Save animation info for future cancellation purposes
                View view = null;
                TransitionValues infoValues = null;
                if (end != null) {
                    view = end.view;
                    String[] properties = getTransitionProperties();
                    if (view != null && properties != null && properties.length > 0) {
                        infoValues = new TransitionValues();
                        infoValues.view = view;
                        TransitionValues newValues = endValues.viewValues.get(view);
                        if (newValues != null) {
                            for (int j = 0; j < properties.length; ++j) {
                                infoValues.values.put(properties[j], newValues.values.get(properties[j]));
                            }
                        }
                        int numExistingAnims = runningAnimators.size();
                        for (int j = 0; j < numExistingAnims; ++j) {
                            Animator anim = runningAnimators.keyAt(j);
                            AnimationInfo info = runningAnimators.get(anim);
                            if (info.values != null && info.view == view && ((info.name == null && getName() == null) || info.name.equals(getName()))) {
                                if (info.values.equals(infoValues)) {
                                    // Favor the old animator
                                    animator = null;
                                    break;
                                }
                            }
                        }
                    }
                } else {
                    view = (start != null) ? start.view : null;
                }
                if (animator != null) {
                    if (mPropagation != null) {
                        long delay = mPropagation.getStartDelay(sceneRoot, this, start, end);
                        startDelays.put(mAnimators.size(), delay);
                        minStartDelay = Math.min(delay, minStartDelay);
                    }
                    AnimationInfo info = new AnimationInfo(view, getName(), this, sceneRoot.getWindowId(), infoValues);
                    runningAnimators.put(animator, info);
                    mAnimators.add(animator);
                }
            }
        }
    }
    if (minStartDelay != 0) {
        for (int i = 0; i < startDelays.size(); i++) {
            int index = startDelays.keyAt(i);
            Animator animator = mAnimators.get(index);
            long delay = startDelays.valueAt(i) - minStartDelay + animator.getStartDelay();
            animator.setStartDelay(delay);
        }
    }
}
Body of Second Method:
{
    if (DBG) {
        Log.d(LOG_TAG, "createAnimators() for " + this);
    }
    ArrayMap<Animator, AnimationInfo> runningAnimators = getRunningAnimators();
    long minStartDelay = Long.MAX_VALUE;
    int minAnimator = mAnimators.size();
    SparseLongArray startDelays = new SparseLongArray();
    int startValuesListCount = startValuesList.size();
    for (int i = 0; i < startValuesListCount; ++i) {
        TransitionValues start = startValuesList.get(i);
        TransitionValues end = endValuesList.get(i);
        if (start != null && !start.targetedTransitions.contains(this)) {
            start = null;
        }
        if (end != null && !end.targetedTransitions.contains(this)) {
            end = null;
        }
        if (start == null && end == null) {
            continue;
        }
        // Only bother trying to animate with values that differ between start/end
        boolean isChanged = start == null || end == null || isTransitionRequired(start, end);
        if (isChanged) {
            if (DBG) {
                View view = (end != null) ? end.view : start.view;
                Log.d(LOG_TAG, "  differing start/end values for view " + view);
                if (start == null || end == null) {
                    Log.d(LOG_TAG, "    " + ((start == null) ? "start null, end non-null" : "start non-null, end null"));
                } else {
                    for (String key : start.values.keySet()) {
                        Object startValue = start.values.get(key);
                        Object endValue = end.values.get(key);
                        if (startValue != endValue && !startValue.equals(endValue)) {
                            Log.d(LOG_TAG, "    " + key + ": start(" + startValue + "), end(" + endValue + ")");
                        }
                    }
                }
            }
            // TODO: what to do about targetIds and itemIds?
            Animator animator = createAnimator(sceneRoot, start, end);
            if (animator != null) {
                // Save animation info for future cancellation purposes
                View view = null;
                TransitionValues infoValues = null;
                if (end != null) {
                    view = end.view;
                    String[] properties = getTransitionProperties();
                    if (view != null && properties != null && properties.length > 0) {
                        infoValues = new TransitionValues();
                        infoValues.view = view;
                        TransitionValues newValues = endValues.viewValues.get(view);
                        if (newValues != null) {
                            for (int j = 0; j < properties.length; ++j) {
                                infoValues.values.put(properties[j], newValues.values.get(properties[j]));
                            }
                        }
                        int numExistingAnims = runningAnimators.size();
                        for (int j = 0; j < numExistingAnims; ++j) {
                            Animator anim = runningAnimators.keyAt(j);
                            AnimationInfo info = runningAnimators.get(anim);
                            if (info.values != null && info.view == view && ((info.name == null && getName() == null) || info.name.equals(getName()))) {
                                if (info.values.equals(infoValues)) {
                                    // Favor the old animator
                                    animator = null;
                                    break;
                                }
                            }
                        }
                    }
                } else {
                    view = (start != null) ? start.view : null;
                }
                if (animator != null) {
                    if (mPropagation != null) {
                        long delay = mPropagation.getStartDelay(sceneRoot, this, start, end);
                        startDelays.put(mAnimators.size(), delay);
                        minStartDelay = Math.min(delay, minStartDelay);
                    }
                    AnimationInfo info = new AnimationInfo(view, getName(), this, sceneRoot.getWindowId(), infoValues);
                    runningAnimators.put(animator, info);
                    mAnimators.add(animator);
                }
            }
        }
    }
    if (minStartDelay != 0) {
        for (int i = 0; i < startDelays.size(); i++) {
            int index = startDelays.keyAt(i);
            Animator animator = mAnimators.get(index);
            long delay = startDelays.valueAt(i) - minStartDelay + animator.getStartDelay();
            animator.setStartDelay(delay);
        }
    }
}
------------------------
Find a silently evolved API code:android.content.pm.PackageManager.installStatusToPublicStatus:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * {@hide}
 */

Body of Frist Method:
{
    switch(status) {
        case INSTALL_SUCCEEDED:
            return PackageInstaller.STATUS_SUCCESS;
        case INSTALL_FAILED_ALREADY_EXISTS:
            return PackageInstaller.STATUS_FAILURE_CONFLICT;
        case INSTALL_FAILED_INVALID_APK:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_FAILED_INVALID_URI:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_FAILED_INSUFFICIENT_STORAGE:
            return PackageInstaller.STATUS_FAILURE_STORAGE;
        case INSTALL_FAILED_DUPLICATE_PACKAGE:
            return PackageInstaller.STATUS_FAILURE_CONFLICT;
        case INSTALL_FAILED_NO_SHARED_USER:
            return PackageInstaller.STATUS_FAILURE_CONFLICT;
        case INSTALL_FAILED_UPDATE_INCOMPATIBLE:
            return PackageInstaller.STATUS_FAILURE_CONFLICT;
        case INSTALL_FAILED_SHARED_USER_INCOMPATIBLE:
            return PackageInstaller.STATUS_FAILURE_CONFLICT;
        case INSTALL_FAILED_MISSING_SHARED_LIBRARY:
            return PackageInstaller.STATUS_FAILURE_INCOMPATIBLE;
        case INSTALL_FAILED_REPLACE_COULDNT_DELETE:
            return PackageInstaller.STATUS_FAILURE_CONFLICT;
        case INSTALL_FAILED_DEXOPT:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_FAILED_OLDER_SDK:
            return PackageInstaller.STATUS_FAILURE_INCOMPATIBLE;
        case INSTALL_FAILED_CONFLICTING_PROVIDER:
            return PackageInstaller.STATUS_FAILURE_CONFLICT;
        case INSTALL_FAILED_NEWER_SDK:
            return PackageInstaller.STATUS_FAILURE_INCOMPATIBLE;
        case INSTALL_FAILED_TEST_ONLY:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_FAILED_CPU_ABI_INCOMPATIBLE:
            return PackageInstaller.STATUS_FAILURE_INCOMPATIBLE;
        case INSTALL_FAILED_MISSING_FEATURE:
            return PackageInstaller.STATUS_FAILURE_INCOMPATIBLE;
        case INSTALL_FAILED_CONTAINER_ERROR:
            return PackageInstaller.STATUS_FAILURE_STORAGE;
        case INSTALL_FAILED_INVALID_INSTALL_LOCATION:
            return PackageInstaller.STATUS_FAILURE_STORAGE;
        case INSTALL_FAILED_MEDIA_UNAVAILABLE:
            return PackageInstaller.STATUS_FAILURE_STORAGE;
        case INSTALL_FAILED_VERIFICATION_TIMEOUT:
            return PackageInstaller.STATUS_FAILURE_ABORTED;
        case INSTALL_FAILED_VERIFICATION_FAILURE:
            return PackageInstaller.STATUS_FAILURE_ABORTED;
        case INSTALL_FAILED_PACKAGE_CHANGED:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_FAILED_UID_CHANGED:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_FAILED_VERSION_DOWNGRADE:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_PARSE_FAILED_NOT_APK:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_PARSE_FAILED_BAD_MANIFEST:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_PARSE_FAILED_UNEXPECTED_EXCEPTION:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_PARSE_FAILED_NO_CERTIFICATES:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_PARSE_FAILED_CERTIFICATE_ENCODING:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_PARSE_FAILED_BAD_SHARED_USER_ID:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_PARSE_FAILED_MANIFEST_MALFORMED:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_PARSE_FAILED_MANIFEST_EMPTY:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_FAILED_INTERNAL_ERROR:
            return PackageInstaller.STATUS_FAILURE;
        case INSTALL_FAILED_USER_RESTRICTED:
            return PackageInstaller.STATUS_FAILURE_INCOMPATIBLE;
        case INSTALL_FAILED_DUPLICATE_PERMISSION:
            return PackageInstaller.STATUS_FAILURE_CONFLICT;
        case INSTALL_FAILED_NO_MATCHING_ABIS:
            return PackageInstaller.STATUS_FAILURE_INCOMPATIBLE;
        case INSTALL_FAILED_ABORTED:
            return PackageInstaller.STATUS_FAILURE_ABORTED;
        default:
            return PackageInstaller.STATUS_FAILURE;
    }
}
Body of Second Method:
{
    switch(status) {
        case INSTALL_SUCCEEDED:
            return PackageInstaller.STATUS_SUCCESS;
        case INSTALL_FAILED_ALREADY_EXISTS:
            return PackageInstaller.STATUS_FAILURE_CONFLICT;
        case INSTALL_FAILED_INVALID_APK:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_FAILED_INVALID_URI:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_FAILED_INSUFFICIENT_STORAGE:
            return PackageInstaller.STATUS_FAILURE_STORAGE;
        case INSTALL_FAILED_DUPLICATE_PACKAGE:
            return PackageInstaller.STATUS_FAILURE_CONFLICT;
        case INSTALL_FAILED_NO_SHARED_USER:
            return PackageInstaller.STATUS_FAILURE_CONFLICT;
        case INSTALL_FAILED_UPDATE_INCOMPATIBLE:
            return PackageInstaller.STATUS_FAILURE_CONFLICT;
        case INSTALL_FAILED_SHARED_USER_INCOMPATIBLE:
            return PackageInstaller.STATUS_FAILURE_CONFLICT;
        case INSTALL_FAILED_MISSING_SHARED_LIBRARY:
            return PackageInstaller.STATUS_FAILURE_INCOMPATIBLE;
        case INSTALL_FAILED_REPLACE_COULDNT_DELETE:
            return PackageInstaller.STATUS_FAILURE_CONFLICT;
        case INSTALL_FAILED_DEXOPT:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_FAILED_OLDER_SDK:
            return PackageInstaller.STATUS_FAILURE_INCOMPATIBLE;
        case INSTALL_FAILED_CONFLICTING_PROVIDER:
            return PackageInstaller.STATUS_FAILURE_CONFLICT;
        case INSTALL_FAILED_NEWER_SDK:
            return PackageInstaller.STATUS_FAILURE_INCOMPATIBLE;
        case INSTALL_FAILED_TEST_ONLY:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_FAILED_CPU_ABI_INCOMPATIBLE:
            return PackageInstaller.STATUS_FAILURE_INCOMPATIBLE;
        case INSTALL_FAILED_MISSING_FEATURE:
            return PackageInstaller.STATUS_FAILURE_INCOMPATIBLE;
        case INSTALL_FAILED_CONTAINER_ERROR:
            return PackageInstaller.STATUS_FAILURE_STORAGE;
        case INSTALL_FAILED_INVALID_INSTALL_LOCATION:
            return PackageInstaller.STATUS_FAILURE_STORAGE;
        case INSTALL_FAILED_MEDIA_UNAVAILABLE:
            return PackageInstaller.STATUS_FAILURE_STORAGE;
        case INSTALL_FAILED_VERIFICATION_TIMEOUT:
            return PackageInstaller.STATUS_FAILURE_ABORTED;
        case INSTALL_FAILED_VERIFICATION_FAILURE:
            return PackageInstaller.STATUS_FAILURE_ABORTED;
        case INSTALL_FAILED_PACKAGE_CHANGED:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_FAILED_UID_CHANGED:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_FAILED_VERSION_DOWNGRADE:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_FAILED_PERMISSION_MODEL_DOWNGRADE:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_PARSE_FAILED_NOT_APK:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_PARSE_FAILED_BAD_MANIFEST:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_PARSE_FAILED_UNEXPECTED_EXCEPTION:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_PARSE_FAILED_NO_CERTIFICATES:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_PARSE_FAILED_CERTIFICATE_ENCODING:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_PARSE_FAILED_BAD_SHARED_USER_ID:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_PARSE_FAILED_MANIFEST_MALFORMED:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_PARSE_FAILED_MANIFEST_EMPTY:
            return PackageInstaller.STATUS_FAILURE_INVALID;
        case INSTALL_FAILED_INTERNAL_ERROR:
            return PackageInstaller.STATUS_FAILURE;
        case INSTALL_FAILED_USER_RESTRICTED:
            return PackageInstaller.STATUS_FAILURE_INCOMPATIBLE;
        case INSTALL_FAILED_DUPLICATE_PERMISSION:
            return PackageInstaller.STATUS_FAILURE_CONFLICT;
        case INSTALL_FAILED_NO_MATCHING_ABIS:
            return PackageInstaller.STATUS_FAILURE_INCOMPATIBLE;
        case INSTALL_FAILED_ABORTED:
            return PackageInstaller.STATUS_FAILURE_ABORTED;
        default:
            return PackageInstaller.STATUS_FAILURE;
    }
}
------------------------
Find a silently evolved API code:android.content.res.Configuration.resourceQualifierString:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Returns a string representation of the configuration that can be parsed
 * by build tools (like AAPT).
 *
 * @hide
 */

Body of Frist Method:
{
    ArrayList<String> parts = new ArrayList<String>();
    if (config.mcc != 0) {
        parts.add("mcc" + config.mcc);
        if (config.mnc != 0) {
            parts.add("mnc" + config.mnc);
        }
    }
    if (config.locale != null && !config.locale.getLanguage().isEmpty()) {
        parts.add(localeToResourceQualifier(config.locale));
    }
    switch(config.screenLayout & Configuration.SCREENLAYOUT_LAYOUTDIR_MASK) {
        case Configuration.SCREENLAYOUT_LAYOUTDIR_LTR:
            parts.add("ldltr");
            break;
        case Configuration.SCREENLAYOUT_LAYOUTDIR_RTL:
            parts.add("ldrtl");
            break;
        default:
            break;
    }
    if (config.smallestScreenWidthDp != 0) {
        parts.add("sw" + config.smallestScreenWidthDp + "dp");
    }
    if (config.screenWidthDp != 0) {
        parts.add("w" + config.screenWidthDp + "dp");
    }
    if (config.screenHeightDp != 0) {
        parts.add("h" + config.screenHeightDp + "dp");
    }
    switch(config.screenLayout & Configuration.SCREENLAYOUT_SIZE_MASK) {
        case Configuration.SCREENLAYOUT_SIZE_SMALL:
            parts.add("small");
            break;
        case Configuration.SCREENLAYOUT_SIZE_NORMAL:
            parts.add("normal");
            break;
        case Configuration.SCREENLAYOUT_SIZE_LARGE:
            parts.add("large");
            break;
        case Configuration.SCREENLAYOUT_SIZE_XLARGE:
            parts.add("xlarge");
            break;
        default:
            break;
    }
    switch(config.screenLayout & Configuration.SCREENLAYOUT_LONG_MASK) {
        case Configuration.SCREENLAYOUT_LONG_YES:
            parts.add("long");
            break;
        case Configuration.SCREENLAYOUT_LONG_NO:
            parts.add("notlong");
            break;
        default:
            break;
    }
    switch(config.orientation) {
        case Configuration.ORIENTATION_LANDSCAPE:
            parts.add("land");
            break;
        case Configuration.ORIENTATION_PORTRAIT:
            parts.add("port");
            break;
        default:
            break;
    }
    switch(config.uiMode & Configuration.UI_MODE_TYPE_MASK) {
        case Configuration.UI_MODE_TYPE_APPLIANCE:
            parts.add("appliance");
            break;
        case Configuration.UI_MODE_TYPE_DESK:
            parts.add("desk");
            break;
        case Configuration.UI_MODE_TYPE_TELEVISION:
            parts.add("television");
            break;
        case Configuration.UI_MODE_TYPE_CAR:
            parts.add("car");
            break;
        case Configuration.UI_MODE_TYPE_WATCH:
            parts.add("watch");
            break;
        default:
            break;
    }
    switch(config.uiMode & Configuration.UI_MODE_NIGHT_MASK) {
        case Configuration.UI_MODE_NIGHT_YES:
            parts.add("night");
            break;
        case Configuration.UI_MODE_NIGHT_NO:
            parts.add("notnight");
            break;
        default:
            break;
    }
    switch(config.densityDpi) {
        case DENSITY_DPI_UNDEFINED:
            break;
        case 120:
            parts.add("ldpi");
            break;
        case 160:
            parts.add("mdpi");
            break;
        case 213:
            parts.add("tvdpi");
            break;
        case 240:
            parts.add("hdpi");
            break;
        case 320:
            parts.add("xhdpi");
            break;
        case 480:
            parts.add("xxhdpi");
            break;
        case 640:
            parts.add("xxxhdpi");
            break;
        case DENSITY_DPI_ANY:
            parts.add("anydpi");
            break;
        case DENSITY_DPI_NONE:
            parts.add("nodpi");
        default:
            parts.add(config.densityDpi + "dpi");
            break;
    }
    switch(config.touchscreen) {
        case Configuration.TOUCHSCREEN_NOTOUCH:
            parts.add("notouch");
            break;
        case Configuration.TOUCHSCREEN_FINGER:
            parts.add("finger");
            break;
        default:
            break;
    }
    switch(config.keyboardHidden) {
        case Configuration.KEYBOARDHIDDEN_NO:
            parts.add("keysexposed");
            break;
        case Configuration.KEYBOARDHIDDEN_YES:
            parts.add("keyshidden");
            break;
        case Configuration.KEYBOARDHIDDEN_SOFT:
            parts.add("keyssoft");
            break;
        default:
            break;
    }
    switch(config.keyboard) {
        case Configuration.KEYBOARD_NOKEYS:
            parts.add("nokeys");
            break;
        case Configuration.KEYBOARD_QWERTY:
            parts.add("qwerty");
            break;
        case Configuration.KEYBOARD_12KEY:
            parts.add("12key");
            break;
        default:
            break;
    }
    switch(config.navigationHidden) {
        case Configuration.NAVIGATIONHIDDEN_NO:
            parts.add("navexposed");
            break;
        case Configuration.NAVIGATIONHIDDEN_YES:
            parts.add("navhidden");
            break;
        default:
            break;
    }
    switch(config.navigation) {
        case Configuration.NAVIGATION_NONAV:
            parts.add("nonav");
            break;
        case Configuration.NAVIGATION_DPAD:
            parts.add("dpad");
            break;
        case Configuration.NAVIGATION_TRACKBALL:
            parts.add("trackball");
            break;
        case Configuration.NAVIGATION_WHEEL:
            parts.add("wheel");
            break;
        default:
            break;
    }
    parts.add("v" + Build.VERSION.RESOURCES_SDK_INT);
    return TextUtils.join("-", parts);
}
Body of Second Method:
{
    ArrayList<String> parts = new ArrayList<String>();
    if (config.mcc != 0) {
        parts.add("mcc" + config.mcc);
        if (config.mnc != 0) {
            parts.add("mnc" + config.mnc);
        }
    }
    if (config.locale != null && !config.locale.getLanguage().isEmpty()) {
        parts.add(localeToResourceQualifier(config.locale));
    }
    switch(config.screenLayout & Configuration.SCREENLAYOUT_LAYOUTDIR_MASK) {
        case Configuration.SCREENLAYOUT_LAYOUTDIR_LTR:
            parts.add("ldltr");
            break;
        case Configuration.SCREENLAYOUT_LAYOUTDIR_RTL:
            parts.add("ldrtl");
            break;
        default:
            break;
    }
    if (config.smallestScreenWidthDp != 0) {
        parts.add("sw" + config.smallestScreenWidthDp + "dp");
    }
    if (config.screenWidthDp != 0) {
        parts.add("w" + config.screenWidthDp + "dp");
    }
    if (config.screenHeightDp != 0) {
        parts.add("h" + config.screenHeightDp + "dp");
    }
    switch(config.screenLayout & Configuration.SCREENLAYOUT_SIZE_MASK) {
        case Configuration.SCREENLAYOUT_SIZE_SMALL:
            parts.add("small");
            break;
        case Configuration.SCREENLAYOUT_SIZE_NORMAL:
            parts.add("normal");
            break;
        case Configuration.SCREENLAYOUT_SIZE_LARGE:
            parts.add("large");
            break;
        case Configuration.SCREENLAYOUT_SIZE_XLARGE:
            parts.add("xlarge");
            break;
        default:
            break;
    }
    switch(config.screenLayout & Configuration.SCREENLAYOUT_LONG_MASK) {
        case Configuration.SCREENLAYOUT_LONG_YES:
            parts.add("long");
            break;
        case Configuration.SCREENLAYOUT_LONG_NO:
            parts.add("notlong");
            break;
        default:
            break;
    }
    switch(config.screenLayout & Configuration.SCREENLAYOUT_ROUND_MASK) {
        case Configuration.SCREENLAYOUT_ROUND_YES:
            parts.add("round");
            break;
        case Configuration.SCREENLAYOUT_ROUND_NO:
            parts.add("notround");
            break;
        default:
            break;
    }
    switch(config.orientation) {
        case Configuration.ORIENTATION_LANDSCAPE:
            parts.add("land");
            break;
        case Configuration.ORIENTATION_PORTRAIT:
            parts.add("port");
            break;
        default:
            break;
    }
    switch(config.uiMode & Configuration.UI_MODE_TYPE_MASK) {
        case Configuration.UI_MODE_TYPE_APPLIANCE:
            parts.add("appliance");
            break;
        case Configuration.UI_MODE_TYPE_DESK:
            parts.add("desk");
            break;
        case Configuration.UI_MODE_TYPE_TELEVISION:
            parts.add("television");
            break;
        case Configuration.UI_MODE_TYPE_CAR:
            parts.add("car");
            break;
        case Configuration.UI_MODE_TYPE_WATCH:
            parts.add("watch");
            break;
        default:
            break;
    }
    switch(config.uiMode & Configuration.UI_MODE_NIGHT_MASK) {
        case Configuration.UI_MODE_NIGHT_YES:
            parts.add("night");
            break;
        case Configuration.UI_MODE_NIGHT_NO:
            parts.add("notnight");
            break;
        default:
            break;
    }
    switch(config.densityDpi) {
        case DENSITY_DPI_UNDEFINED:
            break;
        case 120:
            parts.add("ldpi");
            break;
        case 160:
            parts.add("mdpi");
            break;
        case 213:
            parts.add("tvdpi");
            break;
        case 240:
            parts.add("hdpi");
            break;
        case 320:
            parts.add("xhdpi");
            break;
        case 480:
            parts.add("xxhdpi");
            break;
        case 640:
            parts.add("xxxhdpi");
            break;
        case DENSITY_DPI_ANY:
            parts.add("anydpi");
            break;
        case DENSITY_DPI_NONE:
            parts.add("nodpi");
        default:
            parts.add(config.densityDpi + "dpi");
            break;
    }
    switch(config.touchscreen) {
        case Configuration.TOUCHSCREEN_NOTOUCH:
            parts.add("notouch");
            break;
        case Configuration.TOUCHSCREEN_FINGER:
            parts.add("finger");
            break;
        default:
            break;
    }
    switch(config.keyboardHidden) {
        case Configuration.KEYBOARDHIDDEN_NO:
            parts.add("keysexposed");
            break;
        case Configuration.KEYBOARDHIDDEN_YES:
            parts.add("keyshidden");
            break;
        case Configuration.KEYBOARDHIDDEN_SOFT:
            parts.add("keyssoft");
            break;
        default:
            break;
    }
    switch(config.keyboard) {
        case Configuration.KEYBOARD_NOKEYS:
            parts.add("nokeys");
            break;
        case Configuration.KEYBOARD_QWERTY:
            parts.add("qwerty");
            break;
        case Configuration.KEYBOARD_12KEY:
            parts.add("12key");
            break;
        default:
            break;
    }
    switch(config.navigationHidden) {
        case Configuration.NAVIGATIONHIDDEN_NO:
            parts.add("navexposed");
            break;
        case Configuration.NAVIGATIONHIDDEN_YES:
            parts.add("navhidden");
            break;
        default:
            break;
    }
    switch(config.navigation) {
        case Configuration.NAVIGATION_NONAV:
            parts.add("nonav");
            break;
        case Configuration.NAVIGATION_DPAD:
            parts.add("dpad");
            break;
        case Configuration.NAVIGATION_TRACKBALL:
            parts.add("trackball");
            break;
        case Configuration.NAVIGATION_WHEEL:
            parts.add("wheel");
            break;
        default:
            break;
    }
    parts.add("v" + Build.VERSION.RESOURCES_SDK_INT);
    return TextUtils.join("-", parts);
}
------------------------
Find a silently evolved API code:android.hardware.camera2.params.StreamConfigurationMap.checkArgumentFormatInternal:COMMENT
Method Modifier: default     static      
Comment:/**
 * Ensures that the format is either user-defined or implementation defined.
 *
 * <p>If a format has a different internal representation than the public representation,
 * passing in the public representation here will fail.</p>
 *
 * <p>For example if trying to use {@link ImageFormat#JPEG}:
 * it has a different public representation than the internal representation
 * {@code HAL_PIXEL_FORMAT_BLOB}, this check will fail.</p>
 *
 * <p>Any invalid/undefined formats will raise an exception.</p>
 *
 * @param format image format
 * @return the format
 *
 * @throws IllegalArgumentException if the format was invalid
 */

Body of Frist Method:
{
    switch(format) {
        case HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED:
        case HAL_PIXEL_FORMAT_BLOB:
        case HAL_PIXEL_FORMAT_RAW_OPAQUE:
            return format;
        case ImageFormat.JPEG:
            throw new IllegalArgumentException("ImageFormat.JPEG is an unknown internal format");
        default:
            return checkArgumentFormat(format);
    }
}
Body of Second Method:
{
    switch(format) {
        case HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED:
        case HAL_PIXEL_FORMAT_BLOB:
        case HAL_PIXEL_FORMAT_RAW_OPAQUE:
        case HAL_PIXEL_FORMAT_Y16:
            return format;
        case ImageFormat.JPEG:
            throw new IllegalArgumentException("ImageFormat.JPEG is an unknown internal format");
        default:
            return checkArgumentFormat(format);
    }
}
------------------------
Find a silently evolved API code:javax.obex.ServerSession.handlePutRequest:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Handles a PUT request from a client. This method will provide a
 * <code>ServerOperation</code> object to the request handler. The
 * <code>ServerOperation</code> object will handle the rest of the request.
 * It will also send replies and receive requests until the final reply
 * should be sent. When the final reply should be sent, this method will get
 * the response code to use and send the reply. The
 * <code>ServerOperation</code> object will always reply with a
 * OBEX_HTTP_CONTINUE reply. It will only reply if further information is
 * needed.
 * @param type the type of request received; either 0x02 or 0x82
 * @throws IOException if an error occurred at the transport layer
 */

Body of Frist Method:
{
    ServerOperation op = new ServerOperation(this, mInput, type, mMaxPacketLength, mListener);
    try {
        int response = -1;
        if ((op.finalBitSet) && !op.isValidBody()) {
            response = validateResponseCode(mListener.onDelete(op.requestHeader, op.replyHeader));
        } else {
            response = validateResponseCode(mListener.onPut(op));
        }
        if (response != ResponseCodes.OBEX_HTTP_OK && !op.isAborted) {
            op.sendReply(response);
        } else if (!op.isAborted) {
            // wait for the final bit
            while (!op.finalBitSet) {
                op.sendReply(ResponseCodes.OBEX_HTTP_CONTINUE);
            }
            op.sendReply(response);
        }
    } catch (Exception e) {
        /*To fix bugs in aborted cases,
             *(client abort file transfer prior to the last packet which has the end of body header,
             *internal error should not be sent because server has already replied with
             *OK response in "sendReply")
             */
        if (!op.isAborted) {
            sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR, null);
        }
    }
}
Body of Second Method:
{
    ServerOperation op = new ServerOperation(this, mInput, type, mMaxPacketLength, mListener);
    try {
        int response = -1;
        if ((op.finalBitSet) && !op.isValidBody()) {
            response = validateResponseCode(mListener.onDelete(op.requestHeader, op.replyHeader));
        } else {
            response = validateResponseCode(mListener.onPut(op));
        }
        if (response != ResponseCodes.OBEX_HTTP_OK && !op.isAborted) {
            op.sendReply(response);
        } else if (!op.isAborted) {
            // wait for the final bit
            while (!op.finalBitSet) {
                op.sendReply(ResponseCodes.OBEX_HTTP_CONTINUE);
            }
            op.sendReply(response);
        }
    } catch (Exception e) {
        /*To fix bugs in aborted cases,
             *(client abort file transfer prior to the last packet which has the end of body header,
             *internal error should not be sent because server has already replied with
             *OK response in "sendReply")
             */
        if (V)
            Log.d(TAG, "Exception occured - sending OBEX_HTTP_INTERNAL_ERROR reply", e);
        if (!op.isAborted) {
            sendResponse(ResponseCodes.OBEX_HTTP_INTERNAL_ERROR, null);
        }
    }
}
------------------------
Find a silently evolved API code:android.widget.Editor.updateSpellCheckSpans:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Create new SpellCheckSpans on the modified region.
 */

Body of Frist Method:
{
    // Remove spans whose adjacent characters are text not punctuation
    mTextView.removeAdjacentSuggestionSpans(start);
    mTextView.removeAdjacentSuggestionSpans(end);
    if (mTextView.isTextEditable() && mTextView.isSuggestionsEnabled() && !(mTextView instanceof ExtractEditText)) {
        if (mSpellChecker == null && createSpellChecker) {
            mSpellChecker = new SpellChecker(mTextView);
        }
        if (mSpellChecker != null) {
            mSpellChecker.spellCheck(start, end);
        }
    }
}
Body of Second Method:
{
    // Remove spans whose adjacent characters are text not punctuation
    mTextView.removeAdjacentSuggestionSpans(start);
    mTextView.removeAdjacentSuggestionSpans(end);
    if (mTextView.isTextEditable() && mTextView.isSuggestionsEnabled() && !(mTextView.isInExtractedMode())) {
        if (mSpellChecker == null && createSpellChecker) {
            mSpellChecker = new SpellChecker(mTextView);
        }
        if (mSpellChecker != null) {
            mSpellChecker.spellCheck(start, end);
        }
    }
}
------------------------
Find a silently evolved API code:android.view.animation.Transformation.compose:COMMENT
Method Modifier: public      
Comment:/**
 * Apply this Transformation to an existing Transformation, e.g. apply
 * a scale effect to something that has already been rotated.
 * @param t
 */

Body of Frist Method:
{
    mAlpha *= t.getAlpha();
    mMatrix.preConcat(t.getMatrix());
    if (t.mHasClipRect) {
        setClipRect(t.getClipRect());
    }
}
Body of Second Method:
{
    mAlpha *= t.getAlpha();
    mMatrix.preConcat(t.getMatrix());
    if (t.mHasClipRect) {
        Rect bounds = t.getClipRect();
        if (mHasClipRect) {
            setClipRect(mClipRect.left + bounds.left, mClipRect.top + bounds.top, mClipRect.right + bounds.right, mClipRect.bottom + bounds.bottom);
        } else {
            setClipRect(bounds);
        }
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothDevice.createInsecureRfcommSocketToServiceRecord:COMMENT
Method Modifier: public      
Comment:/**
 * Create an RFCOMM {@link BluetoothSocket} socket ready to start an insecure
 * outgoing connection to this remote device using SDP lookup of uuid.
 * <p> The communication channel will not have an authenticated link key
 * i.e it will be subject to man-in-the-middle attacks. For Bluetooth 2.1
 * devices, the link key will be encrypted, as encryption is mandatory.
 * For legacy devices (pre Bluetooth 2.1 devices) the link key will
 * be not be encrypted. Use {@link #createRfcommSocketToServiceRecord} if an
 * encrypted and authenticated communication channel is desired.
 * <p>This is designed to be used with {@link
 * BluetoothAdapter#listenUsingInsecureRfcommWithServiceRecord} for peer-peer
 * Bluetooth applications.
 * <p>Use {@link BluetoothSocket#connect} to initiate the outgoing
 * connection. This will also perform an SDP lookup of the given uuid to
 * determine which channel to connect to.
 * <p>The remote device will be authenticated and communication on this
 * socket will be encrypted.
 * <p>Hint: If you are connecting to a Bluetooth serial board then try
 * using the well-known SPP UUID 00001101-0000-1000-8000-00805F9B34FB.
 * However if you are connecting to an Android peer then please generate
 * your own unique UUID.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}
 *
 * @param uuid service record uuid to lookup RFCOMM channel
 * @return a RFCOMM BluetoothServerSocket ready for an outgoing connection
 * @throws IOException on error, for example Bluetooth not available, or
 * insufficient permissions
 */

Body of Frist Method:
{
    return new BluetoothSocket(BluetoothSocket.TYPE_RFCOMM, -1, false, false, this, -1, new ParcelUuid(uuid));
}
Body of Second Method:
{
    if (isBluetoothEnabled() == false) {
        Log.e(TAG, "Bluetooth is not enabled");
        throw new IOException();
    }
    return new BluetoothSocket(BluetoothSocket.TYPE_RFCOMM, -1, false, false, this, -1, new ParcelUuid(uuid));
}
------------------------
Find a silently evolved API code:android.inputmethodservice.InputMethodService.InputMethodImpl.hideSoftInput:COMMENT
Method Modifier: public      
Comment:/**
 * Handle a request by the system to hide the soft input area.
 */

Body of Frist Method:
{
    if (DEBUG)
        Log.v(TAG, "hideSoftInput()");
    boolean wasVis = isInputViewShown();
    mShowInputFlags = 0;
    mShowInputRequested = false;
    mShowInputForced = false;
    doHideWindow();
    if (resultReceiver != null) {
        resultReceiver.send(wasVis != isInputViewShown() ? InputMethodManager.RESULT_HIDDEN : (wasVis ? InputMethodManager.RESULT_UNCHANGED_SHOWN : InputMethodManager.RESULT_UNCHANGED_HIDDEN), null);
    }
}
Body of Second Method:
{
    if (DEBUG)
        Log.v(TAG, "hideSoftInput()");
    boolean wasVis = isInputViewShown();
    mShowInputFlags = 0;
    mShowInputRequested = false;
    mShowInputForced = false;
    doHideWindow();
    clearInsetOfPreviousIme();
    if (resultReceiver != null) {
        resultReceiver.send(wasVis != isInputViewShown() ? InputMethodManager.RESULT_HIDDEN : (wasVis ? InputMethodManager.RESULT_UNCHANGED_SHOWN : InputMethodManager.RESULT_UNCHANGED_HIDDEN), null);
    }
}
------------------------
Find a silently evolved API code:android.speech.tts.TextToSpeechService.onGetVoices:COMMENT
Method Modifier: public      
Comment:/**
 * Queries the service for a set of supported voices.
 *
 * Can be called on multiple threads.
 *
 * The default implementation tries to enumerate all available locales, pass them to
 * {@link #onIsLanguageAvailable(String, String, String)} and create Voice instances (using
 * the locale's BCP-47 language tag as the voice name) for the ones that are supported.
 * Note, that this implementation is suitable only for engines that don't have multiple voices
 * for a single locale. Also, this implementation won't work with Locales not listed in the
 * set returned by the {@link Locale#getAvailableLocales()} method.
 *
 * @return A list of voices supported.
 */

Body of Frist Method:
{
    // Enumerate all locales and check if they are available
    ArrayList<Voice> voices = new ArrayList<Voice>();
    for (Locale locale : Locale.getAvailableLocales()) {
        int expectedStatus = getExpectedLanguageAvailableStatus(locale);
        try {
            int localeStatus = onIsLanguageAvailable(locale.getISO3Language(), locale.getISO3Country(), locale.getVariant());
            if (localeStatus != expectedStatus) {
                continue;
            }
        } catch (MissingResourceException e) {
            // Ignore locale without iso 3 codes
            continue;
        }
        Set<String> features = onGetFeaturesForLanguage(locale.getISO3Language(), locale.getISO3Country(), locale.getVariant());
        voices.add(new Voice(locale.toLanguageTag(), locale, Voice.QUALITY_NORMAL, Voice.LATENCY_NORMAL, false, features));
    }
    return voices;
}
Body of Second Method:
{
    // Enumerate all locales and check if they are available
    ArrayList<Voice> voices = new ArrayList<Voice>();
    for (Locale locale : Locale.getAvailableLocales()) {
        int expectedStatus = getExpectedLanguageAvailableStatus(locale);
        try {
            int localeStatus = onIsLanguageAvailable(locale.getISO3Language(), locale.getISO3Country(), locale.getVariant());
            if (localeStatus != expectedStatus) {
                continue;
            }
        } catch (MissingResourceException e) {
            // Ignore locale without iso 3 codes
            continue;
        }
        Set<String> features = onGetFeaturesForLanguage(locale.getISO3Language(), locale.getISO3Country(), locale.getVariant());
        String voiceName = onGetDefaultVoiceNameFor(locale.getISO3Language(), locale.getISO3Country(), locale.getVariant());
        voices.add(new Voice(voiceName, locale, Voice.QUALITY_NORMAL, Voice.LATENCY_NORMAL, false, features));
    }
    return voices;
}
------------------------
Find a silently evolved API code:android.content.res.BridgeResources.disposeSystem:COMMENT
Method Modifier: public      static      
Comment:/**
 * Disposes the static {@link Resources#mSystem} to make sure we don't leave objects
 * around that would prevent us from unloading the library.
 */

Body of Frist Method:
{
    if (Resources.mSystem instanceof BridgeResources) {
        ((BridgeResources) (Resources.mSystem)).mContext = null;
        ((BridgeResources) (Resources.mSystem)).mProjectCallback = null;
    }
    Resources.mSystem = null;
}
Body of Second Method:
{
    if (Resources.mSystem instanceof BridgeResources) {
        ((BridgeResources) (Resources.mSystem)).mContext = null;
        ((BridgeResources) (Resources.mSystem)).mLayoutlibCallback = null;
    }
    Resources.mSystem = null;
}
------------------------
Find a silently evolved API code:android.view.ViewRootImpl.playSoundEffect:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    checkThread();
    if (mMediaDisabled) {
        return;
    }
    try {
        final AudioManager audioManager = getAudioManager();
        switch(effectId) {
            case SoundEffectConstants.CLICK:
                audioManager.playSoundEffect(AudioManager.FX_KEY_CLICK);
                return;
            case SoundEffectConstants.NAVIGATION_DOWN:
                audioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_DOWN);
                return;
            case SoundEffectConstants.NAVIGATION_LEFT:
                audioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_LEFT);
                return;
            case SoundEffectConstants.NAVIGATION_RIGHT:
                audioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_RIGHT);
                return;
            case SoundEffectConstants.NAVIGATION_UP:
                audioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_UP);
                return;
            default:
                throw new IllegalArgumentException("unknown effect id " + effectId + " not defined in " + SoundEffectConstants.class.getCanonicalName());
        }
    } catch (IllegalStateException e) {
        // Exception thrown by getAudioManager() when mView is null
        Log.e(TAG, "FATAL EXCEPTION when attempting to play sound effect: " + e);
        e.printStackTrace();
    }
}
Body of Second Method:
{
    checkThread();
    try {
        final AudioManager audioManager = getAudioManager();
        switch(effectId) {
            case SoundEffectConstants.CLICK:
                audioManager.playSoundEffect(AudioManager.FX_KEY_CLICK);
                return;
            case SoundEffectConstants.NAVIGATION_DOWN:
                audioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_DOWN);
                return;
            case SoundEffectConstants.NAVIGATION_LEFT:
                audioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_LEFT);
                return;
            case SoundEffectConstants.NAVIGATION_RIGHT:
                audioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_RIGHT);
                return;
            case SoundEffectConstants.NAVIGATION_UP:
                audioManager.playSoundEffect(AudioManager.FX_FOCUS_NAVIGATION_UP);
                return;
            default:
                throw new IllegalArgumentException("unknown effect id " + effectId + " not defined in " + SoundEffectConstants.class.getCanonicalName());
        }
    } catch (IllegalStateException e) {
        // Exception thrown by getAudioManager() when mView is null
        Log.e(TAG, "FATAL EXCEPTION when attempting to play sound effect: " + e);
        e.printStackTrace();
    }
}
------------------------
Find a silently evolved API code:android.widget.TextView.bringTextIntoView:COMMENT
Method Modifier: private     
Comment:/**
 * Returns true if anything changed.
 */

Body of Frist Method:
{
    Layout layout = isShowingHint() ? mHintLayout : mLayout;
    int line = 0;
    if ((mGravity & Gravity.VERTICAL_GRAVITY_MASK) == Gravity.BOTTOM) {
        line = layout.getLineCount() - 1;
    }
    Layout.Alignment a = layout.getParagraphAlignment(line);
    int dir = layout.getParagraphDirection(line);
    int hspace = mRight - mLeft - getCompoundPaddingLeft() - getCompoundPaddingRight();
    int vspace = mBottom - mTop - getExtendedPaddingTop() - getExtendedPaddingBottom();
    int ht = layout.getHeight();
    int scrollx, scrolly;
    // Convert to left, center, or right alignment.
    if (a == Layout.Alignment.ALIGN_NORMAL) {
        a = dir == Layout.DIR_LEFT_TO_RIGHT ? Layout.Alignment.ALIGN_LEFT : Layout.Alignment.ALIGN_RIGHT;
    } else if (a == Layout.Alignment.ALIGN_OPPOSITE) {
        a = dir == Layout.DIR_LEFT_TO_RIGHT ? Layout.Alignment.ALIGN_RIGHT : Layout.Alignment.ALIGN_LEFT;
    }
    if (a == Layout.Alignment.ALIGN_CENTER) {
        /*
             * Keep centered if possible, or, if it is too wide to fit,
             * keep leading edge in view.
             */
        int left = (int) FloatMath.floor(layout.getLineLeft(line));
        int right = (int) FloatMath.ceil(layout.getLineRight(line));
        if (right - left < hspace) {
            scrollx = (right + left) / 2 - hspace / 2;
        } else {
            if (dir < 0) {
                scrollx = right - hspace;
            } else {
                scrollx = left;
            }
        }
    } else if (a == Layout.Alignment.ALIGN_RIGHT) {
        int right = (int) FloatMath.ceil(layout.getLineRight(line));
        scrollx = right - hspace;
    } else {
        // a == Layout.Alignment.ALIGN_LEFT (will also be the default)
        scrollx = (int) FloatMath.floor(layout.getLineLeft(line));
    }
    if (ht < vspace) {
        scrolly = 0;
    } else {
        if ((mGravity & Gravity.VERTICAL_GRAVITY_MASK) == Gravity.BOTTOM) {
            scrolly = ht - vspace;
        } else {
            scrolly = 0;
        }
    }
    if (scrollx != mScrollX || scrolly != mScrollY) {
        scrollTo(scrollx, scrolly);
        return true;
    } else {
        return false;
    }
}
Body of Second Method:
{
    Layout layout = isShowingHint() ? mHintLayout : mLayout;
    int line = 0;
    if ((mGravity & Gravity.VERTICAL_GRAVITY_MASK) == Gravity.BOTTOM) {
        line = layout.getLineCount() - 1;
    }
    Layout.Alignment a = layout.getParagraphAlignment(line);
    int dir = layout.getParagraphDirection(line);
    int hspace = mRight - mLeft - getCompoundPaddingLeft() - getCompoundPaddingRight();
    int vspace = mBottom - mTop - getExtendedPaddingTop() - getExtendedPaddingBottom();
    int ht = layout.getHeight();
    int scrollx, scrolly;
    // Convert to left, center, or right alignment.
    if (a == Layout.Alignment.ALIGN_NORMAL) {
        a = dir == Layout.DIR_LEFT_TO_RIGHT ? Layout.Alignment.ALIGN_LEFT : Layout.Alignment.ALIGN_RIGHT;
    } else if (a == Layout.Alignment.ALIGN_OPPOSITE) {
        a = dir == Layout.DIR_LEFT_TO_RIGHT ? Layout.Alignment.ALIGN_RIGHT : Layout.Alignment.ALIGN_LEFT;
    }
    if (a == Layout.Alignment.ALIGN_CENTER) {
        /*
             * Keep centered if possible, or, if it is too wide to fit,
             * keep leading edge in view.
             */
        int left = (int) Math.floor(layout.getLineLeft(line));
        int right = (int) Math.ceil(layout.getLineRight(line));
        if (right - left < hspace) {
            scrollx = (right + left) / 2 - hspace / 2;
        } else {
            if (dir < 0) {
                scrollx = right - hspace;
            } else {
                scrollx = left;
            }
        }
    } else if (a == Layout.Alignment.ALIGN_RIGHT) {
        int right = (int) Math.ceil(layout.getLineRight(line));
        scrollx = right - hspace;
    } else {
        // a == Layout.Alignment.ALIGN_LEFT (will also be the default)
        scrollx = (int) Math.floor(layout.getLineLeft(line));
    }
    if (ht < vspace) {
        scrolly = 0;
    } else {
        if ((mGravity & Gravity.VERTICAL_GRAVITY_MASK) == Gravity.BOTTOM) {
            scrolly = ht - vspace;
        } else {
            scrolly = 0;
        }
    }
    if (scrollx != mScrollX || scrolly != mScrollY) {
        scrollTo(scrollx, scrolly);
        return true;
    } else {
        return false;
    }
}
------------------------
Find a silently evolved API code:android.print.PrintAttributes.Builder.setColorMode:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the color mode.
 *
 * @param colorMode A valid color mode or zero.
 * @return This builder.
 *
 * @see PrintAttributes#COLOR_MODE_MONOCHROME
 * @see PrintAttributes#COLOR_MODE_COLOR
 */

Body of Frist Method:
{
    if (Integer.bitCount(colorMode) > 1) {
        throw new IllegalArgumentException("can specify at most one colorMode bit.");
    }
    mAttributes.setColorMode(colorMode);
    return this;
}
Body of Second Method:
{
    mAttributes.setColorMode(colorMode);
    return this;
}
------------------------
Find a silently evolved API code:android.graphics.drawable.RippleDrawable.onHotspotBoundsChanged:COMMENT
Method Modifier: private     
Comment:/**
 * Notifies all the animating ripples that the hotspot bounds have changed.
 */

Body of Frist Method:
{
    final int count = mExitingRipplesCount;
    final Ripple[] ripples = mExitingRipples;
    for (int i = 0; i < count; i++) {
        ripples[i].onHotspotBoundsChanged();
    }
    if (mRipple != null) {
        mRipple.onHotspotBoundsChanged();
    }
    if (mBackground != null) {
        mBackground.onHotspotBoundsChanged();
    }
}
Body of Second Method:
{
    final int count = mExitingRipplesCount;
    final RippleForeground[] ripples = mExitingRipples;
    for (int i = 0; i < count; i++) {
        ripples[i].onHotspotBoundsChanged();
    }
    if (mRipple != null) {
        mRipple.onHotspotBoundsChanged();
    }
    if (mBackground != null) {
        mBackground.onHotspotBoundsChanged();
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.le.ScanSettings.Builder.setScanMode:COMMENT
Method Modifier: public      
Comment:/**
 * Set scan mode for Bluetooth LE scan.
 *
 * @param scanMode The scan mode can be one of {@link ScanSettings#SCAN_MODE_LOW_POWER},
 * {@link ScanSettings#SCAN_MODE_BALANCED} or
 * {@link ScanSettings#SCAN_MODE_LOW_LATENCY}.
 * @throws IllegalArgumentException If the {@code scanMode} is invalid.
 */

Body of Frist Method:
{
    if (scanMode < SCAN_MODE_LOW_POWER || scanMode > SCAN_MODE_LOW_LATENCY) {
        throw new IllegalArgumentException("invalid scan mode " + scanMode);
    }
    mScanMode = scanMode;
    return this;
}
Body of Second Method:
{
    if (scanMode < SCAN_MODE_OPPORTUNISTIC || scanMode > SCAN_MODE_LOW_LATENCY) {
        throw new IllegalArgumentException("invalid scan mode " + scanMode);
    }
    mScanMode = scanMode;
    return this;
}
------------------------
Find a silently evolved API code:android.graphics.Canvas.drawOval:COMMENT
Method Modifier: public      
Comment:/**
 * Draw the specified oval using the specified paint. The oval will be
 * filled or framed based on the Style in the paint.
 */

Body of Frist Method:
{
    native_drawOval(mNativeCanvasWrapper, left, top, right, bottom, paint.mNativePaint);
}
Body of Second Method:
{
    native_drawOval(mNativeCanvasWrapper, left, top, right, bottom, paint.getNativeInstance());
}
------------------------
Find a silently evolved API code:android.accounts.AccountManager.getAccountsByTypeAsUser:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide Same as {@link #getAccountsByType(String)} but for a specific user.
 */

Body of Frist Method:
{
    try {
        return mService.getAccountsAsUser(type, userHandle.getIdentifier());
    } catch (RemoteException e) {
        // won't ever happen
        throw new RuntimeException(e);
    }
}
Body of Second Method:
{
    try {
        return mService.getAccountsAsUser(type, userHandle.getIdentifier(), mContext.getOpPackageName());
    } catch (RemoteException e) {
        // won't ever happen
        throw new RuntimeException(e);
    }
}
------------------------
Find a silently evolved API code:android.graphics.drawable.BitmapDrawable.updateStateFromTypedArray:COMMENT
Method Modifier: private     
Comment:/**
 * Updates the constant state from the values in the typed array.
 */

Body of Frist Method:
{
    final Resources r = a.getResources();
    final BitmapState state = mBitmapState;
    // Account for any configuration changes.
    state.mChangingConfigurations |= a.getChangingConfigurations();
    // Extract the theme attributes, if any.
    state.mThemeAttrs = a.extractThemeAttrs();
    final int srcResId = a.getResourceId(R.styleable.BitmapDrawable_src, 0);
    if (srcResId != 0) {
        final Bitmap bitmap = BitmapFactory.decodeResource(r, srcResId);
        if (bitmap == null) {
            throw new XmlPullParserException(a.getPositionDescription() + ": <bitmap> requires a valid src attribute");
        }
        state.mBitmap = bitmap;
    }
    state.mTargetDensity = r.getDisplayMetrics().densityDpi;
    final boolean defMipMap = state.mBitmap != null ? state.mBitmap.hasMipMap() : false;
    setMipMap(a.getBoolean(R.styleable.BitmapDrawable_mipMap, defMipMap));
    state.mAutoMirrored = a.getBoolean(R.styleable.BitmapDrawable_autoMirrored, state.mAutoMirrored);
    state.mBaseAlpha = a.getFloat(R.styleable.BitmapDrawable_alpha, state.mBaseAlpha);
    final int tintMode = a.getInt(R.styleable.BitmapDrawable_tintMode, -1);
    if (tintMode != -1) {
        state.mTintMode = Drawable.parseTintMode(tintMode, Mode.SRC_IN);
    }
    final ColorStateList tint = a.getColorStateList(R.styleable.BitmapDrawable_tint);
    if (tint != null) {
        state.mTint = tint;
    }
    final Paint paint = mBitmapState.mPaint;
    paint.setAntiAlias(a.getBoolean(R.styleable.BitmapDrawable_antialias, paint.isAntiAlias()));
    paint.setFilterBitmap(a.getBoolean(R.styleable.BitmapDrawable_filter, paint.isFilterBitmap()));
    paint.setDither(a.getBoolean(R.styleable.BitmapDrawable_dither, paint.isDither()));
    setGravity(a.getInt(R.styleable.BitmapDrawable_gravity, state.mGravity));
    final int tileMode = a.getInt(R.styleable.BitmapDrawable_tileMode, TILE_MODE_UNDEFINED);
    if (tileMode != TILE_MODE_UNDEFINED) {
        final Shader.TileMode mode = parseTileMode(tileMode);
        setTileModeXY(mode, mode);
    }
    final int tileModeX = a.getInt(R.styleable.BitmapDrawable_tileModeX, TILE_MODE_UNDEFINED);
    if (tileModeX != TILE_MODE_UNDEFINED) {
        setTileModeX(parseTileMode(tileModeX));
    }
    final int tileModeY = a.getInt(R.styleable.BitmapDrawable_tileModeY, TILE_MODE_UNDEFINED);
    if (tileModeY != TILE_MODE_UNDEFINED) {
        setTileModeY(parseTileMode(tileModeY));
    }
    // Update local properties.
    initializeWithState(state, r);
}
Body of Second Method:
{
    final Resources r = a.getResources();
    final BitmapState state = mBitmapState;
    // Account for any configuration changes.
    state.mChangingConfigurations |= a.getChangingConfigurations();
    // Extract the theme attributes, if any.
    state.mThemeAttrs = a.extractThemeAttrs();
    final int srcResId = a.getResourceId(R.styleable.BitmapDrawable_src, 0);
    if (srcResId != 0) {
        final Bitmap bitmap = BitmapFactory.decodeResource(r, srcResId);
        if (bitmap == null) {
            throw new XmlPullParserException(a.getPositionDescription() + ": <bitmap> requires a valid 'src' attribute");
        }
        state.mBitmap = bitmap;
    }
    state.mTargetDensity = r.getDisplayMetrics().densityDpi;
    final boolean defMipMap = state.mBitmap != null ? state.mBitmap.hasMipMap() : false;
    setMipMap(a.getBoolean(R.styleable.BitmapDrawable_mipMap, defMipMap));
    state.mAutoMirrored = a.getBoolean(R.styleable.BitmapDrawable_autoMirrored, state.mAutoMirrored);
    state.mBaseAlpha = a.getFloat(R.styleable.BitmapDrawable_alpha, state.mBaseAlpha);
    final int tintMode = a.getInt(R.styleable.BitmapDrawable_tintMode, -1);
    if (tintMode != -1) {
        state.mTintMode = Drawable.parseTintMode(tintMode, Mode.SRC_IN);
    }
    final ColorStateList tint = a.getColorStateList(R.styleable.BitmapDrawable_tint);
    if (tint != null) {
        state.mTint = tint;
    }
    final Paint paint = mBitmapState.mPaint;
    paint.setAntiAlias(a.getBoolean(R.styleable.BitmapDrawable_antialias, paint.isAntiAlias()));
    paint.setFilterBitmap(a.getBoolean(R.styleable.BitmapDrawable_filter, paint.isFilterBitmap()));
    paint.setDither(a.getBoolean(R.styleable.BitmapDrawable_dither, paint.isDither()));
    setGravity(a.getInt(R.styleable.BitmapDrawable_gravity, state.mGravity));
    final int tileMode = a.getInt(R.styleable.BitmapDrawable_tileMode, TILE_MODE_UNDEFINED);
    if (tileMode != TILE_MODE_UNDEFINED) {
        final Shader.TileMode mode = parseTileMode(tileMode);
        setTileModeXY(mode, mode);
    }
    final int tileModeX = a.getInt(R.styleable.BitmapDrawable_tileModeX, TILE_MODE_UNDEFINED);
    if (tileModeX != TILE_MODE_UNDEFINED) {
        setTileModeX(parseTileMode(tileModeX));
    }
    final int tileModeY = a.getInt(R.styleable.BitmapDrawable_tileModeY, TILE_MODE_UNDEFINED);
    if (tileModeY != TILE_MODE_UNDEFINED) {
        setTileModeY(parseTileMode(tileModeY));
    }
    final int densityDpi = r.getDisplayMetrics().densityDpi;
    state.mTargetDensity = densityDpi == 0 ? DisplayMetrics.DENSITY_DEFAULT : densityDpi;
}
------------------------
Find a silently evolved API code:android.os.Process.isIsolated:COMMENT
Method Modifier: public      static      final       hidden      
Comment:/**
 * Returns whether the current process is in an isolated sandbox.
 * @hide
 */

Body of Frist Method:
{
    int uid = UserHandle.getAppId(myUid());
    return uid >= FIRST_ISOLATED_UID && uid <= LAST_ISOLATED_UID;
}
Body of Second Method:
{
    return isIsolated(myUid());
}
------------------------
Find a silently evolved API code:android.widget.FastScroller.layoutTrack:COMMENT
Method Modifier: private     
Comment:/**
 * Lays out the track centered on the thumb. Must be called after
 * {@link #layoutThumb}.
 */

Body of Frist Method:
{
    final View track = mTrackImage;
    final View thumb = mThumbImage;
    final Rect container = mContainerRect;
    final int containerWidth = container.width();
    final int widthMeasureSpec = MeasureSpec.makeMeasureSpec(containerWidth, MeasureSpec.AT_MOST);
    final int heightMeasureSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED);
    track.measure(widthMeasureSpec, heightMeasureSpec);
    final int trackWidth = track.getMeasuredWidth();
    final int thumbHalfHeight = thumb == null ? 0 : thumb.getHeight() / 2;
    final int left = thumb.getLeft() + (thumb.getWidth() - trackWidth) / 2;
    final int right = left + trackWidth;
    final int top = container.top + thumbHalfHeight;
    final int bottom = container.bottom - thumbHalfHeight;
    track.layout(left, top, right, bottom);
}
Body of Second Method:
{
    final View track = mTrackImage;
    final View thumb = mThumbImage;
    final Rect container = mContainerRect;
    final int maxWidth = Math.max(0, container.width());
    final int maxHeight = Math.max(0, container.height());
    final int widthMeasureSpec = MeasureSpec.makeMeasureSpec(maxWidth, MeasureSpec.AT_MOST);
    final int heightMeasureSpec = MeasureSpec.makeSafeMeasureSpec(maxHeight, MeasureSpec.UNSPECIFIED);
    track.measure(widthMeasureSpec, heightMeasureSpec);
    final int top;
    final int bottom;
    if (mThumbPosition == THUMB_POSITION_INSIDE) {
        top = container.top;
        bottom = container.bottom;
    } else {
        final int thumbHalfHeight = thumb.getHeight() / 2;
        top = container.top + thumbHalfHeight;
        bottom = container.bottom - thumbHalfHeight;
    }
    final int trackWidth = track.getMeasuredWidth();
    final int left = thumb.getLeft() + (thumb.getWidth() - trackWidth) / 2;
    final int right = left + trackWidth;
    track.layout(left, top, right, bottom);
}
------------------------
Find a silently evolved API code:android.media.AudioFormat.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Combines all of the format characteristics that have been set and return a new
 * {@link AudioFormat} object.
 * @return a new {@link AudioFormat} object
 */

Body of Frist Method:
{
    AudioFormat af = new AudioFormat(1980);
    af.mEncoding = mEncoding;
    af.mSampleRate = mSampleRate;
    af.mChannelMask = mChannelMask;
    af.mPropertySetMask = mPropertySetMask;
    return af;
}
Body of Second Method:
{
    AudioFormat af = new AudioFormat(1980);
    af.mEncoding = mEncoding;
    af.mSampleRate = mSampleRate;
    af.mChannelMask = mChannelMask;
    af.mChannelIndexMask = mChannelIndexMask;
    af.mPropertySetMask = mPropertySetMask;
    return af;
}
------------------------
Find a silently evolved API code:android.text.SpannableStringBuilder.replace:COMMENT
Method Modifier: public      
Comment:// Documentation from interface

Body of Frist Method:
{
    return replace(start, end, tb, 0, tb.length());
}
Body of Second Method:
{
    checkRange("replace", start, end);
    int filtercount = mFilters.length;
    for (int i = 0; i < filtercount; i++) {
        CharSequence repl = mFilters[i].filter(tb, tbstart, tbend, this, start, end);
        if (repl != null) {
            tb = repl;
            tbstart = 0;
            tbend = repl.length();
        }
    }
    final int origLen = end - start;
    final int newLen = tbend - tbstart;
    if (origLen == 0 && newLen == 0 && !hasNonExclusiveExclusiveSpanAt(tb, tbstart)) {
        // Early exit so that the text watchers do not get notified
        return this;
    }
    TextWatcher[] textWatchers = getSpans(start, start + origLen, TextWatcher.class);
    sendBeforeTextChanged(textWatchers, start, origLen, newLen);
    // Try to keep the cursor / selection at the same relative position during
    // a text replacement. If replaced or replacement text length is zero, this
    // is already taken care of.
    boolean adjustSelection = origLen != 0 && newLen != 0;
    int selectionStart = 0;
    int selectionEnd = 0;
    if (adjustSelection) {
        selectionStart = Selection.getSelectionStart(this);
        selectionEnd = Selection.getSelectionEnd(this);
    }
    change(start, end, tb, tbstart, tbend);
    if (adjustSelection) {
        boolean changed = false;
        if (selectionStart > start && selectionStart < end) {
            final int offset = (selectionStart - start) * newLen / origLen;
            selectionStart = start + offset;
            changed = true;
            setSpan(false, Selection.SELECTION_START, selectionStart, selectionStart, Spanned.SPAN_POINT_POINT);
        }
        if (selectionEnd > start && selectionEnd < end) {
            final int offset = (selectionEnd - start) * newLen / origLen;
            selectionEnd = start + offset;
            changed = true;
            setSpan(false, Selection.SELECTION_END, selectionEnd, selectionEnd, Spanned.SPAN_POINT_POINT);
        }
        if (changed) {
            restoreInvariants();
        }
    }
    sendTextChanged(textWatchers, start, origLen, newLen);
    sendAfterTextChanged(textWatchers);
    // Span watchers need to be called after text watchers, which may update the layout
    sendToSpanWatchers(start, end, newLen - origLen);
    return this;
}
------------------------
Find a silently evolved API code:android.net.StaticIpConfiguration.writeToParcel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Implement the Parcelable interface
 */

Body of Frist Method:
{
    dest.writeParcelable(ipAddress, flags);
    NetworkUtils.parcelInetAddress(dest, gateway, flags);
    dest.writeInt(dnsServers.size());
    for (InetAddress dnsServer : dnsServers) {
        NetworkUtils.parcelInetAddress(dest, dnsServer, flags);
    }
}
Body of Second Method:
{
    dest.writeParcelable(ipAddress, flags);
    NetworkUtils.parcelInetAddress(dest, gateway, flags);
    dest.writeInt(dnsServers.size());
    for (InetAddress dnsServer : dnsServers) {
        NetworkUtils.parcelInetAddress(dest, dnsServer, flags);
    }
    dest.writeString(domains);
}
------------------------
Find a silently evolved API code:android.widget.Spinner.setPopupBackgroundDrawable:COMMENT
Method Modifier: public      
Comment:/**
 * Set the background drawable for the spinner's popup window of choices.
 * Only valid in {@link #MODE_DROPDOWN}; this method is a no-op in other modes.
 *
 * @param background Background drawable
 *
 * @attr ref android.R.styleable#Spinner_popupBackground
 */

Body of Frist Method:
{
    if (!(mPopup instanceof DropdownPopup)) {
        Log.e(TAG, "setPopupBackgroundDrawable: incompatible spinner mode; ignoring...");
        return;
    }
    ((DropdownPopup) mPopup).setBackgroundDrawable(background);
}
Body of Second Method:
{
    if (!(mPopup instanceof DropdownPopup)) {
        Log.e(TAG, "setPopupBackgroundDrawable: incompatible spinner mode; ignoring...");
        return;
    }
    mPopup.setBackgroundDrawable(background);
}
------------------------
Find a silently evolved API code:android.text.Layout.measurePara:COMMENT
Method Modifier: default     static      
Comment:/* package */

Body of Frist Method:
{
    MeasuredText mt = MeasuredText.obtain();
    TextLine tl = TextLine.obtain();
    try {
        mt.setPara(text, start, end, TextDirectionHeuristics.LTR);
        Directions directions;
        int dir;
        if (mt.mEasy) {
            directions = DIRS_ALL_LEFT_TO_RIGHT;
            dir = Layout.DIR_LEFT_TO_RIGHT;
        } else {
            directions = AndroidBidi.directions(mt.mDir, mt.mLevels, 0, mt.mChars, 0, mt.mLen);
            dir = mt.mDir;
        }
        char[] chars = mt.mChars;
        int len = mt.mLen;
        boolean hasTabs = false;
        TabStops tabStops = null;
        // leading margins should be taken into account when measuring a paragraph
        int margin = 0;
        if (text instanceof Spanned) {
            Spanned spanned = (Spanned) text;
            LeadingMarginSpan[] spans = getParagraphSpans(spanned, start, end, LeadingMarginSpan.class);
            for (LeadingMarginSpan lms : spans) {
                margin += lms.getLeadingMargin(true);
            }
        }
        for (int i = 0; i < len; ++i) {
            if (chars[i] == '\t') {
                hasTabs = true;
                if (text instanceof Spanned) {
                    Spanned spanned = (Spanned) text;
                    int spanEnd = spanned.nextSpanTransition(start, end, TabStopSpan.class);
                    TabStopSpan[] spans = getParagraphSpans(spanned, start, spanEnd, TabStopSpan.class);
                    if (spans.length > 0) {
                        tabStops = new TabStops(TAB_INCREMENT, spans);
                    }
                }
                break;
            }
        }
        tl.set(paint, text, start, end, dir, directions, hasTabs, tabStops);
        return margin + tl.metrics(null);
    } finally {
        TextLine.recycle(tl);
        MeasuredText.recycle(mt);
    }
}
Body of Second Method:
{
    MeasuredText mt = MeasuredText.obtain();
    TextLine tl = TextLine.obtain();
    try {
        mt.setPara(text, start, end, TextDirectionHeuristics.LTR, null);
        Directions directions;
        int dir;
        if (mt.mEasy) {
            directions = DIRS_ALL_LEFT_TO_RIGHT;
            dir = Layout.DIR_LEFT_TO_RIGHT;
        } else {
            directions = AndroidBidi.directions(mt.mDir, mt.mLevels, 0, mt.mChars, 0, mt.mLen);
            dir = mt.mDir;
        }
        char[] chars = mt.mChars;
        int len = mt.mLen;
        boolean hasTabs = false;
        TabStops tabStops = null;
        // leading margins should be taken into account when measuring a paragraph
        int margin = 0;
        if (text instanceof Spanned) {
            Spanned spanned = (Spanned) text;
            LeadingMarginSpan[] spans = getParagraphSpans(spanned, start, end, LeadingMarginSpan.class);
            for (LeadingMarginSpan lms : spans) {
                margin += lms.getLeadingMargin(true);
            }
        }
        for (int i = 0; i < len; ++i) {
            if (chars[i] == '\t') {
                hasTabs = true;
                if (text instanceof Spanned) {
                    Spanned spanned = (Spanned) text;
                    int spanEnd = spanned.nextSpanTransition(start, end, TabStopSpan.class);
                    TabStopSpan[] spans = getParagraphSpans(spanned, start, spanEnd, TabStopSpan.class);
                    if (spans.length > 0) {
                        tabStops = new TabStops(TAB_INCREMENT, spans);
                    }
                }
                break;
            }
        }
        tl.set(paint, text, start, end, dir, directions, hasTabs, tabStops);
        return margin + tl.metrics(null);
    } finally {
        TextLine.recycle(tl);
        MeasuredText.recycle(mt);
    }
}
------------------------
Find a silently evolved API code:android.media.audiofx.Virtualizer.getVirtualizationMode:COMMENT
Method Modifier: public      
Comment:/**
 * Return the virtualization mode being used, if any.
 * @return the virtualization mode being used.
 * If virtualization is not active, the virtualization mode will be
 * {@link #VIRTUALIZATION_MODE_OFF}. Otherwise the value will be
 * {@link #VIRTUALIZATION_MODE_BINAURAL} or {@link #VIRTUALIZATION_MODE_TRANSAURAL}.
 * Virtualization may not be active either because the effect is not enabled or
 * because the current output device is not compatible with this virtualization
 * implementation.
 * @throws IllegalStateException
 * @throws UnsupportedOperationException
 */

Body of Frist Method:
{
    int[] value = new int[1];
    int status = getParameter(PARAM_VIRTUALIZATION_MODE, value);
    if (status >= 0) {
        return deviceToMode(AudioDevice.convertInternalDeviceToDeviceType(value[0]));
    } else if (status == AudioEffect.ERROR_BAD_VALUE) {
        return VIRTUALIZATION_MODE_OFF;
    } else {
        // something wrong may have happened
        checkStatus(status);
    }
    // unexpected virtualizer behavior
    Log.e(TAG, "unexpected status code " + status + " after getParameter(PARAM_VIRTUALIZATION_MODE)");
    return VIRTUALIZATION_MODE_OFF;
}
Body of Second Method:
{
    int[] value = new int[1];
    int status = getParameter(PARAM_VIRTUALIZATION_MODE, value);
    if (status >= 0) {
        return deviceToMode(AudioDeviceInfo.convertInternalDeviceToDeviceType(value[0]));
    } else if (status == AudioEffect.ERROR_BAD_VALUE) {
        return VIRTUALIZATION_MODE_OFF;
    } else {
        // something wrong may have happened
        checkStatus(status);
    }
    // unexpected virtualizer behavior
    Log.e(TAG, "unexpected status code " + status + " after getParameter(PARAM_VIRTUALIZATION_MODE)");
    return VIRTUALIZATION_MODE_OFF;
}
------------------------
Find a silently evolved API code:android.view.accessibility.AccessibilityEvent.writeAccessibilityRecordToParcel:COMMENT
Method Modifier: private     
Comment:/**
 * Writes an {@link AccessibilityRecord} to a parcel.
 *
 * @param record The record to write.
 * @param parcel The parcel to which to write.
 */

Body of Frist Method:
{
    parcel.writeInt(record.mBooleanProperties);
    parcel.writeInt(record.mCurrentItemIndex);
    parcel.writeInt(record.mItemCount);
    parcel.writeInt(record.mFromIndex);
    parcel.writeInt(record.mToIndex);
    parcel.writeInt(record.mScrollX);
    parcel.writeInt(record.mScrollY);
    parcel.writeInt(record.mMaxScrollX);
    parcel.writeInt(record.mMaxScrollY);
    parcel.writeInt(record.mAddedCount);
    parcel.writeInt(record.mRemovedCount);
    TextUtils.writeToParcel(record.mClassName, parcel, flags);
    TextUtils.writeToParcel(record.mContentDescription, parcel, flags);
    TextUtils.writeToParcel(record.mBeforeText, parcel, flags);
    parcel.writeParcelable(record.mParcelableData, flags);
    parcel.writeList(record.mText);
    parcel.writeInt(record.mSourceWindowId);
    parcel.writeLong(record.mSourceNodeId);
    parcel.writeInt(record.mSealed ? 1 : 0);
}
Body of Second Method:
{
    parcel.writeInt(record.mBooleanProperties);
    parcel.writeInt(record.mCurrentItemIndex);
    parcel.writeInt(record.mItemCount);
    parcel.writeInt(record.mFromIndex);
    parcel.writeInt(record.mToIndex);
    parcel.writeInt(record.mScrollX);
    parcel.writeInt(record.mScrollY);
    parcel.writeInt(record.mMaxScrollX);
    parcel.writeInt(record.mMaxScrollY);
    parcel.writeInt(record.mAddedCount);
    parcel.writeInt(record.mRemovedCount);
    TextUtils.writeToParcel(record.mClassName, parcel, flags);
    TextUtils.writeToParcel(record.mContentDescription, parcel, flags);
    TextUtils.writeToParcel(record.mBeforeText, parcel, flags);
    parcel.writeParcelable(record.mParcelableData, flags);
    parcel.writeList(record.mText);
    parcel.writeInt(record.mSourceWindowId);
    // create copy of the node here because the node would be recycled just after it is written
    // to parcel
    parcel.writeParcelable(record.mSourceNode != null ? AccessibilityNodeInfo.obtain(record.mSourceNode) : null, flags);
    parcel.writeInt(record.mSealed ? 1 : 0);
}
------------------------
Find a silently evolved API code:android.graphics.drawable.RippleDrawable.isProjected:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return getNumberOfLayers() == 0;
}
Body of Second Method:
{
    // If the layer is bounded, then we don't need to project.
    if (isBounded()) {
        return false;
    }
    // Otherwise, if the maximum radius is contained entirely within the
    // bounds then we don't need to project. This is sort of a hack to
    // prevent check box ripples from being projected across the edges of
    // scroll views. It does not impact rendering performance, and it can
    // be removed once we have better handling of projection in scrollable
    // views.
    final int radius = mState.mMaxRadius;
    final Rect drawableBounds = getBounds();
    final Rect hotspotBounds = mHotspotBounds;
    if (radius != RADIUS_AUTO && radius <= hotspotBounds.width() / 2 && radius <= hotspotBounds.height() / 2 && (drawableBounds.equals(hotspotBounds) || drawableBounds.contains(hotspotBounds))) {
        return false;
    }
    return true;
}
------------------------
Find a silently evolved API code:javax.obex.ServerSession.handleAbortRequest:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Handles a ABORT request from a client. This method will read the rest of
 * the request from the client. Assuming the request is valid, it will
 * create a <code>HeaderSet</code> object to pass to the
 * <code>ServerRequestHandler</code> object. After the handler processes the
 * request, this method will create a reply message to send to the server.
 *
 * @throws IOException if an error occurred at the transport layer
 */

Body of Frist Method:
{
    int code = ResponseCodes.OBEX_HTTP_OK;
    HeaderSet request = new HeaderSet();
    HeaderSet reply = new HeaderSet();
    int length = mInput.read();
    length = (length << 8) + mInput.read();
    if (length > ObexHelper.MAX_PACKET_SIZE_INT) {
        code = ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE;
    } else {
        for (int i = 3; i < length; i++) {
            mInput.read();
        }
        code = mListener.onAbort(request, reply);
        Log.v(TAG, "onAbort request handler return value- " + code);
        code = validateResponseCode(code);
    }
    sendResponse(code, null);
}
Body of Second Method:
{
    int code = ResponseCodes.OBEX_HTTP_OK;
    HeaderSet request = new HeaderSet();
    HeaderSet reply = new HeaderSet();
    int length = mInput.read();
    length = (length << 8) + mInput.read();
    if (length > ObexHelper.getMaxRxPacketSize(mTransport)) {
        code = ResponseCodes.OBEX_HTTP_REQ_TOO_LARGE;
    } else {
        for (int i = 3; i < length; i++) {
            mInput.read();
        }
        code = mListener.onAbort(request, reply);
        Log.v(TAG, "onAbort request handler return value- " + code);
        code = validateResponseCode(code);
    }
    sendResponse(code, null);
}
------------------------
Find a silently evolved API code:android.widget.TextView.setExtracting:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (mEditor.mInputMethodState != null) {
        mEditor.mInputMethodState.mExtractedTextRequest = req;
    }
    // This would stop a possible selection mode, but no such mode is started in case
    // extracted mode will start. Some text is selected though, and will trigger an action mode
    // in the extracted view.
    mEditor.hideControllers();
}
Body of Second Method:
{
    if (mEditor.mInputMethodState != null) {
        mEditor.mInputMethodState.mExtractedTextRequest = req;
    }
    // This would stop a possible selection mode, but no such mode is started in case
    // extracted mode will start. Some text is selected though, and will trigger an action mode
    // in the extracted view.
    mEditor.hideCursorAndSpanControllers();
    stopTextActionMode();
}
------------------------
Find a silently evolved API code:android.os.StrictMode.readAndHandleBinderCallViolations:COMMENT
Method Modifier: default     static      
Comment:/* package */

Body of Frist Method:
{
    // Our own stack trace to append
    StringWriter sw = new StringWriter();
    PrintWriter pw = new FastPrintWriter(sw, false, 256);
    new LogStackTrace().printStackTrace(pw);
    pw.flush();
    String ourStack = sw.toString();
    int policyMask = getThreadPolicyMask();
    boolean currentlyGathering = (policyMask & PENALTY_GATHER) != 0;
    int numViolations = p.readInt();
    for (int i = 0; i < numViolations; ++i) {
        if (LOG_V)
            Log.d(TAG, "strict mode violation stacks read from binder call.  i=" + i);
        ViolationInfo info = new ViolationInfo(p, !currentlyGathering);
        if (info.crashInfo.stackTrace != null && info.crashInfo.stackTrace.length() > 10000) {
            String front = info.crashInfo.stackTrace.substring(256);
            // First, drain the remaining violations from the parcel.
            while (i < numViolations) {
                info = new ViolationInfo(p, !currentlyGathering);
                i++;
            }
            // Next clear out all gathered violations.
            clearGatheredViolations();
            // Now report the problem.
            Slog.wtfStack(TAG, "Stack is too large: numViolations=" + numViolations + " policy=#" + Integer.toHexString(policyMask) + " front=" + front);
            return;
        }
        info.crashInfo.stackTrace += "# via Binder call with stack:\n" + ourStack;
        BlockGuard.Policy policy = BlockGuard.getThreadPolicy();
        if (policy instanceof AndroidBlockGuardPolicy) {
            ((AndroidBlockGuardPolicy) policy).handleViolationWithTimingAttempt(info);
        }
    }
}
Body of Second Method:
{
    // Our own stack trace to append
    StringWriter sw = new StringWriter();
    PrintWriter pw = new FastPrintWriter(sw, false, 256);
    new LogStackTrace().printStackTrace(pw);
    pw.flush();
    String ourStack = sw.toString();
    int policyMask = getThreadPolicyMask();
    boolean currentlyGathering = (policyMask & PENALTY_GATHER) != 0;
    int numViolations = p.readInt();
    for (int i = 0; i < numViolations; ++i) {
        if (LOG_V)
            Log.d(TAG, "strict mode violation stacks read from binder call.  i=" + i);
        ViolationInfo info = new ViolationInfo(p, !currentlyGathering);
        if (info.crashInfo.stackTrace != null && info.crashInfo.stackTrace.length() > 30000) {
            String front = info.crashInfo.stackTrace.substring(256);
            // First, drain the remaining violations from the parcel.
            while (i < numViolations) {
                info = new ViolationInfo(p, !currentlyGathering);
                i++;
            }
            // Next clear out all gathered violations.
            clearGatheredViolations();
            // Now report the problem.
            Slog.wtfStack(TAG, "Stack is too large: numViolations=" + numViolations + " policy=#" + Integer.toHexString(policyMask) + " front=" + front);
            return;
        }
        info.crashInfo.stackTrace += "# via Binder call with stack:\n" + ourStack;
        BlockGuard.Policy policy = BlockGuard.getThreadPolicy();
        if (policy instanceof AndroidBlockGuardPolicy) {
            ((AndroidBlockGuardPolicy) policy).handleViolationWithTimingAttempt(info);
        }
    }
}
------------------------
Find a silently evolved API code:android.media.AudioManager.setStreamVolume:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the volume index for a particular stream.
 * <p>This method has no effect if the device implements a fixed volume policy
 * as indicated by {@link #isVolumeFixed()}.
 * @param streamType The stream whose volume index should be set.
 * @param index The volume index to set. See
 * {@link #getStreamMaxVolume(int)} for the largest valid value.
 * @param flags One or more flags.
 * @see #getStreamMaxVolume(int)
 * @see #getStreamVolume(int)
 * @see #isVolumeFixed()
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        if (mUseMasterVolume) {
            service.setMasterVolume(index, flags, mContext.getOpPackageName());
        } else {
            service.setStreamVolume(streamType, index, flags, mContext.getOpPackageName());
        }
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in setStreamVolume", e);
    }
}
Body of Second Method:
{
    IAudioService service = getService();
    try {
        service.setStreamVolume(streamType, index, flags, getContext().getOpPackageName());
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in setStreamVolume", e);
    }
}
------------------------
Find a silently evolved API code:android.app.Activity.setActionBar:COMMENT
Method Modifier: public      
Comment:/**
 * Set a {@link android.widget.Toolbar Toolbar} to act as the {@link ActionBar} for this
 * Activity window.
 *
 * <p>When set to a non-null value the {@link #getActionBar()} method will return
 * an {@link ActionBar} object that can be used to control the given toolbar as if it were
 * a traditional window decor action bar. The toolbar's menu will be populated with the
 * Activity's options menu and the navigation button will be wired through the standard
 * {@link android.R.id#home home} menu select action.</p>
 *
 * <p>In order to use a Toolbar within the Activity's window content the application
 * must not request the window feature {@link Window#FEATURE_ACTION_BAR FEATURE_ACTION_BAR}.</p>
 *
 * @param toolbar Toolbar to set as the Activity's action bar
 */

Body of Frist Method:
{
    if (getActionBar() instanceof WindowDecorActionBar) {
        throw new IllegalStateException("This Activity already has an action bar supplied " + "by the window decor. Do not request Window.FEATURE_ACTION_BAR and set " + "android:windowActionBar to false in your theme to use a Toolbar instead.");
    }
    ToolbarActionBar tbab = new ToolbarActionBar(toolbar, getTitle(), this);
    mActionBar = tbab;
    mWindow.setCallback(tbab.getWrappedWindowCallback());
    mActionBar.invalidateOptionsMenu();
}
Body of Second Method:
{
    if (getActionBar() instanceof WindowDecorActionBar) {
        throw new IllegalStateException("This Activity already has an action bar supplied " + "by the window decor. Do not request Window.FEATURE_ACTION_BAR and set " + "android:windowActionBar to false in your theme to use a Toolbar instead.");
    }
    // Clear out the MenuInflater to make sure that it is valid for the new Action Bar
    mMenuInflater = null;
    ToolbarActionBar tbab = new ToolbarActionBar(toolbar, getTitle(), this);
    mActionBar = tbab;
    mWindow.setCallback(tbab.getWrappedWindowCallback());
    mActionBar.invalidateOptionsMenu();
}
------------------------
Find a silently evolved API code:android.media.AudioRecord.getMinBufferSize:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns the minimum buffer size required for the successful creation of an AudioRecord
 * object, in byte units.
 * Note that this size doesn't guarantee a smooth recording under load, and higher values
 * should be chosen according to the expected frequency at which the AudioRecord instance
 * will be polled for new data.
 * See {@link #AudioRecord(int, int, int, int, int)} for more information on valid
 * configuration values.
 * @param sampleRateInHz the sample rate expressed in Hertz.
 * @param channelConfig describes the configuration of the audio channels.
 * See {@link AudioFormat#CHANNEL_IN_MONO} and
 * {@link AudioFormat#CHANNEL_IN_STEREO}
 * @param audioFormat the format in which the audio data is represented.
 * See {@link AudioFormat#ENCODING_PCM_16BIT}.
 * @return {@link #ERROR_BAD_VALUE} if the recording parameters are not supported by the
 * hardware, or an invalid parameter was passed,
 * or {@link #ERROR} if the implementation was unable to query the hardware for its
 * input properties,
 * or the minimum buffer size expressed in bytes.
 * @see #AudioRecord(int, int, int, int, int)
 */

Body of Frist Method:
{
    int channelCount = 0;
    switch(channelConfig) {
        // AudioFormat.CHANNEL_CONFIGURATION_DEFAULT
        case AudioFormat.CHANNEL_IN_DEFAULT:
        case AudioFormat.CHANNEL_IN_MONO:
        case AudioFormat.CHANNEL_CONFIGURATION_MONO:
            channelCount = 1;
            break;
        case AudioFormat.CHANNEL_IN_STEREO:
        case AudioFormat.CHANNEL_CONFIGURATION_STEREO:
        case (AudioFormat.CHANNEL_IN_FRONT | AudioFormat.CHANNEL_IN_BACK):
            channelCount = 2;
            break;
        case AudioFormat.CHANNEL_INVALID:
        default:
            loge("getMinBufferSize(): Invalid channel configuration.");
            return ERROR_BAD_VALUE;
    }
    // PCM_8BIT is not supported at the moment
    if (audioFormat != AudioFormat.ENCODING_PCM_16BIT) {
        loge("getMinBufferSize(): Invalid audio format.");
        return ERROR_BAD_VALUE;
    }
    int size = native_get_min_buff_size(sampleRateInHz, channelCount, audioFormat);
    if (size == 0) {
        return ERROR_BAD_VALUE;
    } else if (size == -1) {
        return ERROR;
    } else {
        return size;
    }
}
Body of Second Method:
{
    int channelCount = 0;
    switch(channelConfig) {
        // AudioFormat.CHANNEL_CONFIGURATION_DEFAULT
        case AudioFormat.CHANNEL_IN_DEFAULT:
        case AudioFormat.CHANNEL_IN_MONO:
        case AudioFormat.CHANNEL_CONFIGURATION_MONO:
            channelCount = 1;
            break;
        case AudioFormat.CHANNEL_IN_STEREO:
        case AudioFormat.CHANNEL_CONFIGURATION_STEREO:
        case (AudioFormat.CHANNEL_IN_FRONT | AudioFormat.CHANNEL_IN_BACK):
            channelCount = 2;
            break;
        case AudioFormat.CHANNEL_INVALID:
        default:
            loge("getMinBufferSize(): Invalid channel configuration.");
            return ERROR_BAD_VALUE;
    }
    int size = native_get_min_buff_size(sampleRateInHz, channelCount, audioFormat);
    if (size == 0) {
        return ERROR_BAD_VALUE;
    } else if (size == -1) {
        return ERROR;
    } else {
        return size;
    }
}
------------------------
Find a silently evolved API code:android.content.ContentResolver.bulkInsert:COMMENT
Method Modifier: public      final       
Comment:/**
 * Inserts multiple rows into a table at the given URL.
 *
 * This function make no guarantees about the atomicity of the insertions.
 *
 * @param url The URL of the table to insert into.
 * @param values The initial values for the newly inserted rows. The key is the column name for
 * the field. Passing null will create an empty row.
 * @return the number of newly created rows.
 */

Body of Frist Method:
{
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        throw new IllegalArgumentException("Unknown URL " + url);
    }
    try {
        long startTime = SystemClock.uptimeMillis();
        int rowsCreated = provider.bulkInsert(mPackageName, url, values);
        long durationMillis = SystemClock.uptimeMillis() - startTime;
        maybeLogUpdateToEventLog(durationMillis, url, "bulkinsert", null);
        return rowsCreated;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return 0;
    } finally {
        releaseProvider(provider);
    }
}
Body of Second Method:
{
    Preconditions.checkNotNull(url, "url");
    Preconditions.checkNotNull(values, "values");
    IContentProvider provider = acquireProvider(url);
    if (provider == null) {
        throw new IllegalArgumentException("Unknown URL " + url);
    }
    try {
        long startTime = SystemClock.uptimeMillis();
        int rowsCreated = provider.bulkInsert(mPackageName, url, values);
        long durationMillis = SystemClock.uptimeMillis() - startTime;
        maybeLogUpdateToEventLog(durationMillis, url, "bulkinsert", null);
        return rowsCreated;
    } catch (RemoteException e) {
        // Manager will kill this process shortly anyway.
        return 0;
    } finally {
        releaseProvider(provider);
    }
}
------------------------
Find a silently evolved API code:android.app.ContextImpl.ensureDirsExistOrFilter:COMMENT
Method Modifier: private     
Comment:/**
 * Ensure that given directories exist, trying to create them if missing. If
 * unable to create, they are filtered by replacing with {@code null}.
 */

Body of Frist Method:
{
    File[] result = new File[dirs.length];
    for (int i = 0; i < dirs.length; i++) {
        File dir = dirs[i];
        if (!dir.exists()) {
            if (!dir.mkdirs()) {
                // recheck existence in case of cross-process race
                if (!dir.exists()) {
                    // Failing to mkdir() may be okay, since we might not have
                    // enough permissions; ask vold to create on our behalf.
                    final IMountService mount = IMountService.Stub.asInterface(ServiceManager.getService("mount"));
                    int res = -1;
                    try {
                        res = mount.mkdirs(getPackageName(), dir.getAbsolutePath());
                    } catch (Exception ignored) {
                    }
                    if (res != 0) {
                        Log.w(TAG, "Failed to ensure directory: " + dir);
                        dir = null;
                    }
                }
            }
        }
        result[i] = dir;
    }
    return result;
}
Body of Second Method:
{
    File[] result = new File[dirs.length];
    for (int i = 0; i < dirs.length; i++) {
        File dir = dirs[i];
        if (!dir.exists()) {
            if (!dir.mkdirs()) {
                // recheck existence in case of cross-process race
                if (!dir.exists()) {
                    // Failing to mkdir() may be okay, since we might not have
                    // enough permissions; ask vold to create on our behalf.
                    final IMountService mount = IMountService.Stub.asInterface(ServiceManager.getService("mount"));
                    try {
                        final int res = mount.mkdirs(getPackageName(), dir.getAbsolutePath());
                        if (res != 0) {
                            Log.w(TAG, "Failed to ensure " + dir + ": " + res);
                            dir = null;
                        }
                    } catch (Exception e) {
                        Log.w(TAG, "Failed to ensure " + dir + ": " + e);
                        dir = null;
                    }
                }
            }
        }
        result[i] = dir;
    }
    return result;
}
------------------------
Find a silently evolved API code:android.transition.Visibility.onDisappear:COMMENT
Method Modifier: public      
Comment:/**
 * Subclasses should override this method or
 * {@link #onDisappear(ViewGroup, View, TransitionValues, TransitionValues)}
 * if they need to create an Animator when targets disappear.
 * The method should only be called by the Visibility class; it is
 * not intended to be called from external classes.
 * <p>
 * The default implementation of this method attempts to find a View to use to call
 * {@link #onDisappear(ViewGroup, View, TransitionValues, TransitionValues)},
 * based on the situation of the View in the View hierarchy. For example,
 * if a View was simply removed from its parent, then the View will be added
 * into a {@link android.view.ViewGroupOverlay} and passed as the <code>view</code>
 * parameter in {@link #onDisappear(ViewGroup, View, TransitionValues, TransitionValues)}.
 * If a visible View is changed to be {@link View#GONE} or {@link View#INVISIBLE},
 * then it can be used as the <code>view</code> and the visibility will be changed
 * to {@link View#VISIBLE} for the duration of the animation. However, if a View
 * is in a hierarchy which is also altering its visibility, the situation can be
 * more complicated. In general, if a view that is no longer in the hierarchy in
 * the end scene still has a parent (so its parent hierarchy was removed, but it
 * was not removed from its parent), then it will be left alone to avoid side-effects from
 * improperly removing it from its parent. The only exception to this is if
 * the previous {@link Scene} was {@link Scene#getSceneForLayout(ViewGroup, int,
 * android.content.Context) created from a layout resource file}, then it is considered
 * safe to un-parent the starting scene view in order to make it disappear.</p>
 *
 * @param sceneRoot The root of the transition hierarchy
 * @param startValues The target values in the start scene
 * @param startVisibility The target visibility in the start scene
 * @param endValues The target values in the end scene
 * @param endVisibility The target visibility in the end scene
 * @return An Animator to be started at the appropriate time in the
 * overall transition for this scene change. A null value means no animation
 * should be run.
 */

Body of Frist Method:
{
    if ((mMode & MODE_OUT) != MODE_OUT) {
        return null;
    }
    View startView = (startValues != null) ? startValues.view : null;
    View endView = (endValues != null) ? endValues.view : null;
    View overlayView = null;
    View viewToKeep = null;
    if (endView == null || endView.getParent() == null) {
        if (endView != null) {
            // endView was removed from its parent - add it to the overlay
            overlayView = endView;
        } else if (startView != null) {
            // it being removed from its current parent
            if (startView.getParent() == null) {
                // no parent - safe to use
                overlayView = startView;
            } else if (startView.getParent() instanceof View) {
                View startParent = (View) startView.getParent();
                TransitionValues startParentValues = getTransitionValues(startParent, true);
                TransitionValues endParentValues = getMatchedTransitionValues(startParent, true);
                VisibilityInfo parentVisibilityInfo = getVisibilityChangeInfo(startParentValues, endParentValues);
                if (!parentVisibilityInfo.visibilityChange) {
                    overlayView = TransitionUtils.copyViewImage(sceneRoot, startView, startParent);
                } else if (startParent.getParent() == null) {
                    int id = startParent.getId();
                    if (id != View.NO_ID && sceneRoot.findViewById(id) != null && mCanRemoveViews) {
                        // no parent, but its parent is unparented  but the parent
                        // hierarchy has been replaced by a new hierarchy with the same id
                        // and it is safe to un-parent startView
                        overlayView = startView;
                    }
                }
            }
        }
    } else {
        // visibility change
        if (endVisibility == View.INVISIBLE) {
            viewToKeep = endView;
        } else {
            // Becoming GONE
            if (startView == endView) {
                viewToKeep = endView;
            } else {
                overlayView = startView;
            }
        }
    }
    final int finalVisibility = endVisibility;
    final ViewGroup finalSceneRoot = sceneRoot;
    if (overlayView != null) {
        // TODO: Need to do this for general case of adding to overlay
        int[] screenLoc = (int[]) startValues.values.get(PROPNAME_SCREEN_LOCATION);
        int screenX = screenLoc[0];
        int screenY = screenLoc[1];
        int[] loc = new int[2];
        sceneRoot.getLocationOnScreen(loc);
        overlayView.offsetLeftAndRight((screenX - loc[0]) - overlayView.getLeft());
        overlayView.offsetTopAndBottom((screenY - loc[1]) - overlayView.getTop());
        sceneRoot.getOverlay().add(overlayView);
        Animator animator = onDisappear(sceneRoot, overlayView, startValues, endValues);
        if (animator == null) {
            sceneRoot.getOverlay().remove(overlayView);
        } else {
            final View finalOverlayView = overlayView;
            animator.addListener(new AnimatorListenerAdapter() {

                @Override
                public void onAnimationEnd(Animator animation) {
                    finalSceneRoot.getOverlay().remove(finalOverlayView);
                }
            });
        }
        return animator;
    }
    if (viewToKeep != null) {
        int originalVisibility = -1;
        final boolean isForcedVisibility = mForcedStartVisibility != -1 || mForcedEndVisibility != -1;
        if (!isForcedVisibility) {
            originalVisibility = viewToKeep.getVisibility();
            viewToKeep.setVisibility(View.VISIBLE);
        }
        Animator animator = onDisappear(sceneRoot, viewToKeep, startValues, endValues);
        if (animator != null) {
            final View finalViewToKeep = viewToKeep;
            animator.addListener(new AnimatorListenerAdapter() {

                boolean mCanceled = false;

                @Override
                public void onAnimationPause(Animator animation) {
                    if (!mCanceled && !isForcedVisibility) {
                        finalViewToKeep.setVisibility(finalVisibility);
                    }
                }

                @Override
                public void onAnimationResume(Animator animation) {
                    if (!mCanceled && !isForcedVisibility) {
                        finalViewToKeep.setVisibility(View.VISIBLE);
                    }
                }

                @Override
                public void onAnimationCancel(Animator animation) {
                    mCanceled = true;
                }

                @Override
                public void onAnimationEnd(Animator animation) {
                    if (!mCanceled) {
                        if (isForcedVisibility) {
                            finalViewToKeep.setTransitionAlpha(0);
                        } else {
                            finalViewToKeep.setVisibility(finalVisibility);
                        }
                    }
                }
            });
        } else if (!isForcedVisibility) {
            viewToKeep.setVisibility(originalVisibility);
        }
        return animator;
    }
    return null;
}
Body of Second Method:
{
    if ((mMode & MODE_OUT) != MODE_OUT) {
        return null;
    }
    View startView = (startValues != null) ? startValues.view : null;
    View endView = (endValues != null) ? endValues.view : null;
    View overlayView = null;
    View viewToKeep = null;
    if (endView == null || endView.getParent() == null) {
        if (endView != null) {
            // endView was removed from its parent - add it to the overlay
            overlayView = endView;
        } else if (startView != null) {
            // it being removed from its current parent
            if (startView.getParent() == null) {
                // no parent - safe to use
                overlayView = startView;
            } else if (startView.getParent() instanceof View) {
                View startParent = (View) startView.getParent();
                TransitionValues startParentValues = getTransitionValues(startParent, true);
                TransitionValues endParentValues = getMatchedTransitionValues(startParent, true);
                VisibilityInfo parentVisibilityInfo = getVisibilityChangeInfo(startParentValues, endParentValues);
                if (!parentVisibilityInfo.visibilityChange) {
                    overlayView = TransitionUtils.copyViewImage(sceneRoot, startView, startParent);
                } else if (startParent.getParent() == null) {
                    int id = startParent.getId();
                    if (id != View.NO_ID && sceneRoot.findViewById(id) != null && mCanRemoveViews) {
                        // no parent, but its parent is unparented  but the parent
                        // hierarchy has been replaced by a new hierarchy with the same id
                        // and it is safe to un-parent startView
                        overlayView = startView;
                    }
                }
            }
        }
    } else {
        // visibility change
        if (endVisibility == View.INVISIBLE) {
            viewToKeep = endView;
        } else {
            // Becoming GONE
            if (startView == endView) {
                viewToKeep = endView;
            } else {
                overlayView = startView;
            }
        }
    }
    final int finalVisibility = endVisibility;
    final ViewGroup finalSceneRoot = sceneRoot;
    if (overlayView != null) {
        // TODO: Need to do this for general case of adding to overlay
        int[] screenLoc = (int[]) startValues.values.get(PROPNAME_SCREEN_LOCATION);
        int screenX = screenLoc[0];
        int screenY = screenLoc[1];
        int[] loc = new int[2];
        sceneRoot.getLocationOnScreen(loc);
        overlayView.offsetLeftAndRight((screenX - loc[0]) - overlayView.getLeft());
        overlayView.offsetTopAndBottom((screenY - loc[1]) - overlayView.getTop());
        sceneRoot.getOverlay().add(overlayView);
        Animator animator = onDisappear(sceneRoot, overlayView, startValues, endValues);
        if (animator == null) {
            sceneRoot.getOverlay().remove(overlayView);
        } else {
            final View finalOverlayView = overlayView;
            addListener(new TransitionListenerAdapter() {

                @Override
                public void onTransitionEnd(Transition transition) {
                    finalSceneRoot.getOverlay().remove(finalOverlayView);
                }
            });
        }
        return animator;
    }
    if (viewToKeep != null) {
        int originalVisibility = -1;
        final boolean isForcedVisibility = mForcedStartVisibility != -1 || mForcedEndVisibility != -1;
        if (!isForcedVisibility) {
            originalVisibility = viewToKeep.getVisibility();
            viewToKeep.setTransitionVisibility(View.VISIBLE);
        }
        Animator animator = onDisappear(sceneRoot, viewToKeep, startValues, endValues);
        if (animator != null) {
            DisappearListener disappearListener = new DisappearListener(viewToKeep, finalVisibility, isForcedVisibility);
            animator.addListener(disappearListener);
            animator.addPauseListener(disappearListener);
            addListener(disappearListener);
        } else if (!isForcedVisibility) {
            viewToKeep.setTransitionVisibility(originalVisibility);
        }
        return animator;
    }
    return null;
}
------------------------
Find a silently evolved API code:android.view.LayoutInflater_Delegate.rInflate:COMMENT
Method Modifier: default     static      
Comment:/**
 * Recursive method used to descend down the xml hierarchy and instantiate
 * views, instantiate their children, and then call onFinishInflate().
 *
 * This implementation just records the merge status before calling the default implementation.
 */

Body of Frist Method:
{
    if (finishInflate == false) {
        // this is a merge rInflate!
        if (thisInflater instanceof BridgeInflater) {
            ((BridgeInflater) thisInflater).setIsInMerge(true);
        }
    }
    // ---- START DEFAULT IMPLEMENTATION.
    thisInflater.rInflate_Original(parser, parent, attrs, finishInflate, inheritContext);
    if (finishInflate == false) {
        // this is a merge rInflate!
        if (thisInflater instanceof BridgeInflater) {
            ((BridgeInflater) thisInflater).setIsInMerge(false);
        }
    }
}
Body of Second Method:
{
    if (finishInflate == false) {
        // this is a merge rInflate!
        if (thisInflater instanceof BridgeInflater) {
            ((BridgeInflater) thisInflater).setIsInMerge(true);
        }
    }
    // ---- START DEFAULT IMPLEMENTATION.
    thisInflater.rInflate_Original(parser, parent, context, attrs, finishInflate);
    if (finishInflate == false) {
        // this is a merge rInflate!
        if (thisInflater instanceof BridgeInflater) {
            ((BridgeInflater) thisInflater).setIsInMerge(false);
        }
    }
}
------------------------
Find a silently evolved API code:android.graphics.Canvas.drawPaint:COMMENT
Method Modifier: public      
Comment:/**
 * Fill the entire canvas' bitmap (restricted to the current clip) with
 * the specified paint. This is equivalent (but faster) to drawing an
 * infinitely large rectangle with the specified paint.
 *
 * @param paint The paint used to draw onto the canvas
 */

Body of Frist Method:
{
    native_drawPaint(mNativeCanvasWrapper, paint.mNativePaint);
}
Body of Second Method:
{
    native_drawPaint(mNativeCanvasWrapper, paint.getNativeInstance());
}
------------------------
Find a silently evolved API code:android.graphics.Bitmap.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Write the bitmap and its pixels to the parcel. The bitmap can be
 * rebuilt from the parcel by calling CREATOR.createFromParcel().
 * @param p    Parcel object to write the bitmap data into
 */

Body of Frist Method:
{
    checkRecycled("Can't parcel a recycled bitmap");
    if (!nativeWriteToParcel(mNativeBitmap, mIsMutable, mDensity, p)) {
        throw new RuntimeException("native writeToParcel failed");
    }
}
Body of Second Method:
{
    checkRecycled("Can't parcel a recycled bitmap");
    if (!nativeWriteToParcel(mFinalizer.mNativeBitmap, mIsMutable, mDensity, p)) {
        throw new RuntimeException("native writeToParcel failed");
    }
}
------------------------
Find a silently evolved API code:android.print.PrintAttributes.asLandscape:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Gets a new print attributes instance which is in landscape orientation,
 * which is the media size is in landscape and all orientation dependent
 * attributes such as resolution and margins are properly adjusted.
 *
 * @return New instance in landscape orientation if this one is in
 * portrait, otherwise this instance.
 *
 * @hide
 */

Body of Frist Method:
{
    if (!isPortrait()) {
        return this;
    }
    PrintAttributes attributes = new PrintAttributes();
    // Rotate the media size.
    attributes.setMediaSize(getMediaSize().asLandscape());
    // Rotate the resolution.
    Resolution oldResolution = getResolution();
    Resolution newResolution = new Resolution(oldResolution.getId(), oldResolution.getLabel(), oldResolution.getVerticalDpi(), oldResolution.getHorizontalDpi());
    attributes.setResolution(newResolution);
    // Do not rotate the physical margins.
    attributes.setMinMargins(getMinMargins());
    attributes.setColorMode(getColorMode());
    return attributes;
}
Body of Second Method:
{
    if (!isPortrait()) {
        return this;
    }
    PrintAttributes attributes = new PrintAttributes();
    // Rotate the media size.
    attributes.setMediaSize(getMediaSize().asLandscape());
    // Rotate the resolution.
    Resolution oldResolution = getResolution();
    Resolution newResolution = new Resolution(oldResolution.getId(), oldResolution.getLabel(), oldResolution.getVerticalDpi(), oldResolution.getHorizontalDpi());
    attributes.setResolution(newResolution);
    // Do not rotate the physical margins.
    attributes.setMinMargins(getMinMargins());
    attributes.setColorMode(getColorMode());
    attributes.setDuplexMode(getDuplexMode());
    return attributes;
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiInfo.reset:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    setInetAddress(null);
    setBSSID(null);
    setSSID(null);
    setNetworkId(-1);
    setRssi(INVALID_RSSI);
    setLinkSpeed(-1);
    setFrequency(-1);
    setMeteredHint(false);
    txBad = 0;
    txSuccess = 0;
    rxSuccess = 0;
    txRetries = 0;
    txBadRate = 0;
    txSuccessRate = 0;
    rxSuccessRate = 0;
    txRetriesRate = 0;
    lowRssiCount = 0;
    badRssiCount = 0;
    linkStuckCount = 0;
    score = 0;
}
Body of Second Method:
{
    setInetAddress(null);
    setBSSID(null);
    setSSID(null);
    setNetworkId(-1);
    setRssi(INVALID_RSSI);
    setLinkSpeed(-1);
    setFrequency(-1);
    setMeteredHint(false);
    setEphemeral(false);
    txBad = 0;
    txSuccess = 0;
    rxSuccess = 0;
    txRetries = 0;
    txBadRate = 0;
    txSuccessRate = 0;
    rxSuccessRate = 0;
    txRetriesRate = 0;
    lowRssiCount = 0;
    badRssiCount = 0;
    linkStuckCount = 0;
    score = 0;
}
------------------------
Find a silently evolved API code:android.os.NullVibrator.vibrate:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    vibrate(milliseconds);
}
Body of Second Method:
{
}
------------------------
Find a silently evolved API code:android.graphics.Bitmap.getGenerationId:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the generation ID of this bitmap. The generation ID changes
 * whenever the bitmap is modified. This can be used as an efficient way to
 * check if a bitmap has changed.
 *
 * @return The current generation ID for this bitmap.
 */

Body of Frist Method:
{
    return nativeGenerationId(mNativeBitmap);
}
Body of Second Method:
{
    if (mRecycled) {
        Log.w(TAG, "Called getGenerationId() on a recycle()'d bitmap! This is undefined behavior!");
    }
    return nativeGenerationId(mFinalizer.mNativeBitmap);
}
------------------------
Find a silently evolved API code:android.os.PowerManager.wakeUp:COMMENT
Method Modifier: public      
Comment:/**
 * Forces the device to wake up from sleep.
 * <p>
 * If the device is currently asleep, wakes it up, otherwise does nothing.
 * This is what happens when the power key is pressed to turn on the screen.
 * </p><p>
 * Requires the {@link android.Manifest.permission#DEVICE_POWER} permission.
 * </p>
 *
 * @param time The time when the request to wake up was issued, in the
 * {@link SystemClock#uptimeMillis()} time base.  This timestamp is used to correctly
 * order the wake up request with other power management functions.  It should be set
 * to the timestamp of the input event that caused the request to wake up.
 *
 * @see #userActivity
 * @see #goToSleep
 *
 * @removed Requires signature permission.
 */

Body of Frist Method:
{
    try {
        mService.wakeUp(time);
    } catch (RemoteException e) {
    }
}
Body of Second Method:
{
    try {
        mService.wakeUp(time, "wakeUp", mContext.getOpPackageName());
    } catch (RemoteException e) {
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothActivityEnergyInfo.isValid:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @return if the record is valid
 */

Body of Frist Method:
{
    return ((getControllerTxTimeMillis() != 0) || (getControllerRxTimeMillis() != 0) || (getControllerIdleTimeMillis() != 0));
}
Body of Second Method:
{
    return ((mControllerTxTimeMs != 0) || (mControllerRxTimeMs != 0) || (mControllerIdleTimeMs != 0));
}
------------------------
Find a silently evolved API code:android.view.WindowInsets.hasInsets:COMMENT
Method Modifier: public      
Comment:/**
 * Returns true if this WindowInsets has any nonzero insets.
 *
 * @return true if any inset values are nonzero
 */

Body of Frist Method:
{
    return hasSystemWindowInsets() || hasWindowDecorInsets();
}
Body of Second Method:
{
    return hasSystemWindowInsets() || hasWindowDecorInsets() || hasStableInsets();
}
------------------------
Find a silently evolved API code:android.text.Layout.getLineStartPos:COMMENT
Method Modifier: private     
Comment:/**
 * Return the start position of the line, given the left and right bounds
 * of the margins.
 *
 * @param line the line index
 * @param left the left bounds (0, or leading margin if ltr para)
 * @param right the right bounds (width, minus leading margin if rtl para)
 * @return the start position of the line (to right of line if rtl para)
 */

Body of Frist Method:
{
    // Adjust the point at which to start rendering depending on the
    // alignment of the paragraph.
    Alignment align = getParagraphAlignment(line);
    int dir = getParagraphDirection(line);
    if (align == Alignment.ALIGN_LEFT) {
        align = (dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_NORMAL : Alignment.ALIGN_OPPOSITE;
    } else if (align == Alignment.ALIGN_RIGHT) {
        align = (dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_OPPOSITE : Alignment.ALIGN_NORMAL;
    }
    int x;
    if (align == Alignment.ALIGN_NORMAL) {
        if (dir == DIR_LEFT_TO_RIGHT) {
            x = left;
        } else {
            x = right;
        }
    } else {
        TabStops tabStops = null;
        if (mSpannedText && getLineContainsTab(line)) {
            Spanned spanned = (Spanned) mText;
            int start = getLineStart(line);
            int spanEnd = spanned.nextSpanTransition(start, spanned.length(), TabStopSpan.class);
            TabStopSpan[] tabSpans = getParagraphSpans(spanned, start, spanEnd, TabStopSpan.class);
            if (tabSpans.length > 0) {
                tabStops = new TabStops(TAB_INCREMENT, tabSpans);
            }
        }
        int max = (int) getLineExtent(line, tabStops, false);
        if (align == Alignment.ALIGN_OPPOSITE) {
            if (dir == DIR_LEFT_TO_RIGHT) {
                x = right - max;
            } else {
                // max is negative here
                x = left - max;
            }
        } else {
            // Alignment.ALIGN_CENTER
            max = max & ~1;
            x = (left + right - max) >> 1;
        }
    }
    return x;
}
Body of Second Method:
{
    // Adjust the point at which to start rendering depending on the
    // alignment of the paragraph.
    Alignment align = getParagraphAlignment(line);
    int dir = getParagraphDirection(line);
    if (align == Alignment.ALIGN_LEFT) {
        align = (dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_NORMAL : Alignment.ALIGN_OPPOSITE;
    } else if (align == Alignment.ALIGN_RIGHT) {
        align = (dir == DIR_LEFT_TO_RIGHT) ? Alignment.ALIGN_OPPOSITE : Alignment.ALIGN_NORMAL;
    }
    int x;
    if (align == Alignment.ALIGN_NORMAL) {
        if (dir == DIR_LEFT_TO_RIGHT) {
            x = left + getIndentAdjust(line, Alignment.ALIGN_LEFT);
        } else {
            x = right + getIndentAdjust(line, Alignment.ALIGN_RIGHT);
        }
    } else {
        TabStops tabStops = null;
        if (mSpannedText && getLineContainsTab(line)) {
            Spanned spanned = (Spanned) mText;
            int start = getLineStart(line);
            int spanEnd = spanned.nextSpanTransition(start, spanned.length(), TabStopSpan.class);
            TabStopSpan[] tabSpans = getParagraphSpans(spanned, start, spanEnd, TabStopSpan.class);
            if (tabSpans.length > 0) {
                tabStops = new TabStops(TAB_INCREMENT, tabSpans);
            }
        }
        int max = (int) getLineExtent(line, tabStops, false);
        if (align == Alignment.ALIGN_OPPOSITE) {
            if (dir == DIR_LEFT_TO_RIGHT) {
                x = right - max + getIndentAdjust(line, Alignment.ALIGN_RIGHT);
            } else {
                // max is negative here
                x = left - max + getIndentAdjust(line, Alignment.ALIGN_LEFT);
            }
        } else {
            // Alignment.ALIGN_CENTER
            max = max & ~1;
            x = (left + right - max) >> 1 + getIndentAdjust(line, Alignment.ALIGN_CENTER);
        }
    }
    return x;
}
------------------------
Find a silently evolved API code:android.media.AudioTrack.stop:COMMENT
Method Modifier: public      
Comment:/**
 * Stops playing the audio data.
 * When used on an instance created in {@link #MODE_STREAM} mode, audio will stop playing
 * after the last buffer that was written has been played. For an immediate stop, use
 * {@link #pause()}, followed by {@link #flush()} to discard audio data that hasn't been played
 * back yet.
 * @throws IllegalStateException
 */

Body of Frist Method:
{
    if (mState != STATE_INITIALIZED) {
        throw new IllegalStateException("stop() called on uninitialized AudioTrack.");
    }
    // stop playing
    synchronized (mPlayStateLock) {
        native_stop();
        mPlayState = PLAYSTATE_STOPPED;
    }
}
Body of Second Method:
{
    if (mState != STATE_INITIALIZED) {
        throw new IllegalStateException("stop() called on uninitialized AudioTrack.");
    }
    // stop playing
    synchronized (mPlayStateLock) {
        native_stop();
        mPlayState = PLAYSTATE_STOPPED;
        mAvSyncHeader = null;
        mAvSyncBytesRemaining = 0;
    }
}
------------------------
Find a silently evolved API code:android.graphics.Bitmap.setPixels:COMMENT
Method Modifier: public      
Comment:/**
 * <p>Replace pixels in the bitmap with the colors in the array. Each element
 * in the array is a packed int prepresenting a non-premultiplied ARGB
 * {@link Color}.</p>
 *
 * @param pixels   The colors to write to the bitmap
 * @param offset   The index of the first color to read from pixels[]
 * @param stride   The number of colors in pixels[] to skip between rows.
 * Normally this value will be the same as the width of
 * the bitmap, but it can be larger (or negative).
 * @param x        The x coordinate of the first pixel to write to in
 * the bitmap.
 * @param y        The y coordinate of the first pixel to write to in
 * the bitmap.
 * @param width    The number of colors to copy from pixels[] per row
 * @param height   The number of rows to write to the bitmap
 *
 * @throws IllegalStateException if the bitmap is not mutable
 * @throws IllegalArgumentException if x, y, width, height are outside of
 * the bitmap's bounds.
 * @throws ArrayIndexOutOfBoundsException if the pixels array is too small
 * to receive the specified number of pixels.
 */

Body of Frist Method:
{
    checkRecycled("Can't call setPixels() on a recycled bitmap");
    if (!isMutable()) {
        throw new IllegalStateException();
    }
    if (width == 0 || height == 0) {
        // nothing to do
        return;
    }
    checkPixelsAccess(x, y, width, height, offset, stride, pixels);
    nativeSetPixels(mNativeBitmap, pixels, offset, stride, x, y, width, height);
}
Body of Second Method:
{
    checkRecycled("Can't call setPixels() on a recycled bitmap");
    if (!isMutable()) {
        throw new IllegalStateException();
    }
    if (width == 0 || height == 0) {
        // nothing to do
        return;
    }
    checkPixelsAccess(x, y, width, height, offset, stride, pixels);
    nativeSetPixels(mFinalizer.mNativeBitmap, pixels, offset, stride, x, y, width, height);
}
------------------------
Find a silently evolved API code:android.media.AudioManager.listAudioDevicePorts:COMMENT
<android.media.AudioManager: int listAudioDevicePorts(ArrayList<AudioPort>)>
public      hidden      ->public      static      hidden      
Method Modifier: public      static      hidden      
Method Modifier: Yes         No          Yes         
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * Specialized version of listAudioPorts() listing only audio devices (AudioDevicePort)
 * @see listAudioPorts(ArrayList<AudioPort>)
 * @hide
 */

Body of Frist Method:
{
    ArrayList<AudioPort> ports = new ArrayList<AudioPort>();
    int status = updateAudioPortCache(ports, null);
    if (status == SUCCESS) {
        devices.clear();
        for (int i = 0; i < ports.size(); i++) {
            if (ports.get(i) instanceof AudioDevicePort) {
                devices.add(ports.get(i));
            }
        }
    }
    return status;
}
Body of Second Method:
{
    if (devices == null) {
        return ERROR_BAD_VALUE;
    }
    ArrayList<AudioPort> ports = new ArrayList<AudioPort>();
    int status = updateAudioPortCache(ports, null, null);
    if (status == SUCCESS) {
        filterDevicePorts(ports, devices);
    }
    return status;
}
------------------------
Find a silently evolved API code:android.os.storage.IMountServiceListener.Stub.Proxy.onStorageStateChanged:COMMENT
Method Modifier: public      
Comment:/**
 * Storage state has changed.
 *
 * @param path The volume mount path.
 * @param oldState The old state of the volume.
 * @param newState The new state of the volume. Note: State is one
 * of the values returned by
 * Environment.getExternalStorageState()
 */

Body of Frist Method:
{
    Parcel _data = Parcel.obtain();
    Parcel _reply = Parcel.obtain();
    try {
        _data.writeInterfaceToken(DESCRIPTOR);
        _data.writeString(path);
        _data.writeString(oldState);
        _data.writeString(newState);
        mRemote.transact(Stub.TRANSACTION_onStorageStateChanged, _data, _reply, 0);
        _reply.readException();
    } finally {
        _reply.recycle();
        _data.recycle();
    }
}
Body of Second Method:
{
    Parcel _data = Parcel.obtain();
    Parcel _reply = Parcel.obtain();
    try {
        _data.writeInterfaceToken(DESCRIPTOR);
        _data.writeString(path);
        _data.writeString(oldState);
        _data.writeString(newState);
        mRemote.transact(Stub.TRANSACTION_onStorageStateChanged, _data, _reply, android.os.IBinder.FLAG_ONEWAY);
        _reply.readException();
    } finally {
        _reply.recycle();
        _data.recycle();
    }
}
------------------------
Find a silently evolved API code:android.app.Fragment.onStart:COMMENT
Method Modifier: public      
Comment:/**
 * Called when the Fragment is visible to the user.  This is generally
 * tied to {@link Activity#onStart() Activity.onStart} of the containing
 * Activity's lifecycle.
 */

Body of Frist Method:
{
    mCalled = true;
    if (!mLoadersStarted) {
        mLoadersStarted = true;
        if (!mCheckedForLoaderManager) {
            mCheckedForLoaderManager = true;
            mLoaderManager = mActivity.getLoaderManager(mWho, mLoadersStarted, false);
        }
        if (mLoaderManager != null) {
            mLoaderManager.doStart();
        }
    }
}
Body of Second Method:
{
    mCalled = true;
    if (!mLoadersStarted) {
        mLoadersStarted = true;
        if (!mCheckedForLoaderManager) {
            mCheckedForLoaderManager = true;
            mLoaderManager = mHost.getLoaderManager(mWho, mLoadersStarted, false);
        }
        if (mLoaderManager != null) {
            mLoaderManager.doStart();
        }
    }
}
------------------------
Find a silently evolved API code:android.widget.TextView.paste:COMMENT
Method Modifier: private     
Comment:/**
 * Paste clipboard content between min and max positions.
 */

Body of Frist Method:
{
    ClipboardManager clipboard = (ClipboardManager) getContext().getSystemService(Context.CLIPBOARD_SERVICE);
    ClipData clip = clipboard.getPrimaryClip();
    if (clip != null) {
        boolean didFirst = false;
        for (int i = 0; i < clip.getItemCount(); i++) {
            CharSequence paste = clip.getItemAt(i).coerceToStyledText(getContext());
            if (paste != null) {
                if (!didFirst) {
                    Selection.setSelection((Spannable) mText, max);
                    ((Editable) mText).replace(min, max, paste);
                    didFirst = true;
                } else {
                    ((Editable) mText).insert(getSelectionEnd(), "\n");
                    ((Editable) mText).insert(getSelectionEnd(), paste);
                }
            }
        }
        stopSelectionActionMode();
        LAST_CUT_OR_COPY_TIME = 0;
    }
}
Body of Second Method:
{
    ClipboardManager clipboard = (ClipboardManager) getContext().getSystemService(Context.CLIPBOARD_SERVICE);
    ClipData clip = clipboard.getPrimaryClip();
    if (clip != null) {
        boolean didFirst = false;
        for (int i = 0; i < clip.getItemCount(); i++) {
            final CharSequence paste;
            if (withFormatting) {
                paste = clip.getItemAt(i).coerceToStyledText(getContext());
            } else {
                // Get an item as text and remove all spans by toString().
                final CharSequence text = clip.getItemAt(i).coerceToText(getContext());
                paste = (text instanceof Spanned) ? text.toString() : text;
            }
            if (paste != null) {
                if (!didFirst) {
                    Selection.setSelection((Spannable) mText, max);
                    ((Editable) mText).replace(min, max, paste);
                    didFirst = true;
                } else {
                    ((Editable) mText).insert(getSelectionEnd(), "\n");
                    ((Editable) mText).insert(getSelectionEnd(), paste);
                }
            }
        }
        stopTextActionMode();
        sLastCutCopyOrTextChangedTime = 0;
    }
}
------------------------
Find a silently evolved API code:android.app.Activity.startActivityForResultAsUser:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide Implement to provide correct calling token.
 */

Body of Frist Method:
{
    if (options != null) {
        mActivityTransitionState.startExitOutTransition(this, options);
    }
    if (mParent != null) {
        throw new RuntimeException("Can't be called from a child");
    }
    Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity(this, mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options, user);
    if (ar != null) {
        mMainThread.sendActivityResult(mToken, mEmbeddedID, requestCode, ar.getResultCode(), ar.getResultData());
    }
    if (requestCode >= 0) {
        // If this start is requesting a result, we can avoid making
        // the activity visible until the result is received.  Setting
        // this code during onCreate(Bundle savedInstanceState) or onResume() will keep the
        // activity hidden during this time, to avoid flickering.
        // This can only be done when a result is requested because
        // that guarantees we will get information back when the
        // activity is finished, no matter what happens to it.
        mStartedActivity = true;
    }
    final View decor = mWindow != null ? mWindow.peekDecorView() : null;
    if (decor != null) {
        decor.cancelPendingInputEvents();
    }
}
Body of Second Method:
{
    if (mParent != null) {
        throw new RuntimeException("Can't be called from a child");
    }
    Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity(this, mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options, user);
    if (ar != null) {
        mMainThread.sendActivityResult(mToken, mEmbeddedID, requestCode, ar.getResultCode(), ar.getResultData());
    }
    if (requestCode >= 0) {
        // If this start is requesting a result, we can avoid making
        // the activity visible until the result is received.  Setting
        // this code during onCreate(Bundle savedInstanceState) or onResume() will keep the
        // activity hidden during this time, to avoid flickering.
        // This can only be done when a result is requested because
        // that guarantees we will get information back when the
        // activity is finished, no matter what happens to it.
        mStartedActivity = true;
    }
    cancelInputsAndStartExitTransition(options);
}
------------------------
Find a silently evolved API code:android.os.storage.StorageVolume.getMtpReserveSpace:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Number of megabytes of space to leave unallocated by MTP.
 * MTP will subtract this value from the free space it reports back
 * to the host via GetStorageInfo, and will not allow new files to
 * be added via MTP if there is less than this amount left free in the storage.
 * If MTP has dedicated storage this value should be zero, but if MTP is
 * sharing storage with the rest of the system, set this to a positive value
 * to ensure that MTP activity does not result in the storage being
 * too close to full.
 *
 * @return MTP reserve space
 */

Body of Frist Method:
{
    return mMtpReserveSpace;
}
Body of Second Method:
{
    return (int) (mMtpReserveSize / TrafficStats.MB_IN_BYTES);
}
------------------------
Find a silently evolved API code:android.graphics.drawable.GradientDrawable.ensureValidRect:COMMENT
Method Modifier: private     
Comment:/**
 * This checks mGradientIsDirty, and if it is true, recomputes both our drawing
 * rectangle (mRect) and the gradient itself, since it depends on our
 * rectangle too.
 * @return true if the resulting rectangle is not empty, false otherwise
 */

Body of Frist Method:
{
    if (mGradientIsDirty) {
        mGradientIsDirty = false;
        Rect bounds = getBounds();
        float inset = 0;
        if (mStrokePaint != null) {
            inset = mStrokePaint.getStrokeWidth() * 0.5f;
        }
        final GradientState st = mGradientState;
        mRect.set(bounds.left + inset, bounds.top + inset, bounds.right - inset, bounds.bottom - inset);
        final int[] colors = st.mColors;
        if (colors != null) {
            RectF r = mRect;
            float x0, x1, y0, y1;
            if (st.mGradient == LINEAR_GRADIENT) {
                final float level = st.mUseLevel ? getLevel() / 10000.0f : 1.0f;
                switch(st.mOrientation) {
                    case TOP_BOTTOM:
                        x0 = r.left;
                        y0 = r.top;
                        x1 = x0;
                        y1 = level * r.bottom;
                        break;
                    case TR_BL:
                        x0 = r.right;
                        y0 = r.top;
                        x1 = level * r.left;
                        y1 = level * r.bottom;
                        break;
                    case RIGHT_LEFT:
                        x0 = r.right;
                        y0 = r.top;
                        x1 = level * r.left;
                        y1 = y0;
                        break;
                    case BR_TL:
                        x0 = r.right;
                        y0 = r.bottom;
                        x1 = level * r.left;
                        y1 = level * r.top;
                        break;
                    case BOTTOM_TOP:
                        x0 = r.left;
                        y0 = r.bottom;
                        x1 = x0;
                        y1 = level * r.top;
                        break;
                    case BL_TR:
                        x0 = r.left;
                        y0 = r.bottom;
                        x1 = level * r.right;
                        y1 = level * r.top;
                        break;
                    case LEFT_RIGHT:
                        x0 = r.left;
                        y0 = r.top;
                        x1 = level * r.right;
                        y1 = y0;
                        break;
                    default:
                        /* TL_BR */
                        x0 = r.left;
                        y0 = r.top;
                        x1 = level * r.right;
                        y1 = level * r.bottom;
                        break;
                }
                mFillPaint.setShader(new LinearGradient(x0, y0, x1, y1, colors, st.mPositions, Shader.TileMode.CLAMP));
            } else if (st.mGradient == RADIAL_GRADIENT) {
                x0 = r.left + (r.right - r.left) * st.mCenterX;
                y0 = r.top + (r.bottom - r.top) * st.mCenterY;
                float radius = st.mGradientRadius;
                if (st.mGradientRadiusType == RADIUS_TYPE_FRACTION) {
                    // Fall back to parent width or height if intrinsic
                    // size is not specified.
                    final float width = st.mWidth >= 0 ? st.mWidth : r.width();
                    final float height = st.mHeight >= 0 ? st.mHeight : r.height();
                    radius *= Math.min(width, height);
                } else if (st.mGradientRadiusType == RADIUS_TYPE_FRACTION_PARENT) {
                    radius *= Math.min(r.width(), r.height());
                }
                if (st.mUseLevel) {
                    radius *= getLevel() / 10000.0f;
                }
                mGradientRadius = radius;
                if (radius <= 0) {
                    // We can't have a shader with non-positive radius, so
                    // let's have a very, very small radius.
                    radius = 0.001f;
                }
                mFillPaint.setShader(new RadialGradient(x0, y0, radius, colors, null, Shader.TileMode.CLAMP));
            } else if (st.mGradient == SWEEP_GRADIENT) {
                x0 = r.left + (r.right - r.left) * st.mCenterX;
                y0 = r.top + (r.bottom - r.top) * st.mCenterY;
                int[] tempColors = colors;
                float[] tempPositions = null;
                if (st.mUseLevel) {
                    tempColors = st.mTempColors;
                    final int length = colors.length;
                    if (tempColors == null || tempColors.length != length + 1) {
                        tempColors = st.mTempColors = new int[length + 1];
                    }
                    System.arraycopy(colors, 0, tempColors, 0, length);
                    tempColors[length] = colors[length - 1];
                    tempPositions = st.mTempPositions;
                    final float fraction = 1.0f / (length - 1);
                    if (tempPositions == null || tempPositions.length != length + 1) {
                        tempPositions = st.mTempPositions = new float[length + 1];
                    }
                    final float level = getLevel() / 10000.0f;
                    for (int i = 0; i < length; i++) {
                        tempPositions[i] = i * fraction * level;
                    }
                    tempPositions[length] = 1.0f;
                }
                mFillPaint.setShader(new SweepGradient(x0, y0, tempColors, tempPositions));
            }
            // maxed out so that alpha modulation works correctly.
            if (st.mColorStateList == null) {
                mFillPaint.setColor(Color.BLACK);
            }
        }
    }
    return !mRect.isEmpty();
}
Body of Second Method:
{
    if (mGradientIsDirty) {
        mGradientIsDirty = false;
        Rect bounds = getBounds();
        float inset = 0;
        if (mStrokePaint != null) {
            inset = mStrokePaint.getStrokeWidth() * 0.5f;
        }
        final GradientState st = mGradientState;
        mRect.set(bounds.left + inset, bounds.top + inset, bounds.right - inset, bounds.bottom - inset);
        final int[] gradientColors = st.mGradientColors;
        if (gradientColors != null) {
            final RectF r = mRect;
            final float x0, x1, y0, y1;
            if (st.mGradient == LINEAR_GRADIENT) {
                final float level = st.mUseLevel ? getLevel() / 10000.0f : 1.0f;
                switch(st.mOrientation) {
                    case TOP_BOTTOM:
                        x0 = r.left;
                        y0 = r.top;
                        x1 = x0;
                        y1 = level * r.bottom;
                        break;
                    case TR_BL:
                        x0 = r.right;
                        y0 = r.top;
                        x1 = level * r.left;
                        y1 = level * r.bottom;
                        break;
                    case RIGHT_LEFT:
                        x0 = r.right;
                        y0 = r.top;
                        x1 = level * r.left;
                        y1 = y0;
                        break;
                    case BR_TL:
                        x0 = r.right;
                        y0 = r.bottom;
                        x1 = level * r.left;
                        y1 = level * r.top;
                        break;
                    case BOTTOM_TOP:
                        x0 = r.left;
                        y0 = r.bottom;
                        x1 = x0;
                        y1 = level * r.top;
                        break;
                    case BL_TR:
                        x0 = r.left;
                        y0 = r.bottom;
                        x1 = level * r.right;
                        y1 = level * r.top;
                        break;
                    case LEFT_RIGHT:
                        x0 = r.left;
                        y0 = r.top;
                        x1 = level * r.right;
                        y1 = y0;
                        break;
                    default:
                        /* TL_BR */
                        x0 = r.left;
                        y0 = r.top;
                        x1 = level * r.right;
                        y1 = level * r.bottom;
                        break;
                }
                mFillPaint.setShader(new LinearGradient(x0, y0, x1, y1, gradientColors, st.mPositions, Shader.TileMode.CLAMP));
            } else if (st.mGradient == RADIAL_GRADIENT) {
                x0 = r.left + (r.right - r.left) * st.mCenterX;
                y0 = r.top + (r.bottom - r.top) * st.mCenterY;
                float radius = st.mGradientRadius;
                if (st.mGradientRadiusType == RADIUS_TYPE_FRACTION) {
                    // Fall back to parent width or height if intrinsic
                    // size is not specified.
                    final float width = st.mWidth >= 0 ? st.mWidth : r.width();
                    final float height = st.mHeight >= 0 ? st.mHeight : r.height();
                    radius *= Math.min(width, height);
                } else if (st.mGradientRadiusType == RADIUS_TYPE_FRACTION_PARENT) {
                    radius *= Math.min(r.width(), r.height());
                }
                if (st.mUseLevel) {
                    radius *= getLevel() / 10000.0f;
                }
                mGradientRadius = radius;
                if (radius <= 0) {
                    // We can't have a shader with non-positive radius, so
                    // let's have a very, very small radius.
                    radius = 0.001f;
                }
                mFillPaint.setShader(new RadialGradient(x0, y0, radius, gradientColors, null, Shader.TileMode.CLAMP));
            } else if (st.mGradient == SWEEP_GRADIENT) {
                x0 = r.left + (r.right - r.left) * st.mCenterX;
                y0 = r.top + (r.bottom - r.top) * st.mCenterY;
                int[] tempColors = gradientColors;
                float[] tempPositions = null;
                if (st.mUseLevel) {
                    tempColors = st.mTempColors;
                    final int length = gradientColors.length;
                    if (tempColors == null || tempColors.length != length + 1) {
                        tempColors = st.mTempColors = new int[length + 1];
                    }
                    System.arraycopy(gradientColors, 0, tempColors, 0, length);
                    tempColors[length] = gradientColors[length - 1];
                    tempPositions = st.mTempPositions;
                    final float fraction = 1.0f / (length - 1);
                    if (tempPositions == null || tempPositions.length != length + 1) {
                        tempPositions = st.mTempPositions = new float[length + 1];
                    }
                    final float level = getLevel() / 10000.0f;
                    for (int i = 0; i < length; i++) {
                        tempPositions[i] = i * fraction * level;
                    }
                    tempPositions[length] = 1.0f;
                }
                mFillPaint.setShader(new SweepGradient(x0, y0, tempColors, tempPositions));
            }
            // maxed out so that alpha modulation works correctly.
            if (st.mSolidColors == null) {
                mFillPaint.setColor(Color.BLACK);
            }
        }
    }
    return !mRect.isEmpty();
}
------------------------
Find a silently evolved API code:android.hardware.camera2.legacy.SurfaceTextureRenderer.configureSurfaces:COMMENT
Method Modifier: public      
Comment:/**
 * Set a collection of output {@link Surface}s that can be drawn to.
 *
 * @param surfaces a {@link Collection} of surfaces.
 */

Body of Frist Method:
{
    releaseEGLContext();
    if (surfaces == null || surfaces.size() == 0) {
        Log.w(TAG, "No output surfaces configured for GL drawing.");
        return;
    }
    for (Pair<Surface, Size> p : surfaces) {
        Surface s = p.first;
        Size surfaceSize = p.second;
        // If pixel conversions aren't handled by egl, use a pbuffer
        try {
            EGLSurfaceHolder holder = new EGLSurfaceHolder();
            holder.surface = s;
            holder.width = surfaceSize.getWidth();
            holder.height = surfaceSize.getHeight();
            if (LegacyCameraDevice.needsConversion(s)) {
                // Always override to YV12 output for YUV surface formats.
                LegacyCameraDevice.setSurfaceFormat(s, ImageFormat.YV12);
                mConversionSurfaces.add(holder);
            } else {
                mSurfaces.add(holder);
            }
        } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
            Log.w(TAG, "Surface abandoned, skipping configuration... ", e);
        }
    }
    // Set up egl display
    configureEGLContext();
    // Set up regular egl surfaces if needed
    if (mSurfaces.size() > 0) {
        configureEGLOutputSurfaces(mSurfaces);
    }
    // Set up pbuffer surface if needed
    if (mConversionSurfaces.size() > 0) {
        configureEGLPbufferSurfaces(mConversionSurfaces);
    }
    makeCurrent((mSurfaces.size() > 0) ? mSurfaces.get(0).eglSurface : mConversionSurfaces.get(0).eglSurface);
    initializeGLState();
    mSurfaceTexture = new SurfaceTexture(getTextureId());
    // Set up performance tracking if enabled
    if (SystemProperties.getBoolean(LEGACY_PERF_PROPERTY, false)) {
        setupGlTiming();
    }
}
Body of Second Method:
{
    releaseEGLContext();
    if (surfaces == null || surfaces.size() == 0) {
        Log.w(TAG, "No output surfaces configured for GL drawing.");
        return;
    }
    for (Pair<Surface, Size> p : surfaces) {
        Surface s = p.first;
        Size surfaceSize = p.second;
        // If pixel conversions aren't handled by egl, use a pbuffer
        try {
            EGLSurfaceHolder holder = new EGLSurfaceHolder();
            holder.surface = s;
            holder.width = surfaceSize.getWidth();
            holder.height = surfaceSize.getHeight();
            if (LegacyCameraDevice.needsConversion(s)) {
                mConversionSurfaces.add(holder);
            } else {
                mSurfaces.add(holder);
            }
        } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
            Log.w(TAG, "Surface abandoned, skipping configuration... ", e);
        }
    }
    // Set up egl display
    configureEGLContext();
    // Set up regular egl surfaces if needed
    if (mSurfaces.size() > 0) {
        configureEGLOutputSurfaces(mSurfaces);
    }
    // Set up pbuffer surface if needed
    if (mConversionSurfaces.size() > 0) {
        configureEGLPbufferSurfaces(mConversionSurfaces);
    }
    makeCurrent((mSurfaces.size() > 0) ? mSurfaces.get(0).eglSurface : mConversionSurfaces.get(0).eglSurface);
    initializeGLState();
    mSurfaceTexture = new SurfaceTexture(getTextureId());
    // Set up performance tracking if enabled
    if (SystemProperties.getBoolean(LEGACY_PERF_PROPERTY, false)) {
        setupGlTiming();
    }
}
------------------------
Find a silently evolved API code:android.media.AudioManager.preDispatchKeyEvent:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    /*
         * If the user hits another key within the play sound delay, then
         * cancel the sound
         */
    int keyCode = event.getKeyCode();
    if (keyCode != KeyEvent.KEYCODE_VOLUME_DOWN && keyCode != KeyEvent.KEYCODE_VOLUME_UP && keyCode != KeyEvent.KEYCODE_VOLUME_MUTE && mVolumeKeyUpTime + AudioService.PLAY_SOUND_DELAY > SystemClock.uptimeMillis()) {
        /*
             * The user has hit another key during the delay (e.g., 300ms)
             * since the last volume key up, so cancel any sounds.
             */
        if (mUseMasterVolume) {
            adjustMasterVolume(ADJUST_SAME, AudioManager.FLAG_REMOVE_SOUND_AND_VIBRATE);
        } else {
            adjustSuggestedStreamVolume(ADJUST_SAME, stream, AudioManager.FLAG_REMOVE_SOUND_AND_VIBRATE);
        }
    }
}
Body of Second Method:
{
    /*
         * If the user hits another key within the play sound delay, then
         * cancel the sound
         */
    int keyCode = event.getKeyCode();
    if (keyCode != KeyEvent.KEYCODE_VOLUME_DOWN && keyCode != KeyEvent.KEYCODE_VOLUME_UP && keyCode != KeyEvent.KEYCODE_VOLUME_MUTE && mVolumeKeyUpTime + AudioSystem.PLAY_SOUND_DELAY > SystemClock.uptimeMillis()) {
        /*
             * The user has hit another key during the delay (e.g., 300ms)
             * since the last volume key up, so cancel any sounds.
             */
        adjustSuggestedStreamVolume(ADJUST_SAME, stream, AudioManager.FLAG_REMOVE_SOUND_AND_VIBRATE);
    }
}
------------------------
Find a silently evolved API code:android.text.SpannableStringBuilder.getSpanStart:COMMENT
Method Modifier: public      
Comment:/**
 * Return the buffer offset of the beginning of the specified
 * markup object, or -1 if it is not attached to this buffer.
 */

Body of Frist Method:
{
    int count = mSpanCount;
    Object[] spans = mSpans;
    for (int i = count - 1; i >= 0; i--) {
        if (spans[i] == what) {
            int where = mSpanStarts[i];
            if (where > mGapStart)
                where -= mGapLength;
            return where;
        }
    }
    return -1;
}
Body of Second Method:
{
    if (mIndexOfSpan == null)
        return -1;
    Integer i = mIndexOfSpan.get(what);
    return i == null ? -1 : resolveGap(mSpanStarts[i]);
}
------------------------
Find a silently evolved API code:android.content.pm.PermissionInfo.protectionToString:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    String protLevel = "????";
    switch(level & PROTECTION_MASK_BASE) {
        case PermissionInfo.PROTECTION_DANGEROUS:
            protLevel = "dangerous";
            break;
        case PermissionInfo.PROTECTION_NORMAL:
            protLevel = "normal";
            break;
        case PermissionInfo.PROTECTION_SIGNATURE:
            protLevel = "signature";
            break;
        case PermissionInfo.PROTECTION_SIGNATURE_OR_SYSTEM:
            protLevel = "signatureOrSystem";
            break;
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_SYSTEM) != 0) {
        protLevel += "|system";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_DEVELOPMENT) != 0) {
        protLevel += "|development";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_APPOP) != 0) {
        protLevel += "|appop";
    }
    return protLevel;
}
Body of Second Method:
{
    String protLevel = "????";
    switch(level & PROTECTION_MASK_BASE) {
        case PermissionInfo.PROTECTION_DANGEROUS:
            protLevel = "dangerous";
            break;
        case PermissionInfo.PROTECTION_NORMAL:
            protLevel = "normal";
            break;
        case PermissionInfo.PROTECTION_SIGNATURE:
            protLevel = "signature";
            break;
        case PermissionInfo.PROTECTION_SIGNATURE_OR_SYSTEM:
            protLevel = "signatureOrSystem";
            break;
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_PRIVILEGED) != 0) {
        protLevel += "|privileged";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_DEVELOPMENT) != 0) {
        protLevel += "|development";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_APPOP) != 0) {
        protLevel += "|appop";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_PRE23) != 0) {
        protLevel += "|pre23";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_INSTALLER) != 0) {
        protLevel += "|installer";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_VERIFIER) != 0) {
        protLevel += "|verifier";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_PREINSTALLED) != 0) {
        protLevel += "|preinstalled";
    }
    return protLevel;
}
------------------------
Find a silently evolved API code:android.webkit.WebResourceResponse.setStatusCodeAndReasonPhrase:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the resource response's status code and reason phrase.
 *
 * @param statusCode the status code needs to be in the ranges [100, 299], [400, 599].
 * Causing a redirect by specifying a 3xx code is not supported.
 * @param reasonPhrase the phrase describing the status code, for example "OK". Must be non-null
 * and not empty.
 */

Body of Frist Method:
{
    if (statusCode < 100)
        throw new IllegalArgumentException("statusCode can't be less than 100.");
    if (statusCode > 599)
        throw new IllegalArgumentException("statusCode can't be greater than 599.");
    if (statusCode > 299 && statusCode < 400)
        throw new IllegalArgumentException("statusCode can't be in the [300, 399] range.");
    if (reasonPhrase == null)
        throw new IllegalArgumentException("reasonPhrase can't be null.");
    if (reasonPhrase.trim().isEmpty())
        throw new IllegalArgumentException("reasonPhrase can't be empty.");
    for (int i = 0; i < reasonPhrase.length(); i++) {
        int c = reasonPhrase.charAt(i);
        if (c > 0x7F) {
            throw new IllegalArgumentException("reasonPhrase can't contain non-ASCII characters.");
        }
    }
    mStatusCode = statusCode;
    mReasonPhrase = reasonPhrase;
}
Body of Second Method:
{
    checkImmutable();
    if (statusCode < 100)
        throw new IllegalArgumentException("statusCode can't be less than 100.");
    if (statusCode > 599)
        throw new IllegalArgumentException("statusCode can't be greater than 599.");
    if (statusCode > 299 && statusCode < 400)
        throw new IllegalArgumentException("statusCode can't be in the [300, 399] range.");
    if (reasonPhrase == null)
        throw new IllegalArgumentException("reasonPhrase can't be null.");
    if (reasonPhrase.trim().isEmpty())
        throw new IllegalArgumentException("reasonPhrase can't be empty.");
    for (int i = 0; i < reasonPhrase.length(); i++) {
        int c = reasonPhrase.charAt(i);
        if (c > 0x7F) {
            throw new IllegalArgumentException("reasonPhrase can't contain non-ASCII characters.");
        }
    }
    mStatusCode = statusCode;
    mReasonPhrase = reasonPhrase;
}
------------------------
Find a silently evolved API code:android.view.inputmethod.InputMethodManager.finishInputLocked:COMMENT
Method Modifier: default     
Comment:/**
 * Disconnect any existing input connection, clearing the served view.
 */

Body of Frist Method:
{
    mCurRootView = null;
    mNextServedView = null;
    if (mServedView != null) {
        if (DEBUG)
            Log.v(TAG, "FINISH INPUT: " + mServedView);
        if (mCurrentTextBoxAttribute != null) {
            try {
                mService.finishInput(mClient);
            } catch (RemoteException e) {
            }
        }
        notifyInputConnectionFinished();
        mServedView = null;
        mCompletions = null;
        mServedConnecting = false;
        clearConnectionLocked();
    }
}
Body of Second Method:
{
    mNextServedView = null;
    if (mServedView != null) {
        if (DEBUG)
            Log.v(TAG, "FINISH INPUT: " + mServedView);
        if (mCurrentTextBoxAttribute != null) {
            try {
                mService.finishInput(mClient);
            } catch (RemoteException e) {
            }
        }
        notifyInputConnectionFinished();
        mServedView = null;
        mCompletions = null;
        mServedConnecting = false;
        clearConnectionLocked();
    }
}
------------------------
Find a silently evolved API code:android.graphics.drawable.LayerDrawable.refreshChildPadding:COMMENT
Method Modifier: private     
Comment:/**
 * Refreshes the cached padding values for the specified child.
 *
 * @return true if the child's padding has changed
 */

Body of Frist Method:
{
    final Rect rect = mTmpRect;
    r.mDrawable.getPadding(rect);
    if (rect.left != mPaddingL[i] || rect.top != mPaddingT[i] || rect.right != mPaddingR[i] || rect.bottom != mPaddingB[i]) {
        mPaddingL[i] = rect.left;
        mPaddingT[i] = rect.top;
        mPaddingR[i] = rect.right;
        mPaddingB[i] = rect.bottom;
        return true;
    }
    return false;
}
Body of Second Method:
{
    if (r.mDrawable != null) {
        final Rect rect = mTmpRect;
        r.mDrawable.getPadding(rect);
        if (rect.left != mPaddingL[i] || rect.top != mPaddingT[i] || rect.right != mPaddingR[i] || rect.bottom != mPaddingB[i]) {
            mPaddingL[i] = rect.left;
            mPaddingT[i] = rect.top;
            mPaddingR[i] = rect.right;
            mPaddingB[i] = rect.bottom;
            return true;
        }
    }
    return false;
}
------------------------
Find a silently evolved API code:android.media.AudioTrack.getMinBufferSize:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns the minimum buffer size required for the successful creation of an AudioTrack
 * object to be created in the {@link #MODE_STREAM} mode. Note that this size doesn't
 * guarantee a smooth playback under load, and higher values should be chosen according to
 * the expected frequency at which the buffer will be refilled with additional data to play.
 * For example, if you intend to dynamically set the source sample rate of an AudioTrack
 * to a higher value than the initial source sample rate, be sure to configure the buffer size
 * based on the highest planned sample rate.
 * @param sampleRateInHz the source sample rate expressed in Hz.
 * @param channelConfig describes the configuration of the audio channels.
 * See {@link AudioFormat#CHANNEL_OUT_MONO} and
 * {@link AudioFormat#CHANNEL_OUT_STEREO}
 * @param audioFormat the format in which the audio data is represented.
 * See {@link AudioFormat#ENCODING_PCM_16BIT} and
 * {@link AudioFormat#ENCODING_PCM_8BIT},
 * and {@link AudioFormat#ENCODING_PCM_FLOAT}.
 * @return {@link #ERROR_BAD_VALUE} if an invalid parameter was passed,
 * or {@link #ERROR} if unable to query for output properties,
 * or the minimum buffer size expressed in bytes.
 */

Body of Frist Method:
{
    int channelCount = 0;
    switch(channelConfig) {
        case AudioFormat.CHANNEL_OUT_MONO:
        case AudioFormat.CHANNEL_CONFIGURATION_MONO:
            channelCount = 1;
            break;
        case AudioFormat.CHANNEL_OUT_STEREO:
        case AudioFormat.CHANNEL_CONFIGURATION_STEREO:
            channelCount = 2;
            break;
        default:
            if ((channelConfig & SUPPORTED_OUT_CHANNELS) != channelConfig) {
                // input channel configuration features unsupported channels
                loge("getMinBufferSize(): Invalid channel configuration.");
                return ERROR_BAD_VALUE;
            } else {
                channelCount = Integer.bitCount(channelConfig);
            }
    }
    if (!AudioFormat.isValidEncoding(audioFormat)) {
        loge("getMinBufferSize(): Invalid audio format.");
        return ERROR_BAD_VALUE;
    }
    // sample rate, note these values are subject to change
    if ((sampleRateInHz < SAMPLE_RATE_HZ_MIN) || (sampleRateInHz > SAMPLE_RATE_HZ_MAX)) {
        loge("getMinBufferSize(): " + sampleRateInHz + " Hz is not a supported sample rate.");
        return ERROR_BAD_VALUE;
    }
    int size = native_get_min_buff_size(sampleRateInHz, channelCount, audioFormat);
    if (size <= 0) {
        loge("getMinBufferSize(): error querying hardware");
        return ERROR;
    } else {
        return size;
    }
}
Body of Second Method:
{
    int channelCount = 0;
    switch(channelConfig) {
        case AudioFormat.CHANNEL_OUT_MONO:
        case AudioFormat.CHANNEL_CONFIGURATION_MONO:
            channelCount = 1;
            break;
        case AudioFormat.CHANNEL_OUT_STEREO:
        case AudioFormat.CHANNEL_CONFIGURATION_STEREO:
            channelCount = 2;
            break;
        default:
            if (!isMultichannelConfigSupported(channelConfig)) {
                loge("getMinBufferSize(): Invalid channel configuration.");
                return ERROR_BAD_VALUE;
            } else {
                channelCount = AudioFormat.channelCountFromOutChannelMask(channelConfig);
            }
    }
    if (!AudioFormat.isPublicEncoding(audioFormat)) {
        loge("getMinBufferSize(): Invalid audio format.");
        return ERROR_BAD_VALUE;
    }
    // sample rate, note these values are subject to change
    if ((sampleRateInHz < SAMPLE_RATE_HZ_MIN) || (sampleRateInHz > SAMPLE_RATE_HZ_MAX)) {
        loge("getMinBufferSize(): " + sampleRateInHz + " Hz is not a supported sample rate.");
        return ERROR_BAD_VALUE;
    }
    int size = native_get_min_buff_size(sampleRateInHz, channelCount, audioFormat);
    if (size <= 0) {
        loge("getMinBufferSize(): error querying hardware");
        return ERROR;
    } else {
        return size;
    }
}
------------------------
Find a silently evolved API code:android.net.ConnectivityManager.getNetworkTypeName:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Returns a non-localized string representing a given network type.
 * ONLY used for debugging output.
 * @param type the type needing naming
 * @return a String for the given type, or a string version of the type ("87")
 * if no name is known.
 * {@hide}
 */

Body of Frist Method:
{
    switch(type) {
        case TYPE_MOBILE:
            return "MOBILE";
        case TYPE_WIFI:
            return "WIFI";
        case TYPE_MOBILE_MMS:
            return "MOBILE_MMS";
        case TYPE_MOBILE_SUPL:
            return "MOBILE_SUPL";
        case TYPE_MOBILE_DUN:
            return "MOBILE_DUN";
        case TYPE_MOBILE_HIPRI:
            return "MOBILE_HIPRI";
        case TYPE_WIMAX:
            return "WIMAX";
        case TYPE_BLUETOOTH:
            return "BLUETOOTH";
        case TYPE_DUMMY:
            return "DUMMY";
        case TYPE_ETHERNET:
            return "ETHERNET";
        case TYPE_MOBILE_FOTA:
            return "MOBILE_FOTA";
        case TYPE_MOBILE_IMS:
            return "MOBILE_IMS";
        case TYPE_MOBILE_CBS:
            return "MOBILE_CBS";
        case TYPE_WIFI_P2P:
            return "WIFI_P2P";
        case TYPE_MOBILE_IA:
            return "MOBILE_IA";
        case TYPE_MOBILE_EMERGENCY:
            return "MOBILE_EMERGENCY";
        case TYPE_PROXY:
            return "PROXY";
        default:
            return Integer.toString(type);
    }
}
Body of Second Method:
{
    switch(type) {
        case TYPE_MOBILE:
            return "MOBILE";
        case TYPE_WIFI:
            return "WIFI";
        case TYPE_MOBILE_MMS:
            return "MOBILE_MMS";
        case TYPE_MOBILE_SUPL:
            return "MOBILE_SUPL";
        case TYPE_MOBILE_DUN:
            return "MOBILE_DUN";
        case TYPE_MOBILE_HIPRI:
            return "MOBILE_HIPRI";
        case TYPE_WIMAX:
            return "WIMAX";
        case TYPE_BLUETOOTH:
            return "BLUETOOTH";
        case TYPE_DUMMY:
            return "DUMMY";
        case TYPE_ETHERNET:
            return "ETHERNET";
        case TYPE_MOBILE_FOTA:
            return "MOBILE_FOTA";
        case TYPE_MOBILE_IMS:
            return "MOBILE_IMS";
        case TYPE_MOBILE_CBS:
            return "MOBILE_CBS";
        case TYPE_WIFI_P2P:
            return "WIFI_P2P";
        case TYPE_MOBILE_IA:
            return "MOBILE_IA";
        case TYPE_MOBILE_EMERGENCY:
            return "MOBILE_EMERGENCY";
        case TYPE_PROXY:
            return "PROXY";
        case TYPE_VPN:
            return "VPN";
        default:
            return Integer.toString(type);
    }
}
------------------------
Find a silently evolved API code:android.os.Environment.maybeTranslateEmulatedPathToInternal:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * If the given path exists on emulated external storage, return the
 * translated backing path hosted on internal storage. This bypasses any
 * emulation later, improving performance. This is <em>only</em> suitable
 * for read-only access.
 * <p>
 * Returns original path if given path doesn't meet these criteria. Callers
 * must hold {@link android.Manifest.permission#WRITE_MEDIA_STORAGE}
 * permission.
 *
 * @hide
 */

Body of Frist Method:
{
    // Fast return if not emulated, or missing variables
    if (!Environment.isExternalStorageEmulated() || CANONCIAL_EMULATED_STORAGE_TARGET == null) {
        return path;
    }
    try {
        final String rawPath = path.getCanonicalPath();
        if (rawPath.startsWith(CANONCIAL_EMULATED_STORAGE_TARGET)) {
            final File internalPath = new File(DIR_MEDIA_STORAGE, rawPath.substring(CANONCIAL_EMULATED_STORAGE_TARGET.length()));
            if (internalPath.exists()) {
                return internalPath;
            }
        }
    } catch (IOException e) {
        Log.w(TAG, "Failed to resolve canonical path for " + path);
    }
    // Unable to translate to internal path; use original
    return path;
}
Body of Second Method:
{
    return StorageManager.maybeTranslateEmulatedPathToInternal(path);
}
------------------------
Find a silently evolved API code:android.telephony.SubscriptionManager.getSlotId:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Get slotId associated with the subscription.
 * @return slotId as a positive integer or a negative value if an error either
 * SIM_NOT_INSERTED or < 0 if an invalid slot index
 * @hide
 */

Body of Frist Method:
{
    if (!isValidSubscriptionId(subId)) {
        logd("[getSlotId]- fail");
    }
    int result = INVALID_SIM_SLOT_INDEX;
    try {
        ISub iSub = ISub.Stub.asInterface(ServiceManager.getService("isub"));
        if (iSub != null) {
            result = iSub.getSlotId(subId);
        }
    } catch (RemoteException ex) {
    // ignore it
    }
    return result;
}
Body of Second Method:
{
    if (!isValidSubscriptionId(subId)) {
        if (DBG) {
            logd("[getSlotId]- fail");
        }
    }
    int result = INVALID_SIM_SLOT_INDEX;
    try {
        ISub iSub = ISub.Stub.asInterface(ServiceManager.getService("isub"));
        if (iSub != null) {
            result = iSub.getSlotId(subId);
        }
    } catch (RemoteException ex) {
    // ignore it
    }
    return result;
}
------------------------
Find a silently evolved API code:android.database.DatabaseUtils.cursorFillWindow:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Fills the specified cursor window by iterating over the contents of the cursor.
 * The window is filled until the cursor is exhausted or the window runs out
 * of space.
 *
 * The original position of the cursor is left unchanged by this operation.
 *
 * @param cursor The cursor that contains the data to put in the window.
 * @param position The start position for filling the window.
 * @param window The window to fill.
 * @hide
 */

Body of Frist Method:
{
    if (position < 0 || position >= cursor.getCount()) {
        return;
    }
    final int oldPos = cursor.getPosition();
    final int numColumns = cursor.getColumnCount();
    window.clear();
    window.setStartPosition(position);
    window.setNumColumns(numColumns);
    if (cursor.moveToPosition(position)) {
        do {
            if (!window.allocRow()) {
                break;
            }
            for (int i = 0; i < numColumns; i++) {
                final int type = cursor.getType(i);
                final boolean success;
                switch(type) {
                    case Cursor.FIELD_TYPE_NULL:
                        success = window.putNull(position, i);
                        break;
                    case Cursor.FIELD_TYPE_INTEGER:
                        success = window.putLong(cursor.getLong(i), position, i);
                        break;
                    case Cursor.FIELD_TYPE_FLOAT:
                        success = window.putDouble(cursor.getDouble(i), position, i);
                        break;
                    case Cursor.FIELD_TYPE_BLOB:
                        {
                            final byte[] value = cursor.getBlob(i);
                            success = value != null ? window.putBlob(value, position, i) : window.putNull(position, i);
                            break;
                        }
                    // assume value is convertible to String
                    default:
                    case Cursor.FIELD_TYPE_STRING:
                        {
                            final String value = cursor.getString(i);
                            success = value != null ? window.putString(value, position, i) : window.putNull(position, i);
                            break;
                        }
                }
                if (!success) {
                    window.freeLastRow();
                    break;
                }
            }
            position += 1;
        } while (cursor.moveToNext());
    }
    cursor.moveToPosition(oldPos);
}
Body of Second Method:
{
    if (position < 0 || position >= cursor.getCount()) {
        return;
    }
    final int oldPos = cursor.getPosition();
    final int numColumns = cursor.getColumnCount();
    window.clear();
    window.setStartPosition(position);
    window.setNumColumns(numColumns);
    if (cursor.moveToPosition(position)) {
        rowloop: do {
            if (!window.allocRow()) {
                break;
            }
            for (int i = 0; i < numColumns; i++) {
                final int type = cursor.getType(i);
                final boolean success;
                switch(type) {
                    case Cursor.FIELD_TYPE_NULL:
                        success = window.putNull(position, i);
                        break;
                    case Cursor.FIELD_TYPE_INTEGER:
                        success = window.putLong(cursor.getLong(i), position, i);
                        break;
                    case Cursor.FIELD_TYPE_FLOAT:
                        success = window.putDouble(cursor.getDouble(i), position, i);
                        break;
                    case Cursor.FIELD_TYPE_BLOB:
                        {
                            final byte[] value = cursor.getBlob(i);
                            success = value != null ? window.putBlob(value, position, i) : window.putNull(position, i);
                            break;
                        }
                    // assume value is convertible to String
                    default:
                    case Cursor.FIELD_TYPE_STRING:
                        {
                            final String value = cursor.getString(i);
                            success = value != null ? window.putString(value, position, i) : window.putNull(position, i);
                            break;
                        }
                }
                if (!success) {
                    window.freeLastRow();
                    break rowloop;
                }
            }
            position += 1;
        } while (cursor.moveToNext());
    }
    cursor.moveToPosition(oldPos);
}
------------------------
Find a silently evolved API code:android.widget.ImageView.setImageBitmap:COMMENT
Method Modifier: public      
Comment:/**
 * Sets a Bitmap as the content of this ImageView.
 *
 * @param bm The bitmap to set
 */

Body of Frist Method:
{
    // if this is used frequently, may handle bitmaps explicitly
    // to reduce the intermediate drawable object
    setImageDrawable(new BitmapDrawable(mContext.getResources(), bm));
}
Body of Second Method:
{
    // Hacky fix to force setImageDrawable to do a full setImageDrawable
    // instead of doing an object reference comparison
    mDrawable = null;
    if (mRecycleableBitmapDrawable == null) {
        mRecycleableBitmapDrawable = new ImageViewBitmapDrawable(mContext.getResources(), bm);
    } else {
        mRecycleableBitmapDrawable.setBitmap(bm);
    }
    setImageDrawable(mRecycleableBitmapDrawable);
}
------------------------
Find a silently evolved API code:android.animation.AnimatorInflater.setupValues:COMMENT
Method Modifier: private     static      
Comment:/**
 * Setup ValueAnimator's values.
 * This will handle all of the integer, float and color types.
 *
 * @param anim The target Animator which will be updated.
 * @param arrayAnimator TypedArray for the ValueAnimator.
 * @param getFloats True if the value type is float.
 * @param hasFrom True if "valueFrom" exists.
 * @param fromType The type of "valueFrom".
 * @param hasTo True if "valueTo" exists.
 * @param toType The type of "valueTo".
 */

Body of Frist Method:
{
    int valueFromIndex = R.styleable.Animator_valueFrom;
    int valueToIndex = R.styleable.Animator_valueTo;
    if (getFloats) {
        float valueFrom;
        float valueTo;
        if (hasFrom) {
            if (fromType == TypedValue.TYPE_DIMENSION) {
                valueFrom = arrayAnimator.getDimension(valueFromIndex, 0f);
            } else {
                valueFrom = arrayAnimator.getFloat(valueFromIndex, 0f);
            }
            if (hasTo) {
                if (toType == TypedValue.TYPE_DIMENSION) {
                    valueTo = arrayAnimator.getDimension(valueToIndex, 0f);
                } else {
                    valueTo = arrayAnimator.getFloat(valueToIndex, 0f);
                }
                anim.setFloatValues(valueFrom, valueTo);
            } else {
                anim.setFloatValues(valueFrom);
            }
        } else {
            if (toType == TypedValue.TYPE_DIMENSION) {
                valueTo = arrayAnimator.getDimension(valueToIndex, 0f);
            } else {
                valueTo = arrayAnimator.getFloat(valueToIndex, 0f);
            }
            anim.setFloatValues(valueTo);
        }
    } else {
        int valueFrom;
        int valueTo;
        if (hasFrom) {
            if (fromType == TypedValue.TYPE_DIMENSION) {
                valueFrom = (int) arrayAnimator.getDimension(valueFromIndex, 0f);
            } else if ((fromType >= TypedValue.TYPE_FIRST_COLOR_INT) && (fromType <= TypedValue.TYPE_LAST_COLOR_INT)) {
                valueFrom = arrayAnimator.getColor(valueFromIndex, 0);
            } else {
                valueFrom = arrayAnimator.getInt(valueFromIndex, 0);
            }
            if (hasTo) {
                if (toType == TypedValue.TYPE_DIMENSION) {
                    valueTo = (int) arrayAnimator.getDimension(valueToIndex, 0f);
                } else if ((toType >= TypedValue.TYPE_FIRST_COLOR_INT) && (toType <= TypedValue.TYPE_LAST_COLOR_INT)) {
                    valueTo = arrayAnimator.getColor(valueToIndex, 0);
                } else {
                    valueTo = arrayAnimator.getInt(valueToIndex, 0);
                }
                anim.setIntValues(valueFrom, valueTo);
            } else {
                anim.setIntValues(valueFrom);
            }
        } else {
            if (hasTo) {
                if (toType == TypedValue.TYPE_DIMENSION) {
                    valueTo = (int) arrayAnimator.getDimension(valueToIndex, 0f);
                } else if ((toType >= TypedValue.TYPE_FIRST_COLOR_INT) && (toType <= TypedValue.TYPE_LAST_COLOR_INT)) {
                    valueTo = arrayAnimator.getColor(valueToIndex, 0);
                } else {
                    valueTo = arrayAnimator.getInt(valueToIndex, 0);
                }
                anim.setIntValues(valueTo);
            }
        }
    }
}
Body of Second Method:
{
    int valueFromIndex = R.styleable.Animator_valueFrom;
    int valueToIndex = R.styleable.Animator_valueTo;
    if (getFloats) {
        float valueFrom;
        float valueTo;
        if (hasFrom) {
            if (fromType == TypedValue.TYPE_DIMENSION) {
                valueFrom = arrayAnimator.getDimension(valueFromIndex, 0f);
            } else {
                valueFrom = arrayAnimator.getFloat(valueFromIndex, 0f);
            }
            if (hasTo) {
                if (toType == TypedValue.TYPE_DIMENSION) {
                    valueTo = arrayAnimator.getDimension(valueToIndex, 0f);
                } else {
                    valueTo = arrayAnimator.getFloat(valueToIndex, 0f);
                }
                anim.setFloatValues(valueFrom, valueTo);
            } else {
                anim.setFloatValues(valueFrom);
            }
        } else {
            if (toType == TypedValue.TYPE_DIMENSION) {
                valueTo = arrayAnimator.getDimension(valueToIndex, 0f);
            } else {
                valueTo = arrayAnimator.getFloat(valueToIndex, 0f);
            }
            anim.setFloatValues(valueTo);
        }
    } else {
        int valueFrom;
        int valueTo;
        if (hasFrom) {
            if (fromType == TypedValue.TYPE_DIMENSION) {
                valueFrom = (int) arrayAnimator.getDimension(valueFromIndex, 0f);
            } else if (isColorType(fromType)) {
                valueFrom = arrayAnimator.getColor(valueFromIndex, 0);
            } else {
                valueFrom = arrayAnimator.getInt(valueFromIndex, 0);
            }
            if (hasTo) {
                if (toType == TypedValue.TYPE_DIMENSION) {
                    valueTo = (int) arrayAnimator.getDimension(valueToIndex, 0f);
                } else if (isColorType(toType)) {
                    valueTo = arrayAnimator.getColor(valueToIndex, 0);
                } else {
                    valueTo = arrayAnimator.getInt(valueToIndex, 0);
                }
                anim.setIntValues(valueFrom, valueTo);
            } else {
                anim.setIntValues(valueFrom);
            }
        } else {
            if (hasTo) {
                if (toType == TypedValue.TYPE_DIMENSION) {
                    valueTo = (int) arrayAnimator.getDimension(valueToIndex, 0f);
                } else if (isColorType(toType)) {
                    valueTo = arrayAnimator.getColor(valueToIndex, 0);
                } else {
                    valueTo = arrayAnimator.getInt(valueToIndex, 0);
                }
                anim.setIntValues(valueTo);
            }
        }
    }
}
------------------------
Find a silently evolved API code:android.graphics.Canvas.drawTextOnPath:COMMENT
Method Modifier: public      
Comment:/**
 * Draw the text, with origin at (x,y), using the specified paint, along
 * the specified path. The paint's Align setting determins where along the
 * path to start the text.
 *
 * @param text     The text to be drawn
 * @param path     The path the text should follow for its baseline
 * @param hOffset  The distance along the path to add to the text's
 * starting position
 * @param vOffset  The distance above(-) or below(+) the path to position
 * the text
 * @param paint    The paint used for the text (e.g. color, size, style)
 */

Body of Frist Method:
{
    if (text.length() > 0) {
        native_drawTextOnPath(mNativeCanvasWrapper, text, path.ni(), hOffset, vOffset, paint.mBidiFlags, paint.mNativePaint, paint.mNativeTypeface);
    }
}
Body of Second Method:
{
    if (index < 0 || index + count > text.length) {
        throw new ArrayIndexOutOfBoundsException();
    }
    native_drawTextOnPath(mNativeCanvasWrapper, text, index, count, path.ni(), hOffset, vOffset, paint.mBidiFlags, paint.getNativeInstance(), paint.mNativeTypeface);
}
------------------------
Find a silently evolved API code:javax.obex.HeaderSet.getHeaderList:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Retrieves the list of headers that may be retrieved via the
 * <code>getHeader</code> method that will not return <code>null</code>. In
 * other words, this method returns all the headers that are available in
 * this object.
 * @see #getHeader
 * @return the array of headers that are set in this object or
 * <code>null</code> if no headers are available
 * @throws IOException if an error occurred in the transport layer during
 * the operation or the connection has been closed
 */

Body of Frist Method:
{
    ByteArrayOutputStream out = new ByteArrayOutputStream();
    if (mCount != null) {
        out.write(COUNT);
    }
    if (mName != null) {
        out.write(NAME);
    }
    if (mType != null) {
        out.write(TYPE);
    }
    if (mLength != null) {
        out.write(LENGTH);
    }
    if (mIsoTime != null) {
        out.write(TIME_ISO_8601);
    }
    if (mByteTime != null) {
        out.write(TIME_4_BYTE);
    }
    if (mDescription != null) {
        out.write(DESCRIPTION);
    }
    if (mTarget != null) {
        out.write(TARGET);
    }
    if (mHttpHeader != null) {
        out.write(HTTP);
    }
    if (mWho != null) {
        out.write(WHO);
    }
    if (mAppParam != null) {
        out.write(APPLICATION_PARAMETER);
    }
    if (mObjectClass != null) {
        out.write(OBJECT_CLASS);
    }
    for (int i = 0x30; i < 0x40; i++) {
        if (mUnicodeUserDefined[i - 0x30] != null) {
            out.write(i);
        }
    }
    for (int i = 0x70; i < 0x80; i++) {
        if (mSequenceUserDefined[i - 0x70] != null) {
            out.write(i);
        }
    }
    for (int i = 0xB0; i < 0xC0; i++) {
        if (mByteUserDefined[i - 0xB0] != null) {
            out.write(i);
        }
    }
    for (int i = 0xF0; i < 0x100; i++) {
        if (mIntegerUserDefined[i - 0xF0] != null) {
            out.write(i);
        }
    }
    byte[] headers = out.toByteArray();
    out.close();
    if ((headers == null) || (headers.length == 0)) {
        return null;
    }
    int[] result = new int[headers.length];
    for (int i = 0; i < headers.length; i++) {
        // Convert the byte to a positive integer.  That is, an integer
        // between 0 and 256.
        result[i] = headers[i] & 0xFF;
    }
    return result;
}
Body of Second Method:
{
    ByteArrayOutputStream out = new ByteArrayOutputStream();
    if (mCount != null) {
        out.write(COUNT);
    }
    if (mName != null) {
        out.write(NAME);
    }
    if (mType != null) {
        out.write(TYPE);
    }
    if (mLength != null) {
        out.write(LENGTH);
    }
    if (mIsoTime != null) {
        out.write(TIME_ISO_8601);
    }
    if (mByteTime != null) {
        out.write(TIME_4_BYTE);
    }
    if (mDescription != null) {
        out.write(DESCRIPTION);
    }
    if (mTarget != null) {
        out.write(TARGET);
    }
    if (mHttpHeader != null) {
        out.write(HTTP);
    }
    if (mWho != null) {
        out.write(WHO);
    }
    if (mAppParam != null) {
        out.write(APPLICATION_PARAMETER);
    }
    if (mObjectClass != null) {
        out.write(OBJECT_CLASS);
    }
    if (mSingleResponseMode != null) {
        out.write(SINGLE_RESPONSE_MODE);
    }
    if (mSrmParam != null) {
        out.write(SINGLE_RESPONSE_MODE_PARAMETER);
    }
    for (int i = 0x30; i < 0x40; i++) {
        if (mUnicodeUserDefined[i - 0x30] != null) {
            out.write(i);
        }
    }
    for (int i = 0x70; i < 0x80; i++) {
        if (mSequenceUserDefined[i - 0x70] != null) {
            out.write(i);
        }
    }
    for (int i = 0xB0; i < 0xC0; i++) {
        if (mByteUserDefined[i - 0xB0] != null) {
            out.write(i);
        }
    }
    for (int i = 0xF0; i < 0x100; i++) {
        if (mIntegerUserDefined[i - 0xF0] != null) {
            out.write(i);
        }
    }
    byte[] headers = out.toByteArray();
    out.close();
    if ((headers == null) || (headers.length == 0)) {
        return null;
    }
    int[] result = new int[headers.length];
    for (int i = 0; i < headers.length; i++) {
        // Convert the byte to a positive integer.  That is, an integer
        // between 0 and 256.
        result[i] = headers[i] & 0xFF;
    }
    return result;
}
------------------------
Find a silently evolved API code:android.content.ContentResolver.unregisterContentObserver:COMMENT
Method Modifier: public      final       
Comment:/**
 * Unregisters a change observer.
 *
 * @param observer The previously registered observer that is no longer needed.
 * @see #registerContentObserver
 */

Body of Frist Method:
{
    try {
        IContentObserver contentObserver = observer.releaseContentObserver();
        if (contentObserver != null) {
            getContentService().unregisterContentObserver(contentObserver);
        }
    } catch (RemoteException e) {
    }
}
Body of Second Method:
{
    Preconditions.checkNotNull(observer, "observer");
    try {
        IContentObserver contentObserver = observer.releaseContentObserver();
        if (contentObserver != null) {
            getContentService().unregisterContentObserver(contentObserver);
        }
    } catch (RemoteException e) {
    }
}
------------------------
Find a silently evolved API code:android.app.Instrumentation.execStartActivityAsCaller:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Special version!
 * @hide
 */

Body of Frist Method:
{
    IApplicationThread whoThread = (IApplicationThread) contextThread;
    if (mActivityMonitors != null) {
        synchronized (mSync) {
            final int N = mActivityMonitors.size();
            for (int i = 0; i < N; i++) {
                final ActivityMonitor am = mActivityMonitors.get(i);
                if (am.match(who, null, intent)) {
                    am.mHits++;
                    if (am.isBlocking()) {
                        return requestCode >= 0 ? am.getResult() : null;
                    }
                    break;
                }
            }
        }
    }
    try {
        intent.migrateExtraStreamToClipData();
        intent.prepareToLeaveProcess();
        int result = ActivityManagerNative.getDefault().startActivityAsCaller(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options, userId);
        checkStartActivityResult(result, intent);
    } catch (RemoteException e) {
    }
    return null;
}
Body of Second Method:
{
    IApplicationThread whoThread = (IApplicationThread) contextThread;
    if (mActivityMonitors != null) {
        synchronized (mSync) {
            final int N = mActivityMonitors.size();
            for (int i = 0; i < N; i++) {
                final ActivityMonitor am = mActivityMonitors.get(i);
                if (am.match(who, null, intent)) {
                    am.mHits++;
                    if (am.isBlocking()) {
                        return requestCode >= 0 ? am.getResult() : null;
                    }
                    break;
                }
            }
        }
    }
    try {
        intent.migrateExtraStreamToClipData();
        intent.prepareToLeaveProcess();
        int result = ActivityManagerNative.getDefault().startActivityAsCaller(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options, ignoreTargetSecurity, userId);
        checkStartActivityResult(result, intent);
    } catch (RemoteException e) {
        throw new RuntimeException("Failure from system", e);
    }
    return null;
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiManager.isEnhancedPowerReportingSupported:COMMENT
Method Modifier: public      
Comment:/**
 * @return true if this adapter supports advanced power/performance counters
 */

Body of Frist Method:
{
    return isFeatureSupported(WIFI_FEATURE_EPR);
}
Body of Second Method:
{
    return isFeatureSupported(WIFI_FEATURE_LINK_LAYER_STATS);
}
------------------------
Find a silently evolved API code:android.app.Fragment.onDestroy:COMMENT
Method Modifier: public      
Comment:/**
 * Called when the fragment is no longer in use.  This is called
 * after {@link #onStop()} and before {@link #onDetach()}.
 */

Body of Frist Method:
{
    mCalled = true;
    // + " mLoaderManager=" + mLoaderManager);
    if (!mCheckedForLoaderManager) {
        mCheckedForLoaderManager = true;
        mLoaderManager = mActivity.getLoaderManager(mWho, mLoadersStarted, false);
    }
    if (mLoaderManager != null) {
        mLoaderManager.doDestroy();
    }
}
Body of Second Method:
{
    mCalled = true;
    // + " mLoaderManager=" + mLoaderManager);
    if (!mCheckedForLoaderManager) {
        mCheckedForLoaderManager = true;
        mLoaderManager = mHost.getLoaderManager(mWho, mLoadersStarted, false);
    }
    if (mLoaderManager != null) {
        mLoaderManager.doDestroy();
    }
}
------------------------
Find a silently evolved API code:android.webkit.WebView.clearClientCertPreferences:COMMENT
Method Modifier: public      static      
Comment:/**
 * Clears the client certificate preferences stored in response
 * to proceeding/cancelling client cert requests. Note that Webview
 * automatically clears these preferences when it receives a
 * {@link KeyChain#ACTION_STORAGE_CHANGED} intent. The preferences are
 * shared by all the webviews that are created by the embedder application.
 *
 * @param onCleared  A runnable to be invoked when client certs are cleared.
 * The embedder can pass null if not interested in the
 * callback. The runnable will be called in UI thread.
 */

Body of Frist Method:
{
    if (TRACE)
        Log.d(LOGTAG, "clearClientCertPreferences");
    getFactory().getStatics().clearClientCertPreferences(onCleared);
}
Body of Second Method:
{
    getFactory().getStatics().clearClientCertPreferences(onCleared);
}
------------------------
Find a silently evolved API code:android.graphics.Bitmap.setPremultiplied:COMMENT
Method Modifier: public      final       
Comment:/**
 * Sets whether the bitmap should treat its data as pre-multiplied.
 *
 * <p>Bitmaps are always treated as pre-multiplied by the view system and
 * {@link Canvas} for performance reasons. Storing un-pre-multiplied data in
 * a Bitmap (through {@link #setPixel}, {@link #setPixels}, or {@link
 * BitmapFactory.Options#inPremultiplied BitmapFactory.Options.inPremultiplied})
 * can lead to incorrect blending if drawn by the framework.</p>
 *
 * <p>This method will not affect the behavior of a bitmap without an alpha
 * channel, or if {@link #hasAlpha()} returns false.</p>
 *
 * <p>Calling {@link #createBitmap} or {@link #createScaledBitmap} with a source
 * Bitmap whose colors are not pre-multiplied may result in a RuntimeException,
 * since those functions require drawing the source, which is not supported for
 * un-pre-multiplied Bitmaps.</p>
 *
 * @see Bitmap#isPremultiplied()
 * @see BitmapFactory.Options#inPremultiplied
 */

Body of Frist Method:
{
    mRequestPremultiplied = premultiplied;
    nativeSetPremultiplied(mNativeBitmap, premultiplied);
}
Body of Second Method:
{
    checkRecycled("setPremultiplied called on a recycled bitmap");
    mRequestPremultiplied = premultiplied;
    nativeSetPremultiplied(mFinalizer.mNativeBitmap, premultiplied);
}
------------------------
Find a silently evolved API code:android.view.accessibility.AccessibilityRecord.init:COMMENT
Method Modifier: default     
Comment:/**
 * Initialize this record from another one.
 *
 * @param record The to initialize from.
 */

Body of Frist Method:
{
    mSealed = record.mSealed;
    mBooleanProperties = record.mBooleanProperties;
    mCurrentItemIndex = record.mCurrentItemIndex;
    mItemCount = record.mItemCount;
    mFromIndex = record.mFromIndex;
    mToIndex = record.mToIndex;
    mScrollX = record.mScrollX;
    mScrollY = record.mScrollY;
    mMaxScrollX = record.mMaxScrollX;
    mMaxScrollY = record.mMaxScrollY;
    mAddedCount = record.mAddedCount;
    mRemovedCount = record.mRemovedCount;
    mClassName = record.mClassName;
    mContentDescription = record.mContentDescription;
    mBeforeText = record.mBeforeText;
    mParcelableData = record.mParcelableData;
    mText.addAll(record.mText);
    mSourceWindowId = record.mSourceWindowId;
    mSourceNodeId = record.mSourceNodeId;
    mConnectionId = record.mConnectionId;
}
Body of Second Method:
{
    mSealed = record.mSealed;
    mBooleanProperties = record.mBooleanProperties;
    mCurrentItemIndex = record.mCurrentItemIndex;
    mItemCount = record.mItemCount;
    mFromIndex = record.mFromIndex;
    mToIndex = record.mToIndex;
    mScrollX = record.mScrollX;
    mScrollY = record.mScrollY;
    mMaxScrollX = record.mMaxScrollX;
    mMaxScrollY = record.mMaxScrollY;
    mAddedCount = record.mAddedCount;
    mRemovedCount = record.mRemovedCount;
    mClassName = record.mClassName;
    mContentDescription = record.mContentDescription;
    mBeforeText = record.mBeforeText;
    mParcelableData = record.mParcelableData;
    mText.addAll(record.mText);
    mSourceWindowId = record.mSourceWindowId;
    if (record.mSourceNode != null) {
        mSourceNode = AccessibilityNodeInfo.obtain(record.mSourceNode);
    }
    mConnectionId = record.mConnectionId;
}
------------------------
Find a silently evolved API code:android.net.VpnService.prepare:COMMENT
Method Modifier: public      static      
Comment:/**
 * Prepare to establish a VPN connection. This method returns {@code null}
 * if the VPN application is already prepared or if the user has previously
 * consented to the VPN application. Otherwise, it returns an
 * {@link Intent} to a system activity. The application should launch the
 * activity using {@link Activity#startActivityForResult} to get itself
 * prepared. The activity may pop up a dialog to require user action, and
 * the result will come back via its {@link Activity#onActivityResult}.
 * If the result is {@link Activity#RESULT_OK}, the application becomes
 * prepared and is granted to use other methods in this class.
 *
 * <p>Only one application can be granted at the same time. The right
 * is revoked when another application is granted. The application
 * losing the right will be notified via its {@link #onRevoke}. Unless
 * it becomes prepared again, subsequent calls to other methods in this
 * class will fail.
 *
 * <p>The user may disable the VPN at any time while it is activated, in
 * which case this method will return an intent the next time it is
 * executed to obtain the user's consent again.
 *
 * @see #onRevoke
 */

Body of Frist Method:
{
    try {
        if (getService().prepareVpn(context.getPackageName(), null)) {
            return null;
        }
    } catch (RemoteException e) {
    // ignore
    }
    return VpnConfig.getIntentForConfirmation();
}
Body of Second Method:
{
    try {
        if (getService().prepareVpn(context.getPackageName(), null, UserHandle.myUserId())) {
            return null;
        }
    } catch (RemoteException e) {
    // ignore
    }
    return VpnConfig.getIntentForConfirmation();
}
------------------------
Find a silently evolved API code:android.bluetooth.le.ScanSettings.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Build {@link ScanSettings}.
 */

Body of Frist Method:
{
    return new ScanSettings(mScanMode, mCallbackType, mScanResultType, mReportDelayMillis);
}
Body of Second Method:
{
    return new ScanSettings(mScanMode, mCallbackType, mScanResultType, mReportDelayMillis, mMatchMode, mNumOfMatchesPerFilter);
}
------------------------
Find a silently evolved API code:android.graphics.Picture.draw:COMMENT
Method Modifier: public      
Comment:/**
 * Draw this picture on the canvas.
 * <p>
 * Prior to {@link android.os.Build.VERSION_CODES#LOLLIPOP}, this call could
 * have the side effect of changing the matrix and clip of the canvas
 * if this picture had imbalanced saves/restores.
 *
 * <p>
 * <strong>Note:</strong> This forces the picture to internally call
 * {@link Picture#endRecording()} in order to prepare for playback.
 *
 * @param canvas  The picture is drawn to this canvas
 */

Body of Frist Method:
{
    if (canvas.isHardwareAccelerated()) {
        throw new IllegalArgumentException("Picture playback is only supported on software canvas.");
    }
    if (mRecordingCanvas != null) {
        endRecording();
    }
    nativeDraw(canvas.getNativeCanvasWrapper(), mNativePicture);
}
Body of Second Method:
{
    if (mRecordingCanvas != null) {
        endRecording();
    }
    nativeDraw(canvas.getNativeCanvasWrapper(), mNativePicture);
}
------------------------
Find a silently evolved API code:android.location.LocationRequest.createFromDeprecatedCriteria:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (minTime < 0)
        minTime = 0;
    if (minDistance < 0)
        minDistance = 0;
    int quality;
    switch(criteria.getAccuracy()) {
        case Criteria.ACCURACY_COARSE:
            quality = ACCURACY_BLOCK;
            break;
        case Criteria.ACCURACY_FINE:
            quality = ACCURACY_FINE;
            break;
        default:
            {
                switch(criteria.getPowerRequirement()) {
                    case Criteria.POWER_HIGH:
                        quality = POWER_HIGH;
                    default:
                        quality = POWER_LOW;
                }
            }
    }
    LocationRequest request = new LocationRequest().setQuality(quality).setInterval(minTime).setFastestInterval(minTime).setSmallestDisplacement(minDistance);
    if (singleShot)
        request.setNumUpdates(1);
    return request;
}
Body of Second Method:
{
    if (minTime < 0)
        minTime = 0;
    if (minDistance < 0)
        minDistance = 0;
    int quality;
    switch(criteria.getAccuracy()) {
        case Criteria.ACCURACY_COARSE:
            quality = ACCURACY_BLOCK;
            break;
        case Criteria.ACCURACY_FINE:
            quality = ACCURACY_FINE;
            break;
        default:
            {
                switch(criteria.getPowerRequirement()) {
                    case Criteria.POWER_HIGH:
                        quality = POWER_HIGH;
                        break;
                    default:
                        quality = POWER_LOW;
                }
            }
    }
    LocationRequest request = new LocationRequest().setQuality(quality).setInterval(minTime).setFastestInterval(minTime).setSmallestDisplacement(minDistance);
    if (singleShot)
        request.setNumUpdates(1);
    return request;
}
------------------------
Find a silently evolved API code:android.content.ClipDescription.toShortString:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    boolean first = true;
    for (int i = 0; i < mMimeTypes.length; i++) {
        if (!first) {
            b.append(' ');
        }
        first = false;
        b.append(mMimeTypes[i]);
    }
    if (mLabel != null) {
        if (!first) {
            b.append(' ');
        }
        first = false;
        b.append('"');
        b.append(mLabel);
        b.append('"');
    }
    return !first;
}
Body of Second Method:
{
    boolean first = !toShortStringTypesOnly(b);
    if (mLabel != null) {
        if (!first) {
            b.append(' ');
        }
        first = false;
        b.append('"');
        b.append(mLabel);
        b.append('"');
    }
    return !first;
}
------------------------
Find a silently evolved API code:android.print.PrinterCapabilitiesInfo.Builder.setColorModes:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the color modes.
 * <p>
 * <strong>Required:</strong> Yes
 * </p>
 *
 * @param colorModes The color mode bit mask.
 * @param defaultColorMode The default color mode.
 * @return This builder.
 * <p>
 * <strong>Note:</strong> On platform version 19 (Kitkat) specifying
 * only PrintAttributes#COLOR_MODE_MONOCHROME leads to a print spooler
 * crash. Hence, you should declare either both color modes or
 * PrintAttributes#COLOR_MODE_COLOR.
 * </p>
 *
 * @throws IllegalArgumentException If color modes contains an invalid
 * mode bit or if the default color mode is invalid.
 *
 * @see PrintAttributes#COLOR_MODE_COLOR
 * @see PrintAttributes#COLOR_MODE_MONOCHROME
 */

Body of Frist Method:
{
    int currentModes = colorModes;
    while (currentModes > 0) {
        final int currentMode = (1 << Integer.numberOfTrailingZeros(currentModes));
        currentModes &= ~currentMode;
        PrintAttributes.enforceValidColorMode(currentMode);
    }
    if ((colorModes & defaultColorMode) == 0) {
        throw new IllegalArgumentException("Default color mode not in color modes.");
    }
    PrintAttributes.enforceValidColorMode(colorModes);
    mPrototype.mColorModes = colorModes;
    mPrototype.mDefaults[PROPERTY_COLOR_MODE] = defaultColorMode;
    return this;
}
Body of Second Method:
{
    int currentModes = colorModes;
    while (currentModes > 0) {
        final int currentMode = (1 << Integer.numberOfTrailingZeros(currentModes));
        currentModes &= ~currentMode;
        PrintAttributes.enforceValidColorMode(currentMode);
    }
    PrintAttributes.enforceValidColorMode(defaultColorMode);
    mPrototype.mColorModes = colorModes;
    mPrototype.mDefaults[PROPERTY_COLOR_MODE] = defaultColorMode;
    return this;
}
------------------------
Find a silently evolved API code:android.graphics.Paint.reset:COMMENT
Method Modifier: public      
Comment:/**
 * Restores the paint to its default settings.
 */

Body of Frist Method:
{
    native_reset(mNativePaint);
    setFlags(DEFAULT_PAINT_FLAGS);
    // TODO: Turning off hinting has undesirable side effects, we need to
    // revisit hinting once we add support for subpixel positioning
    // setHinting(DisplayMetrics.DENSITY_DEVICE >= DisplayMetrics.DENSITY_TV
    // ? HINTING_OFF : HINTING_ON);
    mColorFilter = null;
    mMaskFilter = null;
    mPathEffect = null;
    mRasterizer = null;
    mShader = null;
    mTypeface = null;
    mNativeTypeface = 0;
    mXfermode = null;
    mHasCompatScaling = false;
    mCompatScaling = 1;
    mInvCompatScaling = 1;
    mBidiFlags = BIDI_DEFAULT_LTR;
    setTextLocale(Locale.getDefault());
    setElegantTextHeight(false);
    mFontFeatureSettings = null;
}
Body of Second Method:
{
    native_reset(mNativePaint);
    setFlags(HIDDEN_DEFAULT_PAINT_FLAGS);
    // TODO: Turning off hinting has undesirable side effects, we need to
    // revisit hinting once we add support for subpixel positioning
    // setHinting(DisplayMetrics.DENSITY_DEVICE >= DisplayMetrics.DENSITY_TV
    // ? HINTING_OFF : HINTING_ON);
    mColorFilter = null;
    mMaskFilter = null;
    mPathEffect = null;
    mRasterizer = null;
    mShader = null;
    mNativeShader = 0;
    mTypeface = null;
    mNativeTypeface = 0;
    mXfermode = null;
    mHasCompatScaling = false;
    mCompatScaling = 1;
    mInvCompatScaling = 1;
    mBidiFlags = BIDI_DEFAULT_LTR;
    setTextLocale(Locale.getDefault());
    setElegantTextHeight(false);
    mFontFeatureSettings = null;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothDevice.fetchUuidsWithSdp:COMMENT
Method Modifier: public      
Comment:/**
 * Perform a service discovery on the remote device to get the UUIDs supported.
 *
 * <p>This API is asynchronous and {@link #ACTION_UUID} intent is sent,
 * with the UUIDs supported by the remote end. If there is an error
 * in getting the SDP records or if the process takes a long time,
 * {@link #ACTION_UUID} intent is sent with the UUIDs that is currently
 * present in the cache. Clients should use the {@link #getUuids} to get UUIDs
 * if service discovery is not to be performed.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}.
 *
 * @return False if the sanity check fails, True if the process
 * of initiating an ACL connection to the remote device
 * was started.
 */

Body of Frist Method:
{
    IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, "BT not enabled. Cannot fetchUuidsWithSdp");
        return false;
    }
    try {
        return service.fetchRemoteUuids(this);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
Body of Second Method:
{
    IBluetooth service = sService;
    if (service == null || isBluetoothEnabled() == false) {
        Log.e(TAG, "BT not enabled. Cannot fetchUuidsWithSdp");
        return false;
    }
    try {
        return service.fetchRemoteUuids(this);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
------------------------
Find a silently evolved API code:android.widget.TimePickerClockDelegate.setCurrentItemShowing:COMMENT
Method Modifier: private     
Comment:/**
 * Show either Hours or Minutes.
 */

Body of Frist Method:
{
    mRadialTimePickerView.setCurrentItemShowing(index, animateCircle);
    if (index == HOUR_INDEX) {
        if (announce) {
            mDelegator.announceForAccessibility(mSelectHours);
        }
    } else {
        if (announce) {
            mDelegator.announceForAccessibility(mSelectMinutes);
        }
    }
    mHourView.setSelected(index == HOUR_INDEX);
    mMinuteView.setSelected(index == MINUTE_INDEX);
}
Body of Second Method:
{
    mRadialTimePickerView.setCurrentItemShowing(index, animateCircle);
    if (index == HOUR_INDEX) {
        if (announce) {
            mDelegator.announceForAccessibility(mSelectHours);
        }
    } else {
        if (announce) {
            mDelegator.announceForAccessibility(mSelectMinutes);
        }
    }
    mHourView.setActivated(index == HOUR_INDEX);
    mMinuteView.setActivated(index == MINUTE_INDEX);
}
------------------------
Find a silently evolved API code:android.view.accessibility.AccessibilityRecord.setConnectionId:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets the unique id of the IAccessibilityServiceConnection over which
 * this instance can send requests to the system.
 *
 * @param connectionId The connection id.
 *
 * @hide
 */

Body of Frist Method:
{
    enforceNotSealed();
    mConnectionId = connectionId;
}
Body of Second Method:
{
    enforceNotSealed();
    mConnectionId = connectionId;
    if (mSourceNode != null) {
        mSourceNode.setConnectionId(mConnectionId);
    }
}
------------------------
Find a silently evolved API code:android.media.audiofx.Virtualizer.forceVirtualizationMode:COMMENT
Method Modifier: public      
Comment:/**
 * Forces the virtualizer effect to use the given processing mode.
 * The effect must be enabled for the forced mode to be applied.
 * @param virtualizationMode one of {@link #VIRTUALIZATION_MODE_BINAURAL},
 * {@link #VIRTUALIZATION_MODE_TRANSAURAL} to force a particular processing mode, or
 * {@value #VIRTUALIZATION_MODE_AUTO} to stop forcing a mode.
 * @return true if the processing mode is supported, and it is successfully set, or
 * forcing was successfully disabled, false otherwise.
 * @throws IllegalStateException
 * @throws IllegalArgumentException
 * @throws UnsupportedOperationException
 */

Body of Frist Method:
{
    // convert Java device type to internal representation
    int deviceType = getDeviceForModeForce(virtualizationMode);
    int internalDevice = AudioDevice.convertDeviceTypeToInternalDevice(deviceType);
    int status = setParameter(PARAM_FORCE_VIRTUALIZATION_MODE, internalDevice);
    if (status >= 0) {
        return true;
    } else if (status == AudioEffect.ERROR_BAD_VALUE) {
        // don't throw an exception, just return false
        return false;
    } else {
        // something wrong may have happened
        checkStatus(status);
    }
    // unexpected virtualizer behavior
    Log.e(TAG, "unexpected status code " + status + " after setParameter(PARAM_FORCE_VIRTUALIZATION_MODE)");
    return false;
}
Body of Second Method:
{
    // convert Java device type to internal representation
    int deviceType = getDeviceForModeForce(virtualizationMode);
    int internalDevice = AudioDeviceInfo.convertDeviceTypeToInternalDevice(deviceType);
    int status = setParameter(PARAM_FORCE_VIRTUALIZATION_MODE, internalDevice);
    if (status >= 0) {
        return true;
    } else if (status == AudioEffect.ERROR_BAD_VALUE) {
        // don't throw an exception, just return false
        return false;
    } else {
        // something wrong may have happened
        checkStatus(status);
    }
    // unexpected virtualizer behavior
    Log.e(TAG, "unexpected status code " + status + " after setParameter(PARAM_FORCE_VIRTUALIZATION_MODE)");
    return false;
}
------------------------
Find a silently evolved API code:android.widget.TextView.performAccessibilityActionInternal:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Performs an accessibility action after it has been offered to the
 * delegate.
 *
 * @hide
 */

Body of Frist Method:
{
    switch(action) {
        case AccessibilityNodeInfo.ACTION_CLICK:
            {
                boolean handled = false;
                // Simulate View.onTouchEvent for an ACTION_UP event.
                if (isClickable() || isLongClickable()) {
                    if (isFocusable() && !isFocused()) {
                        requestFocus();
                    }
                    performClick();
                    handled = true;
                }
                // Simulate TextView.onTouchEvent for an ACTION_UP event.
                if ((mMovement != null || onCheckIsTextEditor()) && isEnabled() && mText instanceof Spannable && mLayout != null && (isTextEditable() || isTextSelectable()) && isFocused()) {
                    // Show the IME, except when selecting in read-only text.
                    final InputMethodManager imm = InputMethodManager.peekInstance();
                    viewClicked(imm);
                    if (!isTextSelectable() && mEditor.mShowSoftInputOnFocus && imm != null) {
                        handled |= imm.showSoftInput(this, 0);
                    }
                }
                return handled;
            }
        case AccessibilityNodeInfo.ACTION_COPY:
            {
                if (isFocused() && canCopy()) {
                    if (onTextContextMenuItem(ID_COPY)) {
                        return true;
                    }
                }
            }
            return false;
        case AccessibilityNodeInfo.ACTION_PASTE:
            {
                if (isFocused() && canPaste()) {
                    if (onTextContextMenuItem(ID_PASTE)) {
                        return true;
                    }
                }
            }
            return false;
        case AccessibilityNodeInfo.ACTION_CUT:
            {
                if (isFocused() && canCut()) {
                    if (onTextContextMenuItem(ID_CUT)) {
                        return true;
                    }
                }
            }
            return false;
        case AccessibilityNodeInfo.ACTION_SET_SELECTION:
            {
                if (isFocused() && canSelectText()) {
                    ensureIterableTextForAccessibilitySelectable();
                    CharSequence text = getIterableTextForAccessibility();
                    if (text == null) {
                        return false;
                    }
                    final int start = (arguments != null) ? arguments.getInt(AccessibilityNodeInfo.ACTION_ARGUMENT_SELECTION_START_INT, -1) : -1;
                    final int end = (arguments != null) ? arguments.getInt(AccessibilityNodeInfo.ACTION_ARGUMENT_SELECTION_END_INT, -1) : -1;
                    if ((getSelectionStart() != start || getSelectionEnd() != end)) {
                        // No arguments clears the selection.
                        if (start == end && end == -1) {
                            Selection.removeSelection((Spannable) text);
                            return true;
                        }
                        if (start >= 0 && start <= end && end <= text.length()) {
                            Selection.setSelection((Spannable) text, start, end);
                            // Make sure selection mode is engaged.
                            if (mEditor != null) {
                                mEditor.startSelectionActionMode();
                            }
                            return true;
                        }
                    }
                }
            }
            return false;
        case AccessibilityNodeInfo.ACTION_NEXT_AT_MOVEMENT_GRANULARITY:
        case AccessibilityNodeInfo.ACTION_PREVIOUS_AT_MOVEMENT_GRANULARITY:
            {
                ensureIterableTextForAccessibilitySelectable();
                return super.performAccessibilityActionInternal(action, arguments);
            }
        default:
            {
                return super.performAccessibilityActionInternal(action, arguments);
            }
    }
}
Body of Second Method:
{
    if (mEditor != null && mEditor.mProcessTextIntentActionsHandler.performAccessibilityAction(action)) {
        return true;
    }
    switch(action) {
        case AccessibilityNodeInfo.ACTION_CLICK:
            {
                boolean handled = false;
                // Simulate View.onTouchEvent for an ACTION_UP event.
                if (isClickable() || isLongClickable()) {
                    if (isFocusable() && !isFocused()) {
                        requestFocus();
                    }
                    performClick();
                    handled = true;
                }
                // Simulate TextView.onTouchEvent for an ACTION_UP event.
                if ((mMovement != null || onCheckIsTextEditor()) && isEnabled() && mText instanceof Spannable && mLayout != null && (isTextEditable() || isTextSelectable()) && isFocused()) {
                    // Show the IME, except when selecting in read-only text.
                    final InputMethodManager imm = InputMethodManager.peekInstance();
                    viewClicked(imm);
                    if (!isTextSelectable() && mEditor.mShowSoftInputOnFocus && imm != null) {
                        handled |= imm.showSoftInput(this, 0);
                    }
                }
                return handled;
            }
        case AccessibilityNodeInfo.ACTION_COPY:
            {
                if (isFocused() && canCopy()) {
                    if (onTextContextMenuItem(ID_COPY)) {
                        return true;
                    }
                }
            }
            return false;
        case AccessibilityNodeInfo.ACTION_PASTE:
            {
                if (isFocused() && canPaste()) {
                    if (onTextContextMenuItem(ID_PASTE)) {
                        return true;
                    }
                }
            }
            return false;
        case AccessibilityNodeInfo.ACTION_CUT:
            {
                if (isFocused() && canCut()) {
                    if (onTextContextMenuItem(ID_CUT)) {
                        return true;
                    }
                }
            }
            return false;
        case AccessibilityNodeInfo.ACTION_SET_SELECTION:
            {
                ensureIterableTextForAccessibilitySelectable();
                CharSequence text = getIterableTextForAccessibility();
                if (text == null) {
                    return false;
                }
                final int start = (arguments != null) ? arguments.getInt(AccessibilityNodeInfo.ACTION_ARGUMENT_SELECTION_START_INT, -1) : -1;
                final int end = (arguments != null) ? arguments.getInt(AccessibilityNodeInfo.ACTION_ARGUMENT_SELECTION_END_INT, -1) : -1;
                if ((getSelectionStart() != start || getSelectionEnd() != end)) {
                    // No arguments clears the selection.
                    if (start == end && end == -1) {
                        Selection.removeSelection((Spannable) text);
                        return true;
                    }
                    if (start >= 0 && start <= end && end <= text.length()) {
                        Selection.setSelection((Spannable) text, start, end);
                        // Make sure selection mode is engaged.
                        if (mEditor != null) {
                            mEditor.startSelectionActionMode();
                        }
                        return true;
                    }
                }
            }
            return false;
        case AccessibilityNodeInfo.ACTION_NEXT_AT_MOVEMENT_GRANULARITY:
        case AccessibilityNodeInfo.ACTION_PREVIOUS_AT_MOVEMENT_GRANULARITY:
            {
                ensureIterableTextForAccessibilitySelectable();
                return super.performAccessibilityActionInternal(action, arguments);
            }
        case ACCESSIBILITY_ACTION_SHARE:
            {
                if (isFocused() && canShare()) {
                    if (onTextContextMenuItem(ID_SHARE)) {
                        return true;
                    }
                }
            }
            return false;
        default:
            {
                return super.performAccessibilityActionInternal(action, arguments);
            }
    }
}
------------------------
Find a silently evolved API code:android.app.Instrumentation.execStartActivityFromAppTask:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Special version!
 * @hide
 */

Body of Frist Method:
{
    IApplicationThread whoThread = (IApplicationThread) contextThread;
    if (mActivityMonitors != null) {
        synchronized (mSync) {
            final int N = mActivityMonitors.size();
            for (int i = 0; i < N; i++) {
                final ActivityMonitor am = mActivityMonitors.get(i);
                if (am.match(who, null, intent)) {
                    am.mHits++;
                    if (am.isBlocking()) {
                        return;
                    }
                    break;
                }
            }
        }
    }
    try {
        intent.migrateExtraStreamToClipData();
        intent.prepareToLeaveProcess();
        int result = appTask.startActivity(whoThread.asBinder(), who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), options);
        checkStartActivityResult(result, intent);
    } catch (RemoteException e) {
    }
    return;
}
Body of Second Method:
{
    IApplicationThread whoThread = (IApplicationThread) contextThread;
    if (mActivityMonitors != null) {
        synchronized (mSync) {
            final int N = mActivityMonitors.size();
            for (int i = 0; i < N; i++) {
                final ActivityMonitor am = mActivityMonitors.get(i);
                if (am.match(who, null, intent)) {
                    am.mHits++;
                    if (am.isBlocking()) {
                        return;
                    }
                    break;
                }
            }
        }
    }
    try {
        intent.migrateExtraStreamToClipData();
        intent.prepareToLeaveProcess();
        int result = appTask.startActivity(whoThread.asBinder(), who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), options);
        checkStartActivityResult(result, intent);
    } catch (RemoteException e) {
        throw new RuntimeException("Failure from system", e);
    }
    return;
}
------------------------
Find a silently evolved API code:android.graphics.Canvas.drawBitmapMesh:COMMENT
Method Modifier: public      
Comment:/**
 * Draw the bitmap through the mesh, where mesh vertices are evenly
 * distributed across the bitmap. There are meshWidth+1 vertices across, and
 * meshHeight+1 vertices down. The verts array is accessed in row-major
 * order, so that the first meshWidth+1 vertices are distributed across the
 * top of the bitmap from left to right. A more general version of this
 * method is drawVertices().
 *
 * @param bitmap The bitmap to draw using the mesh
 * @param meshWidth The number of columns in the mesh. Nothing is drawn if
 * this is 0
 * @param meshHeight The number of rows in the mesh. Nothing is drawn if
 * this is 0
 * @param verts Array of x,y pairs, specifying where the mesh should be
 * drawn. There must be at least
 * (meshWidth+1) * (meshHeight+1) * 2 + vertOffset values
 * in the array
 * @param vertOffset Number of verts elements to skip before drawing
 * @param colors May be null. Specifies a color at each vertex, which is
 * interpolated across the cell, and whose values are
 * multiplied by the corresponding bitmap colors. If not null,
 * there must be at least (meshWidth+1) * (meshHeight+1) +
 * colorOffset values in the array.
 * @param colorOffset Number of color elements to skip before drawing
 * @param paint  May be null. The paint used to draw the bitmap
 */

Body of Frist Method:
{
    if ((meshWidth | meshHeight | vertOffset | colorOffset) < 0) {
        throw new ArrayIndexOutOfBoundsException();
    }
    if (meshWidth == 0 || meshHeight == 0) {
        return;
    }
    int count = (meshWidth + 1) * (meshHeight + 1);
    // we mul by 2 since we need two floats per vertex
    checkRange(verts.length, vertOffset, count * 2);
    if (colors != null) {
        // no mul by 2, since we need only 1 color per vertex
        checkRange(colors.length, colorOffset, count);
    }
    nativeDrawBitmapMesh(mNativeCanvasWrapper, bitmap.ni(), meshWidth, meshHeight, verts, vertOffset, colors, colorOffset, paint != null ? paint.mNativePaint : 0);
}
Body of Second Method:
{
    if ((meshWidth | meshHeight | vertOffset | colorOffset) < 0) {
        throw new ArrayIndexOutOfBoundsException();
    }
    if (meshWidth == 0 || meshHeight == 0) {
        return;
    }
    int count = (meshWidth + 1) * (meshHeight + 1);
    // we mul by 2 since we need two floats per vertex
    checkRange(verts.length, vertOffset, count * 2);
    if (colors != null) {
        // no mul by 2, since we need only 1 color per vertex
        checkRange(colors.length, colorOffset, count);
    }
    nativeDrawBitmapMesh(mNativeCanvasWrapper, bitmap, meshWidth, meshHeight, verts, vertOffset, colors, colorOffset, paint != null ? paint.getNativeInstance() : 0);
}
------------------------
Find a silently evolved API code:javax.obex.ClientOperation.abort:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sends an ABORT message to the server. By calling this method, the
 * corresponding input and output streams will be closed along with this
 * object.
 * @throws IOException if the transaction has already ended or if an OBEX
 * server called this method
 */

Body of Frist Method:
{
    ensureOpen();
    // no compatible with sun-ri
    if ((mOperationDone) && (mReplyHeader.responseCode != ResponseCodes.OBEX_HTTP_CONTINUE)) {
        throw new IOException("Operation has already ended");
    }
    mExceptionMessage = "Operation aborted";
    if ((!mOperationDone) && (mReplyHeader.responseCode == ResponseCodes.OBEX_HTTP_CONTINUE)) {
        mOperationDone = true;
        /*
             * Since we are not sending any headers or returning any headers then
             * we just need to write and read the same bytes
             */
        mParent.sendRequest(ObexHelper.OBEX_OPCODE_ABORT, null, mReplyHeader, null);
        if (mReplyHeader.responseCode != ResponseCodes.OBEX_HTTP_OK) {
            throw new IOException("Invalid response code from server");
        }
        mExceptionMessage = null;
    }
    close();
}
Body of Second Method:
{
    ensureOpen();
    // no compatible with sun-ri
    if ((mOperationDone) && (mReplyHeader.responseCode != ResponseCodes.OBEX_HTTP_CONTINUE)) {
        throw new IOException("Operation has already ended");
    }
    mExceptionMessage = "Operation aborted";
    if ((!mOperationDone) && (mReplyHeader.responseCode == ResponseCodes.OBEX_HTTP_CONTINUE)) {
        mOperationDone = true;
        /*
             * Since we are not sending any headers or returning any headers then
             * we just need to write and read the same bytes
             */
        mParent.sendRequest(ObexHelper.OBEX_OPCODE_ABORT, null, mReplyHeader, null, false);
        if (mReplyHeader.responseCode != ResponseCodes.OBEX_HTTP_OK) {
            throw new IOException("Invalid response code from server");
        }
        mExceptionMessage = null;
    }
    close();
}
------------------------
Find a silently evolved API code:android.app.Notification.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Combine all of the options that have been set and return a new {@link Notification}
 * object.
 */

Body of Frist Method:
{
    mOriginatingUserId = mContext.getUserId();
    mHasThreeLines = hasThreeLines();
    Notification n = buildUnstyled();
    if (mStyle != null) {
        n = mStyle.buildStyled(n);
    }
    if (mExtras != null) {
        n.extras.putAll(mExtras);
    }
    if (mRebuildBundle.size() > 0) {
        n.extras.putAll(mRebuildBundle);
        mRebuildBundle.clear();
    }
    populateExtras(n.extras);
    if (mStyle != null) {
        mStyle.addExtras(n.extras);
    }
    mHasThreeLines = false;
    return n;
}
Body of Second Method:
{
    if (mSmallIcon != null) {
        mSmallIcon.convertToAshmem();
    }
    if (mLargeIcon != null) {
        mLargeIcon.convertToAshmem();
    }
    mOriginatingUserId = mContext.getUserId();
    mHasThreeLines = hasThreeLines();
    Notification n = buildUnstyled();
    if (mStyle != null) {
        mStyle.purgeResources();
        n = mStyle.buildStyled(n);
    }
    if (mExtras != null) {
        n.extras.putAll(mExtras);
    }
    if (mRebuildBundle.size() > 0) {
        n.extras.putAll(mRebuildBundle);
        mRebuildBundle.clear();
    }
    populateExtras(n.extras);
    if (mStyle != null) {
        mStyle.addExtras(n.extras);
    }
    mHasThreeLines = false;
    return n;
}
------------------------
Find a silently evolved API code:android.graphics.NinePatch.getTransparentRegion:COMMENT
Method Modifier: public      final       
Comment:/**
 * Returns a {@link Region} representing the parts of the NinePatch that are
 * completely transparent.
 *
 * @param bounds The location and size of the NinePatch.
 *
 * @return null if the NinePatch has no transparent region to
 * report, else a {@link Region} holding the parts of the specified bounds
 * that are transparent.
 */

Body of Frist Method:
{
    long r = nativeGetTransparentRegion(mBitmap.ni(), mNativeChunk, bounds);
    return r != 0 ? new Region(r) : null;
}
Body of Second Method:
{
    long r = nativeGetTransparentRegion(mBitmap, mNativeChunk, bounds);
    return r != 0 ? new Region(r) : null;
}
------------------------
Find a silently evolved API code:android.location.GpsMeasurement.getLossOfLockString:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Gets a string representation of the 'loss of lock'.
 * For internal and logging use only.
 */

Body of Frist Method:
{
    switch(mLossOfLock) {
        case LOSS_OF_LOCK_UNKNOWN:
            return "Unknown";
        case LOSS_OF_LOCK_OK:
            return "Ok";
        case LOSS_OF_LOCK_CYCLE_SLIP:
            return "CycleSlip";
        default:
            return "<Invalid>";
    }
}
Body of Second Method:
{
    switch(mLossOfLock) {
        case LOSS_OF_LOCK_UNKNOWN:
            return "Unknown";
        case LOSS_OF_LOCK_OK:
            return "Ok";
        case LOSS_OF_LOCK_CYCLE_SLIP:
            return "CycleSlip";
        default:
            return "<Invalid:" + mLossOfLock + ">";
    }
}
------------------------
Find a silently evolved API code:android.app.Instrumentation.checkStartActivityResult:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (res >= ActivityManager.START_SUCCESS) {
        return;
    }
    switch(res) {
        case ActivityManager.START_INTENT_NOT_RESOLVED:
        case ActivityManager.START_CLASS_NOT_FOUND:
            if (intent instanceof Intent && ((Intent) intent).getComponent() != null)
                throw new ActivityNotFoundException("Unable to find explicit activity class " + ((Intent) intent).getComponent().toShortString() + "; have you declared this activity in your AndroidManifest.xml?");
            throw new ActivityNotFoundException("No Activity found to handle " + intent);
        case ActivityManager.START_PERMISSION_DENIED:
            throw new SecurityException("Not allowed to start activity " + intent);
        case ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT:
            throw new AndroidRuntimeException("FORWARD_RESULT_FLAG used while also requesting a result");
        case ActivityManager.START_NOT_ACTIVITY:
            throw new IllegalArgumentException("PendingIntent is not an activity");
        case ActivityManager.START_NOT_VOICE_COMPATIBLE:
            throw new SecurityException("Starting under voice control not allowed for: " + intent);
        default:
            throw new AndroidRuntimeException("Unknown error code " + res + " when starting " + intent);
    }
}
Body of Second Method:
{
    if (res >= ActivityManager.START_SUCCESS) {
        return;
    }
    switch(res) {
        case ActivityManager.START_INTENT_NOT_RESOLVED:
        case ActivityManager.START_CLASS_NOT_FOUND:
            if (intent instanceof Intent && ((Intent) intent).getComponent() != null)
                throw new ActivityNotFoundException("Unable to find explicit activity class " + ((Intent) intent).getComponent().toShortString() + "; have you declared this activity in your AndroidManifest.xml?");
            throw new ActivityNotFoundException("No Activity found to handle " + intent);
        case ActivityManager.START_PERMISSION_DENIED:
            throw new SecurityException("Not allowed to start activity " + intent);
        case ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT:
            throw new AndroidRuntimeException("FORWARD_RESULT_FLAG used while also requesting a result");
        case ActivityManager.START_NOT_ACTIVITY:
            throw new IllegalArgumentException("PendingIntent is not an activity");
        case ActivityManager.START_NOT_VOICE_COMPATIBLE:
            throw new SecurityException("Starting under voice control not allowed for: " + intent);
        case ActivityManager.START_NOT_CURRENT_USER_ACTIVITY:
            // Fail silently for this case so we don't break current apps.
            // TODO(b/22929608): Instead of failing silently or throwing an exception,
            // we should properly position the activity in the stack (i.e. behind all current
            // user activity/task) and not change the positioning of stacks.
            Log.e(TAG, "Not allowed to start background user activity that shouldn't be displayed" + " for all users. Failing silently...");
            break;
        default:
            throw new AndroidRuntimeException("Unknown error code " + res + " when starting " + intent);
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiInfo.writeToParcel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Implement the Parcelable interface {@hide}
 */

Body of Frist Method:
{
    dest.writeInt(mNetworkId);
    dest.writeInt(mRssi);
    dest.writeInt(mLinkSpeed);
    dest.writeInt(mFrequency);
    if (mIpAddress != null) {
        dest.writeByte((byte) 1);
        dest.writeByteArray(mIpAddress.getAddress());
    } else {
        dest.writeByte((byte) 0);
    }
    if (mWifiSsid != null) {
        dest.writeInt(1);
        mWifiSsid.writeToParcel(dest, flags);
    } else {
        dest.writeInt(0);
    }
    dest.writeString(mBSSID);
    dest.writeString(mMacAddress);
    dest.writeInt(mMeteredHint ? 1 : 0);
    dest.writeInt(score);
    dest.writeDouble(txSuccessRate);
    dest.writeDouble(txRetriesRate);
    dest.writeDouble(txBadRate);
    dest.writeDouble(rxSuccessRate);
    dest.writeInt(badRssiCount);
    dest.writeInt(lowRssiCount);
    mSupplicantState.writeToParcel(dest, flags);
}
Body of Second Method:
{
    dest.writeInt(mNetworkId);
    dest.writeInt(mRssi);
    dest.writeInt(mLinkSpeed);
    dest.writeInt(mFrequency);
    if (mIpAddress != null) {
        dest.writeByte((byte) 1);
        dest.writeByteArray(mIpAddress.getAddress());
    } else {
        dest.writeByte((byte) 0);
    }
    if (mWifiSsid != null) {
        dest.writeInt(1);
        mWifiSsid.writeToParcel(dest, flags);
    } else {
        dest.writeInt(0);
    }
    dest.writeString(mBSSID);
    dest.writeString(mMacAddress);
    dest.writeInt(mMeteredHint ? 1 : 0);
    dest.writeInt(mEphemeral ? 1 : 0);
    dest.writeInt(score);
    dest.writeDouble(txSuccessRate);
    dest.writeDouble(txRetriesRate);
    dest.writeDouble(txBadRate);
    dest.writeDouble(rxSuccessRate);
    dest.writeInt(badRssiCount);
    dest.writeInt(lowRssiCount);
    mSupplicantState.writeToParcel(dest, flags);
}
------------------------
Find a silently evolved API code:android.renderscript.Allocation.syncAll:COMMENT
Method Modifier: public      
Comment:/**
 * Propagate changes from one usage of the Allocation to the
 * other usages of the Allocation.
 */

Body of Frist Method:
{
    Trace.traceBegin(RenderScript.TRACE_TAG, "syncAll");
    switch(srcLocation) {
        case USAGE_GRAPHICS_TEXTURE:
        case USAGE_SCRIPT:
            if ((mUsage & USAGE_SHARED) != 0) {
                copyFrom(mBitmap);
            }
            break;
        case USAGE_GRAPHICS_CONSTANTS:
        case USAGE_GRAPHICS_VERTEX:
            break;
        case USAGE_SHARED:
            if ((mUsage & USAGE_SHARED) != 0) {
                copyTo(mBitmap);
            }
            break;
        default:
            throw new RSIllegalArgumentException("Source must be exactly one usage type.");
    }
    mRS.validate();
    mRS.nAllocationSyncAll(getIDSafe(), srcLocation);
    Trace.traceEnd(RenderScript.TRACE_TAG);
}
Body of Second Method:
{
    try {
        Trace.traceBegin(RenderScript.TRACE_TAG, "syncAll");
        switch(srcLocation) {
            case USAGE_GRAPHICS_TEXTURE:
            case USAGE_SCRIPT:
                if ((mUsage & USAGE_SHARED) != 0) {
                    copyFrom(mBitmap);
                }
                break;
            case USAGE_GRAPHICS_CONSTANTS:
            case USAGE_GRAPHICS_VERTEX:
                break;
            case USAGE_SHARED:
                if ((mUsage & USAGE_SHARED) != 0) {
                    copyTo(mBitmap);
                }
                break;
            default:
                throw new RSIllegalArgumentException("Source must be exactly one usage type.");
        }
        mRS.validate();
        mRS.nAllocationSyncAll(getIDSafe(), srcLocation);
    } finally {
        Trace.traceEnd(RenderScript.TRACE_TAG);
    }
}
------------------------
Find a silently evolved API code:android.inputmethodservice.InputMethodService.onKeyDown:COMMENT
Method Modifier: public      
Comment:/**
 * Override this to intercept key down events before they are processed by the
 * application.  If you return true, the application will not
 * process the event itself.  If you return false, the normal application processing
 * will occur as if the IME had not seen the event at all.
 *
 * <p>The default implementation intercepts {@link KeyEvent#KEYCODE_BACK
 * KeyEvent.KEYCODE_BACK} if the IME is currently shown, to
 * possibly hide it when the key goes up (if not canceled or long pressed).  In
 * addition, in fullscreen mode only, it will consume DPAD movement
 * events to move the cursor in the extracted text view, not allowing
 * them to perform navigation in the underlying application.
 */

Body of Frist Method:
{
    if (event.getKeyCode() == KeyEvent.KEYCODE_BACK) {
        if (handleBack(false)) {
            event.startTracking();
            return true;
        }
        return false;
    }
    return doMovementKey(keyCode, event, MOVEMENT_DOWN);
}
Body of Second Method:
{
    if (event.getKeyCode() == KeyEvent.KEYCODE_BACK) {
        final ExtractEditText eet = getExtractEditTextIfVisible();
        if (eet != null && eet.handleBackInTextActionModeIfNeeded(event)) {
            return true;
        }
        if (handleBack(false)) {
            event.startTracking();
            return true;
        }
        return false;
    }
    return doMovementKey(keyCode, event, MOVEMENT_DOWN);
}
------------------------
Find a silently evolved API code:android.app.Activity.getFragmentManager:COMMENT
Method Modifier: public      
Comment:/**
 * Return the FragmentManager for interacting with fragments associated
 * with this activity.
 */

Body of Frist Method:
{
    return mFragments;
}
Body of Second Method:
{
    return mFragments.getFragmentManager();
}
------------------------
Find a silently evolved API code:android.app.AlarmManager.setWindow:COMMENT
Method Modifier: public      
Comment:/**
 * Schedule an alarm to be delivered within a given window of time.  This method
 * is similar to {@link #set(int, long, PendingIntent)}, but allows the
 * application to precisely control the degree to which its delivery might be
 * adjusted by the OS. This method allows an application to take advantage of the
 * battery optimizations that arise from delivery batching even when it has
 * modest timeliness requirements for its alarms.
 *
 * <p>
 * This method can also be used to achieve strict ordering guarantees among
 * multiple alarms by ensuring that the windows requested for each alarm do
 * not intersect.
 *
 * <p>
 * When precise delivery is not required, applications should use the standard
 * {@link #set(int, long, PendingIntent)} method.  This will give the OS the most
 * flexibility to minimize wakeups and battery use.  For alarms that must be delivered
 * at precisely-specified times with no acceptable variation, applications can use
 * {@link #setExact(int, long, PendingIntent)}.
 *
 * @param type One of {@link #ELAPSED_REALTIME}, {@link #ELAPSED_REALTIME_WAKEUP},
 * {@link #RTC}, or {@link #RTC_WAKEUP}.
 * @param windowStartMillis The earliest time, in milliseconds, that the alarm should
 * be delivered, expressed in the appropriate clock's units (depending on the alarm
 * type).
 * @param windowLengthMillis The length of the requested delivery window,
 * in milliseconds.  The alarm will be delivered no later than this many
 * milliseconds after {@code windowStartMillis}.  Note that this parameter
 * is a <i>duration,</i> not the timestamp of the end of the window.
 * @param operation Action to perform when the alarm goes off;
 * typically comes from {@link PendingIntent#getBroadcast
 * IntentSender.getBroadcast()}.
 *
 * @see #set
 * @see #setExact
 * @see #setRepeating
 * @see #cancel
 * @see android.content.Context#sendBroadcast
 * @see android.content.Context#registerReceiver
 * @see android.content.Intent#filterEquals
 * @see #ELAPSED_REALTIME
 * @see #ELAPSED_REALTIME_WAKEUP
 * @see #RTC
 * @see #RTC_WAKEUP
 */

Body of Frist Method:
{
    setImpl(type, windowStartMillis, windowLengthMillis, 0, operation, null, null);
}
Body of Second Method:
{
    setImpl(type, windowStartMillis, windowLengthMillis, 0, 0, operation, null, null);
}
------------------------
Find a silently evolved API code:android.graphics.Bitmap.reconfigure:COMMENT
Method Modifier: public      
Comment:/**
 * <p>Modifies the bitmap to have a specified width, height, and {@link
 * Config}, without affecting the underlying allocation backing the bitmap.
 * Bitmap pixel data is not re-initialized for the new configuration.</p>
 *
 * <p>This method can be used to avoid allocating a new bitmap, instead
 * reusing an existing bitmap's allocation for a new configuration of equal
 * or lesser size. If the Bitmap's allocation isn't large enough to support
 * the new configuration, an IllegalArgumentException will be thrown and the
 * bitmap will not be modified.</p>
 *
 * <p>The result of {@link #getByteCount()} will reflect the new configuration,
 * while {@link #getAllocationByteCount()} will reflect that of the initial
 * configuration.</p>
 *
 * <p>Note: This may change this result of hasAlpha(). When converting to 565,
 * the new bitmap will always be considered opaque. When converting from 565,
 * the new bitmap will be considered non-opaque, and will respect the value
 * set by setPremultiplied().</p>
 *
 * <p>WARNING: This method should NOT be called on a bitmap currently used
 * by the view system. It does not make guarantees about how the underlying
 * pixel buffer is remapped to the new config, just that the allocation is
 * reused. Additionally, the view system does not account for bitmap
 * properties being modifying during use, e.g. while attached to
 * drawables.</p>
 *
 * @see #setWidth(int)
 * @see #setHeight(int)
 * @see #setConfig(Config)
 */

Body of Frist Method:
{
    checkRecycled("Can't call reconfigure() on a recycled bitmap");
    if (width <= 0 || height <= 0) {
        throw new IllegalArgumentException("width and height must be > 0");
    }
    if (!isMutable()) {
        throw new IllegalStateException("only mutable bitmaps may be reconfigured");
    }
    if (mBuffer == null) {
        throw new IllegalStateException("native-backed bitmaps may not be reconfigured");
    }
    nativeReconfigure(mNativeBitmap, width, height, config.nativeInt, mBuffer.length, mRequestPremultiplied);
    mWidth = width;
    mHeight = height;
}
Body of Second Method:
{
    checkRecycled("Can't call reconfigure() on a recycled bitmap");
    if (width <= 0 || height <= 0) {
        throw new IllegalArgumentException("width and height must be > 0");
    }
    if (!isMutable()) {
        throw new IllegalStateException("only mutable bitmaps may be reconfigured");
    }
    if (mBuffer == null) {
        throw new IllegalStateException("native-backed bitmaps may not be reconfigured");
    }
    nativeReconfigure(mFinalizer.mNativeBitmap, width, height, config.nativeInt, mBuffer.length, mRequestPremultiplied);
    mWidth = width;
    mHeight = height;
}
------------------------
Find a silently evolved API code:android.widget.CalendarViewLegacyDelegate.setUpHeader:COMMENT
Method Modifier: private     
Comment:/**
 * Sets up the strings to be used by the header.
 */

Body of Frist Method:
{
    mDayNamesShort = new String[mDaysPerWeek];
    mDayNamesLong = new String[mDaysPerWeek];
    for (int i = mFirstDayOfWeek, count = mFirstDayOfWeek + mDaysPerWeek; i < count; i++) {
        int calendarDay = (i > Calendar.SATURDAY) ? i - Calendar.SATURDAY : i;
        mDayNamesShort[i - mFirstDayOfWeek] = DateUtils.getDayOfWeekString(calendarDay, DateUtils.LENGTH_SHORTEST);
        mDayNamesLong[i - mFirstDayOfWeek] = DateUtils.getDayOfWeekString(calendarDay, DateUtils.LENGTH_LONG);
    }
    TextView label = (TextView) mDayNamesHeader.getChildAt(0);
    if (mShowWeekNumber) {
        label.setVisibility(View.VISIBLE);
    } else {
        label.setVisibility(View.GONE);
    }
    for (int i = 1, count = mDayNamesHeader.getChildCount(); i < count; i++) {
        label = (TextView) mDayNamesHeader.getChildAt(i);
        if (mWeekDayTextAppearanceResId > -1) {
            label.setTextAppearance(mContext, mWeekDayTextAppearanceResId);
        }
        if (i < mDaysPerWeek + 1) {
            label.setText(mDayNamesShort[i - 1]);
            label.setContentDescription(mDayNamesLong[i - 1]);
            label.setVisibility(View.VISIBLE);
        } else {
            label.setVisibility(View.GONE);
        }
    }
    mDayNamesHeader.invalidate();
}
Body of Second Method:
{
    mDayNamesShort = new String[mDaysPerWeek];
    mDayNamesLong = new String[mDaysPerWeek];
    for (int i = mFirstDayOfWeek, count = mFirstDayOfWeek + mDaysPerWeek; i < count; i++) {
        int calendarDay = (i > Calendar.SATURDAY) ? i - Calendar.SATURDAY : i;
        mDayNamesShort[i - mFirstDayOfWeek] = DateUtils.getDayOfWeekString(calendarDay, DateUtils.LENGTH_SHORTEST);
        mDayNamesLong[i - mFirstDayOfWeek] = DateUtils.getDayOfWeekString(calendarDay, DateUtils.LENGTH_LONG);
    }
    TextView label = (TextView) mDayNamesHeader.getChildAt(0);
    if (mShowWeekNumber) {
        label.setVisibility(View.VISIBLE);
    } else {
        label.setVisibility(View.GONE);
    }
    for (int i = 1, count = mDayNamesHeader.getChildCount(); i < count; i++) {
        label = (TextView) mDayNamesHeader.getChildAt(i);
        if (mWeekDayTextAppearanceResId > -1) {
            label.setTextAppearance(mWeekDayTextAppearanceResId);
        }
        if (i < mDaysPerWeek + 1) {
            label.setText(mDayNamesShort[i - 1]);
            label.setContentDescription(mDayNamesLong[i - 1]);
            label.setVisibility(View.VISIBLE);
        } else {
            label.setVisibility(View.GONE);
        }
    }
    mDayNamesHeader.invalidate();
}
------------------------
Find a silently evolved API code:android.content.ContentProviderClient.getType:COMMENT
Method Modifier: public      
Comment:/**
 * See {@link ContentProvider#getType ContentProvider.getType}
 */

Body of Frist Method:
{
    beforeRemote();
    try {
        return mContentProvider.getType(url);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}
Body of Second Method:
{
    Preconditions.checkNotNull(url, "url");
    beforeRemote();
    try {
        return mContentProvider.getType(url);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}
------------------------
Find a silently evolved API code:android.net.NetworkInfo.writeToParcel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Implement the Parcelable interface.
 * @hide
 */

Body of Frist Method:
{
    synchronized (this) {
        dest.writeInt(mNetworkType);
        dest.writeInt(mSubtype);
        dest.writeString(mTypeName);
        dest.writeString(mSubtypeName);
        dest.writeString(mState.name());
        dest.writeString(mDetailedState.name());
        dest.writeInt(mIsFailover ? 1 : 0);
        dest.writeInt(mIsAvailable ? 1 : 0);
        dest.writeInt(mIsRoaming ? 1 : 0);
        dest.writeInt(mIsConnectedToProvisioningNetwork ? 1 : 0);
        dest.writeString(mReason);
        dest.writeString(mExtraInfo);
    }
}
Body of Second Method:
{
    synchronized (this) {
        dest.writeInt(mNetworkType);
        dest.writeInt(mSubtype);
        dest.writeString(mTypeName);
        dest.writeString(mSubtypeName);
        dest.writeString(mState.name());
        dest.writeString(mDetailedState.name());
        dest.writeInt(mIsFailover ? 1 : 0);
        dest.writeInt(mIsAvailable ? 1 : 0);
        dest.writeInt(mIsRoaming ? 1 : 0);
        dest.writeString(mReason);
        dest.writeString(mExtraInfo);
    }
}
------------------------
Find a silently evolved API code:android.hardware.camera2.legacy.RequestHandlerThread.waitUntilIdle:COMMENT
Method Modifier: public      
Comment:// Blocks until thread is idling

Body of Frist Method:
{
    Handler handler = waitAndGetHandler();
    Looper looper = handler.getLooper();
    if (looper.isIdling()) {
        return;
    }
    mIdle.close();
    looper.getQueue().addIdleHandler(mIdleHandler);
    // Ensure that the idle handler gets run even if the looper already went idle
    handler.sendEmptyMessage(MSG_POKE_IDLE_HANDLER);
    if (looper.isIdling()) {
        return;
    }
    mIdle.block();
}
Body of Second Method:
{
    Handler handler = waitAndGetHandler();
    MessageQueue queue = handler.getLooper().getQueue();
    if (queue.isIdle()) {
        return;
    }
    mIdle.close();
    queue.addIdleHandler(mIdleHandler);
    // Ensure that the idle handler gets run even if the looper already went idle
    handler.sendEmptyMessage(MSG_POKE_IDLE_HANDLER);
    if (queue.isIdle()) {
        return;
    }
    mIdle.block();
}
------------------------
Find a silently evolved API code:android.net.wifi.RttManager.ParcelableRttParams.writeToParcel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Implement the Parcelable interface {@hide}
 */

Body of Frist Method:
{
    if (mParams != null) {
        dest.writeInt(mParams.length);
        for (RttParams params : mParams) {
            dest.writeInt(params.deviceType);
            dest.writeInt(params.requestType);
            dest.writeString(params.bssid);
            dest.writeInt(params.frequency);
            dest.writeInt(params.channelWidth);
            dest.writeInt(params.num_samples);
            dest.writeInt(params.num_retries);
        }
    } else {
        dest.writeInt(0);
    }
}
Body of Second Method:
{
    if (mParams != null) {
        dest.writeInt(mParams.length);
        for (RttParams params : mParams) {
            dest.writeInt(params.deviceType);
            dest.writeInt(params.requestType);
            dest.writeString(params.bssid);
            dest.writeInt(params.channelWidth);
            dest.writeInt(params.frequency);
            dest.writeInt(params.centerFreq0);
            dest.writeInt(params.centerFreq1);
            dest.writeInt(params.numberBurst);
            dest.writeInt(params.interval);
            dest.writeInt(params.numSamplesPerBurst);
            dest.writeInt(params.numRetriesPerMeasurementFrame);
            dest.writeInt(params.numRetriesPerFTMR);
            dest.writeInt(params.LCIRequest ? 1 : 0);
            dest.writeInt(params.LCRRequest ? 1 : 0);
            dest.writeInt(params.burstTimeout);
            dest.writeInt(params.preamble);
            dest.writeInt(params.bandwidth);
        }
    } else {
        dest.writeInt(0);
    }
}
------------------------
Find a silently evolved API code:android.graphics.RectF.roundOut:COMMENT
Method Modifier: public      
Comment:/**
 * Set the dst integer Rect by rounding "out" this rectangle, choosing the
 * floor of top and left, and the ceiling of right and bottom.
 */

Body of Frist Method:
{
    dst.set((int) FloatMath.floor(left), (int) FloatMath.floor(top), (int) FloatMath.ceil(right), (int) FloatMath.ceil(bottom));
}
Body of Second Method:
{
    dst.set((int) Math.floor(left), (int) Math.floor(top), (int) Math.ceil(right), (int) Math.ceil(bottom));
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothDevice.createRfcommSocketToServiceRecord:COMMENT
Method Modifier: public      
Comment:/**
 * Create an RFCOMM {@link BluetoothSocket} ready to start a secure
 * outgoing connection to this remote device using SDP lookup of uuid.
 * <p>This is designed to be used with {@link
 * BluetoothAdapter#listenUsingRfcommWithServiceRecord} for peer-peer
 * Bluetooth applications.
 * <p>Use {@link BluetoothSocket#connect} to initiate the outgoing
 * connection. This will also perform an SDP lookup of the given uuid to
 * determine which channel to connect to.
 * <p>The remote device will be authenticated and communication on this
 * socket will be encrypted.
 * <p> Use this socket only if an authenticated socket link is possible.
 * Authentication refers to the authentication of the link key to
 * prevent man-in-the-middle type of attacks.
 * For example, for Bluetooth 2.1 devices, if any of the devices does not
 * have an input and output capability or just has the ability to
 * display a numeric key, a secure socket connection is not possible.
 * In such a case, use {#link createInsecureRfcommSocketToServiceRecord}.
 * For more details, refer to the Security Model section 5.2 (vol 3) of
 * Bluetooth Core Specification version 2.1 + EDR.
 * <p>Hint: If you are connecting to a Bluetooth serial board then try
 * using the well-known SPP UUID 00001101-0000-1000-8000-00805F9B34FB.
 * However if you are connecting to an Android peer then please generate
 * your own unique UUID.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}
 *
 * @param uuid service record uuid to lookup RFCOMM channel
 * @return a RFCOMM BluetoothServerSocket ready for an outgoing connection
 * @throws IOException on error, for example Bluetooth not available, or
 * insufficient permissions
 */

Body of Frist Method:
{
    return new BluetoothSocket(BluetoothSocket.TYPE_RFCOMM, -1, true, true, this, -1, new ParcelUuid(uuid));
}
Body of Second Method:
{
    if (isBluetoothEnabled() == false) {
        Log.e(TAG, "Bluetooth is not enabled");
        throw new IOException();
    }
    return new BluetoothSocket(BluetoothSocket.TYPE_RFCOMM, -1, true, true, this, -1, new ParcelUuid(uuid));
}
------------------------
Find a silently evolved API code:android.text.TextLine.handleRun:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Utility function for handling a unidirectional run.  The run must not
 * contain tabs or emoji but can contain styles.
 *
 * @param start the line-relative start of the run
 * @param measureLimit the offset to measure to, between start and limit inclusive
 * @param limit the limit of the run
 * @param runIsRtl true if the run is right-to-left
 * @param c the canvas, can be null
 * @param x the end of the run closest to the leading margin
 * @param top the top of the line
 * @param y the baseline
 * @param bottom the bottom of the line
 * @param fmi receives metrics information, can be null
 * @param needWidth true if the width is required
 * @return the signed width of the run based on the run direction; only
 * valid if needWidth is true
 */

Body of Frist Method:
{
    // Case of an empty line, make sure we update fmi according to mPaint
    if (start == measureLimit) {
        TextPaint wp = mWorkPaint;
        wp.set(mPaint);
        if (fmi != null) {
            expandMetricsFromPaint(fmi, wp);
        }
        return 0f;
    }
    if (mSpanned == null) {
        TextPaint wp = mWorkPaint;
        wp.set(mPaint);
        final int mlimit = measureLimit;
        return handleText(wp, start, mlimit, start, limit, runIsRtl, c, x, top, y, bottom, fmi, needWidth || mlimit < measureLimit);
    }
    mMetricAffectingSpanSpanSet.init(mSpanned, mStart + start, mStart + limit);
    mCharacterStyleSpanSet.init(mSpanned, mStart + start, mStart + limit);
    // Shaping needs to take into account context up to metric boundaries,
    // but rendering needs to take into account character style boundaries.
    // So we iterate through metric runs to get metric bounds,
    // then within each metric run iterate through character style runs
    // for the run bounds.
    final float originalX = x;
    for (int i = start, inext; i < measureLimit; i = inext) {
        TextPaint wp = mWorkPaint;
        wp.set(mPaint);
        inext = mMetricAffectingSpanSpanSet.getNextTransition(mStart + i, mStart + limit) - mStart;
        int mlimit = Math.min(inext, measureLimit);
        ReplacementSpan replacement = null;
        for (int j = 0; j < mMetricAffectingSpanSpanSet.numberOfSpans; j++) {
            // empty by construction. This special case in getSpans() explains the >= & <= tests
            if ((mMetricAffectingSpanSpanSet.spanStarts[j] >= mStart + mlimit) || (mMetricAffectingSpanSpanSet.spanEnds[j] <= mStart + i))
                continue;
            MetricAffectingSpan span = mMetricAffectingSpanSpanSet.spans[j];
            if (span instanceof ReplacementSpan) {
                replacement = (ReplacementSpan) span;
            } else {
                // We might have a replacement that uses the draw
                // state, otherwise measure state would suffice.
                span.updateDrawState(wp);
            }
        }
        if (replacement != null) {
            x += handleReplacement(replacement, wp, i, mlimit, runIsRtl, c, x, top, y, bottom, fmi, needWidth || mlimit < measureLimit);
            continue;
        }
        for (int j = i, jnext; j < mlimit; j = jnext) {
            jnext = mCharacterStyleSpanSet.getNextTransition(mStart + j, mStart + mlimit) - mStart;
            wp.set(mPaint);
            for (int k = 0; k < mCharacterStyleSpanSet.numberOfSpans; k++) {
                // Intentionally using >= and <= as explained above
                if ((mCharacterStyleSpanSet.spanStarts[k] >= mStart + jnext) || (mCharacterStyleSpanSet.spanEnds[k] <= mStart + j))
                    continue;
                CharacterStyle span = mCharacterStyleSpanSet.spans[k];
                span.updateDrawState(wp);
            }
            x += handleText(wp, j, jnext, i, inext, runIsRtl, c, x, top, y, bottom, fmi, needWidth || jnext < measureLimit);
        }
    }
    return x - originalX;
}
Body of Second Method:
{
    // Case of an empty line, make sure we update fmi according to mPaint
    if (start == measureLimit) {
        TextPaint wp = mWorkPaint;
        wp.set(mPaint);
        if (fmi != null) {
            expandMetricsFromPaint(fmi, wp);
        }
        return 0f;
    }
    if (mSpanned == null) {
        TextPaint wp = mWorkPaint;
        wp.set(mPaint);
        final int mlimit = measureLimit;
        return handleText(wp, start, mlimit, start, limit, runIsRtl, c, x, top, y, bottom, fmi, needWidth || mlimit < measureLimit);
    }
    mMetricAffectingSpanSpanSet.init(mSpanned, mStart + start, mStart + limit);
    mCharacterStyleSpanSet.init(mSpanned, mStart + start, mStart + limit);
    // Shaping needs to take into account context up to metric boundaries,
    // but rendering needs to take into account character style boundaries.
    // So we iterate through metric runs to get metric bounds,
    // then within each metric run iterate through character style runs
    // for the run bounds.
    final float originalX = x;
    for (int i = start, inext; i < measureLimit; i = inext) {
        TextPaint wp = mWorkPaint;
        wp.set(mPaint);
        inext = mMetricAffectingSpanSpanSet.getNextTransition(mStart + i, mStart + limit) - mStart;
        int mlimit = Math.min(inext, measureLimit);
        ReplacementSpan replacement = null;
        for (int j = 0; j < mMetricAffectingSpanSpanSet.numberOfSpans; j++) {
            // empty by construction. This special case in getSpans() explains the >= & <= tests
            if ((mMetricAffectingSpanSpanSet.spanStarts[j] >= mStart + mlimit) || (mMetricAffectingSpanSpanSet.spanEnds[j] <= mStart + i))
                continue;
            MetricAffectingSpan span = mMetricAffectingSpanSpanSet.spans[j];
            if (span instanceof ReplacementSpan) {
                replacement = (ReplacementSpan) span;
            } else {
                // We might have a replacement that uses the draw
                // state, otherwise measure state would suffice.
                span.updateDrawState(wp);
            }
        }
        if (replacement != null) {
            x += handleReplacement(replacement, wp, i, mlimit, runIsRtl, c, x, top, y, bottom, fmi, needWidth || mlimit < measureLimit);
            continue;
        }
        for (int j = i, jnext; j < mlimit; j = jnext) {
            jnext = mCharacterStyleSpanSet.getNextTransition(mStart + j, mStart + mlimit) - mStart;
            wp.set(mPaint);
            for (int k = 0; k < mCharacterStyleSpanSet.numberOfSpans; k++) {
                // Intentionally using >= and <= as explained above
                if ((mCharacterStyleSpanSet.spanStarts[k] >= mStart + jnext) || (mCharacterStyleSpanSet.spanEnds[k] <= mStart + j))
                    continue;
                CharacterStyle span = mCharacterStyleSpanSet.spans[k];
                span.updateDrawState(wp);
            }
            // Only draw hyphen on last run in line
            if (jnext < mLen) {
                wp.setHyphenEdit(0);
            }
            x += handleText(wp, j, jnext, i, inext, runIsRtl, c, x, top, y, bottom, fmi, needWidth || jnext < measureLimit);
        }
    }
    return x - originalX;
}
------------------------
Find a silently evolved API code:android.widget.SimpleMonthView.drawDays:COMMENT
Method Modifier: private     
Comment:/**
 * Draws the month days.
 */

Body of Frist Method:
{
    int y = (((mRowHeight + mMiniDayNumberTextSize) / 2) - DAY_SEPARATOR_WIDTH) + mMonthHeaderSize;
    int dayWidthHalf = (mWidth - mPadding * 2) / (mNumDays * 2);
    int j = findDayOffset();
    for (int day = 1; day <= mNumCells; day++) {
        int x = (2 * j + 1) * dayWidthHalf + mPadding;
        if (mSelectedDay == day) {
            canvas.drawCircle(x, y - (mMiniDayNumberTextSize / 3), mDaySelectedCircleSize, mDayNumberSelectedPaint);
        }
        if (mHasToday && mToday == day) {
            mDayNumberPaint.setColor(mSelectedDayColor);
        } else {
            mDayNumberPaint.setColor(mNormalTextColor);
        }
        final Paint paint = (day < mEnabledDayStart || day > mEnabledDayEnd) ? mDayNumberDisabledPaint : mDayNumberPaint;
        canvas.drawText(String.format("%d", day), x, y, paint);
        j++;
        if (j == mNumDays) {
            j = 0;
            y += mRowHeight;
        }
    }
}
Body of Second Method:
{
    final TextPaint p = mDayPaint;
    final int headerHeight = mMonthHeight + mDayOfWeekHeight;
    final int rowHeight = mDayHeight;
    final int colWidth = mCellWidth;
    // Text is vertically centered within the row height.
    final float halfLineHeight = (p.ascent() + p.descent()) / 2f;
    int rowCenter = headerHeight + rowHeight / 2;
    for (int day = 1, col = findDayOffset(); day <= mDaysInMonth; day++) {
        final int colCenter = colWidth * col + colWidth / 2;
        final int colCenterRtl;
        if (isLayoutRtl()) {
            colCenterRtl = mPaddedWidth - colCenter;
        } else {
            colCenterRtl = colCenter;
        }
        int stateMask = 0;
        final boolean isDayEnabled = isDayEnabled(day);
        if (isDayEnabled) {
            stateMask |= StateSet.VIEW_STATE_ENABLED;
        }
        final boolean isDayActivated = mActivatedDay == day;
        if (isDayActivated) {
            stateMask |= StateSet.VIEW_STATE_ACTIVATED;
            // Adjust the circle to be centered on the row.
            canvas.drawCircle(colCenterRtl, rowCenter, mDaySelectorRadius, mDaySelectorPaint);
        } else if (mTouchedItem == day) {
            stateMask |= StateSet.VIEW_STATE_PRESSED;
            if (isDayEnabled) {
                // Adjust the circle to be centered on the row.
                canvas.drawCircle(colCenterRtl, rowCenter, mDaySelectorRadius, mDayHighlightPaint);
            }
        }
        final boolean isDayToday = mToday == day;
        final int dayTextColor;
        if (isDayToday && !isDayActivated) {
            dayTextColor = mDaySelectorPaint.getColor();
        } else {
            final int[] stateSet = StateSet.get(stateMask);
            dayTextColor = mDayTextColor.getColorForState(stateSet, 0);
        }
        p.setColor(dayTextColor);
        canvas.drawText(mDayFormatter.format(day), colCenterRtl, rowCenter - halfLineHeight, p);
        col++;
        if (col == DAYS_IN_WEEK) {
            col = 0;
            rowCenter += rowHeight;
        }
    }
}
------------------------
Find a silently evolved API code:android.media.AudioManager.unregisterRemoteControlClient:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * Unregisters the remote control client that was providing information to display on the
 * remote controls.
 * @param rcClient The remote control client to unregister.
 * @see #registerRemoteControlClient(RemoteControlClient)
 * @deprecated Use {@link MediaSession} instead.
 */

Body of Frist Method:
{
    if ((rcClient == null) || (rcClient.getRcMediaIntent() == null)) {
        return;
    }
    rcClient.unregisterWithSession(MediaSessionLegacyHelper.getHelper(mContext));
}
Body of Second Method:
{
    if ((rcClient == null) || (rcClient.getRcMediaIntent() == null)) {
        return;
    }
    rcClient.unregisterWithSession(MediaSessionLegacyHelper.getHelper(getContext()));
}
------------------------
Find a silently evolved API code:android.app.BackStackRecord.calculateFragments:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Finds the first removed fragment and last added fragments when going forward.
 * If none of the fragments have transitions, then both lists will be empty.
 *
 * @param firstOutFragments The list of first fragments to be removed, keyed on the
 * container ID. This list will be modified by the method.
 * @param lastInFragments The list of last fragments to be added, keyed on the
 * container ID. This list will be modified by the method.
 */

Body of Frist Method:
{
    if (!mManager.mContainer.hasView()) {
        // nothing to see, so no transitions
        return;
    }
    Op op = mHead;
    while (op != null) {
        switch(op.cmd) {
            case OP_ADD:
                setLastIn(lastInFragments, op.fragment);
                break;
            case OP_REPLACE:
                {
                    Fragment f = op.fragment;
                    if (mManager.mAdded != null) {
                        for (int i = 0; i < mManager.mAdded.size(); i++) {
                            Fragment old = mManager.mAdded.get(i);
                            if (f == null || old.mContainerId == f.mContainerId) {
                                if (old == f) {
                                    f = null;
                                } else {
                                    setFirstOut(firstOutFragments, old);
                                }
                            }
                        }
                    }
                    setLastIn(lastInFragments, f);
                    break;
                }
            case OP_REMOVE:
                setFirstOut(firstOutFragments, op.fragment);
                break;
            case OP_HIDE:
                setFirstOut(firstOutFragments, op.fragment);
                break;
            case OP_SHOW:
                setLastIn(lastInFragments, op.fragment);
                break;
            case OP_DETACH:
                setFirstOut(firstOutFragments, op.fragment);
                break;
            case OP_ATTACH:
                setLastIn(lastInFragments, op.fragment);
                break;
        }
        op = op.next;
    }
}
Body of Second Method:
{
    if (!mManager.mContainer.onHasView()) {
        // nothing to see, so no transitions
        return;
    }
    Op op = mHead;
    while (op != null) {
        switch(op.cmd) {
            case OP_ADD:
                setLastIn(lastInFragments, op.fragment);
                break;
            case OP_REPLACE:
                {
                    Fragment f = op.fragment;
                    if (mManager.mAdded != null) {
                        for (int i = 0; i < mManager.mAdded.size(); i++) {
                            Fragment old = mManager.mAdded.get(i);
                            if (f == null || old.mContainerId == f.mContainerId) {
                                if (old == f) {
                                    f = null;
                                } else {
                                    setFirstOut(firstOutFragments, old);
                                }
                            }
                        }
                    }
                    setLastIn(lastInFragments, f);
                    break;
                }
            case OP_REMOVE:
                setFirstOut(firstOutFragments, op.fragment);
                break;
            case OP_HIDE:
                setFirstOut(firstOutFragments, op.fragment);
                break;
            case OP_SHOW:
                setLastIn(lastInFragments, op.fragment);
                break;
            case OP_DETACH:
                setFirstOut(firstOutFragments, op.fragment);
                break;
            case OP_ATTACH:
                setLastIn(lastInFragments, op.fragment);
                break;
        }
        op = op.next;
    }
}
------------------------
Find a silently evolved API code:android.media.MediaCodecInfo.VideoCapabilities.getSupportedHeightsFor:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the range of supported video heights for a video width
 * @param width the width of the video
 */

Body of Frist Method:
{
    try {
        Range<Integer> range = mHeightRange;
        if (!mWidthRange.contains(width) || (width % mWidthAlignment) != 0) {
            throw new IllegalArgumentException("unsupported width");
        }
        final int widthInBlocks = Utils.divUp(width, mBlockWidth);
        // constrain by block count and by block aspect ratio
        final int minHeightInBlocks = Math.max(Utils.divUp(mBlockCountRange.getLower(), widthInBlocks), (int) Math.ceil(widthInBlocks / mBlockAspectRatioRange.getUpper().doubleValue()));
        final int maxHeightInBlocks = Math.min(mBlockCountRange.getUpper() / widthInBlocks, (int) (widthInBlocks / mBlockAspectRatioRange.getLower().doubleValue()));
        range = range.intersect((minHeightInBlocks - 1) * mBlockHeight + mHeightAlignment, maxHeightInBlocks * mBlockHeight);
        // constrain by smaller dimension limit
        if (width > mSmallerDimensionUpperLimit) {
            range = range.intersect(1, mSmallerDimensionUpperLimit);
        }
        // constrain by aspect ratio
        range = range.intersect((int) Math.ceil(width / mAspectRatioRange.getUpper().doubleValue()), (int) (width / mAspectRatioRange.getLower().doubleValue()));
        return range;
    } catch (IllegalArgumentException e) {
        // should not be here
        Log.w(TAG, "could not get supported heights for " + width, e);
        throw new IllegalArgumentException("unsupported width");
    }
}
Body of Second Method:
{
    try {
        Range<Integer> range = mHeightRange;
        if (!mWidthRange.contains(width) || (width % mWidthAlignment) != 0) {
            throw new IllegalArgumentException("unsupported width");
        }
        final int widthInBlocks = Utils.divUp(width, mBlockWidth);
        // constrain by block count and by block aspect ratio
        final int minHeightInBlocks = Math.max(Utils.divUp(mBlockCountRange.getLower(), widthInBlocks), (int) Math.ceil(widthInBlocks / mBlockAspectRatioRange.getUpper().doubleValue()));
        final int maxHeightInBlocks = Math.min(mBlockCountRange.getUpper() / widthInBlocks, (int) (widthInBlocks / mBlockAspectRatioRange.getLower().doubleValue()));
        range = range.intersect((minHeightInBlocks - 1) * mBlockHeight + mHeightAlignment, maxHeightInBlocks * mBlockHeight);
        // constrain by smaller dimension limit
        if (width > mSmallerDimensionUpperLimit) {
            range = range.intersect(1, mSmallerDimensionUpperLimit);
        }
        // constrain by aspect ratio
        range = range.intersect((int) Math.ceil(width / mAspectRatioRange.getUpper().doubleValue()), (int) (width / mAspectRatioRange.getLower().doubleValue()));
        return range;
    } catch (IllegalArgumentException e) {
        // width is not supported because there are no suitable heights
        Log.v(TAG, "could not get supported heights for " + width);
        throw new IllegalArgumentException("unsupported width");
    }
}
------------------------
Find a silently evolved API code:javax.obex.ClientOperation.getLength:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns the length of the content which is being provided. E.g. if the
 * connection is via HTTP, then the value of the content-length header field
 * is returned.
 * @return the content length of the resource that this connection's URL
 * references, or -1 if the content length is not known
 */

Body of Frist Method:
{
    try {
        Long temp = (Long) mReplyHeader.getHeader(HeaderSet.LENGTH);
        if (temp == null) {
            return -1;
        } else {
            return temp.longValue();
        }
    } catch (IOException e) {
        return -1;
    }
}
Body of Second Method:
{
    try {
        Long temp = (Long) mReplyHeader.getHeader(HeaderSet.LENGTH);
        if (temp == null) {
            return -1;
        } else {
            return temp.longValue();
        }
    } catch (IOException e) {
        if (V)
            Log.d(TAG, "Exception occured - returning -1", e);
        return -1;
    }
}
------------------------
Find a silently evolved API code:android.telephony.PhoneNumberUtils.getNumberFromIntent:COMMENT
Method Modifier: public      static      
Comment:/**
 * Extracts the phone number from an Intent.
 *
 * @param intent the intent to get the number of
 * @param context a context to use for database access
 *
 * @return the phone number that would be called by the intent, or
 * <code>null</code> if the number cannot be found.
 */

Body of Frist Method:
{
    String number = null;
    Uri uri = intent.getData();
    if (uri == null) {
        return null;
    }
    String scheme = uri.getScheme();
    if (scheme.equals("tel") || scheme.equals("sip")) {
        return uri.getSchemeSpecificPart();
    }
    if (context == null) {
        return null;
    }
    String type = intent.resolveType(context);
    String phoneColumn = null;
    // Correctly read out the phone entry based on requested provider
    final String authority = uri.getAuthority();
    if (Contacts.AUTHORITY.equals(authority)) {
        phoneColumn = Contacts.People.Phones.NUMBER;
    } else if (ContactsContract.AUTHORITY.equals(authority)) {
        phoneColumn = ContactsContract.CommonDataKinds.Phone.NUMBER;
    }
    final Cursor c = context.getContentResolver().query(uri, new String[] { phoneColumn }, null, null, null);
    if (c != null) {
        try {
            if (c.moveToFirst()) {
                number = c.getString(c.getColumnIndex(phoneColumn));
            }
        } finally {
            c.close();
        }
    }
    return number;
}
Body of Second Method:
{
    String number = null;
    Uri uri = intent.getData();
    if (uri == null) {
        return null;
    }
    String scheme = uri.getScheme();
    if (scheme.equals("tel") || scheme.equals("sip")) {
        return uri.getSchemeSpecificPart();
    }
    if (context == null) {
        return null;
    }
    String type = intent.resolveType(context);
    String phoneColumn = null;
    // Correctly read out the phone entry based on requested provider
    final String authority = uri.getAuthority();
    if (Contacts.AUTHORITY.equals(authority)) {
        phoneColumn = Contacts.People.Phones.NUMBER;
    } else if (ContactsContract.AUTHORITY.equals(authority)) {
        phoneColumn = ContactsContract.CommonDataKinds.Phone.NUMBER;
    }
    Cursor c = null;
    try {
        c = context.getContentResolver().query(uri, new String[] { phoneColumn }, null, null, null);
        if (c != null) {
            if (c.moveToFirst()) {
                number = c.getString(c.getColumnIndex(phoneColumn));
            }
        }
    } catch (RuntimeException e) {
        Rlog.e(LOG_TAG, "Error getting phone number.", e);
    } finally {
        if (c != null) {
            c.close();
        }
    }
    return number;
}
------------------------
Find a silently evolved API code:android.widget.TextView.getCompoundPaddingTop:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the top padding of the view, plus space for the top
 * Drawable if any.
 */

Body of Frist Method:
{
    final Drawables dr = mDrawables;
    if (dr == null || dr.mDrawableTop == null) {
        return mPaddingTop;
    } else {
        return mPaddingTop + dr.mDrawablePadding + dr.mDrawableSizeTop;
    }
}
Body of Second Method:
{
    final Drawables dr = mDrawables;
    if (dr == null || dr.mShowing[Drawables.TOP] == null) {
        return mPaddingTop;
    } else {
        return mPaddingTop + dr.mDrawablePadding + dr.mDrawableSizeTop;
    }
}
------------------------
Find a silently evolved API code:android.media.MediaCodecInfo.EncoderCapabilities.supportsFormat:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    final Map<String, Object> map = format.getMap();
    final String mime = mParent.getMimeType();
    Integer mode = (Integer) map.get(MediaFormat.KEY_BITRATE_MODE);
    if (mode != null && !isBitrateModeSupported(mode)) {
        return false;
    }
    Integer complexity = (Integer) map.get(MediaFormat.KEY_COMPLEXITY);
    if (MediaFormat.MIMETYPE_AUDIO_FLAC.equalsIgnoreCase(mime)) {
        Integer flacComplexity = (Integer) map.get(MediaFormat.KEY_FLAC_COMPRESSION_LEVEL);
        if (complexity == null) {
            complexity = flacComplexity;
        } else if (flacComplexity != null && complexity != flacComplexity) {
            throw new IllegalArgumentException("conflicting values for complexity and " + "flac-compression-level");
        }
    }
    // other audio parameters
    Integer profile = (Integer) map.get(MediaFormat.KEY_PROFILE);
    if (MediaFormat.MIMETYPE_AUDIO_AAC.equalsIgnoreCase(mime)) {
        Integer aacProfile = (Integer) map.get(MediaFormat.KEY_AAC_PROFILE);
        if (profile == null) {
            profile = aacProfile;
        } else if (aacProfile != null && aacProfile != profile) {
            throw new IllegalArgumentException("conflicting values for profile and aac-profile");
        }
    }
    Integer quality = (Integer) map.get(MediaFormat.KEY_QUALITY);
    return supports(complexity, quality, profile);
}
Body of Second Method:
{
    final Map<String, Object> map = format.getMap();
    final String mime = mParent.getMimeType();
    Integer mode = (Integer) map.get(MediaFormat.KEY_BITRATE_MODE);
    if (mode != null && !isBitrateModeSupported(mode)) {
        return false;
    }
    Integer complexity = (Integer) map.get(MediaFormat.KEY_COMPLEXITY);
    if (MediaFormat.MIMETYPE_AUDIO_FLAC.equalsIgnoreCase(mime)) {
        Integer flacComplexity = (Integer) map.get(MediaFormat.KEY_FLAC_COMPRESSION_LEVEL);
        if (complexity == null) {
            complexity = flacComplexity;
        } else if (flacComplexity != null && !complexity.equals(flacComplexity)) {
            throw new IllegalArgumentException("conflicting values for complexity and " + "flac-compression-level");
        }
    }
    // other audio parameters
    Integer profile = (Integer) map.get(MediaFormat.KEY_PROFILE);
    if (MediaFormat.MIMETYPE_AUDIO_AAC.equalsIgnoreCase(mime)) {
        Integer aacProfile = (Integer) map.get(MediaFormat.KEY_AAC_PROFILE);
        if (profile == null) {
            profile = aacProfile;
        } else if (aacProfile != null && !aacProfile.equals(profile)) {
            throw new IllegalArgumentException("conflicting values for profile and aac-profile");
        }
    }
    Integer quality = (Integer) map.get(MediaFormat.KEY_QUALITY);
    return supports(complexity, quality, profile);
}
------------------------
Find a silently evolved API code:android.accounts.AbstractAccountAuthenticator.addAccountFromCredentials:COMMENT
Method Modifier: public      
Comment:/**
 * Creates an account based on credentials provided by the authenticator instance of another
 * user on the device, who has chosen to share the account with this user.
 * @param response to send the result back to the AccountManager, will never be null
 * @param account the account to clone, will never be null
 * @param accountCredentials the Bundle containing the required credentials to create the
 * account. Contents of the Bundle are only meaningful to the authenticator. This Bundle is
 * provided by {@link #getAccountCredentialsForCloning(AccountAuthenticatorResponse, Account)}.
 * @return a Bundle result or null if the result is to be returned via the response.
 * @throws NetworkErrorException
 * @see {@link #getAccountCredentialsForCloning(AccountAuthenticatorResponse, Account)}
 */

Body of Frist Method:
{
    new Thread(new Runnable() {

        public void run() {
            Bundle result = new Bundle();
            result.putBoolean(AccountManager.KEY_BOOLEAN_RESULT, false);
            response.onResult(result);
        }
    }).start();
    return null;
}
Body of Second Method:
{
    new Thread(new Runnable() {

        @Override
        public void run() {
            Bundle result = new Bundle();
            result.putBoolean(AccountManager.KEY_BOOLEAN_RESULT, false);
            response.onResult(result);
        }
    }).start();
    return null;
}
------------------------
Find a silently evolved API code:android.content.pm.PackageManager.movePackage:COMMENT
<android.content.pm.PackageManager: void movePackage(String,IPackageMoveObserver,int)>
public      abstract    hidden      ->public      hidden      deprecated  
Method Modifier: public      abstract    hidden      deprecated  
Method Modifier: Yes         Yes         Yes         No          
Method Updated:  Yes         No          Yes         Yes         
Comment:/**
 * Attempts to move package resources from internal to external media or vice versa.
 * Since this may take a little while, the result will
 * be posted back to the given observer.   This call may fail if the calling context
 * lacks the {@link android.Manifest.permission#MOVE_PACKAGE} permission, if the
 * named package cannot be found, or if the named package is a "system package".
 *
 * @param packageName The name of the package to delete
 * @param observer An observer callback to get notified when the package move is
 * complete. {@link android.content.pm.IPackageMoveObserver#packageMoved(boolean)} will be
 * called when that happens.  observer may be null to indicate that no callback is desired.
 * @param flags To indicate install location {@link #MOVE_INTERNAL} or
 * {@link #MOVE_EXTERNAL_MEDIA}
 *
 * @hide
 */

Body of Frist Method:

Body of Second Method:
{
    throw new UnsupportedOperationException();
}
------------------------
Find a silently evolved API code:android.media.ImageReader.getNumPlanesFromFormat:COMMENT
Method Modifier: private     
Comment:/**
 * Only a subset of the formats defined in
 * {@link android.graphics.ImageFormat ImageFormat} and
 * {@link android.graphics.PixelFormat PixelFormat} are supported by
 * ImageReader. When reading RGB data from a surface, the formats defined in
 * {@link android.graphics.PixelFormat PixelFormat} can be used, when
 * reading YUV, JPEG or raw sensor data (for example, from camera or video
 * decoder), formats from {@link android.graphics.ImageFormat ImageFormat}
 * are used.
 */

Body of Frist Method:
{
    switch(mFormat) {
        case ImageFormat.YV12:
        case ImageFormat.YUV_420_888:
        case ImageFormat.NV21:
            return 3;
        case ImageFormat.NV16:
            return 2;
        case PixelFormat.RGB_565:
        case PixelFormat.RGBA_8888:
        case PixelFormat.RGBX_8888:
        case PixelFormat.RGB_888:
        case ImageFormat.JPEG:
        case ImageFormat.YUY2:
        case ImageFormat.Y8:
        case ImageFormat.Y16:
        case ImageFormat.RAW_SENSOR:
        case ImageFormat.RAW10:
            return 1;
        default:
            throw new UnsupportedOperationException(String.format("Invalid format specified %d", mFormat));
    }
}
Body of Second Method:
{
    switch(mFormat) {
        case ImageFormat.YV12:
        case ImageFormat.YUV_420_888:
        case ImageFormat.NV21:
            return 3;
        case ImageFormat.NV16:
            return 2;
        case PixelFormat.RGB_565:
        case PixelFormat.RGBA_8888:
        case PixelFormat.RGBX_8888:
        case PixelFormat.RGB_888:
        case ImageFormat.JPEG:
        case ImageFormat.YUY2:
        case ImageFormat.Y8:
        case ImageFormat.Y16:
        case ImageFormat.RAW_SENSOR:
        case ImageFormat.RAW10:
        case ImageFormat.DEPTH16:
        case ImageFormat.DEPTH_POINT_CLOUD:
            return 1;
        case ImageFormat.PRIVATE:
            return 0;
        default:
            throw new UnsupportedOperationException(String.format("Invalid format specified %d", mFormat));
    }
}
------------------------
Find a silently evolved API code:android.content.res.BridgeResources.initSystem:COMMENT
Method Modifier: public      static      
Comment:/**
 * This initializes the static field {@link Resources#mSystem} which is used
 * by methods who get global resources using {@link Resources#getSystem()}.
 * <p/>
 * They will end up using our bridge resources.
 * <p/>
 * {@link Bridge} calls this method after setting up a new bridge.
 */

Body of Frist Method:
{
    return Resources.mSystem = new BridgeResources(context, assets, metrics, config, projectCallback);
}
Body of Second Method:
{
    return Resources.mSystem = new BridgeResources(context, assets, metrics, config, layoutlibCallback);
}
------------------------
Find a silently evolved API code:android.media.AudioManager.setMicrophoneMute:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the microphone mute on or off.
 * <p>
 * This method should only be used by applications that replace the platform-wide
 * management of audio settings or the main telephony application.
 *
 * @param on set <var>true</var> to mute the microphone;
 * <var>false</var> to turn mute off
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        service.setMicrophoneMute(on, mContext.getOpPackageName());
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in setMicrophoneMute", e);
    }
}
Body of Second Method:
{
    IAudioService service = getService();
    try {
        service.setMicrophoneMute(on, getContext().getOpPackageName(), UserHandle.getCallingUserId());
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in setMicrophoneMute", e);
    }
}
------------------------
Find a silently evolved API code:android.media.AudioManager.disableSafeMediaVolume:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Only useful for volume controllers.
 * @hide
 */

Body of Frist Method:
{
    try {
        getService().disableSafeMediaVolume();
    } catch (RemoteException e) {
        Log.w(TAG, "Error disabling safe media volume", e);
    }
}
Body of Second Method:
{
    try {
        getService().disableSafeMediaVolume(mApplicationContext.getOpPackageName());
    } catch (RemoteException e) {
        Log.w(TAG, "Error disabling safe media volume", e);
    }
}
------------------------
Find a silently evolved API code:android.transition.Transition.matchInstances:COMMENT
Method Modifier: private     
Comment:/**
 * Match start/end values by View instance. Adds matched values to mStartValuesList
 * and mEndValuesList and removes them from unmatchedStart and unmatchedEnd.
 */

Body of Frist Method:
{
    for (int i = unmatchedStart.size() - 1; i >= 0; i--) {
        View view = unmatchedStart.keyAt(i);
        TransitionValues end = unmatchedEnd.remove(view);
        if (end != null) {
            TransitionValues start = unmatchedStart.removeAt(i);
            mStartValuesList.add(start);
            mEndValuesList.add(end);
        }
    }
}
Body of Second Method:
{
    for (int i = unmatchedStart.size() - 1; i >= 0; i--) {
        View view = unmatchedStart.keyAt(i);
        if (view != null && isValidTarget(view)) {
            TransitionValues end = unmatchedEnd.remove(view);
            if (end != null && end.view != null && isValidTarget(end.view)) {
                TransitionValues start = unmatchedStart.removeAt(i);
                mStartValuesList.add(start);
                mEndValuesList.add(end);
            }
        }
    }
}
------------------------
Find a silently evolved API code:android.os.StrictMode.ViolationInfo.writeToParcel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Save a ViolationInfo instance to a parcel.
 */

Body of Frist Method:
{
    crashInfo.writeToParcel(dest, flags);
    int start = dest.dataPosition();
    dest.writeInt(policy);
    dest.writeInt(durationMillis);
    dest.writeInt(violationNumThisLoop);
    dest.writeInt(numAnimationsRunning);
    dest.writeLong(violationUptimeMillis);
    dest.writeLong(numInstances);
    dest.writeString(broadcastIntentAction);
    dest.writeStringArray(tags);
    int total = dest.dataPosition() - start;
    if (total > 10 * 1024) {
        Slog.d(TAG, "VIO: policy=" + policy + " dur=" + durationMillis + " numLoop=" + violationNumThisLoop + " anim=" + numAnimationsRunning + " uptime=" + violationUptimeMillis + " numInst=" + numInstances);
        Slog.d(TAG, "VIO: action=" + broadcastIntentAction);
        Slog.d(TAG, "VIO: tags=" + Arrays.toString(tags));
        Slog.d(TAG, "VIO: TOTAL BYTES WRITTEN: " + (dest.dataPosition() - start));
    }
}
Body of Second Method:
{
    dest.writeString(message);
    crashInfo.writeToParcel(dest, flags);
    int start = dest.dataPosition();
    dest.writeInt(policy);
    dest.writeInt(durationMillis);
    dest.writeInt(violationNumThisLoop);
    dest.writeInt(numAnimationsRunning);
    dest.writeLong(violationUptimeMillis);
    dest.writeLong(numInstances);
    dest.writeString(broadcastIntentAction);
    dest.writeStringArray(tags);
    int total = dest.dataPosition() - start;
    if (total > 10 * 1024) {
        Slog.d(TAG, "VIO: policy=" + policy + " dur=" + durationMillis + " numLoop=" + violationNumThisLoop + " anim=" + numAnimationsRunning + " uptime=" + violationUptimeMillis + " numInst=" + numInstances);
        Slog.d(TAG, "VIO: action=" + broadcastIntentAction);
        Slog.d(TAG, "VIO: tags=" + Arrays.toString(tags));
        Slog.d(TAG, "VIO: TOTAL BYTES WRITTEN: " + (dest.dataPosition() - start));
    }
}
------------------------
Find a silently evolved API code:android.app.DialogFragment.getLayoutInflater:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (!mShowsDialog) {
        return super.getLayoutInflater(savedInstanceState);
    }
    mDialog = onCreateDialog(savedInstanceState);
    switch(mStyle) {
        case STYLE_NO_INPUT:
            mDialog.getWindow().addFlags(WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE);
        // fall through...
        case STYLE_NO_FRAME:
        case STYLE_NO_TITLE:
            mDialog.requestWindowFeature(Window.FEATURE_NO_TITLE);
    }
    if (mDialog != null) {
        return (LayoutInflater) mDialog.getContext().getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    }
    return (LayoutInflater) mActivity.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
}
Body of Second Method:
{
    if (!mShowsDialog) {
        return super.getLayoutInflater(savedInstanceState);
    }
    mDialog = onCreateDialog(savedInstanceState);
    switch(mStyle) {
        case STYLE_NO_INPUT:
            mDialog.getWindow().addFlags(WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE);
        // fall through...
        case STYLE_NO_FRAME:
        case STYLE_NO_TITLE:
            mDialog.requestWindowFeature(Window.FEATURE_NO_TITLE);
    }
    if (mDialog != null) {
        return (LayoutInflater) mDialog.getContext().getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    }
    return (LayoutInflater) mHost.getContext().getSystemService(Context.LAYOUT_INFLATER_SERVICE);
}
------------------------
Find a silently evolved API code:android.util.EventLog.Event.decodeObject:COMMENT
Method Modifier: private     
Comment:/**
 * @return the loggable item at the current position in mBuffer.
 */

Body of Frist Method:
{
    byte type = mBuffer.get();
    switch(type) {
        case INT_TYPE:
            return (Integer) mBuffer.getInt();
        case LONG_TYPE:
            return (Long) mBuffer.getLong();
        case STRING_TYPE:
            try {
                int length = mBuffer.getInt();
                int start = mBuffer.position();
                mBuffer.position(start + length);
                return new String(mBuffer.array(), start, length, "UTF-8");
            } catch (UnsupportedEncodingException e) {
                Log.wtf(TAG, "UTF-8 is not supported", e);
                return null;
            }
        case LIST_TYPE:
            int length = mBuffer.get();
            // treat as signed byte
            if (length < 0)
                length += 256;
            Object[] array = new Object[length];
            for (int i = 0; i < length; ++i) array[i] = decodeObject();
            return array;
        default:
            throw new IllegalArgumentException("Unknown entry type: " + type);
    }
}
Body of Second Method:
{
    byte type = mBuffer.get();
    switch(type) {
        case INT_TYPE:
            return mBuffer.getInt();
        case LONG_TYPE:
            return mBuffer.getLong();
        case FLOAT_TYPE:
            return mBuffer.getFloat();
        case STRING_TYPE:
            try {
                int length = mBuffer.getInt();
                int start = mBuffer.position();
                mBuffer.position(start + length);
                return new String(mBuffer.array(), start, length, "UTF-8");
            } catch (UnsupportedEncodingException e) {
                Log.wtf(TAG, "UTF-8 is not supported", e);
                return null;
            }
        case LIST_TYPE:
            int length = mBuffer.get();
            // treat as signed byte
            if (length < 0)
                length += 256;
            Object[] array = new Object[length];
            for (int i = 0; i < length; ++i) array[i] = decodeObject();
            return array;
        default:
            throw new IllegalArgumentException("Unknown entry type: " + type);
    }
}
------------------------
Find a silently evolved API code:android.graphics.Bitmap.isPremultiplied:COMMENT
Method Modifier: public      final       
Comment:/**
 * <p>Indicates whether pixels stored in this bitmaps are stored pre-multiplied.
 * When a pixel is pre-multiplied, the RGB components have been multiplied by
 * the alpha component. For instance, if the original color is a 50%
 * translucent red <code>(128, 255, 0, 0)</code>, the pre-multiplied form is
 * <code>(128, 128, 0, 0)</code>.</p>
 *
 * <p>This method always returns false if {@link #getConfig()} is
 * {@link Bitmap.Config#RGB_565}.</p>
 *
 * <p>The return value is undefined if {@link #getConfig()} is
 * {@link Bitmap.Config#ALPHA_8}.</p>
 *
 * <p>This method only returns true if {@link #hasAlpha()} returns true.
 * A bitmap with no alpha channel can be used both as a pre-multiplied and
 * as a non pre-multiplied bitmap.</p>
 *
 * <p>Only pre-multiplied bitmaps may be drawn by the view system or
 * {@link Canvas}. If a non-pre-multiplied bitmap with an alpha channel is
 * drawn to a Canvas, a RuntimeException will be thrown.</p>
 *
 * @return true if the underlying pixels have been pre-multiplied, false
 * otherwise
 *
 * @see Bitmap#setPremultiplied(boolean)
 * @see BitmapFactory.Options#inPremultiplied
 */

Body of Frist Method:
{
    return nativeIsPremultiplied(mNativeBitmap);
}
Body of Second Method:
{
    if (mRecycled) {
        Log.w(TAG, "Called isPremultiplied() on a recycle()'d bitmap! This is undefined behavior!");
    }
    return nativeIsPremultiplied(mFinalizer.mNativeBitmap);
}
------------------------
Find a silently evolved API code:android.os.RecoverySystem.installPackage:COMMENT
Method Modifier: public      static      
Comment:/**
 * Reboots the device in order to install the given update
 * package.
 * Requires the {@link android.Manifest.permission#REBOOT} permission.
 *
 * @param context      the Context to use
 * @param packageFile  the update package to install.  Must be on
 * a partition mountable by recovery.  (The set of partitions
 * known to recovery may vary from device to device.  Generally,
 * /cache and /data are safe.)
 *
 * @throws IOException  if writing the recovery command file
 * fails, or if the reboot itself fails.
 */

Body of Frist Method:
{
    String filename = packageFile.getCanonicalPath();
    Log.w(TAG, "!!! REBOOTING TO INSTALL " + filename + " !!!");
    final String filenameArg = "--update_package=" + filename;
    final String localeArg = "--locale=" + Locale.getDefault().toString();
    bootCommand(context, filenameArg, localeArg);
}
Body of Second Method:
{
    String filename = packageFile.getCanonicalPath();
    FileWriter uncryptFile = new FileWriter(UNCRYPT_FILE);
    try {
        uncryptFile.write(filename + "\n");
    } finally {
        uncryptFile.close();
    }
    Log.w(TAG, "!!! REBOOTING TO INSTALL " + filename + " !!!");
    // into COMMAND_FILE instead.
    if (filename.startsWith("/data/")) {
        filename = "@/cache/recovery/block.map";
    }
    final String filenameArg = "--update_package=" + filename;
    final String localeArg = "--locale=" + Locale.getDefault().toString();
    bootCommand(context, filenameArg, localeArg);
}
------------------------
Find a silently evolved API code:android.webkit.WebView.evaluateJavascript:COMMENT
Method Modifier: public      
Comment:/**
 * Asynchronously evaluates JavaScript in the context of the currently displayed page.
 * If non-null, |resultCallback| will be invoked with any result returned from that
 * execution. This method must be called on the UI thread and the callback will
 * be made on the UI thread.
 *
 * @param script the JavaScript to execute.
 * @param resultCallback A callback to be invoked when the script execution
 * completes with the result of the execution (if any).
 * May be null if no notificaion of the result is required.
 */

Body of Frist Method:
{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, "evaluateJavascript=" + script);
    mProvider.evaluateJavaScript(script, resultCallback);
}
Body of Second Method:
{
    checkThread();
    mProvider.evaluateJavaScript(script, resultCallback);
}
------------------------
Find a silently evolved API code:android.content.res.Configuration.generateDelta:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Generate a delta Configuration between <code>base</code> and <code>change</code>. The
 * resulting delta can be used with {@link #updateFrom(Configuration)}.
 * <p />
 * Caveat: If the any of the Configuration's members becomes undefined, then
 * {@link #updateFrom(Configuration)} will treat it as a no-op and not update that member.
 *
 * This is fine for device configurations as no member is ever undefined.
 * {@hide}
 */

Body of Frist Method:
{
    final Configuration delta = new Configuration();
    if (base.fontScale != change.fontScale) {
        delta.fontScale = change.fontScale;
    }
    if (base.mcc != change.mcc) {
        delta.mcc = change.mcc;
    }
    if (base.mnc != change.mnc) {
        delta.mnc = change.mnc;
    }
    if ((base.locale == null && change.locale != null) || (base.locale != null && !base.locale.equals(change.locale))) {
        delta.locale = change.locale;
    }
    if (base.touchscreen != change.touchscreen) {
        delta.touchscreen = change.touchscreen;
    }
    if (base.keyboard != change.keyboard) {
        delta.keyboard = change.keyboard;
    }
    if (base.keyboardHidden != change.keyboardHidden) {
        delta.keyboardHidden = change.keyboardHidden;
    }
    if (base.navigation != change.navigation) {
        delta.navigation = change.navigation;
    }
    if (base.navigationHidden != change.navigationHidden) {
        delta.navigationHidden = change.navigationHidden;
    }
    if (base.orientation != change.orientation) {
        delta.orientation = change.orientation;
    }
    if ((base.screenLayout & SCREENLAYOUT_SIZE_MASK) != (change.screenLayout & SCREENLAYOUT_SIZE_MASK)) {
        delta.screenLayout |= change.screenLayout & SCREENLAYOUT_SIZE_MASK;
    }
    if ((base.screenLayout & SCREENLAYOUT_LAYOUTDIR_MASK) != (change.screenLayout & SCREENLAYOUT_LAYOUTDIR_MASK)) {
        delta.screenLayout |= change.screenLayout & SCREENLAYOUT_LAYOUTDIR_MASK;
    }
    if ((base.screenLayout & SCREENLAYOUT_LONG_MASK) != (change.screenLayout & SCREENLAYOUT_LONG_MASK)) {
        delta.screenLayout |= change.screenLayout & SCREENLAYOUT_LONG_MASK;
    }
    if ((base.uiMode & UI_MODE_TYPE_MASK) != (change.uiMode & UI_MODE_TYPE_MASK)) {
        delta.uiMode |= change.uiMode & UI_MODE_TYPE_MASK;
    }
    if ((base.uiMode & UI_MODE_NIGHT_MASK) != (change.uiMode & UI_MODE_NIGHT_MASK)) {
        delta.uiMode |= change.uiMode & UI_MODE_NIGHT_MASK;
    }
    if (base.screenWidthDp != change.screenWidthDp) {
        delta.screenWidthDp = change.screenWidthDp;
    }
    if (base.screenHeightDp != change.screenHeightDp) {
        delta.screenHeightDp = change.screenHeightDp;
    }
    if (base.smallestScreenWidthDp != change.smallestScreenWidthDp) {
        delta.smallestScreenWidthDp = change.smallestScreenWidthDp;
    }
    if (base.densityDpi != change.densityDpi) {
        delta.densityDpi = change.densityDpi;
    }
    return delta;
}
Body of Second Method:
{
    final Configuration delta = new Configuration();
    if (base.fontScale != change.fontScale) {
        delta.fontScale = change.fontScale;
    }
    if (base.mcc != change.mcc) {
        delta.mcc = change.mcc;
    }
    if (base.mnc != change.mnc) {
        delta.mnc = change.mnc;
    }
    if ((base.locale == null && change.locale != null) || (base.locale != null && !base.locale.equals(change.locale))) {
        delta.locale = change.locale;
    }
    if (base.touchscreen != change.touchscreen) {
        delta.touchscreen = change.touchscreen;
    }
    if (base.keyboard != change.keyboard) {
        delta.keyboard = change.keyboard;
    }
    if (base.keyboardHidden != change.keyboardHidden) {
        delta.keyboardHidden = change.keyboardHidden;
    }
    if (base.navigation != change.navigation) {
        delta.navigation = change.navigation;
    }
    if (base.navigationHidden != change.navigationHidden) {
        delta.navigationHidden = change.navigationHidden;
    }
    if (base.orientation != change.orientation) {
        delta.orientation = change.orientation;
    }
    if ((base.screenLayout & SCREENLAYOUT_SIZE_MASK) != (change.screenLayout & SCREENLAYOUT_SIZE_MASK)) {
        delta.screenLayout |= change.screenLayout & SCREENLAYOUT_SIZE_MASK;
    }
    if ((base.screenLayout & SCREENLAYOUT_LAYOUTDIR_MASK) != (change.screenLayout & SCREENLAYOUT_LAYOUTDIR_MASK)) {
        delta.screenLayout |= change.screenLayout & SCREENLAYOUT_LAYOUTDIR_MASK;
    }
    if ((base.screenLayout & SCREENLAYOUT_LONG_MASK) != (change.screenLayout & SCREENLAYOUT_LONG_MASK)) {
        delta.screenLayout |= change.screenLayout & SCREENLAYOUT_LONG_MASK;
    }
    if ((base.screenLayout & SCREENLAYOUT_ROUND_MASK) != (change.screenLayout & SCREENLAYOUT_ROUND_MASK)) {
        delta.screenLayout |= change.screenLayout & SCREENLAYOUT_ROUND_MASK;
    }
    if ((base.uiMode & UI_MODE_TYPE_MASK) != (change.uiMode & UI_MODE_TYPE_MASK)) {
        delta.uiMode |= change.uiMode & UI_MODE_TYPE_MASK;
    }
    if ((base.uiMode & UI_MODE_NIGHT_MASK) != (change.uiMode & UI_MODE_NIGHT_MASK)) {
        delta.uiMode |= change.uiMode & UI_MODE_NIGHT_MASK;
    }
    if (base.screenWidthDp != change.screenWidthDp) {
        delta.screenWidthDp = change.screenWidthDp;
    }
    if (base.screenHeightDp != change.screenHeightDp) {
        delta.screenHeightDp = change.screenHeightDp;
    }
    if (base.smallestScreenWidthDp != change.smallestScreenWidthDp) {
        delta.smallestScreenWidthDp = change.smallestScreenWidthDp;
    }
    if (base.densityDpi != change.densityDpi) {
        delta.densityDpi = change.densityDpi;
    }
    return delta;
}
------------------------
Find a silently evolved API code:android.graphics.Canvas.drawPoint:COMMENT
Method Modifier: public      
Comment:/**
 * Helper for drawPoints() for drawing a single point.
 */

Body of Frist Method:
{
    native_drawPoint(mNativeCanvasWrapper, x, y, paint.mNativePaint);
}
Body of Second Method:
{
    native_drawPoint(mNativeCanvasWrapper, x, y, paint.getNativeInstance());
}
------------------------
Find a silently evolved API code:android.media.audiofx.NoiseSuppressor.create:COMMENT
Method Modifier: public      static      
Comment:/**
 * Creates a NoiseSuppressor and attaches it to the AudioRecord on the audio
 * session specified.
 * @param audioSession system wide unique audio session identifier. The NoiseSuppressor
 * will be applied to the AudioRecord with the same audio session.
 * @return NoiseSuppressor created or null if the device does not implement noise
 * suppression.
 */

Body of Frist Method:
{
    NoiseSuppressor ns = null;
    try {
        ns = new NoiseSuppressor(audioSession);
    } catch (IllegalArgumentException e) {
        Log.w(TAG, "not implemented on this device " + ns);
    } catch (UnsupportedOperationException e) {
        Log.w(TAG, "not enough resources");
    } catch (RuntimeException e) {
        Log.w(TAG, "not enough memory");
    } finally {
        return ns;
    }
}
Body of Second Method:
{
    NoiseSuppressor ns = null;
    try {
        ns = new NoiseSuppressor(audioSession);
    } catch (IllegalArgumentException e) {
        Log.w(TAG, "not implemented on this device " + ns);
    } catch (UnsupportedOperationException e) {
        Log.w(TAG, "not enough resources");
    } catch (RuntimeException e) {
        Log.w(TAG, "not enough memory");
    }
    return ns;
}
------------------------
Find a silently evolved API code:android.view.HardwareRenderer.isAvailable:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Indicates whether hardware acceleration is available under any form for
 * the view hierarchy.
 *
 * @return True if the view hierarchy can potentially be hardware accelerated,
 * false otherwise
 */

Body of Frist Method:
{
    return GLES20Canvas.isAvailable();
}
Body of Second Method:
{
    return DisplayListCanvas.isAvailable();
}
------------------------
Find a silently evolved API code:android.media.AudioManager.listAudioPorts:COMMENT
<android.media.AudioManager: int listAudioPorts(ArrayList<AudioPort>)>
public      hidden      ->public      static      hidden      
Method Modifier: public      static      hidden      
Method Modifier: Yes         No          Yes         
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * Returns a list of descriptors for all audio ports managed by the audio framework.
 * Audio ports are nodes in the audio framework or audio hardware that can be configured
 * or connected and disconnected with createAudioPatch() or releaseAudioPatch().
 * See AudioPort for a list of attributes of each audio port.
 * @param ports An AudioPort ArrayList where the list will be returned.
 * @hide
 */

Body of Frist Method:
{
    return updateAudioPortCache(ports, null);
}
Body of Second Method:
{
    return updateAudioPortCache(ports, null, null);
}
------------------------
Find a silently evolved API code:android.app.Notification.cloneInto:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Copy all (or if heavy is false, all except Bitmaps and RemoteViews) members
 * of this into that.
 * @hide
 */

Body of Frist Method:
{
    that.when = this.when;
    that.icon = this.icon;
    that.number = this.number;
    // PendingIntents are global, so there's no reason (or way) to clone them.
    that.contentIntent = this.contentIntent;
    that.deleteIntent = this.deleteIntent;
    that.fullScreenIntent = this.fullScreenIntent;
    if (this.tickerText != null) {
        that.tickerText = this.tickerText.toString();
    }
    if (heavy && this.tickerView != null) {
        that.tickerView = this.tickerView.clone();
    }
    if (heavy && this.contentView != null) {
        that.contentView = this.contentView.clone();
    }
    if (heavy && this.largeIcon != null) {
        that.largeIcon = Bitmap.createBitmap(this.largeIcon);
    }
    that.iconLevel = this.iconLevel;
    // android.net.Uri is immutable
    that.sound = this.sound;
    that.audioStreamType = this.audioStreamType;
    if (this.audioAttributes != null) {
        that.audioAttributes = new AudioAttributes.Builder(this.audioAttributes).build();
    }
    final long[] vibrate = this.vibrate;
    if (vibrate != null) {
        final int N = vibrate.length;
        final long[] vib = that.vibrate = new long[N];
        System.arraycopy(vibrate, 0, vib, 0, N);
    }
    that.ledARGB = this.ledARGB;
    that.ledOnMS = this.ledOnMS;
    that.ledOffMS = this.ledOffMS;
    that.defaults = this.defaults;
    that.flags = this.flags;
    that.priority = this.priority;
    that.category = this.category;
    that.mGroupKey = this.mGroupKey;
    that.mSortKey = this.mSortKey;
    if (this.extras != null) {
        try {
            that.extras = new Bundle(this.extras);
            // will unparcel
            that.extras.size();
        } catch (BadParcelableException e) {
            Log.e(TAG, "could not unparcel extras from notification: " + this, e);
            that.extras = null;
        }
    }
    if (this.actions != null) {
        that.actions = new Action[this.actions.length];
        for (int i = 0; i < this.actions.length; i++) {
            that.actions[i] = this.actions[i].clone();
        }
    }
    if (heavy && this.bigContentView != null) {
        that.bigContentView = this.bigContentView.clone();
    }
    if (heavy && this.headsUpContentView != null) {
        that.headsUpContentView = this.headsUpContentView.clone();
    }
    that.visibility = this.visibility;
    if (this.publicVersion != null) {
        that.publicVersion = new Notification();
        this.publicVersion.cloneInto(that.publicVersion, heavy);
    }
    that.color = this.color;
    if (!heavy) {
        // will clean out extras
        that.lightenPayload();
    }
}
Body of Second Method:
{
    that.when = this.when;
    that.mSmallIcon = this.mSmallIcon;
    that.number = this.number;
    // PendingIntents are global, so there's no reason (or way) to clone them.
    that.contentIntent = this.contentIntent;
    that.deleteIntent = this.deleteIntent;
    that.fullScreenIntent = this.fullScreenIntent;
    if (this.tickerText != null) {
        that.tickerText = this.tickerText.toString();
    }
    if (heavy && this.tickerView != null) {
        that.tickerView = this.tickerView.clone();
    }
    if (heavy && this.contentView != null) {
        that.contentView = this.contentView.clone();
    }
    if (heavy && this.mLargeIcon != null) {
        that.mLargeIcon = this.mLargeIcon;
    }
    that.iconLevel = this.iconLevel;
    // android.net.Uri is immutable
    that.sound = this.sound;
    that.audioStreamType = this.audioStreamType;
    if (this.audioAttributes != null) {
        that.audioAttributes = new AudioAttributes.Builder(this.audioAttributes).build();
    }
    final long[] vibrate = this.vibrate;
    if (vibrate != null) {
        final int N = vibrate.length;
        final long[] vib = that.vibrate = new long[N];
        System.arraycopy(vibrate, 0, vib, 0, N);
    }
    that.ledARGB = this.ledARGB;
    that.ledOnMS = this.ledOnMS;
    that.ledOffMS = this.ledOffMS;
    that.defaults = this.defaults;
    that.flags = this.flags;
    that.priority = this.priority;
    that.category = this.category;
    that.mGroupKey = this.mGroupKey;
    that.mSortKey = this.mSortKey;
    if (this.extras != null) {
        try {
            that.extras = new Bundle(this.extras);
            // will unparcel
            that.extras.size();
        } catch (BadParcelableException e) {
            Log.e(TAG, "could not unparcel extras from notification: " + this, e);
            that.extras = null;
        }
    }
    if (this.actions != null) {
        that.actions = new Action[this.actions.length];
        for (int i = 0; i < this.actions.length; i++) {
            that.actions[i] = this.actions[i].clone();
        }
    }
    if (heavy && this.bigContentView != null) {
        that.bigContentView = this.bigContentView.clone();
    }
    if (heavy && this.headsUpContentView != null) {
        that.headsUpContentView = this.headsUpContentView.clone();
    }
    that.visibility = this.visibility;
    if (this.publicVersion != null) {
        that.publicVersion = new Notification();
        this.publicVersion.cloneInto(that.publicVersion, heavy);
    }
    that.color = this.color;
    if (!heavy) {
        // will clean out extras
        that.lightenPayload();
    }
}
------------------------
Find a silently evolved API code:android.net.NetworkRequest.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Build {@link NetworkRequest} give the current set of capabilities.
 */

Body of Frist Method:
{
    return new NetworkRequest(mNetworkCapabilities, ConnectivityManager.TYPE_NONE, ConnectivityManager.REQUEST_ID_UNSET);
}
Body of Second Method:
{
    // Make a copy of mNetworkCapabilities so we don't inadvertently remove NOT_RESTRICTED
    // when later an unrestricted capability could be added to mNetworkCapabilities, in
    // which case NOT_RESTRICTED should be returned to mNetworkCapabilities, which
    // maybeMarkCapabilitiesRestricted() doesn't add back.
    final NetworkCapabilities nc = new NetworkCapabilities(mNetworkCapabilities);
    nc.maybeMarkCapabilitiesRestricted();
    return new NetworkRequest(nc, ConnectivityManager.TYPE_NONE, ConnectivityManager.REQUEST_ID_UNSET);
}
------------------------
Find a silently evolved API code:android.content.res.BridgeTypedArray.getResourceId:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the resource identifier for the attribute at
 * <var>index</var>.  Note that attribute resource as resolved when
 * the overall {@link TypedArray} object is retrieved.  As a
 * result, this function will return the resource identifier of the
 * final resource value that was found, <em>not</em> necessarily the
 * original resource that was specified by the attribute.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute resource identifier, or defValue if not defined.
 */

Body of Frist Method:
{
    if (index < 0 || index >= mResourceData.length) {
        return defValue;
    }
    // get the Resource for this index
    ResourceValue resValue = mResourceData[index];
    // no data, return the default value.
    if (resValue == null) {
        return defValue;
    }
    // check if this is a style resource
    if (resValue instanceof StyleResourceValue) {
        // get the id that will represent this style.
        return mContext.getDynamicIdByStyle((StyleResourceValue) resValue);
    }
    // (and getValue() returning null!). We need to handle this!
    if (resValue.getResourceType() != null) {
        // if this is a framework id
        if (mPlatformFile || resValue.isFramework()) {
            // look for idName in the android R classes
            return mContext.getFrameworkResourceValue(resValue.getResourceType(), resValue.getName(), defValue);
        }
        // look for idName in the project R class.
        return mContext.getProjectResourceValue(resValue.getResourceType(), resValue.getName(), defValue);
    }
    // else, try to get the value, and resolve it somehow.
    String value = resValue.getValue();
    if (value == null) {
        return defValue;
    }
    // if the value is just an integer, return it.
    try {
        int i = Integer.parseInt(value);
        if (Integer.toString(i).equals(value)) {
            return i;
        }
    } catch (NumberFormatException e) {
    // pass
    }
    // if this is a reference to an id, find it.
    if (value.startsWith("@id/") || value.startsWith("@+") || value.startsWith("@android:id/")) {
        int pos = value.indexOf('/');
        String idName = value.substring(pos + 1);
        boolean create = value.startsWith("@+");
        boolean isFrameworkId = mPlatformFile || value.startsWith("@android") || value.startsWith("@+android");
        // Look for the idName in project or android R class depending on isPlatform.
        if (create) {
            Integer idValue;
            if (isFrameworkId) {
                idValue = Bridge.getResourceId(ResourceType.ID, idName);
            } else {
                idValue = mContext.getProjectCallback().getResourceId(ResourceType.ID, idName);
            }
            return idValue == null ? defValue : idValue;
        }
        // one is not found.
        if (isFrameworkId) {
            return mContext.getFrameworkResourceValue(ResourceType.ID, idName, defValue);
        } else {
            return mContext.getProjectResourceValue(ResourceType.ID, idName, defValue);
        }
    }
    // not a direct id valid reference? resolve it
    Integer idValue;
    if (resValue.isFramework()) {
        idValue = Bridge.getResourceId(resValue.getResourceType(), resValue.getName());
    } else {
        idValue = mContext.getProjectCallback().getResourceId(resValue.getResourceType(), resValue.getName());
    }
    if (idValue != null) {
        return idValue;
    }
    Bridge.getLog().warning(LayoutLog.TAG_RESOURCES_RESOLVE, String.format("Unable to resolve id \"%1$s\" for attribute \"%2$s\"", value, mNames[index]), resValue);
    return defValue;
}
Body of Second Method:
{
    if (index < 0 || index >= mResourceData.length) {
        return defValue;
    }
    // get the Resource for this index
    ResourceValue resValue = mResourceData[index];
    // no data, return the default value.
    if (resValue == null) {
        return defValue;
    }
    // check if this is a style resource
    if (resValue instanceof StyleResourceValue) {
        // get the id that will represent this style.
        return mContext.getDynamicIdByStyle((StyleResourceValue) resValue);
    }
    // (and getValue() returning null!). We need to handle this!
    if (resValue.getResourceType() != null) {
        // if this is a framework id
        if (mPlatformFile || resValue.isFramework()) {
            // look for idName in the android R classes
            return mContext.getFrameworkResourceValue(resValue.getResourceType(), resValue.getName(), defValue);
        }
        // look for idName in the project R class.
        return mContext.getProjectResourceValue(resValue.getResourceType(), resValue.getName(), defValue);
    }
    // else, try to get the value, and resolve it somehow.
    String value = resValue.getValue();
    if (value == null) {
        return defValue;
    }
    // if the value is just an integer, return it.
    try {
        int i = Integer.parseInt(value);
        if (Integer.toString(i).equals(value)) {
            return i;
        }
    } catch (NumberFormatException e) {
    // pass
    }
    // if this is a reference to an id, find it.
    if (value.startsWith("@id/") || value.startsWith("@+") || value.startsWith("@android:id/")) {
        int pos = value.indexOf('/');
        String idName = value.substring(pos + 1);
        boolean create = value.startsWith("@+");
        boolean isFrameworkId = mPlatformFile || value.startsWith("@android") || value.startsWith("@+android");
        // Look for the idName in project or android R class depending on isPlatform.
        if (create) {
            Integer idValue;
            if (isFrameworkId) {
                idValue = Bridge.getResourceId(ResourceType.ID, idName);
            } else {
                idValue = mContext.getLayoutlibCallback().getResourceId(ResourceType.ID, idName);
            }
            return idValue == null ? defValue : idValue;
        }
        // one is not found.
        if (isFrameworkId) {
            return mContext.getFrameworkResourceValue(ResourceType.ID, idName, defValue);
        } else {
            return mContext.getProjectResourceValue(ResourceType.ID, idName, defValue);
        }
    }
    // not a direct id valid reference? resolve it
    Integer idValue;
    if (resValue.isFramework()) {
        idValue = Bridge.getResourceId(resValue.getResourceType(), resValue.getName());
    } else {
        idValue = mContext.getLayoutlibCallback().getResourceId(resValue.getResourceType(), resValue.getName());
    }
    if (idValue != null) {
        return idValue;
    }
    Bridge.getLog().warning(LayoutLog.TAG_RESOURCES_RESOLVE, String.format("Unable to resolve id \"%1$s\" for attribute \"%2$s\"", value, mNames[index]), resValue);
    return defValue;
}
------------------------
Find a silently evolved API code:android.content.ContentResolver.openInputStream:COMMENT
Method Modifier: public      final       
Comment:/**
 * Open a stream on to the content associated with a content URI.  If there
 * is no data associated with the URI, FileNotFoundException is thrown.
 *
 * <h5>Accepts the following URI schemes:</h5>
 * <ul>
 * <li>content ({@link #SCHEME_CONTENT})</li>
 * <li>android.resource ({@link #SCHEME_ANDROID_RESOURCE})</li>
 * <li>file ({@link #SCHEME_FILE})</li>
 * </ul>
 *
 * <p>See {@link #openAssetFileDescriptor(Uri, String)} for more information
 * on these schemes.
 *
 * @param uri The desired URI.
 * @return InputStream
 * @throws FileNotFoundException if the provided URI could not be opened.
 * @see #openAssetFileDescriptor(Uri, String)
 */

Body of Frist Method:
{
    String scheme = uri.getScheme();
    if (SCHEME_ANDROID_RESOURCE.equals(scheme)) {
        // Note: left here to avoid breaking compatibility.  May be removed
        // with sufficient testing.
        OpenResourceIdResult r = getResourceId(uri);
        try {
            InputStream stream = r.r.openRawResource(r.id);
            return stream;
        } catch (Resources.NotFoundException ex) {
            throw new FileNotFoundException("Resource does not exist: " + uri);
        }
    } else if (SCHEME_FILE.equals(scheme)) {
        // with sufficient testing.
        return new FileInputStream(uri.getPath());
    } else {
        AssetFileDescriptor fd = openAssetFileDescriptor(uri, "r", null);
        try {
            return fd != null ? fd.createInputStream() : null;
        } catch (IOException e) {
            throw new FileNotFoundException("Unable to create stream");
        }
    }
}
Body of Second Method:
{
    Preconditions.checkNotNull(uri, "uri");
    String scheme = uri.getScheme();
    if (SCHEME_ANDROID_RESOURCE.equals(scheme)) {
        // Note: left here to avoid breaking compatibility.  May be removed
        // with sufficient testing.
        OpenResourceIdResult r = getResourceId(uri);
        try {
            InputStream stream = r.r.openRawResource(r.id);
            return stream;
        } catch (Resources.NotFoundException ex) {
            throw new FileNotFoundException("Resource does not exist: " + uri);
        }
    } else if (SCHEME_FILE.equals(scheme)) {
        // with sufficient testing.
        return new FileInputStream(uri.getPath());
    } else {
        AssetFileDescriptor fd = openAssetFileDescriptor(uri, "r", null);
        try {
            return fd != null ? fd.createInputStream() : null;
        } catch (IOException e) {
            throw new FileNotFoundException("Unable to create stream");
        }
    }
}
------------------------
Find a silently evolved API code:android.renderscript.Script.bindAllocation:COMMENT
Method Modifier: public      
Comment:/**
 * Only intended for use by generated reflected code.
 */

Body of Frist Method:
{
    mRS.validate();
    mRS.validateObject(va);
    if (va != null) {
        if (mRS.getApplicationContext().getApplicationInfo().targetSdkVersion >= 20) {
            final Type t = va.mType;
            if (t.hasMipmaps() || t.hasFaces() || (t.getY() != 0) || (t.getZ() != 0)) {
                throw new RSIllegalArgumentException("API 20+ only allows simple 1D allocations to be used with bind.");
            }
        }
        mRS.nScriptBindAllocation(getID(mRS), va.getID(mRS), slot);
    } else {
        mRS.nScriptBindAllocation(getID(mRS), 0, slot);
    }
}
Body of Second Method:
{
    mRS.validate();
    mRS.validateObject(va);
    if (va != null) {
        android.content.Context context = mRS.getApplicationContext();
        if (context.getApplicationInfo().targetSdkVersion >= 20) {
            final Type t = va.mType;
            if (t.hasMipmaps() || t.hasFaces() || (t.getY() != 0) || (t.getZ() != 0)) {
                throw new RSIllegalArgumentException("API 20+ only allows simple 1D allocations to be " + "used with bind.");
            }
        }
        mRS.nScriptBindAllocation(getID(mRS), va.getID(mRS), slot);
    } else {
        mRS.nScriptBindAllocation(getID(mRS), 0, slot);
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.le.BluetoothLeUtils.checkAdapterStateOn:COMMENT
Method Modifier: default     static      hidden      
Comment:/**
 * Ensure Bluetooth is turned on.
 *
 * @throws IllegalStateException If {@code adapter} is null or Bluetooth state is not
 * {@link BluetoothAdapter#STATE_ON}.
 */

Body of Frist Method:
{
    if (adapter == null || adapter.getState() != BluetoothAdapter.STATE_ON) {
        throw new IllegalStateException("BT Adapter is not turned ON");
    }
}
Body of Second Method:
{
    if (adapter == null || !adapter.isLeEnabled()) {
        // adapter.getState() != BluetoothAdapter.STATE_ON) {
        throw new IllegalStateException("BT Adapter is not turned ON");
    }
}
------------------------
Find a silently evolved API code:android.util.PathParser.getFloats:COMMENT
Method Modifier: private     static      hidden      
Comment:/**
 * Parse the floats in the string.
 * This is an optimized version of parseFloat(s.split(",|\\s"));
 *
 * @param s the string containing a command and list of floats
 * @return array of floats
 */

Body of Frist Method:
{
    if (s.charAt(0) == 'z' | s.charAt(0) == 'Z') {
        return new float[0];
    }
    try {
        float[] results = new float[s.length()];
        int count = 0;
        int startPosition = 1;
        int endPosition = 0;
        ExtractFloatResult result = new ExtractFloatResult();
        int totalLength = s.length();
        // number.
        while (startPosition < totalLength) {
            extract(s, startPosition, result);
            endPosition = result.mEndPosition;
            if (startPosition < endPosition) {
                results[count++] = Float.parseFloat(s.substring(startPosition, endPosition));
            }
            if (result.mEndWithNegOrDot) {
                // Keep the '-' or '.' sign with next number.
                startPosition = endPosition;
            } else {
                startPosition = endPosition + 1;
            }
        }
        return Arrays.copyOf(results, count);
    } catch (NumberFormatException e) {
        throw new RuntimeException("error in parsing \"" + s + "\"", e);
    }
}
Body of Second Method:
{
    if (s.charAt(0) == 'z' || s.charAt(0) == 'Z') {
        return new float[0];
    }
    try {
        float[] results = new float[s.length()];
        int count = 0;
        int startPosition = 1;
        int endPosition = 0;
        ExtractFloatResult result = new ExtractFloatResult();
        int totalLength = s.length();
        // number.
        while (startPosition < totalLength) {
            extract(s, startPosition, result);
            endPosition = result.mEndPosition;
            if (startPosition < endPosition) {
                results[count++] = Float.parseFloat(s.substring(startPosition, endPosition));
            }
            if (result.mEndWithNegOrDot) {
                // Keep the '-' or '.' sign with next number.
                startPosition = endPosition;
            } else {
                startPosition = endPosition + 1;
            }
        }
        return Arrays.copyOf(results, count);
    } catch (NumberFormatException e) {
        throw new RuntimeException("error in parsing \"" + s + "\"", e);
    }
}
------------------------

