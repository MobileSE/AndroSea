Find a silently evolved API code:android.webkit.WebSettings.setBlockNetworkImage:COMMENT
<android.webkit.WebSettings: void setBlockNetworkImage(boolean)>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Sets whether the WebView should not load image resources from the
 * network (resources accessed via http and https URI schemes).  Note
 * that this method has no effect unless
 * {@link #getLoadsImagesAutomatically} returns true. Also note that
 * disabling all network loads using {@link #setBlockNetworkLoads}
 * will also prevent network images from loading, even if this flag is set
 * to false. When the value of this setting is changed from true to false,
 * network images resources referenced by content currently displayed by
 * the WebView are fetched automatically. The default is false.
 *
 * @param flag whether the WebView should not load image resources from the
 * network
 * @see #setBlockNetworkLoads
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.widget.RadialTimePickerView.setCurrentHour:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets the current hour in 24-hour time.
 *
 * @param hour the current hour between 0 and 23 (inclusive)
 */

Body of Frist Method:
{
    final int degrees = (hour % 12) * DEGREES_FOR_ONE_HOUR;
    mSelectionDegrees[HOURS] = degrees;
    mSelectionDegrees[HOURS_INNER] = degrees;
    // 0 is 12 AM (midnight) and 12 is 12 PM (noon).
    mAmOrPm = (hour == 0 || (hour % 24) < 12) ? AM : PM;
    if (mIs24HourMode) {
        // Inner circle is 1 through 12.
        mIsOnInnerCircle = hour >= 1 && hour <= 12;
    } else {
        mIsOnInnerCircle = false;
    }
    initData();
    updateLayoutData();
    invalidate();
}
Body of Second Method:
{
    setCurrentHourInternal(hour, true, false);
}
------------------------
Find a silently evolved API code:android.webkit.WebSettings.getSavePassword:COMMENT
<android.webkit.WebSettings: boolean getSavePassword()>
public      deprecated  ->public      abstract    deprecated  
Method Modifier: public      abstract    deprecated  
Method Modifier: Yes         No          Yes         
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * Gets whether the WebView saves passwords.
 *
 * @return whether the WebView saves passwords
 * @see #setSavePassword
 * @deprecated Saving passwords in WebView will not be supported in future versions.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.content.res.BridgeTypedArray.getDrawable:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the Drawable for the attribute at <var>index</var>.  This
 * gets the resource ID of the selected attribute, and uses
 * {@link Resources#getDrawable Resources.getDrawable} of the owning
 * Resources object to retrieve its Drawable.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return Drawable for the attribute, or null if not defined.
 */

Body of Frist Method:
{
    if (!hasValue(index)) {
        return null;
    }
    ResourceValue value = mResourceData[index];
    return ResourceHelper.getDrawable(value, mContext);
}
Body of Second Method:
{
    if (!hasValue(index)) {
        return null;
    }
    ResourceValue value = mResourceData[index];
    return ResourceHelper.getDrawable(value, mContext, mTheme);
}
------------------------
Find a silently evolved API code:android.webkit.WebSettings.setBuiltInZoomControls:COMMENT
<android.webkit.WebSettings: void setBuiltInZoomControls(boolean)>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:// {@link WebView#getZoomControls}, which is now hidden.

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.content.res.Resources.loadDrawable:COMMENT
Method Modifier: default     
Comment:/*package*/

Body of Frist Method:
{
    if (TRACE_FOR_PRELOAD) {
        // Log only framework resources
        if ((id >>> 24) == 0x1) {
            final String name = getResourceName(id);
            if (name != null) {
                Log.d("PreloadDrawable", name);
            }
        }
    }
    final boolean isColorDrawable;
    final ArrayMap<String, LongSparseArray<WeakReference<ConstantState>>> caches;
    final long key;
    if (value.type >= TypedValue.TYPE_FIRST_COLOR_INT && value.type <= TypedValue.TYPE_LAST_COLOR_INT) {
        isColorDrawable = true;
        caches = mColorDrawableCache;
        key = value.data;
    } else {
        isColorDrawable = false;
        caches = mDrawableCache;
        key = (((long) value.assetCookie) << 32) | value.data;
    }
    // that was inflated against the specified theme.
    if (!mPreloading) {
        final Drawable cachedDrawable = getCachedDrawable(caches, key, theme);
        if (cachedDrawable != null) {
            return cachedDrawable;
        }
    }
    // Next, check preloaded drawables. These are unthemed but may have
    // themeable attributes.
    final ConstantState cs;
    if (isColorDrawable) {
        cs = sPreloadedColorDrawables.get(key);
    } else {
        cs = sPreloadedDrawables[mConfiguration.getLayoutDirection()].get(key);
    }
    final Drawable dr;
    if (cs != null) {
        dr = cs.newDrawable(this, theme);
    } else if (isColorDrawable) {
        dr = new ColorDrawable(value.data);
    } else {
        dr = loadDrawableForCookie(value, id, theme);
    }
    // cache (either preload or themed).
    if (dr != null) {
        dr.setChangingConfigurations(value.changingConfigurations);
        cacheDrawable(value, theme, isColorDrawable, caches, key, dr);
    }
    return dr;
}
Body of Second Method:
{
    if (TRACE_FOR_PRELOAD) {
        // Log only framework resources
        if ((id >>> 24) == 0x1) {
            final String name = getResourceName(id);
            if (name != null) {
                Log.d("PreloadDrawable", name);
            }
        }
    }
    final boolean isColorDrawable;
    final ArrayMap<String, LongSparseArray<WeakReference<ConstantState>>> caches;
    final long key;
    if (value.type >= TypedValue.TYPE_FIRST_COLOR_INT && value.type <= TypedValue.TYPE_LAST_COLOR_INT) {
        isColorDrawable = true;
        caches = mColorDrawableCache;
        key = value.data;
    } else {
        isColorDrawable = false;
        caches = mDrawableCache;
        key = (((long) value.assetCookie) << 32) | value.data;
    }
    // that was inflated against the specified theme.
    if (!mPreloading) {
        final Drawable cachedDrawable = getCachedDrawable(caches, key, theme);
        if (cachedDrawable != null) {
            return cachedDrawable;
        }
    }
    // Next, check preloaded drawables. These are unthemed but may have
    // themeable attributes.
    final ConstantState cs;
    if (isColorDrawable) {
        cs = sPreloadedColorDrawables.get(key);
    } else {
        cs = sPreloadedDrawables[mConfiguration.getLayoutDirection()].get(key);
    }
    final Drawable dr;
    if (cs != null) {
        final Drawable clonedDr = cs.newDrawable(this);
        if (theme != null) {
            dr = clonedDr.mutate();
            dr.applyTheme(theme);
            dr.clearMutated();
        } else {
            dr = clonedDr;
        }
    } else if (isColorDrawable) {
        dr = new ColorDrawable(value.data);
    } else {
        dr = loadDrawableForCookie(value, id, theme);
    }
    // cache (either preload or themed).
    if (dr != null) {
        dr.setChangingConfigurations(value.changingConfigurations);
        cacheDrawable(value, theme, isColorDrawable, caches, key, dr);
    }
    return dr;
}
------------------------
Find a silently evolved API code:android.webkit.WebSettings.setStandardFontFamily:COMMENT
<android.webkit.WebSettings: void setStandardFontFamily(String)>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Sets the standard font family name. The default is "sans-serif".
 *
 * @param font a font family name
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.telephony.ServiceState.fillInNotifierBundle:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Set intent notifier Bundle based on service state.
 *
 * @param m intent notifier Bundle
 * @hide
 */

Body of Frist Method:
{
    m.putInt("voiceRegState", mVoiceRegState);
    m.putInt("dataRegState", mDataRegState);
    m.putBoolean("roaming", Boolean.valueOf(mRoaming));
    m.putString("operator-alpha-long", mOperatorAlphaLong);
    m.putString("operator-alpha-short", mOperatorAlphaShort);
    m.putString("operator-numeric", mOperatorNumeric);
    m.putBoolean("manual", Boolean.valueOf(mIsManualNetworkSelection));
    m.putInt("radioTechnology", mRilVoiceRadioTechnology);
    m.putInt("dataRadioTechnology", mRilDataRadioTechnology);
    m.putBoolean("cssIndicator", mCssIndicator);
    m.putInt("networkId", mNetworkId);
    m.putInt("systemId", mSystemId);
    m.putInt("cdmaRoamingIndicator", mCdmaRoamingIndicator);
    m.putInt("cdmaDefaultRoamingIndicator", mCdmaDefaultRoamingIndicator);
    m.putBoolean("emergencyOnly", Boolean.valueOf(mIsEmergencyOnly));
}
Body of Second Method:
{
    m.putInt("voiceRegState", mVoiceRegState);
    m.putInt("dataRegState", mDataRegState);
    m.putInt("voiceRoamingType", mVoiceRoamingType);
    m.putInt("dataRoamingType", mDataRoamingType);
    m.putString("operator-alpha-long", mVoiceOperatorAlphaLong);
    m.putString("operator-alpha-short", mVoiceOperatorAlphaShort);
    m.putString("operator-numeric", mVoiceOperatorNumeric);
    m.putString("data-operator-alpha-long", mDataOperatorAlphaLong);
    m.putString("data-operator-alpha-short", mDataOperatorAlphaShort);
    m.putString("data-operator-numeric", mDataOperatorNumeric);
    m.putBoolean("manual", Boolean.valueOf(mIsManualNetworkSelection));
    m.putInt("radioTechnology", mRilVoiceRadioTechnology);
    m.putInt("dataRadioTechnology", mRilDataRadioTechnology);
    m.putBoolean("cssIndicator", mCssIndicator);
    m.putInt("networkId", mNetworkId);
    m.putInt("systemId", mSystemId);
    m.putInt("cdmaRoamingIndicator", mCdmaRoamingIndicator);
    m.putInt("cdmaDefaultRoamingIndicator", mCdmaDefaultRoamingIndicator);
    m.putBoolean("emergencyOnly", Boolean.valueOf(mIsEmergencyOnly));
}
------------------------
Find a silently evolved API code:android.telephony.PhoneNumberUtils.normalizeNumber:COMMENT
Method Modifier: public      static      
Comment:/**
 * Normalize a phone number by removing the characters other than digits. If
 * the given number has keypad letters, the letters will be converted to
 * digits first.
 *
 * @param phoneNumber the number to be normalized.
 * @return the normalized number.
 */

Body of Frist Method:
{
    if (TextUtils.isEmpty(phoneNumber)) {
        return "";
    }
    StringBuilder sb = new StringBuilder();
    int len = phoneNumber.length();
    for (int i = 0; i < len; i++) {
        char c = phoneNumber.charAt(i);
        // Character.digit() supports ASCII and Unicode digits (fullwidth, Arabic-Indic, etc.)
        int digit = Character.digit(c, 10);
        if (digit != -1) {
            sb.append(digit);
        } else if (i == 0 && c == '+') {
            sb.append(c);
        } else if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {
            return normalizeNumber(PhoneNumberUtils.convertKeypadLettersToDigits(phoneNumber));
        }
    }
    return sb.toString();
}
Body of Second Method:
{
    if (TextUtils.isEmpty(phoneNumber)) {
        return "";
    }
    StringBuilder sb = new StringBuilder();
    int len = phoneNumber.length();
    for (int i = 0; i < len; i++) {
        char c = phoneNumber.charAt(i);
        // Character.digit() supports ASCII and Unicode digits (fullwidth, Arabic-Indic, etc.)
        int digit = Character.digit(c, 10);
        if (digit != -1) {
            sb.append(digit);
        } else if (sb.length() == 0 && c == '+') {
            sb.append(c);
        } else if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {
            return normalizeNumber(PhoneNumberUtils.convertKeypadLettersToDigits(phoneNumber));
        }
    }
    return sb.toString();
}
------------------------
Find a silently evolved API code:android.webkit.WebSettings.setLoadsImagesAutomatically:COMMENT
<android.webkit.WebSettings: void setLoadsImagesAutomatically(boolean)>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Sets whether the WebView should load image resources. Note that this method
 * controls loading of all images, including those embedded using the data
 * URI scheme. Use {@link #setBlockNetworkImage} to control loading only
 * of images specified using network URI schemes. Note that if the value of this
 * setting is changed from false to true, all images resources referenced
 * by content currently displayed by the WebView are loaded automatically.
 * The default is true.
 *
 * @param flag whether the WebView should load image resources
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.webkit.CookieManager.setAcceptThirdPartyCookies:COMMENT
<android.webkit.CookieManager: void setAcceptThirdPartyCookies(WebView,boolean)>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Sets whether the {@link WebView} should allow third party cookies to be set.
 * Allowing third party cookies is a per WebView policy and can be set
 * differently on different WebView instances.
 * <p>
 * Apps that target {@link android.os.Build.VERSION_CODES#KITKAT} or below
 * default to allowing third party cookies. Apps targeting
 * {@link android.os.Build.VERSION_CODES#LOLLIPOP} or later default to disallowing
 * third party cookies.
 *
 * @param webview the {@link WebView} instance to set the cookie policy on
 * @param accept whether the {@link WebView} instance should accept
 * third party cookies
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.webkit.WebSettings.setMediaPlaybackRequiresUserGesture:COMMENT
<android.webkit.WebSettings: void setMediaPlaybackRequiresUserGesture(boolean)>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Sets whether the WebView requires a user gesture to play media.
 * The default is true.
 *
 * @param require whether the WebView requires a user gesture to play media
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.graphics.drawable.RippleDrawable.tryBackgroundEnter:COMMENT
Method Modifier: private     
Comment:/**
 * Creates an active hotspot at the specified location.
 */

Body of Frist Method:
{
    if (mBackground == null) {
        mBackground = new RippleBackground(this, mHotspotBounds);
    }
    final int color = mState.mColor.getColorForState(getState(), Color.TRANSPARENT);
    mBackground.setup(mState.mMaxRadius, color, mDensity);
    mBackground.enter();
}
Body of Second Method:
{
    if (mBackground == null) {
        mBackground = new RippleBackground(this, mHotspotBounds);
    }
    mBackground.setup(mState.mMaxRadius, mDensity);
    mBackground.enter(focused);
}
------------------------
Find a silently evolved API code:android.webkit.WebSettings.setDefaultZoom:COMMENT
<android.webkit.WebSettings: void setDefaultZoom(ZoomDensity)>
public      deprecated  ->public      abstract    deprecated  
Method Modifier: public      abstract    deprecated  
Method Modifier: Yes         No          Yes         
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * Sets the default zoom density of the page. This must be called from the UI
 * thread. The default is {@link ZoomDensity#MEDIUM}.
 *
 * This setting is not recommended for use in new applications.  If the WebView
 * is utilized to display mobile-oriented pages, the desired effect can be achieved by
 * adjusting 'width' and 'initial-scale' attributes of page's 'meta viewport'
 * tag. For pages lacking the tag, {@link android.webkit.WebView#setInitialScale}
 * and {@link #setUseWideViewPort} can be used.
 *
 * @param zoom the zoom density
 * @deprecated This method is no longer supported, see the function documentation for
 * recommended alternatives.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.view.ViewGroup.isTransformedTouchPointInView:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * Returns true if a child view contains the specified point when transformed
 * into its coordinate space.
 * Child must not be null.
 * @hide
 */

Body of Frist Method:
{
    float localX = x + mScrollX - child.mLeft;
    float localY = y + mScrollY - child.mTop;
    if (!child.hasIdentityMatrix() && mAttachInfo != null) {
        final float[] localXY = mAttachInfo.mTmpTransformLocation;
        localXY[0] = localX;
        localXY[1] = localY;
        child.getInverseMatrix().mapPoints(localXY);
        localX = localXY[0];
        localY = localXY[1];
    }
    final boolean isInView = child.pointInView(localX, localY);
    if (isInView && outLocalPoint != null) {
        outLocalPoint.set(localX, localY);
    }
    return isInView;
}
Body of Second Method:
{
    final float[] point = getTempPoint();
    point[0] = x;
    point[1] = y;
    transformPointToViewLocal(point, child);
    final boolean isInView = child.pointInView(point[0], point[1]);
    if (isInView && outLocalPoint != null) {
        outLocalPoint.set(point[0], point[1]);
    }
    return isInView;
}
------------------------
Find a silently evolved API code:android.media.AudioService.checkForRingerModeChange:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Checks if the adjustment should change ringer mode instead of just
 * adjusting volume. If so, this will set the proper ringer mode and volume
 * indices on the stream states.
 */

Body of Frist Method:
{
    int result = FLAG_ADJUST_VOLUME;
    int ringerMode = getRingerMode();
    switch(ringerMode) {
        case RINGER_MODE_NORMAL:
            if (direction == AudioManager.ADJUST_LOWER) {
                if (mHasVibrator) {
                    // (step <= oldIndex < 2 * step) is equivalent to: (old UI index == 1)
                    if (step <= oldIndex && oldIndex < 2 * step) {
                        ringerMode = RINGER_MODE_VIBRATE;
                    }
                } else {
                    // (oldIndex < step) is equivalent to (old UI index == 0)
                    if ((oldIndex < step) && VOLUME_SETS_RINGER_MODE_SILENT && mPrevVolDirection != AudioManager.ADJUST_LOWER) {
                        ringerMode = RINGER_MODE_SILENT;
                    }
                }
            }
            break;
        case RINGER_MODE_VIBRATE:
            if (!mHasVibrator) {
                Log.e(TAG, "checkForRingerModeChange() current ringer mode is vibrate" + "but no vibrator is present");
                break;
            }
            if ((direction == AudioManager.ADJUST_LOWER)) {
                if (VOLUME_SETS_RINGER_MODE_SILENT && mPrevVolDirection != AudioManager.ADJUST_LOWER) {
                    ringerMode = RINGER_MODE_SILENT;
                }
            } else if (direction == AudioManager.ADJUST_RAISE) {
                ringerMode = RINGER_MODE_NORMAL;
            }
            result &= ~FLAG_ADJUST_VOLUME;
            break;
        case RINGER_MODE_SILENT:
            if (direction == AudioManager.ADJUST_RAISE) {
                if (PREVENT_VOLUME_ADJUSTMENT_IF_SILENT) {
                    result |= AudioManager.FLAG_SHOW_SILENT_HINT;
                } else {
                    if (mHasVibrator) {
                        ringerMode = RINGER_MODE_VIBRATE;
                    } else {
                        ringerMode = RINGER_MODE_NORMAL;
                    }
                }
            }
            result &= ~FLAG_ADJUST_VOLUME;
            break;
        default:
            Log.e(TAG, "checkForRingerModeChange() wrong ringer mode: " + ringerMode);
            break;
    }
    setRingerMode(ringerMode, false);
    mPrevVolDirection = direction;
    return result;
}
Body of Second Method:
{
    int result = FLAG_ADJUST_VOLUME;
    int ringerMode = getRingerModeInternal();
    switch(ringerMode) {
        case RINGER_MODE_NORMAL:
            if (direction == AudioManager.ADJUST_LOWER) {
                if (mHasVibrator) {
                    // (step <= oldIndex < 2 * step) is equivalent to: (old UI index == 1)
                    if (step <= oldIndex && oldIndex < 2 * step) {
                        ringerMode = RINGER_MODE_VIBRATE;
                    }
                } else {
                    // (oldIndex < step) is equivalent to (old UI index == 0)
                    if ((oldIndex < step) && VOLUME_SETS_RINGER_MODE_SILENT && mPrevVolDirection != AudioManager.ADJUST_LOWER) {
                        ringerMode = RINGER_MODE_SILENT;
                    }
                }
            }
            break;
        case RINGER_MODE_VIBRATE:
            if (!mHasVibrator) {
                Log.e(TAG, "checkForRingerModeChange() current ringer mode is vibrate" + "but no vibrator is present");
                break;
            }
            if ((direction == AudioManager.ADJUST_LOWER)) {
                if (mPrevVolDirection != AudioManager.ADJUST_LOWER) {
                    if (VOLUME_SETS_RINGER_MODE_SILENT) {
                        ringerMode = RINGER_MODE_SILENT;
                    } else {
                        result |= AudioManager.FLAG_SHOW_VIBRATE_HINT;
                    }
                }
            } else if (direction == AudioManager.ADJUST_RAISE) {
                ringerMode = RINGER_MODE_NORMAL;
            }
            result &= ~FLAG_ADJUST_VOLUME;
            break;
        case RINGER_MODE_SILENT:
            if (direction == AudioManager.ADJUST_RAISE) {
                if (PREVENT_VOLUME_ADJUSTMENT_IF_SILENT) {
                    result |= AudioManager.FLAG_SHOW_SILENT_HINT;
                } else {
                    if (mHasVibrator) {
                        ringerMode = RINGER_MODE_VIBRATE;
                    } else {
                        ringerMode = RINGER_MODE_NORMAL;
                    }
                }
            }
            result &= ~FLAG_ADJUST_VOLUME;
            break;
        default:
            Log.e(TAG, "checkForRingerModeChange() wrong ringer mode: " + ringerMode);
            break;
    }
    setRingerMode(ringerMode, TAG + ".checkForRingerModeChange", false);
    mPrevVolDirection = direction;
    return result;
}
------------------------
Find a silently evolved API code:android.webkit.WebView.clearMatches:COMMENT
Method Modifier: public      
Comment:/**
 * Clears the highlighting surrounding text matches created by
 * {@link #findAllAsync}.
 */

Body of Frist Method:
{
    checkThread();
    if (DebugFlags.TRACE_API)
        Log.d(LOGTAG, "clearMatches");
    mProvider.clearMatches();
}
Body of Second Method:
{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, "clearMatches");
    mProvider.clearMatches();
}
------------------------
Find a silently evolved API code:android.animation.ValueAnimator.start:COMMENT
Method Modifier: private     
Comment:/**
 * Start the animation playing. This version of start() takes a boolean flag that indicates
 * whether the animation should play in reverse. The flag is usually false, but may be set
 * to true if called from the reverse() method.
 *
 * <p>The animation started by calling this method will be run on the thread that called
 * this method. This thread should have a Looper on it (a runtime exception will be thrown if
 * this is not the case). Also, if the animation will animate
 * properties of objects in the view hierarchy, then the calling thread should be the UI
 * thread for that view hierarchy.</p>
 *
 * @param playBackwards Whether the ValueAnimator should start playing in reverse.
 */

Body of Frist Method:
{
    if (Looper.myLooper() == null) {
        throw new AndroidRuntimeException("Animators may only be run on Looper threads");
    }
    mPlayingBackwards = playBackwards;
    mCurrentIteration = 0;
    mPlayingState = STOPPED;
    mStarted = true;
    mStartedDelay = false;
    mPaused = false;
    // in case the scale factor has changed since creation time
    updateScaledDuration();
    AnimationHandler animationHandler = getOrCreateAnimationHandler();
    animationHandler.mPendingAnimations.add(this);
    if (mStartDelay == 0) {
        // This sets the initial value of the animation, prior to actually starting it running
        setCurrentPlayTime(0);
        mPlayingState = STOPPED;
        mRunning = true;
        notifyStartListeners();
    }
    animationHandler.start();
}
Body of Second Method:
{
    if (Looper.myLooper() == null) {
        throw new AndroidRuntimeException("Animators may only be run on Looper threads");
    }
    mReversing = playBackwards;
    mPlayingBackwards = playBackwards;
    if (playBackwards && mSeekFraction != -1) {
        if (mSeekFraction == 0 && mCurrentIteration == 0) {
            // special case: reversing from seek-to-0 should act as if not seeked at all
            mSeekFraction = 0;
        } else if (mRepeatCount == INFINITE) {
            mSeekFraction = 1 - (mSeekFraction % 1);
        } else {
            mSeekFraction = 1 + mRepeatCount - (mCurrentIteration + mSeekFraction);
        }
        mCurrentIteration = (int) mSeekFraction;
        mSeekFraction = mSeekFraction % 1;
    }
    if (mCurrentIteration > 0 && mRepeatMode == REVERSE && (mCurrentIteration < (mRepeatCount + 1) || mRepeatCount == INFINITE)) {
        // figure out the correct direction to start playing based on the iteration
        if (playBackwards) {
            mPlayingBackwards = (mCurrentIteration % 2) == 0;
        } else {
            mPlayingBackwards = (mCurrentIteration % 2) != 0;
        }
    }
    int prevPlayingState = mPlayingState;
    mPlayingState = STOPPED;
    mStarted = true;
    mStartedDelay = false;
    mPaused = false;
    // in case the scale factor has changed since creation time
    updateScaledDuration();
    AnimationHandler animationHandler = getOrCreateAnimationHandler();
    animationHandler.mPendingAnimations.add(this);
    if (mStartDelay == 0) {
        // This sets the initial value of the animation, prior to actually starting it running
        if (prevPlayingState != SEEKED) {
            setCurrentPlayTime(0);
        }
        mPlayingState = STOPPED;
        mRunning = true;
        notifyStartListeners();
    }
    animationHandler.start();
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadset.close:COMMENT
Method Modifier: default     
Comment:/*package*/

Body of Frist Method:
{
    if (VDBG)
        log("close()");
    IBluetoothManager mgr = mAdapter.getBluetoothManager();
    if (mgr != null) {
        try {
            mgr.unregisterStateChangeCallback(mBluetoothStateChangeCallback);
        } catch (Exception e) {
            Log.e(TAG, "", e);
        }
    }
    synchronized (mConnection) {
        if (mService != null) {
            try {
                mService = null;
                mContext.unbindService(mConnection);
            } catch (Exception re) {
                Log.e(TAG, "", re);
            }
        }
    }
    mServiceListener = null;
}
Body of Second Method:
{
    if (VDBG)
        log("close()");
    IBluetoothManager mgr = mAdapter.getBluetoothManager();
    if (mgr != null) {
        try {
            mgr.unregisterStateChangeCallback(mBluetoothStateChangeCallback);
        } catch (Exception e) {
            Log.e(TAG, "", e);
        }
    }
    mServiceListener = null;
    doUnbind();
}
------------------------
Find a silently evolved API code:android.content.ContentProvider.enforceWritePermissionInner:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * {@hide}
 */

Body of Frist Method:
{
    final Context context = getContext();
    final int pid = Binder.getCallingPid();
    final int uid = Binder.getCallingUid();
    String missingPerm = null;
    if (UserHandle.isSameApp(uid, mMyUid)) {
        return;
    }
    if (mExported && checkUser(pid, uid, context)) {
        final String componentPerm = getWritePermission();
        if (componentPerm != null) {
            if (context.checkPermission(componentPerm, pid, uid) == PERMISSION_GRANTED) {
                return;
            } else {
                missingPerm = componentPerm;
            }
        }
        // track if unprotected write is allowed; any denied
        // <path-permission> below removes this ability
        boolean allowDefaultWrite = (componentPerm == null);
        final PathPermission[] pps = getPathPermissions();
        if (pps != null) {
            final String path = uri.getPath();
            for (PathPermission pp : pps) {
                final String pathPerm = pp.getWritePermission();
                if (pathPerm != null && pp.match(path)) {
                    if (context.checkPermission(pathPerm, pid, uid) == PERMISSION_GRANTED) {
                        return;
                    } else {
                        // any denied <path-permission> means we lose
                        // default <provider> access.
                        allowDefaultWrite = false;
                        missingPerm = pathPerm;
                    }
                }
            }
        }
        // <provider> permission, then allow access.
        if (allowDefaultWrite)
            return;
    }
    // last chance, check against any uri grants
    if (context.checkUriPermission(uri, pid, uid, Intent.FLAG_GRANT_WRITE_URI_PERMISSION) == PERMISSION_GRANTED) {
        return;
    }
    final String failReason = mExported ? " requires " + missingPerm + ", or grantUriPermission()" : " requires the provider be exported, or grantUriPermission()";
    throw new SecurityException("Permission Denial: writing " + ContentProvider.this.getClass().getName() + " uri " + uri + " from pid=" + pid + ", uid=" + uid + failReason);
}
Body of Second Method:
{
    final Context context = getContext();
    final int pid = Binder.getCallingPid();
    final int uid = Binder.getCallingUid();
    String missingPerm = null;
    if (UserHandle.isSameApp(uid, mMyUid)) {
        return;
    }
    if (mExported && checkUser(pid, uid, context)) {
        final String componentPerm = getWritePermission();
        if (componentPerm != null) {
            if (context.checkPermission(componentPerm, pid, uid, callerToken) == PERMISSION_GRANTED) {
                return;
            } else {
                missingPerm = componentPerm;
            }
        }
        // track if unprotected write is allowed; any denied
        // <path-permission> below removes this ability
        boolean allowDefaultWrite = (componentPerm == null);
        final PathPermission[] pps = getPathPermissions();
        if (pps != null) {
            final String path = uri.getPath();
            for (PathPermission pp : pps) {
                final String pathPerm = pp.getWritePermission();
                if (pathPerm != null && pp.match(path)) {
                    if (context.checkPermission(pathPerm, pid, uid, callerToken) == PERMISSION_GRANTED) {
                        return;
                    } else {
                        // any denied <path-permission> means we lose
                        // default <provider> access.
                        allowDefaultWrite = false;
                        missingPerm = pathPerm;
                    }
                }
            }
        }
        // <provider> permission, then allow access.
        if (allowDefaultWrite)
            return;
    }
    // last chance, check against any uri grants
    if (context.checkUriPermission(uri, pid, uid, Intent.FLAG_GRANT_WRITE_URI_PERMISSION, callerToken) == PERMISSION_GRANTED) {
        return;
    }
    final String failReason = mExported ? " requires " + missingPerm + ", or grantUriPermission()" : " requires the provider be exported, or grantUriPermission()";
    throw new SecurityException("Permission Denial: writing " + ContentProvider.this.getClass().getName() + " uri " + uri + " from pid=" + pid + ", uid=" + uid + failReason);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothAdapter.getBluetoothService:COMMENT
Method Modifier: default     
Comment:/*package*/

Body of Frist Method:
{
    synchronized (mManagerCallback) {
        if (cb == null) {
            Log.w(TAG, "getBluetoothService() called with no BluetoothManagerCallback");
        } else if (!mProxyServiceStateCallbacks.contains(cb)) {
            mProxyServiceStateCallbacks.add(cb);
        }
    }
    return mService;
}
Body of Second Method:
{
    synchronized (mProxyServiceStateCallbacks) {
        if (cb == null) {
            Log.w(TAG, "getBluetoothService() called with no BluetoothManagerCallback");
        } else if (!mProxyServiceStateCallbacks.contains(cb)) {
            mProxyServiceStateCallbacks.add(cb);
        }
    }
    return mService;
}
------------------------
Find a silently evolved API code:android.view.ViewGroup.resolveDrawables:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    super.resolveDrawables();
    int count = getChildCount();
    for (int i = 0; i < count; i++) {
        final View child = getChildAt(i);
        if (child.isLayoutDirectionInherited()) {
            child.resolveDrawables();
        }
    }
}
Body of Second Method:
{
    super.resolveDrawables();
    int count = getChildCount();
    for (int i = 0; i < count; i++) {
        final View child = getChildAt(i);
        if (child.isLayoutDirectionInherited() && !child.areDrawablesResolved()) {
            child.resolveDrawables();
        }
    }
}
------------------------
Find a silently evolved API code:android.webkit.WebSettings.setMinimumLogicalFontSize:COMMENT
<android.webkit.WebSettings: void setMinimumLogicalFontSize(int)>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Sets the minimum logical font size. The default is 8.
 *
 * @param size a non-negative integer between 1 and 72. Any number outside
 * the specified range will be pinned.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.telephony.ServiceState.getOperatorAlphaShort:COMMENT
Method Modifier: public      
Comment:/**
 * Get current registered operator name in short alphanumeric format.
 *
 * In GSM/UMTS, short format can be up to 8 characters long.
 *
 * @return short name of operator, null if unregistered or unknown
 */

Body of Frist Method:
{
    return mOperatorAlphaShort;
}
Body of Second Method:
{
    return mVoiceOperatorAlphaShort;
}
------------------------
Find a silently evolved API code:android.graphics.drawable.Ripple.draw:COMMENT
Method Modifier: public      
Comment:/**
 * Draws the ripple centered at (0,0) using the specified paint.
 */

Body of Frist Method:
{
    final boolean canUseHardware = c.isHardwareAccelerated();
    if (mCanUseHardware != canUseHardware && mCanUseHardware) {
        // We've switched from hardware to non-hardware mode. Panic.
        cancelHardwareAnimations(true);
    }
    mCanUseHardware = canUseHardware;
    final boolean hasContent;
    if (canUseHardware && mHardwareAnimating) {
        hasContent = drawHardware((HardwareCanvas) c);
    } else {
        hasContent = drawSoftware(c, p);
    }
    return hasContent;
}
Body of Second Method:
{
    final boolean canUseHardware = c.isHardwareAccelerated();
    if (mCanUseHardware != canUseHardware && mCanUseHardware) {
        // We've switched from hardware to non-hardware mode. Panic.
        cancelHardwareAnimations(true);
    }
    mCanUseHardware = canUseHardware;
    final boolean hasContent;
    if (canUseHardware && (mHardwareAnimating || mHasPendingHardwareExit)) {
        hasContent = drawHardware((HardwareCanvas) c, p);
    } else {
        hasContent = drawSoftware(c, p);
    }
    return hasContent;
}
------------------------
Find a silently evolved API code:android.media.audiopolicy.AudioMixingRule.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Combines all of the matching and exclusion rules that have been set and return a new
 * {@link AudioMixingRule} object.
 * @return a new {@link AudioMixingRule} object
 */

Body of Frist Method:
{
    return new AudioMixingRule(mCriteria);
}
Body of Second Method:
{
    return new AudioMixingRule(mTargetMixType, mCriteria);
}
------------------------
Find a silently evolved API code:android.appwidget.AppWidgetHost.allocateAppWidgetId:COMMENT
Method Modifier: public      
Comment:/**
 * Get a appWidgetId for a host in the calling process.
 *
 * @return a appWidgetId
 */

Body of Frist Method:
{
    try {
        return sService.allocateAppWidgetId(mContext.getOpPackageName(), mHostId);
    } catch (RemoteException e) {
        throw new RuntimeException("system server dead?", e);
    }
}
Body of Second Method:
{
    try {
        return sService.allocateAppWidgetId(mContextOpPackageName, mHostId);
    } catch (RemoteException e) {
        throw new RuntimeException("system server dead?", e);
    }
}
------------------------
Find a silently evolved API code:android.webkit.WebSettings.setGeolocationEnabled:COMMENT
<android.webkit.WebSettings: void setGeolocationEnabled(boolean)>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Sets whether Geolocation is enabled. The default is true.
 * <p>
 * Please note that in order for the Geolocation API to be usable
 * by a page in the WebView, the following requirements must be met:
 * <ul>
 * <li>an application must have permission to access the device location,
 * see {@link android.Manifest.permission#ACCESS_COARSE_LOCATION},
 * {@link android.Manifest.permission#ACCESS_FINE_LOCATION};
 * <li>an application must provide an implementation of the
 * {@link WebChromeClient#onGeolocationPermissionsShowPrompt} callback
 * to receive notifications that a page is requesting access to location
 * via the JavaScript Geolocation API.
 * </ul>
 * <p>
 * As an option, it is possible to store previous locations and web origin
 * permissions in a database. See {@link #setGeolocationDatabasePath}.
 *
 * @param flag whether Geolocation should be enabled
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.graphics.drawable.RippleBackground.cancel:COMMENT
Method Modifier: public      
Comment:/**
 * Cancel all animations. The caller is responsible for removing
 * the ripple from the list of animating ripples.
 */

Body of Frist Method:
{
    cancelSoftwareAnimations();
    cancelHardwareAnimations(true);
}
Body of Second Method:
{
    cancelSoftwareAnimations();
    cancelHardwareAnimations(false);
}
------------------------
Find a silently evolved API code:android.hardware.camera2.params.StreamConfigurationMap.getPublicFormats:COMMENT
Method Modifier: private     
Comment:/**
 * Get the list of publically visible output formats; does not include IMPL_DEFINED
 */

Body of Frist Method:
{
    int[] formats = new int[getPublicFormatCount(output)];
    int i = 0;
    for (int format : getFormatsMap(output).keySet()) {
        if (format != HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED) {
            formats[i++] = format;
        }
    }
    if (formats.length != i) {
        throw new AssertionError("Too few formats " + i + ", expected " + formats.length);
    }
    return imageFormatToPublic(formats);
}
Body of Second Method:
{
    int[] formats = new int[getPublicFormatCount(output)];
    int i = 0;
    for (int format : getFormatsMap(output).keySet()) {
        if (format != HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED && format != HAL_PIXEL_FORMAT_RAW_OPAQUE) {
            formats[i++] = format;
        }
    }
    if (formats.length != i) {
        throw new AssertionError("Too few formats " + i + ", expected " + formats.length);
    }
    return imageFormatToPublic(formats);
}
------------------------
Find a silently evolved API code:android.media.AudioService.registerAudioPolicy:COMMENT
Method Modifier: public      hidden      
Comment:// ==========================================================================================

Body of Frist Method:
{
    // Log.v(TAG, "registerAudioPolicy for " + cb + " got policy:" + policyConfig);
    boolean hasPermissionForPolicy = (PackageManager.PERMISSION_GRANTED == mContext.checkCallingOrSelfPermission(android.Manifest.permission.MODIFY_AUDIO_ROUTING));
    if (!hasPermissionForPolicy) {
        Slog.w(TAG, "Can't register audio policy for pid " + Binder.getCallingPid() + " / uid " + Binder.getCallingUid() + ", need MODIFY_AUDIO_ROUTING");
        return false;
    }
    synchronized (mAudioPolicies) {
        AudioPolicyProxy app = new AudioPolicyProxy(policyConfig, cb);
        try {
            cb.linkToDeath(app, 0);
            mAudioPolicies.put(cb, app);
        } catch (RemoteException e) {
            // audio policy owner has already died!
            Slog.w(TAG, "Audio policy registration failed, could not link to " + cb + " binder death", e);
            return false;
        }
    }
    // TODO implement registration with native audio policy (including permission check)
    return true;
}
Body of Second Method:
{
    if (DEBUG_AP)
        Log.d(TAG, "registerAudioPolicy for " + pcb.asBinder() + " with config:" + policyConfig);
    String regId = null;
    // error handling
    boolean hasPermissionForPolicy = (PackageManager.PERMISSION_GRANTED == mContext.checkCallingPermission(android.Manifest.permission.MODIFY_AUDIO_ROUTING));
    if (!hasPermissionForPolicy) {
        Slog.w(TAG, "Can't register audio policy for pid " + Binder.getCallingPid() + " / uid " + Binder.getCallingUid() + ", need MODIFY_AUDIO_ROUTING");
        return null;
    }
    synchronized (mAudioPolicies) {
        try {
            if (mAudioPolicies.containsKey(pcb.asBinder())) {
                Slog.e(TAG, "Cannot re-register policy");
                return null;
            }
            AudioPolicyProxy app = new AudioPolicyProxy(policyConfig, pcb, hasFocusListener);
            pcb.asBinder().linkToDeath(app, 0);
            regId = app.getRegistrationId();
            mAudioPolicies.put(pcb.asBinder(), app);
        } catch (RemoteException e) {
            // audio policy owner has already died!
            Slog.w(TAG, "Audio policy registration failed, could not link to " + pcb + " binder death", e);
            return null;
        }
    }
    return regId;
}
------------------------
Find a silently evolved API code:android.net.ConnectivityManager.setProcessDefaultNetwork:COMMENT
Method Modifier: public      static      
Comment:/**
 * Binds the current process to {@code network}.  All Sockets created in the future
 * (and not explicitly bound via a bound SocketFactory from
 * {@link Network#getSocketFactory() Network.getSocketFactory()}) will be bound to
 * {@code network}.  All host name resolutions will be limited to {@code network} as well.
 * Note that if {@code network} ever disconnects, all Sockets created in this way will cease to
 * work and all host name resolutions will fail.  This is by design so an application doesn't
 * accidentally use Sockets it thinks are still bound to a particular {@link Network}.
 * To clear binding pass {@code null} for {@code network}.  Using individually bound
 * Sockets created by Network.getSocketFactory().createSocket() and
 * performing network-specific host name resolutions via
 * {@link Network#getAllByName Network.getAllByName} is preferred to calling
 * {@code setProcessDefaultNetwork}.
 *
 * @param network The {@link Network} to bind the current process to, or {@code null} to clear
 * the current binding.
 * @return {@code true} on success, {@code false} if the {@link Network} is no longer valid.
 */

Body of Frist Method:
{
    int netId = (network == null) ? NETID_UNSET : network.netId;
    if (netId == NetworkUtils.getNetworkBoundToProcess()) {
        return true;
    }
    if (NetworkUtils.bindProcessToNetwork(netId)) {
        // Must flush DNS cache as new network may have different DNS resolutions.
        InetAddress.clearDnsCache();
        // Must flush socket pool as idle sockets will be bound to previous network and may
        // cause subsequent fetches to be performed on old network.
        NetworkEventDispatcher.getInstance().onNetworkConfigurationChanged();
        return true;
    } else {
        return false;
    }
}
Body of Second Method:
{
    int netId = (network == null) ? NETID_UNSET : network.netId;
    if (netId == NetworkUtils.getNetworkBoundToProcess()) {
        return true;
    }
    if (NetworkUtils.bindProcessToNetwork(netId)) {
        // Set HTTP proxy system properties to match network.
        // TODO: Deprecate this static method and replace it with a non-static version.
        Proxy.setHttpProxySystemProperty(getInstance().getDefaultProxy());
        // Must flush DNS cache as new network may have different DNS resolutions.
        InetAddress.clearDnsCache();
        // Must flush socket pool as idle sockets will be bound to previous network and may
        // cause subsequent fetches to be performed on old network.
        NetworkEventDispatcher.getInstance().onNetworkConfigurationChanged();
        return true;
    } else {
        return false;
    }
}
------------------------
Find a silently evolved API code:android.webkit.CookieManager.allowFileSchemeCookiesImpl:COMMENT
<android.webkit.CookieManager: boolean allowFileSchemeCookiesImpl()>
protected   hidden      ->protected   abstract    hidden      
Method Modifier: protected   abstract    hidden      
Method Modifier: Yes         No          Yes         
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * Implements {@link #allowFileSchemeCookies()}.
 *
 * @hide Only for use by WebViewProvider implementations
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.view.Window.setFlags:COMMENT
Method Modifier: public      
Comment:/**
 * Set the flags of the window, as per the
 * {@link WindowManager.LayoutParams WindowManager.LayoutParams}
 * flags.
 *
 * <p>Note that some flags must be set before the window decoration is
 * created (by the first call to
 * {@link #setContentView(View, android.view.ViewGroup.LayoutParams)} or
 * {@link #getDecorView()}:
 * {@link WindowManager.LayoutParams#FLAG_LAYOUT_IN_SCREEN} and
 * {@link WindowManager.LayoutParams#FLAG_LAYOUT_INSET_DECOR}.  These
 * will be set for you based on the {@link android.R.attr#windowIsFloating}
 * attribute.
 *
 * @param flags The new window flags (see WindowManager.LayoutParams).
 * @param mask Which of the window flag bits to modify.
 * @see #addFlags
 * @see #clearFlags
 */

Body of Frist Method:
{
    final WindowManager.LayoutParams attrs = getAttributes();
    attrs.flags = (attrs.flags & ~mask) | (flags & mask);
    if ((mask & WindowManager.LayoutParams.FLAG_NEEDS_MENU_KEY) != 0) {
        attrs.privateFlags |= WindowManager.LayoutParams.PRIVATE_FLAG_SET_NEEDS_MENU_KEY;
    }
    mForcedWindowFlags |= mask;
    dispatchWindowAttributesChanged(attrs);
}
Body of Second Method:
{
    final WindowManager.LayoutParams attrs = getAttributes();
    attrs.flags = (attrs.flags & ~mask) | (flags & mask);
    mForcedWindowFlags |= mask;
    dispatchWindowAttributesChanged(attrs);
}
------------------------
Find a silently evolved API code:android.media.session.MediaSession.setPlaybackToRemote:COMMENT
Method Modifier: public      
Comment:/**
 * Configure this session to use remote volume handling. This must be called
 * to receive volume button events, otherwise the system will adjust the
 * appropriate stream volume for this session. If
 * {@link #setPlaybackToLocal} was previously called the system will stop
 * handling volume changes for this session and pass them to the volume
 * provider instead.
 *
 * @param volumeProvider The provider that will handle volume changes. May
 * not be null.
 */

Body of Frist Method:
{
    if (volumeProvider == null) {
        throw new IllegalArgumentException("volumeProvider may not be null!");
    }
    mVolumeProvider = volumeProvider;
    volumeProvider.setCallback(new VolumeProvider.Callback() {

        @Override
        public void onVolumeChanged(VolumeProvider volumeProvider) {
            notifyRemoteVolumeChanged(volumeProvider);
        }
    });
    try {
        mBinder.setPlaybackToRemote(volumeProvider.getVolumeControl(), volumeProvider.getMaxVolume());
        mBinder.setCurrentVolume(volumeProvider.getCurrentVolume());
    } catch (RemoteException e) {
        Log.wtf(TAG, "Failure in setPlaybackToRemote.", e);
    }
}
Body of Second Method:
{
    if (volumeProvider == null) {
        throw new IllegalArgumentException("volumeProvider may not be null!");
    }
    synchronized (mLock) {
        mVolumeProvider = volumeProvider;
    }
    volumeProvider.setCallback(new VolumeProvider.Callback() {

        @Override
        public void onVolumeChanged(VolumeProvider volumeProvider) {
            notifyRemoteVolumeChanged(volumeProvider);
        }
    });
    try {
        mBinder.setPlaybackToRemote(volumeProvider.getVolumeControl(), volumeProvider.getMaxVolume());
        mBinder.setCurrentVolume(volumeProvider.getCurrentVolume());
    } catch (RemoteException e) {
        Log.wtf(TAG, "Failure in setPlaybackToRemote.", e);
    }
}
------------------------
Find a silently evolved API code:android.media.MediaFocusControl.removeFocusStackEntry:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Helper function:
 * Called synchronized on mAudioFocusLock
 * Remove a focus listener from the focus stack.
 * @param clientToRemove the focus listener
 * @param signal if true and the listener was at the top of the focus stack, i.e. it was holding
 * focus, notify the next item in the stack it gained focus.
 */

Body of Frist Method:
{
    // is the current top of the focus stack abandoning focus? (because of request, not death)
    if (!mFocusStack.empty() && mFocusStack.peek().hasSameClient(clientToRemove)) {
        // Log.i(TAG, "   removeFocusStackEntry() removing top of stack");
        FocusRequester fr = mFocusStack.pop();
        fr.release();
        if (signal) {
            // notify the new top of the stack it gained focus
            notifyTopOfAudioFocusStack();
        }
    } else {
        // focus is abandoned by a client that's not at the top of the stack,
        // no need to update focus.
        // (using an iterator on the stack so we can safely remove an entry after having
        // evaluated it, traversal order doesn't matter here)
        Iterator<FocusRequester> stackIterator = mFocusStack.iterator();
        while (stackIterator.hasNext()) {
            FocusRequester fr = stackIterator.next();
            if (fr.hasSameClient(clientToRemove)) {
                Log.i(TAG, "AudioFocus  removeFocusStackEntry(): removing entry for " + clientToRemove);
                stackIterator.remove();
                fr.release();
            }
        }
    }
}
Body of Second Method:
{
    // is the current top of the focus stack abandoning focus? (because of request, not death)
    if (!mFocusStack.empty() && mFocusStack.peek().hasSameClient(clientToRemove)) {
        // Log.i(TAG, "   removeFocusStackEntry() removing top of stack");
        FocusRequester fr = mFocusStack.pop();
        fr.release();
        if (notifyFocusFollowers) {
            final AudioFocusInfo afi = fr.toAudioFocusInfo();
            afi.clearLossReceived();
            notifyExtPolicyFocusLoss_syncAf(afi, false);
        }
        if (signal) {
            // notify the new top of the stack it gained focus
            notifyTopOfAudioFocusStack();
        }
    } else {
        // focus is abandoned by a client that's not at the top of the stack,
        // no need to update focus.
        // (using an iterator on the stack so we can safely remove an entry after having
        // evaluated it, traversal order doesn't matter here)
        Iterator<FocusRequester> stackIterator = mFocusStack.iterator();
        while (stackIterator.hasNext()) {
            FocusRequester fr = stackIterator.next();
            if (fr.hasSameClient(clientToRemove)) {
                Log.i(TAG, "AudioFocus  removeFocusStackEntry(): removing entry for " + clientToRemove);
                stackIterator.remove();
                fr.release();
            }
        }
    }
}
------------------------
Find a silently evolved API code:android.app.Activity.closeOptionsMenu:COMMENT
Method Modifier: public      
Comment:/**
 * Progammatically closes the options menu. If the options menu is already
 * closed, this method does nothing.
 */

Body of Frist Method:
{
    mWindow.closePanel(Window.FEATURE_OPTIONS_PANEL);
}
Body of Second Method:
{
    if (mWindow.hasFeature(Window.FEATURE_OPTIONS_PANEL)) {
        mWindow.closePanel(Window.FEATURE_OPTIONS_PANEL);
    }
}
------------------------
Find a silently evolved API code:android.webkit.CookieManager.acceptCookie:COMMENT
<android.webkit.CookieManager: boolean acceptCookie()>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Gets whether the application's {@link WebView} instances send and accept
 * cookies.
 *
 * @return true if {@link WebView} instances send and accept cookies
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.view.accessibility.AccessibilityNodeInfo.initFromParcel:COMMENT
Method Modifier: private     
Comment:/**
 * Creates a new instance from a {@link Parcel}.
 *
 * @param parcel A parcel containing the state of a {@link AccessibilityNodeInfo}.
 */

Body of Frist Method:
{
    mSealed = (parcel.readInt() == 1);
    mSourceNodeId = parcel.readLong();
    mWindowId = parcel.readInt();
    mParentNodeId = parcel.readLong();
    mLabelForId = parcel.readLong();
    mLabeledById = parcel.readLong();
    mConnectionId = parcel.readInt();
    final int childrenSize = parcel.readInt();
    if (childrenSize <= 0) {
        mChildNodeIds = null;
    } else {
        mChildNodeIds = new LongArray(childrenSize);
        for (int i = 0; i < childrenSize; i++) {
            final long childId = parcel.readLong();
            mChildNodeIds.add(childId);
        }
    }
    mBoundsInParent.top = parcel.readInt();
    mBoundsInParent.bottom = parcel.readInt();
    mBoundsInParent.left = parcel.readInt();
    mBoundsInParent.right = parcel.readInt();
    mBoundsInScreen.top = parcel.readInt();
    mBoundsInScreen.bottom = parcel.readInt();
    mBoundsInScreen.left = parcel.readInt();
    mBoundsInScreen.right = parcel.readInt();
    final int actionCount = parcel.readInt();
    if (actionCount > 0) {
        final int legacyStandardActions = parcel.readInt();
        addLegacyStandardActions(legacyStandardActions);
        final int nonLegacyActionCount = actionCount - Integer.bitCount(legacyStandardActions);
        for (int i = 0; i < nonLegacyActionCount; i++) {
            AccessibilityAction action = new AccessibilityAction(parcel.readInt(), parcel.readCharSequence());
            addAction(action);
        }
    }
    mMaxTextLength = parcel.readInt();
    mMovementGranularities = parcel.readInt();
    mBooleanProperties = parcel.readInt();
    mPackageName = parcel.readCharSequence();
    mClassName = parcel.readCharSequence();
    mText = parcel.readCharSequence();
    mError = parcel.readCharSequence();
    mContentDescription = parcel.readCharSequence();
    mViewIdResourceName = parcel.readString();
    mTextSelectionStart = parcel.readInt();
    mTextSelectionEnd = parcel.readInt();
    mInputType = parcel.readInt();
    mLiveRegion = parcel.readInt();
    if (parcel.readInt() == 1) {
        getExtras().putAll(parcel.readBundle());
    }
    if (parcel.readInt() == 1) {
        mRangeInfo = RangeInfo.obtain(parcel.readInt(), parcel.readFloat(), parcel.readFloat(), parcel.readFloat());
    }
    if (parcel.readInt() == 1) {
        mCollectionInfo = CollectionInfo.obtain(parcel.readInt(), parcel.readInt(), parcel.readInt() == 1, parcel.readInt());
    }
    if (parcel.readInt() == 1) {
        mCollectionItemInfo = CollectionItemInfo.obtain(parcel.readInt(), parcel.readInt(), parcel.readInt(), parcel.readInt(), parcel.readInt() == 1, parcel.readInt() == 1);
    }
}
Body of Second Method:
{
    mSealed = (parcel.readInt() == 1);
    mSourceNodeId = parcel.readLong();
    mWindowId = parcel.readInt();
    mParentNodeId = parcel.readLong();
    mLabelForId = parcel.readLong();
    mLabeledById = parcel.readLong();
    mTraversalBefore = parcel.readLong();
    mTraversalAfter = parcel.readLong();
    mConnectionId = parcel.readInt();
    final int childrenSize = parcel.readInt();
    if (childrenSize <= 0) {
        mChildNodeIds = null;
    } else {
        mChildNodeIds = new LongArray(childrenSize);
        for (int i = 0; i < childrenSize; i++) {
            final long childId = parcel.readLong();
            mChildNodeIds.add(childId);
        }
    }
    mBoundsInParent.top = parcel.readInt();
    mBoundsInParent.bottom = parcel.readInt();
    mBoundsInParent.left = parcel.readInt();
    mBoundsInParent.right = parcel.readInt();
    mBoundsInScreen.top = parcel.readInt();
    mBoundsInScreen.bottom = parcel.readInt();
    mBoundsInScreen.left = parcel.readInt();
    mBoundsInScreen.right = parcel.readInt();
    final int actionCount = parcel.readInt();
    if (actionCount > 0) {
        final int legacyStandardActions = parcel.readInt();
        addLegacyStandardActions(legacyStandardActions);
        final int nonLegacyActionCount = actionCount - Integer.bitCount(legacyStandardActions);
        for (int i = 0; i < nonLegacyActionCount; i++) {
            AccessibilityAction action = new AccessibilityAction(parcel.readInt(), parcel.readCharSequence());
            addAction(action);
        }
    }
    mMaxTextLength = parcel.readInt();
    mMovementGranularities = parcel.readInt();
    mBooleanProperties = parcel.readInt();
    mPackageName = parcel.readCharSequence();
    mClassName = parcel.readCharSequence();
    mText = parcel.readCharSequence();
    mError = parcel.readCharSequence();
    mContentDescription = parcel.readCharSequence();
    mViewIdResourceName = parcel.readString();
    mTextSelectionStart = parcel.readInt();
    mTextSelectionEnd = parcel.readInt();
    mInputType = parcel.readInt();
    mLiveRegion = parcel.readInt();
    if (parcel.readInt() == 1) {
        getExtras().putAll(parcel.readBundle());
    }
    if (parcel.readInt() == 1) {
        mRangeInfo = RangeInfo.obtain(parcel.readInt(), parcel.readFloat(), parcel.readFloat(), parcel.readFloat());
    }
    if (parcel.readInt() == 1) {
        mCollectionInfo = CollectionInfo.obtain(parcel.readInt(), parcel.readInt(), parcel.readInt() == 1, parcel.readInt());
    }
    if (parcel.readInt() == 1) {
        mCollectionItemInfo = CollectionItemInfo.obtain(parcel.readInt(), parcel.readInt(), parcel.readInt(), parcel.readInt(), parcel.readInt() == 1, parcel.readInt() == 1);
    }
}
------------------------
Find a silently evolved API code:android.webkit.WebSettings.getSerifFontFamily:COMMENT
<android.webkit.WebSettings: String getSerifFontFamily()>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Gets the serif font family name. The default is "serif".
 *
 * @return the serif font family name as a string
 * @see #setSerifFontFamily
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.widget.AbsListView.RecycleBin.fillActiveViews:COMMENT
Method Modifier: default     
Comment:/**
 * Fill ActiveViews with all of the children of the AbsListView.
 *
 * @param childCount The minimum number of views mActiveViews should hold
 * @param firstActivePosition The position of the first view that will be stored in
 * mActiveViews
 */

Body of Frist Method:
{
    if (mActiveViews.length < childCount) {
        mActiveViews = new View[childCount];
    }
    mFirstActivePosition = firstActivePosition;
    // noinspection MismatchedReadAndWriteOfArray
    final View[] activeViews = mActiveViews;
    for (int i = 0; i < childCount; i++) {
        View child = getChildAt(i);
        AbsListView.LayoutParams lp = (AbsListView.LayoutParams) child.getLayoutParams();
        // Don't put header or footer views into the scrap heap
        if (lp != null && lp.viewType != ITEM_VIEW_TYPE_HEADER_OR_FOOTER) {
            // Note:  We do place AdapterView.ITEM_VIEW_TYPE_IGNORE in active views.
            // However, we will NOT place them into scrap views.
            activeViews[i] = child;
        }
    }
}
Body of Second Method:
{
    if (mActiveViews.length < childCount) {
        mActiveViews = new View[childCount];
    }
    mFirstActivePosition = firstActivePosition;
    // noinspection MismatchedReadAndWriteOfArray
    final View[] activeViews = mActiveViews;
    for (int i = 0; i < childCount; i++) {
        View child = getChildAt(i);
        AbsListView.LayoutParams lp = (AbsListView.LayoutParams) child.getLayoutParams();
        // Don't put header or footer views into the scrap heap
        if (lp != null && lp.viewType != ITEM_VIEW_TYPE_HEADER_OR_FOOTER) {
            // Note:  We do place AdapterView.ITEM_VIEW_TYPE_IGNORE in active views.
            // However, we will NOT place them into scrap views.
            activeViews[i] = child;
            // Remember the position so that setupChild() doesn't reset state.
            lp.scrappedFromPosition = firstActivePosition + i;
        }
    }
}
------------------------
Find a silently evolved API code:android.webkit.WebView.restoreState:COMMENT
Method Modifier: public      
Comment:/**
 * Restores the state of this WebView from the given Bundle. This method is
 * intended for use in {@link android.app.Activity#onRestoreInstanceState}
 * and should be called to restore the state of this WebView. If
 * it is called after this WebView has had a chance to build state (load
 * pages, create a back/forward list, etc.) there may be undesirable
 * side-effects. Please note that this method no longer restores the
 * display data for this WebView.
 *
 * @param inState the incoming Bundle of state
 * @return the restored back/forward list or null if restoreState failed
 */

Body of Frist Method:
{
    checkThread();
    if (DebugFlags.TRACE_API)
        Log.d(LOGTAG, "restoreState");
    return mProvider.restoreState(inState);
}
Body of Second Method:
{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, "restoreState");
    return mProvider.restoreState(inState);
}
------------------------
Find a silently evolved API code:android.widget.SearchView.setInputType:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the input type on the query text field.
 *
 * @see TextView#setInputType(int)
 * @param inputType the input type to set on the query text field
 *
 * @attr ref android.R.styleable#SearchView_inputType
 */

Body of Frist Method:
{
    mQueryTextView.setInputType(inputType);
}
Body of Second Method:
{
    mSearchSrcTextView.setInputType(inputType);
}
------------------------
Find a silently evolved API code:android.widget.AbsListView.positionSelectorLikeTouch:COMMENT
Method Modifier: default     
Comment:/**
 * Positions the selector in a way that mimics touch.
 */

Body of Frist Method:
{
    positionSelectorLikeFocus(position, sel);
    if (mSelector != null && position != INVALID_POSITION) {
        mSelector.setHotspot(x, y);
    }
}
Body of Second Method:
{
    positionSelector(position, sel, true, x, y);
}
------------------------
Find a silently evolved API code:android.net.StaticIpConfiguration.toLinkProperties:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns a LinkProperties object expressing the data in this object. Note that the information
 * contained in the LinkProperties will not be a complete picture of the link's configuration,
 * because any configuration information that is obtained dynamically by the network (e.g.,
 * IPv6 configuration) will not be included.
 */

Body of Frist Method:
{
    LinkProperties lp = new LinkProperties();
    lp.setInterfaceName(iface);
    if (ipAddress != null) {
        lp.addLinkAddress(ipAddress);
    }
    for (RouteInfo route : getRoutes(iface)) {
        lp.addRoute(route);
    }
    for (InetAddress dns : dnsServers) {
        lp.addDnsServer(dns);
    }
    return lp;
}
Body of Second Method:
{
    LinkProperties lp = new LinkProperties();
    lp.setInterfaceName(iface);
    if (ipAddress != null) {
        lp.addLinkAddress(ipAddress);
    }
    for (RouteInfo route : getRoutes(iface)) {
        lp.addRoute(route);
    }
    for (InetAddress dns : dnsServers) {
        lp.addDnsServer(dns);
    }
    lp.setDomains(domains);
    return lp;
}
------------------------
Find a silently evolved API code:android.webkit.WebSettings.getMinimumFontSize:COMMENT
<android.webkit.WebSettings: int getMinimumFontSize()>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Gets the minimum font size.
 *
 * @return a non-negative integer between 1 and 72
 * @see #setMinimumFontSize
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.app.Activity.openOptionsMenu:COMMENT
Method Modifier: public      
Comment:/**
 * Programmatically opens the options menu. If the options menu is already
 * open, this method does nothing.
 */

Body of Frist Method:
{
    if (mActionBar == null || !mActionBar.openOptionsMenu()) {
        mWindow.openPanel(Window.FEATURE_OPTIONS_PANEL, null);
    }
}
Body of Second Method:
{
    if (mWindow.hasFeature(Window.FEATURE_OPTIONS_PANEL) && (mActionBar == null || !mActionBar.openOptionsMenu())) {
        mWindow.openPanel(Window.FEATURE_OPTIONS_PANEL, null);
    }
}
------------------------
Find a silently evolved API code:android.webkit.WebSettings.setBlockNetworkLoads:COMMENT
<android.webkit.WebSettings: void setBlockNetworkLoads(boolean)>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Sets whether the WebView should not load resources from the network.
 * Use {@link #setBlockNetworkImage} to only avoid loading
 * image resources. Note that if the value of this setting is
 * changed from true to false, network resources referenced by content
 * currently displayed by the WebView are not fetched until
 * {@link android.webkit.WebView#reload} is called.
 * If the application does not have the
 * {@link android.Manifest.permission#INTERNET} permission, attempts to set
 * a value of false will cause a {@link java.lang.SecurityException}
 * to be thrown. The default value is false if the application has the
 * {@link android.Manifest.permission#INTERNET} permission, otherwise it is
 * true.
 *
 * @param flag whether the WebView should not load any resources from the
 * network
 * @see android.webkit.WebView#reload
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.telephony.PhoneNumberUtils.cdmaCheckAndProcessPlusCode:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * This function checks if there is a plus sign (+) in the passed-in dialing number.
 * If there is, it processes the plus sign based on the default telephone
 * numbering plan of the system when the phone is activated and the current
 * telephone numbering plan of the system that the phone is camped on.
 * Currently, we only support the case that the default and current telephone
 * numbering plans are North American Numbering Plan(NANP).
 *
 * The passed-in dialStr should only contain the valid format as described below,
 * 1) the 1st character in the dialStr should be one of the really dialable
 * characters listed below
 * ISO-LATIN characters 0-9, *, # , +
 * 2) the dialStr should already strip out the separator characters,
 * every character in the dialStr should be one of the non separator characters
 * listed below
 * ISO-LATIN characters 0-9, *, # , +, WILD, WAIT, PAUSE
 *
 * Otherwise, this function returns the dial string passed in
 *
 * @param dialStr the original dial string
 * @return the converted dial string if the current/default countries belong to NANP,
 * and if there is the "+" in the original dial string. Otherwise, the original dial
 * string returns.
 *
 * This API is for CDMA only
 *
 * @hide TODO: pending API Council approval
 */

Body of Frist Method:
{
    if (!TextUtils.isEmpty(dialStr)) {
        if (isReallyDialable(dialStr.charAt(0)) && isNonSeparator(dialStr)) {
            String currIso = SystemProperties.get(PROPERTY_OPERATOR_ISO_COUNTRY, "");
            String defaultIso = SystemProperties.get(PROPERTY_ICC_OPERATOR_ISO_COUNTRY, "");
            if (!TextUtils.isEmpty(currIso) && !TextUtils.isEmpty(defaultIso)) {
                return cdmaCheckAndProcessPlusCodeByNumberFormat(dialStr, getFormatTypeFromCountryCode(currIso), getFormatTypeFromCountryCode(defaultIso));
            }
        }
    }
    return dialStr;
}
Body of Second Method:
{
    if (!TextUtils.isEmpty(dialStr)) {
        if (isReallyDialable(dialStr.charAt(0)) && isNonSeparator(dialStr)) {
            String currIso = TelephonyManager.getDefault().getNetworkCountryIso();
            String defaultIso = TelephonyManager.getDefault().getSimCountryIso();
            if (!TextUtils.isEmpty(currIso) && !TextUtils.isEmpty(defaultIso)) {
                return cdmaCheckAndProcessPlusCodeByNumberFormat(dialStr, getFormatTypeFromCountryCode(currIso), getFormatTypeFromCountryCode(defaultIso));
            }
        }
    }
    return dialStr;
}
------------------------
Find a silently evolved API code:android.view.accessibility.AccessibilityNodeInfo.getLabeledBy:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the node info which serves as the label of the view represented by
 * this info for accessibility purposes.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 *
 * @return The label.
 */

Body of Frist Method:
{
    enforceSealed();
    if (!canPerformRequestOverConnection(mLabeledById)) {
        return null;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mWindowId, mLabeledById, false, FLAG_PREFETCH_PREDECESSORS | FLAG_PREFETCH_DESCENDANTS | FLAG_PREFETCH_SIBLINGS);
}
Body of Second Method:
{
    enforceSealed();
    return getNodeForAccessibilityId(mLabeledById);
}
------------------------
Find a silently evolved API code:android.app.Notification.Builder.processSmallIconAsLarge:COMMENT
Method Modifier: private     
Comment:/**
 * Apply any necessary background to smallIcons being used in the largeIcon spot.
 */

Body of Frist Method:
{
    if (!isLegacy() || mColorUtil.isGrayscaleIcon(mContext, largeIconId)) {
        applyLargeIconBackground(contentView);
    }
}
Body of Second Method:
{
    if (!isLegacy()) {
        contentView.setDrawableParameters(R.id.icon, false, -1, 0xFFFFFFFF, PorterDuff.Mode.SRC_ATOP, -1);
    }
    if (!isLegacy() || mColorUtil.isGrayscaleIcon(mContext, largeIconId)) {
        applyLargeIconBackground(contentView);
    }
}
------------------------
Find a silently evolved API code:android.app.Activity.closeContextMenu:COMMENT
Method Modifier: public      
Comment:/**
 * Programmatically closes the most recently opened context menu, if showing.
 */

Body of Frist Method:
{
    mWindow.closePanel(Window.FEATURE_CONTEXT_MENU);
}
Body of Second Method:
{
    if (mWindow.hasFeature(Window.FEATURE_CONTEXT_MENU)) {
        mWindow.closePanel(Window.FEATURE_CONTEXT_MENU);
    }
}
------------------------
Find a silently evolved API code:android.webkit.WebSettings.getLayoutAlgorithm:COMMENT
<android.webkit.WebSettings: LayoutAlgorithm getLayoutAlgorithm()>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Gets the current layout algorithm.
 *
 * @return the layout algorithm in use, as a {@link LayoutAlgorithm} value
 * @see #setLayoutAlgorithm
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.webkit.WebSettings.getDefaultTextEncodingName:COMMENT
<android.webkit.WebSettings: String getDefaultTextEncodingName()>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Gets the default text encoding name.
 *
 * @return the default text encoding name as a string
 * @see #setDefaultTextEncodingName
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.net.ConnectivityManager.startUsingNetworkFeature:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * Tells the underlying networking system that the caller wants to
 * begin using the named feature. The interpretation of {@code feature}
 * is completely up to each networking implementation.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#CHANGE_NETWORK_STATE}.
 * @param networkType specifies which network the request pertains to
 * @param feature the name of the feature to be used
 * @return an integer value representing the outcome of the request.
 * The interpretation of this value is specific to each networking
 * implementation+feature combination, except that the value {@code -1}
 * always indicates failure.
 *
 * @deprecated Deprecated in favor of the cleaner {@link #requestNetwork} api.
 */

Body of Frist Method:
{
    NetworkCapabilities netCap = networkCapabilitiesForFeature(networkType, feature);
    if (netCap == null) {
        Log.d(TAG, "Can't satisfy startUsingNetworkFeature for " + networkType + ", " + feature);
        return PhoneConstants.APN_REQUEST_FAILED;
    }
    NetworkRequest request = null;
    synchronized (sLegacyRequests) {
        if (LEGACY_DBG) {
            Log.d(TAG, "Looking for legacyRequest for netCap with hash: " + netCap + " (" + netCap.hashCode() + ")");
            Log.d(TAG, "sLegacyRequests has:");
            for (NetworkCapabilities nc : sLegacyRequests.keySet()) {
                Log.d(TAG, "  " + nc + " (" + nc.hashCode() + ")");
            }
        }
        LegacyRequest l = sLegacyRequests.get(netCap);
        if (l != null) {
            Log.d(TAG, "renewing startUsingNetworkFeature request " + l.networkRequest);
            renewRequestLocked(l);
            if (l.currentNetwork != null) {
                return PhoneConstants.APN_ALREADY_ACTIVE;
            } else {
                return PhoneConstants.APN_REQUEST_STARTED;
            }
        }
        request = requestNetworkForFeatureLocked(netCap);
    }
    if (request != null) {
        Log.d(TAG, "starting startUsingNetworkFeature for request " + request);
        return PhoneConstants.APN_REQUEST_STARTED;
    } else {
        Log.d(TAG, " request Failed");
        return PhoneConstants.APN_REQUEST_FAILED;
    }
}
Body of Second Method:
{
    NetworkCapabilities netCap = networkCapabilitiesForFeature(networkType, feature);
    if (netCap == null) {
        Log.d(TAG, "Can't satisfy startUsingNetworkFeature for " + networkType + ", " + feature);
        return PhoneConstants.APN_REQUEST_FAILED;
    }
    NetworkRequest request = null;
    synchronized (sLegacyRequests) {
        LegacyRequest l = sLegacyRequests.get(netCap);
        if (l != null) {
            Log.d(TAG, "renewing startUsingNetworkFeature request " + l.networkRequest);
            renewRequestLocked(l);
            if (l.currentNetwork != null) {
                return PhoneConstants.APN_ALREADY_ACTIVE;
            } else {
                return PhoneConstants.APN_REQUEST_STARTED;
            }
        }
        request = requestNetworkForFeatureLocked(netCap);
    }
    if (request != null) {
        Log.d(TAG, "starting startUsingNetworkFeature for request " + request);
        return PhoneConstants.APN_REQUEST_STARTED;
    } else {
        Log.d(TAG, " request Failed");
        return PhoneConstants.APN_REQUEST_FAILED;
    }
}
------------------------
Find a silently evolved API code:android.app.Notification.Builder.processSmallRightIcon:COMMENT
Method Modifier: private     
Comment:/**
 * Recolor small icons when used in the R.id.right_icon slot.
 */

Body of Frist Method:
{
    if (!isLegacy() || mColorUtil.isGrayscaleIcon(mContext, smallIconDrawableId)) {
        contentView.setDrawableParameters(R.id.right_icon, false, -1, 0xFFFFFFFF, PorterDuff.Mode.SRC_ATOP, -1);
        contentView.setInt(R.id.right_icon, "setBackgroundResource", R.drawable.notification_icon_legacy_bg);
        contentView.setDrawableParameters(R.id.right_icon, true, -1, resolveColor(), PorterDuff.Mode.SRC_ATOP, -1);
    }
}
Body of Second Method:
{
    if (!isLegacy()) {
        contentView.setDrawableParameters(R.id.right_icon, false, -1, 0xFFFFFFFF, PorterDuff.Mode.SRC_ATOP, -1);
    }
    if (!isLegacy() || mColorUtil.isGrayscaleIcon(mContext, smallIconDrawableId)) {
        contentView.setInt(R.id.right_icon, "setBackgroundResource", R.drawable.notification_icon_legacy_bg);
        contentView.setDrawableParameters(R.id.right_icon, true, -1, resolveColor(), PorterDuff.Mode.SRC_ATOP, -1);
    }
}
------------------------
Find a silently evolved API code:android.webkit.WebSettings.setCacheMode:COMMENT
<android.webkit.WebSettings: void setCacheMode(int)>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Overrides the way the cache is used. The way the cache is used is based
 * on the navigation type. For a normal page load, the cache is checked
 * and content is re-validated as needed. When navigating back, content is
 * not revalidated, instead the content is just retrieved from the cache.
 * This method allows the client to override this behavior by specifying
 * one of {@link #LOAD_DEFAULT},
 * {@link #LOAD_CACHE_ELSE_NETWORK}, {@link #LOAD_NO_CACHE} or
 * {@link #LOAD_CACHE_ONLY}. The default value is {@link #LOAD_DEFAULT}.
 *
 * @param mode the mode to use
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.webkit.WebSettings.setLayoutAlgorithm:COMMENT
<android.webkit.WebSettings: void setLayoutAlgorithm(LayoutAlgorithm)>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Sets the underlying layout algorithm. This will cause a relayout of the
 * WebView. The default is {@link LayoutAlgorithm#NARROW_COLUMNS}.
 *
 * @param l the layout algorithm to use, as a {@link LayoutAlgorithm} value
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.widget.ProgressBar.applySecondaryProgressTint:COMMENT
Method Modifier: private     
Comment:/**
 * Should only be called if we've already verified that mProgressDrawable
 * and mProgressTintInfo are non-null.
 */

Body of Frist Method:
{
    if (mProgressTintInfo.mHasSecondaryProgressTint || mProgressTintInfo.mHasSecondaryProgressTintMode) {
        final Drawable target = getTintTarget(R.id.secondaryProgress, false);
        if (target != null) {
            if (mProgressTintInfo.mHasSecondaryProgressTint) {
                target.setTintList(mProgressTintInfo.mSecondaryProgressTintList);
            }
            if (mProgressTintInfo.mHasSecondaryProgressTintMode) {
                target.setTintMode(mProgressTintInfo.mSecondaryProgressTintMode);
            }
        }
    }
}
Body of Second Method:
{
    if (mProgressTintInfo.mHasSecondaryProgressTint || mProgressTintInfo.mHasSecondaryProgressTintMode) {
        final Drawable target = getTintTarget(R.id.secondaryProgress, false);
        if (target != null) {
            if (mProgressTintInfo.mHasSecondaryProgressTint) {
                target.setTintList(mProgressTintInfo.mSecondaryProgressTintList);
            }
            if (mProgressTintInfo.mHasSecondaryProgressTintMode) {
                target.setTintMode(mProgressTintInfo.mSecondaryProgressTintMode);
            }
            // stateful before applying the tint, so let's try again.
            if (target.isStateful()) {
                target.setState(getDrawableState());
            }
        }
    }
}
------------------------
Find a silently evolved API code:android.webkit.WebHistoryItem.clone:COMMENT
<android.webkit.WebHistoryItem: WebHistoryItem clone()>
protected   ->protected   abstract    
Method Modifier: protected   abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Clone the history item for use by clients of WebView.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.content.ContentProvider.enforceReadPermissionInner:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * {@hide}
 */

Body of Frist Method:
{
    final Context context = getContext();
    final int pid = Binder.getCallingPid();
    final int uid = Binder.getCallingUid();
    String missingPerm = null;
    if (UserHandle.isSameApp(uid, mMyUid)) {
        return;
    }
    if (mExported && checkUser(pid, uid, context)) {
        final String componentPerm = getReadPermission();
        if (componentPerm != null) {
            if (context.checkPermission(componentPerm, pid, uid) == PERMISSION_GRANTED) {
                return;
            } else {
                missingPerm = componentPerm;
            }
        }
        // track if unprotected read is allowed; any denied
        // <path-permission> below removes this ability
        boolean allowDefaultRead = (componentPerm == null);
        final PathPermission[] pps = getPathPermissions();
        if (pps != null) {
            final String path = uri.getPath();
            for (PathPermission pp : pps) {
                final String pathPerm = pp.getReadPermission();
                if (pathPerm != null && pp.match(path)) {
                    if (context.checkPermission(pathPerm, pid, uid) == PERMISSION_GRANTED) {
                        return;
                    } else {
                        // any denied <path-permission> means we lose
                        // default <provider> access.
                        allowDefaultRead = false;
                        missingPerm = pathPerm;
                    }
                }
            }
        }
        // <provider> permission, then allow access.
        if (allowDefaultRead)
            return;
    }
    // last chance, check against any uri grants
    if (context.checkUriPermission(uri, pid, uid, Intent.FLAG_GRANT_READ_URI_PERMISSION) == PERMISSION_GRANTED) {
        return;
    }
    final String failReason = mExported ? " requires " + missingPerm + ", or grantUriPermission()" : " requires the provider be exported, or grantUriPermission()";
    throw new SecurityException("Permission Denial: reading " + ContentProvider.this.getClass().getName() + " uri " + uri + " from pid=" + pid + ", uid=" + uid + failReason);
}
Body of Second Method:
{
    final Context context = getContext();
    final int pid = Binder.getCallingPid();
    final int uid = Binder.getCallingUid();
    String missingPerm = null;
    if (UserHandle.isSameApp(uid, mMyUid)) {
        return;
    }
    if (mExported && checkUser(pid, uid, context)) {
        final String componentPerm = getReadPermission();
        if (componentPerm != null) {
            if (context.checkPermission(componentPerm, pid, uid, callerToken) == PERMISSION_GRANTED) {
                return;
            } else {
                missingPerm = componentPerm;
            }
        }
        // track if unprotected read is allowed; any denied
        // <path-permission> below removes this ability
        boolean allowDefaultRead = (componentPerm == null);
        final PathPermission[] pps = getPathPermissions();
        if (pps != null) {
            final String path = uri.getPath();
            for (PathPermission pp : pps) {
                final String pathPerm = pp.getReadPermission();
                if (pathPerm != null && pp.match(path)) {
                    if (context.checkPermission(pathPerm, pid, uid, callerToken) == PERMISSION_GRANTED) {
                        return;
                    } else {
                        // any denied <path-permission> means we lose
                        // default <provider> access.
                        allowDefaultRead = false;
                        missingPerm = pathPerm;
                    }
                }
            }
        }
        // <provider> permission, then allow access.
        if (allowDefaultRead)
            return;
    }
    // last chance, check against any uri grants
    final int callingUserId = UserHandle.getUserId(uid);
    final Uri userUri = (mSingleUser && !UserHandle.isSameUser(mMyUid, uid)) ? maybeAddUserId(uri, callingUserId) : uri;
    if (context.checkUriPermission(userUri, pid, uid, Intent.FLAG_GRANT_READ_URI_PERMISSION, callerToken) == PERMISSION_GRANTED) {
        return;
    }
    final String failReason = mExported ? " requires " + missingPerm + ", or grantUriPermission()" : " requires the provider be exported, or grantUriPermission()";
    throw new SecurityException("Permission Denial: reading " + ContentProvider.this.getClass().getName() + " uri " + uri + " from pid=" + pid + ", uid=" + uid + failReason);
}
------------------------
Find a silently evolved API code:android.app.SharedElementCallback.onCreateSnapshotView:COMMENT
Method Modifier: public      
Comment:/**
 * Reconstitutes a snapshot View from a Parcelable returned in
 * {@link #onCaptureSharedElementSnapshot(android.view.View, android.graphics.Matrix,
 * android.graphics.RectF)} to be used in {@link #onSharedElementStart(java.util.List,
 * java.util.List, java.util.List)} and {@link #onSharedElementEnd(java.util.List,
 * java.util.List, java.util.List)}. The returned View will be sized and positioned after
 * this call so that it is ready to be added to the decor View's overlay.
 *
 * <p>This is not called for Fragment Transitions.</p>
 *
 * @param context The Context used to create the snapshot View.
 * @param snapshot The Parcelable returned by {@link #onCaptureSharedElementSnapshot(
 * android.view.View, android.graphics.Matrix, android.graphics.RectF)}.
 * @return A View to be sent in {@link #onSharedElementStart(java.util.List, java.util.List,
 * java.util.List)} and {@link #onSharedElementEnd(java.util.List, java.util.List,
 * java.util.List)}. A null value will produce a null snapshot value for those two methods.
 */

Body of Frist Method:
{
    View view = null;
    if (snapshot instanceof Bitmap) {
        Bitmap bitmap = (Bitmap) snapshot;
        view = new View(context);
        Resources resources = context.getResources();
        view.setBackground(new BitmapDrawable(resources, bitmap));
    }
    return view;
}
Body of Second Method:
{
    View view = null;
    if (snapshot instanceof Bundle) {
        Bundle bundle = (Bundle) snapshot;
        Bitmap bitmap = (Bitmap) bundle.getParcelable(BUNDLE_SNAPSHOT_BITMAP);
        if (bitmap == null) {
            return null;
        }
        ImageView imageView = new ImageView(context);
        view = imageView;
        imageView.setImageBitmap(bitmap);
        imageView.setScaleType(ScaleType.valueOf(bundle.getString(BUNDLE_SNAPSHOT_IMAGE_SCALETYPE)));
        if (imageView.getScaleType() == ScaleType.MATRIX) {
            float[] values = bundle.getFloatArray(BUNDLE_SNAPSHOT_IMAGE_MATRIX);
            Matrix matrix = new Matrix();
            matrix.setValues(values);
            imageView.setImageMatrix(matrix);
        }
    } else if (snapshot instanceof Bitmap) {
        Bitmap bitmap = (Bitmap) snapshot;
        view = new View(context);
        Resources resources = context.getResources();
        view.setBackground(new BitmapDrawable(resources, bitmap));
    }
    return view;
}
------------------------
Find a silently evolved API code:android.webkit.WebView.createPrintDocumentAdapter:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * @deprecated Use {@link #createPrintDocumentAdapter(String)} which requires user
 * to provide a print document name.
 */

Body of Frist Method:
{
    checkThread();
    if (DebugFlags.TRACE_API)
        Log.d(LOGTAG, "createPrintDocumentAdapter");
    return mProvider.createPrintDocumentAdapter("default");
}
Body of Second Method:
{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, "createPrintDocumentAdapter");
    return mProvider.createPrintDocumentAdapter("default");
}
------------------------
Find a silently evolved API code:android.webkit.WebSettings.getBuiltInZoomControls:COMMENT
<android.webkit.WebSettings: boolean getBuiltInZoomControls()>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Gets whether the zoom mechanisms built into WebView are being used.
 *
 * @return true if the zoom mechanisms built into WebView are being used
 * @see #setBuiltInZoomControls
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.webkit.WebView.restorePicture:COMMENT
Method Modifier: public      hidden      deprecated  
Comment:/**
 * Restores the display data that was saved in {@link #savePicture}. Used in
 * conjunction with {@link #restoreState}. Note that this will not work if
 * this WebView is hardware accelerated.
 *
 * @param b a Bundle containing the saved display data
 * @param src the file where the picture data was stored
 * @return true if the picture was successfully restored
 * @deprecated This method is now obsolete.
 * @hide Since API level {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1}
 */

Body of Frist Method:
{
    checkThread();
    if (DebugFlags.TRACE_API)
        Log.d(LOGTAG, "restorePicture=" + src.getName());
    return mProvider.restorePicture(b, src);
}
Body of Second Method:
{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, "restorePicture=" + src.getName());
    return mProvider.restorePicture(b, src);
}
------------------------
Find a silently evolved API code:android.webkit.WebSettings.setTextZoom:COMMENT
<android.webkit.WebSettings: void setTextZoom(int)>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Sets the text zoom of the page in percent. The default is 100.
 *
 * @param textZoom the text zoom in percent
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.media.AudioService.shouldVibrate:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @see AudioManager#shouldVibrate(int)
 */

Body of Frist Method:
{
    if (!mHasVibrator)
        return false;
    switch(getVibrateSetting(vibrateType)) {
        case AudioManager.VIBRATE_SETTING_ON:
            return getRingerMode() != AudioManager.RINGER_MODE_SILENT;
        case AudioManager.VIBRATE_SETTING_ONLY_SILENT:
            return getRingerMode() == AudioManager.RINGER_MODE_VIBRATE;
        case AudioManager.VIBRATE_SETTING_OFF:
            // return false, even for incoming calls
            return false;
        default:
            return false;
    }
}
Body of Second Method:
{
    if (!mHasVibrator)
        return false;
    switch(getVibrateSetting(vibrateType)) {
        case AudioManager.VIBRATE_SETTING_ON:
            return getRingerModeExternal() != AudioManager.RINGER_MODE_SILENT;
        case AudioManager.VIBRATE_SETTING_ONLY_SILENT:
            return getRingerModeExternal() == AudioManager.RINGER_MODE_VIBRATE;
        case AudioManager.VIBRATE_SETTING_OFF:
            // return false, even for incoming calls
            return false;
        default:
            return false;
    }
}
------------------------
Find a silently evolved API code:android.appwidget.AppWidgetHost.deleteAppWidgetId:COMMENT
Method Modifier: public      
Comment:/**
 * Stop listening to changes for this AppWidget.
 */

Body of Frist Method:
{
    synchronized (mViews) {
        mViews.remove(appWidgetId);
        try {
            sService.deleteAppWidgetId(mContext.getOpPackageName(), appWidgetId);
        } catch (RemoteException e) {
            throw new RuntimeException("system server dead?", e);
        }
    }
}
Body of Second Method:
{
    synchronized (mViews) {
        mViews.remove(appWidgetId);
        try {
            sService.deleteAppWidgetId(mContextOpPackageName, appWidgetId);
        } catch (RemoteException e) {
            throw new RuntimeException("system server dead?", e);
        }
    }
}
------------------------
Find a silently evolved API code:android.provider.MediaStore.InternalThumbnails.getThumbnail:COMMENT
Method Modifier: default     static      
Comment:/**
 * This method ensure thumbnails associated with origId are generated and decode the byte
 * stream from database (MICRO_KIND) or file (MINI_KIND).
 *
 * Special optimization has been done to avoid further IPC communication for MICRO_KIND
 * thumbnails.
 *
 * @param cr ContentResolver
 * @param origId original image or video id
 * @param kind could be MINI_KIND or MICRO_KIND
 * @param options this is only used for MINI_KIND when decoding the Bitmap
 * @param baseUri the base URI of requested thumbnails
 * @param groupId the id of group to which this request belongs
 * @return Bitmap bitmap of specified thumbnail kind
 */

Body of Frist Method:
{
    Bitmap bitmap = null;
    String filePath = null;
    // Log.v(TAG, "getThumbnail: origId="+origId+", kind="+kind+", isVideo="+isVideo);
    // If the magic is non-zero, we simply return thumbnail if it does exist.
    // querying MediaProvider and simply return thumbnail.
    MiniThumbFile thumbFile = new MiniThumbFile(isVideo ? Video.Media.EXTERNAL_CONTENT_URI : Images.Media.EXTERNAL_CONTENT_URI);
    Cursor c = null;
    try {
        long magic = thumbFile.getMagic(origId);
        if (magic != 0) {
            if (kind == MICRO_KIND) {
                synchronized (sThumbBufLock) {
                    if (sThumbBuf == null) {
                        sThumbBuf = new byte[MiniThumbFile.BYTES_PER_MINTHUMB];
                    }
                    if (thumbFile.getMiniThumbFromFile(origId, sThumbBuf) != null) {
                        bitmap = BitmapFactory.decodeByteArray(sThumbBuf, 0, sThumbBuf.length);
                        if (bitmap == null) {
                            Log.w(TAG, "couldn't decode byte array.");
                        }
                    }
                }
                return bitmap;
            } else if (kind == MINI_KIND) {
                String column = isVideo ? "video_id=" : "image_id=";
                c = cr.query(baseUri, PROJECTION, column + origId, null, null);
                if (c != null && c.moveToFirst()) {
                    bitmap = getMiniThumbFromFile(c, baseUri, cr, options);
                    if (bitmap != null) {
                        return bitmap;
                    }
                }
            }
        }
        Uri blockingUri = baseUri.buildUpon().appendQueryParameter("blocking", "1").appendQueryParameter("orig_id", String.valueOf(origId)).appendQueryParameter("group_id", String.valueOf(groupId)).build();
        if (c != null)
            c.close();
        c = cr.query(blockingUri, PROJECTION, null, null, null);
        // This happens when original image/video doesn't exist.
        if (c == null)
            return null;
        // Assuming thumbnail has been generated, at least original image exists.
        if (kind == MICRO_KIND) {
            synchronized (sThumbBufLock) {
                if (sThumbBuf == null) {
                    sThumbBuf = new byte[MiniThumbFile.BYTES_PER_MINTHUMB];
                }
                Arrays.fill(sThumbBuf, (byte) 0);
                if (thumbFile.getMiniThumbFromFile(origId, sThumbBuf) != null) {
                    bitmap = BitmapFactory.decodeByteArray(sThumbBuf, 0, sThumbBuf.length);
                    if (bitmap == null) {
                        Log.w(TAG, "couldn't decode byte array.");
                    }
                }
            }
        } else if (kind == MINI_KIND) {
            if (c.moveToFirst()) {
                bitmap = getMiniThumbFromFile(c, baseUri, cr, options);
            }
        } else {
            throw new IllegalArgumentException("Unsupported kind: " + kind);
        }
        // We probably run out of space, so create the thumbnail in memory.
        if (bitmap == null) {
            Log.v(TAG, "Create the thumbnail in memory: origId=" + origId + ", kind=" + kind + ", isVideo=" + isVideo);
            Uri uri = Uri.parse(baseUri.buildUpon().appendPath(String.valueOf(origId)).toString().replaceFirst("thumbnails", "media"));
            if (filePath == null) {
                if (c != null)
                    c.close();
                c = cr.query(uri, PROJECTION, null, null, null);
                if (c == null || !c.moveToFirst()) {
                    return null;
                }
                filePath = c.getString(1);
            }
            if (isVideo) {
                bitmap = ThumbnailUtils.createVideoThumbnail(filePath, kind);
            } else {
                bitmap = ThumbnailUtils.createImageThumbnail(filePath, kind);
            }
        }
    } catch (SQLiteException ex) {
        Log.w(TAG, ex);
    } finally {
        if (c != null)
            c.close();
        // To avoid file descriptor leak in application process.
        thumbFile.deactivate();
        thumbFile = null;
    }
    return bitmap;
}
Body of Second Method:
{
    Bitmap bitmap = null;
    // Log.v(TAG, "getThumbnail: origId="+origId+", kind="+kind+", isVideo="+isVideo);
    // If the magic is non-zero, we simply return thumbnail if it does exist.
    // querying MediaProvider and simply return thumbnail.
    MiniThumbFile thumbFile = new MiniThumbFile(isVideo ? Video.Media.EXTERNAL_CONTENT_URI : Images.Media.EXTERNAL_CONTENT_URI);
    Cursor c = null;
    try {
        long magic = thumbFile.getMagic(origId);
        if (magic != 0) {
            if (kind == MICRO_KIND) {
                synchronized (sThumbBufLock) {
                    if (sThumbBuf == null) {
                        sThumbBuf = new byte[MiniThumbFile.BYTES_PER_MINTHUMB];
                    }
                    if (thumbFile.getMiniThumbFromFile(origId, sThumbBuf) != null) {
                        bitmap = BitmapFactory.decodeByteArray(sThumbBuf, 0, sThumbBuf.length);
                        if (bitmap == null) {
                            Log.w(TAG, "couldn't decode byte array.");
                        }
                    }
                }
                return bitmap;
            } else if (kind == MINI_KIND) {
                String column = isVideo ? "video_id=" : "image_id=";
                c = cr.query(baseUri, PROJECTION, column + origId, null, null);
                if (c != null && c.moveToFirst()) {
                    bitmap = getMiniThumbFromFile(c, baseUri, cr, options);
                    if (bitmap != null) {
                        return bitmap;
                    }
                }
            }
        }
        Uri blockingUri = baseUri.buildUpon().appendQueryParameter("blocking", "1").appendQueryParameter("orig_id", String.valueOf(origId)).appendQueryParameter("group_id", String.valueOf(groupId)).build();
        if (c != null)
            c.close();
        c = cr.query(blockingUri, PROJECTION, null, null, null);
        // This happens when original image/video doesn't exist.
        if (c == null)
            return null;
        // Assuming thumbnail has been generated, at least original image exists.
        if (kind == MICRO_KIND) {
            synchronized (sThumbBufLock) {
                if (sThumbBuf == null) {
                    sThumbBuf = new byte[MiniThumbFile.BYTES_PER_MINTHUMB];
                }
                Arrays.fill(sThumbBuf, (byte) 0);
                if (thumbFile.getMiniThumbFromFile(origId, sThumbBuf) != null) {
                    bitmap = BitmapFactory.decodeByteArray(sThumbBuf, 0, sThumbBuf.length);
                    if (bitmap == null) {
                        Log.w(TAG, "couldn't decode byte array.");
                    }
                }
            }
        } else if (kind == MINI_KIND) {
            if (c.moveToFirst()) {
                bitmap = getMiniThumbFromFile(c, baseUri, cr, options);
            }
        } else {
            throw new IllegalArgumentException("Unsupported kind: " + kind);
        }
        // We probably run out of space, so create the thumbnail in memory.
        if (bitmap == null) {
            Log.v(TAG, "Create the thumbnail in memory: origId=" + origId + ", kind=" + kind + ", isVideo=" + isVideo);
            Uri uri = Uri.parse(baseUri.buildUpon().appendPath(String.valueOf(origId)).toString().replaceFirst("thumbnails", "media"));
            if (c != null)
                c.close();
            c = cr.query(uri, PROJECTION, null, null, null);
            if (c == null || !c.moveToFirst()) {
                return null;
            }
            String filePath = c.getString(1);
            if (filePath != null) {
                if (isVideo) {
                    bitmap = ThumbnailUtils.createVideoThumbnail(filePath, kind);
                } else {
                    bitmap = ThumbnailUtils.createImageThumbnail(filePath, kind);
                }
            }
        }
    } catch (SQLiteException ex) {
        Log.w(TAG, ex);
    } finally {
        if (c != null)
            c.close();
        // To avoid file descriptor leak in application process.
        thumbFile.deactivate();
        thumbFile = null;
    }
    return bitmap;
}
------------------------
Find a silently evolved API code:android.webkit.WebSettings.setMinimumFontSize:COMMENT
<android.webkit.WebSettings: void setMinimumFontSize(int)>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Sets the minimum font size. The default is 8.
 *
 * @param size a non-negative integer between 1 and 72. Any number outside
 * the specified range will be pinned.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.webkit.WebSettings.getDefaultFixedFontSize:COMMENT
<android.webkit.WebSettings: int getDefaultFixedFontSize()>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Gets the default fixed font size.
 *
 * @return a non-negative integer between 1 and 72
 * @see #setDefaultFixedFontSize
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.webkit.WebView.findNext:COMMENT
Method Modifier: public      
Comment:/**
 * Highlights and scrolls to the next match found by
 * {@link #findAllAsync}, wrapping around page boundaries as necessary.
 * Notifies any registered {@link FindListener}. If {@link #findAllAsync(String)}
 * has not been called yet, or if {@link #clearMatches} has been called since the
 * last find operation, this function does nothing.
 *
 * @param forward the direction to search
 * @see #setFindListener
 */

Body of Frist Method:
{
    checkThread();
    if (DebugFlags.TRACE_API)
        Log.d(LOGTAG, "findNext");
    mProvider.findNext(forward);
}
Body of Second Method:
{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, "findNext");
    mProvider.findNext(forward);
}
------------------------
Find a silently evolved API code:android.animation.PropertyValuesHolder.setupEndValue:COMMENT
Method Modifier: default     
Comment:/**
 * This function is called by ObjectAnimator when setting the end values for an animation.
 * The end values are set according to the current values in the target object. The
 * property whose value is extracted is whatever is specified by the propertyName of this
 * PropertyValuesHolder object.
 *
 * @param target The object which holds the start values that should be set.
 */

Body of Frist Method:
{
    ArrayList<Keyframe> keyframes = mKeyframes.getKeyframes();
    if (!keyframes.isEmpty()) {
        setupValue(target, keyframes.get(keyframes.size() - 1));
    }
}
Body of Second Method:
{
    List<Keyframe> keyframes = mKeyframes.getKeyframes();
    if (!keyframes.isEmpty()) {
        setupValue(target, keyframes.get(keyframes.size() - 1));
    }
}
------------------------
Find a silently evolved API code:android.webkit.WebSettings.getLightTouchEnabled:COMMENT
<android.webkit.WebSettings: boolean getLightTouchEnabled()>
public      deprecated  ->public      abstract    deprecated  
Method Modifier: public      abstract    deprecated  
Method Modifier: Yes         No          Yes         
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * Gets whether light touches are enabled.
 * @see #setLightTouchEnabled
 * @deprecated This setting is obsolete.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.os.Parcel.unmarshall:COMMENT
Method Modifier: public      final       
Comment:/**
 * Set the bytes in data to be the raw bytes of this Parcel.
 */

Body of Frist Method:
{
    nativeUnmarshall(mNativePtr, data, offest, length);
}
Body of Second Method:
{
    nativeUnmarshall(mNativePtr, data, offset, length);
}
------------------------
Find a silently evolved API code:android.webkit.WebView.savePicture:COMMENT
Method Modifier: public      hidden      deprecated  
Comment:/**
 * Saves the current display data to the Bundle given. Used in conjunction
 * with {@link #saveState}.
 * @param b a Bundle to store the display data
 * @param dest the file to store the serialized picture data. Will be
 * overwritten with this WebView's picture data.
 * @return true if the picture was successfully saved
 * @deprecated This method is now obsolete.
 * @hide Since API level {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1}
 */

Body of Frist Method:
{
    checkThread();
    if (DebugFlags.TRACE_API)
        Log.d(LOGTAG, "savePicture=" + dest.getName());
    return mProvider.savePicture(b, dest);
}
Body of Second Method:
{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, "savePicture=" + dest.getName());
    return mProvider.savePicture(b, dest);
}
------------------------
Find a silently evolved API code:android.webkit.WebSettings.setLightTouchEnabled:COMMENT
<android.webkit.WebSettings: void setLightTouchEnabled(boolean)>
public      deprecated  ->public      abstract    deprecated  
Method Modifier: public      abstract    deprecated  
Method Modifier: Yes         No          Yes         
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * Enables using light touches to make a selection and activate mouseovers.
 * @deprecated From {@link android.os.Build.VERSION_CODES#JELLY_BEAN} this
 * setting is obsolete and has no effect.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.app.AppOpsManager.resetAllModes:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    try {
        mService.resetAllModes();
    } catch (RemoteException e) {
    }
}
Body of Second Method:
{
    try {
        mService.resetAllModes(UserHandle.myUserId(), null);
    } catch (RemoteException e) {
    }
}
------------------------
Find a silently evolved API code:android.graphics.Bitmap.recycle:COMMENT
Method Modifier: public      
Comment:/**
 * Free the native object associated with this bitmap, and clear the
 * reference to the pixel data. This will not free the pixel data synchronously;
 * it simply allows it to be garbage collected if there are no other references.
 * The bitmap is marked as "dead", meaning it will throw an exception if
 * getPixels() or setPixels() is called, and will draw nothing. This operation
 * cannot be reversed, so it should only be called if you are sure there are no
 * further uses for the bitmap. This is an advanced call, and normally need
 * not be called, since the normal GC process will free up this memory when
 * there are no more references to this bitmap.
 */

Body of Frist Method:
{
    if (!mRecycled) {
        if (nativeRecycle(mNativeBitmap)) {
            // return value indicates whether native pixel object was actually recycled.
            // false indicates that it is still in use at the native level and these
            // objects should not be collected now. They will be collected later when the
            // Bitmap itself is collected.
            mBuffer = null;
            mNinePatchChunk = null;
        }
        mRecycled = true;
    }
}
Body of Second Method:
{
    if (!mRecycled && mFinalizer.mNativeBitmap != 0) {
        if (nativeRecycle(mNativeBitmap)) {
            // return value indicates whether native pixel object was actually recycled.
            // false indicates that it is still in use at the native level and these
            // objects should not be collected now. They will be collected later when the
            // Bitmap itself is collected.
            mBuffer = null;
            mNinePatchChunk = null;
        }
        mRecycled = true;
    }
}
------------------------
Find a silently evolved API code:android.media.AudioService.checkSendBecomingNoisyIntent:COMMENT
Method Modifier: private     hidden      
Comment:// must be called before removing the device from mConnectedDevices

Body of Frist Method:
{
    int delay = 0;
    if ((state == 0) && ((device & mBecomingNoisyIntentDevices) != 0)) {
        int devices = 0;
        for (int dev : mConnectedDevices.keySet()) {
            if (((dev & AudioSystem.DEVICE_BIT_IN) == 0) && ((dev & mBecomingNoisyIntentDevices) != 0)) {
                devices |= dev;
            }
        }
        if (devices == device) {
            sendMsg(mAudioHandler, MSG_BROADCAST_AUDIO_BECOMING_NOISY, SENDMSG_REPLACE, 0, 0, null, 0);
            delay = 1000;
        }
    }
    if (mAudioHandler.hasMessages(MSG_SET_A2DP_SRC_CONNECTION_STATE) || mAudioHandler.hasMessages(MSG_SET_A2DP_SINK_CONNECTION_STATE) || mAudioHandler.hasMessages(MSG_SET_WIRED_DEVICE_CONNECTION_STATE)) {
        delay = 1000;
    }
    return delay;
}
Body of Second Method:
{
    int delay = 0;
    if ((state == 0) && ((device & mBecomingNoisyIntentDevices) != 0)) {
        int devices = 0;
        for (int dev : mConnectedDevices.keySet()) {
            if (((dev & AudioSystem.DEVICE_BIT_IN) == 0) && ((dev & mBecomingNoisyIntentDevices) != 0)) {
                devices |= dev;
            }
        }
        if (devices == device) {
            sendMsg(mAudioHandler, MSG_BROADCAST_AUDIO_BECOMING_NOISY, SENDMSG_REPLACE, 0, 0, null, 0);
            delay = 1000;
        }
    }
    if (mAudioHandler.hasMessages(MSG_SET_A2DP_SRC_CONNECTION_STATE) || mAudioHandler.hasMessages(MSG_SET_A2DP_SINK_CONNECTION_STATE) || mAudioHandler.hasMessages(MSG_SET_WIRED_DEVICE_CONNECTION_STATE)) {
        synchronized (mLastDeviceConnectMsgTime) {
            long time = SystemClock.uptimeMillis();
            if (mLastDeviceConnectMsgTime > time) {
                delay = (int) (mLastDeviceConnectMsgTime - time) + 30;
            }
        }
    }
    return delay;
}
------------------------
Find a silently evolved API code:android.webkit.WebSettings.getJavaScriptCanOpenWindowsAutomatically:COMMENT
<android.webkit.WebSettings: boolean getJavaScriptCanOpenWindowsAutomatically()>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Gets whether JavaScript can open windows automatically.
 *
 * @return true if JavaScript can open windows automatically during
 * window.open()
 * @see #setJavaScriptCanOpenWindowsAutomatically
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.appwidget.AppWidgetHost.stopListening:COMMENT
Method Modifier: public      
Comment:/**
 * Stop receiving onAppWidgetChanged calls for your AppWidgets.  Call this when your activity is
 * no longer visible, i.e. from onStop() in your Activity.
 */

Body of Frist Method:
{
    try {
        sService.stopListening(mContext.getOpPackageName(), mHostId);
    } catch (RemoteException e) {
        throw new RuntimeException("system server dead?", e);
    }
    // This is here because keyguard needs it since it'll be switching users after this call.
    // If it turns out other apps need to call this often, we should re-think how this works.
    clearViews();
}
Body of Second Method:
{
    try {
        sService.stopListening(mContextOpPackageName, mHostId);
    } catch (RemoteException e) {
        throw new RuntimeException("system server dead?", e);
    }
    // This is here because keyguard needs it since it'll be switching users after this call.
    // If it turns out other apps need to call this often, we should re-think how this works.
    clearViews();
}
------------------------
Find a silently evolved API code:android.webkit.WebHistoryItem.getOriginalUrl:COMMENT
<android.webkit.WebHistoryItem: String getOriginalUrl()>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Return the original url of this history item. This was the requested
 * url, the final url may be different as there might have been
 * redirects while loading the site.
 * @return The original url of this history item.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.media.MediaFocusControl.dumpFocusStack:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Helper function:
 * Display in the log the current entries in the audio focus stack
 */

Body of Frist Method:
{
    pw.println("\nAudio Focus stack entries (last is top of stack):");
    synchronized (mAudioFocusLock) {
        Iterator<FocusRequester> stackIterator = mFocusStack.iterator();
        while (stackIterator.hasNext()) {
            stackIterator.next().dump(pw);
        }
    }
}
Body of Second Method:
{
    pw.println("\nAudio Focus stack entries (last is top of stack):");
    synchronized (mAudioFocusLock) {
        Iterator<FocusRequester> stackIterator = mFocusStack.iterator();
        while (stackIterator.hasNext()) {
            stackIterator.next().dump(pw);
        }
    }
    pw.println("\n Notify on duck: " + mNotifyFocusOwnerOnDuck + "\n");
}
------------------------
Find a silently evolved API code:android.view.ViewGroup.getChildVisibleRect:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    // It doesn't make a whole lot of sense to call this on a view that isn't attached,
    // but for some simple tests it can be useful. If we don't have attach info this
    // will allocate memory.
    final RectF rect = mAttachInfo != null ? mAttachInfo.mTmpTransformRect : new RectF();
    rect.set(r);
    if (!child.hasIdentityMatrix()) {
        child.getMatrix().mapRect(rect);
    }
    int dx = child.mLeft - mScrollX;
    int dy = child.mTop - mScrollY;
    rect.offset(dx, dy);
    if (offset != null) {
        if (!child.hasIdentityMatrix()) {
            float[] position = mAttachInfo != null ? mAttachInfo.mTmpTransformLocation : new float[2];
            position[0] = offset.x;
            position[1] = offset.y;
            child.getMatrix().mapPoints(position);
            offset.x = (int) (position[0] + 0.5f);
            offset.y = (int) (position[1] + 0.5f);
        }
        offset.x += dx;
        offset.y += dy;
    }
    if (rect.intersect(0, 0, mRight - mLeft, mBottom - mTop)) {
        if (mParent == null)
            return true;
        r.set((int) (rect.left + 0.5f), (int) (rect.top + 0.5f), (int) (rect.right + 0.5f), (int) (rect.bottom + 0.5f));
        return mParent.getChildVisibleRect(this, r, offset);
    }
    return false;
}
Body of Second Method:
{
    // It doesn't make a whole lot of sense to call this on a view that isn't attached,
    // but for some simple tests it can be useful. If we don't have attach info this
    // will allocate memory.
    final RectF rect = mAttachInfo != null ? mAttachInfo.mTmpTransformRect : new RectF();
    rect.set(r);
    if (!child.hasIdentityMatrix()) {
        child.getMatrix().mapRect(rect);
    }
    final int dx = child.mLeft - mScrollX;
    final int dy = child.mTop - mScrollY;
    rect.offset(dx, dy);
    if (offset != null) {
        if (!child.hasIdentityMatrix()) {
            float[] position = mAttachInfo != null ? mAttachInfo.mTmpTransformLocation : new float[2];
            position[0] = offset.x;
            position[1] = offset.y;
            child.getMatrix().mapPoints(position);
            offset.x = (int) (position[0] + 0.5f);
            offset.y = (int) (position[1] + 0.5f);
        }
        offset.x += dx;
        offset.y += dy;
    }
    final int width = mRight - mLeft;
    final int height = mBottom - mTop;
    boolean rectIsVisible = true;
    if (mParent == null || (mParent instanceof ViewGroup && ((ViewGroup) mParent).getClipChildren())) {
        // Clip to bounds.
        rectIsVisible = rect.intersect(0, 0, width, height);
    }
    if (rectIsVisible && (mGroupFlags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) {
        // Clip to padding.
        rectIsVisible = rect.intersect(mPaddingLeft, mPaddingTop, width - mPaddingRight, height - mPaddingBottom);
    }
    if (rectIsVisible && mClipBounds != null) {
        // Clip to clipBounds.
        rectIsVisible = rect.intersect(mClipBounds.left, mClipBounds.top, mClipBounds.right, mClipBounds.bottom);
    }
    r.set((int) (rect.left + 0.5f), (int) (rect.top + 0.5f), (int) (rect.right + 0.5f), (int) (rect.bottom + 0.5f));
    if (rectIsVisible && mParent != null) {
        rectIsVisible = mParent.getChildVisibleRect(this, r, offset);
    }
    return rectIsVisible;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothAdapter.removeServiceStateCallback:COMMENT
Method Modifier: default     
Comment:/*package*/

Body of Frist Method:
{
    synchronized (mManagerCallback) {
        mProxyServiceStateCallbacks.remove(cb);
    }
}
Body of Second Method:
{
    synchronized (mProxyServiceStateCallbacks) {
        mProxyServiceStateCallbacks.remove(cb);
    }
}
------------------------
Find a silently evolved API code:android.widget.SearchView.updateVoiceButton:COMMENT
Method Modifier: private     
Comment:/**
 * Update the visibility of the voice button.  There are actually two voice search modes,
 * either of which will activate the button.
 * @param empty whether the search query text field is empty. If it is, then the other
 * criteria apply to make the voice button visible.
 */

Body of Frist Method:
{
    int visibility = GONE;
    if (mVoiceButtonEnabled && !isIconified() && empty) {
        visibility = VISIBLE;
        mSubmitButton.setVisibility(GONE);
    }
    mVoiceButton.setVisibility(visibility);
}
Body of Second Method:
{
    int visibility = GONE;
    if (mVoiceButtonEnabled && !isIconified() && empty) {
        visibility = VISIBLE;
        mGoButton.setVisibility(GONE);
    }
    mVoiceButton.setVisibility(visibility);
}
------------------------
Find a silently evolved API code:android.telephony.ServiceState.getOperatorNumeric:COMMENT
Method Modifier: public      
Comment:/*
     * The country code can be decoded using
     * {@link com.android.internal.telephony.MccTable#countryCodeForMcc(int)}.
     */

Body of Frist Method:
{
    return mOperatorNumeric;
}
Body of Second Method:
{
    return mVoiceOperatorNumeric;
}
------------------------
Find a silently evolved API code:android.graphics.drawable.RotateDrawable.setPivotXRelative:COMMENT
Method Modifier: public      
Comment:/**
 * Sets whether the X pivot value represents a fraction of the drawable
 * width or an absolute value in pixels.
 *
 * @param relative True if the X pivot represents a fraction of the drawable
 * width, or false if it represents an absolute value in pixels
 *
 * @see #isPivotXRelative()
 */

Body of Frist Method:
{
    if (mState.mPivotXRel == relative) {
        mState.mPivotXRel = relative;
        invalidateSelf();
    }
}
Body of Second Method:
{
    if (mState.mPivotXRel != relative) {
        mState.mPivotXRel = relative;
        invalidateSelf();
    }
}
------------------------
Find a silently evolved API code:android.webkit.WebView.onPause:COMMENT
Method Modifier: public      
Comment:/**
 * Pauses any extra processing associated with this WebView and its
 * associated DOM, plugins, JavaScript etc. For example, if this WebView is
 * taken offscreen, this could be called to reduce unnecessary CPU or
 * network traffic. When this WebView is again "active", call onResume().
 * Note that this differs from pauseTimers(), which affects all WebViews.
 */

Body of Frist Method:
{
    checkThread();
    if (DebugFlags.TRACE_API)
        Log.d(LOGTAG, "onPause");
    mProvider.onPause();
}
Body of Second Method:
{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, "onPause");
    mProvider.onPause();
}
------------------------
Find a silently evolved API code:android.media.AudioService.handleConfigurationChanged:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Handles device configuration changes that may map to a change in the orientation
 * or orientation.
 * Monitoring orientation and rotation is optional, and is defined by the definition and value
 * of the "ro.audio.monitorOrientation" and "ro.audio.monitorRotation" system properties.
 */

Body of Frist Method:
{
    try {
        // reading new orientation "safely" (i.e. under try catch) in case anything
        // goes wrong when obtaining resources and configuration
        Configuration config = context.getResources().getConfiguration();
        // TODO merge rotation and orientation
        if (mMonitorOrientation) {
            int newOrientation = config.orientation;
            if (newOrientation != mDeviceOrientation) {
                mDeviceOrientation = newOrientation;
                setOrientationForAudioSystem();
            }
        }
        sendMsg(mAudioHandler, MSG_CONFIGURE_SAFE_MEDIA_VOLUME, SENDMSG_REPLACE, 0, 0, null, 0);
        boolean cameraSoundForced = mContext.getResources().getBoolean(com.android.internal.R.bool.config_camera_sound_forced);
        synchronized (mSettingsLock) {
            synchronized (mCameraSoundForced) {
                if (cameraSoundForced != mCameraSoundForced) {
                    mCameraSoundForced = cameraSoundForced;
                    if (!isPlatformTelevision()) {
                        VolumeStreamState s = mStreamStates[AudioSystem.STREAM_SYSTEM_ENFORCED];
                        if (cameraSoundForced) {
                            s.setAllIndexesToMax();
                            mRingerModeAffectedStreams &= ~(1 << AudioSystem.STREAM_SYSTEM_ENFORCED);
                        } else {
                            s.setAllIndexes(mStreamStates[AudioSystem.STREAM_SYSTEM]);
                            mRingerModeAffectedStreams |= (1 << AudioSystem.STREAM_SYSTEM_ENFORCED);
                        }
                        // take new state into account for streams muted by ringer mode
                        setRingerModeInt(getRingerMode(), false);
                    }
                    sendMsg(mAudioHandler, MSG_SET_FORCE_USE, SENDMSG_QUEUE, AudioSystem.FOR_SYSTEM, cameraSoundForced ? AudioSystem.FORCE_SYSTEM_ENFORCED : AudioSystem.FORCE_NONE, null, 0);
                    sendMsg(mAudioHandler, MSG_SET_ALL_VOLUMES, SENDMSG_QUEUE, 0, 0, mStreamStates[AudioSystem.STREAM_SYSTEM_ENFORCED], 0);
                }
            }
        }
        mVolumeController.setLayoutDirection(config.getLayoutDirection());
    } catch (Exception e) {
        Log.e(TAG, "Error handling configuration change: ", e);
    }
}
Body of Second Method:
{
    try {
        // reading new orientation "safely" (i.e. under try catch) in case anything
        // goes wrong when obtaining resources and configuration
        Configuration config = context.getResources().getConfiguration();
        // TODO merge rotation and orientation
        if (mMonitorOrientation) {
            int newOrientation = config.orientation;
            if (newOrientation != mDeviceOrientation) {
                mDeviceOrientation = newOrientation;
                setOrientationForAudioSystem();
            }
        }
        sendMsg(mAudioHandler, MSG_CONFIGURE_SAFE_MEDIA_VOLUME, SENDMSG_REPLACE, 0, 0, null, 0);
        boolean cameraSoundForced = mContext.getResources().getBoolean(com.android.internal.R.bool.config_camera_sound_forced);
        synchronized (mSettingsLock) {
            boolean cameraSoundForcedChanged = false;
            synchronized (mCameraSoundForced) {
                if (cameraSoundForced != mCameraSoundForced) {
                    mCameraSoundForced = cameraSoundForced;
                    cameraSoundForcedChanged = true;
                }
            }
            if (cameraSoundForcedChanged) {
                if (!isPlatformTelevision()) {
                    VolumeStreamState s = mStreamStates[AudioSystem.STREAM_SYSTEM_ENFORCED];
                    if (cameraSoundForced) {
                        s.setAllIndexesToMax();
                        mRingerModeAffectedStreams &= ~(1 << AudioSystem.STREAM_SYSTEM_ENFORCED);
                    } else {
                        s.setAllIndexes(mStreamStates[AudioSystem.STREAM_SYSTEM]);
                        mRingerModeAffectedStreams |= (1 << AudioSystem.STREAM_SYSTEM_ENFORCED);
                    }
                    // take new state into account for streams muted by ringer mode
                    setRingerModeInt(getRingerModeInternal(), false);
                }
                sendMsg(mAudioHandler, MSG_SET_FORCE_USE, SENDMSG_QUEUE, AudioSystem.FOR_SYSTEM, cameraSoundForced ? AudioSystem.FORCE_SYSTEM_ENFORCED : AudioSystem.FORCE_NONE, null, 0);
                sendMsg(mAudioHandler, MSG_SET_ALL_VOLUMES, SENDMSG_QUEUE, 0, 0, mStreamStates[AudioSystem.STREAM_SYSTEM_ENFORCED], 0);
            }
        }
        mVolumeController.setLayoutDirection(config.getLayoutDirection());
    } catch (Exception e) {
        Log.e(TAG, "Error handling configuration change: ", e);
    }
}
------------------------
Find a silently evolved API code:android.view.ViewGroup.dispatchTouchEvent:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(ev, 1);
    }
    boolean handled = false;
    if (onFilterTouchEventForSecurity(ev)) {
        final int action = ev.getAction();
        final int actionMasked = action & MotionEvent.ACTION_MASK;
        // Handle an initial down.
        if (actionMasked == MotionEvent.ACTION_DOWN) {
            // Throw away all previous state when starting a new touch gesture.
            // The framework may have dropped the up or cancel event for the previous gesture
            // due to an app switch, ANR, or some other state change.
            cancelAndClearTouchTargets(ev);
            resetTouchState();
        }
        // Check for interception.
        final boolean intercepted;
        if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) {
            final boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;
            if (!disallowIntercept) {
                intercepted = onInterceptTouchEvent(ev);
                // restore action in case it was changed
                ev.setAction(action);
            } else {
                intercepted = false;
            }
        } else {
            // There are no touch targets and this action is not an initial down
            // so this view group continues to intercept touches.
            intercepted = true;
        }
        // Check for cancelation.
        final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL;
        // Update list of touch targets for pointer down, if needed.
        final boolean split = (mGroupFlags & FLAG_SPLIT_MOTION_EVENTS) != 0;
        TouchTarget newTouchTarget = null;
        boolean alreadyDispatchedToNewTouchTarget = false;
        if (!canceled && !intercepted) {
            if (actionMasked == MotionEvent.ACTION_DOWN || (split && actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
                // always 0 for down
                final int actionIndex = ev.getActionIndex();
                final int idBitsToAssign = split ? 1 << ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS;
                // Clean up earlier touch targets for this pointer id in case they
                // have become out of sync.
                removePointersFromTouchTargets(idBitsToAssign);
                final int childrenCount = mChildrenCount;
                if (newTouchTarget == null && childrenCount != 0) {
                    final float x = ev.getX(actionIndex);
                    final float y = ev.getY(actionIndex);
                    // Find a child that can receive the event.
                    // Scan children from front to back.
                    final ArrayList<View> preorderedList = buildOrderedChildList();
                    final boolean customOrder = preorderedList == null && isChildrenDrawingOrderEnabled();
                    final View[] children = mChildren;
                    for (int i = childrenCount - 1; i >= 0; i--) {
                        final int childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i;
                        final View child = (preorderedList == null) ? children[childIndex] : preorderedList.get(childIndex);
                        if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) {
                            continue;
                        }
                        newTouchTarget = getTouchTarget(child);
                        if (newTouchTarget != null) {
                            // Child is already receiving touch within its bounds.
                            // Give it the new pointer in addition to the ones it is handling.
                            newTouchTarget.pointerIdBits |= idBitsToAssign;
                            break;
                        }
                        resetCancelNextUpFlag(child);
                        if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
                            // Child wants to receive touch within its bounds.
                            mLastTouchDownTime = ev.getDownTime();
                            if (preorderedList != null) {
                                // childIndex points into presorted list, find original index
                                for (int j = 0; j < childrenCount; j++) {
                                    if (children[childIndex] == mChildren[j]) {
                                        mLastTouchDownIndex = j;
                                        break;
                                    }
                                }
                            } else {
                                mLastTouchDownIndex = childIndex;
                            }
                            mLastTouchDownX = ev.getX();
                            mLastTouchDownY = ev.getY();
                            newTouchTarget = addTouchTarget(child, idBitsToAssign);
                            alreadyDispatchedToNewTouchTarget = true;
                            break;
                        }
                    }
                    if (preorderedList != null)
                        preorderedList.clear();
                }
                if (newTouchTarget == null && mFirstTouchTarget != null) {
                    // Did not find a child to receive the event.
                    // Assign the pointer to the least recently added target.
                    newTouchTarget = mFirstTouchTarget;
                    while (newTouchTarget.next != null) {
                        newTouchTarget = newTouchTarget.next;
                    }
                    newTouchTarget.pointerIdBits |= idBitsToAssign;
                }
            }
        }
        // Dispatch to touch targets.
        if (mFirstTouchTarget == null) {
            // No touch targets so treat this as an ordinary view.
            handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS);
        } else {
            // Dispatch to touch targets, excluding the new touch target if we already
            // dispatched to it.  Cancel touch targets if necessary.
            TouchTarget predecessor = null;
            TouchTarget target = mFirstTouchTarget;
            while (target != null) {
                final TouchTarget next = target.next;
                if (alreadyDispatchedToNewTouchTarget && target == newTouchTarget) {
                    handled = true;
                } else {
                    final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted;
                    if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) {
                        handled = true;
                    }
                    if (cancelChild) {
                        if (predecessor == null) {
                            mFirstTouchTarget = next;
                        } else {
                            predecessor.next = next;
                        }
                        target.recycle();
                        target = next;
                        continue;
                    }
                }
                predecessor = target;
                target = next;
            }
        }
        // Update list of touch targets for pointer up or cancel, if needed.
        if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
            resetTouchState();
        } else if (split && actionMasked == MotionEvent.ACTION_POINTER_UP) {
            final int actionIndex = ev.getActionIndex();
            final int idBitsToRemove = 1 << ev.getPointerId(actionIndex);
            removePointersFromTouchTargets(idBitsToRemove);
        }
    }
    if (!handled && mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);
    }
    return handled;
}
Body of Second Method:
{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(ev, 1);
    }
    // normal event dispatch. Maybe a descendant is what will handle the click.
    if (ev.isTargetAccessibilityFocus() && isAccessibilityFocusedViewOrHost()) {
        ev.setTargetAccessibilityFocus(false);
    }
    boolean handled = false;
    if (onFilterTouchEventForSecurity(ev)) {
        final int action = ev.getAction();
        final int actionMasked = action & MotionEvent.ACTION_MASK;
        // Handle an initial down.
        if (actionMasked == MotionEvent.ACTION_DOWN) {
            // Throw away all previous state when starting a new touch gesture.
            // The framework may have dropped the up or cancel event for the previous gesture
            // due to an app switch, ANR, or some other state change.
            cancelAndClearTouchTargets(ev);
            resetTouchState();
        }
        // Check for interception.
        final boolean intercepted;
        if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) {
            final boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;
            if (!disallowIntercept) {
                intercepted = onInterceptTouchEvent(ev);
                // restore action in case it was changed
                ev.setAction(action);
            } else {
                intercepted = false;
            }
        } else {
            // There are no touch targets and this action is not an initial down
            // so this view group continues to intercept touches.
            intercepted = true;
        }
        // a view that is handling the gesture, do normal event dispatch.
        if (intercepted || mFirstTouchTarget != null) {
            ev.setTargetAccessibilityFocus(false);
        }
        // Check for cancelation.
        final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL;
        // Update list of touch targets for pointer down, if needed.
        final boolean split = (mGroupFlags & FLAG_SPLIT_MOTION_EVENTS) != 0;
        TouchTarget newTouchTarget = null;
        boolean alreadyDispatchedToNewTouchTarget = false;
        if (!canceled && !intercepted) {
            // If the event is targeting accessiiblity focus we give it to the
            // view that has accessibility focus and if it does not handle it
            // we clear the flag and dispatch the event to all children as usual.
            // We are looking up the accessibility focused host to avoid keeping
            // state since these events are very rare.
            View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus() ? findChildWithAccessibilityFocus() : null;
            if (actionMasked == MotionEvent.ACTION_DOWN || (split && actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
                // always 0 for down
                final int actionIndex = ev.getActionIndex();
                final int idBitsToAssign = split ? 1 << ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS;
                // Clean up earlier touch targets for this pointer id in case they
                // have become out of sync.
                removePointersFromTouchTargets(idBitsToAssign);
                final int childrenCount = mChildrenCount;
                if (newTouchTarget == null && childrenCount != 0) {
                    final float x = ev.getX(actionIndex);
                    final float y = ev.getY(actionIndex);
                    // Find a child that can receive the event.
                    // Scan children from front to back.
                    final ArrayList<View> preorderedList = buildOrderedChildList();
                    final boolean customOrder = preorderedList == null && isChildrenDrawingOrderEnabled();
                    final View[] children = mChildren;
                    for (int i = childrenCount - 1; i >= 0; i--) {
                        final int childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i;
                        final View child = (preorderedList == null) ? children[childIndex] : preorderedList.get(childIndex);
                        // safer given the timeframe.
                        if (childWithAccessibilityFocus != null) {
                            if (childWithAccessibilityFocus != child) {
                                continue;
                            }
                            childWithAccessibilityFocus = null;
                            i = childrenCount - 1;
                        }
                        if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) {
                            ev.setTargetAccessibilityFocus(false);
                            continue;
                        }
                        newTouchTarget = getTouchTarget(child);
                        if (newTouchTarget != null) {
                            // Child is already receiving touch within its bounds.
                            // Give it the new pointer in addition to the ones it is handling.
                            newTouchTarget.pointerIdBits |= idBitsToAssign;
                            break;
                        }
                        resetCancelNextUpFlag(child);
                        if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
                            // Child wants to receive touch within its bounds.
                            mLastTouchDownTime = ev.getDownTime();
                            if (preorderedList != null) {
                                // childIndex points into presorted list, find original index
                                for (int j = 0; j < childrenCount; j++) {
                                    if (children[childIndex] == mChildren[j]) {
                                        mLastTouchDownIndex = j;
                                        break;
                                    }
                                }
                            } else {
                                mLastTouchDownIndex = childIndex;
                            }
                            mLastTouchDownX = ev.getX();
                            mLastTouchDownY = ev.getY();
                            newTouchTarget = addTouchTarget(child, idBitsToAssign);
                            alreadyDispatchedToNewTouchTarget = true;
                            break;
                        }
                        // The accessibility focus didn't handle the event, so clear
                        // the flag and do a normal dispatch to all children.
                        ev.setTargetAccessibilityFocus(false);
                    }
                    if (preorderedList != null)
                        preorderedList.clear();
                }
                if (newTouchTarget == null && mFirstTouchTarget != null) {
                    // Did not find a child to receive the event.
                    // Assign the pointer to the least recently added target.
                    newTouchTarget = mFirstTouchTarget;
                    while (newTouchTarget.next != null) {
                        newTouchTarget = newTouchTarget.next;
                    }
                    newTouchTarget.pointerIdBits |= idBitsToAssign;
                }
            }
        }
        // Dispatch to touch targets.
        if (mFirstTouchTarget == null) {
            // No touch targets so treat this as an ordinary view.
            handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS);
        } else {
            // Dispatch to touch targets, excluding the new touch target if we already
            // dispatched to it.  Cancel touch targets if necessary.
            TouchTarget predecessor = null;
            TouchTarget target = mFirstTouchTarget;
            while (target != null) {
                final TouchTarget next = target.next;
                if (alreadyDispatchedToNewTouchTarget && target == newTouchTarget) {
                    handled = true;
                } else {
                    final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted;
                    if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) {
                        handled = true;
                    }
                    if (cancelChild) {
                        if (predecessor == null) {
                            mFirstTouchTarget = next;
                        } else {
                            predecessor.next = next;
                        }
                        target.recycle();
                        target = next;
                        continue;
                    }
                }
                predecessor = target;
                target = next;
            }
        }
        // Update list of touch targets for pointer up or cancel, if needed.
        if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
            resetTouchState();
        } else if (split && actionMasked == MotionEvent.ACTION_POINTER_UP) {
            final int actionIndex = ev.getActionIndex();
            final int idBitsToRemove = 1 << ev.getPointerId(actionIndex);
            removePointersFromTouchTargets(idBitsToRemove);
        }
    }
    if (!handled && mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);
    }
    return handled;
}
------------------------
Find a silently evolved API code:android.media.AudioManager.requestAudioFocusForCall:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 * Used internally by telephony package to request audio focus. Will cause the focus request
 * to be associated with the "voice communication" identifier only used in AudioService
 * to identify this use case.
 * @param streamType use STREAM_RING for focus requests when ringing, VOICE_CALL for
 * the establishment of the call
 * @param durationHint the type of focus request. AUDIOFOCUS_GAIN_TRANSIENT is recommended so
 * media applications resume after a call
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        service.requestAudioFocus(streamType, durationHint, mICallBack, null, MediaFocusControl.IN_VOICE_COMM_FOCUS_ID, mContext.getOpPackageName());
    } catch (RemoteException e) {
        Log.e(TAG, "Can't call requestAudioFocusForCall() on AudioService due to " + e);
    }
}
Body of Second Method:
{
    IAudioService service = getService();
    try {
        service.requestAudioFocus(new AudioAttributes.Builder().setInternalLegacyStreamType(streamType).build(), durationHint, mICallBack, null, MediaFocusControl.IN_VOICE_COMM_FOCUS_ID, mContext.getOpPackageName(), AUDIOFOCUS_FLAG_LOCK, null);
    } catch (RemoteException e) {
        Log.e(TAG, "Can't call requestAudioFocusForCall() on AudioService:", e);
    }
}
------------------------
Find a silently evolved API code:android.content.pm.RegisteredServicesCache.getAllServices:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @return a collection of {@link RegisteredServicesCache.ServiceInfo} objects for all
 * registered authenticators.
 */

Body of Frist Method:
{
    synchronized (mServicesLock) {
        // Find user and lazily populate cache
        final UserServices<V> user = findOrCreateUserLocked(userId);
        if (user.services == null) {
            generateServicesMap(userId);
        }
        return Collections.unmodifiableCollection(new ArrayList<ServiceInfo<V>>(user.services.values()));
    }
}
Body of Second Method:
{
    synchronized (mServicesLock) {
        // Find user and lazily populate cache
        final UserServices<V> user = findOrCreateUserLocked(userId);
        if (user.services == null) {
            generateServicesMap(null, userId);
        }
        return Collections.unmodifiableCollection(new ArrayList<ServiceInfo<V>>(user.services.values()));
    }
}
------------------------
Find a silently evolved API code:android.net.NetworkTemplate.matches:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Test if given {@link NetworkIdentity} matches this template.
 */

Body of Frist Method:
{
    switch(mMatchRule) {
        case MATCH_MOBILE_ALL:
            return matchesMobile(ident);
        case MATCH_MOBILE_3G_LOWER:
            return matchesMobile3gLower(ident);
        case MATCH_MOBILE_4G:
            return matchesMobile4g(ident);
        case MATCH_WIFI:
            return matchesWifi(ident);
        case MATCH_ETHERNET:
            return matchesEthernet(ident);
        case MATCH_MOBILE_WILDCARD:
            return matchesMobileWildcard(ident);
        case MATCH_WIFI_WILDCARD:
            return matchesWifiWildcard(ident);
        default:
            throw new IllegalArgumentException("unknown network template");
    }
}
Body of Second Method:
{
    switch(mMatchRule) {
        case MATCH_MOBILE_ALL:
            return matchesMobile(ident);
        case MATCH_MOBILE_3G_LOWER:
            return matchesMobile3gLower(ident);
        case MATCH_MOBILE_4G:
            return matchesMobile4g(ident);
        case MATCH_WIFI:
            return matchesWifi(ident);
        case MATCH_ETHERNET:
            return matchesEthernet(ident);
        case MATCH_MOBILE_WILDCARD:
            return matchesMobileWildcard(ident);
        case MATCH_WIFI_WILDCARD:
            return matchesWifiWildcard(ident);
        case MATCH_BLUETOOTH:
            return matchesBluetooth(ident);
        default:
            throw new IllegalArgumentException("unknown network template");
    }
}
------------------------
Find a silently evolved API code:android.media.AudioService.isStreamMute:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * get stream mute state.
 */

Body of Frist Method:
{
    return mStreamStates[streamType].isMuted();
}
Body of Second Method:
{
    if (streamType == AudioManager.USE_DEFAULT_STREAM_TYPE) {
        streamType = getActiveStreamType(streamType);
    }
    synchronized (VolumeStreamState.class) {
        return mStreamStates[streamType].isMuted_syncVSS();
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiConfiguration.writeToParcel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Implement the Parcelable interface {@hide}
 */

Body of Frist Method:
{
    dest.writeInt(networkId);
    dest.writeInt(status);
    dest.writeInt(disableReason);
    dest.writeString(SSID);
    dest.writeString(BSSID);
    dest.writeString(autoJoinBSSID);
    dest.writeString(FQDN);
    dest.writeString(naiRealm);
    dest.writeString(preSharedKey);
    for (String wepKey : wepKeys) {
        dest.writeString(wepKey);
    }
    dest.writeInt(wepTxKeyIndex);
    dest.writeInt(priority);
    dest.writeInt(hiddenSSID ? 1 : 0);
    dest.writeInt(requirePMF ? 1 : 0);
    dest.writeString(updateIdentifier);
    writeBitSet(dest, allowedKeyManagement);
    writeBitSet(dest, allowedProtocols);
    writeBitSet(dest, allowedAuthAlgorithms);
    writeBitSet(dest, allowedPairwiseCiphers);
    writeBitSet(dest, allowedGroupCiphers);
    dest.writeParcelable(enterpriseConfig, flags);
    dest.writeParcelable(mIpConfiguration, flags);
    dest.writeString(dhcpServer);
    dest.writeString(defaultGwMacAddress);
    dest.writeInt(autoJoinStatus);
    dest.writeInt(selfAdded ? 1 : 0);
    dest.writeInt(didSelfAdd ? 1 : 0);
    dest.writeInt(noInternetAccess ? 1 : 0);
    dest.writeInt(creatorUid);
    dest.writeInt(lastConnectUid);
    dest.writeInt(lastUpdateUid);
    dest.writeLong(blackListTimestamp);
    dest.writeLong(lastConnectionFailure);
    dest.writeInt(numConnectionFailures);
    dest.writeInt(numIpConfigFailures);
    dest.writeInt(numAuthFailures);
    dest.writeInt(numScorerOverride);
    dest.writeInt(numScorerOverrideAndSwitchedNetwork);
    dest.writeInt(numAssociation);
    dest.writeInt(numUserTriggeredWifiDisableLowRSSI);
    dest.writeInt(numUserTriggeredWifiDisableBadRSSI);
    dest.writeInt(numUserTriggeredWifiDisableNotHighRSSI);
    dest.writeInt(numTicksAtLowRSSI);
    dest.writeInt(numTicksAtBadRSSI);
    dest.writeInt(numTicksAtNotHighRSSI);
    dest.writeInt(numUserTriggeredJoinAttempts);
    dest.writeInt(autoJoinUseAggressiveJoinAttemptThreshold);
    dest.writeInt(autoJoinBailedDueToLowRssi ? 1 : 0);
}
Body of Second Method:
{
    dest.writeInt(networkId);
    dest.writeInt(status);
    dest.writeInt(disableReason);
    dest.writeString(SSID);
    dest.writeString(BSSID);
    dest.writeString(autoJoinBSSID);
    dest.writeString(FQDN);
    dest.writeString(naiRealm);
    dest.writeString(preSharedKey);
    for (String wepKey : wepKeys) {
        dest.writeString(wepKey);
    }
    dest.writeInt(wepTxKeyIndex);
    dest.writeInt(priority);
    dest.writeInt(hiddenSSID ? 1 : 0);
    dest.writeInt(requirePMF ? 1 : 0);
    dest.writeString(updateIdentifier);
    writeBitSet(dest, allowedKeyManagement);
    writeBitSet(dest, allowedProtocols);
    writeBitSet(dest, allowedAuthAlgorithms);
    writeBitSet(dest, allowedPairwiseCiphers);
    writeBitSet(dest, allowedGroupCiphers);
    dest.writeParcelable(enterpriseConfig, flags);
    dest.writeParcelable(mIpConfiguration, flags);
    dest.writeString(dhcpServer);
    dest.writeString(defaultGwMacAddress);
    dest.writeInt(autoJoinStatus);
    dest.writeInt(selfAdded ? 1 : 0);
    dest.writeInt(didSelfAdd ? 1 : 0);
    dest.writeInt(validatedInternetAccess ? 1 : 0);
    dest.writeInt(ephemeral ? 1 : 0);
    dest.writeInt(creatorUid);
    dest.writeInt(lastConnectUid);
    dest.writeInt(lastUpdateUid);
    dest.writeLong(blackListTimestamp);
    dest.writeLong(lastConnectionFailure);
    dest.writeLong(lastRoamingFailure);
    dest.writeInt(lastRoamingFailureReason);
    dest.writeLong(roamingFailureBlackListTimeMilli);
    dest.writeInt(numConnectionFailures);
    dest.writeInt(numIpConfigFailures);
    dest.writeInt(numAuthFailures);
    dest.writeInt(numScorerOverride);
    dest.writeInt(numScorerOverrideAndSwitchedNetwork);
    dest.writeInt(numAssociation);
    dest.writeInt(numUserTriggeredWifiDisableLowRSSI);
    dest.writeInt(numUserTriggeredWifiDisableBadRSSI);
    dest.writeInt(numUserTriggeredWifiDisableNotHighRSSI);
    dest.writeInt(numTicksAtLowRSSI);
    dest.writeInt(numTicksAtBadRSSI);
    dest.writeInt(numTicksAtNotHighRSSI);
    dest.writeInt(numUserTriggeredJoinAttempts);
    dest.writeInt(autoJoinUseAggressiveJoinAttemptThreshold);
    dest.writeInt(autoJoinBailedDueToLowRssi ? 1 : 0);
    dest.writeInt(numNoInternetAccessReports);
}
------------------------
Find a silently evolved API code:android.view.accessibility.AccessibilityNodeInfo.getLabelFor:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the node info for which the view represented by this info serves as
 * a label for accessibility purposes.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 *
 * @return The labeled info.
 */

Body of Frist Method:
{
    enforceSealed();
    if (!canPerformRequestOverConnection(mLabelForId)) {
        return null;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mWindowId, mLabelForId, false, FLAG_PREFETCH_PREDECESSORS | FLAG_PREFETCH_DESCENDANTS | FLAG_PREFETCH_SIBLINGS);
}
Body of Second Method:
{
    enforceSealed();
    return getNodeForAccessibilityId(mLabelForId);
}
------------------------
Find a silently evolved API code:android.webkit.CookieManager.removeSessionCookie:COMMENT
<android.webkit.CookieManager: void removeSessionCookie()>
public      deprecated  ->public      abstract    deprecated  
Method Modifier: public      abstract    deprecated  
Method Modifier: Yes         No          Yes         
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * Removes all session cookies, which are cookies without an expiration
 * date.
 * @deprecated use {@link #removeSessionCookies(ValueCallback)} instead.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.webkit.WebSettings.setPluginsEnabled:COMMENT
<android.webkit.WebSettings: void setPluginsEnabled(boolean)>
public      hidden      deprecated  ->public      abstract    hidden      deprecated  
Method Modifier: public      abstract    hidden      deprecated  
Method Modifier: Yes         No          Yes         Yes         
Method Updated:  Yes         Yes         Yes         Yes         
Comment:/**
 * Sets whether the WebView should enable plugins. The default is false.
 *
 * @param flag true if plugins should be enabled
 * @deprecated This method has been deprecated in favor of
 * {@link #setPluginState}
 * @hide Since API level {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.webkit.WebSettings.getPluginsEnabled:COMMENT
<android.webkit.WebSettings: boolean getPluginsEnabled()>
public      hidden      deprecated  ->public      abstract    hidden      deprecated  
Method Modifier: public      abstract    hidden      deprecated  
Method Modifier: Yes         No          Yes         Yes         
Method Updated:  Yes         Yes         Yes         Yes         
Comment:/**
 * Gets whether plugins are enabled.
 *
 * @return true if plugins are enabled
 * @see #setPluginsEnabled
 * @deprecated This method has been replaced by {@link #getPluginState}
 * @hide Since API level {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.webkit.WebSettings.setAcceptThirdPartyCookies:COMMENT
<android.webkit.WebSettings: void setAcceptThirdPartyCookies(boolean)>
public      hidden      ->public      abstract    hidden      
Method Modifier: public      abstract    hidden      
Method Modifier: Yes         No          Yes         
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * Sets policy for third party cookies.
 * Developers should access this via {@link CookieManager#setShouldAcceptThirdPartyCookies}.
 * @hide Internal API.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.webkit.WebView.onResume:COMMENT
Method Modifier: public      
Comment:/**
 * Resumes a WebView after a previous call to onPause().
 */

Body of Frist Method:
{
    checkThread();
    if (DebugFlags.TRACE_API)
        Log.d(LOGTAG, "onResume");
    mProvider.onResume();
}
Body of Second Method:
{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, "onResume");
    mProvider.onResume();
}
------------------------
Find a silently evolved API code:android.webkit.WebSettings.getCursiveFontFamily:COMMENT
<android.webkit.WebSettings: String getCursiveFontFamily()>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Gets the cursive font family name.
 *
 * @return the cursive font family name as a string
 * @see #setCursiveFontFamily
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.telephony.ServiceState.getRoaming:COMMENT
Method Modifier: public      
Comment:/**
 * Get current roaming indicator of phone
 * (note: not just decoding from TS 27.007 7.2)
 *
 * @return true if TS 27.007 7.2 roaming is true
 * and ONS is different from SPN
 */

Body of Frist Method:
{
    return mRoaming;
}
Body of Second Method:
{
    return getVoiceRoaming() || getDataRoaming();
}
------------------------
Find a silently evolved API code:android.animation.PropertyValuesHolder.setupSetterOrGetter:COMMENT
Method Modifier: private     
Comment:/**
 * Returns the setter or getter requested. This utility function checks whether the
 * requested method exists in the propertyMapMap cache. If not, it calls another
 * utility function to request the Method from the targetClass directly.
 * @param targetClass The Class on which the requested method should exist.
 * @param propertyMapMap The cache of setters/getters derived so far.
 * @param prefix "set" or "get", for the setter or getter.
 * @param valueType The type of parameter passed into the method (null for getter).
 * @return Method the method associated with mPropertyName.
 */

Body of Frist Method:
{
    Method setterOrGetter = null;
    try {
        // Have to lock property map prior to reading it, to guard against
        // another thread putting something in there after we've checked it
        // but before we've added an entry to it
        mPropertyMapLock.writeLock().lock();
        HashMap<String, Method> propertyMap = propertyMapMap.get(targetClass);
        if (propertyMap != null) {
            setterOrGetter = propertyMap.get(mPropertyName);
        }
        if (setterOrGetter == null) {
            setterOrGetter = getPropertyFunction(targetClass, prefix, valueType);
            if (propertyMap == null) {
                propertyMap = new HashMap<String, Method>();
                propertyMapMap.put(targetClass, propertyMap);
            }
            propertyMap.put(mPropertyName, setterOrGetter);
        }
    } finally {
        mPropertyMapLock.writeLock().unlock();
    }
    return setterOrGetter;
}
Body of Second Method:
{
    Method setterOrGetter = null;
    synchronized (propertyMapMap) {
        // Have to lock property map prior to reading it, to guard against
        // another thread putting something in there after we've checked it
        // but before we've added an entry to it
        HashMap<String, Method> propertyMap = propertyMapMap.get(targetClass);
        boolean wasInMap = false;
        if (propertyMap != null) {
            wasInMap = propertyMap.containsKey(mPropertyName);
            if (wasInMap) {
                setterOrGetter = propertyMap.get(mPropertyName);
            }
        }
        if (!wasInMap) {
            setterOrGetter = getPropertyFunction(targetClass, prefix, valueType);
            if (propertyMap == null) {
                propertyMap = new HashMap<String, Method>();
                propertyMapMap.put(targetClass, propertyMap);
            }
            propertyMap.put(mPropertyName, setterOrGetter);
        }
    }
    return setterOrGetter;
}
------------------------
Find a silently evolved API code:android.app.BackStackRecord.configureTransitions:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Configures custom transitions for a specific fragment container.
 *
 * @param containerId The container ID of the fragments to configure the transition for.
 * @param state The Transition State keeping track of the executing transitions.
 * @param firstOutFragments The list of first fragments to be removed, keyed on the
 * container ID.
 * @param lastInFragments The list of last fragments to be added, keyed on the
 * container ID.
 * @param isBack true if this is popping the back stack or false if this is a
 * forward operation.
 */

Body of Frist Method:
{
    ViewGroup sceneRoot = (ViewGroup) mManager.mContainer.findViewById(containerId);
    if (sceneRoot != null) {
        Fragment inFragment = lastInFragments.get(containerId);
        Fragment outFragment = firstOutFragments.get(containerId);
        Transition enterTransition = getEnterTransition(inFragment, isBack);
        Transition sharedElementTransition = getSharedElementTransition(inFragment, outFragment, isBack);
        Transition exitTransition = getExitTransition(outFragment, isBack);
        if (enterTransition == null && sharedElementTransition == null && exitTransition == null) {
            // no transitions!
            return;
        }
        if (enterTransition != null) {
            enterTransition.addTarget(state.nonExistentView);
        }
        ArrayMap<String, View> namedViews = null;
        ArrayList<View> sharedElementTargets = new ArrayList<View>();
        if (sharedElementTransition != null) {
            namedViews = remapSharedElements(state, outFragment, isBack);
            if (namedViews.isEmpty()) {
                sharedElementTargets.add(state.nonExistentView);
            } else {
                sharedElementTargets.addAll(namedViews.values());
            }
            addTargets(sharedElementTransition, sharedElementTargets);
            // Notify the start of the transition.
            SharedElementCallback callback = isBack ? outFragment.mEnterTransitionCallback : inFragment.mEnterTransitionCallback;
            ArrayList<String> names = new ArrayList<String>(namedViews.keySet());
            ArrayList<View> views = new ArrayList<View>(namedViews.values());
            callback.onSharedElementStart(names, views, null);
        }
        ArrayList<View> exitingViews = captureExitingViews(exitTransition, outFragment, namedViews);
        if (exitingViews == null || exitingViews.isEmpty()) {
            exitTransition = null;
        }
        // Set the epicenter of the exit transition
        if (mSharedElementTargetNames != null && namedViews != null) {
            View epicenterView = namedViews.get(mSharedElementTargetNames.get(0));
            if (epicenterView != null) {
                if (exitTransition != null) {
                    setEpicenter(exitTransition, epicenterView);
                }
                if (sharedElementTransition != null) {
                    setEpicenter(sharedElementTransition, epicenterView);
                }
            }
        }
        Transition transition = mergeTransitions(enterTransition, exitTransition, sharedElementTransition, inFragment, isBack);
        if (transition != null) {
            ArrayList<View> hiddenFragments = new ArrayList<View>();
            ArrayList<View> enteringViews = addTransitionTargets(state, enterTransition, sharedElementTransition, transition, sceneRoot, inFragment, outFragment, hiddenFragments, isBack, sharedElementTargets);
            transition.setNameOverrides(state.nameOverrides);
            // We want to exclude hidden views later, so we need a non-null list in the
            // transition now.
            transition.excludeTarget(state.nonExistentView, true);
            // Now exclude all currently hidden fragments.
            excludeHiddenFragments(hiddenFragments, containerId, transition);
            TransitionManager.beginDelayedTransition(sceneRoot, transition);
            // Remove the view targeting after the transition starts
            removeTargetedViewsFromTransitions(sceneRoot, state.nonExistentView, enterTransition, enteringViews, exitTransition, exitingViews, sharedElementTransition, sharedElementTargets, transition, hiddenFragments);
        }
    }
}
Body of Second Method:
{
    ViewGroup sceneRoot = (ViewGroup) mManager.mContainer.findViewById(containerId);
    if (sceneRoot != null) {
        Fragment inFragment = lastInFragments.get(containerId);
        Fragment outFragment = firstOutFragments.get(containerId);
        Transition enterTransition = getEnterTransition(inFragment, isBack);
        Transition sharedElementTransition = getSharedElementTransition(inFragment, outFragment, isBack);
        Transition exitTransition = getExitTransition(outFragment, isBack);
        if (enterTransition == null && sharedElementTransition == null && exitTransition == null) {
            // no transitions!
            return;
        }
        if (enterTransition != null) {
            enterTransition.addTarget(state.nonExistentView);
        }
        ArrayMap<String, View> namedViews = null;
        ArrayList<View> sharedElementTargets = new ArrayList<View>();
        if (sharedElementTransition != null) {
            namedViews = remapSharedElements(state, outFragment, isBack);
            sharedElementTargets.add(state.nonExistentView);
            sharedElementTargets.addAll(namedViews.values());
            addTargets(sharedElementTransition, sharedElementTargets);
            // Notify the start of the transition.
            SharedElementCallback callback = isBack ? outFragment.mEnterTransitionCallback : inFragment.mEnterTransitionCallback;
            ArrayList<String> names = new ArrayList<String>(namedViews.keySet());
            ArrayList<View> views = new ArrayList<View>(namedViews.values());
            callback.onSharedElementStart(names, views, null);
        }
        ArrayList<View> exitingViews = captureExitingViews(exitTransition, outFragment, namedViews, state.nonExistentView);
        if (exitingViews == null || exitingViews.isEmpty()) {
            exitTransition = null;
        }
        // Set the epicenter of the exit transition
        if (mSharedElementTargetNames != null && namedViews != null) {
            View epicenterView = namedViews.get(mSharedElementTargetNames.get(0));
            if (epicenterView != null) {
                if (exitTransition != null) {
                    setEpicenter(exitTransition, epicenterView);
                }
                if (sharedElementTransition != null) {
                    setEpicenter(sharedElementTransition, epicenterView);
                }
            }
        }
        Transition transition = mergeTransitions(enterTransition, exitTransition, sharedElementTransition, inFragment, isBack);
        if (transition != null) {
            ArrayList<View> hiddenFragments = new ArrayList<View>();
            ArrayList<View> enteringViews = addTransitionTargets(state, enterTransition, sharedElementTransition, transition, sceneRoot, inFragment, outFragment, hiddenFragments, isBack, sharedElementTargets);
            transition.setNameOverrides(state.nameOverrides);
            // We want to exclude hidden views later, so we need a non-null list in the
            // transition now.
            transition.excludeTarget(state.nonExistentView, true);
            // Now exclude all currently hidden fragments.
            excludeHiddenFragments(hiddenFragments, containerId, transition);
            TransitionManager.beginDelayedTransition(sceneRoot, transition);
            // Remove the view targeting after the transition starts
            removeTargetedViewsFromTransitions(sceneRoot, state.nonExistentView, enterTransition, enteringViews, exitTransition, exitingViews, sharedElementTransition, sharedElementTargets, transition, hiddenFragments);
        }
    }
}
------------------------
Find a silently evolved API code:android.webkit.WebViewDatabase.clearFormData:COMMENT
<android.webkit.WebViewDatabase: void clearFormData()>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Clears any saved data for web forms.
 *
 * @see #hasFormData
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.webkit.WebSettings.setCursiveFontFamily:COMMENT
<android.webkit.WebSettings: void setCursiveFontFamily(String)>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Sets the cursive font family name. The default is "cursive".
 *
 * @param font a font family name
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.content.pm.RegisteredServicesCache.getServiceInfo:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Accessor for the registered authenticators.
 * @param type the account type of the authenticator
 * @return the AuthenticatorInfo that matches the account type or null if none is present
 */

Body of Frist Method:
{
    synchronized (mServicesLock) {
        // Find user and lazily populate cache
        final UserServices<V> user = findOrCreateUserLocked(userId);
        if (user.services == null) {
            generateServicesMap(userId);
        }
        return user.services.get(type);
    }
}
Body of Second Method:
{
    synchronized (mServicesLock) {
        // Find user and lazily populate cache
        final UserServices<V> user = findOrCreateUserLocked(userId);
        if (user.services == null) {
            generateServicesMap(null, userId);
        }
        return user.services.get(type);
    }
}
------------------------
Find a silently evolved API code:android.media.AudioManager.abandonAudioFocusForCall:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 * Used internally by telephony package to abandon audio focus, typically after a call or
 * when ringing ends and the call is rejected or not answered.
 * Should match one or more calls to {@link #requestAudioFocusForCall(int, int)}.
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        service.abandonAudioFocus(null, MediaFocusControl.IN_VOICE_COMM_FOCUS_ID);
    } catch (RemoteException e) {
        Log.e(TAG, "Can't call abandonAudioFocusForCall() on AudioService due to " + e);
    }
}
Body of Second Method:
{
    IAudioService service = getService();
    try {
        service.abandonAudioFocus(null, MediaFocusControl.IN_VOICE_COMM_FOCUS_ID, null);
    } catch (RemoteException e) {
        Log.e(TAG, "Can't call abandonAudioFocusForCall() on AudioService:", e);
    }
}
------------------------
Find a silently evolved API code:android.widget.DayPickerView.setUpListView:COMMENT
<android.widget.DayPickerView: void setUpListView()>
protected   ->private     
Method Modifier: protected   private     
Method Modifier: Yes         No          
Method Updated:  No          Yes         
Comment:/*
     * Sets all the required fields for the list view. Override this method to
     * set a different list view behavior.
     */

Body of Frist Method:
{
    // Transparent background on scroll
    setCacheColorHint(0);
    // No dividers
    setDivider(null);
    // Items are clickable
    setItemsCanFocus(true);
    // The thumb gets in the way, so disable it
    setFastScrollEnabled(false);
    setVerticalScrollBarEnabled(false);
    setOnScrollListener(this);
    setFadingEdgeLength(0);
    // Make the scrolling behavior nicer
    setFriction(ViewConfiguration.getScrollFriction() * mFriction);
}
Body of Second Method:
{
    // Transparent background on scroll
    setCacheColorHint(0);
    // No dividers
    setDivider(null);
    // Items are clickable
    setItemsCanFocus(true);
    // The thumb gets in the way, so disable it
    setFastScrollEnabled(false);
    setVerticalScrollBarEnabled(false);
    setOnScrollListener(this);
    setFadingEdgeLength(0);
    // Make the scrolling behavior nicer
    setFriction(ViewConfiguration.getScrollFriction());
}
------------------------
Find a silently evolved API code:android.webkit.WebSettings.setAppCacheMaxSize:COMMENT
<android.webkit.WebSettings: void setAppCacheMaxSize(long)>
public      deprecated  ->public      abstract    deprecated  
Method Modifier: public      abstract    deprecated  
Method Modifier: Yes         No          Yes         
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * Sets the maximum size for the Application Cache content. The passed size
 * will be rounded to the nearest value that the database can support, so
 * this should be viewed as a guide, not a hard limit. Setting the
 * size to a value less than current database size does not cause the
 * database to be trimmed. The default size is {@link Long#MAX_VALUE}.
 * It is recommended to leave the maximum size set to the default value.
 *
 * @param appCacheMaxSize the maximum size in bytes
 * @deprecated In future quota will be managed automatically.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.graphics.drawable.DrawableContainer.DrawableContainerState.ConstantStateFuture.get:COMMENT
Method Modifier: public      
Comment:/**
 * Obtains and prepares the Drawable represented by this future.
 *
 * @param state the container into which this future will be placed
 * @return a prepared Drawable
 */

Body of Frist Method:
{
    final Drawable result;
    if (state.mRes == null) {
        result = mConstantState.newDrawable();
    } else if (state.mTheme == null) {
        result = mConstantState.newDrawable(state.mRes);
    } else {
        result = mConstantState.newDrawable(state.mRes, state.mTheme);
    }
    result.setLayoutDirection(state.mLayoutDirection);
    result.setCallback(state.mOwner);
    if (state.mMutated) {
        result.mutate();
    }
    return result;
}
Body of Second Method:
{
    final Drawable result;
    if (state.mRes == null) {
        result = mConstantState.newDrawable();
    } else {
        result = mConstantState.newDrawable(state.mRes);
    }
    result.setLayoutDirection(state.mLayoutDirection);
    result.setCallback(state.mOwner);
    if (state.mMutated) {
        result.mutate();
    }
    return result;
}
------------------------
Find a silently evolved API code:android.webkit.WebSettings.setAllowContentAccess:COMMENT
<android.webkit.WebSettings: void setAllowContentAccess(boolean)>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Enables or disables content URL access within WebView.  Content URL
 * access allows WebView to load content from a content provider installed
 * in the system. The default is enabled.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.appwidget.AppWidgetHost.startListening:COMMENT
Method Modifier: public      
Comment:/**
 * Start receiving onAppWidgetChanged calls for your AppWidgets.  Call this when your activity
 * becomes visible, i.e. from onStart() in your Activity.
 */

Body of Frist Method:
{
    int[] updatedIds;
    ArrayList<RemoteViews> updatedViews = new ArrayList<RemoteViews>();
    try {
        updatedIds = sService.startListening(mCallbacks, mContext.getOpPackageName(), mHostId, updatedViews);
    } catch (RemoteException e) {
        throw new RuntimeException("system server dead?", e);
    }
    final int N = updatedIds.length;
    for (int i = 0; i < N; i++) {
        updateAppWidgetView(updatedIds[i], updatedViews.get(i));
    }
}
Body of Second Method:
{
    int[] updatedIds;
    ArrayList<RemoteViews> updatedViews = new ArrayList<RemoteViews>();
    try {
        updatedIds = sService.startListening(mCallbacks, mContextOpPackageName, mHostId, updatedViews);
    } catch (RemoteException e) {
        throw new RuntimeException("system server dead?", e);
    }
    final int N = updatedIds.length;
    for (int i = 0; i < N; i++) {
        updateAppWidgetView(updatedIds[i], updatedViews.get(i));
    }
}
------------------------
Find a silently evolved API code:android.app.Activity.invalidateOptionsMenu:COMMENT
Method Modifier: public      
Comment:/**
 * Declare that the options menu has changed, so should be recreated.
 * The {@link #onCreateOptionsMenu(Menu)} method will be called the next
 * time it needs to be displayed.
 */

Body of Frist Method:
{
    if (mActionBar == null || !mActionBar.invalidateOptionsMenu()) {
        mWindow.invalidatePanelMenu(Window.FEATURE_OPTIONS_PANEL);
    }
}
Body of Second Method:
{
    if (mWindow.hasFeature(Window.FEATURE_OPTIONS_PANEL) && (mActionBar == null || !mActionBar.invalidateOptionsMenu())) {
        mWindow.invalidatePanelMenu(Window.FEATURE_OPTIONS_PANEL);
    }
}
------------------------
Find a silently evolved API code:android.content.ContentProviderClient.openFile:COMMENT
Method Modifier: public      
Comment:/**
 * See {@link ContentProvider#openFile ContentProvider.openFile}.  Note that
 * this <em>does not</em>
 * take care of non-content: URIs such as file:.  It is strongly recommended
 * you use the {@link ContentResolver#openFileDescriptor
 * ContentResolver.openFileDescriptor} API instead.
 */

Body of Frist Method:
{
    beforeRemote();
    try {
        ICancellationSignal remoteSignal = null;
        if (signal != null) {
            signal.throwIfCanceled();
            remoteSignal = mContentProvider.createCancellationSignal();
            signal.setRemote(remoteSignal);
        }
        return mContentProvider.openFile(mPackageName, url, mode, remoteSignal);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}
Body of Second Method:
{
    return openFile(url, mode, null);
}
------------------------
Find a silently evolved API code:android.net.ConnectivityManager.getMobileDataEnabled:COMMENT
Method Modifier: public      hidden      deprecated  
Comment:/**
 * @hide
 * @deprecated Talk to TelephonyManager directly
 */

Body of Frist Method:
{
    IBinder b = ServiceManager.getService(Context.TELEPHONY_SERVICE);
    if (b != null) {
        try {
            ITelephony it = ITelephony.Stub.asInterface(b);
            return it.getDataEnabled();
        } catch (RemoteException e) {
        }
    }
    return false;
}
Body of Second Method:
{
    IBinder b = ServiceManager.getService(Context.TELEPHONY_SERVICE);
    if (b != null) {
        try {
            ITelephony it = ITelephony.Stub.asInterface(b);
            int subId = SubscriptionManager.getDefaultDataSubId();
            Log.d("ConnectivityManager", "getMobileDataEnabled()+ subId=" + subId);
            boolean retVal = it.getDataEnabled(subId);
            Log.d("ConnectivityManager", "getMobileDataEnabled()- subId=" + subId + " retVal=" + retVal);
            return retVal;
        } catch (RemoteException e) {
        }
    }
    Log.d("ConnectivityManager", "getMobileDataEnabled()- remote exception retVal=false");
    return false;
}
------------------------
Find a silently evolved API code:android.webkit.WebSettings.setSupportMultipleWindows:COMMENT
<android.webkit.WebSettings: void setSupportMultipleWindows(boolean)>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Sets whether the WebView whether supports multiple windows. If set to
 * true, {@link WebChromeClient#onCreateWindow} must be implemented by the
 * host application. The default is false.
 *
 * @param support whether to suport multiple windows
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.widget.SearchView.rewriteQueryFromSuggestion:COMMENT
Method Modifier: private     
Comment:/**
 * Query rewriting.
 */

Body of Frist Method:
{
    CharSequence oldQuery = mQueryTextView.getText();
    Cursor c = mSuggestionsAdapter.getCursor();
    if (c == null) {
        return;
    }
    if (c.moveToPosition(position)) {
        // Get the new query from the suggestion.
        CharSequence newQuery = mSuggestionsAdapter.convertToString(c);
        if (newQuery != null) {
            // The suggestion rewrites the query.
            // Update the text field, without getting new suggestions.
            setQuery(newQuery);
        } else {
            // The suggestion does not rewrite the query, restore the user's query.
            setQuery(oldQuery);
        }
    } else {
        // We got a bad position, restore the user's query.
        setQuery(oldQuery);
    }
}
Body of Second Method:
{
    CharSequence oldQuery = mSearchSrcTextView.getText();
    Cursor c = mSuggestionsAdapter.getCursor();
    if (c == null) {
        return;
    }
    if (c.moveToPosition(position)) {
        // Get the new query from the suggestion.
        CharSequence newQuery = mSuggestionsAdapter.convertToString(c);
        if (newQuery != null) {
            // The suggestion rewrites the query.
            // Update the text field, without getting new suggestions.
            setQuery(newQuery);
        } else {
            // The suggestion does not rewrite the query, restore the user's query.
            setQuery(oldQuery);
        }
    } else {
        // We got a bad position, restore the user's query.
        setQuery(oldQuery);
    }
}
------------------------
Find a silently evolved API code:android.content.pm.ParceledListSlice.writeToParcel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Write this to another Parcel. Note that this discards the internal Parcel
 * and should not be used anymore. This is so we can pass this to a Binder
 * where we won't have a chance to call recycle on this.
 */

Body of Frist Method:
{
    final int N = mList.size();
    final int callFlags = flags;
    dest.writeInt(N);
    if (DEBUG)
        Log.d(TAG, "Writing " + N + " items");
    if (N > 0) {
        dest.writeParcelableCreator(mList.get(0));
        int i = 0;
        while (i < N && dest.dataSize() < MAX_FIRST_IPC_SIZE) {
            dest.writeInt(1);
            mList.get(i).writeToParcel(dest, callFlags);
            if (DEBUG)
                Log.d(TAG, "Wrote inline #" + i + ": " + mList.get(i));
            i++;
        }
        if (i < N) {
            dest.writeInt(0);
            Binder retriever = new Binder() {

                @Override
                protected boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException {
                    if (code != FIRST_CALL_TRANSACTION) {
                        return super.onTransact(code, data, reply, flags);
                    }
                    int i = data.readInt();
                    if (DEBUG)
                        Log.d(TAG, "Writing more @" + i + " of " + N);
                    while (i < N && reply.dataSize() < MAX_IPC_SIZE) {
                        reply.writeInt(1);
                        mList.get(i).writeToParcel(reply, callFlags);
                        if (DEBUG)
                            Log.d(TAG, "Wrote extra #" + i + ": " + mList.get(i));
                        i++;
                    }
                    if (i < N) {
                        if (DEBUG)
                            Log.d(TAG, "Breaking @" + i + " of " + N);
                        reply.writeInt(0);
                    }
                    return true;
                }
            };
            if (DEBUG)
                Log.d(TAG, "Breaking @" + i + " of " + N + ": retriever=" + retriever);
            dest.writeStrongBinder(retriever);
        }
    }
}
Body of Second Method:
{
    final int N = mList.size();
    final int callFlags = flags;
    dest.writeInt(N);
    if (DEBUG)
        Log.d(TAG, "Writing " + N + " items");
    if (N > 0) {
        final Class<?> listElementClass = mList.get(0).getClass();
        dest.writeParcelableCreator(mList.get(0));
        int i = 0;
        while (i < N && dest.dataSize() < MAX_FIRST_IPC_SIZE) {
            dest.writeInt(1);
            final T parcelable = mList.get(i);
            verifySameType(listElementClass, parcelable.getClass());
            parcelable.writeToParcel(dest, callFlags);
            if (DEBUG)
                Log.d(TAG, "Wrote inline #" + i + ": " + mList.get(i));
            i++;
        }
        if (i < N) {
            dest.writeInt(0);
            Binder retriever = new Binder() {

                @Override
                protected boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException {
                    if (code != FIRST_CALL_TRANSACTION) {
                        return super.onTransact(code, data, reply, flags);
                    }
                    int i = data.readInt();
                    if (DEBUG)
                        Log.d(TAG, "Writing more @" + i + " of " + N);
                    while (i < N && reply.dataSize() < MAX_IPC_SIZE) {
                        reply.writeInt(1);
                        final T parcelable = mList.get(i);
                        verifySameType(listElementClass, parcelable.getClass());
                        parcelable.writeToParcel(reply, callFlags);
                        if (DEBUG)
                            Log.d(TAG, "Wrote extra #" + i + ": " + mList.get(i));
                        i++;
                    }
                    if (i < N) {
                        if (DEBUG)
                            Log.d(TAG, "Breaking @" + i + " of " + N);
                        reply.writeInt(0);
                    }
                    return true;
                }
            };
            if (DEBUG)
                Log.d(TAG, "Breaking @" + i + " of " + N + ": retriever=" + retriever);
            dest.writeStrongBinder(retriever);
        }
    }
}
------------------------
Find a silently evolved API code:android.webkit.WebIconDatabase.requestIconForPageUrl:COMMENT
<android.webkit.WebIconDatabase: void requestIconForPageUrl(String,IconListener)>
public      deprecated  ->public      abstract    deprecated  
Method Modifier: public      abstract    deprecated  
Method Modifier: Yes         No          Yes         
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * Request the Bitmap representing the icon for the given page
 * url. If the icon exists, the listener will be called with the result.
 * @param url The page's url.
 * @param listener An implementation on IconListener to receive the result.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.webkit.WebView.postUrl:COMMENT
Method Modifier: public      
Comment:/**
 * Loads the URL with postData using "POST" method into this WebView. If url
 * is not a network URL, it will be loaded with {@link #loadUrl(String)}
 * instead, ignoring the postData param.
 *
 * @param url the URL of the resource to load
 * @param postData the data will be passed to "POST" request, which must be
 * be "application/x-www-form-urlencoded" encoded.
 */

Body of Frist Method:
{
    checkThread();
    if (DebugFlags.TRACE_API)
        Log.d(LOGTAG, "postUrl=" + url);
    if (URLUtil.isNetworkUrl(url)) {
        mProvider.postUrl(url, postData);
    } else {
        mProvider.loadUrl(url);
    }
}
Body of Second Method:
{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, "postUrl=" + url);
    if (URLUtil.isNetworkUrl(url)) {
        mProvider.postUrl(url, postData);
    } else {
        mProvider.loadUrl(url);
    }
}
------------------------
Find a silently evolved API code:android.webkit.WebSettings.setSerifFontFamily:COMMENT
<android.webkit.WebSettings: void setSerifFontFamily(String)>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Sets the serif font family name. The default is "sans-serif".
 *
 * @param font a font family name
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.webkit.WebBackForwardList.clone:COMMENT
<android.webkit.WebBackForwardList: WebBackForwardList clone()>
protected   ->protected   abstract    
Method Modifier: protected   abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Clone the entire object to be used in the UI thread by clients of
 * WebView. This creates a copy that should never be modified by any of the
 * webkit package classes.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.graphics.drawable.RippleBackground.draw:COMMENT
Method Modifier: public      
Comment:/**
 * Draws the ripple centered at (0,0) using the specified paint.
 */

Body of Frist Method:
{
    final boolean canUseHardware = c.isHardwareAccelerated();
    if (mCanUseHardware != canUseHardware && mCanUseHardware) {
        // We've switched from hardware to non-hardware mode. Panic.
        cancelHardwareAnimations(true);
    }
    mCanUseHardware = canUseHardware;
    final boolean hasContent;
    if (canUseHardware && mHardwareAnimating) {
        hasContent = drawHardware((HardwareCanvas) c);
    } else {
        hasContent = drawSoftware(c, p);
    }
    return hasContent;
}
Body of Second Method:
{
    mColor = p.getColor();
    final boolean canUseHardware = c.isHardwareAccelerated();
    if (mCanUseHardware != canUseHardware && mCanUseHardware) {
        // We've switched from hardware to non-hardware mode. Panic.
        cancelHardwareAnimations(true);
    }
    mCanUseHardware = canUseHardware;
    final boolean hasContent;
    if (canUseHardware && (mHardwareAnimating || mHasPendingHardwareExit)) {
        hasContent = drawHardware((HardwareCanvas) c, p);
    } else {
        hasContent = drawSoftware(c, p);
    }
    return hasContent;
}
------------------------
Find a silently evolved API code:android.webkit.WebSettings.setJavaScriptCanOpenWindowsAutomatically:COMMENT
<android.webkit.WebSettings: void setJavaScriptCanOpenWindowsAutomatically(boolean)>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Tells JavaScript to open windows automatically. This applies to the
 * JavaScript function window.open(). The default is false.
 *
 * @param flag true if JavaScript can open windows automatically
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.media.AudioManager.registerAudioPortUpdateListener:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Register an audio port list update listener.
 * @hide
 */

Body of Frist Method:
{
    mAudioPortEventHandler.registerListener(l);
}
Body of Second Method:
{
    sAudioPortEventHandler.registerListener(l);
}
------------------------
Find a silently evolved API code:android.graphics.drawable.RippleDrawable.tryRippleEnter:COMMENT
Method Modifier: private     
Comment:/**
 * Attempts to start an enter animation for the active hotspot. Fails if
 * there are too many animating ripples.
 */

Body of Frist Method:
{
    if (mExitingRipplesCount >= MAX_RIPPLES) {
        // or there is a bug that's preventing ripples from being removed.
        return;
    }
    if (mRipple == null) {
        final float x;
        final float y;
        if (mHasPending) {
            mHasPending = false;
            x = mPendingX;
            y = mPendingY;
        } else {
            x = mHotspotBounds.exactCenterX();
            y = mHotspotBounds.exactCenterY();
        }
        mRipple = new Ripple(this, mHotspotBounds, x, y);
    }
    final int color = mState.mColor.getColorForState(getState(), Color.TRANSPARENT);
    mRipple.setup(mState.mMaxRadius, color, mDensity);
    mRipple.enter();
}
Body of Second Method:
{
    if (mExitingRipplesCount >= MAX_RIPPLES) {
        // or there is a bug that's preventing ripples from being removed.
        return;
    }
    if (mRipple == null) {
        final float x;
        final float y;
        if (mHasPending) {
            mHasPending = false;
            x = mPendingX;
            y = mPendingY;
        } else {
            x = mHotspotBounds.exactCenterX();
            y = mHotspotBounds.exactCenterY();
        }
        mRipple = new Ripple(this, mHotspotBounds, x, y);
    }
    mRipple.setup(mState.mMaxRadius, mDensity);
    mRipple.enter();
}
------------------------
Find a silently evolved API code:android.hardware.camera2.legacy.SurfaceTextureRenderer.drawIntoSurfaces:COMMENT
Method Modifier: public      
Comment:/**
 * Draw the current buffer in the {@link SurfaceTexture} returned from
 * {@link #getSurfaceTexture()} into the set of target {@link Surface}s
 * in the next request from the given {@link CaptureCollector}, or drop
 * the frame if none is available.
 *
 * <p>
 * Any {@link Surface}s targeted must be a subset of the {@link Surface}s
 * set in the last {@link #configureSurfaces(java.util.Collection)} call.
 * </p>
 *
 * @param targetCollector the surfaces to draw to.
 */

Body of Frist Method:
{
    if ((mSurfaces == null || mSurfaces.size() == 0) && (mConversionSurfaces == null || mConversionSurfaces.size() == 0)) {
        return;
    }
    boolean doTiming = targetCollector.hasPendingPreviewCaptures();
    checkGlError("before updateTexImage");
    if (doTiming) {
        beginGlTiming();
    }
    mSurfaceTexture.updateTexImage();
    long timestamp = mSurfaceTexture.getTimestamp();
    Pair<RequestHolder, Long> captureHolder = targetCollector.previewCaptured(timestamp);
    // No preview request queued, drop frame.
    if (captureHolder == null) {
        if (DEBUG) {
            Log.d(TAG, "Dropping preview frame.");
        }
        if (doTiming) {
            endGlTiming();
        }
        return;
    }
    RequestHolder request = captureHolder.first;
    Collection<Surface> targetSurfaces = request.getHolderTargets();
    if (doTiming) {
        addGlTimestamp(timestamp);
    }
    List<Long> targetSurfaceIds = LegacyCameraDevice.getSurfaceIds(targetSurfaces);
    for (EGLSurfaceHolder holder : mSurfaces) {
        if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)) {
            makeCurrent(holder.eglSurface);
            try {
                LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height);
                LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second);
                drawFrame(mSurfaceTexture, holder.width, holder.height);
                swapBuffers(holder.eglSurface);
            } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
                Log.w(TAG, "Surface abandoned, dropping frame. ", e);
            }
        }
    }
    for (EGLSurfaceHolder holder : mConversionSurfaces) {
        if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)) {
            makeCurrent(holder.eglSurface);
            drawFrame(mSurfaceTexture, holder.width, holder.height);
            mPBufferPixels.clear();
            GLES20.glReadPixels(/*x*/
            0, /*y*/
            0, holder.width, holder.height, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, mPBufferPixels);
            checkGlError("glReadPixels");
            try {
                int format = LegacyCameraDevice.detectSurfaceType(holder.surface);
                LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second);
                LegacyCameraDevice.produceFrame(holder.surface, mPBufferPixels.array(), holder.width, holder.height, format);
                swapBuffers(holder.eglSurface);
            } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
                Log.w(TAG, "Surface abandoned, dropping frame. ", e);
            }
        }
    }
    targetCollector.previewProduced();
    if (doTiming) {
        endGlTiming();
    }
}
Body of Second Method:
{
    if ((mSurfaces == null || mSurfaces.size() == 0) && (mConversionSurfaces == null || mConversionSurfaces.size() == 0)) {
        return;
    }
    boolean doTiming = targetCollector.hasPendingPreviewCaptures();
    checkGlError("before updateTexImage");
    if (doTiming) {
        beginGlTiming();
    }
    mSurfaceTexture.updateTexImage();
    long timestamp = mSurfaceTexture.getTimestamp();
    Pair<RequestHolder, Long> captureHolder = targetCollector.previewCaptured(timestamp);
    // No preview request queued, drop frame.
    if (captureHolder == null) {
        if (DEBUG) {
            Log.d(TAG, "Dropping preview frame.");
        }
        if (doTiming) {
            endGlTiming();
        }
        return;
    }
    RequestHolder request = captureHolder.first;
    Collection<Surface> targetSurfaces = request.getHolderTargets();
    if (doTiming) {
        addGlTimestamp(timestamp);
    }
    List<Long> targetSurfaceIds = LegacyCameraDevice.getSurfaceIds(targetSurfaces);
    for (EGLSurfaceHolder holder : mSurfaces) {
        if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)) {
            try {
                LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height);
                makeCurrent(holder.eglSurface);
                LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second);
                drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing == CameraCharacteristics.LENS_FACING_FRONT) ? FLIP_TYPE_HORIZONTAL : FLIP_TYPE_NONE);
                swapBuffers(holder.eglSurface);
            } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
                Log.w(TAG, "Surface abandoned, dropping frame. ", e);
            }
        }
    }
    for (EGLSurfaceHolder holder : mConversionSurfaces) {
        if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)) {
            makeCurrent(holder.eglSurface);
            // glReadPixels reads from the bottom of the buffer, so add an extra vertical flip
            drawFrame(mSurfaceTexture, holder.width, holder.height, (mFacing == CameraCharacteristics.LENS_FACING_FRONT) ? FLIP_TYPE_BOTH : FLIP_TYPE_VERTICAL);
            mPBufferPixels.clear();
            GLES20.glReadPixels(/*x*/
            0, /*y*/
            0, holder.width, holder.height, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, mPBufferPixels);
            checkGlError("glReadPixels");
            try {
                int format = LegacyCameraDevice.detectSurfaceType(holder.surface);
                LegacyCameraDevice.setSurfaceDimens(holder.surface, holder.width, holder.height);
                LegacyCameraDevice.setNextTimestamp(holder.surface, captureHolder.second);
                LegacyCameraDevice.produceFrame(holder.surface, mPBufferPixels.array(), holder.width, holder.height, format);
            } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
                Log.w(TAG, "Surface abandoned, dropping frame. ", e);
            }
        }
    }
    targetCollector.previewProduced();
    if (doTiming) {
        endGlTiming();
    }
}
------------------------
Find a silently evolved API code:android.view.accessibility.AccessibilityNodeInfo.getParent:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the parent.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the
 * received info by calling {@link AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 *
 * @return The parent.
 */

Body of Frist Method:
{
    enforceSealed();
    if (!canPerformRequestOverConnection(mParentNodeId)) {
        return null;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mWindowId, mParentNodeId, false, FLAG_PREFETCH_PREDECESSORS | FLAG_PREFETCH_DESCENDANTS | FLAG_PREFETCH_SIBLINGS);
}
Body of Second Method:
{
    enforceSealed();
    return getNodeForAccessibilityId(mParentNodeId);
}
------------------------
Find a silently evolved API code:android.widget.ImageView.animateTransform:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (matrix == null) {
        mDrawable.setBounds(0, 0, getWidth(), getHeight());
    } else {
        mDrawable.setBounds(0, 0, mDrawableWidth, mDrawableHeight);
        if (mDrawMatrix == null) {
            mDrawMatrix = new Matrix();
        }
        mDrawMatrix.set(matrix);
    }
    invalidate();
}
Body of Second Method:
{
    if (mDrawable == null) {
        return;
    }
    if (matrix == null) {
        mDrawable.setBounds(0, 0, getWidth(), getHeight());
    } else {
        mDrawable.setBounds(0, 0, mDrawableWidth, mDrawableHeight);
        if (mDrawMatrix == null) {
            mDrawMatrix = new Matrix();
        }
        mDrawMatrix.set(matrix);
    }
    invalidate();
}
------------------------
Find a silently evolved API code:android.graphics.drawable.GradientDrawable.updateStateFromTypedArray:COMMENT
Method Modifier: private     
Comment:/**
 * Updates the constant state from the values in the typed array.
 */

Body of Frist Method:
{
    final GradientState state = mGradientState;
    // Account for any configuration changes.
    state.mChangingConfigurations |= a.getChangingConfigurations();
    // Extract the theme attributes, if any.
    state.mThemeAttrs = a.extractThemeAttrs();
    state.mShape = a.getInt(R.styleable.GradientDrawable_shape, state.mShape);
    state.mDither = a.getBoolean(R.styleable.GradientDrawable_dither, state.mDither);
    if (state.mShape == RING) {
        state.mInnerRadius = a.getDimensionPixelSize(R.styleable.GradientDrawable_innerRadius, state.mInnerRadius);
        if (state.mInnerRadius == -1) {
            state.mInnerRadiusRatio = a.getFloat(R.styleable.GradientDrawable_innerRadiusRatio, state.mInnerRadiusRatio);
        }
        state.mThickness = a.getDimensionPixelSize(R.styleable.GradientDrawable_thickness, state.mThickness);
        if (state.mThickness == -1) {
            state.mThicknessRatio = a.getFloat(R.styleable.GradientDrawable_thicknessRatio, state.mThicknessRatio);
        }
        state.mUseLevelForShape = a.getBoolean(R.styleable.GradientDrawable_useLevel, state.mUseLevelForShape);
    }
}
Body of Second Method:
{
    final GradientState state = mGradientState;
    // Account for any configuration changes.
    state.mChangingConfigurations |= a.getChangingConfigurations();
    // Extract the theme attributes, if any.
    state.mThemeAttrs = a.extractThemeAttrs();
    state.mShape = a.getInt(R.styleable.GradientDrawable_shape, state.mShape);
    state.mDither = a.getBoolean(R.styleable.GradientDrawable_dither, state.mDither);
    if (state.mShape == RING) {
        state.mInnerRadius = a.getDimensionPixelSize(R.styleable.GradientDrawable_innerRadius, state.mInnerRadius);
        if (state.mInnerRadius == -1) {
            state.mInnerRadiusRatio = a.getFloat(R.styleable.GradientDrawable_innerRadiusRatio, state.mInnerRadiusRatio);
        }
        state.mThickness = a.getDimensionPixelSize(R.styleable.GradientDrawable_thickness, state.mThickness);
        if (state.mThickness == -1) {
            state.mThicknessRatio = a.getFloat(R.styleable.GradientDrawable_thicknessRatio, state.mThicknessRatio);
        }
        state.mUseLevelForShape = a.getBoolean(R.styleable.GradientDrawable_useLevel, state.mUseLevelForShape);
    }
    final int tintMode = a.getInt(R.styleable.GradientDrawable_tintMode, -1);
    if (tintMode != -1) {
        state.mTintMode = Drawable.parseTintMode(tintMode, PorterDuff.Mode.SRC_IN);
    }
    final ColorStateList tint = a.getColorStateList(R.styleable.GradientDrawable_tint);
    if (tint != null) {
        state.mTint = tint;
    }
    mTintFilter = updateTintFilter(mTintFilter, state.mTint, state.mTintMode);
}
------------------------
Find a silently evolved API code:android.view.DisplayInfo.toString:COMMENT
Method Modifier: public      hidden      
Comment:// For debugging purposes

Body of Frist Method:
{
    StringBuilder sb = new StringBuilder();
    sb.append("DisplayInfo{\"");
    sb.append(name);
    sb.append("\", app ");
    sb.append(appWidth);
    sb.append(" x ");
    sb.append(appHeight);
    sb.append(", real ");
    sb.append(logicalWidth);
    sb.append(" x ");
    sb.append(logicalHeight);
    if (overscanLeft != 0 || overscanTop != 0 || overscanRight != 0 || overscanBottom != 0) {
        sb.append(", overscan (");
        sb.append(overscanLeft);
        sb.append(",");
        sb.append(overscanTop);
        sb.append(",");
        sb.append(overscanRight);
        sb.append(",");
        sb.append(overscanBottom);
        sb.append(")");
    }
    sb.append(", largest app ");
    sb.append(largestNominalAppWidth);
    sb.append(" x ");
    sb.append(largestNominalAppHeight);
    sb.append(", smallest app ");
    sb.append(smallestNominalAppWidth);
    sb.append(" x ");
    sb.append(smallestNominalAppHeight);
    sb.append(", ");
    sb.append(refreshRate);
    sb.append(" fps, supportedRefreshRates ");
    sb.append(Arrays.toString(supportedRefreshRates));
    sb.append(", rotation ");
    sb.append(rotation);
    sb.append(", density ");
    sb.append(logicalDensityDpi);
    sb.append(" (");
    sb.append(physicalXDpi);
    sb.append(" x ");
    sb.append(physicalYDpi);
    sb.append(") dpi, layerStack ");
    sb.append(layerStack);
    sb.append(", appVsyncOff ");
    sb.append(appVsyncOffsetNanos);
    sb.append(", presDeadline ");
    sb.append(presentationDeadlineNanos);
    sb.append(", type ");
    sb.append(Display.typeToString(type));
    if (address != null) {
        sb.append(", address ").append(address);
    }
    sb.append(", state ");
    sb.append(Display.stateToString(state));
    if (ownerUid != 0 || ownerPackageName != null) {
        sb.append(", owner ").append(ownerPackageName);
        sb.append(" (uid ").append(ownerUid).append(")");
    }
    sb.append(flagsToString(flags));
    sb.append("}");
    return sb.toString();
}
Body of Second Method:
{
    StringBuilder sb = new StringBuilder();
    sb.append("DisplayInfo{\"");
    sb.append(name);
    sb.append("\", uniqueId \"");
    sb.append(uniqueId);
    sb.append("\", app ");
    sb.append(appWidth);
    sb.append(" x ");
    sb.append(appHeight);
    sb.append(", real ");
    sb.append(logicalWidth);
    sb.append(" x ");
    sb.append(logicalHeight);
    if (overscanLeft != 0 || overscanTop != 0 || overscanRight != 0 || overscanBottom != 0) {
        sb.append(", overscan (");
        sb.append(overscanLeft);
        sb.append(",");
        sb.append(overscanTop);
        sb.append(",");
        sb.append(overscanRight);
        sb.append(",");
        sb.append(overscanBottom);
        sb.append(")");
    }
    sb.append(", largest app ");
    sb.append(largestNominalAppWidth);
    sb.append(" x ");
    sb.append(largestNominalAppHeight);
    sb.append(", smallest app ");
    sb.append(smallestNominalAppWidth);
    sb.append(" x ");
    sb.append(smallestNominalAppHeight);
    sb.append(", ");
    sb.append(refreshRate);
    sb.append(" fps, supportedRefreshRates ");
    sb.append(Arrays.toString(supportedRefreshRates));
    sb.append(", rotation ");
    sb.append(rotation);
    sb.append(", density ");
    sb.append(logicalDensityDpi);
    sb.append(" (");
    sb.append(physicalXDpi);
    sb.append(" x ");
    sb.append(physicalYDpi);
    sb.append(") dpi, layerStack ");
    sb.append(layerStack);
    sb.append(", appVsyncOff ");
    sb.append(appVsyncOffsetNanos);
    sb.append(", presDeadline ");
    sb.append(presentationDeadlineNanos);
    sb.append(", type ");
    sb.append(Display.typeToString(type));
    if (address != null) {
        sb.append(", address ").append(address);
    }
    sb.append(", state ");
    sb.append(Display.stateToString(state));
    if (ownerUid != 0 || ownerPackageName != null) {
        sb.append(", owner ").append(ownerPackageName);
        sb.append(" (uid ").append(ownerUid).append(")");
    }
    sb.append(flagsToString(flags));
    sb.append("}");
    return sb.toString();
}
------------------------
Find a silently evolved API code:android.text.TextLine.recycle:COMMENT
Method Modifier: default     static      hidden      
Comment:/**
 * Puts a TextLine back into the shared pool. Do not use this TextLine once
 * it has been returned.
 * @param tl the textLine
 * @return null, as a convenience from clearing references to the provided
 * TextLine
 */

Body of Frist Method:
{
    tl.mText = null;
    tl.mPaint = null;
    tl.mDirections = null;
    tl.mMetricAffectingSpanSpanSet.recycle();
    tl.mCharacterStyleSpanSet.recycle();
    tl.mReplacementSpanSpanSet.recycle();
    synchronized (sCached) {
        for (int i = 0; i < sCached.length; ++i) {
            if (sCached[i] == null) {
                sCached[i] = tl;
                break;
            }
        }
    }
    return null;
}
Body of Second Method:
{
    tl.mText = null;
    tl.mPaint = null;
    tl.mDirections = null;
    tl.mSpanned = null;
    tl.mTabs = null;
    tl.mChars = null;
    tl.mMetricAffectingSpanSpanSet.recycle();
    tl.mCharacterStyleSpanSet.recycle();
    tl.mReplacementSpanSpanSet.recycle();
    synchronized (sCached) {
        for (int i = 0; i < sCached.length; ++i) {
            if (sCached[i] == null) {
                sCached[i] = tl;
                break;
            }
        }
    }
    return null;
}
------------------------
Find a silently evolved API code:android.webkit.WebSettings.getCacheMode:COMMENT
<android.webkit.WebSettings: int getCacheMode()>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Gets the current setting for overriding the cache mode.
 *
 * @return the current setting for overriding the cache mode
 * @see #setCacheMode
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.bluetooth.BluetoothAdapter.getBluetoothLeAdvertiser:COMMENT
Method Modifier: public      
Comment:/**
 * Returns a {@link BluetoothLeAdvertiser} object for Bluetooth LE Advertising operations.
 * Will return null if Bluetooth is turned off or if Bluetooth LE Advertising is not
 * supported on this device.
 * <p>
 * Use {@link #isMultipleAdvertisementSupported()} to check whether LE Advertising is supported
 * on this device before calling this method.
 */

Body of Frist Method:
{
    if (getState() != STATE_ON) {
        return null;
    }
    if (!isMultipleAdvertisementSupported()) {
        return null;
    }
    synchronized (mLock) {
        if (sBluetoothLeAdvertiser == null) {
            sBluetoothLeAdvertiser = new BluetoothLeAdvertiser(mManagerService);
        }
    }
    return sBluetoothLeAdvertiser;
}
Body of Second Method:
{
    if (getState() != STATE_ON) {
        return null;
    }
    if (!isMultipleAdvertisementSupported() && !isPeripheralModeSupported()) {
        Log.e(TAG, "bluetooth le advertising not supported");
        return null;
    }
    synchronized (mLock) {
        if (sBluetoothLeAdvertiser == null) {
            sBluetoothLeAdvertiser = new BluetoothLeAdvertiser(mManagerService);
        }
    }
    return sBluetoothLeAdvertiser;
}
------------------------
Find a silently evolved API code:android.webkit.WebHistoryItem.getTitle:COMMENT
<android.webkit.WebHistoryItem: String getTitle()>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Return the document title of this history item.
 * @return The document title of this history item.
 * Note: The VM ensures 32-bit atomic read/write operations so we don't have
 * to synchronize this method.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.webkit.WebViewDatabase.clearUsernamePassword:COMMENT
<android.webkit.WebViewDatabase: void clearUsernamePassword()>
public      deprecated  ->public      abstract    deprecated  
Method Modifier: public      abstract    deprecated  
Method Modifier: Yes         No          Yes         
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * Clears any saved username/password pairs for web forms.
 * Note that these are unrelated to HTTP authentication credentials.
 *
 * @see WebView#savePassword
 * @see #hasUsernamePassword
 * @deprecated Saving passwords in WebView will not be supported in future versions.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.widget.PopupWindow.setContentView:COMMENT
Method Modifier: public      
Comment:/**
 * <p>Change the popup's content. The content is represented by an instance
 * of {@link android.view.View}.</p>
 *
 * <p>This method has no effect if called when the popup is showing.</p>
 *
 * @param contentView the new content for the popup
 *
 * @see #getContentView()
 * @see #isShowing()
 */

Body of Frist Method:
{
    if (isShowing()) {
        return;
    }
    mContentView = contentView;
    if (mContext == null && mContentView != null) {
        mContext = mContentView.getContext();
    }
    if (mWindowManager == null && mContentView != null) {
        mWindowManager = (WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE);
    }
}
Body of Second Method:
{
    if (isShowing()) {
        return;
    }
    mContentView = contentView;
    if (mContext == null && mContentView != null) {
        mContext = mContentView.getContext();
    }
    if (mWindowManager == null && mContentView != null) {
        mWindowManager = (WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE);
    }
    // app hasn't already set the attachedInDecor.
    if (mContext != null && !mAttachedInDecorSet) {
        // Attach popup window in decor frame of parent window by default for
        // {@link Build.VERSION_CODES.LOLLIPOP_MR1} or greater. Keep current
        // behavior of not attaching to decor frame for older SDKs.
        setAttachedInDecor(mContext.getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.LOLLIPOP_MR1);
    }
}
------------------------
Find a silently evolved API code:android.widget.RadialTimePickerView.getCurrentHour:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns the current hour in 24-hour time.
 *
 * @return the current hour between 0 and 23 (inclusive)
 */

Body of Frist Method:
{
    int hour = (mSelectionDegrees[mIsOnInnerCircle ? HOURS_INNER : HOURS] / DEGREES_FOR_ONE_HOUR) % 12;
    if (mIs24HourMode) {
        // selector is positioned.
        if (mIsOnInnerCircle && hour == 0) {
            // Inner circle is 1 through 12.
            hour = 12;
        } else if (!mIsOnInnerCircle && hour != 0) {
            // Outer circle is 13 through 23 and 0.
            hour += 12;
        }
    } else if (mAmOrPm == PM) {
        hour += 12;
    }
    return hour;
}
Body of Second Method:
{
    return getHourForDegrees(mSelectionDegrees[mIsOnInnerCircle ? HOURS_INNER : HOURS], mIsOnInnerCircle);
}
------------------------
Find a silently evolved API code:android.webkit.WebSettings.setUserAgentString:COMMENT
<android.webkit.WebSettings: void setUserAgentString(String)>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Sets the WebView's user-agent string. If the string is null or empty,
 * the system default value will be used.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.media.AudioManager.getRingerMode:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the current ringtone mode.
 *
 * @return The current ringtone mode, one of {@link #RINGER_MODE_NORMAL},
 * {@link #RINGER_MODE_SILENT}, or {@link #RINGER_MODE_VIBRATE}.
 * @see #setRingerMode(int)
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        return service.getRingerMode();
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in getRingerMode", e);
        return RINGER_MODE_NORMAL;
    }
}
Body of Second Method:
{
    IAudioService service = getService();
    try {
        return service.getRingerModeExternal();
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in getRingerMode", e);
        return RINGER_MODE_NORMAL;
    }
}
------------------------
Find a silently evolved API code:android.net.ConnectivityManager.stopUsingNetworkFeature:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * Tells the underlying networking system that the caller is finished
 * using the named feature. The interpretation of {@code feature}
 * is completely up to each networking implementation.
 * <p>This method requires the caller to hold the permission
 * {@link android.Manifest.permission#CHANGE_NETWORK_STATE}.
 * @param networkType specifies which network the request pertains to
 * @param feature the name of the feature that is no longer needed
 * @return an integer value representing the outcome of the request.
 * The interpretation of this value is specific to each networking
 * implementation+feature combination, except that the value {@code -1}
 * always indicates failure.
 *
 * @deprecated Deprecated in favor of the cleaner {@link #requestNetwork} api.
 */

Body of Frist Method:
{
    NetworkCapabilities netCap = networkCapabilitiesForFeature(networkType, feature);
    if (netCap == null) {
        Log.d(TAG, "Can't satisfy stopUsingNetworkFeature for " + networkType + ", " + feature);
        return -1;
    }
    NetworkCallback networkCallback = removeRequestForFeature(netCap);
    if (networkCallback != null) {
        Log.d(TAG, "stopUsingNetworkFeature for " + networkType + ", " + feature);
        unregisterNetworkCallback(networkCallback);
    }
    return 1;
}
Body of Second Method:
{
    NetworkCapabilities netCap = networkCapabilitiesForFeature(networkType, feature);
    if (netCap == null) {
        Log.d(TAG, "Can't satisfy stopUsingNetworkFeature for " + networkType + ", " + feature);
        return -1;
    }
    if (removeRequestForFeature(netCap)) {
        Log.d(TAG, "stopUsingNetworkFeature for " + networkType + ", " + feature);
    }
    return 1;
}
------------------------
Find a silently evolved API code:android.app.ApplicationPackageManager.loadItemIcon:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (itemInfo.showUserIcon != UserHandle.USER_NULL) {
        Bitmap bitmap = getUserManager().getUserIcon(itemInfo.showUserIcon);
        if (bitmap == null) {
            return UserIcons.getDefaultUserIcon(itemInfo.showUserIcon, /* light= */
            false);
        }
        return new BitmapDrawable(bitmap);
    }
    Drawable dr = null;
    if (itemInfo.packageName != null) {
        dr = getDrawable(itemInfo.packageName, itemInfo.icon, appInfo);
    }
    if (dr == null) {
        dr = itemInfo.loadDefaultIcon(this);
    }
    return getUserBadgedIcon(dr, new UserHandle(mContext.getUserId()));
}
Body of Second Method:
{
    Drawable dr = loadUnbadgedItemIcon(itemInfo, appInfo);
    if (itemInfo.showUserIcon != UserHandle.USER_NULL) {
        return dr;
    }
    return getUserBadgedIcon(dr, new UserHandle(mContext.getUserId()));
}
------------------------
Find a silently evolved API code:android.webkit.WebSettings.getTextZoom:COMMENT
<android.webkit.WebSettings: int getTextZoom()>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Gets the text zoom of the page in percent.
 *
 * @return the text zoom of the page in percent
 * @see #setTextZoom
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.animation.ValueAnimator.animationFrame:COMMENT
Method Modifier: default     
Comment:/**
 * This internal function processes a single animation frame for a given animation. The
 * currentTime parameter is the timing pulse sent by the handler, used to calculate the
 * elapsed duration, and therefore
 * the elapsed fraction, of the animation. The return value indicates whether the animation
 * should be ended (which happens when the elapsed time of the animation exceeds the
 * animation's duration, including the repeatCount).
 *
 * @param currentTime The current time, as tracked by the static timing handler
 * @return true if the animation's duration, including any repetitions due to
 * <code>repeatCount</code>, has been exceeded and the animation should be ended.
 */

Body of Frist Method:
{
    boolean done = false;
    switch(mPlayingState) {
        case RUNNING:
        case SEEKED:
            float fraction = mDuration > 0 ? (float) (currentTime - mStartTime) / mDuration : 1f;
            if (fraction >= 1f) {
                if (mCurrentIteration < mRepeatCount || mRepeatCount == INFINITE) {
                    // Time to repeat
                    if (mListeners != null) {
                        int numListeners = mListeners.size();
                        for (int i = 0; i < numListeners; ++i) {
                            mListeners.get(i).onAnimationRepeat(this);
                        }
                    }
                    if (mRepeatMode == REVERSE) {
                        mPlayingBackwards = !mPlayingBackwards;
                    }
                    mCurrentIteration += (int) fraction;
                    fraction = fraction % 1f;
                    mStartTime += mDuration;
                } else {
                    done = true;
                    fraction = Math.min(fraction, 1.0f);
                }
            }
            if (mPlayingBackwards) {
                fraction = 1f - fraction;
            }
            animateValue(fraction);
            break;
    }
    return done;
}
Body of Second Method:
{
    boolean done = false;
    switch(mPlayingState) {
        case RUNNING:
        case SEEKED:
            float fraction = mDuration > 0 ? (float) (currentTime - mStartTime) / mDuration : 1f;
            if (mDuration == 0 && mRepeatCount != INFINITE) {
                // Skip to the end
                mCurrentIteration = mRepeatCount;
                if (!mReversing) {
                    mPlayingBackwards = false;
                }
            }
            if (fraction >= 1f) {
                if (mCurrentIteration < mRepeatCount || mRepeatCount == INFINITE) {
                    // Time to repeat
                    if (mListeners != null) {
                        int numListeners = mListeners.size();
                        for (int i = 0; i < numListeners; ++i) {
                            mListeners.get(i).onAnimationRepeat(this);
                        }
                    }
                    if (mRepeatMode == REVERSE) {
                        mPlayingBackwards = !mPlayingBackwards;
                    }
                    mCurrentIteration += (int) fraction;
                    fraction = fraction % 1f;
                    mStartTime += mDuration;
                } else {
                    done = true;
                    fraction = Math.min(fraction, 1.0f);
                }
            }
            if (mPlayingBackwards) {
                fraction = 1f - fraction;
            }
            animateValue(fraction);
            break;
    }
    return done;
}
------------------------
Find a silently evolved API code:android.media.AudioService.setMasterMute:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @see AudioManager#setMasterMute(boolean, int)
 */

Body of Frist Method:
{
    if (mUseFixedVolume) {
        return;
    }
    if (mAppOps.noteOp(AppOpsManager.OP_AUDIO_MASTER_VOLUME, Binder.getCallingUid(), callingPackage) != AppOpsManager.MODE_ALLOWED) {
        return;
    }
    if (state != AudioSystem.getMasterMute()) {
        AudioSystem.setMasterMute(state);
        // Post a persist master volume msg
        sendMsg(mAudioHandler, MSG_PERSIST_MASTER_VOLUME_MUTE, SENDMSG_REPLACE, state ? 1 : 0, UserHandle.getCallingUserId(), null, PERSIST_DELAY);
        sendMasterMuteUpdate(state, flags);
    }
}
Body of Second Method:
{
    setMasterMuteInternal(state, flags, callingPackage, cb, Binder.getCallingUid());
}
------------------------
Find a silently evolved API code:android.webkit.WebSettings.getUseWideViewPort:COMMENT
<android.webkit.WebSettings: boolean getUseWideViewPort()>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Gets whether the WebView supports the &quot;viewport&quot;
 * HTML meta tag or will use a wide viewport.
 *
 * @return true if the WebView supports the viewport meta tag
 * @see #setUseWideViewPort
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.webkit.WebSettings.setAppCacheEnabled:COMMENT
<android.webkit.WebSettings: void setAppCacheEnabled(boolean)>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Sets whether the Application Caches API should be enabled. The default
 * is false. Note that in order for the Application Caches API to be
 * enabled, a valid database path must also be supplied to
 * {@link #setAppCachePath}.
 *
 * @param flag true if the WebView should enable Application Caches
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.webkit.WebIconDatabase.retainIconForPageUrl:COMMENT
<android.webkit.WebIconDatabase: void retainIconForPageUrl(String)>
public      deprecated  ->public      abstract    deprecated  
Method Modifier: public      abstract    deprecated  
Method Modifier: Yes         No          Yes         
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * Retain the icon for the given page url.
 * @param url The page's url.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.webkit.WebSettings.setFixedFontFamily:COMMENT
<android.webkit.WebSettings: void setFixedFontFamily(String)>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Sets the fixed font family name. The default is "monospace".
 *
 * @param font a font family name
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.util.PathParser.extract:COMMENT
Method Modifier: private     static      hidden      
Comment:/**
 * Calculate the position of the next comma or space or negative sign
 * @param s the string to search
 * @param start the position to start searching
 * @param result the result of the extraction, including the position of the
 * the starting position of next number, whether it is ending with a '-'.
 */

Body of Frist Method:
{
    // Now looking for ' ', ',' or '-' from the start.
    int currentIndex = start;
    boolean foundSeparator = false;
    result.mEndWithNegSign = false;
    for (; currentIndex < s.length(); currentIndex++) {
        char currentChar = s.charAt(currentIndex);
        switch(currentChar) {
            case ' ':
            case ',':
                foundSeparator = true;
                break;
            case '-':
                if (currentIndex != start) {
                    foundSeparator = true;
                    result.mEndWithNegSign = true;
                }
                break;
        }
        if (foundSeparator) {
            break;
        }
    }
    // When there is nothing found, then we put the end position to the end
    // of the string.
    result.mEndPosition = currentIndex;
}
Body of Second Method:
{
    // Now looking for ' ', ',', '.' or '-' from the start.
    int currentIndex = start;
    boolean foundSeparator = false;
    result.mEndWithNegOrDot = false;
    boolean secondDot = false;
    boolean isExponential = false;
    for (; currentIndex < s.length(); currentIndex++) {
        boolean isPrevExponential = isExponential;
        isExponential = false;
        char currentChar = s.charAt(currentIndex);
        switch(currentChar) {
            case ' ':
            case ',':
                foundSeparator = true;
                break;
            case '-':
                // The negative sign following a 'e' or 'E' is not a separator.
                if (currentIndex != start && !isPrevExponential) {
                    foundSeparator = true;
                    result.mEndWithNegOrDot = true;
                }
                break;
            case '.':
                if (!secondDot) {
                    secondDot = true;
                } else {
                    // This is the second dot, and it is considered as a separator.
                    foundSeparator = true;
                    result.mEndWithNegOrDot = true;
                }
                break;
            case 'e':
            case 'E':
                isExponential = true;
                break;
        }
        if (foundSeparator) {
            break;
        }
    }
    // When there is nothing found, then we put the end position to the end
    // of the string.
    result.mEndPosition = currentIndex;
}
------------------------
Find a silently evolved API code:android.webkit.WebSettings.setSavePassword:COMMENT
<android.webkit.WebSettings: void setSavePassword(boolean)>
public      deprecated  ->public      abstract    deprecated  
Method Modifier: public      abstract    deprecated  
Method Modifier: Yes         No          Yes         
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * Sets whether the WebView should save passwords. The default is true.
 * @deprecated Saving passwords in WebView will not be supported in future versions.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.webkit.WebSettings.getUserAgentString:COMMENT
<android.webkit.WebSettings: String getUserAgentString()>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Gets the WebView's user-agent string.
 *
 * @return the WebView's user-agent string
 * @see #setUserAgentString
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.os.AsyncTask.publishProgress:COMMENT
Method Modifier: protected   final       
Comment:/**
 * This method can be invoked from {@link #doInBackground} to
 * publish updates on the UI thread while the background computation is
 * still running. Each call to this method will trigger the execution of
 * {@link #onProgressUpdate} on the UI thread.
 *
 * {@link #onProgressUpdate} will not be called if the task has been
 * canceled.
 *
 * @param values The progress values to update the UI with.
 *
 * @see #onProgressUpdate
 * @see #doInBackground
 */

Body of Frist Method:
{
    if (!isCancelled()) {
        sHandler.obtainMessage(MESSAGE_POST_PROGRESS, new AsyncTaskResult<Progress>(this, values)).sendToTarget();
    }
}
Body of Second Method:
{
    if (!isCancelled()) {
        getHandler().obtainMessage(MESSAGE_POST_PROGRESS, new AsyncTaskResult<Progress>(this, values)).sendToTarget();
    }
}
------------------------
Find a silently evolved API code:android.webkit.WebSettings.getDefaultZoom:COMMENT
<android.webkit.WebSettings: ZoomDensity getDefaultZoom()>
public      deprecated  ->public      abstract    deprecated  
Method Modifier: public      abstract    deprecated  
Method Modifier: Yes         No          Yes         
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * Gets the default zoom density of the page. This should be called from
 * the UI thread.
 *
 * This setting is not recommended for use in new applications.
 *
 * @return the zoom density
 * @see #setDefaultZoom
 * @deprecated Will only return the default value.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.webkit.WebSettings.getMediaPlaybackRequiresUserGesture:COMMENT
<android.webkit.WebSettings: boolean getMediaPlaybackRequiresUserGesture()>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Gets whether the WebView requires a user gesture to play media.
 *
 * @return true if the WebView requires a user gesture to play media
 * @see #setMediaPlaybackRequiresUserGesture
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.animation.ValueAnimator.doAnimationFrame:COMMENT
Method Modifier: default     final       
Comment:/**
 * Processes a frame of the animation, adjusting the start time if needed.
 *
 * @param frameTime The frame time.
 * @return true if the animation has ended.
 */

Body of Frist Method:
{
    if (mPlayingState == STOPPED) {
        mPlayingState = RUNNING;
        if (mSeekTime < 0) {
            mStartTime = frameTime;
        } else {
            mStartTime = frameTime - mSeekTime;
            // Now that we're playing, reset the seek time
            mSeekTime = -1;
        }
    }
    if (mPaused) {
        if (mPauseTime < 0) {
            mPauseTime = frameTime;
        }
        return false;
    } else if (mResumed) {
        mResumed = false;
        if (mPauseTime > 0) {
            // Offset by the duration that the animation was paused
            mStartTime += (frameTime - mPauseTime);
        }
    }
    // The frame time might be before the start time during the first frame of
    // an animation.  The "current time" must always be on or after the start
    // time to avoid animating frames at negative time intervals.  In practice, this
    // is very rare and only happens when seeking backwards.
    final long currentTime = Math.max(frameTime, mStartTime);
    return animationFrame(currentTime);
}
Body of Second Method:
{
    if (mPlayingState == STOPPED) {
        mPlayingState = RUNNING;
        if (mSeekFraction < 0) {
            mStartTime = frameTime;
        } else {
            long seekTime = (long) (mDuration * mSeekFraction);
            mStartTime = frameTime - seekTime;
            mSeekFraction = -1;
        }
    }
    if (mPaused) {
        if (mPauseTime < 0) {
            mPauseTime = frameTime;
        }
        return false;
    } else if (mResumed) {
        mResumed = false;
        if (mPauseTime > 0) {
            // Offset by the duration that the animation was paused
            mStartTime += (frameTime - mPauseTime);
        }
    }
    // The frame time might be before the start time during the first frame of
    // an animation.  The "current time" must always be on or after the start
    // time to avoid animating frames at negative time intervals.  In practice, this
    // is very rare and only happens when seeking backwards.
    final long currentTime = Math.max(frameTime, mStartTime);
    return animationFrame(currentTime);
}
------------------------
Find a silently evolved API code:android.media.AudioService.requestAudioFocus:COMMENT
Method Modifier: public      hidden      
Comment:// ==========================================================================================

Body of Frist Method:
{
    return mMediaFocusControl.requestAudioFocus(mainStreamType, durationHint, cb, fd, clientId, callingPackageName);
}
Body of Second Method:
{
    // permission checks
    if ((flags & AudioManager.AUDIOFOCUS_FLAG_LOCK) == AudioManager.AUDIOFOCUS_FLAG_LOCK) {
        if (mMediaFocusControl.IN_VOICE_COMM_FOCUS_ID.equals(clientId)) {
            if (PackageManager.PERMISSION_GRANTED != mContext.checkCallingOrSelfPermission(android.Manifest.permission.MODIFY_PHONE_STATE)) {
                Log.e(TAG, "Invalid permission to (un)lock audio focus", new Exception());
                return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
            }
        } else {
            // only a registered audio policy can be used to lock focus
            synchronized (mAudioPolicies) {
                if (!mAudioPolicies.containsKey(pcb.asBinder())) {
                    Log.e(TAG, "Invalid unregistered AudioPolicy to (un)lock audio focus");
                    return AudioManager.AUDIOFOCUS_REQUEST_FAILED;
                }
            }
        }
    }
    return mMediaFocusControl.requestAudioFocus(aa, durationHint, cb, fd, clientId, callingPackageName, flags);
}
------------------------
Find a silently evolved API code:android.animation.ValueAnimator.reverse:COMMENT
Method Modifier: public      
Comment:/**
 * Plays the ValueAnimator in reverse. If the animation is already running,
 * it will stop itself and play backwards from the point reached when reverse was called.
 * If the animation is not currently running, then it will start from the end and
 * play backwards. This behavior is only set for the current animation; future playing
 * of the animation will use the default behavior of playing forward.
 */

Body of Frist Method:
{
    mPlayingBackwards = !mPlayingBackwards;
    if (mPlayingState == RUNNING) {
        long currentTime = AnimationUtils.currentAnimationTimeMillis();
        long currentPlayTime = currentTime - mStartTime;
        long timeLeft = mDuration - currentPlayTime;
        mStartTime = currentTime - timeLeft;
    } else if (mStarted) {
        end();
    } else {
        start(true);
    }
}
Body of Second Method:
{
    mPlayingBackwards = !mPlayingBackwards;
    if (mPlayingState == RUNNING) {
        long currentTime = AnimationUtils.currentAnimationTimeMillis();
        long currentPlayTime = currentTime - mStartTime;
        long timeLeft = mDuration - currentPlayTime;
        mStartTime = currentTime - timeLeft;
        mReversing = !mReversing;
    } else if (mStarted) {
        end();
    } else {
        start(true);
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothGatt.writeCharacteristic:COMMENT
Method Modifier: public      
Comment:/**
 * Writes a given characteristic and its values to the associated remote device.
 *
 * <p>Once the write operation has been completed, the
 * {@link BluetoothGattCallback#onCharacteristicWrite} callback is invoked,
 * reporting the result of the operation.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param characteristic Characteristic to write on the remote device
 * @return true, if the write operation was initiated successfully
 */

Body of Frist Method:
{
    if ((characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_WRITE) == 0 && (characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE) == 0)
        return false;
    if (VDBG)
        Log.d(TAG, "writeCharacteristic() - uuid: " + characteristic.getUuid());
    if (mService == null || mClientIf == 0)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusy) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.writeCharacteristic(mClientIf, device.getAddress(), service.getType(), service.getInstanceId(), new ParcelUuid(service.getUuid()), characteristic.getInstanceId(), new ParcelUuid(characteristic.getUuid()), characteristic.getWriteType(), AUTHENTICATION_NONE, characteristic.getValue());
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}
Body of Second Method:
{
    if ((characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_WRITE) == 0 && (characteristic.getProperties() & BluetoothGattCharacteristic.PROPERTY_WRITE_NO_RESPONSE) == 0)
        return false;
    if (VDBG)
        Log.d(TAG, "writeCharacteristic() - uuid: " + characteristic.getUuid());
    if (mService == null || mClientIf == 0 || characteristic.getValue() == null)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusy) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.writeCharacteristic(mClientIf, device.getAddress(), service.getType(), service.getInstanceId(), new ParcelUuid(service.getUuid()), characteristic.getInstanceId(), new ParcelUuid(characteristic.getUuid()), characteristic.getWriteType(), AUTHENTICATION_NONE, characteristic.getValue());
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}
------------------------
Find a silently evolved API code:android.webkit.WebIconDatabase.releaseIconForPageUrl:COMMENT
<android.webkit.WebIconDatabase: void releaseIconForPageUrl(String)>
public      deprecated  ->public      abstract    deprecated  
Method Modifier: public      abstract    deprecated  
Method Modifier: Yes         No          Yes         
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * Release the icon for the given page url.
 * @param url The page's url.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.media.AudioService.setStreamSolo:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @see AudioManager#setStreamSolo(int, boolean)
 */

Body of Frist Method:
{
    if (mUseFixedVolume) {
        return;
    }
    for (int stream = 0; stream < mStreamStates.length; stream++) {
        if (!isStreamAffectedByMute(stream) || stream == streamType)
            continue;
        mStreamStates[stream].mute(cb, state);
    }
}
Body of Second Method:
{
    if (mUseFixedVolume) {
        return;
    }
    int streamAlias = mStreamVolumeAlias[streamType];
    for (int stream = 0; stream < mStreamStates.length; stream++) {
        if (!isStreamAffectedByMute(streamAlias) || streamAlias == mStreamVolumeAlias[stream]) {
            continue;
        }
        mStreamStates[stream].mute(cb, state);
    }
}
------------------------
Find a silently evolved API code:android.webkit.WebSettings.getJavaScriptEnabled:COMMENT
<android.webkit.WebSettings: boolean getJavaScriptEnabled()>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Gets whether JavaScript is enabled.
 *
 * @return true if JavaScript is enabled
 * @see #setJavaScriptEnabled
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.webkit.WebSettings.setDefaultTextEncodingName:COMMENT
<android.webkit.WebSettings: void setDefaultTextEncodingName(String)>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Sets the default text encoding name to use when decoding html pages.
 * The default is "UTF-8".
 *
 * @param encoding the text encoding name
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.bluetooth.BluetoothGattCharacteristic.getStringValue:COMMENT
Method Modifier: public      
Comment:/**
 * Return the stored value of this characteristic.
 * <p>See {@link #getValue} for details.
 *
 * @param offset Offset at which the string value can be found.
 * @return Cached value of the characteristic
 */

Body of Frist Method:
{
    if (offset > mValue.length)
        return null;
    byte[] strBytes = new byte[mValue.length - offset];
    for (int i = 0; i != (mValue.length - offset); ++i) strBytes[i] = mValue[offset + i];
    return new String(strBytes);
}
Body of Second Method:
{
    if (mValue == null || offset > mValue.length)
        return null;
    byte[] strBytes = new byte[mValue.length - offset];
    for (int i = 0; i != (mValue.length - offset); ++i) strBytes[i] = mValue[offset + i];
    return new String(strBytes);
}
------------------------
Find a silently evolved API code:android.webkit.CookieManager.acceptThirdPartyCookies:COMMENT
<android.webkit.CookieManager: boolean acceptThirdPartyCookies(WebView)>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Gets whether the {@link WebView} should allow third party cookies to be set.
 *
 * @param webview the {@link WebView} instance to get the cookie policy for
 * @return true if the {@link WebView} accepts third party cookies
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.media.tv.TvInputManager.Session.selectTrack:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Selects a track.
 *
 * @param type The type of the track to select. The type can be
 * {@link TvTrackInfo#TYPE_AUDIO}, {@link TvTrackInfo#TYPE_VIDEO} or
 * {@link TvTrackInfo#TYPE_SUBTITLE}.
 * @param trackId The ID of the track to select. When {@code null}, the currently selected
 * track of the given type will be unselected.
 * @see #getTracks
 */

Body of Frist Method:
{
    if (type == TvTrackInfo.TYPE_AUDIO) {
        if (trackId != null && !containsTrack(mAudioTracks, trackId)) {
            Log.w(TAG, "Invalid audio trackId: " + trackId);
            return;
        }
    } else if (type == TvTrackInfo.TYPE_VIDEO) {
        if (trackId != null && !containsTrack(mVideoTracks, trackId)) {
            Log.w(TAG, "Invalid video trackId: " + trackId);
            return;
        }
    } else if (type == TvTrackInfo.TYPE_SUBTITLE) {
        if (trackId != null && !containsTrack(mSubtitleTracks, trackId)) {
            Log.w(TAG, "Invalid subtitle trackId: " + trackId);
            return;
        }
    } else {
        throw new IllegalArgumentException("invalid type: " + type);
    }
    if (mToken == null) {
        Log.w(TAG, "The session has been already released");
        return;
    }
    try {
        mService.selectTrack(mToken, type, trackId, mUserId);
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}
Body of Second Method:
{
    synchronized (mTrackLock) {
        if (type == TvTrackInfo.TYPE_AUDIO) {
            if (trackId != null && !containsTrack(mAudioTracks, trackId)) {
                Log.w(TAG, "Invalid audio trackId: " + trackId);
                return;
            }
        } else if (type == TvTrackInfo.TYPE_VIDEO) {
            if (trackId != null && !containsTrack(mVideoTracks, trackId)) {
                Log.w(TAG, "Invalid video trackId: " + trackId);
                return;
            }
        } else if (type == TvTrackInfo.TYPE_SUBTITLE) {
            if (trackId != null && !containsTrack(mSubtitleTracks, trackId)) {
                Log.w(TAG, "Invalid subtitle trackId: " + trackId);
                return;
            }
        } else {
            throw new IllegalArgumentException("invalid type: " + type);
        }
    }
    if (mToken == null) {
        Log.w(TAG, "The session has been already released");
        return;
    }
    try {
        mService.selectTrack(mToken, type, trackId, mUserId);
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}
------------------------
Find a silently evolved API code:android.webkit.WebView.setNetworkAvailable:COMMENT
Method Modifier: public      
Comment:/**
 * Informs WebView of the network state. This is used to set
 * the JavaScript property window.navigator.isOnline and
 * generates the online/offline event as specified in HTML5, sec. 5.7.7
 *
 * @param networkUp a boolean indicating if network is available
 */

Body of Frist Method:
{
    checkThread();
    if (DebugFlags.TRACE_API)
        Log.d(LOGTAG, "setNetworkAvailable=" + networkUp);
    mProvider.setNetworkAvailable(networkUp);
}
Body of Second Method:
{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, "setNetworkAvailable=" + networkUp);
    mProvider.setNetworkAvailable(networkUp);
}
------------------------
Find a silently evolved API code:android.telephony.DisconnectCause.toString:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Returns descriptive string for the specified disconnect cause.
 */

Body of Frist Method:
{
    switch(cause) {
        case NOT_DISCONNECTED:
            return "NOT_DISCONNECTED";
        case INCOMING_MISSED:
            return "INCOMING_MISSED";
        case NORMAL:
            return "NORMAL";
        case LOCAL:
            return "LOCAL";
        case BUSY:
            return "BUSY";
        case CONGESTION:
            return "CONGESTION";
        case INVALID_NUMBER:
            return "INVALID_NUMBER";
        case NUMBER_UNREACHABLE:
            return "NUMBER_UNREACHABLE";
        case SERVER_UNREACHABLE:
            return "SERVER_UNREACHABLE";
        case INVALID_CREDENTIALS:
            return "INVALID_CREDENTIALS";
        case OUT_OF_NETWORK:
            return "OUT_OF_NETWORK";
        case SERVER_ERROR:
            return "SERVER_ERROR";
        case TIMED_OUT:
            return "TIMED_OUT";
        case LOST_SIGNAL:
            return "LOST_SIGNAL";
        case LIMIT_EXCEEDED:
            return "LIMIT_EXCEEDED";
        case INCOMING_REJECTED:
            return "INCOMING_REJECTED";
        case POWER_OFF:
            return "POWER_OFF";
        case OUT_OF_SERVICE:
            return "OUT_OF_SERVICE";
        case ICC_ERROR:
            return "ICC_ERROR";
        case CALL_BARRED:
            return "CALL_BARRED";
        case FDN_BLOCKED:
            return "FDN_BLOCKED";
        case CS_RESTRICTED:
            return "CS_RESTRICTED";
        case CS_RESTRICTED_NORMAL:
            return "CS_RESTRICTED_NORMAL";
        case CS_RESTRICTED_EMERGENCY:
            return "CS_RESTRICTED_EMERGENCY";
        case UNOBTAINABLE_NUMBER:
            return "UNOBTAINABLE_NUMBER";
        case CDMA_LOCKED_UNTIL_POWER_CYCLE:
            return "CDMA_LOCKED_UNTIL_POWER_CYCLE";
        case CDMA_DROP:
            return "CDMA_DROP";
        case CDMA_INTERCEPT:
            return "CDMA_INTERCEPT";
        case CDMA_REORDER:
            return "CDMA_REORDER";
        case CDMA_SO_REJECT:
            return "CDMA_SO_REJECT";
        case CDMA_RETRY_ORDER:
            return "CDMA_RETRY_ORDER";
        case CDMA_ACCESS_FAILURE:
            return "CDMA_ACCESS_FAILURE";
        case CDMA_PREEMPTED:
            return "CDMA_PREEMPTED";
        case CDMA_NOT_EMERGENCY:
            return "CDMA_NOT_EMERGENCY";
        case CDMA_ACCESS_BLOCKED:
            return "CDMA_ACCESS_BLOCKED";
        case EMERGENCY_ONLY:
            return "EMERGENCY_ONLY";
        case NO_PHONE_NUMBER_SUPPLIED:
            return "NO_PHONE_NUMBER_SUPPLIED";
        case DIALED_MMI:
            return "DIALED_MMI";
        case VOICEMAIL_NUMBER_MISSING:
            return "VOICEMAIL_NUMBER_MISSING";
        case CDMA_CALL_LOST:
            return "CDMA_CALL_LOST";
        case EXITED_ECM:
            return "EXITED_ECM";
        case ERROR_UNSPECIFIED:
            return "ERROR_UNSPECIFIED";
        case OUTGOING_FAILURE:
            return "OUTGOING_FAILURE";
        case OUTGOING_CANCELED:
            return "OUTGOING_CANCELED";
        default:
            return "INVALID: " + cause;
    }
}
Body of Second Method:
{
    switch(cause) {
        case NOT_DISCONNECTED:
            return "NOT_DISCONNECTED";
        case INCOMING_MISSED:
            return "INCOMING_MISSED";
        case NORMAL:
            return "NORMAL";
        case LOCAL:
            return "LOCAL";
        case BUSY:
            return "BUSY";
        case CONGESTION:
            return "CONGESTION";
        case INVALID_NUMBER:
            return "INVALID_NUMBER";
        case NUMBER_UNREACHABLE:
            return "NUMBER_UNREACHABLE";
        case SERVER_UNREACHABLE:
            return "SERVER_UNREACHABLE";
        case INVALID_CREDENTIALS:
            return "INVALID_CREDENTIALS";
        case OUT_OF_NETWORK:
            return "OUT_OF_NETWORK";
        case SERVER_ERROR:
            return "SERVER_ERROR";
        case TIMED_OUT:
            return "TIMED_OUT";
        case LOST_SIGNAL:
            return "LOST_SIGNAL";
        case LIMIT_EXCEEDED:
            return "LIMIT_EXCEEDED";
        case INCOMING_REJECTED:
            return "INCOMING_REJECTED";
        case POWER_OFF:
            return "POWER_OFF";
        case OUT_OF_SERVICE:
            return "OUT_OF_SERVICE";
        case ICC_ERROR:
            return "ICC_ERROR";
        case CALL_BARRED:
            return "CALL_BARRED";
        case FDN_BLOCKED:
            return "FDN_BLOCKED";
        case CS_RESTRICTED:
            return "CS_RESTRICTED";
        case CS_RESTRICTED_NORMAL:
            return "CS_RESTRICTED_NORMAL";
        case CS_RESTRICTED_EMERGENCY:
            return "CS_RESTRICTED_EMERGENCY";
        case UNOBTAINABLE_NUMBER:
            return "UNOBTAINABLE_NUMBER";
        case CDMA_LOCKED_UNTIL_POWER_CYCLE:
            return "CDMA_LOCKED_UNTIL_POWER_CYCLE";
        case CDMA_DROP:
            return "CDMA_DROP";
        case CDMA_INTERCEPT:
            return "CDMA_INTERCEPT";
        case CDMA_REORDER:
            return "CDMA_REORDER";
        case CDMA_SO_REJECT:
            return "CDMA_SO_REJECT";
        case CDMA_RETRY_ORDER:
            return "CDMA_RETRY_ORDER";
        case CDMA_ACCESS_FAILURE:
            return "CDMA_ACCESS_FAILURE";
        case CDMA_PREEMPTED:
            return "CDMA_PREEMPTED";
        case CDMA_NOT_EMERGENCY:
            return "CDMA_NOT_EMERGENCY";
        case CDMA_ACCESS_BLOCKED:
            return "CDMA_ACCESS_BLOCKED";
        case EMERGENCY_ONLY:
            return "EMERGENCY_ONLY";
        case NO_PHONE_NUMBER_SUPPLIED:
            return "NO_PHONE_NUMBER_SUPPLIED";
        case DIALED_MMI:
            return "DIALED_MMI";
        case VOICEMAIL_NUMBER_MISSING:
            return "VOICEMAIL_NUMBER_MISSING";
        case CDMA_CALL_LOST:
            return "CDMA_CALL_LOST";
        case EXITED_ECM:
            return "EXITED_ECM";
        case DIAL_MODIFIED_TO_USSD:
            return "DIAL_MODIFIED_TO_USSD";
        case DIAL_MODIFIED_TO_SS:
            return "DIAL_MODIFIED_TO_SS";
        case DIAL_MODIFIED_TO_DIAL:
            return "DIAL_MODIFIED_TO_DIAL";
        case ERROR_UNSPECIFIED:
            return "ERROR_UNSPECIFIED";
        case OUTGOING_FAILURE:
            return "OUTGOING_FAILURE";
        case OUTGOING_CANCELED:
            return "OUTGOING_CANCELED";
        case IMS_MERGED_SUCCESSFULLY:
            return "IMS_MERGED_SUCCESSFULLY";
        default:
            return "INVALID: " + cause;
    }
}
------------------------
Find a silently evolved API code:android.telephony.SubscriptionManager.allDefaultsSelected:COMMENT
<android.telephony.SubscriptionManager: boolean allDefaultsSelected()>
public      static      hidden      ->public      hidden      
Method Modifier: public      static      hidden      
Method Modifier: Yes         Yes         Yes         
Method Updated:  Yes         No          Yes         
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (getDefaultDataSubId() == INVALID_SUB_ID) {
        return false;
    }
    if (getDefaultSmsSubId() == INVALID_SUB_ID) {
        return false;
    }
    if (getDefaultVoiceSubId() == INVALID_SUB_ID) {
        return false;
    }
    return true;
}
Body of Second Method:
{
    if (!isValidSubscriptionId(getDefaultDataSubId())) {
        return false;
    }
    if (!isValidSubscriptionId(getDefaultSmsSubId())) {
        return false;
    }
    if (!isValidSubscriptionId(getDefaultVoiceSubId())) {
        return false;
    }
    return true;
}
------------------------
Find a silently evolved API code:android.webkit.WebSettings.getDomStorageEnabled:COMMENT
<android.webkit.WebSettings: boolean getDomStorageEnabled()>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Gets whether the DOM Storage APIs are enabled.
 *
 * @return true if the DOM Storage APIs are enabled
 * @see #setDomStorageEnabled
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.webkit.WebView.setPictureListener:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * Sets the Picture listener. This is an interface used to receive
 * notifications of a new Picture.
 *
 * @param listener an implementation of WebView.PictureListener
 * @deprecated This method is now obsolete.
 */

Body of Frist Method:
{
    checkThread();
    if (DebugFlags.TRACE_API)
        Log.d(LOGTAG, "setPictureListener=" + listener);
    mProvider.setPictureListener(listener);
}
Body of Second Method:
{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, "setPictureListener=" + listener);
    mProvider.setPictureListener(listener);
}
------------------------
Find a silently evolved API code:android.telephony.SubscriptionManager.isValidPhoneId:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    // value is invalid.
    return phoneId != INVALID_PHONE_ID && phoneId >= 0 && phoneId < TelephonyManager.getDefault().getPhoneCount();
}
Body of Second Method:
{
    return phoneId >= 0 && phoneId < TelephonyManager.getDefault().getPhoneCount();
}
------------------------
Find a silently evolved API code:android.media.session.MediaSession.notifyRemoteVolumeChanged:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Notify the system that the remote volume changed.
 *
 * @param provider The provider that is handling volume changes.
 * @hide
 */

Body of Frist Method:
{
    if (provider == null || provider != mVolumeProvider) {
        Log.w(TAG, "Received update from stale volume provider");
        return;
    }
    try {
        mBinder.setCurrentVolume(provider.getCurrentVolume());
    } catch (RemoteException e) {
        Log.e(TAG, "Error in notifyVolumeChanged", e);
    }
}
Body of Second Method:
{
    synchronized (mLock) {
        if (provider == null || provider != mVolumeProvider) {
            Log.w(TAG, "Received update from stale volume provider");
            return;
        }
    }
    try {
        mBinder.setCurrentVolume(provider.getCurrentVolume());
    } catch (RemoteException e) {
        Log.e(TAG, "Error in notifyVolumeChanged", e);
    }
}
------------------------
Find a silently evolved API code:android.view.Surface.unlockCanvasAndPost:COMMENT
Method Modifier: public      
Comment:/**
 * Posts the new contents of the {@link Canvas} to the surface and
 * releases the {@link Canvas}.
 *
 * @param canvas The canvas previously obtained from {@link #lockCanvas}.
 */

Body of Frist Method:
{
    if (canvas != mCanvas) {
        throw new IllegalArgumentException("canvas object must be the same instance that " + "was previously returned by lockCanvas");
    }
    synchronized (mLock) {
        checkNotReleasedLocked();
        if (mNativeObject != mLockedObject) {
            Log.w(TAG, "WARNING: Surface's mNativeObject (0x" + Long.toHexString(mNativeObject) + ") != mLockedObject (0x" + Long.toHexString(mLockedObject) + ")");
        }
        if (mLockedObject == 0) {
            throw new IllegalStateException("Surface was not locked");
        }
        try {
            nativeUnlockCanvasAndPost(mLockedObject, canvas);
        } finally {
            nativeRelease(mLockedObject);
            mLockedObject = 0;
        }
    }
}
Body of Second Method:
{
    synchronized (mLock) {
        checkNotReleasedLocked();
        if (mHwuiContext != null) {
            mHwuiContext.unlockAndPost(canvas);
        } else {
            unlockSwCanvasAndPost(canvas);
        }
    }
}
------------------------
Find a silently evolved API code:android.widget.ImageView.setImageResource:COMMENT
Method Modifier: public      
Comment:/**
 * Sets a drawable as the content of this ImageView.
 *
 * <p class="note">This does Bitmap reading and decoding on the UI
 * thread, which can cause a latency hiccup.  If that's a concern,
 * consider using {@link #setImageDrawable(android.graphics.drawable.Drawable)} or
 * {@link #setImageBitmap(android.graphics.Bitmap)} and
 * {@link android.graphics.BitmapFactory} instead.</p>
 *
 * @param resId the resource identifier of the drawable
 *
 * @attr ref android.R.styleable#ImageView_src
 */

Body of Frist Method:
{
    if (mUri != null || mResource != resId) {
        final int oldWidth = mDrawableWidth;
        final int oldHeight = mDrawableHeight;
        updateDrawable(null);
        mResource = resId;
        mUri = null;
        resolveUri();
        if (oldWidth != mDrawableWidth || oldHeight != mDrawableHeight) {
            requestLayout();
        }
        invalidate();
    }
}
Body of Second Method:
{
    // The resource configuration may have changed, so we should always
    // try to load the resource even if the resId hasn't changed.
    final int oldWidth = mDrawableWidth;
    final int oldHeight = mDrawableHeight;
    updateDrawable(null);
    mResource = resId;
    mUri = null;
    resolveUri();
    if (oldWidth != mDrawableWidth || oldHeight != mDrawableHeight) {
        requestLayout();
    }
    invalidate();
}
------------------------
Find a silently evolved API code:android.widget.SearchView.onActionViewExpanded:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (mExpandedInActionView)
        return;
    mExpandedInActionView = true;
    mCollapsedImeOptions = mQueryTextView.getImeOptions();
    mQueryTextView.setImeOptions(mCollapsedImeOptions | EditorInfo.IME_FLAG_NO_FULLSCREEN);
    mQueryTextView.setText("");
    setIconified(false);
}
Body of Second Method:
{
    if (mExpandedInActionView)
        return;
    mExpandedInActionView = true;
    mCollapsedImeOptions = mSearchSrcTextView.getImeOptions();
    mSearchSrcTextView.setImeOptions(mCollapsedImeOptions | EditorInfo.IME_FLAG_NO_FULLSCREEN);
    mSearchSrcTextView.setText("");
    setIconified(false);
}
------------------------
Find a silently evolved API code:android.provider.DocumentsProvider.call:COMMENT
Method Modifier: public      
Comment:/**
 * Implementation is provided by the parent class. Can be overridden to
 * provide additional functionality, but subclasses <em>must</em> always
 * call the superclass. If the superclass returns {@code null}, the subclass
 * may implement custom behavior.
 */

Body of Frist Method:
{
    if (!method.startsWith("android:")) {
        // Ignore non-platform methods
        return super.call(method, arg, extras);
    }
    final Context context = getContext();
    final Uri documentUri = extras.getParcelable(DocumentsContract.EXTRA_URI);
    final String authority = documentUri.getAuthority();
    final String documentId = DocumentsContract.getDocumentId(documentUri);
    if (!mAuthority.equals(authority)) {
        throw new SecurityException("Requested authority " + authority + " doesn't match provider " + mAuthority);
    }
    enforceTree(documentUri);
    final Bundle out = new Bundle();
    try {
        if (METHOD_CREATE_DOCUMENT.equals(method)) {
            enforceWritePermissionInner(documentUri);
            final String mimeType = extras.getString(Document.COLUMN_MIME_TYPE);
            final String displayName = extras.getString(Document.COLUMN_DISPLAY_NAME);
            final String newDocumentId = createDocument(documentId, mimeType, displayName);
            // No need to issue new grants here, since caller either has
            // manage permission or a prefix grant. We might generate a
            // tree style URI if that's how they called us.
            final Uri newDocumentUri = buildDocumentUriMaybeUsingTree(documentUri, newDocumentId);
            out.putParcelable(DocumentsContract.EXTRA_URI, newDocumentUri);
        } else if (METHOD_RENAME_DOCUMENT.equals(method)) {
            enforceWritePermissionInner(documentUri);
            final String displayName = extras.getString(Document.COLUMN_DISPLAY_NAME);
            final String newDocumentId = renameDocument(documentId, displayName);
            if (newDocumentId != null) {
                final Uri newDocumentUri = buildDocumentUriMaybeUsingTree(documentUri, newDocumentId);
                // narrow grant for the newly renamed document.
                if (!isTreeUri(newDocumentUri)) {
                    final int modeFlags = getCallingOrSelfUriPermissionModeFlags(context, documentUri);
                    context.grantUriPermission(getCallingPackage(), newDocumentUri, modeFlags);
                }
                out.putParcelable(DocumentsContract.EXTRA_URI, newDocumentUri);
                // Original document no longer exists, clean up any grants
                revokeDocumentPermission(documentId);
            }
        } else if (METHOD_DELETE_DOCUMENT.equals(method)) {
            enforceWritePermissionInner(documentUri);
            deleteDocument(documentId);
            // Document no longer exists, clean up any grants
            revokeDocumentPermission(documentId);
        } else {
            throw new UnsupportedOperationException("Method not supported " + method);
        }
    } catch (FileNotFoundException e) {
        throw new IllegalStateException("Failed call " + method, e);
    }
    return out;
}
Body of Second Method:
{
    if (!method.startsWith("android:")) {
        // Ignore non-platform methods
        return super.call(method, arg, extras);
    }
    final Context context = getContext();
    final Uri documentUri = extras.getParcelable(DocumentsContract.EXTRA_URI);
    final String authority = documentUri.getAuthority();
    final String documentId = DocumentsContract.getDocumentId(documentUri);
    if (!mAuthority.equals(authority)) {
        throw new SecurityException("Requested authority " + authority + " doesn't match provider " + mAuthority);
    }
    enforceTree(documentUri);
    final Bundle out = new Bundle();
    try {
        if (METHOD_CREATE_DOCUMENT.equals(method)) {
            enforceWritePermissionInner(documentUri, null);
            final String mimeType = extras.getString(Document.COLUMN_MIME_TYPE);
            final String displayName = extras.getString(Document.COLUMN_DISPLAY_NAME);
            final String newDocumentId = createDocument(documentId, mimeType, displayName);
            // No need to issue new grants here, since caller either has
            // manage permission or a prefix grant. We might generate a
            // tree style URI if that's how they called us.
            final Uri newDocumentUri = buildDocumentUriMaybeUsingTree(documentUri, newDocumentId);
            out.putParcelable(DocumentsContract.EXTRA_URI, newDocumentUri);
        } else if (METHOD_RENAME_DOCUMENT.equals(method)) {
            enforceWritePermissionInner(documentUri, null);
            final String displayName = extras.getString(Document.COLUMN_DISPLAY_NAME);
            final String newDocumentId = renameDocument(documentId, displayName);
            if (newDocumentId != null) {
                final Uri newDocumentUri = buildDocumentUriMaybeUsingTree(documentUri, newDocumentId);
                // narrow grant for the newly renamed document.
                if (!isTreeUri(newDocumentUri)) {
                    final int modeFlags = getCallingOrSelfUriPermissionModeFlags(context, documentUri);
                    context.grantUriPermission(getCallingPackage(), newDocumentUri, modeFlags);
                }
                out.putParcelable(DocumentsContract.EXTRA_URI, newDocumentUri);
                // Original document no longer exists, clean up any grants
                revokeDocumentPermission(documentId);
            }
        } else if (METHOD_DELETE_DOCUMENT.equals(method)) {
            enforceWritePermissionInner(documentUri, null);
            deleteDocument(documentId);
            // Document no longer exists, clean up any grants
            revokeDocumentPermission(documentId);
        } else {
            throw new UnsupportedOperationException("Method not supported " + method);
        }
    } catch (FileNotFoundException e) {
        throw new IllegalStateException("Failed call " + method, e);
    }
    return out;
}
------------------------
Find a silently evolved API code:android.widget.SimpleMonthAdapter.setSelectedDay:COMMENT
Method Modifier: public      
Comment:/**
 * Updates the selected day and related parameters.
 *
 * @param day The day to highlight
 */

Body of Frist Method:
{
    if (mSelectedDay != day) {
        mSelectedDay = day;
        notifyDataSetChanged();
    }
}
Body of Second Method:
{
    mSelectedDay = day;
    notifyDataSetChanged();
}
------------------------
Find a silently evolved API code:android.webkit.WebSettings.getDatabasePath:COMMENT
<android.webkit.WebSettings: String getDatabasePath()>
public      deprecated  ->public      abstract    deprecated  
Method Modifier: public      abstract    deprecated  
Method Modifier: Yes         No          Yes         
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * Gets the path to where database storage API databases are saved.
 *
 * @return the String path to the database storage API databases
 * @see #setDatabasePath
 * @deprecated Database paths are managed by the implementation this method is obsolete.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.webkit.WebViewDatabase.clearHttpAuthUsernamePassword:COMMENT
<android.webkit.WebViewDatabase: void clearHttpAuthUsernamePassword()>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Clears any saved credentials for HTTP authentication.
 *
 * @see WebView#getHttpAuthUsernamePassword
 * @see WebView#setHttpAuthUsernamePassword
 * @see #hasHttpAuthUsernamePassword
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.webkit.WebSettings.setUserAgent:COMMENT
<android.webkit.WebSettings: void setUserAgent(int)>
public      hidden      deprecated  ->public      abstract    hidden      deprecated  
Method Modifier: public      abstract    hidden      deprecated  
Method Modifier: Yes         No          Yes         Yes         
Method Updated:  Yes         Yes         Yes         Yes         
Comment:/**
 * Sets the user-agent string using an integer code.
 * <ul>
 * <li>0 means the WebView should use an Android user-agent string</li>
 * <li>1 means the WebView should use a desktop user-agent string</li>
 * </ul>
 * Other values are ignored. The default is an Android user-agent string,
 * i.e. code value 0.
 *
 * @param ua the integer code for the user-agent string
 * @deprecated Please use {@link #setUserAgentString} instead.
 * @hide Since API level {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1}
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.webkit.WebBackForwardList.getSize:COMMENT
<android.webkit.WebBackForwardList: int getSize()>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Get the total size of the back/forward list.
 * @return The size of the list.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.view.ViewTreeObserver.merge:COMMENT
Method Modifier: default     
Comment:/**
 * Merges all the listeners registered on the specified observer with the listeners
 * registered on this object. After this method is invoked, the specified observer
 * will return false in {@link #isAlive()} and should not be used anymore.
 *
 * @param observer The ViewTreeObserver whose listeners must be added to this observer
 */

Body of Frist Method:
{
    if (observer.mOnWindowAttachListeners != null) {
        if (mOnWindowAttachListeners != null) {
            mOnWindowAttachListeners.addAll(observer.mOnWindowAttachListeners);
        } else {
            mOnWindowAttachListeners = observer.mOnWindowAttachListeners;
        }
    }
    if (observer.mOnWindowFocusListeners != null) {
        if (mOnWindowFocusListeners != null) {
            mOnWindowFocusListeners.addAll(observer.mOnWindowFocusListeners);
        } else {
            mOnWindowFocusListeners = observer.mOnWindowFocusListeners;
        }
    }
    if (observer.mOnGlobalFocusListeners != null) {
        if (mOnGlobalFocusListeners != null) {
            mOnGlobalFocusListeners.addAll(observer.mOnGlobalFocusListeners);
        } else {
            mOnGlobalFocusListeners = observer.mOnGlobalFocusListeners;
        }
    }
    if (observer.mOnGlobalLayoutListeners != null) {
        if (mOnGlobalLayoutListeners != null) {
            mOnGlobalLayoutListeners.addAll(observer.mOnGlobalLayoutListeners);
        } else {
            mOnGlobalLayoutListeners = observer.mOnGlobalLayoutListeners;
        }
    }
    if (observer.mOnPreDrawListeners != null) {
        if (mOnPreDrawListeners != null) {
            mOnPreDrawListeners.addAll(observer.mOnPreDrawListeners);
        } else {
            mOnPreDrawListeners = observer.mOnPreDrawListeners;
        }
    }
    if (observer.mOnTouchModeChangeListeners != null) {
        if (mOnTouchModeChangeListeners != null) {
            mOnTouchModeChangeListeners.addAll(observer.mOnTouchModeChangeListeners);
        } else {
            mOnTouchModeChangeListeners = observer.mOnTouchModeChangeListeners;
        }
    }
    if (observer.mOnComputeInternalInsetsListeners != null) {
        if (mOnComputeInternalInsetsListeners != null) {
            mOnComputeInternalInsetsListeners.addAll(observer.mOnComputeInternalInsetsListeners);
        } else {
            mOnComputeInternalInsetsListeners = observer.mOnComputeInternalInsetsListeners;
        }
    }
    if (observer.mOnScrollChangedListeners != null) {
        if (mOnScrollChangedListeners != null) {
            mOnScrollChangedListeners.addAll(observer.mOnScrollChangedListeners);
        } else {
            mOnScrollChangedListeners = observer.mOnScrollChangedListeners;
        }
    }
    observer.kill();
}
Body of Second Method:
{
    if (observer.mOnWindowAttachListeners != null) {
        if (mOnWindowAttachListeners != null) {
            mOnWindowAttachListeners.addAll(observer.mOnWindowAttachListeners);
        } else {
            mOnWindowAttachListeners = observer.mOnWindowAttachListeners;
        }
    }
    if (observer.mOnWindowFocusListeners != null) {
        if (mOnWindowFocusListeners != null) {
            mOnWindowFocusListeners.addAll(observer.mOnWindowFocusListeners);
        } else {
            mOnWindowFocusListeners = observer.mOnWindowFocusListeners;
        }
    }
    if (observer.mOnGlobalFocusListeners != null) {
        if (mOnGlobalFocusListeners != null) {
            mOnGlobalFocusListeners.addAll(observer.mOnGlobalFocusListeners);
        } else {
            mOnGlobalFocusListeners = observer.mOnGlobalFocusListeners;
        }
    }
    if (observer.mOnGlobalLayoutListeners != null) {
        if (mOnGlobalLayoutListeners != null) {
            mOnGlobalLayoutListeners.addAll(observer.mOnGlobalLayoutListeners);
        } else {
            mOnGlobalLayoutListeners = observer.mOnGlobalLayoutListeners;
        }
    }
    if (observer.mOnPreDrawListeners != null) {
        if (mOnPreDrawListeners != null) {
            mOnPreDrawListeners.addAll(observer.mOnPreDrawListeners);
        } else {
            mOnPreDrawListeners = observer.mOnPreDrawListeners;
        }
    }
    if (observer.mOnTouchModeChangeListeners != null) {
        if (mOnTouchModeChangeListeners != null) {
            mOnTouchModeChangeListeners.addAll(observer.mOnTouchModeChangeListeners);
        } else {
            mOnTouchModeChangeListeners = observer.mOnTouchModeChangeListeners;
        }
    }
    if (observer.mOnComputeInternalInsetsListeners != null) {
        if (mOnComputeInternalInsetsListeners != null) {
            mOnComputeInternalInsetsListeners.addAll(observer.mOnComputeInternalInsetsListeners);
        } else {
            mOnComputeInternalInsetsListeners = observer.mOnComputeInternalInsetsListeners;
        }
    }
    if (observer.mOnScrollChangedListeners != null) {
        if (mOnScrollChangedListeners != null) {
            mOnScrollChangedListeners.addAll(observer.mOnScrollChangedListeners);
        } else {
            mOnScrollChangedListeners = observer.mOnScrollChangedListeners;
        }
    }
    if (observer.mOnWindowShownListeners != null) {
        if (mOnWindowShownListeners != null) {
            mOnWindowShownListeners.addAll(observer.mOnWindowShownListeners);
        } else {
            mOnWindowShownListeners = observer.mOnWindowShownListeners;
        }
    }
    observer.kill();
}
------------------------
Find a silently evolved API code:android.webkit.WebSettings.getDisplayZoomControls:COMMENT
<android.webkit.WebSettings: boolean getDisplayZoomControls()>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Gets whether the WebView displays on-screen zoom controls when using
 * the built-in zoom mechanisms.
 *
 * @return true if the WebView displays on-screen zoom controls when using
 * the built-in zoom mechanisms
 * @see #setDisplayZoomControls
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.widget.TextClock.is24HourModeEnabled:COMMENT
Method Modifier: public      
Comment:/**
 * Indicates whether the system is currently using the 24-hour mode.
 *
 * When the system is in 24-hour mode, this view will use the pattern
 * returned by {@link #getFormat24Hour()}. In 12-hour mode, the pattern
 * returned by {@link #getFormat12Hour()} is used instead.
 *
 * If either one of the formats is null, the other format is used. If
 * both formats are null, the default formats for the current locale are used.
 *
 * @return true if time should be displayed in 24-hour format, false if it
 * should be displayed in 12-hour format.
 *
 * @see #setFormat12Hour(CharSequence)
 * @see #getFormat12Hour()
 * @see #setFormat24Hour(CharSequence)
 * @see #getFormat24Hour()
 */

Body of Frist Method:
{
    return DateFormat.is24HourFormat(getContext());
}
Body of Second Method:
{
    if (mShowCurrentUserTime) {
        return DateFormat.is24HourFormat(getContext(), ActivityManager.getCurrentUser());
    } else {
        return DateFormat.is24HourFormat(getContext());
    }
}
------------------------
Find a silently evolved API code:android.media.AudioManager.isValidRingerMode:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Checks valid ringer mode values.
 *
 * @return true if the ringer mode indicated is valid, false otherwise.
 *
 * @see #setRingerMode(int)
 * @hide
 */

Body of Frist Method:
{
    if (ringerMode < 0 || ringerMode > RINGER_MODE_MAX) {
        return false;
    }
    return true;
}
Body of Second Method:
{
    if (ringerMode < 0 || ringerMode > RINGER_MODE_MAX) {
        return false;
    }
    IAudioService service = getService();
    try {
        return service.isValidRingerMode(ringerMode);
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in isValidRingerMode", e);
        return false;
    }
}
------------------------
Find a silently evolved API code:android.widget.DayPickerView.goTo:COMMENT
<android.widget.DayPickerView: boolean goTo(Calendar,boolean,boolean,boolean)>
public      ->private     
Method Modifier: public      private     
Method Modifier: Yes         No          
Method Updated:  No          Yes         
Comment:/**
 * This moves to the specified time in the view. If the time is not already
 * in range it will move the list so that the first of the month containing
 * the time is at the top of the view. If the new time is already in view
 * the list will not be scrolled unless forceScroll is true. This time may
 * optionally be highlighted as selected as well.
 *
 * @param day The day to move to
 * @param animate Whether to scroll to the given time or just redraw at the
 * new location
 * @param setSelected Whether to set the given time as selected
 * @param forceScroll Whether to recenter even if the time is already
 * visible
 * @return Whether or not the view animated to the new location
 */

Body of Frist Method:
{
    // Set the selected day
    if (setSelected) {
        mSelectedDay.setTimeInMillis(day.getTimeInMillis());
    }
    mTempDay.setTimeInMillis(day.getTimeInMillis());
    final int position = getPositionFromDay(day);
    View child;
    int i = 0;
    int top = 0;
    // Find a child that's completely in the view
    do {
        child = getChildAt(i++);
        if (child == null) {
            break;
        }
        top = child.getTop();
    } while (top < 0);
    // Compute the first and last position visible
    int selectedPosition;
    if (child != null) {
        selectedPosition = getPositionForView(child);
    } else {
        selectedPosition = 0;
    }
    if (setSelected) {
        mAdapter.setSelectedDay(mSelectedDay);
    }
    // and if so scroll to the month that contains it
    if (position != selectedPosition || forceScroll) {
        setMonthDisplayed(mTempDay);
        mPreviousScrollState = OnScrollListener.SCROLL_STATE_FLING;
        if (animate) {
            smoothScrollToPositionFromTop(position, LIST_TOP_OFFSET, GOTO_SCROLL_DURATION);
            return true;
        } else {
            postSetSelection(position);
        }
    } else if (setSelected) {
        setMonthDisplayed(mSelectedDay);
    }
    return false;
}
Body of Second Method:
{
    // Set the selected day
    if (setSelected) {
        mSelectedDay.setTimeInMillis(day);
    }
    mTempDay.setTimeInMillis(day);
    final int position = getPositionFromDay(day);
    View child;
    int i = 0;
    int top = 0;
    // Find a child that's completely in the view
    do {
        child = getChildAt(i++);
        if (child == null) {
            break;
        }
        top = child.getTop();
    } while (top < 0);
    // Compute the first and last position visible
    int selectedPosition;
    if (child != null) {
        selectedPosition = getPositionForView(child);
    } else {
        selectedPosition = 0;
    }
    if (setSelected) {
        mAdapter.setSelectedDay(mSelectedDay);
    }
    // and if so scroll to the month that contains it
    if (position != selectedPosition || forceScroll) {
        setMonthDisplayed(mTempDay);
        mPreviousScrollState = OnScrollListener.SCROLL_STATE_FLING;
        if (animate) {
            smoothScrollToPositionFromTop(position, LIST_TOP_OFFSET, GOTO_SCROLL_DURATION);
            return true;
        } else {
            postSetSelection(position);
        }
    } else if (setSelected) {
        setMonthDisplayed(mSelectedDay);
    }
    return false;
}
------------------------
Find a silently evolved API code:android.webkit.WebIconDatabase.close:COMMENT
<android.webkit.WebIconDatabase: void close()>
public      deprecated  ->public      abstract    deprecated  
Method Modifier: public      abstract    deprecated  
Method Modifier: Yes         No          Yes         
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * Close the shared instance of the icon database.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.provider.Settings.Secure.setLocationModeForUser:COMMENT
Method Modifier: private     static      final       
Comment:/**
 * Thread-safe method for setting the location mode to one of
 * {@link #LOCATION_MODE_HIGH_ACCURACY}, {@link #LOCATION_MODE_SENSORS_ONLY},
 * {@link #LOCATION_MODE_BATTERY_SAVING}, or {@link #LOCATION_MODE_OFF}.
 *
 * @param cr the content resolver to use
 * @param mode such as {@link #LOCATION_MODE_HIGH_ACCURACY}
 * @param userId the userId for which to change mode
 * @return true if the value was set, false on database errors
 *
 * @throws IllegalArgumentException if mode is not one of the supported values
 */

Body of Frist Method:
{
    synchronized (mLocationSettingsLock) {
        boolean gps = false;
        boolean network = false;
        switch(mode) {
            case LOCATION_MODE_OFF:
                break;
            case LOCATION_MODE_SENSORS_ONLY:
                gps = true;
                break;
            case LOCATION_MODE_BATTERY_SAVING:
                network = true;
                break;
            case LOCATION_MODE_HIGH_ACCURACY:
                gps = true;
                network = true;
                break;
            default:
                throw new IllegalArgumentException("Invalid location mode: " + mode);
        }
        boolean gpsSuccess = Settings.Secure.setLocationProviderEnabledForUser(cr, LocationManager.GPS_PROVIDER, gps, userId);
        boolean nlpSuccess = Settings.Secure.setLocationProviderEnabledForUser(cr, LocationManager.NETWORK_PROVIDER, network, userId);
        return gpsSuccess && nlpSuccess;
    }
}
Body of Second Method:
{
    synchronized (mLocationSettingsLock) {
        boolean gps = false;
        boolean network = false;
        switch(mode) {
            case LOCATION_MODE_OFF:
                break;
            case LOCATION_MODE_SENSORS_ONLY:
                gps = true;
                break;
            case LOCATION_MODE_BATTERY_SAVING:
                network = true;
                break;
            case LOCATION_MODE_HIGH_ACCURACY:
                gps = true;
                network = true;
                break;
            default:
                throw new IllegalArgumentException("Invalid location mode: " + mode);
        }
        // Note it's important that we set the NLP mode first. The Google implementation
        // of NLP clears its NLP consent setting any time it receives a
        // LocationManager.PROVIDERS_CHANGED_ACTION broadcast and NLP is disabled. Also,
        // it shows an NLP consent dialog any time it receives the broadcast, NLP is
        // enabled, and the NLP consent is not set. If 1) we were to enable GPS first,
        // 2) a setup wizard has its own NLP consent UI that sets the NLP consent setting,
        // and 3) the receiver happened to complete before we enabled NLP, then the Google
        // NLP would detect the attempt to enable NLP and show a redundant NLP consent
        // dialog. Then the people who wrote the setup wizard would be sad.
        boolean nlpSuccess = Settings.Secure.setLocationProviderEnabledForUser(cr, LocationManager.NETWORK_PROVIDER, network, userId);
        boolean gpsSuccess = Settings.Secure.setLocationProviderEnabledForUser(cr, LocationManager.GPS_PROVIDER, gps, userId);
        return gpsSuccess && nlpSuccess;
    }
}
------------------------
Find a silently evolved API code:android.view.accessibility.AccessibilityNodeInfo.clear:COMMENT
Method Modifier: private     
Comment:/**
 * Clears the state of this instance.
 */

Body of Frist Method:
{
    mSealed = false;
    mSourceNodeId = ROOT_NODE_ID;
    mParentNodeId = ROOT_NODE_ID;
    mLabelForId = ROOT_NODE_ID;
    mLabeledById = ROOT_NODE_ID;
    mWindowId = UNDEFINED_ITEM_ID;
    mConnectionId = UNDEFINED_CONNECTION_ID;
    mMaxTextLength = -1;
    mMovementGranularities = 0;
    if (mChildNodeIds != null) {
        mChildNodeIds.clear();
    }
    mBoundsInParent.set(0, 0, 0, 0);
    mBoundsInScreen.set(0, 0, 0, 0);
    mBooleanProperties = 0;
    mPackageName = null;
    mClassName = null;
    mText = null;
    mError = null;
    mContentDescription = null;
    mViewIdResourceName = null;
    if (mActions != null) {
        mActions.clear();
    }
    mTextSelectionStart = UNDEFINED_SELECTION_INDEX;
    mTextSelectionEnd = UNDEFINED_SELECTION_INDEX;
    mInputType = InputType.TYPE_NULL;
    mLiveRegion = View.ACCESSIBILITY_LIVE_REGION_NONE;
    if (mExtras != null) {
        mExtras.clear();
    }
    if (mRangeInfo != null) {
        mRangeInfo.recycle();
        mRangeInfo = null;
    }
    if (mCollectionInfo != null) {
        mCollectionInfo.recycle();
        mCollectionInfo = null;
    }
    if (mCollectionItemInfo != null) {
        mCollectionItemInfo.recycle();
        mCollectionItemInfo = null;
    }
}
Body of Second Method:
{
    mSealed = false;
    mSourceNodeId = ROOT_NODE_ID;
    mParentNodeId = ROOT_NODE_ID;
    mLabelForId = ROOT_NODE_ID;
    mLabeledById = ROOT_NODE_ID;
    mTraversalBefore = ROOT_NODE_ID;
    mTraversalAfter = ROOT_NODE_ID;
    mWindowId = UNDEFINED_ITEM_ID;
    mConnectionId = UNDEFINED_CONNECTION_ID;
    mMaxTextLength = -1;
    mMovementGranularities = 0;
    if (mChildNodeIds != null) {
        mChildNodeIds.clear();
    }
    mBoundsInParent.set(0, 0, 0, 0);
    mBoundsInScreen.set(0, 0, 0, 0);
    mBooleanProperties = 0;
    mPackageName = null;
    mClassName = null;
    mText = null;
    mError = null;
    mContentDescription = null;
    mViewIdResourceName = null;
    if (mActions != null) {
        mActions.clear();
    }
    mTextSelectionStart = UNDEFINED_SELECTION_INDEX;
    mTextSelectionEnd = UNDEFINED_SELECTION_INDEX;
    mInputType = InputType.TYPE_NULL;
    mLiveRegion = View.ACCESSIBILITY_LIVE_REGION_NONE;
    if (mExtras != null) {
        mExtras.clear();
    }
    if (mRangeInfo != null) {
        mRangeInfo.recycle();
        mRangeInfo = null;
    }
    if (mCollectionInfo != null) {
        mCollectionInfo.recycle();
        mCollectionInfo = null;
    }
    if (mCollectionItemInfo != null) {
        mCollectionItemInfo.recycle();
        mCollectionItemInfo = null;
    }
}
------------------------
Find a silently evolved API code:android.webkit.WebSettings.getLoadWithOverviewMode:COMMENT
<android.webkit.WebSettings: boolean getLoadWithOverviewMode()>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Gets whether this WebView loads pages in overview mode.
 *
 * @return whether this WebView loads pages in overview mode
 * @see #setLoadWithOverviewMode
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.webkit.WebSettings.setAppCachePath:COMMENT
<android.webkit.WebSettings: void setAppCachePath(String)>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Sets the path to the Application Caches files. In order for the
 * Application Caches API to be enabled, this method must be called with a
 * path to which the application can write. This method should only be
 * called once: repeated calls are ignored.
 *
 * @param appCachePath a String path to the directory containing
 * Application Caches files.
 * @see #setAppCacheEnabled
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.webkit.WebSettings.getFantasyFontFamily:COMMENT
<android.webkit.WebSettings: String getFantasyFontFamily()>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Gets the fantasy font family name.
 *
 * @return the fantasy font family name as a string
 * @see #setFantasyFontFamily
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.app.Dialog.closeOptionsMenu:COMMENT
Method Modifier: public      
Comment:/**
 * @see Activity#closeOptionsMenu()
 */

Body of Frist Method:
{
    mWindow.closePanel(Window.FEATURE_OPTIONS_PANEL);
}
Body of Second Method:
{
    if (mWindow.hasFeature(Window.FEATURE_OPTIONS_PANEL)) {
        mWindow.closePanel(Window.FEATURE_OPTIONS_PANEL);
    }
}
------------------------
Find a silently evolved API code:android.media.AudioManager.handleKeyDown:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    int keyCode = event.getKeyCode();
    switch(keyCode) {
        case KeyEvent.KEYCODE_VOLUME_UP:
        case KeyEvent.KEYCODE_VOLUME_DOWN:
            /*
                 * Adjust the volume in on key down since it is more
                 * responsive to the user.
                 */
            int flags = FLAG_SHOW_UI | FLAG_VIBRATE;
            if (mUseMasterVolume) {
                adjustMasterVolume(keyCode == KeyEvent.KEYCODE_VOLUME_UP ? ADJUST_RAISE : ADJUST_LOWER, flags);
            } else {
                adjustSuggestedStreamVolume(keyCode == KeyEvent.KEYCODE_VOLUME_UP ? ADJUST_RAISE : ADJUST_LOWER, stream, flags);
            }
            break;
        case KeyEvent.KEYCODE_VOLUME_MUTE:
            if (event.getRepeatCount() == 0) {
                if (mUseMasterVolume) {
                    setMasterMute(!isMasterMute());
                } else {
                // TODO: Actually handle MUTE.
                }
            }
            break;
    }
}
Body of Second Method:
{
    int keyCode = event.getKeyCode();
    switch(keyCode) {
        case KeyEvent.KEYCODE_VOLUME_UP:
        case KeyEvent.KEYCODE_VOLUME_DOWN:
            /*
                 * Adjust the volume in on key down since it is more
                 * responsive to the user.
                 */
            int flags = FLAG_SHOW_UI | FLAG_VIBRATE;
            if (mUseMasterVolume) {
                adjustMasterVolume(keyCode == KeyEvent.KEYCODE_VOLUME_UP ? ADJUST_RAISE : ADJUST_LOWER, flags);
            } else {
                adjustSuggestedStreamVolume(keyCode == KeyEvent.KEYCODE_VOLUME_UP ? ADJUST_RAISE : ADJUST_LOWER, stream, flags);
            }
            break;
        case KeyEvent.KEYCODE_VOLUME_MUTE:
            if (event.getRepeatCount() == 0) {
                MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(event, false);
            }
            break;
    }
}
------------------------
Find a silently evolved API code:android.graphics.drawable.InsetDrawable.getHotspotBounds:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    mInsetState.mDrawable.getHotspotBounds(outRect);
}
Body of Second Method:
{
    mState.mDrawable.getHotspotBounds(outRect);
}
------------------------
Find a silently evolved API code:android.media.MediaCodecInfo.VideoCapabilities.supportsFormat:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 * @throws java.lang.ClassCastException
 */

Body of Frist Method:
{
    final Map<String, Object> map = format.getMap();
    Integer width = (Integer) map.get(MediaFormat.KEY_WIDTH);
    Integer height = (Integer) map.get(MediaFormat.KEY_HEIGHT);
    Double rate = (Double) map.get(MediaFormat.KEY_FRAME_RATE);
    return supports(width, height, rate);
}
Body of Second Method:
{
    final Map<String, Object> map = format.getMap();
    Integer width = (Integer) map.get(MediaFormat.KEY_WIDTH);
    Integer height = (Integer) map.get(MediaFormat.KEY_HEIGHT);
    Number rate = (Number) map.get(MediaFormat.KEY_FRAME_RATE);
    return supports(width, height, rate);
}
------------------------
Find a silently evolved API code:android.webkit.WebSettings.getUseWebViewBackgroundForOverscrollBackground:COMMENT
<android.webkit.WebSettings: boolean getUseWebViewBackgroundForOverscrollBackground()>
public      hidden      deprecated  ->public      abstract    hidden      deprecated  
Method Modifier: public      abstract    hidden      deprecated  
Method Modifier: Yes         No          Yes         Yes         
Method Updated:  Yes         Yes         Yes         Yes         
Comment:/**
 * Gets whether this WebView uses WebView's background instead of
 * internal pattern for over scroll background.
 *
 * @see #setUseWebViewBackgroundForOverscrollBackground
 * @deprecated This method is now obsolete.
 * @hide Since API level {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1}
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.telephony.SignalStrength.getLteLevel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get LTE as level 0..4
 *
 * @hide
 */

Body of Frist Method:
{
    /*
         * TS 36.214 Physical Layer Section 5.1.3 TS 36.331 RRC RSSI = received
         * signal + noise RSRP = reference signal dBm RSRQ = quality of signal
         * dB= Number of Resource blocksxRSRP/RSSI SNR = gain=signal/noise ratio
         * = -10log P1/P2 dB
         */
    int rssiIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN, rsrpIconLevel = -1, snrIconLevel = -1;
    if (mLteRsrp > -44)
        rsrpIconLevel = -1;
    else if (mLteRsrp >= -85)
        rsrpIconLevel = SIGNAL_STRENGTH_GREAT;
    else if (mLteRsrp >= -95)
        rsrpIconLevel = SIGNAL_STRENGTH_GOOD;
    else if (mLteRsrp >= -105)
        rsrpIconLevel = SIGNAL_STRENGTH_MODERATE;
    else if (mLteRsrp >= -115)
        rsrpIconLevel = SIGNAL_STRENGTH_POOR;
    else if (mLteRsrp >= -140)
        rsrpIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    /*
         * Values are -200 dB to +300 (SNR*10dB) RS_SNR >= 13.0 dB =>4 bars 4.5
         * dB <= RS_SNR < 13.0 dB => 3 bars 1.0 dB <= RS_SNR < 4.5 dB => 2 bars
         * -3.0 dB <= RS_SNR < 1.0 dB 1 bar RS_SNR < -3.0 dB/No Service Antenna
         * Icon Only
         */
    if (mLteRssnr > 300)
        snrIconLevel = -1;
    else if (mLteRssnr >= 130)
        snrIconLevel = SIGNAL_STRENGTH_GREAT;
    else if (mLteRssnr >= 45)
        snrIconLevel = SIGNAL_STRENGTH_GOOD;
    else if (mLteRssnr >= 10)
        snrIconLevel = SIGNAL_STRENGTH_MODERATE;
    else if (mLteRssnr >= -30)
        snrIconLevel = SIGNAL_STRENGTH_POOR;
    else if (mLteRssnr >= -200)
        snrIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    if (DBG)
        log("getLTELevel - rsrp:" + mLteRsrp + " snr:" + mLteRssnr + " rsrpIconLevel:" + rsrpIconLevel + " snrIconLevel:" + snrIconLevel);
    /* Choose a measurement type to use for notification */
    if (snrIconLevel != -1 && rsrpIconLevel != -1) {
        /*
             * The number of bars displayed shall be the smaller of the bars
             * associated with LTE RSRP and the bars associated with the LTE
             * RS_SNR
             */
        return (rsrpIconLevel < snrIconLevel ? rsrpIconLevel : snrIconLevel);
    }
    if (snrIconLevel != -1)
        return snrIconLevel;
    if (rsrpIconLevel != -1)
        return rsrpIconLevel;
    /* Valid values are (0-63, 99) as defined in TS 36.331 */
    if (mLteSignalStrength > 63)
        rssiIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    else if (mLteSignalStrength >= 12)
        rssiIconLevel = SIGNAL_STRENGTH_GREAT;
    else if (mLteSignalStrength >= 8)
        rssiIconLevel = SIGNAL_STRENGTH_GOOD;
    else if (mLteSignalStrength >= 5)
        rssiIconLevel = SIGNAL_STRENGTH_MODERATE;
    else if (mLteSignalStrength >= 0)
        rssiIconLevel = SIGNAL_STRENGTH_POOR;
    if (DBG)
        log("getLTELevel - rssi:" + mLteSignalStrength + " rssiIconLevel:" + rssiIconLevel);
    return rssiIconLevel;
}
Body of Second Method:
{
    /*
         * TS 36.214 Physical Layer Section 5.1.3 TS 36.331 RRC RSSI = received
         * signal + noise RSRP = reference signal dBm RSRQ = quality of signal
         * dB= Number of Resource blocksxRSRP/RSSI SNR = gain=signal/noise ratio
         * = -10log P1/P2 dB
         */
    int rssiIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN, rsrpIconLevel = -1, snrIconLevel = -1;
    int rsrpThreshType = Resources.getSystem().getInteger(com.android.internal.R.integer.config_LTE_RSRP_threshold_type);
    int[] threshRsrp;
    if (rsrpThreshType == RSRP_THRESH_TYPE_STRICT) {
        threshRsrp = RSRP_THRESH_STRICT;
    } else {
        threshRsrp = RSRP_THRESH_LENIENT;
    }
    if (mLteRsrp > threshRsrp[5])
        rsrpIconLevel = -1;
    else if (mLteRsrp >= threshRsrp[4])
        rsrpIconLevel = SIGNAL_STRENGTH_GREAT;
    else if (mLteRsrp >= threshRsrp[3])
        rsrpIconLevel = SIGNAL_STRENGTH_GOOD;
    else if (mLteRsrp >= threshRsrp[2])
        rsrpIconLevel = SIGNAL_STRENGTH_MODERATE;
    else if (mLteRsrp >= threshRsrp[1])
        rsrpIconLevel = SIGNAL_STRENGTH_POOR;
    else if (mLteRsrp >= threshRsrp[0])
        rsrpIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    /*
         * Values are -200 dB to +300 (SNR*10dB) RS_SNR >= 13.0 dB =>4 bars 4.5
         * dB <= RS_SNR < 13.0 dB => 3 bars 1.0 dB <= RS_SNR < 4.5 dB => 2 bars
         * -3.0 dB <= RS_SNR < 1.0 dB 1 bar RS_SNR < -3.0 dB/No Service Antenna
         * Icon Only
         */
    if (mLteRssnr > 300)
        snrIconLevel = -1;
    else if (mLteRssnr >= 130)
        snrIconLevel = SIGNAL_STRENGTH_GREAT;
    else if (mLteRssnr >= 45)
        snrIconLevel = SIGNAL_STRENGTH_GOOD;
    else if (mLteRssnr >= 10)
        snrIconLevel = SIGNAL_STRENGTH_MODERATE;
    else if (mLteRssnr >= -30)
        snrIconLevel = SIGNAL_STRENGTH_POOR;
    else if (mLteRssnr >= -200)
        snrIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    if (DBG)
        log("getLTELevel - rsrp:" + mLteRsrp + " snr:" + mLteRssnr + " rsrpIconLevel:" + rsrpIconLevel + " snrIconLevel:" + snrIconLevel);
    /* Choose a measurement type to use for notification */
    if (snrIconLevel != -1 && rsrpIconLevel != -1) {
        /*
             * The number of bars displayed shall be the smaller of the bars
             * associated with LTE RSRP and the bars associated with the LTE
             * RS_SNR
             */
        return (rsrpIconLevel < snrIconLevel ? rsrpIconLevel : snrIconLevel);
    }
    if (snrIconLevel != -1)
        return snrIconLevel;
    if (rsrpIconLevel != -1)
        return rsrpIconLevel;
    /* Valid values are (0-63, 99) as defined in TS 36.331 */
    if (mLteSignalStrength > 63)
        rssiIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    else if (mLteSignalStrength >= 12)
        rssiIconLevel = SIGNAL_STRENGTH_GREAT;
    else if (mLteSignalStrength >= 8)
        rssiIconLevel = SIGNAL_STRENGTH_GOOD;
    else if (mLteSignalStrength >= 5)
        rssiIconLevel = SIGNAL_STRENGTH_MODERATE;
    else if (mLteSignalStrength >= 0)
        rssiIconLevel = SIGNAL_STRENGTH_POOR;
    if (DBG)
        log("getLTELevel - rssi:" + mLteSignalStrength + " rssiIconLevel:" + rssiIconLevel);
    return rssiIconLevel;
}
------------------------
Find a silently evolved API code:android.widget.SearchView.onActionViewCollapsed:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    setQuery("", false);
    clearFocus();
    updateViewsVisibility(true);
    mQueryTextView.setImeOptions(mCollapsedImeOptions);
    mExpandedInActionView = false;
}
Body of Second Method:
{
    setQuery("", false);
    clearFocus();
    updateViewsVisibility(true);
    mSearchSrcTextView.setImeOptions(mCollapsedImeOptions);
    mExpandedInActionView = false;
}
------------------------
Find a silently evolved API code:android.webkit.WebView.freeMemory:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * Informs this WebView that memory is low so that it can free any available
 * memory.
 * @deprecated Memory caches are automatically dropped when no longer needed, and in response
 * to system memory pressure.
 */

Body of Frist Method:
{
    checkThread();
    if (DebugFlags.TRACE_API)
        Log.d(LOGTAG, "freeMemory");
    mProvider.freeMemory();
}
Body of Second Method:
{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, "freeMemory");
    mProvider.freeMemory();
}
------------------------
Find a silently evolved API code:android.app.Dialog.invalidateOptionsMenu:COMMENT
Method Modifier: public      
Comment:/**
 * @see Activity#invalidateOptionsMenu()
 */

Body of Frist Method:
{
    mWindow.invalidatePanelMenu(Window.FEATURE_OPTIONS_PANEL);
}
Body of Second Method:
{
    if (mWindow.hasFeature(Window.FEATURE_OPTIONS_PANEL)) {
        mWindow.invalidatePanelMenu(Window.FEATURE_OPTIONS_PANEL);
    }
}
------------------------
Find a silently evolved API code:android.media.tv.TvInputManager.Session.getSelectedTrack:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns the selected track for a given type. Returns {@code null} if the information is
 * not available or any of the tracks for the given type is not selected.
 *
 * @return the ID of the selected track.
 * @see #selectTrack
 */

Body of Frist Method:
{
    if (type == TvTrackInfo.TYPE_AUDIO) {
        return mSelectedAudioTrackId;
    } else if (type == TvTrackInfo.TYPE_VIDEO) {
        return mSelectedVideoTrackId;
    } else if (type == TvTrackInfo.TYPE_SUBTITLE) {
        return mSelectedSubtitleTrackId;
    }
    throw new IllegalArgumentException("invalid type: " + type);
}
Body of Second Method:
{
    synchronized (mTrackLock) {
        if (type == TvTrackInfo.TYPE_AUDIO) {
            return mSelectedAudioTrackId;
        } else if (type == TvTrackInfo.TYPE_VIDEO) {
            return mSelectedVideoTrackId;
        } else if (type == TvTrackInfo.TYPE_SUBTITLE) {
            return mSelectedSubtitleTrackId;
        }
    }
    throw new IllegalArgumentException("invalid type: " + type);
}
------------------------
Find a silently evolved API code:android.text.StaticLayout.generate:COMMENT
Method Modifier: default     
Comment:/* package */

Body of Frist Method:
{
    int[] breakOpp = null;
    final String localeLanguageTag = paint.getTextLocale().toLanguageTag();
    mLineCount = 0;
    int v = 0;
    boolean needMultiply = (spacingmult != 1 || spacingadd != 0);
    Paint.FontMetricsInt fm = mFontMetricsInt;
    int[] chooseHtv = null;
    MeasuredText measured = mMeasured;
    Spanned spanned = null;
    if (source instanceof Spanned)
        spanned = (Spanned) source;
    int paraEnd;
    for (int paraStart = bufStart; paraStart <= bufEnd; paraStart = paraEnd) {
        paraEnd = TextUtils.indexOf(source, CHAR_NEW_LINE, paraStart, bufEnd);
        if (paraEnd < 0)
            paraEnd = bufEnd;
        else
            paraEnd++;
        int firstWidthLineLimit = mLineCount + 1;
        int firstWidth = outerWidth;
        int restWidth = outerWidth;
        LineHeightSpan[] chooseHt = null;
        if (spanned != null) {
            LeadingMarginSpan[] sp = getParagraphSpans(spanned, paraStart, paraEnd, LeadingMarginSpan.class);
            for (int i = 0; i < sp.length; i++) {
                LeadingMarginSpan lms = sp[i];
                firstWidth -= sp[i].getLeadingMargin(true);
                restWidth -= sp[i].getLeadingMargin(false);
                // leading margin spans, not just this particular one
                if (lms instanceof LeadingMarginSpan2) {
                    LeadingMarginSpan2 lms2 = (LeadingMarginSpan2) lms;
                    int lmsFirstLine = getLineForOffset(spanned.getSpanStart(lms2));
                    firstWidthLineLimit = Math.max(firstWidthLineLimit, lmsFirstLine + lms2.getLeadingMarginLineCount());
                }
            }
            chooseHt = getParagraphSpans(spanned, paraStart, paraEnd, LineHeightSpan.class);
            if (chooseHt.length != 0) {
                if (chooseHtv == null || chooseHtv.length < chooseHt.length) {
                    chooseHtv = ArrayUtils.newUnpaddedIntArray(chooseHt.length);
                }
                for (int i = 0; i < chooseHt.length; i++) {
                    int o = spanned.getSpanStart(chooseHt[i]);
                    if (o < paraStart) {
                        // starts in this layout, before the
                        // current paragraph
                        chooseHtv[i] = getLineTop(getLineForOffset(o));
                    } else {
                        // starts in this paragraph
                        chooseHtv[i] = v;
                    }
                }
            }
        }
        measured.setPara(source, paraStart, paraEnd, textDir);
        char[] chs = measured.mChars;
        float[] widths = measured.mWidths;
        byte[] chdirs = measured.mLevels;
        int dir = measured.mDir;
        boolean easy = measured.mEasy;
        breakOpp = nLineBreakOpportunities(localeLanguageTag, chs, paraEnd - paraStart, breakOpp);
        int breakOppIndex = 0;
        int width = firstWidth;
        float w = 0;
        // here is the offset of the starting character of the line we are currently measuring
        int here = paraStart;
        // ok is a character offset located after a word separator (space, tab, number...) where
        // we would prefer to cut the current line. Equals to here when no such break was found.
        int ok = paraStart;
        float okWidth = w;
        int okAscent = 0, okDescent = 0, okTop = 0, okBottom = 0;
        // fit is a character offset such that the [here, fit[ range fits in the allowed width.
        // We will cut the line there if no ok position is found.
        int fit = paraStart;
        float fitWidth = w;
        int fitAscent = 0, fitDescent = 0, fitTop = 0, fitBottom = 0;
        // same as fitWidth but not including any trailing whitespace
        float fitWidthGraphing = w;
        boolean hasTabOrEmoji = false;
        boolean hasTab = false;
        TabStops tabStops = null;
        for (int spanStart = paraStart, spanEnd; spanStart < paraEnd; spanStart = spanEnd) {
            if (spanned == null) {
                spanEnd = paraEnd;
                int spanLen = spanEnd - spanStart;
                measured.addStyleRun(paint, spanLen, fm);
            } else {
                spanEnd = spanned.nextSpanTransition(spanStart, paraEnd, MetricAffectingSpan.class);
                int spanLen = spanEnd - spanStart;
                MetricAffectingSpan[] spans = spanned.getSpans(spanStart, spanEnd, MetricAffectingSpan.class);
                spans = TextUtils.removeEmptySpans(spans, spanned, MetricAffectingSpan.class);
                measured.addStyleRun(paint, spans, spanLen, fm);
            }
            int fmTop = fm.top;
            int fmBottom = fm.bottom;
            int fmAscent = fm.ascent;
            int fmDescent = fm.descent;
            for (int j = spanStart; j < spanEnd; j++) {
                char c = chs[j - paraStart];
                if (c == CHAR_NEW_LINE) {
                // intentionally left empty
                } else if (c == CHAR_TAB) {
                    if (hasTab == false) {
                        hasTab = true;
                        hasTabOrEmoji = true;
                        if (spanned != null) {
                            // First tab this para, check for tabstops
                            TabStopSpan[] spans = getParagraphSpans(spanned, paraStart, paraEnd, TabStopSpan.class);
                            if (spans.length > 0) {
                                tabStops = new TabStops(TAB_INCREMENT, spans);
                            }
                        }
                    }
                    if (tabStops != null) {
                        w = tabStops.nextTab(w);
                    } else {
                        w = TabStops.nextDefaultStop(w, TAB_INCREMENT);
                    }
                } else if (c >= CHAR_FIRST_HIGH_SURROGATE && c <= CHAR_LAST_LOW_SURROGATE && j + 1 < spanEnd) {
                    int emoji = Character.codePointAt(chs, j - paraStart);
                    if (emoji >= MIN_EMOJI && emoji <= MAX_EMOJI) {
                        Bitmap bm = EMOJI_FACTORY.getBitmapFromAndroidPua(emoji);
                        if (bm != null) {
                            Paint whichPaint;
                            if (spanned == null) {
                                whichPaint = paint;
                            } else {
                                whichPaint = mWorkPaint;
                            }
                            float wid = bm.getWidth() * -whichPaint.ascent() / bm.getHeight();
                            w += wid;
                            hasTabOrEmoji = true;
                            j++;
                        } else {
                            w += widths[j - paraStart];
                        }
                    } else {
                        w += widths[j - paraStart];
                    }
                } else {
                    w += widths[j - paraStart];
                }
                boolean isSpaceOrTab = c == CHAR_SPACE || c == CHAR_TAB || c == CHAR_ZWSP;
                if (w <= width || isSpaceOrTab) {
                    fitWidth = w;
                    if (!isSpaceOrTab) {
                        fitWidthGraphing = w;
                    }
                    fit = j + 1;
                    if (fmTop < fitTop)
                        fitTop = fmTop;
                    if (fmAscent < fitAscent)
                        fitAscent = fmAscent;
                    if (fmDescent > fitDescent)
                        fitDescent = fmDescent;
                    if (fmBottom > fitBottom)
                        fitBottom = fmBottom;
                    while (breakOpp[breakOppIndex] != -1 && breakOpp[breakOppIndex] < j - paraStart + 1) {
                        breakOppIndex++;
                    }
                    boolean isLineBreak = breakOppIndex < breakOpp.length && breakOpp[breakOppIndex] == j - paraStart + 1;
                    if (isLineBreak) {
                        okWidth = fitWidthGraphing;
                        ok = j + 1;
                        if (fitTop < okTop)
                            okTop = fitTop;
                        if (fitAscent < okAscent)
                            okAscent = fitAscent;
                        if (fitDescent > okDescent)
                            okDescent = fitDescent;
                        if (fitBottom > okBottom)
                            okBottom = fitBottom;
                    }
                } else {
                    final boolean moreChars;
                    int endPos;
                    int above, below, top, bottom;
                    float currentTextWidth;
                    if (ok != here) {
                        endPos = ok;
                        above = okAscent;
                        below = okDescent;
                        top = okTop;
                        bottom = okBottom;
                        currentTextWidth = okWidth;
                        moreChars = (j + 1 < spanEnd);
                    } else if (fit != here) {
                        endPos = fit;
                        above = fitAscent;
                        below = fitDescent;
                        top = fitTop;
                        bottom = fitBottom;
                        currentTextWidth = fitWidth;
                        moreChars = (j + 1 < spanEnd);
                    } else {
                        // must make progress, so take next character
                        endPos = here + 1;
                        // take all zero width characters following that
                        while (endPos < spanEnd && widths[endPos - paraStart] == 0) {
                            endPos++;
                        }
                        above = fmAscent;
                        below = fmDescent;
                        top = fmTop;
                        bottom = fmBottom;
                        currentTextWidth = widths[here - paraStart];
                        moreChars = (endPos < spanEnd);
                    }
                    v = out(source, here, endPos, above, below, top, bottom, v, spacingmult, spacingadd, chooseHt, chooseHtv, fm, hasTabOrEmoji, needMultiply, chdirs, dir, easy, bufEnd, includepad, trackpad, chs, widths, paraStart, ellipsize, ellipsizedWidth, currentTextWidth, paint, moreChars);
                    here = endPos;
                    // restart j-span loop from here, compensating for the j++
                    j = here - 1;
                    ok = fit = here;
                    w = 0;
                    fitWidthGraphing = w;
                    fitAscent = fitDescent = fitTop = fitBottom = 0;
                    okAscent = okDescent = okTop = okBottom = 0;
                    if (--firstWidthLineLimit <= 0) {
                        width = restWidth;
                    }
                    if (here < spanStart) {
                        // The text was cut before the beginning of the current span range.
                        // Exit the span loop, and get spanStart to start over from here.
                        measured.setPos(here);
                        spanEnd = here;
                        break;
                    }
                    if (mLineCount >= mMaximumVisibleLineCount) {
                        return;
                    }
                }
            }
        }
        if (paraEnd != here && mLineCount < mMaximumVisibleLineCount) {
            if ((fitTop | fitBottom | fitDescent | fitAscent) == 0) {
                paint.getFontMetricsInt(fm);
                fitTop = fm.top;
                fitBottom = fm.bottom;
                fitAscent = fm.ascent;
                fitDescent = fm.descent;
            }
            // Log.e("text", "output rest " + here + " to " + end);
            v = out(source, here, paraEnd, fitAscent, fitDescent, fitTop, fitBottom, v, spacingmult, spacingadd, chooseHt, chooseHtv, fm, hasTabOrEmoji, needMultiply, chdirs, dir, easy, bufEnd, includepad, trackpad, chs, widths, paraStart, ellipsize, ellipsizedWidth, w, paint, paraEnd != bufEnd);
        }
        paraStart = paraEnd;
        if (paraEnd == bufEnd)
            break;
    }
    if ((bufEnd == bufStart || source.charAt(bufEnd - 1) == CHAR_NEW_LINE) && mLineCount < mMaximumVisibleLineCount) {
        // Log.e("text", "output last " + bufEnd);
        measured.setPara(source, bufStart, bufEnd, textDir);
        paint.getFontMetricsInt(fm);
        v = out(source, bufEnd, bufEnd, fm.ascent, fm.descent, fm.top, fm.bottom, v, spacingmult, spacingadd, null, null, fm, false, needMultiply, measured.mLevels, measured.mDir, measured.mEasy, bufEnd, includepad, trackpad, null, null, bufStart, ellipsize, ellipsizedWidth, 0, paint, false);
    }
}
Body of Second Method:
{
    int[] breakOpp = null;
    final String localeLanguageTag = paint.getTextLocale().toLanguageTag();
    mLineCount = 0;
    int v = 0;
    boolean needMultiply = (spacingmult != 1 || spacingadd != 0);
    Paint.FontMetricsInt fm = mFontMetricsInt;
    int[] chooseHtv = null;
    MeasuredText measured = mMeasured;
    Spanned spanned = null;
    if (source instanceof Spanned)
        spanned = (Spanned) source;
    int paraEnd;
    for (int paraStart = bufStart; paraStart <= bufEnd; paraStart = paraEnd) {
        paraEnd = TextUtils.indexOf(source, CHAR_NEW_LINE, paraStart, bufEnd);
        if (paraEnd < 0)
            paraEnd = bufEnd;
        else
            paraEnd++;
        int firstWidthLineLimit = mLineCount + 1;
        int firstWidth = outerWidth;
        int restWidth = outerWidth;
        LineHeightSpan[] chooseHt = null;
        if (spanned != null) {
            LeadingMarginSpan[] sp = getParagraphSpans(spanned, paraStart, paraEnd, LeadingMarginSpan.class);
            for (int i = 0; i < sp.length; i++) {
                LeadingMarginSpan lms = sp[i];
                firstWidth -= sp[i].getLeadingMargin(true);
                restWidth -= sp[i].getLeadingMargin(false);
                // leading margin spans, not just this particular one
                if (lms instanceof LeadingMarginSpan2) {
                    LeadingMarginSpan2 lms2 = (LeadingMarginSpan2) lms;
                    int lmsFirstLine = getLineForOffset(spanned.getSpanStart(lms2));
                    firstWidthLineLimit = Math.max(firstWidthLineLimit, lmsFirstLine + lms2.getLeadingMarginLineCount());
                }
            }
            chooseHt = getParagraphSpans(spanned, paraStart, paraEnd, LineHeightSpan.class);
            if (chooseHt.length != 0) {
                if (chooseHtv == null || chooseHtv.length < chooseHt.length) {
                    chooseHtv = ArrayUtils.newUnpaddedIntArray(chooseHt.length);
                }
                for (int i = 0; i < chooseHt.length; i++) {
                    int o = spanned.getSpanStart(chooseHt[i]);
                    if (o < paraStart) {
                        // starts in this layout, before the
                        // current paragraph
                        chooseHtv[i] = getLineTop(getLineForOffset(o));
                    } else {
                        // starts in this paragraph
                        chooseHtv[i] = v;
                    }
                }
            }
        }
        measured.setPara(source, paraStart, paraEnd, textDir);
        char[] chs = measured.mChars;
        float[] widths = measured.mWidths;
        byte[] chdirs = measured.mLevels;
        int dir = measured.mDir;
        boolean easy = measured.mEasy;
        breakOpp = nLineBreakOpportunities(localeLanguageTag, chs, paraEnd - paraStart, breakOpp);
        int breakOppIndex = 0;
        int width = firstWidth;
        float w = 0;
        // here is the offset of the starting character of the line we are currently measuring
        int here = paraStart;
        // ok is a character offset located after a word separator (space, tab, number...) where
        // we would prefer to cut the current line. Equals to here when no such break was found.
        int ok = paraStart;
        float okWidth = w;
        int okAscent = 0, okDescent = 0, okTop = 0, okBottom = 0;
        // fit is a character offset such that the [here, fit[ range fits in the allowed width.
        // We will cut the line there if no ok position is found.
        int fit = paraStart;
        float fitWidth = w;
        int fitAscent = 0, fitDescent = 0, fitTop = 0, fitBottom = 0;
        // same as fitWidth but not including any trailing whitespace
        float fitWidthGraphing = w;
        boolean hasTabOrEmoji = false;
        boolean hasTab = false;
        TabStops tabStops = null;
        for (int spanStart = paraStart, spanEnd; spanStart < paraEnd; spanStart = spanEnd) {
            if (spanned == null) {
                spanEnd = paraEnd;
                int spanLen = spanEnd - spanStart;
                measured.addStyleRun(paint, spanLen, fm);
            } else {
                spanEnd = spanned.nextSpanTransition(spanStart, paraEnd, MetricAffectingSpan.class);
                int spanLen = spanEnd - spanStart;
                MetricAffectingSpan[] spans = spanned.getSpans(spanStart, spanEnd, MetricAffectingSpan.class);
                spans = TextUtils.removeEmptySpans(spans, spanned, MetricAffectingSpan.class);
                measured.addStyleRun(paint, spans, spanLen, fm);
            }
            int fmTop = fm.top;
            int fmBottom = fm.bottom;
            int fmAscent = fm.ascent;
            int fmDescent = fm.descent;
            for (int j = spanStart; j < spanEnd; j++) {
                char c = chs[j - paraStart];
                if (c == CHAR_NEW_LINE) {
                // intentionally left empty
                } else if (c == CHAR_TAB) {
                    if (hasTab == false) {
                        hasTab = true;
                        hasTabOrEmoji = true;
                        if (spanned != null) {
                            // First tab this para, check for tabstops
                            TabStopSpan[] spans = getParagraphSpans(spanned, paraStart, paraEnd, TabStopSpan.class);
                            if (spans.length > 0) {
                                tabStops = new TabStops(TAB_INCREMENT, spans);
                            }
                        }
                    }
                    if (tabStops != null) {
                        w = tabStops.nextTab(w);
                    } else {
                        w = TabStops.nextDefaultStop(w, TAB_INCREMENT);
                    }
                } else if (c >= CHAR_FIRST_HIGH_SURROGATE && c <= CHAR_LAST_LOW_SURROGATE && j + 1 < spanEnd) {
                    int emoji = Character.codePointAt(chs, j - paraStart);
                    if (emoji >= MIN_EMOJI && emoji <= MAX_EMOJI) {
                        Bitmap bm = EMOJI_FACTORY.getBitmapFromAndroidPua(emoji);
                        if (bm != null) {
                            Paint whichPaint;
                            if (spanned == null) {
                                whichPaint = paint;
                            } else {
                                whichPaint = mWorkPaint;
                            }
                            float wid = bm.getWidth() * -whichPaint.ascent() / bm.getHeight();
                            w += wid;
                            hasTabOrEmoji = true;
                            j++;
                        } else {
                            w += widths[j - paraStart];
                        }
                    } else {
                        w += widths[j - paraStart];
                    }
                } else {
                    w += widths[j - paraStart];
                }
                boolean isSpaceOrTab = c == CHAR_SPACE || c == CHAR_TAB || c == CHAR_ZWSP;
                if (w <= width || isSpaceOrTab) {
                    fitWidth = w;
                    if (!isSpaceOrTab) {
                        fitWidthGraphing = w;
                    }
                    fit = j + 1;
                    if (fmTop < fitTop)
                        fitTop = fmTop;
                    if (fmAscent < fitAscent)
                        fitAscent = fmAscent;
                    if (fmDescent > fitDescent)
                        fitDescent = fmDescent;
                    if (fmBottom > fitBottom)
                        fitBottom = fmBottom;
                    while (breakOpp[breakOppIndex] != -1 && breakOpp[breakOppIndex] < j - paraStart + 1) {
                        breakOppIndex++;
                    }
                    boolean isLineBreak = breakOppIndex < breakOpp.length && breakOpp[breakOppIndex] == j - paraStart + 1;
                    if (isLineBreak) {
                        okWidth = fitWidthGraphing;
                        ok = j + 1;
                        if (fitTop < okTop)
                            okTop = fitTop;
                        if (fitAscent < okAscent)
                            okAscent = fitAscent;
                        if (fitDescent > okDescent)
                            okDescent = fitDescent;
                        if (fitBottom > okBottom)
                            okBottom = fitBottom;
                    }
                } else {
                    int endPos;
                    int above, below, top, bottom;
                    float currentTextWidth;
                    if (ok != here) {
                        endPos = ok;
                        above = okAscent;
                        below = okDescent;
                        top = okTop;
                        bottom = okBottom;
                        currentTextWidth = okWidth;
                    } else if (fit != here) {
                        endPos = fit;
                        above = fitAscent;
                        below = fitDescent;
                        top = fitTop;
                        bottom = fitBottom;
                        currentTextWidth = fitWidth;
                    } else {
                        // must make progress, so take next character
                        endPos = here + 1;
                        // take all zero width characters following that
                        while (endPos < spanEnd && widths[endPos - paraStart] == 0) {
                            endPos++;
                        }
                        above = fmAscent;
                        below = fmDescent;
                        top = fmTop;
                        bottom = fmBottom;
                        currentTextWidth = widths[here - paraStart];
                    }
                    int ellipseEnd = endPos;
                    if (mMaximumVisibleLineCount == 1 && ellipsize == TextUtils.TruncateAt.MIDDLE) {
                        ellipseEnd = paraEnd;
                    }
                    v = out(source, here, ellipseEnd, above, below, top, bottom, v, spacingmult, spacingadd, chooseHt, chooseHtv, fm, hasTabOrEmoji, needMultiply, chdirs, dir, easy, bufEnd, includepad, trackpad, chs, widths, paraStart, ellipsize, ellipsizedWidth, currentTextWidth, paint, true);
                    here = endPos;
                    // restart j-span loop from here, compensating for the j++
                    j = here - 1;
                    ok = fit = here;
                    w = 0;
                    fitWidthGraphing = w;
                    fitAscent = fitDescent = fitTop = fitBottom = 0;
                    okAscent = okDescent = okTop = okBottom = 0;
                    if (--firstWidthLineLimit <= 0) {
                        width = restWidth;
                    }
                    if (here < spanStart) {
                        // The text was cut before the beginning of the current span range.
                        // Exit the span loop, and get spanStart to start over from here.
                        measured.setPos(here);
                        spanEnd = here;
                        break;
                    }
                    if (mLineCount >= mMaximumVisibleLineCount) {
                        return;
                    }
                }
            }
        }
        if (paraEnd != here && mLineCount < mMaximumVisibleLineCount) {
            if ((fitTop | fitBottom | fitDescent | fitAscent) == 0) {
                paint.getFontMetricsInt(fm);
                fitTop = fm.top;
                fitBottom = fm.bottom;
                fitAscent = fm.ascent;
                fitDescent = fm.descent;
            }
            // Log.e("text", "output rest " + here + " to " + end);
            v = out(source, here, paraEnd, fitAscent, fitDescent, fitTop, fitBottom, v, spacingmult, spacingadd, chooseHt, chooseHtv, fm, hasTabOrEmoji, needMultiply, chdirs, dir, easy, bufEnd, includepad, trackpad, chs, widths, paraStart, ellipsize, ellipsizedWidth, w, paint, paraEnd != bufEnd);
        }
        paraStart = paraEnd;
        if (paraEnd == bufEnd)
            break;
    }
    if ((bufEnd == bufStart || source.charAt(bufEnd - 1) == CHAR_NEW_LINE) && mLineCount < mMaximumVisibleLineCount) {
        // Log.e("text", "output last " + bufEnd);
        measured.setPara(source, bufStart, bufEnd, textDir);
        paint.getFontMetricsInt(fm);
        v = out(source, bufEnd, bufEnd, fm.ascent, fm.descent, fm.top, fm.bottom, v, spacingmult, spacingadd, null, null, fm, false, needMultiply, measured.mLevels, measured.mDir, measured.mEasy, bufEnd, includepad, trackpad, null, null, bufStart, ellipsize, ellipsizedWidth, 0, paint, false);
    }
}
------------------------
Find a silently evolved API code:android.webkit.WebViewDatabase.hasHttpAuthUsernamePassword:COMMENT
<android.webkit.WebViewDatabase: boolean hasHttpAuthUsernamePassword()>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Gets whether there are any saved credentials for HTTP authentication.
 *
 * @return whether there are any saved credentials
 * @see WebView#getHttpAuthUsernamePassword
 * @see WebView#setHttpAuthUsernamePassword
 * @see #clearHttpAuthUsernamePassword
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.media.audiofx.AudioEffect.isEffectTypeAvailable:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Checks if the device implements the specified effect type.
 * @param type the requested effect type.
 * @return true if the device implements the specified effect type, false otherwise.
 * @hide
 */

Body of Frist Method:
{
    AudioEffect.Descriptor[] desc = AudioEffect.queryEffects();
    for (int i = 0; i < desc.length; i++) {
        if (desc[i].type.equals(type)) {
            return true;
        }
    }
    return false;
}
Body of Second Method:
{
    AudioEffect.Descriptor[] desc = AudioEffect.queryEffects();
    if (desc == null) {
        return false;
    }
    for (int i = 0; i < desc.length; i++) {
        if (desc[i].type.equals(type)) {
            return true;
        }
    }
    return false;
}
------------------------
Find a silently evolved API code:android.telephony.SubscriptionManager.getDefaultSubId:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @return the "system" defaultSubId on a voice capable device this
 * will be getDefaultVoiceSubId() and on a data only device it will be
 * getDefaultDataSubId().
 * @hide
 */

Body of Frist Method:
{
    long subId = INVALID_SUB_ID;
    try {
        ISub iSub = ISub.Stub.asInterface(ServiceManager.getService("isub"));
        if (iSub != null) {
            subId = iSub.getDefaultSubId();
        }
    } catch (RemoteException ex) {
    // ignore it
    }
    if (VDBG)
        logd("getDefaultSubId=" + subId);
    return subId;
}
Body of Second Method:
{
    int subId = INVALID_SUBSCRIPTION_ID;
    try {
        ISub iSub = ISub.Stub.asInterface(ServiceManager.getService("isub"));
        if (iSub != null) {
            subId = iSub.getDefaultSubId();
        }
    } catch (RemoteException ex) {
    // ignore it
    }
    if (VDBG)
        logd("getDefaultSubId=" + subId);
    return subId;
}
------------------------
Find a silently evolved API code:android.telephony.SubscriptionManager.getSubId:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (!isValidSlotId(slotId)) {
        logd("[getSubId]- fail");
        return null;
    }
    long[] subId = null;
    try {
        ISub iSub = ISub.Stub.asInterface(ServiceManager.getService("isub"));
        if (iSub != null) {
            subId = iSub.getSubId(slotId);
        }
    } catch (RemoteException ex) {
    // ignore it
    }
    return subId;
}
Body of Second Method:
{
    if (!isValidSlotId(slotId)) {
        logd("[getSubId]- fail");
        return null;
    }
    int[] subId = null;
    try {
        ISub iSub = ISub.Stub.asInterface(ServiceManager.getService("isub"));
        if (iSub != null) {
            subId = iSub.getSubId(slotId);
        }
    } catch (RemoteException ex) {
    // ignore it
    }
    return subId;
}
------------------------
Find a silently evolved API code:android.animation.StateListAnimator.addState:COMMENT
Method Modifier: public      
Comment:/**
 * Associates the given animator with the provided drawable state specs so that it will be run
 * when the View's drawable state matches the specs.
 *
 * @param specs The drawable state specs to match against
 * @param animator The animator to run when the specs match
 */

Body of Frist Method:
{
    Tuple tuple = new Tuple(specs, animator);
    tuple.mAnimator.addListener(mAnimatorListener);
    mTuples.add(tuple);
}
Body of Second Method:
{
    Tuple tuple = new Tuple(specs, animator);
    tuple.mAnimator.addListener(mAnimatorListener);
    mTuples.add(tuple);
    mChangingConfigurations |= animator.getChangingConfigurations();
}
------------------------
Find a silently evolved API code:android.telephony.SubscriptionManager.getDefaultVoiceSubId:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    long subId = INVALID_SUB_ID;
    try {
        ISub iSub = ISub.Stub.asInterface(ServiceManager.getService("isub"));
        if (iSub != null) {
            subId = iSub.getDefaultVoiceSubId();
        }
    } catch (RemoteException ex) {
    // ignore it
    }
    if (VDBG)
        logd("getDefaultVoiceSubId, sub id = " + subId);
    return subId;
}
Body of Second Method:
{
    int subId = INVALID_SUBSCRIPTION_ID;
    try {
        ISub iSub = ISub.Stub.asInterface(ServiceManager.getService("isub"));
        if (iSub != null) {
            subId = iSub.getDefaultVoiceSubId();
        }
    } catch (RemoteException ex) {
    // ignore it
    }
    if (VDBG)
        logd("getDefaultVoiceSubId, sub id = " + subId);
    return subId;
}
------------------------
Find a silently evolved API code:android.content.Intent.prepareToEnterProcess:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (mContentUserHint != UserHandle.USER_CURRENT) {
        fixUris(mContentUserHint);
        mContentUserHint = UserHandle.USER_CURRENT;
    }
}
Body of Second Method:
{
    if (mContentUserHint != UserHandle.USER_CURRENT) {
        if (UserHandle.getAppId(Process.myUid()) != Process.SYSTEM_UID) {
            fixUris(mContentUserHint);
            mContentUserHint = UserHandle.USER_CURRENT;
        }
    }
}
------------------------
Find a silently evolved API code:android.webkit.WebViewDatabase.hasUsernamePassword:COMMENT
<android.webkit.WebViewDatabase: boolean hasUsernamePassword()>
public      deprecated  ->public      abstract    deprecated  
Method Modifier: public      abstract    deprecated  
Method Modifier: Yes         No          Yes         
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * Gets whether there are any saved username/password pairs for web forms.
 * Note that these are unrelated to HTTP authentication credentials.
 *
 * @return true if there are any saved username/password pairs
 * @see WebView#savePassword
 * @see #clearUsernamePassworda
 * @deprecated Saving passwords in WebView will not be supported in future versions.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.webkit.WebSettings.setGeolocationDatabasePath:COMMENT
<android.webkit.WebSettings: void setGeolocationDatabasePath(String)>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:// This will update WebCore when the Sync runs in the C++ side.

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.appwidget.AppWidgetHost.deleteHost:COMMENT
Method Modifier: public      
Comment:/**
 * Remove all records about this host from the AppWidget manager.
 * <ul>
 * <li>Call this when initializing your database, as it might be because of a data wipe.</li>
 * <li>Call this to have the AppWidget manager release all resources associated with your
 * host.  Any future calls about this host will cause the records to be re-allocated.</li>
 * </ul>
 */

Body of Frist Method:
{
    try {
        sService.deleteHost(mContext.getOpPackageName(), mHostId);
    } catch (RemoteException e) {
        throw new RuntimeException("system server dead?", e);
    }
}
Body of Second Method:
{
    try {
        sService.deleteHost(mContextOpPackageName, mHostId);
    } catch (RemoteException e) {
        throw new RuntimeException("system server dead?", e);
    }
}
------------------------
Find a silently evolved API code:android.app.Notification.BigPictureStyle.restoreFromExtras:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    super.restoreFromExtras(extras);
    if (extras.containsKey(EXTRA_LARGE_ICON_BIG)) {
        mBigLargeIcon = extras.getParcelable(EXTRA_LARGE_ICON_BIG);
    }
    mPicture = extras.getParcelable(EXTRA_PICTURE);
}
Body of Second Method:
{
    super.restoreFromExtras(extras);
    if (extras.containsKey(EXTRA_LARGE_ICON_BIG)) {
        mBigLargeIconSet = true;
        mBigLargeIcon = extras.getParcelable(EXTRA_LARGE_ICON_BIG);
    }
    mPicture = extras.getParcelable(EXTRA_PICTURE);
}
------------------------
Find a silently evolved API code:android.widget.SearchView.onKeyDown:COMMENT
Method Modifier: public      
Comment:/**
 * Handles the key down event for dealing with action keys.
 *
 * @param keyCode This is the keycode of the typed key, and is the same value as
 * found in the KeyEvent parameter.
 * @param event The complete event record for the typed key
 *
 * @return true if the event was handled here, or false if not.
 */

Body of Frist Method:
{
    if (mSearchable == null) {
        return false;
    }
    // if it's an action specified by the searchable activity, launch the
    // entered query with the action key
    SearchableInfo.ActionKeyInfo actionKey = mSearchable.findActionKey(keyCode);
    if ((actionKey != null) && (actionKey.getQueryActionMsg() != null)) {
        launchQuerySearch(keyCode, actionKey.getQueryActionMsg(), mQueryTextView.getText().toString());
        return true;
    }
    return super.onKeyDown(keyCode, event);
}
Body of Second Method:
{
    if (mSearchable == null) {
        return false;
    }
    // if it's an action specified by the searchable activity, launch the
    // entered query with the action key
    SearchableInfo.ActionKeyInfo actionKey = mSearchable.findActionKey(keyCode);
    if ((actionKey != null) && (actionKey.getQueryActionMsg() != null)) {
        launchQuerySearch(keyCode, actionKey.getQueryActionMsg(), mSearchSrcTextView.getText().toString());
        return true;
    }
    return super.onKeyDown(keyCode, event);
}
------------------------
Find a silently evolved API code:android.app.ActivityOptions.toBundle:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the created options as a Bundle, which can be passed to
 * {@link android.content.Context#startActivity(android.content.Intent, android.os.Bundle)
 * Context.startActivity(Intent, Bundle)} and related methods.
 * Note that the returned Bundle is still owned by the ActivityOptions
 * object; you must not modify it, but can supply it to the startActivity
 * methods that take an options Bundle.
 */

Body of Frist Method:
{
    if (mAnimationType == ANIM_DEFAULT) {
        return null;
    }
    Bundle b = new Bundle();
    if (mPackageName != null) {
        b.putString(KEY_PACKAGE_NAME, mPackageName);
    }
    b.putInt(KEY_ANIM_TYPE, mAnimationType);
    switch(mAnimationType) {
        case ANIM_CUSTOM:
            b.putInt(KEY_ANIM_ENTER_RES_ID, mCustomEnterResId);
            b.putInt(KEY_ANIM_EXIT_RES_ID, mCustomExitResId);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_SCALE_UP:
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            break;
        case ANIM_THUMBNAIL_SCALE_UP:
        case ANIM_THUMBNAIL_SCALE_DOWN:
        case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
        case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
            b.putParcelable(KEY_ANIM_THUMBNAIL, mThumbnail);
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_SCENE_TRANSITION:
            if (mTransitionReceiver != null) {
                b.putParcelable(KEY_TRANSITION_COMPLETE_LISTENER, mTransitionReceiver);
            }
            b.putBoolean(KEY_TRANSITION_IS_RETURNING, mIsReturning);
            b.putStringArrayList(KEY_TRANSITION_SHARED_ELEMENTS, mSharedElementNames);
            b.putParcelable(KEY_RESULT_DATA, mResultData);
            b.putInt(KEY_RESULT_CODE, mResultCode);
            b.putInt(KEY_EXIT_COORDINATOR_INDEX, mExitCoordinatorIndex);
            break;
    }
    return b;
}
Body of Second Method:
{
    if (mAnimationType == ANIM_DEFAULT) {
        return null;
    }
    Bundle b = new Bundle();
    if (mPackageName != null) {
        b.putString(KEY_PACKAGE_NAME, mPackageName);
    }
    b.putInt(KEY_ANIM_TYPE, mAnimationType);
    switch(mAnimationType) {
        case ANIM_CUSTOM:
            b.putInt(KEY_ANIM_ENTER_RES_ID, mCustomEnterResId);
            b.putInt(KEY_ANIM_EXIT_RES_ID, mCustomExitResId);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_CUSTOM_IN_PLACE:
            b.putInt(KEY_ANIM_IN_PLACE_RES_ID, mCustomInPlaceResId);
            break;
        case ANIM_SCALE_UP:
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            break;
        case ANIM_THUMBNAIL_SCALE_UP:
        case ANIM_THUMBNAIL_SCALE_DOWN:
        case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
        case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
            b.putParcelable(KEY_ANIM_THUMBNAIL, mThumbnail);
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_SCENE_TRANSITION:
            if (mTransitionReceiver != null) {
                b.putParcelable(KEY_TRANSITION_COMPLETE_LISTENER, mTransitionReceiver);
            }
            b.putBoolean(KEY_TRANSITION_IS_RETURNING, mIsReturning);
            b.putStringArrayList(KEY_TRANSITION_SHARED_ELEMENTS, mSharedElementNames);
            b.putParcelable(KEY_RESULT_DATA, mResultData);
            b.putInt(KEY_RESULT_CODE, mResultCode);
            b.putInt(KEY_EXIT_COORDINATOR_INDEX, mExitCoordinatorIndex);
            break;
    }
    return b;
}
------------------------
Find a silently evolved API code:android.graphics.drawable.RippleBackground.cancelHardwareAnimations:COMMENT
Method Modifier: private     
Comment:/**
 * Cancels any running hardware animations.
 */

Body of Frist Method:
{
    final ArrayList<RenderNodeAnimator> runningAnimations = mRunningAnimations;
    final int N = runningAnimations.size();
    for (int i = 0; i < N; i++) {
        runningAnimations.get(i).cancel();
    }
    runningAnimations.clear();
    if (cancelPending && !mPendingAnimations.isEmpty()) {
        mPendingAnimations.clear();
    }
    mHardwareAnimating = false;
}
Body of Second Method:
{
    final ArrayList<RenderNodeAnimator> runningAnimations = mRunningAnimations;
    final int N = runningAnimations.size();
    for (int i = 0; i < N; i++) {
        if (jumpToEnd) {
            runningAnimations.get(i).end();
        } else {
            runningAnimations.get(i).cancel();
        }
    }
    runningAnimations.clear();
    if (mHasPendingHardwareExit) {
        // If we had a pending hardware exit, jump to the end state.
        mHasPendingHardwareExit = false;
        if (jumpToEnd) {
            mOuterOpacity = 0;
        }
    }
    mHardwareAnimating = false;
}
------------------------
Find a silently evolved API code:android.telephony.ServiceState.getOperatorAlphaLong:COMMENT
Method Modifier: public      
Comment:/**
 * Get current registered operator name in long alphanumeric format.
 *
 * In GSM/UMTS, long format can be up to 16 characters long.
 * In CDMA, returns the ERI text, if set. Otherwise, returns the ONS.
 *
 * @return long name of operator, null if unregistered or unknown
 */

Body of Frist Method:
{
    return mOperatorAlphaLong;
}
Body of Second Method:
{
    return mVoiceOperatorAlphaLong;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothDevice.isConnected:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns whether there is an open connection to this device.
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH}.
 *
 * @return True if there is at least one open connection to this device.
 * @hide
 */

Body of Frist Method:
{
    if (sService == null) {
        // BT is not enabled, we cannot be connected.
        return false;
    }
    try {
        return sService.isConnected(this);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        return false;
    }
}
Body of Second Method:
{
    if (sService == null) {
        // BT is not enabled, we cannot be connected.
        return false;
    }
    try {
        return sService.getConnectionState(this) != CONNECTION_STATE_DISCONNECTED;
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        return false;
    }
}
------------------------
Find a silently evolved API code:android.graphics.drawable.RippleBackground.exit:COMMENT
Method Modifier: public      
Comment:/**
 * Starts the exit animation.
 */

Body of Frist Method:
{
    cancel();
    // Scale the outer max opacity and opacity velocity based
    // on the size of the outer radius.
    final int opacityDuration = (int) (1000 / WAVE_OPACITY_DECAY_VELOCITY + 0.5f);
    final float outerSizeInfluence = MathUtils.constrain((mOuterRadius - WAVE_OUTER_SIZE_INFLUENCE_MIN * mDensity) / (WAVE_OUTER_SIZE_INFLUENCE_MAX * mDensity), 0, 1);
    final float outerOpacityVelocity = MathUtils.lerp(WAVE_OUTER_OPACITY_EXIT_VELOCITY_MIN, WAVE_OUTER_OPACITY_EXIT_VELOCITY_MAX, outerSizeInfluence);
    // Determine at what time the inner and outer opacity intersect.
    // inner(t) = mOpacity - t * WAVE_OPACITY_DECAY_VELOCITY / 1000
    // outer(t) = mOuterOpacity + t * WAVE_OUTER_OPACITY_VELOCITY / 1000
    final int inflectionDuration = Math.max(0, (int) (1000 * (1 - mOuterOpacity) / (WAVE_OPACITY_DECAY_VELOCITY + outerOpacityVelocity) + 0.5f));
    final int inflectionOpacity = (int) (mColorAlpha * (mOuterOpacity + inflectionDuration * outerOpacityVelocity * outerSizeInfluence / 1000) + 0.5f);
    if (mCanUseHardware) {
        exitHardware(opacityDuration, inflectionDuration, inflectionOpacity);
    } else {
        exitSoftware(opacityDuration, inflectionDuration, inflectionOpacity);
    }
}
Body of Second Method:
{
    cancel();
    // Scale the outer max opacity and opacity velocity based
    // on the size of the outer radius.
    final int opacityDuration = (int) (1000 / WAVE_OPACITY_DECAY_VELOCITY + 0.5f);
    final float outerSizeInfluence = MathUtils.constrain((mOuterRadius - WAVE_OUTER_SIZE_INFLUENCE_MIN * mDensity) / (WAVE_OUTER_SIZE_INFLUENCE_MAX * mDensity), 0, 1);
    final float outerOpacityVelocity = MathUtils.lerp(WAVE_OUTER_OPACITY_EXIT_VELOCITY_MIN, WAVE_OUTER_OPACITY_EXIT_VELOCITY_MAX, outerSizeInfluence);
    // Determine at what time the inner and outer opacity intersect.
    // inner(t) = mOpacity - t * WAVE_OPACITY_DECAY_VELOCITY / 1000
    // outer(t) = mOuterOpacity + t * WAVE_OUTER_OPACITY_VELOCITY / 1000
    final int inflectionDuration = Math.max(0, (int) (1000 * (1 - mOuterOpacity) / (WAVE_OPACITY_DECAY_VELOCITY + outerOpacityVelocity) + 0.5f));
    final int inflectionOpacity = (int) (Color.alpha(mColor) * (mOuterOpacity + inflectionDuration * outerOpacityVelocity * outerSizeInfluence / 1000) + 0.5f);
    if (mCanUseHardware) {
        createPendingHardwareExit(opacityDuration, inflectionDuration, inflectionOpacity);
    } else {
        exitSoftware(opacityDuration, inflectionDuration, inflectionOpacity);
    }
}
------------------------
Find a silently evolved API code:android.widget.OverScroller.SplineOverScroller.update:COMMENT
Method Modifier: default     
Comment:/*
         * Update the current position and velocity for current time. Returns
         * true if update has been done and false if animation duration has been
         * reached.
         */

Body of Frist Method:
{
    final long time = AnimationUtils.currentAnimationTimeMillis();
    final long currentTime = time - mStartTime;
    if (currentTime > mDuration) {
        return false;
    }
    double distance = 0.0;
    switch(mState) {
        case SPLINE:
            {
                final float t = (float) currentTime / mSplineDuration;
                final int index = (int) (NB_SAMPLES * t);
                float distanceCoef = 1.f;
                float velocityCoef = 0.f;
                if (index < NB_SAMPLES) {
                    final float t_inf = (float) index / NB_SAMPLES;
                    final float t_sup = (float) (index + 1) / NB_SAMPLES;
                    final float d_inf = SPLINE_POSITION[index];
                    final float d_sup = SPLINE_POSITION[index + 1];
                    velocityCoef = (d_sup - d_inf) / (t_sup - t_inf);
                    distanceCoef = d_inf + (t - t_inf) * velocityCoef;
                }
                distance = distanceCoef * mSplineDistance;
                mCurrVelocity = velocityCoef * mSplineDistance / mSplineDuration * 1000.0f;
                break;
            }
        case BALLISTIC:
            {
                final float t = currentTime / 1000.0f;
                mCurrVelocity = mVelocity + mDeceleration * t;
                distance = mVelocity * t + mDeceleration * t * t / 2.0f;
                break;
            }
        case CUBIC:
            {
                final float t = (float) (currentTime) / mDuration;
                final float t2 = t * t;
                final float sign = Math.signum(mVelocity);
                distance = sign * mOver * (3.0f * t2 - 2.0f * t * t2);
                mCurrVelocity = sign * mOver * 6.0f * (-t + t2);
                break;
            }
    }
    mCurrentPosition = mStart + (int) Math.round(distance);
    return true;
}
Body of Second Method:
{
    final long time = AnimationUtils.currentAnimationTimeMillis();
    final long currentTime = time - mStartTime;
    if (currentTime == 0) {
        // Skip work but report that we're still going if we have a nonzero duration.
        return mDuration > 0;
    }
    if (currentTime > mDuration) {
        return false;
    }
    double distance = 0.0;
    switch(mState) {
        case SPLINE:
            {
                final float t = (float) currentTime / mSplineDuration;
                final int index = (int) (NB_SAMPLES * t);
                float distanceCoef = 1.f;
                float velocityCoef = 0.f;
                if (index < NB_SAMPLES) {
                    final float t_inf = (float) index / NB_SAMPLES;
                    final float t_sup = (float) (index + 1) / NB_SAMPLES;
                    final float d_inf = SPLINE_POSITION[index];
                    final float d_sup = SPLINE_POSITION[index + 1];
                    velocityCoef = (d_sup - d_inf) / (t_sup - t_inf);
                    distanceCoef = d_inf + (t - t_inf) * velocityCoef;
                }
                distance = distanceCoef * mSplineDistance;
                mCurrVelocity = velocityCoef * mSplineDistance / mSplineDuration * 1000.0f;
                break;
            }
        case BALLISTIC:
            {
                final float t = currentTime / 1000.0f;
                mCurrVelocity = mVelocity + mDeceleration * t;
                distance = mVelocity * t + mDeceleration * t * t / 2.0f;
                break;
            }
        case CUBIC:
            {
                final float t = (float) (currentTime) / mDuration;
                final float t2 = t * t;
                final float sign = Math.signum(mVelocity);
                distance = sign * mOver * (3.0f * t2 - 2.0f * t * t2);
                mCurrVelocity = sign * mOver * 6.0f * (-t + t2);
                break;
            }
    }
    mCurrentPosition = mStart + (int) Math.round(distance);
    return true;
}
------------------------
Find a silently evolved API code:android.webkit.WebSettings.setDefaultFontSize:COMMENT
<android.webkit.WebSettings: void setDefaultFontSize(int)>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Sets the default font size. The default is 16.
 *
 * @param size a non-negative integer between 1 and 72. Any number outside
 * the specified range will be pinned.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.graphics.drawable.InsetDrawable.setLayoutDirection:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * {@hide}
 */

Body of Frist Method:
{
    mInsetState.mDrawable.setLayoutDirection(layoutDirection);
}
Body of Second Method:
{
    mState.mDrawable.setLayoutDirection(layoutDirection);
}
------------------------
Find a silently evolved API code:android.appwidget.AppWidgetHost.getAppWidgetIds:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Gets a list of all the appWidgetIds that are bound to the current host
 *
 * @hide
 */

Body of Frist Method:
{
    try {
        if (sService == null) {
            bindService();
        }
        return sService.getAppWidgetIdsForHost(mContext.getOpPackageName(), mHostId);
    } catch (RemoteException e) {
        throw new RuntimeException("system server dead?", e);
    }
}
Body of Second Method:
{
    try {
        if (sService == null) {
            bindService();
        }
        return sService.getAppWidgetIdsForHost(mContextOpPackageName, mHostId);
    } catch (RemoteException e) {
        throw new RuntimeException("system server dead?", e);
    }
}
------------------------
Find a silently evolved API code:android.webkit.WebSettings.getFixedFontFamily:COMMENT
<android.webkit.WebSettings: String getFixedFontFamily()>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Gets the fixed font family name.
 *
 * @return the fixed font family name as a string
 * @see #setFixedFontFamily
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.accessibilityservice.AccessibilityService.onBind:COMMENT
Method Modifier: public      final       
Comment:/**
 * Implement to return the implementation of the internal accessibility
 * service interface.
 */

Body of Frist Method:
{
    return new IAccessibilityServiceClientWrapper(this, getMainLooper(), new Callbacks() {

        @Override
        public void onServiceConnected() {
            AccessibilityService.this.onServiceConnected();
        }

        @Override
        public void onInterrupt() {
            AccessibilityService.this.onInterrupt();
        }

        @Override
        public void onAccessibilityEvent(AccessibilityEvent event) {
            AccessibilityService.this.onAccessibilityEvent(event);
        }

        @Override
        public void onSetConnectionId(int connectionId) {
            mConnectionId = connectionId;
        }

        @Override
        public boolean onGesture(int gestureId) {
            return AccessibilityService.this.onGesture(gestureId);
        }

        @Override
        public boolean onKeyEvent(KeyEvent event) {
            return AccessibilityService.this.onKeyEvent(event);
        }
    });
}
Body of Second Method:
{
    return new IAccessibilityServiceClientWrapper(this, getMainLooper(), new Callbacks() {

        @Override
        public void onServiceConnected() {
            AccessibilityService.this.onServiceConnected();
        }

        @Override
        public void onInterrupt() {
            AccessibilityService.this.onInterrupt();
        }

        @Override
        public void onAccessibilityEvent(AccessibilityEvent event) {
            AccessibilityService.this.onAccessibilityEvent(event);
        }

        @Override
        public void init(int connectionId, IBinder windowToken) {
            mConnectionId = connectionId;
            mWindowToken = windowToken;
            // The client may have already obtained the window manager, so
            // update the default token on whatever manager we gave them.
            final WindowManagerImpl wm = (WindowManagerImpl) getSystemService(WINDOW_SERVICE);
            wm.setDefaultToken(windowToken);
        }

        @Override
        public boolean onGesture(int gestureId) {
            return AccessibilityService.this.onGesture(gestureId);
        }

        @Override
        public boolean onKeyEvent(KeyEvent event) {
            return AccessibilityService.this.onKeyEvent(event);
        }
    });
}
------------------------
Find a silently evolved API code:android.app.Notification.WearableExtender.extend:COMMENT
Method Modifier: public      
Comment:/**
 * Apply wearable extensions to a notification that is being built. This is typically
 * called by the {@link android.app.Notification.Builder#extend} method of
 * {@link android.app.Notification.Builder}.
 */

Body of Frist Method:
{
    Bundle wearableBundle = new Bundle();
    if (!mActions.isEmpty()) {
        wearableBundle.putParcelableArrayList(KEY_ACTIONS, mActions);
    }
    if (mFlags != DEFAULT_FLAGS) {
        wearableBundle.putInt(KEY_FLAGS, mFlags);
    }
    if (mDisplayIntent != null) {
        wearableBundle.putParcelable(KEY_DISPLAY_INTENT, mDisplayIntent);
    }
    if (!mPages.isEmpty()) {
        wearableBundle.putParcelableArray(KEY_PAGES, mPages.toArray(new Notification[mPages.size()]));
    }
    if (mBackground != null) {
        wearableBundle.putParcelable(KEY_BACKGROUND, mBackground);
    }
    if (mContentIcon != 0) {
        wearableBundle.putInt(KEY_CONTENT_ICON, mContentIcon);
    }
    if (mContentIconGravity != DEFAULT_CONTENT_ICON_GRAVITY) {
        wearableBundle.putInt(KEY_CONTENT_ICON_GRAVITY, mContentIconGravity);
    }
    if (mContentActionIndex != UNSET_ACTION_INDEX) {
        wearableBundle.putInt(KEY_CONTENT_ACTION_INDEX, mContentActionIndex);
    }
    if (mCustomSizePreset != SIZE_DEFAULT) {
        wearableBundle.putInt(KEY_CUSTOM_SIZE_PRESET, mCustomSizePreset);
    }
    if (mCustomContentHeight != 0) {
        wearableBundle.putInt(KEY_CUSTOM_CONTENT_HEIGHT, mCustomContentHeight);
    }
    if (mGravity != DEFAULT_GRAVITY) {
        wearableBundle.putInt(KEY_GRAVITY, mGravity);
    }
    builder.getExtras().putBundle(EXTRA_WEARABLE_EXTENSIONS, wearableBundle);
    return builder;
}
Body of Second Method:
{
    Bundle wearableBundle = new Bundle();
    if (!mActions.isEmpty()) {
        wearableBundle.putParcelableArrayList(KEY_ACTIONS, mActions);
    }
    if (mFlags != DEFAULT_FLAGS) {
        wearableBundle.putInt(KEY_FLAGS, mFlags);
    }
    if (mDisplayIntent != null) {
        wearableBundle.putParcelable(KEY_DISPLAY_INTENT, mDisplayIntent);
    }
    if (!mPages.isEmpty()) {
        wearableBundle.putParcelableArray(KEY_PAGES, mPages.toArray(new Notification[mPages.size()]));
    }
    if (mBackground != null) {
        wearableBundle.putParcelable(KEY_BACKGROUND, mBackground);
    }
    if (mContentIcon != 0) {
        wearableBundle.putInt(KEY_CONTENT_ICON, mContentIcon);
    }
    if (mContentIconGravity != DEFAULT_CONTENT_ICON_GRAVITY) {
        wearableBundle.putInt(KEY_CONTENT_ICON_GRAVITY, mContentIconGravity);
    }
    if (mContentActionIndex != UNSET_ACTION_INDEX) {
        wearableBundle.putInt(KEY_CONTENT_ACTION_INDEX, mContentActionIndex);
    }
    if (mCustomSizePreset != SIZE_DEFAULT) {
        wearableBundle.putInt(KEY_CUSTOM_SIZE_PRESET, mCustomSizePreset);
    }
    if (mCustomContentHeight != 0) {
        wearableBundle.putInt(KEY_CUSTOM_CONTENT_HEIGHT, mCustomContentHeight);
    }
    if (mGravity != DEFAULT_GRAVITY) {
        wearableBundle.putInt(KEY_GRAVITY, mGravity);
    }
    if (mHintScreenTimeout != 0) {
        wearableBundle.putInt(KEY_HINT_SCREEN_TIMEOUT, mHintScreenTimeout);
    }
    builder.getExtras().putBundle(EXTRA_WEARABLE_EXTENSIONS, wearableBundle);
    return builder;
}
------------------------
Find a silently evolved API code:android.webkit.WebBackForwardList.getCurrentItem:COMMENT
<android.webkit.WebBackForwardList: WebHistoryItem getCurrentItem()>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Return the current history item. This method returns null if the list is
 * empty.
 * @return The current history item.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.telephony.ServiceState.setOperatorAlphaLong:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * In CDMA, mOperatorAlphaLong can be set from the ERI text.
 * This is done from the CDMAPhone and not from the CdmaServiceStateTracker.
 *
 * @hide
 */

Body of Frist Method:
{
    mOperatorAlphaLong = longName;
}
Body of Second Method:
{
    mVoiceOperatorAlphaLong = longName;
    mDataOperatorAlphaLong = longName;
}
------------------------
Find a silently evolved API code:android.content.res.Configuration.resourceQualifierString:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Returns a string representation of the configuration that can be parsed
 * by build tools (like AAPT).
 *
 * @hide
 */

Body of Frist Method:
{
    ArrayList<String> parts = new ArrayList<String>();
    if (config.mcc != 0) {
        parts.add(config.mcc + "mcc");
        if (config.mnc != 0) {
            parts.add(config.mnc + "mnc");
        }
    }
    if (!config.locale.getLanguage().isEmpty()) {
        parts.add(localeToResourceQualifier(config.locale));
    }
    switch(config.screenLayout & Configuration.SCREENLAYOUT_LAYOUTDIR_MASK) {
        case Configuration.SCREENLAYOUT_LAYOUTDIR_LTR:
            parts.add("ldltr");
            break;
        case Configuration.SCREENLAYOUT_LAYOUTDIR_RTL:
            parts.add("ldrtl");
            break;
        default:
            break;
    }
    if (config.smallestScreenWidthDp != 0) {
        parts.add("sw" + config.smallestScreenWidthDp + "dp");
    }
    if (config.screenWidthDp != 0) {
        parts.add("w" + config.screenWidthDp + "dp");
    }
    if (config.screenHeightDp != 0) {
        parts.add("h" + config.screenHeightDp + "dp");
    }
    switch(config.screenLayout & Configuration.SCREENLAYOUT_SIZE_MASK) {
        case Configuration.SCREENLAYOUT_SIZE_SMALL:
            parts.add("small");
            break;
        case Configuration.SCREENLAYOUT_SIZE_NORMAL:
            parts.add("normal");
            break;
        case Configuration.SCREENLAYOUT_SIZE_LARGE:
            parts.add("large");
            break;
        case Configuration.SCREENLAYOUT_SIZE_XLARGE:
            parts.add("xlarge");
            break;
        default:
            break;
    }
    switch(config.screenLayout & Configuration.SCREENLAYOUT_LONG_MASK) {
        case Configuration.SCREENLAYOUT_LONG_YES:
            parts.add("long");
            break;
        case Configuration.SCREENLAYOUT_LONG_NO:
            parts.add("notlong");
            break;
        default:
            break;
    }
    switch(config.orientation) {
        case Configuration.ORIENTATION_LANDSCAPE:
            parts.add("land");
            break;
        case Configuration.ORIENTATION_PORTRAIT:
            parts.add("port");
            break;
        default:
            break;
    }
    switch(config.uiMode & Configuration.UI_MODE_TYPE_MASK) {
        case Configuration.UI_MODE_TYPE_APPLIANCE:
            parts.add("appliance");
            break;
        case Configuration.UI_MODE_TYPE_DESK:
            parts.add("desk");
            break;
        case Configuration.UI_MODE_TYPE_TELEVISION:
            parts.add("television");
            break;
        case Configuration.UI_MODE_TYPE_CAR:
            parts.add("car");
            break;
        case Configuration.UI_MODE_TYPE_WATCH:
            parts.add("watch");
            break;
        default:
            break;
    }
    switch(config.uiMode & Configuration.UI_MODE_NIGHT_MASK) {
        case Configuration.UI_MODE_NIGHT_YES:
            parts.add("night");
            break;
        case Configuration.UI_MODE_NIGHT_NO:
            parts.add("notnight");
            break;
        default:
            break;
    }
    switch(config.densityDpi) {
        case DENSITY_DPI_UNDEFINED:
            break;
        case 120:
            parts.add("ldpi");
            break;
        case 160:
            parts.add("mdpi");
            break;
        case 213:
            parts.add("tvdpi");
            break;
        case 240:
            parts.add("hdpi");
            break;
        case 320:
            parts.add("xhdpi");
            break;
        case 480:
            parts.add("xxhdpi");
            break;
        case 640:
            parts.add("xxxhdpi");
            break;
        case DENSITY_DPI_ANY:
            parts.add("anydpi");
            break;
        case DENSITY_DPI_NONE:
            parts.add("nodpi");
        default:
            parts.add(config.densityDpi + "dpi");
            break;
    }
    switch(config.touchscreen) {
        case Configuration.TOUCHSCREEN_NOTOUCH:
            parts.add("notouch");
            break;
        case Configuration.TOUCHSCREEN_FINGER:
            parts.add("finger");
            break;
        default:
            break;
    }
    switch(config.keyboardHidden) {
        case Configuration.KEYBOARDHIDDEN_NO:
            parts.add("keysexposed");
            break;
        case Configuration.KEYBOARDHIDDEN_YES:
            parts.add("keyshidden");
            break;
        case Configuration.KEYBOARDHIDDEN_SOFT:
            parts.add("keyssoft");
            break;
        default:
            break;
    }
    switch(config.keyboard) {
        case Configuration.KEYBOARD_NOKEYS:
            parts.add("nokeys");
            break;
        case Configuration.KEYBOARD_QWERTY:
            parts.add("qwerty");
            break;
        case Configuration.KEYBOARD_12KEY:
            parts.add("12key");
            break;
        default:
            break;
    }
    switch(config.navigationHidden) {
        case Configuration.NAVIGATIONHIDDEN_NO:
            parts.add("navexposed");
            break;
        case Configuration.NAVIGATIONHIDDEN_YES:
            parts.add("navhidden");
            break;
        default:
            break;
    }
    switch(config.navigation) {
        case Configuration.NAVIGATION_NONAV:
            parts.add("nonav");
            break;
        case Configuration.NAVIGATION_DPAD:
            parts.add("dpad");
            break;
        case Configuration.NAVIGATION_TRACKBALL:
            parts.add("trackball");
            break;
        case Configuration.NAVIGATION_WHEEL:
            parts.add("wheel");
            break;
        default:
            break;
    }
    parts.add("v" + Build.VERSION.RESOURCES_SDK_INT);
    return TextUtils.join("-", parts);
}
Body of Second Method:
{
    ArrayList<String> parts = new ArrayList<String>();
    if (config.mcc != 0) {
        parts.add("mcc" + config.mcc);
        if (config.mnc != 0) {
            parts.add("mnc" + config.mnc);
        }
    }
    if (config.locale != null && !config.locale.getLanguage().isEmpty()) {
        parts.add(localeToResourceQualifier(config.locale));
    }
    switch(config.screenLayout & Configuration.SCREENLAYOUT_LAYOUTDIR_MASK) {
        case Configuration.SCREENLAYOUT_LAYOUTDIR_LTR:
            parts.add("ldltr");
            break;
        case Configuration.SCREENLAYOUT_LAYOUTDIR_RTL:
            parts.add("ldrtl");
            break;
        default:
            break;
    }
    if (config.smallestScreenWidthDp != 0) {
        parts.add("sw" + config.smallestScreenWidthDp + "dp");
    }
    if (config.screenWidthDp != 0) {
        parts.add("w" + config.screenWidthDp + "dp");
    }
    if (config.screenHeightDp != 0) {
        parts.add("h" + config.screenHeightDp + "dp");
    }
    switch(config.screenLayout & Configuration.SCREENLAYOUT_SIZE_MASK) {
        case Configuration.SCREENLAYOUT_SIZE_SMALL:
            parts.add("small");
            break;
        case Configuration.SCREENLAYOUT_SIZE_NORMAL:
            parts.add("normal");
            break;
        case Configuration.SCREENLAYOUT_SIZE_LARGE:
            parts.add("large");
            break;
        case Configuration.SCREENLAYOUT_SIZE_XLARGE:
            parts.add("xlarge");
            break;
        default:
            break;
    }
    switch(config.screenLayout & Configuration.SCREENLAYOUT_LONG_MASK) {
        case Configuration.SCREENLAYOUT_LONG_YES:
            parts.add("long");
            break;
        case Configuration.SCREENLAYOUT_LONG_NO:
            parts.add("notlong");
            break;
        default:
            break;
    }
    switch(config.orientation) {
        case Configuration.ORIENTATION_LANDSCAPE:
            parts.add("land");
            break;
        case Configuration.ORIENTATION_PORTRAIT:
            parts.add("port");
            break;
        default:
            break;
    }
    switch(config.uiMode & Configuration.UI_MODE_TYPE_MASK) {
        case Configuration.UI_MODE_TYPE_APPLIANCE:
            parts.add("appliance");
            break;
        case Configuration.UI_MODE_TYPE_DESK:
            parts.add("desk");
            break;
        case Configuration.UI_MODE_TYPE_TELEVISION:
            parts.add("television");
            break;
        case Configuration.UI_MODE_TYPE_CAR:
            parts.add("car");
            break;
        case Configuration.UI_MODE_TYPE_WATCH:
            parts.add("watch");
            break;
        default:
            break;
    }
    switch(config.uiMode & Configuration.UI_MODE_NIGHT_MASK) {
        case Configuration.UI_MODE_NIGHT_YES:
            parts.add("night");
            break;
        case Configuration.UI_MODE_NIGHT_NO:
            parts.add("notnight");
            break;
        default:
            break;
    }
    switch(config.densityDpi) {
        case DENSITY_DPI_UNDEFINED:
            break;
        case 120:
            parts.add("ldpi");
            break;
        case 160:
            parts.add("mdpi");
            break;
        case 213:
            parts.add("tvdpi");
            break;
        case 240:
            parts.add("hdpi");
            break;
        case 320:
            parts.add("xhdpi");
            break;
        case 480:
            parts.add("xxhdpi");
            break;
        case 640:
            parts.add("xxxhdpi");
            break;
        case DENSITY_DPI_ANY:
            parts.add("anydpi");
            break;
        case DENSITY_DPI_NONE:
            parts.add("nodpi");
        default:
            parts.add(config.densityDpi + "dpi");
            break;
    }
    switch(config.touchscreen) {
        case Configuration.TOUCHSCREEN_NOTOUCH:
            parts.add("notouch");
            break;
        case Configuration.TOUCHSCREEN_FINGER:
            parts.add("finger");
            break;
        default:
            break;
    }
    switch(config.keyboardHidden) {
        case Configuration.KEYBOARDHIDDEN_NO:
            parts.add("keysexposed");
            break;
        case Configuration.KEYBOARDHIDDEN_YES:
            parts.add("keyshidden");
            break;
        case Configuration.KEYBOARDHIDDEN_SOFT:
            parts.add("keyssoft");
            break;
        default:
            break;
    }
    switch(config.keyboard) {
        case Configuration.KEYBOARD_NOKEYS:
            parts.add("nokeys");
            break;
        case Configuration.KEYBOARD_QWERTY:
            parts.add("qwerty");
            break;
        case Configuration.KEYBOARD_12KEY:
            parts.add("12key");
            break;
        default:
            break;
    }
    switch(config.navigationHidden) {
        case Configuration.NAVIGATIONHIDDEN_NO:
            parts.add("navexposed");
            break;
        case Configuration.NAVIGATIONHIDDEN_YES:
            parts.add("navhidden");
            break;
        default:
            break;
    }
    switch(config.navigation) {
        case Configuration.NAVIGATION_NONAV:
            parts.add("nonav");
            break;
        case Configuration.NAVIGATION_DPAD:
            parts.add("dpad");
            break;
        case Configuration.NAVIGATION_TRACKBALL:
            parts.add("trackball");
            break;
        case Configuration.NAVIGATION_WHEEL:
            parts.add("wheel");
            break;
        default:
            break;
    }
    parts.add("v" + Build.VERSION.RESOURCES_SDK_INT);
    return TextUtils.join("-", parts);
}
------------------------
Find a silently evolved API code:android.webkit.WebSettings.setUseWideViewPort:COMMENT
<android.webkit.WebSettings: void setUseWideViewPort(boolean)>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Sets whether the WebView should enable support for the &quot;viewport&quot;
 * HTML meta tag or should use a wide viewport.
 * When the value of the setting is false, the layout width is always set to the
 * width of the WebView control in device-independent (CSS) pixels.
 * When the value is true and the page contains the viewport meta tag, the value
 * of the width specified in the tag is used. If the page does not contain the tag or
 * does not provide a width, then a wide viewport will be used.
 *
 * @param use whether to enable support for the viewport meta tag
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.content.res.ColorStateList.addFirstIfMissing:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * If the color state list does not already have an entry matching the
 * specified state, prepends a state set and color pair to a color state
 * list.
 * <p>
 * This is a workaround used in TimePicker and DatePicker until we can
 * add support for theme attributes in ColorStateList.
 *
 * @param colorStateList the source color state list
 * @param state the state to prepend
 * @param color the color to use for the given state
 * @return a new color state list, or the source color state list if there
 * was already a matching state set
 *
 * @hide Remove when we can support theme attributes.
 */

Body of Frist Method:
{
    final int[][] inputStates = colorStateList.getStates();
    for (int i = 0; i < inputStates.length; i++) {
        final int[] inputState = inputStates[i];
        for (int j = 0; j < inputState.length; j++) {
            if (inputState[i] == state) {
                return colorStateList;
            }
        }
    }
    final int[][] outputStates = new int[inputStates.length + 1][];
    System.arraycopy(inputStates, 0, outputStates, 1, inputStates.length);
    outputStates[0] = new int[] { state };
    final int[] inputColors = colorStateList.getColors();
    final int[] outputColors = new int[inputColors.length + 1];
    System.arraycopy(inputColors, 0, outputColors, 1, inputColors.length);
    outputColors[0] = color;
    return new ColorStateList(outputStates, outputColors);
}
Body of Second Method:
{
    final int[][] inputStates = colorStateList.getStates();
    for (int i = 0; i < inputStates.length; i++) {
        final int[] inputState = inputStates[i];
        for (int j = 0; j < inputState.length; j++) {
            if (inputState[j] == state) {
                return colorStateList;
            }
        }
    }
    final int[][] outputStates = new int[inputStates.length + 1][];
    System.arraycopy(inputStates, 0, outputStates, 1, inputStates.length);
    outputStates[0] = new int[] { state };
    final int[] inputColors = colorStateList.getColors();
    final int[] outputColors = new int[inputColors.length + 1];
    System.arraycopy(inputColors, 0, outputColors, 1, inputColors.length);
    outputColors[0] = color;
    return new ColorStateList(outputStates, outputColors);
}
------------------------
Find a silently evolved API code:android.webkit.WebSettings.getLoadsImagesAutomatically:COMMENT
<android.webkit.WebSettings: boolean getLoadsImagesAutomatically()>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Gets whether the WebView loads image resources. This includes
 * images embedded using the data URI scheme.
 *
 * @return true if the WebView loads image resources
 * @see #setLoadsImagesAutomatically
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.view.ViewRootImpl.drawSoftware:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * @return true if drawing was successful, false if an error occurred
 */

Body of Frist Method:
{
    // Draw with software renderer.
    final Canvas canvas;
    try {
        final int left = dirty.left;
        final int top = dirty.top;
        final int right = dirty.right;
        final int bottom = dirty.bottom;
        canvas = mSurface.lockCanvas(dirty);
        // noinspection ConstantConditions
        if (left != dirty.left || top != dirty.top || right != dirty.right || bottom != dirty.bottom) {
            attachInfo.mIgnoreDirtyState = true;
        }
        // TODO: Do this in native
        canvas.setDensity(mDensity);
    } catch (Surface.OutOfResourcesException e) {
        handleOutOfResourcesException(e);
        return false;
    } catch (IllegalArgumentException e) {
        Log.e(TAG, "Could not lock surface", e);
        // Don't assume this is due to out of memory, it could be
        // something else, and if it is something else then we could
        // kill stuff (or ourself) for no reason.
        // ask wm for a new surface next time.
        mLayoutRequested = true;
        return false;
    }
    try {
        if (DEBUG_ORIENTATION || DEBUG_DRAW) {
            Log.v(TAG, "Surface " + surface + " drawing to bitmap w=" + canvas.getWidth() + ", h=" + canvas.getHeight());
        // canvas.drawARGB(255, 255, 0, 0);
        }
        // left in the blank areas.
        if (!canvas.isOpaque() || yoff != 0 || xoff != 0) {
            canvas.drawColor(0, PorterDuff.Mode.CLEAR);
        }
        dirty.setEmpty();
        mIsAnimating = false;
        attachInfo.mDrawingTime = SystemClock.uptimeMillis();
        mView.mPrivateFlags |= View.PFLAG_DRAWN;
        if (DEBUG_DRAW) {
            Context cxt = mView.getContext();
            Log.i(TAG, "Drawing: package:" + cxt.getPackageName() + ", metrics=" + cxt.getResources().getDisplayMetrics() + ", compatibilityInfo=" + cxt.getResources().getCompatibilityInfo());
        }
        try {
            canvas.translate(-xoff, -yoff);
            if (mTranslator != null) {
                mTranslator.translateCanvas(canvas);
            }
            canvas.setScreenDensity(scalingRequired ? mNoncompatDensity : 0);
            attachInfo.mSetIgnoreDirtyState = false;
            mView.draw(canvas);
        } finally {
            if (!attachInfo.mSetIgnoreDirtyState) {
                // Only clear the flag if it was not set during the mView.draw() call
                attachInfo.mIgnoreDirtyState = false;
            }
        }
    } finally {
        try {
            surface.unlockCanvasAndPost(canvas);
        } catch (IllegalArgumentException e) {
            Log.e(TAG, "Could not unlock surface", e);
            // ask wm for a new surface next time.
            mLayoutRequested = true;
            // noinspection ReturnInsideFinallyBlock
            return false;
        }
        if (LOCAL_LOGV) {
            Log.v(TAG, "Surface " + surface + " unlockCanvasAndPost");
        }
    }
    return true;
}
Body of Second Method:
{
    // Draw with software renderer.
    final Canvas canvas;
    try {
        final int left = dirty.left;
        final int top = dirty.top;
        final int right = dirty.right;
        final int bottom = dirty.bottom;
        canvas = mSurface.lockCanvas(dirty);
        // noinspection ConstantConditions
        if (left != dirty.left || top != dirty.top || right != dirty.right || bottom != dirty.bottom) {
            attachInfo.mIgnoreDirtyState = true;
        }
        // TODO: Do this in native
        canvas.setDensity(mDensity);
    } catch (Surface.OutOfResourcesException e) {
        handleOutOfResourcesException(e);
        return false;
    } catch (IllegalArgumentException e) {
        Log.e(TAG, "Could not lock surface", e);
        // Don't assume this is due to out of memory, it could be
        // something else, and if it is something else then we could
        // kill stuff (or ourself) for no reason.
        // ask wm for a new surface next time.
        mLayoutRequested = true;
        return false;
    }
    try {
        if (DEBUG_ORIENTATION || DEBUG_DRAW) {
            Log.v(TAG, "Surface " + surface + " drawing to bitmap w=" + canvas.getWidth() + ", h=" + canvas.getHeight());
        // canvas.drawARGB(255, 255, 0, 0);
        }
        // left in the blank areas.
        if (!canvas.isOpaque() || yoff != 0 || xoff != 0) {
            canvas.drawColor(0, PorterDuff.Mode.CLEAR);
        }
        dirty.setEmpty();
        mIsAnimating = false;
        attachInfo.mDrawingTime = SystemClock.uptimeMillis();
        mView.mPrivateFlags |= View.PFLAG_DRAWN;
        if (DEBUG_DRAW) {
            Context cxt = mView.getContext();
            Log.i(TAG, "Drawing: package:" + cxt.getPackageName() + ", metrics=" + cxt.getResources().getDisplayMetrics() + ", compatibilityInfo=" + cxt.getResources().getCompatibilityInfo());
        }
        try {
            canvas.translate(-xoff, -yoff);
            if (mTranslator != null) {
                mTranslator.translateCanvas(canvas);
            }
            canvas.setScreenDensity(scalingRequired ? mNoncompatDensity : 0);
            attachInfo.mSetIgnoreDirtyState = false;
            mView.draw(canvas);
            drawAccessibilityFocusedDrawableIfNeeded(canvas);
        } finally {
            if (!attachInfo.mSetIgnoreDirtyState) {
                // Only clear the flag if it was not set during the mView.draw() call
                attachInfo.mIgnoreDirtyState = false;
            }
        }
    } finally {
        try {
            surface.unlockCanvasAndPost(canvas);
        } catch (IllegalArgumentException e) {
            Log.e(TAG, "Could not unlock surface", e);
            // ask wm for a new surface next time.
            mLayoutRequested = true;
            // noinspection ReturnInsideFinallyBlock
            return false;
        }
        if (LOCAL_LOGV) {
            Log.v(TAG, "Surface " + surface + " unlockCanvasAndPost");
        }
    }
    return true;
}
------------------------
Find a silently evolved API code:android.graphics.drawable.Ripple.cancel:COMMENT
Method Modifier: public      
Comment:/**
 * Cancels all animations. The caller is responsible for removing
 * the ripple from the list of animating ripples.
 */

Body of Frist Method:
{
    mCanceled = true;
    cancelSoftwareAnimations();
    cancelHardwareAnimations(true);
    mCanceled = false;
}
Body of Second Method:
{
    mCanceled = true;
    cancelSoftwareAnimations();
    cancelHardwareAnimations(false);
    mCanceled = false;
}
------------------------
Find a silently evolved API code:android.nfc.NfcActivityManager.createBeamShareData:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Callback from NFC service, usually on binder thread
 */

Body of Frist Method:
{
    NfcAdapter.CreateNdefMessageCallback ndefCallback;
    NfcAdapter.CreateBeamUrisCallback urisCallback;
    NdefMessage message;
    Activity activity;
    Uri[] uris;
    int flags;
    synchronized (NfcActivityManager.this) {
        NfcActivityState state = findResumedActivityState();
        if (state == null)
            return null;
        ndefCallback = state.ndefMessageCallback;
        urisCallback = state.uriCallback;
        message = state.ndefMessage;
        uris = state.uris;
        flags = state.flags;
        activity = state.activity;
    }
    // Make callbacks without lock
    if (ndefCallback != null) {
        message = ndefCallback.createNdefMessage(mDefaultEvent);
    }
    if (urisCallback != null) {
        uris = urisCallback.createBeamUris(mDefaultEvent);
        if (uris != null) {
            for (Uri uri : uris) {
                if (uri == null) {
                    Log.e(TAG, "Uri not allowed to be null.");
                    return null;
                }
                String scheme = uri.getScheme();
                if (scheme == null || (!scheme.equalsIgnoreCase("file") && !scheme.equalsIgnoreCase("content"))) {
                    Log.e(TAG, "Uri needs to have " + "either scheme file or scheme content");
                    return null;
                }
            }
        }
    }
    if (uris != null && uris.length > 0) {
        for (Uri uri : uris) {
            // Grant the NFC process permission to read these URIs
            activity.grantUriPermission("com.android.nfc", uri, Intent.FLAG_GRANT_READ_URI_PERMISSION);
        }
    }
    return new BeamShareData(message, uris, flags);
}
Body of Second Method:
{
    NfcAdapter.CreateNdefMessageCallback ndefCallback;
    NfcAdapter.CreateBeamUrisCallback urisCallback;
    NdefMessage message;
    Activity activity;
    Uri[] uris;
    int flags;
    synchronized (NfcActivityManager.this) {
        NfcActivityState state = findResumedActivityState();
        if (state == null)
            return null;
        ndefCallback = state.ndefMessageCallback;
        urisCallback = state.uriCallback;
        message = state.ndefMessage;
        uris = state.uris;
        flags = state.flags;
        activity = state.activity;
    }
    // Make callbacks without lock
    if (ndefCallback != null) {
        message = ndefCallback.createNdefMessage(mDefaultEvent);
    }
    if (urisCallback != null) {
        uris = urisCallback.createBeamUris(mDefaultEvent);
        if (uris != null) {
            ArrayList<Uri> validUris = new ArrayList<Uri>();
            for (Uri uri : uris) {
                if (uri == null) {
                    Log.e(TAG, "Uri not allowed to be null.");
                    continue;
                }
                String scheme = uri.getScheme();
                if (scheme == null || (!scheme.equalsIgnoreCase("file") && !scheme.equalsIgnoreCase("content"))) {
                    Log.e(TAG, "Uri needs to have " + "either scheme file or scheme content");
                    continue;
                }
                uri = ContentProvider.maybeAddUserId(uri, UserHandle.myUserId());
                validUris.add(uri);
            }
            uris = validUris.toArray(new Uri[validUris.size()]);
        }
    }
    if (uris != null && uris.length > 0) {
        for (Uri uri : uris) {
            // Grant the NFC process permission to read these URIs
            activity.grantUriPermission("com.android.nfc", uri, Intent.FLAG_GRANT_READ_URI_PERMISSION);
        }
    }
    return new BeamShareData(message, uris, UserHandle.CURRENT, flags);
}
------------------------
Find a silently evolved API code:android.webkit.WebSettings.getAllowContentAccess:COMMENT
<android.webkit.WebSettings: boolean getAllowContentAccess()>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Gets whether this WebView supports content URL access.
 *
 * @see #setAllowContentAccess
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.webkit.WebBackForwardList.getCurrentIndex:COMMENT
<android.webkit.WebBackForwardList: int getCurrentIndex()>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Get the index of the current history item. This index can be used to
 * directly index into the array list.
 * @return The current index from 0...n or -1 if the list is empty.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.webkit.WebSettings.setPluginState:COMMENT
<android.webkit.WebSettings: void setPluginState(PluginState)>
public      deprecated  ->public      abstract    deprecated  
Method Modifier: public      abstract    deprecated  
Method Modifier: Yes         No          Yes         
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * Tells the WebView to enable, disable, or have plugins on demand. On
 * demand mode means that if a plugin exists that can handle the embedded
 * content, a placeholder icon will be shown instead of the plugin. When
 * the placeholder is clicked, the plugin will be enabled. The default is
 * {@link PluginState#OFF}.
 *
 * @param state a PluginState value
 * @deprecated Plugins will not be supported in future, and should not be used.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.view.SurfaceView.updateWindow:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (!mHaveFrame) {
        return;
    }
    ViewRootImpl viewRoot = getViewRootImpl();
    if (viewRoot != null) {
        mTranslator = viewRoot.mTranslator;
    }
    if (mTranslator != null) {
        mSurface.setCompatibilityTranslator(mTranslator);
    }
    int myWidth = mRequestedWidth;
    if (myWidth <= 0)
        myWidth = getWidth();
    int myHeight = mRequestedHeight;
    if (myHeight <= 0)
        myHeight = getHeight();
    getLocationInWindow(mLocation);
    final boolean creating = mWindow == null;
    final boolean formatChanged = mFormat != mRequestedFormat;
    final boolean sizeChanged = mWidth != myWidth || mHeight != myHeight;
    final boolean visibleChanged = mVisible != mRequestedVisible;
    if (force || creating || formatChanged || sizeChanged || visibleChanged || mLeft != mLocation[0] || mTop != mLocation[1] || mUpdateWindowNeeded || mReportDrawNeeded || redrawNeeded) {
        if (DEBUG)
            Log.i(TAG, "Changes: creating=" + creating + " format=" + formatChanged + " size=" + sizeChanged + " visible=" + visibleChanged + " left=" + (mLeft != mLocation[0]) + " top=" + (mTop != mLocation[1]));
        try {
            final boolean visible = mVisible = mRequestedVisible;
            mLeft = mLocation[0];
            mTop = mLocation[1];
            mWidth = myWidth;
            mHeight = myHeight;
            mFormat = mRequestedFormat;
            // Scaling/Translate window's layout here because mLayout is not used elsewhere.
            // Places the window relative
            mLayout.x = mLeft;
            mLayout.y = mTop;
            mLayout.width = getWidth();
            mLayout.height = getHeight();
            if (mTranslator != null) {
                mTranslator.translateLayoutParamsInAppWindowToScreen(mLayout);
            }
            mLayout.format = mRequestedFormat;
            mLayout.flags |= WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_SCALED | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;
            if (!getContext().getResources().getCompatibilityInfo().supportsScreen()) {
                mLayout.privateFlags |= WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;
            }
            mLayout.privateFlags |= WindowManager.LayoutParams.PRIVATE_FLAG_NO_MOVE_ANIMATION;
            if (mWindow == null) {
                Display display = getDisplay();
                mWindow = new MyWindow(this);
                mLayout.type = mWindowType;
                mLayout.gravity = Gravity.START | Gravity.TOP;
                mSession.addToDisplayWithoutInputChannel(mWindow, mWindow.mSeq, mLayout, mVisible ? VISIBLE : GONE, display.getDisplayId(), mContentInsets);
            }
            boolean realSizeChanged;
            boolean reportDrawNeeded;
            int relayoutResult;
            mSurfaceLock.lock();
            try {
                mUpdateWindowNeeded = false;
                reportDrawNeeded = mReportDrawNeeded;
                mReportDrawNeeded = false;
                mDrawingStopped = !visible;
                if (DEBUG)
                    Log.i(TAG, "Cur surface: " + mSurface);
                relayoutResult = mSession.relayout(mWindow, mWindow.mSeq, mLayout, mWidth, mHeight, visible ? VISIBLE : GONE, WindowManagerGlobal.RELAYOUT_DEFER_SURFACE_DESTROY, mWinFrame, mOverscanInsets, mContentInsets, mVisibleInsets, mStableInsets, mConfiguration, mNewSurface);
                if ((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0) {
                    mReportDrawNeeded = true;
                }
                if (DEBUG)
                    Log.i(TAG, "New surface: " + mNewSurface + ", vis=" + visible + ", frame=" + mWinFrame);
                mSurfaceFrame.left = 0;
                mSurfaceFrame.top = 0;
                if (mTranslator == null) {
                    mSurfaceFrame.right = mWinFrame.width();
                    mSurfaceFrame.bottom = mWinFrame.height();
                } else {
                    float appInvertedScale = mTranslator.applicationInvertedScale;
                    mSurfaceFrame.right = (int) (mWinFrame.width() * appInvertedScale + 0.5f);
                    mSurfaceFrame.bottom = (int) (mWinFrame.height() * appInvertedScale + 0.5f);
                }
                final int surfaceWidth = mSurfaceFrame.right;
                final int surfaceHeight = mSurfaceFrame.bottom;
                realSizeChanged = mLastSurfaceWidth != surfaceWidth || mLastSurfaceHeight != surfaceHeight;
                mLastSurfaceWidth = surfaceWidth;
                mLastSurfaceHeight = surfaceHeight;
            } finally {
                mSurfaceLock.unlock();
            }
            try {
                redrawNeeded |= creating | reportDrawNeeded;
                SurfaceHolder.Callback[] callbacks = null;
                final boolean surfaceChanged = (relayoutResult & WindowManagerGlobal.RELAYOUT_RES_SURFACE_CHANGED) != 0;
                if (mSurfaceCreated && (surfaceChanged || (!visible && visibleChanged))) {
                    mSurfaceCreated = false;
                    if (mSurface.isValid()) {
                        if (DEBUG)
                            Log.i(TAG, "visibleChanged -- surfaceDestroyed");
                        callbacks = getSurfaceCallbacks();
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceDestroyed(mSurfaceHolder);
                        }
                    }
                }
                mSurface.transferFrom(mNewSurface);
                if (visible && mSurface.isValid()) {
                    if (!mSurfaceCreated && (surfaceChanged || visibleChanged)) {
                        mSurfaceCreated = true;
                        mIsCreating = true;
                        if (DEBUG)
                            Log.i(TAG, "visibleChanged -- surfaceCreated");
                        if (callbacks == null) {
                            callbacks = getSurfaceCallbacks();
                        }
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceCreated(mSurfaceHolder);
                        }
                    }
                    if (creating || formatChanged || sizeChanged || visibleChanged || realSizeChanged) {
                        if (DEBUG)
                            Log.i(TAG, "surfaceChanged -- format=" + mFormat + " w=" + myWidth + " h=" + myHeight);
                        if (callbacks == null) {
                            callbacks = getSurfaceCallbacks();
                        }
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceChanged(mSurfaceHolder, mFormat, myWidth, myHeight);
                        }
                    }
                    if (redrawNeeded) {
                        if (DEBUG)
                            Log.i(TAG, "surfaceRedrawNeeded");
                        if (callbacks == null) {
                            callbacks = getSurfaceCallbacks();
                        }
                        for (SurfaceHolder.Callback c : callbacks) {
                            if (c instanceof SurfaceHolder.Callback2) {
                                ((SurfaceHolder.Callback2) c).surfaceRedrawNeeded(mSurfaceHolder);
                            }
                        }
                    }
                }
            } finally {
                mIsCreating = false;
                if (redrawNeeded) {
                    if (DEBUG)
                        Log.i(TAG, "finishedDrawing");
                    mSession.finishDrawing(mWindow);
                }
                mSession.performDeferredDestroy(mWindow);
            }
        } catch (RemoteException ex) {
        }
        if (DEBUG)
            Log.v(TAG, "Layout: x=" + mLayout.x + " y=" + mLayout.y + " w=" + mLayout.width + " h=" + mLayout.height + ", frame=" + mSurfaceFrame);
    }
}
Body of Second Method:
{
    if (!mHaveFrame) {
        return;
    }
    ViewRootImpl viewRoot = getViewRootImpl();
    if (viewRoot != null) {
        mTranslator = viewRoot.mTranslator;
    }
    if (mTranslator != null) {
        mSurface.setCompatibilityTranslator(mTranslator);
    }
    int myWidth = mRequestedWidth;
    if (myWidth <= 0)
        myWidth = getWidth();
    int myHeight = mRequestedHeight;
    if (myHeight <= 0)
        myHeight = getHeight();
    getLocationInWindow(mLocation);
    final boolean creating = mWindow == null;
    final boolean formatChanged = mFormat != mRequestedFormat;
    final boolean sizeChanged = mWidth != myWidth || mHeight != myHeight;
    final boolean visibleChanged = mVisible != mRequestedVisible;
    if (force || creating || formatChanged || sizeChanged || visibleChanged || mLeft != mLocation[0] || mTop != mLocation[1] || mUpdateWindowNeeded || mReportDrawNeeded || redrawNeeded) {
        if (DEBUG)
            Log.i(TAG, "Changes: creating=" + creating + " format=" + formatChanged + " size=" + sizeChanged + " visible=" + visibleChanged + " left=" + (mLeft != mLocation[0]) + " top=" + (mTop != mLocation[1]));
        try {
            final boolean visible = mVisible = mRequestedVisible;
            mLeft = mLocation[0];
            mTop = mLocation[1];
            mWidth = myWidth;
            mHeight = myHeight;
            mFormat = mRequestedFormat;
            // Scaling/Translate window's layout here because mLayout is not used elsewhere.
            // Places the window relative
            mLayout.x = mLeft;
            mLayout.y = mTop;
            mLayout.width = getWidth();
            mLayout.height = getHeight();
            if (mTranslator != null) {
                mTranslator.translateLayoutParamsInAppWindowToScreen(mLayout);
            }
            mLayout.format = mRequestedFormat;
            mLayout.flags |= WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS | WindowManager.LayoutParams.FLAG_SCALED | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;
            if (!getContext().getResources().getCompatibilityInfo().supportsScreen()) {
                mLayout.privateFlags |= WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;
            }
            mLayout.privateFlags |= WindowManager.LayoutParams.PRIVATE_FLAG_NO_MOVE_ANIMATION;
            if (mWindow == null) {
                Display display = getDisplay();
                mWindow = new MyWindow(this);
                mLayout.type = mWindowType;
                mLayout.gravity = Gravity.START | Gravity.TOP;
                mSession.addToDisplayWithoutInputChannel(mWindow, mWindow.mSeq, mLayout, mVisible ? VISIBLE : GONE, display.getDisplayId(), mContentInsets, mStableInsets);
            }
            boolean realSizeChanged;
            boolean reportDrawNeeded;
            int relayoutResult;
            mSurfaceLock.lock();
            try {
                mUpdateWindowNeeded = false;
                reportDrawNeeded = mReportDrawNeeded;
                mReportDrawNeeded = false;
                mDrawingStopped = !visible;
                if (DEBUG)
                    Log.i(TAG, "Cur surface: " + mSurface);
                relayoutResult = mSession.relayout(mWindow, mWindow.mSeq, mLayout, mWidth, mHeight, visible ? VISIBLE : GONE, WindowManagerGlobal.RELAYOUT_DEFER_SURFACE_DESTROY, mWinFrame, mOverscanInsets, mContentInsets, mVisibleInsets, mStableInsets, mConfiguration, mNewSurface);
                if ((relayoutResult & WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0) {
                    mReportDrawNeeded = true;
                }
                if (DEBUG)
                    Log.i(TAG, "New surface: " + mNewSurface + ", vis=" + visible + ", frame=" + mWinFrame);
                mSurfaceFrame.left = 0;
                mSurfaceFrame.top = 0;
                if (mTranslator == null) {
                    mSurfaceFrame.right = mWinFrame.width();
                    mSurfaceFrame.bottom = mWinFrame.height();
                } else {
                    float appInvertedScale = mTranslator.applicationInvertedScale;
                    mSurfaceFrame.right = (int) (mWinFrame.width() * appInvertedScale + 0.5f);
                    mSurfaceFrame.bottom = (int) (mWinFrame.height() * appInvertedScale + 0.5f);
                }
                final int surfaceWidth = mSurfaceFrame.right;
                final int surfaceHeight = mSurfaceFrame.bottom;
                realSizeChanged = mLastSurfaceWidth != surfaceWidth || mLastSurfaceHeight != surfaceHeight;
                mLastSurfaceWidth = surfaceWidth;
                mLastSurfaceHeight = surfaceHeight;
            } finally {
                mSurfaceLock.unlock();
            }
            try {
                redrawNeeded |= creating | reportDrawNeeded;
                SurfaceHolder.Callback[] callbacks = null;
                final boolean surfaceChanged = (relayoutResult & WindowManagerGlobal.RELAYOUT_RES_SURFACE_CHANGED) != 0;
                if (mSurfaceCreated && (surfaceChanged || (!visible && visibleChanged))) {
                    mSurfaceCreated = false;
                    if (mSurface.isValid()) {
                        if (DEBUG)
                            Log.i(TAG, "visibleChanged -- surfaceDestroyed");
                        callbacks = getSurfaceCallbacks();
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceDestroyed(mSurfaceHolder);
                        }
                    }
                }
                mSurface.transferFrom(mNewSurface);
                if (visible && mSurface.isValid()) {
                    if (!mSurfaceCreated && (surfaceChanged || visibleChanged)) {
                        mSurfaceCreated = true;
                        mIsCreating = true;
                        if (DEBUG)
                            Log.i(TAG, "visibleChanged -- surfaceCreated");
                        if (callbacks == null) {
                            callbacks = getSurfaceCallbacks();
                        }
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceCreated(mSurfaceHolder);
                        }
                    }
                    if (creating || formatChanged || sizeChanged || visibleChanged || realSizeChanged) {
                        if (DEBUG)
                            Log.i(TAG, "surfaceChanged -- format=" + mFormat + " w=" + myWidth + " h=" + myHeight);
                        if (callbacks == null) {
                            callbacks = getSurfaceCallbacks();
                        }
                        for (SurfaceHolder.Callback c : callbacks) {
                            c.surfaceChanged(mSurfaceHolder, mFormat, myWidth, myHeight);
                        }
                    }
                    if (redrawNeeded) {
                        if (DEBUG)
                            Log.i(TAG, "surfaceRedrawNeeded");
                        if (callbacks == null) {
                            callbacks = getSurfaceCallbacks();
                        }
                        for (SurfaceHolder.Callback c : callbacks) {
                            if (c instanceof SurfaceHolder.Callback2) {
                                ((SurfaceHolder.Callback2) c).surfaceRedrawNeeded(mSurfaceHolder);
                            }
                        }
                    }
                }
            } finally {
                mIsCreating = false;
                if (redrawNeeded) {
                    if (DEBUG)
                        Log.i(TAG, "finishedDrawing");
                    mSession.finishDrawing(mWindow);
                }
                mSession.performDeferredDestroy(mWindow);
            }
        } catch (RemoteException ex) {
        }
        if (DEBUG)
            Log.v(TAG, "Layout: x=" + mLayout.x + " y=" + mLayout.y + " w=" + mLayout.width + " h=" + mLayout.height + ", frame=" + mSurfaceFrame);
    }
}
------------------------
Find a silently evolved API code:android.view.ViewRootImpl.setView:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * We have one child
 */

Body of Frist Method:
{
    synchronized (this) {
        if (mView == null) {
            mView = view;
            mAttachInfo.mDisplayState = mDisplay.getState();
            mDisplayManager.registerDisplayListener(mDisplayListener, mHandler);
            mViewLayoutDirectionInitial = mView.getRawLayoutDirection();
            mFallbackEventHandler.setView(view);
            mWindowAttributes.copyFrom(attrs);
            if (mWindowAttributes.packageName == null) {
                mWindowAttributes.packageName = mBasePackageName;
            }
            attrs = mWindowAttributes;
            // Keep track of the actual window flags supplied by the client.
            mClientWindowLayoutFlags = attrs.flags;
            setAccessibilityFocus(null, null);
            if (view instanceof RootViewSurfaceTaker) {
                mSurfaceHolderCallback = ((RootViewSurfaceTaker) view).willYouTakeTheSurface();
                if (mSurfaceHolderCallback != null) {
                    mSurfaceHolder = new TakenSurfaceHolder();
                    mSurfaceHolder.setFormat(PixelFormat.UNKNOWN);
                }
            }
            // Compute surface insets required to draw at specified Z value.
            // TODO: Use real shadow insets for a constant max Z.
            final int surfaceInset = (int) Math.ceil(view.getZ() * 2);
            attrs.surfaceInsets.set(surfaceInset, surfaceInset, surfaceInset, surfaceInset);
            CompatibilityInfo compatibilityInfo = mDisplayAdjustments.getCompatibilityInfo();
            mTranslator = compatibilityInfo.getTranslator();
            mDisplayAdjustments.setActivityToken(attrs.token);
            // If the application owns the surface, don't enable hardware acceleration
            if (mSurfaceHolder == null) {
                enableHardwareAcceleration(attrs);
            }
            boolean restore = false;
            if (mTranslator != null) {
                mSurface.setCompatibilityTranslator(mTranslator);
                restore = true;
                attrs.backup();
                mTranslator.translateWindowLayout(attrs);
            }
            if (DEBUG_LAYOUT)
                Log.d(TAG, "WindowLayout in setView:" + attrs);
            if (!compatibilityInfo.supportsScreen()) {
                attrs.privateFlags |= WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;
                mLastInCompatMode = true;
            }
            mSoftInputMode = attrs.softInputMode;
            mWindowAttributesChanged = true;
            mWindowAttributesChangesFlag = WindowManager.LayoutParams.EVERYTHING_CHANGED;
            mAttachInfo.mRootView = view;
            mAttachInfo.mScalingRequired = mTranslator != null;
            mAttachInfo.mApplicationScale = mTranslator == null ? 1.0f : mTranslator.applicationScale;
            if (panelParentView != null) {
                mAttachInfo.mPanelParentWindowToken = panelParentView.getApplicationWindowToken();
            }
            mAdded = true;
            int res;
            /* = WindowManagerImpl.ADD_OKAY; */
            // Schedule the first layout -before- adding to the window
            // manager, to make sure we do the relayout before receiving
            // any other events from the system.
            requestLayout();
            if ((mWindowAttributes.inputFeatures & WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == 0) {
                mInputChannel = new InputChannel();
            }
            try {
                mOrigWindowType = mWindowAttributes.type;
                mAttachInfo.mRecomputeGlobalAttributes = true;
                collectViewAttributes();
                res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes, getHostVisibility(), mDisplay.getDisplayId(), mAttachInfo.mContentInsets, mInputChannel);
            } catch (RemoteException e) {
                mAdded = false;
                mView = null;
                mAttachInfo.mRootView = null;
                mInputChannel = null;
                mFallbackEventHandler.setView(null);
                unscheduleTraversals();
                setAccessibilityFocus(null, null);
                throw new RuntimeException("Adding window failed", e);
            } finally {
                if (restore) {
                    attrs.restore();
                }
            }
            if (mTranslator != null) {
                mTranslator.translateRectInScreenToAppWindow(mAttachInfo.mContentInsets);
            }
            mPendingOverscanInsets.set(0, 0, 0, 0);
            mPendingContentInsets.set(mAttachInfo.mContentInsets);
            mPendingStableInsets.set(mAttachInfo.mStableInsets);
            mPendingVisibleInsets.set(0, 0, 0, 0);
            if (DEBUG_LAYOUT)
                Log.v(TAG, "Added window " + mWindow);
            if (res < WindowManagerGlobal.ADD_OKAY) {
                mAttachInfo.mRootView = null;
                mAdded = false;
                mFallbackEventHandler.setView(null);
                unscheduleTraversals();
                setAccessibilityFocus(null, null);
                switch(res) {
                    case WindowManagerGlobal.ADD_BAD_APP_TOKEN:
                    case WindowManagerGlobal.ADD_BAD_SUBWINDOW_TOKEN:
                        throw new WindowManager.BadTokenException("Unable to add window -- token " + attrs.token + " is not valid; is your activity running?");
                    case WindowManagerGlobal.ADD_NOT_APP_TOKEN:
                        throw new WindowManager.BadTokenException("Unable to add window -- token " + attrs.token + " is not for an application");
                    case WindowManagerGlobal.ADD_APP_EXITING:
                        throw new WindowManager.BadTokenException("Unable to add window -- app for token " + attrs.token + " is exiting");
                    case WindowManagerGlobal.ADD_DUPLICATE_ADD:
                        throw new WindowManager.BadTokenException("Unable to add window -- window " + mWindow + " has already been added");
                    case WindowManagerGlobal.ADD_STARTING_NOT_NEEDED:
                        // right away, anyway.
                        return;
                    case WindowManagerGlobal.ADD_MULTIPLE_SINGLETON:
                        throw new WindowManager.BadTokenException("Unable to add window " + mWindow + " -- another window of this type already exists");
                    case WindowManagerGlobal.ADD_PERMISSION_DENIED:
                        throw new WindowManager.BadTokenException("Unable to add window " + mWindow + " -- permission denied for this window type");
                    case WindowManagerGlobal.ADD_INVALID_DISPLAY:
                        throw new WindowManager.InvalidDisplayException("Unable to add window " + mWindow + " -- the specified display can not be found");
                }
                throw new RuntimeException("Unable to add window -- unknown error code " + res);
            }
            if (view instanceof RootViewSurfaceTaker) {
                mInputQueueCallback = ((RootViewSurfaceTaker) view).willYouTakeTheInputQueue();
            }
            if (mInputChannel != null) {
                if (mInputQueueCallback != null) {
                    mInputQueue = new InputQueue();
                    mInputQueueCallback.onInputQueueCreated(mInputQueue);
                }
                mInputEventReceiver = new WindowInputEventReceiver(mInputChannel, Looper.myLooper());
            }
            view.assignParent(this);
            mAddedTouchMode = (res & WindowManagerGlobal.ADD_FLAG_IN_TOUCH_MODE) != 0;
            mAppVisible = (res & WindowManagerGlobal.ADD_FLAG_APP_VISIBLE) != 0;
            if (mAccessibilityManager.isEnabled()) {
                mAccessibilityInteractionConnectionManager.ensureConnection();
            }
            if (view.getImportantForAccessibility() == View.IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
                view.setImportantForAccessibility(View.IMPORTANT_FOR_ACCESSIBILITY_YES);
            }
            // Set up the input pipeline.
            CharSequence counterSuffix = attrs.getTitle();
            mSyntheticInputStage = new SyntheticInputStage();
            InputStage viewPostImeStage = new ViewPostImeInputStage(mSyntheticInputStage);
            InputStage nativePostImeStage = new NativePostImeInputStage(viewPostImeStage, "aq:native-post-ime:" + counterSuffix);
            InputStage earlyPostImeStage = new EarlyPostImeInputStage(nativePostImeStage);
            InputStage imeStage = new ImeInputStage(earlyPostImeStage, "aq:ime:" + counterSuffix);
            InputStage viewPreImeStage = new ViewPreImeInputStage(imeStage);
            InputStage nativePreImeStage = new NativePreImeInputStage(viewPreImeStage, "aq:native-pre-ime:" + counterSuffix);
            mFirstInputStage = nativePreImeStage;
            mFirstPostImeInputStage = earlyPostImeStage;
            mPendingInputEventQueueLengthCounterName = "aq:pending:" + counterSuffix;
        }
    }
}
Body of Second Method:
{
    synchronized (this) {
        if (mView == null) {
            mView = view;
            mAttachInfo.mDisplayState = mDisplay.getState();
            mDisplayManager.registerDisplayListener(mDisplayListener, mHandler);
            mViewLayoutDirectionInitial = mView.getRawLayoutDirection();
            mFallbackEventHandler.setView(view);
            mWindowAttributes.copyFrom(attrs);
            if (mWindowAttributes.packageName == null) {
                mWindowAttributes.packageName = mBasePackageName;
            }
            attrs = mWindowAttributes;
            // Keep track of the actual window flags supplied by the client.
            mClientWindowLayoutFlags = attrs.flags;
            setAccessibilityFocus(null, null);
            if (view instanceof RootViewSurfaceTaker) {
                mSurfaceHolderCallback = ((RootViewSurfaceTaker) view).willYouTakeTheSurface();
                if (mSurfaceHolderCallback != null) {
                    mSurfaceHolder = new TakenSurfaceHolder();
                    mSurfaceHolder.setFormat(PixelFormat.UNKNOWN);
                }
            }
            // Compute surface insets required to draw at specified Z value.
            // TODO: Use real shadow insets for a constant max Z.
            final int surfaceInset = (int) Math.ceil(view.getZ() * 2);
            attrs.surfaceInsets.set(surfaceInset, surfaceInset, surfaceInset, surfaceInset);
            CompatibilityInfo compatibilityInfo = mDisplayAdjustments.getCompatibilityInfo();
            mTranslator = compatibilityInfo.getTranslator();
            mDisplayAdjustments.setActivityToken(attrs.token);
            // If the application owns the surface, don't enable hardware acceleration
            if (mSurfaceHolder == null) {
                enableHardwareAcceleration(attrs);
            }
            boolean restore = false;
            if (mTranslator != null) {
                mSurface.setCompatibilityTranslator(mTranslator);
                restore = true;
                attrs.backup();
                mTranslator.translateWindowLayout(attrs);
            }
            if (DEBUG_LAYOUT)
                Log.d(TAG, "WindowLayout in setView:" + attrs);
            if (!compatibilityInfo.supportsScreen()) {
                attrs.privateFlags |= WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;
                mLastInCompatMode = true;
            }
            mSoftInputMode = attrs.softInputMode;
            mWindowAttributesChanged = true;
            mWindowAttributesChangesFlag = WindowManager.LayoutParams.EVERYTHING_CHANGED;
            mAttachInfo.mRootView = view;
            mAttachInfo.mScalingRequired = mTranslator != null;
            mAttachInfo.mApplicationScale = mTranslator == null ? 1.0f : mTranslator.applicationScale;
            if (panelParentView != null) {
                mAttachInfo.mPanelParentWindowToken = panelParentView.getApplicationWindowToken();
            }
            mAdded = true;
            int res;
            /* = WindowManagerImpl.ADD_OKAY; */
            // Schedule the first layout -before- adding to the window
            // manager, to make sure we do the relayout before receiving
            // any other events from the system.
            requestLayout();
            if ((mWindowAttributes.inputFeatures & WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == 0) {
                mInputChannel = new InputChannel();
            }
            try {
                mOrigWindowType = mWindowAttributes.type;
                mAttachInfo.mRecomputeGlobalAttributes = true;
                collectViewAttributes();
                res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes, getHostVisibility(), mDisplay.getDisplayId(), mAttachInfo.mContentInsets, mAttachInfo.mStableInsets, mInputChannel);
            } catch (RemoteException e) {
                mAdded = false;
                mView = null;
                mAttachInfo.mRootView = null;
                mInputChannel = null;
                mFallbackEventHandler.setView(null);
                unscheduleTraversals();
                setAccessibilityFocus(null, null);
                throw new RuntimeException("Adding window failed", e);
            } finally {
                if (restore) {
                    attrs.restore();
                }
            }
            if (mTranslator != null) {
                mTranslator.translateRectInScreenToAppWindow(mAttachInfo.mContentInsets);
            }
            mPendingOverscanInsets.set(0, 0, 0, 0);
            mPendingContentInsets.set(mAttachInfo.mContentInsets);
            mPendingStableInsets.set(mAttachInfo.mStableInsets);
            mPendingVisibleInsets.set(0, 0, 0, 0);
            if (DEBUG_LAYOUT)
                Log.v(TAG, "Added window " + mWindow);
            if (res < WindowManagerGlobal.ADD_OKAY) {
                mAttachInfo.mRootView = null;
                mAdded = false;
                mFallbackEventHandler.setView(null);
                unscheduleTraversals();
                setAccessibilityFocus(null, null);
                switch(res) {
                    case WindowManagerGlobal.ADD_BAD_APP_TOKEN:
                    case WindowManagerGlobal.ADD_BAD_SUBWINDOW_TOKEN:
                        throw new WindowManager.BadTokenException("Unable to add window -- token " + attrs.token + " is not valid; is your activity running?");
                    case WindowManagerGlobal.ADD_NOT_APP_TOKEN:
                        throw new WindowManager.BadTokenException("Unable to add window -- token " + attrs.token + " is not for an application");
                    case WindowManagerGlobal.ADD_APP_EXITING:
                        throw new WindowManager.BadTokenException("Unable to add window -- app for token " + attrs.token + " is exiting");
                    case WindowManagerGlobal.ADD_DUPLICATE_ADD:
                        throw new WindowManager.BadTokenException("Unable to add window -- window " + mWindow + " has already been added");
                    case WindowManagerGlobal.ADD_STARTING_NOT_NEEDED:
                        // right away, anyway.
                        return;
                    case WindowManagerGlobal.ADD_MULTIPLE_SINGLETON:
                        throw new WindowManager.BadTokenException("Unable to add window " + mWindow + " -- another window of this type already exists");
                    case WindowManagerGlobal.ADD_PERMISSION_DENIED:
                        throw new WindowManager.BadTokenException("Unable to add window " + mWindow + " -- permission denied for this window type");
                    case WindowManagerGlobal.ADD_INVALID_DISPLAY:
                        throw new WindowManager.InvalidDisplayException("Unable to add window " + mWindow + " -- the specified display can not be found");
                    case WindowManagerGlobal.ADD_INVALID_TYPE:
                        throw new WindowManager.InvalidDisplayException("Unable to add window " + mWindow + " -- the specified window type is not valid");
                }
                throw new RuntimeException("Unable to add window -- unknown error code " + res);
            }
            if (view instanceof RootViewSurfaceTaker) {
                mInputQueueCallback = ((RootViewSurfaceTaker) view).willYouTakeTheInputQueue();
            }
            if (mInputChannel != null) {
                if (mInputQueueCallback != null) {
                    mInputQueue = new InputQueue();
                    mInputQueueCallback.onInputQueueCreated(mInputQueue);
                }
                mInputEventReceiver = new WindowInputEventReceiver(mInputChannel, Looper.myLooper());
            }
            view.assignParent(this);
            mAddedTouchMode = (res & WindowManagerGlobal.ADD_FLAG_IN_TOUCH_MODE) != 0;
            mAppVisible = (res & WindowManagerGlobal.ADD_FLAG_APP_VISIBLE) != 0;
            if (mAccessibilityManager.isEnabled()) {
                mAccessibilityInteractionConnectionManager.ensureConnection();
            }
            if (view.getImportantForAccessibility() == View.IMPORTANT_FOR_ACCESSIBILITY_AUTO) {
                view.setImportantForAccessibility(View.IMPORTANT_FOR_ACCESSIBILITY_YES);
            }
            // Set up the input pipeline.
            CharSequence counterSuffix = attrs.getTitle();
            mSyntheticInputStage = new SyntheticInputStage();
            InputStage viewPostImeStage = new ViewPostImeInputStage(mSyntheticInputStage);
            InputStage nativePostImeStage = new NativePostImeInputStage(viewPostImeStage, "aq:native-post-ime:" + counterSuffix);
            InputStage earlyPostImeStage = new EarlyPostImeInputStage(nativePostImeStage);
            InputStage imeStage = new ImeInputStage(earlyPostImeStage, "aq:ime:" + counterSuffix);
            InputStage viewPreImeStage = new ViewPreImeInputStage(imeStage);
            InputStage nativePreImeStage = new NativePreImeInputStage(viewPreImeStage, "aq:native-pre-ime:" + counterSuffix);
            mFirstInputStage = nativePreImeStage;
            mFirstPostImeInputStage = earlyPostImeStage;
            mPendingInputEventQueueLengthCounterName = "aq:pending:" + counterSuffix;
        }
    }
}
------------------------
Find a silently evolved API code:android.webkit.WebSettings.setDatabaseEnabled:COMMENT
<android.webkit.WebSettings: void setDatabaseEnabled(boolean)>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Sets whether the database storage API is enabled. The default value is
 * false. See also {@link #setDatabasePath} for how to correctly set up the
 * database storage API.
 *
 * This setting is global in effect, across all WebView instances in a process.
 * Note you should only modify this setting prior to making <b>any</b> WebView
 * page load within a given process, as the WebView implementation may ignore
 * changes to this setting after that point.
 *
 * @param flag true if the WebView should use the database storage API
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.webkit.WebSettings.getMinimumLogicalFontSize:COMMENT
<android.webkit.WebSettings: int getMinimumLogicalFontSize()>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Gets the minimum logical font size.
 *
 * @return a non-negative integer between 1 and 72
 * @see #setMinimumLogicalFontSize
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.webkit.WebSettings.setNavDump:COMMENT
<android.webkit.WebSettings: void setNavDump(boolean)>
public      hidden      deprecated  ->public      abstract    hidden      deprecated  
Method Modifier: public      abstract    hidden      deprecated  
Method Modifier: Yes         No          Yes         Yes         
Method Updated:  Yes         Yes         Yes         Yes         
Comment:/**
 * Enables dumping the pages navigation cache to a text file. The default
 * is false.
 *
 * @deprecated This method is now obsolete.
 * @hide Since API level {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1}
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.webkit.WebSettings.setAllowFileAccess:COMMENT
<android.webkit.WebSettings: void setAllowFileAccess(boolean)>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Enables or disables file access within WebView. File access is enabled by
 * default.  Note that this enables or disables file system access only.
 * Assets and resources are still accessible using file:///android_asset and
 * file:///android_res.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.net.RssiCurve.lookupScore:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Lookup the score for a given RSSI value.
 *
 * @param rssi The RSSI to lookup. If the RSSI falls below the start of the curve, the score at
 * the start of the curve will be returned. If it falls after the end of the curve, the
 * score at the end of the curve will be returned.
 * @return the score for the given RSSI.
 */

Body of Frist Method:
{
    int index = (rssi - start) / bucketWidth;
    // Snap the index to the closest bucket if it falls outside the curve.
    if (index < 0) {
        index = 0;
    } else if (index > rssiBuckets.length - 1) {
        index = rssiBuckets.length - 1;
    }
    return rssiBuckets[index];
}
Body of Second Method:
{
    return lookupScore(rssi, false);
}
------------------------
Find a silently evolved API code:android.media.Image.setCropRect:COMMENT
Method Modifier: public      
Comment:/**
 * Set the crop rectangle associated with this frame.
 * <p>
 * The crop rectangle specifies the region of valid pixels in the image,
 * using coordinates in the largest-resolution plane.
 */

Body of Frist Method:
{
    // make a copy
    cropRect = new Rect(cropRect);
    cropRect.intersect(0, 0, getWidth(), getHeight());
    mCropRect = cropRect;
}
Body of Second Method:
{
    if (cropRect != null) {
        // make a copy
        cropRect = new Rect(cropRect);
        cropRect.intersect(0, 0, getWidth(), getHeight());
    }
    mCropRect = cropRect;
}
------------------------
Find a silently evolved API code:android.app.Notification.Action.WearableExtender.extend:COMMENT
Method Modifier: public      
Comment:/**
 * Apply wearable extensions to a notification action that is being built. This is
 * typically called by the {@link android.app.Notification.Action.Builder#extend}
 * method of {@link android.app.Notification.Action.Builder}.
 */

Body of Frist Method:
{
    Bundle wearableBundle = new Bundle();
    if (mFlags != DEFAULT_FLAGS) {
        wearableBundle.putInt(KEY_FLAGS, mFlags);
    }
    builder.getExtras().putBundle(EXTRA_WEARABLE_EXTENSIONS, wearableBundle);
    return builder;
}
Body of Second Method:
{
    Bundle wearableBundle = new Bundle();
    if (mFlags != DEFAULT_FLAGS) {
        wearableBundle.putInt(KEY_FLAGS, mFlags);
    }
    if (mInProgressLabel != null) {
        wearableBundle.putCharSequence(KEY_IN_PROGRESS_LABEL, mInProgressLabel);
    }
    if (mConfirmLabel != null) {
        wearableBundle.putCharSequence(KEY_CONFIRM_LABEL, mConfirmLabel);
    }
    if (mCancelLabel != null) {
        wearableBundle.putCharSequence(KEY_CANCEL_LABEL, mCancelLabel);
    }
    builder.getExtras().putBundle(EXTRA_WEARABLE_EXTENSIONS, wearableBundle);
    return builder;
}
------------------------
Find a silently evolved API code:android.webkit.WebSettings.getSansSerifFontFamily:COMMENT
<android.webkit.WebSettings: String getSansSerifFontFamily()>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Gets the sans-serif font family name.
 *
 * @return the sans-serif font family name as a string
 * @see #setSansSerifFontFamily
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.graphics.drawable.RotateDrawable.setPivotYRelative:COMMENT
Method Modifier: public      
Comment:/**
 * Sets whether the Y pivot value represents a fraction of the drawable
 * height or an absolute value in pixels.
 *
 * @param relative True if the Y pivot represents a fraction of the drawable
 * height, or false if it represents an absolute value in pixels
 *
 * @see #isPivotYRelative()
 */

Body of Frist Method:
{
    if (mState.mPivotYRel == relative) {
        mState.mPivotYRel = relative;
        invalidateSelf();
    }
}
Body of Second Method:
{
    if (mState.mPivotYRel != relative) {
        mState.mPivotYRel = relative;
        invalidateSelf();
    }
}
------------------------
Find a silently evolved API code:android.webkit.WebView.removeJavascriptInterface:COMMENT
Method Modifier: public      
Comment:/**
 * Removes a previously injected Java object from this WebView. Note that
 * the removal will not be reflected in JavaScript until the page is next
 * (re)loaded. See {@link #addJavascriptInterface}.
 *
 * @param name the name used to expose the object in JavaScript
 */

Body of Frist Method:
{
    checkThread();
    if (DebugFlags.TRACE_API)
        Log.d(LOGTAG, "removeJavascriptInterface=" + name);
    mProvider.removeJavascriptInterface(name);
}
Body of Second Method:
{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, "removeJavascriptInterface=" + name);
    mProvider.removeJavascriptInterface(name);
}
------------------------
Find a silently evolved API code:android.webkit.WebSettings.setLoadWithOverviewMode:COMMENT
<android.webkit.WebSettings: void setLoadWithOverviewMode(boolean)>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Sets whether the WebView loads pages in overview mode, that is,
 * zooms out the content to fit on screen by width. This setting is
 * taken into account when the content width is greater than the width
 * of the WebView control, for example, when {@link #getUseWideViewPort}
 * is enabled. The default is false.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.webkit.WebSettings.setSupportZoom:COMMENT
<android.webkit.WebSettings: void setSupportZoom(boolean)>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Sets whether the WebView should support zooming using its on-screen zoom
 * controls and gestures. The particular zoom mechanisms that should be used
 * can be set with {@link #setBuiltInZoomControls}. This setting does not
 * affect zooming performed using the {@link WebView#zoomIn()} and
 * {@link WebView#zoomOut()} methods. The default is true.
 *
 * @param support whether the WebView should support zoom
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.app.backup.WallpaperBackupHelper.restoreEntity:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Restore one absolute file entity from the restore stream.  If we're restoring the
 * magic wallpaper file, take specific action to determine whether it is suitable for
 * the current device.
 */

Body of Frist Method:
{
    final String key = data.getKey();
    if (isKeyInList(key, mKeys)) {
        if (key.equals(WALLPAPER_IMAGE_KEY)) {
            // restore the file to the stage for inspection
            File f = new File(STAGE_FILE);
            if (writeFile(f, data)) {
                // Preflight the restored image's dimensions without loading it
                BitmapFactory.Options options = new BitmapFactory.Options();
                options.inJustDecodeBounds = true;
                BitmapFactory.decodeFile(STAGE_FILE, options);
                if (DEBUG)
                    Slog.d(TAG, "Restoring wallpaper image w=" + options.outWidth + " h=" + options.outHeight);
                if (REJECT_OUTSIZED_RESTORE) {
                    // We accept any wallpaper that is at least as wide as our preference
                    // (i.e. wide enough to fill the screen), and is within a comfortable
                    // factor of the target height, to avoid significant clipping/scaling/
                    // letterboxing.
                    final double heightRatio = mDesiredMinHeight / options.outHeight;
                    if (options.outWidth < mDesiredMinWidth || heightRatio >= MAX_HEIGHT_RATIO || heightRatio <= MIN_HEIGHT_RATIO) {
                        // Not wide enough for the screen, or too short/tall to be a good fit
                        // for the height of the screen, broken image file, or the system's
                        // desires for wallpaper size are in a bad state.  Probably one of the
                        // first two.
                        Slog.i(TAG, "Restored image dimensions (w=" + options.outWidth + ", h=" + options.outHeight + ") too far off target (tw=" + mDesiredMinWidth + ", th=" + mDesiredMinHeight + "); falling back to default wallpaper.");
                        f.delete();
                        return;
                    }
                }
                // We passed the acceptable-dimensions test (if any), so we're going to
                // use the restored image.
                // TODO: spin a service to copy the restored image to sd/usb storage,
                // since it does not exist anywhere other than the private wallpaper
                // file.
                Slog.d(TAG, "Applying restored wallpaper image.");
                f.renameTo(new File(WALLPAPER_IMAGE));
            }
        } else if (key.equals(WALLPAPER_INFO_KEY)) {
            // XML file containing wallpaper info
            File f = new File(WALLPAPER_INFO);
            writeFile(f, data);
        }
    }
}
Body of Second Method:
{
    final String key = data.getKey();
    if (isKeyInList(key, mKeys)) {
        if (key.equals(WALLPAPER_IMAGE_KEY)) {
            // restore the file to the stage for inspection
            File f = new File(STAGE_FILE);
            if (writeFile(f, data)) {
                // Preflight the restored image's dimensions without loading it
                BitmapFactory.Options options = new BitmapFactory.Options();
                options.inJustDecodeBounds = true;
                BitmapFactory.decodeFile(STAGE_FILE, options);
                if (DEBUG)
                    Slog.d(TAG, "Restoring wallpaper image w=" + options.outWidth + " h=" + options.outHeight);
                if (REJECT_OUTSIZED_RESTORE) {
                    // We accept any wallpaper that is at least as wide as our preference
                    // (i.e. wide enough to fill the screen), and is within a comfortable
                    // factor of the target height, to avoid significant clipping/scaling/
                    // letterboxing.  At this point we know that mDesiredMinWidth is the
                    // smallest dimension, regardless of current orientation, so we can
                    // safely require that the candidate's width and height both exceed
                    // that hard minimum.
                    final double heightRatio = mDesiredMinHeight / options.outHeight;
                    if (options.outWidth < mDesiredMinWidth || options.outHeight < mDesiredMinWidth || heightRatio >= MAX_HEIGHT_RATIO || heightRatio <= MIN_HEIGHT_RATIO) {
                        // Not wide enough for the screen, or too short/tall to be a good fit
                        // for the height of the screen, broken image file, or the system's
                        // desires for wallpaper size are in a bad state.  Probably one of the
                        // first two.
                        Slog.i(TAG, "Restored image dimensions (w=" + options.outWidth + ", h=" + options.outHeight + ") too far off target (tw=" + mDesiredMinWidth + ", th=" + mDesiredMinHeight + "); falling back to default wallpaper.");
                        f.delete();
                        return;
                    }
                }
                // We passed the acceptable-dimensions test (if any), so we're going to
                // use the restored image.
                // TODO: spin a service to copy the restored image to sd/usb storage,
                // since it does not exist anywhere other than the private wallpaper
                // file.
                Slog.d(TAG, "Applying restored wallpaper image.");
                f.renameTo(new File(WALLPAPER_IMAGE));
            }
        } else if (key.equals(WALLPAPER_INFO_KEY)) {
            // XML file containing wallpaper info
            File f = new File(WALLPAPER_INFO);
            writeFile(f, data);
        }
    }
}
------------------------
Find a silently evolved API code:android.telephony.SubscriptionManager.getDefaultDataSubId:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    long subId = INVALID_SUB_ID;
    try {
        ISub iSub = ISub.Stub.asInterface(ServiceManager.getService("isub"));
        if (iSub != null) {
            subId = iSub.getDefaultDataSubId();
        }
    } catch (RemoteException ex) {
    // ignore it
    }
    if (VDBG)
        logd("getDefaultDataSubId, sub id = " + subId);
    return subId;
}
Body of Second Method:
{
    int subId = INVALID_SUBSCRIPTION_ID;
    try {
        ISub iSub = ISub.Stub.asInterface(ServiceManager.getService("isub"));
        if (iSub != null) {
            subId = iSub.getDefaultDataSubId();
        }
    } catch (RemoteException ex) {
    // ignore it
    }
    if (VDBG)
        logd("getDefaultDataSubId, sub id = " + subId);
    return subId;
}
------------------------
Find a silently evolved API code:android.webkit.WebSettings.supportMultipleWindows:COMMENT
<android.webkit.WebSettings: boolean supportMultipleWindows()>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Gets whether the WebView supports multiple windows.
 *
 * @return true if the WebView supports multiple windows
 * @see #setSupportMultipleWindows
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.webkit.WebView.setCertificate:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * Sets the SSL certificate for the main top-level page.
 *
 * @deprecated Calling this function has no useful effect, and will be
 * ignored in future releases.
 */

Body of Frist Method:
{
    checkThread();
    if (DebugFlags.TRACE_API)
        Log.d(LOGTAG, "setCertificate=" + certificate);
    mProvider.setCertificate(certificate);
}
Body of Second Method:
{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, "setCertificate=" + certificate);
    mProvider.setCertificate(certificate);
}
------------------------
Find a silently evolved API code:android.view.accessibility.AccessibilityNodeInfo.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 * <p>
 * <strong>Note:</strong> After the instance is written to a parcel it
 * is recycled. You must not touch the object after calling this function.
 * </p>
 */

Body of Frist Method:
{
    parcel.writeInt(isSealed() ? 1 : 0);
    parcel.writeLong(mSourceNodeId);
    parcel.writeInt(mWindowId);
    parcel.writeLong(mParentNodeId);
    parcel.writeLong(mLabelForId);
    parcel.writeLong(mLabeledById);
    parcel.writeInt(mConnectionId);
    final LongArray childIds = mChildNodeIds;
    if (childIds == null) {
        parcel.writeInt(0);
    } else {
        final int childIdsSize = childIds.size();
        parcel.writeInt(childIdsSize);
        for (int i = 0; i < childIdsSize; i++) {
            parcel.writeLong(childIds.get(i));
        }
    }
    parcel.writeInt(mBoundsInParent.top);
    parcel.writeInt(mBoundsInParent.bottom);
    parcel.writeInt(mBoundsInParent.left);
    parcel.writeInt(mBoundsInParent.right);
    parcel.writeInt(mBoundsInScreen.top);
    parcel.writeInt(mBoundsInScreen.bottom);
    parcel.writeInt(mBoundsInScreen.left);
    parcel.writeInt(mBoundsInScreen.right);
    if (mActions != null && !mActions.isEmpty()) {
        final int actionCount = mActions.size();
        parcel.writeInt(actionCount);
        int defaultLegacyStandardActions = 0;
        for (int i = 0; i < actionCount; i++) {
            AccessibilityAction action = mActions.get(i);
            if (isDefaultLegacyStandardAction(action)) {
                defaultLegacyStandardActions |= action.getId();
            }
        }
        parcel.writeInt(defaultLegacyStandardActions);
        for (int i = 0; i < actionCount; i++) {
            AccessibilityAction action = mActions.get(i);
            if (!isDefaultLegacyStandardAction(action)) {
                parcel.writeInt(action.getId());
                parcel.writeCharSequence(action.getLabel());
            }
        }
    } else {
        parcel.writeInt(0);
    }
    parcel.writeInt(mMaxTextLength);
    parcel.writeInt(mMovementGranularities);
    parcel.writeInt(mBooleanProperties);
    parcel.writeCharSequence(mPackageName);
    parcel.writeCharSequence(mClassName);
    parcel.writeCharSequence(mText);
    parcel.writeCharSequence(mError);
    parcel.writeCharSequence(mContentDescription);
    parcel.writeString(mViewIdResourceName);
    parcel.writeInt(mTextSelectionStart);
    parcel.writeInt(mTextSelectionEnd);
    parcel.writeInt(mInputType);
    parcel.writeInt(mLiveRegion);
    if (mExtras != null) {
        parcel.writeInt(1);
        parcel.writeBundle(mExtras);
    } else {
        parcel.writeInt(0);
    }
    if (mRangeInfo != null) {
        parcel.writeInt(1);
        parcel.writeInt(mRangeInfo.getType());
        parcel.writeFloat(mRangeInfo.getMin());
        parcel.writeFloat(mRangeInfo.getMax());
        parcel.writeFloat(mRangeInfo.getCurrent());
    } else {
        parcel.writeInt(0);
    }
    if (mCollectionInfo != null) {
        parcel.writeInt(1);
        parcel.writeInt(mCollectionInfo.getRowCount());
        parcel.writeInt(mCollectionInfo.getColumnCount());
        parcel.writeInt(mCollectionInfo.isHierarchical() ? 1 : 0);
        parcel.writeInt(mCollectionInfo.getSelectionMode());
    } else {
        parcel.writeInt(0);
    }
    if (mCollectionItemInfo != null) {
        parcel.writeInt(1);
        parcel.writeInt(mCollectionItemInfo.getColumnIndex());
        parcel.writeInt(mCollectionItemInfo.getColumnSpan());
        parcel.writeInt(mCollectionItemInfo.getRowIndex());
        parcel.writeInt(mCollectionItemInfo.getRowSpan());
        parcel.writeInt(mCollectionItemInfo.isHeading() ? 1 : 0);
        parcel.writeInt(mCollectionItemInfo.isSelected() ? 1 : 0);
    } else {
        parcel.writeInt(0);
    }
    // Since instances of this class are fetched via synchronous i.e. blocking
    // calls in IPCs we always recycle as soon as the instance is marshaled.
    recycle();
}
Body of Second Method:
{
    parcel.writeInt(isSealed() ? 1 : 0);
    parcel.writeLong(mSourceNodeId);
    parcel.writeInt(mWindowId);
    parcel.writeLong(mParentNodeId);
    parcel.writeLong(mLabelForId);
    parcel.writeLong(mLabeledById);
    parcel.writeLong(mTraversalBefore);
    parcel.writeLong(mTraversalAfter);
    parcel.writeInt(mConnectionId);
    final LongArray childIds = mChildNodeIds;
    if (childIds == null) {
        parcel.writeInt(0);
    } else {
        final int childIdsSize = childIds.size();
        parcel.writeInt(childIdsSize);
        for (int i = 0; i < childIdsSize; i++) {
            parcel.writeLong(childIds.get(i));
        }
    }
    parcel.writeInt(mBoundsInParent.top);
    parcel.writeInt(mBoundsInParent.bottom);
    parcel.writeInt(mBoundsInParent.left);
    parcel.writeInt(mBoundsInParent.right);
    parcel.writeInt(mBoundsInScreen.top);
    parcel.writeInt(mBoundsInScreen.bottom);
    parcel.writeInt(mBoundsInScreen.left);
    parcel.writeInt(mBoundsInScreen.right);
    if (mActions != null && !mActions.isEmpty()) {
        final int actionCount = mActions.size();
        parcel.writeInt(actionCount);
        int defaultLegacyStandardActions = 0;
        for (int i = 0; i < actionCount; i++) {
            AccessibilityAction action = mActions.get(i);
            if (isDefaultLegacyStandardAction(action)) {
                defaultLegacyStandardActions |= action.getId();
            }
        }
        parcel.writeInt(defaultLegacyStandardActions);
        for (int i = 0; i < actionCount; i++) {
            AccessibilityAction action = mActions.get(i);
            if (!isDefaultLegacyStandardAction(action)) {
                parcel.writeInt(action.getId());
                parcel.writeCharSequence(action.getLabel());
            }
        }
    } else {
        parcel.writeInt(0);
    }
    parcel.writeInt(mMaxTextLength);
    parcel.writeInt(mMovementGranularities);
    parcel.writeInt(mBooleanProperties);
    parcel.writeCharSequence(mPackageName);
    parcel.writeCharSequence(mClassName);
    parcel.writeCharSequence(mText);
    parcel.writeCharSequence(mError);
    parcel.writeCharSequence(mContentDescription);
    parcel.writeString(mViewIdResourceName);
    parcel.writeInt(mTextSelectionStart);
    parcel.writeInt(mTextSelectionEnd);
    parcel.writeInt(mInputType);
    parcel.writeInt(mLiveRegion);
    if (mExtras != null) {
        parcel.writeInt(1);
        parcel.writeBundle(mExtras);
    } else {
        parcel.writeInt(0);
    }
    if (mRangeInfo != null) {
        parcel.writeInt(1);
        parcel.writeInt(mRangeInfo.getType());
        parcel.writeFloat(mRangeInfo.getMin());
        parcel.writeFloat(mRangeInfo.getMax());
        parcel.writeFloat(mRangeInfo.getCurrent());
    } else {
        parcel.writeInt(0);
    }
    if (mCollectionInfo != null) {
        parcel.writeInt(1);
        parcel.writeInt(mCollectionInfo.getRowCount());
        parcel.writeInt(mCollectionInfo.getColumnCount());
        parcel.writeInt(mCollectionInfo.isHierarchical() ? 1 : 0);
        parcel.writeInt(mCollectionInfo.getSelectionMode());
    } else {
        parcel.writeInt(0);
    }
    if (mCollectionItemInfo != null) {
        parcel.writeInt(1);
        parcel.writeInt(mCollectionItemInfo.getColumnIndex());
        parcel.writeInt(mCollectionItemInfo.getColumnSpan());
        parcel.writeInt(mCollectionItemInfo.getRowIndex());
        parcel.writeInt(mCollectionItemInfo.getRowSpan());
        parcel.writeInt(mCollectionItemInfo.isHeading() ? 1 : 0);
        parcel.writeInt(mCollectionItemInfo.isSelected() ? 1 : 0);
    } else {
        parcel.writeInt(0);
    }
    // Since instances of this class are fetched via synchronous i.e. blocking
    // calls in IPCs we always recycle as soon as the instance is marshaled.
    recycle();
}
------------------------
Find a silently evolved API code:android.widget.SearchView.clearFocus:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    mClearingFocus = true;
    setImeVisibility(false);
    super.clearFocus();
    mQueryTextView.clearFocus();
    mClearingFocus = false;
}
Body of Second Method:
{
    mClearingFocus = true;
    setImeVisibility(false);
    super.clearFocus();
    mSearchSrcTextView.clearFocus();
    mClearingFocus = false;
}
------------------------
Find a silently evolved API code:android.webkit.WebView.findAllAsync:COMMENT
Method Modifier: public      
Comment:/**
 * Finds all instances of find on the page and highlights them,
 * asynchronously. Notifies any registered {@link FindListener}.
 * Successive calls to this will cancel any pending searches.
 *
 * @param find the string to find.
 * @see #setFindListener
 */

Body of Frist Method:
{
    checkThread();
    if (DebugFlags.TRACE_API)
        Log.d(LOGTAG, "findAllAsync");
    mProvider.findAllAsync(find);
}
Body of Second Method:
{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, "findAllAsync");
    mProvider.findAllAsync(find);
}
------------------------
Find a silently evolved API code:android.telephony.SubscriptionManager.putPhoneIdAndSubIdExtra:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    long[] subIds = SubscriptionManager.getSubId(phoneId);
    if (subIds != null && subIds.length > 0) {
        putPhoneIdAndSubIdExtra(intent, phoneId, subIds[0]);
    } else {
        logd("putPhoneIdAndSubIdExtra: no valid subs");
    }
}
Body of Second Method:
{
    if (VDBG)
        logd("putPhoneIdAndSubIdExtra: phoneId=" + phoneId + " subId=" + subId);
    intent.putExtra(PhoneConstants.SUBSCRIPTION_KEY, subId);
    intent.putExtra(PhoneConstants.PHONE_KEY, phoneId);
    // FIXME this is using phoneId and slotId interchangeably
    // Eventually, this should be removed as it is not the slot id
    intent.putExtra(PhoneConstants.SLOT_KEY, phoneId);
}
------------------------
Find a silently evolved API code:android.widget.Switch.hitThumb:COMMENT
Method Modifier: private     
Comment:/**
 * @return true if (x, y) is within the target area of the switch thumb
 */

Body of Frist Method:
{
    // Relies on mTempRect, MUST be called first!
    final int thumbOffset = getThumbOffset();
    mThumbDrawable.getPadding(mTempRect);
    final int thumbTop = mSwitchTop - mTouchSlop;
    final int thumbLeft = mSwitchLeft + thumbOffset - mTouchSlop;
    final int thumbRight = thumbLeft + mThumbWidth + mTempRect.left + mTempRect.right + mTouchSlop;
    final int thumbBottom = mSwitchBottom + mTouchSlop;
    return x > thumbLeft && x < thumbRight && y > thumbTop && y < thumbBottom;
}
Body of Second Method:
{
    if (mThumbDrawable == null) {
        return false;
    }
    // Relies on mTempRect, MUST be called first!
    final int thumbOffset = getThumbOffset();
    mThumbDrawable.getPadding(mTempRect);
    final int thumbTop = mSwitchTop - mTouchSlop;
    final int thumbLeft = mSwitchLeft + thumbOffset - mTouchSlop;
    final int thumbRight = thumbLeft + mThumbWidth + mTempRect.left + mTempRect.right + mTouchSlop;
    final int thumbBottom = mSwitchBottom + mTouchSlop;
    return x > thumbLeft && x < thumbRight && y > thumbTop && y < thumbBottom;
}
------------------------
Find a silently evolved API code:android.webkit.WebSettings.getDefaultFontSize:COMMENT
<android.webkit.WebSettings: int getDefaultFontSize()>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Gets the default font size.
 *
 * @return a non-negative integer between 1 and 72
 * @see #setDefaultFontSize
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.os.Debug.MemoryInfo.getOtherLabel:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    switch(which) {
        case 0:
            return "Dalvik Other";
        case 1:
            return "Stack";
        case 2:
            return "Cursor";
        case 3:
            return "Ashmem";
        case 4:
            return "Other dev";
        case 5:
            return ".so mmap";
        case 6:
            return ".jar mmap";
        case 7:
            return ".apk mmap";
        case 8:
            return ".ttf mmap";
        case 9:
            return ".dex mmap";
        case 10:
            return "code mmap";
        case 11:
            return "image mmap";
        case 12:
            return "Other mmap";
        case 13:
            return "Graphics";
        case 14:
            return "GL";
        case 15:
            return "Memtrack";
        case 16:
            return ".Heap";
        case 17:
            return ".LOS";
        case 18:
            return ".LinearAlloc";
        case 19:
            return ".GC";
        case 20:
            return ".JITCache";
        default:
            return "????";
    }
}
Body of Second Method:
{
    switch(which) {
        case 0:
            return "Dalvik Other";
        case 1:
            return "Stack";
        case 2:
            return "Cursor";
        case 3:
            return "Ashmem";
        case 4:
            return "Gfx dev";
        case 5:
            return "Other dev";
        case 6:
            return ".so mmap";
        case 7:
            return ".jar mmap";
        case 8:
            return ".apk mmap";
        case 9:
            return ".ttf mmap";
        case 10:
            return ".dex mmap";
        case 11:
            return ".oat mmap";
        case 12:
            return ".art mmap";
        case 13:
            return "Other mmap";
        case 14:
            return "EGL mtrack";
        case 15:
            return "GL mtrack";
        case 16:
            return "Other mtrack";
        case 17:
            return ".Heap";
        case 18:
            return ".LOS";
        case 19:
            return ".LinearAlloc";
        case 20:
            return ".GC";
        case 21:
            return ".JITCache";
        case 22:
            return ".Zygote";
        case 23:
            return ".NonMoving";
        case 24:
            return ".IndirectRef";
        default:
            return "????";
    }
}
------------------------
Find a silently evolved API code:android.graphics.drawable.InsetDrawable.getOpticalInsets:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    final Insets contentInsets = super.getOpticalInsets();
    return Insets.of(contentInsets.left + mInsetState.mInsetLeft, contentInsets.top + mInsetState.mInsetTop, contentInsets.right + mInsetState.mInsetRight, contentInsets.bottom + mInsetState.mInsetBottom);
}
Body of Second Method:
{
    final Insets contentInsets = super.getOpticalInsets();
    return Insets.of(contentInsets.left + mState.mInsetLeft, contentInsets.top + mState.mInsetTop, contentInsets.right + mState.mInsetRight, contentInsets.bottom + mState.mInsetBottom);
}
------------------------
Find a silently evolved API code:android.webkit.WebSettings.getUserAgent:COMMENT
<android.webkit.WebSettings: int getUserAgent()>
public      hidden      deprecated  ->public      abstract    hidden      deprecated  
Method Modifier: public      abstract    hidden      deprecated  
Method Modifier: Yes         No          Yes         Yes         
Method Updated:  Yes         Yes         Yes         Yes         
Comment:/**
 * Gets the user-agent as an integer code.
 * <ul>
 * <li>-1 means the WebView is using a custom user-agent string set with
 * {@link #setUserAgentString}</li>
 * <li>0 means the WebView should use an Android user-agent string</li>
 * <li>1 means the WebView should use a desktop user-agent string</li>
 * </ul>
 *
 * @return the integer code for the user-agent string
 * @see #setUserAgent
 * @deprecated Please use {@link #getUserAgentString} instead.
 * @hide Since API level {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1}
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.widget.SearchView.setSearchableInfo:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the SearchableInfo for this SearchView. Properties in the SearchableInfo are used
 * to display labels, hints, suggestions, create intents for launching search results screens
 * and controlling other affordances such as a voice button.
 *
 * @param searchable a SearchableInfo can be retrieved from the SearchManager, for a specific
 * activity or a global search provider.
 */

Body of Frist Method:
{
    mSearchable = searchable;
    if (mSearchable != null) {
        updateSearchAutoComplete();
        updateQueryHint();
    }
    // Cache the voice search capability
    mVoiceButtonEnabled = hasVoiceSearch();
    if (mVoiceButtonEnabled) {
        // Disable the microphone on the keyboard, as a mic is displayed near the text box
        // TODO: use imeOptions to disable voice input when the new API will be available
        mQueryTextView.setPrivateImeOptions(IME_OPTION_NO_MICROPHONE);
    }
    updateViewsVisibility(isIconified());
}
Body of Second Method:
{
    mSearchable = searchable;
    if (mSearchable != null) {
        updateSearchAutoComplete();
        updateQueryHint();
    }
    // Cache the voice search capability
    mVoiceButtonEnabled = hasVoiceSearch();
    if (mVoiceButtonEnabled) {
        // Disable the microphone on the keyboard, as a mic is displayed near the text box
        // TODO: use imeOptions to disable voice input when the new API will be available
        mSearchSrcTextView.setPrivateImeOptions(IME_OPTION_NO_MICROPHONE);
    }
    updateViewsVisibility(isIconified());
}
------------------------
Find a silently evolved API code:android.app.ContextImpl.ensureDirsExistOrFilter:COMMENT
Method Modifier: private     
Comment:/**
 * Ensure that given directories exist, trying to create them if missing. If
 * unable to create, they are filtered by replacing with {@code null}.
 */

Body of Frist Method:
{
    File[] result = new File[dirs.length];
    for (int i = 0; i < dirs.length; i++) {
        File dir = dirs[i];
        if (!dir.exists()) {
            if (!dir.mkdirs()) {
                // recheck existence in case of cross-process race
                if (!dir.exists()) {
                    // Failing to mkdir() may be okay, since we might not have
                    // enough permissions; ask vold to create on our behalf.
                    final IMountService mount = IMountService.Stub.asInterface(ServiceManager.getService("mount"));
                    int res = -1;
                    try {
                        res = mount.mkdirs(getPackageName(), dir.getAbsolutePath());
                    } catch (RemoteException e) {
                    }
                    if (res != 0) {
                        Log.w(TAG, "Failed to ensure directory: " + dir);
                        dir = null;
                    }
                }
            }
        }
        result[i] = dir;
    }
    return result;
}
Body of Second Method:
{
    File[] result = new File[dirs.length];
    for (int i = 0; i < dirs.length; i++) {
        File dir = dirs[i];
        if (!dir.exists()) {
            if (!dir.mkdirs()) {
                // recheck existence in case of cross-process race
                if (!dir.exists()) {
                    // Failing to mkdir() may be okay, since we might not have
                    // enough permissions; ask vold to create on our behalf.
                    final IMountService mount = IMountService.Stub.asInterface(ServiceManager.getService("mount"));
                    int res = -1;
                    try {
                        res = mount.mkdirs(getPackageName(), dir.getAbsolutePath());
                    } catch (Exception ignored) {
                    }
                    if (res != 0) {
                        Log.w(TAG, "Failed to ensure directory: " + dir);
                        dir = null;
                    }
                }
            }
        }
        result[i] = dir;
    }
    return result;
}
------------------------
Find a silently evolved API code:android.webkit.WebSettings.setDatabasePath:COMMENT
<android.webkit.WebSettings: void setDatabasePath(String)>
public      deprecated  ->public      abstract    deprecated  
Method Modifier: public      abstract    deprecated  
Method Modifier: Yes         No          Yes         
Method Updated:  Yes         Yes         Yes         
Comment:// once.

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.app.Dialog.openOptionsMenu:COMMENT
Method Modifier: public      
Comment:/**
 * @see Activity#openOptionsMenu()
 */

Body of Frist Method:
{
    mWindow.openPanel(Window.FEATURE_OPTIONS_PANEL, null);
}
Body of Second Method:
{
    if (mWindow.hasFeature(Window.FEATURE_OPTIONS_PANEL)) {
        mWindow.openPanel(Window.FEATURE_OPTIONS_PANEL, null);
    }
}
------------------------
Find a silently evolved API code:android.webkit.WebIconDatabase.bulkRequestIconForPageUrl:COMMENT
<android.webkit.WebIconDatabase: void bulkRequestIconForPageUrl(ContentResolver,String,IconListener)>
public      hidden      deprecated  ->public      abstract    hidden      deprecated  
Method Modifier: public      abstract    hidden      deprecated  
Method Modifier: Yes         No          Yes         Yes         
Method Updated:  Yes         Yes         Yes         Yes         
Comment:/**
 * {@hide}
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.webkit.CookieManager.removeExpiredCookie:COMMENT
<android.webkit.CookieManager: void removeExpiredCookie()>
public      deprecated  ->public      abstract    deprecated  
Method Modifier: public      abstract    deprecated  
Method Modifier: Yes         No          Yes         
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * Removes all expired cookies.
 * @deprecated The WebView handles removing expired cookies automatically.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.widget.SearchView.getQuery:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the query string currently in the text field.
 *
 * @return the query string
 */

Body of Frist Method:
{
    return mQueryTextView.getText();
}
Body of Second Method:
{
    return mSearchSrcTextView.getText();
}
------------------------
Find a silently evolved API code:android.hardware.camera2.params.StreamConfigurationMap.getPublicFormatCount:COMMENT
Method Modifier: private     
Comment:/**
 * Count the number of publicly-visible output formats
 */

Body of Frist Method:
{
    HashMap<Integer, Integer> formatsMap = getFormatsMap(output);
    int size = formatsMap.size();
    if (formatsMap.containsKey(HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED)) {
        size -= 1;
    }
    return size;
}
Body of Second Method:
{
    HashMap<Integer, Integer> formatsMap = getFormatsMap(output);
    int size = formatsMap.size();
    if (formatsMap.containsKey(HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED)) {
        size -= 1;
    }
    if (formatsMap.containsKey(HAL_PIXEL_FORMAT_RAW_OPAQUE)) {
        size -= 1;
    }
    return size;
}
------------------------
Find a silently evolved API code:android.graphics.drawable.InsetDrawable.getDrawable:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the drawable wrapped by this InsetDrawable. May be null.
 */

Body of Frist Method:
{
    return mInsetState.mDrawable;
}
Body of Second Method:
{
    return mState.mDrawable;
}
------------------------
Find a silently evolved API code:android.webkit.CookieManager.removeAllCookie:COMMENT
<android.webkit.CookieManager: void removeAllCookie()>
public      deprecated  ->public      abstract    deprecated  
Method Modifier: public      abstract    deprecated  
Method Modifier: Yes         No          Yes         
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * Removes all cookies.
 * @deprecated Use {@link #removeAllCookies(ValueCallback)} instead.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.media.tv.TvInputManager.Session.getTracks:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns the list of tracks for a given type. Returns {@code null} if the information is
 * not available.
 *
 * @param type The type of the tracks. The type can be {@link TvTrackInfo#TYPE_AUDIO},
 * {@link TvTrackInfo#TYPE_VIDEO} or {@link TvTrackInfo#TYPE_SUBTITLE}.
 * @return the list of tracks for the given type.
 */

Body of Frist Method:
{
    if (type == TvTrackInfo.TYPE_AUDIO) {
        if (mAudioTracks == null) {
            return null;
        }
        return mAudioTracks;
    } else if (type == TvTrackInfo.TYPE_VIDEO) {
        if (mVideoTracks == null) {
            return null;
        }
        return mVideoTracks;
    } else if (type == TvTrackInfo.TYPE_SUBTITLE) {
        if (mSubtitleTracks == null) {
            return null;
        }
        return mSubtitleTracks;
    }
    throw new IllegalArgumentException("invalid type: " + type);
}
Body of Second Method:
{
    synchronized (mTrackLock) {
        if (type == TvTrackInfo.TYPE_AUDIO) {
            if (mAudioTracks == null) {
                return null;
            }
            return new ArrayList<TvTrackInfo>(mAudioTracks);
        } else if (type == TvTrackInfo.TYPE_VIDEO) {
            if (mVideoTracks == null) {
                return null;
            }
            return new ArrayList<TvTrackInfo>(mVideoTracks);
        } else if (type == TvTrackInfo.TYPE_SUBTITLE) {
            if (mSubtitleTracks == null) {
                return null;
            }
            return new ArrayList<TvTrackInfo>(mSubtitleTracks);
        }
    }
    throw new IllegalArgumentException("invalid type: " + type);
}
------------------------
Find a silently evolved API code:android.widget.SearchView.getImeOptions:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the IME options set on the query text field.
 * @return the ime options
 * @see TextView#setImeOptions(int)
 *
 * @attr ref android.R.styleable#SearchView_imeOptions
 */

Body of Frist Method:
{
    return mQueryTextView.getImeOptions();
}
Body of Second Method:
{
    return mSearchSrcTextView.getImeOptions();
}
------------------------
Find a silently evolved API code:android.webkit.WebSettings.setUseWebViewBackgroundForOverscrollBackground:COMMENT
<android.webkit.WebSettings: void setUseWebViewBackgroundForOverscrollBackground(boolean)>
public      hidden      deprecated  ->public      abstract    hidden      deprecated  
Method Modifier: public      abstract    hidden      deprecated  
Method Modifier: Yes         No          Yes         Yes         
Method Updated:  Yes         Yes         Yes         Yes         
Comment:/**
 * Sets whether the WebView uses its background for over scroll background.
 * If true, it will use the WebView's background. If false, it will use an
 * internal pattern. Default is true.
 *
 * @deprecated This method is now obsolete.
 * @hide Since API level {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1}
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.media.AudioService.setStreamMute:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @see AudioManager#setStreamMute(int, boolean)
 */

Body of Frist Method:
{
    if (mUseFixedVolume) {
        return;
    }
    if (isStreamAffectedByMute(streamType)) {
        if (mHdmiManager != null) {
            synchronized (mHdmiManager) {
                if (streamType == AudioSystem.STREAM_MUSIC && mHdmiTvClient != null) {
                    synchronized (mHdmiTvClient) {
                        if (mHdmiSystemAudioSupported) {
                            mHdmiTvClient.setSystemAudioMute(state);
                        }
                    }
                }
            }
        }
        mStreamStates[streamType].mute(cb, state);
    }
}
Body of Second Method:
{
    if (mUseFixedVolume) {
        return;
    }
    if (streamType == AudioManager.USE_DEFAULT_STREAM_TYPE) {
        streamType = getActiveStreamType(streamType);
    }
    int streamAlias = mStreamVolumeAlias[streamType];
    if (isStreamAffectedByMute(streamAlias)) {
        if (streamAlias == AudioSystem.STREAM_MUSIC) {
            setSystemAudioMute(state);
        }
        for (int stream = 0; stream < mStreamStates.length; stream++) {
            if (streamAlias == mStreamVolumeAlias[stream]) {
                mStreamStates[stream].mute(cb, state);
                Intent intent = new Intent(AudioManager.STREAM_MUTE_CHANGED_ACTION);
                intent.putExtra(AudioManager.EXTRA_VOLUME_STREAM_TYPE, stream);
                intent.putExtra(AudioManager.EXTRA_STREAM_VOLUME_MUTED, state);
                sendBroadcastToAll(intent);
            }
        }
    }
}
------------------------
Find a silently evolved API code:android.graphics.drawable.ClipDrawable.setLayoutDirection:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    mClipState.mDrawable.setLayoutDirection(layoutDirection);
    super.setLayoutDirection(layoutDirection);
}
Body of Second Method:
{
    mState.mDrawable.setLayoutDirection(layoutDirection);
    super.setLayoutDirection(layoutDirection);
}
------------------------
Find a silently evolved API code:android.webkit.WebSettings.setDisplayZoomControls:COMMENT
<android.webkit.WebSettings: void setDisplayZoomControls(boolean)>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Sets whether the WebView should display on-screen zoom controls when
 * using the built-in zoom mechanisms. See {@link #setBuiltInZoomControls}.
 * The default is true.
 *
 * @param enabled whether the WebView should display on-screen zoom controls
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.webkit.WebSettings.setDefaultFixedFontSize:COMMENT
<android.webkit.WebSettings: void setDefaultFixedFontSize(int)>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Sets the default fixed font size. The default is 16.
 *
 * @param size a non-negative integer between 1 and 72. Any number outside
 * the specified range will be pinned.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.webkit.WebSettings.enableSmoothTransition:COMMENT
<android.webkit.WebSettings: boolean enableSmoothTransition()>
public      deprecated  ->public      abstract    deprecated  
Method Modifier: public      abstract    deprecated  
Method Modifier: Yes         No          Yes         
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * Gets whether the WebView enables smooth transition while panning or
 * zooming.
 *
 * @see #setEnableSmoothTransition
 *
 * @deprecated This method is now obsolete, and will become a no-op in future.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.net.NetworkIdentity.buildNetworkIdentity:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Build a {@link NetworkIdentity} from the given {@link NetworkState},
 * assuming that any mobile networks are using the current IMSI.
 */

Body of Frist Method:
{
    final int type = state.networkInfo.getType();
    final int subType = state.networkInfo.getSubtype();
    // TODO: consider moving subscriberId over to LinkCapabilities, so it
    // comes from an authoritative source.
    String subscriberId = null;
    String networkId = null;
    boolean roaming = false;
    if (isNetworkTypeMobile(type)) {
        final TelephonyManager telephony = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);
        roaming = telephony.isNetworkRoaming();
        if (state.subscriberId != null) {
            subscriberId = state.subscriberId;
        } else {
            subscriberId = telephony.getSubscriberId();
        }
    } else if (type == TYPE_WIFI) {
        if (state.networkId != null) {
            networkId = state.networkId;
        } else {
            final WifiManager wifi = (WifiManager) context.getSystemService(Context.WIFI_SERVICE);
            final WifiInfo info = wifi.getConnectionInfo();
            networkId = info != null ? info.getSSID() : null;
        }
    }
    return new NetworkIdentity(type, subType, subscriberId, networkId, roaming);
}
Body of Second Method:
{
    final int type = state.networkInfo.getType();
    final int subType = state.networkInfo.getSubtype();
    String subscriberId = null;
    String networkId = null;
    boolean roaming = false;
    if (isNetworkTypeMobile(type)) {
        if (state.subscriberId == null) {
            Slog.w(TAG, "Active mobile network without subscriber!");
        }
        subscriberId = state.subscriberId;
        roaming = state.networkInfo.isRoaming();
    } else if (type == TYPE_WIFI) {
        if (state.networkId != null) {
            networkId = state.networkId;
        } else {
            final WifiManager wifi = (WifiManager) context.getSystemService(Context.WIFI_SERVICE);
            final WifiInfo info = wifi.getConnectionInfo();
            networkId = info != null ? info.getSSID() : null;
        }
    }
    return new NetworkIdentity(type, subType, subscriberId, networkId, roaming);
}
------------------------
Find a silently evolved API code:android.webkit.WebSettings.setSansSerifFontFamily:COMMENT
<android.webkit.WebSettings: void setSansSerifFontFamily(String)>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Sets the sans-serif font family name. The default is "sans-serif".
 *
 * @param font a font family name
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.media.AudioManager.unregisterAudioPortUpdateListener:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Unregister an audio port list update listener.
 * @hide
 */

Body of Frist Method:
{
    mAudioPortEventHandler.unregisterListener(l);
}
Body of Second Method:
{
    sAudioPortEventHandler.unregisterListener(l);
}
------------------------
Find a silently evolved API code:android.media.AudioTrack.setPlaybackHeadPosition:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the playback head position.
 * The track must be stopped or paused for the position to be changed,
 * and must use the {@link #MODE_STATIC} mode.
 * @param positionInFrames playback head position expressed in frames
 * Zero corresponds to start of buffer.
 * The position must not be greater than the buffer size in frames, or negative.
 * @return error code or success, see {@link #SUCCESS}, {@link #ERROR_BAD_VALUE},
 * {@link #ERROR_INVALID_OPERATION}
 */

Body of Frist Method:
{
    if (mDataLoadMode == MODE_STREAM || mState != STATE_INITIALIZED || getPlayState() == PLAYSTATE_PLAYING) {
        return ERROR_INVALID_OPERATION;
    }
    if (!(0 <= positionInFrames && positionInFrames <= mNativeBufferSizeInFrames)) {
        return ERROR_BAD_VALUE;
    }
    return native_set_position(positionInFrames);
}
Body of Second Method:
{
    if (mDataLoadMode == MODE_STREAM || mState == STATE_UNINITIALIZED || getPlayState() == PLAYSTATE_PLAYING) {
        return ERROR_INVALID_OPERATION;
    }
    if (!(0 <= positionInFrames && positionInFrames <= mNativeBufferSizeInFrames)) {
        return ERROR_BAD_VALUE;
    }
    return native_set_position(positionInFrames);
}
------------------------
Find a silently evolved API code:android.net.NetworkTemplate.matchesMobile:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Check if mobile network with matching IMSI.
 */

Body of Frist Method:
{
    if (ident.mType == TYPE_WIMAX) {
        // TODO: consider matching against WiMAX subscriber identity
        return true;
    } else {
        return ((sForceAllNetworkTypes || contains(DATA_USAGE_NETWORK_TYPES, ident.mType)) && Objects.equals(mSubscriberId, ident.mSubscriberId));
    }
}
Body of Second Method:
{
    if (ident.mType == TYPE_WIMAX) {
        // TODO: consider matching against WiMAX subscriber identity
        return true;
    } else {
        final boolean matchesType = (sForceAllNetworkTypes || contains(DATA_USAGE_NETWORK_TYPES, ident.mType));
        return matchesType && ArrayUtils.contains(mMatchSubscriberIds, ident.mSubscriberId);
    }
}
------------------------
Find a silently evolved API code:android.widget.AbsListView.shouldShowSelector:COMMENT
Method Modifier: default     
Comment:/**
 * Indicates whether this view is in a state where the selector should be drawn. This will
 * happen if we have focus but are not in touch mode, or we are in the middle of displaying
 * the pressed state for an item.
 *
 * @return True if the selector should be shown
 */

Body of Frist Method:
{
    return (!isInTouchMode()) || (touchModeDrawsInPressedState() && isPressed());
}
Body of Second Method:
{
    return (isFocused() && !isInTouchMode()) || (touchModeDrawsInPressedState() && isPressed());
}
------------------------
Find a silently evolved API code:android.view.accessibility.AccessibilityNodeInfo.init:COMMENT
Method Modifier: private     
Comment:/**
 * Initializes this instance from another one.
 *
 * @param other The other instance.
 */

Body of Frist Method:
{
    mSealed = other.mSealed;
    mSourceNodeId = other.mSourceNodeId;
    mParentNodeId = other.mParentNodeId;
    mLabelForId = other.mLabelForId;
    mLabeledById = other.mLabeledById;
    mWindowId = other.mWindowId;
    mConnectionId = other.mConnectionId;
    mBoundsInParent.set(other.mBoundsInParent);
    mBoundsInScreen.set(other.mBoundsInScreen);
    mPackageName = other.mPackageName;
    mClassName = other.mClassName;
    mText = other.mText;
    mError = other.mError;
    mContentDescription = other.mContentDescription;
    mViewIdResourceName = other.mViewIdResourceName;
    final ArrayList<AccessibilityAction> otherActions = other.mActions;
    if (otherActions != null && otherActions.size() > 0) {
        if (mActions == null) {
            mActions = new ArrayList(otherActions);
        } else {
            mActions.clear();
            mActions.addAll(other.mActions);
        }
    }
    mBooleanProperties = other.mBooleanProperties;
    mMaxTextLength = other.mMaxTextLength;
    mMovementGranularities = other.mMovementGranularities;
    final LongArray otherChildNodeIds = other.mChildNodeIds;
    if (otherChildNodeIds != null && otherChildNodeIds.size() > 0) {
        if (mChildNodeIds == null) {
            mChildNodeIds = otherChildNodeIds.clone();
        } else {
            mChildNodeIds.clear();
            mChildNodeIds.addAll(otherChildNodeIds);
        }
    }
    mTextSelectionStart = other.mTextSelectionStart;
    mTextSelectionEnd = other.mTextSelectionEnd;
    mInputType = other.mInputType;
    mLiveRegion = other.mLiveRegion;
    if (other.mExtras != null && !other.mExtras.isEmpty()) {
        getExtras().putAll(other.mExtras);
    }
    mRangeInfo = (other.mRangeInfo != null) ? RangeInfo.obtain(other.mRangeInfo) : null;
    mCollectionInfo = (other.mCollectionInfo != null) ? CollectionInfo.obtain(other.mCollectionInfo) : null;
    mCollectionItemInfo = (other.mCollectionItemInfo != null) ? CollectionItemInfo.obtain(other.mCollectionItemInfo) : null;
}
Body of Second Method:
{
    mSealed = other.mSealed;
    mSourceNodeId = other.mSourceNodeId;
    mParentNodeId = other.mParentNodeId;
    mLabelForId = other.mLabelForId;
    mLabeledById = other.mLabeledById;
    mTraversalBefore = other.mTraversalBefore;
    mTraversalAfter = other.mTraversalAfter;
    mWindowId = other.mWindowId;
    mConnectionId = other.mConnectionId;
    mBoundsInParent.set(other.mBoundsInParent);
    mBoundsInScreen.set(other.mBoundsInScreen);
    mPackageName = other.mPackageName;
    mClassName = other.mClassName;
    mText = other.mText;
    mError = other.mError;
    mContentDescription = other.mContentDescription;
    mViewIdResourceName = other.mViewIdResourceName;
    final ArrayList<AccessibilityAction> otherActions = other.mActions;
    if (otherActions != null && otherActions.size() > 0) {
        if (mActions == null) {
            mActions = new ArrayList(otherActions);
        } else {
            mActions.clear();
            mActions.addAll(other.mActions);
        }
    }
    mBooleanProperties = other.mBooleanProperties;
    mMaxTextLength = other.mMaxTextLength;
    mMovementGranularities = other.mMovementGranularities;
    final LongArray otherChildNodeIds = other.mChildNodeIds;
    if (otherChildNodeIds != null && otherChildNodeIds.size() > 0) {
        if (mChildNodeIds == null) {
            mChildNodeIds = otherChildNodeIds.clone();
        } else {
            mChildNodeIds.clear();
            mChildNodeIds.addAll(otherChildNodeIds);
        }
    }
    mTextSelectionStart = other.mTextSelectionStart;
    mTextSelectionEnd = other.mTextSelectionEnd;
    mInputType = other.mInputType;
    mLiveRegion = other.mLiveRegion;
    if (other.mExtras != null && !other.mExtras.isEmpty()) {
        getExtras().putAll(other.mExtras);
    }
    mRangeInfo = (other.mRangeInfo != null) ? RangeInfo.obtain(other.mRangeInfo) : null;
    mCollectionInfo = (other.mCollectionInfo != null) ? CollectionInfo.obtain(other.mCollectionInfo) : null;
    mCollectionItemInfo = (other.mCollectionItemInfo != null) ? CollectionItemInfo.obtain(other.mCollectionItemInfo) : null;
}
------------------------
Find a silently evolved API code:android.graphics.drawable.GradientDrawable.ensureValidRect:COMMENT
Method Modifier: private     
Comment:/**
 * This checks mGradientIsDirty, and if it is true, recomputes both our drawing
 * rectangle (mRect) and the gradient itself, since it depends on our
 * rectangle too.
 * @return true if the resulting rectangle is not empty, false otherwise
 */

Body of Frist Method:
{
    if (mGradientIsDirty) {
        mGradientIsDirty = false;
        Rect bounds = getBounds();
        float inset = 0;
        if (mStrokePaint != null) {
            inset = mStrokePaint.getStrokeWidth() * 0.5f;
        }
        final GradientState st = mGradientState;
        mRect.set(bounds.left + inset, bounds.top + inset, bounds.right - inset, bounds.bottom - inset);
        final int[] colors = st.mColors;
        if (colors != null) {
            RectF r = mRect;
            float x0, x1, y0, y1;
            if (st.mGradient == LINEAR_GRADIENT) {
                final float level = st.mUseLevel ? getLevel() / 10000.0f : 1.0f;
                switch(st.mOrientation) {
                    case TOP_BOTTOM:
                        x0 = r.left;
                        y0 = r.top;
                        x1 = x0;
                        y1 = level * r.bottom;
                        break;
                    case TR_BL:
                        x0 = r.right;
                        y0 = r.top;
                        x1 = level * r.left;
                        y1 = level * r.bottom;
                        break;
                    case RIGHT_LEFT:
                        x0 = r.right;
                        y0 = r.top;
                        x1 = level * r.left;
                        y1 = y0;
                        break;
                    case BR_TL:
                        x0 = r.right;
                        y0 = r.bottom;
                        x1 = level * r.left;
                        y1 = level * r.top;
                        break;
                    case BOTTOM_TOP:
                        x0 = r.left;
                        y0 = r.bottom;
                        x1 = x0;
                        y1 = level * r.top;
                        break;
                    case BL_TR:
                        x0 = r.left;
                        y0 = r.bottom;
                        x1 = level * r.right;
                        y1 = level * r.top;
                        break;
                    case LEFT_RIGHT:
                        x0 = r.left;
                        y0 = r.top;
                        x1 = level * r.right;
                        y1 = y0;
                        break;
                    default:
                        /* TL_BR */
                        x0 = r.left;
                        y0 = r.top;
                        x1 = level * r.right;
                        y1 = level * r.bottom;
                        break;
                }
                mFillPaint.setShader(new LinearGradient(x0, y0, x1, y1, colors, st.mPositions, Shader.TileMode.CLAMP));
            } else if (st.mGradient == RADIAL_GRADIENT) {
                x0 = r.left + (r.right - r.left) * st.mCenterX;
                y0 = r.top + (r.bottom - r.top) * st.mCenterY;
                float radius = st.mGradientRadius;
                if (st.mGradientRadiusType == RADIUS_TYPE_FRACTION) {
                    radius *= Math.min(st.mWidth, st.mHeight);
                } else if (st.mGradientRadiusType == RADIUS_TYPE_FRACTION_PARENT) {
                    radius *= Math.min(r.width(), r.height());
                }
                if (st.mUseLevel) {
                    radius *= getLevel() / 10000.0f;
                }
                mGradientRadius = radius;
                if (radius == 0) {
                    // We can't have a shader with zero radius, so let's
                    // have a very, very small radius.
                    radius = 0.001f;
                }
                mFillPaint.setShader(new RadialGradient(x0, y0, radius, colors, null, Shader.TileMode.CLAMP));
            } else if (st.mGradient == SWEEP_GRADIENT) {
                x0 = r.left + (r.right - r.left) * st.mCenterX;
                y0 = r.top + (r.bottom - r.top) * st.mCenterY;
                int[] tempColors = colors;
                float[] tempPositions = null;
                if (st.mUseLevel) {
                    tempColors = st.mTempColors;
                    final int length = colors.length;
                    if (tempColors == null || tempColors.length != length + 1) {
                        tempColors = st.mTempColors = new int[length + 1];
                    }
                    System.arraycopy(colors, 0, tempColors, 0, length);
                    tempColors[length] = colors[length - 1];
                    tempPositions = st.mTempPositions;
                    final float fraction = 1.0f / (length - 1);
                    if (tempPositions == null || tempPositions.length != length + 1) {
                        tempPositions = st.mTempPositions = new float[length + 1];
                    }
                    final float level = getLevel() / 10000.0f;
                    for (int i = 0; i < length; i++) {
                        tempPositions[i] = i * fraction * level;
                    }
                    tempPositions[length] = 1.0f;
                }
                mFillPaint.setShader(new SweepGradient(x0, y0, tempColors, tempPositions));
            }
            // maxed out so that alpha modulation works correctly.
            if (st.mColorStateList == null) {
                mFillPaint.setColor(Color.BLACK);
            }
        }
    }
    return !mRect.isEmpty();
}
Body of Second Method:
{
    if (mGradientIsDirty) {
        mGradientIsDirty = false;
        Rect bounds = getBounds();
        float inset = 0;
        if (mStrokePaint != null) {
            inset = mStrokePaint.getStrokeWidth() * 0.5f;
        }
        final GradientState st = mGradientState;
        mRect.set(bounds.left + inset, bounds.top + inset, bounds.right - inset, bounds.bottom - inset);
        final int[] colors = st.mColors;
        if (colors != null) {
            RectF r = mRect;
            float x0, x1, y0, y1;
            if (st.mGradient == LINEAR_GRADIENT) {
                final float level = st.mUseLevel ? getLevel() / 10000.0f : 1.0f;
                switch(st.mOrientation) {
                    case TOP_BOTTOM:
                        x0 = r.left;
                        y0 = r.top;
                        x1 = x0;
                        y1 = level * r.bottom;
                        break;
                    case TR_BL:
                        x0 = r.right;
                        y0 = r.top;
                        x1 = level * r.left;
                        y1 = level * r.bottom;
                        break;
                    case RIGHT_LEFT:
                        x0 = r.right;
                        y0 = r.top;
                        x1 = level * r.left;
                        y1 = y0;
                        break;
                    case BR_TL:
                        x0 = r.right;
                        y0 = r.bottom;
                        x1 = level * r.left;
                        y1 = level * r.top;
                        break;
                    case BOTTOM_TOP:
                        x0 = r.left;
                        y0 = r.bottom;
                        x1 = x0;
                        y1 = level * r.top;
                        break;
                    case BL_TR:
                        x0 = r.left;
                        y0 = r.bottom;
                        x1 = level * r.right;
                        y1 = level * r.top;
                        break;
                    case LEFT_RIGHT:
                        x0 = r.left;
                        y0 = r.top;
                        x1 = level * r.right;
                        y1 = y0;
                        break;
                    default:
                        /* TL_BR */
                        x0 = r.left;
                        y0 = r.top;
                        x1 = level * r.right;
                        y1 = level * r.bottom;
                        break;
                }
                mFillPaint.setShader(new LinearGradient(x0, y0, x1, y1, colors, st.mPositions, Shader.TileMode.CLAMP));
            } else if (st.mGradient == RADIAL_GRADIENT) {
                x0 = r.left + (r.right - r.left) * st.mCenterX;
                y0 = r.top + (r.bottom - r.top) * st.mCenterY;
                float radius = st.mGradientRadius;
                if (st.mGradientRadiusType == RADIUS_TYPE_FRACTION) {
                    // Fall back to parent width or height if intrinsic
                    // size is not specified.
                    final float width = st.mWidth >= 0 ? st.mWidth : r.width();
                    final float height = st.mHeight >= 0 ? st.mHeight : r.height();
                    radius *= Math.min(width, height);
                } else if (st.mGradientRadiusType == RADIUS_TYPE_FRACTION_PARENT) {
                    radius *= Math.min(r.width(), r.height());
                }
                if (st.mUseLevel) {
                    radius *= getLevel() / 10000.0f;
                }
                mGradientRadius = radius;
                if (radius <= 0) {
                    // We can't have a shader with non-positive radius, so
                    // let's have a very, very small radius.
                    radius = 0.001f;
                }
                mFillPaint.setShader(new RadialGradient(x0, y0, radius, colors, null, Shader.TileMode.CLAMP));
            } else if (st.mGradient == SWEEP_GRADIENT) {
                x0 = r.left + (r.right - r.left) * st.mCenterX;
                y0 = r.top + (r.bottom - r.top) * st.mCenterY;
                int[] tempColors = colors;
                float[] tempPositions = null;
                if (st.mUseLevel) {
                    tempColors = st.mTempColors;
                    final int length = colors.length;
                    if (tempColors == null || tempColors.length != length + 1) {
                        tempColors = st.mTempColors = new int[length + 1];
                    }
                    System.arraycopy(colors, 0, tempColors, 0, length);
                    tempColors[length] = colors[length - 1];
                    tempPositions = st.mTempPositions;
                    final float fraction = 1.0f / (length - 1);
                    if (tempPositions == null || tempPositions.length != length + 1) {
                        tempPositions = st.mTempPositions = new float[length + 1];
                    }
                    final float level = getLevel() / 10000.0f;
                    for (int i = 0; i < length; i++) {
                        tempPositions[i] = i * fraction * level;
                    }
                    tempPositions[length] = 1.0f;
                }
                mFillPaint.setShader(new SweepGradient(x0, y0, tempColors, tempPositions));
            }
            // maxed out so that alpha modulation works correctly.
            if (st.mColorStateList == null) {
                mFillPaint.setColor(Color.BLACK);
            }
        }
    }
    return !mRect.isEmpty();
}
------------------------
Find a silently evolved API code:android.view.ViewGroup.resolvePadding:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    super.resolvePadding();
    int count = getChildCount();
    for (int i = 0; i < count; i++) {
        final View child = getChildAt(i);
        if (child.isLayoutDirectionInherited()) {
            child.resolvePadding();
        }
    }
}
Body of Second Method:
{
    super.resolvePadding();
    int count = getChildCount();
    for (int i = 0; i < count; i++) {
        final View child = getChildAt(i);
        if (child.isLayoutDirectionInherited() && !child.isPaddingResolved()) {
            child.resolvePadding();
        }
    }
}
------------------------
Find a silently evolved API code:android.view.ViewGroup.removeAllViewsInLayout:COMMENT
Method Modifier: public      
Comment:/**
 * Called by a ViewGroup subclass to remove child views from itself,
 * when it must first know its size on screen before it can calculate how many
 * child views it will render. An example is a Gallery or a ListView, which
 * may "have" 50 children, but actually only render the number of children
 * that can currently fit inside the object on screen. Do not call
 * this method unless you are extending ViewGroup and understand the
 * view measuring and layout pipeline.
 *
 * <p><strong>Note:</strong> do not invoke this method from
 * {@link #draw(android.graphics.Canvas)}, {@link #onDraw(android.graphics.Canvas)},
 * {@link #dispatchDraw(android.graphics.Canvas)} or any related method.</p>
 */

Body of Frist Method:
{
    final int count = mChildrenCount;
    if (count <= 0) {
        return;
    }
    final View[] children = mChildren;
    mChildrenCount = 0;
    final View focused = mFocused;
    final boolean detach = mAttachInfo != null;
    boolean clearChildFocus = false;
    needGlobalAttributesUpdate(false);
    for (int i = count - 1; i >= 0; i--) {
        final View view = children[i];
        if (mTransition != null) {
            mTransition.removeChild(this, view);
        }
        if (view == focused) {
            view.unFocus(null);
            clearChildFocus = true;
        }
        if (view.isAccessibilityFocused()) {
            view.clearAccessibilityFocus();
        }
        cancelTouchTarget(view);
        cancelHoverTarget(view);
        if (view.getAnimation() != null || (mTransitioningViews != null && mTransitioningViews.contains(view))) {
            addDisappearingView(view);
        } else if (detach) {
            view.dispatchDetachedFromWindow();
        }
        if (view.hasTransientState()) {
            childHasTransientStateChanged(view, false);
        }
        onViewRemoved(view);
        view.mParent = null;
        children[i] = null;
    }
    if (clearChildFocus) {
        clearChildFocus(focused);
        if (!rootViewRequestFocus()) {
            notifyGlobalFocusCleared(focused);
        }
    }
}
Body of Second Method:
{
    final int count = mChildrenCount;
    if (count <= 0) {
        return;
    }
    final View[] children = mChildren;
    mChildrenCount = 0;
    final View focused = mFocused;
    final boolean detach = mAttachInfo != null;
    boolean clearChildFocus = false;
    needGlobalAttributesUpdate(false);
    for (int i = count - 1; i >= 0; i--) {
        final View view = children[i];
        if (mTransition != null) {
            mTransition.removeChild(this, view);
        }
        if (view == focused) {
            view.unFocus(null);
            clearChildFocus = true;
        }
        view.clearAccessibilityFocus();
        cancelTouchTarget(view);
        cancelHoverTarget(view);
        if (view.getAnimation() != null || (mTransitioningViews != null && mTransitioningViews.contains(view))) {
            addDisappearingView(view);
        } else if (detach) {
            view.dispatchDetachedFromWindow();
        }
        if (view.hasTransientState()) {
            childHasTransientStateChanged(view, false);
        }
        onViewRemoved(view);
        view.mParent = null;
        children[i] = null;
    }
    if (clearChildFocus) {
        clearChildFocus(focused);
        if (!rootViewRequestFocus()) {
            notifyGlobalFocusCleared(focused);
        }
    }
}
------------------------
Find a silently evolved API code:android.hardware.camera2.legacy.SurfaceTextureRenderer.configureSurfaces:COMMENT
Method Modifier: public      
Comment:/**
 * Set a collection of output {@link Surface}s that can be drawn to.
 *
 * @param surfaces a {@link Collection} of surfaces.
 */

Body of Frist Method:
{
    releaseEGLContext();
    if (surfaces == null || surfaces.size() == 0) {
        Log.w(TAG, "No output surfaces configured for GL drawing.");
        return;
    }
    for (Surface s : surfaces) {
        // If pixel conversions aren't handled by egl, use a pbuffer
        try {
            if (LegacyCameraDevice.needsConversion(s)) {
                // Always override to YV12 output for YUV surface formats.
                LegacyCameraDevice.setSurfaceFormat(s, ImageFormat.YV12);
                EGLSurfaceHolder holder = new EGLSurfaceHolder();
                holder.surface = s;
                mConversionSurfaces.add(holder);
            } else {
                EGLSurfaceHolder holder = new EGLSurfaceHolder();
                holder.surface = s;
                mSurfaces.add(holder);
            }
        } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
            Log.w(TAG, "Surface abandoned, skipping configuration... ", e);
        }
    }
    // Set up egl display
    configureEGLContext();
    // Set up regular egl surfaces if needed
    if (mSurfaces.size() > 0) {
        configureEGLOutputSurfaces(mSurfaces);
    }
    // Set up pbuffer surface if needed
    if (mConversionSurfaces.size() > 0) {
        configureEGLPbufferSurfaces(mConversionSurfaces);
    }
    makeCurrent((mSurfaces.size() > 0) ? mSurfaces.get(0).eglSurface : mConversionSurfaces.get(0).eglSurface);
    initializeGLState();
    mSurfaceTexture = new SurfaceTexture(getTextureId());
    // Set up performance tracking if enabled
    if (SystemProperties.getBoolean(LEGACY_PERF_PROPERTY, false)) {
        setupGlTiming();
    }
}
Body of Second Method:
{
    releaseEGLContext();
    if (surfaces == null || surfaces.size() == 0) {
        Log.w(TAG, "No output surfaces configured for GL drawing.");
        return;
    }
    for (Pair<Surface, Size> p : surfaces) {
        Surface s = p.first;
        Size surfaceSize = p.second;
        // If pixel conversions aren't handled by egl, use a pbuffer
        try {
            EGLSurfaceHolder holder = new EGLSurfaceHolder();
            holder.surface = s;
            holder.width = surfaceSize.getWidth();
            holder.height = surfaceSize.getHeight();
            if (LegacyCameraDevice.needsConversion(s)) {
                // Always override to YV12 output for YUV surface formats.
                LegacyCameraDevice.setSurfaceFormat(s, ImageFormat.YV12);
                mConversionSurfaces.add(holder);
            } else {
                mSurfaces.add(holder);
            }
        } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
            Log.w(TAG, "Surface abandoned, skipping configuration... ", e);
        }
    }
    // Set up egl display
    configureEGLContext();
    // Set up regular egl surfaces if needed
    if (mSurfaces.size() > 0) {
        configureEGLOutputSurfaces(mSurfaces);
    }
    // Set up pbuffer surface if needed
    if (mConversionSurfaces.size() > 0) {
        configureEGLPbufferSurfaces(mConversionSurfaces);
    }
    makeCurrent((mSurfaces.size() > 0) ? mSurfaces.get(0).eglSurface : mConversionSurfaces.get(0).eglSurface);
    initializeGLState();
    mSurfaceTexture = new SurfaceTexture(getTextureId());
    // Set up performance tracking if enabled
    if (SystemProperties.getBoolean(LEGACY_PERF_PROPERTY, false)) {
        setupGlTiming();
    }
}
------------------------
Find a silently evolved API code:android.app.Activity.onKeyDown:COMMENT
Method Modifier: public      
Comment:/**
 * Called when a key was pressed down and not handled by any of the views
 * inside of the activity. So, for example, key presses while the cursor
 * is inside a TextView will not trigger the event (unless it is a navigation
 * to another object) because TextView handles its own key presses.
 *
 * <p>If the focused view didn't want this event, this method is called.
 *
 * <p>The default implementation takes care of {@link KeyEvent#KEYCODE_BACK}
 * by calling {@link #onBackPressed()}, though the behavior varies based
 * on the application compatibility mode: for
 * {@link android.os.Build.VERSION_CODES#ECLAIR} or later applications,
 * it will set up the dispatch to call {@link #onKeyUp} where the action
 * will be performed; for earlier applications, it will perform the
 * action immediately in on-down, as those versions of the platform
 * behaved.
 *
 * <p>Other additional default key handling may be performed
 * if configured with {@link #setDefaultKeyMode}.
 *
 * @return Return <code>true</code> to prevent this event from being propagated
 * further, or <code>false</code> to indicate that you have not handled
 * this event and it should continue to be propagated.
 * @see #onKeyUp
 * @see android.view.KeyEvent
 */

Body of Frist Method:
{
    if (keyCode == KeyEvent.KEYCODE_BACK) {
        if (getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.ECLAIR) {
            event.startTracking();
        } else {
            onBackPressed();
        }
        return true;
    }
    if (mDefaultKeyMode == DEFAULT_KEYS_DISABLE) {
        return false;
    } else if (mDefaultKeyMode == DEFAULT_KEYS_SHORTCUT) {
        if (getWindow().performPanelShortcut(Window.FEATURE_OPTIONS_PANEL, keyCode, event, Menu.FLAG_ALWAYS_PERFORM_CLOSE)) {
            return true;
        }
        return false;
    } else {
        // Common code for DEFAULT_KEYS_DIALER & DEFAULT_KEYS_SEARCH_*
        boolean clearSpannable = false;
        boolean handled;
        if ((event.getRepeatCount() != 0) || event.isSystem()) {
            clearSpannable = true;
            handled = false;
        } else {
            handled = TextKeyListener.getInstance().onKeyDown(null, mDefaultKeySsb, keyCode, event);
            if (handled && mDefaultKeySsb.length() > 0) {
                // something useable has been typed - dispatch it now.
                final String str = mDefaultKeySsb.toString();
                clearSpannable = true;
                switch(mDefaultKeyMode) {
                    case DEFAULT_KEYS_DIALER:
                        Intent intent = new Intent(Intent.ACTION_DIAL, Uri.parse("tel:" + str));
                        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                        startActivity(intent);
                        break;
                    case DEFAULT_KEYS_SEARCH_LOCAL:
                        startSearch(str, false, null, false);
                        break;
                    case DEFAULT_KEYS_SEARCH_GLOBAL:
                        startSearch(str, false, null, true);
                        break;
                }
            }
        }
        if (clearSpannable) {
            mDefaultKeySsb.clear();
            mDefaultKeySsb.clearSpans();
            Selection.setSelection(mDefaultKeySsb, 0);
        }
        return handled;
    }
}
Body of Second Method:
{
    if (keyCode == KeyEvent.KEYCODE_BACK) {
        if (getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.ECLAIR) {
            event.startTracking();
        } else {
            onBackPressed();
        }
        return true;
    }
    if (mDefaultKeyMode == DEFAULT_KEYS_DISABLE) {
        return false;
    } else if (mDefaultKeyMode == DEFAULT_KEYS_SHORTCUT) {
        Window w = getWindow();
        if (w.hasFeature(Window.FEATURE_OPTIONS_PANEL) && w.performPanelShortcut(Window.FEATURE_OPTIONS_PANEL, keyCode, event, Menu.FLAG_ALWAYS_PERFORM_CLOSE)) {
            return true;
        }
        return false;
    } else {
        // Common code for DEFAULT_KEYS_DIALER & DEFAULT_KEYS_SEARCH_*
        boolean clearSpannable = false;
        boolean handled;
        if ((event.getRepeatCount() != 0) || event.isSystem()) {
            clearSpannable = true;
            handled = false;
        } else {
            handled = TextKeyListener.getInstance().onKeyDown(null, mDefaultKeySsb, keyCode, event);
            if (handled && mDefaultKeySsb.length() > 0) {
                // something useable has been typed - dispatch it now.
                final String str = mDefaultKeySsb.toString();
                clearSpannable = true;
                switch(mDefaultKeyMode) {
                    case DEFAULT_KEYS_DIALER:
                        Intent intent = new Intent(Intent.ACTION_DIAL, Uri.parse("tel:" + str));
                        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                        startActivity(intent);
                        break;
                    case DEFAULT_KEYS_SEARCH_LOCAL:
                        startSearch(str, false, null, false);
                        break;
                    case DEFAULT_KEYS_SEARCH_GLOBAL:
                        startSearch(str, false, null, true);
                        break;
                }
            }
        }
        if (clearSpannable) {
            mDefaultKeySsb.clear();
            mDefaultKeySsb.clearSpans();
            Selection.setSelection(mDefaultKeySsb, 0);
        }
        return handled;
    }
}
------------------------
Find a silently evolved API code:android.animation.PropertyValuesHolder.setupSetterAndGetter:COMMENT
Method Modifier: default     
Comment:/**
 * Internal function (called from ObjectAnimator) to set up the setter and getter
 * prior to running the animation. If the setter has not been manually set for this
 * object, it will be derived automatically given the property name, target object, and
 * types of values supplied. If no getter has been set, it will be supplied iff any of the
 * supplied values was null. If there is a null value, then the getter (supplied or derived)
 * will be called to set those null values to the current value of the property
 * on the target object.
 * @param target The object on which the setter (and possibly getter) exist.
 */

Body of Frist Method:
{
    mKeyframes.invalidateCache();
    if (mProperty != null) {
        // check to make sure that mProperty is on the class of target
        try {
            Object testValue = null;
            ArrayList<Keyframe> keyframes = mKeyframes.getKeyframes();
            int keyframeCount = keyframes == null ? 0 : keyframes.size();
            for (int i = 0; i < keyframeCount; i++) {
                Keyframe kf = keyframes.get(i);
                if (!kf.hasValue() || kf.valueWasSetOnStart()) {
                    if (testValue == null) {
                        testValue = convertBack(mProperty.get(target));
                    }
                    kf.setValue(testValue);
                    kf.setValueWasSetOnStart(true);
                }
            }
            return;
        } catch (ClassCastException e) {
            Log.w("PropertyValuesHolder", "No such property (" + mProperty.getName() + ") on target object " + target + ". Trying reflection instead");
            mProperty = null;
        }
    }
    Class targetClass = target.getClass();
    if (mSetter == null) {
        setupSetter(targetClass);
    }
    ArrayList<Keyframe> keyframes = mKeyframes.getKeyframes();
    int keyframeCount = keyframes == null ? 0 : keyframes.size();
    for (int i = 0; i < keyframeCount; i++) {
        Keyframe kf = keyframes.get(i);
        if (!kf.hasValue() || kf.valueWasSetOnStart()) {
            if (mGetter == null) {
                setupGetter(targetClass);
                if (mGetter == null) {
                    // Already logged the error - just return to avoid NPE
                    return;
                }
            }
            try {
                Object value = convertBack(mGetter.invoke(target));
                kf.setValue(value);
                kf.setValueWasSetOnStart(true);
            } catch (InvocationTargetException e) {
                Log.e("PropertyValuesHolder", e.toString());
            } catch (IllegalAccessException e) {
                Log.e("PropertyValuesHolder", e.toString());
            }
        }
    }
}
Body of Second Method:
{
    mKeyframes.invalidateCache();
    if (mProperty != null) {
        // check to make sure that mProperty is on the class of target
        try {
            Object testValue = null;
            List<Keyframe> keyframes = mKeyframes.getKeyframes();
            int keyframeCount = keyframes == null ? 0 : keyframes.size();
            for (int i = 0; i < keyframeCount; i++) {
                Keyframe kf = keyframes.get(i);
                if (!kf.hasValue() || kf.valueWasSetOnStart()) {
                    if (testValue == null) {
                        testValue = convertBack(mProperty.get(target));
                    }
                    kf.setValue(testValue);
                    kf.setValueWasSetOnStart(true);
                }
            }
            return;
        } catch (ClassCastException e) {
            Log.w("PropertyValuesHolder", "No such property (" + mProperty.getName() + ") on target object " + target + ". Trying reflection instead");
            mProperty = null;
        }
    }
    // We can't just say 'else' here because the catch statement sets mProperty to null.
    if (mProperty == null) {
        Class targetClass = target.getClass();
        if (mSetter == null) {
            setupSetter(targetClass);
        }
        List<Keyframe> keyframes = mKeyframes.getKeyframes();
        int keyframeCount = keyframes == null ? 0 : keyframes.size();
        for (int i = 0; i < keyframeCount; i++) {
            Keyframe kf = keyframes.get(i);
            if (!kf.hasValue() || kf.valueWasSetOnStart()) {
                if (mGetter == null) {
                    setupGetter(targetClass);
                    if (mGetter == null) {
                        // Already logged the error - just return to avoid NPE
                        return;
                    }
                }
                try {
                    Object value = convertBack(mGetter.invoke(target));
                    kf.setValue(value);
                    kf.setValueWasSetOnStart(true);
                } catch (InvocationTargetException e) {
                    Log.e("PropertyValuesHolder", e.toString());
                } catch (IllegalAccessException e) {
                    Log.e("PropertyValuesHolder", e.toString());
                }
            }
        }
    }
}
------------------------
Find a silently evolved API code:android.media.AudioRecord.audioParamCheck:COMMENT
Method Modifier: private     
Comment:// mSampleRate is valid

Body of Frist Method:
{
    // audio source
    if ((audioSource < MediaRecorder.AudioSource.DEFAULT) || ((audioSource > MediaRecorder.getAudioSourceMax()) && (audioSource != MediaRecorder.AudioSource.HOTWORD))) {
        throw new IllegalArgumentException("Invalid audio source.");
    }
    mRecordSource = audioSource;
    // sample rate
    if ((sampleRateInHz < 4000) || (sampleRateInHz > 48000)) {
        throw new IllegalArgumentException(sampleRateInHz + "Hz is not a supported sample rate.");
    }
    mSampleRate = sampleRateInHz;
    // audio format
    switch(audioFormat) {
        case AudioFormat.ENCODING_DEFAULT:
            mAudioFormat = AudioFormat.ENCODING_PCM_16BIT;
            break;
        case AudioFormat.ENCODING_PCM_16BIT:
        case AudioFormat.ENCODING_PCM_8BIT:
            mAudioFormat = audioFormat;
            break;
        default:
            throw new IllegalArgumentException("Unsupported sample encoding." + " Should be ENCODING_PCM_8BIT or ENCODING_PCM_16BIT.");
    }
}
Body of Second Method:
{
    // audio source
    if ((audioSource < MediaRecorder.AudioSource.DEFAULT) || ((audioSource > MediaRecorder.getAudioSourceMax()) && (audioSource != MediaRecorder.AudioSource.FM_TUNER) && (audioSource != MediaRecorder.AudioSource.HOTWORD))) {
        throw new IllegalArgumentException("Invalid audio source.");
    }
    mRecordSource = audioSource;
    // sample rate
    if ((sampleRateInHz < 4000) || (sampleRateInHz > 48000)) {
        throw new IllegalArgumentException(sampleRateInHz + "Hz is not a supported sample rate.");
    }
    mSampleRate = sampleRateInHz;
    // audio format
    switch(audioFormat) {
        case AudioFormat.ENCODING_DEFAULT:
            mAudioFormat = AudioFormat.ENCODING_PCM_16BIT;
            break;
        case AudioFormat.ENCODING_PCM_16BIT:
        case AudioFormat.ENCODING_PCM_8BIT:
            mAudioFormat = audioFormat;
            break;
        default:
            throw new IllegalArgumentException("Unsupported sample encoding." + " Should be ENCODING_PCM_8BIT or ENCODING_PCM_16BIT.");
    }
}
------------------------
Find a silently evolved API code:android.graphics.drawable.ScaleDrawable.getDrawable:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the drawable scaled by this ScaleDrawable.
 */

Body of Frist Method:
{
    return mScaleState.mDrawable;
}
Body of Second Method:
{
    return mState.mDrawable;
}
------------------------
Find a silently evolved API code:android.webkit.WebBackForwardList.getItemAtIndex:COMMENT
<android.webkit.WebBackForwardList: WebHistoryItem getItemAtIndex(int)>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Get the history item at the given index. The index range is from 0...n
 * where 0 is the first item and n is the last item.
 * @param index The index to retrieve.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.app.BackStackRecord.addTransitionTargets:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Prepares the enter transition by adding a non-existent view to the transition's target list
 * and setting it epicenter callback. By adding a non-existent view to the target list,
 * we can prevent any view from being targeted at the beginning of the transition.
 * We will add to the views before the end state of the transition is captured so that the
 * views will appear. At the start of the transition, we clear the list of targets so that
 * we can restore the state of the transition and use it again.
 *
 * <p>The shared element transition maps its shared elements immediately prior to
 * capturing the final state of the Transition.</p>
 */

Body of Frist Method:
{
    if (enterTransition == null && sharedElementTransition == null && overallTransition == null) {
        return null;
    }
    final ArrayList<View> enteringViews = new ArrayList<View>();
    container.getViewTreeObserver().addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {

        @Override
        public boolean onPreDraw() {
            container.getViewTreeObserver().removeOnPreDrawListener(this);
            // Don't include any newly-hidden fragments in the transition.
            excludeHiddenFragments(hiddenFragmentViews, inFragment.mContainerId, overallTransition);
            ArrayMap<String, View> namedViews = null;
            if (sharedElementTransition != null) {
                namedViews = mapSharedElementsIn(state, isBack, inFragment);
                removeTargets(sharedElementTransition, sharedElementTargets);
                sharedElementTargets.clear();
                if (namedViews.isEmpty()) {
                    sharedElementTargets.add(state.nonExistentView);
                } else {
                    sharedElementTargets.addAll(namedViews.values());
                }
                addTargets(sharedElementTransition, sharedElementTargets);
                setEpicenterIn(namedViews, state);
                callSharedElementEnd(state, inFragment, outFragment, isBack, namedViews);
            }
            if (enterTransition != null) {
                View view = inFragment.getView();
                if (view != null) {
                    view.captureTransitioningViews(enteringViews);
                    if (namedViews != null) {
                        enteringViews.removeAll(namedViews.values());
                    }
                    addTargets(enterTransition, enteringViews);
                }
                setSharedElementEpicenter(enterTransition, state);
            }
            return true;
        }
    });
    return enteringViews;
}
Body of Second Method:
{
    if (enterTransition == null && sharedElementTransition == null && overallTransition == null) {
        return null;
    }
    final ArrayList<View> enteringViews = new ArrayList<View>();
    container.getViewTreeObserver().addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {

        @Override
        public boolean onPreDraw() {
            container.getViewTreeObserver().removeOnPreDrawListener(this);
            // Don't include any newly-hidden fragments in the transition.
            excludeHiddenFragments(hiddenFragmentViews, inFragment.mContainerId, overallTransition);
            ArrayMap<String, View> namedViews = null;
            if (sharedElementTransition != null) {
                namedViews = mapSharedElementsIn(state, isBack, inFragment);
                removeTargets(sharedElementTransition, sharedElementTargets);
                sharedElementTargets.clear();
                sharedElementTargets.add(state.nonExistentView);
                sharedElementTargets.addAll(namedViews.values());
                addTargets(sharedElementTransition, sharedElementTargets);
                setEpicenterIn(namedViews, state);
                callSharedElementEnd(state, inFragment, outFragment, isBack, namedViews);
            }
            if (enterTransition != null) {
                View view = inFragment.getView();
                if (view != null) {
                    view.captureTransitioningViews(enteringViews);
                    if (namedViews != null) {
                        enteringViews.removeAll(namedViews.values());
                    }
                    enteringViews.add(state.nonExistentView);
                    // We added this earlier to prevent any views being targeted.
                    enterTransition.removeTarget(state.nonExistentView);
                    addTargets(enterTransition, enteringViews);
                }
                setSharedElementEpicenter(enterTransition, state);
            }
            return true;
        }
    });
    return enteringViews;
}
------------------------
Find a silently evolved API code:android.webkit.CookieManager.flush:COMMENT
<android.webkit.CookieManager: void flush()>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Ensures all cookies currently accessible through the getCookie API are
 * written to persistent storage.
 * This call will block the caller until it is done and may perform I/O.
 */

Body of Frist Method:
{
    flushCookieStore();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.telephony.SubscriptionManager.isValidSlotId:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    // value is invalid.
    return slotId != INVALID_SLOT_ID && slotId >= 0 && slotId < TelephonyManager.getDefault().getSimCount();
}
Body of Second Method:
{
    return slotId >= 0 && slotId < TelephonyManager.getDefault().getSimCount();
}
------------------------
Find a silently evolved API code:android.net.LinkAddress.isGlobalPreferred:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns true if this {@code LinkAddress} is global scope and preferred.
 * @hide
 */

Body of Frist Method:
{
    return (scope == RT_SCOPE_UNIVERSE && (flags & (IFA_F_DADFAILED | IFA_F_DEPRECATED | IFA_F_TENTATIVE)) == 0L);
}
Body of Second Method:
{
    /**
     * Note that addresses flagged as IFA_F_OPTIMISTIC are
     * simultaneously flagged as IFA_F_TENTATIVE (when the tentative
     * state has cleared either DAD has succeeded or failed, and both
     * flags are cleared regardless).
     */
    return (scope == RT_SCOPE_UNIVERSE && !isIPv6ULA() && (flags & (IFA_F_DADFAILED | IFA_F_DEPRECATED)) == 0L && ((flags & IFA_F_TENTATIVE) == 0L || (flags & IFA_F_OPTIMISTIC) != 0L));
}
------------------------
Find a silently evolved API code:android.webkit.WebSettings.supportZoom:COMMENT
<android.webkit.WebSettings: boolean supportZoom()>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Gets whether the WebView supports zoom.
 *
 * @return true if the WebView supports zoom
 * @see #setSupportZoom
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.webkit.WebSettings.getPluginState:COMMENT
<android.webkit.WebSettings: PluginState getPluginState()>
public      deprecated  ->public      abstract    deprecated  
Method Modifier: public      abstract    deprecated  
Method Modifier: Yes         No          Yes         
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * Gets the current state regarding whether plugins are enabled.
 *
 * @return the plugin state as a {@link PluginState} value
 * @see #setPluginState
 * @deprecated Plugins will not be supported in future, and should not be used.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.webkit.WebSettings.getDatabaseEnabled:COMMENT
<android.webkit.WebSettings: boolean getDatabaseEnabled()>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Gets whether the database storage API is enabled.
 *
 * @return true if the database storage API is enabled
 * @see #setDatabaseEnabled
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.media.AudioManager.forceVolumeControlStream:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * forces the stream controlled by hard volume keys
 * specifying streamType == -1 releases control to the
 * logic.
 *
 * @hide
 */

Body of Frist Method:
{
    IAudioService service = getService();
    try {
        service.forceVolumeControlStream(streamType, mICallBack);
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in forceVolumeControlStream", e);
    }
}
Body of Second Method:
{
    if (mUseMasterVolume) {
        return;
    }
    IAudioService service = getService();
    try {
        service.forceVolumeControlStream(streamType, mICallBack);
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in forceVolumeControlStream", e);
    }
}
------------------------
Find a silently evolved API code:android.text.format.DateFormat.is24HourFormat:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns true if user preference is set to 24-hour format.
 * @param context the context to use for the content resolver
 * @return true if 24 hour time format is selected, false otherwise.
 */

Body of Frist Method:
{
    String value = Settings.System.getString(context.getContentResolver(), Settings.System.TIME_12_24);
    if (value == null) {
        Locale locale = context.getResources().getConfiguration().locale;
        synchronized (sLocaleLock) {
            if (sIs24HourLocale != null && sIs24HourLocale.equals(locale)) {
                return sIs24Hour;
            }
        }
        java.text.DateFormat natural = java.text.DateFormat.getTimeInstance(java.text.DateFormat.LONG, locale);
        if (natural instanceof SimpleDateFormat) {
            SimpleDateFormat sdf = (SimpleDateFormat) natural;
            String pattern = sdf.toPattern();
            if (pattern.indexOf('H') >= 0) {
                value = "24";
            } else {
                value = "12";
            }
        } else {
            value = "12";
        }
        synchronized (sLocaleLock) {
            sIs24HourLocale = locale;
            sIs24Hour = value.equals("24");
        }
        return sIs24Hour;
    }
    return value.equals("24");
}
Body of Second Method:
{
    return is24HourFormat(context, UserHandle.myUserId());
}
------------------------
Find a silently evolved API code:android.telephony.ServiceState.setFromNotifierBundle:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Set ServiceState based on intent notifier map.
 *
 * @param m intent notifier map
 * @hide
 */

Body of Frist Method:
{
    mVoiceRegState = m.getInt("voiceRegState");
    mDataRegState = m.getInt("dataRegState");
    mRoaming = m.getBoolean("roaming");
    mOperatorAlphaLong = m.getString("operator-alpha-long");
    mOperatorAlphaShort = m.getString("operator-alpha-short");
    mOperatorNumeric = m.getString("operator-numeric");
    mIsManualNetworkSelection = m.getBoolean("manual");
    mRilVoiceRadioTechnology = m.getInt("radioTechnology");
    mRilDataRadioTechnology = m.getInt("dataRadioTechnology");
    mCssIndicator = m.getBoolean("cssIndicator");
    mNetworkId = m.getInt("networkId");
    mSystemId = m.getInt("systemId");
    mCdmaRoamingIndicator = m.getInt("cdmaRoamingIndicator");
    mCdmaDefaultRoamingIndicator = m.getInt("cdmaDefaultRoamingIndicator");
    mIsEmergencyOnly = m.getBoolean("emergencyOnly");
}
Body of Second Method:
{
    mVoiceRegState = m.getInt("voiceRegState");
    mDataRegState = m.getInt("dataRegState");
    mVoiceRoamingType = m.getInt("voiceRoamingType");
    mDataRoamingType = m.getInt("dataRoamingType");
    mVoiceOperatorAlphaLong = m.getString("operator-alpha-long");
    mVoiceOperatorAlphaShort = m.getString("operator-alpha-short");
    mVoiceOperatorNumeric = m.getString("operator-numeric");
    mDataOperatorAlphaLong = m.getString("data-operator-alpha-long");
    mDataOperatorAlphaShort = m.getString("data-operator-alpha-short");
    mDataOperatorNumeric = m.getString("data-operator-numeric");
    mIsManualNetworkSelection = m.getBoolean("manual");
    mRilVoiceRadioTechnology = m.getInt("radioTechnology");
    mRilDataRadioTechnology = m.getInt("dataRadioTechnology");
    mCssIndicator = m.getBoolean("cssIndicator");
    mNetworkId = m.getInt("networkId");
    mSystemId = m.getInt("systemId");
    mCdmaRoamingIndicator = m.getInt("cdmaRoamingIndicator");
    mCdmaDefaultRoamingIndicator = m.getInt("cdmaDefaultRoamingIndicator");
    mIsEmergencyOnly = m.getBoolean("emergencyOnly");
}
------------------------
Find a silently evolved API code:android.webkit.WebHistoryItem.getId:COMMENT
<android.webkit.WebHistoryItem: int getId()>
public      hidden      deprecated  ->public      abstract    hidden      deprecated  
Method Modifier: public      abstract    hidden      deprecated  
Method Modifier: Yes         No          Yes         Yes         
Method Updated:  Yes         Yes         Yes         Yes         
Comment:/**
 * Return an identifier for this history item. If an item is a copy of
 * another item, the identifiers will be the same even if they are not the
 * same object.
 * @return The id for this item.
 * @deprecated This method is now obsolete.
 * @hide Since API level {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1}
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.media.AudioService.adjustMasterVolume:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @see AudioManager#adjustMasterVolume(int, int)
 */

Body of Frist Method:
{
    if (mUseFixedVolume) {
        return;
    }
    ensureValidSteps(steps);
    int volume = Math.round(AudioSystem.getMasterVolume() * MAX_MASTER_VOLUME);
    int delta = 0;
    int numSteps = Math.abs(steps);
    int direction = steps > 0 ? AudioManager.ADJUST_RAISE : AudioManager.ADJUST_LOWER;
    for (int i = 0; i < numSteps; ++i) {
        delta = findVolumeDelta(direction, volume);
        volume += delta;
    }
    // Log.d(TAG, "adjustMasterVolume volume: " + volume + " steps: " + steps);
    setMasterVolume(volume, flags, callingPackage);
}
Body of Second Method:
{
    adjustMasterVolume(steps, flags, callingPackage, Binder.getCallingUid());
}
------------------------
Find a silently evolved API code:android.appwidget.AppWidgetHost.startAppWidgetConfigureActivityForResult:COMMENT
Method Modifier: public      final       
Comment:/**
 * Starts an app widget provider configure activity for result on behalf of the caller.
 * Use this method if the provider is in another profile as you are not allowed to start
 * an activity in another profile. You can optionally provide a request code that is
 * returned in {@link Activity#onActivityResult(int, int, android.content.Intent)} and
 * an options bundle to be passed to the started activity.
 * <p>
 * Note that the provided app widget has to be bound for this method to work.
 * </p>
 *
 * @param activity The activity from which to start the configure one.
 * @param appWidgetId The bound app widget whose provider's config activity to start.
 * @param requestCode Optional request code retuned with the result.
 * @param intentFlags Optional intent flags.
 *
 * @throws android.content.ActivityNotFoundException If the activity is not found.
 *
 * @see AppWidgetProviderInfo#getProfile()
 */

Body of Frist Method:
{
    try {
        IntentSender intentSender = sService.createAppWidgetConfigIntentSender(mContext.getOpPackageName(), appWidgetId, intentFlags);
        if (intentSender != null) {
            activity.startIntentSenderForResult(intentSender, requestCode, null, 0, 0, 0, options);
        } else {
            throw new ActivityNotFoundException();
        }
    } catch (IntentSender.SendIntentException e) {
        throw new ActivityNotFoundException();
    } catch (RemoteException e) {
        throw new RuntimeException("system server dead?", e);
    }
}
Body of Second Method:
{
    try {
        IntentSender intentSender = sService.createAppWidgetConfigIntentSender(mContextOpPackageName, appWidgetId, intentFlags);
        if (intentSender != null) {
            activity.startIntentSenderForResult(intentSender, requestCode, null, 0, 0, 0, options);
        } else {
            throw new ActivityNotFoundException();
        }
    } catch (IntentSender.SendIntentException e) {
        throw new ActivityNotFoundException();
    } catch (RemoteException e) {
        throw new RuntimeException("system server dead?", e);
    }
}
------------------------
Find a silently evolved API code:android.app.ActivityThread.ApplicationThread.scheduleLaunchActivity:COMMENT
Method Modifier: public      final       
Comment:// activity itself back to the activity manager. (matters more with ipc)

Body of Frist Method:
{
    updateProcessState(procState, false);
    ActivityClientRecord r = new ActivityClientRecord();
    r.token = token;
    r.ident = ident;
    r.intent = intent;
    r.voiceInteractor = voiceInteractor;
    r.activityInfo = info;
    r.compatInfo = compatInfo;
    r.state = state;
    r.persistentState = persistentState;
    r.pendingResults = pendingResults;
    r.pendingIntents = pendingNewIntents;
    r.startsNotResumed = notResumed;
    r.isForward = isForward;
    r.profilerInfo = profilerInfo;
    updatePendingConfiguration(curConfig);
    sendMessage(H.LAUNCH_ACTIVITY, r);
}
Body of Second Method:
{
    updateProcessState(procState, false);
    ActivityClientRecord r = new ActivityClientRecord();
    r.token = token;
    r.ident = ident;
    r.intent = intent;
    r.referrer = referrer;
    r.voiceInteractor = voiceInteractor;
    r.activityInfo = info;
    r.compatInfo = compatInfo;
    r.state = state;
    r.persistentState = persistentState;
    r.pendingResults = pendingResults;
    r.pendingIntents = pendingNewIntents;
    r.startsNotResumed = notResumed;
    r.isForward = isForward;
    r.profilerInfo = profilerInfo;
    updatePendingConfiguration(curConfig);
    sendMessage(H.LAUNCH_ACTIVITY, r);
}
------------------------
Find a silently evolved API code:android.widget.RadialTimePickerView.getCurrentMinute:COMMENT
Method Modifier: public      hidden      
Comment:// Returns minutes in 0-59 range

Body of Frist Method:
{
    return (mSelectionDegrees[MINUTES] / DEGREES_FOR_ONE_MINUTE);
}
Body of Second Method:
{
    return getMinuteForDegrees(mSelectionDegrees[MINUTES]);
}
------------------------
Find a silently evolved API code:android.app.ActivityOptions.update:COMMENT
Method Modifier: public      
Comment:/**
 * Update the current values in this ActivityOptions from those supplied
 * in <var>otherOptions</var>.  Any values
 * defined in <var>otherOptions</var> replace those in the base options.
 */

Body of Frist Method:
{
    if (otherOptions.mPackageName != null) {
        mPackageName = otherOptions.mPackageName;
    }
    mTransitionReceiver = null;
    mSharedElementNames = null;
    mIsReturning = false;
    mResultData = null;
    mResultCode = 0;
    mExitCoordinatorIndex = 0;
    mAnimationType = otherOptions.mAnimationType;
    switch(otherOptions.mAnimationType) {
        case ANIM_CUSTOM:
            mCustomEnterResId = otherOptions.mCustomEnterResId;
            mCustomExitResId = otherOptions.mCustomExitResId;
            mThumbnail = null;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = otherOptions.mAnimationStartedListener;
            break;
        case ANIM_SCALE_UP:
            mStartX = otherOptions.mStartX;
            mStartY = otherOptions.mStartY;
            mWidth = otherOptions.mWidth;
            mHeight = otherOptions.mHeight;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = null;
            break;
        case ANIM_THUMBNAIL_SCALE_UP:
        case ANIM_THUMBNAIL_SCALE_DOWN:
        case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
        case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
            mThumbnail = otherOptions.mThumbnail;
            mStartX = otherOptions.mStartX;
            mStartY = otherOptions.mStartY;
            mWidth = otherOptions.mWidth;
            mHeight = otherOptions.mHeight;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = otherOptions.mAnimationStartedListener;
            break;
        case ANIM_SCENE_TRANSITION:
            mTransitionReceiver = otherOptions.mTransitionReceiver;
            mSharedElementNames = otherOptions.mSharedElementNames;
            mIsReturning = otherOptions.mIsReturning;
            mThumbnail = null;
            mAnimationStartedListener = null;
            mResultData = otherOptions.mResultData;
            mResultCode = otherOptions.mResultCode;
            mExitCoordinatorIndex = otherOptions.mExitCoordinatorIndex;
            break;
    }
}
Body of Second Method:
{
    if (otherOptions.mPackageName != null) {
        mPackageName = otherOptions.mPackageName;
    }
    mTransitionReceiver = null;
    mSharedElementNames = null;
    mIsReturning = false;
    mResultData = null;
    mResultCode = 0;
    mExitCoordinatorIndex = 0;
    mAnimationType = otherOptions.mAnimationType;
    switch(otherOptions.mAnimationType) {
        case ANIM_CUSTOM:
            mCustomEnterResId = otherOptions.mCustomEnterResId;
            mCustomExitResId = otherOptions.mCustomExitResId;
            mThumbnail = null;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = otherOptions.mAnimationStartedListener;
            break;
        case ANIM_CUSTOM_IN_PLACE:
            mCustomInPlaceResId = otherOptions.mCustomInPlaceResId;
            break;
        case ANIM_SCALE_UP:
            mStartX = otherOptions.mStartX;
            mStartY = otherOptions.mStartY;
            mWidth = otherOptions.mWidth;
            mHeight = otherOptions.mHeight;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = null;
            break;
        case ANIM_THUMBNAIL_SCALE_UP:
        case ANIM_THUMBNAIL_SCALE_DOWN:
        case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
        case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
            mThumbnail = otherOptions.mThumbnail;
            mStartX = otherOptions.mStartX;
            mStartY = otherOptions.mStartY;
            mWidth = otherOptions.mWidth;
            mHeight = otherOptions.mHeight;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = otherOptions.mAnimationStartedListener;
            break;
        case ANIM_SCENE_TRANSITION:
            mTransitionReceiver = otherOptions.mTransitionReceiver;
            mSharedElementNames = otherOptions.mSharedElementNames;
            mIsReturning = otherOptions.mIsReturning;
            mThumbnail = null;
            mAnimationStartedListener = null;
            mResultData = otherOptions.mResultData;
            mResultCode = otherOptions.mResultCode;
            mExitCoordinatorIndex = otherOptions.mExitCoordinatorIndex;
            break;
    }
}
------------------------
Find a silently evolved API code:android.webkit.WebView.findAll:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * Finds all instances of find on the page and highlights them.
 * Notifies any registered {@link FindListener}.
 *
 * @param find the string to find
 * @return the number of occurances of the String "find" that were found
 * @deprecated {@link #findAllAsync} is preferred.
 * @see #setFindListener
 */

Body of Frist Method:
{
    checkThread();
    if (DebugFlags.TRACE_API)
        Log.d(LOGTAG, "findAll");
    StrictMode.noteSlowCall("findAll blocks UI: prefer findAllAsync");
    return mProvider.findAll(find);
}
Body of Second Method:
{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, "findAll");
    StrictMode.noteSlowCall("findAll blocks UI: prefer findAllAsync");
    return mProvider.findAll(find);
}
------------------------
Find a silently evolved API code:android.graphics.drawable.Ripple.cancelHardwareAnimations:COMMENT
Method Modifier: private     
Comment:/**
 * Cancels any running hardware animations.
 */

Body of Frist Method:
{
    final ArrayList<RenderNodeAnimator> runningAnimations = mRunningAnimations;
    final int N = runningAnimations.size();
    for (int i = 0; i < N; i++) {
        runningAnimations.get(i).cancel();
    }
    runningAnimations.clear();
    if (cancelPending && !mPendingAnimations.isEmpty()) {
        mPendingAnimations.clear();
    }
    mHardwareAnimating = false;
}
Body of Second Method:
{
    final ArrayList<RenderNodeAnimator> runningAnimations = mRunningAnimations;
    final int N = runningAnimations.size();
    for (int i = 0; i < N; i++) {
        if (jumpToEnd) {
            runningAnimations.get(i).end();
        } else {
            runningAnimations.get(i).cancel();
        }
    }
    runningAnimations.clear();
    if (mHasPendingHardwareExit) {
        // If we had a pending hardware exit, jump to the end state.
        mHasPendingHardwareExit = false;
        if (jumpToEnd) {
            mOpacity = 0;
            mTweenX = 1;
            mTweenY = 1;
            mTweenRadius = 1;
        }
    }
    mHardwareAnimating = false;
}
------------------------
Find a silently evolved API code:android.net.RssiCurve.equals:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Determine if two RSSI curves are defined in the same way.
 *
 * <p>Note that two curves can be equivalent but defined differently, e.g. if one bucket in one
 * curve is split into two buckets in another. For the purpose of this method, these curves are
 * not considered equal to each other.
 */

Body of Frist Method:
{
    if (this == o)
        return true;
    if (o == null || getClass() != o.getClass())
        return false;
    RssiCurve rssiCurve = (RssiCurve) o;
    return start == rssiCurve.start && bucketWidth == rssiCurve.bucketWidth && Arrays.equals(rssiBuckets, rssiCurve.rssiBuckets);
}
Body of Second Method:
{
    if (this == o)
        return true;
    if (o == null || getClass() != o.getClass())
        return false;
    RssiCurve rssiCurve = (RssiCurve) o;
    return start == rssiCurve.start && bucketWidth == rssiCurve.bucketWidth && Arrays.equals(rssiBuckets, rssiCurve.rssiBuckets) && activeNetworkRssiBoost == rssiCurve.activeNetworkRssiBoost;
}
------------------------
Find a silently evolved API code:android.webkit.WebView.clearClientCertPreferences:COMMENT
Method Modifier: public      static      
Comment:/**
 * Clears the client certificate preferences stored in response
 * to proceeding/cancelling client cert requests. Note that Webview
 * automatically clears these preferences when it receives a
 * {@link KeyChain#ACTION_STORAGE_CHANGED} intent. The preferences are
 * shared by all the webviews that are created by the embedder application.
 *
 * @param onCleared  A runnable to be invoked when client certs are cleared.
 * The embedder can pass null if not interested in the
 * callback. The runnable will be called in UI thread.
 */

Body of Frist Method:
{
    if (DebugFlags.TRACE_API)
        Log.d(LOGTAG, "clearClientCertPreferences");
    getFactory().getStatics().clearClientCertPreferences(onCleared);
}
Body of Second Method:
{
    if (TRACE)
        Log.d(LOGTAG, "clearClientCertPreferences");
    getFactory().getStatics().clearClientCertPreferences(onCleared);
}
------------------------
Find a silently evolved API code:android.webkit.WebHistoryItem.getFavicon:COMMENT
<android.webkit.WebHistoryItem: Bitmap getFavicon()>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Return the favicon of this history item or null if no favicon was found.
 * @return A Bitmap containing the favicon for this history item or null.
 * Note: The VM ensures 32-bit atomic read/write operations so we don't have
 * to synchronize this method.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.webkit.CookieManager.setAcceptCookie:COMMENT
<android.webkit.CookieManager: void setAcceptCookie(boolean)>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Sets whether the application's {@link WebView} instances should send and
 * accept cookies.
 * By default this is set to true and the WebView accepts cookies.
 * <p>
 * When this is true
 * {@link CookieManager#setAcceptThirdPartyCookies setAcceptThirdPartyCookies} and
 * {@link CookieManager#setAcceptFileSchemeCookies setAcceptFileSchemeCookies}
 * can be used to control the policy for those specific types of cookie.
 *
 * @param accept whether {@link WebView} instances should send and accept
 * cookies
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.widget.DayPickerView.performAccessibilityAction:COMMENT
Method Modifier: public      
Comment:/**
 * When scroll forward/backward events are received, announce the newly scrolled-to month.
 */

Body of Frist Method:
{
    if (action != AccessibilityNodeInfo.ACTION_SCROLL_FORWARD && action != AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD) {
        return super.performAccessibilityAction(action, arguments);
    }
    // Figure out what month is showing.
    int firstVisiblePosition = getFirstVisiblePosition();
    int month = firstVisiblePosition % 12;
    int year = firstVisiblePosition / 12 + mController.getMinYear();
    Calendar day = Calendar.getInstance();
    day.set(year, month, 1);
    // Scroll either forward or backward one month.
    if (action == AccessibilityNodeInfo.ACTION_SCROLL_FORWARD) {
        day.add(Calendar.MONTH, 1);
        if (day.get(Calendar.MONTH) == 12) {
            day.set(Calendar.MONTH, 0);
            day.add(Calendar.YEAR, 1);
        }
    } else if (action == AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD) {
        View firstVisibleView = getChildAt(0);
        // to the first day of first visible month.
        if (firstVisibleView != null && firstVisibleView.getTop() >= -1) {
            // There's an off-by-one somewhere, so the top of the first visible item will
            // actually be -1 when it's at the exact top.
            day.add(Calendar.MONTH, -1);
            if (day.get(Calendar.MONTH) == -1) {
                day.set(Calendar.MONTH, 11);
                day.add(Calendar.YEAR, -1);
            }
        }
    }
    // Go to that month.
    announceForAccessibility(getMonthAndYearString(day));
    goTo(day, true, false, true);
    mPerformingScroll = true;
    return true;
}
Body of Second Method:
{
    if (action != AccessibilityNodeInfo.ACTION_SCROLL_FORWARD && action != AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD) {
        return super.performAccessibilityAction(action, arguments);
    }
    // Figure out what month is showing.
    final int firstVisiblePosition = getFirstVisiblePosition();
    final int month = firstVisiblePosition % 12;
    final int year = firstVisiblePosition / 12 + mMinDate.get(Calendar.YEAR);
    final Calendar day = Calendar.getInstance();
    day.set(year, month, 1);
    // Scroll either forward or backward one month.
    if (action == AccessibilityNodeInfo.ACTION_SCROLL_FORWARD) {
        day.add(Calendar.MONTH, 1);
        if (day.get(Calendar.MONTH) == 12) {
            day.set(Calendar.MONTH, 0);
            day.add(Calendar.YEAR, 1);
        }
    } else if (action == AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD) {
        View firstVisibleView = getChildAt(0);
        // to the first day of first visible month.
        if (firstVisibleView != null && firstVisibleView.getTop() >= -1) {
            // There's an off-by-one somewhere, so the top of the first visible item will
            // actually be -1 when it's at the exact top.
            day.add(Calendar.MONTH, -1);
            if (day.get(Calendar.MONTH) == -1) {
                day.set(Calendar.MONTH, 11);
                day.add(Calendar.YEAR, -1);
            }
        }
    }
    // Go to that month.
    announceForAccessibility(getMonthAndYearString(day));
    goTo(day.getTimeInMillis(), true, false, true);
    mPerformingScroll = true;
    return true;
}
------------------------
Find a silently evolved API code:android.webkit.URLUtil.guessUrl:COMMENT
Method Modifier: public      static      
Comment:/**
 * Cleans up (if possible) user-entered web addresses
 */

Body of Frist Method:
{
    String retVal = inUrl;
    WebAddress webAddress;
    if (DebugFlags.URL_UTIL)
        Log.v(LOGTAG, "guessURL before queueRequest: " + inUrl);
    if (inUrl.length() == 0)
        return inUrl;
    if (inUrl.startsWith("about:"))
        return inUrl;
    // Do not try to interpret data scheme URLs
    if (inUrl.startsWith("data:"))
        return inUrl;
    // Do not try to interpret file scheme URLs
    if (inUrl.startsWith("file:"))
        return inUrl;
    // Do not try to interpret javascript scheme URLs
    if (inUrl.startsWith("javascript:"))
        return inUrl;
    // bug 762454: strip period off end of url
    if (inUrl.endsWith(".") == true) {
        inUrl = inUrl.substring(0, inUrl.length() - 1);
    }
    try {
        webAddress = new WebAddress(inUrl);
    } catch (ParseException ex) {
        if (DebugFlags.URL_UTIL) {
            Log.v(LOGTAG, "smartUrlFilter: failed to parse url = " + inUrl);
        }
        return retVal;
    }
    // Check host
    if (webAddress.getHost().indexOf('.') == -1) {
        // no dot: user probably entered a bare domain.  try .com
        webAddress.setHost("www." + webAddress.getHost() + ".com");
    }
    return webAddress.toString();
}
Body of Second Method:
{
    String retVal = inUrl;
    WebAddress webAddress;
    if (TRACE)
        Log.v(LOGTAG, "guessURL before queueRequest: " + inUrl);
    if (inUrl.length() == 0)
        return inUrl;
    if (inUrl.startsWith("about:"))
        return inUrl;
    // Do not try to interpret data scheme URLs
    if (inUrl.startsWith("data:"))
        return inUrl;
    // Do not try to interpret file scheme URLs
    if (inUrl.startsWith("file:"))
        return inUrl;
    // Do not try to interpret javascript scheme URLs
    if (inUrl.startsWith("javascript:"))
        return inUrl;
    // bug 762454: strip period off end of url
    if (inUrl.endsWith(".") == true) {
        inUrl = inUrl.substring(0, inUrl.length() - 1);
    }
    try {
        webAddress = new WebAddress(inUrl);
    } catch (ParseException ex) {
        if (TRACE) {
            Log.v(LOGTAG, "smartUrlFilter: failed to parse url = " + inUrl);
        }
        return retVal;
    }
    // Check host
    if (webAddress.getHost().indexOf('.') == -1) {
        // no dot: user probably entered a bare domain.  try .com
        webAddress.setHost("www." + webAddress.getHost() + ".com");
    }
    return webAddress.toString();
}
------------------------
Find a silently evolved API code:android.widget.TextView.getIterableTextForAccessibility:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (!(mText instanceof Spannable)) {
        setText(mText, BufferType.SPANNABLE);
    }
    return mText;
}
Body of Second Method:
{
    return mText;
}
------------------------
Find a silently evolved API code:android.animation.PropertyValuesHolder.setupStartValue:COMMENT
Method Modifier: default     
Comment:/**
 * This function is called by ObjectAnimator when setting the start values for an animation.
 * The start values are set according to the current values in the target object. The
 * property whose value is extracted is whatever is specified by the propertyName of this
 * PropertyValuesHolder object.
 *
 * @param target The object which holds the start values that should be set.
 */

Body of Frist Method:
{
    ArrayList<Keyframe> keyframes = mKeyframes.getKeyframes();
    if (!keyframes.isEmpty()) {
        setupValue(target, keyframes.get(0));
    }
}
Body of Second Method:
{
    List<Keyframe> keyframes = mKeyframes.getKeyframes();
    if (!keyframes.isEmpty()) {
        setupValue(target, keyframes.get(0));
    }
}
------------------------
Find a silently evolved API code:android.widget.ProgressBar.applyProgressBackgroundTint:COMMENT
Method Modifier: private     
Comment:/**
 * Should only be called if we've already verified that mProgressDrawable
 * and mProgressTintInfo are non-null.
 */

Body of Frist Method:
{
    if (mProgressTintInfo.mHasProgressBackgroundTint || mProgressTintInfo.mHasProgressBackgroundTintMode) {
        final Drawable target = getTintTarget(R.id.background, false);
        if (target != null) {
            if (mProgressTintInfo.mHasProgressBackgroundTint) {
                target.setTintList(mProgressTintInfo.mProgressBackgroundTintList);
            }
            if (mProgressTintInfo.mHasProgressBackgroundTintMode) {
                target.setTintMode(mProgressTintInfo.mProgressBackgroundTintMode);
            }
        }
    }
}
Body of Second Method:
{
    if (mProgressTintInfo.mHasProgressBackgroundTint || mProgressTintInfo.mHasProgressBackgroundTintMode) {
        final Drawable target = getTintTarget(R.id.background, false);
        if (target != null) {
            if (mProgressTintInfo.mHasProgressBackgroundTint) {
                target.setTintList(mProgressTintInfo.mProgressBackgroundTintList);
            }
            if (mProgressTintInfo.mHasProgressBackgroundTintMode) {
                target.setTintMode(mProgressTintInfo.mProgressBackgroundTintMode);
            }
            // stateful before applying the tint, so let's try again.
            if (target.isStateful()) {
                target.setState(getDrawableState());
            }
        }
    }
}
------------------------
Find a silently evolved API code:android.widget.SearchView.getInputType:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the input type set on the query text field.
 * @return the input type
 *
 * @attr ref android.R.styleable#SearchView_inputType
 */

Body of Frist Method:
{
    return mQueryTextView.getInputType();
}
Body of Second Method:
{
    return mSearchSrcTextView.getInputType();
}
------------------------
Find a silently evolved API code:android.media.AudioService.sendMasterVolumeUpdate:COMMENT
Method Modifier: private     hidden      
Comment:// UI update and Broadcast Intent

Body of Frist Method:
{
    mVolumeController.postMasterVolumeChanged(flags);
    Intent intent = new Intent(AudioManager.MASTER_VOLUME_CHANGED_ACTION);
    intent.putExtra(AudioManager.EXTRA_PREV_MASTER_VOLUME_VALUE, oldVolume);
    intent.putExtra(AudioManager.EXTRA_MASTER_VOLUME_VALUE, newVolume);
    sendBroadcastToAll(intent);
}
Body of Second Method:
{
    mVolumeController.postMasterVolumeChanged(updateFlagsForSystemAudio(flags));
    Intent intent = new Intent(AudioManager.MASTER_VOLUME_CHANGED_ACTION);
    intent.putExtra(AudioManager.EXTRA_PREV_MASTER_VOLUME_VALUE, oldVolume);
    intent.putExtra(AudioManager.EXTRA_MASTER_VOLUME_VALUE, newVolume);
    sendBroadcastToAll(intent);
}
------------------------
Find a silently evolved API code:android.graphics.drawable.RotateDrawable.setPivotY:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the Y position around which the drawable is rotated.
 *
 * @param pivotY Y position around which to rotate. If the Y pivot is
 * relative, the position represents a fraction of the drawable
 * height. Otherwise, the position represents an absolute value
 * in pixels.
 *
 * @see #getPivotY()
 * @attr ref android.R.styleable#RotateDrawable_pivotY
 */

Body of Frist Method:
{
    if (mState.mPivotY == pivotY) {
        mState.mPivotY = pivotY;
        invalidateSelf();
    }
}
Body of Second Method:
{
    if (mState.mPivotY != pivotY) {
        mState.mPivotY = pivotY;
        invalidateSelf();
    }
}
------------------------
Find a silently evolved API code:android.graphics.drawable.RotateDrawable.setPivotX:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the X position around which the drawable is rotated.
 *
 * @param pivotX X position around which to rotate. If the X pivot is
 * relative, the position represents a fraction of the drawable
 * width. Otherwise, the position represents an absolute value in
 * pixels.
 *
 * @see #setPivotXRelative(boolean)
 * @attr ref android.R.styleable#RotateDrawable_pivotX
 */

Body of Frist Method:
{
    if (mState.mPivotX == pivotX) {
        mState.mPivotX = pivotX;
        invalidateSelf();
    }
}
Body of Second Method:
{
    if (mState.mPivotX != pivotX) {
        mState.mPivotX = pivotX;
        invalidateSelf();
    }
}
------------------------
Find a silently evolved API code:android.webkit.WebHistoryItem.getUrl:COMMENT
<android.webkit.WebHistoryItem: String getUrl()>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Return the url of this history item. The url is the base url of this
 * history item. See getTargetUrl() for the url that is the actual target of
 * this history item.
 * @return The base url of this history item.
 * Note: The VM ensures 32-bit atomic read/write operations so we don't have
 * to synchronize this method.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.widget.ProgressBar.applyPrimaryProgressTint:COMMENT
Method Modifier: private     
Comment:/**
 * Should only be called if we've already verified that mProgressDrawable
 * and mProgressTintInfo are non-null.
 */

Body of Frist Method:
{
    if (mProgressTintInfo.mHasProgressTint || mProgressTintInfo.mHasProgressTintMode) {
        final Drawable target = getTintTarget(R.id.progress, true);
        if (target != null) {
            if (mProgressTintInfo.mHasProgressTint) {
                target.setTintList(mProgressTintInfo.mProgressTintList);
            }
            if (mProgressTintInfo.mHasProgressTintMode) {
                target.setTintMode(mProgressTintInfo.mProgressTintMode);
            }
        }
    }
}
Body of Second Method:
{
    if (mProgressTintInfo.mHasProgressTint || mProgressTintInfo.mHasProgressTintMode) {
        final Drawable target = getTintTarget(R.id.progress, true);
        if (target != null) {
            if (mProgressTintInfo.mHasProgressTint) {
                target.setTintList(mProgressTintInfo.mProgressTintList);
            }
            if (mProgressTintInfo.mHasProgressTintMode) {
                target.setTintMode(mProgressTintInfo.mProgressTintMode);
            }
            // stateful before applying the tint, so let's try again.
            if (target.isStateful()) {
                target.setState(getDrawableState());
            }
        }
    }
}
------------------------
Find a silently evolved API code:android.webkit.WebSettings.setDomStorageEnabled:COMMENT
<android.webkit.WebSettings: void setDomStorageEnabled(boolean)>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Sets whether the DOM storage API is enabled. The default value is false.
 *
 * @param flag true if the WebView should use the DOM storage API
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.graphics.drawable.Ripple.exit:COMMENT
Method Modifier: public      
Comment:/**
 * Starts the exit animation.
 */

Body of Frist Method:
{
    cancel();
    final float radius = MathUtils.lerp(0, mOuterRadius, mTweenRadius);
    final float remaining;
    if (mAnimRadius != null && mAnimRadius.isRunning()) {
        remaining = mOuterRadius - radius;
    } else {
        remaining = mOuterRadius;
    }
    final int radiusDuration = (int) (1000 * Math.sqrt(remaining / (WAVE_TOUCH_UP_ACCELERATION + WAVE_TOUCH_DOWN_ACCELERATION) * mDensity) + 0.5);
    final int opacityDuration = (int) (1000 * mOpacity / WAVE_OPACITY_DECAY_VELOCITY + 0.5f);
    if (mCanUseHardware) {
        exitHardware(radiusDuration, opacityDuration);
    } else {
        exitSoftware(radiusDuration, opacityDuration);
    }
}
Body of Second Method:
{
    final float radius = MathUtils.lerp(0, mOuterRadius, mTweenRadius);
    final float remaining;
    if (mAnimRadius != null && mAnimRadius.isRunning()) {
        remaining = mOuterRadius - radius;
    } else {
        remaining = mOuterRadius;
    }
    cancel();
    final int radiusDuration = (int) (1000 * Math.sqrt(remaining / (WAVE_TOUCH_UP_ACCELERATION + WAVE_TOUCH_DOWN_ACCELERATION) * mDensity) + 0.5);
    final int opacityDuration = (int) (1000 * mOpacity / WAVE_OPACITY_DECAY_VELOCITY + 0.5f);
    if (mCanUseHardware) {
        createPendingHardwareExit(radiusDuration, opacityDuration);
    } else {
        exitSoftware(radiusDuration, opacityDuration);
    }
}
------------------------
Find a silently evolved API code:android.media.AudioService.getStreamVolume:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @see AudioManager#getStreamVolume(int)
 */

Body of Frist Method:
{
    ensureValidStreamType(streamType);
    int device = getDeviceForStream(streamType);
    int index = mStreamStates[streamType].getIndex(device);
    // by convention getStreamVolume() returns 0 when a stream is muted.
    if (mStreamStates[streamType].isMuted()) {
        index = 0;
    }
    if (index != 0 && (mStreamVolumeAlias[streamType] == AudioSystem.STREAM_MUSIC) && (device & mFixedVolumeDevices) != 0) {
        index = mStreamStates[streamType].getMaxIndex();
    }
    return (index + 5) / 10;
}
Body of Second Method:
{
    ensureValidStreamType(streamType);
    int device = getDeviceForStream(streamType);
    synchronized (VolumeStreamState.class) {
        int index = mStreamStates[streamType].getIndex(device);
        // by convention getStreamVolume() returns 0 when a stream is muted.
        if (mStreamStates[streamType].isMuted_syncVSS()) {
            index = 0;
        }
        if (index != 0 && (mStreamVolumeAlias[streamType] == AudioSystem.STREAM_MUSIC) && (device & mFixedVolumeDevices) != 0) {
            index = mStreamStates[streamType].getMaxIndex();
        }
        return (index + 5) / 10;
    }
}
------------------------
Find a silently evolved API code:android.webkit.WebView.saveState:COMMENT
Method Modifier: public      
Comment:/**
 * Saves the state of this WebView used in
 * {@link android.app.Activity#onSaveInstanceState}. Please note that this
 * method no longer stores the display data for this WebView. The previous
 * behavior could potentially leak files if {@link #restoreState} was never
 * called.
 *
 * @param outState the Bundle to store this WebView's state
 * @return the same copy of the back/forward list used to save the state. If
 * saveState fails, the returned list will be null.
 */

Body of Frist Method:
{
    checkThread();
    if (DebugFlags.TRACE_API)
        Log.d(LOGTAG, "saveState");
    return mProvider.saveState(outState);
}
Body of Second Method:
{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, "saveState");
    return mProvider.saveState(outState);
}
------------------------
Find a silently evolved API code:android.webkit.WebSettings.setJavaScriptEnabled:COMMENT
<android.webkit.WebSettings: void setJavaScriptEnabled(boolean)>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Tells the WebView to enable JavaScript execution.
 * <b>The default is false.</b>
 *
 * @param flag true if the WebView should execute JavaScript
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.webkit.WebIconDatabase.open:COMMENT
<android.webkit.WebIconDatabase: void open(String)>
public      deprecated  ->public      abstract    deprecated  
Method Modifier: public      abstract    deprecated  
Method Modifier: Yes         No          Yes         
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * Open a the icon database and store the icons in the given path.
 * @param path The directory path where the icon database will be stored.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.media.AudioManager.handleKeyUp:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    int keyCode = event.getKeyCode();
    switch(keyCode) {
        case KeyEvent.KEYCODE_VOLUME_UP:
        case KeyEvent.KEYCODE_VOLUME_DOWN:
            /*
                 * Play a sound. This is done on key up since we don't want the
                 * sound to play when a user holds down volume down to mute.
                 */
            if (mUseVolumeKeySounds) {
                if (mUseMasterVolume) {
                    adjustMasterVolume(ADJUST_SAME, FLAG_PLAY_SOUND);
                } else {
                    int flags = FLAG_PLAY_SOUND;
                    adjustSuggestedStreamVolume(ADJUST_SAME, stream, flags);
                }
            }
            mVolumeKeyUpTime = SystemClock.uptimeMillis();
            break;
    }
}
Body of Second Method:
{
    int keyCode = event.getKeyCode();
    switch(keyCode) {
        case KeyEvent.KEYCODE_VOLUME_UP:
        case KeyEvent.KEYCODE_VOLUME_DOWN:
            /*
                 * Play a sound. This is done on key up since we don't want the
                 * sound to play when a user holds down volume down to mute.
                 */
            if (mUseVolumeKeySounds) {
                if (mUseMasterVolume) {
                    adjustMasterVolume(ADJUST_SAME, FLAG_PLAY_SOUND);
                } else {
                    int flags = FLAG_PLAY_SOUND;
                    adjustSuggestedStreamVolume(ADJUST_SAME, stream, flags);
                }
            }
            mVolumeKeyUpTime = SystemClock.uptimeMillis();
            break;
        case KeyEvent.KEYCODE_VOLUME_MUTE:
            MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(event, false);
            break;
    }
}
------------------------
Find a silently evolved API code:android.webkit.WebSettings.getNavDump:COMMENT
<android.webkit.WebSettings: boolean getNavDump()>
public      hidden      deprecated  ->public      abstract    hidden      deprecated  
Method Modifier: public      abstract    hidden      deprecated  
Method Modifier: Yes         No          Yes         Yes         
Method Updated:  Yes         Yes         Yes         Yes         
Comment:/**
 * Gets whether dumping the navigation cache is enabled.
 *
 * @return whether dumping the navigation cache is enabled
 * @see #setNavDump
 * @deprecated This method is now obsolete.
 * @hide Since API level {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR1}
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.app.SharedElementCallback.onCaptureSharedElementSnapshot:COMMENT
Method Modifier: public      
Comment:/**
 * Creates a snapshot of a shared element to be used by the remote Activity and reconstituted
 * with {@link #onCreateSnapshotView(android.content.Context, android.os.Parcelable)}. A
 * null return value will mean that the remote Activity will have a null snapshot View in
 * {@link #onSharedElementStart(java.util.List, java.util.List, java.util.List)} and
 * {@link #onSharedElementEnd(java.util.List, java.util.List, java.util.List)}.
 *
 * <p>This is not called for Fragment Transitions.</p>
 *
 * @param sharedElement The shared element View to create a snapshot for.
 * @param viewToGlobalMatrix A matrix containing a transform from the view to the screen
 * coordinates.
 * @param screenBounds The bounds of shared element in screen coordinate space. This is
 * the bounds of the view with the viewToGlobalMatrix applied.
 * @return A snapshot to send to the remote Activity to be reconstituted with
 * {@link #onCreateSnapshotView(android.content.Context, android.os.Parcelable)} and passed
 * into {@link #onSharedElementStart(java.util.List, java.util.List, java.util.List)} and
 * {@link #onSharedElementEnd(java.util.List, java.util.List, java.util.List)}.
 */

Body of Frist Method:
{
    if (mTempMatrix == null) {
        mTempMatrix = new Matrix(viewToGlobalMatrix);
    } else {
        mTempMatrix.set(viewToGlobalMatrix);
    }
    return TransitionUtils.createViewBitmap(sharedElement, mTempMatrix, screenBounds);
}
Body of Second Method:
{
    if (sharedElement instanceof ImageView) {
        ImageView imageView = ((ImageView) sharedElement);
        Drawable d = imageView.getDrawable();
        Drawable bg = imageView.getBackground();
        if (d != null && (bg == null || bg.getAlpha() == 0)) {
            Bitmap bitmap = TransitionUtils.createDrawableBitmap(d);
            if (bitmap != null) {
                Bundle bundle = new Bundle();
                bundle.putParcelable(BUNDLE_SNAPSHOT_BITMAP, bitmap);
                bundle.putString(BUNDLE_SNAPSHOT_IMAGE_SCALETYPE, imageView.getScaleType().toString());
                if (imageView.getScaleType() == ScaleType.MATRIX) {
                    Matrix matrix = imageView.getImageMatrix();
                    float[] values = new float[9];
                    matrix.getValues(values);
                    bundle.putFloatArray(BUNDLE_SNAPSHOT_IMAGE_MATRIX, values);
                }
                return bundle;
            }
        }
    }
    if (mTempMatrix == null) {
        mTempMatrix = new Matrix(viewToGlobalMatrix);
    } else {
        mTempMatrix.set(viewToGlobalMatrix);
    }
    return TransitionUtils.createViewBitmap(sharedElement, mTempMatrix, screenBounds);
}
------------------------
Find a silently evolved API code:android.webkit.WebSettings.setNeedInitialFocus:COMMENT
<android.webkit.WebSettings: void setNeedInitialFocus(boolean)>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Tells the WebView whether it needs to set a node to have focus when
 * {@link WebView#requestFocus(int, android.graphics.Rect)} is called. The
 * default value is true.
 *
 * @param flag whether the WebView needs to set a node
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.media.AudioService.sendVolumeUpdate:COMMENT
Method Modifier: private     hidden      
Comment:// UI update and Broadcast Intent

Body of Frist Method:
{
    if (!isPlatformVoice() && (streamType == AudioSystem.STREAM_RING)) {
        streamType = AudioSystem.STREAM_NOTIFICATION;
    }
    // only when TV receives volume notification from Audio Receiver.
    if (mHdmiTvClient != null && streamType == AudioSystem.STREAM_MUSIC) {
        synchronized (mHdmiTvClient) {
            if (mHdmiSystemAudioSupported && ((flags & AudioManager.FLAG_HDMI_SYSTEM_AUDIO_VOLUME) == 0)) {
                flags &= ~AudioManager.FLAG_SHOW_UI;
            }
        }
    }
    mVolumeController.postVolumeChanged(streamType, flags);
    if ((flags & AudioManager.FLAG_FIXED_VOLUME) == 0) {
        oldIndex = (oldIndex + 5) / 10;
        index = (index + 5) / 10;
        Intent intent = new Intent(AudioManager.VOLUME_CHANGED_ACTION);
        intent.putExtra(AudioManager.EXTRA_VOLUME_STREAM_TYPE, streamType);
        intent.putExtra(AudioManager.EXTRA_VOLUME_STREAM_VALUE, index);
        intent.putExtra(AudioManager.EXTRA_PREV_VOLUME_STREAM_VALUE, oldIndex);
        sendBroadcastToAll(intent);
    }
}
Body of Second Method:
{
    if (!isPlatformVoice() && (streamType == AudioSystem.STREAM_RING)) {
        streamType = AudioSystem.STREAM_NOTIFICATION;
    }
    if (streamType == AudioSystem.STREAM_MUSIC) {
        flags = updateFlagsForSystemAudio(flags);
    }
    mVolumeController.postVolumeChanged(streamType, flags);
    if ((flags & AudioManager.FLAG_FIXED_VOLUME) == 0) {
        oldIndex = (oldIndex + 5) / 10;
        index = (index + 5) / 10;
        Intent intent = new Intent(AudioManager.VOLUME_CHANGED_ACTION);
        intent.putExtra(AudioManager.EXTRA_VOLUME_STREAM_TYPE, streamType);
        intent.putExtra(AudioManager.EXTRA_VOLUME_STREAM_VALUE, index);
        intent.putExtra(AudioManager.EXTRA_PREV_VOLUME_STREAM_VALUE, oldIndex);
        sendBroadcastToAll(intent);
    }
}
------------------------
Find a silently evolved API code:android.media.AudioManager.requestAudioFocus:COMMENT
Method Modifier: public      
Comment:/**
 * Request audio focus.
 * Send a request to obtain the audio focus
 * @param l the listener to be notified of audio focus changes
 * @param streamType the main audio stream type affected by the focus request
 * @param durationHint use {@link #AUDIOFOCUS_GAIN_TRANSIENT} to indicate this focus request
 * is temporary, and focus will be abandonned shortly. Examples of transient requests are
 * for the playback of driving directions, or notifications sounds.
 * Use {@link #AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK} to indicate also that it's ok for
 * the previous focus owner to keep playing if it ducks its audio output.
 * Alternatively use {@link #AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE} for a temporary request
 * that benefits from the system not playing disruptive sounds like notifications, for
 * usecases such as voice memo recording, or speech recognition.
 * Use {@link #AUDIOFOCUS_GAIN} for a focus request of unknown duration such
 * as the playback of a song or a video.
 * @return {@link #AUDIOFOCUS_REQUEST_FAILED} or {@link #AUDIOFOCUS_REQUEST_GRANTED}
 */

Body of Frist Method:
{
    int status = AUDIOFOCUS_REQUEST_FAILED;
    if ((durationHint < AUDIOFOCUS_GAIN) || (durationHint > AUDIOFOCUS_GAIN_TRANSIENT_EXCLUSIVE)) {
        Log.e(TAG, "Invalid duration hint, audio focus request denied");
        return status;
    }
    registerAudioFocusListener(l);
    // TODO protect request by permission check?
    IAudioService service = getService();
    try {
        status = service.requestAudioFocus(streamType, durationHint, mICallBack, mAudioFocusDispatcher, getIdForAudioFocusListener(l), mContext.getOpPackageName());
    } catch (RemoteException e) {
        Log.e(TAG, "Can't call requestAudioFocus() on AudioService due to " + e);
    }
    return status;
}
Body of Second Method:
{
    int status = AUDIOFOCUS_REQUEST_FAILED;
    try {
        // status is guaranteed to be either AUDIOFOCUS_REQUEST_FAILED or
        // AUDIOFOCUS_REQUEST_GRANTED as focus is requested without the
        // AUDIOFOCUS_FLAG_DELAY_OK flag
        status = requestAudioFocus(l, new AudioAttributes.Builder().setInternalLegacyStreamType(streamType).build(), durationHint, 0);
    } catch (IllegalArgumentException e) {
        Log.e(TAG, "Audio focus request denied due to ", e);
    }
    return status;
}
------------------------
Find a silently evolved API code:android.widget.Switch.stopDrag:COMMENT
Method Modifier: private     
Comment:/**
 * Called from onTouchEvent to end a drag operation.
 *
 * @param ev Event that triggered the end of drag mode - ACTION_UP or ACTION_CANCEL
 */

Body of Frist Method:
{
    mTouchMode = TOUCH_MODE_IDLE;
    // Commit the change if the event is up and not canceled and the switch
    // has not been disabled during the drag.
    final boolean commitChange = ev.getAction() == MotionEvent.ACTION_UP && isEnabled();
    final boolean newState;
    if (commitChange) {
        mVelocityTracker.computeCurrentVelocity(1000);
        final float xvel = mVelocityTracker.getXVelocity();
        if (Math.abs(xvel) > mMinFlingVelocity) {
            newState = isLayoutRtl() ? (xvel < 0) : (xvel > 0);
        } else {
            newState = getTargetCheckedState();
        }
    } else {
        newState = isChecked();
    }
    setChecked(newState);
    cancelSuperTouch(ev);
}
Body of Second Method:
{
    mTouchMode = TOUCH_MODE_IDLE;
    // Commit the change if the event is up and not canceled and the switch
    // has not been disabled during the drag.
    final boolean commitChange = ev.getAction() == MotionEvent.ACTION_UP && isEnabled();
    final boolean oldState = isChecked();
    final boolean newState;
    if (commitChange) {
        mVelocityTracker.computeCurrentVelocity(1000);
        final float xvel = mVelocityTracker.getXVelocity();
        if (Math.abs(xvel) > mMinFlingVelocity) {
            newState = isLayoutRtl() ? (xvel < 0) : (xvel > 0);
        } else {
            newState = getTargetCheckedState();
        }
    } else {
        newState = oldState;
    }
    if (newState != oldState) {
        playSoundEffect(SoundEffectConstants.CLICK);
        setChecked(newState);
    }
    cancelSuperTouch(ev);
}
------------------------
Find a silently evolved API code:android.preference.ListPreference.getSummary:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the summary of this ListPreference. If the summary
 * has a {@linkplain java.lang.String#format String formatting}
 * marker in it (i.e. "%s" or "%1$s"), then the current entry
 * value will be substituted in its place.
 *
 * @return the summary with appropriate string substitution
 */

Body of Frist Method:
{
    final CharSequence entry = getEntry();
    if (mSummary == null || entry == null) {
        return super.getSummary();
    } else {
        return String.format(mSummary, entry);
    }
}
Body of Second Method:
{
    final CharSequence entry = getEntry();
    if (mSummary == null) {
        return super.getSummary();
    } else {
        return String.format(mSummary, entry == null ? "" : entry);
    }
}
------------------------
Find a silently evolved API code:android.widget.PopupWindow.setBackgroundDrawable:COMMENT
Method Modifier: public      
Comment:/**
 * Specifies the background drawable for this popup window. The background
 * can be set to {@code null}.
 *
 * @param background the popup's background
 * @see #getBackground()
 * @attr ref android.R.styleable#PopupWindow_popupBackground
 */

Body of Frist Method:
{
    mBackground = background;
}
Body of Second Method:
{
    mBackground = background;
    // at least one other drawable, intended for the 'below-anchor state'.
    if (mBackground instanceof StateListDrawable) {
        StateListDrawable stateList = (StateListDrawable) mBackground;
        // Find the above-anchor view - this one's easy, it should be labeled as such.
        int aboveAnchorStateIndex = stateList.getStateDrawableIndex(ABOVE_ANCHOR_STATE_SET);
        // Now, for the below-anchor view, look for any other drawable specified in the
        // StateListDrawable which is not for the above-anchor state and use that.
        int count = stateList.getStateCount();
        int belowAnchorStateIndex = -1;
        for (int i = 0; i < count; i++) {
            if (i != aboveAnchorStateIndex) {
                belowAnchorStateIndex = i;
                break;
            }
        }
        // to null so that we'll just use refreshDrawableState.
        if (aboveAnchorStateIndex != -1 && belowAnchorStateIndex != -1) {
            mAboveAnchorBackgroundDrawable = stateList.getStateDrawable(aboveAnchorStateIndex);
            mBelowAnchorBackgroundDrawable = stateList.getStateDrawable(belowAnchorStateIndex);
        } else {
            mBelowAnchorBackgroundDrawable = null;
            mAboveAnchorBackgroundDrawable = null;
        }
    }
}
------------------------
Find a silently evolved API code:android.media.AudioTrack.setLoopPoints:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the loop points and the loop count. The loop can be infinite.
 * Similarly to setPlaybackHeadPosition,
 * the track must be stopped or paused for the loop points to be changed,
 * and must use the {@link #MODE_STATIC} mode.
 * @param startInFrames loop start marker expressed in frames
 * Zero corresponds to start of buffer.
 * The start marker must not be greater than or equal to the buffer size in frames, or negative.
 * @param endInFrames loop end marker expressed in frames
 * The total buffer size in frames corresponds to end of buffer.
 * The end marker must not be greater than the buffer size in frames.
 * For looping, the end marker must not be less than or equal to the start marker,
 * but to disable looping
 * it is permitted for start marker, end marker, and loop count to all be 0.
 * @param loopCount the number of times the loop is looped.
 * A value of -1 means infinite looping, and 0 disables looping.
 * @return error code or success, see {@link #SUCCESS}, {@link #ERROR_BAD_VALUE},
 * {@link #ERROR_INVALID_OPERATION}
 */

Body of Frist Method:
{
    if (mDataLoadMode == MODE_STREAM || mState != STATE_INITIALIZED || getPlayState() == PLAYSTATE_PLAYING) {
        return ERROR_INVALID_OPERATION;
    }
    if (loopCount == 0) {
        // explicitly allowed as an exception to the loop region range check
        ;
    } else if (!(0 <= startInFrames && startInFrames < mNativeBufferSizeInFrames && startInFrames < endInFrames && endInFrames <= mNativeBufferSizeInFrames)) {
        return ERROR_BAD_VALUE;
    }
    return native_set_loop(startInFrames, endInFrames, loopCount);
}
Body of Second Method:
{
    if (mDataLoadMode == MODE_STREAM || mState == STATE_UNINITIALIZED || getPlayState() == PLAYSTATE_PLAYING) {
        return ERROR_INVALID_OPERATION;
    }
    if (loopCount == 0) {
        // explicitly allowed as an exception to the loop region range check
        ;
    } else if (!(0 <= startInFrames && startInFrames < mNativeBufferSizeInFrames && startInFrames < endInFrames && endInFrames <= mNativeBufferSizeInFrames)) {
        return ERROR_BAD_VALUE;
    }
    return native_set_loop(startInFrames, endInFrames, loopCount);
}
------------------------
Find a silently evolved API code:android.webkit.WebViewDatabase.hasFormData:COMMENT
<android.webkit.WebViewDatabase: boolean hasFormData()>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Gets whether there is any saved data for web forms.
 *
 * @return whether there is any saved data for web forms
 * @see #clearFormData
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.webkit.WebSettings.setFantasyFontFamily:COMMENT
<android.webkit.WebSettings: void setFantasyFontFamily(String)>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Sets the fantasy font family name. The default is "fantasy".
 *
 * @param font a font family name
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.media.AudioService.sendMasterMuteUpdate:COMMENT
Method Modifier: private     hidden      
Comment:// UI update and Broadcast Intent

Body of Frist Method:
{
    mVolumeController.postMasterMuteChanged(flags);
    broadcastMasterMuteStatus(muted);
}
Body of Second Method:
{
    mVolumeController.postMasterMuteChanged(updateFlagsForSystemAudio(flags));
    broadcastMasterMuteStatus(muted);
}
------------------------
Find a silently evolved API code:android.view.ViewGroup.removeView:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 *
 * <p><strong>Note:</strong> do not invoke this method from
 * {@link #draw(android.graphics.Canvas)}, {@link #onDraw(android.graphics.Canvas)},
 * {@link #dispatchDraw(android.graphics.Canvas)} or any related method.</p>
 */

Body of Frist Method:
{
    removeViewInternal(view);
    requestLayout();
    invalidate(true);
}
Body of Second Method:
{
    if (removeViewInternal(view)) {
        requestLayout();
        invalidate(true);
    }
}
------------------------
Find a silently evolved API code:android.webkit.CookieManager.removeSessionCookies:COMMENT
<android.webkit.CookieManager: void removeSessionCookies(ValueCallback<Boolean>)>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Removes all session cookies, which are cookies without an expiration
 * date.
 * <p>
 * This method is asynchronous.
 * If a {@link ValueCallback} is provided,
 * {@link ValueCallback#onReceiveValue(T) onReceiveValue()} will be called on the current
 * thread's {@link android.os.Looper} once the operation is complete.
 * The value provided to the callback indicates whether any cookies were removed.
 * You can pass {@code null} as the callback if you don't need to know when the operation
 * completes or whether any cookie were removed, and in this case it is safe to call the
 * method from a thread without a Looper.
 * @param callback a callback which is executed when the session cookies have been removed
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.telephony.SubscriptionManager.getPhoneId:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (!isValidSubId(subId)) {
        logd("[getPhoneId]- fail");
        return INVALID_PHONE_ID;
    }
    int result = INVALID_PHONE_ID;
    try {
        ISub iSub = ISub.Stub.asInterface(ServiceManager.getService("isub"));
        if (iSub != null) {
            result = iSub.getPhoneId(subId);
        }
    } catch (RemoteException ex) {
    // ignore it
    }
    if (VDBG)
        logd("[getPhoneId]- phoneId=" + result);
    return result;
}
Body of Second Method:
{
    if (!isValidSubscriptionId(subId)) {
        logd("[getPhoneId]- fail");
        return INVALID_PHONE_INDEX;
    }
    int result = INVALID_PHONE_INDEX;
    try {
        ISub iSub = ISub.Stub.asInterface(ServiceManager.getService("isub"));
        if (iSub != null) {
            result = iSub.getPhoneId(subId);
        }
    } catch (RemoteException ex) {
    // ignore it
    }
    if (VDBG)
        logd("[getPhoneId]- phoneId=" + result);
    return result;
}
------------------------
Find a silently evolved API code:android.animation.ValueAnimator.endAnimation:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * Called internally to end an animation by removing it from the animations list. Must be
 * called on the UI thread.
 * @hide
 */

Body of Frist Method:
{
    handler.mAnimations.remove(this);
    handler.mPendingAnimations.remove(this);
    handler.mDelayedAnims.remove(this);
    mPlayingState = STOPPED;
    mPaused = false;
    if ((mStarted || mRunning) && mListeners != null) {
        if (!mRunning) {
            // If it's not yet running, then start listeners weren't called. Call them now.
            notifyStartListeners();
        }
        ArrayList<AnimatorListener> tmpListeners = (ArrayList<AnimatorListener>) mListeners.clone();
        int numListeners = tmpListeners.size();
        for (int i = 0; i < numListeners; ++i) {
            tmpListeners.get(i).onAnimationEnd(this);
        }
    }
    mRunning = false;
    mStarted = false;
    mStartListenersCalled = false;
    mPlayingBackwards = false;
    if (Trace.isTagEnabled(Trace.TRACE_TAG_VIEW)) {
        Trace.asyncTraceEnd(Trace.TRACE_TAG_VIEW, getNameForTrace(), System.identityHashCode(this));
    }
}
Body of Second Method:
{
    handler.mAnimations.remove(this);
    handler.mPendingAnimations.remove(this);
    handler.mDelayedAnims.remove(this);
    mPlayingState = STOPPED;
    mPaused = false;
    if ((mStarted || mRunning) && mListeners != null) {
        if (!mRunning) {
            // If it's not yet running, then start listeners weren't called. Call them now.
            notifyStartListeners();
        }
        ArrayList<AnimatorListener> tmpListeners = (ArrayList<AnimatorListener>) mListeners.clone();
        int numListeners = tmpListeners.size();
        for (int i = 0; i < numListeners; ++i) {
            tmpListeners.get(i).onAnimationEnd(this);
        }
    }
    mRunning = false;
    mStarted = false;
    mStartListenersCalled = false;
    mPlayingBackwards = false;
    mReversing = false;
    mCurrentIteration = 0;
    if (Trace.isTagEnabled(Trace.TRACE_TAG_VIEW)) {
        Trace.asyncTraceEnd(Trace.TRACE_TAG_VIEW, getNameForTrace(), System.identityHashCode(this));
    }
}
------------------------
Find a silently evolved API code:android.content.Intent.createChooser:COMMENT
Method Modifier: public      static      
Comment:/**
 * Convenience function for creating a {@link #ACTION_CHOOSER} Intent.
 *
 * <p>Builds a new {@link #ACTION_CHOOSER} Intent that wraps the given
 * target intent, also optionally supplying a title.  If the target
 * intent has specified {@link #FLAG_GRANT_READ_URI_PERMISSION} or
 * {@link #FLAG_GRANT_WRITE_URI_PERMISSION}, then these flags will also be
 * set in the returned chooser intent, with its ClipData set appropriately:
 * either a direct reflection of {@link #getClipData()} if that is non-null,
 * or a new ClipData built from {@link #getData()}.
 *
 * @param target The Intent that the user will be selecting an activity
 * to perform.
 * @param title Optional title that will be displayed in the chooser.
 * @return Return a new Intent object that you can hand to
 * {@link Context#startActivity(Intent) Context.startActivity()} and
 * related methods.
 */

Body of Frist Method:
{
    Intent intent = new Intent(ACTION_CHOOSER);
    intent.putExtra(EXTRA_INTENT, target);
    if (title != null) {
        intent.putExtra(EXTRA_TITLE, title);
    }
    // Migrate any clip data and flags from target.
    int permFlags = target.getFlags() & (FLAG_GRANT_READ_URI_PERMISSION | FLAG_GRANT_WRITE_URI_PERMISSION | FLAG_GRANT_PERSISTABLE_URI_PERMISSION | FLAG_GRANT_PREFIX_URI_PERMISSION);
    if (permFlags != 0) {
        ClipData targetClipData = target.getClipData();
        if (targetClipData == null && target.getData() != null) {
            ClipData.Item item = new ClipData.Item(target.getData());
            String[] mimeTypes;
            if (target.getType() != null) {
                mimeTypes = new String[] { target.getType() };
            } else {
                mimeTypes = new String[] {};
            }
            targetClipData = new ClipData(null, mimeTypes, item);
        }
        if (targetClipData != null) {
            intent.setClipData(targetClipData);
            intent.addFlags(permFlags);
        }
    }
    return intent;
}
Body of Second Method:
{
    return createChooser(target, title, null);
}
------------------------
Find a silently evolved API code:android.media.AudioAttributes.Builder.setUsage:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the attribute describing what is the intended use of the the audio signal,
 * such as alarm or ringtone.
 * @param usage one of {@link AudioAttributes#USAGE_UNKNOWN},
 * {@link AudioAttributes#USAGE_MEDIA},
 * {@link AudioAttributes#USAGE_VOICE_COMMUNICATION},
 * {@link AudioAttributes#USAGE_VOICE_COMMUNICATION_SIGNALLING},
 * {@link AudioAttributes#USAGE_ALARM}, {@link AudioAttributes#USAGE_NOTIFICATION},
 * {@link AudioAttributes#USAGE_NOTIFICATION_RINGTONE},
 * {@link AudioAttributes#USAGE_NOTIFICATION_COMMUNICATION_REQUEST},
 * {@link AudioAttributes#USAGE_NOTIFICATION_COMMUNICATION_INSTANT},
 * {@link AudioAttributes#USAGE_NOTIFICATION_COMMUNICATION_DELAYED},
 * {@link AudioAttributes#USAGE_NOTIFICATION_EVENT},
 * {@link AudioAttributes#USAGE_ASSISTANCE_ACCESSIBILITY},
 * {@link AudioAttributes#USAGE_ASSISTANCE_NAVIGATION_GUIDANCE},
 * {@link AudioAttributes#USAGE_ASSISTANCE_SONIFICATION},
 * {@link AudioAttributes#USAGE_GAME}.
 * @return the same Builder instance.
 */

Body of Frist Method:
{
    switch(usage) {
        case USAGE_UNKNOWN:
        case USAGE_MEDIA:
        case USAGE_VOICE_COMMUNICATION:
        case USAGE_VOICE_COMMUNICATION_SIGNALLING:
        case USAGE_ALARM:
        case USAGE_NOTIFICATION:
        case USAGE_NOTIFICATION_RINGTONE:
        case USAGE_NOTIFICATION_COMMUNICATION_REQUEST:
        case USAGE_NOTIFICATION_COMMUNICATION_INSTANT:
        case USAGE_NOTIFICATION_COMMUNICATION_DELAYED:
        case USAGE_NOTIFICATION_EVENT:
        case USAGE_ASSISTANCE_ACCESSIBILITY:
        case USAGE_ASSISTANCE_NAVIGATION_GUIDANCE:
        case USAGE_ASSISTANCE_SONIFICATION:
        case USAGE_GAME:
            mUsage = usage;
            break;
        default:
            mUsage = USAGE_UNKNOWN;
    }
    return this;
}
Body of Second Method:
{
    switch(usage) {
        case USAGE_UNKNOWN:
        case USAGE_MEDIA:
        case USAGE_VOICE_COMMUNICATION:
        case USAGE_VOICE_COMMUNICATION_SIGNALLING:
        case USAGE_ALARM:
        case USAGE_NOTIFICATION:
        case USAGE_NOTIFICATION_RINGTONE:
        case USAGE_NOTIFICATION_COMMUNICATION_REQUEST:
        case USAGE_NOTIFICATION_COMMUNICATION_INSTANT:
        case USAGE_NOTIFICATION_COMMUNICATION_DELAYED:
        case USAGE_NOTIFICATION_EVENT:
        case USAGE_ASSISTANCE_ACCESSIBILITY:
        case USAGE_ASSISTANCE_NAVIGATION_GUIDANCE:
        case USAGE_ASSISTANCE_SONIFICATION:
        case USAGE_GAME:
        case USAGE_VIRTUAL_SOURCE:
            mUsage = usage;
            break;
        default:
            mUsage = USAGE_UNKNOWN;
    }
    return this;
}
------------------------
Find a silently evolved API code:android.widget.DayPickerView.onInitializeAccessibilityNodeInfo:COMMENT
Method Modifier: public      
Comment:/**
 * Necessary for accessibility, to ensure we support "scrolling" forward and backward
 * in the month list.
 */

Body of Frist Method:
{
    super.onInitializeAccessibilityNodeInfo(info);
    info.addAction(AccessibilityNodeInfo.ACTION_SCROLL_FORWARD);
    info.addAction(AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD);
}
Body of Second Method:
{
    super.onInitializeAccessibilityNodeInfo(info);
    info.addAction(AccessibilityNodeInfo.AccessibilityAction.ACTION_SCROLL_FORWARD);
    info.addAction(AccessibilityNodeInfo.AccessibilityAction.ACTION_SCROLL_BACKWARD);
}
------------------------
Find a silently evolved API code:android.telephony.PhoneNumberUtils.cdmaCheckAndProcessPlusCodeForSms:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Process phone number for CDMA, converting plus code using the home network number format.
 * This is used for outgoing SMS messages.
 *
 * @param dialStr the original dial string
 * @return the converted dial string
 * @hide for internal use
 */

Body of Frist Method:
{
    if (!TextUtils.isEmpty(dialStr)) {
        if (isReallyDialable(dialStr.charAt(0)) && isNonSeparator(dialStr)) {
            String defaultIso = SystemProperties.get(PROPERTY_ICC_OPERATOR_ISO_COUNTRY, "");
            if (!TextUtils.isEmpty(defaultIso)) {
                int format = getFormatTypeFromCountryCode(defaultIso);
                return cdmaCheckAndProcessPlusCodeByNumberFormat(dialStr, format, format);
            }
        }
    }
    return dialStr;
}
Body of Second Method:
{
    if (!TextUtils.isEmpty(dialStr)) {
        if (isReallyDialable(dialStr.charAt(0)) && isNonSeparator(dialStr)) {
            String defaultIso = TelephonyManager.getDefault().getSimCountryIso();
            if (!TextUtils.isEmpty(defaultIso)) {
                int format = getFormatTypeFromCountryCode(defaultIso);
                return cdmaCheckAndProcessPlusCodeByNumberFormat(dialStr, format, format);
            }
        }
    }
    return dialStr;
}
------------------------
Find a silently evolved API code:android.webkit.WebSettings.getBlockNetworkLoads:COMMENT
<android.webkit.WebSettings: boolean getBlockNetworkLoads()>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Gets whether the WebView does not load any resources from the network.
 *
 * @return true if the WebView does not load any resources from the network
 * @see #setBlockNetworkLoads
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.media.AudioManager.abandonAudioFocus:COMMENT
Method Modifier: public      
Comment:/**
 * Abandon audio focus. Causes the previous focus owner, if any, to receive focus.
 * @param l the listener with which focus was requested.
 * @return {@link #AUDIOFOCUS_REQUEST_FAILED} or {@link #AUDIOFOCUS_REQUEST_GRANTED}
 */

Body of Frist Method:
{
    int status = AUDIOFOCUS_REQUEST_FAILED;
    unregisterAudioFocusListener(l);
    IAudioService service = getService();
    try {
        status = service.abandonAudioFocus(mAudioFocusDispatcher, getIdForAudioFocusListener(l));
    } catch (RemoteException e) {
        Log.e(TAG, "Can't call abandonAudioFocus() on AudioService due to " + e);
    }
    return status;
}
Body of Second Method:
{
    return abandonAudioFocus(l, null);
}
------------------------
Find a silently evolved API code:android.widget.TextView.shouldSpeakPasswordsForAccessibility:COMMENT
Method Modifier: private     
Comment:/**
 * @return true if the user has explicitly allowed accessibility services
 * to speak passwords.
 */

Body of Frist Method:
{
    return (Settings.Secure.getInt(mContext.getContentResolver(), Settings.Secure.ACCESSIBILITY_SPEAK_PASSWORD, 0) == 1);
}
Body of Second Method:
{
    return (Settings.Secure.getIntForUser(mContext.getContentResolver(), Settings.Secure.ACCESSIBILITY_SPEAK_PASSWORD, 0, UserHandle.USER_CURRENT_OR_SELF) == 1);
}
------------------------
Find a silently evolved API code:android.util.PathParser.PathDataNode.nodesToPath:COMMENT
Method Modifier: public      static      
Comment:/**
 * Convert an array of PathDataNode to Path.
 *
 * @param node The source array of PathDataNode.
 * @param path The target Path object.
 */

Body of Frist Method:
{
    float[] current = new float[4];
    char previousCommand = 'm';
    for (int i = 0; i < node.length; i++) {
        addCommand(path, current, previousCommand, node[i].mType, node[i].mParams);
        previousCommand = node[i].mType;
    }
}
Body of Second Method:
{
    float[] current = new float[6];
    char previousCommand = 'm';
    for (int i = 0; i < node.length; i++) {
        addCommand(path, current, previousCommand, node[i].mType, node[i].mParams);
        previousCommand = node[i].mType;
    }
}
------------------------
Find a silently evolved API code:android.widget.SearchView.onSuggestionsKey:COMMENT
Method Modifier: private     
Comment:/**
 * React to the user typing while in the suggestions list. First, check for
 * action keys. If not handled, try refocusing regular characters into the
 * EditText.
 */

Body of Frist Method:
{
    // guard against possible race conditions (late arrival after dismiss)
    if (mSearchable == null) {
        return false;
    }
    if (mSuggestionsAdapter == null) {
        return false;
    }
    if (event.getAction() == KeyEvent.ACTION_DOWN && event.hasNoModifiers()) {
        // "click")
        if (keyCode == KeyEvent.KEYCODE_ENTER || keyCode == KeyEvent.KEYCODE_SEARCH || keyCode == KeyEvent.KEYCODE_TAB) {
            int position = mQueryTextView.getListSelection();
            return onItemClicked(position, KeyEvent.KEYCODE_UNKNOWN, null);
        }
        // user to the edit view
        if (keyCode == KeyEvent.KEYCODE_DPAD_LEFT || keyCode == KeyEvent.KEYCODE_DPAD_RIGHT) {
            // give "focus" to text editor, with cursor at the beginning if
            // left key, at end if right key
            // TODO: Reverse left/right for right-to-left languages, e.g.
            // Arabic
            int selPoint = (keyCode == KeyEvent.KEYCODE_DPAD_LEFT) ? 0 : mQueryTextView.length();
            mQueryTextView.setSelection(selPoint);
            mQueryTextView.setListSelection(0);
            mQueryTextView.clearListSelection();
            mQueryTextView.ensureImeVisible(true);
            return true;
        }
        // Next, check for an "up and out" move
        if (keyCode == KeyEvent.KEYCODE_DPAD_UP && 0 == mQueryTextView.getListSelection()) {
            // let ACTV complete the move
            return false;
        }
        // Next, check for an "action key"
        SearchableInfo.ActionKeyInfo actionKey = mSearchable.findActionKey(keyCode);
        if ((actionKey != null) && ((actionKey.getSuggestActionMsg() != null) || (actionKey.getSuggestActionMsgColumn() != null))) {
            // launch suggestion using action key column
            int position = mQueryTextView.getListSelection();
            if (position != ListView.INVALID_POSITION) {
                Cursor c = mSuggestionsAdapter.getCursor();
                if (c.moveToPosition(position)) {
                    final String actionMsg = getActionKeyMessage(c, actionKey);
                    if (actionMsg != null && (actionMsg.length() > 0)) {
                        return onItemClicked(position, keyCode, actionMsg);
                    }
                }
            }
        }
    }
    return false;
}
Body of Second Method:
{
    // guard against possible race conditions (late arrival after dismiss)
    if (mSearchable == null) {
        return false;
    }
    if (mSuggestionsAdapter == null) {
        return false;
    }
    if (event.getAction() == KeyEvent.ACTION_DOWN && event.hasNoModifiers()) {
        // "click")
        if (keyCode == KeyEvent.KEYCODE_ENTER || keyCode == KeyEvent.KEYCODE_SEARCH || keyCode == KeyEvent.KEYCODE_TAB) {
            int position = mSearchSrcTextView.getListSelection();
            return onItemClicked(position, KeyEvent.KEYCODE_UNKNOWN, null);
        }
        // user to the edit view
        if (keyCode == KeyEvent.KEYCODE_DPAD_LEFT || keyCode == KeyEvent.KEYCODE_DPAD_RIGHT) {
            // give "focus" to text editor, with cursor at the beginning if
            // left key, at end if right key
            // TODO: Reverse left/right for right-to-left languages, e.g.
            // Arabic
            int selPoint = (keyCode == KeyEvent.KEYCODE_DPAD_LEFT) ? 0 : mSearchSrcTextView.length();
            mSearchSrcTextView.setSelection(selPoint);
            mSearchSrcTextView.setListSelection(0);
            mSearchSrcTextView.clearListSelection();
            mSearchSrcTextView.ensureImeVisible(true);
            return true;
        }
        // Next, check for an "up and out" move
        if (keyCode == KeyEvent.KEYCODE_DPAD_UP && 0 == mSearchSrcTextView.getListSelection()) {
            // let ACTV complete the move
            return false;
        }
        // Next, check for an "action key"
        SearchableInfo.ActionKeyInfo actionKey = mSearchable.findActionKey(keyCode);
        if ((actionKey != null) && ((actionKey.getSuggestActionMsg() != null) || (actionKey.getSuggestActionMsgColumn() != null))) {
            // launch suggestion using action key column
            int position = mSearchSrcTextView.getListSelection();
            if (position != ListView.INVALID_POSITION) {
                Cursor c = mSuggestionsAdapter.getCursor();
                if (c.moveToPosition(position)) {
                    final String actionMsg = getActionKeyMessage(c, actionKey);
                    if (actionMsg != null && (actionMsg.length() > 0)) {
                        return onItemClicked(position, keyCode, actionMsg);
                    }
                }
            }
        }
    }
    return false;
}
------------------------
Find a silently evolved API code:android.webkit.CookieManager.removeAllCookies:COMMENT
<android.webkit.CookieManager: void removeAllCookies(ValueCallback<Boolean>)>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Removes all cookies.
 * <p>
 * This method is asynchronous.
 * If a {@link ValueCallback} is provided,
 * {@link ValueCallback#onReceiveValue(T) onReceiveValue()} will be called on the current
 * thread's {@link android.os.Looper} once the operation is complete.
 * The value provided to the callback indicates whether any cookies were removed.
 * You can pass {@code null} as the callback if you don't need to know when the operation
 * completes or whether any cookies were removed, and in this case it is safe to call the
 * method from a thread without a Looper.
 * @param callback a callback which is executed when the cookies have been removed
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.animation.ValueAnimator.setCurrentPlayTime:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the position of the animation to the specified point in time. This time should
 * be between 0 and the total duration of the animation, including any repetition. If
 * the animation has not yet been started, then it will not advance forward after it is
 * set to this time; it will simply set the time to this value and perform any appropriate
 * actions based on that time. If the animation is already running, then setCurrentPlayTime()
 * will set the current playing time to this value and continue playing from that point.
 *
 * @param playTime The time, in milliseconds, to which the animation is advanced or rewound.
 */

Body of Frist Method:
{
    initAnimation();
    long currentTime = AnimationUtils.currentAnimationTimeMillis();
    if (mPlayingState != RUNNING) {
        mSeekTime = playTime;
        mPlayingState = SEEKED;
    }
    mStartTime = currentTime - playTime;
    doAnimationFrame(currentTime);
}
Body of Second Method:
{
    float fraction = mUnscaledDuration > 0 ? (float) playTime / mUnscaledDuration : 1;
    setCurrentFraction(fraction);
}
------------------------
Find a silently evolved API code:android.webkit.WebSettings.setSaveFormData:COMMENT
<android.webkit.WebSettings: void setSaveFormData(boolean)>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Sets whether the WebView should save form data. The default is true.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.webkit.WebSettings.getAllowFileAccess:COMMENT
<android.webkit.WebSettings: boolean getAllowFileAccess()>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Gets whether this WebView supports file access.
 *
 * @see #setAllowFileAccess
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.widget.AbsListView.trackMotionScroll:COMMENT
Method Modifier: default     
Comment:/**
 * Track a motion scroll
 *
 * @param deltaY Amount to offset mMotionView. This is the accumulated delta since the motion
 * began. Positive numbers mean the user's finger is moving down the screen.
 * @param incrementalDeltaY Change in deltaY from the previous event.
 * @return true if we're already at the beginning/end of the list and have nothing to do.
 */

Body of Frist Method:
{
    final int childCount = getChildCount();
    if (childCount == 0) {
        return true;
    }
    final int firstTop = getChildAt(0).getTop();
    final int lastBottom = getChildAt(childCount - 1).getBottom();
    final Rect listPadding = mListPadding;
    // "effective padding" In this case is the amount of padding that affects
    // how much space should not be filled by items. If we don't clip to padding
    // there is no effective padding.
    int effectivePaddingTop = 0;
    int effectivePaddingBottom = 0;
    if ((mGroupFlags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) {
        effectivePaddingTop = listPadding.top;
        effectivePaddingBottom = listPadding.bottom;
    }
    // FIXME account for grid vertical spacing too?
    final int spaceAbove = effectivePaddingTop - firstTop;
    final int end = getHeight() - effectivePaddingBottom;
    final int spaceBelow = lastBottom - end;
    final int height = getHeight() - mPaddingBottom - mPaddingTop;
    if (deltaY < 0) {
        deltaY = Math.max(-(height - 1), deltaY);
    } else {
        deltaY = Math.min(height - 1, deltaY);
    }
    if (incrementalDeltaY < 0) {
        incrementalDeltaY = Math.max(-(height - 1), incrementalDeltaY);
    } else {
        incrementalDeltaY = Math.min(height - 1, incrementalDeltaY);
    }
    final int firstPosition = mFirstPosition;
    // Update our guesses for where the first and last views are
    if (firstPosition == 0) {
        mFirstPositionDistanceGuess = firstTop - listPadding.top;
    } else {
        mFirstPositionDistanceGuess += incrementalDeltaY;
    }
    if (firstPosition + childCount == mItemCount) {
        mLastPositionDistanceGuess = lastBottom + listPadding.bottom;
    } else {
        mLastPositionDistanceGuess += incrementalDeltaY;
    }
    final boolean cannotScrollDown = (firstPosition == 0 && firstTop >= listPadding.top && incrementalDeltaY >= 0);
    final boolean cannotScrollUp = (firstPosition + childCount == mItemCount && lastBottom <= getHeight() - listPadding.bottom && incrementalDeltaY <= 0);
    if (cannotScrollDown || cannotScrollUp) {
        return incrementalDeltaY != 0;
    }
    final boolean down = incrementalDeltaY < 0;
    final boolean inTouchMode = isInTouchMode();
    if (inTouchMode) {
        hideSelector();
    }
    final int headerViewsCount = getHeaderViewsCount();
    final int footerViewsStart = mItemCount - getFooterViewsCount();
    int start = 0;
    int count = 0;
    if (down) {
        int top = -incrementalDeltaY;
        if ((mGroupFlags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) {
            top += listPadding.top;
        }
        for (int i = 0; i < childCount; i++) {
            final View child = getChildAt(i);
            if (child.getBottom() >= top) {
                break;
            } else {
                count++;
                int position = firstPosition + i;
                if (position >= headerViewsCount && position < footerViewsStart) {
                    // system-managed transient state.
                    if (child.isAccessibilityFocused()) {
                        child.clearAccessibilityFocus();
                    }
                    mRecycler.addScrapView(child, position);
                }
            }
        }
    } else {
        int bottom = getHeight() - incrementalDeltaY;
        if ((mGroupFlags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) {
            bottom -= listPadding.bottom;
        }
        for (int i = childCount - 1; i >= 0; i--) {
            final View child = getChildAt(i);
            if (child.getTop() <= bottom) {
                break;
            } else {
                start = i;
                count++;
                int position = firstPosition + i;
                if (position >= headerViewsCount && position < footerViewsStart) {
                    // system-managed transient state.
                    if (child.isAccessibilityFocused()) {
                        child.clearAccessibilityFocus();
                    }
                    mRecycler.addScrapView(child, position);
                }
            }
        }
    }
    mMotionViewNewTop = mMotionViewOriginalTop + deltaY;
    mBlockLayoutRequests = true;
    if (count > 0) {
        detachViewsFromParent(start, count);
        mRecycler.removeSkippedScrap();
    }
    // calls to bubble up from the children all the way to the top
    if (!awakenScrollBars()) {
        invalidate();
    }
    offsetChildrenTopAndBottom(incrementalDeltaY);
    if (down) {
        mFirstPosition += count;
    }
    final int absIncrementalDeltaY = Math.abs(incrementalDeltaY);
    if (spaceAbove < absIncrementalDeltaY || spaceBelow < absIncrementalDeltaY) {
        fillGap(down);
    }
    if (!inTouchMode && mSelectedPosition != INVALID_POSITION) {
        final int childIndex = mSelectedPosition - mFirstPosition;
        if (childIndex >= 0 && childIndex < getChildCount()) {
            positionSelector(mSelectedPosition, getChildAt(childIndex));
        }
    } else if (mSelectorPosition != INVALID_POSITION) {
        final int childIndex = mSelectorPosition - mFirstPosition;
        if (childIndex >= 0 && childIndex < getChildCount()) {
            positionSelector(INVALID_POSITION, getChildAt(childIndex));
        }
    } else {
        mSelectorRect.setEmpty();
    }
    mBlockLayoutRequests = false;
    invokeOnItemScrollListener();
    return false;
}
Body of Second Method:
{
    final int childCount = getChildCount();
    if (childCount == 0) {
        return true;
    }
    final int firstTop = getChildAt(0).getTop();
    final int lastBottom = getChildAt(childCount - 1).getBottom();
    final Rect listPadding = mListPadding;
    // "effective padding" In this case is the amount of padding that affects
    // how much space should not be filled by items. If we don't clip to padding
    // there is no effective padding.
    int effectivePaddingTop = 0;
    int effectivePaddingBottom = 0;
    if ((mGroupFlags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) {
        effectivePaddingTop = listPadding.top;
        effectivePaddingBottom = listPadding.bottom;
    }
    // FIXME account for grid vertical spacing too?
    final int spaceAbove = effectivePaddingTop - firstTop;
    final int end = getHeight() - effectivePaddingBottom;
    final int spaceBelow = lastBottom - end;
    final int height = getHeight() - mPaddingBottom - mPaddingTop;
    if (deltaY < 0) {
        deltaY = Math.max(-(height - 1), deltaY);
    } else {
        deltaY = Math.min(height - 1, deltaY);
    }
    if (incrementalDeltaY < 0) {
        incrementalDeltaY = Math.max(-(height - 1), incrementalDeltaY);
    } else {
        incrementalDeltaY = Math.min(height - 1, incrementalDeltaY);
    }
    final int firstPosition = mFirstPosition;
    // Update our guesses for where the first and last views are
    if (firstPosition == 0) {
        mFirstPositionDistanceGuess = firstTop - listPadding.top;
    } else {
        mFirstPositionDistanceGuess += incrementalDeltaY;
    }
    if (firstPosition + childCount == mItemCount) {
        mLastPositionDistanceGuess = lastBottom + listPadding.bottom;
    } else {
        mLastPositionDistanceGuess += incrementalDeltaY;
    }
    final boolean cannotScrollDown = (firstPosition == 0 && firstTop >= listPadding.top && incrementalDeltaY >= 0);
    final boolean cannotScrollUp = (firstPosition + childCount == mItemCount && lastBottom <= getHeight() - listPadding.bottom && incrementalDeltaY <= 0);
    if (cannotScrollDown || cannotScrollUp) {
        return incrementalDeltaY != 0;
    }
    final boolean down = incrementalDeltaY < 0;
    final boolean inTouchMode = isInTouchMode();
    if (inTouchMode) {
        hideSelector();
    }
    final int headerViewsCount = getHeaderViewsCount();
    final int footerViewsStart = mItemCount - getFooterViewsCount();
    int start = 0;
    int count = 0;
    if (down) {
        int top = -incrementalDeltaY;
        if ((mGroupFlags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) {
            top += listPadding.top;
        }
        for (int i = 0; i < childCount; i++) {
            final View child = getChildAt(i);
            if (child.getBottom() >= top) {
                break;
            } else {
                count++;
                int position = firstPosition + i;
                if (position >= headerViewsCount && position < footerViewsStart) {
                    // The view will be rebound to new data, clear any
                    // system-managed transient state.
                    child.clearAccessibilityFocus();
                    mRecycler.addScrapView(child, position);
                }
            }
        }
    } else {
        int bottom = getHeight() - incrementalDeltaY;
        if ((mGroupFlags & CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) {
            bottom -= listPadding.bottom;
        }
        for (int i = childCount - 1; i >= 0; i--) {
            final View child = getChildAt(i);
            if (child.getTop() <= bottom) {
                break;
            } else {
                start = i;
                count++;
                int position = firstPosition + i;
                if (position >= headerViewsCount && position < footerViewsStart) {
                    // The view will be rebound to new data, clear any
                    // system-managed transient state.
                    child.clearAccessibilityFocus();
                    mRecycler.addScrapView(child, position);
                }
            }
        }
    }
    mMotionViewNewTop = mMotionViewOriginalTop + deltaY;
    mBlockLayoutRequests = true;
    if (count > 0) {
        detachViewsFromParent(start, count);
        mRecycler.removeSkippedScrap();
    }
    // calls to bubble up from the children all the way to the top
    if (!awakenScrollBars()) {
        invalidate();
    }
    offsetChildrenTopAndBottom(incrementalDeltaY);
    if (down) {
        mFirstPosition += count;
    }
    final int absIncrementalDeltaY = Math.abs(incrementalDeltaY);
    if (spaceAbove < absIncrementalDeltaY || spaceBelow < absIncrementalDeltaY) {
        fillGap(down);
    }
    if (!inTouchMode && mSelectedPosition != INVALID_POSITION) {
        final int childIndex = mSelectedPosition - mFirstPosition;
        if (childIndex >= 0 && childIndex < getChildCount()) {
            positionSelector(mSelectedPosition, getChildAt(childIndex));
        }
    } else if (mSelectorPosition != INVALID_POSITION) {
        final int childIndex = mSelectorPosition - mFirstPosition;
        if (childIndex >= 0 && childIndex < getChildCount()) {
            positionSelector(INVALID_POSITION, getChildAt(childIndex));
        }
    } else {
        mSelectorRect.setEmpty();
    }
    mBlockLayoutRequests = false;
    invokeOnItemScrollListener();
    return false;
}
------------------------
Find a silently evolved API code:android.webkit.WebSettings.setRenderPriority:COMMENT
<android.webkit.WebSettings: void setRenderPriority(RenderPriority)>
public      deprecated  ->public      abstract    deprecated  
Method Modifier: public      abstract    deprecated  
Method Modifier: Yes         No          Yes         
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * Sets the priority of the Render thread. Unlike the other settings, this
 * one only needs to be called once per process. The default value is
 * {@link RenderPriority#NORMAL}.
 *
 * @param priority the priority
 * @deprecated It is not recommended to adjust thread priorities, and this will
 * not be supported in future versions.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.view.Surface.release:COMMENT
Method Modifier: public      
Comment:/**
 * Release the local reference to the server-side surface.
 * Always call release() when you're done with a Surface.
 * This will make the surface invalid.
 */

Body of Frist Method:
{
    synchronized (mLock) {
        if (mNativeObject != 0) {
            nativeRelease(mNativeObject);
            setNativeObjectLocked(0);
        }
    }
}
Body of Second Method:
{
    synchronized (mLock) {
        if (mNativeObject != 0) {
            nativeRelease(mNativeObject);
            setNativeObjectLocked(0);
        }
        if (mHwuiContext != null) {
            mHwuiContext.destroy();
            mHwuiContext = null;
        }
    }
}
------------------------
Find a silently evolved API code:android.webkit.WebSettings.getAcceptThirdPartyCookies:COMMENT
<android.webkit.WebSettings: boolean getAcceptThirdPartyCookies()>
public      hidden      ->public      abstract    hidden      
Method Modifier: public      abstract    hidden      
Method Modifier: Yes         No          Yes         
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * Gets policy for third party cookies.
 * Developers should access this via {@link CookieManager#getShouldAcceptThirdPartyCookies}.
 * @hide Internal API
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.widget.SearchView.setImeOptions:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the IME options on the query text field.
 *
 * @see TextView#setImeOptions(int)
 * @param imeOptions the options to set on the query text field
 *
 * @attr ref android.R.styleable#SearchView_imeOptions
 */

Body of Frist Method:
{
    mQueryTextView.setImeOptions(imeOptions);
}
Body of Second Method:
{
    mSearchSrcTextView.setImeOptions(imeOptions);
}
------------------------
Find a silently evolved API code:android.widget.SearchView.setSuggestionsAdapter:COMMENT
Method Modifier: public      
Comment:/**
 * You can set a custom adapter if you wish. Otherwise the default adapter is used to
 * display the suggestions from the suggestions provider associated with the SearchableInfo.
 *
 * @see #setSearchableInfo(SearchableInfo)
 */

Body of Frist Method:
{
    mSuggestionsAdapter = adapter;
    mQueryTextView.setAdapter(mSuggestionsAdapter);
}
Body of Second Method:
{
    mSuggestionsAdapter = adapter;
    mSearchSrcTextView.setAdapter(mSuggestionsAdapter);
}
------------------------
Find a silently evolved API code:android.view.accessibility.AccessibilityWindowInfo.isAccessibilityFocused:COMMENT
Method Modifier: public      
Comment:/**
 * Gets if this window has accessibility focus.
 *
 * @return Whether has accessibility focus.
 */

Body of Frist Method:
{
    return getBooleanProperty(BOOLEAN_PROPERTY_ACCESSIBLITY_FOCUSED);
}
Body of Second Method:
{
    return getBooleanProperty(BOOLEAN_PROPERTY_ACCESSIBILITY_FOCUSED);
}
------------------------
Find a silently evolved API code:android.view.ViewGroup.addViewInLayout:COMMENT
Method Modifier: protected   
Comment:/**
 * Adds a view during layout. This is useful if in your onLayout() method,
 * you need to add more views (as does the list view for example).
 *
 * If index is negative, it means put it at the end of the list.
 *
 * @param child the view to add to the group
 * @param index the index at which the child must be added
 * @param params the layout parameters to associate with the child
 * @param preventRequestLayout if true, calling this method will not trigger a
 * layout request on child
 * @return true if the child was added, false otherwise
 */

Body of Frist Method:
{
    child.mParent = null;
    addViewInner(child, index, params, preventRequestLayout);
    child.mPrivateFlags = (child.mPrivateFlags & ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;
    return true;
}
Body of Second Method:
{
    if (child == null) {
        throw new IllegalArgumentException("Cannot add a null child view to a ViewGroup");
    }
    child.mParent = null;
    addViewInner(child, index, params, preventRequestLayout);
    child.mPrivateFlags = (child.mPrivateFlags & ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;
    return true;
}
------------------------
Find a silently evolved API code:android.util.PathParser.createPathFromPathData:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @param pathData The string representing a path, the same as "d" string in svg file.
 * @return the generated Path object.
 */

Body of Frist Method:
{
    Path path = new Path();
    PathDataNode[] nodes = createNodesFromPathData(pathData);
    if (nodes != null) {
        PathDataNode.nodesToPath(nodes, path);
        return path;
    }
    return null;
}
Body of Second Method:
{
    Path path = new Path();
    PathDataNode[] nodes = createNodesFromPathData(pathData);
    if (nodes != null) {
        try {
            PathDataNode.nodesToPath(nodes, path);
        } catch (RuntimeException e) {
            throw new RuntimeException("Error in parsing " + pathData, e);
        }
        return path;
    }
    return null;
}
------------------------
Find a silently evolved API code:android.webkit.WebSettings.getBlockNetworkImage:COMMENT
<android.webkit.WebSettings: boolean getBlockNetworkImage()>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Gets whether the WebView does not load image resources from the network.
 *
 * @return true if the WebView does not load image resources from the network
 * @see #setBlockNetworkImage
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.widget.AbsListView.positionSelectorLikeFocus:COMMENT
Method Modifier: default     
Comment:/**
 * Positions the selector in a way that mimics keyboard focus.
 */

Body of Frist Method:
{
    // If we're changing position, update the visibility since the selector
    // is technically being detached from the previous selection.
    final Drawable selector = mSelector;
    final boolean manageState = selector != null && mSelectorPosition != position && position != INVALID_POSITION;
    if (manageState) {
        selector.setVisible(false, false);
    }
    positionSelector(position, sel);
    if (manageState) {
        final Rect bounds = mSelectorRect;
        final float x = bounds.exactCenterX();
        final float y = bounds.exactCenterY();
        selector.setVisible(getVisibility() == VISIBLE, false);
        selector.setHotspot(x, y);
    }
}
Body of Second Method:
{
    if (mSelector != null && mSelectorPosition != position && position != INVALID_POSITION) {
        final Rect bounds = mSelectorRect;
        final float x = bounds.exactCenterX();
        final float y = bounds.exactCenterY();
        positionSelector(position, sel, true, x, y);
    } else {
        positionSelector(position, sel);
    }
}
------------------------
Find a silently evolved API code:android.media.session.MediaSession.setMetadata:COMMENT
Method Modifier: public      
Comment:/**
 * Update the current metadata. New metadata can be created using
 * {@link android.media.MediaMetadata.Builder}.
 *
 * @param metadata The new metadata
 */

Body of Frist Method:
{
    try {
        mBinder.setMetadata(metadata);
    } catch (RemoteException e) {
        Log.wtf(TAG, "Dead object in setPlaybackState.", e);
    }
}
Body of Second Method:
{
    if (metadata != null) {
        metadata = (new MediaMetadata.Builder(metadata, mMaxBitmapSize)).build();
    }
    try {
        mBinder.setMetadata(metadata);
    } catch (RemoteException e) {
        Log.wtf(TAG, "Dead object in setPlaybackState.", e);
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothGatt.writeDescriptor:COMMENT
Method Modifier: public      
Comment:/**
 * Write the value of a given descriptor to the associated remote device.
 *
 * <p>A {@link BluetoothGattCallback#onDescriptorWrite} callback is
 * triggered to report the result of the write operation.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH} permission.
 *
 * @param descriptor Descriptor to write to the associated remote device
 * @return true, if the write operation was initiated successfully
 */

Body of Frist Method:
{
    if (VDBG)
        Log.d(TAG, "writeDescriptor() - uuid: " + descriptor.getUuid());
    if (mService == null || mClientIf == 0)
        return false;
    BluetoothGattCharacteristic characteristic = descriptor.getCharacteristic();
    if (characteristic == null)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusy) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.writeDescriptor(mClientIf, device.getAddress(), service.getType(), service.getInstanceId(), new ParcelUuid(service.getUuid()), characteristic.getInstanceId(), new ParcelUuid(characteristic.getUuid()), descriptor.getInstanceId(), new ParcelUuid(descriptor.getUuid()), characteristic.getWriteType(), AUTHENTICATION_NONE, descriptor.getValue());
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}
Body of Second Method:
{
    if (VDBG)
        Log.d(TAG, "writeDescriptor() - uuid: " + descriptor.getUuid());
    if (mService == null || mClientIf == 0 || descriptor.getValue() == null)
        return false;
    BluetoothGattCharacteristic characteristic = descriptor.getCharacteristic();
    if (characteristic == null)
        return false;
    BluetoothGattService service = characteristic.getService();
    if (service == null)
        return false;
    BluetoothDevice device = service.getDevice();
    if (device == null)
        return false;
    synchronized (mDeviceBusy) {
        if (mDeviceBusy)
            return false;
        mDeviceBusy = true;
    }
    try {
        mService.writeDescriptor(mClientIf, device.getAddress(), service.getType(), service.getInstanceId(), new ParcelUuid(service.getUuid()), characteristic.getInstanceId(), new ParcelUuid(characteristic.getUuid()), descriptor.getInstanceId(), new ParcelUuid(descriptor.getUuid()), characteristic.getWriteType(), AUTHENTICATION_NONE, descriptor.getValue());
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        mDeviceBusy = false;
        return false;
    }
    return true;
}
------------------------
Find a silently evolved API code:android.media.projection.MediaProjection.registerCallback:COMMENT
Method Modifier: public      
Comment:/**
 * Register a listener to receive notifications about when the {@link
 * MediaProjection} changes state.
 *
 * @param callback The callback to call.
 * @param handler The handler on which the callback should be invoked, or
 * null if the callback should be invoked on the calling thread's looper.
 *
 * @see #unregisterCallback
 */

Body of Frist Method:
{
    if (callback == null) {
        throw new IllegalArgumentException("callback should not be null");
    }
    mCallbacks.put(callback, new CallbackRecord(callback, handler));
}
Body of Second Method:
{
    if (callback == null) {
        throw new IllegalArgumentException("callback should not be null");
    }
    if (handler == null) {
        handler = new Handler();
    }
    mCallbacks.put(callback, new CallbackRecord(callback, handler));
}
------------------------
Find a silently evolved API code:android.webkit.CookieManager.setAcceptFileSchemeCookiesImpl:COMMENT
<android.webkit.CookieManager: void setAcceptFileSchemeCookiesImpl(boolean)>
protected   hidden      ->protected   abstract    hidden      
Method Modifier: protected   abstract    hidden      
Method Modifier: Yes         No          Yes         
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * Implements {@link #setAcceptFileSchemeCookies(boolean)}.
 *
 * @hide Only for use by WebViewProvider implementations
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.webkit.WebView.evaluateJavascript:COMMENT
Method Modifier: public      
Comment:/**
 * Asynchronously evaluates JavaScript in the context of the currently displayed page.
 * If non-null, |resultCallback| will be invoked with any result returned from that
 * execution. This method must be called on the UI thread and the callback will
 * be made on the UI thread.
 *
 * @param script the JavaScript to execute.
 * @param resultCallback A callback to be invoked when the script execution
 * completes with the result of the execution (if any).
 * May be null if no notificaion of the result is required.
 */

Body of Frist Method:
{
    checkThread();
    if (DebugFlags.TRACE_API)
        Log.d(LOGTAG, "evaluateJavascript=" + script);
    mProvider.evaluateJavaScript(script, resultCallback);
}
Body of Second Method:
{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, "evaluateJavascript=" + script);
    mProvider.evaluateJavaScript(script, resultCallback);
}
------------------------
Find a silently evolved API code:android.webkit.WebIconDatabase.removeAllIcons:COMMENT
<android.webkit.WebIconDatabase: void removeAllIcons()>
public      deprecated  ->public      abstract    deprecated  
Method Modifier: public      abstract    deprecated  
Method Modifier: Yes         No          Yes         
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * Removes all the icons in the database.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.widget.SearchView.updateSearchAutoComplete:COMMENT
Method Modifier: private     
Comment:/**
 * Updates the auto-complete text view.
 */

Body of Frist Method:
{
    // no animation
    mQueryTextView.setDropDownAnimationStyle(0);
    mQueryTextView.setThreshold(mSearchable.getSuggestThreshold());
    mQueryTextView.setImeOptions(mSearchable.getImeOptions());
    int inputType = mSearchable.getInputType();
    // should be, in the case of search!)
    if ((inputType & InputType.TYPE_MASK_CLASS) == InputType.TYPE_CLASS_TEXT) {
        // The existence of a suggestions authority is the proxy for "suggestions
        // are available here"
        inputType &= ~InputType.TYPE_TEXT_FLAG_AUTO_COMPLETE;
        if (mSearchable.getSuggestAuthority() != null) {
            inputType |= InputType.TYPE_TEXT_FLAG_AUTO_COMPLETE;
            // TYPE_TEXT_FLAG_AUTO_COMPLETE means that the text editor is performing
            // auto-completion based on its own semantics, which it will present to the user
            // as they type. This generally means that the input method should not show its
            // own candidates, and the spell checker should not be in action. The text editor
            // supplies its candidates by calling InputMethodManager.displayCompletions(),
            // which in turn will call InputMethodSession.displayCompletions().
            inputType |= InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS;
        }
    }
    mQueryTextView.setInputType(inputType);
    if (mSuggestionsAdapter != null) {
        mSuggestionsAdapter.changeCursor(null);
    }
    // The existence of a suggestions authority is the proxy for "suggestions available here"
    if (mSearchable.getSuggestAuthority() != null) {
        mSuggestionsAdapter = new SuggestionsAdapter(getContext(), this, mSearchable, mOutsideDrawablesCache);
        mQueryTextView.setAdapter(mSuggestionsAdapter);
        ((SuggestionsAdapter) mSuggestionsAdapter).setQueryRefinement(mQueryRefinement ? SuggestionsAdapter.REFINE_ALL : SuggestionsAdapter.REFINE_BY_ENTRY);
    }
}
Body of Second Method:
{
    // no animation
    mSearchSrcTextView.setDropDownAnimationStyle(0);
    mSearchSrcTextView.setThreshold(mSearchable.getSuggestThreshold());
    mSearchSrcTextView.setImeOptions(mSearchable.getImeOptions());
    int inputType = mSearchable.getInputType();
    // should be, in the case of search!)
    if ((inputType & InputType.TYPE_MASK_CLASS) == InputType.TYPE_CLASS_TEXT) {
        // The existence of a suggestions authority is the proxy for "suggestions
        // are available here"
        inputType &= ~InputType.TYPE_TEXT_FLAG_AUTO_COMPLETE;
        if (mSearchable.getSuggestAuthority() != null) {
            inputType |= InputType.TYPE_TEXT_FLAG_AUTO_COMPLETE;
            // TYPE_TEXT_FLAG_AUTO_COMPLETE means that the text editor is performing
            // auto-completion based on its own semantics, which it will present to the user
            // as they type. This generally means that the input method should not show its
            // own candidates, and the spell checker should not be in action. The text editor
            // supplies its candidates by calling InputMethodManager.displayCompletions(),
            // which in turn will call InputMethodSession.displayCompletions().
            inputType |= InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS;
        }
    }
    mSearchSrcTextView.setInputType(inputType);
    if (mSuggestionsAdapter != null) {
        mSuggestionsAdapter.changeCursor(null);
    }
    // The existence of a suggestions authority is the proxy for "suggestions available here"
    if (mSearchable.getSuggestAuthority() != null) {
        mSuggestionsAdapter = new SuggestionsAdapter(getContext(), this, mSearchable, mOutsideDrawablesCache);
        mSearchSrcTextView.setAdapter(mSuggestionsAdapter);
        ((SuggestionsAdapter) mSuggestionsAdapter).setQueryRefinement(mQueryRefinement ? SuggestionsAdapter.REFINE_ALL : SuggestionsAdapter.REFINE_BY_ENTRY);
    }
}
------------------------
Find a silently evolved API code:android.webkit.WebSettings.getSaveFormData:COMMENT
<android.webkit.WebSettings: boolean getSaveFormData()>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Gets whether the WebView saves form data.
 *
 * @return whether the WebView saves form data
 * @see #setSaveFormData
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.graphics.drawable.RippleDrawable.clearHotspots:COMMENT
Method Modifier: private     
Comment:/**
 * Cancels and removes the active ripple, all exiting ripples, and the
 * background. Nothing will be drawn after this method is called.
 */

Body of Frist Method:
{
    boolean needsDraw = false;
    if (mRipple != null) {
        needsDraw |= mRipple.isHardwareAnimating();
        mRipple.cancel();
        mRipple = null;
    }
    if (mBackground != null) {
        needsDraw |= mBackground.isHardwareAnimating();
        mBackground.cancel();
        mBackground = null;
    }
    needsDraw |= cancelExitingRipples();
    mNeedsDraw = needsDraw;
    invalidateSelf();
}
Body of Second Method:
{
    if (mRipple != null) {
        mRipple.cancel();
        mRipple = null;
        mRippleActive = false;
    }
    if (mBackground != null) {
        mBackground.cancel();
        mBackground = null;
        mBackgroundActive = false;
    }
    cancelExitingRipples();
    invalidateSelf();
}
------------------------
Find a silently evolved API code:android.appwidget.AppWidgetHost.createView:COMMENT
Method Modifier: public      final       
Comment:/**
 * Create the AppWidgetHostView for the given widget.
 * The AppWidgetHost retains a pointer to the newly-created View.
 */

Body of Frist Method:
{
    AppWidgetHostView view = onCreateView(mContext, appWidgetId, appWidget);
    view.setOnClickHandler(mOnClickHandler);
    view.setAppWidget(appWidgetId, appWidget);
    synchronized (mViews) {
        mViews.put(appWidgetId, view);
    }
    RemoteViews views;
    try {
        views = sService.getAppWidgetViews(mContext.getOpPackageName(), appWidgetId);
    } catch (RemoteException e) {
        throw new RuntimeException("system server dead?", e);
    }
    view.updateAppWidget(views);
    return view;
}
Body of Second Method:
{
    AppWidgetHostView view = onCreateView(context, appWidgetId, appWidget);
    view.setOnClickHandler(mOnClickHandler);
    view.setAppWidget(appWidgetId, appWidget);
    synchronized (mViews) {
        mViews.put(appWidgetId, view);
    }
    RemoteViews views;
    try {
        views = sService.getAppWidgetViews(mContextOpPackageName, appWidgetId);
    } catch (RemoteException e) {
        throw new RuntimeException("system server dead?", e);
    }
    view.updateAppWidget(views);
    return view;
}
------------------------
Find a silently evolved API code:android.widget.SearchView.requestFocus:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    // Don't accept focus if in the middle of clearing focus
    if (mClearingFocus)
        return false;
    // Check if SearchView is focusable.
    if (!isFocusable())
        return false;
    // If it is not iconified, then give the focus to the text field
    if (!isIconified()) {
        boolean result = mQueryTextView.requestFocus(direction, previouslyFocusedRect);
        if (result) {
            updateViewsVisibility(false);
        }
        return result;
    } else {
        return super.requestFocus(direction, previouslyFocusedRect);
    }
}
Body of Second Method:
{
    // Don't accept focus if in the middle of clearing focus
    if (mClearingFocus)
        return false;
    // Check if SearchView is focusable.
    if (!isFocusable())
        return false;
    // If it is not iconified, then give the focus to the text field
    if (!isIconified()) {
        boolean result = mSearchSrcTextView.requestFocus(direction, previouslyFocusedRect);
        if (result) {
            updateViewsVisibility(false);
        }
        return result;
    } else {
        return super.requestFocus(direction, previouslyFocusedRect);
    }
}
------------------------
Find a silently evolved API code:android.webkit.WebView.showFindDialog:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * Starts an ActionMode for finding text in this WebView.  Only works if this
 * WebView is attached to the view system.
 *
 * @param text if non-null, will be the initial text to search for.
 * Otherwise, the last String searched for in this WebView will
 * be used to start.
 * @param showIme if true, show the IME, assuming the user will begin typing.
 * If false and text is non-null, perform a find all.
 * @return true if the find dialog is shown, false otherwise
 * @deprecated This method does not work reliably on all Android versions;
 * implementing a custom find dialog using WebView.findAllAsync()
 * provides a more robust solution.
 */

Body of Frist Method:
{
    checkThread();
    if (DebugFlags.TRACE_API)
        Log.d(LOGTAG, "showFindDialog");
    return mProvider.showFindDialog(text, showIme);
}
Body of Second Method:
{
    checkThread();
    if (TRACE)
        Log.d(LOGTAG, "showFindDialog");
    return mProvider.showFindDialog(text, showIme);
}
------------------------
Find a silently evolved API code:android.content.res.BridgeTypedArray.getResourceId:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the resource identifier for the attribute at
 * <var>index</var>.  Note that attribute resource as resolved when
 * the overall {@link TypedArray} object is retrieved.  As a
 * result, this function will return the resource identifier of the
 * final resource value that was found, <em>not</em> necessarily the
 * original resource that was specified by the attribute.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute resource identifier, or defValue if not defined.
 */

Body of Frist Method:
{
    if (index < 0 || index >= mResourceData.length) {
        return defValue;
    }
    // get the Resource for this index
    ResourceValue resValue = mResourceData[index];
    // no data, return the default value.
    if (resValue == null) {
        return defValue;
    }
    // check if this is a style resource
    if (resValue instanceof StyleResourceValue) {
        // get the id that will represent this style.
        return mContext.getDynamicIdByStyle((StyleResourceValue) resValue);
    }
    // (and getValue() returning null!). We need to handle this!
    if (resValue.getResourceType() != null) {
        // if this is a framework id
        if (mPlatformFile || resValue.isFramework()) {
            // look for idName in the android R classes
            return mContext.getFrameworkResourceValue(resValue.getResourceType(), resValue.getName(), defValue);
        }
        // look for idName in the project R class.
        return mContext.getProjectResourceValue(resValue.getResourceType(), resValue.getName(), defValue);
    }
    // else, try to get the value, and resolve it somehow.
    String value = resValue.getValue();
    if (value == null) {
        return defValue;
    }
    // if the value is just an integer, return it.
    try {
        int i = Integer.parseInt(value);
        if (Integer.toString(i).equals(value)) {
            return i;
        }
    } catch (NumberFormatException e) {
    // pass
    }
    // if this is a reference to an id, find it.
    if (value.startsWith("@id/") || value.startsWith("@+") || value.startsWith("@android:id/")) {
        int pos = value.indexOf('/');
        String idName = value.substring(pos + 1);
        // if this is a framework id
        if (mPlatformFile || value.startsWith("@android") || value.startsWith("@+android")) {
            // look for idName in the android R classes
            return mContext.getFrameworkResourceValue(ResourceType.ID, idName, defValue);
        }
        // look for idName in the project R class.
        return mContext.getProjectResourceValue(ResourceType.ID, idName, defValue);
    }
    // not a direct id valid reference? resolve it
    Integer idValue;
    if (resValue.isFramework()) {
        idValue = Bridge.getResourceId(resValue.getResourceType(), resValue.getName());
    } else {
        idValue = mContext.getProjectCallback().getResourceId(resValue.getResourceType(), resValue.getName());
    }
    if (idValue != null) {
        return idValue;
    }
    Bridge.getLog().warning(LayoutLog.TAG_RESOURCES_RESOLVE, String.format("Unable to resolve id \"%1$s\" for attribute \"%2$s\"", value, mNames[index]), resValue);
    return defValue;
}
Body of Second Method:
{
    if (index < 0 || index >= mResourceData.length) {
        return defValue;
    }
    // get the Resource for this index
    ResourceValue resValue = mResourceData[index];
    // no data, return the default value.
    if (resValue == null) {
        return defValue;
    }
    // check if this is a style resource
    if (resValue instanceof StyleResourceValue) {
        // get the id that will represent this style.
        return mContext.getDynamicIdByStyle((StyleResourceValue) resValue);
    }
    // (and getValue() returning null!). We need to handle this!
    if (resValue.getResourceType() != null) {
        // if this is a framework id
        if (mPlatformFile || resValue.isFramework()) {
            // look for idName in the android R classes
            return mContext.getFrameworkResourceValue(resValue.getResourceType(), resValue.getName(), defValue);
        }
        // look for idName in the project R class.
        return mContext.getProjectResourceValue(resValue.getResourceType(), resValue.getName(), defValue);
    }
    // else, try to get the value, and resolve it somehow.
    String value = resValue.getValue();
    if (value == null) {
        return defValue;
    }
    // if the value is just an integer, return it.
    try {
        int i = Integer.parseInt(value);
        if (Integer.toString(i).equals(value)) {
            return i;
        }
    } catch (NumberFormatException e) {
    // pass
    }
    // if this is a reference to an id, find it.
    if (value.startsWith("@id/") || value.startsWith("@+") || value.startsWith("@android:id/")) {
        int pos = value.indexOf('/');
        String idName = value.substring(pos + 1);
        boolean create = value.startsWith("@+");
        boolean isFrameworkId = mPlatformFile || value.startsWith("@android") || value.startsWith("@+android");
        // Look for the idName in project or android R class depending on isPlatform.
        if (create) {
            Integer idValue;
            if (isFrameworkId) {
                idValue = Bridge.getResourceId(ResourceType.ID, idName);
            } else {
                idValue = mContext.getProjectCallback().getResourceId(ResourceType.ID, idName);
            }
            return idValue == null ? defValue : idValue;
        }
        // one is not found.
        if (isFrameworkId) {
            return mContext.getFrameworkResourceValue(ResourceType.ID, idName, defValue);
        } else {
            return mContext.getProjectResourceValue(ResourceType.ID, idName, defValue);
        }
    }
    // not a direct id valid reference? resolve it
    Integer idValue;
    if (resValue.isFramework()) {
        idValue = Bridge.getResourceId(resValue.getResourceType(), resValue.getName());
    } else {
        idValue = mContext.getProjectCallback().getResourceId(resValue.getResourceType(), resValue.getName());
    }
    if (idValue != null) {
        return idValue;
    }
    Bridge.getLog().warning(LayoutLog.TAG_RESOURCES_RESOLVE, String.format("Unable to resolve id \"%1$s\" for attribute \"%2$s\"", value, mNames[index]), resValue);
    return defValue;
}
------------------------
Find a silently evolved API code:android.webkit.WebSettings.setEnableSmoothTransition:COMMENT
<android.webkit.WebSettings: void setEnableSmoothTransition(boolean)>
public      deprecated  ->public      abstract    deprecated  
Method Modifier: public      abstract    deprecated  
Method Modifier: Yes         No          Yes         
Method Updated:  Yes         Yes         Yes         
Comment:/**
 * Sets whether the WebView will enable smooth transition while panning or
 * zooming or while the window hosting the WebView does not have focus.
 * If it is true, WebView will choose a solution to maximize the performance.
 * e.g. the WebView's content may not be updated during the transition.
 * If it is false, WebView will keep its fidelity. The default value is false.
 *
 * @deprecated This method is now obsolete, and will become a no-op in future.
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.webkit.WebSettings.getStandardFontFamily:COMMENT
<android.webkit.WebSettings: String getStandardFontFamily()>
public      ->public      abstract    
Method Modifier: public      abstract    
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Gets the standard font family name.
 *
 * @return the standard font family name as a string
 * @see #setStandardFontFamily
 */

Body of Frist Method:
{
    throw new MustOverrideException();
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.util.PathParser.getFloats:COMMENT
Method Modifier: private     static      hidden      
Comment:/**
 * Parse the floats in the string.
 * This is an optimized version of parseFloat(s.split(",|\\s"));
 *
 * @param s the string containing a command and list of floats
 * @return array of floats
 */

Body of Frist Method:
{
    if (s.charAt(0) == 'z' | s.charAt(0) == 'Z') {
        return new float[0];
    }
    try {
        float[] results = new float[s.length()];
        int count = 0;
        int startPosition = 1;
        int endPosition = 0;
        ExtractFloatResult result = new ExtractFloatResult();
        int totalLength = s.length();
        // number.
        while (startPosition < totalLength) {
            extract(s, startPosition, result);
            endPosition = result.mEndPosition;
            if (startPosition < endPosition) {
                results[count++] = Float.parseFloat(s.substring(startPosition, endPosition));
            }
            if (result.mEndWithNegSign) {
                // Keep the '-' sign with next number.
                startPosition = endPosition;
            } else {
                startPosition = endPosition + 1;
            }
        }
        return Arrays.copyOf(results, count);
    } catch (NumberFormatException e) {
        Log.e(LOGTAG, "error in parsing \"" + s + "\"");
        throw e;
    }
}
Body of Second Method:
{
    if (s.charAt(0) == 'z' | s.charAt(0) == 'Z') {
        return new float[0];
    }
    try {
        float[] results = new float[s.length()];
        int count = 0;
        int startPosition = 1;
        int endPosition = 0;
        ExtractFloatResult result = new ExtractFloatResult();
        int totalLength = s.length();
        // number.
        while (startPosition < totalLength) {
            extract(s, startPosition, result);
            endPosition = result.mEndPosition;
            if (startPosition < endPosition) {
                results[count++] = Float.parseFloat(s.substring(startPosition, endPosition));
            }
            if (result.mEndWithNegOrDot) {
                // Keep the '-' or '.' sign with next number.
                startPosition = endPosition;
            } else {
                startPosition = endPosition + 1;
            }
        }
        return Arrays.copyOf(results, count);
    } catch (NumberFormatException e) {
        throw new RuntimeException("error in parsing \"" + s + "\"", e);
    }
}
------------------------

