Find a silently evolved API code:android.content.res.TypedArray.getDimensionPixelSize:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve a dimensional unit attribute at <var>index</var> for use
 * as a size in raw pixels.  This is the same as
 * {@link #getDimension}, except the returned value is converted to
 * integer pixels for use as a size.  A size conversion involves
 * rounding the base value, and ensuring that a non-zero base value
 * is at least one pixel in size.
 * <p>
 * This method will throw an exception if the attribute is defined but is
 * not a dimension.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute dimension value multiplied by the appropriate
 * metric and truncated to integer pixels, or defValue if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not a dimension.
 *
 * @see #getDimension
 * @see #getDimensionPixelOffset
 */

Body of Frist Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    final int attrIndex = index;
    index *= STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimensionPixelSize(data[index + STYLE_DATA], mMetrics);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index, value);
        throw new UnsupportedOperationException("Failed to resolve attribute at index " + attrIndex + ": " + value);
    }
    throw new UnsupportedOperationException("Can't convert value at index " + attrIndex + " to dimension: type=0x" + Integer.toHexString(type));
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    final int attrIndex = index;
    index *= STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimensionPixelSize(data[index + STYLE_DATA], mMetrics);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index, value);
        throw new UnsupportedOperationException("Failed to resolve attribute at index " + attrIndex + ": " + value + ", theme=" + mTheme);
    }
    throw new UnsupportedOperationException("Can't convert value at index " + attrIndex + " to dimension: type=0x" + Integer.toHexString(type) + ", theme=" + mTheme);
}
------------------------
Find a silently evolved API code:android.os.UidBatteryConsumer.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Creates a read-only object out of the Builder values.
 */

Body of Frist Method:
{
    if (mPackageWithHighestDrain == PACKAGE_NAME_UNINITIALIZED) {
        mPackageWithHighestDrain = null;
    }
    return new UidBatteryConsumer(this);
}
Body of Second Method:
{
    if (mPackageWithHighestDrain == PACKAGE_NAME_UNINITIALIZED) {
        mPackageWithHighestDrain = null;
    }
    if (mPackageWithHighestDrain != null) {
        mData.putString(COLUMN_INDEX_PACKAGE_WITH_HIGHEST_DRAIN, mPackageWithHighestDrain);
    }
    return new UidBatteryConsumer(this);
}
------------------------
Find a silently evolved API code:android.location.LocationRequest.setQuality:COMMENT
Method Modifier: public      hidden      deprecated  
Comment:/**
 * @hide
 * @deprecated LocationRequests should be treated as immutable.
 */

Body of Frist Method:
{
    switch(quality) {
        case POWER_HIGH:
        // fall through
        case QUALITY_HIGH_ACCURACY:
            mQuality = QUALITY_HIGH_ACCURACY;
            break;
        case QUALITY_BALANCED_POWER_ACCURACY:
            mQuality = QUALITY_BALANCED_POWER_ACCURACY;
            break;
        case POWER_LOW:
        // fall through
        case QUALITY_LOW_POWER:
            mQuality = QUALITY_LOW_POWER;
            break;
        case POWER_NONE:
            mInterval = PASSIVE_INTERVAL;
            break;
        default:
            throw new IllegalArgumentException("invalid quality: " + quality);
    }
    return this;
}
Body of Second Method:
{
    switch(quality) {
        case POWER_HIGH:
        // fall through
        case QUALITY_HIGH_ACCURACY:
            mQuality = QUALITY_HIGH_ACCURACY;
            break;
        case QUALITY_BALANCED_POWER_ACCURACY:
            mQuality = QUALITY_BALANCED_POWER_ACCURACY;
            break;
        case POWER_LOW:
        // fall through
        case QUALITY_LOW_POWER:
            mQuality = QUALITY_LOW_POWER;
            break;
        case POWER_NONE:
            mIntervalMillis = PASSIVE_INTERVAL;
            break;
        default:
            throw new IllegalArgumentException("invalid quality: " + quality);
    }
    return this;
}
------------------------
Find a silently evolved API code:android.hardware.HardwareBuffer.isSupportedFormat:COMMENT
Method Modifier: private     static      
Comment:/**
 * Validates whether a particular format is supported by HardwareBuffer.
 *
 * @param format The format to validate.
 *
 * @return True if <code>format</code> is a supported format. false otherwise.
 * See {@link #create(int, int, int, int, long)}.
 */

Body of Frist Method:
{
    switch(format) {
        case RGBA_8888:
        case RGBA_FP16:
        case RGBA_1010102:
        case RGBX_8888:
        case RGB_565:
        case RGB_888:
        case BLOB:
        case YCBCR_420_888:
        case D_16:
        case D_24:
        case DS_24UI8:
        case D_FP32:
        case DS_FP32UI8:
        case S_UI8:
            return true;
    }
    return false;
}
Body of Second Method:
{
    switch(format) {
        case RGBA_8888:
        case RGBA_FP16:
        case RGBA_1010102:
        case RGBX_8888:
        case RGB_565:
        case RGB_888:
        case BLOB:
        case YCBCR_420_888:
        case D_16:
        case D_24:
        case DS_24UI8:
        case D_FP32:
        case DS_FP32UI8:
        case S_UI8:
        case YCBCR_P010:
            return true;
    }
    return false;
}
------------------------
Find a silently evolved API code:android.media.audiopolicy.AudioProductStrategy.attributesMatches:COMMENT
Method Modifier: private     static      hidden      
Comment:/**
 * To avoid duplicating the logic in java and native, we shall make use of
 * native API native_get_product_strategies_from_audio_attributes
 * Keep in sync with frameworks/av/media/libaudioclient/AudioProductStrategy::attributesMatches
 * @param refAttr {@link AudioAttributes} to be taken as the reference
 * @param attr {@link AudioAttributes} of the requester.
 */

Body of Frist Method:
{
    Preconditions.checkNotNull(refAttr, "refAttr must not be null");
    Preconditions.checkNotNull(attr, "attr must not be null");
    String refFormattedTags = TextUtils.join(";", refAttr.getTags());
    String cliFormattedTags = TextUtils.join(";", attr.getTags());
    if (refAttr.equals(sDefaultAttributes)) {
        return false;
    }
    return ((refAttr.getSystemUsage() == AudioAttributes.USAGE_UNKNOWN) || (attr.getSystemUsage() == refAttr.getSystemUsage())) && ((refAttr.getContentType() == AudioAttributes.CONTENT_TYPE_UNKNOWN) || (attr.getContentType() == refAttr.getContentType())) && ((refAttr.getAllFlags() == 0) || (attr.getAllFlags() != 0 && (attr.getAllFlags() & refAttr.getAllFlags()) == refAttr.getAllFlags())) && ((refFormattedTags.length() == 0) || refFormattedTags.equals(cliFormattedTags));
}
Body of Second Method:
{
    Preconditions.checkNotNull(refAttr, "refAttr must not be null");
    Preconditions.checkNotNull(attr, "attr must not be null");
    String refFormattedTags = TextUtils.join(";", refAttr.getTags());
    String cliFormattedTags = TextUtils.join(";", attr.getTags());
    if (refAttr.equals(DEFAULT_ATTRIBUTES)) {
        return false;
    }
    return ((refAttr.getSystemUsage() == AudioAttributes.USAGE_UNKNOWN) || (attr.getSystemUsage() == refAttr.getSystemUsage())) && ((refAttr.getContentType() == AudioAttributes.CONTENT_TYPE_UNKNOWN) || (attr.getContentType() == refAttr.getContentType())) && ((refAttr.getAllFlags() == 0) || (attr.getAllFlags() != 0 && (attr.getAllFlags() & refAttr.getAllFlags()) == refAttr.getAllFlags())) && ((refFormattedTags.length() == 0) || refFormattedTags.equals(cliFormattedTags));
}
------------------------
Find a silently evolved API code:android.view.Choreographer.getFrameDeadline:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns the frame deadline in {@link System#nanoTime()} timebase that it is allotted for the
 * frame to be completed. Client are expected to call this function from their frame callback
 * function. Calling this function from anywhere else will return an undefined value.
 *
 * @hide
 */

Body of Frist Method:
{
    return mLastVsyncEventData.frameDeadline;
}
Body of Second Method:
{
    return mLastVsyncEventData.preferredFrameTimeline().deadline;
}
------------------------
Find a silently evolved API code:android.database.sqlite.SQLiteConnectionPool.reconfigure:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Reconfigures the database configuration of the connection pool and all of its
 * connections.
 * <p>
 * Configuration changes are propagated down to connections immediately if
 * they are available or as soon as they are released.  This includes changes
 * that affect the size of the pool.
 * </p>
 *
 * @param configuration The new configuration.
 *
 * @throws IllegalStateException if the pool has been closed.
 */

Body of Frist Method:
{
    if (configuration == null) {
        throw new IllegalArgumentException("configuration must not be null.");
    }
    synchronized (mLock) {
        throwIfClosedLocked();
        boolean walModeChanged = ((configuration.openFlags ^ mConfiguration.openFlags) & SQLiteDatabase.ENABLE_WRITE_AHEAD_LOGGING) != 0;
        if (walModeChanged) {
            // because we need to close all but the primary connection first.
            if (!mAcquiredConnections.isEmpty()) {
                throw new IllegalStateException("Write Ahead Logging (WAL) mode cannot " + "be enabled or disabled while there are transactions in " + "progress.  Finish all transactions and release all active " + "database connections first.");
            }
            // Close all non-primary connections.  This should happen immediately
            // because none of them are in use.
            closeAvailableNonPrimaryConnectionsAndLogExceptionsLocked();
            assert mAvailableNonPrimaryConnections.isEmpty();
        }
        boolean foreignKeyModeChanged = configuration.foreignKeyConstraintsEnabled != mConfiguration.foreignKeyConstraintsEnabled;
        if (foreignKeyModeChanged) {
            // any acquired connections.
            if (!mAcquiredConnections.isEmpty()) {
                throw new IllegalStateException("Foreign Key Constraints cannot " + "be enabled or disabled while there are transactions in " + "progress.  Finish all transactions and release all active " + "database connections first.");
            }
        }
        // We should do in-place switching when transitioning from compatibility WAL
        // to rollback journal. Otherwise transient connection state will be lost
        boolean onlyCompatWalChanged = (mConfiguration.openFlags ^ configuration.openFlags) == SQLiteDatabase.ENABLE_LEGACY_COMPATIBILITY_WAL;
        if (!onlyCompatWalChanged && mConfiguration.openFlags != configuration.openFlags) {
            // because there can only be one connection open when we change WAL mode.
            if (walModeChanged) {
                closeAvailableConnectionsAndLogExceptionsLocked();
            }
            // Try to reopen the primary connection using the new open flags then
            // close and discard all existing connections.
            // This might throw if the database is corrupt or cannot be opened in
            // the new mode in which case existing connections will remain untouched.
            SQLiteConnection newPrimaryConnection = openConnectionLocked(configuration, true);
            closeAvailableConnectionsAndLogExceptionsLocked();
            discardAcquiredConnectionsLocked();
            mAvailablePrimaryConnection = newPrimaryConnection;
            mConfiguration.updateParametersFrom(configuration);
            setMaxConnectionPoolSizeLocked();
        } else {
            // Reconfigure the database connections in place.
            mConfiguration.updateParametersFrom(configuration);
            setMaxConnectionPoolSizeLocked();
            closeExcessConnectionsAndLogExceptionsLocked();
            reconfigureAllConnectionsLocked();
        }
        wakeConnectionWaitersLocked();
    }
}
Body of Second Method:
{
    if (configuration == null) {
        throw new IllegalArgumentException("configuration must not be null.");
    }
    synchronized (mLock) {
        throwIfClosedLocked();
        boolean isWalCurrentMode = mConfiguration.resolveJournalMode().equalsIgnoreCase(SQLiteDatabase.JOURNAL_MODE_WAL);
        boolean isWalNewMode = configuration.resolveJournalMode().equalsIgnoreCase(SQLiteDatabase.JOURNAL_MODE_WAL);
        boolean walModeChanged = isWalCurrentMode ^ isWalNewMode;
        if (walModeChanged) {
            // because we need to close all but the primary connection first.
            if (!mAcquiredConnections.isEmpty()) {
                throw new IllegalStateException("Write Ahead Logging (WAL) mode cannot " + "be enabled or disabled while there are transactions in " + "progress.  Finish all transactions and release all active " + "database connections first.");
            }
            // Close all non-primary connections.  This should happen immediately
            // because none of them are in use.
            closeAvailableNonPrimaryConnectionsAndLogExceptionsLocked();
            assert mAvailableNonPrimaryConnections.isEmpty();
        }
        boolean foreignKeyModeChanged = configuration.foreignKeyConstraintsEnabled != mConfiguration.foreignKeyConstraintsEnabled;
        if (foreignKeyModeChanged) {
            // any acquired connections.
            if (!mAcquiredConnections.isEmpty()) {
                throw new IllegalStateException("Foreign Key Constraints cannot " + "be enabled or disabled while there are transactions in " + "progress.  Finish all transactions and release all active " + "database connections first.");
            }
        }
        // We should do in-place switching when transitioning from compatibility WAL
        // to rollback journal. Otherwise transient connection state will be lost
        boolean onlyCompatWalChanged = (mConfiguration.openFlags ^ configuration.openFlags) == SQLiteDatabase.ENABLE_LEGACY_COMPATIBILITY_WAL;
        if (!onlyCompatWalChanged && mConfiguration.openFlags != configuration.openFlags) {
            // because there can only be one connection open when we change WAL mode.
            if (walModeChanged) {
                closeAvailableConnectionsAndLogExceptionsLocked();
            }
            // Try to reopen the primary connection using the new open flags then
            // close and discard all existing connections.
            // This might throw if the database is corrupt or cannot be opened in
            // the new mode in which case existing connections will remain untouched.
            SQLiteConnection newPrimaryConnection = openConnectionLocked(configuration, true);
            closeAvailableConnectionsAndLogExceptionsLocked();
            discardAcquiredConnectionsLocked();
            mAvailablePrimaryConnection = newPrimaryConnection;
            mConfiguration.updateParametersFrom(configuration);
            setMaxConnectionPoolSizeLocked();
        } else {
            // Reconfigure the database connections in place.
            mConfiguration.updateParametersFrom(configuration);
            setMaxConnectionPoolSizeLocked();
            closeExcessConnectionsAndLogExceptionsLocked();
            reconfigureAllConnectionsLocked();
        }
        wakeConnectionWaitersLocked();
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.nl80211.DeviceWiphyCapabilities.isChannelWidthSupported:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the support for channel bandwidth
 *
 * @param chWidth valid values from {@link ScanResult}'s {@code CHANNEL_WIDTH_}
 *
 * @return {@code true} if supported, {@code false} otherwise.
 */

Body of Frist Method:
{
    switch(chWidth) {
        case ScanResult.CHANNEL_WIDTH_20MHZ:
            return true;
        case ScanResult.CHANNEL_WIDTH_40MHZ:
            return (m80211nSupported || m80211acSupported || m80211axSupported);
        case ScanResult.CHANNEL_WIDTH_80MHZ:
            return (m80211acSupported || m80211axSupported);
        case ScanResult.CHANNEL_WIDTH_160MHZ:
            return mChannelWidth160MhzSupported;
        case ScanResult.CHANNEL_WIDTH_80MHZ_PLUS_MHZ:
            return mChannelWidth80p80MhzSupported;
        default:
            Log.e(TAG, "isChannelWidthSupported called with invalid channel width: " + chWidth);
    }
    return false;
}
Body of Second Method:
{
    switch(chWidth) {
        case ScanResult.CHANNEL_WIDTH_20MHZ:
            return true;
        case ScanResult.CHANNEL_WIDTH_40MHZ:
            return (m80211nSupported || m80211acSupported || m80211axSupported || m80211beSupported);
        case ScanResult.CHANNEL_WIDTH_80MHZ:
            return (m80211acSupported || m80211axSupported || m80211beSupported);
        case ScanResult.CHANNEL_WIDTH_160MHZ:
            return mChannelWidth160MhzSupported;
        case ScanResult.CHANNEL_WIDTH_80MHZ_PLUS_MHZ:
            return mChannelWidth80p80MhzSupported;
        case ScanResult.CHANNEL_WIDTH_320MHZ:
            return mChannelWidth320MhzSupported;
        default:
            Log.e(TAG, "isChannelWidthSupported called with invalid channel width: " + chWidth);
    }
    return false;
}
------------------------
Find a silently evolved API code:android.view.contentcapture.ContentCaptureContext.Builder.setExtras:COMMENT
Method Modifier: public      
Comment:/**
 * Sets extra options associated with this context.
 *
 * <p>It can be used to provide vendor-specific data that can be modified and examined.
 *
 * @param extras extra options.
 * @return this builder.
 *
 * @throws IllegalStateException if {@link #build()} was already called.
 */

Body of Frist Method:
{
    mExtras = Preconditions.checkNotNull(extras);
    throwIfDestroyed();
    return this;
}
Body of Second Method:
{
    mExtras = Objects.requireNonNull(extras);
    throwIfDestroyed();
    return this;
}
------------------------
Find a silently evolved API code:android.media.tv.tuner.filter.DownloadSettings.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Builds a {@link DownloadSettings} object.
 */

Body of Frist Method:
{
    return new DownloadSettings(mMainType, mDownloadId);
}
Body of Second Method:
{
    return new DownloadSettings(mMainType, mUseDownloadId, mDownloadId);
}
------------------------
Find a silently evolved API code:android.hardware.hdmi.HdmiDeviceInfo.writeToParcel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Serializes this object into a {@link Parcel}.
 *
 * @param dest The Parcel in which the object should be written.
 * @param flags Additional flags about how the object should be written. May be 0 or
 * {@link Parcelable#PARCELABLE_WRITE_RETURN_VALUE}.
 */

Body of Frist Method:
{
    dest.writeInt(mHdmiDeviceType);
    dest.writeInt(mPhysicalAddress);
    dest.writeInt(mPortId);
    switch(mHdmiDeviceType) {
        case HDMI_DEVICE_TYPE_CEC:
            dest.writeInt(mLogicalAddress);
            dest.writeInt(mDeviceType);
            dest.writeInt(mVendorId);
            dest.writeInt(mDevicePowerStatus);
            dest.writeString(mDisplayName);
            dest.writeInt(mHdmiCecVersion);
            break;
        case HDMI_DEVICE_TYPE_MHL:
            dest.writeInt(mDeviceId);
            dest.writeInt(mAdopterId);
            break;
        case HDMI_DEVICE_TYPE_INACTIVE:
        // flow through
        default:
    }
}
Body of Second Method:
{
    dest.writeInt(mHdmiDeviceType);
    dest.writeInt(mPhysicalAddress);
    dest.writeInt(mPortId);
    switch(mHdmiDeviceType) {
        case HDMI_DEVICE_TYPE_CEC:
            dest.writeInt(mLogicalAddress);
            dest.writeInt(mDeviceType);
            dest.writeInt(mVendorId);
            dest.writeInt(mDevicePowerStatus);
            dest.writeString(mDisplayName);
            dest.writeInt(mCecVersion);
            break;
        case HDMI_DEVICE_TYPE_MHL:
            dest.writeInt(mDeviceId);
            dest.writeInt(mAdopterId);
            break;
        case HDMI_DEVICE_TYPE_INACTIVE:
        // flow through
        default:
    }
}
------------------------
Find a silently evolved API code:android.app.ActivityOptions.makeCustomTaskAnimation:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Create an ActivityOptions specifying a custom animation to run when the activity in the
 * different task is displayed.
 *
 * @param context Who is defining this.  This is the application that the
 * animation resources will be loaded from.
 * @param enterResId A resource ID of the animation resource to use for
 * the incoming activity.  Use 0 for no animation.
 * @param exitResId A resource ID of the animation resource to use for
 * the outgoing activity.  Use 0 for no animation.
 * @param handler If <var>listener</var> is non-null this must be a valid
 * Handler on which to dispatch the callback; otherwise it should be null.
 * @param startedListener Optional OnAnimationStartedListener to find out when the
 * requested animation has started running.  If for some reason the animation
 * is not executed, the callback will happen immediately.
 * @param finishedListener Optional OnAnimationFinishedListener when the animation
 * has finished running.
 *
 * @return Returns a new ActivityOptions object that you can use to
 * supply these options as the options Bundle when starting an activity.
 * @hide
 */

Body of Frist Method:
{
    ActivityOptions opts = makeCustomAnimation(context, enterResId, exitResId, handler, startedListener, finishedListener);
    opts.mOverrideTaskTransition = true;
    return opts;
}
Body of Second Method:
{
    ActivityOptions opts = makeCustomAnimation(context, enterResId, exitResId, 0, handler, startedListener, finishedListener);
    opts.mOverrideTaskTransition = true;
    return opts;
}
------------------------
Find a silently evolved API code:android.telephony.ims.stub.ImsSmsImplBase.onSendSmsResultSuccess:COMMENT
Method Modifier: public      final       hidden      
Comment:/**
 * This method should be triggered by the IMS providers when an outgoing SMS message has been
 * sent successfully.
 *
 * @param token token provided in {@link #sendSms(int, int, String, String, boolean, byte[])}
 * @param messageRef the message reference, which may be 1 byte if it is in
 * {@link SmsMessage#FORMAT_3GPP} format (see TS.123.040) or 2 bytes if it is in
 * {@link SmsMessage#FORMAT_3GPP2} format (see 3GPP2 C.S0015-B).
 *
 * @throws RuntimeException if called before {@link #onReady()} is triggered or if the
 * connection to the framework is not available. If this happens attempting to send the SMS
 * should be aborted.
 */

Body of Frist Method:
{
    synchronized (mLock) {
        if (mListener == null) {
            throw new RuntimeException("Feature not ready.");
        }
        try {
            mListener.onSendSmsResult(token, messageRef, SEND_STATUS_OK, SmsManager.RESULT_ERROR_NONE, RESULT_NO_NETWORK_ERROR);
        } catch (RemoteException e) {
            e.rethrowFromSystemServer();
        }
    }
}
Body of Second Method:
{
    IImsSmsListener listener = null;
    synchronized (mLock) {
        listener = mListener;
    }
    if (listener == null) {
        throw new RuntimeException("Feature not ready.");
    }
    try {
        listener.onSendSmsResult(token, messageRef, SEND_STATUS_OK, SmsManager.RESULT_ERROR_NONE, RESULT_NO_NETWORK_ERROR);
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.media.EncoderProfiles.VideoProfile.getMediaType:COMMENT
Method Modifier: public      
Comment:/**
 * The media type of the video encoder being used for the video track
 * @see android.media.MediaFormat#KEY_MIME
 */

Body of Frist Method:
{
    if (codec == MediaRecorder.VideoEncoder.H263) {
        return MediaFormat.MIMETYPE_VIDEO_H263;
    } else if (codec == MediaRecorder.VideoEncoder.H264) {
        return MediaFormat.MIMETYPE_VIDEO_AVC;
    } else if (codec == MediaRecorder.VideoEncoder.MPEG_4_SP) {
        return MediaFormat.MIMETYPE_VIDEO_MPEG4;
    } else if (codec == MediaRecorder.VideoEncoder.VP8) {
        return MediaFormat.MIMETYPE_VIDEO_VP8;
    } else if (codec == MediaRecorder.VideoEncoder.HEVC) {
        return MediaFormat.MIMETYPE_VIDEO_HEVC;
    }
    // we should never be here
    throw new RuntimeException("Unknown codec");
}
Body of Second Method:
{
    if (codec == MediaRecorder.VideoEncoder.H263) {
        return MediaFormat.MIMETYPE_VIDEO_H263;
    } else if (codec == MediaRecorder.VideoEncoder.H264) {
        return MediaFormat.MIMETYPE_VIDEO_AVC;
    } else if (codec == MediaRecorder.VideoEncoder.MPEG_4_SP) {
        return MediaFormat.MIMETYPE_VIDEO_MPEG4;
    } else if (codec == MediaRecorder.VideoEncoder.VP8) {
        return MediaFormat.MIMETYPE_VIDEO_VP8;
    } else if (codec == MediaRecorder.VideoEncoder.HEVC) {
        return MediaFormat.MIMETYPE_VIDEO_HEVC;
    } else if (codec == MediaRecorder.VideoEncoder.VP9) {
        return MediaFormat.MIMETYPE_VIDEO_VP9;
    } else if (codec == MediaRecorder.VideoEncoder.DOLBY_VISION) {
        return MediaFormat.MIMETYPE_VIDEO_DOLBY_VISION;
    } else if (codec == MediaRecorder.VideoEncoder.AV1) {
        return MediaFormat.MIMETYPE_VIDEO_AV1;
    }
    // we should never be here
    throw new RuntimeException("Unknown codec");
}
------------------------
Find a silently evolved API code:android.widget.ProgressBar.onInitializeAccessibilityNodeInfoInternal:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    super.onInitializeAccessibilityNodeInfoInternal(info);
    if (!isIndeterminate()) {
        AccessibilityNodeInfo.RangeInfo rangeInfo = AccessibilityNodeInfo.RangeInfo.obtain(AccessibilityNodeInfo.RangeInfo.RANGE_TYPE_INT, getMin(), getMax(), getProgress());
        info.setRangeInfo(rangeInfo);
        info.setStateDescription(formatStateDescription(mProgress));
    }
}
Body of Second Method:
{
    super.onInitializeAccessibilityNodeInfoInternal(info);
    if (!isIndeterminate()) {
        AccessibilityNodeInfo.RangeInfo rangeInfo = AccessibilityNodeInfo.RangeInfo.obtain(AccessibilityNodeInfo.RangeInfo.RANGE_TYPE_INT, getMin(), getMax(), getProgress());
        info.setRangeInfo(rangeInfo);
    }
    // Only set the default state description when custom state descripton is null.
    if (getStateDescription() == null) {
        if (isIndeterminate()) {
            info.setStateDescription(getResources().getString(R.string.in_progress));
        } else {
            info.setStateDescription(formatStateDescription(mProgress));
        }
    }
}
------------------------
Find a silently evolved API code:android.media.tv.tuner.frontend.IsdbtFrontendSettings.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Builds a {@link IsdbtFrontendSettings} object.
 */

Body of Frist Method:
{
    return new IsdbtFrontendSettings(mFrequency, mModulation, mBandwidth, mMode, mCodeRate, mGuardInterval, mServiceAreaId);
}
Body of Second Method:
{
    return new IsdbtFrontendSettings(mFrequency, mBandwidth, mMode, mGuardInterval, mServiceAreaId, mLayerSettings, mPartialReceptionFlag);
}
------------------------
Find a silently evolved API code:android.view.inputmethod.CursorAnchorInfo.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * @return {@link CursorAnchorInfo} using parameters in this {@link Builder}.
 * @throws IllegalArgumentException if one or more positional parameters are specified but
 * the coordinate transformation matrix is not provided via {@link #setMatrix(Matrix)}.
 */

Body of Frist Method:
{
    if (!mMatrixInitialized) {
        // Coordinate transformation matrix is mandatory when at least one positional
        // parameter is specified.
        final boolean hasCharacterBounds = (mCharacterBoundsArrayBuilder != null && !mCharacterBoundsArrayBuilder.isEmpty());
        if (hasCharacterBounds || !Float.isNaN(mInsertionMarkerHorizontal) || !Float.isNaN(mInsertionMarkerTop) || !Float.isNaN(mInsertionMarkerBaseline) || !Float.isNaN(mInsertionMarkerBottom)) {
            throw new IllegalArgumentException("Coordinate transformation matrix is " + "required when positional parameters are specified.");
        }
    }
    return new CursorAnchorInfo(this);
}
Body of Second Method:
{
    if (!mMatrixInitialized) {
        // Coordinate transformation matrix is mandatory when at least one positional
        // parameter is specified.
        final boolean hasCharacterBounds = (mCharacterBoundsArrayBuilder != null && !mCharacterBoundsArrayBuilder.isEmpty());
        if (hasCharacterBounds || !Float.isNaN(mInsertionMarkerHorizontal) || !Float.isNaN(mInsertionMarkerTop) || !Float.isNaN(mInsertionMarkerBaseline) || !Float.isNaN(mInsertionMarkerBottom)) {
            throw new IllegalArgumentException("Coordinate transformation matrix is " + "required when positional parameters are specified.");
        }
    }
    return CursorAnchorInfo.create(this);
}
------------------------
Find a silently evolved API code:android.os.PowerComponents.Builder.setConsumedPowerForCustomComponent:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the amount of drain attributed to the specified custom drain type.
 *
 * @param componentId    The ID of the custom power component.
 * @param componentPower Amount of consumed power in mAh.
 */

Body of Frist Method:
{
    if (componentId >= BatteryConsumer.FIRST_CUSTOM_POWER_COMPONENT_ID && componentId < BatteryConsumer.LAST_CUSTOM_POWER_COMPONENT_ID) {
        try {
            mPowerComponentsMah[CUSTOM_POWER_COMPONENT_OFFSET + componentId] = componentPower;
        } catch (ArrayIndexOutOfBoundsException e) {
            throw new IllegalArgumentException("Unsupported custom power component ID: " + componentId);
        }
    } else {
        throw new IllegalArgumentException("Unsupported custom power component ID: " + componentId);
    }
    return this;
}
Body of Second Method:
{
    final int index = componentId - BatteryConsumer.FIRST_CUSTOM_POWER_COMPONENT_ID;
    if (index < 0 || index >= mData.layout.customPowerComponentCount) {
        throw new IllegalArgumentException("Unsupported custom power component ID: " + componentId);
    }
    mData.putDouble(mData.layout.firstCustomConsumedPowerColumn + index, componentPower);
    return this;
}
------------------------
Find a silently evolved API code:android.content.pm.SigningInfo.getApkContentsSigners:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the signing certificates used to sign the APK contents of this application.  Not
 * including any past signing certificates the package proved it is authorized to use.
 * <note>
 * This method should not be used unless {@link #hasMultipleSigners()} returns true,
 * indicating that {@link #getSigningCertificateHistory()} cannot be used, otherwise {@link
 * #getSigningCertificateHistory()} should be preferred.
 * </note>
 */

Body of Frist Method:
{
    return mSigningDetails.signatures;
}
Body of Second Method:
{
    return mSigningDetails.getSignatures();
}
------------------------
Find a silently evolved API code:android.telecom.PhoneAccount.capabilitiesToString:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Generates a string representation of a capabilities bitmask.
 *
 * @return String representation of the capabilities bitmask.
 * @hide
 */

Body of Frist Method:
{
    StringBuilder sb = new StringBuilder();
    if (hasCapabilities(CAPABILITY_SELF_MANAGED)) {
        sb.append("SelfManaged ");
    }
    if (hasCapabilities(CAPABILITY_SUPPORTS_VIDEO_CALLING)) {
        sb.append("SuppVideo ");
    }
    if (hasCapabilities(CAPABILITY_VIDEO_CALLING)) {
        sb.append("Video ");
    }
    if (hasCapabilities(CAPABILITY_VIDEO_CALLING_RELIES_ON_PRESENCE)) {
        sb.append("Presence ");
    }
    if (hasCapabilities(CAPABILITY_CALL_PROVIDER)) {
        sb.append("CallProvider ");
    }
    if (hasCapabilities(CAPABILITY_CALL_SUBJECT)) {
        sb.append("CallSubject ");
    }
    if (hasCapabilities(CAPABILITY_CONNECTION_MANAGER)) {
        sb.append("ConnectionMgr ");
    }
    if (hasCapabilities(CAPABILITY_EMERGENCY_CALLS_ONLY)) {
        sb.append("EmergOnly ");
    }
    if (hasCapabilities(CAPABILITY_MULTI_USER)) {
        sb.append("MultiUser ");
    }
    if (hasCapabilities(CAPABILITY_PLACE_EMERGENCY_CALLS)) {
        sb.append("PlaceEmerg ");
    }
    if (hasCapabilities(CAPABILITY_EMERGENCY_PREFERRED)) {
        sb.append("EmerPrefer ");
    }
    if (hasCapabilities(CAPABILITY_EMERGENCY_VIDEO_CALLING)) {
        sb.append("EmergVideo ");
    }
    if (hasCapabilities(CAPABILITY_SIM_SUBSCRIPTION)) {
        sb.append("SimSub ");
    }
    if (hasCapabilities(CAPABILITY_RTT)) {
        sb.append("Rtt");
    }
    if (hasCapabilities(CAPABILITY_ADHOC_CONFERENCE_CALLING)) {
        sb.append("AdhocConf");
    }
    if (hasCapabilities(CAPABILITY_CALL_COMPOSER)) {
        sb.append("CallComposer ");
    }
    return sb.toString();
}
Body of Second Method:
{
    StringBuilder sb = new StringBuilder();
    if (hasCapabilities(CAPABILITY_SELF_MANAGED)) {
        sb.append("SelfManaged ");
    }
    if (hasCapabilities(CAPABILITY_SUPPORTS_VIDEO_CALLING)) {
        sb.append("SuppVideo ");
    }
    if (hasCapabilities(CAPABILITY_VIDEO_CALLING)) {
        sb.append("Video ");
    }
    if (hasCapabilities(CAPABILITY_VIDEO_CALLING_RELIES_ON_PRESENCE)) {
        sb.append("Presence ");
    }
    if (hasCapabilities(CAPABILITY_CALL_PROVIDER)) {
        sb.append("CallProvider ");
    }
    if (hasCapabilities(CAPABILITY_CALL_SUBJECT)) {
        sb.append("CallSubject ");
    }
    if (hasCapabilities(CAPABILITY_CONNECTION_MANAGER)) {
        sb.append("ConnectionMgr ");
    }
    if (hasCapabilities(CAPABILITY_EMERGENCY_CALLS_ONLY)) {
        sb.append("EmergOnly ");
    }
    if (hasCapabilities(CAPABILITY_MULTI_USER)) {
        sb.append("MultiUser ");
    }
    if (hasCapabilities(CAPABILITY_PLACE_EMERGENCY_CALLS)) {
        sb.append("PlaceEmerg ");
    }
    if (hasCapabilities(CAPABILITY_EMERGENCY_PREFERRED)) {
        sb.append("EmerPrefer ");
    }
    if (hasCapabilities(CAPABILITY_EMERGENCY_VIDEO_CALLING)) {
        sb.append("EmergVideo ");
    }
    if (hasCapabilities(CAPABILITY_SIM_SUBSCRIPTION)) {
        sb.append("SimSub ");
    }
    if (hasCapabilities(CAPABILITY_RTT)) {
        sb.append("Rtt ");
    }
    if (hasCapabilities(CAPABILITY_ADHOC_CONFERENCE_CALLING)) {
        sb.append("AdhocConf ");
    }
    if (hasCapabilities(CAPABILITY_CALL_COMPOSER)) {
        sb.append("CallComposer ");
    }
    if (hasCapabilities(CAPABILITY_SUPPORTS_VOICE_CALLING_INDICATIONS)) {
        sb.append("SuppVoice ");
    }
    if (hasCapabilities(CAPABILITY_VOICE_CALLING_AVAILABLE)) {
        sb.append("Voice ");
    }
    return sb.toString();
}
------------------------
Find a silently evolved API code:android.app.trust.TrustManager.registerTrustListener:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Registers a listener for trust events.
 *
 * Requires the {@link android.Manifest.permission#TRUST_LISTENER} permission.
 */

Body of Frist Method:
{
    try {
        ITrustListener.Stub iTrustListener = new ITrustListener.Stub() {

            @Override
            public void onTrustChanged(boolean enabled, int userId, int flags) {
                Message m = mHandler.obtainMessage(MSG_TRUST_CHANGED, (enabled ? 1 : 0), userId, trustListener);
                if (flags != 0) {
                    m.getData().putInt(DATA_FLAGS, flags);
                }
                m.sendToTarget();
            }

            @Override
            public void onTrustManagedChanged(boolean managed, int userId) {
                mHandler.obtainMessage(MSG_TRUST_MANAGED_CHANGED, (managed ? 1 : 0), userId, trustListener).sendToTarget();
            }

            @Override
            public void onTrustError(CharSequence message) {
                Message m = mHandler.obtainMessage(MSG_TRUST_ERROR);
                m.getData().putCharSequence(DATA_MESSAGE, message);
                m.sendToTarget();
            }
        };
        mService.registerTrustListener(iTrustListener);
        mTrustListeners.put(trustListener, iTrustListener);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    try {
        ITrustListener.Stub iTrustListener = new ITrustListener.Stub() {

            @Override
            public void onTrustChanged(boolean enabled, int userId, int flags, List<String> trustGrantedMessages) {
                Message m = mHandler.obtainMessage(MSG_TRUST_CHANGED, (enabled ? 1 : 0), userId, trustListener);
                if (flags != 0) {
                    m.getData().putInt(DATA_FLAGS, flags);
                }
                m.getData().putCharSequenceArrayList(DATA_GRANTED_MESSAGES, (ArrayList) trustGrantedMessages);
                m.sendToTarget();
            }

            @Override
            public void onTrustManagedChanged(boolean managed, int userId) {
                mHandler.obtainMessage(MSG_TRUST_MANAGED_CHANGED, (managed ? 1 : 0), userId, trustListener).sendToTarget();
            }

            @Override
            public void onTrustError(CharSequence message) {
                Message m = mHandler.obtainMessage(MSG_TRUST_ERROR, trustListener);
                m.getData().putCharSequence(DATA_MESSAGE, message);
                m.sendToTarget();
            }
        };
        mService.registerTrustListener(iTrustListener);
        mTrustListeners.put(trustListener, iTrustListener);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.app.WindowConfiguration.updateFrom:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Copies the fields from delta into this Configuration object, keeping
 * track of which ones have changed. Any undefined fields in {@code delta}
 * are ignored and not copied in to the current Configuration.
 *
 * @return a bit mask of the changed fields, as per {@link #diff}
 * @hide
 */

Body of Frist Method:
{
    int changed = 0;
    // Only allow override if bounds is not empty
    if (!delta.mBounds.isEmpty() && !delta.mBounds.equals(mBounds)) {
        changed |= WINDOW_CONFIG_BOUNDS;
        setBounds(delta.mBounds);
    }
    if (delta.mAppBounds != null && !delta.mAppBounds.equals(mAppBounds)) {
        changed |= WINDOW_CONFIG_APP_BOUNDS;
        setAppBounds(delta.mAppBounds);
    }
    if (!delta.mMaxBounds.isEmpty() && !delta.mMaxBounds.equals(mMaxBounds)) {
        changed |= WINDOW_CONFIG_MAX_BOUNDS;
        setMaxBounds(delta.mMaxBounds);
    }
    if (delta.mWindowingMode != WINDOWING_MODE_UNDEFINED && mWindowingMode != delta.mWindowingMode) {
        changed |= WINDOW_CONFIG_WINDOWING_MODE;
        setWindowingMode(delta.mWindowingMode);
    }
    if (delta.mActivityType != ACTIVITY_TYPE_UNDEFINED && mActivityType != delta.mActivityType) {
        changed |= WINDOW_CONFIG_ACTIVITY_TYPE;
        setActivityType(delta.mActivityType);
    }
    if (delta.mAlwaysOnTop != ALWAYS_ON_TOP_UNDEFINED && mAlwaysOnTop != delta.mAlwaysOnTop) {
        changed |= WINDOW_CONFIG_ALWAYS_ON_TOP;
        setAlwaysOnTop(delta.mAlwaysOnTop);
    }
    if (delta.mRotation != ROTATION_UNDEFINED && delta.mRotation != mRotation) {
        changed |= WINDOW_CONFIG_ROTATION;
        setRotation(delta.mRotation);
    }
    if (delta.mDisplayWindowingMode != WINDOWING_MODE_UNDEFINED && mDisplayWindowingMode != delta.mDisplayWindowingMode) {
        changed |= WINDOW_CONFIG_DISPLAY_WINDOWING_MODE;
        setDisplayWindowingMode(delta.mDisplayWindowingMode);
    }
    return changed;
}
Body of Second Method:
{
    int changed = 0;
    // Only allow override if bounds is not empty
    if (!delta.mBounds.isEmpty() && !delta.mBounds.equals(mBounds)) {
        changed |= WINDOW_CONFIG_BOUNDS;
        setBounds(delta.mBounds);
    }
    if (delta.mAppBounds != null && !delta.mAppBounds.equals(mAppBounds)) {
        changed |= WINDOW_CONFIG_APP_BOUNDS;
        setAppBounds(delta.mAppBounds);
    }
    if (!delta.mMaxBounds.isEmpty() && !delta.mMaxBounds.equals(mMaxBounds)) {
        changed |= WINDOW_CONFIG_MAX_BOUNDS;
        setMaxBounds(delta.mMaxBounds);
    }
    if (delta.mWindowingMode != WINDOWING_MODE_UNDEFINED && mWindowingMode != delta.mWindowingMode) {
        changed |= WINDOW_CONFIG_WINDOWING_MODE;
        setWindowingMode(delta.mWindowingMode);
    }
    if (delta.mActivityType != ACTIVITY_TYPE_UNDEFINED && mActivityType != delta.mActivityType) {
        changed |= WINDOW_CONFIG_ACTIVITY_TYPE;
        setActivityType(delta.mActivityType);
    }
    if (delta.mAlwaysOnTop != ALWAYS_ON_TOP_UNDEFINED && mAlwaysOnTop != delta.mAlwaysOnTop) {
        changed |= WINDOW_CONFIG_ALWAYS_ON_TOP;
        setAlwaysOnTop(delta.mAlwaysOnTop);
    }
    if (delta.mRotation != ROTATION_UNDEFINED && delta.mRotation != mRotation) {
        changed |= WINDOW_CONFIG_ROTATION;
        setRotation(delta.mRotation);
    }
    if (delta.mDisplayWindowingMode != WINDOWING_MODE_UNDEFINED && mDisplayWindowingMode != delta.mDisplayWindowingMode) {
        changed |= WINDOW_CONFIG_DISPLAY_WINDOWING_MODE;
        setDisplayWindowingMode(delta.mDisplayWindowingMode);
    }
    if (delta.mDisplayRotation != ROTATION_UNDEFINED && delta.mDisplayRotation != mDisplayRotation) {
        changed |= WINDOW_CONFIG_DISPLAY_ROTATION;
        setDisplayRotation(delta.mDisplayRotation);
    }
    return changed;
}
------------------------
Find a silently evolved API code:android.accessibilityservice.AccessibilityServiceInfo.flagToString:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns the string representation of a flag. For example,
 * {@link #DEFAULT} is represented by the string DEFAULT.
 *
 * @param flag The flag.
 * @return The string representation.
 */

Body of Frist Method:
{
    switch(flag) {
        case DEFAULT:
            return "DEFAULT";
        case FLAG_INCLUDE_NOT_IMPORTANT_VIEWS:
            return "FLAG_INCLUDE_NOT_IMPORTANT_VIEWS";
        case FLAG_REQUEST_TOUCH_EXPLORATION_MODE:
            return "FLAG_REQUEST_TOUCH_EXPLORATION_MODE";
        case FLAG_SERVICE_HANDLES_DOUBLE_TAP:
            return "FLAG_SERVICE_HANDLES_DOUBLE_TAP";
        case FLAG_REQUEST_MULTI_FINGER_GESTURES:
            return "FLAG_REQUEST_MULTI_FINGER_GESTURES";
        case FLAG_REQUEST_2_FINGER_PASSTHROUGH:
            return "FLAG_REQUEST_2_FINGER_PASSTHROUGH";
        case FLAG_SEND_MOTION_EVENTS:
            return "FLAG_SEND_MOTION_EVENTS";
        case FLAG_REQUEST_ENHANCED_WEB_ACCESSIBILITY:
            return "FLAG_REQUEST_ENHANCED_WEB_ACCESSIBILITY";
        case FLAG_REPORT_VIEW_IDS:
            return "FLAG_REPORT_VIEW_IDS";
        case FLAG_REQUEST_FILTER_KEY_EVENTS:
            return "FLAG_REQUEST_FILTER_KEY_EVENTS";
        case FLAG_RETRIEVE_INTERACTIVE_WINDOWS:
            return "FLAG_RETRIEVE_INTERACTIVE_WINDOWS";
        case FLAG_ENABLE_ACCESSIBILITY_VOLUME:
            return "FLAG_ENABLE_ACCESSIBILITY_VOLUME";
        case FLAG_REQUEST_ACCESSIBILITY_BUTTON:
            return "FLAG_REQUEST_ACCESSIBILITY_BUTTON";
        case FLAG_REQUEST_FINGERPRINT_GESTURES:
            return "FLAG_REQUEST_FINGERPRINT_GESTURES";
        case FLAG_REQUEST_SHORTCUT_WARNING_DIALOG_SPOKEN_FEEDBACK:
            return "FLAG_REQUEST_SHORTCUT_WARNING_DIALOG_SPOKEN_FEEDBACK";
        default:
            return null;
    }
}
Body of Second Method:
{
    switch(flag) {
        case DEFAULT:
            return "DEFAULT";
        case FLAG_INCLUDE_NOT_IMPORTANT_VIEWS:
            return "FLAG_INCLUDE_NOT_IMPORTANT_VIEWS";
        case FLAG_REQUEST_TOUCH_EXPLORATION_MODE:
            return "FLAG_REQUEST_TOUCH_EXPLORATION_MODE";
        case FLAG_SERVICE_HANDLES_DOUBLE_TAP:
            return "FLAG_SERVICE_HANDLES_DOUBLE_TAP";
        case FLAG_REQUEST_MULTI_FINGER_GESTURES:
            return "FLAG_REQUEST_MULTI_FINGER_GESTURES";
        case FLAG_REQUEST_2_FINGER_PASSTHROUGH:
            return "FLAG_REQUEST_2_FINGER_PASSTHROUGH";
        case FLAG_SEND_MOTION_EVENTS:
            return "FLAG_SEND_MOTION_EVENTS";
        case FLAG_REQUEST_ENHANCED_WEB_ACCESSIBILITY:
            return "FLAG_REQUEST_ENHANCED_WEB_ACCESSIBILITY";
        case FLAG_REPORT_VIEW_IDS:
            return "FLAG_REPORT_VIEW_IDS";
        case FLAG_REQUEST_FILTER_KEY_EVENTS:
            return "FLAG_REQUEST_FILTER_KEY_EVENTS";
        case FLAG_RETRIEVE_INTERACTIVE_WINDOWS:
            return "FLAG_RETRIEVE_INTERACTIVE_WINDOWS";
        case FLAG_ENABLE_ACCESSIBILITY_VOLUME:
            return "FLAG_ENABLE_ACCESSIBILITY_VOLUME";
        case FLAG_REQUEST_ACCESSIBILITY_BUTTON:
            return "FLAG_REQUEST_ACCESSIBILITY_BUTTON";
        case FLAG_REQUEST_FINGERPRINT_GESTURES:
            return "FLAG_REQUEST_FINGERPRINT_GESTURES";
        case FLAG_REQUEST_SHORTCUT_WARNING_DIALOG_SPOKEN_FEEDBACK:
            return "FLAG_REQUEST_SHORTCUT_WARNING_DIALOG_SPOKEN_FEEDBACK";
        case FLAG_INPUT_METHOD_EDITOR:
            return "FLAG_INPUT_METHOD_EDITOR";
        default:
            return null;
    }
}
------------------------
Find a silently evolved API code:android.location.LocationRequest.getMinUpdateIntervalMillis:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the minimum update interval. If location updates are available faster than the
 * request interval then locations will only be updated if the minimum update interval has
 * expired since the last location update.
 *
 * <p class=note><strong>Note:</strong> Some allowance for jitter is already built into the
 * minimum update interval, so you need not worry about updates blocked simply because they
 * arrived a fraction of a second earlier than expected.
 *
 * @return the minimum update interval
 */

Body of Frist Method:
{
    if (mMinUpdateIntervalMillis == IMPLICIT_MIN_UPDATE_INTERVAL) {
        return (long) (mInterval * IMPLICIT_MIN_UPDATE_INTERVAL_FACTOR);
    } else {
        // interval or min update interval
        return min(mMinUpdateIntervalMillis, mInterval);
    }
}
Body of Second Method:
{
    if (mMinUpdateIntervalMillis == IMPLICIT_MIN_UPDATE_INTERVAL) {
        return (long) (mIntervalMillis * IMPLICIT_MIN_UPDATE_INTERVAL_FACTOR);
    } else {
        // interval or min update interval
        return min(mMinUpdateIntervalMillis, mIntervalMillis);
    }
}
------------------------
Find a silently evolved API code:android.content.res.TypedArray.getColorStateList:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the ColorStateList for the attribute at <var>index</var>.
 * The value may be either a single solid color or a reference to
 * a color or complex {@link android.content.res.ColorStateList}
 * description.
 * <p>
 * This method will return {@code null} if the attribute is not defined or
 * is not an integer color or color state list.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return ColorStateList for the attribute, or {@code null} if not
 * defined.
 * @throws RuntimeException if the attribute if the TypedArray has already
 * been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not an integer color or color state list.
 */

Body of Frist Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    final TypedValue value = mValue;
    if (getValueAt(index * STYLE_NUM_ENTRIES, value)) {
        if (value.type == TypedValue.TYPE_ATTRIBUTE) {
            throw new UnsupportedOperationException("Failed to resolve attribute at index " + index + ": " + value);
        }
        return mResources.loadColorStateList(value, value.resourceId, mTheme);
    }
    return null;
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    final TypedValue value = mValue;
    if (getValueAt(index * STYLE_NUM_ENTRIES, value)) {
        if (value.type == TypedValue.TYPE_ATTRIBUTE) {
            throw new UnsupportedOperationException("Failed to resolve attribute at index " + index + ": " + value + ", theme=" + mTheme);
        }
        return mResources.loadColorStateList(value, value.resourceId, mTheme);
    }
    return null;
}
------------------------
Find a silently evolved API code:android.telephony.ims.RcsClientConfiguration.writeToParcel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * {@link Parcelable#writeToParcel}
 */

Body of Frist Method:
{
    out.writeString(mRcsVersion);
    out.writeString(mRcsProfile);
    out.writeString(mClientVendor);
    out.writeString(mClientVersion);
}
Body of Second Method:
{
    out.writeString(mRcsVersion);
    out.writeString(mRcsProfile);
    out.writeString(mClientVendor);
    out.writeString(mClientVersion);
    out.writeBoolean(mRcsEnabledByUser);
}
------------------------
Find a silently evolved API code:android.os.Process.setArgV0:COMMENT
<android.os.Process: void setArgV0(String)>
public      static      final       native      hidden      ->public      static      hidden      
Method Modifier: public      static      final       native      hidden      
Method Modifier: Yes         Yes         Yes         Yes         Yes         
Method Updated:  Yes         Yes         No          No          Yes         
Comment:/**
 * Change this process's argv[0] parameter.  This can be useful to show
 * more descriptive information in things like the 'ps' command.
 *
 * @param text The new name of this process.
 *
 * {@hide}
 */

Body of Frist Method:

Body of Second Method:
{
    sArgV0 = text;
    setArgV0Native(text);
}
------------------------
Find a silently evolved API code:android.view.accessibility.AccessibilityRecord.getSource:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the {@link AccessibilityNodeInfo} of the event source.
 * <p>
 * <strong>Note:</strong> It is a client responsibility to recycle the received info
 * by calling {@link AccessibilityNodeInfo#recycle() AccessibilityNodeInfo#recycle()}
 * to avoid creating of multiple instances.
 * </p>
 * @return The info of the source.
 */

Body of Frist Method:
{
    enforceSealed();
    if ((mConnectionId == UNDEFINED) || (mSourceWindowId == AccessibilityWindowInfo.UNDEFINED_WINDOW_ID) || (AccessibilityNodeInfo.getAccessibilityViewId(mSourceNodeId) == AccessibilityNodeInfo.UNDEFINED_ITEM_ID)) {
        return null;
    }
    AccessibilityInteractionClient client = AccessibilityInteractionClient.getInstance();
    return client.findAccessibilityNodeInfoByAccessibilityId(mConnectionId, mSourceWindowId, mSourceNodeId, false, GET_SOURCE_PREFETCH_FLAGS, null);
}
Body of Second Method:
{
    return getSource(GET_SOURCE_PREFETCH_FLAGS);
}
------------------------
Find a silently evolved API code:android.widget.ScrollView.executeKeyEvent:COMMENT
Method Modifier: public      
Comment:/**
 * You can call this function yourself to have the scroll view perform
 * scrolling from a key event, just as if the event had been dispatched to
 * it by the view hierarchy.
 *
 * @param event The key event to execute.
 * @return Return true if the event was handled, else false.
 */

Body of Frist Method:
{
    mTempRect.setEmpty();
    if (!canScroll()) {
        if (isFocused() && event.getKeyCode() != KeyEvent.KEYCODE_BACK) {
            View currentFocused = findFocus();
            if (currentFocused == this)
                currentFocused = null;
            View nextFocused = FocusFinder.getInstance().findNextFocus(this, currentFocused, View.FOCUS_DOWN);
            return nextFocused != null && nextFocused != this && nextFocused.requestFocus(View.FOCUS_DOWN);
        }
        return false;
    }
    boolean handled = false;
    if (event.getAction() == KeyEvent.ACTION_DOWN) {
        switch(event.getKeyCode()) {
            case KeyEvent.KEYCODE_DPAD_UP:
                if (!event.isAltPressed()) {
                    handled = arrowScroll(View.FOCUS_UP);
                } else {
                    handled = fullScroll(View.FOCUS_UP);
                }
                break;
            case KeyEvent.KEYCODE_DPAD_DOWN:
                if (!event.isAltPressed()) {
                    handled = arrowScroll(View.FOCUS_DOWN);
                } else {
                    handled = fullScroll(View.FOCUS_DOWN);
                }
                break;
            case KeyEvent.KEYCODE_SPACE:
                pageScroll(event.isShiftPressed() ? View.FOCUS_UP : View.FOCUS_DOWN);
                break;
        }
    }
    return handled;
}
Body of Second Method:
{
    mTempRect.setEmpty();
    if (!canScroll()) {
        if (isFocused() && event.getKeyCode() != KeyEvent.KEYCODE_BACK && event.getKeyCode() != KeyEvent.KEYCODE_ESCAPE) {
            View currentFocused = findFocus();
            if (currentFocused == this)
                currentFocused = null;
            View nextFocused = FocusFinder.getInstance().findNextFocus(this, currentFocused, View.FOCUS_DOWN);
            return nextFocused != null && nextFocused != this && nextFocused.requestFocus(View.FOCUS_DOWN);
        }
        return false;
    }
    boolean handled = false;
    if (event.getAction() == KeyEvent.ACTION_DOWN) {
        switch(event.getKeyCode()) {
            case KeyEvent.KEYCODE_DPAD_UP:
                if (!event.isAltPressed()) {
                    handled = arrowScroll(View.FOCUS_UP);
                } else {
                    handled = fullScroll(View.FOCUS_UP);
                }
                break;
            case KeyEvent.KEYCODE_DPAD_DOWN:
                if (!event.isAltPressed()) {
                    handled = arrowScroll(View.FOCUS_DOWN);
                } else {
                    handled = fullScroll(View.FOCUS_DOWN);
                }
                break;
            case KeyEvent.KEYCODE_SPACE:
                pageScroll(event.isShiftPressed() ? View.FOCUS_UP : View.FOCUS_DOWN);
                break;
        }
    }
    return handled;
}
------------------------
Find a silently evolved API code:android.view.Surface.destroy:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Free all server-side state associated with this surface and
 * release this object's reference.  This method can only be
 * called from the process that created the service.
 * @hide
 */

Body of Frist Method:
{
    if (mNativeObject != 0) {
        nativeDestroy(mNativeObject);
    }
    release();
}
Body of Second Method:
{
    synchronized (mLock) {
        if (mNativeObject != 0) {
            nativeDestroy(mNativeObject);
        }
        release();
    }
}
------------------------
Find a silently evolved API code:android.window.ConfigurationHelper.shouldUpdateResources:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Returns {@code true} if the {@link android.content.res.Resources} associated with
 * a {@code token} needs to be updated.
 *
 * @param token A {@link Context#getActivityToken() activity token} or
 * {@link Context#getWindowContextToken() window context token}
 * @param config The original {@link Configuration}
 * @param newConfig The updated Configuration
 * @param displayChanged a flag to indicate there's a display change
 * @param configChanged a flag to indicate there's a Configuration change.
 *
 * @see ResourcesManager#updateResourcesForActivity(IBinder, Configuration, int)
 */

Body of Frist Method:
{
    // The configuration has not yet been initialized. We should update it.
    if (config == null) {
        return true;
    }
    // ResourcesKey.
    if (displayChanged) {
        return true;
    }
    // the override config also didn't change, then don't update the Resources
    if (!ResourcesManager.getInstance().isSameResourcesOverrideConfig(token, overrideConfig)) {
        return true;
    }
    // Resources to make WindowMetrics API report the updated result.
    if (shouldUpdateWindowMetricsBounds(config, newConfig)) {
        return true;
    }
    return configChanged == null ? config.diff(newConfig) != 0 : configChanged;
}
Body of Second Method:
{
    // The configuration has not yet been initialized. We should update it.
    if (config == null) {
        return true;
    }
    // ResourcesKey.
    if (displayChanged) {
        return true;
    }
    // the override config also didn't change, then don't update the Resources
    if (!ResourcesManager.getInstance().isSameResourcesOverrideConfig(token, overrideConfig)) {
        return true;
    }
    // Resources to make WindowMetrics API report the updated result.
    if (shouldUpdateWindowMetricsBounds(config, newConfig)) {
        return true;
    }
    // If the display rotation has changed, we also need to update resources.
    if (isDisplayRotationChanged(config, newConfig)) {
        return true;
    }
    return configChanged == null ? config.diff(newConfig) != 0 : configChanged;
}
------------------------
Find a silently evolved API code:android.nfc.cardemulation.CardEmulation.categoryAllowsForegroundPreference:COMMENT
Method Modifier: public      
Comment:/**
 * Returns whether the user has allowed AIDs registered in the
 * specified category to be handled by a service that is preferred
 * by the foreground application, instead of by a pre-configured default.
 *
 * Foreground applications can set such preferences using the
 * {@link #setPreferredService(Activity, ComponentName)} method.
 *
 * @param category The category, e.g. {@link #CATEGORY_PAYMENT}
 * @return whether AIDs in the category can be handled by a service
 * specified by the foreground app.
 */

Body of Frist Method:
{
    if (CATEGORY_PAYMENT.equals(category)) {
        boolean preferForeground = false;
        try {
            preferForeground = Settings.Secure.getInt(mContext.getContentResolver(), Settings.Secure.NFC_PAYMENT_FOREGROUND) != 0;
        } catch (SettingNotFoundException e) {
        }
        return preferForeground;
    } else {
        // Allowed for all other categories
        return true;
    }
}
Body of Second Method:
{
    if (CATEGORY_PAYMENT.equals(category)) {
        boolean preferForeground = false;
        try {
            preferForeground = Settings.Secure.getIntForUser(mContext.getContentResolver(), Settings.Secure.NFC_PAYMENT_FOREGROUND, UserHandle.myUserId()) != 0;
        } catch (SettingNotFoundException e) {
        }
        return preferForeground;
    } else {
        // Allowed for all other categories
        return true;
    }
}
------------------------
Find a silently evolved API code:android.telephony.ims.stub.ImsSmsImplBase.onSendSmsResult:COMMENT
Method Modifier: public      final       hidden      deprecated  
Comment:/**
 * This method should be triggered by the IMS providers to pass the result of the sent message
 * to the platform.
 *
 * @param token token provided in {@link #sendSms(int, int, String, String, boolean, byte[])}
 * @param messageRef the message reference, which may be 1 byte if it is in
 * {@link SmsMessage#FORMAT_3GPP} format (see TS.123.040) or 2 bytes if it is in
 * {@link SmsMessage#FORMAT_3GPP2} format (see 3GPP2 C.S0015-B).
 * @param status result of sending the SMS.
 * @param reason reason in case status is failure.
 *
 * @throws RuntimeException if called before {@link #onReady()} is triggered or if the
 * connection to the framework is not available. If this happens attempting to send the SMS
 * should be aborted.
 * @deprecated Use {@link #onSendSmsResultSuccess(int, int)} or
 * {@link #onSendSmsResultError(int, int, int, int, int)} to notify the framework of the SMS
 * send result.
 */

Body of Frist Method:
{
    synchronized (mLock) {
        if (mListener == null) {
            throw new RuntimeException("Feature not ready.");
        }
        try {
            mListener.onSendSmsResult(token, messageRef, status, reason, RESULT_NO_NETWORK_ERROR);
        } catch (RemoteException e) {
            e.rethrowFromSystemServer();
        }
    }
}
Body of Second Method:
{
    IImsSmsListener listener = null;
    synchronized (mLock) {
        listener = mListener;
    }
    if (listener == null) {
        throw new RuntimeException("Feature not ready.");
    }
    try {
        listener.onSendSmsResult(token, messageRef, status, reason, RESULT_NO_NETWORK_ERROR);
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.telephony.ims.stub.ImsSmsImplBase.onSmsReceived:COMMENT
Method Modifier: public      final       hidden      
Comment:/**
 * This method should be triggered by the IMS providers when there is an incoming message. The
 * platform will deliver the message to the messages database and notify the IMS provider of the
 * result by calling {@link #acknowledgeSms(int, int, int)}.
 *
 * This method must not be called before {@link #onReady()} is called or the call will fail. If
 * the platform is not available, {@link #acknowledgeSms(int, int, int)} will be called with the
 * {@link #DELIVER_STATUS_ERROR_GENERIC} result code.
 * @param token unique token generated by IMS providers that the platform will use to trigger
 * callbacks for this message.
 * @param format the format of the message.
 * @param pdu PDU representing the contents of the message.
 * @throws RuntimeException if called before {@link #onReady()} is triggered.
 */

Body of Frist Method:
{
    synchronized (mLock) {
        if (mListener == null) {
            throw new RuntimeException("Feature not ready.");
        }
        try {
            mListener.onSmsReceived(token, format, pdu);
        } catch (RemoteException e) {
            Log.e(LOG_TAG, "Can not deliver sms: " + e.getMessage());
            SmsMessage message = SmsMessage.createFromPdu(pdu, format);
            if (message != null && message.mWrappedSmsMessage != null) {
                acknowledgeSms(token, message.mWrappedSmsMessage.mMessageRef, DELIVER_STATUS_ERROR_GENERIC);
            } else {
                Log.w(LOG_TAG, "onSmsReceived: Invalid pdu entered.");
                acknowledgeSms(token, 0, DELIVER_STATUS_ERROR_GENERIC);
            }
        }
    }
}
Body of Second Method:
{
    IImsSmsListener listener = null;
    synchronized (mLock) {
        listener = mListener;
    }
    if (listener == null) {
        throw new RuntimeException("Feature not ready.");
    }
    try {
        listener.onSmsReceived(token, format, pdu);
    } catch (RemoteException e) {
        Log.e(LOG_TAG, "Can not deliver sms: " + e.getMessage());
        SmsMessage message = SmsMessage.createFromPdu(pdu, format);
        if (message != null && message.mWrappedSmsMessage != null) {
            acknowledgeSms(token, message.mWrappedSmsMessage.mMessageRef, DELIVER_STATUS_ERROR_GENERIC);
        } else {
            Log.w(LOG_TAG, "onSmsReceived: Invalid pdu entered.");
            acknowledgeSms(token, 0, DELIVER_STATUS_ERROR_GENERIC);
        }
    }
}
------------------------
Find a silently evolved API code:android.view.Choreographer.getVsyncId:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns the vsync id of the last frame callback. Client are expected to call
 * this function from their frame callback function to get the vsyncId and pass
 * it together with a buffer or transaction to the Surface Composer. Calling
 * this function from anywhere else will return an undefined value.
 *
 * @hide
 */

Body of Frist Method:
{
    return mLastVsyncEventData.id;
}
Body of Second Method:
{
    return mLastVsyncEventData.preferredFrameTimeline().vsyncId;
}
------------------------
Find a silently evolved API code:android.os.PowerComponents.Builder.setUsageDurationForCustomComponentMillis:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the amount of time used by the specified custom component.
 *
 * @param componentId                  The ID of the custom power component.
 * @param componentUsageDurationMillis Amount of time in milliseconds.
 */

Body of Frist Method:
{
    if (componentId < BatteryConsumer.FIRST_CUSTOM_POWER_COMPONENT_ID) {
        throw new IllegalArgumentException("Unsupported custom power component ID: " + componentId);
    }
    try {
        mUsageDurationsMs[CUSTOM_POWER_COMPONENT_OFFSET + componentId] = componentUsageDurationMillis;
    } catch (ArrayIndexOutOfBoundsException e) {
        throw new IllegalArgumentException("Unsupported custom power component ID: " + componentId);
    }
    return this;
}
Body of Second Method:
{
    final int index = componentId - BatteryConsumer.FIRST_CUSTOM_POWER_COMPONENT_ID;
    if (index < 0 || index >= mData.layout.customPowerComponentCount) {
        throw new IllegalArgumentException("Unsupported custom power component ID: " + componentId);
    }
    mData.putLong(mData.layout.firstCustomUsageDurationColumn + index, componentUsageDurationMillis);
    return this;
}
------------------------
Find a silently evolved API code:android.content.pm.Signature.areExactMatch:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Test if given {@link Signature} sets are exactly equal.
 *
 * @hide
 */

Body of Frist Method:
{
    return (a.length == b.length) && ArrayUtils.containsAll(a, b) && ArrayUtils.containsAll(b, a);
}
Body of Second Method:
{
    return (ArrayUtils.size(a) == ArrayUtils.size(b)) && ArrayUtils.containsAll(a, b) && ArrayUtils.containsAll(b, a);
}
------------------------
Find a silently evolved API code:android.os.AggregateBatteryConsumer.Builder.setConsumedPower:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the total power included in this aggregate.
 */

Body of Frist Method:
{
    mConsumedPowerMah = consumedPowerMah;
    return this;
}
Body of Second Method:
{
    mData.putDouble(COLUMN_INDEX_CONSUMED_POWER, consumedPowerMah);
    return this;
}
------------------------
Find a silently evolved API code:android.hardware.camera2.CaptureRequest.readFromParcel:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Expand this object from a Parcel.
 * Hidden since this breaks the immutability of CaptureRequest, but is
 * needed to receive CaptureRequests with aidl.
 *
 * @param in The parcel from which the object should be read
 * @hide
 */

Body of Frist Method:
{
    int physicalCameraCount = in.readInt();
    if (physicalCameraCount <= 0) {
        throw new RuntimeException("Physical camera count" + physicalCameraCount + " should always be positive");
    }
    // Always start with the logical camera id
    mLogicalCameraId = in.readString();
    mLogicalCameraSettings = new CameraMetadataNative();
    mLogicalCameraSettings.readFromParcel(in);
    setNativeInstance(mLogicalCameraSettings);
    mPhysicalCameraSettings.put(mLogicalCameraId, mLogicalCameraSettings);
    for (int i = 1; i < physicalCameraCount; i++) {
        String physicalId = in.readString();
        CameraMetadataNative physicalCameraSettings = new CameraMetadataNative();
        physicalCameraSettings.readFromParcel(in);
        mPhysicalCameraSettings.put(physicalId, physicalCameraSettings);
    }
    mIsReprocess = (in.readInt() == 0) ? false : true;
    mReprocessableSessionId = CameraCaptureSession.SESSION_ID_NONE;
    synchronized (mSurfacesLock) {
        mSurfaceSet.clear();
        Parcelable[] parcelableArray = in.readParcelableArray(Surface.class.getClassLoader());
        if (parcelableArray != null) {
            for (Parcelable p : parcelableArray) {
                Surface s = (Surface) p;
                mSurfaceSet.add(s);
            }
        }
        // Intentionally disallow java side readFromParcel to receive streamIdx/surfaceIdx
        // Since there is no good way to convert indexes back to Surface
        int streamSurfaceSize = in.readInt();
        if (streamSurfaceSize != 0) {
            throw new RuntimeException("Reading cached CaptureRequest is not supported");
        }
    }
}
Body of Second Method:
{
    int physicalCameraCount = in.readInt();
    if (physicalCameraCount <= 0) {
        throw new RuntimeException("Physical camera count" + physicalCameraCount + " should always be positive");
    }
    // Always start with the logical camera id
    mLogicalCameraId = in.readString();
    mLogicalCameraSettings = new CameraMetadataNative();
    mLogicalCameraSettings.readFromParcel(in);
    setNativeInstance(mLogicalCameraSettings);
    mPhysicalCameraSettings.put(mLogicalCameraId, mLogicalCameraSettings);
    for (int i = 1; i < physicalCameraCount; i++) {
        String physicalId = in.readString();
        CameraMetadataNative physicalCameraSettings = new CameraMetadataNative();
        physicalCameraSettings.readFromParcel(in);
        mPhysicalCameraSettings.put(physicalId, physicalCameraSettings);
    }
    mIsReprocess = (in.readInt() == 0) ? false : true;
    mReprocessableSessionId = CameraCaptureSession.SESSION_ID_NONE;
    synchronized (mSurfacesLock) {
        mSurfaceSet.clear();
        Parcelable[] parcelableArray = in.readParcelableArray(Surface.class.getClassLoader(), Surface.class);
        if (parcelableArray != null) {
            for (Parcelable p : parcelableArray) {
                Surface s = (Surface) p;
                mSurfaceSet.add(s);
            }
        }
        // Intentionally disallow java side readFromParcel to receive streamIdx/surfaceIdx
        // Since there is no good way to convert indexes back to Surface
        int streamSurfaceSize = in.readInt();
        if (streamSurfaceSize != 0) {
            throw new RuntimeException("Reading cached CaptureRequest is not supported");
        }
    }
    boolean hasUserTagStr = (in.readInt() == 1) ? true : false;
    if (hasUserTagStr) {
        mUserTag = in.readString();
    }
}
------------------------
Find a silently evolved API code:android.media.AudioDeviceInfo.convertDeviceTypeToInternalInputDevice:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return EXT_TO_INT_INPUT_DEVICE_MAPPING.get(deviceType, AudioSystem.DEVICE_NONE);
}
Body of Second Method:
{
    return convertDeviceTypeToInternalInputDevice(deviceType, "");
}
------------------------
Find a silently evolved API code:android.os.VibrationAttributes.getAudioUsage:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Return {@link AudioAttributes} usage equivalent to {@link #getUsage()}.
 * @return one of {@link AudioAttributes#SDK_USAGES} that represents {@link #getUsage()}
 * @hide
 */

Body of Frist Method:
{
    if (mOriginalAudioUsage != AudioAttributes.USAGE_UNKNOWN) {
        // Return same audio usage set in the Builder.
        return mOriginalAudioUsage;
    }
    // Return correct audio usage based on the vibration usage set in the Builder.
    switch(mUsage) {
        case USAGE_NOTIFICATION:
            return AudioAttributes.USAGE_NOTIFICATION;
        case USAGE_COMMUNICATION_REQUEST:
            return AudioAttributes.USAGE_NOTIFICATION_COMMUNICATION_REQUEST;
        case USAGE_RINGTONE:
            return AudioAttributes.USAGE_NOTIFICATION_RINGTONE;
        case USAGE_TOUCH:
            return AudioAttributes.USAGE_ASSISTANCE_SONIFICATION;
        case USAGE_ALARM:
            return AudioAttributes.USAGE_ALARM;
        default:
            return AudioAttributes.USAGE_UNKNOWN;
    }
}
Body of Second Method:
{
    if (mOriginalAudioUsage != AudioAttributes.USAGE_UNKNOWN) {
        // Return same audio usage set in the Builder.
        return mOriginalAudioUsage;
    }
    // Return correct audio usage based on the vibration usage set in the Builder.
    switch(mUsage) {
        case USAGE_NOTIFICATION:
            return AudioAttributes.USAGE_NOTIFICATION;
        case USAGE_COMMUNICATION_REQUEST:
            return AudioAttributes.USAGE_VOICE_COMMUNICATION;
        case USAGE_RINGTONE:
            return AudioAttributes.USAGE_NOTIFICATION_RINGTONE;
        case USAGE_TOUCH:
            return AudioAttributes.USAGE_ASSISTANCE_SONIFICATION;
        case USAGE_ALARM:
            return AudioAttributes.USAGE_ALARM;
        case USAGE_ACCESSIBILITY:
            return AudioAttributes.USAGE_ASSISTANCE_ACCESSIBILITY;
        case USAGE_MEDIA:
            return AudioAttributes.USAGE_MEDIA;
        default:
            return AudioAttributes.USAGE_UNKNOWN;
    }
}
------------------------
Find a silently evolved API code:android.os.UidBatteryConsumer.getTimeInStateMs:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns the amount of time in milliseconds this UID spent in the specified state.
 */

Body of Frist Method:
{
    switch(state) {
        case STATE_BACKGROUND:
            return mTimeInBackgroundMs;
        case STATE_FOREGROUND:
            return mTimeInForegroundMs;
    }
    return 0;
}
Body of Second Method:
{
    switch(state) {
        case STATE_BACKGROUND:
            return mData.getInt(COLUMN_INDEX_TIME_IN_BACKGROUND);
        case STATE_FOREGROUND:
            return mData.getInt(COLUMN_INDEX_TIME_IN_FOREGROUND);
    }
    return 0;
}
------------------------
Find a silently evolved API code:android.location.GnssMeasurementRequest.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Builds a {@link GnssMeasurementRequest} instance as specified by this builder.
 */

Body of Frist Method:
{
    return new GnssMeasurementRequest(mFullTracking, mCorrelationVectorOutputsEnabled);
}
Body of Second Method:
{
    return new GnssMeasurementRequest(mFullTracking, mCorrelationVectorOutputsEnabled, mIntervalMillis);
}
------------------------
Find a silently evolved API code:android.net.wifi.nl80211.DeviceWiphyCapabilities.writeToParcel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * implement Parcelable interface
 * |flags| is ignored.
 */

Body of Frist Method:
{
    out.writeBoolean(m80211nSupported);
    out.writeBoolean(m80211acSupported);
    out.writeBoolean(m80211axSupported);
    out.writeBoolean(mChannelWidth160MhzSupported);
    out.writeBoolean(mChannelWidth80p80MhzSupported);
    out.writeInt(mMaxNumberTxSpatialStreams);
    out.writeInt(mMaxNumberRxSpatialStreams);
}
Body of Second Method:
{
    out.writeBoolean(m80211nSupported);
    out.writeBoolean(m80211acSupported);
    out.writeBoolean(m80211axSupported);
    out.writeBoolean(m80211beSupported);
    out.writeBoolean(mChannelWidth160MhzSupported);
    out.writeBoolean(mChannelWidth80p80MhzSupported);
    out.writeBoolean(mChannelWidth320MhzSupported);
    out.writeInt(mMaxNumberTxSpatialStreams);
    out.writeInt(mMaxNumberRxSpatialStreams);
}
------------------------
Find a silently evolved API code:android.telephony.data.DataProfile.getWaitTime:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @return The required wait time in seconds after a successful UE initiated disconnect of a
 * given PDN connection before the device can send a new PDN connection request for that given
 * PDN.
 *
 * @hide
 */

Body of Frist Method:
{
    return mWaitTime;
}
Body of Second Method:
{
    if (mApnSetting != null) {
        return mApnSetting.getWaitTime();
    }
    return 0;
}
------------------------
Find a silently evolved API code:android.graphics.PixelFormat.formatToString:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    switch(format) {
        case UNKNOWN:
            return "UNKNOWN";
        case TRANSLUCENT:
            return "TRANSLUCENT";
        case TRANSPARENT:
            return "TRANSPARENT";
        case RGBA_8888:
            return "RGBA_8888";
        case RGBX_8888:
            return "RGBX_8888";
        case RGB_888:
            return "RGB_888";
        case RGB_565:
            return "RGB_565";
        case RGBA_5551:
            return "RGBA_5551";
        case RGBA_4444:
            return "RGBA_4444";
        case A_8:
            return "A_8";
        case L_8:
            return "L_8";
        case LA_88:
            return "LA_88";
        case RGB_332:
            return "RGB_332";
        case YCbCr_422_SP:
            return "YCbCr_422_SP";
        case YCbCr_420_SP:
            return "YCbCr_420_SP";
        case YCbCr_422_I:
            return "YCbCr_422_I";
        case RGBA_F16:
            return "RGBA_F16";
        case RGBA_1010102:
            return "RGBA_1010102";
        case HSV_888:
            return "HSV_888";
        case JPEG:
            return "JPEG";
        default:
            return Integer.toString(format);
    }
}
Body of Second Method:
{
    switch(format) {
        case UNKNOWN:
            return "UNKNOWN";
        case TRANSLUCENT:
            return "TRANSLUCENT";
        case TRANSPARENT:
            return "TRANSPARENT";
        case RGBA_8888:
            return "RGBA_8888";
        case RGBX_8888:
            return "RGBX_8888";
        case RGB_888:
            return "RGB_888";
        case RGB_565:
            return "RGB_565";
        case RGBA_5551:
            return "RGBA_5551";
        case RGBA_4444:
            return "RGBA_4444";
        case A_8:
            return "A_8";
        case L_8:
            return "L_8";
        case LA_88:
            return "LA_88";
        case RGB_332:
            return "RGB_332";
        case YCbCr_422_SP:
            return "YCbCr_422_SP";
        case YCbCr_420_SP:
            return "YCbCr_420_SP";
        case YCbCr_422_I:
            return "YCbCr_422_I";
        case RGBA_F16:
            return "RGBA_F16";
        case RGBA_1010102:
            return "RGBA_1010102";
        case HSV_888:
            return "HSV_888";
        case JPEG:
            return "JPEG";
        case R_8:
            return "R_8";
        default:
            return Integer.toString(format);
    }
}
------------------------
Find a silently evolved API code:android.inputmethodservice.ImsConfigurationTracker.onBindInput:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Called from {@link InputMethodService.InputMethodImpl#onBindInput()}
 */

Body of Frist Method:
{
    Preconditions.checkState(mInitialized, "onBindInput can be called only after onInitialize().");
    if (mLastKnownConfig == null && resources != null) {
        mLastKnownConfig = new Configuration(resources.getConfiguration());
    }
}
Body of Second Method:
{
    if (!mInitialized) {
        return;
    }
    if (mLastKnownConfig == null && resources != null) {
        mLastKnownConfig = new Configuration(resources.getConfiguration());
    }
}
------------------------
Find a silently evolved API code:android.app.admin.ManagedProfileProvisioningParams.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Combines all of the attributes that have been set on this {@code Builder}.
 *
 * @return a new {@link ManagedProfileProvisioningParams} object.
 */

Body of Frist Method:
{
    return new ManagedProfileProvisioningParams(mProfileAdminComponentName, mOwnerName, mProfileName, mAccountToMigrate, mLeaveAllSystemAppsEnabled, mOrganizationOwnedProvisioning, mKeepAccountMigrated);
}
Body of Second Method:
{
    return new ManagedProfileProvisioningParams(mProfileAdminComponentName, mOwnerName, mProfileName, mAccountToMigrate, mLeaveAllSystemAppsEnabled, mOrganizationOwnedProvisioning, mKeepingAccountOnMigration, mAdminExtras != null ? mAdminExtras : new PersistableBundle());
}
------------------------
Find a silently evolved API code:android.graphics.drawable.AdaptiveIconDrawable.updateLayerBoundsInternal:COMMENT
Method Modifier: private     
Comment:/**
 * Set the child layer bounds bigger than the view port size by {@link #DEFAULT_VIEW_PORT_SCALE}
 */

Body of Frist Method:
{
    int cX = bounds.width() / 2;
    int cY = bounds.height() / 2;
    for (int i = 0, count = mLayerState.N_CHILDREN; i < count; i++) {
        final ChildDrawable r = mLayerState.mChildren[i];
        if (r == null) {
            continue;
        }
        final Drawable d = r.mDrawable;
        if (d == null) {
            continue;
        }
        int insetWidth = (int) (bounds.width() / (DEFAULT_VIEW_PORT_SCALE * 2));
        int insetHeight = (int) (bounds.height() / (DEFAULT_VIEW_PORT_SCALE * 2));
        final Rect outRect = mTmpOutRect;
        outRect.set(cX - insetWidth, cY - insetHeight, cX + insetWidth, cY + insetHeight);
        d.setBounds(outRect);
    }
}
Body of Second Method:
{
    int cX = bounds.width() / 2;
    int cY = bounds.height() / 2;
    for (int i = 0, count = mLayerState.N_CHILDREN; i < count; i++) {
        final ChildDrawable r = mLayerState.mChildren[i];
        final Drawable d = r.mDrawable;
        if (d == null) {
            continue;
        }
        int insetWidth = (int) (bounds.width() / (DEFAULT_VIEW_PORT_SCALE * 2));
        int insetHeight = (int) (bounds.height() / (DEFAULT_VIEW_PORT_SCALE * 2));
        final Rect outRect = mTmpOutRect;
        outRect.set(cX - insetWidth, cY - insetHeight, cX + insetWidth, cY + insetHeight);
        d.setBounds(outRect);
    }
}
------------------------
Find a silently evolved API code:android.widget.ProgressBar.setStateDescription:COMMENT
Method Modifier: public      
Comment:/**
 * This function is called when an instance or subclass sets the state description. Once this
 * is called and the argument is not null, the app developer will be responsible for updating
 * state description when progress changes and the default state description will not be used.
 * App developers can restore the default behavior by setting the argument to null. If set
 * progress is called first and then setStateDescription is called, two state change events
 * will be merged by event throttling and we can still get the correct state description.
 *
 * @param stateDescription The state description.
 */

Body of Frist Method:
{
    mCustomStateDescription = stateDescription;
    if (stateDescription == null) {
        super.setStateDescription(formatStateDescription(mProgress));
    } else {
        super.setStateDescription(stateDescription);
    }
}
Body of Second Method:
{
    // Assume the previous custom state description is different from default state description.
    // Otherwise when the argument is null to restore the default state description, we will
    // send out a state description changed event even though the state description presented to
    // the user doesn't change. Since mStateDescription in View is private, we can't prevent
    // this event from sending out.
    super.setStateDescription(stateDescription);
}
------------------------
Find a silently evolved API code:android.location.LocationRequest.setInterval:COMMENT
Method Modifier: public      hidden      deprecated  
Comment:/**
 * @hide
 * @deprecated LocationRequests should be treated as immutable.
 */

Body of Frist Method:
{
    Preconditions.checkArgument(millis >= 0);
    // legacy clients don't know about the passive interval
    if (millis == PASSIVE_INTERVAL) {
        millis = Long.MAX_VALUE - 1;
    }
    mInterval = millis;
    if (mMinUpdateIntervalMillis > mInterval) {
        mMinUpdateIntervalMillis = mInterval;
    }
    return this;
}
Body of Second Method:
{
    Preconditions.checkArgument(millis >= 0);
    // legacy clients don't know about the passive interval
    if (millis == PASSIVE_INTERVAL) {
        millis = Long.MAX_VALUE - 1;
    }
    mIntervalMillis = millis;
    if (mMinUpdateIntervalMillis > mIntervalMillis) {
        mMinUpdateIntervalMillis = mIntervalMillis;
    }
    return this;
}
------------------------
Find a silently evolved API code:android.media.tv.tuner.filter.SectionSettingsWithSectionBits.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Builds a {@link SectionSettingsWithSectionBits} object.
 */

Body of Frist Method:
{
    return new SectionSettingsWithSectionBits(mMainType, mCrcEnabled, mIsRepeat, mIsRaw, mFilter, mMask, mMode);
}
Body of Second Method:
{
    return new SectionSettingsWithSectionBits(mMainType, mCrcEnabled, mIsRepeat, mIsRaw, mBitWidthOfLengthField, mFilter, mMask, mMode);
}
------------------------
Find a silently evolved API code:android.graphics.drawable.GradientDrawable.getColors:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the colors used to draw the gradient, or {@code null} if the
 * gradient is drawn using a single color or no colors.
 *
 * @return the colors used to draw the gradient, or {@code null}
 * @see #setColors(int[] colors)
 */

Body of Frist Method:
{
    return mGradientState.mGradientColors == null ? null : mGradientState.mGradientColors.clone();
}
Body of Second Method:
{
    if (mGradientState.mGradientColors == null) {
        return null;
    } else {
        int[] colors = new int[mGradientState.mGradientColors.length];
        for (int i = 0; i < mGradientState.mGradientColors.length; i++) {
            if (mGradientState.mGradientColors[i] != null) {
                colors[i] = mGradientState.mGradientColors[i].getDefaultColor();
            }
        }
        return colors;
    }
}
------------------------
Find a silently evolved API code:android.app.ActivityOptions.makeCustomAnimation:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Create an ActivityOptions specifying a custom animation to run when
 * the activity is displayed.
 *
 * @param context Who is defining this.  This is the application that the
 * animation resources will be loaded from.
 * @param enterResId A resource ID of the animation resource to use for
 * the incoming activity.  Use 0 for no animation.
 * @param exitResId A resource ID of the animation resource to use for
 * the outgoing activity.  Use 0 for no animation.
 * @param handler If <var>listener</var> is non-null this must be a valid
 * Handler on which to dispatch the callback; otherwise it should be null.
 * @param listener Optional OnAnimationStartedListener to find out when the
 * requested animation has started running.  If for some reason the animation
 * is not executed, the callback will happen immediately.
 * @return Returns a new ActivityOptions object that you can use to
 * supply these options as the options Bundle when starting an activity.
 * @hide
 */

Body of Frist Method:
{
    ActivityOptions opts = new ActivityOptions();
    opts.mPackageName = context.getPackageName();
    opts.mAnimationType = ANIM_CUSTOM;
    opts.mCustomEnterResId = enterResId;
    opts.mCustomExitResId = exitResId;
    opts.setOnAnimationStartedListener(handler, listener);
    return opts;
}
Body of Second Method:
{
    ActivityOptions opts = new ActivityOptions();
    opts.mPackageName = context.getPackageName();
    opts.mAnimationType = ANIM_CUSTOM;
    opts.mCustomEnterResId = enterResId;
    opts.mCustomExitResId = exitResId;
    opts.mCustomBackgroundColor = backgroundColor;
    opts.setOnAnimationStartedListener(handler, listener);
    return opts;
}
------------------------
Find a silently evolved API code:android.os.Process.setStartTimes:COMMENT
Method Modifier: public      static      final       hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    sStartElapsedRealtime = elapsedRealtime;
    sStartUptimeMillis = uptimeMillis;
}
Body of Second Method:
{
    sStartElapsedRealtime = elapsedRealtime;
    sStartUptimeMillis = uptimeMillis;
    sStartRequestedElapsedRealtime = startRequestedElapsedRealtime;
    sStartRequestedUptimeMillis = startRequestedUptime;
}
------------------------
Find a silently evolved API code:android.app.WindowConfiguration.hashCode:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    int result = 0;
    result = 31 * result + Objects.hashCode(mAppBounds);
    result = 31 * result + Objects.hashCode(mBounds);
    result = 31 * result + Objects.hashCode(mMaxBounds);
    result = 31 * result + mWindowingMode;
    result = 31 * result + mActivityType;
    result = 31 * result + mAlwaysOnTop;
    result = 31 * result + mRotation;
    result = 31 * result + mDisplayWindowingMode;
    return result;
}
Body of Second Method:
{
    int result = 0;
    result = 31 * result + Objects.hashCode(mAppBounds);
    result = 31 * result + Objects.hashCode(mBounds);
    result = 31 * result + Objects.hashCode(mMaxBounds);
    result = 31 * result + mWindowingMode;
    result = 31 * result + mActivityType;
    result = 31 * result + mAlwaysOnTop;
    result = 31 * result + mRotation;
    result = 31 * result + mDisplayWindowingMode;
    result = 31 * result + mDisplayRotation;
    return result;
}
------------------------
Find a silently evolved API code:android.view.Choreographer.FrameDisplayEventReceiver.onVsync:COMMENT
Method Modifier: public      
Comment:// for the internal display implicitly.

Body of Frist Method:
{
    try {
        if (Trace.isTagEnabled(Trace.TRACE_TAG_VIEW)) {
            Trace.traceBegin(Trace.TRACE_TAG_VIEW, "Choreographer#onVsync " + vsyncEventData.id);
        }
        // Post the vsync event to the Handler.
        // The idea is to prevent incoming vsync events from completely starving
        // the message queue.  If there are no messages in the queue with timestamps
        // earlier than the frame time, then the vsync event will be processed immediately.
        // Otherwise, messages that predate the vsync event will be handled first.
        long now = System.nanoTime();
        if (timestampNanos > now) {
            Log.w(TAG, "Frame time is " + ((timestampNanos - now) * 0.000001f) + " ms in the future!  Check that graphics HAL is generating vsync " + "timestamps using the correct timebase.");
            timestampNanos = now;
        }
        if (mHavePendingVsync) {
            Log.w(TAG, "Already have a pending vsync event.  There should only be " + "one at a time.");
        } else {
            mHavePendingVsync = true;
        }
        mTimestampNanos = timestampNanos;
        mFrame = frame;
        mLastVsyncEventData = vsyncEventData;
        Message msg = Message.obtain(mHandler, this);
        msg.setAsynchronous(true);
        mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_VIEW);
    }
}
Body of Second Method:
{
    try {
        if (Trace.isTagEnabled(Trace.TRACE_TAG_VIEW)) {
            Trace.traceBegin(Trace.TRACE_TAG_VIEW, "Choreographer#onVsync " + vsyncEventData.preferredFrameTimeline().vsyncId);
        }
        // Post the vsync event to the Handler.
        // The idea is to prevent incoming vsync events from completely starving
        // the message queue.  If there are no messages in the queue with timestamps
        // earlier than the frame time, then the vsync event will be processed immediately.
        // Otherwise, messages that predate the vsync event will be handled first.
        long now = System.nanoTime();
        if (timestampNanos > now) {
            Log.w(TAG, "Frame time is " + ((timestampNanos - now) * 0.000001f) + " ms in the future!  Check that graphics HAL is generating vsync " + "timestamps using the correct timebase.");
            timestampNanos = now;
        }
        if (mHavePendingVsync) {
            Log.w(TAG, "Already have a pending vsync event.  There should only be " + "one at a time.");
        } else {
            mHavePendingVsync = true;
        }
        mTimestampNanos = timestampNanos;
        mFrame = frame;
        mLastVsyncEventData = vsyncEventData;
        Message msg = Message.obtain(mHandler, this);
        msg.setAsynchronous(true);
        mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_VIEW);
    }
}
------------------------
Find a silently evolved API code:android.service.autofill.augmented.FillController.autofill:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Fills the activity with the provided values.
 *
 * <p>As a side effect, the {@link FillWindow} associated with the {@link FillResponse} will be
 * automatically {@link FillWindow#destroy() destroyed}.
 */

Body of Frist Method:
{
    Preconditions.checkNotNull(values);
    if (sDebug) {
        Log.d(TAG, "autofill() with " + values.size() + " values");
    }
    try {
        mProxy.autofill(values);
    } catch (RemoteException e) {
        e.rethrowAsRuntimeException();
    }
    final FillWindow fillWindow = mProxy.getFillWindow();
    if (fillWindow != null) {
        fillWindow.destroy();
    }
}
Body of Second Method:
{
    Objects.requireNonNull(values);
    if (sDebug) {
        Log.d(TAG, "autofill() with " + values.size() + " values");
    }
    try {
        mProxy.autofill(values);
    } catch (RemoteException e) {
        e.rethrowAsRuntimeException();
    }
    final FillWindow fillWindow = mProxy.getFillWindow();
    if (fillWindow != null) {
        fillWindow.destroy();
    }
}
------------------------
Find a silently evolved API code:android.window.PictureInPictureSurfaceTransaction.apply:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Applies {@link PictureInPictureSurfaceTransaction} to a given leash.
 */

Body of Frist Method:
{
    final Matrix matrix = surfaceTransaction.getMatrix();
    tx.setMatrix(surfaceControl, matrix, new float[9]);
    if (surfaceTransaction.mPosition != null) {
        tx.setPosition(surfaceControl, surfaceTransaction.mPosition.x, surfaceTransaction.mPosition.y);
    }
    if (surfaceTransaction.mWindowCrop != null) {
        tx.setWindowCrop(surfaceControl, surfaceTransaction.mWindowCrop);
    }
    if (surfaceTransaction.hasCornerRadiusSet()) {
        tx.setCornerRadius(surfaceControl, surfaceTransaction.mCornerRadius);
    }
    if (surfaceTransaction.mAlpha != NOT_SET) {
        tx.setAlpha(surfaceControl, surfaceTransaction.mAlpha);
    }
}
Body of Second Method:
{
    final Matrix matrix = surfaceTransaction.getMatrix();
    tx.setMatrix(surfaceControl, matrix, new float[9]);
    if (surfaceTransaction.mPosition != null) {
        tx.setPosition(surfaceControl, surfaceTransaction.mPosition.x, surfaceTransaction.mPosition.y);
    }
    if (surfaceTransaction.mWindowCrop != null) {
        tx.setWindowCrop(surfaceControl, surfaceTransaction.mWindowCrop);
    }
    if (surfaceTransaction.hasCornerRadiusSet()) {
        tx.setCornerRadius(surfaceControl, surfaceTransaction.mCornerRadius);
    }
    if (surfaceTransaction.hasShadowRadiusSet()) {
        tx.setShadowRadius(surfaceControl, surfaceTransaction.mShadowRadius);
    }
    if (surfaceTransaction.mAlpha != NOT_SET) {
        tx.setAlpha(surfaceControl, surfaceTransaction.mAlpha);
    }
}
------------------------
Find a silently evolved API code:android.hardware.biometrics.CryptoObject.getOpId:COMMENT
Method Modifier: public      final       hidden      
Comment:/**
 * @hide
 * @return the opId associated with this object or 0 if none
 */

Body of Frist Method:
{
    if (mCrypto == null) {
        return 0;
    } else if (mCrypto instanceof IdentityCredential) {
        return ((IdentityCredential) mCrypto).getCredstoreOperationHandle();
    }
    return AndroidKeyStoreProvider.getKeyStoreOperationHandle(mCrypto);
}
Body of Second Method:
{
    if (mCrypto == null) {
        return 0;
    } else if (mCrypto instanceof IdentityCredential) {
        return ((IdentityCredential) mCrypto).getCredstoreOperationHandle();
    } else if (mCrypto instanceof PresentationSession) {
        return ((PresentationSession) mCrypto).getCredstoreOperationHandle();
    }
    return AndroidKeyStoreProvider.getKeyStoreOperationHandle(mCrypto);
}
------------------------
Find a silently evolved API code:android.app.servertransaction.LaunchActivityItem.writeToParcel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Write from Parcel.
 */

Body of Frist Method:
{
    dest.writeTypedObject(mIntent, flags);
    dest.writeInt(mIdent);
    dest.writeTypedObject(mInfo, flags);
    dest.writeTypedObject(mCurConfig, flags);
    dest.writeTypedObject(mOverrideConfig, flags);
    dest.writeTypedObject(mCompatInfo, flags);
    dest.writeString(mReferrer);
    dest.writeStrongInterface(mVoiceInteractor);
    dest.writeInt(mProcState);
    dest.writeBundle(mState);
    dest.writePersistableBundle(mPersistentState);
    dest.writeTypedList(mPendingResults, flags);
    dest.writeTypedList(mPendingNewIntents, flags);
    dest.writeBundle(mActivityOptions != null ? mActivityOptions.toBundle() : null);
    dest.writeBoolean(mIsForward);
    dest.writeTypedObject(mProfilerInfo, flags);
    dest.writeStrongBinder(mAssistToken);
    dest.writeStrongInterface(mActivityClientController);
    dest.writeTypedObject(mFixedRotationAdjustments, flags);
    dest.writeStrongBinder(mShareableActivityToken);
    dest.writeBoolean(mLaunchedFromBubble);
}
Body of Second Method:
{
    dest.writeTypedObject(mIntent, flags);
    dest.writeInt(mIdent);
    dest.writeTypedObject(mInfo, flags);
    dest.writeTypedObject(mCurConfig, flags);
    dest.writeTypedObject(mOverrideConfig, flags);
    dest.writeTypedObject(mCompatInfo, flags);
    dest.writeString(mReferrer);
    dest.writeStrongInterface(mVoiceInteractor);
    dest.writeInt(mProcState);
    dest.writeBundle(mState);
    dest.writePersistableBundle(mPersistentState);
    dest.writeTypedList(mPendingResults, flags);
    dest.writeTypedList(mPendingNewIntents, flags);
    dest.writeBundle(mActivityOptions != null ? mActivityOptions.toBundle() : null);
    dest.writeBoolean(mIsForward);
    dest.writeTypedObject(mProfilerInfo, flags);
    dest.writeStrongBinder(mAssistToken);
    dest.writeStrongInterface(mActivityClientController);
    dest.writeStrongBinder(mShareableActivityToken);
    dest.writeBoolean(mLaunchedFromBubble);
    dest.writeStrongBinder(mTaskFragmentToken);
}
------------------------
Find a silently evolved API code:android.window.ClientWindowFrames.readFromParcel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Needed for AIDL out parameters.
 */

Body of Frist Method:
{
    frame.readFromParcel(in);
    displayFrame.readFromParcel(in);
    backdropFrame.readFromParcel(in);
}
Body of Second Method:
{
    frame.readFromParcel(in);
    displayFrame.readFromParcel(in);
    parentFrame.readFromParcel(in);
    isParentFrameClippedByDisplayCutout = in.readBoolean();
}
------------------------
Find a silently evolved API code:android.hardware.display.DisplayManager.getDisplays:COMMENT
Method Modifier: public      
Comment:/**
 * Gets all currently valid logical displays of the specified category.
 * <p>
 * When there are multiple displays in a category the returned displays are sorted
 * of preference.  For example, if the requested category is
 * {@link #DISPLAY_CATEGORY_PRESENTATION} and there are multiple presentation displays
 * then the displays are sorted so that the first display in the returned array
 * is the most preferred presentation display.  The application may simply
 * use the first display or allow the user to choose.
 * </p>
 *
 * @param category The requested display category or null to return all displays.
 * @return An array containing all displays sorted by order of preference.
 *
 * @see #DISPLAY_CATEGORY_PRESENTATION
 */

Body of Frist Method:
{
    final int[] displayIds = mGlobal.getDisplayIds();
    synchronized (mLock) {
        try {
            if (category == null) {
                addAllDisplaysLocked(mTempDisplays, displayIds);
            } else if (category.equals(DISPLAY_CATEGORY_PRESENTATION)) {
                addPresentationDisplaysLocked(mTempDisplays, displayIds, Display.TYPE_WIFI);
                addPresentationDisplaysLocked(mTempDisplays, displayIds, Display.TYPE_EXTERNAL);
                addPresentationDisplaysLocked(mTempDisplays, displayIds, Display.TYPE_OVERLAY);
                addPresentationDisplaysLocked(mTempDisplays, displayIds, Display.TYPE_VIRTUAL);
                addPresentationDisplaysLocked(mTempDisplays, displayIds, Display.TYPE_INTERNAL);
            }
            return mTempDisplays.toArray(new Display[mTempDisplays.size()]);
        } finally {
            mTempDisplays.clear();
        }
    }
}
Body of Second Method:
{
    boolean includeDisabledDisplays = (category != null && category.equals(DISPLAY_CATEGORY_ALL_INCLUDING_DISABLED));
    final int[] displayIds = mGlobal.getDisplayIds(includeDisabledDisplays);
    synchronized (mLock) {
        try {
            if (category != null && category.equals(DISPLAY_CATEGORY_PRESENTATION)) {
                addPresentationDisplaysLocked(mTempDisplays, displayIds, Display.TYPE_WIFI);
                addPresentationDisplaysLocked(mTempDisplays, displayIds, Display.TYPE_EXTERNAL);
                addPresentationDisplaysLocked(mTempDisplays, displayIds, Display.TYPE_OVERLAY);
                addPresentationDisplaysLocked(mTempDisplays, displayIds, Display.TYPE_VIRTUAL);
                addPresentationDisplaysLocked(mTempDisplays, displayIds, Display.TYPE_INTERNAL);
            } else if ((category == null || DISPLAY_CATEGORY_ALL_INCLUDING_DISABLED.equals(category))) {
                // All displays requested.
                addAllDisplaysLocked(mTempDisplays, displayIds);
            }
            return mTempDisplays.toArray(new Display[mTempDisplays.size()]);
        } finally {
            mTempDisplays.clear();
        }
    }
}
------------------------
Find a silently evolved API code:android.graphics.BitmapShader.createNativeInstance:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    mFilterFromPaint = filterFromPaint;
    return nativeCreate(nativeMatrix, mBitmap.getNativeInstance(), mTileX, mTileY, mFilterFromPaint);
}
Body of Second Method:
{
    boolean enableLinearFilter = mFilterMode == FILTER_MODE_LINEAR;
    if (mFilterMode == FILTER_MODE_DEFAULT) {
        mFilterFromPaint = filterFromPaint;
        enableLinearFilter = mFilterFromPaint;
    }
    mIsDirectSampled = mRequestDirectSampling;
    mRequestDirectSampling = false;
    return nativeCreate(nativeMatrix, mBitmap.getNativeInstance(), mTileX, mTileY, enableLinearFilter, mIsDirectSampled);
}
------------------------
Find a silently evolved API code:android.content.res.TypedArray.getDrawableForDensity:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Version of {@link #getDrawable(int)} that accepts an override density.
 * @hide
 */

Body of Frist Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    final TypedValue value = mValue;
    if (getValueAt(index * STYLE_NUM_ENTRIES, value)) {
        if (value.type == TypedValue.TYPE_ATTRIBUTE) {
            throw new UnsupportedOperationException("Failed to resolve attribute at index " + index + ": " + value);
        }
        if (density > 0) {
            // If the density is overridden, the value in the TypedArray will not reflect this.
            // Do a separate lookup of the resourceId with the density override.
            mResources.getValueForDensity(value.resourceId, density, value, true);
        }
        return mResources.loadDrawable(value, value.resourceId, density, mTheme);
    }
    return null;
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    final TypedValue value = mValue;
    if (getValueAt(index * STYLE_NUM_ENTRIES, value)) {
        if (value.type == TypedValue.TYPE_ATTRIBUTE) {
            throw new UnsupportedOperationException("Failed to resolve attribute at index " + index + ": " + value + ", theme=" + mTheme);
        }
        if (density > 0) {
            // If the density is overridden, the value in the TypedArray will not reflect this.
            // Do a separate lookup of the resourceId with the density override.
            mResources.getValueForDensity(value.resourceId, density, value, true);
        }
        return mResources.loadDrawable(value, value.resourceId, density, mTheme);
    }
    return null;
}
------------------------
Find a silently evolved API code:android.service.controls.Control.StatelessBuilder.build:COMMENT
Method Modifier: public      
Comment:/**
 * @return a valid {@link Control}
 */

Body of Frist Method:
{
    return new Control(mControlId, mDeviceType, mTitle, mSubtitle, mStructure, mZone, mAppIntent, mCustomIcon, mCustomColor, STATUS_UNKNOWN, ControlTemplate.NO_TEMPLATE, "");
}
Body of Second Method:
{
    return new Control(mControlId, mDeviceType, mTitle, mSubtitle, mStructure, mZone, mAppIntent, mCustomIcon, mCustomColor, STATUS_UNKNOWN, ControlTemplate.NO_TEMPLATE, "", true);
}
------------------------
Find a silently evolved API code:android.os.PowerComponents.getConsumedPowerForCustomComponent:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns the amount of drain attributed to the specified custom drain type.
 *
 * @param componentId The ID of the custom power component.
 * @return Amount of consumed power in mAh.
 */

Body of Frist Method:
{
    if (componentId >= BatteryConsumer.FIRST_CUSTOM_POWER_COMPONENT_ID && componentId < BatteryConsumer.LAST_CUSTOM_POWER_COMPONENT_ID) {
        try {
            return mPowerComponentsMah[CUSTOM_POWER_COMPONENT_OFFSET + componentId];
        } catch (ArrayIndexOutOfBoundsException e) {
            throw new IllegalArgumentException("Unsupported custom power component ID: " + componentId);
        }
    } else {
        throw new IllegalArgumentException("Unsupported custom power component ID: " + componentId);
    }
}
Body of Second Method:
{
    final int index = componentId - BatteryConsumer.FIRST_CUSTOM_POWER_COMPONENT_ID;
    if (index >= 0 && index < mData.layout.customPowerComponentCount) {
        return mData.getDouble(mData.layout.firstCustomConsumedPowerColumn + index);
    } else {
        throw new IllegalArgumentException("Unsupported custom power component ID: " + componentId);
    }
}
------------------------
Find a silently evolved API code:android.hardware.camera2.params.OutputConfiguration.equals:COMMENT
Method Modifier: public      
Comment:/**
 * Check if this {@link OutputConfiguration} is equal to another {@link OutputConfiguration}.
 *
 * <p>Two output configurations are only equal if and only if the underlying surfaces, surface
 * properties (width, height, format, dataspace) when the output configurations are created,
 * and all other configuration parameters are equal. </p>
 *
 * @return {@code true} if the objects were equal, {@code false} otherwise
 */

Body of Frist Method:
{
    if (obj == null) {
        return false;
    } else if (this == obj) {
        return true;
    } else if (obj instanceof OutputConfiguration) {
        final OutputConfiguration other = (OutputConfiguration) obj;
        if (mRotation != other.mRotation || !mConfiguredSize.equals(other.mConfiguredSize) || mConfiguredFormat != other.mConfiguredFormat || mSurfaceGroupId != other.mSurfaceGroupId || mSurfaceType != other.mSurfaceType || mIsDeferredConfig != other.mIsDeferredConfig || mIsShared != other.mIsShared || mConfiguredFormat != other.mConfiguredFormat || mConfiguredDataspace != other.mConfiguredDataspace || mConfiguredGenerationId != other.mConfiguredGenerationId || !Objects.equals(mPhysicalCameraId, other.mPhysicalCameraId) || mIsMultiResolution != other.mIsMultiResolution)
            return false;
        if (mSensorPixelModesUsed.size() != other.mSensorPixelModesUsed.size()) {
            return false;
        }
        for (int j = 0; j < mSensorPixelModesUsed.size(); j++) {
            if (mSensorPixelModesUsed.get(j) != other.mSensorPixelModesUsed.get(j)) {
                return false;
            }
        }
        int minLen = Math.min(mSurfaces.size(), other.mSurfaces.size());
        for (int i = 0; i < minLen; i++) {
            if (mSurfaces.get(i) != other.mSurfaces.get(i))
                return false;
        }
        return true;
    }
    return false;
}
Body of Second Method:
{
    if (obj == null) {
        return false;
    } else if (this == obj) {
        return true;
    } else if (obj instanceof OutputConfiguration) {
        final OutputConfiguration other = (OutputConfiguration) obj;
        if (mRotation != other.mRotation || !mConfiguredSize.equals(other.mConfiguredSize) || mConfiguredFormat != other.mConfiguredFormat || mSurfaceGroupId != other.mSurfaceGroupId || mSurfaceType != other.mSurfaceType || mIsDeferredConfig != other.mIsDeferredConfig || mIsShared != other.mIsShared || mConfiguredFormat != other.mConfiguredFormat || mConfiguredDataspace != other.mConfiguredDataspace || mConfiguredGenerationId != other.mConfiguredGenerationId || !Objects.equals(mPhysicalCameraId, other.mPhysicalCameraId) || mIsMultiResolution != other.mIsMultiResolution || mStreamUseCase != other.mStreamUseCase || mTimestampBase != other.mTimestampBase || mMirrorMode != other.mMirrorMode)
            return false;
        if (mSensorPixelModesUsed.size() != other.mSensorPixelModesUsed.size()) {
            return false;
        }
        for (int j = 0; j < mSensorPixelModesUsed.size(); j++) {
            if (mSensorPixelModesUsed.get(j) != other.mSensorPixelModesUsed.get(j)) {
                return false;
            }
        }
        int minLen = Math.min(mSurfaces.size(), other.mSurfaces.size());
        for (int i = 0; i < minLen; i++) {
            if (mSurfaces.get(i) != other.mSurfaces.get(i))
                return false;
        }
        if (mDynamicRangeProfile != other.mDynamicRangeProfile) {
            return false;
        }
        return true;
    }
    return false;
}
------------------------
Find a silently evolved API code:android.os.PowerComponents.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Creates a read-only object out of the Builder values.
 */

Body of Frist Method:
{
    return new PowerComponents(this);
}
Body of Second Method:
{
    mData.putDouble(mData.layout.totalConsumedPowerColumnIndex, getTotalPower());
    for (BatteryConsumer.Key[] keys : mData.layout.keys) {
        for (BatteryConsumer.Key key : keys) {
            if (key.mPowerModelColumnIndex != -1) {
                if (mData.getInt(key.mPowerModelColumnIndex) == POWER_MODEL_UNINITIALIZED) {
                    mData.putInt(key.mPowerModelColumnIndex, BatteryConsumer.POWER_MODEL_UNDEFINED);
                }
            }
        }
    }
    return new PowerComponents(this);
}
------------------------
Find a silently evolved API code:android.graphics.drawable.RippleShader.setNoisePhase:COMMENT
Method Modifier: public      
Comment:/**
 * Continuous offset used as noise phase.
 */

Body of Frist Method:
{
    setUniform("in_noisePhase", phase * 0.001f);
    // 
    // Keep in sync with: frameworks/base/libs/hwui/pipeline/skia/AnimatedDrawables.h
    // 
    final float turbulencePhase = phase;
    setUniform("in_turbulencePhase", turbulencePhase);
    final float scale = 1.5f;
    setUniform("in_tCircle1", new float[] { (float) (scale * 0.5 + (turbulencePhase * 0.01 * Math.cos(scale * 0.55))), (float) (scale * 0.5 + (turbulencePhase * 0.01 * Math.sin(scale * 0.55))) });
    setUniform("in_tCircle2", new float[] { (float) (scale * 0.2 + (turbulencePhase * -0.0066 * Math.cos(scale * 0.45))), (float) (scale * 0.2 + (turbulencePhase * -0.0066 * Math.sin(scale * 0.45))) });
    setUniform("in_tCircle3", new float[] { (float) (scale + (turbulencePhase * -0.0066 * Math.cos(scale * 0.35))), (float) (scale + (turbulencePhase * -0.0066 * Math.sin(scale * 0.35))) });
    final double rotation1 = turbulencePhase * PI_ROTATE_RIGHT + 1.7 * Math.PI;
    setUniform("in_tRotation1", new float[] { (float) Math.cos(rotation1), (float) Math.sin(rotation1) });
    final double rotation2 = turbulencePhase * PI_ROTATE_LEFT + 2 * Math.PI;
    setUniform("in_tRotation2", new float[] { (float) Math.cos(rotation2), (float) Math.sin(rotation2) });
    final double rotation3 = turbulencePhase * PI_ROTATE_RIGHT + 2.75 * Math.PI;
    setUniform("in_tRotation3", new float[] { (float) Math.cos(rotation3), (float) Math.sin(rotation3) });
}
Body of Second Method:
{
    setFloatUniform("in_noisePhase", phase * 0.001f);
    // 
    // Keep in sync with: frameworks/base/libs/hwui/pipeline/skia/AnimatedDrawables.h
    // 
    final float turbulencePhase = phase;
    setFloatUniform("in_turbulencePhase", turbulencePhase);
    final float scale = 1.5f;
    setFloatUniform("in_tCircle1", (float) (scale * 0.5 + (turbulencePhase * 0.01 * Math.cos(scale * 0.55))), (float) (scale * 0.5 + (turbulencePhase * 0.01 * Math.sin(scale * 0.55))));
    setFloatUniform("in_tCircle2", (float) (scale * 0.2 + (turbulencePhase * -0.0066 * Math.cos(scale * 0.45))), (float) (scale * 0.2 + (turbulencePhase * -0.0066 * Math.sin(scale * 0.45))));
    setFloatUniform("in_tCircle3", (float) (scale + (turbulencePhase * -0.0066 * Math.cos(scale * 0.35))), (float) (scale + (turbulencePhase * -0.0066 * Math.sin(scale * 0.35))));
    final double rotation1 = turbulencePhase * PI_ROTATE_RIGHT + 1.7 * Math.PI;
    setFloatUniform("in_tRotation1", (float) Math.cos(rotation1), (float) Math.sin(rotation1));
    final double rotation2 = turbulencePhase * PI_ROTATE_LEFT + 2 * Math.PI;
    setFloatUniform("in_tRotation2", (float) Math.cos(rotation2), (float) Math.sin(rotation2));
    final double rotation3 = turbulencePhase * PI_ROTATE_RIGHT + 2.75 * Math.PI;
    setFloatUniform("in_tRotation3", (float) Math.cos(rotation3), (float) Math.sin(rotation3));
}
------------------------
Find a silently evolved API code:android.webkit.WebViewLibraryLoader.reserveAddressSpaceInZygote:COMMENT
Method Modifier: default     static      hidden      
Comment:/**
 * Reserve space for the native library to be loaded into.
 */

Body of Frist Method:
{
    System.loadLibrary("webviewchromium_loader");
    boolean is64Bit = VMRuntime.getRuntime().is64Bit();
    // On 64-bit address space is really cheap and we can reserve 1GB which is plenty.
    // On 32-bit it's fairly scarce and we should keep it to a realistic number that
    // permits some future growth but doesn't hog space: we use 130MB which is roughly
    // what was calculated on older OS versions in practice.
    long addressSpaceToReserve = is64Bit ? 1 * 1024 * 1024 * 1024 : 130 * 1024 * 1024;
    sAddressSpaceReserved = nativeReserveAddressSpace(addressSpaceToReserve);
    if (sAddressSpaceReserved) {
        if (DEBUG) {
            Log.v(LOGTAG, "address space reserved: " + addressSpaceToReserve + " bytes");
        }
    } else {
        Log.e(LOGTAG, "reserving " + addressSpaceToReserve + " bytes of address space failed");
    }
}
Body of Second Method:
{
    System.loadLibrary("webviewchromium_loader");
    long addressSpaceToReserve;
    if (VMRuntime.getRuntime().is64Bit()) {
        // On 64-bit address space is really cheap and we can reserve 1GB which is plenty.
        addressSpaceToReserve = 1 * 1024 * 1024 * 1024;
    } else if (VMRuntime.getRuntime().vmInstructionSet().equals("arm")) {
        // On 32-bit the address space is fairly scarce, hence we should keep it to a realistic
        // number that permits some future growth but doesn't hog space. For ARM we use 130MB
        // which is roughly what was calculated on older OS versions. The size has been
        // growing gradually, but a few efforts have offset it back to the size close to the
        // original.
        addressSpaceToReserve = 130 * 1024 * 1024;
    } else {
        // The number below was obtained for a binary used for x86 emulators, allowing some
        // natural growth.
        addressSpaceToReserve = 190 * 1024 * 1024;
    }
    sAddressSpaceReserved = nativeReserveAddressSpace(addressSpaceToReserve);
    if (sAddressSpaceReserved) {
        if (DEBUG) {
            Log.v(LOGTAG, "address space reserved: " + addressSpaceToReserve + " bytes");
        }
    } else {
        Log.e(LOGTAG, "reserving " + addressSpaceToReserve + " bytes of address space failed");
    }
}
------------------------
Find a silently evolved API code:android.net.LocalSocket.createLocalSocketForAccept:COMMENT
Method Modifier: default     static      
Comment:/**
 * for use with LocalServerSocket.accept()
 */

Body of Frist Method:
{
    return createConnectedLocalSocket(impl, SOCKET_UNKNOWN);
}
Body of Second Method:
{
    LocalSocket socket = new LocalSocket(impl, SOCKET_UNKNOWN);
    socket.checkConnected();
    return socket;
}
------------------------
Find a silently evolved API code:android.hardware.usb.UsbDeviceConnection.open:COMMENT
Method Modifier: default     
Comment:/* package */

Body of Frist Method:
{
    mContext = context.getApplicationContext();
    synchronized (mLock) {
        boolean wasOpened = native_open(name, pfd.getFileDescriptor());
        if (wasOpened) {
            mCloseGuard.open("close");
        }
        return wasOpened;
    }
}
Body of Second Method:
{
    mContext = context.getApplicationContext();
    synchronized (mLock) {
        boolean wasOpened = native_open(name, pfd.getFileDescriptor());
        if (wasOpened) {
            mCloseGuard.open("UsbDeviceConnection.close");
        }
        return wasOpened;
    }
}
------------------------
Find a silently evolved API code:android.view.InsetsSource.equals:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @param excludeInvisibleImeFrames If {@link InsetsState#ITYPE_IME} frames should be ignored
 * when IME is not visible.
 */

Body of Frist Method:
{
    if (this == o)
        return true;
    if (o == null || getClass() != o.getClass())
        return false;
    InsetsSource that = (InsetsSource) o;
    if (mType != that.mType)
        return false;
    if (mVisible != that.mVisible)
        return false;
    if (excludeInvisibleImeFrames && !mVisible && mType == ITYPE_IME)
        return true;
    if (!Objects.equals(mVisibleFrame, that.mVisibleFrame))
        return false;
    return mFrame.equals(that.mFrame);
}
Body of Second Method:
{
    if (this == o)
        return true;
    if (o == null || getClass() != o.getClass())
        return false;
    InsetsSource that = (InsetsSource) o;
    if (mType != that.mType)
        return false;
    if (mVisible != that.mVisible)
        return false;
    if (excludeInvisibleImeFrames && !mVisible && mType == ITYPE_IME)
        return true;
    if (!Objects.equals(mVisibleFrame, that.mVisibleFrame))
        return false;
    if (mInsetsRoundedCornerFrame != that.mInsetsRoundedCornerFrame)
        return false;
    return mFrame.equals(that.mFrame);
}
------------------------
Find a silently evolved API code:android.app.WindowConfiguration.readFromParcel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    mBounds.readFromParcel(source);
    mAppBounds = source.readTypedObject(Rect.CREATOR);
    mMaxBounds.readFromParcel(source);
    mWindowingMode = source.readInt();
    mActivityType = source.readInt();
    mAlwaysOnTop = source.readInt();
    mRotation = source.readInt();
    mDisplayWindowingMode = source.readInt();
}
Body of Second Method:
{
    mBounds.readFromParcel(source);
    mAppBounds = source.readTypedObject(Rect.CREATOR);
    mMaxBounds.readFromParcel(source);
    mWindowingMode = source.readInt();
    mActivityType = source.readInt();
    mAlwaysOnTop = source.readInt();
    mRotation = source.readInt();
    mDisplayWindowingMode = source.readInt();
    mDisplayRotation = source.readInt();
}
------------------------
Find a silently evolved API code:android.content.BroadcastReceiver.PendingResult.finish:COMMENT
Method Modifier: public      final       
Comment:/**
 * Finish the broadcast.  The current result will be sent and the
 * next broadcast will proceed.
 */

Body of Frist Method:
{
    if (mType == TYPE_COMPONENT) {
        final IActivityManager mgr = ActivityManager.getService();
        if (QueuedWork.hasPendingWork()) {
            // If this is a broadcast component, we need to make sure any
            // queued work is complete before telling AM we are done, so
            // we don't have our process killed before that.  We now know
            // there is pending work; put another piece of work at the end
            // of the list to finish the broadcast, so we don't block this
            // thread (which may be the main thread) to have it finished.
            // 
            // Note that we don't need to use QueuedWork.addFinisher() with the
            // runnable, since we know the AM is waiting for us until the
            // executor gets to it.
            QueuedWork.queue(new Runnable() {

                @Override
                public void run() {
                    if (ActivityThread.DEBUG_BROADCAST)
                        Slog.i(ActivityThread.TAG, "Finishing broadcast after work to component " + mToken);
                    sendFinished(mgr);
                }
            }, false);
        } else {
            if (ActivityThread.DEBUG_BROADCAST)
                Slog.i(ActivityThread.TAG, "Finishing broadcast to component " + mToken);
            sendFinished(mgr);
        }
    } else if (mOrderedHint && mType != TYPE_UNREGISTERED) {
        if (ActivityThread.DEBUG_BROADCAST)
            Slog.i(ActivityThread.TAG, "Finishing broadcast to " + mToken);
        final IActivityManager mgr = ActivityManager.getService();
        sendFinished(mgr);
    }
}
Body of Second Method:
{
    if (Trace.isTagEnabled(Trace.TRACE_TAG_ACTIVITY_MANAGER)) {
        Trace.traceCounter(Trace.TRACE_TAG_ACTIVITY_MANAGER, "PendingResult#finish#ClassName:" + mReceiverClassName, 1);
    }
    if (mType == TYPE_COMPONENT) {
        final IActivityManager mgr = ActivityManager.getService();
        if (QueuedWork.hasPendingWork()) {
            // If this is a broadcast component, we need to make sure any
            // queued work is complete before telling AM we are done, so
            // we don't have our process killed before that.  We now know
            // there is pending work; put another piece of work at the end
            // of the list to finish the broadcast, so we don't block this
            // thread (which may be the main thread) to have it finished.
            // 
            // Note that we don't need to use QueuedWork.addFinisher() with the
            // runnable, since we know the AM is waiting for us until the
            // executor gets to it.
            QueuedWork.queue(new Runnable() {

                @Override
                public void run() {
                    if (ActivityThread.DEBUG_BROADCAST)
                        Slog.i(ActivityThread.TAG, "Finishing broadcast after work to component " + mToken);
                    sendFinished(mgr);
                }
            }, false);
        } else {
            if (ActivityThread.DEBUG_BROADCAST)
                Slog.i(ActivityThread.TAG, "Finishing broadcast to component " + mToken);
            sendFinished(mgr);
        }
    } else if (mOrderedHint && mType != TYPE_UNREGISTERED) {
        if (ActivityThread.DEBUG_BROADCAST)
            Slog.i(ActivityThread.TAG, "Finishing broadcast to " + mToken);
        final IActivityManager mgr = ActivityManager.getService();
        sendFinished(mgr);
    }
}
------------------------
Find a silently evolved API code:android.location.LocationRequest.createFromDeprecatedProvider:COMMENT
Method Modifier: public      static      hidden      deprecated  
Comment:/**
 * @hide
 * @deprecated Use the Builder to construct new LocationRequests.
 */

Body of Frist Method:
{
    Preconditions.checkArgument(provider != null, "invalid null provider");
    if (intervalMillis < 0) {
        intervalMillis = 0;
    } else if (intervalMillis == PASSIVE_INTERVAL) {
        intervalMillis = Long.MAX_VALUE - 1;
    }
    if (minUpdateDistanceMeters < 0) {
        minUpdateDistanceMeters = 0;
    }
    int quality;
    if (LocationManager.PASSIVE_PROVIDER.equals(provider)) {
        quality = POWER_NONE;
    } else if (LocationManager.GPS_PROVIDER.equals(provider)) {
        quality = QUALITY_HIGH_ACCURACY;
    } else {
        quality = POWER_LOW;
    }
    return new LocationRequest.Builder(intervalMillis).setMinUpdateIntervalMillis(intervalMillis).setMinUpdateDistanceMeters(minUpdateDistanceMeters).setMaxUpdates(singleShot ? 1 : Integer.MAX_VALUE).build().setProvider(provider).setQuality(quality);
}
Body of Second Method:
{
    Preconditions.checkArgument(provider != null, "invalid null provider");
    if (intervalMillis < 0) {
        intervalMillis = 0;
    } else if (intervalMillis == PASSIVE_INTERVAL) {
        intervalMillis = Long.MAX_VALUE - 1;
    }
    if (minUpdateDistanceMeters < 0) {
        minUpdateDistanceMeters = 0;
    }
    int quality;
    if (LocationManager.PASSIVE_PROVIDER.equals(provider)) {
        quality = POWER_NONE;
    } else if (LocationManager.GPS_PROVIDER.equals(provider)) {
        quality = QUALITY_HIGH_ACCURACY;
    } else {
        quality = QUALITY_BALANCED_POWER_ACCURACY;
    }
    return new LocationRequest.Builder(intervalMillis).setMinUpdateIntervalMillis(intervalMillis).setMinUpdateDistanceMeters(minUpdateDistanceMeters).setMaxUpdates(singleShot ? 1 : Integer.MAX_VALUE).build().setProvider(provider).setQuality(quality);
}
------------------------
Find a silently evolved API code:android.hardware.hdmi.HdmiDeviceInfo.getCecVersion:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns the CEC version the device supports.
 *
 * @hide
 */

Body of Frist Method:
{
    return mHdmiCecVersion;
}
Body of Second Method:
{
    return mCecVersion;
}
------------------------
Find a silently evolved API code:android.util.SparseDoubleArray.get:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Gets the double mapped from the specified key, or <code>0</code>
 * if no such mapping has been made.
 */

Body of Frist Method:
{
    final int index = mValues.indexOfKey(key);
    if (index < 0) {
        return 0.0d;
    }
    return valueAt(index);
}
Body of Second Method:
{
    return get(key, 0);
}
------------------------
Find a silently evolved API code:android.graphics.RuntimeShader.createNativeInstance:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return nativeCreateShader(mNativeInstanceRuntimeShaderBuilder, nativeMatrix, mIsOpaque);
}
Body of Second Method:
{
    return nativeCreateShader(mNativeInstanceRuntimeShaderBuilder, nativeMatrix);
}
------------------------
Find a silently evolved API code:android.net.wifi.nl80211.DeviceWiphyCapabilities.setWifiStandardSupport:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Set the IEEE 802.11 standard support
 *
 * @param standard the IEEE 802.11 standard to set its support.
 * valid values from {@link ScanResult}'s {@code WIFI_STANDARD_}
 * @param support {@code true} if supported, {@code false} otherwise.
 */

Body of Frist Method:
{
    switch(standard) {
        case ScanResult.WIFI_STANDARD_11N:
            m80211nSupported = support;
            break;
        case ScanResult.WIFI_STANDARD_11AC:
            m80211acSupported = support;
            break;
        case ScanResult.WIFI_STANDARD_11AX:
            m80211axSupported = support;
            break;
        default:
            Log.e(TAG, "setWifiStandardSupport called with invalid standard: " + standard);
    }
}
Body of Second Method:
{
    switch(standard) {
        case ScanResult.WIFI_STANDARD_11N:
            m80211nSupported = support;
            break;
        case ScanResult.WIFI_STANDARD_11AC:
            m80211acSupported = support;
            break;
        case ScanResult.WIFI_STANDARD_11AX:
            m80211axSupported = support;
            break;
        case ScanResult.WIFI_STANDARD_11BE:
            m80211beSupported = support;
            break;
        default:
            Log.e(TAG, "setWifiStandardSupport called with invalid standard: " + standard);
    }
}
------------------------
Find a silently evolved API code:android.database.sqlite.SQLiteConnectionPool.dump:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Dumps debugging information about this connection pool.
 *
 * @param printer The printer to receive the dump, not null.
 * @param verbose True to dump more verbose information.
 */

Body of Frist Method:
{
    Printer indentedPrinter = PrefixPrinter.create(printer, "    ");
    synchronized (mLock) {
        if (directories != null) {
            directories.add(new File(mConfiguration.path).getParent());
        }
        boolean isCompatibilityWalEnabled = mConfiguration.isLegacyCompatibilityWalEnabled();
        printer.println("Connection pool for " + mConfiguration.path + ":");
        printer.println("  Open: " + mIsOpen);
        printer.println("  Max connections: " + mMaxConnectionPoolSize);
        printer.println("  Total execution time: " + mTotalExecutionTimeCounter);
        printer.println("  Configuration: openFlags=" + mConfiguration.openFlags + ", isLegacyCompatibilityWalEnabled=" + isCompatibilityWalEnabled + ", journalMode=" + TextUtils.emptyIfNull(mConfiguration.journalMode) + ", syncMode=" + TextUtils.emptyIfNull(mConfiguration.syncMode));
        if (isCompatibilityWalEnabled) {
            printer.println("  Compatibility WAL enabled: wal_syncmode=" + SQLiteCompatibilityWalFlags.getWALSyncMode());
        }
        if (mConfiguration.isLookasideConfigSet()) {
            printer.println("  Lookaside config: sz=" + mConfiguration.lookasideSlotSize + " cnt=" + mConfiguration.lookasideSlotCount);
        }
        if (mConfiguration.idleConnectionTimeoutMs != Long.MAX_VALUE) {
            printer.println("  Idle connection timeout: " + mConfiguration.idleConnectionTimeoutMs);
        }
        printer.println("  Available primary connection:");
        if (mAvailablePrimaryConnection != null) {
            mAvailablePrimaryConnection.dump(indentedPrinter, verbose);
        } else {
            indentedPrinter.println("<none>");
        }
        printer.println("  Available non-primary connections:");
        if (!mAvailableNonPrimaryConnections.isEmpty()) {
            final int count = mAvailableNonPrimaryConnections.size();
            for (int i = 0; i < count; i++) {
                mAvailableNonPrimaryConnections.get(i).dump(indentedPrinter, verbose);
            }
        } else {
            indentedPrinter.println("<none>");
        }
        printer.println("  Acquired connections:");
        if (!mAcquiredConnections.isEmpty()) {
            for (Map.Entry<SQLiteConnection, AcquiredConnectionStatus> entry : mAcquiredConnections.entrySet()) {
                final SQLiteConnection connection = entry.getKey();
                connection.dumpUnsafe(indentedPrinter, verbose);
                indentedPrinter.println("  Status: " + entry.getValue());
            }
        } else {
            indentedPrinter.println("<none>");
        }
        printer.println("  Connection waiters:");
        if (mConnectionWaiterQueue != null) {
            int i = 0;
            final long now = SystemClock.uptimeMillis();
            for (ConnectionWaiter waiter = mConnectionWaiterQueue; waiter != null; waiter = waiter.mNext, i++) {
                indentedPrinter.println(i + ": waited for " + ((now - waiter.mStartTime) * 0.001f) + " ms - thread=" + waiter.mThread + ", priority=" + waiter.mPriority + ", sql='" + waiter.mSql + "'");
            }
        } else {
            indentedPrinter.println("<none>");
        }
    }
}
Body of Second Method:
{
    Printer indentedPrinter = PrefixPrinter.create(printer, "    ");
    synchronized (mLock) {
        if (directories != null) {
            directories.add(new File(mConfiguration.path).getParent());
        }
        boolean isCompatibilityWalEnabled = mConfiguration.isLegacyCompatibilityWalEnabled();
        printer.println("Connection pool for " + mConfiguration.path + ":");
        printer.println("  Open: " + mIsOpen);
        printer.println("  Max connections: " + mMaxConnectionPoolSize);
        printer.println("  Total execution time (ms): " + mTotalStatementsTime);
        printer.println("  Total statements executed: " + mTotalStatementsCount);
        if (mTotalStatementsCount.get() > 0) {
            // Avoid division by 0 by filtering out logs where there are no statements executed.
            printer.println("  Average time per statement (ms): " + mTotalStatementsTime.get() / mTotalStatementsCount.get());
        }
        printer.println("  Configuration: openFlags=" + mConfiguration.openFlags + ", isLegacyCompatibilityWalEnabled=" + isCompatibilityWalEnabled + ", journalMode=" + TextUtils.emptyIfNull(mConfiguration.resolveJournalMode()) + ", syncMode=" + TextUtils.emptyIfNull(mConfiguration.resolveSyncMode()));
        printer.println("  IsReadOnlyDatabase=" + mConfiguration.isReadOnlyDatabase());
        if (isCompatibilityWalEnabled) {
            printer.println("  Compatibility WAL enabled: wal_syncmode=" + SQLiteCompatibilityWalFlags.getWALSyncMode());
        }
        if (mConfiguration.isLookasideConfigSet()) {
            printer.println("  Lookaside config: sz=" + mConfiguration.lookasideSlotSize + " cnt=" + mConfiguration.lookasideSlotCount);
        }
        if (mConfiguration.idleConnectionTimeoutMs != Long.MAX_VALUE) {
            printer.println("  Idle connection timeout: " + mConfiguration.idleConnectionTimeoutMs);
        }
        printer.println("  Available primary connection:");
        if (mAvailablePrimaryConnection != null) {
            mAvailablePrimaryConnection.dump(indentedPrinter, verbose);
        } else {
            indentedPrinter.println("<none>");
        }
        printer.println("  Available non-primary connections:");
        if (!mAvailableNonPrimaryConnections.isEmpty()) {
            final int count = mAvailableNonPrimaryConnections.size();
            for (int i = 0; i < count; i++) {
                mAvailableNonPrimaryConnections.get(i).dump(indentedPrinter, verbose);
            }
        } else {
            indentedPrinter.println("<none>");
        }
        printer.println("  Acquired connections:");
        if (!mAcquiredConnections.isEmpty()) {
            for (Map.Entry<SQLiteConnection, AcquiredConnectionStatus> entry : mAcquiredConnections.entrySet()) {
                final SQLiteConnection connection = entry.getKey();
                connection.dumpUnsafe(indentedPrinter, verbose);
                indentedPrinter.println("  Status: " + entry.getValue());
            }
        } else {
            indentedPrinter.println("<none>");
        }
        printer.println("  Connection waiters:");
        if (mConnectionWaiterQueue != null) {
            int i = 0;
            final long now = SystemClock.uptimeMillis();
            for (ConnectionWaiter waiter = mConnectionWaiterQueue; waiter != null; waiter = waiter.mNext, i++) {
                indentedPrinter.println(i + ": waited for " + ((now - waiter.mStartTime) * 0.001f) + " ms - thread=" + waiter.mThread + ", priority=" + waiter.mPriority + ", sql='" + waiter.mSql + "'");
            }
        } else {
            indentedPrinter.println("<none>");
        }
    }
}
------------------------
Find a silently evolved API code:android.os.VibrationAttributes.usageToString:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    switch(usage) {
        case USAGE_UNKNOWN:
            return "UNKNOWN";
        case USAGE_ALARM:
            return "ALARM";
        case USAGE_RINGTONE:
            return "RIGNTONE";
        case USAGE_NOTIFICATION:
            return "NOTIFICATION";
        case USAGE_COMMUNICATION_REQUEST:
            return "COMMUNICATION_REQUEST";
        case USAGE_TOUCH:
            return "TOUCH";
        case USAGE_PHYSICAL_EMULATION:
            return "PHYSICAL_EMULATION";
        case USAGE_HARDWARE_FEEDBACK:
            return "HARDWARE_FEEDBACK";
        default:
            return "unknown usage " + usage;
    }
}
Body of Second Method:
{
    switch(usage) {
        case USAGE_UNKNOWN:
            return "UNKNOWN";
        case USAGE_ALARM:
            return "ALARM";
        case USAGE_ACCESSIBILITY:
            return "ACCESSIBILITY";
        case USAGE_RINGTONE:
            return "RINGTONE";
        case USAGE_NOTIFICATION:
            return "NOTIFICATION";
        case USAGE_COMMUNICATION_REQUEST:
            return "COMMUNICATION_REQUEST";
        case USAGE_MEDIA:
            return "MEDIA";
        case USAGE_TOUCH:
            return "TOUCH";
        case USAGE_PHYSICAL_EMULATION:
            return "PHYSICAL_EMULATION";
        case USAGE_HARDWARE_FEEDBACK:
            return "HARDWARE_FEEDBACK";
        default:
            return "unknown usage " + usage;
    }
}
------------------------
Find a silently evolved API code:android.media.tv.tuner.filter.SectionSettingsWithTableInfo.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Builds a {@link SectionSettingsWithTableInfo} object.
 */

Body of Frist Method:
{
    return new SectionSettingsWithTableInfo(mMainType, mCrcEnabled, mIsRepeat, mIsRaw, mTableId, mVersion);
}
Body of Second Method:
{
    return new SectionSettingsWithTableInfo(mMainType, mCrcEnabled, mIsRepeat, mIsRaw, mBitWidthOfLengthField, mTableId, mVersion);
}
------------------------
Find a silently evolved API code:android.graphics.BaseCanvas.drawDoubleRoundRect:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Make lint happy.
 * See {@link Canvas#drawDoubleRoundRect(RectF, float, float, RectF, float, float, Paint)}
 */

Body of Frist Method:
{
    throwIfHasHwBitmapInSwMode(paint);
    float outerLeft = outer.left;
    float outerTop = outer.top;
    float outerRight = outer.right;
    float outerBottom = outer.bottom;
    float innerLeft = inner.left;
    float innerTop = inner.top;
    float innerRight = inner.right;
    float innerBottom = inner.bottom;
    nDrawDoubleRoundRect(mNativeCanvasWrapper, outerLeft, outerTop, outerRight, outerBottom, outerRx, outerRy, innerLeft, innerTop, innerRight, innerBottom, innerRx, innerRy, paint.getNativeInstance());
}
Body of Second Method:
{
    throwIfHasHwFeaturesInSwMode(paint);
    float outerLeft = outer.left;
    float outerTop = outer.top;
    float outerRight = outer.right;
    float outerBottom = outer.bottom;
    float innerLeft = inner.left;
    float innerTop = inner.top;
    float innerRight = inner.right;
    float innerBottom = inner.bottom;
    nDrawDoubleRoundRect(mNativeCanvasWrapper, outerLeft, outerTop, outerRight, outerBottom, outerRx, outerRy, innerLeft, innerTop, innerRight, innerBottom, innerRx, innerRy, paint.getNativeInstance());
}
------------------------
Find a silently evolved API code:android.app.ApplicationExitInfo.readFromProto:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Read from a protocol buffer input stream.
 * Protocol buffer message definition at {@link android.app.ApplicationExitInfoProto}
 *
 * @param proto   Stream to read the ApplicationExitInfo object from.
 * @param fieldId Field Id of the ApplicationExitInfo as defined in the parent message
 * @hide
 */

Body of Frist Method:
{
    final long token = proto.start(fieldId);
    while (proto.nextField() != ProtoInputStream.NO_MORE_FIELDS) {
        switch(proto.getFieldNumber()) {
            case (int) ApplicationExitInfoProto.PID:
                mPid = proto.readInt(ApplicationExitInfoProto.PID);
                break;
            case (int) ApplicationExitInfoProto.REAL_UID:
                mRealUid = proto.readInt(ApplicationExitInfoProto.REAL_UID);
                break;
            case (int) ApplicationExitInfoProto.PACKAGE_UID:
                mPackageUid = proto.readInt(ApplicationExitInfoProto.PACKAGE_UID);
                break;
            case (int) ApplicationExitInfoProto.DEFINING_UID:
                mDefiningUid = proto.readInt(ApplicationExitInfoProto.DEFINING_UID);
                break;
            case (int) ApplicationExitInfoProto.PROCESS_NAME:
                mProcessName = proto.readString(ApplicationExitInfoProto.PROCESS_NAME);
                break;
            case (int) ApplicationExitInfoProto.CONNECTION_GROUP:
                mConnectionGroup = proto.readInt(ApplicationExitInfoProto.CONNECTION_GROUP);
                break;
            case (int) ApplicationExitInfoProto.REASON:
                mReason = proto.readInt(ApplicationExitInfoProto.REASON);
                break;
            case (int) ApplicationExitInfoProto.SUB_REASON:
                mSubReason = proto.readInt(ApplicationExitInfoProto.SUB_REASON);
                break;
            case (int) ApplicationExitInfoProto.STATUS:
                mStatus = proto.readInt(ApplicationExitInfoProto.STATUS);
                break;
            case (int) ApplicationExitInfoProto.IMPORTANCE:
                mImportance = proto.readInt(ApplicationExitInfoProto.IMPORTANCE);
                break;
            case (int) ApplicationExitInfoProto.PSS:
                mPss = proto.readLong(ApplicationExitInfoProto.PSS);
                break;
            case (int) ApplicationExitInfoProto.RSS:
                mRss = proto.readLong(ApplicationExitInfoProto.RSS);
                break;
            case (int) ApplicationExitInfoProto.TIMESTAMP:
                mTimestamp = proto.readLong(ApplicationExitInfoProto.TIMESTAMP);
                break;
            case (int) ApplicationExitInfoProto.DESCRIPTION:
                mDescription = proto.readString(ApplicationExitInfoProto.DESCRIPTION);
                break;
            case (int) ApplicationExitInfoProto.STATE:
                mState = proto.readBytes(ApplicationExitInfoProto.STATE);
                break;
            case (int) ApplicationExitInfoProto.TRACE_FILE:
                final String path = proto.readString(ApplicationExitInfoProto.TRACE_FILE);
                if (!TextUtils.isEmpty(path)) {
                    mTraceFile = new File(path);
                }
                break;
        }
    }
    proto.end(token);
}
Body of Second Method:
{
    final long token = proto.start(fieldId);
    while (proto.nextField() != ProtoInputStream.NO_MORE_FIELDS) {
        switch(proto.getFieldNumber()) {
            case (int) ApplicationExitInfoProto.PID:
                mPid = proto.readInt(ApplicationExitInfoProto.PID);
                break;
            case (int) ApplicationExitInfoProto.REAL_UID:
                mRealUid = proto.readInt(ApplicationExitInfoProto.REAL_UID);
                break;
            case (int) ApplicationExitInfoProto.PACKAGE_UID:
                mPackageUid = proto.readInt(ApplicationExitInfoProto.PACKAGE_UID);
                break;
            case (int) ApplicationExitInfoProto.DEFINING_UID:
                mDefiningUid = proto.readInt(ApplicationExitInfoProto.DEFINING_UID);
                break;
            case (int) ApplicationExitInfoProto.PROCESS_NAME:
                mProcessName = intern(proto.readString(ApplicationExitInfoProto.PROCESS_NAME));
                break;
            case (int) ApplicationExitInfoProto.CONNECTION_GROUP:
                mConnectionGroup = proto.readInt(ApplicationExitInfoProto.CONNECTION_GROUP);
                break;
            case (int) ApplicationExitInfoProto.REASON:
                mReason = proto.readInt(ApplicationExitInfoProto.REASON);
                break;
            case (int) ApplicationExitInfoProto.SUB_REASON:
                mSubReason = proto.readInt(ApplicationExitInfoProto.SUB_REASON);
                break;
            case (int) ApplicationExitInfoProto.STATUS:
                mStatus = proto.readInt(ApplicationExitInfoProto.STATUS);
                break;
            case (int) ApplicationExitInfoProto.IMPORTANCE:
                mImportance = proto.readInt(ApplicationExitInfoProto.IMPORTANCE);
                break;
            case (int) ApplicationExitInfoProto.PSS:
                mPss = proto.readLong(ApplicationExitInfoProto.PSS);
                break;
            case (int) ApplicationExitInfoProto.RSS:
                mRss = proto.readLong(ApplicationExitInfoProto.RSS);
                break;
            case (int) ApplicationExitInfoProto.TIMESTAMP:
                mTimestamp = proto.readLong(ApplicationExitInfoProto.TIMESTAMP);
                break;
            case (int) ApplicationExitInfoProto.DESCRIPTION:
                mDescription = intern(proto.readString(ApplicationExitInfoProto.DESCRIPTION));
                break;
            case (int) ApplicationExitInfoProto.STATE:
                mState = proto.readBytes(ApplicationExitInfoProto.STATE);
                break;
            case (int) ApplicationExitInfoProto.TRACE_FILE:
                final String path = proto.readString(ApplicationExitInfoProto.TRACE_FILE);
                if (!TextUtils.isEmpty(path)) {
                    mTraceFile = new File(path);
                }
                break;
        }
    }
    proto.end(token);
}
------------------------
Find a silently evolved API code:android.location.LocationRequest.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Builds a location request from this builder. If an explicit minimum update interval is
 * set, the minimum update interval of the location request will be the minimum of the
 * interval and minimum update interval.
 *
 * <p>If building a passive request then you must have set an explicit minimum update
 * interval.
 *
 * @throws IllegalStateException if building a passive request with no explicit minimum
 * update interval set
 * @return a new location request
 */

Body of Frist Method:
{
    Preconditions.checkState(mIntervalMillis != PASSIVE_INTERVAL || mMinUpdateIntervalMillis != IMPLICIT_MIN_UPDATE_INTERVAL, "passive location requests must have an explicit minimum update interval");
    return new LocationRequest(null, mIntervalMillis, mQuality, Long.MAX_VALUE, mDurationMillis, mMaxUpdates, min(mMinUpdateIntervalMillis, mIntervalMillis), mMinUpdateDistanceMeters, mMaxUpdateDelayMillis, mHiddenFromAppOps, mAdasGnssBypass, mLocationSettingsIgnored, mLowPower, new WorkSource(mWorkSource));
}
Body of Second Method:
{
    Preconditions.checkState(mIntervalMillis != PASSIVE_INTERVAL || mMinUpdateIntervalMillis != IMPLICIT_MIN_UPDATE_INTERVAL, "passive location requests must have an explicit minimum update interval");
    return new LocationRequest(null, mIntervalMillis, mQuality, Long.MAX_VALUE, mDurationMillis, mMaxUpdates, min(mMinUpdateIntervalMillis, mIntervalMillis), mMinUpdateDistanceMeters, mMaxUpdateDelayMillis, mHiddenFromAppOps, mAdasGnssBypass, mBypass, mLowPower, new WorkSource(mWorkSource));
}
------------------------
Find a silently evolved API code:android.os.SystemClock.currentNetworkTimeMillis:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Returns milliseconds since January 1, 1970 00:00:00.0 UTC, synchronized
 * using a remote network source outside the device.
 * <p>
 * While the time returned by {@link System#currentTimeMillis()} can be
 * adjusted by the user, the time returned by this method cannot be adjusted
 * by the user. Note that synchronization may occur using an insecure
 * network protocol, so the returned time should not be used for security
 * purposes.
 * <p>
 * This performs no blocking network operations and returns values based on
 * a recent successful synchronization event; it will either return a valid
 * time or throw.
 *
 * @throws DateTimeException when no accurate network time can be provided.
 * @hide
 */

Body of Frist Method:
{
    final IAlarmManager mgr = IAlarmManager.Stub.asInterface(ServiceManager.getService(Context.ALARM_SERVICE));
    if (mgr != null) {
        try {
            return mgr.currentNetworkTimeMillis();
        } catch (ParcelableException e) {
            e.maybeRethrow(DateTimeException.class);
            throw new RuntimeException(e);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    } else {
        throw new RuntimeException(new DeadSystemException());
    }
}
Body of Second Method:
{
    final IAlarmManager mgr = getIAlarmManager();
    if (mgr != null) {
        try {
            return mgr.currentNetworkTimeMillis();
        } catch (ParcelableException e) {
            e.maybeRethrow(DateTimeException.class);
            throw new RuntimeException(e);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    } else {
        throw new RuntimeException(new DeadSystemException());
    }
}
------------------------
Find a silently evolved API code:android.app.WindowConfiguration.setToDefaults:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    setAppBounds(null);
    setBounds(null);
    setMaxBounds(null);
    setWindowingMode(WINDOWING_MODE_UNDEFINED);
    setActivityType(ACTIVITY_TYPE_UNDEFINED);
    setAlwaysOnTop(ALWAYS_ON_TOP_UNDEFINED);
    setRotation(ROTATION_UNDEFINED);
    setDisplayWindowingMode(WINDOWING_MODE_UNDEFINED);
}
Body of Second Method:
{
    setAppBounds(null);
    setBounds(null);
    setMaxBounds(null);
    setDisplayRotation(ROTATION_UNDEFINED);
    setWindowingMode(WINDOWING_MODE_UNDEFINED);
    setActivityType(ACTIVITY_TYPE_UNDEFINED);
    setAlwaysOnTop(ALWAYS_ON_TOP_UNDEFINED);
    setRotation(ROTATION_UNDEFINED);
    setDisplayWindowingMode(WINDOWING_MODE_UNDEFINED);
}
------------------------
Find a silently evolved API code:android.os.PowerComponents.writeStatsProtoImpl:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Returns whether there are any atoms.proto POWER_COMPONENTS data to write to a proto,
 * and writes it to the given proto if it is non-null.
 */

Body of Frist Method:
{
    boolean interestingData = false;
    for (int idx = 0; idx < mPowerComponentsMah.length; idx++) {
        final int componentId = idx < BatteryConsumer.POWER_COMPONENT_COUNT ? idx : idx - CUSTOM_POWER_COMPONENT_OFFSET;
        final long powerDeciCoulombs = convertMahToDeciCoulombs(mPowerComponentsMah[idx]);
        final long durationMs = mUsageDurationsMs[idx];
        if (powerDeciCoulombs == 0 && durationMs == 0) {
            // No interesting data. Make sure not to even write the COMPONENT int.
            continue;
        }
        interestingData = true;
        if (proto == null) {
            // We're just asked whether there is data, not to actually write it. And there is.
            return true;
        }
        final long token = proto.start(BatteryUsageStatsAtomsProto.BatteryConsumerData.POWER_COMPONENTS);
        proto.write(BatteryUsageStatsAtomsProto.BatteryConsumerData.PowerComponentUsage.COMPONENT, componentId);
        proto.write(BatteryUsageStatsAtomsProto.BatteryConsumerData.PowerComponentUsage.POWER_DECI_COULOMBS, powerDeciCoulombs);
        proto.write(BatteryUsageStatsAtomsProto.BatteryConsumerData.PowerComponentUsage.DURATION_MILLIS, durationMs);
        proto.end(token);
    }
    return interestingData;
}
Body of Second Method:
{
    boolean interestingData = false;
    for (int componentId = 0; componentId < BatteryConsumer.POWER_COMPONENT_COUNT; componentId++) {
        final BatteryConsumer.Key[] keys = mData.getKeys(componentId);
        for (BatteryConsumer.Key key : keys) {
            final long powerDeciCoulombs = convertMahToDeciCoulombs(getConsumedPower(key));
            final long durationMs = getUsageDurationMillis(key);
            if (powerDeciCoulombs == 0 && durationMs == 0) {
                // No interesting data. Make sure not to even write the COMPONENT int.
                continue;
            }
            interestingData = true;
            if (proto == null) {
                // And there is.
                return true;
            }
            if (key.processState == PROCESS_STATE_ANY) {
                writePowerComponentUsage(proto, BatteryUsageStatsAtomsProto.BatteryConsumerData.POWER_COMPONENTS, componentId, powerDeciCoulombs, durationMs);
            } else {
                writePowerUsageSlice(proto, componentId, powerDeciCoulombs, durationMs, key.processState);
            }
        }
    }
    for (int idx = 0; idx < mData.layout.customPowerComponentCount; idx++) {
        final int componentId = BatteryConsumer.FIRST_CUSTOM_POWER_COMPONENT_ID + idx;
        final long powerDeciCoulombs = convertMahToDeciCoulombs(getConsumedPowerForCustomComponent(componentId));
        final long durationMs = getUsageDurationForCustomComponentMillis(componentId);
        if (powerDeciCoulombs == 0 && durationMs == 0) {
            // No interesting data. Make sure not to even write the COMPONENT int.
            continue;
        }
        interestingData = true;
        if (proto == null) {
            // We're just asked whether there is data, not to actually write it. And there is.
            return true;
        }
        writePowerComponentUsage(proto, BatteryUsageStatsAtomsProto.BatteryConsumerData.POWER_COMPONENTS, componentId, powerDeciCoulombs, durationMs);
    }
    return interestingData;
}
------------------------
Find a silently evolved API code:android.app.ApplicationExitInfo.setPackageName:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @see #getPackageName
 *
 * @hide
 */

Body of Frist Method:
{
    mPackageName = packageName;
}
Body of Second Method:
{
    mPackageName = intern(packageName);
}
------------------------
Find a silently evolved API code:android.telephony.LocationAccessPolicy.checkLocationPermission:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Check if location permissions have been granted
 */

Body of Frist Method:
{
    // process anyway, and the system server already has location access.
    if (query.callingUid == Process.PHONE_UID || query.callingUid == Process.SYSTEM_UID || query.callingUid == Process.NETWORK_STACK_UID || query.callingUid == Process.ROOT_UID) {
        return LocationPermissionResult.ALLOWED;
    }
    // the app's profile isn't in foreground, return a soft denial.
    if (!checkSystemLocationAccess(context, query.callingUid, query.callingPid)) {
        return LocationPermissionResult.DENIED_SOFT;
    }
    // Do the check for fine, then for coarse.
    if (query.minSdkVersionForFine < Integer.MAX_VALUE) {
        LocationPermissionResult resultForFine = checkAppLocationPermissionHelper(context, query, Manifest.permission.ACCESS_FINE_LOCATION);
        if (resultForFine != null) {
            return resultForFine;
        }
    }
    if (query.minSdkVersionForCoarse < Integer.MAX_VALUE) {
        LocationPermissionResult resultForCoarse = checkAppLocationPermissionHelper(context, query, Manifest.permission.ACCESS_COARSE_LOCATION);
        if (resultForCoarse != null) {
            return resultForCoarse;
        }
    }
    // ones due to the SDK backwards compatibility schemes, allow it access.
    return LocationPermissionResult.ALLOWED;
}
Body of Second Method:
{
    // process anyway, and the system server already has location access.
    if (query.callingUid == Process.PHONE_UID || query.callingUid == Process.SYSTEM_UID || query.callingUid == Process.NETWORK_STACK_UID || query.callingUid == Process.ROOT_UID) {
        return LocationPermissionResult.ALLOWED;
    }
    // isn't in the foreground, return a soft denial.
    if (!checkSystemLocationAccess(context, query.callingUid, query.callingPid, query.callingPackage)) {
        return LocationPermissionResult.DENIED_SOFT;
    }
    // Do the check for fine, then for coarse.
    if (query.minSdkVersionForFine < Integer.MAX_VALUE) {
        LocationPermissionResult resultForFine = checkAppLocationPermissionHelper(context, query, Manifest.permission.ACCESS_FINE_LOCATION);
        if (resultForFine != null) {
            return resultForFine;
        }
    }
    if (query.minSdkVersionForCoarse < Integer.MAX_VALUE) {
        LocationPermissionResult resultForCoarse = checkAppLocationPermissionHelper(context, query, Manifest.permission.ACCESS_COARSE_LOCATION);
        if (resultForCoarse != null) {
            return resultForCoarse;
        }
    }
    // ones due to the SDK backwards compatibility schemes, allow it access.
    return LocationPermissionResult.ALLOWED;
}
------------------------
Find a silently evolved API code:android.os.ParcelableHolder.readFromParcel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Read ParcelableHolder from a parcel.
 */

Body of Frist Method:
{
    this.mStability = parcel.readInt();
    mParcelable = null;
    int dataSize = parcel.readInt();
    if (dataSize < 0) {
        throw new IllegalArgumentException("dataSize from parcel is negative");
    } else if (dataSize == 0) {
        if (mParcel != null) {
            mParcel.recycle();
            mParcel = null;
        }
        return;
    }
    if (mParcel == null) {
        mParcel = Parcel.obtain();
    }
    mParcel.setDataPosition(0);
    mParcel.setDataSize(0);
    int dataStartPos = parcel.dataPosition();
    mParcel.appendFrom(parcel, dataStartPos, dataSize);
    parcel.setDataPosition(MathUtils.addOrThrow(dataStartPos, dataSize));
}
Body of Second Method:
{
    int wireStability = parcel.readInt();
    if (this.mStability != wireStability) {
        throw new IllegalArgumentException("Expected stability " + this.mStability + " but got " + wireStability);
    }
    mParcelable = null;
    int dataSize = parcel.readInt();
    if (dataSize < 0) {
        throw new IllegalArgumentException("dataSize from parcel is negative");
    } else if (dataSize == 0) {
        if (mParcel != null) {
            mParcel.recycle();
            mParcel = null;
        }
        return;
    }
    if (mParcel == null) {
        mParcel = Parcel.obtain();
    }
    mParcel.setDataPosition(0);
    mParcel.setDataSize(0);
    int dataStartPos = parcel.dataPosition();
    mParcel.appendFrom(parcel, dataStartPos, dataSize);
    parcel.setDataPosition(MathUtils.addOrThrow(dataStartPos, dataSize));
}
------------------------
Find a silently evolved API code:android.graphics.drawable.AdaptiveIconDrawable.inflateLayers:COMMENT
Method Modifier: private     
Comment:/**
 * Inflates child layers using the specified parser.
 */

Body of Frist Method:
{
    final LayerState state = mLayerState;
    final int innerDepth = parser.getDepth() + 1;
    int type;
    int depth;
    int childIndex = 0;
    while ((type = parser.next()) != XmlPullParser.END_DOCUMENT && ((depth = parser.getDepth()) >= innerDepth || type != XmlPullParser.END_TAG)) {
        if (type != XmlPullParser.START_TAG) {
            continue;
        }
        if (depth > innerDepth) {
            continue;
        }
        String tagName = parser.getName();
        if (tagName.equals("background")) {
            childIndex = BACKGROUND_ID;
        } else if (tagName.equals("foreground")) {
            childIndex = FOREGROUND_ID;
        } else {
            continue;
        }
        final ChildDrawable layer = new ChildDrawable(state.mDensity);
        final TypedArray a = obtainAttributes(r, theme, attrs, R.styleable.AdaptiveIconDrawableLayer);
        updateLayerFromTypedArray(layer, a);
        a.recycle();
        // first one.
        if (layer.mDrawable == null && (layer.mThemeAttrs == null)) {
            while ((type = parser.next()) == XmlPullParser.TEXT) {
            }
            if (type != XmlPullParser.START_TAG) {
                throw new XmlPullParserException(parser.getPositionDescription() + ": <foreground> or <background> tag requires a 'drawable'" + "attribute or child tag defining a drawable");
            }
            // We found a child drawable. Take ownership.
            layer.mDrawable = Drawable.createFromXmlInnerForDensity(r, parser, attrs, mLayerState.mSrcDensityOverride, theme);
            layer.mDrawable.setCallback(this);
            state.mChildrenChangingConfigurations |= layer.mDrawable.getChangingConfigurations();
        }
        addLayer(childIndex, layer);
    }
}
Body of Second Method:
{
    final LayerState state = mLayerState;
    final int innerDepth = parser.getDepth() + 1;
    int type;
    int depth;
    int childIndex = 0;
    while ((type = parser.next()) != XmlPullParser.END_DOCUMENT && ((depth = parser.getDepth()) >= innerDepth || type != XmlPullParser.END_TAG)) {
        if (type != XmlPullParser.START_TAG) {
            continue;
        }
        if (depth > innerDepth) {
            continue;
        }
        String tagName = parser.getName();
        switch(tagName) {
            case "background":
                childIndex = BACKGROUND_ID;
                break;
            case "foreground":
                childIndex = FOREGROUND_ID;
                break;
            case "monochrome":
                childIndex = MONOCHROME_ID;
                break;
            default:
                continue;
        }
        final ChildDrawable layer = new ChildDrawable(state.mDensity);
        final TypedArray a = obtainAttributes(r, theme, attrs, R.styleable.AdaptiveIconDrawableLayer);
        updateLayerFromTypedArray(layer, a);
        a.recycle();
        // first one.
        if (layer.mDrawable == null && (layer.mThemeAttrs == null)) {
            while ((type = parser.next()) == XmlPullParser.TEXT) {
            }
            if (type != XmlPullParser.START_TAG) {
                throw new XmlPullParserException(parser.getPositionDescription() + ": <foreground> or <background> tag requires a 'drawable'" + "attribute or child tag defining a drawable");
            }
            // We found a child drawable. Take ownership.
            layer.mDrawable = Drawable.createFromXmlInnerForDensity(r, parser, attrs, mLayerState.mSrcDensityOverride, theme);
            layer.mDrawable.setCallback(this);
            state.mChildrenChangingConfigurations |= layer.mDrawable.getChangingConfigurations();
        }
        addLayer(childIndex, layer);
    }
}
------------------------
Find a silently evolved API code:android.hardware.location.ContextHubClient.setClientProxy:COMMENT
Method Modifier: default     hidden      
Comment:/* package */

Body of Frist Method:
{
    Objects.requireNonNull(clientProxy, "IContextHubClient cannot be null");
    if (mClientProxy != null) {
        throw new IllegalStateException("Cannot change client proxy multiple times");
    }
    mClientProxy = clientProxy;
}
Body of Second Method:
{
    Objects.requireNonNull(clientProxy, "IContextHubClient cannot be null");
    if (mClientProxy != null) {
        throw new IllegalStateException("Cannot change client proxy multiple times");
    }
    mClientProxy = clientProxy;
    try {
        mId = Integer.valueOf(mClientProxy.getId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.os.PowerComponents.getUsageDurationForCustomComponentMillis:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns the amount of usage time attributed to the specified custom component.
 *
 * @param componentId The ID of the custom power component.
 * @return Amount of time in milliseconds.
 */

Body of Frist Method:
{
    if (componentId < BatteryConsumer.FIRST_CUSTOM_POWER_COMPONENT_ID) {
        throw new IllegalArgumentException("Unsupported custom power component ID: " + componentId);
    }
    try {
        return mUsageDurationsMs[CUSTOM_POWER_COMPONENT_OFFSET + componentId];
    } catch (ArrayIndexOutOfBoundsException e) {
        throw new IllegalArgumentException("Unsupported custom power component ID: " + componentId);
    }
}
Body of Second Method:
{
    final int index = componentId - BatteryConsumer.FIRST_CUSTOM_POWER_COMPONENT_ID;
    if (index >= 0 && index < mData.layout.customPowerComponentCount) {
        return mData.getLong(mData.layout.firstCustomUsageDurationColumn + index);
    } else {
        throw new IllegalArgumentException("Unsupported custom power component ID: " + componentId);
    }
}
------------------------
Find a silently evolved API code:android.app.ActivityOptions.toBundle:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the created options as a Bundle, which can be passed to
 * {@link android.content.Context#startActivity(android.content.Intent, android.os.Bundle)
 * Context.startActivity(Intent, Bundle)} and related methods.
 * Note that the returned Bundle is still owned by the ActivityOptions
 * object; you must not modify it, but can supply it to the startActivity
 * methods that take an options Bundle.
 */

Body of Frist Method:
{
    Bundle b = new Bundle();
    if (mPackageName != null) {
        b.putString(KEY_PACKAGE_NAME, mPackageName);
    }
    if (mLaunchBounds != null) {
        b.putParcelable(KEY_LAUNCH_BOUNDS, mLaunchBounds);
    }
    if (mAnimationType != ANIM_UNDEFINED) {
        b.putInt(KEY_ANIM_TYPE, mAnimationType);
    }
    if (mUsageTimeReport != null) {
        b.putParcelable(KEY_USAGE_TIME_REPORT, mUsageTimeReport);
    }
    switch(mAnimationType) {
        case ANIM_CUSTOM:
            b.putInt(KEY_ANIM_ENTER_RES_ID, mCustomEnterResId);
            b.putInt(KEY_ANIM_EXIT_RES_ID, mCustomExitResId);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_CUSTOM_IN_PLACE:
            b.putInt(KEY_ANIM_IN_PLACE_RES_ID, mCustomInPlaceResId);
            break;
        case ANIM_SCALE_UP:
        case ANIM_CLIP_REVEAL:
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            break;
        case ANIM_THUMBNAIL_SCALE_UP:
        case ANIM_THUMBNAIL_SCALE_DOWN:
        case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
        case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
            // the bitmap to a hardware bitmap and pass through the HardwareBuffer
            if (mThumbnail != null) {
                final Bitmap hwBitmap = mThumbnail.copy(Config.HARDWARE, false);
                if (hwBitmap != null) {
                    b.putParcelable(KEY_ANIM_THUMBNAIL, hwBitmap.getHardwareBuffer());
                } else {
                    Slog.w(TAG, "Failed to copy thumbnail");
                }
            }
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_SCENE_TRANSITION:
            if (mTransitionReceiver != null) {
                b.putParcelable(KEY_TRANSITION_COMPLETE_LISTENER, mTransitionReceiver);
            }
            b.putBoolean(KEY_TRANSITION_IS_RETURNING, mIsReturning);
            b.putStringArrayList(KEY_TRANSITION_SHARED_ELEMENTS, mSharedElementNames);
            b.putParcelable(KEY_RESULT_DATA, mResultData);
            b.putInt(KEY_RESULT_CODE, mResultCode);
            b.putInt(KEY_EXIT_COORDINATOR_INDEX, mExitCoordinatorIndex);
            break;
    }
    if (mLockTaskMode) {
        b.putBoolean(KEY_LOCK_TASK_MODE, mLockTaskMode);
    }
    if (mLaunchDisplayId != INVALID_DISPLAY) {
        b.putInt(KEY_LAUNCH_DISPLAY_ID, mLaunchDisplayId);
    }
    if (mCallerDisplayId != INVALID_DISPLAY) {
        b.putInt(KEY_CALLER_DISPLAY_ID, mCallerDisplayId);
    }
    if (mLaunchTaskDisplayArea != null) {
        b.putParcelable(KEY_LAUNCH_TASK_DISPLAY_AREA_TOKEN, mLaunchTaskDisplayArea);
    }
    if (mLaunchRootTask != null) {
        b.putParcelable(KEY_LAUNCH_ROOT_TASK_TOKEN, mLaunchRootTask);
    }
    if (mLaunchTaskFragmentToken != null) {
        b.putBinder(KEY_LAUNCH_TASK_FRAGMENT_TOKEN, mLaunchTaskFragmentToken);
    }
    if (mLaunchWindowingMode != WINDOWING_MODE_UNDEFINED) {
        b.putInt(KEY_LAUNCH_WINDOWING_MODE, mLaunchWindowingMode);
    }
    if (mLaunchActivityType != ACTIVITY_TYPE_UNDEFINED) {
        b.putInt(KEY_LAUNCH_ACTIVITY_TYPE, mLaunchActivityType);
    }
    if (mLaunchTaskId != -1) {
        b.putInt(KEY_LAUNCH_TASK_ID, mLaunchTaskId);
    }
    if (mPendingIntentLaunchFlags != 0) {
        b.putInt(KEY_PENDING_INTENT_LAUNCH_FLAGS, mPendingIntentLaunchFlags);
    }
    if (mTaskAlwaysOnTop) {
        b.putBoolean(KEY_TASK_ALWAYS_ON_TOP, mTaskAlwaysOnTop);
    }
    if (mTaskOverlay) {
        b.putBoolean(KEY_TASK_OVERLAY, mTaskOverlay);
    }
    if (mTaskOverlayCanResume) {
        b.putBoolean(KEY_TASK_OVERLAY_CAN_RESUME, mTaskOverlayCanResume);
    }
    if (mAvoidMoveToFront) {
        b.putBoolean(KEY_AVOID_MOVE_TO_FRONT, mAvoidMoveToFront);
    }
    if (mFreezeRecentTasksReordering) {
        b.putBoolean(KEY_FREEZE_RECENT_TASKS_REORDERING, mFreezeRecentTasksReordering);
    }
    if (mDisallowEnterPictureInPictureWhileLaunching) {
        b.putBoolean(KEY_DISALLOW_ENTER_PICTURE_IN_PICTURE_WHILE_LAUNCHING, mDisallowEnterPictureInPictureWhileLaunching);
    }
    if (mApplyActivityFlagsForBubbles) {
        b.putBoolean(KEY_APPLY_ACTIVITY_FLAGS_FOR_BUBBLES, mApplyActivityFlagsForBubbles);
    }
    if (mAnimSpecs != null) {
        b.putParcelableArray(KEY_ANIM_SPECS, mAnimSpecs);
    }
    if (mAnimationFinishedListener != null) {
        b.putBinder(KEY_ANIMATION_FINISHED_LISTENER, mAnimationFinishedListener.asBinder());
    }
    if (mSpecsFuture != null) {
        b.putBinder(KEY_SPECS_FUTURE, mSpecsFuture.asBinder());
    }
    if (mSourceInfo != null) {
        b.putParcelable(KEY_SOURCE_INFO, mSourceInfo);
    }
    if (mRotationAnimationHint != -1) {
        b.putInt(KEY_ROTATION_ANIMATION_HINT, mRotationAnimationHint);
    }
    if (mAppVerificationBundle != null) {
        b.putBundle(KEY_INSTANT_APP_VERIFICATION_BUNDLE, mAppVerificationBundle);
    }
    if (mRemoteAnimationAdapter != null) {
        b.putParcelable(KEY_REMOTE_ANIMATION_ADAPTER, mRemoteAnimationAdapter);
    }
    if (mLaunchCookie != null) {
        b.putBinder(KEY_LAUNCH_COOKIE, mLaunchCookie);
    }
    if (mRemoteTransition != null) {
        b.putParcelable(KEY_REMOTE_TRANSITION, mRemoteTransition);
    }
    if (mOverrideTaskTransition) {
        b.putBoolean(KEY_OVERRIDE_TASK_TRANSITION, mOverrideTaskTransition);
    }
    if (mSplashScreenThemeResName != null && !mSplashScreenThemeResName.isEmpty()) {
        b.putString(KEY_SPLASH_SCREEN_THEME, mSplashScreenThemeResName);
    }
    if (mRemoveWithTaskOrganizer) {
        b.putBoolean(KEY_REMOVE_WITH_TASK_ORGANIZER, mRemoveWithTaskOrganizer);
    }
    if (mLaunchedFromBubble) {
        b.putBoolean(KEY_LAUNCHED_FROM_BUBBLE, mLaunchedFromBubble);
    }
    if (mTransientLaunch) {
        b.putBoolean(KEY_TRANSIENT_LAUNCH, mTransientLaunch);
    }
    if (mSplashScreenStyle != 0) {
        b.putInt(KEY_SPLASH_SCREEN_STYLE, mSplashScreenStyle);
    }
    return b;
}
Body of Second Method:
{
    Bundle b = super.toBundle();
    if (mPackageName != null) {
        b.putString(KEY_PACKAGE_NAME, mPackageName);
    }
    if (mLaunchBounds != null) {
        b.putParcelable(KEY_LAUNCH_BOUNDS, mLaunchBounds);
    }
    if (mAnimationType != ANIM_UNDEFINED) {
        b.putInt(KEY_ANIM_TYPE, mAnimationType);
    }
    if (mUsageTimeReport != null) {
        b.putParcelable(KEY_USAGE_TIME_REPORT, mUsageTimeReport);
    }
    switch(mAnimationType) {
        case ANIM_CUSTOM:
            b.putInt(KEY_ANIM_ENTER_RES_ID, mCustomEnterResId);
            b.putInt(KEY_ANIM_EXIT_RES_ID, mCustomExitResId);
            b.putInt(KEY_ANIM_BACKGROUND_COLOR, mCustomBackgroundColor);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_CUSTOM_IN_PLACE:
            b.putInt(KEY_ANIM_IN_PLACE_RES_ID, mCustomInPlaceResId);
            break;
        case ANIM_SCALE_UP:
        case ANIM_CLIP_REVEAL:
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            break;
        case ANIM_THUMBNAIL_SCALE_UP:
        case ANIM_THUMBNAIL_SCALE_DOWN:
        case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
        case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
            // the bitmap to a hardware bitmap and pass through the HardwareBuffer
            if (mThumbnail != null) {
                final Bitmap hwBitmap = mThumbnail.copy(Config.HARDWARE, false);
                if (hwBitmap != null) {
                    b.putParcelable(KEY_ANIM_THUMBNAIL, hwBitmap.getHardwareBuffer());
                } else {
                    Slog.w(TAG, "Failed to copy thumbnail");
                }
            }
            b.putInt(KEY_ANIM_START_X, mStartX);
            b.putInt(KEY_ANIM_START_Y, mStartY);
            b.putInt(KEY_ANIM_WIDTH, mWidth);
            b.putInt(KEY_ANIM_HEIGHT, mHeight);
            b.putBinder(KEY_ANIM_START_LISTENER, mAnimationStartedListener != null ? mAnimationStartedListener.asBinder() : null);
            break;
        case ANIM_SCENE_TRANSITION:
            if (mTransitionReceiver != null) {
                b.putParcelable(KEY_TRANSITION_COMPLETE_LISTENER, mTransitionReceiver);
            }
            b.putBoolean(KEY_TRANSITION_IS_RETURNING, mIsReturning);
            b.putStringArrayList(KEY_TRANSITION_SHARED_ELEMENTS, mSharedElementNames);
            b.putParcelable(KEY_RESULT_DATA, mResultData);
            b.putInt(KEY_RESULT_CODE, mResultCode);
            b.putInt(KEY_EXIT_COORDINATOR_INDEX, mExitCoordinatorIndex);
            break;
    }
    if (mLockTaskMode) {
        b.putBoolean(KEY_LOCK_TASK_MODE, mLockTaskMode);
    }
    if (mLaunchDisplayId != INVALID_DISPLAY) {
        b.putInt(KEY_LAUNCH_DISPLAY_ID, mLaunchDisplayId);
    }
    if (mCallerDisplayId != INVALID_DISPLAY) {
        b.putInt(KEY_CALLER_DISPLAY_ID, mCallerDisplayId);
    }
    if (mLaunchTaskDisplayArea != null) {
        b.putParcelable(KEY_LAUNCH_TASK_DISPLAY_AREA_TOKEN, mLaunchTaskDisplayArea);
    }
    if (mLaunchRootTask != null) {
        b.putParcelable(KEY_LAUNCH_ROOT_TASK_TOKEN, mLaunchRootTask);
    }
    if (mLaunchTaskFragmentToken != null) {
        b.putBinder(KEY_LAUNCH_TASK_FRAGMENT_TOKEN, mLaunchTaskFragmentToken);
    }
    if (mLaunchWindowingMode != WINDOWING_MODE_UNDEFINED) {
        b.putInt(KEY_LAUNCH_WINDOWING_MODE, mLaunchWindowingMode);
    }
    if (mLaunchActivityType != ACTIVITY_TYPE_UNDEFINED) {
        b.putInt(KEY_LAUNCH_ACTIVITY_TYPE, mLaunchActivityType);
    }
    if (mLaunchTaskId != -1) {
        b.putInt(KEY_LAUNCH_TASK_ID, mLaunchTaskId);
    }
    if (mPendingIntentLaunchFlags != 0) {
        b.putInt(KEY_PENDING_INTENT_LAUNCH_FLAGS, mPendingIntentLaunchFlags);
    }
    if (mTaskAlwaysOnTop) {
        b.putBoolean(KEY_TASK_ALWAYS_ON_TOP, mTaskAlwaysOnTop);
    }
    if (mTaskOverlay) {
        b.putBoolean(KEY_TASK_OVERLAY, mTaskOverlay);
    }
    if (mTaskOverlayCanResume) {
        b.putBoolean(KEY_TASK_OVERLAY_CAN_RESUME, mTaskOverlayCanResume);
    }
    if (mAvoidMoveToFront) {
        b.putBoolean(KEY_AVOID_MOVE_TO_FRONT, mAvoidMoveToFront);
    }
    if (mFreezeRecentTasksReordering) {
        b.putBoolean(KEY_FREEZE_RECENT_TASKS_REORDERING, mFreezeRecentTasksReordering);
    }
    if (mDisallowEnterPictureInPictureWhileLaunching) {
        b.putBoolean(KEY_DISALLOW_ENTER_PICTURE_IN_PICTURE_WHILE_LAUNCHING, mDisallowEnterPictureInPictureWhileLaunching);
    }
    if (mApplyActivityFlagsForBubbles) {
        b.putBoolean(KEY_APPLY_ACTIVITY_FLAGS_FOR_BUBBLES, mApplyActivityFlagsForBubbles);
    }
    if (mAnimSpecs != null) {
        b.putParcelableArray(KEY_ANIM_SPECS, mAnimSpecs);
    }
    if (mAnimationFinishedListener != null) {
        b.putBinder(KEY_ANIMATION_FINISHED_LISTENER, mAnimationFinishedListener.asBinder());
    }
    if (mSpecsFuture != null) {
        b.putBinder(KEY_SPECS_FUTURE, mSpecsFuture.asBinder());
    }
    if (mSourceInfo != null) {
        b.putParcelable(KEY_SOURCE_INFO, mSourceInfo);
    }
    if (mRotationAnimationHint != -1) {
        b.putInt(KEY_ROTATION_ANIMATION_HINT, mRotationAnimationHint);
    }
    if (mAppVerificationBundle != null) {
        b.putBundle(KEY_INSTANT_APP_VERIFICATION_BUNDLE, mAppVerificationBundle);
    }
    if (mRemoteAnimationAdapter != null) {
        b.putParcelable(KEY_REMOTE_ANIMATION_ADAPTER, mRemoteAnimationAdapter);
    }
    if (mLaunchCookie != null) {
        b.putBinder(KEY_LAUNCH_COOKIE, mLaunchCookie);
    }
    if (mRemoteTransition != null) {
        b.putParcelable(KEY_REMOTE_TRANSITION, mRemoteTransition);
    }
    if (mOverrideTaskTransition) {
        b.putBoolean(KEY_OVERRIDE_TASK_TRANSITION, mOverrideTaskTransition);
    }
    if (mSplashScreenThemeResName != null && !mSplashScreenThemeResName.isEmpty()) {
        b.putString(KEY_SPLASH_SCREEN_THEME, mSplashScreenThemeResName);
    }
    if (mRemoveWithTaskOrganizer) {
        b.putBoolean(KEY_REMOVE_WITH_TASK_ORGANIZER, mRemoveWithTaskOrganizer);
    }
    if (mLaunchedFromBubble) {
        b.putBoolean(KEY_LAUNCHED_FROM_BUBBLE, mLaunchedFromBubble);
    }
    if (mTransientLaunch) {
        b.putBoolean(KEY_TRANSIENT_LAUNCH, mTransientLaunch);
    }
    if (mSplashScreenStyle != 0) {
        b.putInt(KEY_SPLASH_SCREEN_STYLE, mSplashScreenStyle);
    }
    if (mLaunchIntoPipParams != null) {
        b.putParcelable(KEY_LAUNCH_INTO_PIP_PARAMS, mLaunchIntoPipParams);
    }
    if (mIsEligibleForLegacyPermissionPrompt) {
        b.putBoolean(KEY_LEGACY_PERMISSION_PROMPT_ELIGIBLE, mIsEligibleForLegacyPermissionPrompt);
    }
    if (mDismissKeyguardIfInsecure) {
        b.putBoolean(KEY_DISMISS_KEYGUARD_IF_INSECURE, mDismissKeyguardIfInsecure);
    }
    if (mIgnorePendingIntentCreatorForegroundState) {
        b.putBoolean(KEY_IGNORE_PENDING_INTENT_CREATOR_FOREGROUND_STATE, mIgnorePendingIntentCreatorForegroundState);
    }
    return b;
}
------------------------
Find a silently evolved API code:android.view.KeyEvent.getDownTime:COMMENT
Method Modifier: public      final       
Comment:/**
 * Retrieve the time of the most recent key down event,
 * in the {@link android.os.SystemClock#uptimeMillis} time base.  If this
 * is a down event, this will be the same as {@link #getEventTime()}.
 * Note that when chording keys, this value is the down time of the
 * most recently pressed key, which may <em>not</em> be the same physical
 * key of this event.
 *
 * @return Returns the most recent key down time, in the
 * {@link android.os.SystemClock#uptimeMillis} time base
 */

Body of Frist Method:
{
    return mDownTime;
}
Body of Second Method:
{
    return TimeUnit.MILLISECONDS.convert(mDownTime, TimeUnit.NANOSECONDS);
}
------------------------
Find a silently evolved API code:android.view.KeyEvent.getEventTimeNano:COMMENT
Method Modifier: public      final       hidden      
Comment:/**
 * Retrieve the time this event occurred,
 * in the {@link android.os.SystemClock#uptimeMillis} time base but with
 * nanosecond (instead of millisecond) precision.
 * <p>
 * The value is in nanosecond precision but it may not have nanosecond accuracy.
 * </p>
 *
 * @return Returns the time this event occurred,
 * in the {@link android.os.SystemClock#uptimeMillis} time base but with
 * nanosecond (instead of millisecond) precision.
 *
 * @hide
 */

Body of Frist Method:
{
    return mEventTime * 1000000L;
}
Body of Second Method:
{
    return mEventTime;
}
------------------------
Find a silently evolved API code:android.content.pm.PackageManager.Property.toBundle:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Adds a mapping from the given key to this property's value in the provided
 * {@link android.os.Bundle}. If the provided {@link android.os.Bundle} is
 * {@code null}, creates a new {@link android.os.Bundle}.
 * @hide
 */

Body of Frist Method:
{
    final Bundle b = outBundle == null ? new Bundle() : outBundle;
    if (mType == TYPE_BOOLEAN) {
        b.putBoolean(mName, mBooleanValue);
    } else if (mType == TYPE_FLOAT) {
        b.putFloat(mName, mFloatValue);
    } else if (mType == TYPE_INTEGER) {
        b.putInt(mName, mIntegerValue);
    } else if (mType == TYPE_RESOURCE) {
        b.putInt(mName, mIntegerValue);
    } else if (mType == TYPE_STRING) {
        b.putString(mName, mStringValue);
    }
    return b;
}
Body of Second Method:
{
    final Bundle b = outBundle == null || outBundle == Bundle.EMPTY ? new Bundle() : outBundle;
    if (mType == TYPE_BOOLEAN) {
        b.putBoolean(mName, mBooleanValue);
    } else if (mType == TYPE_FLOAT) {
        b.putFloat(mName, mFloatValue);
    } else if (mType == TYPE_INTEGER) {
        b.putInt(mName, mIntegerValue);
    } else if (mType == TYPE_RESOURCE) {
        b.putInt(mName, mIntegerValue);
    } else if (mType == TYPE_STRING) {
        b.putString(mName, mStringValue);
    }
    return b;
}
------------------------
Find a silently evolved API code:android.view.KeyEvent.setTime:COMMENT
Method Modifier: public      final       hidden      
Comment:/**
 * Modifies the down time and the event time of the event.
 *
 * @param downTime The new down time (in {@link android.os.SystemClock#uptimeMillis}) of the
 * event.
 * @param eventTime The new event time (in {@link android.os.SystemClock#uptimeMillis}) of the
 * event.
 * @hide
 */

Body of Frist Method:
{
    mDownTime = downTime;
    mEventTime = eventTime;
}
Body of Second Method:
{
    mDownTime = TimeUnit.NANOSECONDS.convert(downTime, TimeUnit.MILLISECONDS);
    mEventTime = TimeUnit.NANOSECONDS.convert(eventTime, TimeUnit.MILLISECONDS);
}
------------------------
Find a silently evolved API code:android.os.AggregateBatteryConsumer.writeToXml:COMMENT
Method Modifier: default     hidden      
Comment:/**
 * Serializes this object to XML
 */

Body of Frist Method:
{
    serializer.startTag(null, BatteryUsageStats.XML_TAG_AGGREGATE);
    serializer.attributeInt(null, BatteryUsageStats.XML_ATTR_SCOPE, scope);
    serializer.attributeDouble(null, BatteryUsageStats.XML_ATTR_POWER, mConsumedPowerMah);
    mPowerComponents.writeToXml(serializer);
    serializer.endTag(null, BatteryUsageStats.XML_TAG_AGGREGATE);
}
Body of Second Method:
{
    serializer.startTag(null, BatteryUsageStats.XML_TAG_AGGREGATE);
    serializer.attributeInt(null, BatteryUsageStats.XML_ATTR_SCOPE, scope);
    serializer.attributeDouble(null, BatteryUsageStats.XML_ATTR_POWER, getConsumedPower());
    mPowerComponents.writeToXml(serializer);
    serializer.endTag(null, BatteryUsageStats.XML_TAG_AGGREGATE);
}
------------------------
Find a silently evolved API code:android.view.WindowInsets.getStableInsets:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * Returns the stable insets in pixels.
 *
 * <p>The stable inset represents the area of a full-screen window that <b>may</b> be
 * partially or fully obscured by the system UI elements.  This value does not change
 * based on the visibility state of those elements; for example, if the status bar is
 * normally shown, but temporarily hidden, the stable inset will still provide the inset
 * associated with the status bar being shown.</p>
 *
 * @return The stable insets
 * @deprecated Use {@link #getInsetsIgnoringVisibility(int)} with {@link Type#systemBars()}
 * instead.
 */

Body of Frist Method:
{
    return getInsets(mTypeMaxInsetsMap, mCompatInsetsTypes);
}
Body of Second Method:
{
    return getInsets(mTypeMaxInsetsMap, systemBars());
}
------------------------
Find a silently evolved API code:android.net.wifi.nl80211.DeviceWiphyCapabilities.hashCode:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * override hash code
 */

Body of Frist Method:
{
    return Objects.hash(m80211nSupported, m80211acSupported, m80211axSupported, mChannelWidth160MhzSupported, mChannelWidth80p80MhzSupported, mMaxNumberTxSpatialStreams, mMaxNumberRxSpatialStreams);
}
Body of Second Method:
{
    return Objects.hash(m80211nSupported, m80211acSupported, m80211axSupported, m80211beSupported, mChannelWidth160MhzSupported, mChannelWidth80p80MhzSupported, mChannelWidth320MhzSupported, mMaxNumberTxSpatialStreams, mMaxNumberRxSpatialStreams);
}
------------------------
Find a silently evolved API code:android.util.NtpTrustedTime.TimeResult.getAgeMillis:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Calculates and returns the age of this result.
 */

Body of Frist Method:
{
    return SystemClock.elapsedRealtime() - mElapsedRealtimeMillis;
}
Body of Second Method:
{
    return getAgeMillis(SystemClock.elapsedRealtime());
}
------------------------
Find a silently evolved API code:android.app.servertransaction.LaunchActivityItem.obtain:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Obtain an instance initialized with provided params.
 */

Body of Frist Method:
{
    LaunchActivityItem instance = ObjectPool.obtain(LaunchActivityItem.class);
    if (instance == null) {
        instance = new LaunchActivityItem();
    }
    setValues(instance, intent, ident, info, curConfig, overrideConfig, compatInfo, referrer, voiceInteractor, procState, state, persistentState, pendingResults, pendingNewIntents, activityOptions, isForward, profilerInfo, assistToken, activityClientController, fixedRotationAdjustments, shareableActivityToken, launchedFromBubble);
    return instance;
}
Body of Second Method:
{
    LaunchActivityItem instance = ObjectPool.obtain(LaunchActivityItem.class);
    if (instance == null) {
        instance = new LaunchActivityItem();
    }
    setValues(instance, intent, ident, info, curConfig, overrideConfig, compatInfo, referrer, voiceInteractor, procState, state, persistentState, pendingResults, pendingNewIntents, activityOptions, isForward, profilerInfo, assistToken, activityClientController, shareableActivityToken, launchedFromBubble, taskFragmentToken);
    return instance;
}
------------------------
Find a silently evolved API code:android.security.keystore2.AndroidKeyStoreProvider.makeAndroidKeyStorePublicKeyFromKeyEntryResponse:COMMENT
Method Modifier: default     static      hidden      
Comment:/**
 * This helper function gets called if the key loaded from the keystore daemon
 * is for an asymmetric algorithm. It constructs an instance of {@link AndroidKeyStorePublicKey}
 * which implements {@link PublicKey}.
 *
 * @param descriptor The original key descriptor that was used to load the key.
 *
 * @param metadata The key metadata which includes the public key material, a reference to the
 * stored private key material, the key characteristics.
 * @param iSecurityLevel A binder interface that allows using the private key.
 * @param algorithm Must indicate EC or RSA.
 * @return AndroidKeyStorePublicKey
 * @throws UnrecoverableKeyException
 * @hide
 */

Body of Frist Method:
{
    if (metadata.certificate == null) {
        throw new UnrecoverableKeyException("Failed to obtain X.509 form of public key." + " Keystore has no public certificate stored.");
    }
    final byte[] x509PublicCert = metadata.certificate;
    PublicKey publicKey = AndroidKeyStoreSpi.toCertificate(x509PublicCert).getPublicKey();
    String jcaKeyAlgorithm = publicKey.getAlgorithm();
    KeyStoreSecurityLevel securityLevel = iSecurityLevel;
    if (KeyProperties.KEY_ALGORITHM_EC.equalsIgnoreCase(jcaKeyAlgorithm)) {
        return new AndroidKeyStoreECPublicKey(descriptor, metadata, iSecurityLevel, (ECPublicKey) publicKey);
    } else if (KeyProperties.KEY_ALGORITHM_RSA.equalsIgnoreCase(jcaKeyAlgorithm)) {
        return new AndroidKeyStoreRSAPublicKey(descriptor, metadata, iSecurityLevel, (RSAPublicKey) publicKey);
    } else {
        throw new ProviderException("Unsupported Android Keystore public key algorithm: " + jcaKeyAlgorithm);
    }
}
Body of Second Method:
{
    if (metadata.certificate == null) {
        throw new UnrecoverableKeyException("Failed to obtain X.509 form of public key." + " Keystore has no public certificate stored.");
    }
    final byte[] x509PublicCert = metadata.certificate;
    PublicKey publicKey = AndroidKeyStoreSpi.toCertificate(x509PublicCert).getPublicKey();
    String jcaKeyAlgorithm = publicKey.getAlgorithm();
    if (KeyProperties.KEY_ALGORITHM_EC.equalsIgnoreCase(jcaKeyAlgorithm)) {
        return new AndroidKeyStoreECPublicKey(descriptor, metadata, iSecurityLevel, (ECPublicKey) publicKey);
    } else if (KeyProperties.KEY_ALGORITHM_RSA.equalsIgnoreCase(jcaKeyAlgorithm)) {
        return new AndroidKeyStoreRSAPublicKey(descriptor, metadata, iSecurityLevel, (RSAPublicKey) publicKey);
    } else if (ED25519_OID.equalsIgnoreCase(jcaKeyAlgorithm)) {
        final byte[] publicKeyEncoded = publicKey.getEncoded();
        return new AndroidKeyStoreEdECPublicKey(descriptor, metadata, ED25519_OID, iSecurityLevel, publicKeyEncoded);
    } else if (X25519_ALIAS.equalsIgnoreCase(jcaKeyAlgorithm)) {
        return new AndroidKeyStoreXDHPublicKey(descriptor, metadata, X25519_ALIAS, iSecurityLevel, publicKey.getEncoded());
    } else {
        throw new ProviderException("Unsupported Android Keystore public key algorithm: " + jcaKeyAlgorithm);
    }
}
------------------------
Find a silently evolved API code:android.location.LocationRequest.Builder.setLocationSettingsIgnored:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * If set to true, indicates that location settings, throttling, background location limits,
 * and any other possible limiting factors should be ignored in order to satisfy this
 * request. This is only intended for use in user initiated emergency situations, and
 * should be used extremely cautiously. Defaults to false.
 *
 * <p>Permissions enforcement occurs when resulting location request is actually used, not
 * when this method is invoked.
 *
 * @hide
 */

Body of Frist Method:
{
    mLocationSettingsIgnored = locationSettingsIgnored;
    return this;
}
Body of Second Method:
{
    mBypass = locationSettingsIgnored;
    return this;
}
------------------------
Find a silently evolved API code:android.os.PowerExemptionManager.reasonCodeToString:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Return string name of the integer reason code.
 * @hide
 * @param reasonCode
 * @return string name of the reason code.
 */

Body of Frist Method:
{
    switch(reasonCode) {
        case REASON_DENIED:
            return "DENIED";
        case REASON_UNKNOWN:
            return "UNKNOWN";
        case REASON_OTHER:
            return "OTHER";
        case REASON_PROC_STATE_PERSISTENT:
            return "PROC_STATE_PERSISTENT";
        case REASON_PROC_STATE_PERSISTENT_UI:
            return "PROC_STATE_PERSISTENT_UI";
        case REASON_PROC_STATE_TOP:
            return "PROC_STATE_TOP";
        case REASON_PROC_STATE_BTOP:
            return "PROC_STATE_BTOP";
        case REASON_PROC_STATE_FGS:
            return "PROC_STATE_FGS";
        case REASON_PROC_STATE_BFGS:
            return "PROC_STATE_BFGS";
        case REASON_UID_VISIBLE:
            return "UID_VISIBLE";
        case REASON_SYSTEM_UID:
            return "SYSTEM_UID";
        case REASON_ACTIVITY_STARTER:
            return "ACTIVITY_STARTER";
        case REASON_START_ACTIVITY_FLAG:
            return "START_ACTIVITY_FLAG";
        case REASON_FGS_BINDING:
            return "FGS_BINDING";
        case REASON_DEVICE_OWNER:
            return "DEVICE_OWNER";
        case REASON_PROFILE_OWNER:
            return "PROFILE_OWNER";
        case REASON_COMPANION_DEVICE_MANAGER:
            return "COMPANION_DEVICE_MANAGER";
        case REASON_BACKGROUND_ACTIVITY_PERMISSION:
            return "BACKGROUND_ACTIVITY_PERMISSION";
        case REASON_BACKGROUND_FGS_PERMISSION:
            return "BACKGROUND_FGS_PERMISSION";
        case REASON_INSTR_BACKGROUND_ACTIVITY_PERMISSION:
            return "INSTR_BACKGROUND_ACTIVITY_PERMISSION";
        case REASON_INSTR_BACKGROUND_FGS_PERMISSION:
            return "INSTR_BACKGROUND_FGS_PERMISSION";
        case REASON_SYSTEM_ALERT_WINDOW_PERMISSION:
            return "SYSTEM_ALERT_WINDOW_PERMISSION";
        case REASON_DEVICE_DEMO_MODE:
            return "DEVICE_DEMO_MODE";
        case REASON_ALLOWLISTED_PACKAGE:
            return "ALLOWLISTED_PACKAGE";
        case REASON_APPOP:
            return "APPOP";
        case REASON_ACTIVITY_VISIBILITY_GRACE_PERIOD:
            return "ACTIVITY_VISIBILITY_GRACE_PERIOD";
        case REASON_OP_ACTIVATE_VPN:
            return "OP_ACTIVATE_VPN";
        case REASON_OP_ACTIVATE_PLATFORM_VPN:
            return "OP_ACTIVATE_PLATFORM_VPN";
        case REASON_CURRENT_INPUT_METHOD:
            return "CURRENT_INPUT_METHOD";
        case REASON_TEMP_ALLOWED_WHILE_IN_USE:
            return "TEMP_ALLOWED_WHILE_IN_USE";
        case REASON_GEOFENCING:
            return "GEOFENCING";
        case REASON_PUSH_MESSAGING:
            return "PUSH_MESSAGING";
        case REASON_PUSH_MESSAGING_OVER_QUOTA:
            return "PUSH_MESSAGING_OVER_QUOTA";
        case REASON_ACTIVITY_RECOGNITION:
            return "ACTIVITY_RECOGNITION";
        case REASON_ACCOUNT_TRANSFER:
            return "REASON_ACCOUNT_TRANSFER";
        case REASON_BOOT_COMPLETED:
            return "BOOT_COMPLETED";
        case REASON_PRE_BOOT_COMPLETED:
            return "PRE_BOOT_COMPLETED";
        case REASON_LOCKED_BOOT_COMPLETED:
            return "LOCKED_BOOT_COMPLETED";
        case REASON_BLUETOOTH_BROADCAST:
            return "BLUETOOTH_BROADCAST";
        case REASON_TIMEZONE_CHANGED:
            return "TIMEZONE_CHANGED";
        case REASON_TIME_CHANGED:
            return "TIME_CHANGED";
        case REASON_LOCALE_CHANGED:
            return "LOCALE_CHANGED";
        case REASON_SCHEDULE_EXACT_ALARM_PERMISSION_STATE_CHANGED:
            return "REASON_SCHEDULE_EXACT_ALARM_PERMISSION_STATE_CHANGED";
        case REASON_SYSTEM_ALLOW_LISTED:
            return "SYSTEM_ALLOW_LISTED";
        case REASON_ALARM_MANAGER_ALARM_CLOCK:
            return "ALARM_MANAGER_ALARM_CLOCK";
        case REASON_ALARM_MANAGER_WHILE_IDLE:
            return "ALARM_MANAGER_WHILE_IDLE";
        case REASON_SERVICE_LAUNCH:
            return "SERVICE_LAUNCH";
        case REASON_KEY_CHAIN:
            return "KEY_CHAIN";
        case REASON_PACKAGE_VERIFIER:
            return "PACKAGE_VERIFIER";
        case REASON_SYNC_MANAGER:
            return "SYNC_MANAGER";
        case REASON_DOMAIN_VERIFICATION_V1:
            return "DOMAIN_VERIFICATION_V1";
        case REASON_DOMAIN_VERIFICATION_V2:
            return "DOMAIN_VERIFICATION_V2";
        case REASON_VPN:
            return "VPN";
        case REASON_NOTIFICATION_SERVICE:
            return "NOTIFICATION_SERVICE";
        case REASON_PACKAGE_REPLACED:
            return "PACKAGE_REPLACED";
        case REASON_LOCATION_PROVIDER:
            return "LOCATION_PROVIDER";
        case REASON_MEDIA_BUTTON:
            return "MEDIA_BUTTON";
        case REASON_EVENT_SMS:
            return "EVENT_SMS";
        case REASON_EVENT_MMS:
            return "EVENT_MMS";
        case REASON_SHELL:
            return "SHELL";
        case REASON_MEDIA_SESSION_CALLBACK:
            return "MEDIA_SESSION_CALLBACK";
        case REASON_OPT_OUT_REQUESTED:
            return "REASON_OPT_OUT_REQUESTED";
        default:
            return "(unknown:" + reasonCode + ")";
    }
}
Body of Second Method:
{
    switch(reasonCode) {
        case REASON_DENIED:
            return "DENIED";
        case REASON_UNKNOWN:
            return "UNKNOWN";
        case REASON_OTHER:
            return "OTHER";
        case REASON_PROC_STATE_PERSISTENT:
            return "PROC_STATE_PERSISTENT";
        case REASON_PROC_STATE_PERSISTENT_UI:
            return "PROC_STATE_PERSISTENT_UI";
        case REASON_PROC_STATE_TOP:
            return "PROC_STATE_TOP";
        case REASON_PROC_STATE_BTOP:
            return "PROC_STATE_BTOP";
        case REASON_PROC_STATE_FGS:
            return "PROC_STATE_FGS";
        case REASON_PROC_STATE_BFGS:
            return "PROC_STATE_BFGS";
        case REASON_UID_VISIBLE:
            return "UID_VISIBLE";
        case REASON_SYSTEM_UID:
            return "SYSTEM_UID";
        case REASON_ACTIVITY_STARTER:
            return "ACTIVITY_STARTER";
        case REASON_START_ACTIVITY_FLAG:
            return "START_ACTIVITY_FLAG";
        case REASON_FGS_BINDING:
            return "FGS_BINDING";
        case REASON_DEVICE_OWNER:
            return "DEVICE_OWNER";
        case REASON_PROFILE_OWNER:
            return "PROFILE_OWNER";
        case REASON_COMPANION_DEVICE_MANAGER:
            return "COMPANION_DEVICE_MANAGER";
        case REASON_BACKGROUND_ACTIVITY_PERMISSION:
            return "BACKGROUND_ACTIVITY_PERMISSION";
        case REASON_BACKGROUND_FGS_PERMISSION:
            return "BACKGROUND_FGS_PERMISSION";
        case REASON_INSTR_BACKGROUND_ACTIVITY_PERMISSION:
            return "INSTR_BACKGROUND_ACTIVITY_PERMISSION";
        case REASON_INSTR_BACKGROUND_FGS_PERMISSION:
            return "INSTR_BACKGROUND_FGS_PERMISSION";
        case REASON_SYSTEM_ALERT_WINDOW_PERMISSION:
            return "SYSTEM_ALERT_WINDOW_PERMISSION";
        case REASON_DEVICE_DEMO_MODE:
            return "DEVICE_DEMO_MODE";
        case REASON_ALLOWLISTED_PACKAGE:
            return "ALLOWLISTED_PACKAGE";
        case REASON_APPOP:
            return "APPOP";
        case REASON_ACTIVITY_VISIBILITY_GRACE_PERIOD:
            return "ACTIVITY_VISIBILITY_GRACE_PERIOD";
        case REASON_OP_ACTIVATE_VPN:
            return "OP_ACTIVATE_VPN";
        case REASON_OP_ACTIVATE_PLATFORM_VPN:
            return "OP_ACTIVATE_PLATFORM_VPN";
        case REASON_CURRENT_INPUT_METHOD:
            return "CURRENT_INPUT_METHOD";
        case REASON_TEMP_ALLOWED_WHILE_IN_USE:
            return "TEMP_ALLOWED_WHILE_IN_USE";
        case REASON_GEOFENCING:
            return "GEOFENCING";
        case REASON_PUSH_MESSAGING:
            return "PUSH_MESSAGING";
        case REASON_PUSH_MESSAGING_OVER_QUOTA:
            return "PUSH_MESSAGING_OVER_QUOTA";
        case REASON_ACTIVITY_RECOGNITION:
            return "ACTIVITY_RECOGNITION";
        case REASON_ACCOUNT_TRANSFER:
            return "REASON_ACCOUNT_TRANSFER";
        case REASON_BOOT_COMPLETED:
            return "BOOT_COMPLETED";
        case REASON_PRE_BOOT_COMPLETED:
            return "PRE_BOOT_COMPLETED";
        case REASON_LOCKED_BOOT_COMPLETED:
            return "LOCKED_BOOT_COMPLETED";
        case REASON_BLUETOOTH_BROADCAST:
            return "BLUETOOTH_BROADCAST";
        case REASON_TIMEZONE_CHANGED:
            return "TIMEZONE_CHANGED";
        case REASON_TIME_CHANGED:
            return "TIME_CHANGED";
        case REASON_LOCALE_CHANGED:
            return "LOCALE_CHANGED";
        case REASON_SCHEDULE_EXACT_ALARM_PERMISSION_STATE_CHANGED:
            return "REASON_SCHEDULE_EXACT_ALARM_PERMISSION_STATE_CHANGED";
        case REASON_REFRESH_SAFETY_SOURCES:
            return "REASON_REFRESH_SAFETY_SOURCES";
        case REASON_SYSTEM_ALLOW_LISTED:
            return "SYSTEM_ALLOW_LISTED";
        case REASON_ALARM_MANAGER_ALARM_CLOCK:
            return "ALARM_MANAGER_ALARM_CLOCK";
        case REASON_ALARM_MANAGER_WHILE_IDLE:
            return "ALARM_MANAGER_WHILE_IDLE";
        case REASON_SERVICE_LAUNCH:
            return "SERVICE_LAUNCH";
        case REASON_KEY_CHAIN:
            return "KEY_CHAIN";
        case REASON_PACKAGE_VERIFIER:
            return "PACKAGE_VERIFIER";
        case REASON_SYNC_MANAGER:
            return "SYNC_MANAGER";
        case REASON_DOMAIN_VERIFICATION_V1:
            return "DOMAIN_VERIFICATION_V1";
        case REASON_DOMAIN_VERIFICATION_V2:
            return "DOMAIN_VERIFICATION_V2";
        case REASON_VPN:
            return "VPN";
        case REASON_NOTIFICATION_SERVICE:
            return "NOTIFICATION_SERVICE";
        case REASON_PACKAGE_REPLACED:
            return "PACKAGE_REPLACED";
        case REASON_LOCATION_PROVIDER:
            return "LOCATION_PROVIDER";
        case REASON_MEDIA_BUTTON:
            return "MEDIA_BUTTON";
        case REASON_EVENT_SMS:
            return "EVENT_SMS";
        case REASON_EVENT_MMS:
            return "EVENT_MMS";
        case REASON_SHELL:
            return "SHELL";
        case REASON_MEDIA_SESSION_CALLBACK:
            return "MEDIA_SESSION_CALLBACK";
        case REASON_ROLE_DIALER:
            return "ROLE_DIALER";
        case REASON_ROLE_EMERGENCY:
            return "ROLE_EMERGENCY";
        case REASON_SYSTEM_MODULE:
            return "SYSTEM_MODULE";
        case REASON_CARRIER_PRIVILEGED_APP:
            return "CARRIER_PRIVILEGED_APP";
        case REASON_DPO_PROTECTED_APP:
            return "DPO_PROTECTED_APP";
        case REASON_DISALLOW_APPS_CONTROL:
            return "DISALLOW_APPS_CONTROL";
        case REASON_ACTIVE_DEVICE_ADMIN:
            return "ACTIVE_DEVICE_ADMIN";
        case REASON_OPT_OUT_REQUESTED:
            return "REASON_OPT_OUT_REQUESTED";
        case REASON_MEDIA_NOTIFICATION_TRANSFER:
            return "REASON_MEDIA_NOTIFICATION_TRANSFER";
        default:
            return "(unknown:" + reasonCode + ")";
    }
}
------------------------
Find a silently evolved API code:android.view.animation.Transformation.compose:COMMENT
Method Modifier: public      
Comment:/**
 * Apply this Transformation to an existing Transformation, e.g. apply
 * a scale effect to something that has already been rotated.
 * @param t
 */

Body of Frist Method:
{
    mAlpha *= t.getAlpha();
    mMatrix.preConcat(t.getMatrix());
    if (t.mHasClipRect) {
        Rect bounds = t.getClipRect();
        if (mHasClipRect) {
            setClipRect(mClipRect.left + bounds.left, mClipRect.top + bounds.top, mClipRect.right + bounds.right, mClipRect.bottom + bounds.bottom);
        } else {
            setClipRect(bounds);
        }
    }
}
Body of Second Method:
{
    mAlpha *= t.getAlpha();
    mMatrix.preConcat(t.getMatrix());
    if (t.mHasClipRect) {
        Rect bounds = t.getClipRect();
        if (mHasClipRect) {
            setClipRect(mClipRect.left + bounds.left, mClipRect.top + bounds.top, mClipRect.right + bounds.right, mClipRect.bottom + bounds.bottom);
        } else {
            setClipRect(bounds);
        }
    }
    setInsets(Insets.add(getInsets(), t.getInsets()));
}
------------------------
Find a silently evolved API code:android.os.UidBatteryConsumer.writeToXml:COMMENT
Method Modifier: default     hidden      
Comment:/**
 * Serializes this object to XML
 */

Body of Frist Method:
{
    if (getConsumedPower() == 0) {
        return;
    }
    serializer.startTag(null, BatteryUsageStats.XML_TAG_UID);
    serializer.attributeInt(null, BatteryUsageStats.XML_ATTR_UID, getUid());
    if (!TextUtils.isEmpty(mPackageWithHighestDrain)) {
        serializer.attribute(null, BatteryUsageStats.XML_ATTR_HIGHEST_DRAIN_PACKAGE, mPackageWithHighestDrain);
    }
    serializer.attributeLong(null, BatteryUsageStats.XML_ATTR_TIME_IN_FOREGROUND, mTimeInForegroundMs);
    serializer.attributeLong(null, BatteryUsageStats.XML_ATTR_TIME_IN_BACKGROUND, mTimeInBackgroundMs);
    mPowerComponents.writeToXml(serializer);
    serializer.endTag(null, BatteryUsageStats.XML_TAG_UID);
}
Body of Second Method:
{
    if (getConsumedPower() == 0) {
        return;
    }
    serializer.startTag(null, BatteryUsageStats.XML_TAG_UID);
    serializer.attributeInt(null, BatteryUsageStats.XML_ATTR_UID, getUid());
    final String packageWithHighestDrain = getPackageWithHighestDrain();
    if (!TextUtils.isEmpty(packageWithHighestDrain)) {
        serializer.attribute(null, BatteryUsageStats.XML_ATTR_HIGHEST_DRAIN_PACKAGE, packageWithHighestDrain);
    }
    serializer.attributeLong(null, BatteryUsageStats.XML_ATTR_TIME_IN_FOREGROUND, getTimeInStateMs(STATE_FOREGROUND));
    serializer.attributeLong(null, BatteryUsageStats.XML_ATTR_TIME_IN_BACKGROUND, getTimeInStateMs(STATE_BACKGROUND));
    mPowerComponents.writeToXml(serializer);
    serializer.endTag(null, BatteryUsageStats.XML_TAG_UID);
}
------------------------
Find a silently evolved API code:android.os.SystemClock.setCurrentTimeMillis:COMMENT
Method Modifier: public      static      
Comment:/**
 * Sets the current wall time, in milliseconds.  Requires the calling
 * process to have appropriate permissions.
 *
 * @return if the clock was successfully set to the specified time.
 */

Body of Frist Method:
{
    final IAlarmManager mgr = IAlarmManager.Stub.asInterface(ServiceManager.getService(Context.ALARM_SERVICE));
    if (mgr == null) {
        Slog.e(TAG, "Unable to set RTC: mgr == null");
        return false;
    }
    try {
        return mgr.setTime(millis);
    } catch (RemoteException e) {
        Slog.e(TAG, "Unable to set RTC", e);
    } catch (SecurityException e) {
        Slog.e(TAG, "Unable to set RTC", e);
    }
    return false;
}
Body of Second Method:
{
    final IAlarmManager mgr = getIAlarmManager();
    if (mgr == null) {
        Slog.e(TAG, "Unable to set RTC: mgr == null");
        return false;
    }
    try {
        return mgr.setTime(millis);
    } catch (RemoteException e) {
        Slog.e(TAG, "Unable to set RTC", e);
    } catch (SecurityException e) {
        Slog.e(TAG, "Unable to set RTC", e);
    }
    return false;
}
------------------------
Find a silently evolved API code:android.os.Vibrator.getHapticChannelMaximumAmplitude:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Return the maximum amplitude the vibrator can play using the audio haptic channels.
 *
 * <p>This is a positive value, or {@link Float#NaN NaN} if it's unknown. If this returns a
 * positive value <code>maxAmplitude</code>, then the signals from the haptic channels of audio
 * tracks should be in the range <code>[-maxAmplitude, maxAmplitude]</code>.
 *
 * @return a positive value representing the maximum absolute value the device can play signals
 * from audio haptic channels, or {@link Float#NaN NaN} if it's unknown.
 * @hide
 */

Body of Frist Method:
{
    if (mHapticChannelMaxVibrationAmplitude <= 0) {
        return Float.NaN;
    }
    return mHapticChannelMaxVibrationAmplitude;
}
Body of Second Method:
{
    return getConfig().getHapticChannelMaximumAmplitude();
}
------------------------
Find a silently evolved API code:android.hardware.usb.UsbRequest.initialize:COMMENT
Method Modifier: public      
Comment:/**
 * Initializes the request so it can read or write data on the given endpoint.
 * Whether the request allows reading or writing depends on the direction of the endpoint.
 *
 * @param endpoint the endpoint to be used for this request.
 * @return true if the request was successfully opened.
 */

Body of Frist Method:
{
    mEndpoint = endpoint;
    mConnection = Objects.requireNonNull(connection, "connection");
    boolean wasInitialized = native_init(connection, endpoint.getAddress(), endpoint.getAttributes(), endpoint.getMaxPacketSize(), endpoint.getInterval());
    if (wasInitialized) {
        mCloseGuard.open("close");
    }
    return wasInitialized;
}
Body of Second Method:
{
    mEndpoint = endpoint;
    mConnection = Objects.requireNonNull(connection, "connection");
    boolean wasInitialized = native_init(connection, endpoint.getAddress(), endpoint.getAttributes(), endpoint.getMaxPacketSize(), endpoint.getInterval());
    if (wasInitialized) {
        mCloseGuard.open("UsbRequest.close");
    }
    return wasInitialized;
}
------------------------
Find a silently evolved API code:android.app.servertransaction.LaunchActivityItem.setValues:COMMENT
Method Modifier: private     static      hidden      
Comment:// Using the same method to set and clear values to make sure we don't forget anything

Body of Frist Method:
{
    instance.mIntent = intent;
    instance.mIdent = ident;
    instance.mInfo = info;
    instance.mCurConfig = curConfig;
    instance.mOverrideConfig = overrideConfig;
    instance.mCompatInfo = compatInfo;
    instance.mReferrer = referrer;
    instance.mVoiceInteractor = voiceInteractor;
    instance.mProcState = procState;
    instance.mState = state;
    instance.mPersistentState = persistentState;
    instance.mPendingResults = pendingResults;
    instance.mPendingNewIntents = pendingNewIntents;
    instance.mActivityOptions = activityOptions;
    instance.mIsForward = isForward;
    instance.mProfilerInfo = profilerInfo;
    instance.mAssistToken = assistToken;
    instance.mActivityClientController = activityClientController;
    instance.mFixedRotationAdjustments = fixedRotationAdjustments;
    instance.mShareableActivityToken = shareableActivityToken;
    instance.mLaunchedFromBubble = launchedFromBubble;
}
Body of Second Method:
{
    instance.mIntent = intent;
    instance.mIdent = ident;
    instance.mInfo = info;
    instance.mCurConfig = curConfig;
    instance.mOverrideConfig = overrideConfig;
    instance.mCompatInfo = compatInfo;
    instance.mReferrer = referrer;
    instance.mVoiceInteractor = voiceInteractor;
    instance.mProcState = procState;
    instance.mState = state;
    instance.mPersistentState = persistentState;
    instance.mPendingResults = pendingResults;
    instance.mPendingNewIntents = pendingNewIntents;
    instance.mActivityOptions = activityOptions;
    instance.mIsForward = isForward;
    instance.mProfilerInfo = profilerInfo;
    instance.mAssistToken = assistToken;
    instance.mActivityClientController = activityClientController;
    instance.mShareableActivityToken = shareableActivityToken;
    instance.mLaunchedFromBubble = launchedFromBubble;
    instance.mTaskFragmentToken = taskFragmentToken;
}
------------------------
Find a silently evolved API code:android.widget.ListPopupWindow.onKeyPreIme:COMMENT
Method Modifier: public      
Comment:/**
 * Filter pre-IME key events. By forwarding {@link View#onKeyPreIme(int, KeyEvent)}
 * events to this function, views using ListPopupWindow can have it dismiss the popup
 * when the back key is pressed.
 *
 * @param keyCode keyCode param passed to the host view's onKeyPreIme
 * @param event event param passed to the host view's onKeyPreIme
 * @return true if the event was handled, false if it was ignored.
 *
 * @see #setModal(boolean)
 */

Body of Frist Method:
{
    if (keyCode == KeyEvent.KEYCODE_BACK && isShowing()) {
        // special case for the back key, we do not even try to send it
        // to the drop down list but instead, consume it immediately
        final View anchorView = mDropDownAnchorView;
        if (event.getAction() == KeyEvent.ACTION_DOWN && event.getRepeatCount() == 0) {
            KeyEvent.DispatcherState state = anchorView.getKeyDispatcherState();
            if (state != null) {
                state.startTracking(event, this);
            }
            return true;
        } else if (event.getAction() == KeyEvent.ACTION_UP) {
            KeyEvent.DispatcherState state = anchorView.getKeyDispatcherState();
            if (state != null) {
                state.handleUpEvent(event);
            }
            if (event.isTracking() && !event.isCanceled()) {
                dismiss();
                return true;
            }
        }
    }
    return false;
}
Body of Second Method:
{
    if ((keyCode == KeyEvent.KEYCODE_BACK || keyCode == KeyEvent.KEYCODE_ESCAPE) && isShowing()) {
        // special case for the back key, we do not even try to send it
        // to the drop down list but instead, consume it immediately
        final View anchorView = mDropDownAnchorView;
        if (event.getAction() == KeyEvent.ACTION_DOWN && event.getRepeatCount() == 0) {
            KeyEvent.DispatcherState state = anchorView.getKeyDispatcherState();
            if (state != null) {
                state.startTracking(event, this);
            }
            return true;
        } else if (event.getAction() == KeyEvent.ACTION_UP) {
            KeyEvent.DispatcherState state = anchorView.getKeyDispatcherState();
            if (state != null) {
                state.handleUpEvent(event);
            }
            if (event.isTracking() && !event.isCanceled()) {
                dismiss();
                return true;
            }
        }
    }
    return false;
}
------------------------
Find a silently evolved API code:android.graphics.Picture.endRecording:COMMENT
Method Modifier: public      
Comment:/**
 * Call endRecording when the picture is built. After this call, the picture
 * may be drawn, but the canvas that was returned by beginRecording must not
 * be used anymore. This is automatically called if {@link Picture#draw}
 * or {@link Canvas#drawPicture(Picture)} is called.
 */

Body of Frist Method:
{
    verifyValid();
    if (mRecordingCanvas != null) {
        mRequiresHwAcceleration = mRecordingCanvas.mHoldsHwBitmap;
        mRecordingCanvas = null;
        nativeEndRecording(mNativePicture);
    }
}
Body of Second Method:
{
    verifyValid();
    if (mRecordingCanvas != null) {
        mRequiresHwAcceleration = mRecordingCanvas.mUsesHwFeature;
        mRecordingCanvas = null;
        nativeEndRecording(mNativePicture);
    }
}
------------------------
Find a silently evolved API code:android.window.WindowContextController.attachToDisplayArea:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Attaches the {@code mToken} to a {@link com.android.server.wm.DisplayArea}.
 *
 * @param type The window type of the {@link WindowContext}
 * @param displayId The {@link Context#getDisplayId() ID of display} to associate with
 * @param options The window context launched option
 * @throws IllegalStateException if the {@code mToken} has already been attached to a
 * DisplayArea.
 */

Body of Frist Method:
{
    if (mAttachedToDisplayArea) {
        throw new IllegalStateException("A Window Context can be only attached to " + "a DisplayArea once.");
    }
    mAttachedToDisplayArea = mToken.attachToDisplayArea(type, displayId, options);
}
Body of Second Method:
{
    if (mAttachedToDisplayArea == AttachStatus.STATUS_ATTACHED) {
        throw new IllegalStateException("A Window Context can be only attached to " + "a DisplayArea once.");
    }
    mAttachedToDisplayArea = mToken.attachToDisplayArea(type, displayId, options) ? AttachStatus.STATUS_ATTACHED : AttachStatus.STATUS_FAILED;
    if (mAttachedToDisplayArea == AttachStatus.STATUS_FAILED) {
        Log.w(TAG, "attachToDisplayArea fail, type:" + type + ", displayId:" + displayId);
    } else if (DEBUG_ATTACH) {
        Log.d(TAG, "attachToDisplayArea success, type:" + type + ", displayId:" + displayId);
    }
}
------------------------
Find a silently evolved API code:android.graphics.text.MeasuredText.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Creates a MeasuredText.
 *
 * Once you called build() method, you can't reuse the Builder class again.
 * @throws IllegalStateException if this Builder is reused.
 * @throws IllegalStateException if the whole text is not covered by one or more runs (style
 * or replacement)
 */

Body of Frist Method:
{
    ensureNativePtrNoReuse();
    if (mCurrentOffset != mText.length) {
        throw new IllegalStateException("Style info has not been provided for all text.");
    }
    if (mHintMt != null && mHintMt.mComputeHyphenation != mComputeHyphenation) {
        throw new IllegalArgumentException("The hyphenation configuration is different from given hint MeasuredText");
    }
    try {
        long hintPtr = (mHintMt == null) ? 0 : mHintMt.getNativePtr();
        long ptr = nBuildMeasuredText(mNativePtr, hintPtr, mText, mComputeHyphenation, mComputeLayout);
        final MeasuredText res = new MeasuredText(ptr, mText, mComputeHyphenation, mComputeLayout);
        sRegistry.registerNativeAllocation(res, ptr);
        return res;
    } finally {
        nFreeBuilder(mNativePtr);
        mNativePtr = 0;
    }
}
Body of Second Method:
{
    ensureNativePtrNoReuse();
    if (mCurrentOffset != mText.length) {
        throw new IllegalStateException("Style info has not been provided for all text.");
    }
    if (mHintMt != null && mHintMt.mComputeHyphenation != mComputeHyphenation) {
        throw new IllegalArgumentException("The hyphenation configuration is different from given hint MeasuredText");
    }
    try {
        long hintPtr = (mHintMt == null) ? 0 : mHintMt.getNativePtr();
        long ptr = nBuildMeasuredText(mNativePtr, hintPtr, mText, mComputeHyphenation, mComputeLayout, mFastHyphenation);
        final MeasuredText res = new MeasuredText(ptr, mText, mComputeHyphenation, mComputeLayout, mTop, mBottom);
        sRegistry.registerNativeAllocation(res, ptr);
        return res;
    } finally {
        nFreeBuilder(mNativePtr);
        mNativePtr = 0;
    }
}
------------------------
Find a silently evolved API code:android.app.usage.UsageEvents.getNextEvent:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the next {@link android.app.usage.UsageEvents.Event} from the collection and put the
 * resulting data into {@code eventOut}.
 *
 * @param eventOut The {@link android.app.usage.UsageEvents.Event} object that will receive the
 * next event data.
 * @return true if an event was available, false if there are no more events.
 */

Body of Frist Method:
{
    if (mIndex >= mEventCount) {
        return false;
    }
    if (mParcel != null) {
        readEventFromParcel(mParcel, eventOut);
    } else {
        eventOut.copyFrom(mEventsToWrite.get(mIndex));
    }
    mIndex++;
    if (mIndex >= mEventCount && mParcel != null) {
        mParcel.recycle();
        mParcel = null;
    }
    return true;
}
Body of Second Method:
{
    if (eventOut == null) {
        throw new IllegalArgumentException("Given eventOut must not be null");
    }
    if (mIndex >= mEventCount) {
        return false;
    }
    if (mParcel != null) {
        readEventFromParcel(mParcel, eventOut);
    } else {
        eventOut.copyFrom(mEventsToWrite.get(mIndex));
    }
    mIndex++;
    if (mIndex >= mEventCount && mParcel != null) {
        mParcel.recycle();
        mParcel = null;
    }
    return true;
}
------------------------
Find a silently evolved API code:android.widget.TimePickerClockDelegate.applyLegacyColorFixes:COMMENT
Method Modifier: private     
Comment:/**
 * The legacy text color might have been poorly defined. Ensures that it
 * has an appropriate activated state, using the selected state if one
 * exists or modifying the default text color otherwise.
 *
 * @param color a legacy text color, or {@code null}
 * @return a color state list with an appropriate activated state, or
 * {@code null} if a valid activated state could not be generated
 */

Body of Frist Method:
{
    if (color == null || color.hasState(R.attr.state_activated)) {
        return color;
    }
    final int activatedColor;
    final int defaultColor;
    if (color.hasState(R.attr.state_selected)) {
        activatedColor = color.getColorForState(StateSet.get(StateSet.VIEW_STATE_ENABLED | StateSet.VIEW_STATE_SELECTED), 0);
        defaultColor = color.getColorForState(StateSet.get(StateSet.VIEW_STATE_ENABLED), 0);
    } else {
        activatedColor = color.getDefaultColor();
        // Generate a non-activated color using the disabled alpha.
        final TypedArray ta = mContext.obtainStyledAttributes(ATTRS_DISABLED_ALPHA);
        final float disabledAlpha = ta.getFloat(0, 0.30f);
        defaultColor = multiplyAlphaComponent(activatedColor, disabledAlpha);
    }
    if (activatedColor == 0 || defaultColor == 0) {
        // We somehow failed to obtain the colors.
        return null;
    }
    final int[][] stateSet = new int[][] { { R.attr.state_activated }, {} };
    final int[] colors = new int[] { activatedColor, defaultColor };
    return new ColorStateList(stateSet, colors);
}
Body of Second Method:
{
    if (color == null || color.hasState(R.attr.state_activated)) {
        return color;
    }
    final int activatedColor;
    final int defaultColor;
    if (color.hasState(R.attr.state_selected)) {
        activatedColor = color.getColorForState(StateSet.get(StateSet.VIEW_STATE_ENABLED | StateSet.VIEW_STATE_SELECTED), 0);
        defaultColor = color.getColorForState(StateSet.get(StateSet.VIEW_STATE_ENABLED), 0);
    } else {
        activatedColor = color.getDefaultColor();
        // Generate a non-activated color using the disabled alpha.
        final TypedArray ta = mContext.obtainStyledAttributes(ATTRS_DISABLED_ALPHA);
        final float disabledAlpha = ta.getFloat(0, 0.30f);
        ta.recycle();
        defaultColor = multiplyAlphaComponent(activatedColor, disabledAlpha);
    }
    if (activatedColor == 0 || defaultColor == 0) {
        // We somehow failed to obtain the colors.
        return null;
    }
    final int[][] stateSet = new int[][] { { R.attr.state_activated }, {} };
    final int[] colors = new int[] { activatedColor, defaultColor };
    return new ColorStateList(stateSet, colors);
}
------------------------
Find a silently evolved API code:android.app.BroadcastOptions.toBundle:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns the created options as a Bundle, which can be passed to
 * {@link android.content.Context#sendBroadcast(android.content.Intent)
 * Context.sendBroadcast(Intent)} and related methods.
 * Note that the returned Bundle is still owned by the BroadcastOptions
 * object; you must not modify it, but can supply it to the sendBroadcast
 * methods that take an options Bundle.
 */

Body of Frist Method:
{
    Bundle b = new Bundle();
    if (isTemporaryAppAllowlistSet()) {
        b.putLong(KEY_TEMPORARY_APP_ALLOWLIST_DURATION, mTemporaryAppAllowlistDuration);
        b.putInt(KEY_TEMPORARY_APP_ALLOWLIST_TYPE, mTemporaryAppAllowlistType);
        b.putInt(KEY_TEMPORARY_APP_ALLOWLIST_REASON_CODE, mTemporaryAppAllowlistReasonCode);
        b.putString(KEY_TEMPORARY_APP_ALLOWLIST_REASON, mTemporaryAppAllowlistReason);
    }
    if (mMinManifestReceiverApiLevel != 0) {
        b.putInt(KEY_MIN_MANIFEST_RECEIVER_API_LEVEL, mMinManifestReceiverApiLevel);
    }
    if (mMaxManifestReceiverApiLevel != Build.VERSION_CODES.CUR_DEVELOPMENT) {
        b.putInt(KEY_MAX_MANIFEST_RECEIVER_API_LEVEL, mMaxManifestReceiverApiLevel);
    }
    if (mDontSendToRestrictedApps) {
        b.putBoolean(KEY_DONT_SEND_TO_RESTRICTED_APPS, true);
    }
    if (mAllowBackgroundActivityStarts) {
        b.putBoolean(KEY_ALLOW_BACKGROUND_ACTIVITY_STARTS, true);
    }
    return b.isEmpty() ? null : b;
}
Body of Second Method:
{
    Bundle b = super.toBundle();
    if (isTemporaryAppAllowlistSet()) {
        b.putLong(KEY_TEMPORARY_APP_ALLOWLIST_DURATION, mTemporaryAppAllowlistDuration);
        b.putInt(KEY_TEMPORARY_APP_ALLOWLIST_TYPE, mTemporaryAppAllowlistType);
        b.putInt(KEY_TEMPORARY_APP_ALLOWLIST_REASON_CODE, mTemporaryAppAllowlistReasonCode);
        b.putString(KEY_TEMPORARY_APP_ALLOWLIST_REASON, mTemporaryAppAllowlistReason);
    }
    if (mMinManifestReceiverApiLevel != 0) {
        b.putInt(KEY_MIN_MANIFEST_RECEIVER_API_LEVEL, mMinManifestReceiverApiLevel);
    }
    if (mMaxManifestReceiverApiLevel != Build.VERSION_CODES.CUR_DEVELOPMENT) {
        b.putInt(KEY_MAX_MANIFEST_RECEIVER_API_LEVEL, mMaxManifestReceiverApiLevel);
    }
    if (mDontSendToRestrictedApps) {
        b.putBoolean(KEY_DONT_SEND_TO_RESTRICTED_APPS, true);
    }
    if (mAllowBackgroundActivityStarts) {
        b.putBoolean(KEY_ALLOW_BACKGROUND_ACTIVITY_STARTS, true);
    }
    if (mRequireAllOfPermissions != null) {
        b.putStringArray(KEY_REQUIRE_ALL_OF_PERMISSIONS, mRequireAllOfPermissions);
    }
    if (mRequireNoneOfPermissions != null) {
        b.putStringArray(KEY_REQUIRE_NONE_OF_PERMISSIONS, mRequireNoneOfPermissions);
    }
    if (mRequireCompatChangeId != CHANGE_INVALID) {
        b.putLong(KEY_REQUIRE_COMPAT_CHANGE_ID, mRequireCompatChangeId);
        b.putBoolean(KEY_REQUIRE_COMPAT_CHANGE_ENABLED, mRequireCompatChangeEnabled);
    }
    if (mIdForResponseEvent != 0) {
        b.putLong(KEY_ID_FOR_RESPONSE_EVENT, mIdForResponseEvent);
    }
    return b.isEmpty() ? null : b;
}
------------------------
Find a silently evolved API code:android.os.incremental.IncrementalStorage.validateV4Signature:COMMENT
Method Modifier: private     static      hidden      
Comment:/**
 * Deserialize and validate v4 signature bytes.
 */

Body of Frist Method:
{
    if (v4signatureBytes == null || v4signatureBytes.length == 0) {
        return;
    }
    final V4Signature signature;
    try {
        signature = V4Signature.readFrom(v4signatureBytes);
    } catch (IOException e) {
        throw new IOException("Failed to read v4 signature:", e);
    }
    if (!signature.isVersionSupported()) {
        throw new IOException("v4 signature version " + signature.version + " is not supported");
    }
    final V4Signature.HashingInfo hashingInfo = V4Signature.HashingInfo.fromByteArray(signature.hashingInfo);
    final V4Signature.SigningInfo signingInfo = V4Signature.SigningInfo.fromByteArray(signature.signingInfo);
    if (hashingInfo.hashAlgorithm != V4Signature.HASHING_ALGORITHM_SHA256) {
        throw new IOException("Unsupported hashAlgorithm: " + hashingInfo.hashAlgorithm);
    }
    if (hashingInfo.log2BlockSize != V4Signature.LOG2_BLOCK_SIZE_4096_BYTES) {
        throw new IOException("Unsupported log2BlockSize: " + hashingInfo.log2BlockSize);
    }
    if (hashingInfo.salt != null && hashingInfo.salt.length > 0) {
        throw new IOException("Unsupported salt: " + hashingInfo.salt);
    }
    if (hashingInfo.rawRootHash.length != INCFS_MAX_HASH_SIZE) {
        throw new IOException("rawRootHash has to be " + INCFS_MAX_HASH_SIZE + " bytes");
    }
    if (signingInfo.additionalData.length > INCFS_MAX_ADD_DATA_SIZE) {
        throw new IOException("additionalData has to be at most " + INCFS_MAX_ADD_DATA_SIZE + " bytes");
    }
}
Body of Second Method:
{
    if (v4signatureBytes == null || v4signatureBytes.length == 0) {
        return;
    }
    final V4Signature signature;
    try {
        signature = V4Signature.readFrom(v4signatureBytes);
    } catch (IOException e) {
        throw new IOException("Failed to read v4 signature:", e);
    }
    if (!signature.isVersionSupported()) {
        throw new IOException("v4 signature version " + signature.version + " is not supported");
    }
    final V4Signature.HashingInfo hashingInfo = V4Signature.HashingInfo.fromByteArray(signature.hashingInfo);
    final V4Signature.SigningInfos signingInfos = V4Signature.SigningInfos.fromByteArray(signature.signingInfos);
    if (hashingInfo.hashAlgorithm != V4Signature.HASHING_ALGORITHM_SHA256) {
        throw new IOException("Unsupported hashAlgorithm: " + hashingInfo.hashAlgorithm);
    }
    if (hashingInfo.log2BlockSize != V4Signature.LOG2_BLOCK_SIZE_4096_BYTES) {
        throw new IOException("Unsupported log2BlockSize: " + hashingInfo.log2BlockSize);
    }
    if (hashingInfo.salt != null && hashingInfo.salt.length > 0) {
        throw new IOException("Unsupported salt: " + hashingInfo.salt);
    }
    if (hashingInfo.rawRootHash.length != INCFS_MAX_HASH_SIZE) {
        throw new IOException("rawRootHash has to be " + INCFS_MAX_HASH_SIZE + " bytes");
    }
    if (signingInfos.signingInfo.additionalData.length > INCFS_MAX_ADD_DATA_SIZE) {
        throw new IOException("additionalData has to be at most " + INCFS_MAX_ADD_DATA_SIZE + " bytes");
    }
}
------------------------
Find a silently evolved API code:android.nfc.Tag.getTagService:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return mTagService;
}
Body of Second Method:
{
    if (mTagService == null) {
        return null;
    }
    try {
        if (!mTagService.isTagUpToDate(mCookie)) {
            String id_str = "";
            for (int i = 0; i < mId.length; i++) {
                id_str = id_str + String.format("%02X ", mId[i]);
            }
            String msg = "Permission Denial: Tag ( ID: " + id_str + ") is out of date";
            throw new SecurityException(msg);
        }
    } catch (RemoteException e) {
        throw e.rethrowAsRuntimeException();
    }
    return mTagService;
}
------------------------
Find a silently evolved API code:android.hardware.camera2.params.OutputConfiguration.hashCode:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    // surface is set.
    if (mIsDeferredConfig) {
        return HashCodeHelpers.hashCode(mRotation, mConfiguredSize.hashCode(), mConfiguredFormat, mConfiguredDataspace, mSurfaceGroupId, mSurfaceType, mIsShared ? 1 : 0, mPhysicalCameraId == null ? 0 : mPhysicalCameraId.hashCode(), mIsMultiResolution ? 1 : 0, mSensorPixelModesUsed.hashCode());
    }
    return HashCodeHelpers.hashCode(mRotation, mSurfaces.hashCode(), mConfiguredGenerationId, mConfiguredSize.hashCode(), mConfiguredFormat, mConfiguredDataspace, mSurfaceGroupId, mIsShared ? 1 : 0, mPhysicalCameraId == null ? 0 : mPhysicalCameraId.hashCode(), mIsMultiResolution ? 1 : 0, mSensorPixelModesUsed.hashCode());
}
Body of Second Method:
{
    // surface is set.
    if (mIsDeferredConfig) {
        return HashCodeHelpers.hashCode(mRotation, mConfiguredSize.hashCode(), mConfiguredFormat, mConfiguredDataspace, mSurfaceGroupId, mSurfaceType, mIsShared ? 1 : 0, mPhysicalCameraId == null ? 0 : mPhysicalCameraId.hashCode(), mIsMultiResolution ? 1 : 0, mSensorPixelModesUsed.hashCode(), mDynamicRangeProfile, mStreamUseCase, mTimestampBase, mMirrorMode);
    }
    return HashCodeHelpers.hashCode(mRotation, mSurfaces.hashCode(), mConfiguredGenerationId, mConfiguredSize.hashCode(), mConfiguredFormat, mConfiguredDataspace, mSurfaceGroupId, mIsShared ? 1 : 0, mPhysicalCameraId == null ? 0 : mPhysicalCameraId.hashCode(), mIsMultiResolution ? 1 : 0, mSensorPixelModesUsed.hashCode(), mDynamicRangeProfile, mStreamUseCase, mTimestampBase, mMirrorMode);
}
------------------------
Find a silently evolved API code:android.view.inputmethod.CursorAnchorInfo.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Used to package this object into a {@link Parcel}.
 *
 * @param dest The {@link Parcel} to be written.
 * @param flags The flags used for parceling.
 */

Body of Frist Method:
{
    dest.writeInt(mHashCode);
    dest.writeInt(mSelectionStart);
    dest.writeInt(mSelectionEnd);
    dest.writeInt(mComposingTextStart);
    TextUtils.writeToParcel(mComposingText, dest, flags);
    dest.writeInt(mInsertionMarkerFlags);
    dest.writeFloat(mInsertionMarkerHorizontal);
    dest.writeFloat(mInsertionMarkerTop);
    dest.writeFloat(mInsertionMarkerBaseline);
    dest.writeFloat(mInsertionMarkerBottom);
    dest.writeParcelable(mCharacterBoundsArray, flags);
    dest.writeFloatArray(mMatrixValues);
}
Body of Second Method:
{
    dest.writeInt(mHashCode);
    dest.writeInt(mSelectionStart);
    dest.writeInt(mSelectionEnd);
    dest.writeInt(mComposingTextStart);
    TextUtils.writeToParcel(mComposingText, dest, flags);
    dest.writeInt(mInsertionMarkerFlags);
    dest.writeFloat(mInsertionMarkerHorizontal);
    dest.writeFloat(mInsertionMarkerTop);
    dest.writeFloat(mInsertionMarkerBaseline);
    dest.writeFloat(mInsertionMarkerBottom);
    dest.writeParcelable(mCharacterBoundsArray, flags);
    dest.writeTypedObject(mEditorBoundsInfo, flags);
    dest.writeFloatArray(mMatrixValues);
}
------------------------
Find a silently evolved API code:android.text.method.TextKeyListener.getPrefs:COMMENT
Method Modifier: default     
Comment:/* package */

Body of Frist Method:
{
    synchronized (this) {
        if (!mPrefsInited || mResolver.get() == null) {
            initPrefs(context);
        }
    }
    return mPrefs;
}
Body of Second Method:
{
    synchronized (this) {
        if (!mPrefsInited || mResolver.refersTo(null)) {
            initPrefs(context);
        }
    }
    return mPrefs;
}
------------------------
Find a silently evolved API code:android.media.tv.tuner.TunerUtils.getFilterSubtype:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Gets the corresponding filter subtype constant defined in tuner HAL.
 *
 * @param mainType filter main type.
 * @param subtype filter subtype.
 */

Body of Frist Method:
{
    if (mainType == Filter.TYPE_TS) {
        switch(subtype) {
            case Filter.SUBTYPE_UNDEFINED:
                return Constants.DemuxTsFilterType.UNDEFINED;
            case Filter.SUBTYPE_SECTION:
                return Constants.DemuxTsFilterType.SECTION;
            case Filter.SUBTYPE_PES:
                return Constants.DemuxTsFilterType.PES;
            case Filter.SUBTYPE_TS:
                return Constants.DemuxTsFilterType.TS;
            case Filter.SUBTYPE_AUDIO:
                return Constants.DemuxTsFilterType.AUDIO;
            case Filter.SUBTYPE_VIDEO:
                return Constants.DemuxTsFilterType.VIDEO;
            case Filter.SUBTYPE_PCR:
                return Constants.DemuxTsFilterType.PCR;
            case Filter.SUBTYPE_RECORD:
                return Constants.DemuxTsFilterType.RECORD;
            case Filter.SUBTYPE_TEMI:
                return Constants.DemuxTsFilterType.TEMI;
            default:
                break;
        }
    } else if (mainType == Filter.TYPE_MMTP) {
        switch(subtype) {
            case Filter.SUBTYPE_UNDEFINED:
                return Constants.DemuxMmtpFilterType.UNDEFINED;
            case Filter.SUBTYPE_SECTION:
                return Constants.DemuxMmtpFilterType.SECTION;
            case Filter.SUBTYPE_PES:
                return Constants.DemuxMmtpFilterType.PES;
            case Filter.SUBTYPE_MMTP:
                return Constants.DemuxMmtpFilterType.MMTP;
            case Filter.SUBTYPE_AUDIO:
                return Constants.DemuxMmtpFilterType.AUDIO;
            case Filter.SUBTYPE_VIDEO:
                return Constants.DemuxMmtpFilterType.VIDEO;
            case Filter.SUBTYPE_RECORD:
                return Constants.DemuxMmtpFilterType.RECORD;
            case Filter.SUBTYPE_DOWNLOAD:
                return Constants.DemuxMmtpFilterType.DOWNLOAD;
            default:
                break;
        }
    } else if (mainType == Filter.TYPE_IP) {
        switch(subtype) {
            case Filter.SUBTYPE_UNDEFINED:
                return Constants.DemuxIpFilterType.UNDEFINED;
            case Filter.SUBTYPE_SECTION:
                return Constants.DemuxIpFilterType.SECTION;
            case Filter.SUBTYPE_NTP:
                return Constants.DemuxIpFilterType.NTP;
            case Filter.SUBTYPE_IP_PAYLOAD:
                return Constants.DemuxIpFilterType.IP_PAYLOAD;
            case Filter.SUBTYPE_IP:
                return Constants.DemuxIpFilterType.IP;
            case Filter.SUBTYPE_PAYLOAD_THROUGH:
                return Constants.DemuxIpFilterType.PAYLOAD_THROUGH;
            default:
                break;
        }
    } else if (mainType == Filter.TYPE_TLV) {
        switch(subtype) {
            case Filter.SUBTYPE_UNDEFINED:
                return Constants.DemuxTlvFilterType.UNDEFINED;
            case Filter.SUBTYPE_SECTION:
                return Constants.DemuxTlvFilterType.SECTION;
            case Filter.SUBTYPE_TLV:
                return Constants.DemuxTlvFilterType.TLV;
            case Filter.SUBTYPE_PAYLOAD_THROUGH:
                return Constants.DemuxTlvFilterType.PAYLOAD_THROUGH;
            default:
                break;
        }
    } else if (mainType == Filter.TYPE_ALP) {
        switch(subtype) {
            case Filter.SUBTYPE_UNDEFINED:
                return Constants.DemuxAlpFilterType.UNDEFINED;
            case Filter.SUBTYPE_SECTION:
                return Constants.DemuxAlpFilterType.SECTION;
            case Filter.SUBTYPE_PTP:
                return Constants.DemuxAlpFilterType.PTP;
            case Filter.SUBTYPE_PAYLOAD_THROUGH:
                return Constants.DemuxAlpFilterType.PAYLOAD_THROUGH;
            default:
                break;
        }
    }
    throw new IllegalArgumentException("Invalid filter types. Main type=" + mainType + ", subtype=" + subtype);
}
Body of Second Method:
{
    if (mainType == Filter.TYPE_TS) {
        switch(subtype) {
            case Filter.SUBTYPE_UNDEFINED:
                return DemuxTsFilterType.UNDEFINED;
            case Filter.SUBTYPE_SECTION:
                return DemuxTsFilterType.SECTION;
            case Filter.SUBTYPE_PES:
                return DemuxTsFilterType.PES;
            case Filter.SUBTYPE_TS:
                return DemuxTsFilterType.TS;
            case Filter.SUBTYPE_AUDIO:
                return DemuxTsFilterType.AUDIO;
            case Filter.SUBTYPE_VIDEO:
                return DemuxTsFilterType.VIDEO;
            case Filter.SUBTYPE_PCR:
                return DemuxTsFilterType.PCR;
            case Filter.SUBTYPE_RECORD:
                return DemuxTsFilterType.RECORD;
            case Filter.SUBTYPE_TEMI:
                return DemuxTsFilterType.TEMI;
            default:
                break;
        }
    } else if (mainType == Filter.TYPE_MMTP) {
        switch(subtype) {
            case Filter.SUBTYPE_UNDEFINED:
                return DemuxMmtpFilterType.UNDEFINED;
            case Filter.SUBTYPE_SECTION:
                return DemuxMmtpFilterType.SECTION;
            case Filter.SUBTYPE_PES:
                return DemuxMmtpFilterType.PES;
            case Filter.SUBTYPE_MMTP:
                return DemuxMmtpFilterType.MMTP;
            case Filter.SUBTYPE_AUDIO:
                return DemuxMmtpFilterType.AUDIO;
            case Filter.SUBTYPE_VIDEO:
                return DemuxMmtpFilterType.VIDEO;
            case Filter.SUBTYPE_RECORD:
                return DemuxMmtpFilterType.RECORD;
            case Filter.SUBTYPE_DOWNLOAD:
                return DemuxMmtpFilterType.DOWNLOAD;
            default:
                break;
        }
    } else if (mainType == Filter.TYPE_IP) {
        switch(subtype) {
            case Filter.SUBTYPE_UNDEFINED:
                return DemuxIpFilterType.UNDEFINED;
            case Filter.SUBTYPE_SECTION:
                return DemuxIpFilterType.SECTION;
            case Filter.SUBTYPE_NTP:
                return DemuxIpFilterType.NTP;
            case Filter.SUBTYPE_IP_PAYLOAD:
                return DemuxIpFilterType.IP_PAYLOAD;
            case Filter.SUBTYPE_IP:
                return DemuxIpFilterType.IP;
            case Filter.SUBTYPE_PAYLOAD_THROUGH:
                return DemuxIpFilterType.PAYLOAD_THROUGH;
            default:
                break;
        }
    } else if (mainType == Filter.TYPE_TLV) {
        switch(subtype) {
            case Filter.SUBTYPE_UNDEFINED:
                return DemuxTlvFilterType.UNDEFINED;
            case Filter.SUBTYPE_SECTION:
                return DemuxTlvFilterType.SECTION;
            case Filter.SUBTYPE_TLV:
                return DemuxTlvFilterType.TLV;
            case Filter.SUBTYPE_PAYLOAD_THROUGH:
                return DemuxTlvFilterType.PAYLOAD_THROUGH;
            default:
                break;
        }
    } else if (mainType == Filter.TYPE_ALP) {
        switch(subtype) {
            case Filter.SUBTYPE_UNDEFINED:
                return DemuxAlpFilterType.UNDEFINED;
            case Filter.SUBTYPE_SECTION:
                return DemuxAlpFilterType.SECTION;
            case Filter.SUBTYPE_PTP:
                return DemuxAlpFilterType.PTP;
            case Filter.SUBTYPE_PAYLOAD_THROUGH:
                return DemuxAlpFilterType.PAYLOAD_THROUGH;
            default:
                break;
        }
    }
    throw new IllegalArgumentException("Invalid filter types. Main type=" + mainType + ", subtype=" + subtype);
}
------------------------
Find a silently evolved API code:android.view.KeyEvent.getEventTime:COMMENT
Method Modifier: public      final       
Comment:/**
 * Retrieve the time this event occurred,
 * in the {@link android.os.SystemClock#uptimeMillis} time base.
 *
 * @return Returns the time this event occurred,
 * in the {@link android.os.SystemClock#uptimeMillis} time base.
 */

Body of Frist Method:
{
    return mEventTime;
}
Body of Second Method:
{
    return TimeUnit.MILLISECONDS.convert(mEventTime, TimeUnit.NANOSECONDS);
}
------------------------
Find a silently evolved API code:android.widget.ProgressBar.setIndeterminate:COMMENT
Method Modifier: public      
Comment:/**
 * <p>Change the indeterminate mode for this progress bar. In indeterminate
 * mode, the progress is ignored and the progress bar shows an infinite
 * animation instead.</p>
 *
 * If this progress bar's style only supports indeterminate mode (such as the circular
 * progress bars), then this will be ignored.
 *
 * @param indeterminate true to enable the indeterminate mode
 */

Body of Frist Method:
{
    if ((!mOnlyIndeterminate || !mIndeterminate) && indeterminate != mIndeterminate) {
        mIndeterminate = indeterminate;
        if (indeterminate) {
            // swap between indeterminate and regular backgrounds
            swapCurrentDrawable(mIndeterminateDrawable);
            startAnimation();
        } else {
            swapCurrentDrawable(mProgressDrawable);
            stopAnimation();
        }
    }
}
Body of Second Method:
{
    if ((!mOnlyIndeterminate || !mIndeterminate) && indeterminate != mIndeterminate) {
        mIndeterminate = indeterminate;
        if (indeterminate) {
            // swap between indeterminate and regular backgrounds
            swapCurrentDrawable(mIndeterminateDrawable);
            startAnimation();
        } else {
            swapCurrentDrawable(mProgressDrawable);
            stopAnimation();
        }
        notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_UNDEFINED);
    }
}
------------------------
Find a silently evolved API code:android.hardware.camera2.utils.SurfaceUtils.isSurfaceForHwVideoEncoder:COMMENT
Method Modifier: public      static      
Comment:/**
 * Check if the surface is for hardware video encoder consumer based on consumer end point
 * Gralloc usage flags.
 *
 * @param surface The surface to be checked.
 * @return true if the surface is for hardware video encoder consumer, false otherwise.
 */

Body of Frist Method:
{
    checkNotNull(surface);
    long usageFlags = nativeDetectSurfaceUsageFlags(surface);
    long disallowedFlags = HardwareBuffer.USAGE_GPU_SAMPLED_IMAGE | USAGE_HW_COMPOSER | USAGE_RENDERSCRIPT | HardwareBuffer.USAGE_CPU_READ_OFTEN;
    long allowedFlags = HardwareBuffer.USAGE_VIDEO_ENCODE;
    boolean videoEncoderConsumer = ((usageFlags & disallowedFlags) == 0 && (usageFlags & allowedFlags) != 0);
    int surfaceFormat = getSurfaceFormat(surface);
    return videoEncoderConsumer;
}
Body of Second Method:
{
    checkNotNull(surface);
    long usageFlags = nativeDetectSurfaceUsageFlags(surface);
    long disallowedFlags = USAGE_HW_COMPOSER | USAGE_RENDERSCRIPT | HardwareBuffer.USAGE_CPU_READ_OFTEN;
    long allowedFlags = HardwareBuffer.USAGE_VIDEO_ENCODE;
    boolean videoEncoderConsumer = ((usageFlags & disallowedFlags) == 0 && (usageFlags & allowedFlags) != 0);
    int surfaceFormat = getSurfaceFormat(surface);
    return videoEncoderConsumer;
}
------------------------
Find a silently evolved API code:android.content.pm.SigningInfo.hasMultipleSigners:COMMENT
Method Modifier: public      
Comment:/**
 * Although relatively uncommon, packages may be signed by more than one signer, in which case
 * their identity is viewed as being the set of all signers, not just any one.
 */

Body of Frist Method:
{
    return mSigningDetails.signatures != null && mSigningDetails.signatures.length > 1;
}
Body of Second Method:
{
    return mSigningDetails.getSignatures() != null && mSigningDetails.getSignatures().length > 1;
}
------------------------
Find a silently evolved API code:android.location.LocationRequest.setLocationSettingsIgnored:COMMENT
Method Modifier: public      hidden      deprecated  
Comment:/**
 * @hide
 * @deprecated LocationRequests should be treated as immutable.
 */

Body of Frist Method:
{
    mLocationSettingsIgnored = locationSettingsIgnored;
    return this;
}
Body of Second Method:
{
    mBypass = locationSettingsIgnored;
    return this;
}
------------------------
Find a silently evolved API code:android.text.TextShaper.shapeText:COMMENT
Method Modifier: public      static      
Comment:/**
 * Shape multi-styled text.
 *
 * In the LTR context, the shape result will go from left to right, thus you may want to draw
 * glyphs from left most position of the canvas. In the RTL context, the shape result will go
 * from right to left, thus you may want to draw glyphs from right most position of the canvas.
 *
 * @param text a styled text.
 * @param start a start index of shaping target in the text.
 * @param count a length of shaping target in the text.
 * @param dir a text direction.
 * @param paint a paint
 * @param consumer a consumer of the shape result.
 */

Body of Frist Method:
{
    MeasuredParagraph mp = MeasuredParagraph.buildForBidi(text, start, start + count, dir, null);
    TextLine tl = TextLine.obtain();
    try {
        tl.set(paint, text, start, start + count, mp.getParagraphDir(), mp.getDirections(0, count), false, /* tabstop is not supported */
        null, // ellipsis is not supported.
        -1, // ellipsis is not supported.
        -1);
        tl.shape(consumer);
    } finally {
        TextLine.recycle(tl);
    }
}
Body of Second Method:
{
    MeasuredParagraph mp = MeasuredParagraph.buildForBidi(text, start, start + count, dir, null);
    TextLine tl = TextLine.obtain();
    try {
        tl.set(paint, text, start, start + count, mp.getParagraphDir(), mp.getDirections(0, count), false, /* tabstop is not supported */
        null, // ellipsis is not supported.
        -1, // ellipsis is not supported.
        -1, false);
        tl.shape(consumer);
    } finally {
        TextLine.recycle(tl);
    }
}
------------------------
Find a silently evolved API code:android.location.LocationRequest.isBypass:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns true if any bypass flag is set on this request. For internal use only.
 *
 * @hide
 */

Body of Frist Method:
{
    return mAdasGnssBypass || mLocationSettingsIgnored;
}
Body of Second Method:
{
    return mAdasGnssBypass || mBypass;
}
------------------------
Find a silently evolved API code:android.os.UidBatteryConsumer.Builder.add:COMMENT
Method Modifier: public      
Comment:/**
 * Adds power and usage duration from the supplied UidBatteryConsumer.
 */

Body of Frist Method:
{
    mPowerComponentsBuilder.addPowerAndDuration(consumer.mPowerComponents);
    mTimeInBackgroundMs += consumer.mTimeInBackgroundMs;
    mTimeInForegroundMs += consumer.mTimeInForegroundMs;
    if (mPackageWithHighestDrain == PACKAGE_NAME_UNINITIALIZED) {
        mPackageWithHighestDrain = consumer.mPackageWithHighestDrain;
    } else if (!TextUtils.equals(mPackageWithHighestDrain, consumer.mPackageWithHighestDrain)) {
        // Consider combining two UidBatteryConsumers with this distribution
        // of power drain between packages:
        // (package1=100, package2=10) and (package1=100, package2=101).
        // Since we don't know the actual power distribution between packages at this
        // point, we have no way to correctly declare package1 as the winner.
        // The naive logic of picking the consumer with the higher total consumed
        // power would produce an incorrect result.
        mPackageWithHighestDrain = null;
    }
    return this;
}
Body of Second Method:
{
    mPowerComponentsBuilder.addPowerAndDuration(consumer.mPowerComponents);
    setTimeInStateMs(STATE_FOREGROUND, mData.getLong(COLUMN_INDEX_TIME_IN_FOREGROUND) + consumer.getTimeInStateMs(STATE_FOREGROUND));
    setTimeInStateMs(STATE_BACKGROUND, mData.getLong(COLUMN_INDEX_TIME_IN_BACKGROUND) + consumer.getTimeInStateMs(STATE_BACKGROUND));
    if (mPackageWithHighestDrain == PACKAGE_NAME_UNINITIALIZED) {
        mPackageWithHighestDrain = consumer.getPackageWithHighestDrain();
    } else if (!TextUtils.equals(mPackageWithHighestDrain, consumer.getPackageWithHighestDrain())) {
        // Consider combining two UidBatteryConsumers with this distribution
        // of power drain between packages:
        // (package1=100, package2=10) and (package1=100, package2=101).
        // Since we don't know the actual power distribution between packages at this
        // point, we have no way to correctly declare package1 as the winner.
        // The naive logic of picking the consumer with the higher total consumed
        // power would produce an incorrect result.
        mPackageWithHighestDrain = null;
    }
    return this;
}
------------------------
Find a silently evolved API code:android.app.admin.FullyManagedDeviceProvisioningParams.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Combines all of the attributes that have been set on this {@code Builder}
 *
 * @return a new {@link FullyManagedDeviceProvisioningParams} object.
 */

Body of Frist Method:
{
    return new FullyManagedDeviceProvisioningParams(mDeviceAdminComponentName, mOwnerName, mLeaveAllSystemAppsEnabled, mTimeZone, mLocalTime, mLocale, mDeviceOwnerCanGrantSensorsPermissions);
}
Body of Second Method:
{
    return new FullyManagedDeviceProvisioningParams(mDeviceAdminComponentName, mOwnerName, mLeaveAllSystemAppsEnabled, mTimeZone, mLocalTime, mLocale, mDeviceOwnerCanGrantSensorsPermissions, mAdminExtras != null ? mAdminExtras : new PersistableBundle(), mDemoDevice);
}
------------------------
Find a silently evolved API code:android.app.WindowConfiguration.diff:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Return a bit mask of the differences between this Configuration object and the given one.
 * Does not change the values of either. Any undefined fields in <var>other</var> are ignored.
 * @param other The configuration to diff against.
 * @param compareUndefined If undefined values should be compared.
 * @return Returns a bit mask indicating which configuration
 * values has changed, containing any combination of {@link WindowConfig} flags.
 *
 * @see Configuration#diff(Configuration)
 * @hide
 */

Body of Frist Method:
{
    long changes = 0;
    if (!mBounds.equals(other.mBounds)) {
        changes |= WINDOW_CONFIG_BOUNDS;
    }
    // Make sure that one of the values is not null and that they are not equal.
    if ((compareUndefined || other.mAppBounds != null) && mAppBounds != other.mAppBounds && (mAppBounds == null || !mAppBounds.equals(other.mAppBounds))) {
        changes |= WINDOW_CONFIG_APP_BOUNDS;
    }
    if (!mMaxBounds.equals(other.mMaxBounds)) {
        changes |= WINDOW_CONFIG_MAX_BOUNDS;
    }
    if ((compareUndefined || other.mWindowingMode != WINDOWING_MODE_UNDEFINED) && mWindowingMode != other.mWindowingMode) {
        changes |= WINDOW_CONFIG_WINDOWING_MODE;
    }
    if ((compareUndefined || other.mActivityType != ACTIVITY_TYPE_UNDEFINED) && mActivityType != other.mActivityType) {
        changes |= WINDOW_CONFIG_ACTIVITY_TYPE;
    }
    if ((compareUndefined || other.mAlwaysOnTop != ALWAYS_ON_TOP_UNDEFINED) && mAlwaysOnTop != other.mAlwaysOnTop) {
        changes |= WINDOW_CONFIG_ALWAYS_ON_TOP;
    }
    if ((compareUndefined || other.mRotation != ROTATION_UNDEFINED) && mRotation != other.mRotation) {
        changes |= WINDOW_CONFIG_ROTATION;
    }
    if ((compareUndefined || other.mDisplayWindowingMode != WINDOWING_MODE_UNDEFINED) && mDisplayWindowingMode != other.mDisplayWindowingMode) {
        changes |= WINDOW_CONFIG_DISPLAY_WINDOWING_MODE;
    }
    return changes;
}
Body of Second Method:
{
    long changes = 0;
    if (!mBounds.equals(other.mBounds)) {
        changes |= WINDOW_CONFIG_BOUNDS;
    }
    // Make sure that one of the values is not null and that they are not equal.
    if ((compareUndefined || other.mAppBounds != null) && mAppBounds != other.mAppBounds && (mAppBounds == null || !mAppBounds.equals(other.mAppBounds))) {
        changes |= WINDOW_CONFIG_APP_BOUNDS;
    }
    if (!mMaxBounds.equals(other.mMaxBounds)) {
        changes |= WINDOW_CONFIG_MAX_BOUNDS;
    }
    if ((compareUndefined || other.mWindowingMode != WINDOWING_MODE_UNDEFINED) && mWindowingMode != other.mWindowingMode) {
        changes |= WINDOW_CONFIG_WINDOWING_MODE;
    }
    if ((compareUndefined || other.mActivityType != ACTIVITY_TYPE_UNDEFINED) && mActivityType != other.mActivityType) {
        changes |= WINDOW_CONFIG_ACTIVITY_TYPE;
    }
    if ((compareUndefined || other.mAlwaysOnTop != ALWAYS_ON_TOP_UNDEFINED) && mAlwaysOnTop != other.mAlwaysOnTop) {
        changes |= WINDOW_CONFIG_ALWAYS_ON_TOP;
    }
    if ((compareUndefined || other.mRotation != ROTATION_UNDEFINED) && mRotation != other.mRotation) {
        changes |= WINDOW_CONFIG_ROTATION;
    }
    if ((compareUndefined || other.mDisplayWindowingMode != WINDOWING_MODE_UNDEFINED) && mDisplayWindowingMode != other.mDisplayWindowingMode) {
        changes |= WINDOW_CONFIG_DISPLAY_WINDOWING_MODE;
    }
    if ((compareUndefined || other.mDisplayRotation != ROTATION_UNDEFINED) && mDisplayRotation != other.mDisplayRotation) {
        changes |= WINDOW_CONFIG_DISPLAY_ROTATION;
    }
    return changes;
}
------------------------
Find a silently evolved API code:android.view.inputmethod.InputConnectionWrapper.setTarget:COMMENT
Method Modifier: public      
Comment:/**
 * Change the target of the input connection.
 *
 * <p><b>Caveat:</b> Although the system can accept {@code (InputConnection) null} in some
 * places, you cannot emulate such a behavior by non-null {@link InputConnectionWrapper} that
 * has {@code null} in {@code target}.</p>
 * @param target the {@link InputConnection} to be proxied.
 * @throws SecurityException when this wrapper has non-null target and is immutable.
 */

Body of Frist Method:
{
    if (mTarget != null && !mMutable) {
        throw new SecurityException("not mutable");
    }
    mTarget = target;
    mMissingMethodFlags = InputConnectionInspector.getMissingMethodFlags(target);
}
Body of Second Method:
{
    if (mTarget != null && !mMutable) {
        throw new SecurityException("not mutable");
    }
    mTarget = target;
}
------------------------
Find a silently evolved API code:android.content.res.TypedArray.getDimensionPixelOffset:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve a dimensional unit attribute at <var>index</var> for use
 * as an offset in raw pixels.  This is the same as
 * {@link #getDimension}, except the returned value is converted to
 * integer pixels for you.  An offset conversion involves simply
 * truncating the base value to an integer.
 * <p>
 * This method will throw an exception if the attribute is defined but is
 * not a dimension.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute dimension value multiplied by the appropriate
 * metric and truncated to integer pixels, or defValue if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not an integer.
 *
 * @see #getDimension
 * @see #getDimensionPixelSize
 */

Body of Frist Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    final int attrIndex = index;
    index *= STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimensionPixelOffset(data[index + STYLE_DATA], mMetrics);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index, value);
        throw new UnsupportedOperationException("Failed to resolve attribute at index " + attrIndex + ": " + value);
    }
    throw new UnsupportedOperationException("Can't convert value at index " + attrIndex + " to dimension: type=0x" + Integer.toHexString(type));
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    final int attrIndex = index;
    index *= STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimensionPixelOffset(data[index + STYLE_DATA], mMetrics);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index, value);
        throw new UnsupportedOperationException("Failed to resolve attribute at index " + attrIndex + ": " + value + ", theme=" + mTheme);
    }
    throw new UnsupportedOperationException("Can't convert value at index " + attrIndex + " to dimension: type=0x" + Integer.toHexString(type) + ", theme=" + mTheme);
}
------------------------
Find a silently evolved API code:android.media.audiopolicy.AudioMix.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Combines all of the settings and return a new {@link AudioMix} object.
 * @return a new {@link AudioMix} object
 * @throws IllegalArgumentException if no {@link AudioMixingRule} has been set.
 */

Body of Frist Method:
{
    if (mRule == null) {
        throw new IllegalArgumentException("Illegal null AudioMixingRule");
    }
    if (mRouteFlags == 0) {
        // no route flags set, use default as described in Builder.setRouteFlags(int)
        mRouteFlags = ROUTE_FLAG_LOOP_BACK;
    }
    if (mFormat == null) {
        // FIXME Can we eliminate this?  Will AudioMix work with an unspecified sample rate?
        int rate = AudioSystem.getPrimaryOutputSamplingRate();
        if (rate <= 0) {
            rate = 44100;
        }
        mFormat = new AudioFormat.Builder().setSampleRate(rate).build();
    }
    if ((mDeviceSystemType != AudioSystem.DEVICE_NONE) && (mDeviceSystemType != AudioSystem.DEVICE_OUT_REMOTE_SUBMIX) && (mDeviceSystemType != AudioSystem.DEVICE_IN_REMOTE_SUBMIX)) {
        if ((mRouteFlags & ROUTE_FLAG_RENDER) == 0) {
            throw new IllegalArgumentException("Can't have audio device without flag ROUTE_FLAG_RENDER");
        }
        if (mRule.getTargetMixType() != AudioMix.MIX_TYPE_PLAYERS) {
            throw new IllegalArgumentException("Unsupported device on non-playback mix");
        }
    } else {
        if ((mRouteFlags & ROUTE_FLAG_SUPPORTED) == ROUTE_FLAG_RENDER) {
            throw new IllegalArgumentException("Can't have flag ROUTE_FLAG_RENDER without an audio device");
        }
        if ((mRouteFlags & ROUTE_FLAG_LOOP_BACK) == ROUTE_FLAG_LOOP_BACK) {
            if (mRule.getTargetMixType() == MIX_TYPE_PLAYERS) {
                mDeviceSystemType = AudioSystem.DEVICE_OUT_REMOTE_SUBMIX;
            } else if (mRule.getTargetMixType() == MIX_TYPE_RECORDERS) {
                mDeviceSystemType = AudioSystem.DEVICE_IN_REMOTE_SUBMIX;
            } else {
                throw new IllegalArgumentException("Unknown mixing rule type");
            }
        }
    }
    if (mRule.allowPrivilegedMediaPlaybackCapture()) {
        String error = AudioMix.canBeUsedForPrivilegedMediaCapture(mFormat);
        if (error != null) {
            throw new IllegalArgumentException(error);
        }
    }
    return new AudioMix(mRule, mFormat, mRouteFlags, mCallbackFlags, mDeviceSystemType, mDeviceAddress);
}
Body of Second Method:
{
    if (mRule == null) {
        throw new IllegalArgumentException("Illegal null AudioMixingRule");
    }
    if (mRouteFlags == 0) {
        // no route flags set, use default as described in Builder.setRouteFlags(int)
        mRouteFlags = ROUTE_FLAG_LOOP_BACK;
    }
    if (mFormat == null) {
        // FIXME Can we eliminate this?  Will AudioMix work with an unspecified sample rate?
        int rate = AudioSystem.getPrimaryOutputSamplingRate();
        if (rate <= 0) {
            rate = 44100;
        }
        mFormat = new AudioFormat.Builder().setSampleRate(rate).build();
    } else {
        // assumes usage in AudioMixes of output channel masks only (b/194910301).
        if ((mFormat.getPropertySetMask() & AudioFormat.AUDIO_FORMAT_HAS_PROPERTY_CHANNEL_MASK) != 0) {
            if (mFormat.getChannelCount() == 1 && mFormat.getChannelMask() == AudioFormat.CHANNEL_IN_MONO) {
                mFormat = new AudioFormat.Builder(mFormat).setChannelMask(AudioFormat.CHANNEL_OUT_MONO).build();
            }
        // CHANNEL_IN_STEREO == CHANNEL_OUT_STEREO so no need to correct.
        // CHANNEL_IN_FRONT_BACK is hidden, should not appear.
        }
    }
    if ((mDeviceSystemType != AudioSystem.DEVICE_NONE) && (mDeviceSystemType != AudioSystem.DEVICE_OUT_REMOTE_SUBMIX) && (mDeviceSystemType != AudioSystem.DEVICE_IN_REMOTE_SUBMIX)) {
        if ((mRouteFlags & ROUTE_FLAG_RENDER) == 0) {
            throw new IllegalArgumentException("Can't have audio device without flag ROUTE_FLAG_RENDER");
        }
        if (mRule.getTargetMixType() != AudioMix.MIX_TYPE_PLAYERS) {
            throw new IllegalArgumentException("Unsupported device on non-playback mix");
        }
    } else {
        if ((mRouteFlags & ROUTE_FLAG_SUPPORTED) == ROUTE_FLAG_RENDER) {
            throw new IllegalArgumentException("Can't have flag ROUTE_FLAG_RENDER without an audio device");
        }
        if ((mRouteFlags & ROUTE_FLAG_LOOP_BACK) == ROUTE_FLAG_LOOP_BACK) {
            if (mRule.getTargetMixType() == MIX_TYPE_PLAYERS) {
                mDeviceSystemType = AudioSystem.DEVICE_OUT_REMOTE_SUBMIX;
            } else if (mRule.getTargetMixType() == MIX_TYPE_RECORDERS) {
                mDeviceSystemType = AudioSystem.DEVICE_IN_REMOTE_SUBMIX;
            } else {
                throw new IllegalArgumentException("Unknown mixing rule type");
            }
        }
    }
    if (mRule.allowPrivilegedMediaPlaybackCapture()) {
        String error = AudioMix.canBeUsedForPrivilegedMediaCapture(mFormat);
        if (error != null) {
            throw new IllegalArgumentException(error);
        }
    }
    return new AudioMix(mRule, mFormat, mRouteFlags, mCallbackFlags, mDeviceSystemType, mDeviceAddress);
}
------------------------
Find a silently evolved API code:android.content.pm.SigningInfo.hasPastSigningCertificates:COMMENT
Method Modifier: public      
Comment:/**
 * APK Signature Scheme v3 enables packages to provide a proof-of-rotation record that the
 * platform verifies, and uses, to allow the use of new signing certificates.  This is only
 * available to packages that are not signed by multiple signers.  In the event of a change to a
 * new signing certificate, the package's past signing certificates are presented as well.  Any
 * check of a package's signing certificate should also include a search through its entire
 * signing history, since it could change to a new signing certificate at any time.
 */

Body of Frist Method:
{
    return mSigningDetails.signatures != null && mSigningDetails.pastSigningCertificates != null;
}
Body of Second Method:
{
    return mSigningDetails.getPastSigningCertificates() != null && mSigningDetails.getPastSigningCertificates().length > 0;
}
------------------------
Find a silently evolved API code:android.graphics.drawable.GradientDrawable.ensureValidRect:COMMENT
Method Modifier: private     
Comment:/**
 * This checks mGradientIsDirty, and if it is true, recomputes both our drawing
 * rectangle (mRect) and the gradient itself, since it depends on our
 * rectangle too.
 * @return true if the resulting rectangle is not empty, false otherwise
 */

Body of Frist Method:
{
    if (mGradientIsDirty) {
        mGradientIsDirty = false;
        Rect bounds = getBounds();
        float inset = 0;
        if (mStrokePaint != null) {
            inset = mStrokePaint.getStrokeWidth() * 0.5f;
        }
        final GradientState st = mGradientState;
        mRect.set(bounds.left + inset, bounds.top + inset, bounds.right - inset, bounds.bottom - inset);
        final int[] gradientColors = st.mGradientColors;
        if (gradientColors != null) {
            final RectF r = mRect;
            final float x0, x1, y0, y1;
            if (st.mGradient == LINEAR_GRADIENT) {
                final float level = st.mUseLevel ? getLevel() / 10000.0f : 1.0f;
                switch(st.mOrientation) {
                    case TOP_BOTTOM:
                        x0 = r.left;
                        y0 = r.top;
                        x1 = x0;
                        y1 = level * r.bottom;
                        break;
                    case TR_BL:
                        x0 = r.right;
                        y0 = r.top;
                        x1 = level * r.left;
                        y1 = level * r.bottom;
                        break;
                    case RIGHT_LEFT:
                        x0 = r.right;
                        y0 = r.top;
                        x1 = level * r.left;
                        y1 = y0;
                        break;
                    case BR_TL:
                        x0 = r.right;
                        y0 = r.bottom;
                        x1 = level * r.left;
                        y1 = level * r.top;
                        break;
                    case BOTTOM_TOP:
                        x0 = r.left;
                        y0 = r.bottom;
                        x1 = x0;
                        y1 = level * r.top;
                        break;
                    case BL_TR:
                        x0 = r.left;
                        y0 = r.bottom;
                        x1 = level * r.right;
                        y1 = level * r.top;
                        break;
                    case LEFT_RIGHT:
                        x0 = r.left;
                        y0 = r.top;
                        x1 = level * r.right;
                        y1 = y0;
                        break;
                    default:
                        /* TL_BR */
                        x0 = r.left;
                        y0 = r.top;
                        x1 = level * r.right;
                        y1 = level * r.bottom;
                        break;
                }
                mFillPaint.setShader(new LinearGradient(x0, y0, x1, y1, gradientColors, st.mPositions, Shader.TileMode.CLAMP));
            } else if (st.mGradient == RADIAL_GRADIENT) {
                x0 = r.left + (r.right - r.left) * st.mCenterX;
                y0 = r.top + (r.bottom - r.top) * st.mCenterY;
                float radius = st.mGradientRadius;
                if (st.mGradientRadiusType == RADIUS_TYPE_FRACTION) {
                    // Fall back to parent width or height if intrinsic
                    // size is not specified.
                    final float width = st.mWidth >= 0 ? st.mWidth : r.width();
                    final float height = st.mHeight >= 0 ? st.mHeight : r.height();
                    radius *= Math.min(width, height);
                } else if (st.mGradientRadiusType == RADIUS_TYPE_FRACTION_PARENT) {
                    radius *= Math.min(r.width(), r.height());
                }
                if (st.mUseLevel) {
                    radius *= getLevel() / 10000.0f;
                }
                mGradientRadius = radius;
                if (radius <= 0) {
                    // We can't have a shader with non-positive radius, so
                    // let's have a very, very small radius.
                    radius = 0.001f;
                }
                mFillPaint.setShader(new RadialGradient(x0, y0, radius, gradientColors, null, Shader.TileMode.CLAMP));
            } else if (st.mGradient == SWEEP_GRADIENT) {
                x0 = r.left + (r.right - r.left) * st.mCenterX;
                y0 = r.top + (r.bottom - r.top) * st.mCenterY;
                int[] tempColors = gradientColors;
                float[] tempPositions = null;
                if (st.mUseLevel) {
                    tempColors = st.mTempColors;
                    final int length = gradientColors.length;
                    if (tempColors == null || tempColors.length != length + 1) {
                        tempColors = st.mTempColors = new int[length + 1];
                    }
                    System.arraycopy(gradientColors, 0, tempColors, 0, length);
                    tempColors[length] = gradientColors[length - 1];
                    tempPositions = st.mTempPositions;
                    final float fraction = 1.0f / (length - 1);
                    if (tempPositions == null || tempPositions.length != length + 1) {
                        tempPositions = st.mTempPositions = new float[length + 1];
                    }
                    final float level = getLevel() / 10000.0f;
                    for (int i = 0; i < length; i++) {
                        tempPositions[i] = i * fraction * level;
                    }
                    tempPositions[length] = 1.0f;
                }
                mFillPaint.setShader(new SweepGradient(x0, y0, tempColors, tempPositions));
            }
            // maxed out so that alpha modulation works correctly.
            if (st.mSolidColors == null) {
                mFillPaint.setColor(Color.BLACK);
            }
        }
    }
    return !mRect.isEmpty();
}
Body of Second Method:
{
    if (mGradientIsDirty) {
        mGradientIsDirty = false;
        Rect bounds = getBounds();
        float inset = 0;
        if (mStrokePaint != null) {
            inset = mStrokePaint.getStrokeWidth() * 0.5f;
        }
        final GradientState st = mGradientState;
        mRect.set(bounds.left + inset, bounds.top + inset, bounds.right - inset, bounds.bottom - inset);
        int[] gradientColors = null;
        if (st.mGradientColors != null) {
            gradientColors = new int[st.mGradientColors.length];
            for (int i = 0; i < gradientColors.length; i++) {
                if (st.mGradientColors[i] != null) {
                    gradientColors[i] = st.mGradientColors[i].getDefaultColor();
                }
            }
        }
        if (gradientColors != null) {
            final RectF r = mRect;
            final float x0, x1, y0, y1;
            if (st.mGradient == LINEAR_GRADIENT) {
                final float level = st.mUseLevel ? getLevel() / 10000.0f : 1.0f;
                switch(st.mOrientation) {
                    case TOP_BOTTOM:
                        x0 = r.left;
                        y0 = r.top;
                        x1 = x0;
                        y1 = level * r.bottom;
                        break;
                    case TR_BL:
                        x0 = r.right;
                        y0 = r.top;
                        x1 = level * r.left;
                        y1 = level * r.bottom;
                        break;
                    case RIGHT_LEFT:
                        x0 = r.right;
                        y0 = r.top;
                        x1 = level * r.left;
                        y1 = y0;
                        break;
                    case BR_TL:
                        x0 = r.right;
                        y0 = r.bottom;
                        x1 = level * r.left;
                        y1 = level * r.top;
                        break;
                    case BOTTOM_TOP:
                        x0 = r.left;
                        y0 = r.bottom;
                        x1 = x0;
                        y1 = level * r.top;
                        break;
                    case BL_TR:
                        x0 = r.left;
                        y0 = r.bottom;
                        x1 = level * r.right;
                        y1 = level * r.top;
                        break;
                    case LEFT_RIGHT:
                        x0 = r.left;
                        y0 = r.top;
                        x1 = level * r.right;
                        y1 = y0;
                        break;
                    default:
                        /* TL_BR */
                        x0 = r.left;
                        y0 = r.top;
                        x1 = level * r.right;
                        y1 = level * r.bottom;
                        break;
                }
                mFillPaint.setShader(new LinearGradient(x0, y0, x1, y1, gradientColors, st.mPositions, Shader.TileMode.CLAMP));
            } else if (st.mGradient == RADIAL_GRADIENT) {
                x0 = r.left + (r.right - r.left) * st.mCenterX;
                y0 = r.top + (r.bottom - r.top) * st.mCenterY;
                float radius = st.mGradientRadius;
                if (st.mGradientRadiusType == RADIUS_TYPE_FRACTION) {
                    // Fall back to parent width or height if intrinsic
                    // size is not specified.
                    final float width = st.mWidth >= 0 ? st.mWidth : r.width();
                    final float height = st.mHeight >= 0 ? st.mHeight : r.height();
                    radius *= Math.min(width, height);
                } else if (st.mGradientRadiusType == RADIUS_TYPE_FRACTION_PARENT) {
                    radius *= Math.min(r.width(), r.height());
                }
                if (st.mUseLevel) {
                    radius *= getLevel() / 10000.0f;
                }
                mGradientRadius = radius;
                if (radius <= 0) {
                    // We can't have a shader with non-positive radius, so
                    // let's have a very, very small radius.
                    radius = 0.001f;
                }
                mFillPaint.setShader(new RadialGradient(x0, y0, radius, gradientColors, null, Shader.TileMode.CLAMP));
            } else if (st.mGradient == SWEEP_GRADIENT) {
                x0 = r.left + (r.right - r.left) * st.mCenterX;
                y0 = r.top + (r.bottom - r.top) * st.mCenterY;
                int[] tempColors = gradientColors;
                float[] tempPositions = null;
                if (st.mUseLevel) {
                    tempColors = st.mTempColors;
                    final int length = gradientColors.length;
                    if (tempColors == null || tempColors.length != length + 1) {
                        tempColors = st.mTempColors = new int[length + 1];
                    }
                    System.arraycopy(gradientColors, 0, tempColors, 0, length);
                    tempColors[length] = gradientColors[length - 1];
                    tempPositions = st.mTempPositions;
                    final float fraction = 1.0f / (length - 1);
                    if (tempPositions == null || tempPositions.length != length + 1) {
                        tempPositions = st.mTempPositions = new float[length + 1];
                    }
                    final float level = getLevel() / 10000.0f;
                    for (int i = 0; i < length; i++) {
                        tempPositions[i] = i * fraction * level;
                    }
                    tempPositions[length] = 1.0f;
                }
                mFillPaint.setShader(new SweepGradient(x0, y0, tempColors, tempPositions));
            }
            // maxed out so that alpha modulation works correctly.
            if (st.mSolidColors == null) {
                mFillPaint.setColor(Color.BLACK);
            }
        }
    }
    return !mRect.isEmpty();
}
------------------------
Find a silently evolved API code:android.location.LocationRequest.isLocationSettingsIgnored:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns true if location settings, throttling, background location limits, and any other
 * possible limiting factors will be ignored in order to satisfy this request.
 *
 * @return true if all limiting factors will be ignored to satisfy this request
 *
 * @hide
 */

Body of Frist Method:
{
    return mLocationSettingsIgnored;
}
Body of Second Method:
{
    return mBypass;
}
------------------------
Find a silently evolved API code:android.content.pm.PermissionInfo.protectionToString:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    final StringBuilder protLevel = new StringBuilder();
    switch(level & PROTECTION_MASK_BASE) {
        case PermissionInfo.PROTECTION_DANGEROUS:
            protLevel.append("dangerous");
            break;
        case PermissionInfo.PROTECTION_NORMAL:
            protLevel.append("normal");
            break;
        case PermissionInfo.PROTECTION_SIGNATURE:
            protLevel.append("signature");
            break;
        case PermissionInfo.PROTECTION_SIGNATURE_OR_SYSTEM:
            protLevel.append("signatureOrSystem");
            break;
        case PermissionInfo.PROTECTION_INTERNAL:
            protLevel.append("internal");
            break;
        default:
            protLevel.append("????");
            break;
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_PRIVILEGED) != 0) {
        protLevel.append("|privileged");
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_DEVELOPMENT) != 0) {
        protLevel.append("|development");
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_APPOP) != 0) {
        protLevel.append("|appop");
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_PRE23) != 0) {
        protLevel.append("|pre23");
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_INSTALLER) != 0) {
        protLevel.append("|installer");
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_VERIFIER) != 0) {
        protLevel.append("|verifier");
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_PREINSTALLED) != 0) {
        protLevel.append("|preinstalled");
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_SETUP) != 0) {
        protLevel.append("|setup");
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_INSTANT) != 0) {
        protLevel.append("|instant");
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_RUNTIME_ONLY) != 0) {
        protLevel.append("|runtime");
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_OEM) != 0) {
        protLevel.append("|oem");
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_VENDOR_PRIVILEGED) != 0) {
        protLevel.append("|vendorPrivileged");
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_SYSTEM_TEXT_CLASSIFIER) != 0) {
        protLevel.append("|textClassifier");
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_DOCUMENTER) != 0) {
        protLevel.append("|documenter");
    }
    if ((level & PROTECTION_FLAG_CONFIGURATOR) != 0) {
        protLevel.append("|configurator");
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_INCIDENT_REPORT_APPROVER) != 0) {
        protLevel.append("|incidentReportApprover");
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_APP_PREDICTOR) != 0) {
        protLevel.append("|appPredictor");
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_COMPANION) != 0) {
        protLevel.append("|companion");
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_RETAIL_DEMO) != 0) {
        protLevel.append("|retailDemo");
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_RECENTS) != 0) {
        protLevel.append("|recents");
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_ROLE) != 0) {
        protLevel.append("|role");
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_KNOWN_SIGNER) != 0) {
        protLevel.append("|knownSigner");
    }
    return protLevel.toString();
}
Body of Second Method:
{
    final StringBuilder protLevel = new StringBuilder();
    switch(level & PROTECTION_MASK_BASE) {
        case PermissionInfo.PROTECTION_DANGEROUS:
            protLevel.append("dangerous");
            break;
        case PermissionInfo.PROTECTION_NORMAL:
            protLevel.append("normal");
            break;
        case PermissionInfo.PROTECTION_SIGNATURE:
            protLevel.append("signature");
            break;
        case PermissionInfo.PROTECTION_SIGNATURE_OR_SYSTEM:
            protLevel.append("signatureOrSystem");
            break;
        case PermissionInfo.PROTECTION_INTERNAL:
            protLevel.append("internal");
            break;
        default:
            protLevel.append("????");
            break;
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_PRIVILEGED) != 0) {
        protLevel.append("|privileged");
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_DEVELOPMENT) != 0) {
        protLevel.append("|development");
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_APPOP) != 0) {
        protLevel.append("|appop");
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_PRE23) != 0) {
        protLevel.append("|pre23");
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_INSTALLER) != 0) {
        protLevel.append("|installer");
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_VERIFIER) != 0) {
        protLevel.append("|verifier");
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_PREINSTALLED) != 0) {
        protLevel.append("|preinstalled");
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_SETUP) != 0) {
        protLevel.append("|setup");
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_INSTANT) != 0) {
        protLevel.append("|instant");
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_RUNTIME_ONLY) != 0) {
        protLevel.append("|runtime");
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_OEM) != 0) {
        protLevel.append("|oem");
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_VENDOR_PRIVILEGED) != 0) {
        protLevel.append("|vendorPrivileged");
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_SYSTEM_TEXT_CLASSIFIER) != 0) {
        protLevel.append("|textClassifier");
    }
    if ((level & PROTECTION_FLAG_CONFIGURATOR) != 0) {
        protLevel.append("|configurator");
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_INCIDENT_REPORT_APPROVER) != 0) {
        protLevel.append("|incidentReportApprover");
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_APP_PREDICTOR) != 0) {
        protLevel.append("|appPredictor");
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_COMPANION) != 0) {
        protLevel.append("|companion");
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_RETAIL_DEMO) != 0) {
        protLevel.append("|retailDemo");
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_RECENTS) != 0) {
        protLevel.append("|recents");
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_ROLE) != 0) {
        protLevel.append("|role");
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_KNOWN_SIGNER) != 0) {
        protLevel.append("|knownSigner");
    }
    return protLevel.toString();
}
------------------------
Find a silently evolved API code:android.os.PersistableBundle.deepCopy:COMMENT
Method Modifier: public      
Comment:/**
 * Make a deep copy of the given bundle.  Traverses into inner containers and copies
 * them as well, so they are not shared across bundles.  Will traverse in to
 * {@link Bundle}, {@link PersistableBundle}, {@link ArrayList}, and all types of
 * primitive arrays.  Other types of objects (such as Parcelable or Serializable)
 * are referenced as-is and not copied in any way.
 */

Body of Frist Method:
{
    PersistableBundle b = new PersistableBundle(false);
    b.copyInternal(this, true);
    return b;
}
Body of Second Method:
{
    return new PersistableBundle(this, /* deep */
    true);
}
------------------------
Find a silently evolved API code:android.content.res.TypedArray.getInteger:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the integer value for the attribute at <var>index</var>.
 * <p>
 * Unlike {@link #getInt(int, int)}, this method will throw an exception if
 * the attribute is defined but is not an integer.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute integer value, or defValue if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not an integer.
 */

Body of Frist Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    final int attrIndex = index;
    index *= STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + STYLE_DATA];
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index, value);
        throw new UnsupportedOperationException("Failed to resolve attribute at index " + attrIndex + ": " + value);
    }
    throw new UnsupportedOperationException("Can't convert value at index " + attrIndex + " to integer: type=0x" + Integer.toHexString(type));
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    final int attrIndex = index;
    index *= STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + STYLE_DATA];
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index, value);
        throw new UnsupportedOperationException("Failed to resolve attribute at index " + attrIndex + ": " + value + ", theme=" + mTheme);
    }
    throw new UnsupportedOperationException("Can't convert value at index " + attrIndex + " to integer: type=0x" + Integer.toHexString(type) + ", theme=" + mTheme);
}
------------------------
Find a silently evolved API code:android.graphics.drawable.RippleShader.setColor:COMMENT
Method Modifier: public      
Comment:/**
 * Color of the circle that's under the sparkles. Sparkles will always be white.
 */

Body of Frist Method:
{
    Color color = Color.valueOf(colorInt);
    Color sparkleColor = Color.valueOf(sparkleColorInt);
    setUniform("in_color", new float[] { color.red(), color.green(), color.blue(), color.alpha() });
    setUniform("in_sparkleColor", new float[] { sparkleColor.red(), sparkleColor.green(), sparkleColor.blue(), sparkleColor.alpha() });
}
Body of Second Method:
{
    setColorUniform("in_color", colorInt);
    setColorUniform("in_sparkleColor", sparkleColorInt);
}
------------------------
Find a silently evolved API code:android.app.ApplicationExitInfo.setProcessName:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @see #getProcessName
 *
 * @hide
 */

Body of Frist Method:
{
    mProcessName = processName;
}
Body of Second Method:
{
    mProcessName = intern(processName);
}
------------------------
Find a silently evolved API code:android.telephony.MmsManager.downloadMultimediaMessage:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Download an MMS message from carrier by a given location URL
 *
 * @param subId the subscription id
 * @param locationUrl the location URL of the MMS message to be downloaded, usually obtained
 * from the MMS WAP push notification
 * @param contentUri the content uri to which the downloaded pdu will be written
 * @param configOverrides the carrier-specific messaging configuration values to override for
 * downloading the message.
 * @param downloadedIntent if not NULL this <code>PendingIntent</code> is
 * broadcast when the message is downloaded, or the download is failed
 * @param messageId an id that uniquely identifies the message requested to be downloaded.
 * Used for logging and diagnostics purposes. The id may be 0. The messageId
 * can be found in radio logs from logcat.
 * @throws IllegalArgumentException if locationUrl or contentUri is empty
 */

Body of Frist Method:
{
    try {
        final IMms iMms = IMms.Stub.asInterface(ServiceManager.getService("imms"));
        if (iMms == null) {
            return;
        }
        iMms.downloadMessage(subId, ActivityThread.currentPackageName(), locationUrl, contentUri, configOverrides, downloadedIntent, messageId);
    } catch (RemoteException e) {
    // Ignore it
    }
}
Body of Second Method:
{
    try {
        final IMms iMms = IMms.Stub.asInterface(ServiceManager.getService("imms"));
        if (iMms == null) {
            return;
        }
        iMms.downloadMessage(subId, ActivityThread.currentPackageName(), locationUrl, contentUri, configOverrides, downloadedIntent, messageId, mContext.getAttributionTag());
    } catch (RemoteException e) {
    // Ignore it
    }
}
------------------------
Find a silently evolved API code:android.telephony.CallQuality.toString:COMMENT
Method Modifier: public      hidden      
Comment:// Parcelable things

Body of Frist Method:
{
    return "CallQuality: {downlinkCallQualityLevel=" + mDownlinkCallQualityLevel + " uplinkCallQualityLevel=" + mUplinkCallQualityLevel + " callDuration=" + mCallDuration + " numRtpPacketsTransmitted=" + mNumRtpPacketsTransmitted + " numRtpPacketsReceived=" + mNumRtpPacketsReceived + " numRtpPacketsTransmittedLost=" + mNumRtpPacketsTransmittedLost + " numRtpPacketsNotReceived=" + mNumRtpPacketsNotReceived + " averageRelativeJitter=" + mAverageRelativeJitter + " maxRelativeJitter=" + mMaxRelativeJitter + " averageRoundTripTime=" + mAverageRoundTripTime + " codecType=" + mCodecType + " rtpInactivityDetected=" + mRtpInactivityDetected + " txSilenceDetected=" + mTxSilenceDetected + " rxSilenceDetected=" + mRxSilenceDetected + "}";
}
Body of Second Method:
{
    return "CallQuality: {downlinkCallQualityLevel=" + mDownlinkCallQualityLevel + " uplinkCallQualityLevel=" + mUplinkCallQualityLevel + " callDuration=" + mCallDuration + " numRtpPacketsTransmitted=" + mNumRtpPacketsTransmitted + " numRtpPacketsReceived=" + mNumRtpPacketsReceived + " numRtpPacketsTransmittedLost=" + mNumRtpPacketsTransmittedLost + " numRtpPacketsNotReceived=" + mNumRtpPacketsNotReceived + " averageRelativeJitter=" + mAverageRelativeJitter + " maxRelativeJitter=" + mMaxRelativeJitter + " averageRoundTripTime=" + mAverageRoundTripTime + " codecType=" + mCodecType + " rtpInactivityDetected=" + mRtpInactivityDetected + " txSilenceDetected=" + mTxSilenceDetected + " rxSilenceDetected=" + mRxSilenceDetected + " numVoiceFrames=" + mNumVoiceFrames + " numNoDataFrames=" + mNumNoDataFrames + " numDroppedRtpPackets=" + mNumDroppedRtpPackets + " minPlayoutDelayMillis=" + mMinPlayoutDelayMillis + " maxPlayoutDelayMillis=" + mMaxPlayoutDelayMillis + " numRtpSidPacketsReceived=" + mNumRtpSidPacketsReceived + " numRtpDuplicatePackets=" + mNumRtpDuplicatePackets + "}";
}
------------------------
Find a silently evolved API code:android.app.trust.TrustManager.clearAllBiometricRecognized:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Clears authentication by the specified biometric type for all users.
 */

Body of Frist Method:
{
    try {
        mService.clearAllBiometricRecognized(source);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    try {
        mService.clearAllBiometricRecognized(source, unlockedUser);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.telephony.data.DataServiceCallback.resultCodeToString:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Get the result code as a string
 *
 * @param resultCode The result code. Must be one of the {@link ResultCode}
 * @return the string representation
 *
 * @hide
 */

Body of Frist Method:
{
    switch(resultCode) {
        case RESULT_SUCCESS:
            return "RESULT_SUCCESS";
        case RESULT_ERROR_UNSUPPORTED:
            return "RESULT_ERROR_UNSUPPORTED";
        case RESULT_ERROR_INVALID_ARG:
            return "RESULT_ERROR_INVALID_ARG";
        case RESULT_ERROR_BUSY:
            return "RESULT_ERROR_BUSY";
        case RESULT_ERROR_ILLEGAL_STATE:
            return "RESULT_ERROR_ILLEGAL_STATE";
        default:
            return "Missing case for result code=" + resultCode;
    }
}
Body of Second Method:
{
    switch(resultCode) {
        case RESULT_SUCCESS:
            return "RESULT_SUCCESS";
        case RESULT_ERROR_UNSUPPORTED:
            return "RESULT_ERROR_UNSUPPORTED";
        case RESULT_ERROR_INVALID_ARG:
            return "RESULT_ERROR_INVALID_ARG";
        case RESULT_ERROR_BUSY:
            return "RESULT_ERROR_BUSY";
        case RESULT_ERROR_ILLEGAL_STATE:
            return "RESULT_ERROR_ILLEGAL_STATE";
        case RESULT_ERROR_TEMPORARILY_UNAVAILABLE:
            return "RESULT_ERROR_TEMPORARILY_UNAVAILABLE";
        default:
            return "Unknown(" + resultCode + ")";
    }
}
------------------------
Find a silently evolved API code:android.content.res.TypedArray.getComplexColor:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Retrieve the ComplexColor for the attribute at <var>index</var>.
 * The value may be either a {@link android.content.res.ColorStateList} which can wrap a simple
 * color value or a {@link android.content.res.GradientColor}
 * <p>
 * This method will return {@code null} if the attribute is not defined or
 * is not an integer color, color state list or GradientColor.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return ComplexColor for the attribute, or {@code null} if not defined.
 * @throws RuntimeException if the attribute if the TypedArray has already
 * been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not an integer color, color state list or GradientColor.
 * @hide
 */

Body of Frist Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    final TypedValue value = mValue;
    if (getValueAt(index * STYLE_NUM_ENTRIES, value)) {
        if (value.type == TypedValue.TYPE_ATTRIBUTE) {
            throw new UnsupportedOperationException("Failed to resolve attribute at index " + index + ": " + value);
        }
        return mResources.loadComplexColor(value, value.resourceId, mTheme);
    }
    return null;
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    final TypedValue value = mValue;
    if (getValueAt(index * STYLE_NUM_ENTRIES, value)) {
        if (value.type == TypedValue.TYPE_ATTRIBUTE) {
            throw new UnsupportedOperationException("Failed to resolve attribute at index " + index + ": " + value + ", theme=" + mTheme);
        }
        return mResources.loadComplexColor(value, value.resourceId, mTheme);
    }
    return null;
}
------------------------
Find a silently evolved API code:android.hardware.display.VirtualDisplayConfig.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Builds the instance. This builder should not be touched after calling this!
 */

Body of Frist Method:
{
    checkNotUsed();
    // Mark builder used
    mBuilderFieldsSet |= 0x200;
    if ((mBuilderFieldsSet & 0x10) == 0) {
        mFlags = 0;
    }
    if ((mBuilderFieldsSet & 0x20) == 0) {
        mSurface = null;
    }
    if ((mBuilderFieldsSet & 0x40) == 0) {
        mUniqueId = null;
    }
    if ((mBuilderFieldsSet & 0x80) == 0) {
        mDisplayIdToMirror = DEFAULT_DISPLAY;
    }
    if ((mBuilderFieldsSet & 0x100) == 0) {
        mWindowTokenClientToMirror = null;
    }
    VirtualDisplayConfig o = new VirtualDisplayConfig(mName, mWidth, mHeight, mDensityDpi, mFlags, mSurface, mUniqueId, mDisplayIdToMirror, mWindowTokenClientToMirror);
    return o;
}
Body of Second Method:
{
    checkNotUsed();
    // Mark builder used
    mBuilderFieldsSet |= 0x200;
    if ((mBuilderFieldsSet & 0x10) == 0) {
        mFlags = 0;
    }
    if ((mBuilderFieldsSet & 0x20) == 0) {
        mSurface = null;
    }
    if ((mBuilderFieldsSet & 0x40) == 0) {
        mUniqueId = null;
    }
    if ((mBuilderFieldsSet & 0x80) == 0) {
        mDisplayIdToMirror = DEFAULT_DISPLAY;
    }
    if ((mBuilderFieldsSet & 0x100) == 0) {
        mWindowManagerMirroring = false;
    }
    VirtualDisplayConfig o = new VirtualDisplayConfig(mName, mWidth, mHeight, mDensityDpi, mFlags, mSurface, mUniqueId, mDisplayIdToMirror, mWindowManagerMirroring);
    return o;
}
------------------------
Find a silently evolved API code:android.app.ActivityOptions.update:COMMENT
Method Modifier: public      
Comment:/**
 * Update the current values in this ActivityOptions from those supplied
 * in <var>otherOptions</var>.  Any values
 * defined in <var>otherOptions</var> replace those in the base options.
 */

Body of Frist Method:
{
    if (otherOptions.mPackageName != null) {
        mPackageName = otherOptions.mPackageName;
    }
    mUsageTimeReport = otherOptions.mUsageTimeReport;
    mTransitionReceiver = null;
    mSharedElementNames = null;
    mIsReturning = false;
    mResultData = null;
    mResultCode = 0;
    mExitCoordinatorIndex = 0;
    mAnimationType = otherOptions.mAnimationType;
    switch(otherOptions.mAnimationType) {
        case ANIM_CUSTOM:
            mCustomEnterResId = otherOptions.mCustomEnterResId;
            mCustomExitResId = otherOptions.mCustomExitResId;
            mThumbnail = null;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = otherOptions.mAnimationStartedListener;
            break;
        case ANIM_CUSTOM_IN_PLACE:
            mCustomInPlaceResId = otherOptions.mCustomInPlaceResId;
            break;
        case ANIM_SCALE_UP:
            mStartX = otherOptions.mStartX;
            mStartY = otherOptions.mStartY;
            mWidth = otherOptions.mWidth;
            mHeight = otherOptions.mHeight;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = null;
            break;
        case ANIM_THUMBNAIL_SCALE_UP:
        case ANIM_THUMBNAIL_SCALE_DOWN:
        case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
        case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
            mThumbnail = otherOptions.mThumbnail;
            mStartX = otherOptions.mStartX;
            mStartY = otherOptions.mStartY;
            mWidth = otherOptions.mWidth;
            mHeight = otherOptions.mHeight;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = otherOptions.mAnimationStartedListener;
            break;
        case ANIM_SCENE_TRANSITION:
            mTransitionReceiver = otherOptions.mTransitionReceiver;
            mSharedElementNames = otherOptions.mSharedElementNames;
            mIsReturning = otherOptions.mIsReturning;
            mThumbnail = null;
            mAnimationStartedListener = null;
            mResultData = otherOptions.mResultData;
            mResultCode = otherOptions.mResultCode;
            mExitCoordinatorIndex = otherOptions.mExitCoordinatorIndex;
            break;
    }
    mLockTaskMode = otherOptions.mLockTaskMode;
    mAnimSpecs = otherOptions.mAnimSpecs;
    mAnimationFinishedListener = otherOptions.mAnimationFinishedListener;
    mSpecsFuture = otherOptions.mSpecsFuture;
    mRemoteAnimationAdapter = otherOptions.mRemoteAnimationAdapter;
}
Body of Second Method:
{
    if (otherOptions.mPackageName != null) {
        mPackageName = otherOptions.mPackageName;
    }
    mUsageTimeReport = otherOptions.mUsageTimeReport;
    mTransitionReceiver = null;
    mSharedElementNames = null;
    mIsReturning = false;
    mResultData = null;
    mResultCode = 0;
    mExitCoordinatorIndex = 0;
    mAnimationType = otherOptions.mAnimationType;
    switch(otherOptions.mAnimationType) {
        case ANIM_CUSTOM:
            mCustomEnterResId = otherOptions.mCustomEnterResId;
            mCustomExitResId = otherOptions.mCustomExitResId;
            mCustomBackgroundColor = otherOptions.mCustomBackgroundColor;
            mThumbnail = null;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = otherOptions.mAnimationStartedListener;
            break;
        case ANIM_CUSTOM_IN_PLACE:
            mCustomInPlaceResId = otherOptions.mCustomInPlaceResId;
            break;
        case ANIM_SCALE_UP:
            mStartX = otherOptions.mStartX;
            mStartY = otherOptions.mStartY;
            mWidth = otherOptions.mWidth;
            mHeight = otherOptions.mHeight;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = null;
            break;
        case ANIM_THUMBNAIL_SCALE_UP:
        case ANIM_THUMBNAIL_SCALE_DOWN:
        case ANIM_THUMBNAIL_ASPECT_SCALE_UP:
        case ANIM_THUMBNAIL_ASPECT_SCALE_DOWN:
            mThumbnail = otherOptions.mThumbnail;
            mStartX = otherOptions.mStartX;
            mStartY = otherOptions.mStartY;
            mWidth = otherOptions.mWidth;
            mHeight = otherOptions.mHeight;
            if (mAnimationStartedListener != null) {
                try {
                    mAnimationStartedListener.sendResult(null);
                } catch (RemoteException e) {
                }
            }
            mAnimationStartedListener = otherOptions.mAnimationStartedListener;
            break;
        case ANIM_SCENE_TRANSITION:
            mTransitionReceiver = otherOptions.mTransitionReceiver;
            mSharedElementNames = otherOptions.mSharedElementNames;
            mIsReturning = otherOptions.mIsReturning;
            mThumbnail = null;
            mAnimationStartedListener = null;
            mResultData = otherOptions.mResultData;
            mResultCode = otherOptions.mResultCode;
            mExitCoordinatorIndex = otherOptions.mExitCoordinatorIndex;
            break;
    }
    mLockTaskMode = otherOptions.mLockTaskMode;
    mAnimSpecs = otherOptions.mAnimSpecs;
    mAnimationFinishedListener = otherOptions.mAnimationFinishedListener;
    mSpecsFuture = otherOptions.mSpecsFuture;
    mRemoteAnimationAdapter = otherOptions.mRemoteAnimationAdapter;
    mLaunchIntoPipParams = otherOptions.mLaunchIntoPipParams;
    mIsEligibleForLegacyPermissionPrompt = otherOptions.mIsEligibleForLegacyPermissionPrompt;
}
------------------------
Find a silently evolved API code:android.app.ApplicationExitInfo.setDescription:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @see #getDescription
 *
 * @hide
 */

Body of Frist Method:
{
    mDescription = description;
}
Body of Second Method:
{
    mDescription = intern(description);
}
------------------------
Find a silently evolved API code:android.content.res.TypedArray.getColor:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the color value for the attribute at <var>index</var>.  If
 * the attribute references a color resource holding a complex
 * {@link android.content.res.ColorStateList}, then the default color from
 * the set is returned.
 * <p>
 * This method will throw an exception if the attribute is defined but is
 * not an integer color or color state list.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute color value, or defValue if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not an integer color or color state list.
 */

Body of Frist Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    final int attrIndex = index;
    index *= STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + STYLE_DATA];
    } else if (type == TypedValue.TYPE_STRING) {
        final TypedValue value = mValue;
        if (getValueAt(index, value)) {
            final ColorStateList csl = mResources.loadColorStateList(value, value.resourceId, mTheme);
            return csl.getDefaultColor();
        }
        return defValue;
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index, value);
        throw new UnsupportedOperationException("Failed to resolve attribute at index " + attrIndex + ": " + value);
    }
    throw new UnsupportedOperationException("Can't convert value at index " + attrIndex + " to color: type=0x" + Integer.toHexString(type));
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    final int attrIndex = index;
    index *= STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + STYLE_DATA];
    } else if (type == TypedValue.TYPE_STRING) {
        final TypedValue value = mValue;
        if (getValueAt(index, value)) {
            final ColorStateList csl = mResources.loadColorStateList(value, value.resourceId, mTheme);
            return csl.getDefaultColor();
        }
        return defValue;
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index, value);
        throw new UnsupportedOperationException("Failed to resolve attribute at index " + attrIndex + ": " + value + ", theme=" + mTheme);
    }
    throw new UnsupportedOperationException("Can't convert value at index " + attrIndex + " to color: type=0x" + Integer.toHexString(type) + ", theme=" + mTheme);
}
------------------------
Find a silently evolved API code:android.media.tv.tuner.filter.AvSettings.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Builds a {@link AvSettings} object.
 */

Body of Frist Method:
{
    return new AvSettings(mMainType, mIsAudio, mIsPassthrough, mAudioStreamType, mVideoStreamType);
}
Body of Second Method:
{
    return new AvSettings(mMainType, mIsAudio, mIsPassthrough, mAudioStreamType, mVideoStreamType, mUseSecureMemory);
}
------------------------
Find a silently evolved API code:android.view.accessibility.AccessibilityRecord.init:COMMENT
Method Modifier: default     
Comment:/**
 * Initialize this record from another one.
 *
 * @param record The to initialize from.
 */

Body of Frist Method:
{
    mSealed = record.mSealed;
    mBooleanProperties = record.mBooleanProperties;
    mCurrentItemIndex = record.mCurrentItemIndex;
    mItemCount = record.mItemCount;
    mFromIndex = record.mFromIndex;
    mToIndex = record.mToIndex;
    mScrollX = record.mScrollX;
    mScrollY = record.mScrollY;
    mMaxScrollX = record.mMaxScrollX;
    mMaxScrollY = record.mMaxScrollY;
    mScrollDeltaX = record.mScrollDeltaX;
    mScrollDeltaY = record.mScrollDeltaY;
    mAddedCount = record.mAddedCount;
    mRemovedCount = record.mRemovedCount;
    mClassName = record.mClassName;
    mContentDescription = record.mContentDescription;
    mBeforeText = record.mBeforeText;
    mParcelableData = record.mParcelableData;
    mText.addAll(record.mText);
    mSourceWindowId = record.mSourceWindowId;
    mSourceNodeId = record.mSourceNodeId;
    mConnectionId = record.mConnectionId;
}
Body of Second Method:
{
    mSealed = record.mSealed;
    mBooleanProperties = record.mBooleanProperties;
    mCurrentItemIndex = record.mCurrentItemIndex;
    mItemCount = record.mItemCount;
    mFromIndex = record.mFromIndex;
    mToIndex = record.mToIndex;
    mScrollX = record.mScrollX;
    mScrollY = record.mScrollY;
    mMaxScrollX = record.mMaxScrollX;
    mMaxScrollY = record.mMaxScrollY;
    mScrollDeltaX = record.mScrollDeltaX;
    mScrollDeltaY = record.mScrollDeltaY;
    mAddedCount = record.mAddedCount;
    mRemovedCount = record.mRemovedCount;
    mClassName = record.mClassName;
    mContentDescription = record.mContentDescription;
    mBeforeText = record.mBeforeText;
    mParcelableData = record.mParcelableData;
    mText.addAll(record.mText);
    mSourceWindowId = record.mSourceWindowId;
    mSourceNodeId = record.mSourceNodeId;
    mSourceDisplayId = record.mSourceDisplayId;
    mConnectionId = record.mConnectionId;
}
------------------------
Find a silently evolved API code:android.window.WindowContextController.detachIfNeeded:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Detaches the window context from the node it's currently associated with.
 */

Body of Frist Method:
{
    if (mAttachedToDisplayArea) {
        mToken.detachFromWindowContainerIfNeeded();
        mAttachedToDisplayArea = false;
    }
}
Body of Second Method:
{
    if (mAttachedToDisplayArea == AttachStatus.STATUS_ATTACHED) {
        mToken.detachFromWindowContainerIfNeeded();
        mAttachedToDisplayArea = AttachStatus.STATUS_DETACHED;
        if (DEBUG_ATTACH) {
            Log.d(TAG, "Detach Window Context.");
        }
    }
}
------------------------
Find a silently evolved API code:android.media.AudioDeviceInfo.getProductName:COMMENT
Method Modifier: public      
Comment:/**
 * @return The human-readable name of the audio device.
 */

Body of Frist Method:
{
    String portName = mPort.name();
    return portName.length() != 0 ? portName : android.os.Build.MODEL;
}
Body of Second Method:
{
    String portName = mPort.name();
    return (portName != null && portName.length() != 0) ? portName : android.os.Build.MODEL;
}
------------------------
Find a silently evolved API code:android.telephony.ims.stub.ImsSmsImplBase.onSendSmsResultError:COMMENT
Method Modifier: public      final       hidden      
Comment:/**
 * This method should be triggered by the IMS providers when an outgoing message fails to be
 * sent due to an error generated while processing the message or after being sent to the
 * network.
 *
 * @param token token provided in {@link #sendSms(int, int, String, String, boolean, byte[])}
 * @param messageRef the message reference, which may be 1 byte if it is in
 * {@link SmsMessage#FORMAT_3GPP} format (see TS.123.040) or 2 bytes if it is in
 * {@link SmsMessage#FORMAT_3GPP2} format (see 3GPP2 C.S0015-B).
 * @param status result of sending the SMS.
 * @param networkErrorCode the error code reported by the carrier network if sending this SMS
 * has resulted in an error or {@link #RESULT_NO_NETWORK_ERROR} if no network error was
 * generated. See 3GPP TS 24.011 Section 7.3.4 for valid error codes and more information.
 *
 * @throws RuntimeException if called before {@link #onReady()} is triggered or if the
 * connection to the framework is not available. If this happens attempting to send the SMS
 * should be aborted.
 */

Body of Frist Method:
{
    synchronized (mLock) {
        if (mListener == null) {
            throw new RuntimeException("Feature not ready.");
        }
        try {
            mListener.onSendSmsResult(token, messageRef, status, reason, networkErrorCode);
        } catch (RemoteException e) {
            e.rethrowFromSystemServer();
        }
    }
}
Body of Second Method:
{
    IImsSmsListener listener = null;
    synchronized (mLock) {
        listener = mListener;
    }
    if (listener == null) {
        throw new RuntimeException("Feature not ready.");
    }
    try {
        listener.onSendSmsResult(token, messageRef, status, reason, networkErrorCode);
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.app.WindowConfiguration.toString:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return "{ mBounds=" + mBounds + " mAppBounds=" + mAppBounds + " mMaxBounds=" + mMaxBounds + " mWindowingMode=" + windowingModeToString(mWindowingMode) + " mDisplayWindowingMode=" + windowingModeToString(mDisplayWindowingMode) + " mActivityType=" + activityTypeToString(mActivityType) + " mAlwaysOnTop=" + alwaysOnTopToString(mAlwaysOnTop) + " mRotation=" + (mRotation == ROTATION_UNDEFINED ? "undefined" : rotationToString(mRotation)) + "}";
}
Body of Second Method:
{
    return "{ mBounds=" + mBounds + " mAppBounds=" + mAppBounds + " mMaxBounds=" + mMaxBounds + " mDisplayRotation=" + (mRotation == ROTATION_UNDEFINED ? "undefined" : rotationToString(mDisplayRotation)) + " mWindowingMode=" + windowingModeToString(mWindowingMode) + " mDisplayWindowingMode=" + windowingModeToString(mDisplayWindowingMode) + " mActivityType=" + activityTypeToString(mActivityType) + " mAlwaysOnTop=" + alwaysOnTopToString(mAlwaysOnTop) + " mRotation=" + (mRotation == ROTATION_UNDEFINED ? "undefined" : rotationToString(mRotation)) + "}";
}
------------------------
Find a silently evolved API code:android.app.admin.SecurityLog.SecurityEvent.getLogLevel:COMMENT
Method Modifier: public      
Comment:/**
 * Returns severity level for the event.
 */

Body of Frist Method:
{
    switch(getTag()) {
        case TAG_ADB_SHELL_INTERACTIVE:
        case TAG_ADB_SHELL_CMD:
        case TAG_SYNC_RECV_FILE:
        case TAG_SYNC_SEND_FILE:
        case TAG_APP_PROCESS_START:
        case TAG_KEYGUARD_DISMISSED:
        case TAG_KEYGUARD_SECURED:
        case TAG_OS_STARTUP:
        case TAG_OS_SHUTDOWN:
        case TAG_LOGGING_STARTED:
        case TAG_LOGGING_STOPPED:
        case TAG_MEDIA_MOUNT:
        case TAG_MEDIA_UNMOUNT:
        case TAG_PASSWORD_EXPIRATION_SET:
        case TAG_PASSWORD_COMPLEXITY_SET:
        case TAG_PASSWORD_HISTORY_LENGTH_SET:
        case TAG_MAX_SCREEN_LOCK_TIMEOUT_SET:
        case TAG_MAX_PASSWORD_ATTEMPTS_SET:
        case TAG_USER_RESTRICTION_ADDED:
        case TAG_USER_RESTRICTION_REMOVED:
        case TAG_CAMERA_POLICY_SET:
        case TAG_PASSWORD_COMPLEXITY_REQUIRED:
            return LEVEL_INFO;
        case TAG_CERT_AUTHORITY_REMOVED:
        case TAG_CRYPTO_SELF_TEST_COMPLETED:
            return getSuccess() ? LEVEL_INFO : LEVEL_ERROR;
        case TAG_CERT_AUTHORITY_INSTALLED:
        case TAG_KEYGUARD_DISMISS_AUTH_ATTEMPT:
        case TAG_KEY_IMPORT:
        case TAG_KEY_DESTRUCTION:
        case TAG_KEY_GENERATED:
            return getSuccess() ? LEVEL_INFO : LEVEL_WARNING;
        case TAG_LOG_BUFFER_SIZE_CRITICAL:
        case TAG_WIPE_FAILURE:
        case TAG_KEY_INTEGRITY_VIOLATION:
            return LEVEL_ERROR;
        case TAG_CERT_VALIDATION_FAILURE:
            return LEVEL_WARNING;
        default:
            return LEVEL_INFO;
    }
}
Body of Second Method:
{
    switch(getTag()) {
        case TAG_ADB_SHELL_INTERACTIVE:
        case TAG_ADB_SHELL_CMD:
        case TAG_SYNC_RECV_FILE:
        case TAG_SYNC_SEND_FILE:
        case TAG_APP_PROCESS_START:
        case TAG_KEYGUARD_DISMISSED:
        case TAG_KEYGUARD_SECURED:
        case TAG_OS_STARTUP:
        case TAG_OS_SHUTDOWN:
        case TAG_LOGGING_STARTED:
        case TAG_LOGGING_STOPPED:
        case TAG_MEDIA_MOUNT:
        case TAG_MEDIA_UNMOUNT:
        case TAG_PASSWORD_EXPIRATION_SET:
        case TAG_PASSWORD_COMPLEXITY_SET:
        case TAG_PASSWORD_HISTORY_LENGTH_SET:
        case TAG_MAX_SCREEN_LOCK_TIMEOUT_SET:
        case TAG_MAX_PASSWORD_ATTEMPTS_SET:
        case TAG_USER_RESTRICTION_ADDED:
        case TAG_USER_RESTRICTION_REMOVED:
        case TAG_CAMERA_POLICY_SET:
        case TAG_PASSWORD_COMPLEXITY_REQUIRED:
        case TAG_PASSWORD_CHANGED:
            return LEVEL_INFO;
        case TAG_CERT_AUTHORITY_REMOVED:
        case TAG_CRYPTO_SELF_TEST_COMPLETED:
            return getSuccess() ? LEVEL_INFO : LEVEL_ERROR;
        case TAG_CERT_AUTHORITY_INSTALLED:
        case TAG_KEYGUARD_DISMISS_AUTH_ATTEMPT:
        case TAG_KEY_IMPORT:
        case TAG_KEY_DESTRUCTION:
        case TAG_KEY_GENERATED:
            return getSuccess() ? LEVEL_INFO : LEVEL_WARNING;
        case TAG_LOG_BUFFER_SIZE_CRITICAL:
        case TAG_WIPE_FAILURE:
        case TAG_KEY_INTEGRITY_VIOLATION:
            return LEVEL_ERROR;
        case TAG_CERT_VALIDATION_FAILURE:
            return LEVEL_WARNING;
        default:
            return LEVEL_INFO;
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.nl80211.DeviceWiphyCapabilities.equals:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * override comparator
 */

Body of Frist Method:
{
    if (this == rhs)
        return true;
    if (!(rhs instanceof DeviceWiphyCapabilities)) {
        return false;
    }
    DeviceWiphyCapabilities capa = (DeviceWiphyCapabilities) rhs;
    return m80211nSupported == capa.m80211nSupported && m80211acSupported == capa.m80211acSupported && m80211axSupported == capa.m80211axSupported && mChannelWidth160MhzSupported == capa.mChannelWidth160MhzSupported && mChannelWidth80p80MhzSupported == capa.mChannelWidth80p80MhzSupported && mMaxNumberTxSpatialStreams == capa.mMaxNumberTxSpatialStreams && mMaxNumberRxSpatialStreams == capa.mMaxNumberRxSpatialStreams;
}
Body of Second Method:
{
    if (this == rhs)
        return true;
    if (!(rhs instanceof DeviceWiphyCapabilities)) {
        return false;
    }
    DeviceWiphyCapabilities capa = (DeviceWiphyCapabilities) rhs;
    return m80211nSupported == capa.m80211nSupported && m80211acSupported == capa.m80211acSupported && m80211axSupported == capa.m80211axSupported && m80211beSupported == capa.m80211beSupported && mChannelWidth160MhzSupported == capa.mChannelWidth160MhzSupported && mChannelWidth80p80MhzSupported == capa.mChannelWidth80p80MhzSupported && mChannelWidth320MhzSupported == capa.mChannelWidth320MhzSupported && mMaxNumberTxSpatialStreams == capa.mMaxNumberTxSpatialStreams && mMaxNumberRxSpatialStreams == capa.mMaxNumberRxSpatialStreams;
}
------------------------
Find a silently evolved API code:android.location.LocationRequest.create:COMMENT
Method Modifier: public      static      hidden      deprecated  
Comment:/**
 * @hide
 * @deprecated Use the Builder to construct new LocationRequests.
 */

Body of Frist Method:
{
    // 60 minutes is the default legacy interval
    return new LocationRequest.Builder(60 * 60 * 1000).setQuality(QUALITY_LOW_POWER).build();
}
Body of Second Method:
{
    // 60 minutes is the default legacy interval
    return new LocationRequest.Builder(60 * 60 * 1000).build();
}
------------------------
Find a silently evolved API code:android.telephony.data.DataProfile.getMaxConnections:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @return The maximum connections allowed.
 *
 * @hide
 */

Body of Frist Method:
{
    return mMaxConnections;
}
Body of Second Method:
{
    if (mApnSetting != null) {
        return mApnSetting.getMaxConns();
    }
    return 0;
}
------------------------
Find a silently evolved API code:android.graphics.Picture.draw:COMMENT
Method Modifier: public      
Comment:/**
 * Draw this picture on the canvas.
 * <p>
 * Prior to {@link android.os.Build.VERSION_CODES#LOLLIPOP}, this call could
 * have the side effect of changing the matrix and clip of the canvas
 * if this picture had imbalanced saves/restores.
 *
 * <p>
 * <strong>Note:</strong> This forces the picture to internally call
 * {@link Picture#endRecording()} in order to prepare for playback.
 *
 * @param canvas  The picture is drawn to this canvas
 */

Body of Frist Method:
{
    verifyValid();
    if (mRecordingCanvas != null) {
        endRecording();
    }
    if (mRequiresHwAcceleration && !canvas.isHardwareAccelerated()) {
        canvas.onHwBitmapInSwMode();
    }
    nativeDraw(canvas.getNativeCanvasWrapper(), mNativePicture);
}
Body of Second Method:
{
    verifyValid();
    if (mRecordingCanvas != null) {
        endRecording();
    }
    if (mRequiresHwAcceleration && !canvas.isHardwareAccelerated() && canvas.onHwFeatureInSwMode()) {
        throw new IllegalArgumentException("Software rendering not supported for Pictures that" + " require hardware acceleration");
    }
    nativeDraw(canvas.getNativeCanvasWrapper(), mNativePicture);
}
------------------------
Find a silently evolved API code:android.view.DisplayEventReceiver.dispatchVsync:COMMENT
Method Modifier: private     hidden      
Comment:// Called from native code.

Body of Frist Method:
{
    onVsync(timestampNanos, physicalDisplayId, frame, new VsyncEventData(frameTimelineVsyncId, frameDeadline, frameInterval));
}
Body of Second Method:
{
    onVsync(timestampNanos, physicalDisplayId, frame, vsyncEventData);
}
------------------------
Find a silently evolved API code:android.location.SatellitePvt.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Build SatellitePvt object.
 *
 * @return instance of SatellitePvt
 */

Body of Frist Method:
{
    return new SatellitePvt(mFlags, mPositionEcef, mVelocityEcef, mClockInfo, mIonoDelayMeters, mTropoDelayMeters);
}
Body of Second Method:
{
    return new SatellitePvt(mFlags, mPositionEcef, mVelocityEcef, mClockInfo, mIonoDelayMeters, mTropoDelayMeters, mTimeOfClockSeconds, mTimeOfEphemerisSeconds, mIssueOfDataClock, mIssueOfDataEphemeris, mEphemerisSource);
}
------------------------
Find a silently evolved API code:android.view.inputmethod.CursorAnchorInfo.Builder.reset:COMMENT
Method Modifier: public      
Comment:/**
 * Resets the internal state so that this instance can be reused to build another
 * instance of {@link CursorAnchorInfo}.
 */

Body of Frist Method:
{
    mSelectionStart = -1;
    mSelectionEnd = -1;
    mComposingTextStart = -1;
    mComposingText = null;
    mInsertionMarkerFlags = 0;
    mInsertionMarkerHorizontal = Float.NaN;
    mInsertionMarkerTop = Float.NaN;
    mInsertionMarkerBaseline = Float.NaN;
    mInsertionMarkerBottom = Float.NaN;
    mMatrixInitialized = false;
    if (mCharacterBoundsArrayBuilder != null) {
        mCharacterBoundsArrayBuilder.reset();
    }
}
Body of Second Method:
{
    mSelectionStart = -1;
    mSelectionEnd = -1;
    mComposingTextStart = -1;
    mComposingText = null;
    mInsertionMarkerFlags = 0;
    mInsertionMarkerHorizontal = Float.NaN;
    mInsertionMarkerTop = Float.NaN;
    mInsertionMarkerBaseline = Float.NaN;
    mInsertionMarkerBottom = Float.NaN;
    mMatrixInitialized = false;
    if (mCharacterBoundsArrayBuilder != null) {
        mCharacterBoundsArrayBuilder.reset();
    }
    mEditorBoundsInfo = null;
}
------------------------
Find a silently evolved API code:android.os.AggregateBatteryConsumer.Builder.add:COMMENT
Method Modifier: public      
Comment:/**
 * Adds power and usage duration from the supplied AggregateBatteryConsumer.
 */

Body of Frist Method:
{
    mConsumedPowerMah += aggregateBatteryConsumer.mConsumedPowerMah;
    mPowerComponentsBuilder.addPowerAndDuration(aggregateBatteryConsumer.mPowerComponents);
}
Body of Second Method:
{
    setConsumedPower(mData.getDouble(COLUMN_INDEX_CONSUMED_POWER) + aggregateBatteryConsumer.getConsumedPower());
    mPowerComponentsBuilder.addPowerAndDuration(aggregateBatteryConsumer.mPowerComponents);
}
------------------------
Find a silently evolved API code:android.graphics.BitmapShader.shouldDiscardNativeInstance:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return mFilterFromPaint != filterFromPaint;
}
Body of Second Method:
{
    return mIsDirectSampled != mRequestDirectSampling || (mFilterMode == FILTER_MODE_DEFAULT && mFilterFromPaint != filterFromPaint);
}
------------------------
Find a silently evolved API code:android.app.ApplicationExitInfo.dump:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    pw.println(prefix + "ApplicationExitInfo " + seqSuffix + ":");
    pw.println(prefix + "  timestamp=" + sdf.format(new Date(mTimestamp)));
    pw.println(prefix + "  pid=" + mPid);
    pw.println(prefix + "  realUid=" + mRealUid);
    pw.println(prefix + "  packageUid=" + mPackageUid);
    pw.println(prefix + "  definingUid=" + mDefiningUid);
    pw.println(prefix + "  user=" + UserHandle.getUserId(mPackageUid));
    pw.println(prefix + "  process=" + mProcessName);
    pw.println(prefix + "  reason=" + mReason + " (" + reasonCodeToString(mReason) + ")");
    pw.println(prefix + "  subreason=" + mSubReason + " (" + subreasonToString(mSubReason) + ")");
    pw.println(prefix + "  status=" + mStatus);
    pw.println(prefix + "  importance=" + mImportance);
    pw.print(prefix + "  pss=");
    DebugUtils.printSizeValue(pw, mPss << 10);
    pw.println();
    pw.print(prefix + "  rss=");
    DebugUtils.printSizeValue(pw, mRss << 10);
    pw.println();
    pw.println(prefix + "  description=" + mDescription);
    pw.println(prefix + "  state=" + (ArrayUtils.isEmpty(mState) ? "empty" : Integer.toString(mState.length) + " bytes"));
    pw.println(prefix + "  trace=" + mTraceFile);
}
Body of Second Method:
{
    StringBuilder sb = new StringBuilder();
    sb.append(prefix).append("ApplicationExitInfo ").append(seqSuffix).append(':').append('\n');
    sb.append(prefix).append(' ').append(" timestamp=").append(sdf.format(new Date(mTimestamp))).append(" pid=").append(mPid).append(" realUid=").append(mRealUid).append(" packageUid=").append(mPackageUid).append(" definingUid=").append(mDefiningUid).append(" user=").append(UserHandle.getUserId(mPackageUid)).append('\n');
    sb.append(prefix).append(' ').append(" process=").append(mProcessName).append(" reason=").append(mReason).append(" (").append(reasonCodeToString(mReason)).append(")").append(" subreason=").append(mSubReason).append(" (").append(subreasonToString(mSubReason)).append(")").append(" status=").append(mStatus).append('\n');
    sb.append(prefix).append(' ').append(" importance=").append(mImportance).append(" pss=");
    DebugUtils.sizeValueToString(mPss << 10, sb);
    sb.append(" rss=");
    DebugUtils.sizeValueToString(mRss << 10, sb);
    sb.append(" description=").append(mDescription).append(" state=").append((ArrayUtils.isEmpty(mState) ? "empty" : Integer.toString(mState.length) + " bytes")).append(" trace=").append(mTraceFile).append('\n');
    pw.print(sb.toString());
}
------------------------
Find a silently evolved API code:android.content.res.TypedArray.getDimension:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve a dimensional unit attribute at <var>index</var>. Unit
 * conversions are based on the current {@link DisplayMetrics}
 * associated with the resources this {@link TypedArray} object
 * came from.
 * <p>
 * This method will throw an exception if the attribute is defined but is
 * not a dimension.
 *
 * @param index Index of attribute to retrieve.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute dimension value multiplied by the appropriate
 * metric, or defValue if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not an integer.
 *
 * @see #getDimensionPixelOffset
 * @see #getDimensionPixelSize
 */

Body of Frist Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    final int attrIndex = index;
    index *= STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimension(data[index + STYLE_DATA], mMetrics);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index, value);
        throw new UnsupportedOperationException("Failed to resolve attribute at index " + attrIndex + ": " + value);
    }
    throw new UnsupportedOperationException("Can't convert value at index " + attrIndex + " to dimension: type=0x" + Integer.toHexString(type));
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    final int attrIndex = index;
    index *= STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimension(data[index + STYLE_DATA], mMetrics);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index, value);
        throw new UnsupportedOperationException("Failed to resolve attribute at index " + attrIndex + ": " + value + ", theme=" + mTheme);
    }
    throw new UnsupportedOperationException("Can't convert value at index " + attrIndex + " to dimension: type=0x" + Integer.toHexString(type) + ", theme=" + mTheme);
}
------------------------
Find a silently evolved API code:android.renderscript.ScriptIntrinsicBlend.forEachSrc:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * Sets dst = src
 *
 * @param ain The source buffer
 * @param aout The destination buffer
 * @param opt LaunchOptions for clipping
 */

Body of Frist Method:
{
    blend(1, ain, aout, null);
}
Body of Second Method:
{
    blend(1, ain, aout, opt);
}
------------------------
Find a silently evolved API code:android.graphics.drawable.Icon.convertToAshmem:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Puts the memory used by this instance into Ashmem memory, if possible.
 * @hide
 */

Body of Frist Method:
{
    if ((mType == TYPE_BITMAP || mType == TYPE_ADAPTIVE_BITMAP) && getBitmap().isMutable() && getBitmap().getAllocationByteCount() >= MIN_ASHMEM_ICON_SIZE) {
        setBitmap(getBitmap().asShared());
    }
}
Body of Second Method:
{
    if ((mType == TYPE_BITMAP || mType == TYPE_ADAPTIVE_BITMAP) && getBitmap().isMutable() && getBitmap().getAllocationByteCount() >= MIN_ASHMEM_ICON_SIZE) {
        setBitmap(getBitmap().asShared());
    }
    mCachedAshmem = true;
}
------------------------
Find a silently evolved API code:android.telephony.MmsManager.sendMultimediaMessage:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Send an MMS message
 *
 * @param subId the subscription id
 * @param contentUri the content Uri from which the message pdu will be read
 * @param locationUrl the optional location url where message should be sent to
 * @param configOverrides the carrier-specific messaging configuration values to override for
 * sending the message.
 * @param sentIntent if not NULL this <code>PendingIntent</code> is broadcast when the message
 * is successfully sent, or failed
 * @param messageId an id that uniquely identifies the message requested to be sent.
 * Used for logging and diagnostics purposes. The id may be 0. The messageId
 * can be found in radio logs from logcat.
 */

Body of Frist Method:
{
    try {
        final IMms iMms = IMms.Stub.asInterface(ServiceManager.getService("imms"));
        if (iMms == null) {
            return;
        }
        iMms.sendMessage(subId, ActivityThread.currentPackageName(), contentUri, locationUrl, configOverrides, sentIntent, messageId);
    } catch (RemoteException e) {
    // Ignore it
    }
}
Body of Second Method:
{
    try {
        final IMms iMms = IMms.Stub.asInterface(ServiceManager.getService("imms"));
        if (iMms == null) {
            return;
        }
        iMms.sendMessage(subId, ActivityThread.currentPackageName(), contentUri, locationUrl, configOverrides, sentIntent, messageId, mContext.getAttributionTag());
    } catch (RemoteException e) {
    // Ignore it
    }
}
------------------------
Find a silently evolved API code:android.content.res.TypedArray.getFont:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the Typeface for the attribute at <var>index</var>.
 * <p>
 * This method will throw an exception if the attribute is defined but is
 * not a font.
 *
 * @param index Index of attribute to retrieve.
 *
 * @return Typeface for the attribute, or {@code null} if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not a font resource.
 */

Body of Frist Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    final TypedValue value = mValue;
    if (getValueAt(index * STYLE_NUM_ENTRIES, value)) {
        if (value.type == TypedValue.TYPE_ATTRIBUTE) {
            throw new UnsupportedOperationException("Failed to resolve attribute at index " + index + ": " + value);
        }
        return mResources.getFont(value, value.resourceId);
    }
    return null;
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    final TypedValue value = mValue;
    if (getValueAt(index * STYLE_NUM_ENTRIES, value)) {
        if (value.type == TypedValue.TYPE_ATTRIBUTE) {
            throw new UnsupportedOperationException("Failed to resolve attribute at index " + index + ": " + value + ", theme=" + mTheme);
        }
        return mResources.getFont(value, value.resourceId);
    }
    return null;
}
------------------------
Find a silently evolved API code:android.content.res.TypedArray.getLayoutDimension:COMMENT
Method Modifier: public      
Comment:/**
 * Special version of {@link #getDimensionPixelSize} for retrieving
 * {@link android.view.ViewGroup}'s layout_width and layout_height
 * attributes.  This is only here for performance reasons; applications
 * should use {@link #getDimensionPixelSize}.
 * <p>
 * This method will throw an exception if the attribute is defined but is
 * not a dimension or integer (enum).
 *
 * @param index Index of the attribute to retrieve.
 * @param name Textual name of attribute for error reporting.
 *
 * @return Attribute dimension value multiplied by the appropriate
 * metric and truncated to integer pixels.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not a dimension or integer (enum).
 */

Body of Frist Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    final int attrIndex = index;
    index *= STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + STYLE_TYPE];
    if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + STYLE_DATA];
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimensionPixelSize(data[index + STYLE_DATA], mMetrics);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index, value);
        throw new UnsupportedOperationException("Failed to resolve attribute at index " + attrIndex + ": " + value);
    }
    throw new UnsupportedOperationException(getPositionDescription() + ": You must supply a " + name + " attribute.");
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    final int attrIndex = index;
    index *= STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + STYLE_TYPE];
    if (type >= TypedValue.TYPE_FIRST_INT && type <= TypedValue.TYPE_LAST_INT) {
        return data[index + STYLE_DATA];
    } else if (type == TypedValue.TYPE_DIMENSION) {
        return TypedValue.complexToDimensionPixelSize(data[index + STYLE_DATA], mMetrics);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index, value);
        throw new UnsupportedOperationException("Failed to resolve attribute at index " + attrIndex + ": " + value + ", theme=" + mTheme);
    }
    throw new UnsupportedOperationException(getPositionDescription() + ": You must supply a " + name + " attribute." + ", theme=" + mTheme);
}
------------------------
Find a silently evolved API code:android.hardware.camera2.CameraCharacteristics.getRecommendedStreamConfigurationMap:COMMENT
Method Modifier: public      
Comment:/**
 * <p>Retrieve camera device recommended stream configuration map
 * {@link RecommendedStreamConfigurationMap} for a given use case.</p>
 *
 * <p>The stream configurations advertised here are efficient in terms of power and performance
 * for common use cases like preview, video, snapshot, etc. The recommended maps are usually
 * only small subsets of the exhaustive list provided in
 * {@link #SCALER_STREAM_CONFIGURATION_MAP} and suggested for a particular use case by the
 * camera device implementation. For further information about the expected configurations in
 * various scenarios please refer to:
 * <ul>
 * <li>{@link RecommendedStreamConfigurationMap#USECASE_PREVIEW}</li>
 * <li>{@link RecommendedStreamConfigurationMap#USECASE_RECORD}</li>
 * <li>{@link RecommendedStreamConfigurationMap#USECASE_VIDEO_SNAPSHOT}</li>
 * <li>{@link RecommendedStreamConfigurationMap#USECASE_SNAPSHOT}</li>
 * <li>{@link RecommendedStreamConfigurationMap#USECASE_RAW}</li>
 * <li>{@link RecommendedStreamConfigurationMap#USECASE_ZSL}</li>
 * <li>{@link RecommendedStreamConfigurationMap#USECASE_LOW_LATENCY_SNAPSHOT}</li>
 * </ul>
 * </p>
 *
 * <p>For example on how this can be used by camera clients to find out the maximum recommended
 * preview and snapshot resolution, consider the following pseudo-code:
 * </p>
 * <pre><code>
 * public static Size getMaxSize(Size... sizes) {
 * if (sizes == null || sizes.length == 0) {
 * throw new IllegalArgumentException("sizes was empty");
 * }
 *
 * Size sz = sizes[0];
 * for (Size size : sizes) {
 * if (size.getWidth() * size.getHeight() &gt; sz.getWidth() * sz.getHeight()) {
 * sz = size;
 * }
 * }
 *
 * return sz;
 * }
 *
 * CameraCharacteristics characteristics =
 * cameraManager.getCameraCharacteristics(cameraId);
 * RecommendedStreamConfigurationMap previewConfig =
 * characteristics.getRecommendedStreamConfigurationMap(
 * RecommendedStreamConfigurationMap.USECASE_PREVIEW);
 * RecommendedStreamConfigurationMap snapshotConfig =
 * characteristics.getRecommendedStreamConfigurationMap(
 * RecommendedStreamConfigurationMap.USECASE_SNAPSHOT);
 *
 * if ((previewConfig != null) &amp;&amp; (snapshotConfig != null)) {
 *
 * Set<Size> snapshotSizeSet = snapshotConfig.getOutputSizes(
 * ImageFormat.JPEG);
 * Size[] snapshotSizes = new Size[snapshotSizeSet.size()];
 * snapshotSizes = snapshotSizeSet.toArray(snapshotSizes);
 * Size suggestedMaxJpegSize = getMaxSize(snapshotSizes);
 *
 * Set<Size> previewSizeSet = snapshotConfig.getOutputSizes(
 * ImageFormat.PRIVATE);
 * Size[] previewSizes = new Size[previewSizeSet.size()];
 * previewSizes = previewSizeSet.toArray(previewSizes);
 * Size suggestedMaxPreviewSize = getMaxSize(previewSizes);
 * }
 *
 * </code></pre>
 *
 * <p>Similar logic can be used for other use cases as well.</p>
 *
 * <p>Support for recommended stream configurations is optional. In case there a no
 * suggested configurations for the particular use case, please refer to
 * {@link #SCALER_STREAM_CONFIGURATION_MAP} for the exhaustive available list.</p>
 *
 * @param usecase Use case id.
 *
 * @throws IllegalArgumentException In case the use case argument is invalid.
 * @return Valid {@link RecommendedStreamConfigurationMap} or null in case the camera device
 * doesn't have any recommendation for this use case or the recommended configurations
 * are invalid.
 */

Body of Frist Method:
{
    if (((usecase >= RecommendedStreamConfigurationMap.USECASE_PREVIEW) && (usecase <= RecommendedStreamConfigurationMap.USECASE_LOW_LATENCY_SNAPSHOT)) || ((usecase >= RecommendedStreamConfigurationMap.USECASE_VENDOR_START) && (usecase < RecommendedStreamConfigurationMap.MAX_USECASE_COUNT))) {
        if (mRecommendedConfigurations == null) {
            mRecommendedConfigurations = mProperties.getRecommendedStreamConfigurations();
            if (mRecommendedConfigurations == null) {
                return null;
            }
        }
        return mRecommendedConfigurations.get(usecase);
    }
    throw new IllegalArgumentException(String.format("Invalid use case: %d", usecase));
}
Body of Second Method:
{
    if (((usecase >= RecommendedStreamConfigurationMap.USECASE_PREVIEW) && (usecase <= RecommendedStreamConfigurationMap.USECASE_10BIT_OUTPUT)) || ((usecase >= RecommendedStreamConfigurationMap.USECASE_VENDOR_START) && (usecase < RecommendedStreamConfigurationMap.MAX_USECASE_COUNT))) {
        if (mRecommendedConfigurations == null) {
            mRecommendedConfigurations = mProperties.getRecommendedStreamConfigurations();
            if (mRecommendedConfigurations == null) {
                return null;
            }
        }
        return mRecommendedConfigurations.get(usecase);
    }
    throw new IllegalArgumentException(String.format("Invalid use case: %d", usecase));
}
------------------------
Find a silently evolved API code:android.service.notification.ScheduleCalendar.getNextChangeTime:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @param now current time in milliseconds
 * @return next time this rule changes (starts or ends)
 */

Body of Frist Method:
{
    if (mSchedule == null)
        return 0;
    final long nextStart = getNextTime(now, mSchedule.startHour, mSchedule.startMinute);
    final long nextEnd = getNextTime(now, mSchedule.endHour, mSchedule.endMinute);
    long nextScheduleTime = Math.min(nextStart, nextEnd);
    return nextScheduleTime;
}
Body of Second Method:
{
    if (mSchedule == null)
        return 0;
    final long nextStart = getNextTime(now, mSchedule.startHour, mSchedule.startMinute, true);
    final long nextEnd = getNextTime(now, mSchedule.endHour, mSchedule.endMinute, false);
    long nextScheduleTime = Math.min(nextStart, nextEnd);
    return nextScheduleTime;
}
------------------------
Find a silently evolved API code:android.webkit.URLUtil.guessFileName:COMMENT
Method Modifier: public      static      final       
Comment:/**
 * Guesses canonical filename that a download would have, using
 * the URL and contentDisposition. File extension, if not defined,
 * is added based on the mimetype
 * @param url Url to the content
 * @param contentDisposition Content-Disposition HTTP header or {@code null}
 * @param mimeType Mime-type of the content or {@code null}
 *
 * @return suggested filename
 */

Body of Frist Method:
{
    String filename = null;
    String extension = null;
    // If we couldn't do anything with the hint, move toward the content disposition
    if (filename == null && contentDisposition != null) {
        filename = parseContentDisposition(contentDisposition);
        if (filename != null) {
            int index = filename.lastIndexOf('/') + 1;
            if (index > 0) {
                filename = filename.substring(index);
            }
        }
    }
    // If all the other http-related approaches failed, use the plain uri
    if (filename == null) {
        String decodedUrl = Uri.decode(url);
        if (decodedUrl != null) {
            int queryIndex = decodedUrl.indexOf('?');
            // If there is a query string strip it, same as desktop browsers
            if (queryIndex > 0) {
                decodedUrl = decodedUrl.substring(0, queryIndex);
            }
            if (!decodedUrl.endsWith("/")) {
                int index = decodedUrl.lastIndexOf('/') + 1;
                if (index > 0) {
                    filename = decodedUrl.substring(index);
                }
            }
        }
    }
    // Finally, if couldn't get filename from URI, get a generic filename
    if (filename == null) {
        filename = "downloadfile";
    }
    // Split filename between base and extension
    // Add an extension if filename does not have one
    int dotIndex = filename.indexOf('.');
    if (dotIndex < 0) {
        if (mimeType != null) {
            extension = MimeTypeMap.getSingleton().getExtensionFromMimeType(mimeType);
            if (extension != null) {
                extension = "." + extension;
            }
        }
        if (extension == null) {
            if (mimeType != null && mimeType.toLowerCase(Locale.ROOT).startsWith("text/")) {
                if (mimeType.equalsIgnoreCase("text/html")) {
                    extension = ".html";
                } else {
                    extension = ".txt";
                }
            } else {
                extension = ".bin";
            }
        }
    } else {
        if (mimeType != null) {
            // Compare the last segment of the extension against the mime type.
            // If there's a mismatch, discard the entire extension.
            int lastDotIndex = filename.lastIndexOf('.');
            String typeFromExt = MimeTypeMap.getSingleton().getMimeTypeFromExtension(filename.substring(lastDotIndex + 1));
            if (typeFromExt != null && !typeFromExt.equalsIgnoreCase(mimeType)) {
                extension = MimeTypeMap.getSingleton().getExtensionFromMimeType(mimeType);
                if (extension != null) {
                    extension = "." + extension;
                }
            }
        }
        if (extension == null) {
            extension = filename.substring(dotIndex);
        }
        filename = filename.substring(0, dotIndex);
    }
    return filename + extension;
}
Body of Second Method:
{
    String filename = null;
    String extension = null;
    // If we couldn't do anything with the hint, move toward the content disposition
    if (contentDisposition != null) {
        filename = parseContentDisposition(contentDisposition);
        if (filename != null) {
            int index = filename.lastIndexOf('/') + 1;
            if (index > 0) {
                filename = filename.substring(index);
            }
        }
    }
    // If all the other http-related approaches failed, use the plain uri
    if (filename == null) {
        String decodedUrl = Uri.decode(url);
        if (decodedUrl != null) {
            int queryIndex = decodedUrl.indexOf('?');
            // If there is a query string strip it, same as desktop browsers
            if (queryIndex > 0) {
                decodedUrl = decodedUrl.substring(0, queryIndex);
            }
            if (!decodedUrl.endsWith("/")) {
                int index = decodedUrl.lastIndexOf('/') + 1;
                if (index > 0) {
                    filename = decodedUrl.substring(index);
                }
            }
        }
    }
    // Finally, if couldn't get filename from URI, get a generic filename
    if (filename == null) {
        filename = "downloadfile";
    }
    // Split filename between base and extension
    // Add an extension if filename does not have one
    int dotIndex = filename.indexOf('.');
    if (dotIndex < 0) {
        if (mimeType != null) {
            extension = MimeTypeMap.getSingleton().getExtensionFromMimeType(mimeType);
            if (extension != null) {
                extension = "." + extension;
            }
        }
        if (extension == null) {
            if (mimeType != null && mimeType.toLowerCase(Locale.ROOT).startsWith("text/")) {
                if (mimeType.equalsIgnoreCase("text/html")) {
                    extension = ".html";
                } else {
                    extension = ".txt";
                }
            } else {
                extension = ".bin";
            }
        }
    } else {
        if (mimeType != null) {
            // Compare the last segment of the extension against the mime type.
            // If there's a mismatch, discard the entire extension.
            int lastDotIndex = filename.lastIndexOf('.');
            String typeFromExt = MimeTypeMap.getSingleton().getMimeTypeFromExtension(filename.substring(lastDotIndex + 1));
            if (typeFromExt != null && !typeFromExt.equalsIgnoreCase(mimeType)) {
                extension = MimeTypeMap.getSingleton().getExtensionFromMimeType(mimeType);
                if (extension != null) {
                    extension = "." + extension;
                }
            }
        }
        if (extension == null) {
            extension = filename.substring(dotIndex);
        }
        filename = filename.substring(0, dotIndex);
    }
    return filename + extension;
}
------------------------
Find a silently evolved API code:android.content.res.TypedArray.getFraction:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieves a fractional unit attribute at <var>index</var>.
 *
 * @param index Index of attribute to retrieve.
 * @param base The base value of this fraction.  In other words, a
 * standard fraction is multiplied by this value.
 * @param pbase The parent base value of this fraction.  In other
 * words, a parent fraction (nn%p) is multiplied by this
 * value.
 * @param defValue Value to return if the attribute is not defined or
 * not a resource.
 *
 * @return Attribute fractional value multiplied by the appropriate
 * base value, or defValue if not defined.
 * @throws RuntimeException if the TypedArray has already been recycled.
 * @throws UnsupportedOperationException if the attribute is defined but is
 * not a fraction.
 */

Body of Frist Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    final int attrIndex = index;
    index *= STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_FRACTION) {
        return TypedValue.complexToFraction(data[index + STYLE_DATA], base, pbase);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index, value);
        throw new UnsupportedOperationException("Failed to resolve attribute at index " + attrIndex + ": " + value);
    }
    throw new UnsupportedOperationException("Can't convert value at index " + attrIndex + " to fraction: type=0x" + Integer.toHexString(type));
}
Body of Second Method:
{
    if (mRecycled) {
        throw new RuntimeException("Cannot make calls to a recycled instance!");
    }
    final int attrIndex = index;
    index *= STYLE_NUM_ENTRIES;
    final int[] data = mData;
    final int type = data[index + STYLE_TYPE];
    if (type == TypedValue.TYPE_NULL) {
        return defValue;
    } else if (type == TypedValue.TYPE_FRACTION) {
        return TypedValue.complexToFraction(data[index + STYLE_DATA], base, pbase);
    } else if (type == TypedValue.TYPE_ATTRIBUTE) {
        final TypedValue value = mValue;
        getValueAt(index, value);
        throw new UnsupportedOperationException("Failed to resolve attribute at index " + attrIndex + ": " + value + ", theme=" + mTheme);
    }
    throw new UnsupportedOperationException("Can't convert value at index " + attrIndex + " to fraction: type=0x" + Integer.toHexString(type) + ", theme=" + mTheme);
}
------------------------
Find a silently evolved API code:android.service.notification.ScheduleCalendar.isAlarmInSchedule:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @param alarm milliseconds since Epoch
 * @param now milliseconds since Epoch
 * @return true if alarm and now is within the schedule, else false
 */

Body of Frist Method:
{
    if (mSchedule == null || mDays.size() == 0)
        return false;
    final long start = getTime(alarm, mSchedule.startHour, mSchedule.startMinute);
    long end = getTime(alarm, mSchedule.endHour, mSchedule.endMinute);
    if (end <= start) {
        end = addDays(end, 1);
    }
    return (isInSchedule(-1, alarm, start, end) && isInSchedule(-1, now, start, end)) || (isInSchedule(0, alarm, start, end) && isInSchedule(0, now, start, end));
}
Body of Second Method:
{
    if (mSchedule == null || mDays.size() == 0)
        return false;
    final long start = getClosestActualTime(alarm, mSchedule.startHour, mSchedule.startMinute);
    long end = getTime(alarm, mSchedule.endHour, mSchedule.endMinute);
    if (end <= start) {
        end = addDays(end, 1);
    }
    return (isInSchedule(-1, alarm, start, end) && isInSchedule(-1, now, start, end)) || (isInSchedule(0, alarm, start, end) && isInSchedule(0, now, start, end));
}
------------------------
Find a silently evolved API code:android.view.accessibility.AccessibilityRecord.clear:COMMENT
Method Modifier: default     
Comment:/**
 * Clears the state of this instance.
 */

Body of Frist Method:
{
    mSealed = false;
    mBooleanProperties = 0;
    mCurrentItemIndex = UNDEFINED;
    mItemCount = UNDEFINED;
    mFromIndex = UNDEFINED;
    mToIndex = UNDEFINED;
    mScrollX = 0;
    mScrollY = 0;
    mMaxScrollX = 0;
    mMaxScrollY = 0;
    mScrollDeltaX = UNDEFINED;
    mScrollDeltaY = UNDEFINED;
    mAddedCount = UNDEFINED;
    mRemovedCount = UNDEFINED;
    mClassName = null;
    mContentDescription = null;
    mBeforeText = null;
    mParcelableData = null;
    mText.clear();
    mSourceNodeId = AccessibilityNodeInfo.UNDEFINED_ITEM_ID;
    mSourceWindowId = AccessibilityWindowInfo.UNDEFINED_WINDOW_ID;
    mConnectionId = UNDEFINED;
}
Body of Second Method:
{
    mSealed = false;
    mBooleanProperties = 0;
    mCurrentItemIndex = UNDEFINED;
    mItemCount = UNDEFINED;
    mFromIndex = UNDEFINED;
    mToIndex = UNDEFINED;
    mScrollX = 0;
    mScrollY = 0;
    mMaxScrollX = 0;
    mMaxScrollY = 0;
    mScrollDeltaX = UNDEFINED;
    mScrollDeltaY = UNDEFINED;
    mAddedCount = UNDEFINED;
    mRemovedCount = UNDEFINED;
    mClassName = null;
    mContentDescription = null;
    mBeforeText = null;
    mParcelableData = null;
    mText.clear();
    mSourceNodeId = AccessibilityNodeInfo.UNDEFINED_ITEM_ID;
    mSourceWindowId = AccessibilityWindowInfo.UNDEFINED_WINDOW_ID;
    mSourceDisplayId = Display.INVALID_DISPLAY;
    mConnectionId = UNDEFINED;
}
------------------------
Find a silently evolved API code:android.app.admin.SecurityLog.SecurityEvent.redact:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns a copy of the security event suitable to be consumed by the provided user.
 * This method will either return the original event itself if the event does not contain
 * any sensitive data; or a copy of itself but with sensitive information redacted; or
 * {@code null} if the entire event should not be accessed by the given user.
 *
 * @param accessingUser which user this security event is to be accessed, must be a
 * concrete user id.
 * @hide
 */

Body of Frist Method:
{
    // Which user the event is associated with, for the purpose of log redaction.
    final int userId;
    switch(getTag()) {
        case SecurityLog.TAG_ADB_SHELL_CMD:
            return new SecurityEvent(getId(), mEvent.withNewData("").getBytes());
        case SecurityLog.TAG_MEDIA_MOUNT:
        case SecurityLog.TAG_MEDIA_UNMOUNT:
            // Partial redaction
            String mountPoint;
            try {
                mountPoint = getStringData(0);
            } catch (Exception e) {
                return null;
            }
            return new SecurityEvent(getId(), mEvent.withNewData(new Object[] { mountPoint, "" }).getBytes());
        case SecurityLog.TAG_APP_PROCESS_START:
            try {
                userId = UserHandle.getUserId(getIntegerData(2));
            } catch (Exception e) {
                return null;
            }
            break;
        case SecurityLog.TAG_CERT_AUTHORITY_INSTALLED:
        case SecurityLog.TAG_CERT_AUTHORITY_REMOVED:
            try {
                userId = getIntegerData(2);
            } catch (Exception e) {
                return null;
            }
            break;
        case SecurityLog.TAG_KEY_GENERATED:
        case SecurityLog.TAG_KEY_IMPORT:
        case SecurityLog.TAG_KEY_DESTRUCTION:
            try {
                userId = UserHandle.getUserId(getIntegerData(2));
            } catch (Exception e) {
                return null;
            }
            break;
        case SecurityLog.TAG_KEY_INTEGRITY_VIOLATION:
            try {
                userId = UserHandle.getUserId(getIntegerData(1));
            } catch (Exception e) {
                return null;
            }
            break;
        default:
            userId = UserHandle.USER_NULL;
    }
    // unmodified, else redact by returning null
    if (userId == UserHandle.USER_NULL || accessingUser == userId) {
        return this;
    } else {
        return null;
    }
}
Body of Second Method:
{
    // Which user the event is associated with, for the purpose of log redaction.
    final int userId;
    switch(getTag()) {
        case SecurityLog.TAG_ADB_SHELL_CMD:
            return new SecurityEvent(getId(), mEvent.withNewData("").getBytes());
        case SecurityLog.TAG_MEDIA_MOUNT:
        case SecurityLog.TAG_MEDIA_UNMOUNT:
            // Partial redaction
            String mountPoint;
            try {
                mountPoint = getStringData(0);
            } catch (Exception e) {
                return null;
            }
            return new SecurityEvent(getId(), mEvent.withNewData(new Object[] { mountPoint, "" }).getBytes());
        case SecurityLog.TAG_APP_PROCESS_START:
            try {
                userId = UserHandle.getUserId(getIntegerData(2));
            } catch (Exception e) {
                return null;
            }
            break;
        case SecurityLog.TAG_CERT_AUTHORITY_INSTALLED:
        case SecurityLog.TAG_CERT_AUTHORITY_REMOVED:
            try {
                userId = getIntegerData(2);
            } catch (Exception e) {
                return null;
            }
            break;
        case SecurityLog.TAG_KEY_GENERATED:
        case SecurityLog.TAG_KEY_IMPORT:
        case SecurityLog.TAG_KEY_DESTRUCTION:
            try {
                userId = UserHandle.getUserId(getIntegerData(2));
            } catch (Exception e) {
                return null;
            }
            break;
        case SecurityLog.TAG_KEY_INTEGRITY_VIOLATION:
            try {
                userId = UserHandle.getUserId(getIntegerData(1));
            } catch (Exception e) {
                return null;
            }
            break;
        case SecurityLog.TAG_PASSWORD_CHANGED:
            try {
                userId = getIntegerData(1);
            } catch (Exception e) {
                return null;
            }
            break;
        default:
            userId = UserHandle.USER_NULL;
    }
    // unmodified, else redact by returning null
    if (userId == UserHandle.USER_NULL || accessingUser == userId) {
        return this;
    } else {
        return null;
    }
}
------------------------
Find a silently evolved API code:android.app.ApplicationExitInfo.subreasonToString:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    switch(subreason) {
        case SUBREASON_WAIT_FOR_DEBUGGER:
            return "WAIT FOR DEBUGGER";
        case SUBREASON_TOO_MANY_CACHED:
            return "TOO MANY CACHED PROCS";
        case SUBREASON_TOO_MANY_EMPTY:
            return "TOO MANY EMPTY PROCS";
        case SUBREASON_TRIM_EMPTY:
            return "TRIM EMPTY";
        case SUBREASON_LARGE_CACHED:
            return "LARGE CACHED";
        case SUBREASON_MEMORY_PRESSURE:
            return "MEMORY PRESSURE";
        case SUBREASON_EXCESSIVE_CPU:
            return "EXCESSIVE CPU USAGE";
        case SUBREASON_SYSTEM_UPDATE_DONE:
            return "SYSTEM UPDATE_DONE";
        case SUBREASON_KILL_ALL_FG:
            return "KILL ALL FG";
        case SUBREASON_KILL_ALL_BG_EXCEPT:
            return "KILL ALL BG EXCEPT";
        case SUBREASON_KILL_UID:
            return "KILL UID";
        case SUBREASON_KILL_PID:
            return "KILL PID";
        case SUBREASON_INVALID_START:
            return "INVALID START";
        case SUBREASON_INVALID_STATE:
            return "INVALID STATE";
        case SUBREASON_IMPERCEPTIBLE:
            return "IMPERCEPTIBLE";
        case SUBREASON_REMOVE_LRU:
            return "REMOVE LRU";
        case SUBREASON_ISOLATED_NOT_NEEDED:
            return "ISOLATED NOT NEEDED";
        case SUBREASON_FREEZER_BINDER_IOCTL:
            return "FREEZER BINDER IOCTL";
        case SUBREASON_FREEZER_BINDER_TRANSACTION:
            return "FREEZER BINDER TRANSACTION";
        default:
            return "UNKNOWN";
    }
}
Body of Second Method:
{
    switch(subreason) {
        case SUBREASON_WAIT_FOR_DEBUGGER:
            return "WAIT FOR DEBUGGER";
        case SUBREASON_TOO_MANY_CACHED:
            return "TOO MANY CACHED PROCS";
        case SUBREASON_TOO_MANY_EMPTY:
            return "TOO MANY EMPTY PROCS";
        case SUBREASON_TRIM_EMPTY:
            return "TRIM EMPTY";
        case SUBREASON_LARGE_CACHED:
            return "LARGE CACHED";
        case SUBREASON_MEMORY_PRESSURE:
            return "MEMORY PRESSURE";
        case SUBREASON_EXCESSIVE_CPU:
            return "EXCESSIVE CPU USAGE";
        case SUBREASON_SYSTEM_UPDATE_DONE:
            return "SYSTEM UPDATE_DONE";
        case SUBREASON_KILL_ALL_FG:
            return "KILL ALL FG";
        case SUBREASON_KILL_ALL_BG_EXCEPT:
            return "KILL ALL BG EXCEPT";
        case SUBREASON_KILL_UID:
            return "KILL UID";
        case SUBREASON_KILL_PID:
            return "KILL PID";
        case SUBREASON_INVALID_START:
            return "INVALID START";
        case SUBREASON_INVALID_STATE:
            return "INVALID STATE";
        case SUBREASON_IMPERCEPTIBLE:
            return "IMPERCEPTIBLE";
        case SUBREASON_REMOVE_LRU:
            return "REMOVE LRU";
        case SUBREASON_ISOLATED_NOT_NEEDED:
            return "ISOLATED NOT NEEDED";
        case SUBREASON_FREEZER_BINDER_IOCTL:
            return "FREEZER BINDER IOCTL";
        case SUBREASON_FREEZER_BINDER_TRANSACTION:
            return "FREEZER BINDER TRANSACTION";
        case SUBREASON_FORCE_STOP:
            return "FORCE STOP";
        case SUBREASON_REMOVE_TASK:
            return "REMOVE TASK";
        case SUBREASON_STOP_APP:
            return "STOP APP";
        case SUBREASON_KILL_BACKGROUND:
            return "KILL BACKGROUND";
        case SUBREASON_PACKAGE_UPDATE:
            return "PACKAGE UPDATE";
        default:
            return "UNKNOWN";
    }
}
------------------------
Find a silently evolved API code:android.os.PersistableBundle.restoreFromXml:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    final int outerDepth = in.getDepth();
    final String startTag = in.getName();
    final String[] tagName = new String[1];
    int event;
    while (((event = in.next()) != XmlPullParser.END_DOCUMENT) && (event != XmlPullParser.END_TAG || in.getDepth() < outerDepth)) {
        if (event == XmlPullParser.START_TAG) {
            return new PersistableBundle((ArrayMap<String, Object>) XmlUtils.readThisArrayMapXml(in, startTag, tagName, new MyReadMapCallback()));
        }
    }
    return EMPTY;
}
Body of Second Method:
{
    final int outerDepth = in.getDepth();
    final String startTag = in.getName();
    final String[] tagName = new String[1];
    int event;
    while (((event = in.next()) != XmlPullParser.END_DOCUMENT) && (event != XmlPullParser.END_TAG || in.getDepth() < outerDepth)) {
        if (event == XmlPullParser.START_TAG) {
            return new PersistableBundle((ArrayMap<String, Object>) XmlUtils.readThisArrayMapXml(in, startTag, tagName, new MyReadMapCallback()));
        }
    }
    // An empty mutable PersistableBundle
    return new PersistableBundle();
}
------------------------
Find a silently evolved API code:android.window.WindowContextController.attachToWindowToken:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Switches to attach the window context to a window token.
 * <p>
 * Note that the context should have been attached to a
 * {@link com.android.server.wm.DisplayArea} by {@link #attachToDisplayArea(int, int, Bundle)}
 * before attaching to a window token, and the window token's type must match the window
 * context's type.
 * </p><p>
 * A {@link WindowContext} can only attach to a specific window manager node, which is either a
 * {@link com.android.server.wm.DisplayArea} by calling
 * {@link #attachToDisplayArea(int, int, Bundle)} or the latest attached {@code windowToken}
 * although this API is allowed to be called multiple times.
 * </p>
 * @throws IllegalStateException if the {@code mClientToken} has not yet attached to
 * a {@link com.android.server.wm.DisplayArea} by
 * {@link #attachToDisplayArea(int, int, Bundle)}.
 *
 * @see WindowProviderService#attachToWindowToken(IBinder))
 * @see IWindowManager#attachWindowContextToWindowToken(IBinder, IBinder)
 */

Body of Frist Method:
{
    if (!mAttachedToDisplayArea) {
        throw new IllegalStateException("The Window Context should have been attached" + " to a DisplayArea.");
    }
    mToken.attachToWindowToken(windowToken);
}
Body of Second Method:
{
    if (mAttachedToDisplayArea != AttachStatus.STATUS_ATTACHED) {
        throw new IllegalStateException("The Window Context should have been attached" + " to a DisplayArea. AttachToDisplayArea:" + mAttachedToDisplayArea);
    }
    mToken.attachToWindowToken(windowToken);
}
------------------------
Find a silently evolved API code:android.telephony.ims.stub.ImsSmsImplBase.onSmsStatusReportReceived:COMMENT
Method Modifier: public      final       hidden      deprecated  
Comment:/**
 * This method should be triggered by the IMS providers when the status report of the sent
 * message is received. The platform will handle the report and notify the IMS provider of the
 * result by calling {@link #acknowledgeSmsReport(int, int, int)}.
 *
 * This method must not be called before {@link #onReady()} is called or the call will fail. If
 * the platform is not available, {@link #acknowledgeSmsReport(int, int, int)} will be called
 * with the {@link #STATUS_REPORT_STATUS_ERROR} result code.
 * @param token token provided in {@link #sendSms(int, int, String, String, boolean, byte[])}
 * @param messageRef the message reference, which may be 1 byte if it is in
 * {@link SmsMessage#FORMAT_3GPP} format or 2 bytes if it is in
 * {@link SmsMessage#FORMAT_3GPP2} format (see 3GPP2 C.S0015-B).
 * @param format the format of the message.
 * @param pdu PDU representing the content of the status report.
 * @throws RuntimeException if called before {@link #onReady()} is triggered
 *
 * @deprecated Use {@link #onSmsStatusReportReceived(int, String, byte[])} instead without the
 * message reference.
 */

Body of Frist Method:
{
    synchronized (mLock) {
        if (mListener == null) {
            throw new RuntimeException("Feature not ready.");
        }
        try {
            mListener.onSmsStatusReportReceived(token, format, pdu);
        } catch (RemoteException e) {
            Log.e(LOG_TAG, "Can not process sms status report: " + e.getMessage());
            acknowledgeSmsReport(token, messageRef, STATUS_REPORT_STATUS_ERROR);
        }
    }
}
Body of Second Method:
{
    IImsSmsListener listener = null;
    synchronized (mLock) {
        listener = mListener;
    }
    if (listener == null) {
        throw new RuntimeException("Feature not ready.");
    }
    try {
        listener.onSmsStatusReportReceived(token, format, pdu);
    } catch (RemoteException e) {
        Log.e(LOG_TAG, "Can not process sms status report: " + e.getMessage());
        acknowledgeSmsReport(token, messageRef, STATUS_REPORT_STATUS_ERROR);
    }
}
------------------------
Find a silently evolved API code:android.hardware.Sensor.setType:COMMENT
Method Modifier: private     
Comment:/**
 * Sets the Type associated with the sensor.
 * NOTE: to be used only by native bindings in SensorManager.
 *
 * This allows interned static strings to be used across all representations of the Sensor. If
 * a sensor type is not referenced here, it will still be interned by the native SensorManager.
 *
 * @return {@code true} if the StringType was successfully set, {@code false} otherwise.
 */

Body of Frist Method:
{
    mType = value;
    switch(mType) {
        case TYPE_ACCELEROMETER:
            mStringType = STRING_TYPE_ACCELEROMETER;
            return true;
        case TYPE_AMBIENT_TEMPERATURE:
            mStringType = STRING_TYPE_AMBIENT_TEMPERATURE;
            return true;
        case TYPE_GAME_ROTATION_VECTOR:
            mStringType = STRING_TYPE_GAME_ROTATION_VECTOR;
            return true;
        case TYPE_GEOMAGNETIC_ROTATION_VECTOR:
            mStringType = STRING_TYPE_GEOMAGNETIC_ROTATION_VECTOR;
            return true;
        case TYPE_GLANCE_GESTURE:
            mStringType = STRING_TYPE_GLANCE_GESTURE;
            return true;
        case TYPE_GRAVITY:
            mStringType = STRING_TYPE_GRAVITY;
            return true;
        case TYPE_GYROSCOPE:
            mStringType = STRING_TYPE_GYROSCOPE;
            return true;
        case TYPE_GYROSCOPE_UNCALIBRATED:
            mStringType = STRING_TYPE_GYROSCOPE_UNCALIBRATED;
            return true;
        case TYPE_HEART_RATE:
            mStringType = STRING_TYPE_HEART_RATE;
            return true;
        case TYPE_LIGHT:
            mStringType = STRING_TYPE_LIGHT;
            return true;
        case TYPE_LINEAR_ACCELERATION:
            mStringType = STRING_TYPE_LINEAR_ACCELERATION;
            return true;
        case TYPE_MAGNETIC_FIELD:
            mStringType = STRING_TYPE_MAGNETIC_FIELD;
            return true;
        case TYPE_MAGNETIC_FIELD_UNCALIBRATED:
            mStringType = STRING_TYPE_MAGNETIC_FIELD_UNCALIBRATED;
            return true;
        case TYPE_PICK_UP_GESTURE:
            mStringType = STRING_TYPE_PICK_UP_GESTURE;
            return true;
        case TYPE_PRESSURE:
            mStringType = STRING_TYPE_PRESSURE;
            return true;
        case TYPE_PROXIMITY:
            mStringType = STRING_TYPE_PROXIMITY;
            return true;
        case TYPE_RELATIVE_HUMIDITY:
            mStringType = STRING_TYPE_RELATIVE_HUMIDITY;
            return true;
        case TYPE_ROTATION_VECTOR:
            mStringType = STRING_TYPE_ROTATION_VECTOR;
            return true;
        case TYPE_SIGNIFICANT_MOTION:
            mStringType = STRING_TYPE_SIGNIFICANT_MOTION;
            return true;
        case TYPE_STEP_COUNTER:
            mStringType = STRING_TYPE_STEP_COUNTER;
            return true;
        case TYPE_STEP_DETECTOR:
            mStringType = STRING_TYPE_STEP_DETECTOR;
            return true;
        case TYPE_TILT_DETECTOR:
            mStringType = SENSOR_STRING_TYPE_TILT_DETECTOR;
            return true;
        case TYPE_WAKE_GESTURE:
            mStringType = STRING_TYPE_WAKE_GESTURE;
            return true;
        case TYPE_ORIENTATION:
            mStringType = STRING_TYPE_ORIENTATION;
            return true;
        case TYPE_TEMPERATURE:
            mStringType = STRING_TYPE_TEMPERATURE;
            return true;
        case TYPE_DEVICE_ORIENTATION:
            mStringType = STRING_TYPE_DEVICE_ORIENTATION;
            return true;
        case TYPE_DYNAMIC_SENSOR_META:
            mStringType = STRING_TYPE_DYNAMIC_SENSOR_META;
            return true;
        case TYPE_LOW_LATENCY_OFFBODY_DETECT:
            mStringType = STRING_TYPE_LOW_LATENCY_OFFBODY_DETECT;
            return true;
        case TYPE_ACCELEROMETER_UNCALIBRATED:
            mStringType = STRING_TYPE_ACCELEROMETER_UNCALIBRATED;
            return true;
        case TYPE_HINGE_ANGLE:
            mStringType = STRING_TYPE_HINGE_ANGLE;
            return true;
        default:
            return false;
    }
}
Body of Second Method:
{
    mType = value;
    switch(mType) {
        case TYPE_ACCELEROMETER:
            mStringType = STRING_TYPE_ACCELEROMETER;
            return true;
        case TYPE_AMBIENT_TEMPERATURE:
            mStringType = STRING_TYPE_AMBIENT_TEMPERATURE;
            return true;
        case TYPE_GAME_ROTATION_VECTOR:
            mStringType = STRING_TYPE_GAME_ROTATION_VECTOR;
            return true;
        case TYPE_GEOMAGNETIC_ROTATION_VECTOR:
            mStringType = STRING_TYPE_GEOMAGNETIC_ROTATION_VECTOR;
            return true;
        case TYPE_GLANCE_GESTURE:
            mStringType = STRING_TYPE_GLANCE_GESTURE;
            return true;
        case TYPE_GRAVITY:
            mStringType = STRING_TYPE_GRAVITY;
            return true;
        case TYPE_GYROSCOPE:
            mStringType = STRING_TYPE_GYROSCOPE;
            return true;
        case TYPE_GYROSCOPE_UNCALIBRATED:
            mStringType = STRING_TYPE_GYROSCOPE_UNCALIBRATED;
            return true;
        case TYPE_HEART_RATE:
            mStringType = STRING_TYPE_HEART_RATE;
            return true;
        case TYPE_LIGHT:
            mStringType = STRING_TYPE_LIGHT;
            return true;
        case TYPE_LINEAR_ACCELERATION:
            mStringType = STRING_TYPE_LINEAR_ACCELERATION;
            return true;
        case TYPE_MAGNETIC_FIELD:
            mStringType = STRING_TYPE_MAGNETIC_FIELD;
            return true;
        case TYPE_MAGNETIC_FIELD_UNCALIBRATED:
            mStringType = STRING_TYPE_MAGNETIC_FIELD_UNCALIBRATED;
            return true;
        case TYPE_PICK_UP_GESTURE:
            mStringType = STRING_TYPE_PICK_UP_GESTURE;
            return true;
        case TYPE_PRESSURE:
            mStringType = STRING_TYPE_PRESSURE;
            return true;
        case TYPE_PROXIMITY:
            mStringType = STRING_TYPE_PROXIMITY;
            return true;
        case TYPE_RELATIVE_HUMIDITY:
            mStringType = STRING_TYPE_RELATIVE_HUMIDITY;
            return true;
        case TYPE_ROTATION_VECTOR:
            mStringType = STRING_TYPE_ROTATION_VECTOR;
            return true;
        case TYPE_SIGNIFICANT_MOTION:
            mStringType = STRING_TYPE_SIGNIFICANT_MOTION;
            return true;
        case TYPE_STEP_COUNTER:
            mStringType = STRING_TYPE_STEP_COUNTER;
            return true;
        case TYPE_STEP_DETECTOR:
            mStringType = STRING_TYPE_STEP_DETECTOR;
            return true;
        case TYPE_TILT_DETECTOR:
            mStringType = SENSOR_STRING_TYPE_TILT_DETECTOR;
            return true;
        case TYPE_WAKE_GESTURE:
            mStringType = STRING_TYPE_WAKE_GESTURE;
            return true;
        case TYPE_ORIENTATION:
            mStringType = STRING_TYPE_ORIENTATION;
            return true;
        case TYPE_TEMPERATURE:
            mStringType = STRING_TYPE_TEMPERATURE;
            return true;
        case TYPE_DEVICE_ORIENTATION:
            mStringType = STRING_TYPE_DEVICE_ORIENTATION;
            return true;
        case TYPE_DYNAMIC_SENSOR_META:
            mStringType = STRING_TYPE_DYNAMIC_SENSOR_META;
            return true;
        case TYPE_LOW_LATENCY_OFFBODY_DETECT:
            mStringType = STRING_TYPE_LOW_LATENCY_OFFBODY_DETECT;
            return true;
        case TYPE_ACCELEROMETER_UNCALIBRATED:
            mStringType = STRING_TYPE_ACCELEROMETER_UNCALIBRATED;
            return true;
        case TYPE_HINGE_ANGLE:
            mStringType = STRING_TYPE_HINGE_ANGLE;
            return true;
        case TYPE_HEAD_TRACKER:
            mStringType = STRING_TYPE_HEAD_TRACKER;
            return true;
        case TYPE_ACCELEROMETER_LIMITED_AXES:
            mStringType = STRING_TYPE_ACCELEROMETER_LIMITED_AXES;
            return true;
        case TYPE_GYROSCOPE_LIMITED_AXES:
            mStringType = STRING_TYPE_GYROSCOPE_LIMITED_AXES;
            return true;
        case TYPE_ACCELEROMETER_LIMITED_AXES_UNCALIBRATED:
            mStringType = STRING_TYPE_ACCELEROMETER_LIMITED_AXES_UNCALIBRATED;
            return true;
        case TYPE_GYROSCOPE_LIMITED_AXES_UNCALIBRATED:
            mStringType = STRING_TYPE_GYROSCOPE_LIMITED_AXES_UNCALIBRATED;
            return true;
        case TYPE_HEADING:
            mStringType = STRING_TYPE_HEADING;
            return true;
        default:
            return false;
    }
}
------------------------
Find a silently evolved API code:android.telephony.data.DataProfile.getMaxConnectionsTime:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @return The period in seconds to limit the maximum connections.
 *
 * @hide
 */

Body of Frist Method:
{
    return mMaxConnectionsTime;
}
Body of Second Method:
{
    if (mApnSetting != null) {
        return mApnSetting.getMaxConnsTime();
    }
    return 0;
}
------------------------
Find a silently evolved API code:android.location.LocationRequest.getIntervalMillis:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the desired interval of location updates, or {@link #PASSIVE_INTERVAL} if this is a
 * passive, no power request. A passive request will not actively generate location updates
 * (and thus will not be power blamed for location), but may receive location updates generated
 * as a result of other location requests. A passive request must always have an explicit
 * minimum update interval set.
 *
 * <p>Locations may be available at a faster interval than specified here, see
 * {@link #getMinUpdateIntervalMillis()} for the behavior in that case.
 *
 * @return the desired interval of location updates
 */

Body of Frist Method:
{
    return mInterval;
}
Body of Second Method:
{
    return mIntervalMillis;
}
------------------------
Find a silently evolved API code:android.service.controls.Control.StatefulBuilder.build:COMMENT
Method Modifier: public      
Comment:/**
 * @return a valid {@link Control}
 */

Body of Frist Method:
{
    return new Control(mControlId, mDeviceType, mTitle, mSubtitle, mStructure, mZone, mAppIntent, mCustomIcon, mCustomColor, mStatus, mControlTemplate, mStatusText);
}
Body of Second Method:
{
    return new Control(mControlId, mDeviceType, mTitle, mSubtitle, mStructure, mZone, mAppIntent, mCustomIcon, mCustomColor, mStatus, mControlTemplate, mStatusText, mAuthRequired);
}
------------------------
Find a silently evolved API code:android.os.PowerComponents.Builder.getTotalPower:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the total power accumulated by this builder so far. It may change
 * by the time the {@code build()} method is called.
 */

Body of Frist Method:
{
    double totalPowerMah = 0;
    for (int i = mPowerComponentsMah.length - 1; i >= 0; i--) {
        totalPowerMah += mPowerComponentsMah[i];
    }
    return totalPowerMah;
}
Body of Second Method:
{
    double totalPowerMah = 0;
    for (int componentId = 0; componentId < BatteryConsumer.POWER_COMPONENT_COUNT; componentId++) {
        totalPowerMah += mData.getDouble(mData.getKeyOrThrow(componentId, PROCESS_STATE_ANY).mPowerColumnIndex);
    }
    for (int i = 0; i < mData.layout.customPowerComponentCount; i++) {
        totalPowerMah += mData.getDouble(mData.layout.firstCustomConsumedPowerColumn + i);
    }
    return totalPowerMah;
}
------------------------
Find a silently evolved API code:android.app.DreamManager.setActiveDream:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets the active dream on the device to be "dreamComponent".
 *
 * <p>This is only used for testing the dream service APIs.
 *
 * @hide
 */

Body of Frist Method:
{
    ComponentName[] dreams = { dreamComponent };
    try {
        mService.setDreamComponentsForUser(mContext.getUserId(), dreams);
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    ComponentName[] dreams = { dreamComponent };
    try {
        mService.setDreamComponentsForUser(mContext.getUserId(), dreamComponent != null ? dreams : null);
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.nl80211.DeviceWiphyCapabilities.isWifiStandardSupported:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the IEEE 802.11 standard support
 *
 * @param standard the IEEE 802.11 standard to check on its support.
 * valid values from {@link ScanResult}'s {@code WIFI_STANDARD_}
 * @return {@code true} if supported, {@code false} otherwise.
 */

Body of Frist Method:
{
    switch(standard) {
        case ScanResult.WIFI_STANDARD_LEGACY:
            return true;
        case ScanResult.WIFI_STANDARD_11N:
            return m80211nSupported;
        case ScanResult.WIFI_STANDARD_11AC:
            return m80211acSupported;
        case ScanResult.WIFI_STANDARD_11AX:
            return m80211axSupported;
        default:
            Log.e(TAG, "isWifiStandardSupported called with invalid standard: " + standard);
            return false;
    }
}
Body of Second Method:
{
    switch(standard) {
        case ScanResult.WIFI_STANDARD_LEGACY:
            return true;
        case ScanResult.WIFI_STANDARD_11N:
            return m80211nSupported;
        case ScanResult.WIFI_STANDARD_11AC:
            return m80211acSupported;
        case ScanResult.WIFI_STANDARD_11AX:
            return m80211axSupported;
        case ScanResult.WIFI_STANDARD_11BE:
            return m80211beSupported;
        default:
            Log.e(TAG, "isWifiStandardSupported called with invalid standard: " + standard);
            return false;
    }
}
------------------------
Find a silently evolved API code:android.text.BoringLayout.init:COMMENT
Method Modifier: default     
Comment:/* package */

Body of Frist Method:
{
    int spacing;
    if (source instanceof String && align == Layout.Alignment.ALIGN_NORMAL) {
        mDirect = source.toString();
    } else {
        mDirect = null;
    }
    mPaint = paint;
    if (includePad) {
        spacing = metrics.bottom - metrics.top;
        mDesc = metrics.bottom;
    } else {
        spacing = metrics.descent - metrics.ascent;
        mDesc = metrics.descent;
    }
    mBottom = spacing;
    if (trustWidth) {
        mMax = metrics.width;
    } else {
        /*
             * If we have ellipsized, we have to actually calculate the
             * width because the width that was passed in was for the
             * full text, not the ellipsized form.
             */
        TextLine line = TextLine.obtain();
        line.set(paint, source, 0, source.length(), Layout.DIR_LEFT_TO_RIGHT, Layout.DIRS_ALL_LEFT_TO_RIGHT, false, null, mEllipsizedStart, mEllipsizedStart + mEllipsizedCount);
        mMax = (int) Math.ceil(line.metrics(null));
        TextLine.recycle(line);
    }
    if (includePad) {
        mTopPadding = metrics.top - metrics.ascent;
        mBottomPadding = metrics.bottom - metrics.descent;
    }
}
Body of Second Method:
{
    int spacing;
    if (source instanceof String && align == Layout.Alignment.ALIGN_NORMAL) {
        mDirect = source.toString();
    } else {
        mDirect = null;
    }
    mPaint = paint;
    if (includePad) {
        spacing = metrics.bottom - metrics.top;
        mDesc = metrics.bottom;
    } else {
        spacing = metrics.descent - metrics.ascent;
        mDesc = metrics.descent;
    }
    mBottom = spacing;
    if (trustWidth) {
        mMax = metrics.width;
    } else {
        /*
             * If we have ellipsized, we have to actually calculate the
             * width because the width that was passed in was for the
             * full text, not the ellipsized form.
             */
        TextLine line = TextLine.obtain();
        line.set(paint, source, 0, source.length(), Layout.DIR_LEFT_TO_RIGHT, Layout.DIRS_ALL_LEFT_TO_RIGHT, false, null, mEllipsizedStart, mEllipsizedStart + mEllipsizedCount, useFallbackLineSpacing);
        mMax = (int) Math.ceil(line.metrics(null));
        TextLine.recycle(line);
    }
    if (includePad) {
        mTopPadding = metrics.top - metrics.ascent;
        mBottomPadding = metrics.bottom - metrics.descent;
    }
}
------------------------
Find a silently evolved API code:android.telephony.CallQuality.writeToParcel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * {@link Parcelable#writeToParcel}
 */

Body of Frist Method:
{
    dest.writeInt(mDownlinkCallQualityLevel);
    dest.writeInt(mUplinkCallQualityLevel);
    dest.writeInt(mCallDuration);
    dest.writeInt(mNumRtpPacketsTransmitted);
    dest.writeInt(mNumRtpPacketsReceived);
    dest.writeInt(mNumRtpPacketsTransmittedLost);
    dest.writeInt(mNumRtpPacketsNotReceived);
    dest.writeInt(mAverageRelativeJitter);
    dest.writeInt(mMaxRelativeJitter);
    dest.writeInt(mAverageRoundTripTime);
    dest.writeInt(mCodecType);
    dest.writeBoolean(mRtpInactivityDetected);
    dest.writeBoolean(mRxSilenceDetected);
    dest.writeBoolean(mTxSilenceDetected);
}
Body of Second Method:
{
    dest.writeInt(mDownlinkCallQualityLevel);
    dest.writeInt(mUplinkCallQualityLevel);
    dest.writeInt(mCallDuration);
    dest.writeInt(mNumRtpPacketsTransmitted);
    dest.writeInt(mNumRtpPacketsReceived);
    dest.writeInt(mNumRtpPacketsTransmittedLost);
    dest.writeInt(mNumRtpPacketsNotReceived);
    dest.writeInt(mAverageRelativeJitter);
    dest.writeInt(mMaxRelativeJitter);
    dest.writeInt(mAverageRoundTripTime);
    dest.writeInt(mCodecType);
    dest.writeBoolean(mRtpInactivityDetected);
    dest.writeBoolean(mRxSilenceDetected);
    dest.writeBoolean(mTxSilenceDetected);
    dest.writeInt(mNumVoiceFrames);
    dest.writeInt(mNumNoDataFrames);
    dest.writeInt(mNumDroppedRtpPackets);
    dest.writeLong(mMinPlayoutDelayMillis);
    dest.writeLong(mMaxPlayoutDelayMillis);
    dest.writeInt(mNumRtpSidPacketsReceived);
    dest.writeInt(mNumRtpDuplicatePackets);
}
------------------------
Find a silently evolved API code:android.media.AudioDeviceInfo.isValidAudioDeviceTypeOut:COMMENT
Method Modifier: default     static      
Comment:/*package*/

Body of Frist Method:
{
    switch(type) {
        case TYPE_BUILTIN_EARPIECE:
        case TYPE_BUILTIN_SPEAKER:
        case TYPE_WIRED_HEADSET:
        case TYPE_WIRED_HEADPHONES:
        case TYPE_BLUETOOTH_SCO:
        case TYPE_BLUETOOTH_A2DP:
        case TYPE_HDMI:
        case TYPE_DOCK:
        case TYPE_USB_ACCESSORY:
        case TYPE_USB_DEVICE:
        case TYPE_USB_HEADSET:
        case TYPE_TELEPHONY:
        case TYPE_LINE_ANALOG:
        case TYPE_HDMI_ARC:
        case TYPE_HDMI_EARC:
        case TYPE_LINE_DIGITAL:
        case TYPE_FM:
        case TYPE_AUX_LINE:
        case TYPE_IP:
        case TYPE_BUS:
        case TYPE_HEARING_AID:
        case TYPE_BUILTIN_SPEAKER_SAFE:
        case TYPE_BLE_HEADSET:
        case TYPE_BLE_SPEAKER:
            return true;
        default:
            return false;
    }
}
Body of Second Method:
{
    switch(type) {
        case TYPE_BUILTIN_EARPIECE:
        case TYPE_BUILTIN_SPEAKER:
        case TYPE_WIRED_HEADSET:
        case TYPE_WIRED_HEADPHONES:
        case TYPE_BLUETOOTH_SCO:
        case TYPE_BLUETOOTH_A2DP:
        case TYPE_HDMI:
        case TYPE_DOCK:
        case TYPE_USB_ACCESSORY:
        case TYPE_USB_DEVICE:
        case TYPE_USB_HEADSET:
        case TYPE_TELEPHONY:
        case TYPE_LINE_ANALOG:
        case TYPE_HDMI_ARC:
        case TYPE_HDMI_EARC:
        case TYPE_LINE_DIGITAL:
        case TYPE_FM:
        case TYPE_AUX_LINE:
        case TYPE_IP:
        case TYPE_BUS:
        case TYPE_HEARING_AID:
        case TYPE_BUILTIN_SPEAKER_SAFE:
        case TYPE_BLE_HEADSET:
        case TYPE_BLE_SPEAKER:
        case TYPE_BLE_BROADCAST:
            return true;
        default:
            return false;
    }
}
------------------------
Find a silently evolved API code:android.os.UidBatteryConsumer.Builder.setTimeInStateMs:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the duration, in milliseconds, that this UID was active in a particular state,
 * such as foreground or background.
 */

Body of Frist Method:
{
    switch(state) {
        case STATE_FOREGROUND:
            mTimeInForegroundMs = timeInStateMs;
            break;
        case STATE_BACKGROUND:
            mTimeInBackgroundMs = timeInStateMs;
            break;
        default:
            throw new IllegalArgumentException("Unsupported state: " + state);
    }
    return this;
}
Body of Second Method:
{
    switch(state) {
        case STATE_FOREGROUND:
            mData.putLong(COLUMN_INDEX_TIME_IN_FOREGROUND, timeInStateMs);
            break;
        case STATE_BACKGROUND:
            mData.putLong(COLUMN_INDEX_TIME_IN_BACKGROUND, timeInStateMs);
            break;
        default:
            throw new IllegalArgumentException("Unsupported state: " + state);
    }
    return this;
}
------------------------

