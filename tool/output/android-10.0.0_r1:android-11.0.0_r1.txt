Find a silently evolved API code:android.content.pm.PackageItemInfo.loadLabel:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the current textual label associated with this item.  This
 * will call back on the given PackageManager to load the label from
 * the application.
 *
 * @param pm A PackageManager from which the label can be loaded; usually
 * the PackageManager from which you originally retrieved this item.
 *
 * @return Returns a CharSequence containing the item's label.  If the
 * item does not have a label, its name is returned.
 */

Body of Frist Method:
{
    if (sForceSafeLabels) {
        return loadSafeLabel(pm, DEFAULT_MAX_LABEL_SIZE_PX, SAFE_STRING_FLAG_TRIM | SAFE_STRING_FLAG_FIRST_LINE);
    } else {
        return loadUnsafeLabel(pm);
    }
}
Body of Second Method:
{
    if (sForceSafeLabels && !Objects.equals(packageName, ActivityThread.currentPackageName())) {
        return loadSafeLabel(pm, DEFAULT_MAX_LABEL_SIZE_PX, SAFE_STRING_FLAG_TRIM | SAFE_STRING_FLAG_FIRST_LINE);
    } else {
        return loadUnsafeLabel(pm);
    }
}
------------------------
Find a silently evolved API code:android.net.RouteInfo.selectBestRoute:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Find the route from a Collection of routes that best matches a given address.
 * May return null if no routes are applicable.
 * @param routes a Collection of RouteInfos to chose from
 * @param dest the InetAddress your trying to get to
 * @return the RouteInfo from the Collection that best fits the given address
 *
 * @hide
 */

Body of Frist Method:
{
    if ((routes == null) || (dest == null))
        return null;
    RouteInfo bestRoute = null;
    // pick a longest prefix match under same address type
    for (RouteInfo route : routes) {
        if (NetworkUtils.addressTypeMatches(route.mDestination.getAddress(), dest)) {
            if ((bestRoute != null) && (bestRoute.mDestination.getPrefixLength() >= route.mDestination.getPrefixLength())) {
                continue;
            }
            if (route.matches(dest))
                bestRoute = route;
        }
    }
    return bestRoute;
}
Body of Second Method:
{
    return NetUtils.selectBestRoute(routes, dest);
}
------------------------
Find a silently evolved API code:android.app.Service.attach:COMMENT
Method Modifier: public      final       hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    attachBaseContext(context);
    // NOTE:  unused - remove?
    mThread = thread;
    mClassName = className;
    mToken = token;
    mApplication = application;
    mActivityManager = (IActivityManager) activityManager;
    mStartCompatibility = getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.ECLAIR;
}
Body of Second Method:
{
    attachBaseContext(context);
    // NOTE:  unused - remove?
    mThread = thread;
    mClassName = className;
    mToken = token;
    mApplication = application;
    mActivityManager = (IActivityManager) activityManager;
    mStartCompatibility = getApplicationInfo().targetSdkVersion < Build.VERSION_CODES.ECLAIR;
    setContentCaptureOptions(application.getContentCaptureOptions());
}
------------------------
Find a silently evolved API code:android.media.tv.TvTrackInfo.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Used to package this object into a {@link Parcel}.
 *
 * @param dest The {@link Parcel} to be written.
 * @param flags The flags used for parceling.
 */

Body of Frist Method:
{
    dest.writeInt(mType);
    dest.writeString(mId);
    dest.writeString(mLanguage);
    dest.writeString(mDescription != null ? mDescription.toString() : null);
    dest.writeInt(mAudioChannelCount);
    dest.writeInt(mAudioSampleRate);
    dest.writeInt(mVideoWidth);
    dest.writeInt(mVideoHeight);
    dest.writeFloat(mVideoFrameRate);
    dest.writeFloat(mVideoPixelAspectRatio);
    dest.writeByte(mVideoActiveFormatDescription);
    dest.writeBundle(mExtra);
}
Body of Second Method:
{
    Preconditions.checkNotNull(dest);
    dest.writeInt(mType);
    dest.writeString(mId);
    dest.writeString(mLanguage);
    dest.writeString(mDescription != null ? mDescription.toString() : null);
    dest.writeString(mEncoding);
    dest.writeInt(mEncrypted ? 1 : 0);
    dest.writeInt(mAudioChannelCount);
    dest.writeInt(mAudioSampleRate);
    dest.writeInt(mAudioDescription ? 1 : 0);
    dest.writeInt(mHardOfHearing ? 1 : 0);
    dest.writeInt(mSpokenSubtitle ? 1 : 0);
    dest.writeInt(mVideoWidth);
    dest.writeInt(mVideoHeight);
    dest.writeFloat(mVideoFrameRate);
    dest.writeFloat(mVideoPixelAspectRatio);
    dest.writeByte(mVideoActiveFormatDescription);
    dest.writeBundle(mExtra);
}
------------------------
Find a silently evolved API code:android.media.tv.TvTrackInfo.Builder.setLanguage:COMMENT
<android.media.tv.TvTrackInfo.Builder: Builder setLanguage(String)>
public      final       ->public      
Method Modifier: public      final       
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * Sets the language information of the current track.
 *
 * @param language The language string encoded by either ISO 639-1 or ISO 639-2/T.
 */

Body of Frist Method:
{
    mLanguage = language;
    return this;
}
Body of Second Method:
{
    Preconditions.checkNotNull(language);
    mLanguage = language;
    return this;
}
------------------------
Find a silently evolved API code:android.net.NattKeepalivePacketData.writeToParcel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Write to parcel
 */

Body of Frist Method:
{
    out.writeString(srcAddress.getHostAddress());
    out.writeString(dstAddress.getHostAddress());
    out.writeInt(srcPort);
    out.writeInt(dstPort);
}
Body of Second Method:
{
    out.writeString(getSrcAddress().getHostAddress());
    out.writeString(getDstAddress().getHostAddress());
    out.writeInt(getSrcPort());
    out.writeInt(getDstPort());
}
------------------------
Find a silently evolved API code:android.net.TrafficStats.getUidTxBytes:COMMENT
Method Modifier: public      static      
Comment:/**
 * Return number of bytes transmitted by the given UID since device boot.
 * Counts packets across all network interfaces, and always increases
 * monotonically since device boot. Statistics are measured at the network
 * layer, so they include both TCP and UDP usage.
 * <p>
 * Before {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}, this may
 * return {@link #UNSUPPORTED} on devices where statistics aren't available.
 * <p>
 * Starting in {@link android.os.Build.VERSION_CODES#N} this will only
 * report traffic statistics for the calling UID. It will return
 * {@link #UNSUPPORTED} for all other UIDs for privacy reasons. To access
 * historical network statistics belonging to other UIDs, use
 * {@link NetworkStatsManager}.
 *
 * @see android.os.Process#myUid()
 * @see android.content.pm.ApplicationInfo#uid
 */

Body of Frist Method:
{
    // This isn't actually enforcing any security; it just returns the
    // unsupported value. The real filtering is done at the kernel level.
    final int callingUid = android.os.Process.myUid();
    if (callingUid == android.os.Process.SYSTEM_UID || callingUid == uid) {
        try {
            return getStatsService().getUidStats(uid, TYPE_TX_BYTES);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    } else {
        return UNSUPPORTED;
    }
}
Body of Second Method:
{
    try {
        return getStatsService().getUidStats(uid, TYPE_TX_BYTES);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.view.textclassifier.TextClassifierEvent.Builder.setExtras:COMMENT
Method Modifier: public      
Comment:/**
 * Sets a bundle containing non-structured extra information about the event.
 *
 * <p><b>NOTE: </b>Prefer to set only immutable values on the bundle otherwise, avoid
 * updating the internals of this bundle as it may have unexpected consequences on the
 * clients of the built event object. For similar reasons, avoid depending on mutable
 * objects in this bundle.
 */

Body of Frist Method:
{
    mExtras = Preconditions.checkNotNull(extras);
    return self();
}
Body of Second Method:
{
    mExtras = Objects.requireNonNull(extras);
    return self();
}
------------------------
Find a silently evolved API code:android.app.StatusBarManager.DisableInfo.areAllComponentsEnabled:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @return {@code true} if no components are disabled (default state)
 *
 * @hide
 */

Body of Frist Method:
{
    return !mStatusBarExpansion && !mNavigateHome && !mNotificationPeeking && !mRecents && !mSearch;
}
Body of Second Method:
{
    return !mStatusBarExpansion && !mNavigateHome && !mNotificationPeeking && !mRecents && !mSearch && !mSystemIcons && !mClock && !mNotificationIcons;
}
------------------------
Find a silently evolved API code:android.content.ContentProviderClient.query:COMMENT
Method Modifier: public      
Comment:/**
 * See {@link ContentProvider#query ContentProvider.query}
 */

Body of Frist Method:
{
    Preconditions.checkNotNull(uri, "url");
    beforeRemote();
    try {
        ICancellationSignal remoteCancellationSignal = null;
        if (cancellationSignal != null) {
            cancellationSignal.throwIfCanceled();
            remoteCancellationSignal = mContentProvider.createCancellationSignal();
            cancellationSignal.setRemote(remoteCancellationSignal);
        }
        final Cursor cursor = mContentProvider.query(mPackageName, uri, projection, queryArgs, remoteCancellationSignal);
        if (cursor == null) {
            return null;
        }
        return new CursorWrapperInner(cursor);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}
Body of Second Method:
{
    Objects.requireNonNull(uri, "url");
    beforeRemote();
    try {
        ICancellationSignal remoteCancellationSignal = null;
        if (cancellationSignal != null) {
            cancellationSignal.throwIfCanceled();
            remoteCancellationSignal = mContentProvider.createCancellationSignal();
            cancellationSignal.setRemote(remoteCancellationSignal);
        }
        final Cursor cursor = mContentProvider.query(mPackageName, mAttributionTag, uri, projection, queryArgs, remoteCancellationSignal);
        if (cursor == null) {
            return null;
        }
        return new CursorWrapperInner(cursor);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}
------------------------
Find a silently evolved API code:android.os.Looper.loop:COMMENT
Method Modifier: public      static      
Comment:/**
 * Run the message queue in this thread. Be sure to call
 * {@link #quit()} to end the loop.
 */

Body of Frist Method:
{
    final Looper me = myLooper();
    if (me == null) {
        throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread.");
    }
    final MessageQueue queue = me.mQueue;
    // Make sure the identity of this thread is that of the local process,
    // and keep track of what that identity token actually is.
    Binder.clearCallingIdentity();
    final long ident = Binder.clearCallingIdentity();
    // Allow overriding a threshold with a system prop. e.g.
    // adb shell 'setprop log.looper.1000.main.slow 1 && stop && start'
    final int thresholdOverride = SystemProperties.getInt("log.looper." + Process.myUid() + "." + Thread.currentThread().getName() + ".slow", 0);
    boolean slowDeliveryDetected = false;
    for (; ; ) {
        // might block
        Message msg = queue.next();
        if (msg == null) {
            // No message indicates that the message queue is quitting.
            return;
        }
        // This must be in a local variable, in case a UI event sets the logger
        final Printer logging = me.mLogging;
        if (logging != null) {
            logging.println(">>>>> Dispatching to " + msg.target + " " + msg.callback + ": " + msg.what);
        }
        // Make sure the observer won't change while processing a transaction.
        final Observer observer = sObserver;
        final long traceTag = me.mTraceTag;
        long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;
        long slowDeliveryThresholdMs = me.mSlowDeliveryThresholdMs;
        if (thresholdOverride > 0) {
            slowDispatchThresholdMs = thresholdOverride;
            slowDeliveryThresholdMs = thresholdOverride;
        }
        final boolean logSlowDelivery = (slowDeliveryThresholdMs > 0) && (msg.when > 0);
        final boolean logSlowDispatch = (slowDispatchThresholdMs > 0);
        final boolean needStartTime = logSlowDelivery || logSlowDispatch;
        final boolean needEndTime = logSlowDispatch;
        if (traceTag != 0 && Trace.isTagEnabled(traceTag)) {
            Trace.traceBegin(traceTag, msg.target.getTraceName(msg));
        }
        final long dispatchStart = needStartTime ? SystemClock.uptimeMillis() : 0;
        final long dispatchEnd;
        Object token = null;
        if (observer != null) {
            token = observer.messageDispatchStarting();
        }
        long origWorkSource = ThreadLocalWorkSource.setUid(msg.workSourceUid);
        try {
            msg.target.dispatchMessage(msg);
            if (observer != null) {
                observer.messageDispatched(token, msg);
            }
            dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0;
        } catch (Exception exception) {
            if (observer != null) {
                observer.dispatchingThrewException(token, msg, exception);
            }
            throw exception;
        } finally {
            ThreadLocalWorkSource.restore(origWorkSource);
            if (traceTag != 0) {
                Trace.traceEnd(traceTag);
            }
        }
        if (logSlowDelivery) {
            if (slowDeliveryDetected) {
                if ((dispatchStart - msg.when) <= 10) {
                    Slog.w(TAG, "Drained");
                    slowDeliveryDetected = false;
                }
            } else {
                if (showSlowLog(slowDeliveryThresholdMs, msg.when, dispatchStart, "delivery", msg)) {
                    // Once we write a slow delivery log, suppress until the queue drains.
                    slowDeliveryDetected = true;
                }
            }
        }
        if (logSlowDispatch) {
            showSlowLog(slowDispatchThresholdMs, dispatchStart, dispatchEnd, "dispatch", msg);
        }
        if (logging != null) {
            logging.println("<<<<< Finished to " + msg.target + " " + msg.callback);
        }
        // Make sure that during the course of dispatching the
        // identity of the thread wasn't corrupted.
        final long newIdent = Binder.clearCallingIdentity();
        if (ident != newIdent) {
            Log.wtf(TAG, "Thread identity changed from 0x" + Long.toHexString(ident) + " to 0x" + Long.toHexString(newIdent) + " while dispatching to " + msg.target.getClass().getName() + " " + msg.callback + " what=" + msg.what);
        }
        msg.recycleUnchecked();
    }
}
Body of Second Method:
{
    final Looper me = myLooper();
    if (me == null) {
        throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread.");
    }
    if (me.mInLoop) {
        Slog.w(TAG, "Loop again would have the queued messages be executed" + " before this one completed.");
    }
    me.mInLoop = true;
    final MessageQueue queue = me.mQueue;
    // Make sure the identity of this thread is that of the local process,
    // and keep track of what that identity token actually is.
    Binder.clearCallingIdentity();
    final long ident = Binder.clearCallingIdentity();
    // Allow overriding a threshold with a system prop. e.g.
    // adb shell 'setprop log.looper.1000.main.slow 1 && stop && start'
    final int thresholdOverride = SystemProperties.getInt("log.looper." + Process.myUid() + "." + Thread.currentThread().getName() + ".slow", 0);
    boolean slowDeliveryDetected = false;
    for (; ; ) {
        // might block
        Message msg = queue.next();
        if (msg == null) {
            // No message indicates that the message queue is quitting.
            return;
        }
        // This must be in a local variable, in case a UI event sets the logger
        final Printer logging = me.mLogging;
        if (logging != null) {
            logging.println(">>>>> Dispatching to " + msg.target + " " + msg.callback + ": " + msg.what);
        }
        // Make sure the observer won't change while processing a transaction.
        final Observer observer = sObserver;
        final long traceTag = me.mTraceTag;
        long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;
        long slowDeliveryThresholdMs = me.mSlowDeliveryThresholdMs;
        if (thresholdOverride > 0) {
            slowDispatchThresholdMs = thresholdOverride;
            slowDeliveryThresholdMs = thresholdOverride;
        }
        final boolean logSlowDelivery = (slowDeliveryThresholdMs > 0) && (msg.when > 0);
        final boolean logSlowDispatch = (slowDispatchThresholdMs > 0);
        final boolean needStartTime = logSlowDelivery || logSlowDispatch;
        final boolean needEndTime = logSlowDispatch;
        if (traceTag != 0 && Trace.isTagEnabled(traceTag)) {
            Trace.traceBegin(traceTag, msg.target.getTraceName(msg));
        }
        final long dispatchStart = needStartTime ? SystemClock.uptimeMillis() : 0;
        final long dispatchEnd;
        Object token = null;
        if (observer != null) {
            token = observer.messageDispatchStarting();
        }
        long origWorkSource = ThreadLocalWorkSource.setUid(msg.workSourceUid);
        try {
            msg.target.dispatchMessage(msg);
            if (observer != null) {
                observer.messageDispatched(token, msg);
            }
            dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0;
        } catch (Exception exception) {
            if (observer != null) {
                observer.dispatchingThrewException(token, msg, exception);
            }
            throw exception;
        } finally {
            ThreadLocalWorkSource.restore(origWorkSource);
            if (traceTag != 0) {
                Trace.traceEnd(traceTag);
            }
        }
        if (logSlowDelivery) {
            if (slowDeliveryDetected) {
                if ((dispatchStart - msg.when) <= 10) {
                    Slog.w(TAG, "Drained");
                    slowDeliveryDetected = false;
                }
            } else {
                if (showSlowLog(slowDeliveryThresholdMs, msg.when, dispatchStart, "delivery", msg)) {
                    // Once we write a slow delivery log, suppress until the queue drains.
                    slowDeliveryDetected = true;
                }
            }
        }
        if (logSlowDispatch) {
            showSlowLog(slowDispatchThresholdMs, dispatchStart, dispatchEnd, "dispatch", msg);
        }
        if (logging != null) {
            logging.println("<<<<< Finished to " + msg.target + " " + msg.callback);
        }
        // Make sure that during the course of dispatching the
        // identity of the thread wasn't corrupted.
        final long newIdent = Binder.clearCallingIdentity();
        if (ident != newIdent) {
            Log.wtf(TAG, "Thread identity changed from 0x" + Long.toHexString(ident) + " to 0x" + Long.toHexString(newIdent) + " while dispatching to " + msg.target.getClass().getName() + " " + msg.callback + " what=" + msg.what);
        }
        msg.recycleUnchecked();
    }
}
------------------------
Find a silently evolved API code:android.media.AudioFormat.Builder.setEncoding:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the data encoding format.
 * @param encoding the specified encoding or default.
 * @return the same Builder instance.
 * @throws java.lang.IllegalArgumentException
 */

Body of Frist Method:
{
    switch(encoding) {
        case ENCODING_DEFAULT:
            mEncoding = ENCODING_PCM_16BIT;
            break;
        case ENCODING_PCM_16BIT:
        case ENCODING_PCM_8BIT:
        case ENCODING_PCM_FLOAT:
        case ENCODING_AC3:
        case ENCODING_E_AC3:
        case ENCODING_DTS:
        case ENCODING_DTS_HD:
        case ENCODING_MP3:
        case ENCODING_AAC_LC:
        case ENCODING_AAC_HE_V1:
        case ENCODING_AAC_HE_V2:
        case ENCODING_IEC61937:
        case ENCODING_DOLBY_TRUEHD:
        case ENCODING_AAC_ELD:
        case ENCODING_AAC_XHE:
        case ENCODING_AC4:
        case ENCODING_E_AC3_JOC:
        case ENCODING_DOLBY_MAT:
            mEncoding = encoding;
            break;
        case ENCODING_INVALID:
        default:
            throw new IllegalArgumentException("Invalid encoding " + encoding);
    }
    mPropertySetMask |= AUDIO_FORMAT_HAS_PROPERTY_ENCODING;
    return this;
}
Body of Second Method:
{
    switch(encoding) {
        case ENCODING_DEFAULT:
            mEncoding = ENCODING_PCM_16BIT;
            break;
        case ENCODING_PCM_16BIT:
        case ENCODING_PCM_8BIT:
        case ENCODING_PCM_FLOAT:
        case ENCODING_AC3:
        case ENCODING_E_AC3:
        case ENCODING_DTS:
        case ENCODING_DTS_HD:
        case ENCODING_MP3:
        case ENCODING_AAC_LC:
        case ENCODING_AAC_HE_V1:
        case ENCODING_AAC_HE_V2:
        case ENCODING_IEC61937:
        case ENCODING_DOLBY_TRUEHD:
        case ENCODING_AAC_ELD:
        case ENCODING_AAC_XHE:
        case ENCODING_AC4:
        case ENCODING_E_AC3_JOC:
        case ENCODING_DOLBY_MAT:
        case ENCODING_OPUS:
            mEncoding = encoding;
            break;
        case ENCODING_INVALID:
        default:
            throw new IllegalArgumentException("Invalid encoding " + encoding);
    }
    mPropertySetMask |= AUDIO_FORMAT_HAS_PROPERTY_ENCODING;
    return this;
}
------------------------
Find a silently evolved API code:android.media.session.MediaController.TransportControls.pause:COMMENT
Method Modifier: public      
Comment:/**
 * Request that the player pause its playback and stay at its current
 * position.
 */

Body of Frist Method:
{
    try {
        mSessionBinder.pause(mContext.getPackageName(), mCbStub);
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling pause.", e);
    }
}
Body of Second Method:
{
    try {
        mSessionBinder.pause(mContext.getPackageName());
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling pause.", e);
    }
}
------------------------
Find a silently evolved API code:android.telephony.ims.ImsCallSessionListener.callSessionMergeComplete:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Compatibility method for older implementations of ImsService.
 *
 * See {@link #callSessionMergeComplete(ImsCallSessionImplBase)}}.
 *
 * @hide
 */

Body of Frist Method:
{
    try {
        mListener.callSessionMergeComplete(newSession);
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}
Body of Second Method:
{
    try {
        mListener.callSessionMergeComplete(newSession);
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.view.WindowInsets.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Builds a {@link WindowInsets} instance.
 *
 * @return the {@link WindowInsets} instance.
 */

Body of Frist Method:
{
    return new WindowInsets(mSystemInsetsConsumed ? null : mTypeInsetsMap, mStableInsetsConsumed ? null : mTypeMaxInsetsMap, mTypeVisibilityMap, mIsRound, mAlwaysConsumeSystemBars, mDisplayCutout);
}
Body of Second Method:
{
    return new WindowInsets(mSystemInsetsConsumed ? null : mTypeInsetsMap, mStableInsetsConsumed ? null : mTypeMaxInsetsMap, mTypeVisibilityMap, mIsRound, mAlwaysConsumeSystemBars, mDisplayCutout, systemBars(), false);
}
------------------------
Find a silently evolved API code:android.telephony.ims.ImsCallSessionListener.callSessionInitiated:COMMENT
Method Modifier: public      
Comment:/**
 * The IMS call session has been initiated.
 *
 * @param profile the associated {@link ImsCallProfile}.
 */

Body of Frist Method:
{
    try {
        mListener.callSessionInitiated(profile);
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}
Body of Second Method:
{
    try {
        mListener.callSessionInitiated(profile);
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.content.pm.ShortcutManager.getManifestShortcuts:COMMENT
Method Modifier: public      
Comment:/**
 * Return all static (manifest) shortcuts from the caller app.
 *
 * <p>This API is intended to be used for examining what shortcuts are currently published.
 * Re-publishing returned {@link ShortcutInfo}s via APIs such as
 * {@link #setDynamicShortcuts(List)} may cause loss of information such as icons.
 *
 * @throws IllegalStateException when the user is locked.
 */

Body of Frist Method:
{
    try {
        return mService.getManifestShortcuts(mContext.getPackageName(), injectMyUserId()).getList();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    try {
        return mService.getShortcuts(mContext.getPackageName(), FLAG_MATCH_MANIFEST, injectMyUserId()).getList();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.widget.ToggleButton.setTextOff:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the text for when the button is not in the checked state.
 *
 * @param textOff The text.
 */

Body of Frist Method:
{
    mTextOff = textOff;
}
Body of Second Method:
{
    mTextOff = textOff;
    // Default state is derived from on/off-text, so state has to be updated when on/off-text
    // are updated.
    setDefaultStateDescritption();
}
------------------------
Find a silently evolved API code:android.net.VpnService.prepareAndAuthorize:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Version of {@link #prepare(Context)} which does not require user consent.
 *
 * <p>Requires {@link android.Manifest.permission#CONTROL_VPN} and should generally not be
 * used. Only acceptable in situations where user consent has been obtained through other means.
 *
 * <p>Once this is run, future preparations may be done with the standard prepare method as this
 * will authorize the package to prepare the VPN without consent in the future.
 *
 * @hide
 */

Body of Frist Method:
{
    IConnectivityManager cm = getService();
    String packageName = context.getPackageName();
    try {
        // Only prepare if we're not already prepared.
        int userId = context.getUserId();
        if (!cm.prepareVpn(packageName, null, userId)) {
            cm.prepareVpn(null, packageName, userId);
        }
        cm.setVpnPackageAuthorization(packageName, userId, true);
    } catch (RemoteException e) {
    // ignore
    }
}
Body of Second Method:
{
    IConnectivityManager cm = getService();
    String packageName = context.getPackageName();
    try {
        // Only prepare if we're not already prepared.
        int userId = context.getUserId();
        if (!cm.prepareVpn(packageName, null, userId)) {
            cm.prepareVpn(null, packageName, userId);
        }
        cm.setVpnPackageAuthorization(packageName, userId, VpnManager.TYPE_VPN_SERVICE);
    } catch (RemoteException e) {
    // ignore
    }
}
------------------------
Find a silently evolved API code:android.telephony.ims.ImsCallSession.IImsCallSessionListenerProxy.callSessionMergeComplete:COMMENT
Method Modifier: public      
Comment:/**
 * Notifies the successful completion of a call merge operation.
 *
 * @param newSession The call session.
 */

Body of Frist Method:
{
    if (mListener != null) {
        if (newSession != null) {
            // Check if the active session is the same session that was
            // active before the merge request was sent.
            ImsCallSession validActiveSession = ImsCallSession.this;
            try {
                if (!Objects.equals(miSession.getCallId(), newSession.getCallId())) {
                    // New session created after conference
                    validActiveSession = new ImsCallSession(newSession);
                }
            } catch (RemoteException rex) {
                Log.e(TAG, "callSessionMergeComplete: exception for getCallId!");
            }
            mListener.callSessionMergeComplete(validActiveSession);
        } else {
            // Session already exists. Hence no need to pass
            mListener.callSessionMergeComplete(null);
        }
    }
}
Body of Second Method:
{
    if (mListener != null) {
        if (newSession != null) {
            // New session created after conference
            mListener.callSessionMergeComplete(new ImsCallSession(newSession));
        } else {
            // Session already exists. Hence no need to pass
            mListener.callSessionMergeComplete(null);
        }
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.rtt.ResponderConfig.fromScanResult:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Creates a Responder configuration from a {@link ScanResult} corresponding to an Access
 * Point (AP), which can be obtained from {@link android.net.wifi.WifiManager#getScanResults()}.
 */

Body of Frist Method:
{
    MacAddress macAddress = MacAddress.fromString(scanResult.BSSID);
    int responderType = RESPONDER_AP;
    boolean supports80211mc = scanResult.is80211mcResponder();
    int channelWidth = translateScanResultChannelWidth(scanResult.channelWidth);
    int frequency = scanResult.frequency;
    int centerFreq0 = scanResult.centerFreq0;
    int centerFreq1 = scanResult.centerFreq1;
    int preamble;
    if (scanResult.informationElements != null && scanResult.informationElements.length != 0) {
        boolean htCapabilitiesPresent = false;
        boolean vhtCapabilitiesPresent = false;
        for (ScanResult.InformationElement ie : scanResult.informationElements) {
            if (ie.id == EID_HT_CAPABILITIES) {
                htCapabilitiesPresent = true;
            } else if (ie.id == EID_VHT_CAPABILITIES) {
                vhtCapabilitiesPresent = true;
            }
        }
        if (vhtCapabilitiesPresent) {
            preamble = PREAMBLE_VHT;
        } else if (htCapabilitiesPresent) {
            preamble = PREAMBLE_HT;
        } else {
            preamble = PREAMBLE_LEGACY;
        }
    } else {
        Log.e(TAG, "Scan Results do not contain IEs - using backup method to select preamble");
        if (channelWidth == CHANNEL_WIDTH_80MHZ || channelWidth == CHANNEL_WIDTH_160MHZ) {
            preamble = PREAMBLE_VHT;
        } else {
            preamble = PREAMBLE_HT;
        }
    }
    return new ResponderConfig(macAddress, responderType, supports80211mc, channelWidth, frequency, centerFreq0, centerFreq1, preamble);
}
Body of Second Method:
{
    MacAddress macAddress = MacAddress.fromString(scanResult.BSSID);
    int responderType = RESPONDER_AP;
    boolean supports80211mc = scanResult.is80211mcResponder();
    int channelWidth = translateScanResultChannelWidth(scanResult.channelWidth);
    int frequency = scanResult.frequency;
    int centerFreq0 = scanResult.centerFreq0;
    int centerFreq1 = scanResult.centerFreq1;
    int preamble;
    if (scanResult.informationElements != null && scanResult.informationElements.length != 0) {
        boolean htCapabilitiesPresent = false;
        boolean vhtCapabilitiesPresent = false;
        boolean heCapabilitiesPresent = false;
        for (ScanResult.InformationElement ie : scanResult.informationElements) {
            if (ie.id == EID_HT_CAPABILITIES) {
                htCapabilitiesPresent = true;
            } else if (ie.id == EID_VHT_CAPABILITIES) {
                vhtCapabilitiesPresent = true;
            } else if (ie.id == EID_EXTENSION_PRESENT && ie.idExt == EID_EXT_HE_CAPABILITIES) {
                heCapabilitiesPresent = true;
            }
        }
        if (heCapabilitiesPresent) {
            preamble = PREAMBLE_HE;
        } else if (vhtCapabilitiesPresent) {
            preamble = PREAMBLE_VHT;
        } else if (htCapabilitiesPresent) {
            preamble = PREAMBLE_HT;
        } else {
            preamble = PREAMBLE_LEGACY;
        }
    } else {
        Log.e(TAG, "Scan Results do not contain IEs - using backup method to select preamble");
        if (channelWidth == CHANNEL_WIDTH_80MHZ || channelWidth == CHANNEL_WIDTH_160MHZ) {
            preamble = PREAMBLE_VHT;
        } else {
            preamble = PREAMBLE_HT;
        }
    }
    return new ResponderConfig(macAddress, responderType, supports80211mc, channelWidth, frequency, centerFreq0, centerFreq1, preamble);
}
------------------------
Find a silently evolved API code:android.util.Half.lessEquals:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns true if the first half-precision float value is less (smaller
 * toward negative infinity) than or equal to the second half-precision
 * float value. If either of the values is NaN, the result is false.
 *
 * @param x The first half-precision value
 * @param y The second half-precision value
 *
 * @return True if x is less than or equal to y, false otherwise
 */

Body of Frist Method:
{
    if ((x & FP16_COMBINED) > FP16_EXPONENT_MAX)
        return false;
    if ((y & FP16_COMBINED) > FP16_EXPONENT_MAX)
        return false;
    return ((x & FP16_SIGN_MASK) != 0 ? 0x8000 - (x & 0xffff) : x & 0xffff) <= ((y & FP16_SIGN_MASK) != 0 ? 0x8000 - (y & 0xffff) : y & 0xffff);
}
Body of Second Method:
{
    return FP16.lessEquals(x, y);
}
------------------------
Find a silently evolved API code:android.accessibilityservice.AccessibilityServiceInfo.flagToString:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns the string representation of a flag. For example,
 * {@link #DEFAULT} is represented by the string DEFAULT.
 *
 * @param flag The flag.
 * @return The string representation.
 */

Body of Frist Method:
{
    switch(flag) {
        case DEFAULT:
            return "DEFAULT";
        case FLAG_INCLUDE_NOT_IMPORTANT_VIEWS:
            return "FLAG_INCLUDE_NOT_IMPORTANT_VIEWS";
        case FLAG_REQUEST_TOUCH_EXPLORATION_MODE:
            return "FLAG_REQUEST_TOUCH_EXPLORATION_MODE";
        case FLAG_REQUEST_ENHANCED_WEB_ACCESSIBILITY:
            return "FLAG_REQUEST_ENHANCED_WEB_ACCESSIBILITY";
        case FLAG_REPORT_VIEW_IDS:
            return "FLAG_REPORT_VIEW_IDS";
        case FLAG_REQUEST_FILTER_KEY_EVENTS:
            return "FLAG_REQUEST_FILTER_KEY_EVENTS";
        case FLAG_RETRIEVE_INTERACTIVE_WINDOWS:
            return "FLAG_RETRIEVE_INTERACTIVE_WINDOWS";
        case FLAG_ENABLE_ACCESSIBILITY_VOLUME:
            return "FLAG_ENABLE_ACCESSIBILITY_VOLUME";
        case FLAG_REQUEST_ACCESSIBILITY_BUTTON:
            return "FLAG_REQUEST_ACCESSIBILITY_BUTTON";
        case FLAG_REQUEST_FINGERPRINT_GESTURES:
            return "FLAG_REQUEST_FINGERPRINT_GESTURES";
        case FLAG_REQUEST_SHORTCUT_WARNING_DIALOG_SPOKEN_FEEDBACK:
            return "FLAG_REQUEST_SHORTCUT_WARNING_DIALOG_SPOKEN_FEEDBACK";
        default:
            return null;
    }
}
Body of Second Method:
{
    switch(flag) {
        case DEFAULT:
            return "DEFAULT";
        case FLAG_INCLUDE_NOT_IMPORTANT_VIEWS:
            return "FLAG_INCLUDE_NOT_IMPORTANT_VIEWS";
        case FLAG_REQUEST_TOUCH_EXPLORATION_MODE:
            return "FLAG_REQUEST_TOUCH_EXPLORATION_MODE";
        case FLAG_SERVICE_HANDLES_DOUBLE_TAP:
            return "FLAG_SERVICE_HANDLES_DOUBLE_TAP";
        case FLAG_REQUEST_MULTI_FINGER_GESTURES:
            return "FLAG_REQUEST_MULTI_FINGER_GESTURES";
        case FLAG_REQUEST_ENHANCED_WEB_ACCESSIBILITY:
            return "FLAG_REQUEST_ENHANCED_WEB_ACCESSIBILITY";
        case FLAG_REPORT_VIEW_IDS:
            return "FLAG_REPORT_VIEW_IDS";
        case FLAG_REQUEST_FILTER_KEY_EVENTS:
            return "FLAG_REQUEST_FILTER_KEY_EVENTS";
        case FLAG_RETRIEVE_INTERACTIVE_WINDOWS:
            return "FLAG_RETRIEVE_INTERACTIVE_WINDOWS";
        case FLAG_ENABLE_ACCESSIBILITY_VOLUME:
            return "FLAG_ENABLE_ACCESSIBILITY_VOLUME";
        case FLAG_REQUEST_ACCESSIBILITY_BUTTON:
            return "FLAG_REQUEST_ACCESSIBILITY_BUTTON";
        case FLAG_REQUEST_FINGERPRINT_GESTURES:
            return "FLAG_REQUEST_FINGERPRINT_GESTURES";
        case FLAG_REQUEST_SHORTCUT_WARNING_DIALOG_SPOKEN_FEEDBACK:
            return "FLAG_REQUEST_SHORTCUT_WARNING_DIALOG_SPOKEN_FEEDBACK";
        default:
            return null;
    }
}
------------------------
Find a silently evolved API code:android.telephony.ims.ImsCallSessionListener.callSessionInitiatedFailed:COMMENT
Method Modifier: public      
Comment:/**
 * The IMS call session establishment has failed.
 *
 * @param reasonInfo {@link ImsReasonInfo} detailing the reason of the IMS call session
 * establishment failure.
 */

Body of Frist Method:
{
    try {
        mListener.callSessionInitiatedFailed(reasonInfo);
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}
Body of Second Method:
{
    try {
        mListener.callSessionInitiatedFailed(reasonInfo);
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.hardware.display.DisplayViewport.toString:COMMENT
Method Modifier: public      hidden      
Comment:// For debugging purposes.

Body of Frist Method:
{
    return "DisplayViewport{type=" + typeToString(type) + ", valid=" + valid + ", displayId=" + displayId + ", uniqueId='" + uniqueId + "'" + ", physicalPort=" + physicalPort + ", orientation=" + orientation + ", logicalFrame=" + logicalFrame + ", physicalFrame=" + physicalFrame + ", deviceWidth=" + deviceWidth + ", deviceHeight=" + deviceHeight + "}";
}
Body of Second Method:
{
    final Integer port = physicalPort == null ? null : Byte.toUnsignedInt(physicalPort);
    return "DisplayViewport{type=" + typeToString(type) + ", valid=" + valid + ", isActive=" + isActive + ", displayId=" + displayId + ", uniqueId='" + uniqueId + "'" + ", physicalPort=" + port + ", orientation=" + orientation + ", logicalFrame=" + logicalFrame + ", physicalFrame=" + physicalFrame + ", deviceWidth=" + deviceWidth + ", deviceHeight=" + deviceHeight + "}";
}
------------------------
Find a silently evolved API code:android.util.ArraySet.append:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Special fast path for appending items to the end of the array without validation.
 * The array must already be large enough to contain the item.
 * @hide
 */

Body of Frist Method:
{
    final int index = mSize;
    final int hash = value == null ? 0 : (mIdentityHashCode ? System.identityHashCode(value) : value.hashCode());
    if (index >= mHashes.length) {
        throw new IllegalStateException("Array is full");
    }
    if (index > 0 && mHashes[index - 1] > hash) {
        // Cannot optimize since it would break the sorted order - fallback to add()
        if (DEBUG) {
            RuntimeException e = new RuntimeException("here");
            e.fillInStackTrace();
            Log.w(TAG, "New hash " + hash + " is before end of array hash " + mHashes[index - 1] + " at index " + index, e);
        }
        add(value);
        return;
    }
    mSize = index + 1;
    mHashes[index] = hash;
    mArray[index] = value;
}
Body of Second Method:
{
    final int oSize = mSize;
    final int index = mSize;
    final int hash = value == null ? 0 : (mIdentityHashCode ? System.identityHashCode(value) : value.hashCode());
    if (index >= mHashes.length) {
        throw new IllegalStateException("Array is full");
    }
    if (index > 0 && mHashes[index - 1] > hash) {
        // Cannot optimize since it would break the sorted order - fallback to add()
        if (DEBUG) {
            RuntimeException e = new RuntimeException("here");
            e.fillInStackTrace();
            Log.w(TAG, "New hash " + hash + " is before end of array hash " + mHashes[index - 1] + " at index " + index, e);
        }
        add(value);
        return;
    }
    if (oSize != mSize) {
        throw new ConcurrentModificationException();
    }
    mSize = index + 1;
    mHashes[index] = hash;
    mArray[index] = value;
}
------------------------
Find a silently evolved API code:android.media.session.MediaController.TransportControls.fastForward:COMMENT
Method Modifier: public      
Comment:/**
 * Start fast forwarding. If playback is already fast forwarding this
 * may increase the rate.
 */

Body of Frist Method:
{
    try {
        mSessionBinder.fastForward(mContext.getPackageName(), mCbStub);
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling fastForward.", e);
    }
}
Body of Second Method:
{
    try {
        mSessionBinder.fastForward(mContext.getPackageName());
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling fastForward.", e);
    }
}
------------------------
Find a silently evolved API code:android.location.LocationRequest.setProvider:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets the provider to use for this location request.
 */

Body of Frist Method:
{
    checkProvider(provider);
    mProvider = provider;
    return this;
}
Body of Second Method:
{
    Preconditions.checkArgument(provider != null, "invalid provider: null");
    mProvider = provider;
    return this;
}
------------------------
Find a silently evolved API code:android.view.GestureDetector.onTouchEvent:COMMENT
Method Modifier: public      
Comment:/**
 * Analyzes the given motion event and if applicable triggers the
 * appropriate callbacks on the {@link OnGestureListener} supplied.
 *
 * @param ev The current motion event.
 * @return true if the {@link OnGestureListener} consumed the event,
 * else false.
 */

Body of Frist Method:
{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(ev, 0);
    }
    final int action = ev.getAction();
    if (mCurrentMotionEvent != null) {
        mCurrentMotionEvent.recycle();
    }
    mCurrentMotionEvent = MotionEvent.obtain(ev);
    if (mVelocityTracker == null) {
        mVelocityTracker = VelocityTracker.obtain();
    }
    mVelocityTracker.addMovement(ev);
    final boolean pointerUp = (action & MotionEvent.ACTION_MASK) == MotionEvent.ACTION_POINTER_UP;
    final int skipIndex = pointerUp ? ev.getActionIndex() : -1;
    final boolean isGeneratedGesture = (ev.getFlags() & MotionEvent.FLAG_IS_GENERATED_GESTURE) != 0;
    // Determine focal point
    float sumX = 0, sumY = 0;
    final int count = ev.getPointerCount();
    for (int i = 0; i < count; i++) {
        if (skipIndex == i)
            continue;
        sumX += ev.getX(i);
        sumY += ev.getY(i);
    }
    final int div = pointerUp ? count - 1 : count;
    final float focusX = sumX / div;
    final float focusY = sumY / div;
    boolean handled = false;
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_POINTER_DOWN:
            mDownFocusX = mLastFocusX = focusX;
            mDownFocusY = mLastFocusY = focusY;
            // Cancel long press and taps
            cancelTaps();
            break;
        case MotionEvent.ACTION_POINTER_UP:
            mDownFocusX = mLastFocusX = focusX;
            mDownFocusY = mLastFocusY = focusY;
            // Check the dot product of current velocities.
            // If the pointer that left was opposing another velocity vector, clear.
            mVelocityTracker.computeCurrentVelocity(1000, mMaximumFlingVelocity);
            final int upIndex = ev.getActionIndex();
            final int id1 = ev.getPointerId(upIndex);
            final float x1 = mVelocityTracker.getXVelocity(id1);
            final float y1 = mVelocityTracker.getYVelocity(id1);
            for (int i = 0; i < count; i++) {
                if (i == upIndex)
                    continue;
                final int id2 = ev.getPointerId(i);
                final float x = x1 * mVelocityTracker.getXVelocity(id2);
                final float y = y1 * mVelocityTracker.getYVelocity(id2);
                final float dot = x + y;
                if (dot < 0) {
                    mVelocityTracker.clear();
                    break;
                }
            }
            break;
        case MotionEvent.ACTION_DOWN:
            if (mDoubleTapListener != null) {
                boolean hadTapMessage = mHandler.hasMessages(TAP);
                if (hadTapMessage)
                    mHandler.removeMessages(TAP);
                if ((mCurrentDownEvent != null) && (mPreviousUpEvent != null) && hadTapMessage && isConsideredDoubleTap(mCurrentDownEvent, mPreviousUpEvent, ev)) {
                    // This is a second tap
                    mIsDoubleTapping = true;
                    recordGestureClassification(TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__DOUBLE_TAP);
                    // Give a callback with the first tap of the double-tap
                    handled |= mDoubleTapListener.onDoubleTap(mCurrentDownEvent);
                    // Give a callback with down event of the double-tap
                    handled |= mDoubleTapListener.onDoubleTapEvent(ev);
                } else {
                    // This is a first tap
                    mHandler.sendEmptyMessageDelayed(TAP, DOUBLE_TAP_TIMEOUT);
                }
            }
            mDownFocusX = mLastFocusX = focusX;
            mDownFocusY = mLastFocusY = focusY;
            if (mCurrentDownEvent != null) {
                mCurrentDownEvent.recycle();
            }
            mCurrentDownEvent = MotionEvent.obtain(ev);
            mAlwaysInTapRegion = true;
            mAlwaysInBiggerTapRegion = true;
            mStillDown = true;
            mInLongPress = false;
            mDeferConfirmSingleTap = false;
            mHasRecordedClassification = false;
            if (mIsLongpressEnabled) {
                mHandler.removeMessages(LONG_PRESS);
                mHandler.sendMessageAtTime(mHandler.obtainMessage(LONG_PRESS, TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__LONG_PRESS, 0), mCurrentDownEvent.getDownTime() + ViewConfiguration.getLongPressTimeout());
            }
            mHandler.sendEmptyMessageAtTime(SHOW_PRESS, mCurrentDownEvent.getDownTime() + TAP_TIMEOUT);
            handled |= mListener.onDown(ev);
            break;
        case MotionEvent.ACTION_MOVE:
            if (mInLongPress || mInContextClick) {
                break;
            }
            final int motionClassification = ev.getClassification();
            final boolean hasPendingLongPress = mHandler.hasMessages(LONG_PRESS);
            final float scrollX = mLastFocusX - focusX;
            final float scrollY = mLastFocusY - focusY;
            if (mIsDoubleTapping) {
                // Give the move events of the double-tap
                recordGestureClassification(TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__DOUBLE_TAP);
                handled |= mDoubleTapListener.onDoubleTapEvent(ev);
            } else if (mAlwaysInTapRegion) {
                final int deltaX = (int) (focusX - mDownFocusX);
                final int deltaY = (int) (focusY - mDownFocusY);
                int distance = (deltaX * deltaX) + (deltaY * deltaY);
                int slopSquare = isGeneratedGesture ? 0 : mTouchSlopSquare;
                final boolean ambiguousGesture = motionClassification == MotionEvent.CLASSIFICATION_AMBIGUOUS_GESTURE;
                final boolean shouldInhibitDefaultAction = hasPendingLongPress && ambiguousGesture;
                if (shouldInhibitDefaultAction) {
                    // Inhibit default long press
                    final float multiplier = ViewConfiguration.getAmbiguousGestureMultiplier();
                    if (distance > slopSquare) {
                        // The default action here is to remove long press. But if the touch
                        // slop below gets increased, and we never exceed the modified touch
                        // slop while still receiving AMBIGUOUS_GESTURE, we risk that *nothing*
                        // will happen in response to user input. To prevent this,
                        // reschedule long press with a modified timeout.
                        mHandler.removeMessages(LONG_PRESS);
                        final long longPressTimeout = ViewConfiguration.getLongPressTimeout();
                        mHandler.sendMessageAtTime(mHandler.obtainMessage(LONG_PRESS, TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__LONG_PRESS, 0), ev.getDownTime() + (long) (longPressTimeout * multiplier));
                    }
                    // Inhibit default scroll. If a gesture is ambiguous, we prevent scroll
                    // until the gesture is resolved.
                    // However, for safety, simply increase the touch slop in case the
                    // classification is erroneous. Since the value is squared, multiply twice.
                    slopSquare *= multiplier * multiplier;
                }
                if (distance > slopSquare) {
                    recordGestureClassification(TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__SCROLL);
                    handled = mListener.onScroll(mCurrentDownEvent, ev, scrollX, scrollY);
                    mLastFocusX = focusX;
                    mLastFocusY = focusY;
                    mAlwaysInTapRegion = false;
                    mHandler.removeMessages(TAP);
                    mHandler.removeMessages(SHOW_PRESS);
                    mHandler.removeMessages(LONG_PRESS);
                }
                int doubleTapSlopSquare = isGeneratedGesture ? 0 : mDoubleTapTouchSlopSquare;
                if (distance > doubleTapSlopSquare) {
                    mAlwaysInBiggerTapRegion = false;
                }
            } else if ((Math.abs(scrollX) >= 1) || (Math.abs(scrollY) >= 1)) {
                recordGestureClassification(TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__SCROLL);
                handled = mListener.onScroll(mCurrentDownEvent, ev, scrollX, scrollY);
                mLastFocusX = focusX;
                mLastFocusY = focusY;
            }
            final boolean deepPress = motionClassification == MotionEvent.CLASSIFICATION_DEEP_PRESS;
            if (deepPress && hasPendingLongPress) {
                mHandler.removeMessages(LONG_PRESS);
                mHandler.sendMessage(mHandler.obtainMessage(LONG_PRESS, TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__DEEP_PRESS, 0));
            }
            break;
        case MotionEvent.ACTION_UP:
            mStillDown = false;
            MotionEvent currentUpEvent = MotionEvent.obtain(ev);
            if (mIsDoubleTapping) {
                // Finally, give the up event of the double-tap
                recordGestureClassification(TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__DOUBLE_TAP);
                handled |= mDoubleTapListener.onDoubleTapEvent(ev);
            } else if (mInLongPress) {
                mHandler.removeMessages(TAP);
                mInLongPress = false;
            } else if (mAlwaysInTapRegion && !mIgnoreNextUpEvent) {
                recordGestureClassification(TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__SINGLE_TAP);
                handled = mListener.onSingleTapUp(ev);
                if (mDeferConfirmSingleTap && mDoubleTapListener != null) {
                    mDoubleTapListener.onSingleTapConfirmed(ev);
                }
            } else if (!mIgnoreNextUpEvent) {
                // A fling must travel the minimum tap distance
                final VelocityTracker velocityTracker = mVelocityTracker;
                final int pointerId = ev.getPointerId(0);
                velocityTracker.computeCurrentVelocity(1000, mMaximumFlingVelocity);
                final float velocityY = velocityTracker.getYVelocity(pointerId);
                final float velocityX = velocityTracker.getXVelocity(pointerId);
                if ((Math.abs(velocityY) > mMinimumFlingVelocity) || (Math.abs(velocityX) > mMinimumFlingVelocity)) {
                    handled = mListener.onFling(mCurrentDownEvent, ev, velocityX, velocityY);
                }
            }
            if (mPreviousUpEvent != null) {
                mPreviousUpEvent.recycle();
            }
            // Hold the event we obtained above - listeners may have changed the original.
            mPreviousUpEvent = currentUpEvent;
            if (mVelocityTracker != null) {
                // This may have been cleared when we called out to the
                // application above.
                mVelocityTracker.recycle();
                mVelocityTracker = null;
            }
            mIsDoubleTapping = false;
            mDeferConfirmSingleTap = false;
            mIgnoreNextUpEvent = false;
            mHandler.removeMessages(SHOW_PRESS);
            mHandler.removeMessages(LONG_PRESS);
            break;
        case MotionEvent.ACTION_CANCEL:
            cancel();
            break;
    }
    if (!handled && mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(ev, 0);
    }
    return handled;
}
Body of Second Method:
{
    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(ev, 0);
    }
    final int action = ev.getAction();
    if (mCurrentMotionEvent != null) {
        mCurrentMotionEvent.recycle();
    }
    mCurrentMotionEvent = MotionEvent.obtain(ev);
    if (mVelocityTracker == null) {
        mVelocityTracker = VelocityTracker.obtain();
    }
    mVelocityTracker.addMovement(ev);
    final boolean pointerUp = (action & MotionEvent.ACTION_MASK) == MotionEvent.ACTION_POINTER_UP;
    final int skipIndex = pointerUp ? ev.getActionIndex() : -1;
    final boolean isGeneratedGesture = (ev.getFlags() & MotionEvent.FLAG_IS_GENERATED_GESTURE) != 0;
    // Determine focal point
    float sumX = 0, sumY = 0;
    final int count = ev.getPointerCount();
    for (int i = 0; i < count; i++) {
        if (skipIndex == i)
            continue;
        sumX += ev.getX(i);
        sumY += ev.getY(i);
    }
    final int div = pointerUp ? count - 1 : count;
    final float focusX = sumX / div;
    final float focusY = sumY / div;
    boolean handled = false;
    switch(action & MotionEvent.ACTION_MASK) {
        case MotionEvent.ACTION_POINTER_DOWN:
            mDownFocusX = mLastFocusX = focusX;
            mDownFocusY = mLastFocusY = focusY;
            // Cancel long press and taps
            cancelTaps();
            break;
        case MotionEvent.ACTION_POINTER_UP:
            mDownFocusX = mLastFocusX = focusX;
            mDownFocusY = mLastFocusY = focusY;
            // Check the dot product of current velocities.
            // If the pointer that left was opposing another velocity vector, clear.
            mVelocityTracker.computeCurrentVelocity(1000, mMaximumFlingVelocity);
            final int upIndex = ev.getActionIndex();
            final int id1 = ev.getPointerId(upIndex);
            final float x1 = mVelocityTracker.getXVelocity(id1);
            final float y1 = mVelocityTracker.getYVelocity(id1);
            for (int i = 0; i < count; i++) {
                if (i == upIndex)
                    continue;
                final int id2 = ev.getPointerId(i);
                final float x = x1 * mVelocityTracker.getXVelocity(id2);
                final float y = y1 * mVelocityTracker.getYVelocity(id2);
                final float dot = x + y;
                if (dot < 0) {
                    mVelocityTracker.clear();
                    break;
                }
            }
            break;
        case MotionEvent.ACTION_DOWN:
            if (mDoubleTapListener != null) {
                boolean hadTapMessage = mHandler.hasMessages(TAP);
                if (hadTapMessage)
                    mHandler.removeMessages(TAP);
                if ((mCurrentDownEvent != null) && (mPreviousUpEvent != null) && hadTapMessage && isConsideredDoubleTap(mCurrentDownEvent, mPreviousUpEvent, ev)) {
                    // This is a second tap
                    mIsDoubleTapping = true;
                    recordGestureClassification(TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__DOUBLE_TAP);
                    // Give a callback with the first tap of the double-tap
                    handled |= mDoubleTapListener.onDoubleTap(mCurrentDownEvent);
                    // Give a callback with down event of the double-tap
                    handled |= mDoubleTapListener.onDoubleTapEvent(ev);
                } else {
                    // This is a first tap
                    mHandler.sendEmptyMessageDelayed(TAP, DOUBLE_TAP_TIMEOUT);
                }
            }
            mDownFocusX = mLastFocusX = focusX;
            mDownFocusY = mLastFocusY = focusY;
            if (mCurrentDownEvent != null) {
                mCurrentDownEvent.recycle();
            }
            mCurrentDownEvent = MotionEvent.obtain(ev);
            mAlwaysInTapRegion = true;
            mAlwaysInBiggerTapRegion = true;
            mStillDown = true;
            mInLongPress = false;
            mDeferConfirmSingleTap = false;
            mHasRecordedClassification = false;
            if (mIsLongpressEnabled) {
                mHandler.removeMessages(LONG_PRESS);
                mHandler.sendMessageAtTime(mHandler.obtainMessage(LONG_PRESS, TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__LONG_PRESS, 0), mCurrentDownEvent.getDownTime() + ViewConfiguration.getLongPressTimeout());
            }
            mHandler.sendEmptyMessageAtTime(SHOW_PRESS, mCurrentDownEvent.getDownTime() + TAP_TIMEOUT);
            handled |= mListener.onDown(ev);
            break;
        case MotionEvent.ACTION_MOVE:
            if (mInLongPress || mInContextClick) {
                break;
            }
            final int motionClassification = ev.getClassification();
            final boolean hasPendingLongPress = mHandler.hasMessages(LONG_PRESS);
            final float scrollX = mLastFocusX - focusX;
            final float scrollY = mLastFocusY - focusY;
            if (mIsDoubleTapping) {
                // Give the move events of the double-tap
                recordGestureClassification(TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__DOUBLE_TAP);
                handled |= mDoubleTapListener.onDoubleTapEvent(ev);
            } else if (mAlwaysInTapRegion) {
                final int deltaX = (int) (focusX - mDownFocusX);
                final int deltaY = (int) (focusY - mDownFocusY);
                int distance = (deltaX * deltaX) + (deltaY * deltaY);
                int slopSquare = isGeneratedGesture ? 0 : mTouchSlopSquare;
                final boolean ambiguousGesture = motionClassification == MotionEvent.CLASSIFICATION_AMBIGUOUS_GESTURE;
                final boolean shouldInhibitDefaultAction = hasPendingLongPress && ambiguousGesture;
                if (shouldInhibitDefaultAction) {
                    // Inhibit default long press
                    if (distance > slopSquare) {
                        // The default action here is to remove long press. But if the touch
                        // slop below gets increased, and we never exceed the modified touch
                        // slop while still receiving AMBIGUOUS_GESTURE, we risk that *nothing*
                        // will happen in response to user input. To prevent this,
                        // reschedule long press with a modified timeout.
                        mHandler.removeMessages(LONG_PRESS);
                        final long longPressTimeout = ViewConfiguration.getLongPressTimeout();
                        mHandler.sendMessageAtTime(mHandler.obtainMessage(LONG_PRESS, TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__LONG_PRESS, 0), ev.getDownTime() + (long) (longPressTimeout * mAmbiguousGestureMultiplier));
                    }
                    // Inhibit default scroll. If a gesture is ambiguous, we prevent scroll
                    // until the gesture is resolved.
                    // However, for safety, simply increase the touch slop in case the
                    // classification is erroneous. Since the value is squared, multiply twice.
                    slopSquare *= mAmbiguousGestureMultiplier * mAmbiguousGestureMultiplier;
                }
                if (distance > slopSquare) {
                    recordGestureClassification(TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__SCROLL);
                    handled = mListener.onScroll(mCurrentDownEvent, ev, scrollX, scrollY);
                    mLastFocusX = focusX;
                    mLastFocusY = focusY;
                    mAlwaysInTapRegion = false;
                    mHandler.removeMessages(TAP);
                    mHandler.removeMessages(SHOW_PRESS);
                    mHandler.removeMessages(LONG_PRESS);
                }
                int doubleTapSlopSquare = isGeneratedGesture ? 0 : mDoubleTapTouchSlopSquare;
                if (distance > doubleTapSlopSquare) {
                    mAlwaysInBiggerTapRegion = false;
                }
            } else if ((Math.abs(scrollX) >= 1) || (Math.abs(scrollY) >= 1)) {
                recordGestureClassification(TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__SCROLL);
                handled = mListener.onScroll(mCurrentDownEvent, ev, scrollX, scrollY);
                mLastFocusX = focusX;
                mLastFocusY = focusY;
            }
            final boolean deepPress = motionClassification == MotionEvent.CLASSIFICATION_DEEP_PRESS;
            if (deepPress && hasPendingLongPress) {
                mHandler.removeMessages(LONG_PRESS);
                mHandler.sendMessage(mHandler.obtainMessage(LONG_PRESS, TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__DEEP_PRESS, 0));
            }
            break;
        case MotionEvent.ACTION_UP:
            mStillDown = false;
            MotionEvent currentUpEvent = MotionEvent.obtain(ev);
            if (mIsDoubleTapping) {
                // Finally, give the up event of the double-tap
                recordGestureClassification(TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__DOUBLE_TAP);
                handled |= mDoubleTapListener.onDoubleTapEvent(ev);
            } else if (mInLongPress) {
                mHandler.removeMessages(TAP);
                mInLongPress = false;
            } else if (mAlwaysInTapRegion && !mIgnoreNextUpEvent) {
                recordGestureClassification(TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__SINGLE_TAP);
                handled = mListener.onSingleTapUp(ev);
                if (mDeferConfirmSingleTap && mDoubleTapListener != null) {
                    mDoubleTapListener.onSingleTapConfirmed(ev);
                }
            } else if (!mIgnoreNextUpEvent) {
                // A fling must travel the minimum tap distance
                final VelocityTracker velocityTracker = mVelocityTracker;
                final int pointerId = ev.getPointerId(0);
                velocityTracker.computeCurrentVelocity(1000, mMaximumFlingVelocity);
                final float velocityY = velocityTracker.getYVelocity(pointerId);
                final float velocityX = velocityTracker.getXVelocity(pointerId);
                if ((Math.abs(velocityY) > mMinimumFlingVelocity) || (Math.abs(velocityX) > mMinimumFlingVelocity)) {
                    handled = mListener.onFling(mCurrentDownEvent, ev, velocityX, velocityY);
                }
            }
            if (mPreviousUpEvent != null) {
                mPreviousUpEvent.recycle();
            }
            // Hold the event we obtained above - listeners may have changed the original.
            mPreviousUpEvent = currentUpEvent;
            if (mVelocityTracker != null) {
                // This may have been cleared when we called out to the
                // application above.
                mVelocityTracker.recycle();
                mVelocityTracker = null;
            }
            mIsDoubleTapping = false;
            mDeferConfirmSingleTap = false;
            mIgnoreNextUpEvent = false;
            mHandler.removeMessages(SHOW_PRESS);
            mHandler.removeMessages(LONG_PRESS);
            break;
        case MotionEvent.ACTION_CANCEL:
            cancel();
            break;
    }
    if (!handled && mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(ev, 0);
    }
    return handled;
}
------------------------
Find a silently evolved API code:android.content.ContentProviderClient.update:COMMENT
Method Modifier: public      
Comment:/**
 * See {@link ContentProvider#update ContentProvider.update}
 */

Body of Frist Method:
{
    Preconditions.checkNotNull(url, "url");
    beforeRemote();
    try {
        return mContentProvider.update(mPackageName, url, values, selection, selectionArgs);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}
Body of Second Method:
{
    Objects.requireNonNull(url, "url");
    beforeRemote();
    try {
        return mContentProvider.update(mPackageName, mAttributionTag, url, values, extras);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}
------------------------
Find a silently evolved API code:android.media.MediaMuxer.start:COMMENT
Method Modifier: public      
Comment:/**
 * Starts the muxer.
 * <p>Make sure this is called after {@link #addTrack} and before
 * {@link #writeSampleData}.</p>
 * @throws IllegalStateException If this method is called after {@link #start}
 * or Muxer is released
 */

Body of Frist Method:
{
    if (mNativeObject == 0) {
        throw new IllegalStateException("Muxer has been released!");
    }
    if (mState == MUXER_STATE_INITIALIZED) {
        nativeStart(mNativeObject);
        mState = MUXER_STATE_STARTED;
    } else {
        throw new IllegalStateException("Can't start due to wrong state.");
    }
}
Body of Second Method:
{
    if (mNativeObject == 0) {
        throw new IllegalStateException("Muxer has been released!");
    }
    if (mState == MUXER_STATE_INITIALIZED) {
        nativeStart(mNativeObject);
        mState = MUXER_STATE_STARTED;
    } else {
        throw new IllegalStateException("Can't start due to wrong state(" + convertMuxerStateCodeToString(mState) + ")");
    }
}
------------------------
Find a silently evolved API code:android.media.session.MediaController.sendCommand:COMMENT
Method Modifier: public      
Comment:/**
 * Sends a generic command to the session. It is up to the session creator
 * to decide what commands and parameters they will support. As such,
 * commands should only be sent to sessions that the controller owns.
 *
 * @param command The command to send
 * @param args Any parameters to include with the command
 * @param cb The callback to receive the result on
 */

Body of Frist Method:
{
    if (TextUtils.isEmpty(command)) {
        throw new IllegalArgumentException("command cannot be null or empty");
    }
    try {
        mSessionBinder.sendCommand(mContext.getPackageName(), mCbStub, command, args, cb);
    } catch (RemoteException e) {
        Log.d(TAG, "Dead object in sendCommand.", e);
    }
}
Body of Second Method:
{
    if (TextUtils.isEmpty(command)) {
        throw new IllegalArgumentException("command cannot be null or empty");
    }
    try {
        mSessionBinder.sendCommand(mContext.getPackageName(), command, args, cb);
    } catch (RemoteException e) {
        Log.d(TAG, "Dead object in sendCommand.", e);
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.aware.WifiAwareNetworkSpecifier.toString:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    StringBuilder sb = new StringBuilder("WifiAwareNetworkSpecifier [");
    sb.append("type=").append(type).append(", role=").append(role).append(", clientId=").append(clientId).append(", sessionId=").append(sessionId).append(", peerId=").append(peerId).append(", peerMac=").append((peerMac == null) ? "<null>" : "<non-null>").append(", pmk=").append((pmk == null) ? "<null>" : "<non-null>").append(", passphrase=").append((passphrase == null) ? "<null>" : "<non-null>").append(", port=").append(port).append(", transportProtocol=").append(transportProtocol).append(", requestorUid=").append(requestorUid).append("]");
    return sb.toString();
}
Body of Second Method:
{
    StringBuilder sb = new StringBuilder("WifiAwareNetworkSpecifier [");
    sb.append("type=").append(type).append(", role=").append(role).append(", clientId=").append(clientId).append(", sessionId=").append(sessionId).append(", peerId=").append(peerId).append(", peerMac=").append((peerMac == null) ? "<null>" : "<non-null>").append(", pmk=").append((pmk == null) ? "<null>" : "<non-null>").append(", passphrase=").append((passphrase == null) ? "<null>" : "<non-null>").append(", port=").append(port).append(", transportProtocol=").append(transportProtocol).append("]");
    return sb.toString();
}
------------------------
Find a silently evolved API code:android.telephony.ims.ImsCallSessionListener.callSessionHoldFailed:COMMENT
Method Modifier: public      
Comment:/**
 * The IMS call session has failed to be held.
 *
 * @param reasonInfo {@link ImsReasonInfo} detailing the reason of the session hold failure.
 */

Body of Frist Method:
{
    try {
        mListener.callSessionHoldFailed(reasonInfo);
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}
Body of Second Method:
{
    try {
        mListener.callSessionHoldFailed(reasonInfo);
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.telephony.AccessNetworkConstants.AccessNetworkType.toString:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    switch(type) {
        case UNKNOWN:
            return "UNKNOWN";
        case GERAN:
            return "GERAN";
        case UTRAN:
            return "UTRAN";
        case EUTRAN:
            return "EUTRAN";
        case CDMA2000:
            return "CDMA2000";
        case IWLAN:
            return "IWLAN";
        default:
            return Integer.toString(type);
    }
}
Body of Second Method:
{
    switch(type) {
        case UNKNOWN:
            return "UNKNOWN";
        case GERAN:
            return "GERAN";
        case UTRAN:
            return "UTRAN";
        case EUTRAN:
            return "EUTRAN";
        case CDMA2000:
            return "CDMA2000";
        case IWLAN:
            return "IWLAN";
        case NGRAN:
            return "NGRAN";
        default:
            return Integer.toString(type);
    }
}
------------------------
Find a silently evolved API code:android.location.GnssMeasurement.resetCarrierPhaseUncertainty:COMMENT
Method Modifier: public      hidden      deprecated  
Comment:/**
 * Resets the Carrier-phase's uncertainty (1-Sigma) in cycles.
 *
 * @deprecated use {@link #setAccumulatedDeltaRangeUncertaintyMeters(double)}
 * and {@link #setAccumulatedDeltaRangeState(int)} instead.
 *
 * @hide
 */

Body of Frist Method:
{
    resetFlag(HAS_CARRIER_PHASE_UNCERTAINTY);
    mCarrierPhaseUncertainty = Double.NaN;
}
Body of Second Method:
{
    resetFlag(HAS_CARRIER_PHASE_UNCERTAINTY);
}
------------------------
Find a silently evolved API code:android.util.Half.toHalf:COMMENT
Method Modifier: public      static      
Comment:/**
 * <p>Converts the specified single-precision float value into a
 * half-precision float value. The following special cases are handled:</p>
 * <ul>
 * <li>If the input is NaN (see {@link Float#isNaN(float)}), the returned
 * value is {@link #NaN}</li>
 * <li>If the input is {@link Float#POSITIVE_INFINITY} or
 * {@link Float#NEGATIVE_INFINITY}, the returned value is respectively
 * {@link #POSITIVE_INFINITY} or {@link #NEGATIVE_INFINITY}</li>
 * <li>If the input is 0 (positive or negative), the returned value is
 * {@link #POSITIVE_ZERO} or {@link #NEGATIVE_ZERO}</li>
 * <li>If the input is a less than {@link #MIN_VALUE}, the returned value
 * is flushed to {@link #POSITIVE_ZERO} or {@link #NEGATIVE_ZERO}</li>
 * <li>If the input is a less than {@link #MIN_NORMAL}, the returned value
 * is a denorm half-precision float</li>
 * <li>Otherwise, the returned value is rounded to the nearest
 * representable half-precision float value</li>
 * </ul>
 *
 * @param f The single-precision float value to convert to half-precision
 * @return A half-precision float value
 */

Body of Frist Method:
{
    int bits = Float.floatToRawIntBits(f);
    int s = (bits >>> FP32_SIGN_SHIFT);
    int e = (bits >>> FP32_EXPONENT_SHIFT) & FP32_EXPONENT_MASK;
    int m = (bits) & FP32_SIGNIFICAND_MASK;
    int outE = 0;
    int outM = 0;
    if (e == 0xff) {
        // Infinite or NaN
        outE = 0x1f;
        outM = m != 0 ? 0x200 : 0;
    } else {
        e = e - FP32_EXPONENT_BIAS + FP16_EXPONENT_BIAS;
        if (e >= 0x1f) {
            // Overflow
            outE = 0x31;
        } else if (e <= 0) {
            // Underflow
            if (e < -10) {
            // The absolute fp32 value is less than MIN_VALUE, flush to +/-0
            } else {
                // The fp32 value is a normalized float less than MIN_NORMAL,
                // we convert to a denorm fp16
                m = (m | 0x800000) >> (1 - e);
                if ((m & 0x1000) != 0)
                    m += 0x2000;
                outM = m >> 13;
            }
        } else {
            outE = e;
            outM = m >> 13;
            if ((m & 0x1000) != 0) {
                // Round to nearest "0.5" up
                int out = (outE << FP16_EXPONENT_SHIFT) | outM;
                out++;
                return (short) (out | (s << FP16_SIGN_SHIFT));
            }
        }
    }
    return (short) ((s << FP16_SIGN_SHIFT) | (outE << FP16_EXPONENT_SHIFT) | outM);
}
Body of Second Method:
{
    return FP16.toHalf(f);
}
------------------------
Find a silently evolved API code:android.media.AudioFormat.isEncodingLinearPcm:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    switch(audioFormat) {
        case ENCODING_PCM_16BIT:
        case ENCODING_PCM_8BIT:
        case ENCODING_PCM_FLOAT:
        case ENCODING_DEFAULT:
            return true;
        case ENCODING_AC3:
        case ENCODING_E_AC3:
        case ENCODING_DTS:
        case ENCODING_DTS_HD:
        case ENCODING_MP3:
        case ENCODING_AAC_LC:
        case ENCODING_AAC_HE_V1:
        case ENCODING_AAC_HE_V2:
        // wrapped in PCM but compressed
        case ENCODING_IEC61937:
        case ENCODING_DOLBY_TRUEHD:
        case ENCODING_AAC_ELD:
        case ENCODING_AAC_XHE:
        case ENCODING_AC4:
        case ENCODING_E_AC3_JOC:
        case ENCODING_DOLBY_MAT:
            return false;
        case ENCODING_INVALID:
        default:
            throw new IllegalArgumentException("Bad audio format " + audioFormat);
    }
}
Body of Second Method:
{
    switch(audioFormat) {
        case ENCODING_PCM_16BIT:
        case ENCODING_PCM_8BIT:
        case ENCODING_PCM_FLOAT:
        case ENCODING_DEFAULT:
            return true;
        case ENCODING_AC3:
        case ENCODING_E_AC3:
        case ENCODING_DTS:
        case ENCODING_DTS_HD:
        case ENCODING_MP3:
        case ENCODING_AAC_LC:
        case ENCODING_AAC_HE_V1:
        case ENCODING_AAC_HE_V2:
        // wrapped in PCM but compressed
        case ENCODING_IEC61937:
        case ENCODING_DOLBY_TRUEHD:
        case ENCODING_AAC_ELD:
        case ENCODING_AAC_XHE:
        case ENCODING_AC4:
        case ENCODING_E_AC3_JOC:
        case ENCODING_DOLBY_MAT:
        case ENCODING_OPUS:
            return false;
        case ENCODING_INVALID:
        default:
            throw new IllegalArgumentException("Bad audio format " + audioFormat);
    }
}
------------------------
Find a silently evolved API code:android.view.textclassifier.TextClassificationSession.SelectionEventHelper.sanitizeEvent:COMMENT
Method Modifier: default     
Comment:/**
 * Updates the necessary fields in the event for the current session.
 *
 * @return true if the event should be reported. false if the event should be ignored
 */

Body of Frist Method:
{
    updateInvocationMethod(event);
    modifyAutoSelectionEventType(event);
    if (event.getEventType() != SelectionEvent.EVENT_SELECTION_STARTED && mStartEvent == null) {
        Log.d(LOG_TAG, "Selection session not yet started. Ignoring event");
        return false;
    }
    final long now = System.currentTimeMillis();
    switch(event.getEventType()) {
        case SelectionEvent.EVENT_SELECTION_STARTED:
            Preconditions.checkArgument(event.getAbsoluteEnd() == event.getAbsoluteStart() + 1);
            event.setSessionId(mSessionId);
            mStartEvent = event;
            break;
        // fall through
        case SelectionEvent.EVENT_SMART_SELECTION_SINGLE:
        // fall through
        case SelectionEvent.EVENT_SMART_SELECTION_MULTI:
        case SelectionEvent.EVENT_AUTO_SELECTION:
            mSmartEvent = event;
            break;
        case SelectionEvent.EVENT_SELECTION_MODIFIED:
            if (mPrevEvent != null && mPrevEvent.getAbsoluteStart() == event.getAbsoluteStart() && mPrevEvent.getAbsoluteEnd() == event.getAbsoluteEnd()) {
                // Selection did not change. Ignore event.
                return false;
            }
            break;
        default:
    }
    event.setEventTime(now);
    if (mStartEvent != null) {
        event.setSessionId(mStartEvent.getSessionId()).setDurationSinceSessionStart(now - mStartEvent.getEventTime()).setStart(event.getAbsoluteStart() - mStartEvent.getAbsoluteStart()).setEnd(event.getAbsoluteEnd() - mStartEvent.getAbsoluteStart());
    }
    if (mSmartEvent != null) {
        event.setResultId(mSmartEvent.getResultId()).setSmartStart(mSmartEvent.getAbsoluteStart() - mStartEvent.getAbsoluteStart()).setSmartEnd(mSmartEvent.getAbsoluteEnd() - mStartEvent.getAbsoluteStart());
    }
    if (mPrevEvent != null) {
        event.setDurationSincePreviousEvent(now - mPrevEvent.getEventTime()).setEventIndex(mPrevEvent.getEventIndex() + 1);
    }
    mPrevEvent = event;
    return true;
}
Body of Second Method:
{
    updateInvocationMethod(event);
    modifyAutoSelectionEventType(event);
    if (event.getEventType() != SelectionEvent.EVENT_SELECTION_STARTED && mStartEvent == null) {
        Log.d(LOG_TAG, "Selection session not yet started. Ignoring event");
        return false;
    }
    final long now = System.currentTimeMillis();
    switch(event.getEventType()) {
        case SelectionEvent.EVENT_SELECTION_STARTED:
            Preconditions.checkArgument(event.getAbsoluteEnd() == event.getAbsoluteStart() + 1);
            event.setSessionId(mSessionId);
            mStartEvent = event;
            break;
        // fall through
        case SelectionEvent.EVENT_SMART_SELECTION_SINGLE:
        // fall through
        case SelectionEvent.EVENT_SMART_SELECTION_MULTI:
        case SelectionEvent.EVENT_AUTO_SELECTION:
            mSmartEvent = event;
            break;
        case SelectionEvent.ACTION_ABANDON:
        case SelectionEvent.ACTION_OVERTYPE:
            if (mPrevEvent != null) {
                event.setEntityType(mPrevEvent.getEntityType());
            }
            break;
        case SelectionEvent.EVENT_SELECTION_MODIFIED:
            if (mPrevEvent != null && mPrevEvent.getAbsoluteStart() == event.getAbsoluteStart() && mPrevEvent.getAbsoluteEnd() == event.getAbsoluteEnd()) {
                // Selection did not change. Ignore event.
                return false;
            }
            break;
        default:
    }
    event.setEventTime(now);
    if (mStartEvent != null) {
        event.setSessionId(mStartEvent.getSessionId()).setDurationSinceSessionStart(now - mStartEvent.getEventTime()).setStart(event.getAbsoluteStart() - mStartEvent.getAbsoluteStart()).setEnd(event.getAbsoluteEnd() - mStartEvent.getAbsoluteStart());
    }
    if (mSmartEvent != null) {
        event.setResultId(mSmartEvent.getResultId()).setSmartStart(mSmartEvent.getAbsoluteStart() - mStartEvent.getAbsoluteStart()).setSmartEnd(mSmartEvent.getAbsoluteEnd() - mStartEvent.getAbsoluteStart());
    }
    if (mPrevEvent != null) {
        event.setDurationSincePreviousEvent(now - mPrevEvent.getEventTime()).setEventIndex(mPrevEvent.getEventIndex() + 1);
    }
    mPrevEvent = event;
    return true;
}
------------------------
Find a silently evolved API code:android.content.ContentProviderClient.bulkInsert:COMMENT
Method Modifier: public      
Comment:/**
 * See {@link ContentProvider#bulkInsert ContentProvider.bulkInsert}
 */

Body of Frist Method:
{
    Preconditions.checkNotNull(url, "url");
    Preconditions.checkNotNull(initialValues, "initialValues");
    beforeRemote();
    try {
        return mContentProvider.bulkInsert(mPackageName, url, initialValues);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}
Body of Second Method:
{
    Objects.requireNonNull(url, "url");
    Objects.requireNonNull(initialValues, "initialValues");
    beforeRemote();
    try {
        return mContentProvider.bulkInsert(mPackageName, mAttributionTag, url, initialValues);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}
------------------------
Find a silently evolved API code:android.util.Half.getSign:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns the sign of the specified half-precision float.
 *
 * @param h A half-precision float value
 * @return 1 if the value is positive, -1 if the value is negative
 */

Body of Frist Method:
{
    return (h & FP16_SIGN_MASK) == 0 ? 1 : -1;
}
Body of Second Method:
{
    return (h & FP16.SIGN_MASK) == 0 ? 1 : -1;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothA2dp.disableOptionalCodecs:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Disables the optional codecs.
 *
 * @param device the remote Bluetooth device. If null, use the currect
 * active A2DP Bluetooth device.
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        Log.d(TAG, "disableOptionalCodecs(" + device + ")");
    enableDisableOptionalCodecs(device, false);
}
Body of Second Method:
{
    if (DBG)
        Log.d(TAG, "disableOptionalCodecs(" + device + ")");
    verifyDeviceNotNull(device, "disableOptionalCodecs");
    enableDisableOptionalCodecs(device, false);
}
------------------------
Find a silently evolved API code:android.util.Half.less:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns true if the first half-precision float value is less (smaller
 * toward negative infinity) than the second half-precision float value.
 * If either of the values is NaN, the result is false.
 *
 * @param x The first half-precision value
 * @param y The second half-precision value
 *
 * @return True if x is less than y, false otherwise
 */

Body of Frist Method:
{
    if ((x & FP16_COMBINED) > FP16_EXPONENT_MAX)
        return false;
    if ((y & FP16_COMBINED) > FP16_EXPONENT_MAX)
        return false;
    return ((x & FP16_SIGN_MASK) != 0 ? 0x8000 - (x & 0xffff) : x & 0xffff) < ((y & FP16_SIGN_MASK) != 0 ? 0x8000 - (y & 0xffff) : y & 0xffff);
}
Body of Second Method:
{
    return FP16.less(x, y);
}
------------------------
Find a silently evolved API code:android.view.animation.AnticipateInterpolator.createNativeInterpolator:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return NativeInterpolatorFactoryHelper.createAnticipateInterpolator(mTension);
}
Body of Second Method:
{
    return NativeInterpolatorFactory.createAnticipateInterpolator(mTension);
}
------------------------
Find a silently evolved API code:android.view.inputmethod.EditorInfo.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Used to package this object into a {@link Parcel}.
 *
 * @param dest The {@link Parcel} to be written.
 * @param flags The flags used for parceling.
 */

Body of Frist Method:
{
    dest.writeInt(inputType);
    dest.writeInt(imeOptions);
    dest.writeString(privateImeOptions);
    TextUtils.writeToParcel(actionLabel, dest, flags);
    dest.writeInt(actionId);
    dest.writeInt(initialSelStart);
    dest.writeInt(initialSelEnd);
    dest.writeInt(initialCapsMode);
    TextUtils.writeToParcel(hintText, dest, flags);
    TextUtils.writeToParcel(label, dest, flags);
    dest.writeString(packageName);
    dest.writeInt(fieldId);
    dest.writeString(fieldName);
    dest.writeBundle(extras);
    if (hintLocales != null) {
        hintLocales.writeToParcel(dest, flags);
    } else {
        LocaleList.getEmptyLocaleList().writeToParcel(dest, flags);
    }
    dest.writeStringArray(contentMimeTypes);
    UserHandle.writeToParcel(targetInputMethodUser, dest);
}
Body of Second Method:
{
    dest.writeInt(inputType);
    dest.writeInt(imeOptions);
    dest.writeString(privateImeOptions);
    TextUtils.writeToParcel(actionLabel, dest, flags);
    dest.writeInt(actionId);
    dest.writeInt(initialSelStart);
    dest.writeInt(initialSelEnd);
    dest.writeInt(initialCapsMode);
    TextUtils.writeToParcel(hintText, dest, flags);
    TextUtils.writeToParcel(label, dest, flags);
    dest.writeString(packageName);
    dest.writeParcelable(autofillId, flags);
    dest.writeInt(fieldId);
    dest.writeString(fieldName);
    dest.writeBundle(extras);
    mInitialSurroundingText.writeToParcel(dest, flags);
    if (hintLocales != null) {
        hintLocales.writeToParcel(dest, flags);
    } else {
        LocaleList.getEmptyLocaleList().writeToParcel(dest, flags);
    }
    dest.writeStringArray(contentMimeTypes);
    UserHandle.writeToParcel(targetInputMethodUser, dest);
}
------------------------
Find a silently evolved API code:android.hardware.usb.UsbDevice.Builder.build:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Create a new {@link UsbDevice}
 *
 * @param serialReader The method to read the serial number.
 *
 * @return The usb device
 */

Body of Frist Method:
{
    return new UsbDevice(mName, mVendorId, mProductId, mClass, mSubclass, mProtocol, mManufacturerName, mProductName, mVersion, mConfigurations, serialReader);
}
Body of Second Method:
{
    return new UsbDevice(mName, mVendorId, mProductId, mClass, mSubclass, mProtocol, mManufacturerName, mProductName, mVersion, mConfigurations, serialReader, mHasAudioPlayback, mHasAudioCapture, mHasMidi, mHasVideoPlayback, mHasVideoCapture);
}
------------------------
Find a silently evolved API code:android.telephony.ims.ImsCallSessionListener.callSessionSuppServiceReceived:COMMENT
Method Modifier: public      
Comment:/**
 * Supplementary service information has been received for the current IMS call session.
 *
 * @param suppSrvNotification The {@link ImsSuppServiceNotification} containing the change.
 */

Body of Frist Method:
{
    try {
        mListener.callSessionSuppServiceReceived(suppSrvNotification);
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}
Body of Second Method:
{
    try {
        mListener.callSessionSuppServiceReceived(suppSrvNotification);
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.widget.ScrollView.onInitializeAccessibilityEventInternal:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    super.onInitializeAccessibilityEventInternal(event);
    final boolean scrollable = getScrollRange() > 0;
    event.setScrollable(scrollable);
    event.setScrollX(mScrollX);
    event.setScrollY(mScrollY);
    event.setMaxScrollX(mScrollX);
    event.setMaxScrollY(getScrollRange());
}
Body of Second Method:
{
    super.onInitializeAccessibilityEventInternal(event);
    final boolean scrollable = getScrollRange() > 0;
    event.setScrollable(scrollable);
    event.setMaxScrollX(mScrollX);
    event.setMaxScrollY(getScrollRange());
}
------------------------
Find a silently evolved API code:android.net.wifi.ScanResult.writeToParcel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Implement the Parcelable interface {@hide}
 */

Body of Frist Method:
{
    if (wifiSsid != null) {
        dest.writeInt(1);
        wifiSsid.writeToParcel(dest, flags);
    } else {
        dest.writeInt(0);
    }
    dest.writeString(SSID);
    dest.writeString(BSSID);
    dest.writeLong(hessid);
    dest.writeInt(anqpDomainId);
    dest.writeString(capabilities);
    dest.writeInt(level);
    dest.writeInt(frequency);
    dest.writeLong(timestamp);
    dest.writeInt(distanceCm);
    dest.writeInt(distanceSdCm);
    dest.writeInt(channelWidth);
    dest.writeInt(centerFreq0);
    dest.writeInt(centerFreq1);
    dest.writeLong(seen);
    dest.writeInt(untrusted ? 1 : 0);
    dest.writeInt(numUsage);
    dest.writeString((venueName != null) ? venueName.toString() : "");
    dest.writeString((operatorFriendlyName != null) ? operatorFriendlyName.toString() : "");
    dest.writeLong(this.flags);
    if (informationElements != null) {
        dest.writeInt(informationElements.length);
        for (int i = 0; i < informationElements.length; i++) {
            dest.writeInt(informationElements[i].id);
            dest.writeInt(informationElements[i].bytes.length);
            dest.writeByteArray(informationElements[i].bytes);
        }
    } else {
        dest.writeInt(0);
    }
    if (anqpLines != null) {
        dest.writeInt(anqpLines.size());
        for (int i = 0; i < anqpLines.size(); i++) {
            dest.writeString(anqpLines.get(i));
        }
    } else {
        dest.writeInt(0);
    }
    if (anqpElements != null) {
        dest.writeInt(anqpElements.length);
        for (AnqpInformationElement element : anqpElements) {
            dest.writeInt(element.getVendorId());
            dest.writeInt(element.getElementId());
            dest.writeInt(element.getPayload().length);
            dest.writeByteArray(element.getPayload());
        }
    } else {
        dest.writeInt(0);
    }
    dest.writeInt(isCarrierAp ? 1 : 0);
    dest.writeInt(carrierApEapType);
    dest.writeString(carrierName);
    if (radioChainInfos != null) {
        dest.writeInt(radioChainInfos.length);
        for (int i = 0; i < radioChainInfos.length; i++) {
            dest.writeInt(radioChainInfos[i].id);
            dest.writeInt(radioChainInfos[i].level);
        }
    } else {
        dest.writeInt(0);
    }
}
Body of Second Method:
{
    if (wifiSsid != null) {
        dest.writeInt(1);
        wifiSsid.writeToParcel(dest, flags);
    } else {
        dest.writeInt(0);
    }
    dest.writeString(SSID);
    dest.writeString(BSSID);
    dest.writeLong(hessid);
    dest.writeInt(anqpDomainId);
    dest.writeString(capabilities);
    dest.writeInt(level);
    dest.writeInt(frequency);
    dest.writeLong(timestamp);
    dest.writeInt(distanceCm);
    dest.writeInt(distanceSdCm);
    dest.writeInt(channelWidth);
    dest.writeInt(centerFreq0);
    dest.writeInt(centerFreq1);
    dest.writeInt(mWifiStandard);
    dest.writeLong(seen);
    dest.writeInt(untrusted ? 1 : 0);
    dest.writeInt(numUsage);
    dest.writeString((venueName != null) ? venueName.toString() : "");
    dest.writeString((operatorFriendlyName != null) ? operatorFriendlyName.toString() : "");
    dest.writeLong(this.flags);
    if (informationElements != null) {
        dest.writeInt(informationElements.length);
        for (int i = 0; i < informationElements.length; i++) {
            dest.writeInt(informationElements[i].id);
            dest.writeInt(informationElements[i].idExt);
            dest.writeInt(informationElements[i].bytes.length);
            dest.writeByteArray(informationElements[i].bytes);
        }
    } else {
        dest.writeInt(0);
    }
    if (anqpLines != null) {
        dest.writeInt(anqpLines.size());
        for (int i = 0; i < anqpLines.size(); i++) {
            dest.writeString(anqpLines.get(i));
        }
    } else {
        dest.writeInt(0);
    }
    if (anqpElements != null) {
        dest.writeInt(anqpElements.length);
        for (AnqpInformationElement element : anqpElements) {
            dest.writeInt(element.getVendorId());
            dest.writeInt(element.getElementId());
            dest.writeInt(element.getPayload().length);
            dest.writeByteArray(element.getPayload());
        }
    } else {
        dest.writeInt(0);
    }
    if (radioChainInfos != null) {
        dest.writeInt(radioChainInfos.length);
        for (int i = 0; i < radioChainInfos.length; i++) {
            dest.writeInt(radioChainInfos[i].id);
            dest.writeInt(radioChainInfos[i].level);
        }
    } else {
        dest.writeInt(0);
    }
}
------------------------
Find a silently evolved API code:android.location.LocationRequest.setInterval:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Set the desired interval for active location updates, in milliseconds.
 *
 * <p>The location manager will actively try to obtain location updates
 * for your application at this interval, so it has a
 * direct influence on the amount of power used by your application.
 * Choose your interval wisely.
 *
 * <p>This interval is inexact. You may not receive updates at all (if
 * no location sources are available), or you may receive them
 * slower than requested. You may also receive them faster than
 * requested (if other applications are requesting location at a
 * faster interval). The fastest rate that you will receive
 * updates can be controlled with {@link #setFastestInterval}.
 *
 * <p>Applications with only the coarse location permission may have their
 * interval silently throttled.
 *
 * <p>An interval of 0 is allowed, but not recommended, since
 * location updates may be extremely fast on future implementations.
 *
 * <p>{@link #setQuality} and {@link #setInterval} are the most important parameters
 * on a location request.
 *
 * @param millis desired interval in millisecond, inexact
 * @return the same object, so that setters can be chained
 * @throws IllegalArgumentException if the interval is less than zero
 */

Body of Frist Method:
{
    checkInterval(millis);
    mInterval = millis;
    if (!mExplicitFastestInterval) {
        mFastestInterval = (long) (mInterval / FASTEST_INTERVAL_FACTOR);
    }
    return this;
}
Body of Second Method:
{
    Preconditions.checkArgument(millis >= 0, "invalid interval: + millis");
    mInterval = millis;
    if (!mExplicitFastestInterval) {
        mFastestInterval = (long) (mInterval / FASTEST_INTERVAL_FACTOR);
    }
    return this;
}
------------------------
Find a silently evolved API code:android.webkit.MimeTypeMap.getMimeTypeFromExtension:COMMENT
Method Modifier: public      
Comment:/**
 * Return the MIME type for the given extension.
 * @param extension A file extension without the leading '.'
 * @return The MIME type for the given extension or {@code null} if there is none.
 */

Body of Frist Method:
{
    return MimeUtils.guessMimeTypeFromExtension(extension);
}
Body of Second Method:
{
    return MimeMap.getDefault().guessMimeTypeFromExtension(extension);
}
------------------------
Find a silently evolved API code:android.net.LinkAddress.hashCode:COMMENT
Method Modifier: public      
Comment:/**
 * Returns a hashcode for this address.
 */

Body of Frist Method:
{
    return address.hashCode() + 11 * prefixLength + 19 * flags + 43 * scope;
}
Body of Second Method:
{
    return Objects.hash(address, prefixLength, flags, scope, deprecationTime, expirationTime);
}
------------------------
Find a silently evolved API code:android.text.Emoji.isEmojiModifierBase:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Returns true if the given code point is emoji modifier base.
 * @param c codepoint to check
 * @return true if is emoji modifier base
 */

Body of Frist Method:
{
    // that treats these as potential emoji bases.
    if (c == 0x1F91D || c == 0x1F93C) {
        return true;
    }
    // TODO: Remove once emoji-data.text 11 is in ICU or update to 11.
    if ((0x1F9B5 <= c && c <= 0x1F9B6) || (0x1F9B8 <= c && c <= 0x1F9B9)) {
        return true;
    }
    return UCharacter.hasBinaryProperty(c, UProperty.EMOJI_MODIFIER_BASE);
}
Body of Second Method:
{
    // that treats these as potential emoji bases.
    if (c == 0x1F91D || c == 0x1F93C) {
        return true;
    }
    // Consult log for implementation pattern.
    return UCharacter.hasBinaryProperty(c, UProperty.EMOJI_MODIFIER_BASE);
}
------------------------
Find a silently evolved API code:android.graphics.RenderNode.computeApproximateMemoryUsage:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the approximate memory usage of the RenderNode for debug purposes. Does not include
 * the memory usage of any child RenderNodes nor any bitmaps, only the memory usage of
 * this RenderNode and any data it owns.
 *
 * @return Approximate memory usage in bytes.
 */

Body of Frist Method:
{
    return nGetDebugSize(mNativeRenderNode);
}
Body of Second Method:
{
    return nGetUsageSize(mNativeRenderNode);
}
------------------------
Find a silently evolved API code:android.content.ContentProviderClient.openFile:COMMENT
Method Modifier: public      
Comment:/**
 * See {@link ContentProvider#openFile ContentProvider.openFile}.  Note that
 * this <em>does not</em>
 * take care of non-content: URIs such as file:.  It is strongly recommended
 * you use the {@link ContentResolver#openFileDescriptor
 * ContentResolver.openFileDescriptor} API instead.
 */

Body of Frist Method:
{
    return openFile(url, mode, null);
}
Body of Second Method:
{
    Objects.requireNonNull(url, "url");
    Objects.requireNonNull(mode, "mode");
    beforeRemote();
    try {
        ICancellationSignal remoteSignal = null;
        if (signal != null) {
            signal.throwIfCanceled();
            remoteSignal = mContentProvider.createCancellationSignal();
            signal.setRemote(remoteSignal);
        }
        return mContentProvider.openFile(mPackageName, mAttributionTag, url, mode, remoteSignal, null);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}
------------------------
Find a silently evolved API code:android.util.Half.floor:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns the largest half-precision float value toward positive infinity
 * less than or equal to the specified half-precision float value.
 * Special values are handled in the following ways:
 * <ul>
 * <li>If the specified half-precision float is NaN, the result is NaN</li>
 * <li>If the specified half-precision float is infinity (negative or positive),
 * the result is infinity (with the same sign)</li>
 * <li>If the specified half-precision float is zero (negative or positive),
 * the result is zero (with the same sign)</li>
 * </ul>
 *
 * @param h A half-precision float value
 * @return The largest half-precision float value toward positive infinity
 * less than or equal to the specified half-precision float value
 */

Body of Frist Method:
{
    int bits = h & 0xffff;
    int e = bits & 0x7fff;
    int result = bits;
    if (e < 0x3c00) {
        result &= FP16_SIGN_MASK;
        result |= 0x3c00 & (bits > 0x8000 ? 0xffff : 0x0);
    } else if (e < 0x6400) {
        e = 25 - (e >> 10);
        int mask = (1 << e) - 1;
        result += mask & -(bits >> 15);
        result &= ~mask;
    }
    return (short) result;
}
Body of Second Method:
{
    return FP16.floor(h);
}
------------------------
Find a silently evolved API code:android.app.servertransaction.TransactionExecutorHelper.getLifecycleRequestForCurrentState:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Get the lifecycle state request to match the current state in the end of a transaction.
 */

Body of Frist Method:
{
    final int prevState = r.getLifecycleState();
    final ActivityLifecycleItem lifecycleItem;
    switch(prevState) {
        // TODO(lifecycler): Extend to support all possible states.
        case ON_PAUSE:
            lifecycleItem = PauseActivityItem.obtain();
            break;
        case ON_STOP:
            lifecycleItem = StopActivityItem.obtain(r.isVisibleFromServer(), 0);
            break;
        default:
            lifecycleItem = ResumeActivityItem.obtain(false);
            break;
    }
    return lifecycleItem;
}
Body of Second Method:
{
    final int prevState = r.getLifecycleState();
    final ActivityLifecycleItem lifecycleItem;
    switch(prevState) {
        // TODO(lifecycler): Extend to support all possible states.
        case ON_PAUSE:
            lifecycleItem = PauseActivityItem.obtain();
            break;
        case ON_STOP:
            lifecycleItem = StopActivityItem.obtain(0);
            break;
        default:
            lifecycleItem = ResumeActivityItem.obtain(false);
            break;
    }
    return lifecycleItem;
}
------------------------
Find a silently evolved API code:android.telephony.CellSignalStrengthLte.updateLevel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    int[] thresholds;
    boolean rsrpOnly;
    if (cc == null) {
        thresholds = sThresholds;
        rsrpOnly = false;
    } else {
        rsrpOnly = cc.getBoolean(CarrierConfigManager.KEY_USE_ONLY_RSRP_FOR_LTE_SIGNAL_BAR_BOOL, false);
        thresholds = cc.getIntArray(CarrierConfigManager.KEY_LTE_RSRP_THRESHOLDS_INT_ARRAY);
        if (thresholds == null)
            thresholds = sThresholds;
        if (DBG)
            log("updateLevel() carrierconfig - rsrpOnly=" + rsrpOnly + ", thresholds=" + Arrays.toString(thresholds));
    }
    int rsrpBoost = 0;
    if (ss != null) {
        rsrpBoost = ss.getLteEarfcnRsrpBoost();
    }
    int rssiIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    int rsrpIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    int snrIconLevel = -1;
    int rsrp = mRsrp + rsrpBoost;
    if (rsrp < MIN_LTE_RSRP || rsrp > MAX_LTE_RSRP) {
        rsrpIconLevel = -1;
    } else {
        rsrpIconLevel = thresholds.length;
        while (rsrpIconLevel > 0 && rsrp < thresholds[rsrpIconLevel - 1]) rsrpIconLevel--;
    }
    if (rsrpOnly) {
        if (DBG)
            log("updateLevel() - rsrp = " + rsrpIconLevel);
        if (rsrpIconLevel != -1) {
            mLevel = rsrpIconLevel;
            return;
        }
    }
    /*
         * Values are -200 dB to +300 (SNR*10dB) RS_SNR >= 13.0 dB =>4 bars 4.5
         * dB <= RS_SNR < 13.0 dB => 3 bars 1.0 dB <= RS_SNR < 4.5 dB => 2 bars
         * -3.0 dB <= RS_SNR < 1.0 dB 1 bar RS_SNR < -3.0 dB/No Service Antenna
         * Icon Only
         */
    if (mRssnr > 300)
        snrIconLevel = -1;
    else if (mRssnr >= 130)
        snrIconLevel = SIGNAL_STRENGTH_GREAT;
    else if (mRssnr >= 45)
        snrIconLevel = SIGNAL_STRENGTH_GOOD;
    else if (mRssnr >= 10)
        snrIconLevel = SIGNAL_STRENGTH_MODERATE;
    else if (mRssnr >= -30)
        snrIconLevel = SIGNAL_STRENGTH_POOR;
    else if (mRssnr >= -200)
        snrIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    if (DBG)
        log("updateLevel() - rsrp:" + mRsrp + " snr:" + mRssnr + " rsrpIconLevel:" + rsrpIconLevel + " snrIconLevel:" + snrIconLevel + " lteRsrpBoost:" + sRsrpBoost);
    /* Choose a measurement type to use for notification */
    if (snrIconLevel != -1 && rsrpIconLevel != -1) {
        /*
             * The number of bars displayed shall be the smaller of the bars
             * associated with LTE RSRP and the bars associated with the LTE
             * RS_SNR
             */
        mLevel = (rsrpIconLevel < snrIconLevel ? rsrpIconLevel : snrIconLevel);
        return;
    }
    if (snrIconLevel != -1) {
        mLevel = snrIconLevel;
        return;
    }
    if (rsrpIconLevel != -1) {
        mLevel = rsrpIconLevel;
        return;
    }
    if (mRssi > -51)
        rssiIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    else if (mRssi >= -89)
        rssiIconLevel = SIGNAL_STRENGTH_GREAT;
    else if (mRssi >= -97)
        rssiIconLevel = SIGNAL_STRENGTH_GOOD;
    else if (mRssi >= -103)
        rssiIconLevel = SIGNAL_STRENGTH_MODERATE;
    else if (mRssi >= -113)
        rssiIconLevel = SIGNAL_STRENGTH_POOR;
    else
        rssiIconLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    if (DBG)
        log("getLteLevel - rssi:" + mRssi + " rssiIconLevel:" + rssiIconLevel);
    mLevel = rssiIconLevel;
}
Body of Second Method:
{
    int[] rsrpThresholds, rsrqThresholds, rssnrThresholds;
    boolean rsrpOnly;
    if (cc == null) {
        mParametersUseForLevel = USE_RSRP;
        rsrpThresholds = sRsrpThresholds;
        rsrqThresholds = sRsrqThresholds;
        rssnrThresholds = sRssnrThresholds;
        rsrpOnly = false;
    } else {
        mParametersUseForLevel = cc.getInt(CarrierConfigManager.KEY_PARAMETERS_USED_FOR_LTE_SIGNAL_BAR_INT);
        if (DBG) {
            Rlog.i(LOG_TAG, "Using signal strength level: " + mParametersUseForLevel);
        }
        rsrpThresholds = cc.getIntArray(CarrierConfigManager.KEY_LTE_RSRP_THRESHOLDS_INT_ARRAY);
        if (rsrpThresholds == null)
            rsrpThresholds = sRsrpThresholds;
        if (DBG) {
            Rlog.i(LOG_TAG, "Applying LTE RSRP Thresholds: " + Arrays.toString(rsrpThresholds));
        }
        rsrqThresholds = cc.getIntArray(CarrierConfigManager.KEY_LTE_RSRQ_THRESHOLDS_INT_ARRAY);
        if (rsrqThresholds == null)
            rsrqThresholds = sRsrqThresholds;
        if (DBG) {
            Rlog.i(LOG_TAG, "Applying LTE RSRQ Thresholds: " + Arrays.toString(rsrqThresholds));
        }
        rssnrThresholds = cc.getIntArray(CarrierConfigManager.KEY_LTE_RSSNR_THRESHOLDS_INT_ARRAY);
        if (rssnrThresholds == null)
            rssnrThresholds = sRssnrThresholds;
        if (DBG) {
            Rlog.i(LOG_TAG, "Applying LTE RSSNR Thresholds: " + Arrays.toString(rssnrThresholds));
        }
        rsrpOnly = cc.getBoolean(CarrierConfigManager.KEY_USE_ONLY_RSRP_FOR_LTE_SIGNAL_BAR_BOOL, false);
    }
    int rsrpBoost = 0;
    if (ss != null) {
        rsrpBoost = ss.getLteEarfcnRsrpBoost();
    }
    int rsrp = inRangeOrUnavailable(mRsrp + rsrpBoost, MIN_LTE_RSRP, MAX_LTE_RSRP);
    if (rsrpOnly) {
        int level = updateLevelWithMeasure(rsrp, rsrpThresholds);
        if (DBG)
            log("updateLevel() - rsrp = " + level);
        if (level != SignalStrength.INVALID) {
            mLevel = level;
            return;
        }
    }
    int rsrpLevel = SignalStrength.INVALID;
    int rsrqLevel = SignalStrength.INVALID;
    int rssnrLevel = SignalStrength.INVALID;
    if (isLevelForParameter(USE_RSRP)) {
        rsrpLevel = updateLevelWithMeasure(rsrp, rsrpThresholds);
        if (DBG) {
            Rlog.i(LOG_TAG, "Updated 4G LTE RSRP Level: " + rsrpLevel);
        }
    }
    if (isLevelForParameter(USE_RSRQ)) {
        rsrqLevel = updateLevelWithMeasure(mRsrq, rsrqThresholds);
        if (DBG) {
            Rlog.i(LOG_TAG, "Updated 4G LTE RSRQ Level: " + rsrqLevel);
        }
    }
    if (isLevelForParameter(USE_RSSNR)) {
        rssnrLevel = updateLevelWithMeasure(mRssnr, rssnrThresholds);
        if (DBG) {
            Rlog.i(LOG_TAG, "Updated 4G LTE RSSNR Level: " + rssnrLevel);
        }
    }
    // Apply the smaller value among three levels of three measures.
    mLevel = Math.min(Math.min(rsrpLevel, rsrqLevel), rssnrLevel);
    if (mLevel == SignalStrength.INVALID) {
        int rssiLevel;
        if (mRssi > -51) {
            rssiLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
        } else if (mRssi >= -89) {
            rssiLevel = SIGNAL_STRENGTH_GREAT;
        } else if (mRssi >= -97) {
            rssiLevel = SIGNAL_STRENGTH_GOOD;
        } else if (mRssi >= -103) {
            rssiLevel = SIGNAL_STRENGTH_MODERATE;
        } else if (mRssi >= -113) {
            rssiLevel = SIGNAL_STRENGTH_POOR;
        } else {
            rssiLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
        }
        if (DBG)
            log("getLteLevel - rssi:" + mRssi + " rssiIconLevel:" + rssiLevel);
        mLevel = rssiLevel;
    }
}
------------------------
Find a silently evolved API code:android.util.Half.abs:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns the absolute value of the specified half-precision float.
 * Special values are handled in the following ways:
 * <ul>
 * <li>If the specified half-precision float is NaN, the result is NaN</li>
 * <li>If the specified half-precision float is zero (negative or positive),
 * the result is positive zero (see {@link #POSITIVE_ZERO})</li>
 * <li>If the specified half-precision float is infinity (negative or positive),
 * the result is positive infinity (see {@link #POSITIVE_INFINITY})</li>
 * </ul>
 *
 * @param h A half-precision float value
 * @return The absolute value of the specified half-precision float
 */

Body of Frist Method:
{
    return (short) (h & FP16_COMBINED);
}
Body of Second Method:
{
    return (short) (h & FP16.EXPONENT_SIGNIFICAND_MASK);
}
------------------------
Find a silently evolved API code:android.media.AudioFormat.isValidEncoding:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    switch(audioFormat) {
        case ENCODING_PCM_16BIT:
        case ENCODING_PCM_8BIT:
        case ENCODING_PCM_FLOAT:
        case ENCODING_AC3:
        case ENCODING_E_AC3:
        case ENCODING_DTS:
        case ENCODING_DTS_HD:
        case ENCODING_MP3:
        case ENCODING_AAC_LC:
        case ENCODING_AAC_HE_V1:
        case ENCODING_AAC_HE_V2:
        case ENCODING_IEC61937:
        case ENCODING_DOLBY_TRUEHD:
        case ENCODING_AAC_ELD:
        case ENCODING_AAC_XHE:
        case ENCODING_AC4:
        case ENCODING_E_AC3_JOC:
        case ENCODING_DOLBY_MAT:
            return true;
        default:
            return false;
    }
}
Body of Second Method:
{
    switch(audioFormat) {
        case ENCODING_PCM_16BIT:
        case ENCODING_PCM_8BIT:
        case ENCODING_PCM_FLOAT:
        case ENCODING_AC3:
        case ENCODING_E_AC3:
        case ENCODING_DTS:
        case ENCODING_DTS_HD:
        case ENCODING_MP3:
        case ENCODING_AAC_LC:
        case ENCODING_AAC_HE_V1:
        case ENCODING_AAC_HE_V2:
        case ENCODING_IEC61937:
        case ENCODING_DOLBY_TRUEHD:
        case ENCODING_AAC_ELD:
        case ENCODING_AAC_XHE:
        case ENCODING_AC4:
        case ENCODING_E_AC3_JOC:
        case ENCODING_DOLBY_MAT:
        case ENCODING_OPUS:
            return true;
        default:
            return false;
    }
}
------------------------
Find a silently evolved API code:android.media.session.MediaController.TransportControls.setRating:COMMENT
Method Modifier: public      
Comment:/**
 * Rate the current content. This will cause the rating to be set for
 * the current user. The Rating type must match the type returned by
 * {@link #getRatingType()}.
 *
 * @param rating The rating to set for the current content
 */

Body of Frist Method:
{
    try {
        mSessionBinder.rate(mContext.getPackageName(), mCbStub, rating);
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling rate.", e);
    }
}
Body of Second Method:
{
    try {
        mSessionBinder.rate(mContext.getPackageName(), rating);
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling rate.", e);
    }
}
------------------------
Find a silently evolved API code:android.hardware.usb.UsbRequest.cancel:COMMENT
Method Modifier: public      
Comment:/**
 * Cancels a pending queue operation.
 *
 * @return true if cancelling succeeded
 */

Body of Frist Method:
{
    return native_cancel();
}
Body of Second Method:
{
    if (mConnection == null) {
        return false;
    }
    return mConnection.cancelRequest(this);
}
------------------------
Find a silently evolved API code:android.net.wifi.p2p.WifiP2pManager.Channel.close:COMMENT
Method Modifier: public      
Comment:/**
 * Close the current P2P connection and indicate to the P2P service that connections
 * created by the app can be removed.
 */

Body of Frist Method:
{
    if (mP2pManager == null) {
        Log.w(TAG, "Channel.close(): Null mP2pManager!?");
    } else {
        try {
            mP2pManager.mService.close(mBinder);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    mAsyncChannel.disconnect();
    mCloseGuard.close();
}
Body of Second Method:
{
    if (mP2pManager == null) {
        Log.w(TAG, "Channel.close(): Null mP2pManager!?");
    } else {
        try {
            mP2pManager.mService.close(mBinder);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
    mAsyncChannel.disconnect();
    mCloseGuard.close();
    Reference.reachabilityFence(this);
}
------------------------
Find a silently evolved API code:android.telephony.ims.ImsCallSessionListener.callSessionConferenceStateUpdated:COMMENT
Method Modifier: public      
Comment:/**
 * The IMS call session's conference state has changed.
 *
 * @param state The new {@link ImsConferenceState} associated with the conference.
 */

Body of Frist Method:
{
    try {
        mListener.callSessionConferenceStateUpdated(state);
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}
Body of Second Method:
{
    try {
        mListener.callSessionConferenceStateUpdated(state);
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.service.autofill.augmented.FillController.autofill:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Fills the activity with the provided values.
 *
 * <p>As a side effect, the {@link FillWindow} associated with the {@link FillResponse} will be
 * automatically {@link FillWindow#destroy() destroyed}.
 */

Body of Frist Method:
{
    Preconditions.checkNotNull(values);
    if (sDebug) {
        Log.d(TAG, "autofill() with " + values.size() + " values");
    }
    try {
        mProxy.autofill(values);
        final FillWindow fillWindow = mProxy.getFillWindow();
        if (fillWindow != null) {
            fillWindow.destroy();
        }
    } catch (RemoteException e) {
        e.rethrowAsRuntimeException();
    }
}
Body of Second Method:
{
    Preconditions.checkNotNull(values);
    if (sDebug) {
        Log.d(TAG, "autofill() with " + values.size() + " values");
    }
    try {
        mProxy.autofill(values);
    } catch (RemoteException e) {
        e.rethrowAsRuntimeException();
    }
    final FillWindow fillWindow = mProxy.getFillWindow();
    if (fillWindow != null) {
        fillWindow.destroy();
    }
}
------------------------
Find a silently evolved API code:android.service.dreams.Sandman.shouldStartDockApp:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Returns true if the specified dock app intent should be started.
 * False if we should dream instead, if appropriate.
 */

Body of Frist Method:
{
    ComponentName name = intent.resolveActivity(context.getPackageManager());
    return name != null && !name.equals(SOMNAMBULATOR_COMPONENT);
}
Body of Second Method:
{
    final ComponentName somnambulatorComponent = ComponentName.unflattenFromString(context.getResources().getString(com.android.internal.R.string.config_somnambulatorComponent));
    ComponentName name = intent.resolveActivity(context.getPackageManager());
    return name != null && !name.equals(somnambulatorComponent);
}
------------------------
Find a silently evolved API code:android.telephony.ims.ImsCallSessionListener.callSessionRttAudioIndicatorChanged:COMMENT
Method Modifier: public      
Comment:/**
 * While in call, there has been a change in RTT audio indicator.
 *
 * @param profile updated ImsStreamMediaProfile
 */

Body of Frist Method:
{
    try {
        mListener.callSessionRttAudioIndicatorChanged(profile);
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}
Body of Second Method:
{
    try {
        mListener.callSessionRttAudioIndicatorChanged(profile);
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.hardware.biometrics.CryptoObject.getOpId:COMMENT
Method Modifier: public      final       hidden      
Comment:/**
 * @hide
 * @return the opId associated with this object or 0 if none
 */

Body of Frist Method:
{
    return mCrypto != null ? AndroidKeyStoreProvider.getKeyStoreOperationHandle(mCrypto) : 0;
}
Body of Second Method:
{
    if (mCrypto == null) {
        return 0;
    } else if (mCrypto instanceof IdentityCredential) {
        return ((IdentityCredential) mCrypto).getCredstoreOperationHandle();
    }
    return AndroidKeyStoreProvider.getKeyStoreOperationHandle(mCrypto);
}
------------------------
Find a silently evolved API code:android.telephony.ims.ImsCallSessionListener.callSessionTtyModeReceived:COMMENT
Method Modifier: public      
Comment:/**
 * The TTY mode has been changed by the remote party.
 *
 * @param mode one of the following: -
 * {@link com.android.internal.telephony.Phone#TTY_MODE_OFF} -
 * {@link com.android.internal.telephony.Phone#TTY_MODE_FULL} -
 * {@link com.android.internal.telephony.Phone#TTY_MODE_HCO} -
 * {@link com.android.internal.telephony.Phone#TTY_MODE_VCO}
 */

Body of Frist Method:
{
    try {
        mListener.callSessionTtyModeReceived(mode);
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}
Body of Second Method:
{
    try {
        mListener.callSessionTtyModeReceived(mode);
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.opengl.GLUtils.getType:COMMENT
Method Modifier: public      static      
Comment:/**
 * Return the type as defined by OpenGL ES of the supplied bitmap, if there
 * is one. If the bitmap is stored in a compressed format, it may not have
 * a valid OpenGL ES type.
 * @throws IllegalArgumentException if the bitmap does not have a type.
 * @param bitmap
 * @return the OpenGL ES type of the bitmap.
 */

Body of Frist Method:
{
    if (bitmap == null) {
        throw new NullPointerException("getType can't be used with a null Bitmap");
    }
    if (bitmap.isRecycled()) {
        throw new IllegalArgumentException("bitmap is recycled");
    }
    int result = native_getType(bitmap.getNativeInstance());
    if (result < 0) {
        throw new IllegalArgumentException("Unknown type");
    }
    return result;
}
Body of Second Method:
{
    if (bitmap == null) {
        throw new NullPointerException("getType can't be used with a null Bitmap");
    }
    if (bitmap.isRecycled()) {
        throw new IllegalArgumentException("bitmap is recycled");
    }
    int result = native_getType(bitmap);
    if (result < 0) {
        throw new IllegalArgumentException("Unknown type");
    }
    return result;
}
------------------------
Find a silently evolved API code:android.app.prediction.AppTarget.Builder.setClassName:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets the className for the target.
 */

Body of Frist Method:
{
    mClassName = Preconditions.checkNotNull(className);
    return this;
}
Body of Second Method:
{
    mClassName = Objects.requireNonNull(className);
    return this;
}
------------------------
Find a silently evolved API code:android.media.session.MediaController.TransportControls.skipToQueueItem:COMMENT
Method Modifier: public      
Comment:/**
 * Play an item with a specific id in the play queue. If you specify an
 * id that is not in the play queue, the behavior is undefined.
 */

Body of Frist Method:
{
    try {
        mSessionBinder.skipToQueueItem(mContext.getPackageName(), mCbStub, id);
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling skipToItem(" + id + ").", e);
    }
}
Body of Second Method:
{
    try {
        mSessionBinder.skipToQueueItem(mContext.getPackageName(), id);
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling skipToItem(" + id + ").", e);
    }
}
------------------------
Find a silently evolved API code:android.media.session.MediaController.adjustVolume:COMMENT
Method Modifier: public      
Comment:/**
 * Adjust the volume of the output this session is playing on. The direction
 * must be one of {@link AudioManager#ADJUST_LOWER},
 * {@link AudioManager#ADJUST_RAISE}, or {@link AudioManager#ADJUST_SAME}.
 * The command will be ignored if the session does not support
 * {@link VolumeProvider#VOLUME_CONTROL_RELATIVE} or
 * {@link VolumeProvider#VOLUME_CONTROL_ABSOLUTE}. The flags in
 * {@link AudioManager} may be used to affect the handling.
 *
 * @see #getPlaybackInfo()
 * @param direction The direction to adjust the volume in.
 * @param flags Any flags to pass with the command.
 */

Body of Frist Method:
{
    try {
        // Note: Need both package name and OP package name. Package name is used for
        // RemoteUserInfo, and OP package name is used for AudioService's internal
        // AppOpsManager usages.
        mSessionBinder.adjustVolume(mContext.getPackageName(), mContext.getOpPackageName(), mCbStub, direction, flags);
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling adjustVolumeBy.", e);
    }
}
Body of Second Method:
{
    try {
        // Note: Need both package name and OP package name. Package name is used for
        // RemoteUserInfo, and OP package name is used for AudioService's internal
        // AppOpsManager usages.
        mSessionBinder.adjustVolume(mContext.getPackageName(), mContext.getOpPackageName(), direction, flags);
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling adjustVolumeBy.", e);
    }
}
------------------------
Find a silently evolved API code:android.provider.CalendarContract.CalendarAlerts.scheduleAlarm:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Schedules an alarm intent with the system AlarmManager that will
 * notify listeners when a reminder should be fired. The provider will
 * keep scheduled reminders up to date but apps may use this to
 * implement snooze functionality without modifying the reminders table.
 * Scheduled alarms will generate an intent using
 * {@link #ACTION_EVENT_REMINDER}. TODO Move to provider
 *
 * @param context A context for referencing system resources
 * @param manager The AlarmManager to use or null
 * @param alarmTime The time to fire the intent in UTC millis since
 * epoch
 * @hide
 */

Body of Frist Method:
{
    if (DEBUG) {
        Time time = new Time();
        time.set(alarmTime);
        String schedTime = time.format(" %a, %b %d, %Y %I:%M%P");
        Log.d(TAG, "Schedule alarm at " + alarmTime + " " + schedTime);
    }
    if (manager == null) {
        manager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);
    }
    Intent intent = new Intent(ACTION_EVENT_REMINDER);
    intent.setData(ContentUris.withAppendedId(CalendarContract.CONTENT_URI, alarmTime));
    intent.putExtra(ALARM_TIME, alarmTime);
    intent.setFlags(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);
    PendingIntent pi = PendingIntent.getBroadcast(context, 0, intent, 0);
    manager.setExactAndAllowWhileIdle(AlarmManager.RTC_WAKEUP, alarmTime, pi);
}
Body of Second Method:
{
    if (DEBUG) {
        String schedTime = TimeMigrationUtils.formatMillisWithFixedFormat(alarmTime);
        Log.d(TAG, "Schedule alarm at " + alarmTime + " " + schedTime);
    }
    if (manager == null) {
        manager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);
    }
    Intent intent = new Intent(ACTION_EVENT_REMINDER);
    intent.setData(ContentUris.withAppendedId(CalendarContract.CONTENT_URI, alarmTime));
    intent.putExtra(ALARM_TIME, alarmTime);
    intent.setFlags(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);
    PendingIntent pi = PendingIntent.getBroadcast(context, 0, intent, 0);
    manager.setExactAndAllowWhileIdle(AlarmManager.RTC_WAKEUP, alarmTime, pi);
}
------------------------
Find a silently evolved API code:android.util.Half.halfToShortBits:COMMENT
Method Modifier: public      static      
Comment:/**
 * <p>Returns a representation of the specified half-precision float value
 * according to the bit layout described in {@link Half}.</p>
 *
 * <p>Similar to {@link #halfToIntBits(short)}, this method collapses all
 * possible Not-a-Number values to a single canonical Not-a-Number value
 * defined by {@link #NaN}.</p>
 *
 * @param h A half-precision float value
 * @return The bits that represent the half-precision float value
 *
 * @see #halfToIntBits(short)
 */

Body of Frist Method:
{
    return (h & FP16_COMBINED) > FP16_EXPONENT_MAX ? NaN : h;
}
Body of Second Method:
{
    return (h & FP16.EXPONENT_SIGNIFICAND_MASK) > FP16.POSITIVE_INFINITY ? NaN : h;
}
------------------------
Find a silently evolved API code:android.provider.SearchIndexablesProvider.attachInfo:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Implementation is provided by the parent class.
 */

Body of Frist Method:
{
    mAuthority = info.authority;
    mMatcher = new UriMatcher(UriMatcher.NO_MATCH);
    mMatcher.addURI(mAuthority, SearchIndexablesContract.INDEXABLES_XML_RES_PATH, MATCH_RES_CODE);
    mMatcher.addURI(mAuthority, SearchIndexablesContract.INDEXABLES_RAW_PATH, MATCH_RAW_CODE);
    mMatcher.addURI(mAuthority, SearchIndexablesContract.NON_INDEXABLES_KEYS_PATH, MATCH_NON_INDEXABLE_KEYS_CODE);
    mMatcher.addURI(mAuthority, SearchIndexablesContract.SITE_MAP_PAIRS_PATH, MATCH_SITE_MAP_PAIRS_CODE);
    mMatcher.addURI(mAuthority, SearchIndexablesContract.SLICE_URI_PAIRS_PATH, MATCH_SLICE_URI_PAIRS_CODE);
    // Sanity check our setup
    if (!info.exported) {
        throw new SecurityException("Provider must be exported");
    }
    if (!info.grantUriPermissions) {
        throw new SecurityException("Provider must grantUriPermissions");
    }
    if (!android.Manifest.permission.READ_SEARCH_INDEXABLES.equals(info.readPermission)) {
        throw new SecurityException("Provider must be protected by READ_SEARCH_INDEXABLES");
    }
    super.attachInfo(context, info);
}
Body of Second Method:
{
    mAuthority = info.authority;
    mMatcher = new UriMatcher(UriMatcher.NO_MATCH);
    mMatcher.addURI(mAuthority, SearchIndexablesContract.INDEXABLES_XML_RES_PATH, MATCH_RES_CODE);
    mMatcher.addURI(mAuthority, SearchIndexablesContract.INDEXABLES_RAW_PATH, MATCH_RAW_CODE);
    mMatcher.addURI(mAuthority, SearchIndexablesContract.NON_INDEXABLES_KEYS_PATH, MATCH_NON_INDEXABLE_KEYS_CODE);
    mMatcher.addURI(mAuthority, SearchIndexablesContract.SITE_MAP_PAIRS_PATH, MATCH_SITE_MAP_PAIRS_CODE);
    mMatcher.addURI(mAuthority, SearchIndexablesContract.SLICE_URI_PAIRS_PATH, MATCH_SLICE_URI_PAIRS_CODE);
    mMatcher.addURI(mAuthority, SearchIndexablesContract.DYNAMIC_INDEXABLES_RAW_PATH, MATCH_DYNAMIC_RAW_CODE);
    // Sanity check our setup
    if (!info.exported) {
        throw new SecurityException("Provider must be exported");
    }
    if (!info.grantUriPermissions) {
        throw new SecurityException("Provider must grantUriPermissions");
    }
    if (!android.Manifest.permission.READ_SEARCH_INDEXABLES.equals(info.readPermission)) {
        throw new SecurityException("Provider must be protected by READ_SEARCH_INDEXABLES");
    }
    super.attachInfo(context, info);
}
------------------------
Find a silently evolved API code:android.widget.AdapterView.onProvideStructure:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    super.onProvideStructure(structure, viewFor, flags);
    if (viewFor == VIEW_STRUCTURE_FOR_AUTOFILL) {
        final Adapter adapter = getAdapter();
        if (adapter == null)
            return;
        final CharSequence[] options = adapter.getAutofillOptions();
        if (options != null) {
            structure.setAutofillOptions(options);
        }
    }
}
Body of Second Method:
{
    super.onProvideStructure(structure, viewFor, flags);
    if (viewFor == VIEW_STRUCTURE_FOR_AUTOFILL || viewFor == VIEW_STRUCTURE_FOR_CONTENT_CAPTURE) {
        final Adapter adapter = getAdapter();
        if (adapter == null)
            return;
        final CharSequence[] options = adapter.getAutofillOptions();
        if (options != null) {
            structure.setAutofillOptions(options);
        }
    }
}
------------------------
Find a silently evolved API code:android.os.Process.startWebView:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return WebViewZygote.getProcess().start(processClass, niceName, uid, gid, gids, runtimeFlags, mountExternal, targetSdkVersion, seInfo, abi, instructionSet, appDataDir, invokeWith, packageName, /*useUsapPool=*/
    false, zygoteArgs);
}
Body of Second Method:
{
    // info.
    return WebViewZygote.getProcess().start(processClass, niceName, uid, gid, gids, runtimeFlags, mountExternal, targetSdkVersion, seInfo, abi, instructionSet, appDataDir, invokeWith, packageName, /*zygotePolicyFlags=*/
    ZYGOTE_POLICY_FLAG_EMPTY, /*isTopApp=*/
    false, disabledCompatChanges, /* pkgDataInfoMap */
    null, /* whitelistedDataInfoMap */
    null, false, false, zygoteArgs);
}
------------------------
Find a silently evolved API code:android.graphics.drawable.Icon.createFromStream:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Create an Icon from the specified stream.
 *
 * @param stream The input stream from which to reconstruct the Icon.
 * @hide
 */

Body of Frist Method:
{
    DataInputStream inputStream = new DataInputStream(stream);
    final int version = inputStream.readInt();
    if (version >= VERSION_STREAM_SERIALIZER) {
        final int type = inputStream.readByte();
        switch(type) {
            case TYPE_BITMAP:
                return createWithBitmap(BitmapFactory.decodeStream(inputStream));
            case TYPE_ADAPTIVE_BITMAP:
                return createWithAdaptiveBitmap(BitmapFactory.decodeStream(inputStream));
            case TYPE_DATA:
                final int length = inputStream.readInt();
                final byte[] data = new byte[length];
                inputStream.read(data, 0, /* offset */
                length);
                return createWithData(data, 0, /* offset */
                length);
            case TYPE_RESOURCE:
                final String packageName = inputStream.readUTF();
                final int resId = inputStream.readInt();
                return createWithResource(packageName, resId);
            case TYPE_URI:
                final String uriOrPath = inputStream.readUTF();
                return createWithContentUri(uriOrPath);
        }
    }
    return null;
}
Body of Second Method:
{
    DataInputStream inputStream = new DataInputStream(stream);
    final int version = inputStream.readInt();
    if (version >= VERSION_STREAM_SERIALIZER) {
        final int type = inputStream.readByte();
        switch(type) {
            case TYPE_BITMAP:
                return createWithBitmap(BitmapFactory.decodeStream(inputStream));
            case TYPE_ADAPTIVE_BITMAP:
                return createWithAdaptiveBitmap(BitmapFactory.decodeStream(inputStream));
            case TYPE_DATA:
                final int length = inputStream.readInt();
                final byte[] data = new byte[length];
                inputStream.read(data, 0, /* offset */
                length);
                return createWithData(data, 0, /* offset */
                length);
            case TYPE_RESOURCE:
                final String packageName = inputStream.readUTF();
                final int resId = inputStream.readInt();
                return createWithResource(packageName, resId);
            case TYPE_URI:
                final String uriOrPath = inputStream.readUTF();
                return createWithContentUri(uriOrPath);
            case TYPE_URI_ADAPTIVE_BITMAP:
                final String uri = inputStream.readUTF();
                return createWithAdaptiveBitmapContentUri(uri);
        }
    }
    return null;
}
------------------------
Find a silently evolved API code:android.widget.Switch.setTextOff:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the text displayed when the button is not in the checked state.
 *
 * @attr ref android.R.styleable#Switch_textOff
 */

Body of Frist Method:
{
    mTextOff = textOff;
    requestLayout();
}
Body of Second Method:
{
    mTextOff = textOff;
    requestLayout();
    // Default state is derived from on/off-text, so state has to be updated when on/off-text
    // are updated.
    setDefaultStateDescritption();
}
------------------------
Find a silently evolved API code:android.view.autofill.AutofillId.withoutSession:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    final int flags = id.mFlags & ~FLAG_HAS_SESSION;
    return new AutofillId(flags, id.mViewId, id.mVirtualLongId, NO_SESSION);
}
Body of Second Method:
{
    final int flags = id.mFlags & ~FLAG_HAS_SESSION;
    final long virtualChildId = ((id.mFlags & FLAG_IS_VIRTUAL_LONG) != 0) ? id.mVirtualLongId : id.mVirtualIntId;
    return new AutofillId(flags, id.mViewId, virtualChildId, NO_SESSION);
}
------------------------
Find a silently evolved API code:android.media.AudioFormat.isEncodingLinearFrames:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    switch(audioFormat) {
        case ENCODING_PCM_16BIT:
        case ENCODING_PCM_8BIT:
        case ENCODING_PCM_FLOAT:
        // same size as stereo PCM
        case ENCODING_IEC61937:
        case ENCODING_DEFAULT:
            return true;
        case ENCODING_AC3:
        case ENCODING_E_AC3:
        case ENCODING_DTS:
        case ENCODING_DTS_HD:
        case ENCODING_MP3:
        case ENCODING_AAC_LC:
        case ENCODING_AAC_HE_V1:
        case ENCODING_AAC_HE_V2:
        case ENCODING_DOLBY_TRUEHD:
        case ENCODING_AAC_ELD:
        case ENCODING_AAC_XHE:
        case ENCODING_AC4:
        case ENCODING_E_AC3_JOC:
        case ENCODING_DOLBY_MAT:
            return false;
        case ENCODING_INVALID:
        default:
            throw new IllegalArgumentException("Bad audio format " + audioFormat);
    }
}
Body of Second Method:
{
    switch(audioFormat) {
        case ENCODING_PCM_16BIT:
        case ENCODING_PCM_8BIT:
        case ENCODING_PCM_FLOAT:
        // same size as stereo PCM
        case ENCODING_IEC61937:
        case ENCODING_DEFAULT:
            return true;
        case ENCODING_AC3:
        case ENCODING_E_AC3:
        case ENCODING_DTS:
        case ENCODING_DTS_HD:
        case ENCODING_MP3:
        case ENCODING_AAC_LC:
        case ENCODING_AAC_HE_V1:
        case ENCODING_AAC_HE_V2:
        case ENCODING_DOLBY_TRUEHD:
        case ENCODING_AAC_ELD:
        case ENCODING_AAC_XHE:
        case ENCODING_AC4:
        case ENCODING_E_AC3_JOC:
        case ENCODING_DOLBY_MAT:
        case ENCODING_OPUS:
            return false;
        case ENCODING_INVALID:
        default:
            throw new IllegalArgumentException("Bad audio format " + audioFormat);
    }
}
------------------------
Find a silently evolved API code:android.widget.StackView.onInitializeAccessibilityNodeInfoInternal:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    super.onInitializeAccessibilityNodeInfoInternal(info);
    info.setScrollable(getChildCount() > 1);
    if (isEnabled()) {
        if (getDisplayedChild() < getChildCount() - 1) {
            info.addAction(AccessibilityNodeInfo.ACTION_SCROLL_FORWARD);
        }
        if (getDisplayedChild() > 0) {
            info.addAction(AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD);
        }
    }
}
Body of Second Method:
{
    super.onInitializeAccessibilityNodeInfoInternal(info);
    info.setScrollable(getChildCount() > 1);
    if (isEnabled()) {
        if (getDisplayedChild() < getChildCount() - 1) {
            info.addAction(AccessibilityNodeInfo.AccessibilityAction.ACTION_SCROLL_FORWARD);
            if (mStackMode == ITEMS_SLIDE_UP) {
                info.addAction(AccessibilityNodeInfo.AccessibilityAction.ACTION_PAGE_DOWN);
            } else {
                info.addAction(AccessibilityNodeInfo.AccessibilityAction.ACTION_PAGE_UP);
            }
        }
        if (getDisplayedChild() > 0) {
            info.addAction(AccessibilityNodeInfo.AccessibilityAction.ACTION_SCROLL_BACKWARD);
            if (mStackMode == ITEMS_SLIDE_UP) {
                info.addAction(AccessibilityNodeInfo.AccessibilityAction.ACTION_PAGE_UP);
            } else {
                info.addAction(AccessibilityNodeInfo.AccessibilityAction.ACTION_PAGE_DOWN);
            }
        }
    }
}
------------------------
Find a silently evolved API code:android.app.ActivityView.performBackPress:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Injects a pair of down/up key events with keycode {@link KeyEvent#KEYCODE_BACK} to the
 * virtual display.
 */

Body of Frist Method:
{
    if (mVirtualDisplay == null) {
        return;
    }
    final int displayId = mVirtualDisplay.getDisplay().getDisplayId();
    final InputManager im = InputManager.getInstance();
    im.injectInputEvent(createKeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_BACK, displayId), InputManager.INJECT_INPUT_EVENT_MODE_ASYNC);
    im.injectInputEvent(createKeyEvent(KeyEvent.ACTION_UP, KeyEvent.KEYCODE_BACK, displayId), InputManager.INJECT_INPUT_EVENT_MODE_ASYNC);
}
Body of Second Method:
{
    mTaskEmbedder.performBackPress();
}
------------------------
Find a silently evolved API code:android.se.omapi.SEService.getReaders:COMMENT
Method Modifier: public      
Comment:/**
 * Returns an array of available Secure Element readers.
 * There must be no duplicated objects in the returned list.
 * All available readers shall be listed even if no card is inserted.
 *
 * @return An array of Readers. If there are no readers the returned array
 * is of length 0.
 */

Body of Frist Method:
{
    if (mSecureElementService == null) {
        throw new IllegalStateException("service not connected to system");
    }
    String[] readerNames;
    try {
        readerNames = mSecureElementService.getReaders();
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
    Reader[] readers = new Reader[readerNames.length];
    int i = 0;
    for (String readerName : readerNames) {
        if (mReaders.get(readerName) == null) {
            try {
                mReaders.put(readerName, new Reader(this, readerName, getReader(readerName)));
                readers[i++] = mReaders.get(readerName);
            } catch (Exception e) {
                Log.e(TAG, "Error adding Reader: " + readerName, e);
            }
        } else {
            readers[i++] = mReaders.get(readerName);
        }
    }
    return readers;
}
Body of Second Method:
{
    loadReaders();
    return mReaders.values().toArray(new Reader[0]);
}
------------------------
Find a silently evolved API code:android.net.ip.IpClientUtil.IpClientCallbacksProxy.onNewDhcpResults:COMMENT
Method Modifier: public      
Comment:// null or not.

Body of Frist Method:
{
    mCb.onNewDhcpResults(fromStableParcelable(dhcpResults));
}
Body of Second Method:
{
    mCb.onNewDhcpResults(dhcpResults);
}
------------------------
Find a silently evolved API code:android.widget.HorizontalScrollView.onInitializeAccessibilityEventInternal:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    super.onInitializeAccessibilityEventInternal(event);
    event.setScrollable(getScrollRange() > 0);
    event.setScrollX(mScrollX);
    event.setScrollY(mScrollY);
    event.setMaxScrollX(getScrollRange());
    event.setMaxScrollY(mScrollY);
}
Body of Second Method:
{
    super.onInitializeAccessibilityEventInternal(event);
    event.setScrollable(getScrollRange() > 0);
    event.setMaxScrollX(getScrollRange());
    event.setMaxScrollY(mScrollY);
}
------------------------
Find a silently evolved API code:android.app.servertransaction.ActivityConfigurationChangeItem.obtain:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Obtain an instance initialized with provided params.
 */

Body of Frist Method:
{
    ActivityConfigurationChangeItem instance = ObjectPool.obtain(ActivityConfigurationChangeItem.class);
    if (instance == null) {
        instance = new ActivityConfigurationChangeItem();
    }
    instance.mConfiguration = config;
    return instance;
}
Body of Second Method:
{
    if (config == null) {
        throw new IllegalArgumentException("Config must not be null.");
    }
    ActivityConfigurationChangeItem instance = ObjectPool.obtain(ActivityConfigurationChangeItem.class);
    if (instance == null) {
        instance = new ActivityConfigurationChangeItem();
    }
    instance.mConfiguration = config;
    return instance;
}
------------------------
Find a silently evolved API code:android.util.PackageUtils.computeSha256Digest:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Computes the SHA256 digest of some data.
 * @param data The data.
 * @return The digest or null if an error occurs.
 */

Body of Frist Method:
{
    return ByteStringUtils.toHexString(computeSha256DigestBytes(data));
}
Body of Second Method:
{
    byte[] sha256DigestBytes = computeSha256DigestBytes(data);
    if (sha256DigestBytes == null) {
        return null;
    }
    return HexEncoding.encodeToString(sha256DigestBytes, true);
}
------------------------
Find a silently evolved API code:android.content.ContentProviderClient.openAssetFile:COMMENT
Method Modifier: public      
Comment:/**
 * See {@link ContentProvider#openAssetFile ContentProvider.openAssetFile}.
 * Note that this <em>does not</em>
 * take care of non-content: URIs such as file:.  It is strongly recommended
 * you use the {@link ContentResolver#openAssetFileDescriptor
 * ContentResolver.openAssetFileDescriptor} API instead.
 */

Body of Frist Method:
{
    return openAssetFile(url, mode, null);
}
Body of Second Method:
{
    Objects.requireNonNull(url, "url");
    Objects.requireNonNull(mode, "mode");
    beforeRemote();
    try {
        ICancellationSignal remoteSignal = null;
        if (signal != null) {
            signal.throwIfCanceled();
            remoteSignal = mContentProvider.createCancellationSignal();
            signal.setRemote(remoteSignal);
        }
        return mContentProvider.openAssetFile(mPackageName, mAttributionTag, url, mode, remoteSignal);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}
------------------------
Find a silently evolved API code:android.hardware.soundtrigger.SoundTriggerModule.loadSoundModel:COMMENT
<android.hardware.soundtrigger.SoundTriggerModule: int loadSoundModel(SoundModel,int[])>
public      native      hidden      ->public      hidden      
Method Modifier: public      native      hidden      
Method Modifier: Yes         Yes         Yes         
Method Updated:  Yes         No          Yes         
Comment:/**
 * Load a {@link SoundTrigger.SoundModel} to the hardware. A sound model must be loaded in
 * order to start listening to a key phrase in this model.
 * @param model The sound model to load.
 * @param soundModelHandle an array of int where the sound model handle will be returned.
 * @return - {@link SoundTrigger#STATUS_OK} in case of success
 * - {@link SoundTrigger#STATUS_ERROR} in case of unspecified error
 * - {@link SoundTrigger#STATUS_PERMISSION_DENIED} if the caller does not have
 * system permission
 * - {@link SoundTrigger#STATUS_NO_INIT} if the native service cannot be reached
 * - {@link SoundTrigger#STATUS_BAD_VALUE} if parameters are invalid
 * - {@link SoundTrigger#STATUS_DEAD_OBJECT} if the binder transaction to the native
 * service fails
 * - {@link SoundTrigger#STATUS_INVALID_OPERATION} if the call is out of sequence
 */

Body of Frist Method:

Body of Second Method:
{
    try {
        if (model instanceof SoundTrigger.GenericSoundModel) {
            SoundModel aidlModel = ConversionUtil.api2aidlGenericSoundModel((SoundTrigger.GenericSoundModel) model);
            soundModelHandle[0] = mService.loadModel(aidlModel);
            return SoundTrigger.STATUS_OK;
        }
        if (model instanceof SoundTrigger.KeyphraseSoundModel) {
            PhraseSoundModel aidlModel = ConversionUtil.api2aidlPhraseSoundModel((SoundTrigger.KeyphraseSoundModel) model);
            soundModelHandle[0] = mService.loadPhraseModel(aidlModel);
            return SoundTrigger.STATUS_OK;
        }
        return SoundTrigger.STATUS_BAD_VALUE;
    } catch (Exception e) {
        return SoundTrigger.handleException(e);
    }
}
------------------------
Find a silently evolved API code:android.media.session.MediaController.TransportControls.playFromUri:COMMENT
Method Modifier: public      
Comment:/**
 * Request that the player start playback for a specific {@link Uri}.
 *
 * @param uri The URI of the requested media.
 * @param extras Optional extras that can include extra information about the media item
 * to be played.
 */

Body of Frist Method:
{
    if (uri == null || Uri.EMPTY.equals(uri)) {
        throw new IllegalArgumentException("You must specify a non-empty Uri for playFromUri.");
    }
    try {
        mSessionBinder.playFromUri(mContext.getPackageName(), mCbStub, uri, extras);
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling play(" + uri + ").", e);
    }
}
Body of Second Method:
{
    if (uri == null || Uri.EMPTY.equals(uri)) {
        throw new IllegalArgumentException("You must specify a non-empty Uri for playFromUri.");
    }
    try {
        mSessionBinder.playFromUri(mContext.getPackageName(), uri, extras);
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling play(" + uri + ").", e);
    }
}
------------------------
Find a silently evolved API code:android.net.TrafficStats.getUidRxPackets:COMMENT
Method Modifier: public      static      
Comment:/**
 * Return number of packets received by the given UID since device boot.
 * Counts packets across all network interfaces, and always increases
 * monotonically since device boot. Statistics are measured at the network
 * layer, so they include both TCP and UDP usage.
 * <p>
 * Before {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}, this may return
 * {@link #UNSUPPORTED} on devices where statistics aren't available.
 * <p>
 * Starting in {@link android.os.Build.VERSION_CODES#N} this will only
 * report traffic statistics for the calling UID. It will return
 * {@link #UNSUPPORTED} for all other UIDs for privacy reasons. To access
 * historical network statistics belonging to other UIDs, use
 * {@link NetworkStatsManager}.
 *
 * @see android.os.Process#myUid()
 * @see android.content.pm.ApplicationInfo#uid
 */

Body of Frist Method:
{
    // This isn't actually enforcing any security; it just returns the
    // unsupported value. The real filtering is done at the kernel level.
    final int callingUid = android.os.Process.myUid();
    if (callingUid == android.os.Process.SYSTEM_UID || callingUid == uid) {
        try {
            return getStatsService().getUidStats(uid, TYPE_RX_PACKETS);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    } else {
        return UNSUPPORTED;
    }
}
Body of Second Method:
{
    try {
        return getStatsService().getUidStats(uid, TYPE_RX_PACKETS);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.graphics.RenderNode.setOutline:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the outline, defining the shape that casts a shadow, and the path to
 * be clipped if setClipToOutline is set.
 *
 * This will make a copy of the provided {@link Outline}, so any future modifications
 * to the outline will need to call {@link #setOutline(Outline)} with the modified
 * outline for those changes to be applied.
 *
 * @param outline The outline to use for this RenderNode.
 * @return True if the value changed, false if the new value was the same as the previous value.
 */

Body of Frist Method:
{
    if (outline == null) {
        return nSetOutlineNone(mNativeRenderNode);
    }
    switch(outline.mMode) {
        case Outline.MODE_EMPTY:
            return nSetOutlineEmpty(mNativeRenderNode);
        case Outline.MODE_ROUND_RECT:
            return nSetOutlineRoundRect(mNativeRenderNode, outline.mRect.left, outline.mRect.top, outline.mRect.right, outline.mRect.bottom, outline.mRadius, outline.mAlpha);
        case Outline.MODE_CONVEX_PATH:
            return nSetOutlineConvexPath(mNativeRenderNode, outline.mPath.mNativePath, outline.mAlpha);
    }
    throw new IllegalArgumentException("Unrecognized outline?");
}
Body of Second Method:
{
    if (outline == null) {
        return nSetOutlineNone(mNativeRenderNode);
    }
    switch(outline.mMode) {
        case Outline.MODE_EMPTY:
            return nSetOutlineEmpty(mNativeRenderNode);
        case Outline.MODE_ROUND_RECT:
            return nSetOutlineRoundRect(mNativeRenderNode, outline.mRect.left, outline.mRect.top, outline.mRect.right, outline.mRect.bottom, outline.mRadius, outline.mAlpha);
        case Outline.MODE_PATH:
            return nSetOutlinePath(mNativeRenderNode, outline.mPath.mNativePath, outline.mAlpha);
    }
    throw new IllegalArgumentException("Unrecognized outline?");
}
------------------------
Find a silently evolved API code:android.text.SpannableStringInternal.copySpans:COMMENT
Method Modifier: private     
Comment:/**
 * Following two unused methods are left since these are listed in hidden api list.
 *
 * Due to backward compatibility reasons, we copy even NoCopySpan by default
 */

Body of Frist Method:
{
    copySpans(src, start, end, false);
}
Body of Second Method:
{
    copySpansFromSpanned(src, start, end, false);
}
------------------------
Find a silently evolved API code:android.telephony.ims.ImsCallSessionListener.callSessionInviteParticipantsRequestDelivered:COMMENT
Method Modifier: public      
Comment:/**
 * The request to invite participants to the conference has been delivered to the conference
 * server.
 */

Body of Frist Method:
{
    try {
        mListener.callSessionInviteParticipantsRequestDelivered();
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}
Body of Second Method:
{
    try {
        mListener.callSessionInviteParticipantsRequestDelivered();
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.media.AudioAttributes.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Combines all of the attributes that have been set and return a new
 * {@link AudioAttributes} object.
 * @return a new {@link AudioAttributes} object
 */

Body of Frist Method:
{
    AudioAttributes aa = new AudioAttributes();
    aa.mContentType = mContentType;
    aa.mUsage = mUsage;
    aa.mSource = mSource;
    aa.mFlags = mFlags;
    if (mMuteHapticChannels) {
        aa.mFlags |= FLAG_MUTE_HAPTIC;
    }
    aa.mTags = (HashSet<String>) mTags.clone();
    aa.mFormattedTags = TextUtils.join(";", mTags);
    if (mBundle != null) {
        aa.mBundle = new Bundle(mBundle);
    }
    return aa;
}
Body of Second Method:
{
    AudioAttributes aa = new AudioAttributes();
    aa.mContentType = mContentType;
    if (mUsage == USAGE_INVALID) {
        if (mSystemUsage == USAGE_INVALID) {
            aa.mUsage = USAGE_UNKNOWN;
        } else {
            aa.mUsage = mSystemUsage;
        }
    } else {
        if (mSystemUsage == USAGE_INVALID) {
            aa.mUsage = mUsage;
        } else {
            throw new IllegalArgumentException("Cannot set both usage and system usage on same builder");
        }
    }
    aa.mSource = mSource;
    aa.mFlags = mFlags;
    if (mMuteHapticChannels) {
        aa.mFlags |= FLAG_MUTE_HAPTIC;
    }
    if (mPrivacySensitive == PRIVACY_SENSITIVE_DEFAULT) {
        // reflect legacy behavior
        if (mSource == MediaRecorder.AudioSource.VOICE_COMMUNICATION || mSource == MediaRecorder.AudioSource.CAMCORDER) {
            aa.mFlags |= FLAG_CAPTURE_PRIVATE;
        } else {
            aa.mFlags &= ~FLAG_CAPTURE_PRIVATE;
        }
    } else if (mPrivacySensitive == PRIVACY_SENSITIVE_ENABLED) {
        aa.mFlags |= FLAG_CAPTURE_PRIVATE;
    } else {
        aa.mFlags &= ~FLAG_CAPTURE_PRIVATE;
    }
    aa.mTags = (HashSet<String>) mTags.clone();
    aa.mFormattedTags = TextUtils.join(";", mTags);
    if (mBundle != null) {
        aa.mBundle = new Bundle(mBundle);
    }
    return aa;
}
------------------------
Find a silently evolved API code:android.service.autofill.augmented.FillCallback.onSuccess:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets the response associated with the request.
 *
 * @param response response associated with the request, or {@code null} if the service
 * could not provide autofill for the request.
 */

Body of Frist Method:
{
    if (sDebug)
        Log.d(TAG, "onSuccess(): " + response);
    if (response == null) {
        mProxy.report(AutofillProxy.REPORT_EVENT_NO_RESPONSE);
        return;
    }
    final FillWindow fillWindow = response.getFillWindow();
    if (fillWindow != null) {
        fillWindow.show();
    }
// TODO(b/123099468): must notify the server so it can update the session state to avoid
// showing conflicting UIs (for example, if a new request is made to the main autofill
// service and it now wants to show something).
}
Body of Second Method:
{
    if (sDebug)
        Log.d(TAG, "onSuccess(): " + response);
    if (response == null) {
        mProxy.logEvent(AutofillProxy.REPORT_EVENT_NO_RESPONSE);
        mProxy.reportResult(/* inlineSuggestionsData */
        null, /* clientState */
        null, /* showingFillWindow */
        false);
        return;
    }
    final List<Dataset> inlineSuggestions = response.getInlineSuggestions();
    final Bundle clientState = response.getClientState();
    final FillWindow fillWindow = response.getFillWindow();
    boolean showingFillWindow = false;
    if (inlineSuggestions != null && !inlineSuggestions.isEmpty()) {
        mProxy.logEvent(AutofillProxy.REPORT_EVENT_INLINE_RESPONSE);
    } else if (fillWindow != null) {
        fillWindow.show();
        showingFillWindow = true;
    }
    // We need to report result regardless of whether inline suggestions are returned or not.
    mProxy.reportResult(inlineSuggestions, clientState, showingFillWindow);
// TODO(b/123099468): must notify the server so it can update the session state to avoid
// showing conflicting UIs (for example, if a new request is made to the main autofill
// service and it now wants to show something).
}
------------------------
Find a silently evolved API code:android.view.textclassifier.TextClassifierEvent.Builder.setEntityTypes:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the entity types. e.g. {@link TextClassifier#TYPE_ADDRESS}.
 * <p>
 * Supported types:
 * <p>See {@link TextClassifier.EntityType}
 * <p>See {@link ConversationAction.ActionType}
 * <p>See {@link ULocale#toLanguageTag()}
 */

Body of Frist Method:
{
    Preconditions.checkNotNull(entityTypes);
    mEntityTypes = new String[entityTypes.length];
    System.arraycopy(entityTypes, 0, mEntityTypes, 0, entityTypes.length);
    return self();
}
Body of Second Method:
{
    Objects.requireNonNull(entityTypes);
    mEntityTypes = new String[entityTypes.length];
    System.arraycopy(entityTypes, 0, mEntityTypes, 0, entityTypes.length);
    return self();
}
------------------------
Find a silently evolved API code:android.content.ContentProviderClient.canonicalize:COMMENT
Method Modifier: public      final       
Comment:/**
 * See {@link ContentProvider#canonicalize}
 */

Body of Frist Method:
{
    Preconditions.checkNotNull(url, "url");
    beforeRemote();
    try {
        return mContentProvider.canonicalize(mPackageName, url);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}
Body of Second Method:
{
    Objects.requireNonNull(url, "url");
    beforeRemote();
    try {
        return mContentProvider.canonicalize(mPackageName, mAttributionTag, url);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}
------------------------
Find a silently evolved API code:android.speech.SpeechRecognizer.handleStopMessage:COMMENT
Method Modifier: private     
Comment:/**
 * sends the actual message to the service
 */

Body of Frist Method:
{
    if (!checkOpenConnection()) {
        return;
    }
    try {
        mService.stopListening(mListener);
        if (DBG)
            Log.d(TAG, "service stop listening command succeded");
    } catch (final RemoteException e) {
        Log.e(TAG, "stopListening() failed", e);
        mListener.onError(ERROR_CLIENT);
    }
}
Body of Second Method:
{
    if (!checkOpenConnection()) {
        return;
    }
    try {
        mService.stopListening(mListener, mContext.getOpPackageName(), mContext.getAttributionTag());
        if (DBG)
            Log.d(TAG, "service stop listening command succeded");
    } catch (final RemoteException e) {
        Log.e(TAG, "stopListening() failed", e);
        mListener.onError(ERROR_CLIENT);
    }
}
------------------------
Find a silently evolved API code:android.util.Half.greaterEquals:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns true if the first half-precision float value is greater (larger
 * toward positive infinity) than or equal to the second half-precision float
 * value. If either of the values is NaN, the result is false.
 *
 * @param x The first half-precision value
 * @param y The second half-precision value
 *
 * @return True if x is greater than y, false otherwise
 */

Body of Frist Method:
{
    if ((x & FP16_COMBINED) > FP16_EXPONENT_MAX)
        return false;
    if ((y & FP16_COMBINED) > FP16_EXPONENT_MAX)
        return false;
    return ((x & FP16_SIGN_MASK) != 0 ? 0x8000 - (x & 0xffff) : x & 0xffff) >= ((y & FP16_SIGN_MASK) != 0 ? 0x8000 - (y & 0xffff) : y & 0xffff);
}
Body of Second Method:
{
    return FP16.greaterEquals(x, y);
}
------------------------
Find a silently evolved API code:android.location.GnssClock.resetBiasUncertaintyNanos:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Resets the clock's Bias Uncertainty (1-Sigma) in nanoseconds.
 * @hide
 */

Body of Frist Method:
{
    resetFlag(HAS_BIAS_UNCERTAINTY);
    mBiasUncertaintyNanos = Double.NaN;
}
Body of Second Method:
{
    resetFlag(HAS_BIAS_UNCERTAINTY);
}
------------------------
Find a silently evolved API code:android.hardware.usb.UsbDeviceConnection.close:COMMENT
Method Modifier: public      
Comment:/**
 * Releases all system resources related to the device.
 * Once the object is closed it cannot be used again.
 * The client must call {@link UsbManager#openDevice} again
 * to retrieve a new instance to reestablish communication with the device.
 */

Body of Frist Method:
{
    if (mNativeContext != 0) {
        native_close();
        mCloseGuard.close();
    }
}
Body of Second Method:
{
    synchronized (mLock) {
        if (isOpen()) {
            native_close();
            mCloseGuard.close();
        }
    }
}
------------------------
Find a silently evolved API code:android.app.NotificationChannel.dump:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    String redactedName = redacted ? TextUtils.trimToLengthWithEllipsis(mName, 3) : mName;
    String output = "NotificationChannel{" + "mId='" + mId + '\'' + ", mName=" + redactedName + ", mDescription=" + (!TextUtils.isEmpty(mDesc) ? "hasDescription " : "") + ", mImportance=" + mImportance + ", mBypassDnd=" + mBypassDnd + ", mLockscreenVisibility=" + mLockscreenVisibility + ", mSound=" + mSound + ", mLights=" + mLights + ", mLightColor=" + mLightColor + ", mVibration=" + Arrays.toString(mVibration) + ", mUserLockedFields=" + Integer.toHexString(mUserLockedFields) + ", mFgServiceShown=" + mFgServiceShown + ", mVibrationEnabled=" + mVibrationEnabled + ", mShowBadge=" + mShowBadge + ", mDeleted=" + mDeleted + ", mGroup='" + mGroup + '\'' + ", mAudioAttributes=" + mAudioAttributes + ", mBlockableSystem=" + mBlockableSystem + ", mAllowBubbles=" + mAllowBubbles + ", mImportanceLockedByOEM=" + mImportanceLockedByOEM + ", mImportanceLockedDefaultApp=" + mImportanceLockedDefaultApp + '}';
    pw.println(prefix + output);
}
Body of Second Method:
{
    String redactedName = redacted ? TextUtils.trimToLengthWithEllipsis(mName, 3) : mName;
    String output = "NotificationChannel{" + "mId='" + mId + '\'' + ", mName=" + redactedName + getFieldsString() + '}';
    pw.println(prefix + output);
}
------------------------
Find a silently evolved API code:android.net.LinkAddress.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Implement the Parcelable interface.
 */

Body of Frist Method:
{
    dest.writeByteArray(address.getAddress());
    dest.writeInt(prefixLength);
    dest.writeInt(this.flags);
    dest.writeInt(scope);
}
Body of Second Method:
{
    dest.writeByteArray(address.getAddress());
    dest.writeInt(prefixLength);
    dest.writeInt(this.flags);
    dest.writeInt(scope);
    dest.writeLong(deprecationTime);
    dest.writeLong(expirationTime);
}
------------------------
Find a silently evolved API code:android.media.tv.TvTrackInfo.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Creates a {@link TvTrackInfo} instance with the specified fields.
 *
 * @return The new {@link TvTrackInfo} instance
 */

Body of Frist Method:
{
    return new TvTrackInfo(mType, mId, mLanguage, mDescription, mAudioChannelCount, mAudioSampleRate, mVideoWidth, mVideoHeight, mVideoFrameRate, mVideoPixelAspectRatio, mVideoActiveFormatDescription, mExtra);
}
Body of Second Method:
{
    return new TvTrackInfo(mType, mId, mLanguage, mDescription, mEncoding, mEncrypted, mAudioChannelCount, mAudioSampleRate, mAudioDescription, mHardOfHearing, mSpokenSubtitle, mVideoWidth, mVideoHeight, mVideoFrameRate, mVideoPixelAspectRatio, mVideoActiveFormatDescription, mExtra);
}
------------------------
Find a silently evolved API code:android.app.servertransaction.LaunchActivityItem.obtain:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Obtain an instance initialized with provided params.
 */

Body of Frist Method:
{
    LaunchActivityItem instance = ObjectPool.obtain(LaunchActivityItem.class);
    if (instance == null) {
        instance = new LaunchActivityItem();
    }
    setValues(instance, intent, ident, info, curConfig, overrideConfig, compatInfo, referrer, voiceInteractor, procState, state, persistentState, pendingResults, pendingNewIntents, isForward, profilerInfo, assistToken);
    return instance;
}
Body of Second Method:
{
    LaunchActivityItem instance = ObjectPool.obtain(LaunchActivityItem.class);
    if (instance == null) {
        instance = new LaunchActivityItem();
    }
    setValues(instance, intent, ident, info, curConfig, overrideConfig, compatInfo, referrer, voiceInteractor, procState, state, persistentState, pendingResults, pendingNewIntents, isForward, profilerInfo, assistToken, fixedRotationAdjustments);
    return instance;
}
------------------------
Find a silently evolved API code:android.text.format.TimeFormatter.format:COMMENT
Method Modifier: public      
Comment:/**
 * Format the specified {@code wallTime} using {@code pattern}. The output is returned.
 */

Body of Frist Method:
{
    try {
        StringBuilder stringBuilder = new StringBuilder();
        outputBuilder = stringBuilder;
        // This uses the US locale because number localization is handled separately (see below)
        // and locale sensitive strings are output directly using outputBuilder.
        numberFormatter = new Formatter(stringBuilder, Locale.US);
        formatInternal(pattern, wallTime, zoneInfo);
        String result = stringBuilder.toString();
        // in ASCII and not localized.
        if (localeData.zeroDigit != '0') {
            result = localizeDigits(result);
        }
        return result;
    } finally {
        outputBuilder = null;
        numberFormatter = null;
    }
}
Body of Second Method:
{
    try {
        StringBuilder stringBuilder = new StringBuilder();
        outputBuilder = stringBuilder;
        // This uses the US locale because number localization is handled separately (see below)
        // and locale sensitive strings are output directly using outputBuilder.
        numberFormatter = new Formatter(stringBuilder, Locale.US);
        formatInternal(pattern, wallTime, zoneInfo);
        String result = stringBuilder.toString();
        // as being in ASCII and not localized.
        return localizeDigits(result);
    } finally {
        outputBuilder = null;
        numberFormatter = null;
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiEnterpriseConfig.copyFrom:COMMENT
Method Modifier: private     
Comment:/**
 * Copy over the contents of the source WifiEnterpriseConfig object over to this object.
 *
 * @param source Source WifiEnterpriseConfig object.
 * @param ignoreMaskedPassword Set to true to ignore masked password field, false otherwise.
 * @param mask if |ignoreMaskedPassword| is set, check if the incoming password field is set
 * to this value.
 */

Body of Frist Method:
{
    for (String key : source.mFields.keySet()) {
        if (ignoreMaskedPassword && key.equals(PASSWORD_KEY) && TextUtils.equals(source.mFields.get(key), mask)) {
            continue;
        }
        mFields.put(key, source.mFields.get(key));
    }
    if (source.mCaCerts != null) {
        mCaCerts = Arrays.copyOf(source.mCaCerts, source.mCaCerts.length);
    } else {
        mCaCerts = null;
    }
    mClientPrivateKey = source.mClientPrivateKey;
    if (source.mClientCertificateChain != null) {
        mClientCertificateChain = Arrays.copyOf(source.mClientCertificateChain, source.mClientCertificateChain.length);
    } else {
        mClientCertificateChain = null;
    }
    mEapMethod = source.mEapMethod;
    mPhase2Method = source.mPhase2Method;
    mIsAppInstalledDeviceKeyAndCert = source.mIsAppInstalledDeviceKeyAndCert;
    mIsAppInstalledCaCert = source.mIsAppInstalledCaCert;
}
Body of Second Method:
{
    for (String key : source.mFields.keySet()) {
        if (ignoreMaskedPassword && key.equals(PASSWORD_KEY) && TextUtils.equals(source.mFields.get(key), mask)) {
            continue;
        }
        mFields.put(key, source.mFields.get(key));
    }
    if (source.mCaCerts != null) {
        mCaCerts = Arrays.copyOf(source.mCaCerts, source.mCaCerts.length);
    } else {
        mCaCerts = null;
    }
    mClientPrivateKey = source.mClientPrivateKey;
    if (source.mClientCertificateChain != null) {
        mClientCertificateChain = Arrays.copyOf(source.mClientCertificateChain, source.mClientCertificateChain.length);
    } else {
        mClientCertificateChain = null;
    }
    mEapMethod = source.mEapMethod;
    mPhase2Method = source.mPhase2Method;
    mIsAppInstalledDeviceKeyAndCert = source.mIsAppInstalledDeviceKeyAndCert;
    mIsAppInstalledCaCert = source.mIsAppInstalledCaCert;
    mOcsp = source.mOcsp;
}
------------------------
Find a silently evolved API code:android.media.audiopolicy.AudioMixingRule.equals:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (this == o)
        return true;
    if (o == null || getClass() != o.getClass())
        return false;
    final AudioMixingRule that = (AudioMixingRule) o;
    return (this.mTargetMixType == that.mTargetMixType) && (areCriteriaEquivalent(this.mCriteria, that.mCriteria) && this.mAllowPrivilegedPlaybackCapture == that.mAllowPrivilegedPlaybackCapture);
}
Body of Second Method:
{
    if (this == o)
        return true;
    if (o == null || getClass() != o.getClass())
        return false;
    final AudioMixingRule that = (AudioMixingRule) o;
    return (this.mTargetMixType == that.mTargetMixType) && (areCriteriaEquivalent(this.mCriteria, that.mCriteria) && this.mAllowPrivilegedPlaybackCapture == that.mAllowPrivilegedPlaybackCapture && this.mVoiceCommunicationCaptureAllowed == that.mVoiceCommunicationCaptureAllowed);
}
------------------------
Find a silently evolved API code:android.net.wifi.aware.WifiAwareNetworkSpecifier.hashCode:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return Objects.hash(type, role, clientId, sessionId, peerId, Arrays.hashCode(peerMac), Arrays.hashCode(pmk), passphrase, port, transportProtocol, requestorUid);
}
Body of Second Method:
{
    return Objects.hash(type, role, clientId, sessionId, peerId, Arrays.hashCode(peerMac), Arrays.hashCode(pmk), passphrase, port, transportProtocol);
}
------------------------
Find a silently evolved API code:android.media.audiopolicy.AudioVolumeGroupChangeHandler.init:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Initialization
 */

Body of Frist Method:
{
    synchronized (this) {
        if (mHandler != null) {
            return;
        }
        // create a new thread for our new event handler
        mHandlerThread = new HandlerThread(TAG);
        mHandlerThread.start();
        if (mHandlerThread.getLooper() == null) {
            mHandler = null;
            return;
        }
        mHandler = new Handler(mHandlerThread.getLooper()) {

            @Override
            public void handleMessage(Message msg) {
                ArrayList<AudioManager.VolumeGroupCallback> listeners;
                synchronized (this) {
                    if (msg.what == AUDIOVOLUMEGROUP_EVENT_NEW_LISTENER) {
                        listeners = new ArrayList<AudioManager.VolumeGroupCallback>();
                        if (mListeners.contains(msg.obj)) {
                            listeners.add((AudioManager.VolumeGroupCallback) msg.obj);
                        }
                    } else {
                        listeners = mListeners;
                    }
                }
                if (listeners.isEmpty()) {
                    return;
                }
                switch(msg.what) {
                    case AUDIOVOLUMEGROUP_EVENT_VOLUME_CHANGED:
                        for (int i = 0; i < listeners.size(); i++) {
                            listeners.get(i).onAudioVolumeGroupChanged((int) msg.arg1, (int) msg.arg2);
                        }
                        break;
                    default:
                        break;
                }
            }
        };
        native_setup(new WeakReference<AudioVolumeGroupChangeHandler>(this));
    }
}
Body of Second Method:
{
    synchronized (this) {
        if (mHandler != null) {
            return;
        }
        // create a new thread for our new event handler
        mHandlerThread = new HandlerThread(TAG);
        mHandlerThread.start();
        if (mHandlerThread.getLooper() == null) {
            mHandler = null;
            return;
        }
        mHandler = new Handler(mHandlerThread.getLooper()) {

            @Override
            public void handleMessage(Message msg) {
                ArrayList<AudioManager.VolumeGroupCallback> listeners;
                synchronized (this) {
                    if (msg.what == AUDIOVOLUMEGROUP_EVENT_NEW_LISTENER) {
                        listeners = new ArrayList<AudioManager.VolumeGroupCallback>();
                        if (mListeners.contains(msg.obj)) {
                            listeners.add((AudioManager.VolumeGroupCallback) msg.obj);
                        }
                    } else {
                        listeners = (ArrayList<AudioManager.VolumeGroupCallback>) mListeners.clone();
                    }
                }
                if (listeners.isEmpty()) {
                    return;
                }
                switch(msg.what) {
                    case AUDIOVOLUMEGROUP_EVENT_VOLUME_CHANGED:
                        for (int i = 0; i < listeners.size(); i++) {
                            listeners.get(i).onAudioVolumeGroupChanged((int) msg.arg1, (int) msg.arg2);
                        }
                        break;
                    default:
                        break;
                }
            }
        };
        native_setup(new WeakReference<AudioVolumeGroupChangeHandler>(this));
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothA2dp.setOptionalCodecsEnabled:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets a persistent preference for whether a given device should have optional codecs enabled.
 *
 * @param device The device to set this preference for.
 * @param value Whether the optional codecs should be enabled for this device.  This should be
 * one of OPTIONAL_CODECS_PREF_UNKNOWN, OPTIONAL_CODECS_PREF_ENABLED, or
 * OPTIONAL_CODECS_PREF_DISABLED.
 * @hide
 */

Body of Frist Method:
{
    try {
        if (value != BluetoothA2dp.OPTIONAL_CODECS_PREF_UNKNOWN && value != BluetoothA2dp.OPTIONAL_CODECS_PREF_DISABLED && value != BluetoothA2dp.OPTIONAL_CODECS_PREF_ENABLED) {
            Log.e(TAG, "Invalid value passed to setOptionalCodecsEnabled: " + value);
            return;
        }
        final IBluetoothA2dp service = getService();
        if (service != null && isEnabled() && isValidDevice(device)) {
            service.setOptionalCodecsEnabled(device, value);
        }
        if (service == null)
            Log.w(TAG, "Proxy not attached to service");
        return;
    } catch (RemoteException e) {
        Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
        return;
    }
}
Body of Second Method:
{
    verifyDeviceNotNull(device, "setOptionalCodecsEnabled");
    try {
        if (value != BluetoothA2dp.OPTIONAL_CODECS_PREF_UNKNOWN && value != BluetoothA2dp.OPTIONAL_CODECS_PREF_DISABLED && value != BluetoothA2dp.OPTIONAL_CODECS_PREF_ENABLED) {
            Log.e(TAG, "Invalid value passed to setOptionalCodecsEnabled: " + value);
            return;
        }
        final IBluetoothA2dp service = getService();
        if (service != null && isEnabled() && isValidDevice(device)) {
            service.setOptionalCodecsEnabled(device, value);
        }
        if (service == null)
            Log.w(TAG, "Proxy not attached to service");
        return;
    } catch (RemoteException e) {
        Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
        return;
    }
}
------------------------
Find a silently evolved API code:android.os.SystemClock.setCurrentTimeMillis:COMMENT
Method Modifier: public      static      
Comment:/**
 * Sets the current wall time, in milliseconds.  Requires the calling
 * process to have appropriate permissions.
 *
 * @return if the clock was successfully set to the specified time.
 */

Body of Frist Method:
{
    final IAlarmManager mgr = IAlarmManager.Stub.asInterface(ServiceManager.getService(Context.ALARM_SERVICE));
    if (mgr == null) {
        return false;
    }
    try {
        return mgr.setTime(millis);
    } catch (RemoteException e) {
        Slog.e(TAG, "Unable to set RTC", e);
    } catch (SecurityException e) {
        Slog.e(TAG, "Unable to set RTC", e);
    }
    return false;
}
Body of Second Method:
{
    final IAlarmManager mgr = IAlarmManager.Stub.asInterface(ServiceManager.getService(Context.ALARM_SERVICE));
    if (mgr == null) {
        Slog.e(TAG, "Unable to set RTC: mgr == null");
        return false;
    }
    try {
        return mgr.setTime(millis);
    } catch (RemoteException e) {
        Slog.e(TAG, "Unable to set RTC", e);
    } catch (SecurityException e) {
        Slog.e(TAG, "Unable to set RTC", e);
    }
    return false;
}
------------------------
Find a silently evolved API code:android.media.MediaMuxer.setLocation:COMMENT
Method Modifier: public      
Comment:/**
 * Set and store the geodata (latitude and longitude) in the output file.
 * This method should be called before {@link #start}. The geodata is stored
 * in udta box if the output format is
 * {@link OutputFormat#MUXER_OUTPUT_MPEG_4}, and is ignored for other output
 * formats. The geodata is stored according to ISO-6709 standard.
 *
 * @param latitude Latitude in degrees. Its value must be in the range [-90,
 * 90].
 * @param longitude Longitude in degrees. Its value must be in the range
 * [-180, 180].
 * @throws IllegalArgumentException If the given latitude or longitude is out
 * of range.
 * @throws IllegalStateException If this method is called after {@link #start}.
 */

Body of Frist Method:
{
    int latitudex10000 = (int) (latitude * 10000 + 0.5);
    int longitudex10000 = (int) (longitude * 10000 + 0.5);
    if (latitudex10000 > 900000 || latitudex10000 < -900000) {
        String msg = "Latitude: " + latitude + " out of range.";
        throw new IllegalArgumentException(msg);
    }
    if (longitudex10000 > 1800000 || longitudex10000 < -1800000) {
        String msg = "Longitude: " + longitude + " out of range";
        throw new IllegalArgumentException(msg);
    }
    if (mState == MUXER_STATE_INITIALIZED && mNativeObject != 0) {
        nativeSetLocation(mNativeObject, latitudex10000, longitudex10000);
    } else {
        throw new IllegalStateException("Can't set location due to wrong state.");
    }
}
Body of Second Method:
{
    int latitudex10000 = (int) (latitude * 10000 + 0.5);
    int longitudex10000 = (int) (longitude * 10000 + 0.5);
    if (latitudex10000 > 900000 || latitudex10000 < -900000) {
        String msg = "Latitude: " + latitude + " out of range.";
        throw new IllegalArgumentException(msg);
    }
    if (longitudex10000 > 1800000 || longitudex10000 < -1800000) {
        String msg = "Longitude: " + longitude + " out of range";
        throw new IllegalArgumentException(msg);
    }
    if (mState == MUXER_STATE_INITIALIZED && mNativeObject != 0) {
        nativeSetLocation(mNativeObject, latitudex10000, longitudex10000);
    } else {
        throw new IllegalStateException("Can't set location due to wrong state(" + convertMuxerStateCodeToString(mState) + ")");
    }
}
------------------------
Find a silently evolved API code:android.graphics.Outline.setOval:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the outline to the oval defined by input rect.
 */

Body of Frist Method:
{
    if (left >= right || top >= bottom) {
        setEmpty();
        return;
    }
    if ((bottom - top) == (right - left)) {
        // represent circle as round rect, for efficiency, and to enable clipping
        setRoundRect(left, top, right, bottom, (bottom - top) / 2.0f);
        return;
    }
    if (mPath == null) {
        mPath = new Path();
    } else {
        mPath.rewind();
    }
    mMode = MODE_CONVEX_PATH;
    mPath.addOval(left, top, right, bottom, Path.Direction.CW);
    mRect.setEmpty();
    mRadius = RADIUS_UNDEFINED;
}
Body of Second Method:
{
    if (left >= right || top >= bottom) {
        setEmpty();
        return;
    }
    if ((bottom - top) == (right - left)) {
        // represent circle as round rect, for efficiency, and to enable clipping
        setRoundRect(left, top, right, bottom, (bottom - top) / 2.0f);
        return;
    }
    if (mPath == null) {
        mPath = new Path();
    } else {
        mPath.rewind();
    }
    mMode = MODE_PATH;
    mPath.addOval(left, top, right, bottom, Path.Direction.CW);
    mRect.setEmpty();
    mRadius = RADIUS_UNDEFINED;
}
------------------------
Find a silently evolved API code:android.app.WindowConfiguration.canResizeTask:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns true if the tasks associated with this window configuration can be resized
 * independently of their parent container.
 * @hide
 */

Body of Frist Method:
{
    return mWindowingMode == WINDOWING_MODE_FREEFORM;
}
Body of Second Method:
{
    return mWindowingMode == WINDOWING_MODE_FREEFORM || mWindowingMode == WINDOWING_MODE_MULTI_WINDOW;
}
------------------------
Find a silently evolved API code:android.content.pm.ShortcutManager.getPinnedShortcuts:COMMENT
Method Modifier: public      
Comment:/**
 * Return all pinned shortcuts from the caller app.
 *
 * <p>This API is intended to be used for examining what shortcuts are currently published.
 * Re-publishing returned {@link ShortcutInfo}s via APIs such as
 * {@link #setDynamicShortcuts(List)} may cause loss of information such as icons.
 *
 * @throws IllegalStateException when the user is locked.
 */

Body of Frist Method:
{
    try {
        return mService.getPinnedShortcuts(mContext.getPackageName(), injectMyUserId()).getList();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    try {
        return mService.getShortcuts(mContext.getPackageName(), FLAG_MATCH_PINNED, injectMyUserId()).getList();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.telephony.ims.ImsCallSessionListener.callSessionConferenceExtendFailed:COMMENT
Method Modifier: public      
Comment:/**
 * The previous conference extension has failed.
 *
 * @param reasonInfo {@link ImsReasonInfo} containing the detailed reason of the conference
 * extension failure.
 */

Body of Frist Method:
{
    try {
        mListener.callSessionConferenceExtendFailed(reasonInfo);
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}
Body of Second Method:
{
    try {
        mListener.callSessionConferenceExtendFailed(reasonInfo);
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.widget.ViewAnimator.initViewAnimator:COMMENT
Method Modifier: private     
Comment:/**
 * Initialize this {@link ViewAnimator}, possibly setting
 * {@link #setMeasureAllChildren(boolean)} based on {@link FrameLayout} flags.
 */

Body of Frist Method:
{
    if (attrs == null) {
        // For compatibility, always measure children when undefined.
        mMeasureAllChildren = true;
        return;
    }
    // For compatibility, default to measure children, but allow XML
    // attribute to override.
    final TypedArray a = context.obtainStyledAttributes(attrs, com.android.internal.R.styleable.FrameLayout);
    final boolean measureAllChildren = a.getBoolean(com.android.internal.R.styleable.FrameLayout_measureAllChildren, true);
    setMeasureAllChildren(measureAllChildren);
    a.recycle();
}
Body of Second Method:
{
    if (attrs == null) {
        // For compatibility, always measure children when undefined.
        mMeasureAllChildren = true;
        return;
    }
    // For compatibility, default to measure children, but allow XML
    // attribute to override.
    final TypedArray a = context.obtainStyledAttributes(attrs, com.android.internal.R.styleable.FrameLayout);
    saveAttributeDataForStyleable(context, com.android.internal.R.styleable.FrameLayout, attrs, a, 0, 0);
    final boolean measureAllChildren = a.getBoolean(com.android.internal.R.styleable.FrameLayout_measureAllChildren, true);
    setMeasureAllChildren(measureAllChildren);
    a.recycle();
}
------------------------
Find a silently evolved API code:android.media.session.MediaController.setVolumeTo:COMMENT
Method Modifier: public      
Comment:/**
 * Set the volume of the output this session is playing on. The command will
 * be ignored if it does not support
 * {@link VolumeProvider#VOLUME_CONTROL_ABSOLUTE}. The flags in
 * {@link AudioManager} may be used to affect the handling.
 *
 * @see #getPlaybackInfo()
 * @param value The value to set it to, between 0 and the reported max.
 * @param flags Flags from {@link AudioManager} to include with the volume
 * request.
 */

Body of Frist Method:
{
    try {
        // Note: Need both package name and OP package name. Package name is used for
        // RemoteUserInfo, and OP package name is used for AudioService's internal
        // AppOpsManager usages.
        mSessionBinder.setVolumeTo(mContext.getPackageName(), mContext.getOpPackageName(), mCbStub, value, flags);
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling setVolumeTo.", e);
    }
}
Body of Second Method:
{
    try {
        // Note: Need both package name and OP package name. Package name is used for
        // RemoteUserInfo, and OP package name is used for AudioService's internal
        // AppOpsManager usages.
        mSessionBinder.setVolumeTo(mContext.getPackageName(), mContext.getOpPackageName(), value, flags);
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling setVolumeTo.", e);
    }
}
------------------------
Find a silently evolved API code:android.telecom.GatewayInfo.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    destination.writeString(mGatewayProviderPackageName);
    mGatewayAddress.writeToParcel(destination, 0);
    mOriginalAddress.writeToParcel(destination, 0);
}
Body of Second Method:
{
    destination.writeString(mGatewayProviderPackageName);
    Uri.writeToParcel(destination, mGatewayAddress);
    Uri.writeToParcel(destination, mOriginalAddress);
}
------------------------
Find a silently evolved API code:android.content.ContentProviderClient.delete:COMMENT
Method Modifier: public      
Comment:/**
 * See {@link ContentProvider#delete ContentProvider.delete}
 */

Body of Frist Method:
{
    Preconditions.checkNotNull(url, "url");
    beforeRemote();
    try {
        return mContentProvider.delete(mPackageName, url, selection, selectionArgs);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}
Body of Second Method:
{
    return delete(url, ContentResolver.createSqlQueryBundle(selection, selectionArgs));
}
------------------------
Find a silently evolved API code:android.telephony.ims.ImsCallSessionListener.callSessionTerminated:COMMENT
Method Modifier: public      
Comment:/**
 * The IMS call session has been terminated.
 *
 * @param reasonInfo {@link ImsReasonInfo} detailing the reason of the session termination.
 */

Body of Frist Method:
{
    try {
        mListener.callSessionTerminated(reasonInfo);
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}
Body of Second Method:
{
    try {
        mListener.callSessionTerminated(reasonInfo);
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.telephony.ims.ImsCallSessionListener.callSessionUssdMessageReceived:COMMENT
Method Modifier: public      
Comment:/**
 * The IMS call session has received a Ussd message.
 *
 * @param mode The mode of the USSD message, either
 * {@link ImsCallSessionImplBase#USSD_MODE_NOTIFY} or
 * {@link ImsCallSessionImplBase#USSD_MODE_REQUEST}.
 * @param ussdMessage The USSD message.
 */

Body of Frist Method:
{
    try {
        mListener.callSessionUssdMessageReceived(mode, ussdMessage);
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}
Body of Second Method:
{
    try {
        mListener.callSessionUssdMessageReceived(mode, ussdMessage);
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.service.autofill.augmented.Helper.logResponse:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Logs a {@code MetricsEvent.AUTOFILL_AUGMENTED_RESPONSE} event.
 */

Body of Frist Method:
{
    final LogMaker log = new LogMaker(MetricsEvent.AUTOFILL_AUGMENTED_RESPONSE).setType(type).setComponentName(componentName).addTaggedData(MetricsEvent.FIELD_AUTOFILL_SESSION_ID, mSessionId).addTaggedData(MetricsEvent.FIELD_AUTOFILL_SERVICE, servicePackageName).addTaggedData(MetricsEvent.FIELD_AUTOFILL_DURATION, durationMs);
    // felipeal: tmp
    System.out.println("LOGGGO: " + log.getEntries());
    sMetricsLogger.write(log);
}
Body of Second Method:
{
    final LogMaker log = new LogMaker(MetricsEvent.AUTOFILL_AUGMENTED_RESPONSE).setType(type).setComponentName(componentName).addTaggedData(MetricsEvent.FIELD_AUTOFILL_SESSION_ID, mSessionId).addTaggedData(MetricsEvent.FIELD_AUTOFILL_SERVICE, servicePackageName).addTaggedData(MetricsEvent.FIELD_AUTOFILL_DURATION, durationMs);
    sMetricsLogger.write(log);
}
------------------------
Find a silently evolved API code:android.content.ContentProviderClient.getStreamTypes:COMMENT
Method Modifier: public      
Comment:/**
 * See {@link ContentProvider#getStreamTypes ContentProvider.getStreamTypes}
 */

Body of Frist Method:
{
    Preconditions.checkNotNull(url, "url");
    Preconditions.checkNotNull(mimeTypeFilter, "mimeTypeFilter");
    beforeRemote();
    try {
        return mContentProvider.getStreamTypes(url, mimeTypeFilter);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}
Body of Second Method:
{
    Objects.requireNonNull(url, "url");
    Objects.requireNonNull(mimeTypeFilter, "mimeTypeFilter");
    beforeRemote();
    try {
        return mContentProvider.getStreamTypes(url, mimeTypeFilter);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiNetworkSuggestion.Builder.buildWifiConfiguration:COMMENT
Method Modifier: private     
Comment:/**
 * Helper method to build WifiConfiguration object from the builder.
 * @return Instance of {@link WifiConfiguration}.
 */

Body of Frist Method:
{
    final WifiConfiguration wifiConfiguration = new WifiConfiguration();
    // WifiConfiguration.SSID needs quotes around unicode SSID.
    wifiConfiguration.SSID = "\"" + mSsid + "\"";
    if (mBssid != null) {
        wifiConfiguration.BSSID = mBssid.toString();
    }
    setSecurityParamsInWifiConfiguration(wifiConfiguration);
    wifiConfiguration.hiddenSSID = mIsHiddenSSID;
    wifiConfiguration.priority = mPriority;
    wifiConfiguration.meteredOverride = mIsMetered ? WifiConfiguration.METERED_OVERRIDE_METERED : WifiConfiguration.METERED_OVERRIDE_NONE;
    return wifiConfiguration;
}
Body of Second Method:
{
    final WifiConfiguration wifiConfiguration = new WifiConfiguration();
    // WifiConfiguration.SSID needs quotes around unicode SSID.
    wifiConfiguration.SSID = "\"" + mSsid + "\"";
    if (mBssid != null) {
        wifiConfiguration.BSSID = mBssid.toString();
    }
    setSecurityParamsInWifiConfiguration(wifiConfiguration);
    wifiConfiguration.hiddenSSID = mIsHiddenSSID;
    wifiConfiguration.priority = mPriority;
    wifiConfiguration.meteredOverride = mMeteredOverride;
    wifiConfiguration.carrierId = mCarrierId;
    wifiConfiguration.trusted = !mIsNetworkUntrusted;
    return wifiConfiguration;
}
------------------------
Find a silently evolved API code:android.os.Debug.MemoryInfo.getOtherLabel:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    switch(which) {
        case OTHER_DALVIK_OTHER:
            return "Dalvik Other";
        case OTHER_STACK:
            return "Stack";
        case OTHER_CURSOR:
            return "Cursor";
        case OTHER_ASHMEM:
            return "Ashmem";
        case OTHER_GL_DEV:
            return "Gfx dev";
        case OTHER_UNKNOWN_DEV:
            return "Other dev";
        case OTHER_SO:
            return ".so mmap";
        case OTHER_JAR:
            return ".jar mmap";
        case OTHER_APK:
            return ".apk mmap";
        case OTHER_TTF:
            return ".ttf mmap";
        case OTHER_DEX:
            return ".dex mmap";
        case OTHER_OAT:
            return ".oat mmap";
        case OTHER_ART:
            return ".art mmap";
        case OTHER_UNKNOWN_MAP:
            return "Other mmap";
        case OTHER_GRAPHICS:
            return "EGL mtrack";
        case OTHER_GL:
            return "GL mtrack";
        case OTHER_OTHER_MEMTRACK:
            return "Other mtrack";
        case OTHER_DALVIK_NORMAL:
            return ".Heap";
        case OTHER_DALVIK_LARGE:
            return ".LOS";
        case OTHER_DALVIK_ZYGOTE:
            return ".Zygote";
        case OTHER_DALVIK_NON_MOVING:
            return ".NonMoving";
        case OTHER_DALVIK_OTHER_LINEARALLOC:
            return ".LinearAlloc";
        case OTHER_DALVIK_OTHER_ACCOUNTING:
            return ".GC";
        case OTHER_DALVIK_OTHER_CODE_CACHE:
            return ".JITCache";
        case OTHER_DALVIK_OTHER_COMPILER_METADATA:
            return ".CompilerMetadata";
        case OTHER_DALVIK_OTHER_INDIRECT_REFERENCE_TABLE:
            return ".IndirectRef";
        case OTHER_DEX_BOOT_VDEX:
            return ".Boot vdex";
        case OTHER_DEX_APP_DEX:
            return ".App dex";
        case OTHER_DEX_APP_VDEX:
            return ".App vdex";
        case OTHER_ART_APP:
            return ".App art";
        case OTHER_ART_BOOT:
            return ".Boot art";
        default:
            return "????";
    }
}
Body of Second Method:
{
    switch(which) {
        case OTHER_DALVIK_OTHER:
            return "Dalvik Other";
        case OTHER_STACK:
            return "Stack";
        case OTHER_CURSOR:
            return "Cursor";
        case OTHER_ASHMEM:
            return "Ashmem";
        case OTHER_GL_DEV:
            return "Gfx dev";
        case OTHER_UNKNOWN_DEV:
            return "Other dev";
        case OTHER_SO:
            return ".so mmap";
        case OTHER_JAR:
            return ".jar mmap";
        case OTHER_APK:
            return ".apk mmap";
        case OTHER_TTF:
            return ".ttf mmap";
        case OTHER_DEX:
            return ".dex mmap";
        case OTHER_OAT:
            return ".oat mmap";
        case OTHER_ART:
            return ".art mmap";
        case OTHER_UNKNOWN_MAP:
            return "Other mmap";
        case OTHER_GRAPHICS:
            return "EGL mtrack";
        case OTHER_GL:
            return "GL mtrack";
        case OTHER_OTHER_MEMTRACK:
            return "Other mtrack";
        case OTHER_DALVIK_NORMAL:
            return ".Heap";
        case OTHER_DALVIK_LARGE:
            return ".LOS";
        case OTHER_DALVIK_ZYGOTE:
            return ".Zygote";
        case OTHER_DALVIK_NON_MOVING:
            return ".NonMoving";
        case OTHER_DALVIK_OTHER_LINEARALLOC:
            return ".LinearAlloc";
        case OTHER_DALVIK_OTHER_ACCOUNTING:
            return ".GC";
        case OTHER_DALVIK_OTHER_ZYGOTE_CODE_CACHE:
            return ".ZygoteJIT";
        case OTHER_DALVIK_OTHER_APP_CODE_CACHE:
            return ".AppJIT";
        case OTHER_DALVIK_OTHER_COMPILER_METADATA:
            return ".CompilerMetadata";
        case OTHER_DALVIK_OTHER_INDIRECT_REFERENCE_TABLE:
            return ".IndirectRef";
        case OTHER_DEX_BOOT_VDEX:
            return ".Boot vdex";
        case OTHER_DEX_APP_DEX:
            return ".App dex";
        case OTHER_DEX_APP_VDEX:
            return ".App vdex";
        case OTHER_ART_APP:
            return ".App art";
        case OTHER_ART_BOOT:
            return ".Boot art";
        default:
            return "????";
    }
}
------------------------
Find a silently evolved API code:android.hardware.camera2.impl.CameraMetadataNative.getEntryCount:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return nativeGetEntryCount();
}
Body of Second Method:
{
    return nativeGetEntryCount(mMetadataPtr);
}
------------------------
Find a silently evolved API code:android.app.usage.UsageEvents.writeEventToParcel:COMMENT
Method Modifier: private     
Comment:/**
 * Writes a single event to the parcel. Modify this when updating {@link Event}.
 */

Body of Frist Method:
{
    final int packageIndex;
    if (event.mPackage != null) {
        packageIndex = findStringIndex(event.mPackage);
    } else {
        packageIndex = -1;
    }
    final int classIndex;
    if (event.mClass != null) {
        classIndex = findStringIndex(event.mClass);
    } else {
        classIndex = -1;
    }
    final int taskRootPackageIndex;
    if (mIncludeTaskRoots && event.mTaskRootPackage != null) {
        taskRootPackageIndex = findStringIndex(event.mTaskRootPackage);
    } else {
        taskRootPackageIndex = -1;
    }
    final int taskRootClassIndex;
    if (mIncludeTaskRoots && event.mTaskRootClass != null) {
        taskRootClassIndex = findStringIndex(event.mTaskRootClass);
    } else {
        taskRootClassIndex = -1;
    }
    p.writeInt(packageIndex);
    p.writeInt(classIndex);
    p.writeInt(event.mInstanceId);
    p.writeInt(taskRootPackageIndex);
    p.writeInt(taskRootClassIndex);
    p.writeInt(event.mEventType);
    p.writeLong(event.mTimeStamp);
    switch(event.mEventType) {
        case Event.CONFIGURATION_CHANGE:
            event.mConfiguration.writeToParcel(p, flags);
            break;
        case Event.SHORTCUT_INVOCATION:
            p.writeString(event.mShortcutId);
            break;
        case Event.CHOOSER_ACTION:
            p.writeString(event.mAction);
            p.writeString(event.mContentType);
            p.writeStringArray(event.mContentAnnotations);
            break;
        case Event.STANDBY_BUCKET_CHANGED:
            p.writeInt(event.mBucketAndReason);
            break;
        case Event.NOTIFICATION_INTERRUPTION:
            p.writeString(event.mNotificationChannelId);
            break;
    }
    p.writeInt(event.mFlags);
}
Body of Second Method:
{
    final int packageIndex;
    if (event.mPackage != null) {
        packageIndex = findStringIndex(event.mPackage);
    } else {
        packageIndex = -1;
    }
    final int classIndex;
    if (event.mClass != null) {
        classIndex = findStringIndex(event.mClass);
    } else {
        classIndex = -1;
    }
    final int taskRootPackageIndex;
    if (mIncludeTaskRoots && event.mTaskRootPackage != null) {
        taskRootPackageIndex = findStringIndex(event.mTaskRootPackage);
    } else {
        taskRootPackageIndex = -1;
    }
    final int taskRootClassIndex;
    if (mIncludeTaskRoots && event.mTaskRootClass != null) {
        taskRootClassIndex = findStringIndex(event.mTaskRootClass);
    } else {
        taskRootClassIndex = -1;
    }
    p.writeInt(packageIndex);
    p.writeInt(classIndex);
    p.writeInt(event.mInstanceId);
    p.writeInt(taskRootPackageIndex);
    p.writeInt(taskRootClassIndex);
    p.writeInt(event.mEventType);
    p.writeLong(event.mTimeStamp);
    switch(event.mEventType) {
        case Event.CONFIGURATION_CHANGE:
            event.mConfiguration.writeToParcel(p, flags);
            break;
        case Event.SHORTCUT_INVOCATION:
            p.writeString(event.mShortcutId);
            break;
        case Event.CHOOSER_ACTION:
            p.writeString(event.mAction);
            p.writeString(event.mContentType);
            p.writeStringArray(event.mContentAnnotations);
            break;
        case Event.STANDBY_BUCKET_CHANGED:
            p.writeInt(event.mBucketAndReason);
            break;
        case Event.NOTIFICATION_INTERRUPTION:
            p.writeString(event.mNotificationChannelId);
            break;
        case Event.LOCUS_ID_SET:
            p.writeString(event.mLocusId);
            break;
    }
    p.writeInt(event.mFlags);
}
------------------------
Find a silently evolved API code:android.media.MediaMuxer.setOrientationHint:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the orientation hint for output video playback.
 * <p>This method should be called before {@link #start}. Calling this
 * method will not rotate the video frame when muxer is generating the file,
 * but add a composition matrix containing the rotation angle in the output
 * video if the output format is
 * {@link OutputFormat#MUXER_OUTPUT_MPEG_4} so that a video player can
 * choose the proper orientation for playback. Note that some video players
 * may choose to ignore the composition matrix in a video during playback.
 * By default, the rotation degree is 0.</p>
 * @param degrees the angle to be rotated clockwise in degrees.
 * The supported angles are 0, 90, 180, and 270 degrees.
 * @throws IllegalArgumentException if degree is not supported.
 * @throws IllegalStateException If this method is called after {@link #start}.
 */

Body of Frist Method:
{
    if (degrees != 0 && degrees != 90 && degrees != 180 && degrees != 270) {
        throw new IllegalArgumentException("Unsupported angle: " + degrees);
    }
    if (mState == MUXER_STATE_INITIALIZED) {
        nativeSetOrientationHint(mNativeObject, degrees);
    } else {
        throw new IllegalStateException("Can't set rotation degrees due" + " to wrong state.");
    }
}
Body of Second Method:
{
    if (degrees != 0 && degrees != 90 && degrees != 180 && degrees != 270) {
        throw new IllegalArgumentException("Unsupported angle: " + degrees);
    }
    if (mState == MUXER_STATE_INITIALIZED) {
        nativeSetOrientationHint(mNativeObject, degrees);
    } else {
        throw new IllegalStateException("Can't set rotation degrees due" + " to wrong state(" + convertMuxerStateCodeToString(mState) + ")");
    }
}
------------------------
Find a silently evolved API code:android.telephony.ims.ImsCallSessionListener.callSessionUpdateFailed:COMMENT
Method Modifier: public      
Comment:/**
 * The IMS call session profile update has failed.
 *
 * @param reasonInfo {@link ImsReasonInfo} containing a reason for the session update failure.
 */

Body of Frist Method:
{
    try {
        mListener.callSessionUpdateFailed(reasonInfo);
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}
Body of Second Method:
{
    try {
        mListener.callSessionUpdateFailed(reasonInfo);
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.hardware.display.AmbientDisplayConfiguration.enabled:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * {@hide}
 */

Body of Frist Method:
{
    return pulseOnNotificationEnabled(user) || pulseOnLongPressEnabled(user) || alwaysOnEnabled(user) || wakeScreenGestureEnabled(user) || pickupGestureEnabled(user) || tapGestureEnabled(user) || doubleTapGestureEnabled(user);
}
Body of Second Method:
{
    return pulseOnNotificationEnabled(user) || pulseOnLongPressEnabled(user) || alwaysOnEnabled(user) || wakeLockScreenGestureEnabled(user) || wakeDisplayGestureEnabled(user) || pickupGestureEnabled(user) || tapGestureEnabled(user) || doubleTapGestureEnabled(user);
}
------------------------
Find a silently evolved API code:android.net.LinkAddress.init:COMMENT
Method Modifier: private     
Comment:/**
 * Utility function for the constructors.
 */

Body of Frist Method:
{
    if (address == null || address.isMulticastAddress() || prefixLength < 0 || (address instanceof Inet4Address && prefixLength > 32) || (prefixLength > 128)) {
        throw new IllegalArgumentException("Bad LinkAddress params " + address + "/" + prefixLength);
    }
    this.address = address;
    this.prefixLength = prefixLength;
    this.flags = flags;
    this.scope = scope;
}
Body of Second Method:
{
    if (address == null || address.isMulticastAddress() || prefixLength < 0 || (address instanceof Inet4Address && prefixLength > 32) || (prefixLength > 128)) {
        throw new IllegalArgumentException("Bad LinkAddress params " + address + "/" + prefixLength);
    }
    // deprecation time and expiration time must be both provided, or neither.
    if ((deprecationTime == LIFETIME_UNKNOWN) != (expirationTime == LIFETIME_UNKNOWN)) {
        throw new IllegalArgumentException("Must not specify only one of deprecation time and expiration time");
    }
    // deprecation time needs to be a positive value.
    if (deprecationTime != LIFETIME_UNKNOWN && deprecationTime < 0) {
        throw new IllegalArgumentException("invalid deprecation time " + deprecationTime);
    }
    // expiration time needs to be a positive value.
    if (expirationTime != LIFETIME_UNKNOWN && expirationTime < 0) {
        throw new IllegalArgumentException("invalid expiration time " + expirationTime);
    }
    // expiration time can't be earlier than deprecation time
    if (deprecationTime != LIFETIME_UNKNOWN && expirationTime != LIFETIME_UNKNOWN && expirationTime < deprecationTime) {
        throw new IllegalArgumentException("expiration earlier than deprecation (" + deprecationTime + ", " + expirationTime + ")");
    }
    this.address = address;
    this.prefixLength = prefixLength;
    this.flags = flags;
    this.scope = scope;
    this.deprecationTime = deprecationTime;
    this.expirationTime = expirationTime;
}
------------------------
Find a silently evolved API code:android.os.ParcelFileDescriptor.getFile:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Return the filesystem path of the real file on disk that is represented
 * by the given {@link FileDescriptor}.
 *
 * @hide
 */

Body of Frist Method:
{
    try {
        final String path = Os.readlink("/proc/self/fd/" + fd.getInt$());
        if (OsConstants.S_ISREG(Os.stat(path).st_mode)) {
            return new File(path);
        } else {
            throw new IOException("Not a regular file: " + path);
        }
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
}
Body of Second Method:
{
    try {
        final String path = Os.readlink("/proc/self/fd/" + fd.getInt$());
        if (OsConstants.S_ISREG(Os.stat(path).st_mode) || OsConstants.S_ISCHR(Os.stat(path).st_mode)) {
            return new File(path);
        } else {
            throw new IOException("Not a regular file or character device: " + path);
        }
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
}
------------------------
Find a silently evolved API code:android.view.ImeInsetsSourceConsumer.requestShow:COMMENT
<android.view.ImeInsetsSourceConsumer: int requestShow(boolean)>
default     hidden      ->public      hidden      
Method Modifier: public      default     hidden      
Method Modifier: No          Yes         Yes         
Method Updated:  Yes         No          Yes         
Comment:/**
 * Request {@link InputMethodManager} to show the IME.
 * @return @see {@link android.view.InsetsSourceConsumer.ShowResult}.
 */

Body of Frist Method:
{
    // TODO: Set mShowOnNextImeRender to automatically show IME and guard it with a flag.
    if (fromIme) {
        return ShowResult.SHOW_IMMEDIATELY;
    }
    return getImm().requestImeShow(null) ? ShowResult.SHOW_DELAYED : ShowResult.SHOW_FAILED;
}
Body of Second Method:
{
    if (getControl() == null) {
        // If control is null, schedule to show IME when control is available.
        mIsRequestedVisibleAwaitingControl = true;
    }
    // If client window is trying to control IME and IME is already visible, it is immediate.
    if (fromIme || mState.getSource(getType()).isVisible() && getControl() != null) {
        return ShowResult.SHOW_IMMEDIATELY;
    }
    return getImm().requestImeShow(mController.getHost().getWindowToken()) ? ShowResult.IME_SHOW_DELAYED : ShowResult.IME_SHOW_FAILED;
}
------------------------
Find a silently evolved API code:android.telephony.ims.ImsCallSessionListener.callSessionInviteParticipantsRequestFailed:COMMENT
Method Modifier: public      
Comment:/**
 * The previous request to invite participants to the conference (see
 * {@link #callSessionInviteParticipantsRequestDelivered()}) has failed.
 *
 * @param reasonInfo {@link ImsReasonInfo} detailing the reason forthe conference invitation
 * failure.
 */

Body of Frist Method:
{
    try {
        mListener.callSessionInviteParticipantsRequestFailed(reasonInfo);
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}
Body of Second Method:
{
    try {
        mListener.callSessionInviteParticipantsRequestFailed(reasonInfo);
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.media.AudioFormat.isPublicEncoding:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    switch(audioFormat) {
        case ENCODING_PCM_16BIT:
        case ENCODING_PCM_8BIT:
        case ENCODING_PCM_FLOAT:
        case ENCODING_AC3:
        case ENCODING_E_AC3:
        case ENCODING_DTS:
        case ENCODING_DTS_HD:
        case ENCODING_MP3:
        case ENCODING_AAC_LC:
        case ENCODING_AAC_HE_V1:
        case ENCODING_AAC_HE_V2:
        case ENCODING_IEC61937:
        case ENCODING_DOLBY_TRUEHD:
        case ENCODING_AAC_ELD:
        case ENCODING_AAC_XHE:
        case ENCODING_AC4:
        case ENCODING_E_AC3_JOC:
        case ENCODING_DOLBY_MAT:
            return true;
        default:
            return false;
    }
}
Body of Second Method:
{
    switch(audioFormat) {
        case ENCODING_PCM_16BIT:
        case ENCODING_PCM_8BIT:
        case ENCODING_PCM_FLOAT:
        case ENCODING_AC3:
        case ENCODING_E_AC3:
        case ENCODING_DTS:
        case ENCODING_DTS_HD:
        case ENCODING_MP3:
        case ENCODING_AAC_LC:
        case ENCODING_AAC_HE_V1:
        case ENCODING_AAC_HE_V2:
        case ENCODING_IEC61937:
        case ENCODING_DOLBY_TRUEHD:
        case ENCODING_AAC_ELD:
        case ENCODING_AAC_XHE:
        case ENCODING_AC4:
        case ENCODING_E_AC3_JOC:
        case ENCODING_DOLBY_MAT:
        case ENCODING_OPUS:
            return true;
        default:
            return false;
    }
}
------------------------
Find a silently evolved API code:android.util.AtomicFile.getLastModifiedTime:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Gets the last modified time of the atomic file.
 * {@hide}
 *
 * @return last modified time in milliseconds since epoch.  Returns zero if
 * the file does not exist or an I/O error is encountered.
 */

Body of Frist Method:
{
    if (mBackupName.exists()) {
        return mBackupName.lastModified();
    }
    return mBaseName.lastModified();
}
Body of Second Method:
{
    if (mLegacyBackupName.exists()) {
        return mLegacyBackupName.lastModified();
    }
    return mBaseName.lastModified();
}
------------------------
Find a silently evolved API code:android.util.AtomicFile.finishWrite:COMMENT
Method Modifier: public      
Comment:/**
 * Call when you have successfully finished writing to the stream
 * returned by {@link #startWrite()}.  This will close, sync, and
 * commit the new data.  The next attempt to read the atomic file
 * will return the new file stream.
 */

Body of Frist Method:
{
    if (str != null) {
        FileUtils.sync(str);
        try {
            str.close();
            mBackupName.delete();
        } catch (IOException e) {
            Log.w("AtomicFile", "finishWrite: Got exception:", e);
        }
        if (mCommitTag != null) {
            com.android.internal.logging.EventLogTags.writeCommitSysConfigFile(mCommitTag, SystemClock.uptimeMillis() - mStartTime);
        }
    }
}
Body of Second Method:
{
    if (str == null) {
        return;
    }
    if (!FileUtils.sync(str)) {
        Log.e(LOG_TAG, "Failed to sync file output stream");
    }
    try {
        str.close();
    } catch (IOException e) {
        Log.e(LOG_TAG, "Failed to close file output stream", e);
    }
    rename(mNewName, mBaseName);
    if (mCommitTag != null) {
        com.android.internal.logging.EventLogTags.writeCommitSysConfigFile(mCommitTag, SystemClock.uptimeMillis() - mStartTime);
    }
}
------------------------
Find a silently evolved API code:android.service.autofill.augmented.FillRequest.getActivityComponent:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Gets the name of the activity associated with this request.
 */

Body of Frist Method:
{
    return mProxy.componentName;
}
Body of Second Method:
{
    return mProxy.mComponentName;
}
------------------------
Find a silently evolved API code:android.telephony.ims.ImsCallSessionListener.callSessionResumeReceived:COMMENT
Method Modifier: public      
Comment:/**
 * The remote party has resumed this IMS call session.
 *
 * @param profile {@link ImsCallProfile} associated with the IMS call session.
 */

Body of Frist Method:
{
    try {
        mListener.callSessionResumeReceived(profile);
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}
Body of Second Method:
{
    try {
        mListener.callSessionResumeReceived(profile);
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.media.session.MediaController.TransportControls.stop:COMMENT
Method Modifier: public      
Comment:/**
 * Request that the player stop its playback; it may clear its state in
 * whatever way is appropriate.
 */

Body of Frist Method:
{
    try {
        mSessionBinder.stop(mContext.getPackageName(), mCbStub);
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling stop.", e);
    }
}
Body of Second Method:
{
    try {
        mSessionBinder.stop(mContext.getPackageName());
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling stop.", e);
    }
}
------------------------
Find a silently evolved API code:android.util.Half.trunc:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns the truncated half-precision float value of the specified
 * half-precision float value. Special values are handled in the following ways:
 * <ul>
 * <li>If the specified half-precision float is NaN, the result is NaN</li>
 * <li>If the specified half-precision float is infinity (negative or positive),
 * the result is infinity (with the same sign)</li>
 * <li>If the specified half-precision float is zero (negative or positive),
 * the result is zero (with the same sign)</li>
 * </ul>
 *
 * @param h A half-precision float value
 * @return The truncated half-precision float value of the specified
 * half-precision float value
 */

Body of Frist Method:
{
    int bits = h & 0xffff;
    int e = bits & 0x7fff;
    int result = bits;
    if (e < 0x3c00) {
        result &= FP16_SIGN_MASK;
    } else if (e < 0x6400) {
        e = 25 - (e >> 10);
        int mask = (1 << e) - 1;
        result &= ~mask;
    }
    return (short) result;
}
Body of Second Method:
{
    return FP16.trunc(h);
}
------------------------
Find a silently evolved API code:android.content.ContentProviderClient.applyBatch:COMMENT
Method Modifier: public      
Comment:/**
 * See {@link ContentProvider#applyBatch ContentProvider.applyBatch}
 */

Body of Frist Method:
{
    Preconditions.checkNotNull(operations, "operations");
    beforeRemote();
    try {
        return mContentProvider.applyBatch(mPackageName, authority, operations);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}
Body of Second Method:
{
    Objects.requireNonNull(operations, "operations");
    beforeRemote();
    try {
        return mContentProvider.applyBatch(mPackageName, mAttributionTag, authority, operations);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiEnterpriseConfig.setEapMethod:COMMENT
Method Modifier: public      
Comment:/**
 * Set the EAP authentication method.
 * @param  eapMethod is one {@link Eap#PEAP}, {@link Eap#TLS}, {@link Eap#TTLS} or
 * {@link Eap#PWD}
 * @throws IllegalArgumentException on an invalid eap method
 */

Body of Frist Method:
{
    switch(eapMethod) {
        /**
         * Valid methods
         */
        case Eap.TLS:
        case Eap.UNAUTH_TLS:
            setPhase2Method(Phase2.NONE);
        /* fall through */
        case Eap.PEAP:
        case Eap.PWD:
        case Eap.TTLS:
        case Eap.SIM:
        case Eap.AKA:
        case Eap.AKA_PRIME:
            mEapMethod = eapMethod;
            setFieldValue(OPP_KEY_CACHING, "1");
            break;
        default:
            throw new IllegalArgumentException("Unknown EAP method");
    }
}
Body of Second Method:
{
    switch(eapMethod) {
        /**
         * Valid methods
         */
        case Eap.WAPI_CERT:
            mEapMethod = eapMethod;
            setPhase2Method(Phase2.NONE);
            break;
        case Eap.TLS:
        case Eap.UNAUTH_TLS:
            setPhase2Method(Phase2.NONE);
        /* fall through */
        case Eap.PEAP:
        case Eap.PWD:
        case Eap.TTLS:
        case Eap.SIM:
        case Eap.AKA:
        case Eap.AKA_PRIME:
            mEapMethod = eapMethod;
            setFieldValue(OPP_KEY_CACHING, "1");
            break;
        default:
            throw new IllegalArgumentException("Unknown EAP method");
    }
}
------------------------
Find a silently evolved API code:android.util.Half.ceil:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns the smallest half-precision float value toward negative infinity
 * greater than or equal to the specified half-precision float value.
 * Special values are handled in the following ways:
 * <ul>
 * <li>If the specified half-precision float is NaN, the result is NaN</li>
 * <li>If the specified half-precision float is infinity (negative or positive),
 * the result is infinity (with the same sign)</li>
 * <li>If the specified half-precision float is zero (negative or positive),
 * the result is zero (with the same sign)</li>
 * </ul>
 *
 * @param h A half-precision float value
 * @return The smallest half-precision float value toward negative infinity
 * greater than or equal to the specified half-precision float value
 */

Body of Frist Method:
{
    int bits = h & 0xffff;
    int e = bits & 0x7fff;
    int result = bits;
    if (e < 0x3c00) {
        result &= FP16_SIGN_MASK;
        result |= 0x3c00 & -(~(bits >> 15) & (e != 0 ? 1 : 0));
    } else if (e < 0x6400) {
        e = 25 - (e >> 10);
        int mask = (1 << e) - 1;
        result += mask & ((bits >> 15) - 1);
        result &= ~mask;
    }
    return (short) result;
}
Body of Second Method:
{
    return FP16.ceil(h);
}
------------------------
Find a silently evolved API code:android.app.usage.UsageEvents.readEventFromParcel:COMMENT
Method Modifier: private     
Comment:/**
 * Reads a single event from the parcel. Modify this when updating {@link Event}.
 */

Body of Frist Method:
{
    final int packageIndex = p.readInt();
    if (packageIndex >= 0) {
        eventOut.mPackage = mStringPool[packageIndex];
    } else {
        eventOut.mPackage = null;
    }
    final int classIndex = p.readInt();
    if (classIndex >= 0) {
        eventOut.mClass = mStringPool[classIndex];
    } else {
        eventOut.mClass = null;
    }
    eventOut.mInstanceId = p.readInt();
    final int taskRootPackageIndex = p.readInt();
    if (taskRootPackageIndex >= 0) {
        eventOut.mTaskRootPackage = mStringPool[taskRootPackageIndex];
    } else {
        eventOut.mTaskRootPackage = null;
    }
    final int taskRootClassIndex = p.readInt();
    if (taskRootClassIndex >= 0) {
        eventOut.mTaskRootClass = mStringPool[taskRootClassIndex];
    } else {
        eventOut.mTaskRootClass = null;
    }
    eventOut.mEventType = p.readInt();
    eventOut.mTimeStamp = p.readLong();
    // Fill out the event-dependant fields.
    eventOut.mConfiguration = null;
    eventOut.mShortcutId = null;
    eventOut.mAction = null;
    eventOut.mContentType = null;
    eventOut.mContentAnnotations = null;
    eventOut.mNotificationChannelId = null;
    switch(eventOut.mEventType) {
        case Event.CONFIGURATION_CHANGE:
            // Extract the configuration for configuration change events.
            eventOut.mConfiguration = Configuration.CREATOR.createFromParcel(p);
            break;
        case Event.SHORTCUT_INVOCATION:
            eventOut.mShortcutId = p.readString();
            break;
        case Event.CHOOSER_ACTION:
            eventOut.mAction = p.readString();
            eventOut.mContentType = p.readString();
            eventOut.mContentAnnotations = p.createStringArray();
            break;
        case Event.STANDBY_BUCKET_CHANGED:
            eventOut.mBucketAndReason = p.readInt();
            break;
        case Event.NOTIFICATION_INTERRUPTION:
            eventOut.mNotificationChannelId = p.readString();
            break;
    }
    eventOut.mFlags = p.readInt();
}
Body of Second Method:
{
    final int packageIndex = p.readInt();
    if (packageIndex >= 0) {
        eventOut.mPackage = mStringPool[packageIndex];
    } else {
        eventOut.mPackage = null;
    }
    final int classIndex = p.readInt();
    if (classIndex >= 0) {
        eventOut.mClass = mStringPool[classIndex];
    } else {
        eventOut.mClass = null;
    }
    eventOut.mInstanceId = p.readInt();
    final int taskRootPackageIndex = p.readInt();
    if (taskRootPackageIndex >= 0) {
        eventOut.mTaskRootPackage = mStringPool[taskRootPackageIndex];
    } else {
        eventOut.mTaskRootPackage = null;
    }
    final int taskRootClassIndex = p.readInt();
    if (taskRootClassIndex >= 0) {
        eventOut.mTaskRootClass = mStringPool[taskRootClassIndex];
    } else {
        eventOut.mTaskRootClass = null;
    }
    eventOut.mEventType = p.readInt();
    eventOut.mTimeStamp = p.readLong();
    // Fill out the event-dependant fields.
    eventOut.mConfiguration = null;
    eventOut.mShortcutId = null;
    eventOut.mAction = null;
    eventOut.mContentType = null;
    eventOut.mContentAnnotations = null;
    eventOut.mNotificationChannelId = null;
    eventOut.mLocusId = null;
    switch(eventOut.mEventType) {
        case Event.CONFIGURATION_CHANGE:
            // Extract the configuration for configuration change events.
            eventOut.mConfiguration = Configuration.CREATOR.createFromParcel(p);
            break;
        case Event.SHORTCUT_INVOCATION:
            eventOut.mShortcutId = p.readString();
            break;
        case Event.CHOOSER_ACTION:
            eventOut.mAction = p.readString();
            eventOut.mContentType = p.readString();
            eventOut.mContentAnnotations = p.createStringArray();
            break;
        case Event.STANDBY_BUCKET_CHANGED:
            eventOut.mBucketAndReason = p.readInt();
            break;
        case Event.NOTIFICATION_INTERRUPTION:
            eventOut.mNotificationChannelId = p.readString();
            break;
        case Event.LOCUS_ID_SET:
            eventOut.mLocusId = p.readString();
            break;
    }
    eventOut.mFlags = p.readInt();
}
------------------------
Find a silently evolved API code:android.telephony.CallQuality.toString:COMMENT
Method Modifier: public      hidden      
Comment:// Parcelable things

Body of Frist Method:
{
    return "CallQuality: {downlinkCallQualityLevel=" + mDownlinkCallQualityLevel + " uplinkCallQualityLevel=" + mUplinkCallQualityLevel + " callDuration=" + mCallDuration + " numRtpPacketsTransmitted=" + mNumRtpPacketsTransmitted + " numRtpPacketsReceived=" + mNumRtpPacketsReceived + " numRtpPacketsTransmittedLost=" + mNumRtpPacketsTransmittedLost + " numRtpPacketsNotReceived=" + mNumRtpPacketsNotReceived + " averageRelativeJitter=" + mAverageRelativeJitter + " maxRelativeJitter=" + mMaxRelativeJitter + " averageRoundTripTime=" + mAverageRoundTripTime + " codecType=" + mCodecType + "}";
}
Body of Second Method:
{
    return "CallQuality: {downlinkCallQualityLevel=" + mDownlinkCallQualityLevel + " uplinkCallQualityLevel=" + mUplinkCallQualityLevel + " callDuration=" + mCallDuration + " numRtpPacketsTransmitted=" + mNumRtpPacketsTransmitted + " numRtpPacketsReceived=" + mNumRtpPacketsReceived + " numRtpPacketsTransmittedLost=" + mNumRtpPacketsTransmittedLost + " numRtpPacketsNotReceived=" + mNumRtpPacketsNotReceived + " averageRelativeJitter=" + mAverageRelativeJitter + " maxRelativeJitter=" + mMaxRelativeJitter + " averageRoundTripTime=" + mAverageRoundTripTime + " codecType=" + mCodecType + " rtpInactivityDetected=" + mRtpInactivityDetected + " txSilenceDetected=" + mRxSilenceDetected + " rxSilenceDetected=" + mTxSilenceDetected + "}";
}
------------------------
Find a silently evolved API code:android.content.pm.UserInfo.canHaveProfile:COMMENT
Method Modifier: public      hidden      
Comment:/* @hide */

Body of Frist Method:
{
    if (isManagedProfile() || isGuest() || isRestricted()) {
        return false;
    }
    if (UserManager.isSplitSystemUser()) {
        return id != UserHandle.USER_SYSTEM;
    } else {
        return id == UserHandle.USER_SYSTEM;
    }
}
Body of Second Method:
{
    if (isProfile() || isGuest() || isRestricted()) {
        return false;
    }
    if (UserManager.isSplitSystemUser() || UserManager.isHeadlessSystemUserMode()) {
        return id != UserHandle.USER_SYSTEM;
    } else {
        return id == UserHandle.USER_SYSTEM;
    }
}
------------------------
Find a silently evolved API code:android.app.ActivityView.setForwardedInsets:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Set forwarded insets on the virtual display.
 *
 * @see IWindowManager#setForwardedInsets
 */

Body of Frist Method:
{
    mForwardedInsets = insets;
    if (mVirtualDisplay == null) {
        return;
    }
    try {
        final IWindowManager wm = WindowManagerGlobal.getWindowManagerService();
        wm.setForwardedInsets(mVirtualDisplay.getDisplay().getDisplayId(), mForwardedInsets);
    } catch (RemoteException e) {
        e.rethrowAsRuntimeException();
    }
}
Body of Second Method:
{
    mTaskEmbedder.setForwardedInsets(insets);
}
------------------------
Find a silently evolved API code:android.util.Half.isInfinite:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns true if the specified half-precision float value represents
 * infinity, false otherwise.
 *
 * @param h A half-precision float value
 * @return True if the value is positive infinity or negative infinity,
 * false otherwise
 */

Body of Frist Method:
{
    return (h & FP16_COMBINED) == FP16_EXPONENT_MAX;
}
Body of Second Method:
{
    return FP16.isInfinite(h);
}
------------------------
Find a silently evolved API code:android.media.session.MediaController.TransportControls.play:COMMENT
Method Modifier: public      
Comment:/**
 * Request that the player start its playback at its current position.
 */

Body of Frist Method:
{
    try {
        mSessionBinder.play(mContext.getPackageName(), mCbStub);
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling play.", e);
    }
}
Body of Second Method:
{
    try {
        mSessionBinder.play(mContext.getPackageName());
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling play.", e);
    }
}
------------------------
Find a silently evolved API code:android.hardware.soundtrigger.SoundTriggerModule.unloadSoundModel:COMMENT
<android.hardware.soundtrigger.SoundTriggerModule: int unloadSoundModel(int)>
public      native      hidden      ->public      hidden      
Method Modifier: public      native      hidden      
Method Modifier: Yes         Yes         Yes         
Method Updated:  Yes         No          Yes         
Comment:/**
 * Unload a {@link SoundTrigger.SoundModel} and abort any pendiong recognition
 * @param soundModelHandle The sound model handle
 * @return - {@link SoundTrigger#STATUS_OK} in case of success
 * - {@link SoundTrigger#STATUS_ERROR} in case of unspecified error
 * - {@link SoundTrigger#STATUS_PERMISSION_DENIED} if the caller does not have
 * system permission
 * - {@link SoundTrigger#STATUS_NO_INIT} if the native service cannot be reached
 * - {@link SoundTrigger#STATUS_BAD_VALUE} if the sound model handle is invalid
 * - {@link SoundTrigger#STATUS_DEAD_OBJECT} if the binder transaction to the native
 * service fails
 */

Body of Frist Method:

Body of Second Method:
{
    try {
        mService.unloadModel(soundModelHandle);
        return SoundTrigger.STATUS_OK;
    } catch (Exception e) {
        return SoundTrigger.handleException(e);
    }
}
------------------------
Find a silently evolved API code:android.app.UiModeManager.enableCarMode:COMMENT
Method Modifier: public      
Comment:/**
 * Force device into car mode, like it had been placed in the car dock.
 * This will cause the device to switch to the car home UI as part of
 * the mode switch.
 * @param flags Must be 0.
 */

Body of Frist Method:
{
    if (mService != null) {
        try {
            mService.enableCarMode(flags);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    }
}
Body of Second Method:
{
    enableCarMode(DEFAULT_PRIORITY, flags);
}
------------------------
Find a silently evolved API code:android.media.soundtrigger.SoundTriggerDetector.startRecognition:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Starts recognition on the associated sound model. Result is indicated via the
 * {@link Callback}.
 * @return Indicates whether the call succeeded or not.
 */

Body of Frist Method:
{
    if (DBG) {
        Slog.d(TAG, "startRecognition()");
    }
    boolean captureTriggerAudio = (recognitionFlags & RECOGNITION_FLAG_CAPTURE_TRIGGER_AUDIO) != 0;
    boolean allowMultipleTriggers = (recognitionFlags & RECOGNITION_FLAG_ALLOW_MULTIPLE_TRIGGERS) != 0;
    int status = STATUS_OK;
    try {
        status = mSoundTriggerService.startRecognition(new ParcelUuid(mSoundModelId), mRecognitionCallback, new RecognitionConfig(captureTriggerAudio, allowMultipleTriggers, null, null));
    } catch (RemoteException e) {
        return false;
    }
    return status == STATUS_OK;
}
Body of Second Method:
{
    if (DBG) {
        Slog.d(TAG, "startRecognition()");
    }
    boolean captureTriggerAudio = (recognitionFlags & RECOGNITION_FLAG_CAPTURE_TRIGGER_AUDIO) != 0;
    boolean allowMultipleTriggers = (recognitionFlags & RECOGNITION_FLAG_ALLOW_MULTIPLE_TRIGGERS) != 0;
    int audioCapabilities = 0;
    if ((recognitionFlags & RECOGNITION_FLAG_ENABLE_AUDIO_ECHO_CANCELLATION) != 0) {
        audioCapabilities |= SoundTrigger.ModuleProperties.AUDIO_CAPABILITY_ECHO_CANCELLATION;
    }
    if ((recognitionFlags & RECOGNITION_FLAG_ENABLE_AUDIO_NOISE_SUPPRESSION) != 0) {
        audioCapabilities |= SoundTrigger.ModuleProperties.AUDIO_CAPABILITY_NOISE_SUPPRESSION;
    }
    int status;
    try {
        status = mSoundTriggerService.startRecognition(new ParcelUuid(mSoundModelId), mRecognitionCallback, new RecognitionConfig(captureTriggerAudio, allowMultipleTriggers, null, null, audioCapabilities));
    } catch (RemoteException e) {
        return false;
    }
    return status == STATUS_OK;
}
------------------------
Find a silently evolved API code:android.util.Half.copySign:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns the first parameter with the sign of the second parameter.
 * This method treats NaNs as having a sign.
 *
 * @param magnitude A half-precision float value providing the magnitude of the result
 * @param sign  A half-precision float value providing the sign of the result
 * @return A value with the magnitude of the first parameter and the sign
 * of the second parameter
 */

Body of Frist Method:
{
    return (short) ((sign & FP16_SIGN_MASK) | (magnitude & FP16_COMBINED));
}
Body of Second Method:
{
    return (short) ((sign & FP16.SIGN_MASK) | (magnitude & FP16.EXPONENT_SIGNIFICAND_MASK));
}
------------------------
Find a silently evolved API code:android.view.MotionEvent.split:COMMENT
Method Modifier: public      final       hidden      
Comment:/**
 * Splits a motion event such that it includes only a subset of pointer ids.
 * @hide
 */

Body of Frist Method:
{
    MotionEvent ev = obtain();
    synchronized (gSharedTempLock) {
        final int oldPointerCount = nativeGetPointerCount(mNativePtr);
        ensureSharedTempPointerCapacity(oldPointerCount);
        final PointerProperties[] pp = gSharedTempPointerProperties;
        final PointerCoords[] pc = gSharedTempPointerCoords;
        final int[] map = gSharedTempPointerIndexMap;
        final int oldAction = nativeGetAction(mNativePtr);
        final int oldActionMasked = oldAction & ACTION_MASK;
        final int oldActionPointerIndex = (oldAction & ACTION_POINTER_INDEX_MASK) >> ACTION_POINTER_INDEX_SHIFT;
        int newActionPointerIndex = -1;
        int newPointerCount = 0;
        for (int i = 0; i < oldPointerCount; i++) {
            nativeGetPointerProperties(mNativePtr, i, pp[newPointerCount]);
            final int idBit = 1 << pp[newPointerCount].id;
            if ((idBit & idBits) != 0) {
                if (i == oldActionPointerIndex) {
                    newActionPointerIndex = newPointerCount;
                }
                map[newPointerCount] = i;
                newPointerCount += 1;
            }
        }
        if (newPointerCount == 0) {
            throw new IllegalArgumentException("idBits did not match any ids in the event");
        }
        final int newAction;
        if (oldActionMasked == ACTION_POINTER_DOWN || oldActionMasked == ACTION_POINTER_UP) {
            if (newActionPointerIndex < 0) {
                // An unrelated pointer changed.
                newAction = ACTION_MOVE;
            } else if (newPointerCount == 1) {
                // The first/last pointer went down/up.
                newAction = oldActionMasked == ACTION_POINTER_DOWN ? ACTION_DOWN : ACTION_UP;
            } else {
                // A secondary pointer went down/up.
                newAction = oldActionMasked | (newActionPointerIndex << ACTION_POINTER_INDEX_SHIFT);
            }
        } else {
            // Simple up/down/cancel/move or other motion action.
            newAction = oldAction;
        }
        final int historySize = nativeGetHistorySize(mNativePtr);
        for (int h = 0; h <= historySize; h++) {
            final int historyPos = h == historySize ? HISTORY_CURRENT : h;
            for (int i = 0; i < newPointerCount; i++) {
                nativeGetPointerCoords(mNativePtr, map[i], historyPos, pc[i]);
            }
            final long eventTimeNanos = nativeGetEventTimeNanos(mNativePtr, historyPos);
            if (h == 0) {
                ev.mNativePtr = nativeInitialize(ev.mNativePtr, nativeGetDeviceId(mNativePtr), nativeGetSource(mNativePtr), nativeGetDisplayId(mNativePtr), newAction, nativeGetFlags(mNativePtr), nativeGetEdgeFlags(mNativePtr), nativeGetMetaState(mNativePtr), nativeGetButtonState(mNativePtr), nativeGetClassification(mNativePtr), nativeGetXOffset(mNativePtr), nativeGetYOffset(mNativePtr), nativeGetXPrecision(mNativePtr), nativeGetYPrecision(mNativePtr), nativeGetDownTimeNanos(mNativePtr), eventTimeNanos, newPointerCount, pp, pc);
            } else {
                nativeAddBatch(ev.mNativePtr, eventTimeNanos, pc, 0);
            }
        }
        return ev;
    }
}
Body of Second Method:
{
    MotionEvent ev = obtain();
    synchronized (gSharedTempLock) {
        final int oldPointerCount = nativeGetPointerCount(mNativePtr);
        ensureSharedTempPointerCapacity(oldPointerCount);
        final PointerProperties[] pp = gSharedTempPointerProperties;
        final PointerCoords[] pc = gSharedTempPointerCoords;
        final int[] map = gSharedTempPointerIndexMap;
        final int oldAction = nativeGetAction(mNativePtr);
        final int oldActionMasked = oldAction & ACTION_MASK;
        final int oldActionPointerIndex = (oldAction & ACTION_POINTER_INDEX_MASK) >> ACTION_POINTER_INDEX_SHIFT;
        int newActionPointerIndex = -1;
        int newPointerCount = 0;
        for (int i = 0; i < oldPointerCount; i++) {
            nativeGetPointerProperties(mNativePtr, i, pp[newPointerCount]);
            final int idBit = 1 << pp[newPointerCount].id;
            if ((idBit & idBits) != 0) {
                if (i == oldActionPointerIndex) {
                    newActionPointerIndex = newPointerCount;
                }
                map[newPointerCount] = i;
                newPointerCount += 1;
            }
        }
        if (newPointerCount == 0) {
            throw new IllegalArgumentException("idBits did not match any ids in the event");
        }
        final int newAction;
        if (oldActionMasked == ACTION_POINTER_DOWN || oldActionMasked == ACTION_POINTER_UP) {
            if (newActionPointerIndex < 0) {
                // An unrelated pointer changed.
                newAction = ACTION_MOVE;
            } else if (newPointerCount == 1) {
                // The first/last pointer went down/up.
                newAction = oldActionMasked == ACTION_POINTER_DOWN ? ACTION_DOWN : ACTION_UP;
            } else {
                // A secondary pointer went down/up.
                newAction = oldActionMasked | (newActionPointerIndex << ACTION_POINTER_INDEX_SHIFT);
            }
        } else {
            // Simple up/down/cancel/move or other motion action.
            newAction = oldAction;
        }
        final int historySize = nativeGetHistorySize(mNativePtr);
        for (int h = 0; h <= historySize; h++) {
            final int historyPos = h == historySize ? HISTORY_CURRENT : h;
            for (int i = 0; i < newPointerCount; i++) {
                nativeGetPointerCoords(mNativePtr, map[i], historyPos, pc[i]);
            }
            final long eventTimeNanos = nativeGetEventTimeNanos(mNativePtr, historyPos);
            if (h == 0) {
                ev.initialize(nativeGetDeviceId(mNativePtr), nativeGetSource(mNativePtr), nativeGetDisplayId(mNativePtr), newAction, nativeGetFlags(mNativePtr), nativeGetEdgeFlags(mNativePtr), nativeGetMetaState(mNativePtr), nativeGetButtonState(mNativePtr), nativeGetClassification(mNativePtr), nativeGetXOffset(mNativePtr), nativeGetYOffset(mNativePtr), nativeGetXPrecision(mNativePtr), nativeGetYPrecision(mNativePtr), nativeGetDownTimeNanos(mNativePtr), eventTimeNanos, newPointerCount, pp, pc);
            } else {
                nativeAddBatch(ev.mNativePtr, eventTimeNanos, pc, 0);
            }
        }
        return ev;
    }
}
------------------------
Find a silently evolved API code:android.telephony.CellLocation.requestLocationUpdate:COMMENT
Method Modifier: public      static      
Comment:/**
 * Request an update of the current location.  If the location has changed,
 * a broadcast will be sent to everyone registered with {@link
 * PhoneStateListener#LISTEN_CELL_LOCATION}.
 */

Body of Frist Method:
{
    try {
        ITelephony phone = ITelephony.Stub.asInterface(ServiceManager.getService("phone"));
        if (phone != null) {
            phone.updateServiceLocation();
        }
    } catch (RemoteException ex) {
    // ignore it
    }
}
Body of Second Method:
{
    try {
        ITelephony phone = ITelephony.Stub.asInterface(TelephonyFrameworkInitializer.getTelephonyServiceManager().getTelephonyServiceRegisterer().get());
        if (phone != null) {
            phone.updateServiceLocation();
        }
    } catch (RemoteException ex) {
    // ignore it
    }
}
------------------------
Find a silently evolved API code:android.net.RouteInfo.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Implement the Parcelable interface
 */

Body of Frist Method:
{
    dest.writeParcelable(mDestination, flags);
    byte[] gatewayBytes = (mGateway == null) ? null : mGateway.getAddress();
    dest.writeByteArray(gatewayBytes);
    dest.writeString(mInterface);
    dest.writeInt(mType);
}
Body of Second Method:
{
    dest.writeParcelable(mDestination, flags);
    byte[] gatewayBytes = (mGateway == null) ? null : mGateway.getAddress();
    dest.writeByteArray(gatewayBytes);
    dest.writeString(mInterface);
    dest.writeInt(mType);
    dest.writeInt(mMtu);
}
------------------------
Find a silently evolved API code:android.os.image.DynamicSystemManager.Session.commit:COMMENT
Method Modifier: public      
Comment:/**
 * Finish write and make device to boot into the it after reboot.
 *
 * @return {@code true} if the call succeeds. {@code false} if there is any native runtime
 * error.
 */

Body of Frist Method:
{
    try {
        return mService.commit();
    } catch (RemoteException e) {
        throw new RuntimeException(e.toString());
    }
}
Body of Second Method:
{
    try {
        return mService.setEnable(true, true);
    } catch (RemoteException e) {
        throw new RuntimeException(e.toString());
    }
}
------------------------
Find a silently evolved API code:android.security.keystore.recovery.WrappedApplicationKey.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Creates a new {@link WrappedApplicationKey} instance.
 *
 * @return new instance
 * @throws NullPointerException if some required fields were not set.
 */

Body of Frist Method:
{
    Preconditions.checkNotNull(mInstance.mAlias);
    Preconditions.checkNotNull(mInstance.mEncryptedKeyMaterial);
    return mInstance;
}
Body of Second Method:
{
    Objects.requireNonNull(mInstance.mAlias);
    Objects.requireNonNull(mInstance.mEncryptedKeyMaterial);
    return mInstance;
}
------------------------
Find a silently evolved API code:android.media.session.MediaController.TransportControls.prepare:COMMENT
Method Modifier: public      
Comment:/**
 * Request that the player prepare its playback. In other words, other sessions can continue
 * to play during the preparation of this session. This method can be used to speed up the
 * start of the playback. Once the preparation is done, the session will change its playback
 * state to {@link PlaybackState#STATE_PAUSED}. Afterwards, {@link #play} can be called to
 * start playback.
 */

Body of Frist Method:
{
    try {
        mSessionBinder.prepare(mContext.getPackageName(), mCbStub);
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling prepare.", e);
    }
}
Body of Second Method:
{
    try {
        mSessionBinder.prepare(mContext.getPackageName());
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling prepare.", e);
    }
}
------------------------
Find a silently evolved API code:android.net.TrafficStats.getUidRxBytes:COMMENT
Method Modifier: public      static      
Comment:/**
 * Return number of bytes received by the given UID since device boot.
 * Counts packets across all network interfaces, and always increases
 * monotonically since device boot. Statistics are measured at the network
 * layer, so they include both TCP and UDP usage.
 * <p>
 * Before {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}, this may return
 * {@link #UNSUPPORTED} on devices where statistics aren't available.
 * <p>
 * Starting in {@link android.os.Build.VERSION_CODES#N} this will only
 * report traffic statistics for the calling UID. It will return
 * {@link #UNSUPPORTED} for all other UIDs for privacy reasons. To access
 * historical network statistics belonging to other UIDs, use
 * {@link NetworkStatsManager}.
 *
 * @see android.os.Process#myUid()
 * @see android.content.pm.ApplicationInfo#uid
 */

Body of Frist Method:
{
    // This isn't actually enforcing any security; it just returns the
    // unsupported value. The real filtering is done at the kernel level.
    final int callingUid = android.os.Process.myUid();
    if (callingUid == android.os.Process.SYSTEM_UID || callingUid == uid) {
        try {
            return getStatsService().getUidStats(uid, TYPE_RX_BYTES);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    } else {
        return UNSUPPORTED;
    }
}
Body of Second Method:
{
    try {
        return getStatsService().getUidStats(uid, TYPE_RX_BYTES);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.webkit.MimeTypeMap.hasExtension:COMMENT
Method Modifier: public      
Comment:/**
 * Return {@code true} if the given extension has a registered MIME type.
 * @param extension A file extension without the leading '.'
 * @return {@code true} if there is an extension entry in the map.
 */

Body of Frist Method:
{
    return MimeUtils.hasExtension(extension);
}
Body of Second Method:
{
    return MimeMap.getDefault().hasExtension(extension);
}
------------------------
Find a silently evolved API code:android.app.StatusBarManager.DisableInfo.toFlags:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Convert a DisableInfo to equivalent flags
 * @return a pair of equivalent disable flags
 *
 * @hide
 */

Body of Frist Method:
{
    int disable1 = DISABLE_NONE;
    int disable2 = DISABLE2_NONE;
    if (mStatusBarExpansion)
        disable1 |= DISABLE_EXPAND;
    if (mNavigateHome)
        disable1 |= DISABLE_HOME;
    if (mNotificationPeeking)
        disable1 |= DISABLE_NOTIFICATION_ALERTS;
    if (mRecents)
        disable1 |= DISABLE_RECENT;
    if (mSearch)
        disable1 |= DISABLE_SEARCH;
    return new Pair<Integer, Integer>(disable1, disable2);
}
Body of Second Method:
{
    int disable1 = DISABLE_NONE;
    int disable2 = DISABLE2_NONE;
    if (mStatusBarExpansion)
        disable1 |= DISABLE_EXPAND;
    if (mNavigateHome)
        disable1 |= DISABLE_HOME;
    if (mNotificationPeeking)
        disable1 |= DISABLE_NOTIFICATION_ALERTS;
    if (mRecents)
        disable1 |= DISABLE_RECENT;
    if (mSearch)
        disable1 |= DISABLE_SEARCH;
    if (mSystemIcons)
        disable1 |= DISABLE_SYSTEM_INFO;
    if (mClock)
        disable1 |= DISABLE_CLOCK;
    if (mNotificationIcons)
        disable1 |= DISABLE_NOTIFICATION_ICONS;
    return new Pair<Integer, Integer>(disable1, disable2);
}
------------------------
Find a silently evolved API code:android.app.admin.SecurityLog.SecurityEvent.getLogLevel:COMMENT
Method Modifier: public      
Comment:/**
 * Returns severity level for the event.
 */

Body of Frist Method:
{
    switch(mEvent.getTag()) {
        case TAG_ADB_SHELL_INTERACTIVE:
        case TAG_ADB_SHELL_CMD:
        case TAG_SYNC_RECV_FILE:
        case TAG_SYNC_SEND_FILE:
        case TAG_APP_PROCESS_START:
        case TAG_KEYGUARD_DISMISSED:
        case TAG_KEYGUARD_SECURED:
        case TAG_OS_STARTUP:
        case TAG_OS_SHUTDOWN:
        case TAG_LOGGING_STARTED:
        case TAG_LOGGING_STOPPED:
        case TAG_MEDIA_MOUNT:
        case TAG_MEDIA_UNMOUNT:
        case TAG_PASSWORD_EXPIRATION_SET:
        case TAG_PASSWORD_COMPLEXITY_SET:
        case TAG_PASSWORD_HISTORY_LENGTH_SET:
        case TAG_MAX_SCREEN_LOCK_TIMEOUT_SET:
        case TAG_MAX_PASSWORD_ATTEMPTS_SET:
        case TAG_USER_RESTRICTION_ADDED:
        case TAG_USER_RESTRICTION_REMOVED:
            return LEVEL_INFO;
        case TAG_CERT_AUTHORITY_REMOVED:
        case TAG_CRYPTO_SELF_TEST_COMPLETED:
            return getSuccess() ? LEVEL_INFO : LEVEL_ERROR;
        case TAG_CERT_AUTHORITY_INSTALLED:
        case TAG_KEYGUARD_DISMISS_AUTH_ATTEMPT:
        case TAG_KEY_IMPORT:
        case TAG_KEY_DESTRUCTION:
        case TAG_KEY_GENERATED:
            return getSuccess() ? LEVEL_INFO : LEVEL_WARNING;
        case TAG_LOG_BUFFER_SIZE_CRITICAL:
        case TAG_WIPE_FAILURE:
        case TAG_KEY_INTEGRITY_VIOLATION:
            return LEVEL_ERROR;
        case TAG_CERT_VALIDATION_FAILURE:
            return LEVEL_WARNING;
        default:
            return LEVEL_INFO;
    }
}
Body of Second Method:
{
    switch(getTag()) {
        case TAG_ADB_SHELL_INTERACTIVE:
        case TAG_ADB_SHELL_CMD:
        case TAG_SYNC_RECV_FILE:
        case TAG_SYNC_SEND_FILE:
        case TAG_APP_PROCESS_START:
        case TAG_KEYGUARD_DISMISSED:
        case TAG_KEYGUARD_SECURED:
        case TAG_OS_STARTUP:
        case TAG_OS_SHUTDOWN:
        case TAG_LOGGING_STARTED:
        case TAG_LOGGING_STOPPED:
        case TAG_MEDIA_MOUNT:
        case TAG_MEDIA_UNMOUNT:
        case TAG_PASSWORD_EXPIRATION_SET:
        case TAG_PASSWORD_COMPLEXITY_SET:
        case TAG_PASSWORD_HISTORY_LENGTH_SET:
        case TAG_MAX_SCREEN_LOCK_TIMEOUT_SET:
        case TAG_MAX_PASSWORD_ATTEMPTS_SET:
        case TAG_USER_RESTRICTION_ADDED:
        case TAG_USER_RESTRICTION_REMOVED:
        case TAG_CAMERA_POLICY_SET:
            return LEVEL_INFO;
        case TAG_CERT_AUTHORITY_REMOVED:
        case TAG_CRYPTO_SELF_TEST_COMPLETED:
            return getSuccess() ? LEVEL_INFO : LEVEL_ERROR;
        case TAG_CERT_AUTHORITY_INSTALLED:
        case TAG_KEYGUARD_DISMISS_AUTH_ATTEMPT:
        case TAG_KEY_IMPORT:
        case TAG_KEY_DESTRUCTION:
        case TAG_KEY_GENERATED:
            return getSuccess() ? LEVEL_INFO : LEVEL_WARNING;
        case TAG_LOG_BUFFER_SIZE_CRITICAL:
        case TAG_WIPE_FAILURE:
        case TAG_KEY_INTEGRITY_VIOLATION:
            return LEVEL_ERROR;
        case TAG_CERT_VALIDATION_FAILURE:
            return LEVEL_WARNING;
        default:
            return LEVEL_INFO;
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothA2dp.enableOptionalCodecs:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Enables the optional codecs.
 *
 * @param device the remote Bluetooth device. If null, use the currect
 * active A2DP Bluetooth device.
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        Log.d(TAG, "enableOptionalCodecs(" + device + ")");
    enableDisableOptionalCodecs(device, true);
}
Body of Second Method:
{
    if (DBG)
        Log.d(TAG, "enableOptionalCodecs(" + device + ")");
    verifyDeviceNotNull(device, "enableOptionalCodecs");
    enableDisableOptionalCodecs(device, true);
}
------------------------
Find a silently evolved API code:android.hardware.camera2.impl.CameraMetadataNative.writeValues:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * <p>Updates the existing entry for tag with the new bytes pointed by src, erasing
 * the entry if src was null.</p>
 *
 * <p>An empty array can be passed in to update the entry to 0 elements.</p>
 *
 * @param tag An integer tag, see e.g. {@link #getTag}
 * @param src An array of bytes, or null to erase the entry
 *
 * @hide
 */

Body of Frist Method:
{
    nativeWriteValues(tag, src);
}
Body of Second Method:
{
    nativeWriteValues(tag, src, mMetadataPtr);
}
------------------------
Find a silently evolved API code:android.telephony.ims.ImsCallSessionListener.callSessionUpdated:COMMENT
Method Modifier: public      
Comment:/**
 * The IMS call session profile has been updated. Does not include holding or resuming a call.
 *
 * @param profile The {@link ImsCallProfile} associated with the updated IMS call session.
 */

Body of Frist Method:
{
    try {
        mListener.callSessionUpdated(profile);
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}
Body of Second Method:
{
    try {
        mListener.callSessionUpdated(profile);
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.location.GnssMeasurement.set:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets all contents to the values stored in the provided object.
 * @hide
 */

Body of Frist Method:
{
    mFlags = measurement.mFlags;
    mSvid = measurement.mSvid;
    mConstellationType = measurement.mConstellationType;
    mTimeOffsetNanos = measurement.mTimeOffsetNanos;
    mState = measurement.mState;
    mReceivedSvTimeNanos = measurement.mReceivedSvTimeNanos;
    mReceivedSvTimeUncertaintyNanos = measurement.mReceivedSvTimeUncertaintyNanos;
    mCn0DbHz = measurement.mCn0DbHz;
    mPseudorangeRateMetersPerSecond = measurement.mPseudorangeRateMetersPerSecond;
    mPseudorangeRateUncertaintyMetersPerSecond = measurement.mPseudorangeRateUncertaintyMetersPerSecond;
    mAccumulatedDeltaRangeState = measurement.mAccumulatedDeltaRangeState;
    mAccumulatedDeltaRangeMeters = measurement.mAccumulatedDeltaRangeMeters;
    mAccumulatedDeltaRangeUncertaintyMeters = measurement.mAccumulatedDeltaRangeUncertaintyMeters;
    mCarrierFrequencyHz = measurement.mCarrierFrequencyHz;
    mCarrierCycles = measurement.mCarrierCycles;
    mCarrierPhase = measurement.mCarrierPhase;
    mCarrierPhaseUncertainty = measurement.mCarrierPhaseUncertainty;
    mMultipathIndicator = measurement.mMultipathIndicator;
    mSnrInDb = measurement.mSnrInDb;
    mAutomaticGainControlLevelInDb = measurement.mAutomaticGainControlLevelInDb;
    mCodeType = measurement.mCodeType;
}
Body of Second Method:
{
    mFlags = measurement.mFlags;
    mSvid = measurement.mSvid;
    mConstellationType = measurement.mConstellationType;
    mTimeOffsetNanos = measurement.mTimeOffsetNanos;
    mState = measurement.mState;
    mReceivedSvTimeNanos = measurement.mReceivedSvTimeNanos;
    mReceivedSvTimeUncertaintyNanos = measurement.mReceivedSvTimeUncertaintyNanos;
    mCn0DbHz = measurement.mCn0DbHz;
    mBasebandCn0DbHz = measurement.mBasebandCn0DbHz;
    mPseudorangeRateMetersPerSecond = measurement.mPseudorangeRateMetersPerSecond;
    mPseudorangeRateUncertaintyMetersPerSecond = measurement.mPseudorangeRateUncertaintyMetersPerSecond;
    mAccumulatedDeltaRangeState = measurement.mAccumulatedDeltaRangeState;
    mAccumulatedDeltaRangeMeters = measurement.mAccumulatedDeltaRangeMeters;
    mAccumulatedDeltaRangeUncertaintyMeters = measurement.mAccumulatedDeltaRangeUncertaintyMeters;
    mCarrierFrequencyHz = measurement.mCarrierFrequencyHz;
    mCarrierCycles = measurement.mCarrierCycles;
    mCarrierPhase = measurement.mCarrierPhase;
    mCarrierPhaseUncertainty = measurement.mCarrierPhaseUncertainty;
    mMultipathIndicator = measurement.mMultipathIndicator;
    mSnrInDb = measurement.mSnrInDb;
    mAutomaticGainControlLevelInDb = measurement.mAutomaticGainControlLevelInDb;
    mCodeType = measurement.mCodeType;
    mFullInterSignalBiasNanos = measurement.mFullInterSignalBiasNanos;
    mFullInterSignalBiasUncertaintyNanos = measurement.mFullInterSignalBiasUncertaintyNanos;
    mSatelliteInterSignalBiasNanos = measurement.mSatelliteInterSignalBiasNanos;
    mSatelliteInterSignalBiasUncertaintyNanos = measurement.mSatelliteInterSignalBiasUncertaintyNanos;
}
------------------------
Find a silently evolved API code:android.hardware.camera2.legacy.SurfaceTextureRenderer.dumpGlTiming:COMMENT
Method Modifier: private     
Comment:/**
 * Save a measurement dump to disk, in
 * {@code /sdcard/CameraLegacy/durations_<time>_<width1>x<height1>_...txt}
 */

Body of Frist Method:
{
    if (mPerfMeasurer == null)
        return;
    File legacyStorageDir = new File(Environment.getExternalStorageDirectory(), "CameraLegacy");
    if (!legacyStorageDir.exists()) {
        if (!legacyStorageDir.mkdirs()) {
            Log.e(TAG, "Failed to create directory for data dump");
            return;
        }
    }
    StringBuilder path = new StringBuilder(legacyStorageDir.getPath());
    path.append(File.separator);
    path.append("durations_");
    Time now = new Time();
    now.setToNow();
    path.append(now.format2445());
    path.append("_S");
    for (EGLSurfaceHolder surface : mSurfaces) {
        path.append(String.format("_%d_%d", surface.width, surface.height));
    }
    path.append("_C");
    for (EGLSurfaceHolder surface : mConversionSurfaces) {
        path.append(String.format("_%d_%d", surface.width, surface.height));
    }
    path.append(".txt");
    mPerfMeasurer.dumpPerformanceData(path.toString());
}
Body of Second Method:
{
    if (mPerfMeasurer == null)
        return;
    File legacyStorageDir = new File(Environment.getExternalStorageDirectory(), "CameraLegacy");
    if (!legacyStorageDir.exists()) {
        if (!legacyStorageDir.mkdirs()) {
            Log.e(TAG, "Failed to create directory for data dump");
            return;
        }
    }
    StringBuilder path = new StringBuilder(legacyStorageDir.getPath());
    path.append(File.separator);
    path.append("durations_");
    path.append(formatTimestamp(System.currentTimeMillis()));
    path.append("_S");
    for (EGLSurfaceHolder surface : mSurfaces) {
        path.append(String.format("_%d_%d", surface.width, surface.height));
    }
    path.append("_C");
    for (EGLSurfaceHolder surface : mConversionSurfaces) {
        path.append(String.format("_%d_%d", surface.width, surface.height));
    }
    path.append(".txt");
    mPerfMeasurer.dumpPerformanceData(path.toString());
}
------------------------
Find a silently evolved API code:android.net.wifi.p2p.WifiP2pConfig.Builder.setNetworkName:COMMENT
Method Modifier: public      
Comment:/**
 * Specify the network name, a.k.a. group name,
 * for creating or joining a group.
 * <p>
 * A network name shall begin with "DIRECT-xy". x and y are selected
 * from the following character set: upper case letters, lower case
 * letters and numbers. Any byte values allowed for an SSID according to
 * IEEE802.11-2012 [1] may be included after the string "DIRECT-xy"
 * (including none).
 * <p>
 * Must be called - an empty network name or an network name
 * not conforming to the P2P Group ID naming rule is not valid.
 *
 * @param networkName network name of a group.
 * @return The builder to facilitate chaining
 * {@code builder.setXXX(..).setXXX(..)}.
 */

Body of Frist Method:
{
    if (TextUtils.isEmpty(networkName)) {
        throw new IllegalArgumentException("network name must be non-empty.");
    }
    try {
        if (!networkName.matches("^DIRECT-[a-zA-Z0-9]{2}.*")) {
            throw new IllegalArgumentException("network name must starts with the prefix DIRECT-xy.");
        }
    } catch (PatternSyntaxException e) {
    // can never happen (fixed pattern)
    }
    mNetworkName = networkName;
    return this;
}
Body of Second Method:
{
    if (TextUtils.isEmpty(networkName)) {
        throw new IllegalArgumentException("network name must be non-empty.");
    }
    if (networkName.getBytes(StandardCharsets.UTF_8).length > MAX_SSID_BYTES) {
        throw new IllegalArgumentException("network name exceeds " + MAX_SSID_BYTES + " bytes.");
    }
    try {
        if (!networkName.matches("^DIRECT-[a-zA-Z0-9]{2}.*")) {
            throw new IllegalArgumentException("network name must starts with the prefix DIRECT-xy.");
        }
    } catch (PatternSyntaxException e) {
    // can never happen (fixed pattern)
    }
    mNetworkName = networkName;
    return this;
}
------------------------
Find a silently evolved API code:android.content.pm.ActivityInfo.isTranslucentOrFloating:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Determines whether the {@link Activity} is considered translucent or floating.
 * @hide
 */

Body of Frist Method:
{
    final boolean isTranslucent = attributes.getBoolean(com.android.internal.R.styleable.Window_windowIsTranslucent, false);
    final boolean isSwipeToDismiss = !attributes.hasValue(com.android.internal.R.styleable.Window_windowIsTranslucent) && attributes.getBoolean(com.android.internal.R.styleable.Window_windowSwipeToDismiss, false);
    final boolean isFloating = attributes.getBoolean(com.android.internal.R.styleable.Window_windowIsFloating, false);
    return isFloating || isTranslucent || isSwipeToDismiss;
}
Body of Second Method:
{
    final boolean isTranslucent = attributes.getBoolean(com.android.internal.R.styleable.Window_windowIsTranslucent, false);
    final boolean isFloating = attributes.getBoolean(com.android.internal.R.styleable.Window_windowIsFloating, false);
    return isFloating || isTranslucent;
}
------------------------
Find a silently evolved API code:android.app.WindowConfiguration.windowingModeToString:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    switch(windowingMode) {
        case WINDOWING_MODE_UNDEFINED:
            return "undefined";
        case WINDOWING_MODE_FULLSCREEN:
            return "fullscreen";
        case WINDOWING_MODE_PINNED:
            return "pinned";
        case WINDOWING_MODE_SPLIT_SCREEN_PRIMARY:
            return "split-screen-primary";
        case WINDOWING_MODE_SPLIT_SCREEN_SECONDARY:
            return "split-screen-secondary";
        case WINDOWING_MODE_FREEFORM:
            return "freeform";
    }
    return String.valueOf(windowingMode);
}
Body of Second Method:
{
    switch(windowingMode) {
        case WINDOWING_MODE_UNDEFINED:
            return "undefined";
        case WINDOWING_MODE_FULLSCREEN:
            return "fullscreen";
        case WINDOWING_MODE_MULTI_WINDOW:
            return "multi-window";
        case WINDOWING_MODE_PINNED:
            return "pinned";
        case WINDOWING_MODE_SPLIT_SCREEN_PRIMARY:
            return "split-screen-primary";
        case WINDOWING_MODE_SPLIT_SCREEN_SECONDARY:
            return "split-screen-secondary";
        case WINDOWING_MODE_FREEFORM:
            return "freeform";
    }
    return String.valueOf(windowingMode);
}
------------------------
Find a silently evolved API code:android.view.animation.AccelerateInterpolator.createNativeInterpolator:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return NativeInterpolatorFactoryHelper.createAccelerateInterpolator(mFactor);
}
Body of Second Method:
{
    return NativeInterpolatorFactory.createAccelerateInterpolator(mFactor);
}
------------------------
Find a silently evolved API code:android.speech.SpeechRecognizer.startListening:COMMENT
Method Modifier: public      
Comment:/**
 * Starts listening for speech. Please note that
 * {@link #setRecognitionListener(RecognitionListener)} should be called beforehand, otherwise
 * no notifications will be received.
 *
 * @param recognizerIntent contains parameters for the recognition to be performed. The intent
 * may also contain optional extras, see {@link RecognizerIntent}. If these values are
 * not set explicitly, default values will be used by the recognizer.
 */

Body of Frist Method:
{
    if (recognizerIntent == null) {
        throw new IllegalArgumentException("intent must not be null");
    }
    checkIsCalledFromMainThread();
    if (mConnection == null) {
        // first time connection
        mConnection = new Connection();
        Intent serviceIntent = new Intent(RecognitionService.SERVICE_INTERFACE);
        if (mServiceComponent == null) {
            String serviceComponent = Settings.Secure.getString(mContext.getContentResolver(), Settings.Secure.VOICE_RECOGNITION_SERVICE);
            if (TextUtils.isEmpty(serviceComponent)) {
                Log.e(TAG, "no selected voice recognition service");
                mListener.onError(ERROR_CLIENT);
                return;
            }
            serviceIntent.setComponent(ComponentName.unflattenFromString(serviceComponent));
        } else {
            serviceIntent.setComponent(mServiceComponent);
        }
        if (!mContext.bindService(serviceIntent, mConnection, Context.BIND_AUTO_CREATE)) {
            Log.e(TAG, "bind to recognition service failed");
            mConnection = null;
            mService = null;
            mListener.onError(ERROR_CLIENT);
            return;
        }
    }
    putMessage(Message.obtain(mHandler, MSG_START, recognizerIntent));
}
Body of Second Method:
{
    if (recognizerIntent == null) {
        throw new IllegalArgumentException("intent must not be null");
    }
    checkIsCalledFromMainThread();
    if (mConnection == null) {
        // first time connection
        mConnection = new Connection();
        Intent serviceIntent = new Intent(RecognitionService.SERVICE_INTERFACE);
        if (mServiceComponent == null) {
            String serviceComponent = Settings.Secure.getString(mContext.getContentResolver(), Settings.Secure.VOICE_RECOGNITION_SERVICE);
            if (TextUtils.isEmpty(serviceComponent)) {
                Log.e(TAG, "no selected voice recognition service");
                mListener.onError(ERROR_CLIENT);
                return;
            }
            serviceIntent.setComponent(ComponentName.unflattenFromString(serviceComponent));
        } else {
            serviceIntent.setComponent(mServiceComponent);
        }
        if (!mContext.bindService(serviceIntent, mConnection, Context.BIND_AUTO_CREATE | Context.BIND_INCLUDE_CAPABILITIES)) {
            Log.e(TAG, "bind to recognition service failed");
            mConnection = null;
            mService = null;
            mListener.onError(ERROR_CLIENT);
            return;
        }
    }
    putMessage(Message.obtain(mHandler, MSG_START, recognizerIntent));
}
------------------------
Find a silently evolved API code:android.util.Half.getExponent:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns the unbiased exponent used in the representation of
 * the specified  half-precision float value. if the value is NaN
 * or infinite, this* method returns {@link #MAX_EXPONENT} + 1.
 * If the argument is 0 or a subnormal representation, this method
 * returns {@link #MIN_EXPONENT} - 1.
 *
 * @param h A half-precision float value
 * @return The unbiased exponent of the specified value
 */

Body of Frist Method:
{
    return ((h >>> FP16_EXPONENT_SHIFT) & FP16_EXPONENT_MASK) - FP16_EXPONENT_BIAS;
}
Body of Second Method:
{
    return ((h >>> FP16.EXPONENT_SHIFT) & FP16.SHIFTED_EXPONENT_MASK) - FP16.EXPONENT_BIAS;
}
------------------------
Find a silently evolved API code:android.graphics.Outline.set:COMMENT
Method Modifier: public      
Comment:/**
 * Replace the contents of this Outline with the contents of src.
 *
 * @param src Source outline to copy from.
 */

Body of Frist Method:
{
    mMode = src.mMode;
    if (src.mMode == MODE_CONVEX_PATH) {
        if (mPath == null) {
            mPath = new Path();
        }
        mPath.set(src.mPath);
    }
    mRect.set(src.mRect);
    mRadius = src.mRadius;
    mAlpha = src.mAlpha;
}
Body of Second Method:
{
    mMode = src.mMode;
    if (src.mMode == MODE_PATH) {
        if (mPath == null) {
            mPath = new Path();
        }
        mPath.set(src.mPath);
    }
    mRect.set(src.mRect);
    mRadius = src.mRadius;
    mAlpha = src.mAlpha;
}
------------------------
Find a silently evolved API code:android.app.SharedElementCallback.onCaptureSharedElementSnapshot:COMMENT
Method Modifier: public      
Comment:/**
 * Creates a snapshot of a shared element to be used by the remote Activity and reconstituted
 * with {@link #onCreateSnapshotView(android.content.Context, android.os.Parcelable)}. A
 * null return value will mean that the remote Activity will have a null snapshot View in
 * {@link #onSharedElementStart(java.util.List, java.util.List, java.util.List)} and
 * {@link #onSharedElementEnd(java.util.List, java.util.List, java.util.List)}.
 *
 * <p>This is not called for Fragment Transitions.</p>
 *
 * @param sharedElement The shared element View to create a snapshot for.
 * @param viewToGlobalMatrix A matrix containing a transform from the view to the screen
 * coordinates.
 * @param screenBounds The bounds of shared element in screen coordinate space. This is
 * the bounds of the view with the viewToGlobalMatrix applied.
 * @return A snapshot to send to the remote Activity to be reconstituted with
 * {@link #onCreateSnapshotView(android.content.Context, android.os.Parcelable)} and passed
 * into {@link #onSharedElementStart(java.util.List, java.util.List, java.util.List)} and
 * {@link #onSharedElementEnd(java.util.List, java.util.List, java.util.List)}.
 */

Body of Frist Method:
{
    if (sharedElement instanceof ImageView) {
        ImageView imageView = ((ImageView) sharedElement);
        Drawable d = imageView.getDrawable();
        Drawable bg = imageView.getBackground();
        if (d != null && (bg == null || bg.getAlpha() == 0)) {
            Bitmap bitmap = TransitionUtils.createDrawableBitmap(d, imageView);
            if (bitmap != null) {
                Bundle bundle = new Bundle();
                if (bitmap.getConfig() != Bitmap.Config.HARDWARE) {
                    bundle.putParcelable(BUNDLE_SNAPSHOT_BITMAP, bitmap);
                } else {
                    GraphicBuffer graphicBuffer = bitmap.createGraphicBufferHandle();
                    bundle.putParcelable(BUNDLE_SNAPSHOT_GRAPHIC_BUFFER, graphicBuffer);
                    ColorSpace cs = bitmap.getColorSpace();
                    if (cs != null) {
                        bundle.putInt(BUNDLE_SNAPSHOT_COLOR_SPACE, cs.getId());
                    }
                }
                bundle.putString(BUNDLE_SNAPSHOT_IMAGE_SCALETYPE, imageView.getScaleType().toString());
                if (imageView.getScaleType() == ScaleType.MATRIX) {
                    Matrix matrix = imageView.getImageMatrix();
                    float[] values = new float[9];
                    matrix.getValues(values);
                    bundle.putFloatArray(BUNDLE_SNAPSHOT_IMAGE_MATRIX, values);
                }
                return bundle;
            }
        }
    }
    if (mTempMatrix == null) {
        mTempMatrix = new Matrix(viewToGlobalMatrix);
    } else {
        mTempMatrix.set(viewToGlobalMatrix);
    }
    ViewGroup parent = (ViewGroup) sharedElement.getParent();
    return TransitionUtils.createViewBitmap(sharedElement, mTempMatrix, screenBounds, parent);
}
Body of Second Method:
{
    if (sharedElement instanceof ImageView) {
        ImageView imageView = ((ImageView) sharedElement);
        Drawable d = imageView.getDrawable();
        Drawable bg = imageView.getBackground();
        if (d != null && (bg == null || bg.getAlpha() == 0)) {
            Bitmap bitmap = TransitionUtils.createDrawableBitmap(d, imageView);
            if (bitmap != null) {
                Bundle bundle = new Bundle();
                if (bitmap.getConfig() != Bitmap.Config.HARDWARE) {
                    bundle.putParcelable(BUNDLE_SNAPSHOT_BITMAP, bitmap);
                } else {
                    HardwareBuffer hardwareBuffer = bitmap.getHardwareBuffer();
                    bundle.putParcelable(BUNDLE_SNAPSHOT_HARDWARE_BUFFER, hardwareBuffer);
                    ColorSpace cs = bitmap.getColorSpace();
                    if (cs != null) {
                        bundle.putInt(BUNDLE_SNAPSHOT_COLOR_SPACE, cs.getId());
                    }
                }
                bundle.putString(BUNDLE_SNAPSHOT_IMAGE_SCALETYPE, imageView.getScaleType().toString());
                if (imageView.getScaleType() == ScaleType.MATRIX) {
                    Matrix matrix = imageView.getImageMatrix();
                    float[] values = new float[9];
                    matrix.getValues(values);
                    bundle.putFloatArray(BUNDLE_SNAPSHOT_IMAGE_MATRIX, values);
                }
                return bundle;
            }
        }
    }
    if (mTempMatrix == null) {
        mTempMatrix = new Matrix(viewToGlobalMatrix);
    } else {
        mTempMatrix.set(viewToGlobalMatrix);
    }
    ViewGroup parent = (ViewGroup) sharedElement.getParent();
    return TransitionUtils.createViewBitmap(sharedElement, mTempMatrix, screenBounds, parent);
}
------------------------
Find a silently evolved API code:android.telecom.CallScreeningService.respondToCall:COMMENT
Method Modifier: public      final       
Comment:/**
 * Responds to the given incoming call, either allowing it, silencing it or disallowing it.
 * <p>
 * The {@link CallScreeningService} calls this method to inform the system whether the call
 * should be silently blocked or not. In the event that it should not be blocked, it may
 * also be requested to ring silently.
 * <p>
 * Calls to this method are ignored unless the {@link Call.Details#getCallDirection()} is
 * {@link Call.Details#DIRECTION_INCOMING}.
 *
 * @param callDetails The call to allow.
 * <p>
 * Must be the same {@link Call.Details call} which was provided to the
 * {@link CallScreeningService} via {@link #onScreenCall(Call.Details)}.
 * @param response The {@link CallScreeningService.CallResponse} which contains information
 * about how to respond to a call.
 */

Body of Frist Method:
{
    try {
        if (response.getDisallowCall()) {
            mCallScreeningAdapter.disallowCall(callDetails.getTelecomCallId(), response.getRejectCall(), !response.getSkipCallLog(), !response.getSkipNotification(), new ComponentName(getPackageName(), getClass().getName()));
        } else if (response.getSilenceCall()) {
            mCallScreeningAdapter.silenceCall(callDetails.getTelecomCallId());
        } else {
            mCallScreeningAdapter.allowCall(callDetails.getTelecomCallId());
        }
    } catch (RemoteException e) {
    }
}
Body of Second Method:
{
    try {
        if (response.getDisallowCall()) {
            mCallScreeningAdapter.disallowCall(callDetails.getTelecomCallId(), response.getRejectCall(), !response.getSkipCallLog(), !response.getSkipNotification(), new ComponentName(getPackageName(), getClass().getName()));
        } else if (response.getSilenceCall()) {
            mCallScreeningAdapter.silenceCall(callDetails.getTelecomCallId());
        } else if (response.getShouldScreenCallViaAudioProcessing()) {
            mCallScreeningAdapter.screenCallFurther(callDetails.getTelecomCallId());
        } else {
            mCallScreeningAdapter.allowCall(callDetails.getTelecomCallId());
        }
    } catch (RemoteException e) {
    }
}
------------------------
Find a silently evolved API code:android.media.session.MediaController.TransportControls.prepareFromSearch:COMMENT
Method Modifier: public      
Comment:/**
 * Request that the player prepare playback for a specific search query. An empty or null
 * query should be treated as a request to prepare any music. In other words, other sessions
 * can continue to play during the preparation of this session. This method can be used to
 * speed up the start of the playback. Once the preparation is done, the session will
 * change its playback state to {@link PlaybackState#STATE_PAUSED}. Afterwards,
 * {@link #play} can be called to start playback. If the preparation is not needed,
 * {@link #playFromSearch} can be directly called without this method.
 *
 * @param query The search query.
 * @param extras Optional extras that can include extra information
 * about the query.
 */

Body of Frist Method:
{
    if (query == null) {
        // This is to remain compatible with
        // INTENT_ACTION_MEDIA_PLAY_FROM_SEARCH
        query = "";
    }
    try {
        mSessionBinder.prepareFromSearch(mContext.getPackageName(), mCbStub, query, extras);
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling prepare(" + query + ").", e);
    }
}
Body of Second Method:
{
    if (query == null) {
        // This is to remain compatible with
        // INTENT_ACTION_MEDIA_PLAY_FROM_SEARCH
        query = "";
    }
    try {
        mSessionBinder.prepareFromSearch(mContext.getPackageName(), query, extras);
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling prepare(" + query + ").", e);
    }
}
------------------------
Find a silently evolved API code:android.companion.BluetoothLeDeviceFilter.Builder.setRawDataFilter:COMMENT
Method Modifier: public      
Comment:/**
 * Filter devices by raw advertisement data, as obtained by {@link ScanRecord#getBytes}
 *
 * @param rawDataFilter bit values that have to match against advertized data
 * @param rawDataFilterMask bits that have to be matched
 * @return self for chaining
 */

Body of Frist Method:
{
    checkNotUsed();
    Preconditions.checkNotNull(rawDataFilter);
    checkArgument(rawDataFilterMask == null || rawDataFilter.length == rawDataFilterMask.length, "Mask and filter should be the same length");
    mRawDataFilter = rawDataFilter;
    mRawDataFilterMask = rawDataFilterMask;
    return this;
}
Body of Second Method:
{
    checkNotUsed();
    Objects.requireNonNull(rawDataFilter);
    checkArgument(rawDataFilterMask == null || rawDataFilter.length == rawDataFilterMask.length, "Mask and filter should be the same length");
    mRawDataFilter = rawDataFilter;
    mRawDataFilterMask = rawDataFilterMask;
    return this;
}
------------------------
Find a silently evolved API code:android.animation.ValueAnimator.getAnimationHandler:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @return The {@link AnimationHandler} that will be used to schedule updates for this animator.
 * @hide
 */

Body of Frist Method:
{
    return AnimationHandler.getInstance();
}
Body of Second Method:
{
    return mAnimationHandler != null ? mAnimationHandler : AnimationHandler.getInstance();
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothA2dpSink.stateToString:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Helper for converting a state to a string.
 *
 * For debug use only - strings are not internationalized.
 *
 * @hide
 */

Body of Frist Method:
{
    switch(state) {
        case STATE_DISCONNECTED:
            return "disconnected";
        case STATE_CONNECTING:
            return "connecting";
        case STATE_CONNECTED:
            return "connected";
        case STATE_DISCONNECTING:
            return "disconnecting";
        case STATE_PLAYING:
            return "playing";
        case STATE_NOT_PLAYING:
            return "not playing";
        default:
            return "<unknown state " + state + ">";
    }
}
Body of Second Method:
{
    switch(state) {
        case STATE_DISCONNECTED:
            return "disconnected";
        case STATE_CONNECTING:
            return "connecting";
        case STATE_CONNECTED:
            return "connected";
        case STATE_DISCONNECTING:
            return "disconnecting";
        case BluetoothA2dp.STATE_PLAYING:
            return "playing";
        case BluetoothA2dp.STATE_NOT_PLAYING:
            return "not playing";
        default:
            return "<unknown state " + state + ">";
    }
}
------------------------
Find a silently evolved API code:android.net.util.KeepalivePacketDataUtil.toStableParcelable:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Convert this NattKeepalivePacketData to a NattKeepalivePacketDataParcelable.
 */

Body of Frist Method:
{
    final NattKeepalivePacketDataParcelable parcel = new NattKeepalivePacketDataParcelable();
    parcel.srcAddress = pkt.srcAddress.getAddress();
    parcel.srcPort = pkt.srcPort;
    parcel.dstAddress = pkt.dstAddress.getAddress();
    parcel.dstPort = pkt.dstPort;
    return parcel;
}
Body of Second Method:
{
    final NattKeepalivePacketDataParcelable parcel = new NattKeepalivePacketDataParcelable();
    final InetAddress srcAddress = pkt.getSrcAddress();
    final InetAddress dstAddress = pkt.getDstAddress();
    parcel.srcAddress = srcAddress.getAddress();
    parcel.srcPort = pkt.getSrcPort();
    parcel.dstAddress = dstAddress.getAddress();
    parcel.dstPort = pkt.getDstPort();
    return parcel;
}
------------------------
Find a silently evolved API code:android.hardware.camera2.impl.CameraMetadataNative.isEmpty:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Does this metadata contain at least 1 entry?
 *
 * @hide
 */

Body of Frist Method:
{
    return nativeIsEmpty();
}
Body of Second Method:
{
    return nativeIsEmpty(mMetadataPtr);
}
------------------------
Find a silently evolved API code:android.telephony.AccessNetworkUtils.getOperatingBandForEarfcn:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Gets the EUTRAN Operating band for a given downlink EARFCN.
 *
 * <p>See 3GPP 36.101 sec 5.7.3-1 for calculation.
 *
 * @param earfcn The downlink EARFCN
 * @return Operating band number, or {@link #INVALID_BAND} if no corresponding band exists
 */

Body of Frist Method:
{
    if (earfcn > 67535) {
        return INVALID_BAND;
    } else if (earfcn >= 67366) {
        // band 67 only for CarrierAgg
        return INVALID_BAND;
    } else if (earfcn >= 66436) {
        return EutranBand.BAND_66;
    } else if (earfcn >= 65536) {
        return EutranBand.BAND_65;
    } else if (earfcn > 54339) {
        return INVALID_BAND;
    } else if (earfcn >= 46790) /* inferred from the end range of BAND_45 */
    {
        return EutranBand.BAND_46;
    } else if (earfcn >= 46590) {
        return EutranBand.BAND_45;
    } else if (earfcn >= 45590) {
        return EutranBand.BAND_44;
    } else if (earfcn >= 43590) {
        return EutranBand.BAND_43;
    } else if (earfcn >= 41590) {
        return EutranBand.BAND_42;
    } else if (earfcn >= 39650) {
        return EutranBand.BAND_41;
    } else if (earfcn >= 38650) {
        return EutranBand.BAND_40;
    } else if (earfcn >= 38250) {
        return EutranBand.BAND_39;
    } else if (earfcn >= 37750) {
        return EutranBand.BAND_38;
    } else if (earfcn >= 37550) {
        return EutranBand.BAND_37;
    } else if (earfcn >= 36950) {
        return EutranBand.BAND_36;
    } else if (earfcn >= 36350) {
        return EutranBand.BAND_35;
    } else if (earfcn >= 36200) {
        return EutranBand.BAND_34;
    } else if (earfcn >= 36000) {
        return EutranBand.BAND_33;
    } else if (earfcn > 10359) {
        return INVALID_BAND;
    } else if (earfcn >= 9920) {
        // band 32 only for CarrierAgg
        return INVALID_BAND;
    } else if (earfcn >= 9870) {
        return EutranBand.BAND_31;
    } else if (earfcn >= 9770) {
        return EutranBand.BAND_30;
    } else if (earfcn >= 9660) {
        // band 29 only for CarrierAgg
        return INVALID_BAND;
    } else if (earfcn >= 9210) {
        return EutranBand.BAND_28;
    } else if (earfcn >= 9040) {
        return EutranBand.BAND_27;
    } else if (earfcn >= 8690) {
        return EutranBand.BAND_26;
    } else if (earfcn >= 8040) {
        return EutranBand.BAND_25;
    } else if (earfcn >= 7700) {
        return EutranBand.BAND_24;
    } else if (earfcn >= 7500) {
        return EutranBand.BAND_23;
    } else if (earfcn >= 6600) {
        return EutranBand.BAND_22;
    } else if (earfcn >= 6450) {
        return EutranBand.BAND_21;
    } else if (earfcn >= 6150) {
        return EutranBand.BAND_20;
    } else if (earfcn >= 6000) {
        return EutranBand.BAND_19;
    } else if (earfcn >= 5850) {
        return EutranBand.BAND_18;
    } else if (earfcn >= 5730) {
        return EutranBand.BAND_17;
    } else if (earfcn > 5379) {
        return INVALID_BAND;
    } else if (earfcn >= 5280) {
        return EutranBand.BAND_14;
    } else if (earfcn >= 5180) {
        return EutranBand.BAND_13;
    } else if (earfcn >= 5010) {
        return EutranBand.BAND_12;
    } else if (earfcn >= 4750) {
        return EutranBand.BAND_11;
    } else if (earfcn >= 4150) {
        return EutranBand.BAND_10;
    } else if (earfcn >= 3800) {
        return EutranBand.BAND_9;
    } else if (earfcn >= 3450) {
        return EutranBand.BAND_8;
    } else if (earfcn >= 2750) {
        return EutranBand.BAND_7;
    } else if (earfcn >= 2650) {
        return EutranBand.BAND_6;
    } else if (earfcn >= 2400) {
        return EutranBand.BAND_5;
    } else if (earfcn >= 1950) {
        return EutranBand.BAND_4;
    } else if (earfcn >= 1200) {
        return EutranBand.BAND_3;
    } else if (earfcn >= 600) {
        return EutranBand.BAND_2;
    } else if (earfcn >= 0) {
        return EutranBand.BAND_1;
    }
    return INVALID_BAND;
}
Body of Second Method:
{
    if (earfcn > 70645) {
        return INVALID_BAND;
    } else if (earfcn >= 70596) {
        return EutranBand.BAND_88;
    } else if (earfcn >= 70546) {
        return EutranBand.BAND_87;
    } else if (earfcn >= 70366) {
        return EutranBand.BAND_85;
    } else if (earfcn > 69465) {
        return INVALID_BAND;
    } else if (earfcn >= 69036) {
        return EutranBand.BAND_74;
    } else if (earfcn >= 68986) {
        return EutranBand.BAND_73;
    } else if (earfcn >= 68936) {
        return EutranBand.BAND_72;
    } else if (earfcn >= 68586) {
        return EutranBand.BAND_71;
    } else if (earfcn >= 68336) {
        return EutranBand.BAND_70;
    } else if (earfcn > 67835) {
        return INVALID_BAND;
    } else if (earfcn >= 67536) {
        return EutranBand.BAND_68;
    } else if (earfcn >= 67366) {
        // band 67 only for CarrierAgg
        return INVALID_BAND;
    } else if (earfcn >= 66436) {
        return EutranBand.BAND_66;
    } else if (earfcn >= 65536) {
        return EutranBand.BAND_65;
    } else if (earfcn > 60254) {
        return INVALID_BAND;
    } else if (earfcn >= 60140) {
        return EutranBand.BAND_53;
    } else if (earfcn >= 59140) {
        return EutranBand.BAND_52;
    } else if (earfcn >= 59090) {
        return EutranBand.BAND_51;
    } else if (earfcn >= 58240) {
        return EutranBand.BAND_50;
    } else if (earfcn >= 56740) {
        return EutranBand.BAND_49;
    } else if (earfcn >= 55240) {
        return EutranBand.BAND_48;
    } else if (earfcn >= 54540) {
        return EutranBand.BAND_47;
    } else if (earfcn >= 46790) {
        return EutranBand.BAND_46;
    } else if (earfcn >= 46590) {
        return EutranBand.BAND_45;
    } else if (earfcn >= 45590) {
        return EutranBand.BAND_44;
    } else if (earfcn >= 43590) {
        return EutranBand.BAND_43;
    } else if (earfcn >= 41590) {
        return EutranBand.BAND_42;
    } else if (earfcn >= 39650) {
        return EutranBand.BAND_41;
    } else if (earfcn >= 38650) {
        return EutranBand.BAND_40;
    } else if (earfcn >= 38250) {
        return EutranBand.BAND_39;
    } else if (earfcn >= 37750) {
        return EutranBand.BAND_38;
    } else if (earfcn >= 37550) {
        return EutranBand.BAND_37;
    } else if (earfcn >= 36950) {
        return EutranBand.BAND_36;
    } else if (earfcn >= 36350) {
        return EutranBand.BAND_35;
    } else if (earfcn >= 36200) {
        return EutranBand.BAND_34;
    } else if (earfcn >= 36000) {
        return EutranBand.BAND_33;
    } else if (earfcn > 10359) {
        return INVALID_BAND;
    } else if (earfcn >= 9920) {
        // band 32 only for CarrierAgg
        return INVALID_BAND;
    } else if (earfcn >= 9870) {
        return EutranBand.BAND_31;
    } else if (earfcn >= 9770) {
        return EutranBand.BAND_30;
    } else if (earfcn >= 9660) {
        // band 29 only for CarrierAgg
        return INVALID_BAND;
    } else if (earfcn >= 9210) {
        return EutranBand.BAND_28;
    } else if (earfcn >= 9040) {
        return EutranBand.BAND_27;
    } else if (earfcn >= 8690) {
        return EutranBand.BAND_26;
    } else if (earfcn >= 8040) {
        return EutranBand.BAND_25;
    } else if (earfcn >= 7700) {
        return EutranBand.BAND_24;
    } else if (earfcn >= 7500) {
        return EutranBand.BAND_23;
    } else if (earfcn >= 6600) {
        return EutranBand.BAND_22;
    } else if (earfcn >= 6450) {
        return EutranBand.BAND_21;
    } else if (earfcn >= 6150) {
        return EutranBand.BAND_20;
    } else if (earfcn >= 6000) {
        return EutranBand.BAND_19;
    } else if (earfcn >= 5850) {
        return EutranBand.BAND_18;
    } else if (earfcn >= 5730) {
        return EutranBand.BAND_17;
    } else if (earfcn > 5379) {
        return INVALID_BAND;
    } else if (earfcn >= 5280) {
        return EutranBand.BAND_14;
    } else if (earfcn >= 5180) {
        return EutranBand.BAND_13;
    } else if (earfcn >= 5010) {
        return EutranBand.BAND_12;
    } else if (earfcn >= 4750) {
        return EutranBand.BAND_11;
    } else if (earfcn >= 4150) {
        return EutranBand.BAND_10;
    } else if (earfcn >= 3800) {
        return EutranBand.BAND_9;
    } else if (earfcn >= 3450) {
        return EutranBand.BAND_8;
    } else if (earfcn >= 2750) {
        return EutranBand.BAND_7;
    } else if (earfcn >= 2650) {
        return EutranBand.BAND_6;
    } else if (earfcn >= 2400) {
        return EutranBand.BAND_5;
    } else if (earfcn >= 1950) {
        return EutranBand.BAND_4;
    } else if (earfcn >= 1200) {
        return EutranBand.BAND_3;
    } else if (earfcn >= 600) {
        return EutranBand.BAND_2;
    } else if (earfcn >= 0) {
        return EutranBand.BAND_1;
    }
    return INVALID_BAND;
}
------------------------
Find a silently evolved API code:android.widget.ToggleButton.setTextOn:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the text for when the button is in the checked state.
 *
 * @param textOn The text.
 */

Body of Frist Method:
{
    mTextOn = textOn;
}
Body of Second Method:
{
    mTextOn = textOn;
    // Default state is derived from on/off-text, so state has to be updated when on/off-text
    // are updated.
    setDefaultStateDescritption();
}
------------------------
Find a silently evolved API code:android.telephony.ims.ImsCallSessionListener.callSessionMergeStarted:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Compatibility method for older implementations.
 * See {@link #callSessionMergeStarted(ImsCallSessionImplBase, ImsCallProfile)}.
 *
 * @hide
 */

Body of Frist Method:
{
    try {
        mListener.callSessionMergeStarted(newSession, profile);
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}
Body of Second Method:
{
    try {
        mListener.callSessionMergeStarted(newSession, profile);
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.view.accessibility.AccessibilityRecord.clear:COMMENT
Method Modifier: default     
Comment:/**
 * Clears the state of this instance.
 */

Body of Frist Method:
{
    mSealed = false;
    mBooleanProperties = 0;
    mCurrentItemIndex = UNDEFINED;
    mItemCount = UNDEFINED;
    mFromIndex = UNDEFINED;
    mToIndex = UNDEFINED;
    mScrollX = UNDEFINED;
    mScrollY = UNDEFINED;
    mMaxScrollX = UNDEFINED;
    mMaxScrollY = UNDEFINED;
    mAddedCount = UNDEFINED;
    mRemovedCount = UNDEFINED;
    mClassName = null;
    mContentDescription = null;
    mBeforeText = null;
    mParcelableData = null;
    mText.clear();
    mSourceNodeId = AccessibilityNodeInfo.UNDEFINED_ITEM_ID;
    mSourceWindowId = AccessibilityWindowInfo.UNDEFINED_WINDOW_ID;
    mConnectionId = UNDEFINED;
}
Body of Second Method:
{
    mSealed = false;
    mBooleanProperties = 0;
    mCurrentItemIndex = UNDEFINED;
    mItemCount = UNDEFINED;
    mFromIndex = UNDEFINED;
    mToIndex = UNDEFINED;
    mScrollX = 0;
    mScrollY = 0;
    mMaxScrollX = 0;
    mMaxScrollY = 0;
    mScrollDeltaX = UNDEFINED;
    mScrollDeltaY = UNDEFINED;
    mAddedCount = UNDEFINED;
    mRemovedCount = UNDEFINED;
    mClassName = null;
    mContentDescription = null;
    mBeforeText = null;
    mParcelableData = null;
    mText.clear();
    mSourceNodeId = AccessibilityNodeInfo.UNDEFINED_ITEM_ID;
    mSourceWindowId = AccessibilityWindowInfo.UNDEFINED_WINDOW_ID;
    mConnectionId = UNDEFINED;
}
------------------------
Find a silently evolved API code:android.media.soundtrigger.SoundTriggerManager.loadSoundModel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Loads a given sound model into the sound trigger. Note the model will be unloaded if there is
 * an error/the system service is restarted.
 * @hide
 */

Body of Frist Method:
{
    if (soundModel == null) {
        return STATUS_ERROR;
    }
    try {
        switch(soundModel.type) {
            case SoundModel.TYPE_GENERIC_SOUND:
                return mSoundTriggerService.loadGenericSoundModel((GenericSoundModel) soundModel);
            case SoundModel.TYPE_KEYPHRASE:
                return mSoundTriggerService.loadKeyphraseSoundModel((KeyphraseSoundModel) soundModel);
            default:
                Slog.e(TAG, "Unkown model type");
                return STATUS_ERROR;
        }
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    if (soundModel == null) {
        return STATUS_ERROR;
    }
    try {
        switch(soundModel.getType()) {
            case SoundModel.TYPE_GENERIC_SOUND:
                return mSoundTriggerService.loadGenericSoundModel((GenericSoundModel) soundModel);
            case SoundModel.TYPE_KEYPHRASE:
                return mSoundTriggerService.loadKeyphraseSoundModel((KeyphraseSoundModel) soundModel);
            default:
                Slog.e(TAG, "Unkown model type");
                return STATUS_ERROR;
        }
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.app.prediction.AppTarget.Builder.setTarget:COMMENT
Method Modifier: public      hidden      deprecated  
Comment:/**
 * @deprecated Use the appropriate constructor.
 * @removed
 */

Body of Frist Method:
{
    if (mPackageName != null) {
        throw new IllegalArgumentException("Target is already set");
    }
    mPackageName = Preconditions.checkNotNull(packageName);
    mUser = Preconditions.checkNotNull(user);
    return this;
}
Body of Second Method:
{
    setTarget(info.getPackage(), info.getUserHandle());
    mShortcutInfo = Objects.requireNonNull(info);
    return this;
}
------------------------
Find a silently evolved API code:android.hardware.display.DisplayManagerGlobal.getDisplayInfo:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get information about a particular logical display.
 *
 * @param displayId The logical display id.
 * @return Information about the specified display, or null if it does not exist.
 * This object belongs to an internal cache and should be treated as if it were immutable.
 */

Body of Frist Method:
{
    try {
        synchronized (mLock) {
            DisplayInfo info;
            if (USE_CACHE) {
                info = mDisplayInfoCache.get(displayId);
                if (info != null) {
                    return info;
                }
            }
            info = mDm.getDisplayInfo(displayId);
            if (info == null) {
                return null;
            }
            if (USE_CACHE) {
                mDisplayInfoCache.put(displayId, info);
            }
            registerCallbackIfNeededLocked();
            if (DEBUG) {
                Log.d(TAG, "getDisplayInfo: displayId=" + displayId + ", info=" + info);
            }
            return info;
        }
    } catch (RemoteException ex) {
        throw ex.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    synchronized (mLock) {
        return getDisplayInfoLocked(displayId);
    }
}
------------------------
Find a silently evolved API code:android.speech.SpeechRecognizer.handleCancelMessage:COMMENT
Method Modifier: private     
Comment:/**
 * sends the actual message to the service
 */

Body of Frist Method:
{
    if (!checkOpenConnection()) {
        return;
    }
    try {
        mService.cancel(mListener);
        if (DBG)
            Log.d(TAG, "service cancel command succeded");
    } catch (final RemoteException e) {
        Log.e(TAG, "cancel() failed", e);
        mListener.onError(ERROR_CLIENT);
    }
}
Body of Second Method:
{
    if (!checkOpenConnection()) {
        return;
    }
    try {
        mService.cancel(mListener, mContext.getOpPackageName(), mContext.getAttributionTag());
        if (DBG)
            Log.d(TAG, "service cancel command succeded");
    } catch (final RemoteException e) {
        Log.e(TAG, "cancel() failed", e);
        mListener.onError(ERROR_CLIENT);
    }
}
------------------------
Find a silently evolved API code:android.net.TrafficStats.getUidTxPackets:COMMENT
Method Modifier: public      static      
Comment:/**
 * Return number of packets transmitted by the given UID since device boot.
 * Counts packets across all network interfaces, and always increases
 * monotonically since device boot. Statistics are measured at the network
 * layer, so they include both TCP and UDP usage.
 * <p>
 * Before {@link android.os.Build.VERSION_CODES#JELLY_BEAN_MR2}, this may return
 * {@link #UNSUPPORTED} on devices where statistics aren't available.
 * <p>
 * Starting in {@link android.os.Build.VERSION_CODES#N} this will only
 * report traffic statistics for the calling UID. It will return
 * {@link #UNSUPPORTED} for all other UIDs for privacy reasons. To access
 * historical network statistics belonging to other UIDs, use
 * {@link NetworkStatsManager}.
 *
 * @see android.os.Process#myUid()
 * @see android.content.pm.ApplicationInfo#uid
 */

Body of Frist Method:
{
    // This isn't actually enforcing any security; it just returns the
    // unsupported value. The real filtering is done at the kernel level.
    final int callingUid = android.os.Process.myUid();
    if (callingUid == android.os.Process.SYSTEM_UID || callingUid == uid) {
        try {
            return getStatsService().getUidStats(uid, TYPE_TX_PACKETS);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
    } else {
        return UNSUPPORTED;
    }
}
Body of Second Method:
{
    try {
        return getStatsService().getUidStats(uid, TYPE_TX_PACKETS);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.hardware.Sensor.setType:COMMENT
Method Modifier: private     
Comment:/**
 * Sets the Type associated with the sensor.
 * NOTE: to be used only by native bindings in SensorManager.
 *
 * This allows interned static strings to be used across all representations of the Sensor. If
 * a sensor type is not referenced here, it will still be interned by the native SensorManager.
 *
 * @return {@code true} if the StringType was successfully set, {@code false} otherwise.
 */

Body of Frist Method:
{
    mType = value;
    switch(mType) {
        case TYPE_ACCELEROMETER:
            mStringType = STRING_TYPE_ACCELEROMETER;
            return true;
        case TYPE_AMBIENT_TEMPERATURE:
            mStringType = STRING_TYPE_AMBIENT_TEMPERATURE;
            return true;
        case TYPE_GAME_ROTATION_VECTOR:
            mStringType = STRING_TYPE_GAME_ROTATION_VECTOR;
            return true;
        case TYPE_GEOMAGNETIC_ROTATION_VECTOR:
            mStringType = STRING_TYPE_GEOMAGNETIC_ROTATION_VECTOR;
            return true;
        case TYPE_GLANCE_GESTURE:
            mStringType = STRING_TYPE_GLANCE_GESTURE;
            return true;
        case TYPE_GRAVITY:
            mStringType = STRING_TYPE_GRAVITY;
            return true;
        case TYPE_GYROSCOPE:
            mStringType = STRING_TYPE_GYROSCOPE;
            return true;
        case TYPE_GYROSCOPE_UNCALIBRATED:
            mStringType = STRING_TYPE_GYROSCOPE_UNCALIBRATED;
            return true;
        case TYPE_HEART_RATE:
            mStringType = STRING_TYPE_HEART_RATE;
            return true;
        case TYPE_LIGHT:
            mStringType = STRING_TYPE_LIGHT;
            return true;
        case TYPE_LINEAR_ACCELERATION:
            mStringType = STRING_TYPE_LINEAR_ACCELERATION;
            return true;
        case TYPE_MAGNETIC_FIELD:
            mStringType = STRING_TYPE_MAGNETIC_FIELD;
            return true;
        case TYPE_MAGNETIC_FIELD_UNCALIBRATED:
            mStringType = STRING_TYPE_MAGNETIC_FIELD_UNCALIBRATED;
            return true;
        case TYPE_PICK_UP_GESTURE:
            mStringType = STRING_TYPE_PICK_UP_GESTURE;
            return true;
        case TYPE_PRESSURE:
            mStringType = STRING_TYPE_PRESSURE;
            return true;
        case TYPE_PROXIMITY:
            mStringType = STRING_TYPE_PROXIMITY;
            return true;
        case TYPE_RELATIVE_HUMIDITY:
            mStringType = STRING_TYPE_RELATIVE_HUMIDITY;
            return true;
        case TYPE_ROTATION_VECTOR:
            mStringType = STRING_TYPE_ROTATION_VECTOR;
            return true;
        case TYPE_SIGNIFICANT_MOTION:
            mStringType = STRING_TYPE_SIGNIFICANT_MOTION;
            return true;
        case TYPE_STEP_COUNTER:
            mStringType = STRING_TYPE_STEP_COUNTER;
            return true;
        case TYPE_STEP_DETECTOR:
            mStringType = STRING_TYPE_STEP_DETECTOR;
            return true;
        case TYPE_TILT_DETECTOR:
            mStringType = SENSOR_STRING_TYPE_TILT_DETECTOR;
            return true;
        case TYPE_WAKE_GESTURE:
            mStringType = STRING_TYPE_WAKE_GESTURE;
            return true;
        case TYPE_ORIENTATION:
            mStringType = STRING_TYPE_ORIENTATION;
            return true;
        case TYPE_TEMPERATURE:
            mStringType = STRING_TYPE_TEMPERATURE;
            return true;
        case TYPE_DEVICE_ORIENTATION:
            mStringType = STRING_TYPE_DEVICE_ORIENTATION;
            return true;
        case TYPE_DYNAMIC_SENSOR_META:
            mStringType = STRING_TYPE_DYNAMIC_SENSOR_META;
            return true;
        case TYPE_LOW_LATENCY_OFFBODY_DETECT:
            mStringType = STRING_TYPE_LOW_LATENCY_OFFBODY_DETECT;
            return true;
        case TYPE_ACCELEROMETER_UNCALIBRATED:
            mStringType = STRING_TYPE_ACCELEROMETER_UNCALIBRATED;
            return true;
        default:
            return false;
    }
}
Body of Second Method:
{
    mType = value;
    switch(mType) {
        case TYPE_ACCELEROMETER:
            mStringType = STRING_TYPE_ACCELEROMETER;
            return true;
        case TYPE_AMBIENT_TEMPERATURE:
            mStringType = STRING_TYPE_AMBIENT_TEMPERATURE;
            return true;
        case TYPE_GAME_ROTATION_VECTOR:
            mStringType = STRING_TYPE_GAME_ROTATION_VECTOR;
            return true;
        case TYPE_GEOMAGNETIC_ROTATION_VECTOR:
            mStringType = STRING_TYPE_GEOMAGNETIC_ROTATION_VECTOR;
            return true;
        case TYPE_GLANCE_GESTURE:
            mStringType = STRING_TYPE_GLANCE_GESTURE;
            return true;
        case TYPE_GRAVITY:
            mStringType = STRING_TYPE_GRAVITY;
            return true;
        case TYPE_GYROSCOPE:
            mStringType = STRING_TYPE_GYROSCOPE;
            return true;
        case TYPE_GYROSCOPE_UNCALIBRATED:
            mStringType = STRING_TYPE_GYROSCOPE_UNCALIBRATED;
            return true;
        case TYPE_HEART_RATE:
            mStringType = STRING_TYPE_HEART_RATE;
            return true;
        case TYPE_LIGHT:
            mStringType = STRING_TYPE_LIGHT;
            return true;
        case TYPE_LINEAR_ACCELERATION:
            mStringType = STRING_TYPE_LINEAR_ACCELERATION;
            return true;
        case TYPE_MAGNETIC_FIELD:
            mStringType = STRING_TYPE_MAGNETIC_FIELD;
            return true;
        case TYPE_MAGNETIC_FIELD_UNCALIBRATED:
            mStringType = STRING_TYPE_MAGNETIC_FIELD_UNCALIBRATED;
            return true;
        case TYPE_PICK_UP_GESTURE:
            mStringType = STRING_TYPE_PICK_UP_GESTURE;
            return true;
        case TYPE_PRESSURE:
            mStringType = STRING_TYPE_PRESSURE;
            return true;
        case TYPE_PROXIMITY:
            mStringType = STRING_TYPE_PROXIMITY;
            return true;
        case TYPE_RELATIVE_HUMIDITY:
            mStringType = STRING_TYPE_RELATIVE_HUMIDITY;
            return true;
        case TYPE_ROTATION_VECTOR:
            mStringType = STRING_TYPE_ROTATION_VECTOR;
            return true;
        case TYPE_SIGNIFICANT_MOTION:
            mStringType = STRING_TYPE_SIGNIFICANT_MOTION;
            return true;
        case TYPE_STEP_COUNTER:
            mStringType = STRING_TYPE_STEP_COUNTER;
            return true;
        case TYPE_STEP_DETECTOR:
            mStringType = STRING_TYPE_STEP_DETECTOR;
            return true;
        case TYPE_TILT_DETECTOR:
            mStringType = SENSOR_STRING_TYPE_TILT_DETECTOR;
            return true;
        case TYPE_WAKE_GESTURE:
            mStringType = STRING_TYPE_WAKE_GESTURE;
            return true;
        case TYPE_ORIENTATION:
            mStringType = STRING_TYPE_ORIENTATION;
            return true;
        case TYPE_TEMPERATURE:
            mStringType = STRING_TYPE_TEMPERATURE;
            return true;
        case TYPE_DEVICE_ORIENTATION:
            mStringType = STRING_TYPE_DEVICE_ORIENTATION;
            return true;
        case TYPE_DYNAMIC_SENSOR_META:
            mStringType = STRING_TYPE_DYNAMIC_SENSOR_META;
            return true;
        case TYPE_LOW_LATENCY_OFFBODY_DETECT:
            mStringType = STRING_TYPE_LOW_LATENCY_OFFBODY_DETECT;
            return true;
        case TYPE_ACCELEROMETER_UNCALIBRATED:
            mStringType = STRING_TYPE_ACCELEROMETER_UNCALIBRATED;
            return true;
        case TYPE_HINGE_ANGLE:
            mStringType = STRING_TYPE_HINGE_ANGLE;
        default:
            return false;
    }
}
------------------------
Find a silently evolved API code:android.companion.BluetoothLeDeviceFilter.matches:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    boolean result = matches(device.getDevice()) && (mRawDataFilter == null || BitUtils.maskedEquals(device.getScanRecord().getBytes(), mRawDataFilter, mRawDataFilterMask));
    if (DEBUG)
        Log.i(LOG_TAG, "matches(this = " + this + ", device = " + device + ") -> " + result);
    return result;
}
Body of Second Method:
{
    BluetoothDevice device = scanResult.getDevice();
    boolean result = getScanFilter().matches(scanResult) && BluetoothDeviceFilterUtils.matchesName(getNamePattern(), device) && (mRawDataFilter == null || BitUtils.maskedEquals(scanResult.getScanRecord().getBytes(), mRawDataFilter, mRawDataFilterMask));
    if (DEBUG)
        Log.i(LOG_TAG, "matches(this = " + this + ", device = " + device + ") -> " + result);
    return result;
}
------------------------
Find a silently evolved API code:android.util.Half.getSignificand:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns the significand, or mantissa, used in the representation
 * of the specified half-precision float value.
 *
 * @param h A half-precision float value
 * @return The significand, or significand, of the specified vlaue
 */

Body of Frist Method:
{
    return h & FP16_SIGNIFICAND_MASK;
}
Body of Second Method:
{
    return h & FP16.SIGNIFICAND_MASK;
}
------------------------
Find a silently evolved API code:android.net.LinkAddress.getFlags:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the flags of this {@code LinkAddress}.
 */

Body of Frist Method:
{
    return flags;
}
Body of Second Method:
{
    int flags = this.flags;
    if (deprecationTime != LIFETIME_UNKNOWN) {
        if (SystemClock.elapsedRealtime() >= deprecationTime) {
            flags |= IFA_F_DEPRECATED;
        } else {
            // If deprecation time is in the future, or permanent.
            flags &= ~IFA_F_DEPRECATED;
        }
    }
    if (expirationTime == LIFETIME_PERMANENT) {
        flags |= IFA_F_PERMANENT;
    } else if (expirationTime != LIFETIME_UNKNOWN) {
        // If we know this address expired or will expire in the future, then this address
        // should not be permanent.
        flags &= ~IFA_F_PERMANENT;
    }
    // Do no touch the original flags. Return the adjusted flags here.
    return flags;
}
------------------------
Find a silently evolved API code:android.util.EventLog.Event.getData:COMMENT
Method Modifier: public      
Comment:/**
 * @return one of Integer, Long, Float, String, null, or Object[] of same.
 */

Body of Frist Method:
{
    try {
        int offset = mBuffer.getShort(HEADER_SIZE_OFFSET);
        if (offset == 0) {
            offset = V1_PAYLOAD_START;
        }
        mBuffer.limit(offset + mBuffer.getShort(LENGTH_OFFSET));
        if ((offset + DATA_OFFSET) >= mBuffer.limit()) {
            // no payload
            return null;
        }
        // Just after the tag.
        mBuffer.position(offset + DATA_OFFSET);
        return decodeObject();
    } catch (IllegalArgumentException e) {
        Log.wtf(TAG, "Illegal entry payload: tag=" + getTag(), e);
        mLastWtf = e;
        return null;
    } catch (BufferUnderflowException e) {
        Log.wtf(TAG, "Truncated entry payload: tag=" + getTag(), e);
        mLastWtf = e;
        return null;
    }
}
Body of Second Method:
{
    try {
        int offset = getHeaderSize();
        mBuffer.limit(offset + mBuffer.getShort(LENGTH_OFFSET));
        if ((offset + TAG_LENGTH) >= mBuffer.limit()) {
            // no payload
            return null;
        }
        // Just after the tag.
        mBuffer.position(offset + TAG_LENGTH);
        return decodeObject();
    } catch (IllegalArgumentException e) {
        Log.wtf(TAG, "Illegal entry payload: tag=" + getTag(), e);
        mLastWtf = e;
        return null;
    } catch (BufferUnderflowException e) {
        Log.wtf(TAG, "Truncated entry payload: tag=" + getTag(), e);
        mLastWtf = e;
        return null;
    }
}
------------------------
Find a silently evolved API code:android.net.MacAddress.getAddressType:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the type of this address.
 *
 * @return the int constant representing the MAC address type of this MacAddress.
 */

Body of Frist Method:
{
    if (equals(BROADCAST_ADDRESS)) {
        return TYPE_BROADCAST;
    }
    if (isMulticastAddress()) {
        return TYPE_MULTICAST;
    }
    return TYPE_UNICAST;
}
Body of Second Method:
{
    if (equals(BROADCAST_ADDRESS)) {
        return TYPE_BROADCAST;
    }
    if ((mAddr & MULTICAST_MASK) != 0) {
        return TYPE_MULTICAST;
    }
    return TYPE_UNICAST;
}
------------------------
Find a silently evolved API code:android.util.Half.halfToIntBits:COMMENT
Method Modifier: public      static      
Comment:/**
 * <p>Returns a representation of the specified half-precision float value
 * according to the bit layout described in {@link Half}.</p>
 *
 * <p>Unlike {@link #halfToRawIntBits(short)}, this method collapses all
 * possible Not-a-Number values to a single canonical Not-a-Number value
 * defined by {@link #NaN}.</p>
 *
 * @param h A half-precision float value
 * @return The bits that represent the half-precision float value
 *
 * @see #halfToRawIntBits(short)
 * @see #halfToShortBits(short)
 * @see #intBitsToHalf(int)
 */

Body of Frist Method:
{
    return (h & FP16_COMBINED) > FP16_EXPONENT_MAX ? NaN : h & 0xffff;
}
Body of Second Method:
{
    return (h & FP16.EXPONENT_SIGNIFICAND_MASK) > FP16.POSITIVE_INFINITY ? NaN : h & 0xffff;
}
------------------------
Find a silently evolved API code:android.app.servertransaction.StopActivityItem.writeToParcel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Write to Parcel.
 */

Body of Frist Method:
{
    dest.writeBoolean(mShowWindow);
    dest.writeInt(mConfigChanges);
}
Body of Second Method:
{
    dest.writeInt(mConfigChanges);
}
------------------------
Find a silently evolved API code:android.content.om.OverlayInfo.isEnabled:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Return true if this overlay is enabled, i.e. should be used to overlay
 * the resources in the target package.
 *
 * Disabled overlay packages are installed but are currently not in use.
 *
 * @return true if the overlay is enabled, else false.
 * @hide
 */

Body of Frist Method:
{
    switch(state) {
        case STATE_ENABLED:
        case STATE_ENABLED_STATIC:
            return true;
        default:
            return false;
    }
}
Body of Second Method:
{
    switch(state) {
        case STATE_ENABLED:
        case STATE_ENABLED_IMMUTABLE:
            return true;
        default:
            return false;
    }
}
------------------------
Find a silently evolved API code:android.app.admin.DevicePolicyEventLogger.write:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Writes the metric to {@link StatsLog}.
 */

Body of Frist Method:
{
    byte[] bytes = stringArrayValueToBytes(mStringArrayValue);
    StatsLog.write(StatsLog.DEVICE_POLICY_EVENT, mEventId, mAdminPackageName, mIntValue, mBooleanValue, mTimePeriodMs, bytes);
}
Body of Second Method:
{
    byte[] bytes = stringArrayValueToBytes(mStringArrayValue);
    FrameworkStatsLog.write(FrameworkStatsLog.DEVICE_POLICY_EVENT, mEventId, mAdminPackageName, mIntValue, mBooleanValue, mTimePeriodMs, bytes);
}
------------------------
Find a silently evolved API code:android.widget.ListPopupWindow.onKeyDown:COMMENT
Method Modifier: public      
Comment:/**
 * Filter key down events. By forwarding key down events to this function,
 * views using non-modal ListPopupWindow can have it handle key selection of items.
 *
 * @param keyCode keyCode param passed to the host view's onKeyDown
 * @param event event param passed to the host view's onKeyDown
 * @return true if the event was handled, false if it was ignored.
 *
 * @see #setModal(boolean)
 * @see #onKeyUp(int, KeyEvent)
 */

Body of Frist Method:
{
    // when the drop down is shown, we drive it directly
    if (isShowing()) {
        // to select one of its items
        if (keyCode != KeyEvent.KEYCODE_SPACE && (mDropDownList.getSelectedItemPosition() >= 0 || !KeyEvent.isConfirmKey(keyCode))) {
            int curIndex = mDropDownList.getSelectedItemPosition();
            boolean consumed;
            final boolean below = !mPopup.isAboveAnchor();
            final ListAdapter adapter = mAdapter;
            boolean allEnabled;
            int firstItem = Integer.MAX_VALUE;
            int lastItem = Integer.MIN_VALUE;
            if (adapter != null) {
                allEnabled = adapter.areAllItemsEnabled();
                firstItem = allEnabled ? 0 : mDropDownList.lookForSelectablePosition(0, true);
                lastItem = allEnabled ? adapter.getCount() - 1 : mDropDownList.lookForSelectablePosition(adapter.getCount() - 1, false);
            }
            if ((below && keyCode == KeyEvent.KEYCODE_DPAD_UP && curIndex <= firstItem) || (!below && keyCode == KeyEvent.KEYCODE_DPAD_DOWN && curIndex >= lastItem)) {
                // When the selection is at the top, we block the key
                // event to prevent focus from moving.
                clearListSelection();
                mPopup.setInputMethodMode(PopupWindow.INPUT_METHOD_NEEDED);
                show();
                return true;
            } else {
                // WARNING: Please read the comment where mListSelectionHidden
                // is declared
                mDropDownList.setListSelectionHidden(false);
            }
            consumed = mDropDownList.onKeyDown(keyCode, event);
            if (DEBUG)
                Log.v(TAG, "Key down: code=" + keyCode + " list consumed=" + consumed);
            if (consumed) {
                // If it handled the key event, then the user is
                // navigating in the list, so we should put it in front.
                mPopup.setInputMethodMode(PopupWindow.INPUT_METHOD_NOT_NEEDED);
                // Here's a little trick we need to do to make sure that
                // the list view is actually showing its focus indicator,
                // by ensuring it has focus and getting its window out
                // of touch mode.
                mDropDownList.requestFocusFromTouch();
                show();
                switch(keyCode) {
                    // next component
                    case KeyEvent.KEYCODE_ENTER:
                    case KeyEvent.KEYCODE_DPAD_CENTER:
                    case KeyEvent.KEYCODE_DPAD_DOWN:
                    case KeyEvent.KEYCODE_DPAD_UP:
                        return true;
                }
            } else {
                if (below && keyCode == KeyEvent.KEYCODE_DPAD_DOWN) {
                    // event to avoid going to the next focusable widget
                    if (curIndex == lastItem) {
                        return true;
                    }
                } else if (!below && keyCode == KeyEvent.KEYCODE_DPAD_UP && curIndex == firstItem) {
                    return true;
                }
            }
        }
    }
    return false;
}
Body of Second Method:
{
    // when the drop down is shown, we drive it directly
    if (isShowing()) {
        // to select one of its items
        if (keyCode != KeyEvent.KEYCODE_SPACE && (mDropDownList.getSelectedItemPosition() >= 0 || !KeyEvent.isConfirmKey(keyCode))) {
            int curIndex = mDropDownList.getSelectedItemPosition();
            boolean consumed;
            final boolean below = !mPopup.isAboveAnchor();
            final ListAdapter adapter = mAdapter;
            boolean allEnabled;
            int firstItem = Integer.MAX_VALUE;
            int lastItem = Integer.MIN_VALUE;
            if (adapter != null) {
                allEnabled = adapter.areAllItemsEnabled();
                firstItem = allEnabled ? 0 : mDropDownList.lookForSelectablePosition(0, true);
                lastItem = allEnabled ? adapter.getCount() - 1 : mDropDownList.lookForSelectablePosition(adapter.getCount() - 1, false);
            }
            if ((below && keyCode == KeyEvent.KEYCODE_DPAD_UP && curIndex <= firstItem) || (!below && keyCode == KeyEvent.KEYCODE_DPAD_DOWN && curIndex >= lastItem)) {
                // When the selection is at the top, we block the key
                // event to prevent focus from moving.
                clearListSelection();
                mPopup.setInputMethodMode(PopupWindow.INPUT_METHOD_NEEDED);
                show();
                return true;
            } else {
                // WARNING: Please read the comment where mListSelectionHidden
                // is declared
                mDropDownList.setListSelectionHidden(false);
            }
            consumed = mDropDownList.onKeyDown(keyCode, event);
            if (DEBUG)
                Log.v(TAG, "Key down: code=" + keyCode + " list consumed=" + consumed);
            if (consumed) {
                // If it handled the key event, then the user is
                // navigating in the list, so we should put it in front.
                mPopup.setInputMethodMode(PopupWindow.INPUT_METHOD_NOT_NEEDED);
                // Here's a little trick we need to do to make sure that
                // the list view is actually showing its focus indicator,
                // by ensuring it has focus and getting its window out
                // of touch mode.
                mDropDownList.requestFocusFromTouch();
                show();
                switch(keyCode) {
                    // next component
                    case KeyEvent.KEYCODE_ENTER:
                    case KeyEvent.KEYCODE_DPAD_CENTER:
                    case KeyEvent.KEYCODE_DPAD_DOWN:
                    case KeyEvent.KEYCODE_DPAD_UP:
                    case KeyEvent.KEYCODE_NUMPAD_ENTER:
                        return true;
                }
            } else {
                if (below && keyCode == KeyEvent.KEYCODE_DPAD_DOWN) {
                    // event to avoid going to the next focusable widget
                    if (curIndex == lastItem) {
                        return true;
                    }
                } else if (!below && keyCode == KeyEvent.KEYCODE_DPAD_UP && curIndex == firstItem) {
                    return true;
                }
            }
        }
    }
    return false;
}
------------------------
Find a silently evolved API code:android.media.AudioAttributes.Builder.setFlags:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the combination of flags.
 *
 * This is a bitwise OR with the existing flags.
 * @param flags a combination of {@link AudioAttributes#FLAG_AUDIBILITY_ENFORCED},
 * {@link AudioAttributes#FLAG_HW_AV_SYNC}.
 * @return the same Builder instance.
 */

Body of Frist Method:
{
    flags &= AudioAttributes.FLAG_ALL;
    mFlags |= flags;
    return this;
}
Body of Second Method:
{
    flags &= AudioAttributes.FLAG_ALL_API_SET;
    mFlags |= flags;
    return this;
}
------------------------
Find a silently evolved API code:android.app.StatusBarManager.DisableInfo.setEnableAll:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    mStatusBarExpansion = false;
    mNavigateHome = false;
    mNotificationPeeking = false;
    mRecents = false;
    mSearch = false;
}
Body of Second Method:
{
    mStatusBarExpansion = false;
    mNavigateHome = false;
    mNotificationPeeking = false;
    mRecents = false;
    mSearch = false;
    mSystemIcons = false;
    mClock = false;
    mNotificationIcons = false;
}
------------------------
Find a silently evolved API code:android.telephony.CallQuality.writeToParcel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * {@link Parcelable#writeToParcel}
 */

Body of Frist Method:
{
    dest.writeInt(mDownlinkCallQualityLevel);
    dest.writeInt(mUplinkCallQualityLevel);
    dest.writeInt(mCallDuration);
    dest.writeInt(mNumRtpPacketsTransmitted);
    dest.writeInt(mNumRtpPacketsReceived);
    dest.writeInt(mNumRtpPacketsTransmittedLost);
    dest.writeInt(mNumRtpPacketsNotReceived);
    dest.writeInt(mAverageRelativeJitter);
    dest.writeInt(mMaxRelativeJitter);
    dest.writeInt(mAverageRoundTripTime);
    dest.writeInt(mCodecType);
}
Body of Second Method:
{
    dest.writeInt(mDownlinkCallQualityLevel);
    dest.writeInt(mUplinkCallQualityLevel);
    dest.writeInt(mCallDuration);
    dest.writeInt(mNumRtpPacketsTransmitted);
    dest.writeInt(mNumRtpPacketsReceived);
    dest.writeInt(mNumRtpPacketsTransmittedLost);
    dest.writeInt(mNumRtpPacketsNotReceived);
    dest.writeInt(mAverageRelativeJitter);
    dest.writeInt(mMaxRelativeJitter);
    dest.writeInt(mAverageRoundTripTime);
    dest.writeInt(mCodecType);
    dest.writeBoolean(mRtpInactivityDetected);
    dest.writeBoolean(mRxSilenceDetected);
    dest.writeBoolean(mTxSilenceDetected);
}
------------------------
Find a silently evolved API code:android.telephony.CellSignalStrengthNr.setDefaultValues:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    mCsiRsrp = CellInfo.UNAVAILABLE;
    mCsiRsrq = CellInfo.UNAVAILABLE;
    mCsiSinr = CellInfo.UNAVAILABLE;
    mSsRsrp = CellInfo.UNAVAILABLE;
    mSsRsrq = CellInfo.UNAVAILABLE;
    mSsSinr = CellInfo.UNAVAILABLE;
    mLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
}
Body of Second Method:
{
    mCsiRsrp = CellInfo.UNAVAILABLE;
    mCsiRsrq = CellInfo.UNAVAILABLE;
    mCsiSinr = CellInfo.UNAVAILABLE;
    mSsRsrp = CellInfo.UNAVAILABLE;
    mSsRsrq = CellInfo.UNAVAILABLE;
    mSsSinr = CellInfo.UNAVAILABLE;
    mLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    mParametersUseForLevel = USE_SSRSRP;
}
------------------------
Find a silently evolved API code:android.view.animation.DecelerateInterpolator.createNativeInterpolator:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return NativeInterpolatorFactoryHelper.createDecelerateInterpolator(mFactor);
}
Body of Second Method:
{
    return NativeInterpolatorFactory.createDecelerateInterpolator(mFactor);
}
------------------------
Find a silently evolved API code:android.content.ContentProviderClient.insert:COMMENT
Method Modifier: public      
Comment:/**
 * See {@link ContentProvider#insert ContentProvider.insert}
 */

Body of Frist Method:
{
    Preconditions.checkNotNull(url, "url");
    beforeRemote();
    try {
        return mContentProvider.insert(mPackageName, url, initialValues);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}
Body of Second Method:
{
    return insert(url, initialValues, null);
}
------------------------
Find a silently evolved API code:android.media.AudioDeviceInfo.isValidAudioDeviceTypeOut:COMMENT
Method Modifier: default     static      
Comment:/*package*/

Body of Frist Method:
{
    switch(type) {
        case TYPE_BUILTIN_EARPIECE:
        case TYPE_BUILTIN_SPEAKER:
        case TYPE_WIRED_HEADSET:
        case TYPE_WIRED_HEADPHONES:
        case TYPE_BLUETOOTH_SCO:
        case TYPE_BLUETOOTH_A2DP:
        case TYPE_HDMI:
        case TYPE_DOCK:
        case TYPE_USB_ACCESSORY:
        case TYPE_USB_DEVICE:
        case TYPE_USB_HEADSET:
        case TYPE_TELEPHONY:
        case TYPE_LINE_ANALOG:
        case TYPE_HDMI_ARC:
        case TYPE_LINE_DIGITAL:
        case TYPE_FM:
        case TYPE_AUX_LINE:
        case TYPE_IP:
        case TYPE_BUS:
        case TYPE_HEARING_AID:
            return true;
        default:
            return false;
    }
}
Body of Second Method:
{
    switch(type) {
        case TYPE_BUILTIN_EARPIECE:
        case TYPE_BUILTIN_SPEAKER:
        case TYPE_WIRED_HEADSET:
        case TYPE_WIRED_HEADPHONES:
        case TYPE_BLUETOOTH_SCO:
        case TYPE_BLUETOOTH_A2DP:
        case TYPE_HDMI:
        case TYPE_DOCK:
        case TYPE_USB_ACCESSORY:
        case TYPE_USB_DEVICE:
        case TYPE_USB_HEADSET:
        case TYPE_TELEPHONY:
        case TYPE_LINE_ANALOG:
        case TYPE_HDMI_ARC:
        case TYPE_LINE_DIGITAL:
        case TYPE_FM:
        case TYPE_AUX_LINE:
        case TYPE_IP:
        case TYPE_BUS:
        case TYPE_HEARING_AID:
        case TYPE_BUILTIN_SPEAKER_SAFE:
        case TYPE_REMOTE_SUBMIX:
            return true;
        default:
            return false;
    }
}
------------------------
Find a silently evolved API code:android.view.animation.OvershootInterpolator.createNativeInterpolator:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return NativeInterpolatorFactoryHelper.createOvershootInterpolator(mTension);
}
Body of Second Method:
{
    return NativeInterpolatorFactory.createOvershootInterpolator(mTension);
}
------------------------
Find a silently evolved API code:android.media.session.MediaController.TransportControls.seekTo:COMMENT
Method Modifier: public      
Comment:/**
 * Move to a new location in the media stream.
 *
 * @param pos Position to move to, in milliseconds.
 */

Body of Frist Method:
{
    try {
        mSessionBinder.seekTo(mContext.getPackageName(), mCbStub, pos);
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling seekTo.", e);
    }
}
Body of Second Method:
{
    try {
        mSessionBinder.seekTo(mContext.getPackageName(), pos);
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling seekTo.", e);
    }
}
------------------------
Find a silently evolved API code:android.view.MotionEvent.transform:COMMENT
Method Modifier: public      final       
Comment:/**
 * Applies a transformation matrix to all of the points in the event.
 *
 * @param matrix The transformation matrix to apply.
 */

Body of Frist Method:
{
    if (matrix == null) {
        throw new IllegalArgumentException("matrix must not be null");
    }
    nativeTransform(mNativePtr, matrix.native_instance);
}
Body of Second Method:
{
    if (matrix == null) {
        throw new IllegalArgumentException("matrix must not be null");
    }
    nativeTransform(mNativePtr, matrix);
}
------------------------
Find a silently evolved API code:android.app.ActivityView.setCallback:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Set the callback to be notified about state changes.
 * <p>This class must finish initializing before {@link #startActivity(Intent)} can be called.
 * <p>Note: If the instance was ready prior to this call being made, then
 * {@link StateCallback#onActivityViewReady(ActivityView)} will be called from within
 * this method call.
 *
 * @param callback The callback to report events to.
 *
 * @see StateCallback
 * @see #startActivity(Intent)
 */

Body of Frist Method:
{
    mActivityViewCallback = callback;
    if (mVirtualDisplay != null && mActivityViewCallback != null) {
        mActivityViewCallback.onActivityViewReady(this);
    }
}
Body of Second Method:
{
    if (callback == null) {
        mTaskEmbedder.setListener(null);
        return;
    }
    mTaskEmbedder.setListener(new StateCallbackAdapter(callback));
}
------------------------
Find a silently evolved API code:android.text.TextUtils.writeToParcel:COMMENT
Method Modifier: public      static      
Comment:/**
 * Flatten a CharSequence and whatever styles can be copied across processes
 * into the parcel.
 */

Body of Frist Method:
{
    if (cs instanceof Spanned) {
        p.writeInt(0);
        p.writeString(cs.toString());
        Spanned sp = (Spanned) cs;
        Object[] os = sp.getSpans(0, cs.length(), Object.class);
        for (int i = 0; i < os.length; i++) {
            Object o = os[i];
            Object prop = os[i];
            if (prop instanceof CharacterStyle) {
                prop = ((CharacterStyle) prop).getUnderlying();
            }
            if (prop instanceof ParcelableSpan) {
                final ParcelableSpan ps = (ParcelableSpan) prop;
                final int spanTypeId = ps.getSpanTypeIdInternal();
                if (spanTypeId < FIRST_SPAN || spanTypeId > LAST_SPAN) {
                    Log.e(TAG, "External class \"" + ps.getClass().getSimpleName() + "\" is attempting to use the frameworks-only ParcelableSpan" + " interface");
                } else {
                    p.writeInt(spanTypeId);
                    ps.writeToParcelInternal(p, parcelableFlags);
                    writeWhere(p, sp, o);
                }
            }
        }
        p.writeInt(0);
    } else {
        p.writeInt(1);
        if (cs != null) {
            p.writeString(cs.toString());
        } else {
            p.writeString(null);
        }
    }
}
Body of Second Method:
{
    if (cs instanceof Spanned) {
        p.writeInt(0);
        p.writeString8(cs.toString());
        Spanned sp = (Spanned) cs;
        Object[] os = sp.getSpans(0, cs.length(), Object.class);
        for (int i = 0; i < os.length; i++) {
            Object o = os[i];
            Object prop = os[i];
            if (prop instanceof CharacterStyle) {
                prop = ((CharacterStyle) prop).getUnderlying();
            }
            if (prop instanceof ParcelableSpan) {
                final ParcelableSpan ps = (ParcelableSpan) prop;
                final int spanTypeId = ps.getSpanTypeIdInternal();
                if (spanTypeId < FIRST_SPAN || spanTypeId > LAST_SPAN) {
                    Log.e(TAG, "External class \"" + ps.getClass().getSimpleName() + "\" is attempting to use the frameworks-only ParcelableSpan" + " interface");
                } else {
                    p.writeInt(spanTypeId);
                    ps.writeToParcelInternal(p, parcelableFlags);
                    writeWhere(p, sp, o);
                }
            }
        }
        p.writeInt(0);
    } else {
        p.writeInt(1);
        if (cs != null) {
            p.writeString8(cs.toString());
        } else {
            p.writeString8(null);
        }
    }
}
------------------------
Find a silently evolved API code:android.hardware.HardwareBuffer.isSupportedFormat:COMMENT
Method Modifier: private     static      
Comment:/**
 * Validates whether a particular format is supported by HardwareBuffer.
 *
 * @param format The format to validate.
 *
 * @return True if <code>format</code> is a supported format. false otherwise.
 * See {@link #create(int, int, int, int, long)}.
 */

Body of Frist Method:
{
    switch(format) {
        case RGBA_8888:
        case RGBA_FP16:
        case RGBA_1010102:
        case RGBX_8888:
        case RGB_565:
        case RGB_888:
        case BLOB:
        case D_16:
        case D_24:
        case DS_24UI8:
        case D_FP32:
        case DS_FP32UI8:
        case S_UI8:
            return true;
    }
    return false;
}
Body of Second Method:
{
    switch(format) {
        case RGBA_8888:
        case RGBA_FP16:
        case RGBA_1010102:
        case RGBX_8888:
        case RGB_565:
        case RGB_888:
        case BLOB:
        case YCBCR_420_888:
        case D_16:
        case D_24:
        case DS_24UI8:
        case D_FP32:
        case DS_FP32UI8:
        case S_UI8:
            return true;
    }
    return false;
}
------------------------
Find a silently evolved API code:android.text.Emoji.isEmoji:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Returns true if the character has Emoji property.
 */

Body of Frist Method:
{
    return isNewEmoji(codePoint) || UCharacter.hasBinaryProperty(codePoint, UProperty.EMOJI);
}
Body of Second Method:
{
    return UCharacter.hasBinaryProperty(codePoint, UProperty.EMOJI);
}
------------------------
Find a silently evolved API code:android.media.session.MediaController.TransportControls.skipToNext:COMMENT
Method Modifier: public      
Comment:/**
 * Skip to the next item.
 */

Body of Frist Method:
{
    try {
        mSessionBinder.next(mContext.getPackageName(), mCbStub);
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling next.", e);
    }
}
Body of Second Method:
{
    try {
        mSessionBinder.next(mContext.getPackageName());
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling next.", e);
    }
}
------------------------
Find a silently evolved API code:android.media.audiopolicy.AudioMixingRule.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Combines all of the matching and exclusion rules that have been set and return a new
 * {@link AudioMixingRule} object.
 * @return a new {@link AudioMixingRule} object
 */

Body of Frist Method:
{
    return new AudioMixingRule(mTargetMixType, mCriteria, mAllowPrivilegedPlaybackCapture);
}
Body of Second Method:
{
    return new AudioMixingRule(mTargetMixType, mCriteria, mAllowPrivilegedPlaybackCapture, mVoiceCommunicationCaptureAllowed);
}
------------------------
Find a silently evolved API code:android.location.GnssClock.resetElapsedRealtimeUncertaintyNanos:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Resets the estimate of the relative precision of the alignment of the
 * {@link #getElapsedRealtimeNanos()} timestamp, with the reported measurements in
 * nanoseconds (68% confidence).
 * @hide
 */

Body of Frist Method:
{
    resetFlag(HAS_ELAPSED_REALTIME_UNCERTAINTY_NANOS);
    mElapsedRealtimeUncertaintyNanos = Double.NaN;
}
Body of Second Method:
{
    resetFlag(HAS_ELAPSED_REALTIME_UNCERTAINTY_NANOS);
}
------------------------
Find a silently evolved API code:android.database.sqlite.SQLiteOpenHelper.setOpenParams:COMMENT
Method Modifier: public      
Comment:/**
 * Sets configuration parameters that are used for opening {@link SQLiteDatabase}.
 * <p>Please note that {@link SQLiteDatabase#CREATE_IF_NECESSARY} flag will always be set when
 * opening the database
 *
 * @param openParams configuration parameters that are used for opening {@link SQLiteDatabase}.
 * @throws IllegalStateException if the database is already open
 */

Body of Frist Method:
{
    Preconditions.checkNotNull(openParams);
    synchronized (this) {
        if (mDatabase != null && mDatabase.isOpen()) {
            throw new IllegalStateException("OpenParams cannot be set after opening the database");
        }
        setOpenParamsBuilder(new SQLiteDatabase.OpenParams.Builder(openParams));
    }
}
Body of Second Method:
{
    Objects.requireNonNull(openParams);
    synchronized (this) {
        if (mDatabase != null && mDatabase.isOpen()) {
            throw new IllegalStateException("OpenParams cannot be set after opening the database");
        }
        setOpenParamsBuilder(new SQLiteDatabase.OpenParams.Builder(openParams));
    }
}
------------------------
Find a silently evolved API code:android.telephony.ims.ImsCallSessionListener.callSessionHoldReceived:COMMENT
Method Modifier: public      
Comment:/**
 * This IMS Call session has been put on hold by the remote party.
 *
 * @param profile The {@link ImsCallProfile} associated with this IMS call session.
 */

Body of Frist Method:
{
    try {
        mListener.callSessionHoldReceived(profile);
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}
Body of Second Method:
{
    try {
        mListener.callSessionHoldReceived(profile);
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.net.ip.IpClientCallbacks.onNewDhcpResults:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Callback called when new DHCP results are available.
 *
 * <p>This is purely advisory and not an indication of provisioning success or failure.  This is
 * only here for callers that want to expose DHCPv4 results to other APIs
 * (e.g., WifiInfo#setInetAddress).
 *
 * <p>DHCPv4 or static IPv4 configuration failure or success can be determined by whether or not
 * the passed-in DhcpResults object is null.
 */

Body of Frist Method:
{
}
Body of Second Method:
{
// In general callbacks would not use a parcelable directly (DhcpResultsParcelable), and
// would use a wrapper instead, because of the lack of safety of stable parcelables. But
// there are already two classes in the tree for DHCP information: DhcpInfo and DhcpResults,
// and neither of them exposes an appropriate API (they are bags of mutable fields and can't
// be changed because they are public API and @UnsupportedAppUsage, being no better than the
// stable parcelable). Adding a third class would cost more than the gain considering that
// the only client of this callback is WiFi, which will end up converting the results to
// DhcpInfo anyway.
}
------------------------
Find a silently evolved API code:android.net.wifi.aware.ConfigRequest.validate:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Verifies that the contents of the ConfigRequest are valid. Otherwise
 * throws an IllegalArgumentException.
 */

Body of Frist Method:
{
    if (mMasterPreference < 0) {
        throw new IllegalArgumentException("Master Preference specification must be non-negative");
    }
    if (mMasterPreference == 1 || mMasterPreference == 255 || mMasterPreference > 255) {
        throw new IllegalArgumentException("Master Preference specification must not " + "exceed 255 or use 1 or 255 (reserved values)");
    }
    if (mClusterLow < CLUSTER_ID_MIN) {
        throw new IllegalArgumentException("Cluster specification must be non-negative");
    }
    if (mClusterLow > CLUSTER_ID_MAX) {
        throw new IllegalArgumentException("Cluster specification must not exceed 0xFFFF");
    }
    if (mClusterHigh < CLUSTER_ID_MIN) {
        throw new IllegalArgumentException("Cluster specification must be non-negative");
    }
    if (mClusterHigh > CLUSTER_ID_MAX) {
        throw new IllegalArgumentException("Cluster specification must not exceed 0xFFFF");
    }
    if (mClusterLow > mClusterHigh) {
        throw new IllegalArgumentException("Invalid argument combination - must have Cluster Low <= Cluster High");
    }
    if (mDiscoveryWindowInterval.length != 2) {
        throw new IllegalArgumentException("Invalid discovery window interval: must have 2 elements (2.4 & 5");
    }
    if (mDiscoveryWindowInterval[NAN_BAND_24GHZ] != DW_INTERVAL_NOT_INIT && (// valid for 2.4GHz: [1-5]
    mDiscoveryWindowInterval[NAN_BAND_24GHZ] < 1 || mDiscoveryWindowInterval[NAN_BAND_24GHZ] > 5)) {
        throw new IllegalArgumentException("Invalid discovery window interval for 2.4GHz: valid is UNSET or [1,5]");
    }
    if (mDiscoveryWindowInterval[NAN_BAND_5GHZ] != DW_INTERVAL_NOT_INIT && (// valid for 5GHz: [0-5]
    mDiscoveryWindowInterval[NAN_BAND_5GHZ] < 0 || mDiscoveryWindowInterval[NAN_BAND_5GHZ] > 5)) {
        throw new IllegalArgumentException("Invalid discovery window interval for 5GHz: valid is UNSET or [0,5]");
    }
}
Body of Second Method:
{
    if (mMasterPreference < 0) {
        throw new IllegalArgumentException("Master Preference specification must be non-negative");
    }
    if (mMasterPreference == 1 || mMasterPreference == 255 || mMasterPreference > 255) {
        throw new IllegalArgumentException("Master Preference specification must not " + "exceed 255 or use 1 or 255 (reserved values)");
    }
    if (mClusterLow < CLUSTER_ID_MIN) {
        throw new IllegalArgumentException("Cluster specification must be non-negative");
    }
    if (mClusterLow > CLUSTER_ID_MAX) {
        throw new IllegalArgumentException("Cluster specification must not exceed 0xFFFF");
    }
    if (mClusterHigh < CLUSTER_ID_MIN) {
        throw new IllegalArgumentException("Cluster specification must be non-negative");
    }
    if (mClusterHigh > CLUSTER_ID_MAX) {
        throw new IllegalArgumentException("Cluster specification must not exceed 0xFFFF");
    }
    if (mClusterLow > mClusterHigh) {
        throw new IllegalArgumentException("Invalid argument combination - must have Cluster Low <= Cluster High");
    }
    if (mDiscoveryWindowInterval.length != 3) {
        throw new IllegalArgumentException("Invalid discovery window interval: must have 3 elements (2.4 & 5 & 6");
    }
    if (mDiscoveryWindowInterval[NAN_BAND_24GHZ] != DW_INTERVAL_NOT_INIT && (// valid for 2.4GHz: [1-5]
    mDiscoveryWindowInterval[NAN_BAND_24GHZ] < 1 || mDiscoveryWindowInterval[NAN_BAND_24GHZ] > 5)) {
        throw new IllegalArgumentException("Invalid discovery window interval for 2.4GHz: valid is UNSET or [1,5]");
    }
    if (mDiscoveryWindowInterval[NAN_BAND_5GHZ] != DW_INTERVAL_NOT_INIT && (// valid for 5GHz: [0-5]
    mDiscoveryWindowInterval[NAN_BAND_5GHZ] < 0 || mDiscoveryWindowInterval[NAN_BAND_5GHZ] > 5)) {
        throw new IllegalArgumentException("Invalid discovery window interval for 5GHz: valid is UNSET or [0,5]");
    }
    if (mDiscoveryWindowInterval[NAN_BAND_6GHZ] != DW_INTERVAL_NOT_INIT && (// valid for 6GHz: [0-5]
    mDiscoveryWindowInterval[NAN_BAND_6GHZ] < 0 || mDiscoveryWindowInterval[NAN_BAND_6GHZ] > 5)) {
        throw new IllegalArgumentException("Invalid discovery window interval for 6GHz: valid is UNSET or [0,5]");
    }
}
------------------------
Find a silently evolved API code:android.location.GnssMeasurement.resetAutomaticGainControlLevel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Resets the Automatic Gain Control level.
 * @hide
 */

Body of Frist Method:
{
    resetFlag(HAS_AUTOMATIC_GAIN_CONTROL);
    mAutomaticGainControlLevelInDb = Double.NaN;
}
Body of Second Method:
{
    resetFlag(HAS_AUTOMATIC_GAIN_CONTROL);
}
------------------------
Find a silently evolved API code:android.net.RouteInfo.hashCode:COMMENT
Method Modifier: public      
Comment:/**
 * Returns a hashcode for this <code>RouteInfo</code> object.
 */

Body of Frist Method:
{
    return (mDestination.hashCode() * 41) + (mGateway == null ? 0 : mGateway.hashCode() * 47) + (mInterface == null ? 0 : mInterface.hashCode() * 67) + (mType * 71);
}
Body of Second Method:
{
    return (mDestination.hashCode() * 41) + (mGateway == null ? 0 : mGateway.hashCode() * 47) + (mInterface == null ? 0 : mInterface.hashCode() * 67) + (mType * 71) + (mMtu * 89);
}
------------------------
Find a silently evolved API code:android.media.session.MediaController.TransportControls.setPlaybackSpeed:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the playback speed. A value of {@code 1.0f} is the default playback value,
 * and a negative value indicates reverse playback. {@code 0.0f} is not allowed.
 *
 * @param speed The playback speed
 * @throws IllegalArgumentException if the {@code speed} is equal to zero.
 */

Body of Frist Method:
{
    if (speed == 0.0f) {
        throw new IllegalArgumentException("speed must not be zero");
    }
    try {
        mSessionBinder.setPlaybackSpeed(mContext.getPackageName(), mCbStub, speed);
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling setPlaybackSpeed.", e);
    }
}
Body of Second Method:
{
    if (speed == 0.0f) {
        throw new IllegalArgumentException("speed must not be zero");
    }
    try {
        mSessionBinder.setPlaybackSpeed(mContext.getPackageName(), speed);
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling setPlaybackSpeed.", e);
    }
}
------------------------
Find a silently evolved API code:android.telecom.PhoneAccount.capabilitiesToString:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Generates a string representation of a capabilities bitmask.
 *
 * @return String representation of the capabilities bitmask.
 * @hide
 */

Body of Frist Method:
{
    StringBuilder sb = new StringBuilder();
    if (hasCapabilities(CAPABILITY_SELF_MANAGED)) {
        sb.append("SelfManaged ");
    }
    if (hasCapabilities(CAPABILITY_SUPPORTS_VIDEO_CALLING)) {
        sb.append("SuppVideo ");
    }
    if (hasCapabilities(CAPABILITY_VIDEO_CALLING)) {
        sb.append("Video ");
    }
    if (hasCapabilities(CAPABILITY_VIDEO_CALLING_RELIES_ON_PRESENCE)) {
        sb.append("Presence ");
    }
    if (hasCapabilities(CAPABILITY_CALL_PROVIDER)) {
        sb.append("CallProvider ");
    }
    if (hasCapabilities(CAPABILITY_CALL_SUBJECT)) {
        sb.append("CallSubject ");
    }
    if (hasCapabilities(CAPABILITY_CONNECTION_MANAGER)) {
        sb.append("ConnectionMgr ");
    }
    if (hasCapabilities(CAPABILITY_EMERGENCY_CALLS_ONLY)) {
        sb.append("EmergOnly ");
    }
    if (hasCapabilities(CAPABILITY_MULTI_USER)) {
        sb.append("MultiUser ");
    }
    if (hasCapabilities(CAPABILITY_PLACE_EMERGENCY_CALLS)) {
        sb.append("PlaceEmerg ");
    }
    if (hasCapabilities(CAPABILITY_EMERGENCY_PREFERRED)) {
        sb.append("EmerPrefer ");
    }
    if (hasCapabilities(CAPABILITY_EMERGENCY_VIDEO_CALLING)) {
        sb.append("EmergVideo ");
    }
    if (hasCapabilities(CAPABILITY_SIM_SUBSCRIPTION)) {
        sb.append("SimSub ");
    }
    if (hasCapabilities(CAPABILITY_RTT)) {
        sb.append("Rtt");
    }
    return sb.toString();
}
Body of Second Method:
{
    StringBuilder sb = new StringBuilder();
    if (hasCapabilities(CAPABILITY_SELF_MANAGED)) {
        sb.append("SelfManaged ");
    }
    if (hasCapabilities(CAPABILITY_SUPPORTS_VIDEO_CALLING)) {
        sb.append("SuppVideo ");
    }
    if (hasCapabilities(CAPABILITY_VIDEO_CALLING)) {
        sb.append("Video ");
    }
    if (hasCapabilities(CAPABILITY_VIDEO_CALLING_RELIES_ON_PRESENCE)) {
        sb.append("Presence ");
    }
    if (hasCapabilities(CAPABILITY_CALL_PROVIDER)) {
        sb.append("CallProvider ");
    }
    if (hasCapabilities(CAPABILITY_CALL_SUBJECT)) {
        sb.append("CallSubject ");
    }
    if (hasCapabilities(CAPABILITY_CONNECTION_MANAGER)) {
        sb.append("ConnectionMgr ");
    }
    if (hasCapabilities(CAPABILITY_EMERGENCY_CALLS_ONLY)) {
        sb.append("EmergOnly ");
    }
    if (hasCapabilities(CAPABILITY_MULTI_USER)) {
        sb.append("MultiUser ");
    }
    if (hasCapabilities(CAPABILITY_PLACE_EMERGENCY_CALLS)) {
        sb.append("PlaceEmerg ");
    }
    if (hasCapabilities(CAPABILITY_EMERGENCY_PREFERRED)) {
        sb.append("EmerPrefer ");
    }
    if (hasCapabilities(CAPABILITY_EMERGENCY_VIDEO_CALLING)) {
        sb.append("EmergVideo ");
    }
    if (hasCapabilities(CAPABILITY_SIM_SUBSCRIPTION)) {
        sb.append("SimSub ");
    }
    if (hasCapabilities(CAPABILITY_RTT)) {
        sb.append("Rtt");
    }
    if (hasCapabilities(CAPABILITY_ADHOC_CONFERENCE_CALLING)) {
        sb.append("AdhocConf");
    }
    return sb.toString();
}
------------------------
Find a silently evolved API code:android.app.SharedElementCallback.onCreateSnapshotView:COMMENT
Method Modifier: public      
Comment:/**
 * Reconstitutes a snapshot View from a Parcelable returned in
 * {@link #onCaptureSharedElementSnapshot(android.view.View, android.graphics.Matrix,
 * android.graphics.RectF)} to be used in {@link #onSharedElementStart(java.util.List,
 * java.util.List, java.util.List)} and {@link #onSharedElementEnd(java.util.List,
 * java.util.List, java.util.List)}. The returned View will be sized and positioned after
 * this call so that it is ready to be added to the decor View's overlay.
 *
 * <p>This is not called for Fragment Transitions.</p>
 *
 * @param context The Context used to create the snapshot View.
 * @param snapshot The Parcelable returned by {@link #onCaptureSharedElementSnapshot(
 * android.view.View, android.graphics.Matrix, android.graphics.RectF)}.
 * @return A View to be sent in {@link #onSharedElementStart(java.util.List, java.util.List,
 * java.util.List)} and {@link #onSharedElementEnd(java.util.List, java.util.List,
 * java.util.List)}. A null value will produce a null snapshot value for those two methods.
 */

Body of Frist Method:
{
    View view = null;
    if (snapshot instanceof Bundle) {
        Bundle bundle = (Bundle) snapshot;
        GraphicBuffer buffer = bundle.getParcelable(BUNDLE_SNAPSHOT_GRAPHIC_BUFFER);
        Bitmap bitmap = bundle.getParcelable(BUNDLE_SNAPSHOT_BITMAP);
        if (buffer == null && bitmap == null) {
            return null;
        }
        if (bitmap == null) {
            ColorSpace colorSpace = null;
            int colorSpaceId = bundle.getInt(BUNDLE_SNAPSHOT_COLOR_SPACE, 0);
            if (colorSpaceId >= 0 && colorSpaceId < ColorSpace.Named.values().length) {
                colorSpace = ColorSpace.get(ColorSpace.Named.values()[colorSpaceId]);
            }
            bitmap = Bitmap.wrapHardwareBuffer(HardwareBuffer.createFromGraphicBuffer(buffer), colorSpace);
        }
        ImageView imageView = new ImageView(context);
        view = imageView;
        imageView.setImageBitmap(bitmap);
        imageView.setScaleType(ScaleType.valueOf(bundle.getString(BUNDLE_SNAPSHOT_IMAGE_SCALETYPE)));
        if (imageView.getScaleType() == ScaleType.MATRIX) {
            float[] values = bundle.getFloatArray(BUNDLE_SNAPSHOT_IMAGE_MATRIX);
            Matrix matrix = new Matrix();
            matrix.setValues(values);
            imageView.setImageMatrix(matrix);
        }
    } else if (snapshot instanceof Bitmap) {
        Bitmap bitmap = (Bitmap) snapshot;
        view = new View(context);
        Resources resources = context.getResources();
        view.setBackground(new BitmapDrawable(resources, bitmap));
    }
    return view;
}
Body of Second Method:
{
    View view = null;
    if (snapshot instanceof Bundle) {
        Bundle bundle = (Bundle) snapshot;
        HardwareBuffer buffer = bundle.getParcelable(BUNDLE_SNAPSHOT_HARDWARE_BUFFER);
        Bitmap bitmap = bundle.getParcelable(BUNDLE_SNAPSHOT_BITMAP);
        if (buffer == null && bitmap == null) {
            return null;
        }
        if (bitmap == null) {
            ColorSpace colorSpace = null;
            int colorSpaceId = bundle.getInt(BUNDLE_SNAPSHOT_COLOR_SPACE, 0);
            if (colorSpaceId >= 0 && colorSpaceId < ColorSpace.Named.values().length) {
                colorSpace = ColorSpace.get(ColorSpace.Named.values()[colorSpaceId]);
            }
            bitmap = Bitmap.wrapHardwareBuffer(buffer, colorSpace);
        }
        ImageView imageView = new ImageView(context);
        view = imageView;
        imageView.setImageBitmap(bitmap);
        imageView.setScaleType(ScaleType.valueOf(bundle.getString(BUNDLE_SNAPSHOT_IMAGE_SCALETYPE)));
        if (imageView.getScaleType() == ScaleType.MATRIX) {
            float[] values = bundle.getFloatArray(BUNDLE_SNAPSHOT_IMAGE_MATRIX);
            Matrix matrix = new Matrix();
            matrix.setValues(values);
            imageView.setImageMatrix(matrix);
        }
    } else if (snapshot instanceof Bitmap) {
        Bitmap bitmap = (Bitmap) snapshot;
        view = new View(context);
        Resources resources = context.getResources();
        view.setBackground(new BitmapDrawable(resources, bitmap));
    }
    return view;
}
------------------------
Find a silently evolved API code:android.view.ImeInsetsSourceConsumer.notifyHidden:COMMENT
Method Modifier: default     hidden      
Comment:/**
 * Notify {@link InputMethodService} that IME window is hidden.
 */

Body of Frist Method:
{
    getImm().notifyImeHidden();
}
Body of Second Method:
{
    getImm().notifyImeHidden(mController.getHost().getWindowToken());
}
------------------------
Find a silently evolved API code:android.location.GnssNavigationMessage.getTypeString:COMMENT
Method Modifier: private     
Comment:/**
 * Gets a string representation of the 'type'.
 * For internal and logging use only.
 */

Body of Frist Method:
{
    switch(mType) {
        case TYPE_UNKNOWN:
            return "Unknown";
        case TYPE_GPS_L1CA:
            return "GPS L1 C/A";
        case TYPE_GPS_L2CNAV:
            return "GPS L2-CNAV";
        case TYPE_GPS_L5CNAV:
            return "GPS L5-CNAV";
        case TYPE_GPS_CNAV2:
            return "GPS CNAV2";
        case TYPE_GLO_L1CA:
            return "Glonass L1 C/A";
        case TYPE_BDS_D1:
            return "Beidou D1";
        case TYPE_BDS_D2:
            return "Beidou D2";
        case TYPE_GAL_I:
            return "Galileo I";
        case TYPE_GAL_F:
            return "Galileo F";
        default:
            return "<Invalid:" + mType + ">";
    }
}
Body of Second Method:
{
    switch(mType) {
        case TYPE_UNKNOWN:
            return "Unknown";
        case TYPE_GPS_L1CA:
            return "GPS L1 C/A";
        case TYPE_GPS_L2CNAV:
            return "GPS L2-CNAV";
        case TYPE_GPS_L5CNAV:
            return "GPS L5-CNAV";
        case TYPE_GPS_CNAV2:
            return "GPS CNAV2";
        case TYPE_SBS:
            return "SBS";
        case TYPE_GLO_L1CA:
            return "Glonass L1 C/A";
        case TYPE_QZS_L1CA:
            return "QZSS L1 C/A";
        case TYPE_BDS_D1:
            return "Beidou D1";
        case TYPE_BDS_D2:
            return "Beidou D2";
        case TYPE_BDS_CNAV1:
            return "Beidou CNAV1";
        case TYPE_BDS_CNAV2:
            return "Beidou CNAV2";
        case TYPE_GAL_I:
            return "Galileo I";
        case TYPE_GAL_F:
            return "Galileo F";
        case TYPE_IRN_L5CA:
            return "IRNSS L5 C/A";
        default:
            return "<Invalid:" + mType + ">";
    }
}
------------------------
Find a silently evolved API code:android.util.EventLog.Event.getTag:COMMENT
Method Modifier: public      
Comment:/**
 * @return the type tag code of the entry
 */

Body of Frist Method:
{
    int offset = mBuffer.getShort(HEADER_SIZE_OFFSET);
    if (offset == 0) {
        offset = V1_PAYLOAD_START;
    }
    return mBuffer.getInt(offset);
}
Body of Second Method:
{
    return mBuffer.getInt(getHeaderSize());
}
------------------------
Find a silently evolved API code:android.graphics.Outline.canClip:COMMENT
Method Modifier: public      
Comment:/**
 * Returns whether the outline can be used to clip a View.
 * <p>
 * Currently, only Outlines that can be represented as a rectangle, circle,
 * or round rect support clipping.
 *
 * @see android.view.View#setClipToOutline(boolean)
 */

Body of Frist Method:
{
    return mMode != MODE_CONVEX_PATH;
}
Body of Second Method:
{
    return mMode != MODE_PATH;
}
------------------------
Find a silently evolved API code:android.text.AndroidBidi.bidi:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Runs the bidi algorithm on input text.
 */

Body of Frist Method:
{
    if (chs == null || chInfo == null) {
        throw new NullPointerException();
    }
    final int length = chs.length;
    if (chInfo.length < length) {
        throw new IndexOutOfBoundsException();
    }
    final byte paraLevel;
    switch(dir) {
        case Layout.DIR_REQUEST_LTR:
            paraLevel = Bidi.LTR;
            break;
        case Layout.DIR_REQUEST_RTL:
            paraLevel = Bidi.RTL;
            break;
        case Layout.DIR_REQUEST_DEFAULT_LTR:
            paraLevel = Bidi.LEVEL_DEFAULT_LTR;
            break;
        case Layout.DIR_REQUEST_DEFAULT_RTL:
            paraLevel = Bidi.LEVEL_DEFAULT_RTL;
            break;
        default:
            paraLevel = Bidi.LTR;
            break;
    }
    final Bidi icuBidi = new Bidi(length, /* maxLength */
    0);
    icuBidi.setCustomClassifier(sEmojiBidiOverride);
    icuBidi.setPara(chs, paraLevel, null);
    for (int i = 0; i < length; i++) {
        chInfo[i] = icuBidi.getLevelAt(i);
    }
    final byte result = icuBidi.getParaLevel();
    return (result & 0x1) == 0 ? Layout.DIR_LEFT_TO_RIGHT : Layout.DIR_RIGHT_TO_LEFT;
}
Body of Second Method:
{
    if (chs == null || chInfo == null) {
        throw new NullPointerException();
    }
    final int length = chs.length;
    if (chInfo.length < length) {
        throw new IndexOutOfBoundsException();
    }
    final byte paraLevel;
    switch(dir) {
        case Layout.DIR_REQUEST_LTR:
            paraLevel = Bidi.LTR;
            break;
        case Layout.DIR_REQUEST_RTL:
            paraLevel = Bidi.RTL;
            break;
        case Layout.DIR_REQUEST_DEFAULT_LTR:
            paraLevel = Bidi.LEVEL_DEFAULT_LTR;
            break;
        case Layout.DIR_REQUEST_DEFAULT_RTL:
            paraLevel = Bidi.LEVEL_DEFAULT_RTL;
            break;
        default:
            paraLevel = Bidi.LTR;
            break;
    }
    final Bidi icuBidi = new Bidi(length, /* maxLength */
    0);
    icuBidi.setPara(chs, paraLevel, null);
    for (int i = 0; i < length; i++) {
        chInfo[i] = icuBidi.getLevelAt(i);
    }
    final byte result = icuBidi.getParaLevel();
    return (result & 0x1) == 0 ? Layout.DIR_LEFT_TO_RIGHT : Layout.DIR_RIGHT_TO_LEFT;
}
------------------------
Find a silently evolved API code:android.speech.SpeechRecognizer.handleStartListening:COMMENT
Method Modifier: private     
Comment:/**
 * sends the actual message to the service
 */

Body of Frist Method:
{
    if (!checkOpenConnection()) {
        return;
    }
    try {
        mService.startListening(recognizerIntent, mListener);
        if (DBG)
            Log.d(TAG, "service start listening command succeded");
    } catch (final RemoteException e) {
        Log.e(TAG, "startListening() failed", e);
        mListener.onError(ERROR_CLIENT);
    }
}
Body of Second Method:
{
    if (!checkOpenConnection()) {
        return;
    }
    try {
        mService.startListening(recognizerIntent, mListener, mContext.getOpPackageName(), mContext.getAttributionTag());
        if (DBG)
            Log.d(TAG, "service start listening command succeded");
    } catch (final RemoteException e) {
        Log.e(TAG, "startListening() failed", e);
        mListener.onError(ERROR_CLIENT);
    }
}
------------------------
Find a silently evolved API code:android.view.inputmethod.EditorInfo.dump:COMMENT
Method Modifier: public      
Comment:/**
 * Write debug output of this object.
 */

Body of Frist Method:
{
    pw.println(prefix + "inputType=0x" + Integer.toHexString(inputType) + " imeOptions=0x" + Integer.toHexString(imeOptions) + " privateImeOptions=" + privateImeOptions);
    pw.println(prefix + "actionLabel=" + actionLabel + " actionId=" + actionId);
    pw.println(prefix + "initialSelStart=" + initialSelStart + " initialSelEnd=" + initialSelEnd + " initialCapsMode=0x" + Integer.toHexString(initialCapsMode));
    pw.println(prefix + "hintText=" + hintText + " label=" + label);
    pw.println(prefix + "packageName=" + packageName + " fieldId=" + fieldId + " fieldName=" + fieldName);
    pw.println(prefix + "extras=" + extras);
    pw.println(prefix + "hintLocales=" + hintLocales);
    pw.println(prefix + "contentMimeTypes=" + Arrays.toString(contentMimeTypes));
    if (targetInputMethodUser != null) {
        pw.println(prefix + "targetInputMethodUserId=" + targetInputMethodUser.getIdentifier());
    }
}
Body of Second Method:
{
    pw.println(prefix + "inputType=0x" + Integer.toHexString(inputType) + " imeOptions=0x" + Integer.toHexString(imeOptions) + " privateImeOptions=" + privateImeOptions);
    pw.println(prefix + "actionLabel=" + actionLabel + " actionId=" + actionId);
    pw.println(prefix + "initialSelStart=" + initialSelStart + " initialSelEnd=" + initialSelEnd + " initialCapsMode=0x" + Integer.toHexString(initialCapsMode));
    pw.println(prefix + "hintText=" + hintText + " label=" + label);
    pw.println(prefix + "packageName=" + packageName + " autofillId=" + autofillId + " fieldId=" + fieldId + " fieldName=" + fieldName);
    pw.println(prefix + "extras=" + extras);
    pw.println(prefix + "hintLocales=" + hintLocales);
    pw.println(prefix + "contentMimeTypes=" + Arrays.toString(contentMimeTypes));
    if (targetInputMethodUser != null) {
        pw.println(prefix + "targetInputMethodUserId=" + targetInputMethodUser.getIdentifier());
    }
}
------------------------
Find a silently evolved API code:android.graphics.drawable.GradientDrawable.setOrientation:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the orientation of the gradient defined in this drawable.
 * <p>
 * <strong>Note</strong>: changing orientation will affect all instances
 * of a drawable loaded from a resource. It is recommended to invoke
 * {@link #mutate()} before changing the orientation.
 *
 * @param orientation the desired orientation (angle) of the gradient
 *
 * @see #mutate()
 * @see #getOrientation()
 */

Body of Frist Method:
{
    mGradientState.setOrientation(orientation);
    mGradientIsDirty = true;
    invalidateSelf();
}
Body of Second Method:
{
    mGradientState.mOrientation = orientation;
    mGradientIsDirty = true;
    invalidateSelf();
}
------------------------
Find a silently evolved API code:android.os.image.DynamicSystemManager.setEnable:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Enable or disable DynamicSystem.
 * @return {@code true} if the call succeeds. {@code false} if there is no installed image.
 */

Body of Frist Method:
{
    try {
        return mService.setEnable(enable);
    } catch (RemoteException e) {
        throw new RuntimeException(e.toString());
    }
}
Body of Second Method:
{
    try {
        return mService.setEnable(enable, oneShot);
    } catch (RemoteException e) {
        throw new RuntimeException(e.toString());
    }
}
------------------------
Find a silently evolved API code:android.view.KeyEvent.isWakeKey:COMMENT
<android.view.KeyEvent: boolean isWakeKey(int)>
public      static      final       hidden      ->public      final       hidden      
Method Modifier: public      static      final       hidden      
Method Modifier: Yes         Yes         Yes         Yes         
Method Updated:  Yes         No          Yes         Yes         
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    switch(keyCode) {
        case KeyEvent.KEYCODE_BACK:
        case KeyEvent.KEYCODE_MENU:
        case KeyEvent.KEYCODE_WAKEUP:
        case KeyEvent.KEYCODE_PAIRING:
        case KeyEvent.KEYCODE_STEM_1:
        case KeyEvent.KEYCODE_STEM_2:
        case KeyEvent.KEYCODE_STEM_3:
            return true;
    }
    return false;
}
Body of Second Method:
{
    return isWakeKey(mKeyCode);
}
------------------------
Find a silently evolved API code:android.media.AudioFormat.toLogFriendlyEncoding:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    switch(enc) {
        case ENCODING_INVALID:
            return "ENCODING_INVALID";
        case ENCODING_PCM_16BIT:
            return "ENCODING_PCM_16BIT";
        case ENCODING_PCM_8BIT:
            return "ENCODING_PCM_8BIT";
        case ENCODING_PCM_FLOAT:
            return "ENCODING_PCM_FLOAT";
        case ENCODING_AC3:
            return "ENCODING_AC3";
        case ENCODING_E_AC3:
            return "ENCODING_E_AC3";
        case ENCODING_DTS:
            return "ENCODING_DTS";
        case ENCODING_DTS_HD:
            return "ENCODING_DTS_HD";
        case ENCODING_MP3:
            return "ENCODING_MP3";
        case ENCODING_AAC_LC:
            return "ENCODING_AAC_LC";
        case ENCODING_AAC_HE_V1:
            return "ENCODING_AAC_HE_V1";
        case ENCODING_AAC_HE_V2:
            return "ENCODING_AAC_HE_V2";
        case ENCODING_IEC61937:
            return "ENCODING_IEC61937";
        case ENCODING_DOLBY_TRUEHD:
            return "ENCODING_DOLBY_TRUEHD";
        case ENCODING_AAC_ELD:
            return "ENCODING_AAC_ELD";
        case ENCODING_AAC_XHE:
            return "ENCODING_AAC_XHE";
        case ENCODING_AC4:
            return "ENCODING_AC4";
        case ENCODING_E_AC3_JOC:
            return "ENCODING_E_AC3_JOC";
        case ENCODING_DOLBY_MAT:
            return "ENCODING_DOLBY_MAT";
        default:
            return "invalid encoding " + enc;
    }
}
Body of Second Method:
{
    switch(enc) {
        case ENCODING_INVALID:
            return "ENCODING_INVALID";
        case ENCODING_PCM_16BIT:
            return "ENCODING_PCM_16BIT";
        case ENCODING_PCM_8BIT:
            return "ENCODING_PCM_8BIT";
        case ENCODING_PCM_FLOAT:
            return "ENCODING_PCM_FLOAT";
        case ENCODING_AC3:
            return "ENCODING_AC3";
        case ENCODING_E_AC3:
            return "ENCODING_E_AC3";
        case ENCODING_DTS:
            return "ENCODING_DTS";
        case ENCODING_DTS_HD:
            return "ENCODING_DTS_HD";
        case ENCODING_MP3:
            return "ENCODING_MP3";
        case ENCODING_AAC_LC:
            return "ENCODING_AAC_LC";
        case ENCODING_AAC_HE_V1:
            return "ENCODING_AAC_HE_V1";
        case ENCODING_AAC_HE_V2:
            return "ENCODING_AAC_HE_V2";
        case ENCODING_IEC61937:
            return "ENCODING_IEC61937";
        case ENCODING_DOLBY_TRUEHD:
            return "ENCODING_DOLBY_TRUEHD";
        case ENCODING_AAC_ELD:
            return "ENCODING_AAC_ELD";
        case ENCODING_AAC_XHE:
            return "ENCODING_AAC_XHE";
        case ENCODING_AC4:
            return "ENCODING_AC4";
        case ENCODING_E_AC3_JOC:
            return "ENCODING_E_AC3_JOC";
        case ENCODING_DOLBY_MAT:
            return "ENCODING_DOLBY_MAT";
        case ENCODING_OPUS:
            return "ENCODING_OPUS";
        default:
            return "invalid encoding " + enc;
    }
}
------------------------
Find a silently evolved API code:android.graphics.drawable.Icon.loadDrawableInner:COMMENT
Method Modifier: private     
Comment:/**
 * Do the heavy lifting of loading the drawable, but stop short of applying any tint.
 */

Body of Frist Method:
{
    switch(mType) {
        case TYPE_BITMAP:
            return new BitmapDrawable(context.getResources(), getBitmap());
        case TYPE_ADAPTIVE_BITMAP:
            return new AdaptiveIconDrawable(null, new BitmapDrawable(context.getResources(), getBitmap()));
        case TYPE_RESOURCE:
            if (getResources() == null) {
                // figure out where to load resources from
                String resPackage = getResPackage();
                if (TextUtils.isEmpty(resPackage)) {
                    // if none is specified, try the given context
                    resPackage = context.getPackageName();
                }
                if ("android".equals(resPackage)) {
                    mObj1 = Resources.getSystem();
                } else {
                    final PackageManager pm = context.getPackageManager();
                    try {
                        ApplicationInfo ai = pm.getApplicationInfo(resPackage, PackageManager.MATCH_UNINSTALLED_PACKAGES);
                        if (ai != null) {
                            mObj1 = pm.getResourcesForApplication(ai);
                        } else {
                            break;
                        }
                    } catch (PackageManager.NameNotFoundException e) {
                        Log.e(TAG, String.format("Unable to find pkg=%s for icon %s", resPackage, this), e);
                        break;
                    }
                }
            }
            try {
                return getResources().getDrawable(getResId(), context.getTheme());
            } catch (RuntimeException e) {
                Log.e(TAG, String.format("Unable to load resource 0x%08x from pkg=%s", getResId(), getResPackage()), e);
            }
            break;
        case TYPE_DATA:
            return new BitmapDrawable(context.getResources(), BitmapFactory.decodeByteArray(getDataBytes(), getDataOffset(), getDataLength()));
        case TYPE_URI:
            final Uri uri = getUri();
            final String scheme = uri.getScheme();
            InputStream is = null;
            if (ContentResolver.SCHEME_CONTENT.equals(scheme) || ContentResolver.SCHEME_FILE.equals(scheme)) {
                try {
                    is = context.getContentResolver().openInputStream(uri);
                } catch (Exception e) {
                    Log.w(TAG, "Unable to load image from URI: " + uri, e);
                }
            } else {
                try {
                    is = new FileInputStream(new File(mString1));
                } catch (FileNotFoundException e) {
                    Log.w(TAG, "Unable to load image from path: " + uri, e);
                }
            }
            if (is != null) {
                return new BitmapDrawable(context.getResources(), BitmapFactory.decodeStream(is));
            }
            break;
    }
    return null;
}
Body of Second Method:
{
    switch(mType) {
        case TYPE_BITMAP:
            return new BitmapDrawable(context.getResources(), getBitmap());
        case TYPE_ADAPTIVE_BITMAP:
            return new AdaptiveIconDrawable(null, new BitmapDrawable(context.getResources(), getBitmap()));
        case TYPE_RESOURCE:
            if (getResources() == null) {
                // figure out where to load resources from
                String resPackage = getResPackage();
                if (TextUtils.isEmpty(resPackage)) {
                    // if none is specified, try the given context
                    resPackage = context.getPackageName();
                }
                if ("android".equals(resPackage)) {
                    mObj1 = Resources.getSystem();
                } else {
                    final PackageManager pm = context.getPackageManager();
                    try {
                        ApplicationInfo ai = pm.getApplicationInfo(resPackage, PackageManager.MATCH_UNINSTALLED_PACKAGES);
                        if (ai != null) {
                            mObj1 = pm.getResourcesForApplication(ai);
                        } else {
                            break;
                        }
                    } catch (PackageManager.NameNotFoundException e) {
                        Log.e(TAG, String.format("Unable to find pkg=%s for icon %s", resPackage, this), e);
                        break;
                    }
                }
            }
            try {
                return getResources().getDrawable(getResId(), context.getTheme());
            } catch (RuntimeException e) {
                Log.e(TAG, String.format("Unable to load resource 0x%08x from pkg=%s", getResId(), getResPackage()), e);
            }
            break;
        case TYPE_DATA:
            return new BitmapDrawable(context.getResources(), BitmapFactory.decodeByteArray(getDataBytes(), getDataOffset(), getDataLength()));
        case TYPE_URI:
            InputStream is = getUriInputStream(context);
            if (is != null) {
                return new BitmapDrawable(context.getResources(), BitmapFactory.decodeStream(is));
            }
            break;
        case TYPE_URI_ADAPTIVE_BITMAP:
            is = getUriInputStream(context);
            if (is != null) {
                return new AdaptiveIconDrawable(null, new BitmapDrawable(context.getResources(), BitmapFactory.decodeStream(is)));
            }
            break;
    }
    return null;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothA2dp.getCodecStatus:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Gets the current codec status (configuration and capability).
 *
 * @param device the remote Bluetooth device. If null, use the current
 * active A2DP Bluetooth device.
 * @return the current codec status
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        Log.d(TAG, "getCodecStatus(" + device + ")");
    try {
        final IBluetoothA2dp service = getService();
        if (service != null && isEnabled()) {
            return service.getCodecStatus(device);
        }
        if (service == null) {
            Log.w(TAG, "Proxy not attached to service");
        }
        return null;
    } catch (RemoteException e) {
        Log.e(TAG, "Error talking to BT service in getCodecStatus()", e);
        return null;
    }
}
Body of Second Method:
{
    if (DBG)
        Log.d(TAG, "getCodecStatus(" + device + ")");
    verifyDeviceNotNull(device, "getCodecStatus");
    try {
        final IBluetoothA2dp service = getService();
        if (service != null && isEnabled()) {
            return service.getCodecStatus(device);
        }
        if (service == null) {
            Log.w(TAG, "Proxy not attached to service");
        }
        return null;
    } catch (RemoteException e) {
        Log.e(TAG, "Error talking to BT service in getCodecStatus()", e);
        return null;
    }
}
------------------------
Find a silently evolved API code:android.media.session.MediaController.TransportControls.prepareFromUri:COMMENT
Method Modifier: public      
Comment:/**
 * Request that the player prepare playback for a specific {@link Uri}. In other words,
 * other sessions can continue to play during the preparation of this session. This method
 * can be used to speed up the start of the playback. Once the preparation is done, the
 * session will change its playback state to {@link PlaybackState#STATE_PAUSED}. Afterwards,
 * {@link #play} can be called to start playback. If the preparation is not needed,
 * {@link #playFromUri} can be directly called without this method.
 *
 * @param uri The URI of the requested media.
 * @param extras Optional extras that can include extra information about the media item
 * to be prepared.
 */

Body of Frist Method:
{
    if (uri == null || Uri.EMPTY.equals(uri)) {
        throw new IllegalArgumentException("You must specify a non-empty Uri for prepareFromUri.");
    }
    try {
        mSessionBinder.prepareFromUri(mContext.getPackageName(), mCbStub, uri, extras);
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling prepare(" + uri + ").", e);
    }
}
Body of Second Method:
{
    if (uri == null || Uri.EMPTY.equals(uri)) {
        throw new IllegalArgumentException("You must specify a non-empty Uri for prepareFromUri.");
    }
    try {
        mSessionBinder.prepareFromUri(mContext.getPackageName(), uri, extras);
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling prepare(" + uri + ").", e);
    }
}
------------------------
Find a silently evolved API code:android.location.GnssClock.resetDriftNanosPerSecond:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Resets the clock's Drift in nanoseconds per second.
 * @hide
 */

Body of Frist Method:
{
    resetFlag(HAS_DRIFT);
    mDriftNanosPerSecond = Double.NaN;
}
Body of Second Method:
{
    resetFlag(HAS_DRIFT);
}
------------------------
Find a silently evolved API code:android.telephony.ims.ImsCallSessionListener.callSessionRttModifyRequestReceived:COMMENT
Method Modifier: public      
Comment:/**
 * An RTT modify request has been received from the remote party.
 *
 * @param callProfile An {@link ImsCallProfile} with the updated attributes
 */

Body of Frist Method:
{
    try {
        mListener.callSessionRttModifyRequestReceived(callProfile);
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}
Body of Second Method:
{
    try {
        mListener.callSessionRttModifyRequestReceived(callProfile);
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.hardware.location.NanoApp.setNeededSensors:COMMENT
Method Modifier: public      hidden      deprecated  
Comment:/**
 * set the sensors needed for this app
 *
 * @param neededSensors
 * needed Sensors
 */

Body of Frist Method:
{
    Preconditions.checkNotNull(neededSensors, "neededSensors must not be null");
    mNeededSensors = neededSensors;
}
Body of Second Method:
{
    Objects.requireNonNull(neededSensors, "neededSensors must not be null");
    mNeededSensors = neededSensors;
}
------------------------
Find a silently evolved API code:android.hardware.location.ContextHubIntentEvent.fromIntent:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Creates a ContextHubIntentEvent object from an Intent received through a PendingIntent
 * registered with {@link ContextHubManager.createClient(ContextHubInfo, PendingIntent, long)}.
 *
 * @param intent the Intent object from an Intent event
 * @return the ContextHubIntentEvent object describing the event
 *
 * @throws IllegalArgumentException if the Intent was not a valid intent
 */

Body of Frist Method:
{
    Preconditions.checkNotNull(intent, "Intent cannot be null");
    hasExtraOrThrow(intent, ContextHubManager.EXTRA_CONTEXT_HUB_INFO);
    ContextHubInfo info = intent.getParcelableExtra(ContextHubManager.EXTRA_CONTEXT_HUB_INFO);
    if (info == null) {
        throw new IllegalArgumentException("ContextHubInfo extra was null");
    }
    int eventType = getIntExtraOrThrow(intent, ContextHubManager.EXTRA_EVENT_TYPE);
    ContextHubIntentEvent event;
    switch(eventType) {
        case ContextHubManager.EVENT_NANOAPP_LOADED:
        case ContextHubManager.EVENT_NANOAPP_UNLOADED:
        case ContextHubManager.EVENT_NANOAPP_ENABLED:
        case ContextHubManager.EVENT_NANOAPP_DISABLED:
        case ContextHubManager.EVENT_NANOAPP_ABORTED:
        case // fall through
        ContextHubManager.EVENT_NANOAPP_MESSAGE:
            long nanoAppId = getLongExtraOrThrow(intent, ContextHubManager.EXTRA_NANOAPP_ID);
            if (eventType == ContextHubManager.EVENT_NANOAPP_MESSAGE) {
                hasExtraOrThrow(intent, ContextHubManager.EXTRA_MESSAGE);
                NanoAppMessage message = intent.getParcelableExtra(ContextHubManager.EXTRA_MESSAGE);
                if (message == null) {
                    throw new IllegalArgumentException("NanoAppMessage extra was null");
                }
                event = new ContextHubIntentEvent(info, eventType, nanoAppId, message);
            } else if (eventType == ContextHubManager.EVENT_NANOAPP_ABORTED) {
                int nanoAppAbortCode = getIntExtraOrThrow(intent, ContextHubManager.EXTRA_NANOAPP_ABORT_CODE);
                event = new ContextHubIntentEvent(info, eventType, nanoAppId, nanoAppAbortCode);
            } else {
                event = new ContextHubIntentEvent(info, eventType, nanoAppId);
            }
            break;
        case ContextHubManager.EVENT_HUB_RESET:
            event = new ContextHubIntentEvent(info, eventType);
            break;
        default:
            throw new IllegalArgumentException("Unknown intent event type " + eventType);
    }
    return event;
}
Body of Second Method:
{
    Objects.requireNonNull(intent, "Intent cannot be null");
    hasExtraOrThrow(intent, ContextHubManager.EXTRA_CONTEXT_HUB_INFO);
    ContextHubInfo info = intent.getParcelableExtra(ContextHubManager.EXTRA_CONTEXT_HUB_INFO);
    if (info == null) {
        throw new IllegalArgumentException("ContextHubInfo extra was null");
    }
    int eventType = getIntExtraOrThrow(intent, ContextHubManager.EXTRA_EVENT_TYPE);
    ContextHubIntentEvent event;
    switch(eventType) {
        case ContextHubManager.EVENT_NANOAPP_LOADED:
        case ContextHubManager.EVENT_NANOAPP_UNLOADED:
        case ContextHubManager.EVENT_NANOAPP_ENABLED:
        case ContextHubManager.EVENT_NANOAPP_DISABLED:
        case ContextHubManager.EVENT_NANOAPP_ABORTED:
        case // fall through
        ContextHubManager.EVENT_NANOAPP_MESSAGE:
            long nanoAppId = getLongExtraOrThrow(intent, ContextHubManager.EXTRA_NANOAPP_ID);
            if (eventType == ContextHubManager.EVENT_NANOAPP_MESSAGE) {
                hasExtraOrThrow(intent, ContextHubManager.EXTRA_MESSAGE);
                NanoAppMessage message = intent.getParcelableExtra(ContextHubManager.EXTRA_MESSAGE);
                if (message == null) {
                    throw new IllegalArgumentException("NanoAppMessage extra was null");
                }
                event = new ContextHubIntentEvent(info, eventType, nanoAppId, message);
            } else if (eventType == ContextHubManager.EVENT_NANOAPP_ABORTED) {
                int nanoAppAbortCode = getIntExtraOrThrow(intent, ContextHubManager.EXTRA_NANOAPP_ABORT_CODE);
                event = new ContextHubIntentEvent(info, eventType, nanoAppId, nanoAppAbortCode);
            } else {
                event = new ContextHubIntentEvent(info, eventType, nanoAppId);
            }
            break;
        case ContextHubManager.EVENT_HUB_RESET:
            event = new ContextHubIntentEvent(info, eventType);
            break;
        default:
            throw new IllegalArgumentException("Unknown intent event type " + eventType);
    }
    return event;
}
------------------------
Find a silently evolved API code:android.view.textclassifier.TextClassifierEvent.Builder.setScores:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the scores of the suggestions.
 */

Body of Frist Method:
{
    Preconditions.checkNotNull(scores);
    mScores = new float[scores.length];
    System.arraycopy(scores, 0, mScores, 0, scores.length);
    return self();
}
Body of Second Method:
{
    Objects.requireNonNull(scores);
    mScores = new float[scores.length];
    System.arraycopy(scores, 0, mScores, 0, scores.length);
    return self();
}
------------------------
Find a silently evolved API code:android.util.ArraySet.ensureCapacity:COMMENT
Method Modifier: public      
Comment:/**
 * Ensure the array map can hold at least <var>minimumCapacity</var>
 * items.
 */

Body of Frist Method:
{
    if (mHashes.length < minimumCapacity) {
        final int[] ohashes = mHashes;
        final Object[] oarray = mArray;
        allocArrays(minimumCapacity);
        if (mSize > 0) {
            System.arraycopy(ohashes, 0, mHashes, 0, mSize);
            System.arraycopy(oarray, 0, mArray, 0, mSize);
        }
        freeArrays(ohashes, oarray, mSize);
    }
}
Body of Second Method:
{
    final int oSize = mSize;
    if (mHashes.length < minimumCapacity) {
        final int[] ohashes = mHashes;
        final Object[] oarray = mArray;
        allocArrays(minimumCapacity);
        if (mSize > 0) {
            System.arraycopy(ohashes, 0, mHashes, 0, mSize);
            System.arraycopy(oarray, 0, mArray, 0, mSize);
        }
        freeArrays(ohashes, oarray, mSize);
    }
    if (mSize != oSize) {
        throw new ConcurrentModificationException();
    }
}
------------------------
Find a silently evolved API code:android.content.pm.UserInfo.supportsSwitchToByUser:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @return true if this user can be switched to by end user through UI.
 */

Body of Frist Method:
{
    // Hide the system user when it does not represent a human user.
    boolean hideSystemUser = UserManager.isSplitSystemUser();
    return (!hideSystemUser || id != UserHandle.USER_SYSTEM) && supportsSwitchTo();
}
Body of Second Method:
{
    // Hide the system user when it does not represent a human user.
    boolean hideSystemUser = UserManager.isHeadlessSystemUserMode();
    return (!hideSystemUser || id != UserHandle.USER_SYSTEM) && supportsSwitchTo();
}
------------------------
Find a silently evolved API code:android.hardware.camera2.params.LensShadingMap.copyGainFactors:COMMENT
Method Modifier: public      
Comment:/**
 * Copy all gain factors in row-major order from this lens shading map into the destination.
 *
 * <p>Each gain factor will be >= {@link #MINIMUM_GAIN_FACTOR}.</p>
 *
 * @param destination
 * an array big enough to hold at least {@link RggbChannelVector#COUNT}
 * elements after the {@code offset}
 * @param offset
 * a non-negative offset into the array
 * @throws NullPointerException
 * If {@code destination} was {@code null}
 * @throws IllegalArgumentException
 * If offset was negative
 * @throws ArrayIndexOutOfBoundsException
 * If there's not enough room to write the elements at the specified destination and
 * offset.
 *
 * @see CaptureResult#STATISTICS_LENS_SHADING_CORRECTION_MAP
 */

Body of Frist Method:
{
    checkArgumentNonnegative(offset, "offset must not be negative");
    checkNotNull(destination, "destination must not be null");
    if (destination.length + offset < getGainFactorCount()) {
        throw new ArrayIndexOutOfBoundsException("destination too small to fit elements");
    }
    System.arraycopy(mElements, /*srcPos*/
    0, destination, offset, getGainFactorCount());
}
Body of Second Method:
{
    checkArgumentNonnegative(offset, "offset must not be negative");
    Objects.requireNonNull(destination, "destination must not be null");
    if (destination.length + offset < getGainFactorCount()) {
        throw new ArrayIndexOutOfBoundsException("destination too small to fit elements");
    }
    System.arraycopy(mElements, /*srcPos*/
    0, destination, offset, getGainFactorCount());
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothA2dp.setCodecConfigPreference:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets the codec configuration preference.
 *
 * @param device the remote Bluetooth device. If null, use the current
 * active A2DP Bluetooth device.
 * @param codecConfig the codec configuration preference
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        Log.d(TAG, "setCodecConfigPreference(" + device + ")");
    try {
        final IBluetoothA2dp service = getService();
        if (service != null && isEnabled()) {
            service.setCodecConfigPreference(device, codecConfig);
        }
        if (service == null)
            Log.w(TAG, "Proxy not attached to service");
        return;
    } catch (RemoteException e) {
        Log.e(TAG, "Error talking to BT service in setCodecConfigPreference()", e);
        return;
    }
}
Body of Second Method:
{
    if (DBG)
        Log.d(TAG, "setCodecConfigPreference(" + device + ")");
    verifyDeviceNotNull(device, "setCodecConfigPreference");
    if (codecConfig == null) {
        Log.e(TAG, "setCodecConfigPreference: Codec config can't be null");
        throw new IllegalArgumentException("codecConfig cannot be null");
    }
    try {
        final IBluetoothA2dp service = getService();
        if (service != null && isEnabled()) {
            service.setCodecConfigPreference(device, codecConfig);
        }
        if (service == null)
            Log.w(TAG, "Proxy not attached to service");
        return;
    } catch (RemoteException e) {
        Log.e(TAG, "Error talking to BT service in setCodecConfigPreference()", e);
        return;
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiEnterpriseConfig.saveToSupplicant:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Internal use only; supply field values to wpa_supplicant config.  The configuration
 * process aborts on the first failed call on {@code saver}.
 * @param saver proxy for setting configuration in wpa_supplciant
 * @return whether the save succeeded on all attempts
 * @hide
 */

Body of Frist Method:
{
    if (!isEapMethodValid()) {
        return false;
    }
    // wpa_supplicant can update the anonymous identity for these kinds of networks after
    // framework reads them, so make sure the framework doesn't try to overwrite them.
    boolean shouldNotWriteAnonIdentity = mEapMethod == WifiEnterpriseConfig.Eap.SIM || mEapMethod == WifiEnterpriseConfig.Eap.AKA || mEapMethod == WifiEnterpriseConfig.Eap.AKA_PRIME;
    for (String key : mFields.keySet()) {
        if (shouldNotWriteAnonIdentity && ANON_IDENTITY_KEY.equals(key)) {
            continue;
        }
        if (!saver.saveValue(key, mFields.get(key))) {
            return false;
        }
    }
    if (!saver.saveValue(EAP_KEY, Eap.strings[mEapMethod])) {
        return false;
    }
    if (mEapMethod != Eap.TLS && mPhase2Method != Phase2.NONE) {
        boolean is_autheap = mEapMethod == Eap.TTLS && mPhase2Method == Phase2.GTC;
        String prefix = is_autheap ? Phase2.AUTHEAP_PREFIX : Phase2.AUTH_PREFIX;
        String value = convertToQuotedString(prefix + Phase2.strings[mPhase2Method]);
        return saver.saveValue(PHASE2_KEY, value);
    } else if (mPhase2Method == Phase2.NONE) {
        // By default, send a null phase 2 to clear old configuration values.
        return saver.saveValue(PHASE2_KEY, null);
    } else {
        Log.e(TAG, "WiFi enterprise configuration is invalid as it supplies a " + "phase 2 method but the phase1 method does not support it.");
        return false;
    }
}
Body of Second Method:
{
    if (!isEapMethodValid()) {
        return false;
    }
    // wpa_supplicant can update the anonymous identity for these kinds of networks after
    // framework reads them, so make sure the framework doesn't try to overwrite them.
    boolean shouldNotWriteAnonIdentity = mEapMethod == WifiEnterpriseConfig.Eap.SIM || mEapMethod == WifiEnterpriseConfig.Eap.AKA || mEapMethod == WifiEnterpriseConfig.Eap.AKA_PRIME;
    for (String key : mFields.keySet()) {
        if (shouldNotWriteAnonIdentity && ANON_IDENTITY_KEY.equals(key)) {
            continue;
        }
        if (!saver.saveValue(key, mFields.get(key))) {
            return false;
        }
    }
    if (!saver.saveValue(EAP_KEY, Eap.strings[mEapMethod])) {
        return false;
    }
    if (mEapMethod != Eap.TLS && mEapMethod != Eap.UNAUTH_TLS && mPhase2Method != Phase2.NONE) {
        boolean is_autheap = mEapMethod == Eap.TTLS && mPhase2Method == Phase2.GTC;
        String prefix = is_autheap ? Phase2.AUTHEAP_PREFIX : Phase2.AUTH_PREFIX;
        String value = convertToQuotedString(prefix + Phase2.strings[mPhase2Method]);
        return saver.saveValue(PHASE2_KEY, value);
    } else if (mPhase2Method == Phase2.NONE) {
        // By default, send a null phase 2 to clear old configuration values.
        return saver.saveValue(PHASE2_KEY, null);
    } else {
        Log.e(TAG, "WiFi enterprise configuration is invalid as it supplies a " + "phase 2 method but the phase1 method does not support it.");
        return false;
    }
}
------------------------
Find a silently evolved API code:android.security.keystore.recovery.KeyChainProtectionParams.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Creates a new {@link KeyChainProtectionParams} instance.
 * The instance will include default values, if {@link #setSecret}
 * or {@link #setUserSecretType} were not called.
 *
 * @return new instance
 * @throws NullPointerException if some required fields were not set.
 */

Body of Frist Method:
{
    if (mInstance.mUserSecretType == null) {
        mInstance.mUserSecretType = TYPE_LOCKSCREEN;
    }
    Preconditions.checkNotNull(mInstance.mLockScreenUiFormat);
    Preconditions.checkNotNull(mInstance.mKeyDerivationParams);
    if (mInstance.mSecret == null) {
        mInstance.mSecret = new byte[] {};
    }
    return mInstance;
}
Body of Second Method:
{
    if (mInstance.mUserSecretType == null) {
        mInstance.mUserSecretType = TYPE_LOCKSCREEN;
    }
    Objects.requireNonNull(mInstance.mLockScreenUiFormat);
    Objects.requireNonNull(mInstance.mKeyDerivationParams);
    if (mInstance.mSecret == null) {
        mInstance.mSecret = new byte[] {};
    }
    return mInstance;
}
------------------------
Find a silently evolved API code:android.content.ContentProviderClient.call:COMMENT
Method Modifier: public      
Comment:/**
 * See {@link ContentProvider#call(String, String, Bundle)}
 */

Body of Frist Method:
{
    Preconditions.checkNotNull(authority, "authority");
    Preconditions.checkNotNull(method, "method");
    beforeRemote();
    try {
        return mContentProvider.call(mPackageName, authority, method, arg, extras);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}
Body of Second Method:
{
    Objects.requireNonNull(authority, "authority");
    Objects.requireNonNull(method, "method");
    beforeRemote();
    try {
        return mContentProvider.call(mPackageName, mAttributionTag, authority, method, arg, extras);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}
------------------------
Find a silently evolved API code:android.view.animation.AccelerateDecelerateInterpolator.createNativeInterpolator:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return NativeInterpolatorFactoryHelper.createAccelerateDecelerateInterpolator();
}
Body of Second Method:
{
    return NativeInterpolatorFactory.createAccelerateDecelerateInterpolator();
}
------------------------
Find a silently evolved API code:android.location.GnssMeasurement.resetCarrierPhase:COMMENT
Method Modifier: public      hidden      deprecated  
Comment:/**
 * Resets the RF phase detected by the receiver.
 *
 * @deprecated use {@link #setAccumulatedDeltaRangeMeters(double)}
 * and {@link #setAccumulatedDeltaRangeState(int)} instead.
 *
 * @hide
 */

Body of Frist Method:
{
    resetFlag(HAS_CARRIER_PHASE);
    mCarrierPhase = Double.NaN;
}
Body of Second Method:
{
    resetFlag(HAS_CARRIER_PHASE);
}
------------------------
Find a silently evolved API code:android.security.keystore.KeyProtection.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Builds an instance of {@link KeyProtection}.
 *
 * @throws IllegalArgumentException if a required field is missing
 */

Body of Frist Method:
{
    return new KeyProtection(mKeyValidityStart, mKeyValidityForOriginationEnd, mKeyValidityForConsumptionEnd, mPurposes, mEncryptionPaddings, mSignaturePaddings, mDigests, mBlockModes, mRandomizedEncryptionRequired, mUserAuthenticationRequired, mUserAuthenticationValidityDurationSeconds, mUserPresenceRequired, mUserAuthenticationValidWhileOnBody, mInvalidatedByBiometricEnrollment, mBoundToSecureUserId, mCriticalToDeviceEncryption, mUserConfirmationRequired, mUnlockedDeviceRequired, mIsStrongBoxBacked);
}
Body of Second Method:
{
    return new KeyProtection(mKeyValidityStart, mKeyValidityForOriginationEnd, mKeyValidityForConsumptionEnd, mPurposes, mEncryptionPaddings, mSignaturePaddings, mDigests, mBlockModes, mRandomizedEncryptionRequired, mUserAuthenticationRequired, mUserAuthenticationType, mUserAuthenticationValidityDurationSeconds, mUserPresenceRequired, mUserAuthenticationValidWhileOnBody, mInvalidatedByBiometricEnrollment, mBoundToSecureUserId, mCriticalToDeviceEncryption, mUserConfirmationRequired, mUnlockedDeviceRequired, mIsStrongBoxBacked);
}
------------------------
Find a silently evolved API code:android.util.Half.toFloat:COMMENT
Method Modifier: public      static      
Comment:/**
 * <p>Converts the specified half-precision float value into a
 * single-precision float value. The following special cases are handled:</p>
 * <ul>
 * <li>If the input is {@link #NaN}, the returned value is {@link Float#NaN}</li>
 * <li>If the input is {@link #POSITIVE_INFINITY} or
 * {@link #NEGATIVE_INFINITY}, the returned value is respectively
 * {@link Float#POSITIVE_INFINITY} or {@link Float#NEGATIVE_INFINITY}</li>
 * <li>If the input is 0 (positive or negative), the returned value is +/-0.0f</li>
 * <li>Otherwise, the returned value is a normalized single-precision float value</li>
 * </ul>
 *
 * @param h The half-precision float value to convert to single-precision
 * @return A normalized single-precision float value
 */

Body of Frist Method:
{
    int bits = h & 0xffff;
    int s = bits & FP16_SIGN_MASK;
    int e = (bits >>> FP16_EXPONENT_SHIFT) & FP16_EXPONENT_MASK;
    int m = (bits) & FP16_SIGNIFICAND_MASK;
    int outE = 0;
    int outM = 0;
    if (e == 0) {
        // Denormal or 0
        if (m != 0) {
            // Convert denorm fp16 into normalized fp32
            float o = Float.intBitsToFloat(FP32_DENORMAL_MAGIC + m);
            o -= FP32_DENORMAL_FLOAT;
            return s == 0 ? o : -o;
        }
    } else {
        outM = m << 13;
        if (e == 0x1f) {
            // Infinite or NaN
            outE = 0xff;
            if (outM != 0) {
                // SNaNs are quieted
                outM |= FP32_QNAN_MASK;
            }
        } else {
            outE = e - FP16_EXPONENT_BIAS + FP32_EXPONENT_BIAS;
        }
    }
    int out = (s << 16) | (outE << FP32_EXPONENT_SHIFT) | outM;
    return Float.intBitsToFloat(out);
}
Body of Second Method:
{
    return FP16.toFloat(h);
}
------------------------
Find a silently evolved API code:android.net.wifi.p2p.WifiP2pWfdInfo.writeToParcel:COMMENT
<android.net.wifi.p2p.WifiP2pWfdInfo: void writeToParcel(Parcel,int)>
public      hidden      ->public      
Method Modifier: public      hidden      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * Implement the Parcelable interface
 */

Body of Frist Method:
{
    dest.writeInt(mWfdEnabled ? 1 : 0);
    dest.writeInt(mDeviceInfo);
    dest.writeInt(mCtrlPort);
    dest.writeInt(mMaxThroughput);
}
Body of Second Method:
{
    dest.writeInt(mEnabled ? 1 : 0);
    dest.writeInt(mDeviceInfo);
    dest.writeInt(mCtrlPort);
    dest.writeInt(mMaxThroughput);
}
------------------------
Find a silently evolved API code:android.telephony.ims.ImsCallSessionListener.callSessionHeld:COMMENT
Method Modifier: public      
Comment:/**
 * The IMS call session has started the process of holding the call. If it fails,
 * {@link #callSessionHoldFailed(ImsReasonInfo)} should be called.
 *
 * If the IMS call session is resumed, call {@link #callSessionResumed(ImsCallProfile)}.
 *
 * @param profile The associated {@link ImsCallProfile} of the call session that has been put
 * on hold.
 */

Body of Frist Method:
{
    try {
        mListener.callSessionHeld(profile);
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}
Body of Second Method:
{
    try {
        mListener.callSessionHeld(profile);
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.location.GnssMeasurement.resetSnrInDb:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Resets the Signal-to-noise ratio (SNR) in dB.
 * @hide
 */

Body of Frist Method:
{
    resetFlag(HAS_SNR);
    mSnrInDb = Double.NaN;
}
Body of Second Method:
{
    resetFlag(HAS_SNR);
}
------------------------
Find a silently evolved API code:android.telephony.ims.ImsCallSessionListener.callSessionRemoveParticipantsRequestFailed:COMMENT
Method Modifier: public      
Comment:/**
 * The previous request to remove participants from the conference (see
 * {@link #callSessionRemoveParticipantsRequestDelivered()}) has failed.
 *
 * @param reasonInfo {@link ImsReasonInfo} detailing the reason for the conference removal
 * failure.
 */

Body of Frist Method:
{
    try {
        mListener.callSessionInviteParticipantsRequestFailed(reasonInfo);
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}
Body of Second Method:
{
    try {
        mListener.callSessionInviteParticipantsRequestFailed(reasonInfo);
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.telephony.CellSignalStrengthLte.setDefaultValues:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    mSignalStrength = CellInfo.UNAVAILABLE;
    mRssi = CellInfo.UNAVAILABLE;
    mRsrp = CellInfo.UNAVAILABLE;
    mRsrq = CellInfo.UNAVAILABLE;
    mRssnr = CellInfo.UNAVAILABLE;
    mCqi = CellInfo.UNAVAILABLE;
    mTimingAdvance = CellInfo.UNAVAILABLE;
    mLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
}
Body of Second Method:
{
    mSignalStrength = CellInfo.UNAVAILABLE;
    mRssi = CellInfo.UNAVAILABLE;
    mRsrp = CellInfo.UNAVAILABLE;
    mRsrq = CellInfo.UNAVAILABLE;
    mRssnr = CellInfo.UNAVAILABLE;
    mCqi = CellInfo.UNAVAILABLE;
    mTimingAdvance = CellInfo.UNAVAILABLE;
    mLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    mParametersUseForLevel = USE_RSRP;
}
------------------------
Find a silently evolved API code:android.telephony.AccessNetworkUtils.getDuplexModeForEutranBand:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Gets the duplex mode for the given EUTRAN operating band.
 *
 * <p>See 3GPP 36.101 sec 5.5-1 for calculation
 *
 * @param band The EUTRAN band number
 * @return The duplex mode of the given EUTRAN band
 */

Body of Frist Method:
{
    if (band == INVALID_BAND) {
        return DUPLEX_MODE_UNKNOWN;
    }
    if (band >= EutranBand.BAND_68) {
        return DUPLEX_MODE_UNKNOWN;
    } else if (band >= EutranBand.BAND_65) {
        return DUPLEX_MODE_FDD;
    } else if (band >= EutranBand.BAND_47) {
        return DUPLEX_MODE_UNKNOWN;
    } else if (band >= EutranBand.BAND_33) {
        return DUPLEX_MODE_TDD;
    } else if (band >= EutranBand.BAND_1) {
        return DUPLEX_MODE_FDD;
    }
    return DUPLEX_MODE_UNKNOWN;
}
Body of Second Method:
{
    if (band == INVALID_BAND) {
        return DUPLEX_MODE_UNKNOWN;
    }
    if (band > EutranBand.BAND_88) {
        return DUPLEX_MODE_UNKNOWN;
    } else if (band >= EutranBand.BAND_65) {
        return DUPLEX_MODE_FDD;
    } else if (band >= EutranBand.BAND_33) {
        return DUPLEX_MODE_TDD;
    } else if (band >= EutranBand.BAND_1) {
        return DUPLEX_MODE_FDD;
    }
    return DUPLEX_MODE_UNKNOWN;
}
------------------------
Find a silently evolved API code:android.graphics.drawable.Icon.createWithContentUri:COMMENT
Method Modifier: public      static      
Comment:/**
 * Create an Icon pointing to an image file specified by URI.
 *
 * @param uri A uri referring to local content:// or file:// image data.
 */

Body of Frist Method:
{
    if (uri == null) {
        throw new IllegalArgumentException("Uri must not be null.");
    }
    final Icon rep = new Icon(TYPE_URI);
    rep.mString1 = uri.toString();
    return rep;
}
Body of Second Method:
{
    if (uri == null) {
        throw new IllegalArgumentException("Uri must not be null.");
    }
    final Icon rep = new Icon(TYPE_URI);
    rep.mString1 = uri;
    return rep;
}
------------------------
Find a silently evolved API code:android.graphics.Outline.offset:COMMENT
Method Modifier: public      
Comment:/**
 * Offsets the Outline by (dx,dy)
 */

Body of Frist Method:
{
    if (mMode == MODE_ROUND_RECT) {
        mRect.offset(dx, dy);
    } else if (mMode == MODE_CONVEX_PATH) {
        mPath.offset(dx, dy);
    }
}
Body of Second Method:
{
    if (mMode == MODE_ROUND_RECT) {
        mRect.offset(dx, dy);
    } else if (mMode == MODE_PATH) {
        mPath.offset(dx, dy);
    }
}
------------------------
Find a silently evolved API code:android.ddm.DdmHandleHello.handleHELO:COMMENT
Method Modifier: private     
Comment:/*
     * Handle introductory packet. This is called during JNI_CreateJavaVM
     * before frameworks native methods are registered, so be careful not
     * to call any APIs that depend on frameworks native code.
     */

Body of Frist Method:
{
    if (false)
        return createFailChunk(123, "This is a test");
    /*
         * Process the request.
         */
    ByteBuffer in = wrapChunk(request);
    int serverProtoVers = in.getInt();
    if (false)
        Log.v("ddm-hello", "Server version is " + serverProtoVers);
    /*
         * Create a response.
         */
    String vmName = System.getProperty("java.vm.name", "?");
    String vmVersion = System.getProperty("java.vm.version", "?");
    String vmIdent = vmName + " v" + vmVersion;
    // String appName = android.app.ActivityThread.currentPackageName();
    // if (appName == null)
    // appName = "unknown";
    String appName = DdmHandleAppName.getAppName();
    VMRuntime vmRuntime = VMRuntime.getRuntime();
    String instructionSetDescription = vmRuntime.is64Bit() ? "64-bit" : "32-bit";
    String vmInstructionSet = vmRuntime.vmInstructionSet();
    if (vmInstructionSet != null && vmInstructionSet.length() > 0) {
        instructionSetDescription += " (" + vmInstructionSet + ")";
    }
    String vmFlags = "CheckJNI=" + (vmRuntime.isCheckJniEnabled() ? "true" : "false");
    boolean isNativeDebuggable = vmRuntime.isNativeDebuggable();
    ByteBuffer out = ByteBuffer.allocate(28 + vmIdent.length() * 2 + appName.length() * 2 + instructionSetDescription.length() * 2 + vmFlags.length() * 2 + 1);
    out.order(ChunkHandler.CHUNK_ORDER);
    out.putInt(CLIENT_PROTOCOL_VERSION);
    out.putInt(android.os.Process.myPid());
    out.putInt(vmIdent.length());
    out.putInt(appName.length());
    putString(out, vmIdent);
    putString(out, appName);
    out.putInt(UserHandle.myUserId());
    out.putInt(instructionSetDescription.length());
    putString(out, instructionSetDescription);
    out.putInt(vmFlags.length());
    putString(out, vmFlags);
    out.put((byte) (isNativeDebuggable ? 1 : 0));
    Chunk reply = new Chunk(CHUNK_HELO, out);
    /*
         * Take the opportunity to inform DDMS if we are waiting for a
         * debugger to attach.
         */
    if (Debug.waitingForDebugger())
        sendWAIT(0);
    return reply;
}
Body of Second Method:
{
    if (false)
        return createFailChunk(123, "This is a test");
    /*
         * Process the request.
         */
    ByteBuffer in = wrapChunk(request);
    int serverProtoVers = in.getInt();
    if (false)
        Log.v("ddm-hello", "Server version is " + serverProtoVers);
    /*
         * Create a response.
         */
    String vmName = System.getProperty("java.vm.name", "?");
    String vmVersion = System.getProperty("java.vm.version", "?");
    String vmIdent = vmName + " v" + vmVersion;
    DdmHandleAppName.Names names = DdmHandleAppName.getNames();
    String appName = names.getAppName();
    String pkgName = names.getPkgName();
    VMRuntime vmRuntime = VMRuntime.getRuntime();
    String instructionSetDescription = vmRuntime.is64Bit() ? "64-bit" : "32-bit";
    String vmInstructionSet = vmRuntime.vmInstructionSet();
    if (vmInstructionSet != null && vmInstructionSet.length() > 0) {
        instructionSetDescription += " (" + vmInstructionSet + ")";
    }
    String vmFlags = "CheckJNI=" + (vmRuntime.isCheckJniEnabled() ? "true" : "false");
    boolean isNativeDebuggable = vmRuntime.isNativeDebuggable();
    ByteBuffer out = ByteBuffer.allocate(32 + vmIdent.length() * 2 + appName.length() * 2 + instructionSetDescription.length() * 2 + vmFlags.length() * 2 + 1 + pkgName.length() * 2);
    out.order(ChunkHandler.CHUNK_ORDER);
    out.putInt(CLIENT_PROTOCOL_VERSION);
    out.putInt(android.os.Process.myPid());
    out.putInt(vmIdent.length());
    out.putInt(appName.length());
    putString(out, vmIdent);
    putString(out, appName);
    out.putInt(UserHandle.myUserId());
    out.putInt(instructionSetDescription.length());
    putString(out, instructionSetDescription);
    out.putInt(vmFlags.length());
    putString(out, vmFlags);
    out.put((byte) (isNativeDebuggable ? 1 : 0));
    out.putInt(pkgName.length());
    putString(out, pkgName);
    Chunk reply = new Chunk(CHUNK_HELO, out);
    /*
         * Take the opportunity to inform DDMS if we are waiting for a
         * debugger to attach.
         */
    if (Debug.waitingForDebugger())
        sendWAIT(0);
    return reply;
}
------------------------
Find a silently evolved API code:android.widget.CompoundButton.setChecked:COMMENT
Method Modifier: public      
Comment:/**
 * <p>Changes the checked state of this button.</p>
 *
 * @param checked true to check the button, false to uncheck it
 */

Body of Frist Method:
{
    if (mChecked != checked) {
        mCheckedFromResource = false;
        mChecked = checked;
        refreshDrawableState();
        notifyViewAccessibilityStateChangedIfNeeded(AccessibilityEvent.CONTENT_CHANGE_TYPE_UNDEFINED);
        // Avoid infinite recursions if setChecked() is called from a listener
        if (mBroadcasting) {
            return;
        }
        mBroadcasting = true;
        if (mOnCheckedChangeListener != null) {
            mOnCheckedChangeListener.onCheckedChanged(this, mChecked);
        }
        if (mOnCheckedChangeWidgetListener != null) {
            mOnCheckedChangeWidgetListener.onCheckedChanged(this, mChecked);
        }
        final AutofillManager afm = mContext.getSystemService(AutofillManager.class);
        if (afm != null) {
            afm.notifyValueChanged(this);
        }
        mBroadcasting = false;
    }
}
Body of Second Method:
{
    if (mChecked != checked) {
        mCheckedFromResource = false;
        mChecked = checked;
        refreshDrawableState();
        // Avoid infinite recursions if setChecked() is called from a listener
        if (mBroadcasting) {
            return;
        }
        mBroadcasting = true;
        if (mOnCheckedChangeListener != null) {
            mOnCheckedChangeListener.onCheckedChanged(this, mChecked);
        }
        if (mOnCheckedChangeWidgetListener != null) {
            mOnCheckedChangeWidgetListener.onCheckedChanged(this, mChecked);
        }
        final AutofillManager afm = mContext.getSystemService(AutofillManager.class);
        if (afm != null) {
            afm.notifyValueChanged(this);
        }
        mBroadcasting = false;
    }
    // setStateDescription will not send out event if the description is unchanged.
    setDefaultStateDescritption();
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothDevice.getBondState:COMMENT
Method Modifier: public      
Comment:/**
 * Get the bond state of the remote device.
 * <p>Possible values for the bond state are:
 * {@link #BOND_NONE},
 * {@link #BOND_BONDING},
 * {@link #BOND_BONDED}.
 *
 * @return the bond state
 */

Body of Frist Method:
{
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, "BT not enabled. Cannot get bond state");
        return BOND_NONE;
    }
    try {
        return service.getBondState(this);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return BOND_NONE;
}
Body of Second Method:
{
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, "BT not enabled. Cannot get bond state");
        return BOND_NONE;
    }
    try {
        return mBluetoothBondCache.query(this);
    } catch (RuntimeException e) {
        if (e.getCause() instanceof RemoteException) {
            Log.e(TAG, "", e);
        } else {
            throw e;
        }
    }
    return BOND_NONE;
}
------------------------
Find a silently evolved API code:android.media.session.MediaController.TransportControls.prepareFromMediaId:COMMENT
Method Modifier: public      
Comment:/**
 * Request that the player prepare playback for a specific media id. In other words, other
 * sessions can continue to play during the preparation of this session. This method can be
 * used to speed up the start of the playback. Once the preparation is done, the session
 * will change its playback state to {@link PlaybackState#STATE_PAUSED}. Afterwards,
 * {@link #play} can be called to start playback. If the preparation is not needed,
 * {@link #playFromMediaId} can be directly called without this method.
 *
 * @param mediaId The id of the requested media.
 * @param extras Optional extras that can include extra information about the media item
 * to be prepared.
 */

Body of Frist Method:
{
    if (TextUtils.isEmpty(mediaId)) {
        throw new IllegalArgumentException("You must specify a non-empty String for prepareFromMediaId.");
    }
    try {
        mSessionBinder.prepareFromMediaId(mContext.getPackageName(), mCbStub, mediaId, extras);
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling prepare(" + mediaId + ").", e);
    }
}
Body of Second Method:
{
    if (TextUtils.isEmpty(mediaId)) {
        throw new IllegalArgumentException("You must specify a non-empty String for prepareFromMediaId.");
    }
    try {
        mSessionBinder.prepareFromMediaId(mContext.getPackageName(), mediaId, extras);
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling prepare(" + mediaId + ").", e);
    }
}
------------------------
Find a silently evolved API code:android.app.WindowConfiguration.isAlwaysOnTop:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns true if the container associated with this window configuration is always-on-top of
 * its siblings.
 * @hide
 */

Body of Frist Method:
{
    return mWindowingMode == WINDOWING_MODE_PINNED || (mWindowingMode == WINDOWING_MODE_FREEFORM && mAlwaysOnTop == ALWAYS_ON_TOP_ON);
}
Body of Second Method:
{
    if (mWindowingMode == WINDOWING_MODE_PINNED)
        return true;
    if (mActivityType == ACTIVITY_TYPE_DREAM)
        return true;
    if (mAlwaysOnTop != ALWAYS_ON_TOP_ON)
        return false;
    return mWindowingMode == WINDOWING_MODE_FREEFORM || mWindowingMode == WINDOWING_MODE_MULTI_WINDOW;
}
------------------------
Find a silently evolved API code:android.view.textclassifier.SelectionEvent.createSelectionModifiedEvent:COMMENT
Method Modifier: public      static      
Comment:/**
 * Creates a "selection modified" event.
 * Use when the user modifies the selection and the selection's entity type is known.
 *
 * @param start  the start (inclusive) index of the selection
 * @param end  the end (exclusive) index of the selection
 * @param classification  the TextClassification object returned by the TextClassifier that
 * classified the selected text
 *
 * @throws IllegalArgumentException if end is less than start
 */

Body of Frist Method:
{
    Preconditions.checkArgument(end >= start, "end cannot be less than start");
    Preconditions.checkNotNull(classification);
    final String entityType = classification.getEntityCount() > 0 ? classification.getEntity(0) : TextClassifier.TYPE_UNKNOWN;
    return new SelectionEvent(start, end, SelectionEvent.EVENT_SELECTION_MODIFIED, entityType, INVOCATION_UNKNOWN, classification.getId());
}
Body of Second Method:
{
    Preconditions.checkArgument(end >= start, "end cannot be less than start");
    Objects.requireNonNull(classification);
    final String entityType = classification.getEntityCount() > 0 ? classification.getEntity(0) : TextClassifier.TYPE_UNKNOWN;
    return new SelectionEvent(start, end, SelectionEvent.EVENT_SELECTION_MODIFIED, entityType, INVOCATION_UNKNOWN, classification.getId());
}
------------------------
Find a silently evolved API code:android.security.keystore.recovery.KeyChainSnapshot.Builder.build:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Creates a new {@link KeyChainSnapshot} instance.
 *
 * @return new instance
 * @throws NullPointerException if some of the required fields were not set.
 */

Body of Frist Method:
{
    Preconditions.checkCollectionElementsNotNull(mInstance.mKeyChainProtectionParams, "keyChainProtectionParams");
    Preconditions.checkCollectionElementsNotNull(mInstance.mEntryRecoveryData, "entryRecoveryData");
    Preconditions.checkNotNull(mInstance.mEncryptedRecoveryKeyBlob);
    Preconditions.checkNotNull(mInstance.mServerParams);
    Preconditions.checkNotNull(mInstance.mCertPath);
    return mInstance;
}
Body of Second Method:
{
    Preconditions.checkCollectionElementsNotNull(mInstance.mKeyChainProtectionParams, "keyChainProtectionParams");
    Preconditions.checkCollectionElementsNotNull(mInstance.mEntryRecoveryData, "entryRecoveryData");
    Objects.requireNonNull(mInstance.mEncryptedRecoveryKeyBlob);
    Objects.requireNonNull(mInstance.mServerParams);
    Objects.requireNonNull(mInstance.mCertPath);
    return mInstance;
}
------------------------
Find a silently evolved API code:android.view.InputMonitor.dispose:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Disposes the input monitor.
 *
 * Explicitly release all of the resources this monitor is holding on to (e.g. the
 * InputChannel). Once this method is called, this monitor and any resources it's provided may
 * no longer be used.
 */

Body of Frist Method:
{
    mChannel.dispose();
    try {
        mHost.dispose();
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    mInputChannel.dispose();
    try {
        mHost.dispose();
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.net.TcpKeepalivePacketData.writeToParcel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Write to parcel.
 */

Body of Frist Method:
{
    super.writeToParcel(out, flags);
    out.writeInt(tcpSeq);
    out.writeInt(tcpAck);
    out.writeInt(tcpWnd);
    out.writeInt(tcpWndScale);
    out.writeInt(ipTos);
    out.writeInt(ipTtl);
}
Body of Second Method:
{
    out.writeString(getSrcAddress().getHostAddress());
    out.writeString(getDstAddress().getHostAddress());
    out.writeInt(getSrcPort());
    out.writeInt(getDstPort());
    out.writeByteArray(getPacket());
    out.writeInt(tcpSeq);
    out.writeInt(tcpAck);
    out.writeInt(tcpWnd);
    out.writeInt(tcpWndScale);
    out.writeInt(ipTos);
    out.writeInt(ipTtl);
}
------------------------
Find a silently evolved API code:android.hardware.camera2.params.BlackLevelPattern.copyTo:COMMENT
Method Modifier: public      
Comment:/**
 * Copy the ColorChannel offsets into the destination vector.
 *
 * <p>Offsets are given in row-column scan order for a given 2x2 color pattern.</p>
 *
 * @param destination an array big enough to hold at least {@value #COUNT} elements after the
 * {@code offset}
 * @param offset a non-negative offset into the array
 *
 * @throws IllegalArgumentException if the offset is invalid.
 * @throws ArrayIndexOutOfBoundsException if the destination vector is too small.
 * @throws NullPointerException if the destination is null.
 */

Body of Frist Method:
{
    checkNotNull(destination, "destination must not be null");
    if (offset < 0) {
        throw new IllegalArgumentException("Null offset passed to copyTo");
    }
    if (destination.length - offset < COUNT) {
        throw new ArrayIndexOutOfBoundsException("destination too small to fit elements");
    }
    for (int i = 0; i < COUNT; ++i) {
        destination[offset + i] = mCfaOffsets[i];
    }
}
Body of Second Method:
{
    Objects.requireNonNull(destination, "destination must not be null");
    if (offset < 0) {
        throw new IllegalArgumentException("Null offset passed to copyTo");
    }
    if (destination.length - offset < COUNT) {
        throw new ArrayIndexOutOfBoundsException("destination too small to fit elements");
    }
    for (int i = 0; i < COUNT; ++i) {
        destination[offset + i] = mCfaOffsets[i];
    }
}
------------------------
Find a silently evolved API code:android.security.keystore.KeyGenParameterSpec.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Builds an instance of {@code KeyGenParameterSpec}.
 */

Body of Frist Method:
{
    return new KeyGenParameterSpec(mKeystoreAlias, mUid, mKeySize, mSpec, mCertificateSubject, mCertificateSerialNumber, mCertificateNotBefore, mCertificateNotAfter, mKeyValidityStart, mKeyValidityForOriginationEnd, mKeyValidityForConsumptionEnd, mPurposes, mDigests, mEncryptionPaddings, mSignaturePaddings, mBlockModes, mRandomizedEncryptionRequired, mUserAuthenticationRequired, mUserAuthenticationValidityDurationSeconds, mUserPresenceRequired, mAttestationChallenge, mUniqueIdIncluded, mUserAuthenticationValidWhileOnBody, mInvalidatedByBiometricEnrollment, mIsStrongBoxBacked, mUserConfirmationRequired, mUnlockedDeviceRequired);
}
Body of Second Method:
{
    return new KeyGenParameterSpec(mKeystoreAlias, mUid, mKeySize, mSpec, mCertificateSubject, mCertificateSerialNumber, mCertificateNotBefore, mCertificateNotAfter, mKeyValidityStart, mKeyValidityForOriginationEnd, mKeyValidityForConsumptionEnd, mPurposes, mDigests, mEncryptionPaddings, mSignaturePaddings, mBlockModes, mRandomizedEncryptionRequired, mUserAuthenticationRequired, mUserAuthenticationValidityDurationSeconds, mUserAuthenticationType, mUserPresenceRequired, mAttestationChallenge, mUniqueIdIncluded, mUserAuthenticationValidWhileOnBody, mInvalidatedByBiometricEnrollment, mIsStrongBoxBacked, mUserConfirmationRequired, mUnlockedDeviceRequired, mCriticalToDeviceEncryption);
}
------------------------
Find a silently evolved API code:android.text.format.DateUtils.isToday:COMMENT
Method Modifier: public      static      
Comment:/**
 * @return true if the supplied when is today else false
 */

Body of Frist Method:
{
    Time time = new Time();
    time.set(when);
    int thenYear = time.year;
    int thenMonth = time.month;
    int thenMonthDay = time.monthDay;
    time.set(System.currentTimeMillis());
    return (thenYear == time.year) && (thenMonth == time.month) && (thenMonthDay == time.monthDay);
}
Body of Second Method:
{
    return isSameDate(when, System.currentTimeMillis());
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiNetworkSuggestion.equals:COMMENT
Method Modifier: public      
Comment:/**
 * Equals for network suggestions.
 */

Body of Frist Method:
{
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof WifiNetworkSuggestion)) {
        return false;
    }
    WifiNetworkSuggestion lhs = (WifiNetworkSuggestion) obj;
    return Objects.equals(this.wifiConfiguration.SSID, lhs.wifiConfiguration.SSID) && Objects.equals(this.wifiConfiguration.BSSID, lhs.wifiConfiguration.BSSID) && Objects.equals(this.wifiConfiguration.allowedKeyManagement, lhs.wifiConfiguration.allowedKeyManagement) && suggestorUid == lhs.suggestorUid && TextUtils.equals(suggestorPackageName, lhs.suggestorPackageName);
}
Body of Second Method:
{
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof WifiNetworkSuggestion)) {
        return false;
    }
    WifiNetworkSuggestion lhs = (WifiNetworkSuggestion) obj;
    if (this.passpointConfiguration == null ^ lhs.passpointConfiguration == null) {
        return false;
    }
    return TextUtils.equals(this.wifiConfiguration.SSID, lhs.wifiConfiguration.SSID) && TextUtils.equals(this.wifiConfiguration.BSSID, lhs.wifiConfiguration.BSSID) && Objects.equals(this.wifiConfiguration.allowedKeyManagement, lhs.wifiConfiguration.allowedKeyManagement) && TextUtils.equals(this.wifiConfiguration.getKey(), lhs.wifiConfiguration.getKey());
}
------------------------
Find a silently evolved API code:android.speech.SpeechRecognizer.destroy:COMMENT
Method Modifier: public      
Comment:/**
 * Destroys the {@code SpeechRecognizer} object.
 */

Body of Frist Method:
{
    if (mService != null) {
        try {
            mService.cancel(mListener);
        } catch (final RemoteException e) {
        // Not important
        }
    }
    if (mConnection != null) {
        mContext.unbindService(mConnection);
    }
    mPendingTasks.clear();
    mService = null;
    mConnection = null;
    mListener.mInternalListener = null;
}
Body of Second Method:
{
    if (mService != null) {
        try {
            mService.cancel(mListener, mContext.getOpPackageName(), mContext.getAttributionTag());
        } catch (final RemoteException e) {
        // Not important
        }
    }
    if (mConnection != null) {
        mContext.unbindService(mConnection);
    }
    mPendingTasks.clear();
    mService = null;
    mConnection = null;
    mListener.mInternalListener = null;
}
------------------------
Find a silently evolved API code:android.hardware.location.NanoApp.setAppBinary:COMMENT
Method Modifier: public      hidden      deprecated  
Comment:/**
 * set output events returned by the nano app
 *
 * @param appBinary generated events
 */

Body of Frist Method:
{
    Preconditions.checkNotNull(appBinary, "appBinary must not be null");
    mAppBinary = appBinary;
}
Body of Second Method:
{
    Objects.requireNonNull(appBinary, "appBinary must not be null");
    mAppBinary = appBinary;
}
------------------------
Find a silently evolved API code:android.app.servertransaction.LaunchActivityItem.writeToParcel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Write from Parcel.
 */

Body of Frist Method:
{
    dest.writeTypedObject(mIntent, flags);
    dest.writeInt(mIdent);
    dest.writeTypedObject(mInfo, flags);
    dest.writeTypedObject(mCurConfig, flags);
    dest.writeTypedObject(mOverrideConfig, flags);
    dest.writeTypedObject(mCompatInfo, flags);
    dest.writeString(mReferrer);
    dest.writeStrongInterface(mVoiceInteractor);
    dest.writeInt(mProcState);
    dest.writeBundle(mState);
    dest.writePersistableBundle(mPersistentState);
    dest.writeTypedList(mPendingResults, flags);
    dest.writeTypedList(mPendingNewIntents, flags);
    dest.writeBoolean(mIsForward);
    dest.writeTypedObject(mProfilerInfo, flags);
    dest.writeStrongBinder(mAssistToken);
}
Body of Second Method:
{
    dest.writeTypedObject(mIntent, flags);
    dest.writeInt(mIdent);
    dest.writeTypedObject(mInfo, flags);
    dest.writeTypedObject(mCurConfig, flags);
    dest.writeTypedObject(mOverrideConfig, flags);
    dest.writeTypedObject(mCompatInfo, flags);
    dest.writeString(mReferrer);
    dest.writeStrongInterface(mVoiceInteractor);
    dest.writeInt(mProcState);
    dest.writeBundle(mState);
    dest.writePersistableBundle(mPersistentState);
    dest.writeTypedList(mPendingResults, flags);
    dest.writeTypedList(mPendingNewIntents, flags);
    dest.writeBoolean(mIsForward);
    dest.writeTypedObject(mProfilerInfo, flags);
    dest.writeStrongBinder(mAssistToken);
    dest.writeTypedObject(mFixedRotationAdjustments, flags);
}
------------------------
Find a silently evolved API code:android.view.animation.LinearInterpolator.createNativeInterpolator:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return NativeInterpolatorFactoryHelper.createLinearInterpolator();
}
Body of Second Method:
{
    return NativeInterpolatorFactory.createLinearInterpolator();
}
------------------------
Find a silently evolved API code:android.graphics.drawable.GradientDrawable.getOrientation:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the orientation of the gradient defined in this drawable.
 *
 * @return the orientation of the gradient defined in this drawable
 * @see #setOrientation(Orientation)
 */

Body of Frist Method:
{
    return mGradientState.getOrientation();
}
Body of Second Method:
{
    return mGradientState.mOrientation;
}
------------------------
Find a silently evolved API code:android.media.AudioAttributes.Builder.setInternalLegacyStreamType:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 * For internal framework use only, enables building from hidden stream types.
 * @param streamType
 * @return the same Builder instance.
 */

Body of Frist Method:
{
    mContentType = CONTENT_TYPE_UNKNOWN;
    mUsage = USAGE_UNKNOWN;
    if (AudioProductStrategy.getAudioProductStrategies().size() > 0) {
        AudioAttributes attributes = AudioProductStrategy.getAudioAttributesForStrategyWithLegacyStreamType(streamType);
        if (attributes != null) {
            mUsage = attributes.mUsage;
            mContentType = attributes.mContentType;
            mFlags = attributes.mFlags;
            mMuteHapticChannels = attributes.areHapticChannelsMuted();
            mTags = attributes.mTags;
            mBundle = attributes.mBundle;
            mSource = attributes.mSource;
        }
    }
    if (mContentType == CONTENT_TYPE_UNKNOWN) {
        switch(streamType) {
            case AudioSystem.STREAM_VOICE_CALL:
                mContentType = CONTENT_TYPE_SPEECH;
                break;
            case AudioSystem.STREAM_SYSTEM_ENFORCED:
                mFlags |= FLAG_AUDIBILITY_ENFORCED;
            // intended fall through, attributes in common with STREAM_SYSTEM
            case AudioSystem.STREAM_SYSTEM:
                mContentType = CONTENT_TYPE_SONIFICATION;
                break;
            case AudioSystem.STREAM_RING:
                mContentType = CONTENT_TYPE_SONIFICATION;
                break;
            case AudioSystem.STREAM_MUSIC:
                mContentType = CONTENT_TYPE_MUSIC;
                break;
            case AudioSystem.STREAM_ALARM:
                mContentType = CONTENT_TYPE_SONIFICATION;
                break;
            case AudioSystem.STREAM_NOTIFICATION:
                mContentType = CONTENT_TYPE_SONIFICATION;
                break;
            case AudioSystem.STREAM_BLUETOOTH_SCO:
                mContentType = CONTENT_TYPE_SPEECH;
                mFlags |= FLAG_SCO;
                break;
            case AudioSystem.STREAM_DTMF:
                mContentType = CONTENT_TYPE_SONIFICATION;
                break;
            case AudioSystem.STREAM_TTS:
                mContentType = CONTENT_TYPE_SONIFICATION;
                mFlags |= FLAG_BEACON;
                break;
            case AudioSystem.STREAM_ACCESSIBILITY:
                mContentType = CONTENT_TYPE_SPEECH;
                break;
            default:
                Log.e(TAG, "Invalid stream type " + streamType + " for AudioAttributes");
        }
    }
    if (mUsage == USAGE_UNKNOWN) {
        mUsage = usageForStreamType(streamType);
    }
    return this;
}
Body of Second Method:
{
    mContentType = CONTENT_TYPE_UNKNOWN;
    mUsage = USAGE_UNKNOWN;
    if (AudioProductStrategy.getAudioProductStrategies().size() > 0) {
        AudioAttributes attributes = AudioProductStrategy.getAudioAttributesForStrategyWithLegacyStreamType(streamType);
        if (attributes != null) {
            mUsage = attributes.mUsage;
            mContentType = attributes.mContentType;
            mFlags = attributes.getAllFlags();
            mMuteHapticChannels = attributes.areHapticChannelsMuted();
            mTags = attributes.mTags;
            mBundle = attributes.mBundle;
            mSource = attributes.mSource;
        }
    }
    if (mContentType == CONTENT_TYPE_UNKNOWN) {
        switch(streamType) {
            case AudioSystem.STREAM_VOICE_CALL:
                mContentType = CONTENT_TYPE_SPEECH;
                break;
            case AudioSystem.STREAM_SYSTEM_ENFORCED:
                mFlags |= FLAG_AUDIBILITY_ENFORCED;
            // intended fall through, attributes in common with STREAM_SYSTEM
            case AudioSystem.STREAM_SYSTEM:
                mContentType = CONTENT_TYPE_SONIFICATION;
                break;
            case AudioSystem.STREAM_RING:
                mContentType = CONTENT_TYPE_SONIFICATION;
                break;
            case AudioSystem.STREAM_MUSIC:
                mContentType = CONTENT_TYPE_MUSIC;
                break;
            case AudioSystem.STREAM_ALARM:
                mContentType = CONTENT_TYPE_SONIFICATION;
                break;
            case AudioSystem.STREAM_NOTIFICATION:
                mContentType = CONTENT_TYPE_SONIFICATION;
                break;
            case AudioSystem.STREAM_BLUETOOTH_SCO:
                mContentType = CONTENT_TYPE_SPEECH;
                mFlags |= FLAG_SCO;
                break;
            case AudioSystem.STREAM_DTMF:
                mContentType = CONTENT_TYPE_SONIFICATION;
                break;
            case AudioSystem.STREAM_TTS:
                mContentType = CONTENT_TYPE_SONIFICATION;
                mFlags |= FLAG_BEACON;
                break;
            case AudioSystem.STREAM_ACCESSIBILITY:
                mContentType = CONTENT_TYPE_SPEECH;
                break;
            default:
                Log.e(TAG, "Invalid stream type " + streamType + " for AudioAttributes");
        }
    }
    if (mUsage == USAGE_UNKNOWN) {
        mUsage = usageForStreamType(streamType);
    }
    return this;
}
------------------------
Find a silently evolved API code:android.app.TaskInfo.readFromParcel:COMMENT
Method Modifier: default     
Comment:/**
 * Reads the TaskInfo from a parcel.
 */

Body of Frist Method:
{
    userId = source.readInt();
    stackId = source.readInt();
    taskId = source.readInt();
    displayId = source.readInt();
    isRunning = source.readBoolean();
    baseIntent = source.readInt() != 0 ? Intent.CREATOR.createFromParcel(source) : null;
    baseActivity = ComponentName.readFromParcel(source);
    topActivity = ComponentName.readFromParcel(source);
    origActivity = ComponentName.readFromParcel(source);
    realActivity = ComponentName.readFromParcel(source);
    numActivities = source.readInt();
    lastActiveTime = source.readLong();
    taskDescription = source.readInt() != 0 ? ActivityManager.TaskDescription.CREATOR.createFromParcel(source) : null;
    supportsSplitScreenMultiWindow = source.readBoolean();
    resizeMode = source.readInt();
    configuration.readFromParcel(source);
}
Body of Second Method:
{
    userId = source.readInt();
    stackId = source.readInt();
    taskId = source.readInt();
    displayId = source.readInt();
    isRunning = source.readBoolean();
    baseIntent = source.readInt() != 0 ? Intent.CREATOR.createFromParcel(source) : null;
    baseActivity = ComponentName.readFromParcel(source);
    topActivity = ComponentName.readFromParcel(source);
    origActivity = ComponentName.readFromParcel(source);
    realActivity = ComponentName.readFromParcel(source);
    numActivities = source.readInt();
    lastActiveTime = source.readLong();
    taskDescription = source.readInt() != 0 ? ActivityManager.TaskDescription.CREATOR.createFromParcel(source) : null;
    supportsSplitScreenMultiWindow = source.readBoolean();
    resizeMode = source.readInt();
    configuration.readFromParcel(source);
    token = WindowContainerToken.CREATOR.createFromParcel(source);
    topActivityType = source.readInt();
    pictureInPictureParams = source.readInt() != 0 ? PictureInPictureParams.CREATOR.createFromParcel(source) : null;
    topActivityInfo = source.readInt() != 0 ? ActivityInfo.CREATOR.createFromParcel(source) : null;
    isResizeable = source.readBoolean();
}
------------------------
Find a silently evolved API code:android.widget.Switch.setTextOn:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the text displayed when the button is in the checked state.
 *
 * @attr ref android.R.styleable#Switch_textOn
 */

Body of Frist Method:
{
    mTextOn = textOn;
    requestLayout();
}
Body of Second Method:
{
    mTextOn = textOn;
    requestLayout();
    // Default state is derived from on/off-text, so state has to be updated when on/off-text
    // are updated.
    setDefaultStateDescritption();
}
------------------------
Find a silently evolved API code:android.media.tv.TvTrackInfo.Builder.setDescription:COMMENT
<android.media.tv.TvTrackInfo.Builder: Builder setDescription(CharSequence)>
public      final       ->public      
Method Modifier: public      final       
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * Sets a user readable description for the current track.
 *
 * @param description The user readable description.
 */

Body of Frist Method:
{
    mDescription = description;
    return this;
}
Body of Second Method:
{
    Preconditions.checkNotNull(description);
    mDescription = description;
    return this;
}
------------------------
Find a silently evolved API code:android.telephony.ims.ImsCallSessionListener.callSessionRemoveParticipantsRequestDelivered:COMMENT
Method Modifier: public      
Comment:/**
 * The request to remove participants from the conference has been delivered to the conference
 * server.
 */

Body of Frist Method:
{
    try {
        mListener.callSessionRemoveParticipantsRequestDelivered();
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}
Body of Second Method:
{
    try {
        mListener.callSessionRemoveParticipantsRequestDelivered();
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.view.animation.PathInterpolator.createNativeInterpolator:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide *
 */

Body of Frist Method:
{
    return NativeInterpolatorFactoryHelper.createPathInterpolator(mX, mY);
}
Body of Second Method:
{
    return NativeInterpolatorFactory.createPathInterpolator(mX, mY);
}
------------------------
Find a silently evolved API code:android.util.Half.toHexString:COMMENT
Method Modifier: public      static      
Comment:/**
 * <p>Returns a hexadecimal string representation of the specified half-precision
 * float value. If the value is a NaN, the result is <code>"NaN"</code>,
 * otherwise the result follows this format:</p>
 * <ul>
 * <li>If the sign is positive, no sign character appears in the result</li>
 * <li>If the sign is negative, the first character is <code>'-'</code></li>
 * <li>If the value is inifinity, the string is <code>"Infinity"</code></li>
 * <li>If the value is 0, the string is <code>"0x0.0p0"</code></li>
 * <li>If the value has a normalized representation, the exponent and
 * significand are represented in the string in two fields. The significand
 * starts with <code>"0x1."</code> followed by its lowercase hexadecimal
 * representation. Trailing zeroes are removed unless all digits are 0, then
 * a single zero is used. The significand representation is followed by the
 * exponent, represented by <code>"p"</code>, itself followed by a decimal
 * string of the unbiased exponent</li>
 * <li>If the value has a subnormal representation, the significand starts
 * with <code>"0x0."</code> followed by its lowercase hexadecimal
 * representation. Trailing zeroes are removed unless all digits are 0, then
 * a single zero is used. The significand representation is followed by the
 * exponent, represented by <code>"p-14"</code></li>
 * </ul>
 *
 * @param h A half-precision float value
 * @return A hexadecimal string representation of the specified value
 */

Body of Frist Method:
{
    StringBuilder o = new StringBuilder();
    int bits = h & 0xffff;
    int s = (bits >>> FP16_SIGN_SHIFT);
    int e = (bits >>> FP16_EXPONENT_SHIFT) & FP16_EXPONENT_MASK;
    int m = (bits) & FP16_SIGNIFICAND_MASK;
    if (e == 0x1f) {
        // Infinite or NaN
        if (m == 0) {
            if (s != 0)
                o.append('-');
            o.append("Infinity");
        } else {
            o.append("NaN");
        }
    } else {
        if (s == 1)
            o.append('-');
        if (e == 0) {
            if (m == 0) {
                o.append("0x0.0p0");
            } else {
                o.append("0x0.");
                String significand = Integer.toHexString(m);
                o.append(significand.replaceFirst("0{2,}$", ""));
                o.append("p-14");
            }
        } else {
            o.append("0x1.");
            String significand = Integer.toHexString(m);
            o.append(significand.replaceFirst("0{2,}$", ""));
            o.append('p');
            o.append(Integer.toString(e - FP16_EXPONENT_BIAS));
        }
    }
    return o.toString();
}
Body of Second Method:
{
    return FP16.toHexString(h);
}
------------------------
Find a silently evolved API code:android.telephony.ims.ImsCallSession.IImsCallSessionListenerProxy.callSessionHandover:COMMENT
Method Modifier: public      
Comment:/**
 * Notifies of handover information for this call
 */

Body of Frist Method:
{
    if (mListener != null) {
        mListener.callSessionHandover(ImsCallSession.this, srcAccessTech, targetAccessTech, reasonInfo);
    }
}
Body of Second Method:
{
    if (mListener != null) {
        mListener.callSessionHandover(ImsCallSession.this, srcNetworkType, targetNetworkType, reasonInfo);
    }
}
------------------------
Find a silently evolved API code:android.graphics.drawable.Icon.writeToStream:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Writes a serialized version of an Icon to the specified stream.
 *
 * @param stream The stream on which to serialize the Icon.
 * @hide
 */

Body of Frist Method:
{
    DataOutputStream dataStream = new DataOutputStream(stream);
    dataStream.writeInt(VERSION_STREAM_SERIALIZER);
    dataStream.writeByte(mType);
    switch(mType) {
        case TYPE_BITMAP:
        case TYPE_ADAPTIVE_BITMAP:
            getBitmap().compress(Bitmap.CompressFormat.PNG, 100, dataStream);
            break;
        case TYPE_DATA:
            dataStream.writeInt(getDataLength());
            dataStream.write(getDataBytes(), getDataOffset(), getDataLength());
            break;
        case TYPE_RESOURCE:
            dataStream.writeUTF(getResPackage());
            dataStream.writeInt(getResId());
            break;
        case TYPE_URI:
            dataStream.writeUTF(getUriString());
            break;
    }
}
Body of Second Method:
{
    DataOutputStream dataStream = new DataOutputStream(stream);
    dataStream.writeInt(VERSION_STREAM_SERIALIZER);
    dataStream.writeByte(mType);
    switch(mType) {
        case TYPE_BITMAP:
        case TYPE_ADAPTIVE_BITMAP:
            getBitmap().compress(Bitmap.CompressFormat.PNG, 100, dataStream);
            break;
        case TYPE_DATA:
            dataStream.writeInt(getDataLength());
            dataStream.write(getDataBytes(), getDataOffset(), getDataLength());
            break;
        case TYPE_RESOURCE:
            dataStream.writeUTF(getResPackage());
            dataStream.writeInt(getResId());
            break;
        case TYPE_URI:
        case TYPE_URI_ADAPTIVE_BITMAP:
            dataStream.writeUTF(getUriString());
            break;
    }
}
------------------------
Find a silently evolved API code:android.app.ActivityView.getVirtualDisplayId:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @return the display id of the virtual display.
 */

Body of Frist Method:
{
    if (mVirtualDisplay != null) {
        return mVirtualDisplay.getDisplay().getDisplayId();
    }
    return INVALID_DISPLAY;
}
Body of Second Method:
{
    return mTaskEmbedder.getDisplayId();
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothA2dp.shouldSendVolumeKeys:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * This function checks if the remote device is an AVCRP
 * target and thus whether we should send volume keys
 * changes or not.
 *
 * @hide
 */

Body of Frist Method:
{
    if (isEnabled() && isValidDevice(device)) {
        ParcelUuid[] uuids = device.getUuids();
        if (uuids == null)
            return false;
        for (ParcelUuid uuid : uuids) {
            if (BluetoothUuid.isAvrcpTarget(uuid)) {
                return true;
            }
        }
    }
    return false;
}
Body of Second Method:
{
    if (isEnabled() && isValidDevice(device)) {
        ParcelUuid[] uuids = device.getUuids();
        if (uuids == null)
            return false;
        for (ParcelUuid uuid : uuids) {
            if (uuid.equals(BluetoothUuid.AVRCP_TARGET)) {
                return true;
            }
        }
    }
    return false;
}
------------------------
Find a silently evolved API code:android.telephony.ims.ImsCallSessionListener.callSessionResumed:COMMENT
Method Modifier: public      
Comment:/**
 * The IMS call session has started the process of resuming the call. If the process of resuming
 * the call fails, call {@link #callSessionResumeFailed(ImsReasonInfo)}.
 *
 * @param profile The {@link ImsCallProfile} associated with this IMS call session.
 */

Body of Frist Method:
{
    try {
        mListener.callSessionResumed(profile);
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}
Body of Second Method:
{
    try {
        mListener.callSessionResumed(profile);
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.telephony.ims.ImsCallSessionListener.callQualityChanged:COMMENT
Method Modifier: public      
Comment:/**
 * The call quality has changed.
 *
 * @param callQuality The new call quality
 */

Body of Frist Method:
{
    try {
        mListener.callQualityChanged(callQuality);
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}
Body of Second Method:
{
    try {
        mListener.callQualityChanged(callQuality);
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.telephony.DisconnectCause.toString:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Returns descriptive string for the specified disconnect cause.
 * @hide
 */

Body of Frist Method:
{
    switch(cause) {
        case NOT_DISCONNECTED:
            return "NOT_DISCONNECTED";
        case INCOMING_MISSED:
            return "INCOMING_MISSED";
        case NORMAL:
            return "NORMAL";
        case LOCAL:
            return "LOCAL";
        case BUSY:
            return "BUSY";
        case CONGESTION:
            return "CONGESTION";
        case INVALID_NUMBER:
            return "INVALID_NUMBER";
        case NUMBER_UNREACHABLE:
            return "NUMBER_UNREACHABLE";
        case SERVER_UNREACHABLE:
            return "SERVER_UNREACHABLE";
        case INVALID_CREDENTIALS:
            return "INVALID_CREDENTIALS";
        case OUT_OF_NETWORK:
            return "OUT_OF_NETWORK";
        case SERVER_ERROR:
            return "SERVER_ERROR";
        case TIMED_OUT:
            return "TIMED_OUT";
        case LOST_SIGNAL:
            return "LOST_SIGNAL";
        case LIMIT_EXCEEDED:
            return "LIMIT_EXCEEDED";
        case INCOMING_REJECTED:
            return "INCOMING_REJECTED";
        case POWER_OFF:
            return "POWER_OFF";
        case OUT_OF_SERVICE:
            return "OUT_OF_SERVICE";
        case ICC_ERROR:
            return "ICC_ERROR";
        case CALL_BARRED:
            return "CALL_BARRED";
        case FDN_BLOCKED:
            return "FDN_BLOCKED";
        case CS_RESTRICTED:
            return "CS_RESTRICTED";
        case CS_RESTRICTED_NORMAL:
            return "CS_RESTRICTED_NORMAL";
        case CS_RESTRICTED_EMERGENCY:
            return "CS_RESTRICTED_EMERGENCY";
        case UNOBTAINABLE_NUMBER:
            return "UNOBTAINABLE_NUMBER";
        case CDMA_LOCKED_UNTIL_POWER_CYCLE:
            return "CDMA_LOCKED_UNTIL_POWER_CYCLE";
        case CDMA_DROP:
            return "CDMA_DROP";
        case CDMA_INTERCEPT:
            return "CDMA_INTERCEPT";
        case CDMA_REORDER:
            return "CDMA_REORDER";
        case CDMA_SO_REJECT:
            return "CDMA_SO_REJECT";
        case CDMA_RETRY_ORDER:
            return "CDMA_RETRY_ORDER";
        case CDMA_ACCESS_FAILURE:
            return "CDMA_ACCESS_FAILURE";
        case CDMA_PREEMPTED:
            return "CDMA_PREEMPTED";
        case CDMA_NOT_EMERGENCY:
            return "CDMA_NOT_EMERGENCY";
        case CDMA_ACCESS_BLOCKED:
            return "CDMA_ACCESS_BLOCKED";
        case EMERGENCY_ONLY:
            return "EMERGENCY_ONLY";
        case NO_PHONE_NUMBER_SUPPLIED:
            return "NO_PHONE_NUMBER_SUPPLIED";
        case DIALED_MMI:
            return "DIALED_MMI";
        case VOICEMAIL_NUMBER_MISSING:
            return "VOICEMAIL_NUMBER_MISSING";
        case CDMA_CALL_LOST:
            return "CDMA_CALL_LOST";
        case EXITED_ECM:
            return "EXITED_ECM";
        case DIAL_MODIFIED_TO_USSD:
            return "DIAL_MODIFIED_TO_USSD";
        case DIAL_MODIFIED_TO_SS:
            return "DIAL_MODIFIED_TO_SS";
        case DIAL_MODIFIED_TO_DIAL:
            return "DIAL_MODIFIED_TO_DIAL";
        case DIAL_MODIFIED_TO_DIAL_VIDEO:
            return "DIAL_MODIFIED_TO_DIAL_VIDEO";
        case DIAL_VIDEO_MODIFIED_TO_SS:
            return "DIAL_VIDEO_MODIFIED_TO_SS";
        case DIAL_VIDEO_MODIFIED_TO_USSD:
            return "DIAL_VIDEO_MODIFIED_TO_USSD";
        case DIAL_VIDEO_MODIFIED_TO_DIAL:
            return "DIAL_VIDEO_MODIFIED_TO_DIAL";
        case DIAL_VIDEO_MODIFIED_TO_DIAL_VIDEO:
            return "DIAL_VIDEO_MODIFIED_TO_DIAL_VIDEO";
        case ERROR_UNSPECIFIED:
            return "ERROR_UNSPECIFIED";
        case OUTGOING_FAILURE:
            return "OUTGOING_FAILURE";
        case OUTGOING_CANCELED:
            return "OUTGOING_CANCELED";
        case IMS_MERGED_SUCCESSFULLY:
            return "IMS_MERGED_SUCCESSFULLY";
        case CDMA_ALREADY_ACTIVATED:
            return "CDMA_ALREADY_ACTIVATED";
        case VIDEO_CALL_NOT_ALLOWED_WHILE_TTY_ENABLED:
            return "VIDEO_CALL_NOT_ALLOWED_WHILE_TTY_ENABLED";
        case CALL_PULLED:
            return "CALL_PULLED";
        case ANSWERED_ELSEWHERE:
            return "ANSWERED_ELSEWHERE";
        case MAXIMUM_NUMBER_OF_CALLS_REACHED:
            return "MAXIMUM_NUMER_OF_CALLS_REACHED";
        case DATA_DISABLED:
            return "DATA_DISABLED";
        case DATA_LIMIT_REACHED:
            return "DATA_LIMIT_REACHED";
        case DIALED_CALL_FORWARDING_WHILE_ROAMING:
            return "DIALED_CALL_FORWARDING_WHILE_ROAMING";
        case IMEI_NOT_ACCEPTED:
            return "IMEI_NOT_ACCEPTED";
        case WIFI_LOST:
            return "WIFI_LOST";
        case IMS_ACCESS_BLOCKED:
            return "IMS_ACCESS_BLOCKED";
        case LOW_BATTERY:
            return "LOW_BATTERY";
        case DIAL_LOW_BATTERY:
            return "DIAL_LOW_BATTERY";
        case EMERGENCY_TEMP_FAILURE:
            return "EMERGENCY_TEMP_FAILURE";
        case EMERGENCY_PERM_FAILURE:
            return "EMERGENCY_PERM_FAILURE";
        case NORMAL_UNSPECIFIED:
            return "NORMAL_UNSPECIFIED";
        case IMS_SIP_ALTERNATE_EMERGENCY_CALL:
            return "IMS_SIP_ALTERNATE_EMERGENCY_CALL";
        case ALREADY_DIALING:
            return "ALREADY_DIALING";
        case CANT_CALL_WHILE_RINGING:
            return "CANT_CALL_WHILE_RINGING";
        case CALLING_DISABLED:
            return "CALLING_DISABLED";
        case TOO_MANY_ONGOING_CALLS:
            return "TOO_MANY_ONGOING_CALLS";
        case OTASP_PROVISIONING_IN_PROCESS:
            return "OTASP_PROVISIONING_IN_PROCESS";
        default:
            return "INVALID: " + cause;
    }
}
Body of Second Method:
{
    switch(cause) {
        case NOT_DISCONNECTED:
            return "NOT_DISCONNECTED";
        case INCOMING_MISSED:
            return "INCOMING_MISSED";
        case NORMAL:
            return "NORMAL";
        case LOCAL:
            return "LOCAL";
        case BUSY:
            return "BUSY";
        case CONGESTION:
            return "CONGESTION";
        case INVALID_NUMBER:
            return "INVALID_NUMBER";
        case NUMBER_UNREACHABLE:
            return "NUMBER_UNREACHABLE";
        case SERVER_UNREACHABLE:
            return "SERVER_UNREACHABLE";
        case INVALID_CREDENTIALS:
            return "INVALID_CREDENTIALS";
        case OUT_OF_NETWORK:
            return "OUT_OF_NETWORK";
        case SERVER_ERROR:
            return "SERVER_ERROR";
        case TIMED_OUT:
            return "TIMED_OUT";
        case LOST_SIGNAL:
            return "LOST_SIGNAL";
        case LIMIT_EXCEEDED:
            return "LIMIT_EXCEEDED";
        case INCOMING_REJECTED:
            return "INCOMING_REJECTED";
        case POWER_OFF:
            return "POWER_OFF";
        case OUT_OF_SERVICE:
            return "OUT_OF_SERVICE";
        case ICC_ERROR:
            return "ICC_ERROR";
        case CALL_BARRED:
            return "CALL_BARRED";
        case FDN_BLOCKED:
            return "FDN_BLOCKED";
        case CS_RESTRICTED:
            return "CS_RESTRICTED";
        case CS_RESTRICTED_NORMAL:
            return "CS_RESTRICTED_NORMAL";
        case CS_RESTRICTED_EMERGENCY:
            return "CS_RESTRICTED_EMERGENCY";
        case UNOBTAINABLE_NUMBER:
            return "UNOBTAINABLE_NUMBER";
        case CDMA_LOCKED_UNTIL_POWER_CYCLE:
            return "CDMA_LOCKED_UNTIL_POWER_CYCLE";
        case CDMA_DROP:
            return "CDMA_DROP";
        case CDMA_INTERCEPT:
            return "CDMA_INTERCEPT";
        case CDMA_REORDER:
            return "CDMA_REORDER";
        case CDMA_SO_REJECT:
            return "CDMA_SO_REJECT";
        case CDMA_RETRY_ORDER:
            return "CDMA_RETRY_ORDER";
        case CDMA_ACCESS_FAILURE:
            return "CDMA_ACCESS_FAILURE";
        case CDMA_PREEMPTED:
            return "CDMA_PREEMPTED";
        case CDMA_NOT_EMERGENCY:
            return "CDMA_NOT_EMERGENCY";
        case CDMA_ACCESS_BLOCKED:
            return "CDMA_ACCESS_BLOCKED";
        case EMERGENCY_ONLY:
            return "EMERGENCY_ONLY";
        case NO_PHONE_NUMBER_SUPPLIED:
            return "NO_PHONE_NUMBER_SUPPLIED";
        case DIALED_MMI:
            return "DIALED_MMI";
        case VOICEMAIL_NUMBER_MISSING:
            return "VOICEMAIL_NUMBER_MISSING";
        case CDMA_CALL_LOST:
            return "CDMA_CALL_LOST";
        case EXITED_ECM:
            return "EXITED_ECM";
        case DIAL_MODIFIED_TO_USSD:
            return "DIAL_MODIFIED_TO_USSD";
        case DIAL_MODIFIED_TO_SS:
            return "DIAL_MODIFIED_TO_SS";
        case DIAL_MODIFIED_TO_DIAL:
            return "DIAL_MODIFIED_TO_DIAL";
        case DIAL_MODIFIED_TO_DIAL_VIDEO:
            return "DIAL_MODIFIED_TO_DIAL_VIDEO";
        case DIAL_VIDEO_MODIFIED_TO_SS:
            return "DIAL_VIDEO_MODIFIED_TO_SS";
        case DIAL_VIDEO_MODIFIED_TO_USSD:
            return "DIAL_VIDEO_MODIFIED_TO_USSD";
        case DIAL_VIDEO_MODIFIED_TO_DIAL:
            return "DIAL_VIDEO_MODIFIED_TO_DIAL";
        case DIAL_VIDEO_MODIFIED_TO_DIAL_VIDEO:
            return "DIAL_VIDEO_MODIFIED_TO_DIAL_VIDEO";
        case ERROR_UNSPECIFIED:
            return "ERROR_UNSPECIFIED";
        case OUTGOING_FAILURE:
            return "OUTGOING_FAILURE";
        case OUTGOING_CANCELED:
            return "OUTGOING_CANCELED";
        case IMS_MERGED_SUCCESSFULLY:
            return "IMS_MERGED_SUCCESSFULLY";
        case CDMA_ALREADY_ACTIVATED:
            return "CDMA_ALREADY_ACTIVATED";
        case VIDEO_CALL_NOT_ALLOWED_WHILE_TTY_ENABLED:
            return "VIDEO_CALL_NOT_ALLOWED_WHILE_TTY_ENABLED";
        case CALL_PULLED:
            return "CALL_PULLED";
        case ANSWERED_ELSEWHERE:
            return "ANSWERED_ELSEWHERE";
        case MAXIMUM_NUMBER_OF_CALLS_REACHED:
            return "MAXIMUM_NUMER_OF_CALLS_REACHED";
        case DATA_DISABLED:
            return "DATA_DISABLED";
        case DATA_LIMIT_REACHED:
            return "DATA_LIMIT_REACHED";
        case DIALED_CALL_FORWARDING_WHILE_ROAMING:
            return "DIALED_CALL_FORWARDING_WHILE_ROAMING";
        case IMEI_NOT_ACCEPTED:
            return "IMEI_NOT_ACCEPTED";
        case WIFI_LOST:
            return "WIFI_LOST";
        case IMS_ACCESS_BLOCKED:
            return "IMS_ACCESS_BLOCKED";
        case LOW_BATTERY:
            return "LOW_BATTERY";
        case DIAL_LOW_BATTERY:
            return "DIAL_LOW_BATTERY";
        case EMERGENCY_TEMP_FAILURE:
            return "EMERGENCY_TEMP_FAILURE";
        case EMERGENCY_PERM_FAILURE:
            return "EMERGENCY_PERM_FAILURE";
        case NORMAL_UNSPECIFIED:
            return "NORMAL_UNSPECIFIED";
        case IMS_SIP_ALTERNATE_EMERGENCY_CALL:
            return "IMS_SIP_ALTERNATE_EMERGENCY_CALL";
        case ALREADY_DIALING:
            return "ALREADY_DIALING";
        case CANT_CALL_WHILE_RINGING:
            return "CANT_CALL_WHILE_RINGING";
        case CALLING_DISABLED:
            return "CALLING_DISABLED";
        case TOO_MANY_ONGOING_CALLS:
            return "TOO_MANY_ONGOING_CALLS";
        case OTASP_PROVISIONING_IN_PROCESS:
            return "OTASP_PROVISIONING_IN_PROCESS";
        case MEDIA_TIMEOUT:
            return "MEDIA_TIMEOUT";
        case EMERGENCY_CALL_OVER_WFC_NOT_AVAILABLE:
            return "EMERGENCY_CALL_OVER_WFC_NOT_AVAILABLE";
        case WFC_SERVICE_NOT_AVAILABLE_IN_THIS_LOCATION:
            return "WFC_SERVICE_NOT_AVAILABLE_IN_THIS_LOCATION";
        case OUTGOING_EMERGENCY_CALL_PLACED:
            return "OUTGOING_EMERGENCY_CALL_PLACED";
        case INCOMING_AUTO_REJECTED:
            return "INCOMING_AUTO_REJECTED";
        default:
            return "INVALID: " + cause;
    }
}
------------------------
Find a silently evolved API code:android.hardware.location.ContextHubClient.sendMessageToNanoApp:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sends a message to a nanoapp through the Context Hub Service.
 *
 * This function returns RESULT_SUCCESS if the message has reached the HAL, but
 * does not guarantee delivery of the message to the target nanoapp.
 *
 * @param message the message object to send
 *
 * @return the result of sending the message defined as in ContextHubTransaction.Result
 *
 * @throws NullPointerException if NanoAppMessage is null
 *
 * @see NanoAppMessage
 * @see ContextHubTransaction.Result
 */

Body of Frist Method:
{
    Preconditions.checkNotNull(message, "NanoAppMessage cannot be null");
    try {
        return mClientProxy.sendMessageToNanoApp(message);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    Objects.requireNonNull(message, "NanoAppMessage cannot be null");
    int maxPayloadBytes = mAttachedHub.getMaxPacketLengthBytes();
    byte[] payload = message.getMessageBody();
    if (payload != null && payload.length > maxPayloadBytes) {
        Log.e(TAG, "Message (" + payload.length + " bytes) exceeds max payload length (" + maxPayloadBytes + " bytes)");
        return ContextHubTransaction.RESULT_FAILED_BAD_PARAMS;
    }
    try {
        return mClientProxy.sendMessageToNanoApp(message);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.webkit.MimeTypeMap.hasMimeType:COMMENT
Method Modifier: public      
Comment:/**
 * Return {@code true} if the given MIME type has an entry in the map.
 * @param mimeType A MIME type (i.e. text/plain)
 * @return {@code true} if there is a mimeType entry in the map.
 */

Body of Frist Method:
{
    return MimeUtils.hasMimeType(mimeType);
}
Body of Second Method:
{
    return MimeMap.getDefault().hasMimeType(mimeType);
}
------------------------
Find a silently evolved API code:android.content.ContentProviderClient.uncanonicalize:COMMENT
Method Modifier: public      final       
Comment:/**
 * See {@link ContentProvider#uncanonicalize}
 */

Body of Frist Method:
{
    Preconditions.checkNotNull(url, "url");
    beforeRemote();
    try {
        return mContentProvider.uncanonicalize(mPackageName, url);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}
Body of Second Method:
{
    Objects.requireNonNull(url, "url");
    beforeRemote();
    try {
        return mContentProvider.uncanonicalize(mPackageName, mAttributionTag, url);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}
------------------------
Find a silently evolved API code:android.hardware.usb.UsbDeviceConnection.open:COMMENT
Method Modifier: default     
Comment:/* package */

Body of Frist Method:
{
    mContext = context.getApplicationContext();
    boolean wasOpened = native_open(name, pfd.getFileDescriptor());
    if (wasOpened) {
        mCloseGuard.open("close");
    }
    return wasOpened;
}
Body of Second Method:
{
    mContext = context.getApplicationContext();
    synchronized (mLock) {
        boolean wasOpened = native_open(name, pfd.getFileDescriptor());
        if (wasOpened) {
            mCloseGuard.open("close");
        }
        return wasOpened;
    }
}
------------------------
Find a silently evolved API code:android.util.Half.min:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns the smaller of two half-precision float values (the value closest
 * to negative infinity). Special values are handled in the following ways:
 * <ul>
 * <li>If either value is NaN, the result is NaN</li>
 * <li>{@link #NEGATIVE_ZERO} is smaller than {@link #POSITIVE_ZERO}</li>
 * </ul>
 *
 * @param x The first half-precision value
 * @param y The second half-precision value
 * @return The smaller of the two specified half-precision values
 */

Body of Frist Method:
{
    if ((x & FP16_COMBINED) > FP16_EXPONENT_MAX)
        return NaN;
    if ((y & FP16_COMBINED) > FP16_EXPONENT_MAX)
        return NaN;
    if ((x & FP16_COMBINED) == 0 && (y & FP16_COMBINED) == 0) {
        return (x & FP16_SIGN_MASK) != 0 ? x : y;
    }
    return ((x & FP16_SIGN_MASK) != 0 ? 0x8000 - (x & 0xffff) : x & 0xffff) < ((y & FP16_SIGN_MASK) != 0 ? 0x8000 - (y & 0xffff) : y & 0xffff) ? x : y;
}
Body of Second Method:
{
    return FP16.min(x, y);
}
------------------------
Find a silently evolved API code:android.telephony.ims.ImsCallSessionListener.callSessionUpdateReceived:COMMENT
Method Modifier: public      
Comment:/**
 * The IMS call session profile has received an update from the remote user.
 *
 * @param profile The new {@link ImsCallProfile} associated with the update.
 */

Body of Frist Method:
{
    try {
        mListener.callSessionUpdateReceived(profile);
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}
Body of Second Method:
{
    try {
        mListener.callSessionUpdateReceived(profile);
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.location.LocationRequest.createFromDeprecatedProvider:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (minTime < 0)
        minTime = 0;
    if (minDistance < 0)
        minDistance = 0;
    int quality;
    if (LocationManager.PASSIVE_PROVIDER.equals(provider)) {
        quality = POWER_NONE;
    } else if (LocationManager.GPS_PROVIDER.equals(provider)) {
        quality = ACCURACY_FINE;
    } else {
        quality = POWER_LOW;
    }
    LocationRequest request = new LocationRequest().setProvider(provider).setQuality(quality).setInterval(minTime).setFastestInterval(minTime).setSmallestDisplacement(minDistance);
    if (singleShot)
        request.setNumUpdates(1);
    return request;
}
Body of Second Method:
{
    Preconditions.checkArgument(provider != null, "invalid null provider");
    if (minTime < 0)
        minTime = 0;
    if (minDistance < 0)
        minDistance = 0;
    int quality;
    if (LocationManager.PASSIVE_PROVIDER.equals(provider)) {
        quality = POWER_NONE;
    } else if (LocationManager.GPS_PROVIDER.equals(provider)) {
        quality = ACCURACY_FINE;
    } else {
        quality = POWER_LOW;
    }
    LocationRequest request = new LocationRequest().setProvider(provider).setQuality(quality).setInterval(minTime).setFastestInterval(minTime).setSmallestDisplacement(minDistance);
    if (singleShot)
        request.setNumUpdates(1);
    return request;
}
------------------------
Find a silently evolved API code:android.util.Half.compare:COMMENT
Method Modifier: public      static      
Comment:/**
 * <p>Compares the two specified half-precision float values. The following
 * conditions apply during the comparison:</p>
 *
 * <ul>
 * <li>{@link #NaN} is considered by this method to be equal to itself and greater
 * than all other half-precision float values (including {@code #POSITIVE_INFINITY})</li>
 * <li>{@link #POSITIVE_ZERO} is considered by this method to be greater than
 * {@link #NEGATIVE_ZERO}.</li>
 * </ul>
 *
 * @param x The first half-precision float value to compare.
 * @param y The second half-precision float value to compare
 *
 * @return  The value {@code 0} if {@code x} is numerically equal to {@code y}, a
 * value less than {@code 0} if {@code x} is numerically less than {@code y},
 * and a value greater than {@code 0} if {@code x} is numerically greater
 * than {@code y}
 */

Body of Frist Method:
{
    if (less(x, y))
        return -1;
    if (greater(x, y))
        return 1;
    // Collapse NaNs, akin to halfToIntBits(), but we want to keep
    // (signed) short value types to preserve the ordering of -0.0
    // and +0.0
    short xBits = (x & FP16_COMBINED) > FP16_EXPONENT_MAX ? NaN : x;
    short yBits = (y & FP16_COMBINED) > FP16_EXPONENT_MAX ? NaN : y;
    return (xBits == yBits ? 0 : (xBits < yBits ? -1 : 1));
}
Body of Second Method:
{
    return FP16.compare(x, y);
}
------------------------
Find a silently evolved API code:android.accessibilityservice.AccessibilityServiceInfo.capabilityToString:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns the string representation of a capability. For example,
 * {@link #CAPABILITY_CAN_RETRIEVE_WINDOW_CONTENT} is represented
 * by the string CAPABILITY_CAN_RETRIEVE_WINDOW_CONTENT.
 *
 * @param capability The capability.
 * @return The string representation.
 */

Body of Frist Method:
{
    switch(capability) {
        case CAPABILITY_CAN_RETRIEVE_WINDOW_CONTENT:
            return "CAPABILITY_CAN_RETRIEVE_WINDOW_CONTENT";
        case CAPABILITY_CAN_REQUEST_TOUCH_EXPLORATION:
            return "CAPABILITY_CAN_REQUEST_TOUCH_EXPLORATION";
        case CAPABILITY_CAN_REQUEST_ENHANCED_WEB_ACCESSIBILITY:
            return "CAPABILITY_CAN_REQUEST_ENHANCED_WEB_ACCESSIBILITY";
        case CAPABILITY_CAN_REQUEST_FILTER_KEY_EVENTS:
            return "CAPABILITY_CAN_REQUEST_FILTER_KEY_EVENTS";
        case CAPABILITY_CAN_CONTROL_MAGNIFICATION:
            return "CAPABILITY_CAN_CONTROL_MAGNIFICATION";
        case CAPABILITY_CAN_PERFORM_GESTURES:
            return "CAPABILITY_CAN_PERFORM_GESTURES";
        case CAPABILITY_CAN_REQUEST_FINGERPRINT_GESTURES:
            return "CAPABILITY_CAN_REQUEST_FINGERPRINT_GESTURES";
        default:
            return "UNKNOWN";
    }
}
Body of Second Method:
{
    switch(capability) {
        case CAPABILITY_CAN_RETRIEVE_WINDOW_CONTENT:
            return "CAPABILITY_CAN_RETRIEVE_WINDOW_CONTENT";
        case CAPABILITY_CAN_REQUEST_TOUCH_EXPLORATION:
            return "CAPABILITY_CAN_REQUEST_TOUCH_EXPLORATION";
        case CAPABILITY_CAN_REQUEST_ENHANCED_WEB_ACCESSIBILITY:
            return "CAPABILITY_CAN_REQUEST_ENHANCED_WEB_ACCESSIBILITY";
        case CAPABILITY_CAN_REQUEST_FILTER_KEY_EVENTS:
            return "CAPABILITY_CAN_REQUEST_FILTER_KEY_EVENTS";
        case CAPABILITY_CAN_CONTROL_MAGNIFICATION:
            return "CAPABILITY_CAN_CONTROL_MAGNIFICATION";
        case CAPABILITY_CAN_PERFORM_GESTURES:
            return "CAPABILITY_CAN_PERFORM_GESTURES";
        case CAPABILITY_CAN_REQUEST_FINGERPRINT_GESTURES:
            return "CAPABILITY_CAN_REQUEST_FINGERPRINT_GESTURES";
        case CAPABILITY_CAN_TAKE_SCREENSHOT:
            return "CAPABILITY_CAN_TAKE_SCREENSHOT";
        default:
            return "UNKNOWN";
    }
}
------------------------
Find a silently evolved API code:android.opengl.GLUtils.getInternalFormat:COMMENT
Method Modifier: public      static      
Comment:/**
 * return the internal format as defined by OpenGL ES of the supplied bitmap.
 * @param bitmap
 * @return the internal format of the bitmap.
 */

Body of Frist Method:
{
    if (bitmap == null) {
        throw new NullPointerException("getInternalFormat can't be used with a null Bitmap");
    }
    if (bitmap.isRecycled()) {
        throw new IllegalArgumentException("bitmap is recycled");
    }
    int result = native_getInternalFormat(bitmap.getNativeInstance());
    if (result < 0) {
        throw new IllegalArgumentException("Unknown internalformat");
    }
    return result;
}
Body of Second Method:
{
    if (bitmap == null) {
        throw new NullPointerException("getInternalFormat can't be used with a null Bitmap");
    }
    if (bitmap.isRecycled()) {
        throw new IllegalArgumentException("bitmap is recycled");
    }
    int result = native_getInternalFormat(bitmap);
    if (result < 0) {
        throw new IllegalArgumentException("Unknown internalformat");
    }
    return result;
}
------------------------
Find a silently evolved API code:android.view.MotionEvent.setSource:COMMENT
Method Modifier: public      final       
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    nativeSetSource(mNativePtr, source);
}
Body of Second Method:
{
    if (source == getSource()) {
        return;
    }
    nativeSetSource(mNativePtr, source);
    updateCursorPosition();
}
------------------------
Find a silently evolved API code:android.view.WindowInsets.Builder.setDisplayCutout:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the display cutout.
 *
 * @see #getDisplayCutout()
 * @param displayCutout the display cutout or null if there is none
 * @return itself
 */

Body of Frist Method:
{
    mDisplayCutout = displayCutout != null ? displayCutout : DisplayCutout.NO_CUTOUT;
    return this;
}
Body of Second Method:
{
    mDisplayCutout = displayCutout != null ? displayCutout : DisplayCutout.NO_CUTOUT;
    if (!mDisplayCutout.isEmpty()) {
        final Insets safeInsets = Insets.of(mDisplayCutout.getSafeInsets());
        final int index = indexOf(DISPLAY_CUTOUT);
        mTypeInsetsMap[index] = safeInsets;
        mTypeMaxInsetsMap[index] = safeInsets;
        mTypeVisibilityMap[index] = true;
    }
    return this;
}
------------------------
Find a silently evolved API code:android.os.ParcelFileDescriptor.fromData:COMMENT
Method Modifier: public      static      hidden      deprecated  
Comment:/**
 * @hide Please use createPipe() or ContentProvider.openPipeHelper().
 * Gets a file descriptor for a read-only copy of the given data.
 *
 * @param data Data to copy.
 * @param name Name for the shared memory area that may back the file descriptor.
 * This is purely informative and may be {@code null}.
 * @return A ParcelFileDescriptor.
 * @throws IOException if there is an error while creating the shared memory area.
 */

Body of Frist Method:
{
    if (data == null)
        return null;
    MemoryFile file = new MemoryFile(name, data.length);
    if (data.length > 0) {
        file.writeBytes(data, 0, 0, data.length);
    }
    file.deactivate();
    FileDescriptor fd = file.getFileDescriptor();
    return fd != null ? ParcelFileDescriptor.dup(fd) : null;
}
Body of Second Method:
{
    if (data == null)
        return null;
    MemoryFile file = new MemoryFile(name, data.length);
    try {
        if (data.length > 0) {
            file.writeBytes(data, 0, 0, data.length);
        }
        file.deactivate();
        FileDescriptor fd = file.getFileDescriptor();
        return fd != null ? ParcelFileDescriptor.dup(fd) : null;
    } finally {
        file.close();
    }
}
------------------------
Find a silently evolved API code:android.os.UserHandle.of:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return userId == USER_SYSTEM ? SYSTEM : new UserHandle(userId);
}
Body of Second Method:
{
    if (userId == USER_SYSTEM) {
        // Most common.
        return SYSTEM;
    }
    // These are sequential; so use a switch. Maybe they'll be optimized to a table lookup.
    switch(userId) {
        case USER_ALL:
            return ALL;
        case USER_CURRENT:
            return CURRENT;
        case USER_CURRENT_OR_SELF:
            return CURRENT_OR_SELF;
    }
    if (userId >= MIN_SECONDARY_USER_ID && userId < (MIN_SECONDARY_USER_ID + CACHED_USER_INFOS.length)) {
        return CACHED_USER_INFOS[userId - MIN_SECONDARY_USER_ID];
    }
    if (userId == USER_NULL) {
        // Not common.
        return NULL;
    }
    return new UserHandle(userId);
}
------------------------
Find a silently evolved API code:android.util.Half.max:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns the larger of two half-precision float values (the value closest
 * to positive infinity). Special values are handled in the following ways:
 * <ul>
 * <li>If either value is NaN, the result is NaN</li>
 * <li>{@link #POSITIVE_ZERO} is greater than {@link #NEGATIVE_ZERO}</li>
 * </ul>
 *
 * @param x The first half-precision value
 * @param y The second half-precision value
 *
 * @return The larger of the two specified half-precision values
 */

Body of Frist Method:
{
    if ((x & FP16_COMBINED) > FP16_EXPONENT_MAX)
        return NaN;
    if ((y & FP16_COMBINED) > FP16_EXPONENT_MAX)
        return NaN;
    if ((x & FP16_COMBINED) == 0 && (y & FP16_COMBINED) == 0) {
        return (x & FP16_SIGN_MASK) != 0 ? y : x;
    }
    return ((x & FP16_SIGN_MASK) != 0 ? 0x8000 - (x & 0xffff) : x & 0xffff) > ((y & FP16_SIGN_MASK) != 0 ? 0x8000 - (y & 0xffff) : y & 0xffff) ? x : y;
}
Body of Second Method:
{
    return FP16.max(x, y);
}
------------------------
Find a silently evolved API code:android.view.animation.CycleInterpolator.createNativeInterpolator:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return NativeInterpolatorFactoryHelper.createCycleInterpolator(mCycles);
}
Body of Second Method:
{
    return NativeInterpolatorFactory.createCycleInterpolator(mCycles);
}
------------------------
Find a silently evolved API code:android.location.GnssClock.resetTimeUncertaintyNanos:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Resets the clock's Time Uncertainty (1-Sigma) in nanoseconds.
 * @hide
 */

Body of Frist Method:
{
    resetFlag(HAS_TIME_UNCERTAINTY);
    mTimeUncertaintyNanos = Double.NaN;
}
Body of Second Method:
{
    resetFlag(HAS_TIME_UNCERTAINTY);
}
------------------------
Find a silently evolved API code:android.content.pm.SuspendDialogInfo.restoreFromXml:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    final SuspendDialogInfo.Builder dialogInfoBuilder = new SuspendDialogInfo.Builder();
    try {
        final int iconId = XmlUtils.readIntAttribute(in, XML_ATTR_ICON_RES_ID, ID_NULL);
        final int titleId = XmlUtils.readIntAttribute(in, XML_ATTR_TITLE_RES_ID, ID_NULL);
        final int buttonTextId = XmlUtils.readIntAttribute(in, XML_ATTR_BUTTON_TEXT_RES_ID, ID_NULL);
        final int dialogMessageResId = XmlUtils.readIntAttribute(in, XML_ATTR_DIALOG_MESSAGE_RES_ID, ID_NULL);
        final String dialogMessage = XmlUtils.readStringAttribute(in, XML_ATTR_DIALOG_MESSAGE);
        if (iconId != ID_NULL) {
            dialogInfoBuilder.setIcon(iconId);
        }
        if (titleId != ID_NULL) {
            dialogInfoBuilder.setTitle(titleId);
        }
        if (buttonTextId != ID_NULL) {
            dialogInfoBuilder.setNeutralButtonText(buttonTextId);
        }
        if (dialogMessageResId != ID_NULL) {
            dialogInfoBuilder.setMessage(dialogMessageResId);
        } else if (dialogMessage != null) {
            dialogInfoBuilder.setMessage(dialogMessage);
        }
    } catch (Exception e) {
        Slog.e(TAG, "Exception while parsing from xml. Some fields may default", e);
    }
    return dialogInfoBuilder.build();
}
Body of Second Method:
{
    final SuspendDialogInfo.Builder dialogInfoBuilder = new SuspendDialogInfo.Builder();
    try {
        final int iconId = XmlUtils.readIntAttribute(in, XML_ATTR_ICON_RES_ID, ID_NULL);
        final int titleId = XmlUtils.readIntAttribute(in, XML_ATTR_TITLE_RES_ID, ID_NULL);
        final int buttonTextId = XmlUtils.readIntAttribute(in, XML_ATTR_BUTTON_TEXT_RES_ID, ID_NULL);
        final int buttonAction = XmlUtils.readIntAttribute(in, XML_ATTR_BUTTON_ACTION, BUTTON_ACTION_MORE_DETAILS);
        final int dialogMessageResId = XmlUtils.readIntAttribute(in, XML_ATTR_DIALOG_MESSAGE_RES_ID, ID_NULL);
        final String dialogMessage = XmlUtils.readStringAttribute(in, XML_ATTR_DIALOG_MESSAGE);
        if (iconId != ID_NULL) {
            dialogInfoBuilder.setIcon(iconId);
        }
        if (titleId != ID_NULL) {
            dialogInfoBuilder.setTitle(titleId);
        }
        if (buttonTextId != ID_NULL) {
            dialogInfoBuilder.setNeutralButtonText(buttonTextId);
        }
        if (dialogMessageResId != ID_NULL) {
            dialogInfoBuilder.setMessage(dialogMessageResId);
        } else if (dialogMessage != null) {
            dialogInfoBuilder.setMessage(dialogMessage);
        }
        dialogInfoBuilder.setNeutralButtonAction(buttonAction);
    } catch (Exception e) {
        Slog.e(TAG, "Exception while parsing from xml. Some fields may default", e);
    }
    return dialogInfoBuilder.build();
}
------------------------
Find a silently evolved API code:android.media.session.MediaController.TransportControls.playFromMediaId:COMMENT
Method Modifier: public      
Comment:/**
 * Request that the player start playback for a specific media id.
 *
 * @param mediaId The id of the requested media.
 * @param extras Optional extras that can include extra information about the media item
 * to be played.
 */

Body of Frist Method:
{
    if (TextUtils.isEmpty(mediaId)) {
        throw new IllegalArgumentException("You must specify a non-empty String for playFromMediaId.");
    }
    try {
        mSessionBinder.playFromMediaId(mContext.getPackageName(), mCbStub, mediaId, extras);
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling play(" + mediaId + ").", e);
    }
}
Body of Second Method:
{
    if (TextUtils.isEmpty(mediaId)) {
        throw new IllegalArgumentException("You must specify a non-empty String for playFromMediaId.");
    }
    try {
        mSessionBinder.playFromMediaId(mContext.getPackageName(), mediaId, extras);
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling play(" + mediaId + ").", e);
    }
}
------------------------
Find a silently evolved API code:android.telephony.CellSignalStrengthLte.copyFrom:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    mSignalStrength = s.mSignalStrength;
    mRssi = s.mRssi;
    mRsrp = s.mRsrp;
    mRsrq = s.mRsrq;
    mRssnr = s.mRssnr;
    mCqi = s.mCqi;
    mTimingAdvance = s.mTimingAdvance;
    mLevel = s.mLevel;
}
Body of Second Method:
{
    mSignalStrength = s.mSignalStrength;
    mRssi = s.mRssi;
    mRsrp = s.mRsrp;
    mRsrq = s.mRsrq;
    mRssnr = s.mRssnr;
    mCqi = s.mCqi;
    mTimingAdvance = s.mTimingAdvance;
    mLevel = s.mLevel;
    mParametersUseForLevel = s.mParametersUseForLevel;
}
------------------------
Find a silently evolved API code:android.nfc.Tag.setConnectedTechnology:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * For internal use only.
 *
 * @hide
 */

Body of Frist Method:
{
    if (mConnectedTechnology == -1) {
        mConnectedTechnology = technology;
    } else {
        throw new IllegalStateException("Close other technology first!");
    }
}
Body of Second Method:
{
    if (mConnectedTechnology != -1) {
        return false;
    }
    mConnectedTechnology = technology;
    return true;
}
------------------------
Find a silently evolved API code:android.telephony.ims.ImsCallSessionListener.callSessionConferenceExtendReceived:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Compatibility method to interface with older versions of ImsService.
 * See {@link #callSessionConferenceExtendReceived(ImsCallSessionImplBase, ImsCallProfile)}.
 *
 * @hide
 */

Body of Frist Method:
{
    try {
        mListener.callSessionConferenceExtendReceived(newSession, profile);
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}
Body of Second Method:
{
    try {
        mListener.callSessionConferenceExtendReceived(newSession, profile);
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.hardware.location.ContextHubClient.setClientProxy:COMMENT
Method Modifier: default     hidden      
Comment:/* package */

Body of Frist Method:
{
    Preconditions.checkNotNull(clientProxy, "IContextHubClient cannot be null");
    if (mClientProxy != null) {
        throw new IllegalStateException("Cannot change client proxy multiple times");
    }
    mClientProxy = clientProxy;
}
Body of Second Method:
{
    Objects.requireNonNull(clientProxy, "IContextHubClient cannot be null");
    if (mClientProxy != null) {
        throw new IllegalStateException("Cannot change client proxy multiple times");
    }
    mClientProxy = clientProxy;
}
------------------------
Find a silently evolved API code:android.net.wifi.aware.ConfigRequest.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Build {@link ConfigRequest} given the current requests made on the
 * builder.
 */

Body of Frist Method:
{
    if (mClusterLow > mClusterHigh) {
        throw new IllegalArgumentException("Invalid argument combination - must have Cluster Low <= Cluster High");
    }
    return new ConfigRequest(mSupport5gBand, mMasterPreference, mClusterLow, mClusterHigh, mDiscoveryWindowInterval);
}
Body of Second Method:
{
    if (mClusterLow > mClusterHigh) {
        throw new IllegalArgumentException("Invalid argument combination - must have Cluster Low <= Cluster High");
    }
    return new ConfigRequest(mSupport5gBand, mSupport6gBand, mMasterPreference, mClusterLow, mClusterHigh, mDiscoveryWindowInterval);
}
------------------------
Find a silently evolved API code:android.net.UrlQuerySanitizer.IllegalCharacterValueSanitizer.sanitize:COMMENT
Method Modifier: public      
Comment:/**
 * Sanitize a value.
 * <ol>
 * <li>If script URLs are not OK, they will be removed.
 * <li>If neither spaces nor other white space is OK, then
 * white space will be trimmed from the beginning and end of
 * the URL. (Just the actual white space characters are trimmed, not
 * other control codes.)
 * <li> Illegal characters will be replaced with
 * either ' ' or '_', depending on whether a space is itself a
 * legal character.
 * </ol>
 * @param value
 * @return the sanitized value
 */

Body of Frist Method:
{
    if (value == null) {
        return null;
    }
    int length = value.length();
    if ((mFlags & SCRIPT_URL_OK) != 0) {
        if (length >= MIN_SCRIPT_PREFIX_LENGTH) {
            String asLower = value.toLowerCase(Locale.ROOT);
            if (asLower.startsWith(JAVASCRIPT_PREFIX) || asLower.startsWith(VBSCRIPT_PREFIX)) {
                return "";
            }
        }
    }
    // and end of value.
    if ((mFlags & ALL_WHITESPACE_OK) == 0) {
        value = trimWhitespace(value);
        // The length could have changed, so we need to correct
        // the length variable.
        length = value.length();
    }
    StringBuilder stringBuilder = new StringBuilder(length);
    for (int i = 0; i < length; i++) {
        char c = value.charAt(i);
        if (!characterIsLegal(c)) {
            if ((mFlags & SPACE_OK) != 0) {
                c = ' ';
            } else {
                c = '_';
            }
        }
        stringBuilder.append(c);
    }
    return stringBuilder.toString();
}
Body of Second Method:
{
    if (value == null) {
        return null;
    }
    int length = value.length();
    if ((mFlags & SCRIPT_URL_OK) == 0) {
        if (length >= MIN_SCRIPT_PREFIX_LENGTH) {
            String asLower = value.toLowerCase(Locale.ROOT);
            if (asLower.startsWith(JAVASCRIPT_PREFIX) || asLower.startsWith(VBSCRIPT_PREFIX)) {
                return "";
            }
        }
    }
    // and end of value.
    if ((mFlags & ALL_WHITESPACE_OK) == 0) {
        value = trimWhitespace(value);
        // The length could have changed, so we need to correct
        // the length variable.
        length = value.length();
    }
    StringBuilder stringBuilder = new StringBuilder(length);
    for (int i = 0; i < length; i++) {
        char c = value.charAt(i);
        if (!characterIsLegal(c)) {
            if ((mFlags & SPACE_OK) != 0) {
                c = ' ';
            } else {
                c = '_';
            }
        }
        stringBuilder.append(c);
    }
    return stringBuilder.toString();
}
------------------------
Find a silently evolved API code:android.telephony.CarrierConfigManager.getConfigForSubId:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the configuration values for a particular subscription, which is associated with a
 * specific SIM card. If an invalid subId is used, the returned config will contain default
 * values. After using this method to get the configuration bundle,
 * {@link #isConfigForIdentifiedCarrier(PersistableBundle)} should be called to confirm whether
 * any carrier specific configuration has been applied.
 *
 * <p>Requires Permission:
 * {@link android.Manifest.permission#READ_PHONE_STATE READ_PHONE_STATE}
 *
 * @param subId the subscription ID, normally obtained from {@link SubscriptionManager}.
 * @return A {@link PersistableBundle} containing the config for the given subId, or default
 * values for an invalid subId.
 */

Body of Frist Method:
{
    try {
        ICarrierConfigLoader loader = getICarrierConfigLoader();
        if (loader == null) {
            Rlog.w(TAG, "Error getting config for subId " + subId + " ICarrierConfigLoader is null");
            return null;
        }
        return loader.getConfigForSubId(subId, mContext.getOpPackageName());
    } catch (RemoteException ex) {
        Rlog.e(TAG, "Error getting config for subId " + subId + ": " + ex.toString());
    }
    return null;
}
Body of Second Method:
{
    try {
        ICarrierConfigLoader loader = getICarrierConfigLoader();
        if (loader == null) {
            Rlog.w(TAG, "Error getting config for subId " + subId + " ICarrierConfigLoader is null");
            return null;
        }
        return loader.getConfigForSubIdWithFeature(subId, mContext.getOpPackageName(), mContext.getAttributionTag());
    } catch (RemoteException ex) {
        Rlog.e(TAG, "Error getting config for subId " + subId + ": " + ex.toString());
    }
    return null;
}
------------------------
Find a silently evolved API code:android.app.ActivityView.onLocationChanged:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Triggers an update of {@link ActivityView}'s location in window to properly set tap exclude
 * regions and avoid focus switches by touches on this view.
 */

Body of Frist Method:
{
    updateLocationAndTapExcludeRegion();
}
Body of Second Method:
{
    mTaskEmbedder.notifyBoundsChanged();
}
------------------------
Find a silently evolved API code:android.net.RouteInfo.toString:COMMENT
Method Modifier: public      
Comment:/**
 * Returns a human-readable description of this object.
 */

Body of Frist Method:
{
    String val = "";
    if (mDestination != null)
        val = mDestination.toString();
    if (mType == RTN_UNREACHABLE) {
        val += " unreachable";
    } else if (mType == RTN_THROW) {
        val += " throw";
    } else {
        val += " ->";
        if (mGateway != null)
            val += " " + mGateway.getHostAddress();
        if (mInterface != null)
            val += " " + mInterface;
        if (mType != RTN_UNICAST) {
            val += " unknown type " + mType;
        }
    }
    return val;
}
Body of Second Method:
{
    String val = "";
    if (mDestination != null)
        val = mDestination.toString();
    if (mType == RTN_UNREACHABLE) {
        val += " unreachable";
    } else if (mType == RTN_THROW) {
        val += " throw";
    } else {
        val += " ->";
        if (mGateway != null)
            val += " " + mGateway.getHostAddress();
        if (mInterface != null)
            val += " " + mInterface;
        if (mType != RTN_UNICAST) {
            val += " unknown type " + mType;
        }
    }
    val += " mtu " + mMtu;
    return val;
}
------------------------
Find a silently evolved API code:android.location.LocationRequest.setSmallestDisplacement:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    checkDisplacement(meters);
    mSmallestDisplacement = meters;
    return this;
}
Body of Second Method:
{
    mSmallestDisplacement = Preconditions.checkArgumentInRange(smallestDisplacementM, 0, Float.MAX_VALUE, "smallestDisplacementM");
    return this;
}
------------------------
Find a silently evolved API code:android.media.AudioAttributes.usageToString:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    switch(usage) {
        case USAGE_UNKNOWN:
            return new String("USAGE_UNKNOWN");
        case USAGE_MEDIA:
            return new String("USAGE_MEDIA");
        case USAGE_VOICE_COMMUNICATION:
            return new String("USAGE_VOICE_COMMUNICATION");
        case USAGE_VOICE_COMMUNICATION_SIGNALLING:
            return new String("USAGE_VOICE_COMMUNICATION_SIGNALLING");
        case USAGE_ALARM:
            return new String("USAGE_ALARM");
        case USAGE_NOTIFICATION:
            return new String("USAGE_NOTIFICATION");
        case USAGE_NOTIFICATION_RINGTONE:
            return new String("USAGE_NOTIFICATION_RINGTONE");
        case USAGE_NOTIFICATION_COMMUNICATION_REQUEST:
            return new String("USAGE_NOTIFICATION_COMMUNICATION_REQUEST");
        case USAGE_NOTIFICATION_COMMUNICATION_INSTANT:
            return new String("USAGE_NOTIFICATION_COMMUNICATION_INSTANT");
        case USAGE_NOTIFICATION_COMMUNICATION_DELAYED:
            return new String("USAGE_NOTIFICATION_COMMUNICATION_DELAYED");
        case USAGE_NOTIFICATION_EVENT:
            return new String("USAGE_NOTIFICATION_EVENT");
        case USAGE_ASSISTANCE_ACCESSIBILITY:
            return new String("USAGE_ASSISTANCE_ACCESSIBILITY");
        case USAGE_ASSISTANCE_NAVIGATION_GUIDANCE:
            return new String("USAGE_ASSISTANCE_NAVIGATION_GUIDANCE");
        case USAGE_ASSISTANCE_SONIFICATION:
            return new String("USAGE_ASSISTANCE_SONIFICATION");
        case USAGE_GAME:
            return new String("USAGE_GAME");
        case USAGE_ASSISTANT:
            return new String("USAGE_ASSISTANT");
        default:
            return new String("unknown usage " + usage);
    }
}
Body of Second Method:
{
    switch(usage) {
        case USAGE_UNKNOWN:
            return new String("USAGE_UNKNOWN");
        case USAGE_MEDIA:
            return new String("USAGE_MEDIA");
        case USAGE_VOICE_COMMUNICATION:
            return new String("USAGE_VOICE_COMMUNICATION");
        case USAGE_VOICE_COMMUNICATION_SIGNALLING:
            return new String("USAGE_VOICE_COMMUNICATION_SIGNALLING");
        case USAGE_ALARM:
            return new String("USAGE_ALARM");
        case USAGE_NOTIFICATION:
            return new String("USAGE_NOTIFICATION");
        case USAGE_NOTIFICATION_RINGTONE:
            return new String("USAGE_NOTIFICATION_RINGTONE");
        case USAGE_NOTIFICATION_COMMUNICATION_REQUEST:
            return new String("USAGE_NOTIFICATION_COMMUNICATION_REQUEST");
        case USAGE_NOTIFICATION_COMMUNICATION_INSTANT:
            return new String("USAGE_NOTIFICATION_COMMUNICATION_INSTANT");
        case USAGE_NOTIFICATION_COMMUNICATION_DELAYED:
            return new String("USAGE_NOTIFICATION_COMMUNICATION_DELAYED");
        case USAGE_NOTIFICATION_EVENT:
            return new String("USAGE_NOTIFICATION_EVENT");
        case USAGE_ASSISTANCE_ACCESSIBILITY:
            return new String("USAGE_ASSISTANCE_ACCESSIBILITY");
        case USAGE_ASSISTANCE_NAVIGATION_GUIDANCE:
            return new String("USAGE_ASSISTANCE_NAVIGATION_GUIDANCE");
        case USAGE_ASSISTANCE_SONIFICATION:
            return new String("USAGE_ASSISTANCE_SONIFICATION");
        case USAGE_GAME:
            return new String("USAGE_GAME");
        case USAGE_ASSISTANT:
            return new String("USAGE_ASSISTANT");
        case USAGE_CALL_ASSISTANT:
            return new String("USAGE_CALL_ASSISTANT");
        case USAGE_EMERGENCY:
            return new String("USAGE_EMERGENCY");
        case USAGE_SAFETY:
            return new String("USAGE_SAFETY");
        case USAGE_VEHICLE_STATUS:
            return new String("USAGE_VEHICLE_STATUS");
        case USAGE_ANNOUNCEMENT:
            return new String("USAGE_ANNOUNCEMENT");
        default:
            return new String("unknown usage " + usage);
    }
}
------------------------
Find a silently evolved API code:android.app.StatusBarManager.DisableInfo.setDisableAll:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    mStatusBarExpansion = true;
    mNavigateHome = true;
    mNotificationPeeking = true;
    mRecents = true;
    mSearch = true;
}
Body of Second Method:
{
    mStatusBarExpansion = true;
    mNavigateHome = true;
    mNotificationPeeking = true;
    mRecents = true;
    mSearch = true;
    mSystemIcons = true;
    mClock = true;
    mNotificationIcons = true;
}
------------------------
Find a silently evolved API code:android.content.pm.ModuleInfo.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Flattens this object into the given {@link Parcel}.
 */

Body of Frist Method:
{
    dest.writeCharSequence(mName);
    dest.writeString(mPackageName);
    dest.writeBoolean(mHidden);
}
Body of Second Method:
{
    dest.writeCharSequence(mName);
    dest.writeString(mPackageName);
    dest.writeBoolean(mHidden);
    dest.writeString(mApexModuleName);
}
------------------------
Find a silently evolved API code:android.content.pm.UserInfo.supportsSwitchTo:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @return true if this user can be switched to.
 */

Body of Frist Method:
{
    if (isEphemeral() && !isEnabled()) {
        // Don't support switching to an ephemeral user with removal in progress.
        return false;
    }
    return !isManagedProfile();
}
Body of Second Method:
{
    if (isEphemeral() && !isEnabled()) {
        // Don't support switching to an ephemeral user with removal in progress.
        return false;
    }
    if (preCreated) {
        // Don't support switching to pre-created users until they become "real" users.
        return false;
    }
    return !isProfile();
}
------------------------
Find a silently evolved API code:android.util.ArraySet.addAll:COMMENT
Method Modifier: public      
Comment:/**
 * Perform a {@link #add(Object)} of all values in <var>array</var>
 * @param array The array whose contents are to be retrieved.
 */

Body of Frist Method:
{
    final int N = array.mSize;
    ensureCapacity(mSize + N);
    if (mSize == 0) {
        if (N > 0) {
            System.arraycopy(array.mHashes, 0, mHashes, 0, N);
            System.arraycopy(array.mArray, 0, mArray, 0, N);
            mSize = N;
        }
    } else {
        for (int i = 0; i < N; i++) {
            add(array.valueAt(i));
        }
    }
}
Body of Second Method:
{
    final int N = array.mSize;
    ensureCapacity(mSize + N);
    if (mSize == 0) {
        if (N > 0) {
            System.arraycopy(array.mHashes, 0, mHashes, 0, N);
            System.arraycopy(array.mArray, 0, mArray, 0, N);
            if (0 != mSize) {
                throw new ConcurrentModificationException();
            }
            mSize = N;
        }
    } else {
        for (int i = 0; i < N; i++) {
            add(array.valueAt(i));
        }
    }
}
------------------------
Find a silently evolved API code:android.app.servertransaction.MoveToDisplayItem.obtain:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Obtain an instance initialized with provided params.
 */

Body of Frist Method:
{
    MoveToDisplayItem instance = ObjectPool.obtain(MoveToDisplayItem.class);
    if (instance == null) {
        instance = new MoveToDisplayItem();
    }
    instance.mTargetDisplayId = targetDisplayId;
    instance.mConfiguration = configuration;
    return instance;
}
Body of Second Method:
{
    if (configuration == null) {
        throw new IllegalArgumentException("Configuration must not be null");
    }
    MoveToDisplayItem instance = ObjectPool.obtain(MoveToDisplayItem.class);
    if (instance == null) {
        instance = new MoveToDisplayItem();
    }
    instance.mTargetDisplayId = targetDisplayId;
    instance.mConfiguration = configuration;
    return instance;
}
------------------------
Find a silently evolved API code:android.hardware.usb.UsbRequest.initialize:COMMENT
Method Modifier: public      
Comment:/**
 * Initializes the request so it can read or write data on the given endpoint.
 * Whether the request allows reading or writing depends on the direction of the endpoint.
 *
 * @param endpoint the endpoint to be used for this request.
 * @return true if the request was successfully opened.
 */

Body of Frist Method:
{
    mEndpoint = endpoint;
    mConnection = Preconditions.checkNotNull(connection, "connection");
    boolean wasInitialized = native_init(connection, endpoint.getAddress(), endpoint.getAttributes(), endpoint.getMaxPacketSize(), endpoint.getInterval());
    if (wasInitialized) {
        mCloseGuard.open("close");
    }
    return wasInitialized;
}
Body of Second Method:
{
    mEndpoint = endpoint;
    mConnection = Objects.requireNonNull(connection, "connection");
    boolean wasInitialized = native_init(connection, endpoint.getAddress(), endpoint.getAttributes(), endpoint.getMaxPacketSize(), endpoint.getInterval());
    if (wasInitialized) {
        mCloseGuard.open("close");
    }
    return wasInitialized;
}
------------------------
Find a silently evolved API code:android.app.servertransaction.LaunchActivityItem.setValues:COMMENT
Method Modifier: private     static      hidden      
Comment:// Using the same method to set and clear values to make sure we don't forget anything

Body of Frist Method:
{
    instance.mIntent = intent;
    instance.mIdent = ident;
    instance.mInfo = info;
    instance.mCurConfig = curConfig;
    instance.mOverrideConfig = overrideConfig;
    instance.mCompatInfo = compatInfo;
    instance.mReferrer = referrer;
    instance.mVoiceInteractor = voiceInteractor;
    instance.mProcState = procState;
    instance.mState = state;
    instance.mPersistentState = persistentState;
    instance.mPendingResults = pendingResults;
    instance.mPendingNewIntents = pendingNewIntents;
    instance.mIsForward = isForward;
    instance.mProfilerInfo = profilerInfo;
    instance.mAssistToken = assistToken;
}
Body of Second Method:
{
    instance.mIntent = intent;
    instance.mIdent = ident;
    instance.mInfo = info;
    instance.mCurConfig = curConfig;
    instance.mOverrideConfig = overrideConfig;
    instance.mCompatInfo = compatInfo;
    instance.mReferrer = referrer;
    instance.mVoiceInteractor = voiceInteractor;
    instance.mProcState = procState;
    instance.mState = state;
    instance.mPersistentState = persistentState;
    instance.mPendingResults = pendingResults;
    instance.mPendingNewIntents = pendingNewIntents;
    instance.mIsForward = isForward;
    instance.mProfilerInfo = profilerInfo;
    instance.mAssistToken = assistToken;
    instance.mFixedRotationAdjustments = fixedRotationAdjustments;
}
------------------------
Find a silently evolved API code:android.media.AudioPlaybackConfiguration.dump:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 * For AudioService dump
 * @param pw
 */

Body of Frist Method:
{
    pw.println("  " + toLogFriendlyString(this));
}
Body of Second Method:
{
    pw.println("  " + this);
}
------------------------
Find a silently evolved API code:android.os.Debug.MemoryInfo.getSummaryCode:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Pss of code and other static resource bytes in KB due to
 * the application.
 * @hide
 */

Body of Frist Method:
{
    return getOtherPrivate(OTHER_SO) + getOtherPrivate(OTHER_JAR) + getOtherPrivate(OTHER_APK) + getOtherPrivate(OTHER_TTF) + getOtherPrivate(OTHER_DEX) + getOtherPrivate(OTHER_OAT);
}
Body of Second Method:
{
    return getOtherPrivate(OTHER_SO) + getOtherPrivate(OTHER_JAR) + getOtherPrivate(OTHER_APK) + getOtherPrivate(OTHER_TTF) + getOtherPrivate(OTHER_DEX) + getOtherPrivate(OTHER_OAT) + getOtherPrivate(OTHER_DALVIK_OTHER_ZYGOTE_CODE_CACHE) + getOtherPrivate(OTHER_DALVIK_OTHER_APP_CODE_CACHE);
}
------------------------
Find a silently evolved API code:android.service.notification.StatusBarNotification.cloneLight:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    final Notification no = new Notification();
    // light copy
    this.notification.cloneInto(no, false);
    return new StatusBarNotification(this.pkg, this.opPkg, this.id, this.tag, this.uid, this.initialPid, no, this.user, this.overrideGroupKey, this.postTime);
}
Body of Second Method:
{
    final Notification no = new Notification();
    // light copy
    this.notification.cloneInto(no, false);
    return cloneShallow(no);
}
------------------------
Find a silently evolved API code:android.content.om.OverlayInfo.stateToString:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Translate a state to a human readable string. Only intended for
 * debugging purposes.
 *
 * @return a human readable String representing the state.
 * @hide
 */

Body of Frist Method:
{
    switch(state) {
        case STATE_UNKNOWN:
            return "STATE_UNKNOWN";
        case STATE_MISSING_TARGET:
            return "STATE_MISSING_TARGET";
        case STATE_NO_IDMAP:
            return "STATE_NO_IDMAP";
        case STATE_DISABLED:
            return "STATE_DISABLED";
        case STATE_ENABLED:
            return "STATE_ENABLED";
        case STATE_ENABLED_STATIC:
            return "STATE_ENABLED_STATIC";
        case STATE_TARGET_IS_BEING_REPLACED:
            return "STATE_TARGET_IS_BEING_REPLACED";
        case STATE_OVERLAY_IS_BEING_REPLACED:
            return "STATE_OVERLAY_IS_BEING_REPLACED";
        default:
            return "<unknown state>";
    }
}
Body of Second Method:
{
    switch(state) {
        case STATE_UNKNOWN:
            return "STATE_UNKNOWN";
        case STATE_MISSING_TARGET:
            return "STATE_MISSING_TARGET";
        case STATE_NO_IDMAP:
            return "STATE_NO_IDMAP";
        case STATE_DISABLED:
            return "STATE_DISABLED";
        case STATE_ENABLED:
            return "STATE_ENABLED";
        case STATE_ENABLED_IMMUTABLE:
            return "STATE_ENABLED_IMMUTABLE";
        case STATE_TARGET_IS_BEING_REPLACED:
            return "STATE_TARGET_IS_BEING_REPLACED";
        case STATE_OVERLAY_IS_BEING_REPLACED:
            return "STATE_OVERLAY_IS_BEING_REPLACED";
        default:
            return "<unknown state>";
    }
}
------------------------
Find a silently evolved API code:android.service.voice.AlwaysOnHotwordDetector.RefreshAvailabiltyTask.internalGetInitialAvailability:COMMENT
Method Modifier: private     
Comment:/**
 * @return The initial availability without checking the enrollment status.
 */

Body of Frist Method:
{
    synchronized (mLock) {
        // This detector has already been invalidated.
        if (mAvailability == STATE_INVALID) {
            return STATE_INVALID;
        }
    }
    ModuleProperties dspModuleProperties = null;
    try {
        dspModuleProperties = mModelManagementService.getDspModuleProperties(mVoiceInteractionService);
    } catch (RemoteException e) {
        Slog.w(TAG, "RemoteException in getDspProperties!", e);
    }
    // No DSP available
    if (dspModuleProperties == null) {
        return STATE_HARDWARE_UNAVAILABLE;
    }
    // No enrollment application supports this keyphrase/locale
    if (mKeyphraseMetadata == null) {
        return STATE_KEYPHRASE_UNSUPPORTED;
    }
    return STATE_NOT_READY;
}
Body of Second Method:
{
    synchronized (mLock) {
        // This detector has already been invalidated.
        if (mAvailability == STATE_INVALID) {
            return STATE_INVALID;
        }
    }
    ModuleProperties dspModuleProperties;
    try {
        dspModuleProperties = mModelManagementService.getDspModuleProperties();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
    // No DSP available
    if (dspModuleProperties == null) {
        return STATE_HARDWARE_UNAVAILABLE;
    }
    return STATE_NOT_READY;
}
------------------------
Find a silently evolved API code:android.telephony.CellSignalStrengthLte.toString:COMMENT
Method Modifier: public      
Comment:/**
 * @return string representation.
 */

Body of Frist Method:
{
    return "CellSignalStrengthLte:" + " rssi=" + mRssi + " rsrp=" + mRsrp + " rsrq=" + mRsrq + " rssnr=" + mRssnr + " cqi=" + mCqi + " ta=" + mTimingAdvance + " level=" + mLevel;
}
Body of Second Method:
{
    return "CellSignalStrengthLte:" + " rssi=" + mRssi + " rsrp=" + mRsrp + " rsrq=" + mRsrq + " rssnr=" + mRssnr + " cqi=" + mCqi + " ta=" + mTimingAdvance + " level=" + mLevel + " parametersUseForLevel=" + mParametersUseForLevel;
}
------------------------
Find a silently evolved API code:android.app.usage.UsageEvents.getNextEvent:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the next {@link android.app.usage.UsageEvents.Event} from the collection and put the
 * resulting data into {@code eventOut}.
 *
 * @param eventOut The {@link android.app.usage.UsageEvents.Event} object that will receive the
 * next event data.
 * @return true if an event was available, false if there are no more events.
 */

Body of Frist Method:
{
    if (mIndex >= mEventCount) {
        return false;
    }
    readEventFromParcel(mParcel, eventOut);
    mIndex++;
    if (mIndex >= mEventCount) {
        mParcel.recycle();
        mParcel = null;
    }
    return true;
}
Body of Second Method:
{
    if (mIndex >= mEventCount) {
        return false;
    }
    if (mParcel != null) {
        readEventFromParcel(mParcel, eventOut);
    } else {
        eventOut.copyFrom(mEventsToWrite.get(mIndex));
    }
    mIndex++;
    if (mIndex >= mEventCount && mParcel != null) {
        mParcel.recycle();
        mParcel = null;
    }
    return true;
}
------------------------
Find a silently evolved API code:android.net.MacAddress.createRandomUnicastAddressWithGoogleBase:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Returns a generated MAC address whose 24 least significant bits constituting the
 * NIC part of the address are randomly selected and has Google OUI base.
 *
 * The locally assigned bit is always set to 1. The multicast bit is always set to 0.
 *
 * @return a random locally assigned, unicast MacAddress with Google OUI.
 *
 * @hide
 */

Body of Frist Method:
{
    return createRandomUnicastAddress(BASE_GOOGLE_MAC, new SecureRandom());
}
Body of Second Method:
{
    return MacAddressUtils.createRandomUnicastAddress(BASE_GOOGLE_MAC, new SecureRandom());
}
------------------------
Find a silently evolved API code:android.app.WindowConfiguration.hasWindowShadow:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns true if the activities associated with this window configuration display a shadow
 * around their border.
 * @hide
 */

Body of Frist Method:
{
    return tasksAreFloating();
}
Body of Second Method:
{
    return mWindowingMode != WINDOWING_MODE_MULTI_WINDOW && tasksAreFloating();
}
------------------------
Find a silently evolved API code:android.hardware.camera2.impl.CameraMetadataNative.swap:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * <p>Perform a 0-copy swap of the internal metadata with another object.</p>
 *
 * <p>Useful to convert a CameraMetadata into e.g. a CaptureRequest.</p>
 *
 * @param other Metadata to swap with
 * @throws NullPointerException if other was null
 * @hide
 */

Body of Frist Method:
{
    nativeSwap(other);
    mCameraId = other.mCameraId;
    mDisplaySize = other.mDisplaySize;
}
Body of Second Method:
{
    nativeSwap(mMetadataPtr, other.mMetadataPtr);
    mCameraId = other.mCameraId;
    mHasMandatoryConcurrentStreams = other.mHasMandatoryConcurrentStreams;
    mDisplaySize = other.mDisplaySize;
}
------------------------
Find a silently evolved API code:android.hardware.soundtrigger.SoundTriggerModule.startRecognition:COMMENT
<android.hardware.soundtrigger.SoundTriggerModule: int startRecognition(int,RecognitionConfig)>
public      native      hidden      ->public      hidden      
Method Modifier: public      native      hidden      
Method Modifier: Yes         Yes         Yes         
Method Updated:  Yes         No          Yes         
Comment:/**
 * Start listening to all key phrases in a {@link SoundTrigger.SoundModel}.
 * Recognition must be restarted after each callback (success or failure) received on
 * the {@link SoundTrigger.StatusListener}.
 * @param soundModelHandle The sound model handle to start listening to
 * @param config contains configuration information for this recognition request:
 * recognition mode, keyphrases, users, minimum confidence levels...
 * @return - {@link SoundTrigger#STATUS_OK} in case of success
 * - {@link SoundTrigger#STATUS_ERROR} in case of unspecified error
 * - {@link SoundTrigger#STATUS_PERMISSION_DENIED} if the caller does not have
 * system permission
 * - {@link SoundTrigger#STATUS_NO_INIT} if the native service cannot be reached
 * - {@link SoundTrigger#STATUS_BAD_VALUE} if the sound model handle is invalid
 * - {@link SoundTrigger#STATUS_DEAD_OBJECT} if the binder transaction to the native
 * service fails
 * - {@link SoundTrigger#STATUS_INVALID_OPERATION} if the call is out of sequence
 */

Body of Frist Method:

Body of Second Method:
{
    try {
        mService.startRecognition(soundModelHandle, ConversionUtil.api2aidlRecognitionConfig(config));
        return SoundTrigger.STATUS_OK;
    } catch (Exception e) {
        return SoundTrigger.handleException(e);
    }
}
------------------------
Find a silently evolved API code:android.service.autofill.augmented.FillRequest.getTaskId:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Gets the task of the activity associated with this request.
 */

Body of Frist Method:
{
    return mProxy.taskId;
}
Body of Second Method:
{
    return mProxy.mTaskId;
}
------------------------
Find a silently evolved API code:android.telephony.ims.ImsCallSessionListener.callSessionMultipartyStateChanged:COMMENT
Method Modifier: public      
Comment:/**
 * The multiparty state has been changed for this {@code ImsCallSession}.
 *
 * @param isMultiParty {@code true} if the session became multiparty, {@code false} otherwise.
 */

Body of Frist Method:
{
    try {
        mListener.callSessionMultipartyStateChanged(isMultiParty);
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}
Body of Second Method:
{
    try {
        mListener.callSessionMultipartyStateChanged(isMultiParty);
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.telephony.CellSignalStrengthNr.updateLevel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (mCsiRsrp == CellInfo.UNAVAILABLE) {
        mLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    } else if (mCsiRsrp >= SIGNAL_GREAT_THRESHOLD) {
        mLevel = SIGNAL_STRENGTH_GREAT;
    } else if (mCsiRsrp >= SIGNAL_GOOD_THRESHOLD) {
        mLevel = SIGNAL_STRENGTH_GOOD;
    } else if (mCsiRsrp >= SIGNAL_MODERATE_THRESHOLD) {
        mLevel = SIGNAL_STRENGTH_MODERATE;
    } else {
        mLevel = SIGNAL_STRENGTH_POOR;
    }
}
Body of Second Method:
{
    if (cc == null) {
        mParametersUseForLevel = USE_SSRSRP;
    } else {
        mParametersUseForLevel = cc.getInt(CarrierConfigManager.KEY_PARAMETERS_USE_FOR_5G_NR_SIGNAL_BAR_INT, USE_SSRSRP);
        mSsRsrpThresholds = cc.getIntArray(CarrierConfigManager.KEY_5G_NR_SSRSRP_THRESHOLDS_INT_ARRAY);
        if (VDBG) {
            Rlog.i(TAG, "Applying 5G NR SSRSRP Thresholds: " + Arrays.toString(mSsRsrpThresholds));
        }
        mSsRsrqThresholds = cc.getIntArray(CarrierConfigManager.KEY_5G_NR_SSRSRQ_THRESHOLDS_INT_ARRAY);
        if (VDBG) {
            Rlog.i(TAG, "Applying 5G NR SSRSRQ Thresholds: " + Arrays.toString(mSsRsrqThresholds));
        }
        mSsSinrThresholds = cc.getIntArray(CarrierConfigManager.KEY_5G_NR_SSSINR_THRESHOLDS_INT_ARRAY);
        if (VDBG) {
            Rlog.i(TAG, "Applying 5G NR SSSINR Thresholds: " + Arrays.toString(mSsSinrThresholds));
        }
    }
    int ssRsrpLevel = SignalStrength.INVALID;
    int ssRsrqLevel = SignalStrength.INVALID;
    int ssSinrLevel = SignalStrength.INVALID;
    if (isLevelForParameter(USE_SSRSRP)) {
        ssRsrpLevel = updateLevelWithMeasure(mSsRsrp, mSsRsrpThresholds);
        if (VDBG) {
            Rlog.i(TAG, "Updated 5G NR SSRSRP Level: " + ssRsrpLevel);
        }
    }
    if (isLevelForParameter(USE_SSRSRQ)) {
        ssRsrqLevel = updateLevelWithMeasure(mSsRsrq, mSsRsrqThresholds);
        if (VDBG) {
            Rlog.i(TAG, "Updated 5G NR SSRSRQ Level: " + ssRsrqLevel);
        }
    }
    if (isLevelForParameter(USE_SSSINR)) {
        ssSinrLevel = updateLevelWithMeasure(mSsSinr, mSsSinrThresholds);
        if (VDBG) {
            Rlog.i(TAG, "Updated 5G NR SSSINR Level: " + ssSinrLevel);
        }
    }
    // Apply the smaller value among three levels of three measures.
    mLevel = Math.min(Math.min(ssRsrpLevel, ssRsrqLevel), ssSinrLevel);
}
------------------------
Find a silently evolved API code:android.content.pm.SuspendDialogInfo.saveToXml:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (mIconResId != ID_NULL) {
        XmlUtils.writeIntAttribute(out, XML_ATTR_ICON_RES_ID, mIconResId);
    }
    if (mTitleResId != ID_NULL) {
        XmlUtils.writeIntAttribute(out, XML_ATTR_TITLE_RES_ID, mTitleResId);
    }
    if (mDialogMessageResId != ID_NULL) {
        XmlUtils.writeIntAttribute(out, XML_ATTR_DIALOG_MESSAGE_RES_ID, mDialogMessageResId);
    } else {
        XmlUtils.writeStringAttribute(out, XML_ATTR_DIALOG_MESSAGE, mDialogMessage);
    }
    if (mNeutralButtonTextResId != ID_NULL) {
        XmlUtils.writeIntAttribute(out, XML_ATTR_BUTTON_TEXT_RES_ID, mNeutralButtonTextResId);
    }
}
Body of Second Method:
{
    if (mIconResId != ID_NULL) {
        XmlUtils.writeIntAttribute(out, XML_ATTR_ICON_RES_ID, mIconResId);
    }
    if (mTitleResId != ID_NULL) {
        XmlUtils.writeIntAttribute(out, XML_ATTR_TITLE_RES_ID, mTitleResId);
    }
    if (mDialogMessageResId != ID_NULL) {
        XmlUtils.writeIntAttribute(out, XML_ATTR_DIALOG_MESSAGE_RES_ID, mDialogMessageResId);
    } else {
        XmlUtils.writeStringAttribute(out, XML_ATTR_DIALOG_MESSAGE, mDialogMessage);
    }
    if (mNeutralButtonTextResId != ID_NULL) {
        XmlUtils.writeIntAttribute(out, XML_ATTR_BUTTON_TEXT_RES_ID, mNeutralButtonTextResId);
    }
    XmlUtils.writeIntAttribute(out, XML_ATTR_BUTTON_ACTION, mNeutralButtonAction);
}
------------------------
Find a silently evolved API code:android.app.NotificationChannel.toJson:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    JSONObject record = new JSONObject();
    record.put(ATT_ID, getId());
    record.put(ATT_NAME, getName());
    record.put(ATT_DESC, getDescription());
    if (getImportance() != DEFAULT_IMPORTANCE) {
        record.put(ATT_IMPORTANCE, NotificationListenerService.Ranking.importanceToString(getImportance()));
    }
    if (canBypassDnd()) {
        record.put(ATT_PRIORITY, Notification.PRIORITY_MAX);
    }
    if (getLockscreenVisibility() != DEFAULT_VISIBILITY) {
        record.put(ATT_VISIBILITY, Notification.visibilityToString(getLockscreenVisibility()));
    }
    if (getSound() != null) {
        record.put(ATT_SOUND, getSound().toString());
    }
    if (getAudioAttributes() != null) {
        record.put(ATT_USAGE, Integer.toString(getAudioAttributes().getUsage()));
        record.put(ATT_CONTENT_TYPE, Integer.toString(getAudioAttributes().getContentType()));
        record.put(ATT_FLAGS, Integer.toString(getAudioAttributes().getFlags()));
    }
    record.put(ATT_LIGHTS, Boolean.toString(shouldShowLights()));
    record.put(ATT_LIGHT_COLOR, Integer.toString(getLightColor()));
    record.put(ATT_VIBRATION_ENABLED, Boolean.toString(shouldVibrate()));
    record.put(ATT_USER_LOCKED, Integer.toString(getUserLockedFields()));
    record.put(ATT_FG_SERVICE_SHOWN, Boolean.toString(isFgServiceShown()));
    record.put(ATT_VIBRATION, longArrayToString(getVibrationPattern()));
    record.put(ATT_SHOW_BADGE, Boolean.toString(canShowBadge()));
    record.put(ATT_DELETED, Boolean.toString(isDeleted()));
    record.put(ATT_GROUP, getGroup());
    record.put(ATT_BLOCKABLE_SYSTEM, isBlockableSystem());
    record.put(ATT_ALLOW_BUBBLE, canBubble());
    return record;
}
Body of Second Method:
{
    JSONObject record = new JSONObject();
    record.put(ATT_ID, getId());
    record.put(ATT_NAME, getName());
    record.put(ATT_DESC, getDescription());
    if (getImportance() != DEFAULT_IMPORTANCE) {
        record.put(ATT_IMPORTANCE, NotificationListenerService.Ranking.importanceToString(getImportance()));
    }
    if (canBypassDnd()) {
        record.put(ATT_PRIORITY, Notification.PRIORITY_MAX);
    }
    if (getLockscreenVisibility() != DEFAULT_VISIBILITY) {
        record.put(ATT_VISIBILITY, Notification.visibilityToString(getLockscreenVisibility()));
    }
    if (getSound() != null) {
        record.put(ATT_SOUND, getSound().toString());
    }
    if (getAudioAttributes() != null) {
        record.put(ATT_USAGE, Integer.toString(getAudioAttributes().getUsage()));
        record.put(ATT_CONTENT_TYPE, Integer.toString(getAudioAttributes().getContentType()));
        record.put(ATT_FLAGS, Integer.toString(getAudioAttributes().getFlags()));
    }
    record.put(ATT_LIGHTS, Boolean.toString(shouldShowLights()));
    record.put(ATT_LIGHT_COLOR, Integer.toString(getLightColor()));
    record.put(ATT_VIBRATION_ENABLED, Boolean.toString(shouldVibrate()));
    record.put(ATT_USER_LOCKED, Integer.toString(getUserLockedFields()));
    record.put(ATT_FG_SERVICE_SHOWN, Boolean.toString(isFgServiceShown()));
    record.put(ATT_VIBRATION, longArrayToString(getVibrationPattern()));
    record.put(ATT_SHOW_BADGE, Boolean.toString(canShowBadge()));
    record.put(ATT_DELETED, Boolean.toString(isDeleted()));
    record.put(ATT_GROUP, getGroup());
    record.put(ATT_BLOCKABLE_SYSTEM, isBlockable());
    record.put(ATT_ALLOW_BUBBLE, getAllowBubbles());
    // TODO: original importance
    return record;
}
------------------------
Find a silently evolved API code:android.media.AudioAttributes.getUsage:COMMENT
Method Modifier: public      
Comment:/**
 * Return the usage.
 * @return one of the values that can be set in {@link Builder#setUsage(int)}
 */

Body of Frist Method:
{
    return mUsage;
}
Body of Second Method:
{
    if (isSystemUsage(mUsage)) {
        return USAGE_UNKNOWN;
    }
    return mUsage;
}
------------------------
Find a silently evolved API code:android.service.voice.AlwaysOnHotwordDetector.onSoundModelsChanged:COMMENT
Method Modifier: default     hidden      
Comment:/**
 * Reloads the sound models from the service.
 *
 * @hide
 */

Body of Frist Method:
{
    synchronized (mLock) {
        if (mAvailability == STATE_INVALID || mAvailability == STATE_HARDWARE_UNAVAILABLE || mAvailability == STATE_KEYPHRASE_UNSUPPORTED) {
            Slog.w(TAG, "Received onSoundModelsChanged for an unsupported keyphrase/config");
            return;
        }
        // Stop the recognition before proceeding.
        // This is done because we want to stop the recognition on an older model if it changed
        // or was deleted.
        // The availability change callback should ensure that the client starts recognition
        // again if needed.
        stopRecognitionLocked();
        // Execute a refresh availability task - which should then notify of a change.
        new RefreshAvailabiltyTask().execute();
    }
}
Body of Second Method:
{
    synchronized (mLock) {
        if (mAvailability == STATE_INVALID || mAvailability == STATE_HARDWARE_UNAVAILABLE) {
            Slog.w(TAG, "Received onSoundModelsChanged for an unsupported keyphrase/config");
            return;
        }
        // again if needed.
        if (mAvailability == STATE_KEYPHRASE_ENROLLED) {
            stopRecognitionLocked();
        }
        // Execute a refresh availability task - which should then notify of a change.
        new RefreshAvailabiltyTask().execute();
    }
}
------------------------
Find a silently evolved API code:android.view.KeyEvent.changeTimeRepeat:COMMENT
Method Modifier: public      static      
Comment:/**
 * Create a new key event that is the same as the given one, but whose
 * event time and repeat count are replaced with the given value.
 *
 * @param event The existing event to be copied.  This is not modified.
 * @param eventTime The new event time
 * (in {@link android.os.SystemClock#uptimeMillis}) of the event.
 * @param newRepeat The new repeat count of the event.
 * @param newFlags New flags for the event, replacing the entire value
 * in the original event.
 */

Body of Frist Method:
{
    KeyEvent ret = new KeyEvent(event);
    ret.mEventTime = eventTime;
    ret.mRepeatCount = newRepeat;
    ret.mFlags = newFlags;
    return ret;
}
Body of Second Method:
{
    KeyEvent ret = new KeyEvent(event);
    // Not an exact copy so assign a new ID.
    ret.mId = nativeNextId();
    ret.mEventTime = eventTime;
    ret.mRepeatCount = newRepeat;
    ret.mFlags = newFlags;
    return ret;
}
------------------------
Find a silently evolved API code:android.hardware.soundtrigger.SoundTriggerModule.stopRecognition:COMMENT
<android.hardware.soundtrigger.SoundTriggerModule: int stopRecognition(int)>
public      native      hidden      ->public      hidden      
Method Modifier: public      native      hidden      
Method Modifier: Yes         Yes         Yes         
Method Updated:  Yes         No          Yes         
Comment:/**
 * Stop listening to all key phrases in a {@link SoundTrigger.SoundModel}
 * @param soundModelHandle The sound model handle to stop listening to
 * @return - {@link SoundTrigger#STATUS_OK} in case of success
 * - {@link SoundTrigger#STATUS_ERROR} in case of unspecified error
 * - {@link SoundTrigger#STATUS_PERMISSION_DENIED} if the caller does not have
 * system permission
 * - {@link SoundTrigger#STATUS_NO_INIT} if the native service cannot be reached
 * - {@link SoundTrigger#STATUS_BAD_VALUE} if the sound model handle is invalid
 * - {@link SoundTrigger#STATUS_DEAD_OBJECT} if the binder transaction to the native
 * service fails
 * - {@link SoundTrigger#STATUS_INVALID_OPERATION} if the call is out of sequence
 */

Body of Frist Method:

Body of Second Method:
{
    try {
        mService.stopRecognition(soundModelHandle);
        return SoundTrigger.STATUS_OK;
    } catch (Exception e) {
        return SoundTrigger.handleException(e);
    }
}
------------------------
Find a silently evolved API code:android.telephony.data.DataProfile.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Build the DataProfile object
 *
 * @return The data profile object
 */

Body of Frist Method:
{
    return new DataProfile(mProfileId, mApn, mProtocolType, mAuthType, mUserName, mPassword, mType, mMaxConnectionsTime, mMaxConnections, mWaitTime, mEnabled, mSupportedApnTypesBitmask, mRoamingProtocolType, mBearerBitmask, mMtu, mPersistent, mPreferred);
}
Body of Second Method:
{
    return new DataProfile(mProfileId, mApn, mProtocolType, mAuthType, mUserName, mPassword, mType, mMaxConnectionsTime, mMaxConnections, mWaitTime, mEnabled, mSupportedApnTypesBitmask, mRoamingProtocolType, mBearerBitmask, mMtuV4, mMtuV6, mPersistent, mPreferred);
}
------------------------
Find a silently evolved API code:android.util.ArraySet.removeAt:COMMENT
Method Modifier: public      
Comment:/**
 * Remove the key/value mapping at the given index.
 *
 * <p>For indices outside of the range <code>0...size()-1</code>, the behavior is undefined for
 * apps targeting {@link android.os.Build.VERSION_CODES#P} and earlier, and an
 * {@link ArrayIndexOutOfBoundsException} is thrown for apps targeting
 * {@link android.os.Build.VERSION_CODES#Q} and later.</p>
 *
 * @param index The desired index, must be between 0 and {@link #size()}-1.
 * @return Returns the value that was stored at this index.
 */

Body of Frist Method:
{
    if (index >= mSize && UtilConfig.sThrowExceptionForUpperArrayOutOfBounds) {
        // Check if exception should be thrown outside of the critical path.
        throw new ArrayIndexOutOfBoundsException(index);
    }
    final Object old = mArray[index];
    if (mSize <= 1) {
        // Now empty.
        if (DEBUG)
            Log.d(TAG, "remove: shrink from " + mHashes.length + " to 0");
        clear();
    } else {
        if (shouldShrink()) {
            // Shrunk enough to reduce size of arrays.
            final int n = getNewShrunkenSize();
            if (DEBUG)
                Log.d(TAG, "remove: shrink from " + mHashes.length + " to " + n);
            final int[] ohashes = mHashes;
            final Object[] oarray = mArray;
            allocArrays(n);
            mSize--;
            if (index > 0) {
                if (DEBUG)
                    Log.d(TAG, "remove: copy from 0-" + index + " to 0");
                System.arraycopy(ohashes, 0, mHashes, 0, index);
                System.arraycopy(oarray, 0, mArray, 0, index);
            }
            if (index < mSize) {
                if (DEBUG) {
                    Log.d(TAG, "remove: copy from " + (index + 1) + "-" + mSize + " to " + index);
                }
                System.arraycopy(ohashes, index + 1, mHashes, index, mSize - index);
                System.arraycopy(oarray, index + 1, mArray, index, mSize - index);
            }
        } else {
            mSize--;
            if (index < mSize) {
                if (DEBUG) {
                    Log.d(TAG, "remove: move " + (index + 1) + "-" + mSize + " to " + index);
                }
                System.arraycopy(mHashes, index + 1, mHashes, index, mSize - index);
                System.arraycopy(mArray, index + 1, mArray, index, mSize - index);
            }
            mArray[mSize] = null;
        }
    }
    return (E) old;
}
Body of Second Method:
{
    if (index >= mSize && UtilConfig.sThrowExceptionForUpperArrayOutOfBounds) {
        // Check if exception should be thrown outside of the critical path.
        throw new ArrayIndexOutOfBoundsException(index);
    }
    final int oSize = mSize;
    final Object old = mArray[index];
    if (oSize <= 1) {
        // Now empty.
        if (DEBUG)
            Log.d(TAG, "remove: shrink from " + mHashes.length + " to 0");
        clear();
    } else {
        final int nSize = oSize - 1;
        if (shouldShrink()) {
            // Shrunk enough to reduce size of arrays.
            final int n = getNewShrunkenSize();
            if (DEBUG)
                Log.d(TAG, "remove: shrink from " + mHashes.length + " to " + n);
            final int[] ohashes = mHashes;
            final Object[] oarray = mArray;
            allocArrays(n);
            if (index > 0) {
                if (DEBUG)
                    Log.d(TAG, "remove: copy from 0-" + index + " to 0");
                System.arraycopy(ohashes, 0, mHashes, 0, index);
                System.arraycopy(oarray, 0, mArray, 0, index);
            }
            if (index < nSize) {
                if (DEBUG) {
                    Log.d(TAG, "remove: copy from " + (index + 1) + "-" + nSize + " to " + index);
                }
                System.arraycopy(ohashes, index + 1, mHashes, index, nSize - index);
                System.arraycopy(oarray, index + 1, mArray, index, nSize - index);
            }
        } else {
            if (index < nSize) {
                if (DEBUG) {
                    Log.d(TAG, "remove: move " + (index + 1) + "-" + nSize + " to " + index);
                }
                System.arraycopy(mHashes, index + 1, mHashes, index, nSize - index);
                System.arraycopy(mArray, index + 1, mArray, index, nSize - index);
            }
            mArray[nSize] = null;
        }
        if (oSize != mSize) {
            throw new ConcurrentModificationException();
        }
        mSize = nSize;
    }
    return (E) old;
}
------------------------
Find a silently evolved API code:android.media.MediaMuxer.stop:COMMENT
Method Modifier: public      
Comment:/**
 * Stops the muxer.
 * <p>Once the muxer stops, it can not be restarted.</p>
 * @throws IllegalStateException if muxer is in the wrong state.
 */

Body of Frist Method:
{
    if (mState == MUXER_STATE_STARTED) {
        nativeStop(mNativeObject);
        mState = MUXER_STATE_STOPPED;
    } else {
        throw new IllegalStateException("Can't stop due to wrong state.");
    }
}
Body of Second Method:
{
    if (mState == MUXER_STATE_STARTED) {
        try {
            nativeStop(mNativeObject);
        } catch (Exception e) {
            throw e;
        } finally {
            mState = MUXER_STATE_STOPPED;
        }
    } else {
        throw new IllegalStateException("Can't stop due to wrong state(" + convertMuxerStateCodeToString(mState) + ")");
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiInfo.reset:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    setInetAddress(null);
    setBSSID(null);
    setSSID(null);
    setNetworkId(-1);
    setRssi(INVALID_RSSI);
    setLinkSpeed(LINK_SPEED_UNKNOWN);
    setTxLinkSpeedMbps(LINK_SPEED_UNKNOWN);
    setRxLinkSpeedMbps(LINK_SPEED_UNKNOWN);
    setFrequency(-1);
    setMeteredHint(false);
    setEphemeral(false);
    setOsuAp(false);
    setNetworkSuggestionOrSpecifierPackageName(null);
    setFQDN(null);
    setProviderFriendlyName(null);
    txBad = 0;
    txSuccess = 0;
    rxSuccess = 0;
    txRetries = 0;
    txBadRate = 0;
    txSuccessRate = 0;
    rxSuccessRate = 0;
    txRetriesRate = 0;
    score = 0;
}
Body of Second Method:
{
    setInetAddress(null);
    setBSSID(null);
    setSSID(null);
    setNetworkId(-1);
    setRssi(INVALID_RSSI);
    setLinkSpeed(LINK_SPEED_UNKNOWN);
    setTxLinkSpeedMbps(LINK_SPEED_UNKNOWN);
    setRxLinkSpeedMbps(LINK_SPEED_UNKNOWN);
    setMaxSupportedTxLinkSpeedMbps(LINK_SPEED_UNKNOWN);
    setMaxSupportedRxLinkSpeedMbps(LINK_SPEED_UNKNOWN);
    setFrequency(-1);
    setMeteredHint(false);
    setEphemeral(false);
    setOsuAp(false);
    setRequestingPackageName(null);
    setFQDN(null);
    setProviderFriendlyName(null);
    setPasspointUniqueId(null);
    txBad = 0;
    txSuccess = 0;
    rxSuccess = 0;
    txRetries = 0;
    mLostTxPacketsPerSecond = 0;
    mSuccessfulTxPacketsPerSecond = 0;
    mSuccessfulRxPacketsPerSecond = 0;
    mTxRetriedTxPacketsPerSecond = 0;
    score = 0;
}
------------------------
Find a silently evolved API code:android.location.GnssClock.resetBiasNanos:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Resets the clock's Bias in nanoseconds.
 * @hide
 */

Body of Frist Method:
{
    resetFlag(HAS_BIAS);
    mBiasNanos = Double.NaN;
}
Body of Second Method:
{
    resetFlag(HAS_BIAS);
}
------------------------
Find a silently evolved API code:android.media.session.MediaController.TransportControls.skipToPrevious:COMMENT
Method Modifier: public      
Comment:/**
 * Skip to the previous item.
 */

Body of Frist Method:
{
    try {
        mSessionBinder.previous(mContext.getPackageName(), mCbStub);
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling previous.", e);
    }
}
Body of Second Method:
{
    try {
        mSessionBinder.previous(mContext.getPackageName());
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling previous.", e);
    }
}
------------------------
Find a silently evolved API code:android.content.pm.PackageManager.permissionFlagToString:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * {@hide}
 */

Body of Frist Method:
{
    switch(flag) {
        case FLAG_PERMISSION_GRANTED_BY_DEFAULT:
            return "GRANTED_BY_DEFAULT";
        case FLAG_PERMISSION_POLICY_FIXED:
            return "POLICY_FIXED";
        case FLAG_PERMISSION_SYSTEM_FIXED:
            return "SYSTEM_FIXED";
        case FLAG_PERMISSION_USER_SET:
            return "USER_SET";
        case FLAG_PERMISSION_REVOKE_ON_UPGRADE:
            return "REVOKE_ON_UPGRADE";
        case FLAG_PERMISSION_USER_FIXED:
            return "USER_FIXED";
        case FLAG_PERMISSION_REVIEW_REQUIRED:
            return "REVIEW_REQUIRED";
        case FLAG_PERMISSION_REVOKE_WHEN_REQUESTED:
            return "REVOKE_WHEN_REQUESTED";
        case FLAG_PERMISSION_USER_SENSITIVE_WHEN_GRANTED:
            return "USER_SENSITIVE_WHEN_GRANTED";
        case FLAG_PERMISSION_USER_SENSITIVE_WHEN_DENIED:
            return "USER_SENSITIVE_WHEN_DENIED";
        case FLAG_PERMISSION_RESTRICTION_INSTALLER_EXEMPT:
            return "RESTRICTION_INSTALLER_EXEMPT";
        case FLAG_PERMISSION_RESTRICTION_SYSTEM_EXEMPT:
            return "RESTRICTION_SYSTEM_EXEMPT";
        case FLAG_PERMISSION_RESTRICTION_UPGRADE_EXEMPT:
            return "RESTRICTION_UPGRADE_EXEMPT";
        case FLAG_PERMISSION_APPLY_RESTRICTION:
            return "APPLY_RESTRICTION";
        case FLAG_PERMISSION_GRANTED_BY_ROLE:
            return "GRANTED_BY_ROLE";
        default:
            return Integer.toString(flag);
    }
}
Body of Second Method:
{
    switch(flag) {
        case FLAG_PERMISSION_GRANTED_BY_DEFAULT:
            return "GRANTED_BY_DEFAULT";
        case FLAG_PERMISSION_POLICY_FIXED:
            return "POLICY_FIXED";
        case FLAG_PERMISSION_SYSTEM_FIXED:
            return "SYSTEM_FIXED";
        case FLAG_PERMISSION_USER_SET:
            return "USER_SET";
        case FLAG_PERMISSION_USER_FIXED:
            return "USER_FIXED";
        case FLAG_PERMISSION_REVIEW_REQUIRED:
            return "REVIEW_REQUIRED";
        case FLAG_PERMISSION_REVOKE_WHEN_REQUESTED:
            return "REVOKE_WHEN_REQUESTED";
        case FLAG_PERMISSION_USER_SENSITIVE_WHEN_GRANTED:
            return "USER_SENSITIVE_WHEN_GRANTED";
        case FLAG_PERMISSION_USER_SENSITIVE_WHEN_DENIED:
            return "USER_SENSITIVE_WHEN_DENIED";
        case FLAG_PERMISSION_RESTRICTION_INSTALLER_EXEMPT:
            return "RESTRICTION_INSTALLER_EXEMPT";
        case FLAG_PERMISSION_RESTRICTION_SYSTEM_EXEMPT:
            return "RESTRICTION_SYSTEM_EXEMPT";
        case FLAG_PERMISSION_RESTRICTION_UPGRADE_EXEMPT:
            return "RESTRICTION_UPGRADE_EXEMPT";
        case FLAG_PERMISSION_APPLY_RESTRICTION:
            return "APPLY_RESTRICTION";
        case FLAG_PERMISSION_GRANTED_BY_ROLE:
            return "GRANTED_BY_ROLE";
        case FLAG_PERMISSION_REVOKED_COMPAT:
            return "REVOKED_COMPAT";
        case FLAG_PERMISSION_ONE_TIME:
            return "ONE_TIME";
        case FLAG_PERMISSION_AUTO_REVOKED:
            return "AUTO_REVOKED";
        default:
            return Integer.toString(flag);
    }
}
------------------------
Find a silently evolved API code:android.telephony.ims.ImsCallSessionListener.callSessionRttMessageReceived:COMMENT
Method Modifier: public      
Comment:/**
 * An RTT message has been received from the remote party.
 *
 * @param rttMessage The RTT message that has been received.
 */

Body of Frist Method:
{
    try {
        mListener.callSessionRttMessageReceived(rttMessage);
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}
Body of Second Method:
{
    try {
        mListener.callSessionRttMessageReceived(rttMessage);
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.telephony.ims.ImsCallSessionListener.callSessionResumeFailed:COMMENT
Method Modifier: public      
Comment:/**
 * The IMS call session resume has failed.
 *
 * @param reasonInfo {@link ImsReasonInfo} containing the detailed reason of the session resume
 * failure.
 */

Body of Frist Method:
{
    try {
        mListener.callSessionResumeFailed(reasonInfo);
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}
Body of Second Method:
{
    try {
        mListener.callSessionResumeFailed(reasonInfo);
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.hardware.camera2.impl.CameraMetadataNative.dumpToLog:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Dumps the native metadata contents to logcat.
 *
 * <p>Visibility for testing/debugging only. The results will not
 * include any synthesized keys, as they are invisible to the native layer.</p>
 *
 * @hide
 */

Body of Frist Method:
{
    try {
        nativeDump();
    } catch (IOException e) {
        Log.wtf(TAG, "Dump logging failed", e);
    }
}
Body of Second Method:
{
    try {
        nativeDump(mMetadataPtr);
    } catch (IOException e) {
        Log.wtf(TAG, "Dump logging failed", e);
    }
}
------------------------
Find a silently evolved API code:android.graphics.drawable.GradientDrawable.ensureValidRect:COMMENT
Method Modifier: private     
Comment:/**
 * This checks mGradientIsDirty, and if it is true, recomputes both our drawing
 * rectangle (mRect) and the gradient itself, since it depends on our
 * rectangle too.
 * @return true if the resulting rectangle is not empty, false otherwise
 */

Body of Frist Method:
{
    if (mGradientIsDirty) {
        mGradientIsDirty = false;
        Rect bounds = getBounds();
        float inset = 0;
        if (mStrokePaint != null) {
            inset = mStrokePaint.getStrokeWidth() * 0.5f;
        }
        final GradientState st = mGradientState;
        mRect.set(bounds.left + inset, bounds.top + inset, bounds.right - inset, bounds.bottom - inset);
        final int[] gradientColors = st.mGradientColors;
        if (gradientColors != null) {
            final RectF r = mRect;
            final float x0, x1, y0, y1;
            if (st.mGradient == LINEAR_GRADIENT) {
                final float level = st.mUseLevel ? getLevel() / 10000.0f : 1.0f;
                switch(st.getOrientation()) {
                    case TOP_BOTTOM:
                        x0 = r.left;
                        y0 = r.top;
                        x1 = x0;
                        y1 = level * r.bottom;
                        break;
                    case TR_BL:
                        x0 = r.right;
                        y0 = r.top;
                        x1 = level * r.left;
                        y1 = level * r.bottom;
                        break;
                    case RIGHT_LEFT:
                        x0 = r.right;
                        y0 = r.top;
                        x1 = level * r.left;
                        y1 = y0;
                        break;
                    case BR_TL:
                        x0 = r.right;
                        y0 = r.bottom;
                        x1 = level * r.left;
                        y1 = level * r.top;
                        break;
                    case BOTTOM_TOP:
                        x0 = r.left;
                        y0 = r.bottom;
                        x1 = x0;
                        y1 = level * r.top;
                        break;
                    case BL_TR:
                        x0 = r.left;
                        y0 = r.bottom;
                        x1 = level * r.right;
                        y1 = level * r.top;
                        break;
                    case LEFT_RIGHT:
                        x0 = r.left;
                        y0 = r.top;
                        x1 = level * r.right;
                        y1 = y0;
                        break;
                    default:
                        /* TL_BR */
                        x0 = r.left;
                        y0 = r.top;
                        x1 = level * r.right;
                        y1 = level * r.bottom;
                        break;
                }
                mFillPaint.setShader(new LinearGradient(x0, y0, x1, y1, gradientColors, st.mPositions, Shader.TileMode.CLAMP));
            } else if (st.mGradient == RADIAL_GRADIENT) {
                x0 = r.left + (r.right - r.left) * st.mCenterX;
                y0 = r.top + (r.bottom - r.top) * st.mCenterY;
                float radius = st.mGradientRadius;
                if (st.mGradientRadiusType == RADIUS_TYPE_FRACTION) {
                    // Fall back to parent width or height if intrinsic
                    // size is not specified.
                    final float width = st.mWidth >= 0 ? st.mWidth : r.width();
                    final float height = st.mHeight >= 0 ? st.mHeight : r.height();
                    radius *= Math.min(width, height);
                } else if (st.mGradientRadiusType == RADIUS_TYPE_FRACTION_PARENT) {
                    radius *= Math.min(r.width(), r.height());
                }
                if (st.mUseLevel) {
                    radius *= getLevel() / 10000.0f;
                }
                mGradientRadius = radius;
                if (radius <= 0) {
                    // We can't have a shader with non-positive radius, so
                    // let's have a very, very small radius.
                    radius = 0.001f;
                }
                mFillPaint.setShader(new RadialGradient(x0, y0, radius, gradientColors, null, Shader.TileMode.CLAMP));
            } else if (st.mGradient == SWEEP_GRADIENT) {
                x0 = r.left + (r.right - r.left) * st.mCenterX;
                y0 = r.top + (r.bottom - r.top) * st.mCenterY;
                int[] tempColors = gradientColors;
                float[] tempPositions = null;
                if (st.mUseLevel) {
                    tempColors = st.mTempColors;
                    final int length = gradientColors.length;
                    if (tempColors == null || tempColors.length != length + 1) {
                        tempColors = st.mTempColors = new int[length + 1];
                    }
                    System.arraycopy(gradientColors, 0, tempColors, 0, length);
                    tempColors[length] = gradientColors[length - 1];
                    tempPositions = st.mTempPositions;
                    final float fraction = 1.0f / (length - 1);
                    if (tempPositions == null || tempPositions.length != length + 1) {
                        tempPositions = st.mTempPositions = new float[length + 1];
                    }
                    final float level = getLevel() / 10000.0f;
                    for (int i = 0; i < length; i++) {
                        tempPositions[i] = i * fraction * level;
                    }
                    tempPositions[length] = 1.0f;
                }
                mFillPaint.setShader(new SweepGradient(x0, y0, tempColors, tempPositions));
            }
            // maxed out so that alpha modulation works correctly.
            if (st.mSolidColors == null) {
                mFillPaint.setColor(Color.BLACK);
            }
        }
    }
    return !mRect.isEmpty();
}
Body of Second Method:
{
    if (mGradientIsDirty) {
        mGradientIsDirty = false;
        Rect bounds = getBounds();
        float inset = 0;
        if (mStrokePaint != null) {
            inset = mStrokePaint.getStrokeWidth() * 0.5f;
        }
        final GradientState st = mGradientState;
        mRect.set(bounds.left + inset, bounds.top + inset, bounds.right - inset, bounds.bottom - inset);
        final int[] gradientColors = st.mGradientColors;
        if (gradientColors != null) {
            final RectF r = mRect;
            final float x0, x1, y0, y1;
            if (st.mGradient == LINEAR_GRADIENT) {
                final float level = st.mUseLevel ? getLevel() / 10000.0f : 1.0f;
                switch(st.mOrientation) {
                    case TOP_BOTTOM:
                        x0 = r.left;
                        y0 = r.top;
                        x1 = x0;
                        y1 = level * r.bottom;
                        break;
                    case TR_BL:
                        x0 = r.right;
                        y0 = r.top;
                        x1 = level * r.left;
                        y1 = level * r.bottom;
                        break;
                    case RIGHT_LEFT:
                        x0 = r.right;
                        y0 = r.top;
                        x1 = level * r.left;
                        y1 = y0;
                        break;
                    case BR_TL:
                        x0 = r.right;
                        y0 = r.bottom;
                        x1 = level * r.left;
                        y1 = level * r.top;
                        break;
                    case BOTTOM_TOP:
                        x0 = r.left;
                        y0 = r.bottom;
                        x1 = x0;
                        y1 = level * r.top;
                        break;
                    case BL_TR:
                        x0 = r.left;
                        y0 = r.bottom;
                        x1 = level * r.right;
                        y1 = level * r.top;
                        break;
                    case LEFT_RIGHT:
                        x0 = r.left;
                        y0 = r.top;
                        x1 = level * r.right;
                        y1 = y0;
                        break;
                    default:
                        /* TL_BR */
                        x0 = r.left;
                        y0 = r.top;
                        x1 = level * r.right;
                        y1 = level * r.bottom;
                        break;
                }
                mFillPaint.setShader(new LinearGradient(x0, y0, x1, y1, gradientColors, st.mPositions, Shader.TileMode.CLAMP));
            } else if (st.mGradient == RADIAL_GRADIENT) {
                x0 = r.left + (r.right - r.left) * st.mCenterX;
                y0 = r.top + (r.bottom - r.top) * st.mCenterY;
                float radius = st.mGradientRadius;
                if (st.mGradientRadiusType == RADIUS_TYPE_FRACTION) {
                    // Fall back to parent width or height if intrinsic
                    // size is not specified.
                    final float width = st.mWidth >= 0 ? st.mWidth : r.width();
                    final float height = st.mHeight >= 0 ? st.mHeight : r.height();
                    radius *= Math.min(width, height);
                } else if (st.mGradientRadiusType == RADIUS_TYPE_FRACTION_PARENT) {
                    radius *= Math.min(r.width(), r.height());
                }
                if (st.mUseLevel) {
                    radius *= getLevel() / 10000.0f;
                }
                mGradientRadius = radius;
                if (radius <= 0) {
                    // We can't have a shader with non-positive radius, so
                    // let's have a very, very small radius.
                    radius = 0.001f;
                }
                mFillPaint.setShader(new RadialGradient(x0, y0, radius, gradientColors, null, Shader.TileMode.CLAMP));
            } else if (st.mGradient == SWEEP_GRADIENT) {
                x0 = r.left + (r.right - r.left) * st.mCenterX;
                y0 = r.top + (r.bottom - r.top) * st.mCenterY;
                int[] tempColors = gradientColors;
                float[] tempPositions = null;
                if (st.mUseLevel) {
                    tempColors = st.mTempColors;
                    final int length = gradientColors.length;
                    if (tempColors == null || tempColors.length != length + 1) {
                        tempColors = st.mTempColors = new int[length + 1];
                    }
                    System.arraycopy(gradientColors, 0, tempColors, 0, length);
                    tempColors[length] = gradientColors[length - 1];
                    tempPositions = st.mTempPositions;
                    final float fraction = 1.0f / (length - 1);
                    if (tempPositions == null || tempPositions.length != length + 1) {
                        tempPositions = st.mTempPositions = new float[length + 1];
                    }
                    final float level = getLevel() / 10000.0f;
                    for (int i = 0; i < length; i++) {
                        tempPositions[i] = i * fraction * level;
                    }
                    tempPositions[length] = 1.0f;
                }
                mFillPaint.setShader(new SweepGradient(x0, y0, tempColors, tempPositions));
            }
            // maxed out so that alpha modulation works correctly.
            if (st.mSolidColors == null) {
                mFillPaint.setColor(Color.BLACK);
            }
        }
    }
    return !mRect.isEmpty();
}
------------------------
Find a silently evolved API code:android.content.pm.PackageManager.getPackageArchiveInfo:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve overall information about an application package defined in a
 * package archive file
 *
 * @param archiveFilePath The path to the archive file
 * @param flags Additional option flags to modify the data returned.
 * @return A PackageInfo object containing information about the package
 * archive. If the package could not be parsed, returns null.
 */

Body of Frist Method:
{
    final PackageParser parser = new PackageParser();
    parser.setCallback(new PackageParser.CallbackImpl(this));
    final File apkFile = new File(archiveFilePath);
    try {
        if ((flags & (MATCH_DIRECT_BOOT_UNAWARE | MATCH_DIRECT_BOOT_AWARE)) != 0) {
        // Caller expressed an explicit opinion about what encryption
        // aware/unaware components they want to see, so fall through and
        // give them what they want
        } else {
            // Caller expressed no opinion, so match everything
            flags |= MATCH_DIRECT_BOOT_AWARE | MATCH_DIRECT_BOOT_UNAWARE;
        }
        PackageParser.Package pkg = parser.parseMonolithicPackage(apkFile, 0);
        if ((flags & GET_SIGNATURES) != 0) {
            PackageParser.collectCertificates(pkg, false);
        }
        PackageUserState state = new PackageUserState();
        return PackageParser.generatePackageInfo(pkg, null, flags, 0, 0, null, state);
    } catch (PackageParserException e) {
        return null;
    }
}
Body of Second Method:
{
    if ((flags & (PackageManager.MATCH_DIRECT_BOOT_UNAWARE | PackageManager.MATCH_DIRECT_BOOT_AWARE)) == 0) {
        // Caller expressed no opinion about what encryption
        // aware/unaware components they want to see, so match both
        flags |= PackageManager.MATCH_DIRECT_BOOT_AWARE | PackageManager.MATCH_DIRECT_BOOT_UNAWARE;
    }
    boolean collectCertificates = (flags & PackageManager.GET_SIGNATURES) != 0 || (flags & PackageManager.GET_SIGNING_CERTIFICATES) != 0;
    ParseInput input = ParseTypeImpl.forParsingWithoutPlatformCompat().reset();
    ParseResult<ParsingPackage> result = ParsingPackageUtils.parseDefault(input, new File(archiveFilePath), 0, collectCertificates);
    if (result.isError()) {
        return null;
    }
    return PackageInfoWithoutStateUtils.generate(result.getResult(), null, flags, 0, 0, null, new PackageUserState(), UserHandle.getCallingUserId());
}
------------------------
Find a silently evolved API code:android.media.session.MediaController.dispatchMediaButtonEvent:COMMENT
Method Modifier: public      
Comment:/**
 * Send the specified media button event to the session. Only media keys can
 * be sent by this method, other keys will be ignored.
 *
 * @param keyEvent The media button event to dispatch.
 * @return true if the event was sent to the session, false otherwise.
 */

Body of Frist Method:
{
    if (keyEvent == null) {
        throw new IllegalArgumentException("KeyEvent may not be null");
    }
    if (!KeyEvent.isMediaSessionKey(keyEvent.getKeyCode())) {
        return false;
    }
    try {
        return mSessionBinder.sendMediaButton(mContext.getPackageName(), mCbStub, keyEvent);
    } catch (RemoteException e) {
    // System is dead. =(
    }
    return false;
}
Body of Second Method:
{
    if (keyEvent == null) {
        throw new IllegalArgumentException("KeyEvent may not be null");
    }
    if (!KeyEvent.isMediaSessionKey(keyEvent.getKeyCode())) {
        return false;
    }
    try {
        return mSessionBinder.sendMediaButton(mContext.getPackageName(), keyEvent);
    } catch (RemoteException e) {
    // System is dead. =(
    }
    return false;
}
------------------------
Find a silently evolved API code:android.content.pm.PermissionInfo.protectionToString:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    String protLevel = "????";
    switch(level & PROTECTION_MASK_BASE) {
        case PermissionInfo.PROTECTION_DANGEROUS:
            protLevel = "dangerous";
            break;
        case PermissionInfo.PROTECTION_NORMAL:
            protLevel = "normal";
            break;
        case PermissionInfo.PROTECTION_SIGNATURE:
            protLevel = "signature";
            break;
        case PermissionInfo.PROTECTION_SIGNATURE_OR_SYSTEM:
            protLevel = "signatureOrSystem";
            break;
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_PRIVILEGED) != 0) {
        protLevel += "|privileged";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_DEVELOPMENT) != 0) {
        protLevel += "|development";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_APPOP) != 0) {
        protLevel += "|appop";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_PRE23) != 0) {
        protLevel += "|pre23";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_INSTALLER) != 0) {
        protLevel += "|installer";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_VERIFIER) != 0) {
        protLevel += "|verifier";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_PREINSTALLED) != 0) {
        protLevel += "|preinstalled";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_SETUP) != 0) {
        protLevel += "|setup";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_INSTANT) != 0) {
        protLevel += "|instant";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_RUNTIME_ONLY) != 0) {
        protLevel += "|runtime";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_OEM) != 0) {
        protLevel += "|oem";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_VENDOR_PRIVILEGED) != 0) {
        protLevel += "|vendorPrivileged";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_SYSTEM_TEXT_CLASSIFIER) != 0) {
        protLevel += "|textClassifier";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_WELLBEING) != 0) {
        protLevel += "|wellbeing";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_DOCUMENTER) != 0) {
        protLevel += "|documenter";
    }
    if ((level & PROTECTION_FLAG_CONFIGURATOR) != 0) {
        protLevel += "|configurator";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_INCIDENT_REPORT_APPROVER) != 0) {
        protLevel += "|incidentReportApprover";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_APP_PREDICTOR) != 0) {
        protLevel += "|appPredictor";
    }
    return protLevel;
}
Body of Second Method:
{
    String protLevel = "????";
    switch(level & PROTECTION_MASK_BASE) {
        case PermissionInfo.PROTECTION_DANGEROUS:
            protLevel = "dangerous";
            break;
        case PermissionInfo.PROTECTION_NORMAL:
            protLevel = "normal";
            break;
        case PermissionInfo.PROTECTION_SIGNATURE:
            protLevel = "signature";
            break;
        case PermissionInfo.PROTECTION_SIGNATURE_OR_SYSTEM:
            protLevel = "signatureOrSystem";
            break;
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_PRIVILEGED) != 0) {
        protLevel += "|privileged";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_DEVELOPMENT) != 0) {
        protLevel += "|development";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_APPOP) != 0) {
        protLevel += "|appop";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_PRE23) != 0) {
        protLevel += "|pre23";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_INSTALLER) != 0) {
        protLevel += "|installer";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_VERIFIER) != 0) {
        protLevel += "|verifier";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_PREINSTALLED) != 0) {
        protLevel += "|preinstalled";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_SETUP) != 0) {
        protLevel += "|setup";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_INSTANT) != 0) {
        protLevel += "|instant";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_RUNTIME_ONLY) != 0) {
        protLevel += "|runtime";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_OEM) != 0) {
        protLevel += "|oem";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_VENDOR_PRIVILEGED) != 0) {
        protLevel += "|vendorPrivileged";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_SYSTEM_TEXT_CLASSIFIER) != 0) {
        protLevel += "|textClassifier";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_WELLBEING) != 0) {
        protLevel += "|wellbeing";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_DOCUMENTER) != 0) {
        protLevel += "|documenter";
    }
    if ((level & PROTECTION_FLAG_CONFIGURATOR) != 0) {
        protLevel += "|configurator";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_INCIDENT_REPORT_APPROVER) != 0) {
        protLevel += "|incidentReportApprover";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_APP_PREDICTOR) != 0) {
        protLevel += "|appPredictor";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_RETAIL_DEMO) != 0) {
        protLevel += "|retailDemo";
    }
    return protLevel;
}
------------------------
Find a silently evolved API code:android.graphics.drawable.Icon.sameAs:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Compares if this icon is constructed from the same resources as another icon.
 * Note that this is an inexpensive operation and doesn't do deep Bitmap equality comparisons.
 *
 * @param otherIcon the other icon
 * @return whether this icon is the same as the another one
 * @hide
 */

Body of Frist Method:
{
    if (otherIcon == this) {
        return true;
    }
    if (mType != otherIcon.getType()) {
        return false;
    }
    switch(mType) {
        case TYPE_BITMAP:
        case TYPE_ADAPTIVE_BITMAP:
            return getBitmap() == otherIcon.getBitmap();
        case TYPE_DATA:
            return getDataLength() == otherIcon.getDataLength() && getDataOffset() == otherIcon.getDataOffset() && Arrays.equals(getDataBytes(), otherIcon.getDataBytes());
        case TYPE_RESOURCE:
            return getResId() == otherIcon.getResId() && Objects.equals(getResPackage(), otherIcon.getResPackage());
        case TYPE_URI:
            return Objects.equals(getUriString(), otherIcon.getUriString());
    }
    return false;
}
Body of Second Method:
{
    if (otherIcon == this) {
        return true;
    }
    if (mType != otherIcon.getType()) {
        return false;
    }
    switch(mType) {
        case TYPE_BITMAP:
        case TYPE_ADAPTIVE_BITMAP:
            return getBitmap() == otherIcon.getBitmap();
        case TYPE_DATA:
            return getDataLength() == otherIcon.getDataLength() && getDataOffset() == otherIcon.getDataOffset() && Arrays.equals(getDataBytes(), otherIcon.getDataBytes());
        case TYPE_RESOURCE:
            return getResId() == otherIcon.getResId() && Objects.equals(getResPackage(), otherIcon.getResPackage());
        case TYPE_URI:
        case TYPE_URI_ADAPTIVE_BITMAP:
            return Objects.equals(getUriString(), otherIcon.getUriString());
    }
    return false;
}
------------------------
Find a silently evolved API code:android.net.MacAddress.isMacAddress:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Returns true if the given byte array is an valid MAC address.
 * A valid byte array representation for a MacAddress is a non-null array of length 6.
 *
 * @param addr a byte array.
 * @return true if the given byte array is not null and has the length of a MAC address.
 *
 * @hide
 */

Body of Frist Method:
{
    return addr != null && addr.length == ETHER_ADDR_LEN;
}
Body of Second Method:
{
    return MacAddressUtils.isMacAddress(addr);
}
------------------------
Find a silently evolved API code:android.telephony.ims.ImsCallSession.IImsCallSessionListenerProxy.callSessionHandoverFailed:COMMENT
Method Modifier: public      
Comment:/**
 * Notifies of handover failure info for this call
 */

Body of Frist Method:
{
    if (mListener != null) {
        mListener.callSessionHandoverFailed(ImsCallSession.this, srcAccessTech, targetAccessTech, reasonInfo);
    }
}
Body of Second Method:
{
    if (mListener != null) {
        mListener.callSessionHandoverFailed(ImsCallSession.this, srcNetworkType, targetNetworkType, reasonInfo);
    }
}
------------------------
Find a silently evolved API code:android.view.WindowInsets.assignCompatInsets:COMMENT
<android.view.WindowInsets: void assignCompatInsets(Insets[],Rect)>
default     static      hidden      ->public      static      hidden      
Method Modifier: public      default     static      hidden      
Method Modifier: No          Yes         Yes         Yes         
Method Updated:  Yes         No          Yes         Yes         
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    typeInsetMap[indexOf(TOP_BAR)] = Insets.of(0, insets.top, 0, 0);
    typeInsetMap[indexOf(SIDE_BARS)] = Insets.of(insets.left, 0, insets.right, insets.bottom);
}
Body of Second Method:
{
    typeInsetsMap[indexOf(STATUS_BARS)] = Insets.of(0, insets.top, 0, 0);
    typeInsetsMap[indexOf(NAVIGATION_BARS)] = Insets.of(insets.left, 0, insets.right, insets.bottom);
}
------------------------
Find a silently evolved API code:android.media.tv.TvTrackInfo.Builder.setExtra:COMMENT
<android.media.tv.TvTrackInfo.Builder: Builder setExtra(Bundle)>
public      final       ->public      
Method Modifier: public      final       
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * Sets the extra information about the current track.
 *
 * @param extra The extra information.
 */

Body of Frist Method:
{
    mExtra = new Bundle(extra);
    return this;
}
Body of Second Method:
{
    Preconditions.checkNotNull(extra);
    mExtra = new Bundle(extra);
    return this;
}
------------------------
Find a silently evolved API code:android.app.TaskInfo.writeToParcel:COMMENT
Method Modifier: default     
Comment:/**
 * Writes the TaskInfo to a parcel.
 */

Body of Frist Method:
{
    dest.writeInt(userId);
    dest.writeInt(stackId);
    dest.writeInt(taskId);
    dest.writeInt(displayId);
    dest.writeBoolean(isRunning);
    if (baseIntent != null) {
        dest.writeInt(1);
        baseIntent.writeToParcel(dest, 0);
    } else {
        dest.writeInt(0);
    }
    ComponentName.writeToParcel(baseActivity, dest);
    ComponentName.writeToParcel(topActivity, dest);
    ComponentName.writeToParcel(origActivity, dest);
    ComponentName.writeToParcel(realActivity, dest);
    dest.writeInt(numActivities);
    dest.writeLong(lastActiveTime);
    if (taskDescription != null) {
        dest.writeInt(1);
        taskDescription.writeToParcel(dest, flags);
    } else {
        dest.writeInt(0);
    }
    dest.writeBoolean(supportsSplitScreenMultiWindow);
    dest.writeInt(resizeMode);
    configuration.writeToParcel(dest, flags);
}
Body of Second Method:
{
    dest.writeInt(userId);
    dest.writeInt(stackId);
    dest.writeInt(taskId);
    dest.writeInt(displayId);
    dest.writeBoolean(isRunning);
    if (baseIntent != null) {
        dest.writeInt(1);
        baseIntent.writeToParcel(dest, 0);
    } else {
        dest.writeInt(0);
    }
    ComponentName.writeToParcel(baseActivity, dest);
    ComponentName.writeToParcel(topActivity, dest);
    ComponentName.writeToParcel(origActivity, dest);
    ComponentName.writeToParcel(realActivity, dest);
    dest.writeInt(numActivities);
    dest.writeLong(lastActiveTime);
    if (taskDescription != null) {
        dest.writeInt(1);
        taskDescription.writeToParcel(dest, flags);
    } else {
        dest.writeInt(0);
    }
    dest.writeBoolean(supportsSplitScreenMultiWindow);
    dest.writeInt(resizeMode);
    configuration.writeToParcel(dest, flags);
    token.writeToParcel(dest, flags);
    dest.writeInt(topActivityType);
    if (pictureInPictureParams == null) {
        dest.writeInt(0);
    } else {
        dest.writeInt(1);
        pictureInPictureParams.writeToParcel(dest, flags);
    }
    if (topActivityInfo == null) {
        dest.writeInt(0);
    } else {
        dest.writeInt(1);
        topActivityInfo.writeToParcel(dest, flags);
    }
    dest.writeBoolean(isResizeable);
}
------------------------
Find a silently evolved API code:android.location.GnssClock.set:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets all contents to the values stored in the provided object.
 * @hide
 */

Body of Frist Method:
{
    mFlags = clock.mFlags;
    mLeapSecond = clock.mLeapSecond;
    mTimeNanos = clock.mTimeNanos;
    mTimeUncertaintyNanos = clock.mTimeUncertaintyNanos;
    mFullBiasNanos = clock.mFullBiasNanos;
    mBiasNanos = clock.mBiasNanos;
    mBiasUncertaintyNanos = clock.mBiasUncertaintyNanos;
    mDriftNanosPerSecond = clock.mDriftNanosPerSecond;
    mDriftUncertaintyNanosPerSecond = clock.mDriftUncertaintyNanosPerSecond;
    mHardwareClockDiscontinuityCount = clock.mHardwareClockDiscontinuityCount;
    mElapsedRealtimeNanos = clock.mElapsedRealtimeNanos;
    mElapsedRealtimeUncertaintyNanos = clock.mElapsedRealtimeUncertaintyNanos;
}
Body of Second Method:
{
    mFlags = clock.mFlags;
    mLeapSecond = clock.mLeapSecond;
    mTimeNanos = clock.mTimeNanos;
    mTimeUncertaintyNanos = clock.mTimeUncertaintyNanos;
    mFullBiasNanos = clock.mFullBiasNanos;
    mBiasNanos = clock.mBiasNanos;
    mBiasUncertaintyNanos = clock.mBiasUncertaintyNanos;
    mDriftNanosPerSecond = clock.mDriftNanosPerSecond;
    mDriftUncertaintyNanosPerSecond = clock.mDriftUncertaintyNanosPerSecond;
    mHardwareClockDiscontinuityCount = clock.mHardwareClockDiscontinuityCount;
    mElapsedRealtimeNanos = clock.mElapsedRealtimeNanos;
    mElapsedRealtimeUncertaintyNanos = clock.mElapsedRealtimeUncertaintyNanos;
    mReferenceConstellationTypeForIsb = clock.mReferenceConstellationTypeForIsb;
    mReferenceCarrierFrequencyHzForIsb = clock.mReferenceCarrierFrequencyHzForIsb;
    mReferenceCodeTypeForIsb = clock.mReferenceCodeTypeForIsb;
}
------------------------
Find a silently evolved API code:android.view.accessibility.AccessibilityRecord.init:COMMENT
Method Modifier: default     
Comment:/**
 * Initialize this record from another one.
 *
 * @param record The to initialize from.
 */

Body of Frist Method:
{
    mSealed = record.mSealed;
    mBooleanProperties = record.mBooleanProperties;
    mCurrentItemIndex = record.mCurrentItemIndex;
    mItemCount = record.mItemCount;
    mFromIndex = record.mFromIndex;
    mToIndex = record.mToIndex;
    mScrollX = record.mScrollX;
    mScrollY = record.mScrollY;
    mMaxScrollX = record.mMaxScrollX;
    mMaxScrollY = record.mMaxScrollY;
    mAddedCount = record.mAddedCount;
    mRemovedCount = record.mRemovedCount;
    mClassName = record.mClassName;
    mContentDescription = record.mContentDescription;
    mBeforeText = record.mBeforeText;
    mParcelableData = record.mParcelableData;
    mText.addAll(record.mText);
    mSourceWindowId = record.mSourceWindowId;
    mSourceNodeId = record.mSourceNodeId;
    mConnectionId = record.mConnectionId;
}
Body of Second Method:
{
    mSealed = record.mSealed;
    mBooleanProperties = record.mBooleanProperties;
    mCurrentItemIndex = record.mCurrentItemIndex;
    mItemCount = record.mItemCount;
    mFromIndex = record.mFromIndex;
    mToIndex = record.mToIndex;
    mScrollX = record.mScrollX;
    mScrollY = record.mScrollY;
    mMaxScrollX = record.mMaxScrollX;
    mMaxScrollY = record.mMaxScrollY;
    mScrollDeltaX = record.mScrollDeltaX;
    mScrollDeltaY = record.mScrollDeltaY;
    mAddedCount = record.mAddedCount;
    mRemovedCount = record.mRemovedCount;
    mClassName = record.mClassName;
    mContentDescription = record.mContentDescription;
    mBeforeText = record.mBeforeText;
    mParcelableData = record.mParcelableData;
    mText.addAll(record.mText);
    mSourceWindowId = record.mSourceWindowId;
    mSourceNodeId = record.mSourceNodeId;
    mConnectionId = record.mConnectionId;
}
------------------------
Find a silently evolved API code:android.content.rollback.RollbackManager.getRecentlyCommittedRollbacks:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Gets the list of all recently committed rollbacks.
 * This is for the purposes of preventing re-install of a bad version of a
 * package and monitoring the status of a staged rollback.
 * <p>
 * Returns an empty list if there are no recently committed rollbacks.
 * <p>
 * To avoid having to keep around complete rollback history forever on a
 * device, the returned list of rollbacks is only guaranteed to include
 * rollbacks that are still relevant. A rollback is no longer considered
 * relevant if the package is subsequently uninstalled or upgraded
 * (without the possibility of rollback) to a higher version code than was
 * rolled back from.
 *
 * @return the recently committed rollbacks
 * @throws SecurityException if the caller does not have appropriate permissions.
 */

Body of Frist Method:
{
    try {
        return mBinder.getRecentlyExecutedRollbacks().getList();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    try {
        return mBinder.getRecentlyCommittedRollbacks().getList();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.util.ArraySet.clear:COMMENT
Method Modifier: public      
Comment:/**
 * Make the array map empty.  All storage is released.
 */

Body of Frist Method:
{
    if (mSize != 0) {
        freeArrays(mHashes, mArray, mSize);
        mHashes = EmptyArray.INT;
        mArray = EmptyArray.OBJECT;
        mSize = 0;
    }
}
Body of Second Method:
{
    if (mSize != 0) {
        final int[] ohashes = mHashes;
        final Object[] oarray = mArray;
        final int osize = mSize;
        mHashes = EmptyArray.INT;
        mArray = EmptyArray.OBJECT;
        mSize = 0;
        freeArrays(ohashes, oarray, osize);
    }
    if (mSize != 0) {
        throw new ConcurrentModificationException();
    }
}
------------------------
Find a silently evolved API code:android.ddm.DdmHandleAppName.setAppName:COMMENT
Method Modifier: public      static      
Comment:/**
 * Set the application name.  Called when we get named, which may be
 * before or after DDMS connects.  For the latter we need to send up
 * an APNM message.
 */

Body of Frist Method:
{
    if (name == null || name.length() == 0)
        return;
    mAppName = name;
    // if DDMS is already connected, send the app name up
    sendAPNM(name, userId);
}
Body of Second Method:
{
    if (appName == null || appName.isEmpty() || pkgName == null || pkgName.isEmpty())
        return;
    sNames = new Names(appName, pkgName);
    // if DDMS is already connected, send the app name up
    sendAPNM(appName, pkgName, userId);
}
------------------------
Find a silently evolved API code:android.view.animation.AnticipateOvershootInterpolator.createNativeInterpolator:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return NativeInterpolatorFactoryHelper.createAnticipateOvershootInterpolator(mTension);
}
Body of Second Method:
{
    return NativeInterpolatorFactory.createAnticipateOvershootInterpolator(mTension);
}
------------------------
Find a silently evolved API code:android.os.Handler.getTraceName:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * {@hide}
 */

Body of Frist Method:
{
    final StringBuilder sb = new StringBuilder();
    sb.append(getClass().getName()).append(": ");
    if (message.callback != null) {
        sb.append(message.callback.getClass().getName());
    } else {
        sb.append("#").append(message.what);
    }
    return sb.toString();
}
Body of Second Method:
{
    if (message.callback instanceof TraceNameSupplier) {
        return ((TraceNameSupplier) message.callback).getTraceName();
    }
    final StringBuilder sb = new StringBuilder();
    sb.append(getClass().getName()).append(": ");
    if (message.callback != null) {
        sb.append(message.callback.getClass().getName());
    } else {
        sb.append("#").append(message.what);
    }
    return sb.toString();
}
------------------------
Find a silently evolved API code:android.location.LocationRequest.createFromDeprecatedCriteria:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (minTime < 0)
        minTime = 0;
    if (minDistance < 0)
        minDistance = 0;
    int quality;
    switch(criteria.getAccuracy()) {
        case Criteria.ACCURACY_COARSE:
            quality = ACCURACY_BLOCK;
            break;
        case Criteria.ACCURACY_FINE:
            quality = ACCURACY_FINE;
            break;
        default:
            {
                if (criteria.getPowerRequirement() == Criteria.POWER_HIGH) {
                    quality = POWER_HIGH;
                } else {
                    quality = POWER_LOW;
                }
            }
    }
    LocationRequest request = new LocationRequest().setQuality(quality).setInterval(minTime).setFastestInterval(minTime).setSmallestDisplacement(minDistance);
    if (singleShot)
        request.setNumUpdates(1);
    return request;
}
Body of Second Method:
{
    Preconditions.checkArgument(criteria != null, "invalid null criteria");
    if (minTime < 0)
        minTime = 0;
    if (minDistance < 0)
        minDistance = 0;
    int quality;
    switch(criteria.getAccuracy()) {
        case Criteria.ACCURACY_COARSE:
            quality = ACCURACY_BLOCK;
            break;
        case Criteria.ACCURACY_FINE:
            quality = ACCURACY_FINE;
            break;
        default:
            {
                if (criteria.getPowerRequirement() == Criteria.POWER_HIGH) {
                    quality = POWER_HIGH;
                } else {
                    quality = POWER_LOW;
                }
            }
    }
    LocationRequest request = new LocationRequest().setQuality(quality).setInterval(minTime).setFastestInterval(minTime).setSmallestDisplacement(minDistance);
    if (singleShot)
        request.setNumUpdates(1);
    return request;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothDevice.createBondOutOfBand:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Start the bonding (pairing) process with the remote device using the
 * Out Of Band mechanism.
 *
 * <p>This is an asynchronous call, it will return immediately. Register
 * for {@link #ACTION_BOND_STATE_CHANGED} intents to be notified when
 * the bonding process completes, and its result.
 *
 * <p>Android system services will handle the necessary user interactions
 * to confirm and complete the bonding process.
 *
 * <p>Requires {@link android.Manifest.permission#BLUETOOTH_ADMIN}.
 *
 * @param transport - Transport to use
 * @param oobData - Out Of Band data
 * @return false on immediate error, true if bonding will begin
 * @hide
 */

Body of Frist Method:
{
    final IBluetooth service = sService;
    if (service == null) {
        Log.w(TAG, "BT not enabled, createBondOutOfBand failed");
        return false;
    }
    try {
        return service.createBondOutOfBand(this, transport, oobData);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
Body of Second Method:
{
    final IBluetooth service = sService;
    if (service == null) {
        Log.w(TAG, "BT not enabled, createBondOutOfBand failed");
        return false;
    }
    try {
        return service.createBond(this, transport, oobData);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
------------------------
Find a silently evolved API code:android.telephony.CarrierConfigManager.overrideConfig:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Overrides the carrier config of the provided subscription ID with the provided values.
 *
 * Any further queries to carrier config from any process will return the overridden values
 * after this method returns. The overrides are effective for the lifetime of the phone process
 * until the user passes in {@code null} for {@code overrideValues}. This removes all previous
 * overrides and sets the carrier config back to production values.
 *
 * May throw an {@link IllegalArgumentException} if {@code overrideValues} contains invalid
 * values for the specified config keys.
 *
 * NOTE: This API is meant for testing purposes only.
 *
 * @param subscriptionId The subscription ID for which the override should be done.
 * @param overrideValues Key-value pairs of the values that are to be overridden. If set to
 * {@code null}, this will remove all previous overrides and set the
 * carrier configuration back to production values.
 * @hide
 */

Body of Frist Method:
{
    try {
        ICarrierConfigLoader loader = getICarrierConfigLoader();
        if (loader == null) {
            Rlog.w(TAG, "Error setting config for subId " + subscriptionId + " ICarrierConfigLoader is null");
            return;
        }
        loader.overrideConfig(subscriptionId, overrideValues);
    } catch (RemoteException ex) {
        Rlog.e(TAG, "Error setting config for subId " + subscriptionId + ": " + ex.toString());
    }
}
Body of Second Method:
{
    overrideConfig(subscriptionId, overrideValues, false);
}
------------------------
Find a silently evolved API code:android.hardware.camera2.impl.CameraMetadataNative.getAllVendorKeys:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Return a list containing keys of the given key class for all defined vendor tags.
 *
 * @hide
 */

Body of Frist Method:
{
    if (keyClass == null) {
        throw new NullPointerException();
    }
    return (ArrayList<K>) nativeGetAllVendorKeys(keyClass);
}
Body of Second Method:
{
    if (keyClass == null) {
        throw new NullPointerException();
    }
    return (ArrayList<K>) nativeGetAllVendorKeys(mMetadataPtr, keyClass);
}
------------------------
Find a silently evolved API code:android.companion.BluetoothLeDeviceFilter.getDeviceDisplayName:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (mRenameBytesFrom < 0 && mRenameNameFrom < 0) {
        return getDeviceDisplayNameInternal(sr.getDevice());
    }
    final StringBuilder sb = new StringBuilder(TextUtils.emptyIfNull(mRenamePrefix));
    if (mRenameBytesFrom >= 0) {
        final byte[] bytes = sr.getScanRecord().getBytes();
        int startInclusive = mRenameBytesFrom;
        int endInclusive = mRenameBytesFrom + mRenameBytesLength - 1;
        int initial = mRenameBytesReverseOrder ? endInclusive : startInclusive;
        int step = mRenameBytesReverseOrder ? -1 : 1;
        for (int i = initial; startInclusive <= i && i <= endInclusive; i += step) {
            sb.append(Byte.toHexString(bytes[i], true));
        }
    } else {
        sb.append(getDeviceDisplayNameInternal(sr.getDevice()).substring(mRenameNameFrom, mRenameNameFrom + mRenameNameLength));
    }
    return sb.append(TextUtils.emptyIfNull(mRenameSuffix)).toString();
}
Body of Second Method:
{
    if (mRenameBytesFrom < 0 && mRenameNameFrom < 0) {
        return getDeviceDisplayNameInternal(sr.getDevice());
    }
    final StringBuilder sb = new StringBuilder(TextUtils.emptyIfNull(mRenamePrefix));
    if (mRenameBytesFrom >= 0) {
        final byte[] bytes = sr.getScanRecord().getBytes();
        int startInclusive = mRenameBytesFrom;
        int endInclusive = mRenameBytesFrom + mRenameBytesLength - 1;
        int initial = mRenameBytesReverseOrder ? endInclusive : startInclusive;
        int step = mRenameBytesReverseOrder ? -1 : 1;
        for (int i = initial; startInclusive <= i && i <= endInclusive; i += step) {
            sb.append(HexEncoding.encodeToString(bytes[i], true));
        }
    } else {
        sb.append(getDeviceDisplayNameInternal(sr.getDevice()).substring(mRenameNameFrom, mRenameNameFrom + mRenameNameLength));
    }
    return sb.append(TextUtils.emptyIfNull(mRenameSuffix)).toString();
}
------------------------
Find a silently evolved API code:android.telephony.CarrierConfigManager.getICarrierConfigLoader:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return ICarrierConfigLoader.Stub.asInterface(ServiceManager.getService(Context.CARRIER_CONFIG_SERVICE));
}
Body of Second Method:
{
    return ICarrierConfigLoader.Stub.asInterface(TelephonyFrameworkInitializer.getTelephonyServiceManager().getCarrierConfigServiceRegisterer().get());
}
------------------------
Find a silently evolved API code:android.hardware.camera2.impl.CameraMetadataNative.readValues:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * <p>Returns a byte[] of data corresponding to this tag. Use a wrapped bytebuffer to unserialize
 * the data properly.</p>
 *
 * <p>An empty array can be returned to denote an existing entry with 0 elements.</p>
 *
 * @param tag An integer tag, see e.g. {@link #getTag}
 *
 * @return {@code null} if there were 0 entries for this tag, a byte[] otherwise.
 * @hide
 */

Body of Frist Method:
{
    // TODO: Optimization. Native code returns a ByteBuffer instead.
    return nativeReadValues(tag);
}
Body of Second Method:
{
    // TODO: Optimization. Native code returns a ByteBuffer instead.
    return nativeReadValues(tag, mMetadataPtr);
}
------------------------
Find a silently evolved API code:android.content.ContentProviderClient.refresh:COMMENT
Method Modifier: public      
Comment:/**
 * See {@link ContentProvider#refresh}
 */

Body of Frist Method:
{
    Preconditions.checkNotNull(url, "url");
    beforeRemote();
    try {
        ICancellationSignal remoteCancellationSignal = null;
        if (cancellationSignal != null) {
            cancellationSignal.throwIfCanceled();
            remoteCancellationSignal = mContentProvider.createCancellationSignal();
            cancellationSignal.setRemote(remoteCancellationSignal);
        }
        return mContentProvider.refresh(mPackageName, url, args, remoteCancellationSignal);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}
Body of Second Method:
{
    Objects.requireNonNull(url, "url");
    beforeRemote();
    try {
        ICancellationSignal remoteCancellationSignal = null;
        if (cancellationSignal != null) {
            cancellationSignal.throwIfCanceled();
            remoteCancellationSignal = mContentProvider.createCancellationSignal();
            cancellationSignal.setRemote(remoteCancellationSignal);
        }
        return mContentProvider.refresh(mPackageName, mAttributionTag, url, extras, remoteCancellationSignal);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}
------------------------
Find a silently evolved API code:android.app.servertransaction.TransactionExecutor.performLifecycleSequence:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Transition the client through previously initialized state sequence.
 */

Body of Frist Method:
{
    final int size = path.size();
    for (int i = 0, state; i < size; i++) {
        state = path.get(i);
        if (DEBUG_RESOLVER) {
            Slog.d(TAG, tId(transaction) + "Transitioning activity: " + getShortActivityName(r.token, mTransactionHandler) + " to state: " + getStateName(state));
        }
        switch(state) {
            case ON_CREATE:
                mTransactionHandler.handleLaunchActivity(r, mPendingActions, null);
                break;
            case ON_START:
                mTransactionHandler.handleStartActivity(r, mPendingActions);
                break;
            case ON_RESUME:
                mTransactionHandler.handleResumeActivity(r.token, false, /* finalStateRequest */
                r.isForward, "LIFECYCLER_RESUME_ACTIVITY");
                break;
            case ON_PAUSE:
                mTransactionHandler.handlePauseActivity(r.token, false, /* finished */
                false, /* userLeaving */
                0, /* configChanges */
                mPendingActions, "LIFECYCLER_PAUSE_ACTIVITY");
                break;
            case ON_STOP:
                mTransactionHandler.handleStopActivity(r.token, false, /* show */
                0, /* configChanges */
                mPendingActions, false, /* finalStateRequest */
                "LIFECYCLER_STOP_ACTIVITY");
                break;
            case ON_DESTROY:
                mTransactionHandler.handleDestroyActivity(r.token, false, /* finishing */
                0, /* configChanges */
                false, /* getNonConfigInstance */
                "performLifecycleSequence. cycling to:" + path.get(size - 1));
                break;
            case ON_RESTART:
                mTransactionHandler.performRestartActivity(r.token, false);
                break;
            default:
                throw new IllegalArgumentException("Unexpected lifecycle state: " + state);
        }
    }
}
Body of Second Method:
{
    final int size = path.size();
    for (int i = 0, state; i < size; i++) {
        state = path.get(i);
        if (DEBUG_RESOLVER) {
            Slog.d(TAG, tId(transaction) + "Transitioning activity: " + getShortActivityName(r.token, mTransactionHandler) + " to state: " + getStateName(state));
        }
        switch(state) {
            case ON_CREATE:
                mTransactionHandler.handleLaunchActivity(r, mPendingActions, null);
                break;
            case ON_START:
                mTransactionHandler.handleStartActivity(r.token, mPendingActions);
                break;
            case ON_RESUME:
                mTransactionHandler.handleResumeActivity(r.token, false, /* finalStateRequest */
                r.isForward, "LIFECYCLER_RESUME_ACTIVITY");
                break;
            case ON_PAUSE:
                mTransactionHandler.handlePauseActivity(r.token, false, /* finished */
                false, /* userLeaving */
                0, /* configChanges */
                mPendingActions, "LIFECYCLER_PAUSE_ACTIVITY");
                break;
            case ON_STOP:
                mTransactionHandler.handleStopActivity(r.token, 0, /* configChanges */
                mPendingActions, false, /* finalStateRequest */
                "LIFECYCLER_STOP_ACTIVITY");
                break;
            case ON_DESTROY:
                mTransactionHandler.handleDestroyActivity(r.token, false, /* finishing */
                0, /* configChanges */
                false, /* getNonConfigInstance */
                "performLifecycleSequence. cycling to:" + path.get(size - 1));
                break;
            case ON_RESTART:
                mTransactionHandler.performRestartActivity(r.token, false);
                break;
            default:
                throw new IllegalArgumentException("Unexpected lifecycle state: " + state);
        }
    }
}
------------------------
Find a silently evolved API code:android.net.wifi.aware.WifiAwareNetworkSpecifier.equals:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof WifiAwareNetworkSpecifier)) {
        return false;
    }
    WifiAwareNetworkSpecifier lhs = (WifiAwareNetworkSpecifier) obj;
    return type == lhs.type && role == lhs.role && clientId == lhs.clientId && sessionId == lhs.sessionId && peerId == lhs.peerId && Arrays.equals(peerMac, lhs.peerMac) && Arrays.equals(pmk, lhs.pmk) && Objects.equals(passphrase, lhs.passphrase) && port == lhs.port && transportProtocol == lhs.transportProtocol && requestorUid == lhs.requestorUid;
}
Body of Second Method:
{
    if (this == obj) {
        return true;
    }
    if (!(obj instanceof WifiAwareNetworkSpecifier)) {
        return false;
    }
    WifiAwareNetworkSpecifier lhs = (WifiAwareNetworkSpecifier) obj;
    return type == lhs.type && role == lhs.role && clientId == lhs.clientId && sessionId == lhs.sessionId && peerId == lhs.peerId && Arrays.equals(peerMac, lhs.peerMac) && Arrays.equals(pmk, lhs.pmk) && Objects.equals(passphrase, lhs.passphrase) && port == lhs.port && transportProtocol == lhs.transportProtocol;
}
------------------------
Find a silently evolved API code:android.companion.WifiDeviceFilter.matches:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return BluetoothDeviceFilterUtils.matchesName(getNamePattern(), device);
}
Body of Second Method:
{
    return BluetoothDeviceFilterUtils.matchesName(getNamePattern(), device) && (mBssid == null || MacAddress.fromString(device.BSSID).matches(mBssid, mBssidMask));
}
------------------------
Find a silently evolved API code:android.view.KeyEvent.changeFlags:COMMENT
Method Modifier: public      static      
Comment:/**
 * Create a new key event that is the same as the given one, but whose
 * flags are replaced with the given value.
 *
 * @param event The existing event to be copied.  This is not modified.
 * @param flags The new flags constant.
 */

Body of Frist Method:
{
    event = new KeyEvent(event);
    event.mFlags = flags;
    return event;
}
Body of Second Method:
{
    event = new KeyEvent(event);
    // Not an exact copy so assign a new ID.
    event.mId = nativeNextId();
    event.mFlags = flags;
    return event;
}
------------------------
Find a silently evolved API code:android.net.wifi.WifiInfo.writeToParcel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Implement the Parcelable interface {@hide}
 */

Body of Frist Method:
{
    dest.writeInt(mNetworkId);
    dest.writeInt(mRssi);
    dest.writeInt(mLinkSpeed);
    dest.writeInt(mTxLinkSpeed);
    dest.writeInt(mRxLinkSpeed);
    dest.writeInt(mFrequency);
    if (mIpAddress != null) {
        dest.writeByte((byte) 1);
        dest.writeByteArray(mIpAddress.getAddress());
    } else {
        dest.writeByte((byte) 0);
    }
    if (mWifiSsid != null) {
        dest.writeInt(1);
        mWifiSsid.writeToParcel(dest, flags);
    } else {
        dest.writeInt(0);
    }
    dest.writeString(mBSSID);
    dest.writeString(mMacAddress);
    dest.writeInt(mMeteredHint ? 1 : 0);
    dest.writeInt(mEphemeral ? 1 : 0);
    dest.writeInt(mTrusted ? 1 : 0);
    dest.writeInt(score);
    dest.writeLong(txSuccess);
    dest.writeDouble(txSuccessRate);
    dest.writeLong(txRetries);
    dest.writeDouble(txRetriesRate);
    dest.writeLong(txBad);
    dest.writeDouble(txBadRate);
    dest.writeLong(rxSuccess);
    dest.writeDouble(rxSuccessRate);
    mSupplicantState.writeToParcel(dest, flags);
    dest.writeInt(mOsuAp ? 1 : 0);
    dest.writeString(mNetworkSuggestionOrSpecifierPackageName);
    dest.writeString(mFqdn);
    dest.writeString(mProviderFriendlyName);
}
Body of Second Method:
{
    dest.writeInt(mNetworkId);
    dest.writeInt(mRssi);
    dest.writeInt(mLinkSpeed);
    dest.writeInt(mTxLinkSpeed);
    dest.writeInt(mRxLinkSpeed);
    dest.writeInt(mFrequency);
    if (mIpAddress != null) {
        dest.writeByte((byte) 1);
        dest.writeByteArray(mIpAddress.getAddress());
    } else {
        dest.writeByte((byte) 0);
    }
    if (mWifiSsid != null) {
        dest.writeInt(1);
        mWifiSsid.writeToParcel(dest, flags);
    } else {
        dest.writeInt(0);
    }
    dest.writeString(mBSSID);
    dest.writeString(mMacAddress);
    dest.writeInt(mMeteredHint ? 1 : 0);
    dest.writeInt(mEphemeral ? 1 : 0);
    dest.writeInt(mTrusted ? 1 : 0);
    dest.writeInt(score);
    dest.writeLong(txSuccess);
    dest.writeDouble(mSuccessfulTxPacketsPerSecond);
    dest.writeLong(txRetries);
    dest.writeDouble(mTxRetriedTxPacketsPerSecond);
    dest.writeLong(txBad);
    dest.writeDouble(mLostTxPacketsPerSecond);
    dest.writeLong(rxSuccess);
    dest.writeDouble(mSuccessfulRxPacketsPerSecond);
    mSupplicantState.writeToParcel(dest, flags);
    dest.writeInt(mOsuAp ? 1 : 0);
    dest.writeString(mRequestingPackageName);
    dest.writeString(mFqdn);
    dest.writeString(mProviderFriendlyName);
    dest.writeInt(mWifiStandard);
    dest.writeInt(mMaxSupportedTxLinkSpeed);
    dest.writeInt(mMaxSupportedRxLinkSpeed);
    dest.writeString(mPasspointUniqueId);
}
------------------------
Find a silently evolved API code:android.view.animation.BounceInterpolator.createNativeInterpolator:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return NativeInterpolatorFactoryHelper.createBounceInterpolator();
}
Body of Second Method:
{
    return NativeInterpolatorFactory.createBounceInterpolator();
}
------------------------
Find a silently evolved API code:android.media.session.MediaController.TransportControls.playFromSearch:COMMENT
Method Modifier: public      
Comment:/**
 * Request that the player start playback for a specific search query.
 * An empty or null query should be treated as a request to play any
 * music.
 *
 * @param query The search query.
 * @param extras Optional extras that can include extra information
 * about the query.
 */

Body of Frist Method:
{
    if (query == null) {
        // This is to remain compatible with
        // INTENT_ACTION_MEDIA_PLAY_FROM_SEARCH
        query = "";
    }
    try {
        mSessionBinder.playFromSearch(mContext.getPackageName(), mCbStub, query, extras);
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling play(" + query + ").", e);
    }
}
Body of Second Method:
{
    if (query == null) {
        // This is to remain compatible with
        // INTENT_ACTION_MEDIA_PLAY_FROM_SEARCH
        query = "";
    }
    try {
        mSessionBinder.playFromSearch(mContext.getPackageName(), query, extras);
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling play(" + query + ").", e);
    }
}
------------------------
Find a silently evolved API code:android.net.LinkAddress.equals:COMMENT
Method Modifier: public      
Comment:/**
 * Compares this {@code LinkAddress} instance against {@code obj}. Two addresses are equal if
 * their address, prefix length, flags and scope are equal. Thus, for example, two addresses
 * that have the same address and prefix length are not equal if one of them is deprecated and
 * the other is not.
 *
 * @param obj the object to be tested for equality.
 * @return {@code true} if both objects are equal, {@code false} otherwise.
 */

Body of Frist Method:
{
    if (!(obj instanceof LinkAddress)) {
        return false;
    }
    LinkAddress linkAddress = (LinkAddress) obj;
    return this.address.equals(linkAddress.address) && this.prefixLength == linkAddress.prefixLength && this.flags == linkAddress.flags && this.scope == linkAddress.scope;
}
Body of Second Method:
{
    if (!(obj instanceof LinkAddress)) {
        return false;
    }
    LinkAddress linkAddress = (LinkAddress) obj;
    return this.address.equals(linkAddress.address) && this.prefixLength == linkAddress.prefixLength && this.flags == linkAddress.flags && this.scope == linkAddress.scope && this.deprecationTime == linkAddress.deprecationTime && this.expirationTime == linkAddress.expirationTime;
}
------------------------
Find a silently evolved API code:android.content.ContentProviderClient.getType:COMMENT
Method Modifier: public      
Comment:/**
 * See {@link ContentProvider#getType ContentProvider.getType}
 */

Body of Frist Method:
{
    Preconditions.checkNotNull(url, "url");
    beforeRemote();
    try {
        return mContentProvider.getType(url);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}
Body of Second Method:
{
    Objects.requireNonNull(url, "url");
    beforeRemote();
    try {
        return mContentProvider.getType(url);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}
------------------------
Find a silently evolved API code:android.util.Half.isNormalized:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns true if the specified half-precision float value is normalized
 * (does not have a subnormal representation). If the specified value is
 * {@link #POSITIVE_INFINITY}, {@link #NEGATIVE_INFINITY},
 * {@link #POSITIVE_ZERO}, {@link #NEGATIVE_ZERO}, NaN or any subnormal
 * number, this method returns false.
 *
 * @param h A half-precision float value
 * @return True if the value is normalized, false otherwise
 */

Body of Frist Method:
{
    return (h & FP16_EXPONENT_MAX) != 0 && (h & FP16_EXPONENT_MAX) != FP16_EXPONENT_MAX;
}
Body of Second Method:
{
    return FP16.isNormalized(h);
}
------------------------
Find a silently evolved API code:android.net.wifi.p2p.WifiP2pConfig.Builder.enablePersistentMode:COMMENT
Method Modifier: public      
Comment:/**
 * Specify that the group configuration be persisted (i.e. saved).
 * By default the group configuration will not be saved.
 * <p>
 * Optional. false by default.
 *
 * @param persistent is this group persistent group.
 * @return The builder to facilitate chaining
 * {@code builder.setXXX(..).setXXX(..)}.
 */

Body of Frist Method:
{
    if (persistent) {
        mNetId = WifiP2pGroup.PERSISTENT_NET_ID;
    } else {
        mNetId = WifiP2pGroup.TEMPORARY_NET_ID;
    }
    return this;
}
Body of Second Method:
{
    if (persistent) {
        mNetId = WifiP2pGroup.NETWORK_ID_PERSISTENT;
    } else {
        mNetId = WifiP2pGroup.NETWORK_ID_TEMPORARY;
    }
    return this;
}
------------------------
Find a silently evolved API code:android.telephony.ims.feature.MmTelFeature.notifyIncomingCallSession:COMMENT
Method Modifier: public      final       hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    synchronized (mLock) {
        if (mListener == null) {
            throw new IllegalStateException("Session is not available.");
        }
        try {
            mListener.onIncomingCall(c, extras);
        } catch (RemoteException e) {
            throw new RuntimeException(e);
        }
    }
}
Body of Second Method:
{
    IImsMmTelListener listener = getListener();
    if (listener == null) {
        throw new IllegalStateException("Session is not available.");
    }
    try {
        listener.onIncomingCall(c, extras);
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}
------------------------
Find a silently evolved API code:android.view.MotionEvent.clampNoHistory:COMMENT
Method Modifier: public      final       hidden      
Comment:/**
 * Returns a new motion events whose points have been clamped to the specified bounds.
 * @hide
 */

Body of Frist Method:
{
    MotionEvent ev = obtain();
    synchronized (gSharedTempLock) {
        final int pointerCount = nativeGetPointerCount(mNativePtr);
        ensureSharedTempPointerCapacity(pointerCount);
        final PointerProperties[] pp = gSharedTempPointerProperties;
        final PointerCoords[] pc = gSharedTempPointerCoords;
        for (int i = 0; i < pointerCount; i++) {
            nativeGetPointerProperties(mNativePtr, i, pp[i]);
            nativeGetPointerCoords(mNativePtr, i, HISTORY_CURRENT, pc[i]);
            pc[i].x = clamp(pc[i].x, left, right);
            pc[i].y = clamp(pc[i].y, top, bottom);
        }
        ev.mNativePtr = nativeInitialize(ev.mNativePtr, nativeGetDeviceId(mNativePtr), nativeGetSource(mNativePtr), nativeGetDisplayId(mNativePtr), nativeGetAction(mNativePtr), nativeGetFlags(mNativePtr), nativeGetEdgeFlags(mNativePtr), nativeGetMetaState(mNativePtr), nativeGetButtonState(mNativePtr), nativeGetClassification(mNativePtr), nativeGetXOffset(mNativePtr), nativeGetYOffset(mNativePtr), nativeGetXPrecision(mNativePtr), nativeGetYPrecision(mNativePtr), nativeGetDownTimeNanos(mNativePtr), nativeGetEventTimeNanos(mNativePtr, HISTORY_CURRENT), pointerCount, pp, pc);
        return ev;
    }
}
Body of Second Method:
{
    MotionEvent ev = obtain();
    synchronized (gSharedTempLock) {
        final int pointerCount = nativeGetPointerCount(mNativePtr);
        ensureSharedTempPointerCapacity(pointerCount);
        final PointerProperties[] pp = gSharedTempPointerProperties;
        final PointerCoords[] pc = gSharedTempPointerCoords;
        for (int i = 0; i < pointerCount; i++) {
            nativeGetPointerProperties(mNativePtr, i, pp[i]);
            nativeGetPointerCoords(mNativePtr, i, HISTORY_CURRENT, pc[i]);
            pc[i].x = clamp(pc[i].x, left, right);
            pc[i].y = clamp(pc[i].y, top, bottom);
        }
        ev.initialize(nativeGetDeviceId(mNativePtr), nativeGetSource(mNativePtr), nativeGetDisplayId(mNativePtr), nativeGetAction(mNativePtr), nativeGetFlags(mNativePtr), nativeGetEdgeFlags(mNativePtr), nativeGetMetaState(mNativePtr), nativeGetButtonState(mNativePtr), nativeGetClassification(mNativePtr), nativeGetXOffset(mNativePtr), nativeGetYOffset(mNativePtr), nativeGetXPrecision(mNativePtr), nativeGetYPrecision(mNativePtr), nativeGetDownTimeNanos(mNativePtr), nativeGetEventTimeNanos(mNativePtr, HISTORY_CURRENT), pointerCount, pp, pc);
        return ev;
    }
}
------------------------
Find a silently evolved API code:android.app.StatusBarManager.DisableInfo.areAllComponentsDisabled:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @return {@code true} if all status bar components are disabled
 *
 * @hide
 */

Body of Frist Method:
{
    return mStatusBarExpansion && mNavigateHome && mNotificationPeeking && mRecents && mSearch;
}
Body of Second Method:
{
    return mStatusBarExpansion && mNavigateHome && mNotificationPeeking && mRecents && mSearch && mSystemIcons && mClock && mNotificationIcons;
}
------------------------
Find a silently evolved API code:android.app.NotificationChannel.writeXml:COMMENT
Method Modifier: private     
Comment:/**
 * If {@param forBackup} is true, {@param Context} MUST be non-null.
 */

Body of Frist Method:
{
    Preconditions.checkArgument(!forBackup || context != null, "forBackup is true but got null context");
    out.startTag(null, TAG_CHANNEL);
    out.attribute(null, ATT_ID, getId());
    if (getName() != null) {
        out.attribute(null, ATT_NAME, getName().toString());
    }
    if (getDescription() != null) {
        out.attribute(null, ATT_DESC, getDescription());
    }
    if (getImportance() != DEFAULT_IMPORTANCE) {
        out.attribute(null, ATT_IMPORTANCE, Integer.toString(getImportance()));
    }
    if (canBypassDnd()) {
        out.attribute(null, ATT_PRIORITY, Integer.toString(Notification.PRIORITY_MAX));
    }
    if (getLockscreenVisibility() != DEFAULT_VISIBILITY) {
        out.attribute(null, ATT_VISIBILITY, Integer.toString(getLockscreenVisibility()));
    }
    Uri sound = forBackup ? getSoundForBackup(context) : getSound();
    if (sound != null) {
        out.attribute(null, ATT_SOUND, sound.toString());
    }
    if (getAudioAttributes() != null) {
        out.attribute(null, ATT_USAGE, Integer.toString(getAudioAttributes().getUsage()));
        out.attribute(null, ATT_CONTENT_TYPE, Integer.toString(getAudioAttributes().getContentType()));
        out.attribute(null, ATT_FLAGS, Integer.toString(getAudioAttributes().getFlags()));
    }
    if (shouldShowLights()) {
        out.attribute(null, ATT_LIGHTS, Boolean.toString(shouldShowLights()));
    }
    if (getLightColor() != DEFAULT_LIGHT_COLOR) {
        out.attribute(null, ATT_LIGHT_COLOR, Integer.toString(getLightColor()));
    }
    if (shouldVibrate()) {
        out.attribute(null, ATT_VIBRATION_ENABLED, Boolean.toString(shouldVibrate()));
    }
    if (getVibrationPattern() != null) {
        out.attribute(null, ATT_VIBRATION, longArrayToString(getVibrationPattern()));
    }
    if (getUserLockedFields() != 0) {
        out.attribute(null, ATT_USER_LOCKED, Integer.toString(getUserLockedFields()));
    }
    if (isFgServiceShown()) {
        out.attribute(null, ATT_FG_SERVICE_SHOWN, Boolean.toString(isFgServiceShown()));
    }
    if (canShowBadge()) {
        out.attribute(null, ATT_SHOW_BADGE, Boolean.toString(canShowBadge()));
    }
    if (isDeleted()) {
        out.attribute(null, ATT_DELETED, Boolean.toString(isDeleted()));
    }
    if (getGroup() != null) {
        out.attribute(null, ATT_GROUP, getGroup());
    }
    if (isBlockableSystem()) {
        out.attribute(null, ATT_BLOCKABLE_SYSTEM, Boolean.toString(isBlockableSystem()));
    }
    if (canBubble() != DEFAULT_ALLOW_BUBBLE) {
        out.attribute(null, ATT_ALLOW_BUBBLE, Boolean.toString(canBubble()));
    }
    // mImportanceLockedDefaultApp and mImportanceLockedByOEM have a different source of
    // truth and so aren't written to this xml file
    out.endTag(null, TAG_CHANNEL);
}
Body of Second Method:
{
    Preconditions.checkArgument(!forBackup || context != null, "forBackup is true but got null context");
    out.startTag(null, TAG_CHANNEL);
    out.attribute(null, ATT_ID, getId());
    if (getName() != null) {
        out.attribute(null, ATT_NAME, getName().toString());
    }
    if (getDescription() != null) {
        out.attribute(null, ATT_DESC, getDescription());
    }
    if (getImportance() != DEFAULT_IMPORTANCE) {
        out.attribute(null, ATT_IMPORTANCE, Integer.toString(getImportance()));
    }
    if (canBypassDnd()) {
        out.attribute(null, ATT_PRIORITY, Integer.toString(Notification.PRIORITY_MAX));
    }
    if (getLockscreenVisibility() != DEFAULT_VISIBILITY) {
        out.attribute(null, ATT_VISIBILITY, Integer.toString(getLockscreenVisibility()));
    }
    Uri sound = forBackup ? getSoundForBackup(context) : getSound();
    if (sound != null) {
        out.attribute(null, ATT_SOUND, sound.toString());
    }
    if (getAudioAttributes() != null) {
        out.attribute(null, ATT_USAGE, Integer.toString(getAudioAttributes().getUsage()));
        out.attribute(null, ATT_CONTENT_TYPE, Integer.toString(getAudioAttributes().getContentType()));
        out.attribute(null, ATT_FLAGS, Integer.toString(getAudioAttributes().getFlags()));
    }
    if (shouldShowLights()) {
        out.attribute(null, ATT_LIGHTS, Boolean.toString(shouldShowLights()));
    }
    if (getLightColor() != DEFAULT_LIGHT_COLOR) {
        out.attribute(null, ATT_LIGHT_COLOR, Integer.toString(getLightColor()));
    }
    if (shouldVibrate()) {
        out.attribute(null, ATT_VIBRATION_ENABLED, Boolean.toString(shouldVibrate()));
    }
    if (getVibrationPattern() != null) {
        out.attribute(null, ATT_VIBRATION, longArrayToString(getVibrationPattern()));
    }
    if (getUserLockedFields() != 0) {
        out.attribute(null, ATT_USER_LOCKED, Integer.toString(getUserLockedFields()));
    }
    if (isFgServiceShown()) {
        out.attribute(null, ATT_FG_SERVICE_SHOWN, Boolean.toString(isFgServiceShown()));
    }
    if (canShowBadge()) {
        out.attribute(null, ATT_SHOW_BADGE, Boolean.toString(canShowBadge()));
    }
    if (isDeleted()) {
        out.attribute(null, ATT_DELETED, Boolean.toString(isDeleted()));
    }
    if (getGroup() != null) {
        out.attribute(null, ATT_GROUP, getGroup());
    }
    if (isBlockable()) {
        out.attribute(null, ATT_BLOCKABLE_SYSTEM, Boolean.toString(isBlockable()));
    }
    if (getAllowBubbles() != DEFAULT_ALLOW_BUBBLE) {
        out.attribute(null, ATT_ALLOW_BUBBLE, Integer.toString(getAllowBubbles()));
    }
    if (getOriginalImportance() != DEFAULT_IMPORTANCE) {
        out.attribute(null, ATT_ORIG_IMP, Integer.toString(getOriginalImportance()));
    }
    if (getParentChannelId() != null) {
        out.attribute(null, ATT_PARENT_CHANNEL, getParentChannelId());
    }
    if (getConversationId() != null) {
        out.attribute(null, ATT_CONVERSATION_ID, getConversationId());
    }
    if (isDemoted()) {
        out.attribute(null, ATT_DEMOTE, Boolean.toString(isDemoted()));
    }
    if (isImportantConversation()) {
        out.attribute(null, ATT_IMP_CONVERSATION, Boolean.toString(isImportantConversation()));
    }
    // mImportanceLockedDefaultApp and mImportanceLockedByOEM have a different source of
    // truth and so aren't written to this xml file
    out.endTag(null, TAG_CHANNEL);
}
------------------------
Find a silently evolved API code:android.telephony.ims.ImsCallSessionListener.callSessionMergeFailed:COMMENT
Method Modifier: public      
Comment:/**
 * The IMS call session merge has failed.
 *
 * @param reasonInfo {@link ImsReasonInfo} contining the reason for the call merge failure.
 */

Body of Frist Method:
{
    try {
        mListener.callSessionMergeFailed(reasonInfo);
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}
Body of Second Method:
{
    try {
        mListener.callSessionMergeFailed(reasonInfo);
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.util.Half.greater:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns true if the first half-precision float value is greater (larger
 * toward positive infinity) than the second half-precision float value.
 * If either of the values is NaN, the result is false.
 *
 * @param x The first half-precision value
 * @param y The second half-precision value
 *
 * @return True if x is greater than y, false otherwise
 */

Body of Frist Method:
{
    if ((x & FP16_COMBINED) > FP16_EXPONENT_MAX)
        return false;
    if ((y & FP16_COMBINED) > FP16_EXPONENT_MAX)
        return false;
    return ((x & FP16_SIGN_MASK) != 0 ? 0x8000 - (x & 0xffff) : x & 0xffff) > ((y & FP16_SIGN_MASK) != 0 ? 0x8000 - (y & 0xffff) : y & 0xffff);
}
Body of Second Method:
{
    return FP16.greater(x, y);
}
------------------------
Find a silently evolved API code:android.telephony.ims.ImsCallSessionListener.callSessionRttModifyResponseReceived:COMMENT
Method Modifier: public      
Comment:/**
 * An RTT modify response has been received.
 *
 * @param status the received response for RTT modify request.
 */

Body of Frist Method:
{
    try {
        mListener.callSessionRttModifyResponseReceived(status);
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}
Body of Second Method:
{
    try {
        mListener.callSessionRttModifyResponseReceived(status);
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.widget.StackView.performAccessibilityActionInternal:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (super.performAccessibilityActionInternal(action, arguments)) {
        return true;
    }
    if (!isEnabled()) {
        return false;
    }
    switch(action) {
        case AccessibilityNodeInfo.ACTION_SCROLL_FORWARD:
            {
                if (getDisplayedChild() < getChildCount() - 1) {
                    showNext();
                    return true;
                }
            }
            return false;
        case AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD:
            {
                if (getDisplayedChild() > 0) {
                    showPrevious();
                    return true;
                }
            }
            return false;
    }
    return false;
}
Body of Second Method:
{
    if (super.performAccessibilityActionInternal(action, arguments)) {
        return true;
    }
    if (!isEnabled()) {
        return false;
    }
    switch(action) {
        case AccessibilityNodeInfo.ACTION_SCROLL_FORWARD:
            {
                return goForward();
            }
        case AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD:
            {
                return goBackward();
            }
        case R.id.accessibilityActionPageUp:
            {
                if (mStackMode == ITEMS_SLIDE_UP) {
                    return goBackward();
                } else {
                    return goForward();
                }
            }
        case R.id.accessibilityActionPageDown:
            {
                if (mStackMode == ITEMS_SLIDE_UP) {
                    return goForward();
                } else {
                    return goBackward();
                }
            }
    }
    return false;
}
------------------------
Find a silently evolved API code:android.webkit.MimeTypeMap.getExtensionFromMimeType:COMMENT
Method Modifier: public      
Comment:/**
 * Return the registered extension for the given MIME type. Note that some
 * MIME types map to multiple extensions. This call will return the most
 * common extension for the given MIME type.
 * @param mimeType A MIME type (i.e. text/plain)
 * @return The extension for the given MIME type or {@code null} if there is none.
 */

Body of Frist Method:
{
    return MimeUtils.guessExtensionFromMimeType(mimeType);
}
Body of Second Method:
{
    return MimeMap.getDefault().guessExtensionFromMimeType(mimeType);
}
------------------------
Find a silently evolved API code:android.telephony.PhoneNumberUtils.getNumberFromIntent:COMMENT
Method Modifier: public      static      
Comment:/**
 * Extracts the phone number from an Intent.
 *
 * @param intent the intent to get the number of
 * @param context a context to use for database access
 *
 * @return the phone number that would be called by the intent, or
 * <code>null</code> if the number cannot be found.
 */

Body of Frist Method:
{
    String number = null;
    Uri uri = intent.getData();
    if (uri == null) {
        return null;
    }
    String scheme = uri.getScheme();
    if (scheme.equals("tel") || scheme.equals("sip")) {
        return uri.getSchemeSpecificPart();
    }
    if (context == null) {
        return null;
    }
    String type = intent.resolveType(context);
    String phoneColumn = null;
    // Correctly read out the phone entry based on requested provider
    final String authority = uri.getAuthority();
    if (Contacts.AUTHORITY.equals(authority)) {
        phoneColumn = Contacts.People.Phones.NUMBER;
    } else if (ContactsContract.AUTHORITY.equals(authority)) {
        phoneColumn = ContactsContract.CommonDataKinds.Phone.NUMBER;
    }
    Cursor c = null;
    try {
        c = context.getContentResolver().query(uri, new String[] { phoneColumn }, null, null, null);
        if (c != null) {
            if (c.moveToFirst()) {
                number = c.getString(c.getColumnIndex(phoneColumn));
            }
        }
    } catch (RuntimeException e) {
        Rlog.e(LOG_TAG, "Error getting phone number.", e);
    } finally {
        if (c != null) {
            c.close();
        }
    }
    return number;
}
Body of Second Method:
{
    String number = null;
    Uri uri = intent.getData();
    if (uri == null) {
        return null;
    }
    String scheme = uri.getScheme();
    if (scheme == null) {
        return null;
    }
    if (scheme.equals("tel") || scheme.equals("sip")) {
        return uri.getSchemeSpecificPart();
    }
    if (context == null) {
        return null;
    }
    String type = intent.resolveType(context);
    String phoneColumn = null;
    // Correctly read out the phone entry based on requested provider
    final String authority = uri.getAuthority();
    if (Contacts.AUTHORITY.equals(authority)) {
        phoneColumn = Contacts.People.Phones.NUMBER;
    } else if (ContactsContract.AUTHORITY.equals(authority)) {
        phoneColumn = ContactsContract.CommonDataKinds.Phone.NUMBER;
    }
    Cursor c = null;
    try {
        c = context.getContentResolver().query(uri, new String[] { phoneColumn }, null, null, null);
        if (c != null) {
            if (c.moveToFirst()) {
                number = c.getString(c.getColumnIndex(phoneColumn));
            }
        }
    } catch (RuntimeException e) {
        Rlog.e(LOG_TAG, "Error getting phone number.", e);
    } finally {
        if (c != null) {
            c.close();
        }
    }
    return number;
}
------------------------
Find a silently evolved API code:android.service.quicksettings.TileService.requestListeningState:COMMENT
Method Modifier: public      static      final       
Comment:/**
 * Requests that a tile be put in the listening state so it can send an update.
 *
 * This method is only applicable to tiles that have {@link #META_DATA_ACTIVE_TILE} defined
 * as true on their TileService Manifest declaration, and will do nothing otherwise.
 */

Body of Frist Method:
{
    Intent intent = new Intent(ACTION_REQUEST_LISTENING);
    intent.putExtra(Intent.EXTRA_COMPONENT_NAME, component);
    intent.setPackage("com.android.systemui");
    context.sendBroadcast(intent, Manifest.permission.BIND_QUICK_SETTINGS_TILE);
}
Body of Second Method:
{
    final ComponentName sysuiComponent = ComponentName.unflattenFromString(context.getResources().getString(com.android.internal.R.string.config_systemUIServiceComponent));
    Intent intent = new Intent(ACTION_REQUEST_LISTENING);
    intent.putExtra(Intent.EXTRA_COMPONENT_NAME, component);
    intent.setPackage(sysuiComponent.getPackageName());
    context.sendBroadcast(intent, Manifest.permission.BIND_QUICK_SETTINGS_TILE);
}
------------------------
Find a silently evolved API code:android.view.Surface.release:COMMENT
Method Modifier: public      
Comment:/**
 * Release the local reference to the server-side surface.
 * Always call release() when you're done with a Surface.
 * This will make the surface invalid.
 */

Body of Frist Method:
{
    synchronized (mLock) {
        if (mNativeObject != 0) {
            nativeRelease(mNativeObject);
            setNativeObjectLocked(0);
        }
        if (mHwuiContext != null) {
            mHwuiContext.destroy();
            mHwuiContext = null;
        }
    }
}
Body of Second Method:
{
    synchronized (mLock) {
        if (mHwuiContext != null) {
            mHwuiContext.destroy();
            mHwuiContext = null;
        }
        if (mNativeObject != 0) {
            nativeRelease(mNativeObject);
            setNativeObjectLocked(0);
        }
    }
}
------------------------
Find a silently evolved API code:android.telephony.ims.ImsCallSessionListener.callSessionProgressing:COMMENT
Method Modifier: public      
Comment:/**
 * A request has been sent out to initiate a new IMS call session and a 1xx response has been
 * received from the network.
 */

Body of Frist Method:
{
    try {
        mListener.callSessionProgressing(profile);
    } catch (RemoteException e) {
        throw new RuntimeException(e);
    }
}
Body of Second Method:
{
    try {
        mListener.callSessionProgressing(profile);
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.view.ViewPropertyAnimator.AnimatorEventListener.onAnimationUpdate:COMMENT
Method Modifier: public      
Comment:/**
 * Calculate the current value for each property and set it on the view. Invalidate
 * the view object appropriately, depending on which properties are being animated.
 *
 * @param animation The animator associated with the properties that need to be
 * set. This animator holds the animation fraction which we will use to calculate
 * the current value of each property.
 */

Body of Frist Method:
{
    PropertyBundle propertyBundle = mAnimatorMap.get(animation);
    if (propertyBundle == null) {
        // Shouldn't happen, but just to play it safe
        return;
    }
    boolean hardwareAccelerated = mView.isHardwareAccelerated();
    if (!hardwareAccelerated) {
        mView.invalidateParentCaches();
    }
    float fraction = animation.getAnimatedFraction();
    int propertyMask = propertyBundle.mPropertyMask;
    if ((propertyMask & TRANSFORM_MASK) != 0) {
        mView.invalidateViewProperty(hardwareAccelerated, false);
    }
    ArrayList<NameValuesHolder> valueList = propertyBundle.mNameValuesHolder;
    if (valueList != null) {
        int count = valueList.size();
        for (int i = 0; i < count; ++i) {
            NameValuesHolder values = valueList.get(i);
            float value = values.mFromValue + fraction * values.mDeltaValue;
            setValue(values.mNameConstant, value);
        }
    }
    if ((propertyMask & TRANSFORM_MASK) != 0) {
        if (!hardwareAccelerated) {
            // force another invalidation
            mView.mPrivateFlags |= View.PFLAG_DRAWN;
        }
    }
    mView.invalidateViewProperty(false, false);
    if (mUpdateListener != null) {
        mUpdateListener.onAnimationUpdate(animation);
    }
}
Body of Second Method:
{
    PropertyBundle propertyBundle = mAnimatorMap.get(animation);
    if (propertyBundle == null) {
        // Shouldn't happen, but just to play it safe
        return;
    }
    boolean hardwareAccelerated = mView.isHardwareAccelerated();
    // alpha requires slightly different treatment than the other (transform) properties.
    // The logic in setAlpha() is not simply setting mAlpha, plus the invalidation
    // logic is dependent on how the view handles an internal call to onSetAlpha().
    // We track what kinds of properties are set, and how alpha is handled when it is
    // set, and perform the invalidation steps appropriately.
    boolean alphaHandled = false;
    if (!hardwareAccelerated) {
        mView.invalidateParentCaches();
    }
    float fraction = animation.getAnimatedFraction();
    int propertyMask = propertyBundle.mPropertyMask;
    if ((propertyMask & TRANSFORM_MASK) != 0) {
        mView.invalidateViewProperty(hardwareAccelerated, false);
    }
    ArrayList<NameValuesHolder> valueList = propertyBundle.mNameValuesHolder;
    if (valueList != null) {
        int count = valueList.size();
        for (int i = 0; i < count; ++i) {
            NameValuesHolder values = valueList.get(i);
            float value = values.mFromValue + fraction * values.mDeltaValue;
            if (values.mNameConstant == ALPHA) {
                alphaHandled = mView.setAlphaNoInvalidation(value);
            } else {
                setValue(values.mNameConstant, value);
            }
        }
    }
    if ((propertyMask & TRANSFORM_MASK) != 0) {
        if (!hardwareAccelerated) {
            // force another invalidation
            mView.mPrivateFlags |= View.PFLAG_DRAWN;
        }
    }
    // via the call to setAlphaNoInvalidation(), above
    if (alphaHandled) {
        mView.invalidate(true);
    } else {
        mView.invalidateViewProperty(false, false);
    }
    if (mUpdateListener != null) {
        mUpdateListener.onAnimationUpdate(animation);
    }
}
------------------------
Find a silently evolved API code:android.net.NetworkKey.createFromWifiInfo:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Constructs a new NetworkKey for the given {@link WifiInfo}.
 *
 * @param wifiInfo the {@link WifiInfo} to create a {@link NetworkKey} for.
 * @return A new {@link NetworkKey} instance or <code>null</code> if the given {@link WifiInfo}
 * instance doesn't represent a connected WiFi network.
 * @hide
 */

Body of Frist Method:
{
    if (wifiInfo != null) {
        final String ssid = wifiInfo.getSSID();
        final String bssid = wifiInfo.getBSSID();
        if (!TextUtils.isEmpty(ssid) && !ssid.equals(WifiSsid.NONE) && !TextUtils.isEmpty(bssid)) {
            WifiKey wifiKey;
            try {
                wifiKey = new WifiKey(ssid, bssid);
            } catch (IllegalArgumentException e) {
                Log.e(TAG, "Unable to create WifiKey.", e);
                return null;
            }
            return new NetworkKey(wifiKey);
        }
    }
    return null;
}
Body of Second Method:
{
    if (wifiInfo != null) {
        final String ssid = wifiInfo.getSSID();
        final String bssid = wifiInfo.getBSSID();
        if (!TextUtils.isEmpty(ssid) && !ssid.equals(WifiManager.UNKNOWN_SSID) && !TextUtils.isEmpty(bssid)) {
            WifiKey wifiKey;
            try {
                wifiKey = new WifiKey(ssid, bssid);
            } catch (IllegalArgumentException e) {
                Log.e(TAG, "Unable to create WifiKey.", e);
                return null;
            }
            return new NetworkKey(wifiKey);
        }
    }
    return null;
}
------------------------
Find a silently evolved API code:android.view.textclassifier.SelectionEvent.setTextClassificationSessionContext:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets the {@link TextClassificationContext} for this event.
 * @hide
 */

Body of Frist Method:
{
    mPackageName = context.getPackageName();
    mWidgetType = context.getWidgetType();
    mWidgetVersion = context.getWidgetVersion();
}
Body of Second Method:
{
    mPackageName = context.getPackageName();
    mWidgetType = context.getWidgetType();
    mWidgetVersion = context.getWidgetVersion();
    mSystemTcMetadata = context.getSystemTextClassifierMetadata();
}
------------------------
Find a silently evolved API code:android.content.pm.ShortcutManager.getDynamicShortcuts:COMMENT
Method Modifier: public      
Comment:/**
 * Return all dynamic shortcuts from the caller app.
 *
 * <p>This API is intended to be used for examining what shortcuts are currently published.
 * Re-publishing returned {@link ShortcutInfo}s via APIs such as
 * {@link #setDynamicShortcuts(List)} may cause loss of information such as icons.
 *
 * @throws IllegalStateException when the user is locked.
 */

Body of Frist Method:
{
    try {
        return mService.getDynamicShortcuts(mContext.getPackageName(), injectMyUserId()).getList();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    try {
        return mService.getShortcuts(mContext.getPackageName(), FLAG_MATCH_DYNAMIC, injectMyUserId()).getList();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.media.AudioAttributes.Builder.setContentType:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the attribute describing the content type of the audio signal, such as speech,
 * or music.
 * @param contentType the content type values, one of
 * {@link AudioAttributes#CONTENT_TYPE_MOVIE},
 * {@link AudioAttributes#CONTENT_TYPE_MUSIC},
 * {@link AudioAttributes#CONTENT_TYPE_SONIFICATION},
 * {@link AudioAttributes#CONTENT_TYPE_SPEECH},
 * {@link AudioAttributes#CONTENT_TYPE_UNKNOWN}.
 * @return the same Builder instance.
 */

Body of Frist Method:
{
    switch(contentType) {
        case CONTENT_TYPE_UNKNOWN:
        case CONTENT_TYPE_MOVIE:
        case CONTENT_TYPE_MUSIC:
        case CONTENT_TYPE_SONIFICATION:
        case CONTENT_TYPE_SPEECH:
            mContentType = contentType;
            break;
        default:
            mContentType = CONTENT_TYPE_UNKNOWN;
    }
    return this;
}
Body of Second Method:
{
    switch(contentType) {
        case CONTENT_TYPE_UNKNOWN:
        case CONTENT_TYPE_MOVIE:
        case CONTENT_TYPE_MUSIC:
        case CONTENT_TYPE_SONIFICATION:
        case CONTENT_TYPE_SPEECH:
            mContentType = contentType;
            break;
        default:
            throw new IllegalArgumentException("Invalid content type " + contentType);
    }
    return this;
}
------------------------
Find a silently evolved API code:android.net.TcpKeepalivePacketData.toStableParcelable:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Convert this TcpKeepalivePacketData to a TcpKeepalivePacketDataParcelable.
 */

Body of Frist Method:
{
    final TcpKeepalivePacketDataParcelable parcel = new TcpKeepalivePacketDataParcelable();
    parcel.srcAddress = srcAddress.getAddress();
    parcel.srcPort = srcPort;
    parcel.dstAddress = dstAddress.getAddress();
    parcel.dstPort = dstPort;
    parcel.seq = tcpSeq;
    parcel.ack = tcpAck;
    parcel.rcvWnd = tcpWnd;
    parcel.rcvWndScale = tcpWndScale;
    parcel.tos = ipTos;
    parcel.ttl = ipTtl;
    return parcel;
}
Body of Second Method:
{
    final TcpKeepalivePacketDataParcelable parcel = new TcpKeepalivePacketDataParcelable();
    final InetAddress srcAddress = getSrcAddress();
    final InetAddress dstAddress = getDstAddress();
    parcel.srcAddress = srcAddress.getAddress();
    parcel.srcPort = getSrcPort();
    parcel.dstAddress = dstAddress.getAddress();
    parcel.dstPort = getDstPort();
    parcel.seq = tcpSeq;
    parcel.ack = tcpAck;
    parcel.rcvWnd = tcpWnd;
    parcel.rcvWndScale = tcpWndScale;
    parcel.tos = ipTos;
    parcel.ttl = ipTtl;
    return parcel;
}
------------------------
Find a silently evolved API code:android.webkit.MimeTypeMap.mimeTypeFromExtension:COMMENT
Method Modifier: private     static      
Comment:// Static method called by jni.

Body of Frist Method:
{
    return MimeUtils.guessMimeTypeFromExtension(extension);
}
Body of Second Method:
{
    return MimeMap.getDefault().guessMimeTypeFromExtension(extension);
}
------------------------
Find a silently evolved API code:android.net.RouteInfo.equals:COMMENT
Method Modifier: public      
Comment:/**
 * Compares this RouteInfo object against the specified object and indicates if they are equal.
 * @return {@code true} if the objects are equal, {@code false} otherwise.
 */

Body of Frist Method:
{
    if (this == obj)
        return true;
    if (!(obj instanceof RouteInfo))
        return false;
    RouteInfo target = (RouteInfo) obj;
    return Objects.equals(mDestination, target.getDestination()) && Objects.equals(mGateway, target.getGateway()) && Objects.equals(mInterface, target.getInterface()) && mType == target.getType();
}
Body of Second Method:
{
    if (this == obj)
        return true;
    if (!(obj instanceof RouteInfo))
        return false;
    RouteInfo target = (RouteInfo) obj;
    return Objects.equals(mDestination, target.getDestination()) && Objects.equals(mGateway, target.getGateway()) && Objects.equals(mInterface, target.getInterface()) && mType == target.getType() && mMtu == target.getMtu();
}
------------------------
Find a silently evolved API code:android.media.audiopolicy.AudioProductStrategy.getLegacyStreamTypeForStrategyWithAudioAttributes:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 * @param audioAttributes to identify AudioProductStrategy with
 * @return legacy stream type associated with matched AudioProductStrategy
 * Defaults to STREAM_MUSIC if no match is found, or if matches is STREAM_DEFAULT
 */

Body of Frist Method:
{
    Preconditions.checkNotNull(audioAttributes, "AudioAttributes must not be null");
    for (final AudioProductStrategy productStrategy : AudioProductStrategy.getAudioProductStrategies()) {
        if (productStrategy.supportsAudioAttributes(audioAttributes)) {
            int streamType = productStrategy.getLegacyStreamTypeForAudioAttributes(audioAttributes);
            if (streamType == AudioSystem.STREAM_DEFAULT) {
                Log.w(TAG, "Attributes " + audioAttributes.toString() + " ported by strategy " + productStrategy.getId() + " has no stream type associated, " + "DO NOT USE STREAM TO CONTROL THE VOLUME");
                return AudioSystem.STREAM_MUSIC;
            }
            return streamType;
        }
    }
    return AudioSystem.STREAM_MUSIC;
}
Body of Second Method:
{
    Preconditions.checkNotNull(audioAttributes, "AudioAttributes must not be null");
    for (final AudioProductStrategy productStrategy : AudioProductStrategy.getAudioProductStrategies()) {
        if (productStrategy.supportsAudioAttributes(audioAttributes)) {
            int streamType = productStrategy.getLegacyStreamTypeForAudioAttributes(audioAttributes);
            if (streamType == AudioSystem.STREAM_DEFAULT) {
                Log.w(TAG, "Attributes " + audioAttributes.toString() + " ported by strategy " + productStrategy.getId() + " has no stream type associated, " + "DO NOT USE STREAM TO CONTROL THE VOLUME");
                return AudioSystem.STREAM_MUSIC;
            }
            if (streamType < AudioSystem.getNumStreamTypes()) {
                return streamType;
            }
        }
    }
    return AudioSystem.STREAM_MUSIC;
}
------------------------
Find a silently evolved API code:android.app.WindowConfiguration.activityTypeToString:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    switch(applicationType) {
        case ACTIVITY_TYPE_UNDEFINED:
            return "undefined";
        case ACTIVITY_TYPE_STANDARD:
            return "standard";
        case ACTIVITY_TYPE_HOME:
            return "home";
        case ACTIVITY_TYPE_RECENTS:
            return "recents";
        case ACTIVITY_TYPE_ASSISTANT:
            return "assistant";
    }
    return String.valueOf(applicationType);
}
Body of Second Method:
{
    switch(applicationType) {
        case ACTIVITY_TYPE_UNDEFINED:
            return "undefined";
        case ACTIVITY_TYPE_STANDARD:
            return "standard";
        case ACTIVITY_TYPE_HOME:
            return "home";
        case ACTIVITY_TYPE_RECENTS:
            return "recents";
        case ACTIVITY_TYPE_ASSISTANT:
            return "assistant";
        case ACTIVITY_TYPE_DREAM:
            return "dream";
    }
    return String.valueOf(applicationType);
}
------------------------
Find a silently evolved API code:android.location.GnssClock.resetDriftUncertaintyNanosPerSecond:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Resets the clock's Drift Uncertainty (1-Sigma) in nanoseconds per second.
 * @hide
 */

Body of Frist Method:
{
    resetFlag(HAS_DRIFT_UNCERTAINTY);
    mDriftUncertaintyNanosPerSecond = Double.NaN;
}
Body of Second Method:
{
    resetFlag(HAS_DRIFT_UNCERTAINTY);
}
------------------------
Find a silently evolved API code:android.media.session.MediaController.TransportControls.rewind:COMMENT
Method Modifier: public      
Comment:/**
 * Start rewinding. If playback is already rewinding this may increase
 * the rate.
 */

Body of Frist Method:
{
    try {
        mSessionBinder.rewind(mContext.getPackageName(), mCbStub);
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling rewind.", e);
    }
}
Body of Second Method:
{
    try {
        mSessionBinder.rewind(mContext.getPackageName());
    } catch (RemoteException e) {
        Log.wtf(TAG, "Error calling rewind.", e);
    }
}
------------------------
Find a silently evolved API code:android.app.servertransaction.TransactionExecutorHelper.getLifecyclePath:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Calculate the path through main lifecycle states for an activity and fill
 * @link #mLifecycleSequence} with values starting with the state that follows the initial
 * state.
 * <p>NOTE: The returned value is used internally in this class and is not a copy. It's contents
 * may change after calling other methods of this class.</p>
 */

Body of Frist Method:
{
    if (start == UNDEFINED || finish == UNDEFINED) {
        throw new IllegalArgumentException("Can't resolve lifecycle path for undefined state");
    }
    if (start == ON_RESTART || finish == ON_RESTART) {
        throw new IllegalArgumentException("Can't start or finish in intermittent RESTART state");
    }
    if (finish == PRE_ON_CREATE && start != finish) {
        throw new IllegalArgumentException("Can only start in pre-onCreate state");
    }
    mLifecycleSequence.clear();
    if (finish >= start) {
        // just go there
        for (int i = start + 1; i <= finish; i++) {
            mLifecycleSequence.add(i);
        }
    } else {
        // finish < start, can't just cycle down
        if (start == ON_PAUSE && finish == ON_RESUME) {
            // Special case when we can just directly go to resumed state.
            mLifecycleSequence.add(ON_RESUME);
        } else if (start <= ON_STOP && finish >= ON_START) {
            // Go to stopped state first.
            for (int i = start + 1; i <= ON_STOP; i++) {
                mLifecycleSequence.add(i);
            }
            // Restart
            mLifecycleSequence.add(ON_RESTART);
            // Go to required state
            for (int i = ON_START; i <= finish; i++) {
                mLifecycleSequence.add(i);
            }
        } else {
            // Go to destroyed state first.
            for (int i = start + 1; i <= ON_DESTROY; i++) {
                mLifecycleSequence.add(i);
            }
            // Go to required state
            for (int i = ON_CREATE; i <= finish; i++) {
                mLifecycleSequence.add(i);
            }
        }
    }
    // Remove last transition in case we want to perform it with some specific params.
    if (excludeLastState && mLifecycleSequence.size() != 0) {
        mLifecycleSequence.remove(mLifecycleSequence.size() - 1);
    }
    return mLifecycleSequence;
}
Body of Second Method:
{
    if (start == UNDEFINED || finish == UNDEFINED) {
        throw new IllegalArgumentException("Can't resolve lifecycle path for undefined state");
    }
    if (start == ON_RESTART || finish == ON_RESTART) {
        throw new IllegalArgumentException("Can't start or finish in intermittent RESTART state");
    }
    if (finish == PRE_ON_CREATE && start != finish) {
        throw new IllegalArgumentException("Can only start in pre-onCreate state");
    }
    mLifecycleSequence.clear();
    if (finish >= start) {
        if (start == ON_START && finish == ON_STOP) {
            // A case when we from start to stop state soon, we don't need to go
            // through the resumed, paused state.
            mLifecycleSequence.add(ON_STOP);
        } else {
            // just go there
            for (int i = start + 1; i <= finish; i++) {
                mLifecycleSequence.add(i);
            }
        }
    } else {
        // finish < start, can't just cycle down
        if (start == ON_PAUSE && finish == ON_RESUME) {
            // Special case when we can just directly go to resumed state.
            mLifecycleSequence.add(ON_RESUME);
        } else if (start <= ON_STOP && finish >= ON_START) {
            // Go to stopped state first.
            for (int i = start + 1; i <= ON_STOP; i++) {
                mLifecycleSequence.add(i);
            }
            // Restart
            mLifecycleSequence.add(ON_RESTART);
            // Go to required state
            for (int i = ON_START; i <= finish; i++) {
                mLifecycleSequence.add(i);
            }
        } else {
            // Go to destroyed state first.
            for (int i = start + 1; i <= ON_DESTROY; i++) {
                mLifecycleSequence.add(i);
            }
            // Go to required state
            for (int i = ON_CREATE; i <= finish; i++) {
                mLifecycleSequence.add(i);
            }
        }
    }
    // Remove last transition in case we want to perform it with some specific params.
    if (excludeLastState && mLifecycleSequence.size() != 0) {
        mLifecycleSequence.remove(mLifecycleSequence.size() - 1);
    }
    return mLifecycleSequence;
}
------------------------

