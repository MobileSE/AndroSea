Find a silently evolved API code:android.content.pm.PackageItemInfo.loadLabel:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve the current textual label associated with this item.  This
 * will call back on the given PackageManager to load the label from
 * the application.
 *
 * @param pm A PackageManager from which the label can be loaded; usually
 * the PackageManager from which you originally retrieved this item.
 *
 * @return Returns a CharSequence containing the item's label.  If the
 * item does not have a label, its name is returned.
 */

Body of Frist Method:
{
    if (sForceSafeLabels && !Objects.equals(packageName, ActivityThread.currentPackageName())) {
        return loadSafeLabel(pm, DEFAULT_MAX_LABEL_SIZE_PX, SAFE_STRING_FLAG_TRIM | SAFE_STRING_FLAG_FIRST_LINE);
    } else {
        return loadUnsafeLabel(pm);
    }
}
Body of Second Method:
{
    if (sForceSafeLabels && !Objects.equals(packageName, ActivityThread.currentPackageName())) {
        return loadSafeLabel(pm, DEFAULT_MAX_LABEL_SIZE_PX, SAFE_STRING_FLAG_TRIM | SAFE_STRING_FLAG_FIRST_LINE);
    } else {
        // system is overwhelmed by an enormous string returned by the application.
        return TextUtils.trimToSize(loadUnsafeLabel(pm), MAX_SAFE_LABEL_LENGTH);
    }
}
------------------------
Find a silently evolved API code:android.widget.AdapterViewAnimator.setRemoteViewsOnClickHandler:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets up the onClickHandler to be used by the RemoteViewsAdapter when inflating RemoteViews
 *
 * @param handler The OnClickHandler to use when inflating RemoteViews.
 *
 * @hide
 */

Body of Frist Method:
{
    // service handling the specified intent.
    if (mRemoteViewsAdapter != null) {
        mRemoteViewsAdapter.setRemoteViewsOnClickHandler(handler);
    }
}
Body of Second Method:
{
    // service handling the specified intent.
    if (mRemoteViewsAdapter != null) {
        mRemoteViewsAdapter.setRemoteViewsInteractionHandler(handler);
    }
}
------------------------
Find a silently evolved API code:android.content.pm.parsing.PackageInfoWithoutStateUtils.generateServiceInfoUnchecked:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * This bypasses critical checks that are necessary for usage with data passed outside of
 * system server.
 *
 * Prefer {@link #generateServiceInfo(ParsingPackageRead, ParsedService, int, PackageUserState,
 * ApplicationInfo, int)}.
 */

Body of Frist Method:
{
    // Make shallow copies so we can store the metadata safely
    ServiceInfo si = new ServiceInfo();
    assignSharedFieldsForComponentInfo(si, s);
    si.exported = s.isExported();
    si.flags = s.getFlags();
    si.metaData = s.getMetaData();
    si.permission = s.getPermission();
    si.processName = s.getProcessName();
    si.mForegroundServiceType = s.getForegroundServiceType();
    si.applicationInfo = applicationInfo;
    return si;
}
Body of Second Method:
{
    // Make shallow copies so we can store the metadata safely
    ServiceInfo si = new ServiceInfo();
    assignSharedFieldsForComponentInfo(si, s);
    si.exported = s.isExported();
    si.flags = s.getFlags();
    si.permission = s.getPermission();
    si.processName = s.getProcessName();
    si.mForegroundServiceType = s.getForegroundServiceType();
    si.applicationInfo = applicationInfo;
    if ((flags & PackageManager.GET_META_DATA) != 0) {
        si.metaData = s.getMetaData();
    }
    return si;
}
------------------------
Find a silently evolved API code:android.media.ImageUtils.imageCopy:COMMENT
Method Modifier: public      static      
Comment:/**
 * <p>
 * Copy source image data to destination Image.
 * </p>
 * <p>
 * Only support the copy between two non-{@link ImageFormat#PRIVATE PRIVATE} format
 * images with same properties (format, size, etc.). The data from the
 * source image will be copied to the byteBuffers from the destination Image
 * starting from position zero, and the destination image will be rewound to
 * zero after copy is done.
 * </p>
 *
 * @param src The source image to be copied from.
 * @param dst The destination image to be copied to.
 * @throws IllegalArgumentException If the source and destination images
 * have different format, or one of the images is not copyable.
 */

Body of Frist Method:
{
    if (src == null || dst == null) {
        throw new IllegalArgumentException("Images should be non-null");
    }
    if (src.getFormat() != dst.getFormat()) {
        throw new IllegalArgumentException("Src and dst images should have the same format");
    }
    if (src.getFormat() == ImageFormat.PRIVATE || dst.getFormat() == ImageFormat.PRIVATE) {
        throw new IllegalArgumentException("PRIVATE format images are not copyable");
    }
    if (src.getFormat() == ImageFormat.RAW_PRIVATE) {
        throw new IllegalArgumentException("Copy of RAW_OPAQUE format has not been implemented");
    }
    if (src.getFormat() == ImageFormat.RAW_DEPTH) {
        throw new IllegalArgumentException("Copy of RAW_DEPTH format has not been implemented");
    }
    if (!(dst.getOwner() instanceof ImageWriter)) {
        throw new IllegalArgumentException("Destination image is not from ImageWriter. Only" + " the images from ImageWriter are writable");
    }
    Size srcSize = new Size(src.getWidth(), src.getHeight());
    Size dstSize = new Size(dst.getWidth(), dst.getHeight());
    if (!srcSize.equals(dstSize)) {
        throw new IllegalArgumentException("source image size " + srcSize + " is different" + " with " + "destination image size " + dstSize);
    }
    Plane[] srcPlanes = src.getPlanes();
    Plane[] dstPlanes = dst.getPlanes();
    ByteBuffer srcBuffer = null;
    ByteBuffer dstBuffer = null;
    for (int i = 0; i < srcPlanes.length; i++) {
        int srcRowStride = srcPlanes[i].getRowStride();
        int dstRowStride = dstPlanes[i].getRowStride();
        srcBuffer = srcPlanes[i].getBuffer();
        dstBuffer = dstPlanes[i].getBuffer();
        if (!(srcBuffer.isDirect() && dstBuffer.isDirect())) {
            throw new IllegalArgumentException("Source and destination ByteBuffers must be" + " direct byteBuffer!");
        }
        if (srcPlanes[i].getPixelStride() != dstPlanes[i].getPixelStride()) {
            throw new IllegalArgumentException("Source plane image pixel stride " + srcPlanes[i].getPixelStride() + " must be same as destination image pixel stride " + dstPlanes[i].getPixelStride());
        }
        int srcPos = srcBuffer.position();
        srcBuffer.rewind();
        dstBuffer.rewind();
        if (srcRowStride == dstRowStride) {
            // Fast path, just copy the content if the byteBuffer all together.
            dstBuffer.put(srcBuffer);
        } else {
            // Source and destination images may have different alignment requirements,
            // therefore may have different strides. Copy row by row for such case.
            int srcOffset = srcBuffer.position();
            int dstOffset = dstBuffer.position();
            Size effectivePlaneSize = getEffectivePlaneSizeForImage(src, i);
            int srcByteCount = effectivePlaneSize.getWidth() * srcPlanes[i].getPixelStride();
            for (int row = 0; row < effectivePlaneSize.getHeight(); row++) {
                if (row == effectivePlaneSize.getHeight() - 1) {
                    // Special case for NV21 backed YUV420_888: need handle the last row
                    // carefully to avoid memory corruption. Check if we have enough bytes to
                    // copy.
                    int remainingBytes = srcBuffer.remaining() - srcOffset;
                    if (srcByteCount > remainingBytes) {
                        srcByteCount = remainingBytes;
                    }
                }
                directByteBufferCopy(srcBuffer, srcOffset, dstBuffer, dstOffset, srcByteCount);
                srcOffset += srcRowStride;
                dstOffset += dstRowStride;
            }
        }
        srcBuffer.position(srcPos);
        dstBuffer.rewind();
    }
}
Body of Second Method:
{
    if (src == null || dst == null) {
        throw new IllegalArgumentException("Images should be non-null");
    }
    if (src.getFormat() != dst.getFormat()) {
        throw new IllegalArgumentException("Src and dst images should have the same format");
    }
    if (src.getFormat() == ImageFormat.PRIVATE || dst.getFormat() == ImageFormat.PRIVATE) {
        throw new IllegalArgumentException("PRIVATE format images are not copyable");
    }
    if (src.getFormat() == ImageFormat.RAW_PRIVATE) {
        throw new IllegalArgumentException("Copy of RAW_OPAQUE format has not been implemented");
    }
    if (src.getFormat() == ImageFormat.RAW_DEPTH) {
        throw new IllegalArgumentException("Copy of RAW_DEPTH format has not been implemented");
    }
    if (src.getFormat() == ImageFormat.RAW_DEPTH10) {
        throw new IllegalArgumentException("Copy of RAW_DEPTH10 format has not been implemented");
    }
    if (!(dst.getOwner() instanceof ImageWriter)) {
        throw new IllegalArgumentException("Destination image is not from ImageWriter. Only" + " the images from ImageWriter are writable");
    }
    Size srcSize = new Size(src.getWidth(), src.getHeight());
    Size dstSize = new Size(dst.getWidth(), dst.getHeight());
    if (!srcSize.equals(dstSize)) {
        throw new IllegalArgumentException("source image size " + srcSize + " is different" + " with " + "destination image size " + dstSize);
    }
    Plane[] srcPlanes = src.getPlanes();
    Plane[] dstPlanes = dst.getPlanes();
    ByteBuffer srcBuffer = null;
    ByteBuffer dstBuffer = null;
    for (int i = 0; i < srcPlanes.length; i++) {
        int srcRowStride = srcPlanes[i].getRowStride();
        int dstRowStride = dstPlanes[i].getRowStride();
        srcBuffer = srcPlanes[i].getBuffer();
        dstBuffer = dstPlanes[i].getBuffer();
        if (!(srcBuffer.isDirect() && dstBuffer.isDirect())) {
            throw new IllegalArgumentException("Source and destination ByteBuffers must be" + " direct byteBuffer!");
        }
        if (srcPlanes[i].getPixelStride() != dstPlanes[i].getPixelStride()) {
            throw new IllegalArgumentException("Source plane image pixel stride " + srcPlanes[i].getPixelStride() + " must be same as destination image pixel stride " + dstPlanes[i].getPixelStride());
        }
        int srcPos = srcBuffer.position();
        srcBuffer.rewind();
        dstBuffer.rewind();
        if (srcRowStride == dstRowStride) {
            // Fast path, just copy the content if the byteBuffer all together.
            dstBuffer.put(srcBuffer);
        } else {
            // Source and destination images may have different alignment requirements,
            // therefore may have different strides. Copy row by row for such case.
            int srcOffset = srcBuffer.position();
            int dstOffset = dstBuffer.position();
            Size effectivePlaneSize = getEffectivePlaneSizeForImage(src, i);
            int srcByteCount = effectivePlaneSize.getWidth() * srcPlanes[i].getPixelStride();
            for (int row = 0; row < effectivePlaneSize.getHeight(); row++) {
                if (row == effectivePlaneSize.getHeight() - 1) {
                    // Special case for NV21 backed YUV420_888: need handle the last row
                    // carefully to avoid memory corruption. Check if we have enough bytes to
                    // copy.
                    int remainingBytes = srcBuffer.remaining() - srcOffset;
                    if (srcByteCount > remainingBytes) {
                        srcByteCount = remainingBytes;
                    }
                }
                directByteBufferCopy(srcBuffer, srcOffset, dstBuffer, dstOffset, srcByteCount);
                srcOffset += srcRowStride;
                dstOffset += dstRowStride;
            }
        }
        srcBuffer.position(srcPos);
        dstBuffer.rewind();
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothAvrcpController.getDevicesMatchingConnectionStates:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (VDBG)
        log("getDevicesMatchingStates()");
    final IBluetoothAvrcpController service = getService();
    if (service != null && isEnabled()) {
        try {
            return service.getDevicesMatchingConnectionStates(states);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
Body of Second Method:
{
    if (VDBG)
        log("getDevicesMatchingStates()");
    final IBluetoothAvrcpController service = getService();
    if (service != null && isEnabled()) {
        try {
            return Attributable.setAttributionSource(service.getDevicesMatchingConnectionStates(states, mAttributionSource), mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothAvrcpController.getConnectionState:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (VDBG)
        log("getState(" + device + ")");
    final IBluetoothAvrcpController service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getConnectionState(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.STATE_DISCONNECTED;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return BluetoothProfile.STATE_DISCONNECTED;
}
Body of Second Method:
{
    if (VDBG)
        log("getState(" + device + ")");
    final IBluetoothAvrcpController service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getConnectionState(device, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.STATE_DISCONNECTED;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return BluetoothProfile.STATE_DISCONNECTED;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothManager.getConnectedDevices:COMMENT
Method Modifier: public      
Comment:/**
 * Get connected devices for the specified profile.
 *
 * <p> Return the set of devices which are in state {@link BluetoothProfile#STATE_CONNECTED}
 *
 * <p>This is not specific to any application configuration but represents
 * the connection state of Bluetooth for this profile.
 * This can be used by applications like status bar which would just like
 * to know the state of Bluetooth.
 *
 * @param profile GATT or GATT_SERVER
 * @return List of devices. The list will be empty on error.
 */

Body of Frist Method:
{
    if (DBG)
        Log.d(TAG, "getConnectedDevices");
    if (profile != BluetoothProfile.GATT && profile != BluetoothProfile.GATT_SERVER) {
        throw new IllegalArgumentException("Profile not supported: " + profile);
    }
    List<BluetoothDevice> connectedDevices = new ArrayList<BluetoothDevice>();
    try {
        IBluetoothManager managerService = mAdapter.getBluetoothManager();
        IBluetoothGatt iGatt = managerService.getBluetoothGatt();
        if (iGatt == null)
            return connectedDevices;
        connectedDevices = iGatt.getDevicesMatchingConnectionStates(new int[] { BluetoothProfile.STATE_CONNECTED });
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return connectedDevices;
}
Body of Second Method:
{
    if (DBG)
        Log.d(TAG, "getConnectedDevices");
    return getDevicesMatchingConnectionStates(profile, new int[] { BluetoothProfile.STATE_CONNECTED });
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadset.setAudioRouteAllowed:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets whether audio routing is allowed. When set to {@code false}, the AG will not route any
 * audio to the HF unless explicitly told to.
 * This method should be used in cases where the SCO channel is shared between multiple profiles
 * and must be delegated by a source knowledgeable
 * Note: This is an internal function and shouldn't be exposed
 *
 * @param allowed {@code true} if the profile can reroute audio, {@code false} otherwise.
 * @hide
 */

Body of Frist Method:
{
    if (VDBG)
        log("setAudioRouteAllowed");
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled()) {
        try {
            service.setAudioRouteAllowed(allowed);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
}
Body of Second Method:
{
    if (VDBG)
        log("setAudioRouteAllowed");
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled()) {
        try {
            service.setAudioRouteAllowed(allowed, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
}
------------------------
Find a silently evolved API code:android.location.GnssCapabilities.hasLowPowerMode:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns {@code true} if GNSS chipset supports low power mode, {@code false} otherwise.
 *
 * @hide
 */

Body of Frist Method:
{
    return hasCapability(LOW_POWER_MODE);
}
Body of Second Method:
{
    return (mTopFlags & TOP_HAL_CAPABILITY_LOW_POWER_MODE) != 0;
}
------------------------
Find a silently evolved API code:android.content.ContentProviderClient.query:COMMENT
Method Modifier: public      
Comment:/**
 * See {@link ContentProvider#query ContentProvider.query}
 */

Body of Frist Method:
{
    return query(url, projection, selection, selectionArgs, sortOrder, null);
}
Body of Second Method:
{
    Objects.requireNonNull(uri, "url");
    beforeRemote();
    try {
        ICancellationSignal remoteCancellationSignal = null;
        if (cancellationSignal != null) {
            cancellationSignal.throwIfCanceled();
            remoteCancellationSignal = mContentProvider.createCancellationSignal();
            cancellationSignal.setRemote(remoteCancellationSignal);
        }
        final Cursor cursor = mContentProvider.query(mAttributionSource, uri, projection, queryArgs, remoteCancellationSignal);
        if (cursor == null) {
            return null;
        }
        return new CursorWrapperInner(cursor);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothA2dp.enableDisableOptionalCodecs:COMMENT
Method Modifier: private     
Comment:/**
 * Enables or disables the optional codecs.
 *
 * @param device the remote Bluetooth device. If null, use the currect
 * active A2DP Bluetooth device.
 * @param enable if true, enable the optional codecs, other disable them
 */

Body of Frist Method:
{
    try {
        final IBluetoothA2dp service = getService();
        if (service != null && isEnabled()) {
            if (enable) {
                service.enableOptionalCodecs(device);
            } else {
                service.disableOptionalCodecs(device);
            }
        }
        if (service == null)
            Log.w(TAG, "Proxy not attached to service");
        return;
    } catch (RemoteException e) {
        Log.e(TAG, "Error talking to BT service in enableDisableOptionalCodecs()", e);
        return;
    }
}
Body of Second Method:
{
    try {
        final IBluetoothA2dp service = getService();
        if (service != null && isEnabled()) {
            if (enable) {
                service.enableOptionalCodecs(device, mAttributionSource);
            } else {
                service.disableOptionalCodecs(device, mAttributionSource);
            }
        }
        if (service == null)
            Log.w(TAG, "Proxy not attached to service");
        return;
    } catch (RemoteException e) {
        Log.e(TAG, "Error talking to BT service in enableDisableOptionalCodecs()", e);
        return;
    }
}
------------------------
Find a silently evolved API code:android.os.Looper.loop:COMMENT
Method Modifier: public      static      
Comment:/**
 * Run the message queue in this thread. Be sure to call
 * {@link #quit()} to end the loop.
 */

Body of Frist Method:
{
    final Looper me = myLooper();
    if (me == null) {
        throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread.");
    }
    if (me.mInLoop) {
        Slog.w(TAG, "Loop again would have the queued messages be executed" + " before this one completed.");
    }
    me.mInLoop = true;
    final MessageQueue queue = me.mQueue;
    // Make sure the identity of this thread is that of the local process,
    // and keep track of what that identity token actually is.
    Binder.clearCallingIdentity();
    final long ident = Binder.clearCallingIdentity();
    // Allow overriding a threshold with a system prop. e.g.
    // adb shell 'setprop log.looper.1000.main.slow 1 && stop && start'
    final int thresholdOverride = SystemProperties.getInt("log.looper." + Process.myUid() + "." + Thread.currentThread().getName() + ".slow", 0);
    boolean slowDeliveryDetected = false;
    for (; ; ) {
        // might block
        Message msg = queue.next();
        if (msg == null) {
            // No message indicates that the message queue is quitting.
            return;
        }
        // This must be in a local variable, in case a UI event sets the logger
        final Printer logging = me.mLogging;
        if (logging != null) {
            logging.println(">>>>> Dispatching to " + msg.target + " " + msg.callback + ": " + msg.what);
        }
        // Make sure the observer won't change while processing a transaction.
        final Observer observer = sObserver;
        final long traceTag = me.mTraceTag;
        long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;
        long slowDeliveryThresholdMs = me.mSlowDeliveryThresholdMs;
        if (thresholdOverride > 0) {
            slowDispatchThresholdMs = thresholdOverride;
            slowDeliveryThresholdMs = thresholdOverride;
        }
        final boolean logSlowDelivery = (slowDeliveryThresholdMs > 0) && (msg.when > 0);
        final boolean logSlowDispatch = (slowDispatchThresholdMs > 0);
        final boolean needStartTime = logSlowDelivery || logSlowDispatch;
        final boolean needEndTime = logSlowDispatch;
        if (traceTag != 0 && Trace.isTagEnabled(traceTag)) {
            Trace.traceBegin(traceTag, msg.target.getTraceName(msg));
        }
        final long dispatchStart = needStartTime ? SystemClock.uptimeMillis() : 0;
        final long dispatchEnd;
        Object token = null;
        if (observer != null) {
            token = observer.messageDispatchStarting();
        }
        long origWorkSource = ThreadLocalWorkSource.setUid(msg.workSourceUid);
        try {
            msg.target.dispatchMessage(msg);
            if (observer != null) {
                observer.messageDispatched(token, msg);
            }
            dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0;
        } catch (Exception exception) {
            if (observer != null) {
                observer.dispatchingThrewException(token, msg, exception);
            }
            throw exception;
        } finally {
            ThreadLocalWorkSource.restore(origWorkSource);
            if (traceTag != 0) {
                Trace.traceEnd(traceTag);
            }
        }
        if (logSlowDelivery) {
            if (slowDeliveryDetected) {
                if ((dispatchStart - msg.when) <= 10) {
                    Slog.w(TAG, "Drained");
                    slowDeliveryDetected = false;
                }
            } else {
                if (showSlowLog(slowDeliveryThresholdMs, msg.when, dispatchStart, "delivery", msg)) {
                    // Once we write a slow delivery log, suppress until the queue drains.
                    slowDeliveryDetected = true;
                }
            }
        }
        if (logSlowDispatch) {
            showSlowLog(slowDispatchThresholdMs, dispatchStart, dispatchEnd, "dispatch", msg);
        }
        if (logging != null) {
            logging.println("<<<<< Finished to " + msg.target + " " + msg.callback);
        }
        // Make sure that during the course of dispatching the
        // identity of the thread wasn't corrupted.
        final long newIdent = Binder.clearCallingIdentity();
        if (ident != newIdent) {
            Log.wtf(TAG, "Thread identity changed from 0x" + Long.toHexString(ident) + " to 0x" + Long.toHexString(newIdent) + " while dispatching to " + msg.target.getClass().getName() + " " + msg.callback + " what=" + msg.what);
        }
        msg.recycleUnchecked();
    }
}
Body of Second Method:
{
    final Looper me = myLooper();
    if (me == null) {
        throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread.");
    }
    if (me.mInLoop) {
        Slog.w(TAG, "Loop again would have the queued messages be executed" + " before this one completed.");
    }
    me.mInLoop = true;
    // Make sure the identity of this thread is that of the local process,
    // and keep track of what that identity token actually is.
    Binder.clearCallingIdentity();
    final long ident = Binder.clearCallingIdentity();
    // Allow overriding a threshold with a system prop. e.g.
    // adb shell 'setprop log.looper.1000.main.slow 1 && stop && start'
    final int thresholdOverride = SystemProperties.getInt("log.looper." + Process.myUid() + "." + Thread.currentThread().getName() + ".slow", 0);
    me.mSlowDeliveryDetected = false;
    for (; ; ) {
        if (!loopOnce(me, ident, thresholdOverride)) {
            return;
        }
    }
}
------------------------
Find a silently evolved API code:android.media.AudioFormat.Builder.setEncoding:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the data encoding format.
 * @param encoding the specified encoding or default.
 * @return the same Builder instance.
 * @throws java.lang.IllegalArgumentException
 */

Body of Frist Method:
{
    switch(encoding) {
        case ENCODING_DEFAULT:
            mEncoding = ENCODING_PCM_16BIT;
            break;
        case ENCODING_PCM_16BIT:
        case ENCODING_PCM_8BIT:
        case ENCODING_PCM_FLOAT:
        case ENCODING_AC3:
        case ENCODING_E_AC3:
        case ENCODING_DTS:
        case ENCODING_DTS_HD:
        case ENCODING_MP3:
        case ENCODING_AAC_LC:
        case ENCODING_AAC_HE_V1:
        case ENCODING_AAC_HE_V2:
        case ENCODING_IEC61937:
        case ENCODING_DOLBY_TRUEHD:
        case ENCODING_AAC_ELD:
        case ENCODING_AAC_XHE:
        case ENCODING_AC4:
        case ENCODING_E_AC3_JOC:
        case ENCODING_DOLBY_MAT:
        case ENCODING_OPUS:
            mEncoding = encoding;
            break;
        case ENCODING_INVALID:
        default:
            throw new IllegalArgumentException("Invalid encoding " + encoding);
    }
    mPropertySetMask |= AUDIO_FORMAT_HAS_PROPERTY_ENCODING;
    return this;
}
Body of Second Method:
{
    switch(encoding) {
        case ENCODING_DEFAULT:
            mEncoding = ENCODING_PCM_16BIT;
            break;
        case ENCODING_PCM_16BIT:
        case ENCODING_PCM_8BIT:
        case ENCODING_PCM_FLOAT:
        case ENCODING_AC3:
        case ENCODING_E_AC3:
        case ENCODING_DTS:
        case ENCODING_DTS_HD:
        case ENCODING_MP3:
        case ENCODING_AAC_LC:
        case ENCODING_AAC_HE_V1:
        case ENCODING_AAC_HE_V2:
        case ENCODING_IEC61937:
        case ENCODING_DOLBY_TRUEHD:
        case ENCODING_AAC_ELD:
        case ENCODING_AAC_XHE:
        case ENCODING_AC4:
        case ENCODING_E_AC3_JOC:
        case ENCODING_DOLBY_MAT:
        case ENCODING_OPUS:
        case ENCODING_PCM_24BIT_PACKED:
        case ENCODING_PCM_32BIT:
        case ENCODING_MPEGH_BL_L3:
        case ENCODING_MPEGH_BL_L4:
        case ENCODING_MPEGH_LC_L3:
        case ENCODING_MPEGH_LC_L4:
        case ENCODING_DTS_UHD:
        case ENCODING_DRA:
            mEncoding = encoding;
            break;
        case ENCODING_INVALID:
        default:
            throw new IllegalArgumentException("Invalid encoding " + encoding);
    }
    mPropertySetMask |= AUDIO_FORMAT_HAS_PROPERTY_ENCODING;
    return this;
}
------------------------
Find a silently evolved API code:android.graphics.text.MeasuredText.getWidth:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the width of a given range.
 *
 * @param start an inclusive start index of the range
 * @param end an exclusive end index of the range
 */

Body of Frist Method:
{
    Preconditions.checkArgument(0 <= start && start <= mChars.length, "start(" + start + ") must be 0 <= start <= " + mChars.length);
    Preconditions.checkArgument(0 <= end && end <= mChars.length, "end(" + end + ") must be 0 <= end <= " + mChars.length);
    Preconditions.checkArgument(start <= end, "start(" + start + ") is larger than end(" + end + ")");
    return nGetWidth(mNativePtr, start, end);
}
Body of Second Method:
{
    Preconditions.checkArgument(0 <= start && start <= mChars.length, "start(%d) must be 0 <= start <= %d", start, mChars.length);
    Preconditions.checkArgument(0 <= end && end <= mChars.length, "end(%d) must be 0 <= end <= %d", end, mChars.length);
    Preconditions.checkArgument(start <= end, "start(%d) is larger than end(%d)", start, end);
    return nGetWidth(mNativePtr, start, end);
}
------------------------
Find a silently evolved API code:android.view.WindowInsets.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Builds a {@link WindowInsets} instance.
 *
 * @return the {@link WindowInsets} instance.
 */

Body of Frist Method:
{
    return new WindowInsets(mSystemInsetsConsumed ? null : mTypeInsetsMap, mStableInsetsConsumed ? null : mTypeMaxInsetsMap, mTypeVisibilityMap, mIsRound, mAlwaysConsumeSystemBars, mDisplayCutout, systemBars(), false);
}
Body of Second Method:
{
    return new WindowInsets(mSystemInsetsConsumed ? null : mTypeInsetsMap, mStableInsetsConsumed ? null : mTypeMaxInsetsMap, mTypeVisibilityMap, mIsRound, mAlwaysConsumeSystemBars, mDisplayCutout, mRoundedCorners, mPrivacyIndicatorBounds, systemBars(), false);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.acceptCall:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Accepts a call
 *
 * @param device remote device
 * @param flag action policy while accepting a call. Possible values {@link #CALL_ACCEPT_NONE},
 * {@link #CALL_ACCEPT_HOLD}, {@link #CALL_ACCEPT_TERMINATE}
 * @return <code>true</code> if command has been issued successfully; <code>false</code>
 * otherwise; upon completion HFP sends {@link #ACTION_CALL_CHANGED} intent.
 */

Body of Frist Method:
{
    if (DBG)
        log("acceptCall()");
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.acceptCall(device, flag);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("acceptCall()");
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.acceptCall(device, flag, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.hardware.hdmi.HdmiDeviceInfo.writeToParcel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Serializes this object into a {@link Parcel}.
 *
 * @param dest The Parcel in which the object should be written.
 * @param flags Additional flags about how the object should be written. May be 0 or
 * {@link Parcelable#PARCELABLE_WRITE_RETURN_VALUE}.
 */

Body of Frist Method:
{
    dest.writeInt(mHdmiDeviceType);
    dest.writeInt(mPhysicalAddress);
    dest.writeInt(mPortId);
    switch(mHdmiDeviceType) {
        case HDMI_DEVICE_TYPE_CEC:
            dest.writeInt(mLogicalAddress);
            dest.writeInt(mDeviceType);
            dest.writeInt(mVendorId);
            dest.writeInt(mDevicePowerStatus);
            dest.writeString(mDisplayName);
            break;
        case HDMI_DEVICE_TYPE_MHL:
            dest.writeInt(mDeviceId);
            dest.writeInt(mAdopterId);
            break;
        case HDMI_DEVICE_TYPE_INACTIVE:
        // flow through
        default:
    }
}
Body of Second Method:
{
    dest.writeInt(mHdmiDeviceType);
    dest.writeInt(mPhysicalAddress);
    dest.writeInt(mPortId);
    switch(mHdmiDeviceType) {
        case HDMI_DEVICE_TYPE_CEC:
            dest.writeInt(mLogicalAddress);
            dest.writeInt(mDeviceType);
            dest.writeInt(mVendorId);
            dest.writeInt(mDevicePowerStatus);
            dest.writeString(mDisplayName);
            dest.writeInt(mHdmiCecVersion);
            break;
        case HDMI_DEVICE_TYPE_MHL:
            dest.writeInt(mDeviceId);
            dest.writeInt(mAdopterId);
            break;
        case HDMI_DEVICE_TYPE_INACTIVE:
        // flow through
        default:
    }
}
------------------------
Find a silently evolved API code:android.timezone.TzDataSetVersion.isCompatibleWithThisDevice:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Returns true if the version information provided would be compatible with this device, i.e.
 * with the current system image, and set of active modules.
 */

Body of Frist Method:
{
    return libcore.timezone.TzDataSetVersion.isCompatibleWithThisDevice(tzDataSetVersion.mDelegate);
}
Body of Second Method:
{
    return com.android.i18n.timezone.TzDataSetVersion.isCompatibleWithThisDevice(tzDataSetVersion.mDelegate);
}
------------------------
Find a silently evolved API code:android.nfc.NfcAdapter.isSecureNfcSupported:COMMENT
Method Modifier: public      
Comment:/**
 * Checks if the device supports Secure NFC functionality.
 *
 * @return True if device supports Secure NFC, false otherwise
 * @throws UnsupportedOperationException if FEATURE_NFC is unavailable.
 */

Body of Frist Method:
{
    if (!sHasNfcFeature) {
        throw new UnsupportedOperationException();
    }
    try {
        return sService.deviceSupportsNfcSecure();
    } catch (RemoteException e) {
        attemptDeadServiceRecovery(e);
        return false;
    }
}
Body of Second Method:
{
    if (!sHasNfcFeature) {
        throw new UnsupportedOperationException();
    }
    try {
        return sService.deviceSupportsNfcSecure();
    } catch (RemoteException e) {
        attemptDeadServiceRecovery(e);
        // Try one more time
        if (sService == null) {
            Log.e(TAG, "Failed to recover NFC Service.");
            return false;
        }
        try {
            return sService.deviceSupportsNfcSecure();
        } catch (RemoteException ee) {
            Log.e(TAG, "Failed to recover NFC Service.");
        }
        return false;
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothDevice.getPhonebookAccessPermission:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Gets whether the phonebook access is allowed for this bluetooth device
 *
 * @return Whether the phonebook access is allowed to this device. Can be {@link
 * #ACCESS_UNKNOWN}, {@link #ACCESS_ALLOWED} or {@link #ACCESS_REJECTED}.
 * @hide
 */

Body of Frist Method:
{
    final IBluetooth service = sService;
    if (service == null) {
        return ACCESS_UNKNOWN;
    }
    try {
        return service.getPhonebookAccessPermission(this);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return ACCESS_UNKNOWN;
}
Body of Second Method:
{
    final IBluetooth service = sService;
    if (service == null) {
        return ACCESS_UNKNOWN;
    }
    try {
        return service.getPhonebookAccessPermission(this, mAttributionSource);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return ACCESS_UNKNOWN;
}
------------------------
Find a silently evolved API code:android.content.pm.ShortcutManager.getManifestShortcuts:COMMENT
Method Modifier: public      
Comment:/**
 * Return all static (manifest) shortcuts from the caller app.
 *
 * <p>This API is intended to be used for examining what shortcuts are currently published.
 * Re-publishing returned {@link ShortcutInfo}s via APIs such as
 * {@link #setDynamicShortcuts(List)} may cause loss of information such as icons.
 *
 * @throws IllegalStateException when the user is locked.
 */

Body of Frist Method:
{
    try {
        return mService.getShortcuts(mContext.getPackageName(), FLAG_MATCH_MANIFEST, injectMyUserId()).getList();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    try {
        return getFutureOrThrow(mService.getShortcuts(mContext.getPackageName(), FLAG_MATCH_MANIFEST, injectMyUserId())).getList();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothA2dpSink.getDevicesMatchingConnectionStates:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * {@inheritDoc}
 *
 * @hide
 */

Body of Frist Method:
{
    if (VDBG)
        log("getDevicesMatchingStates()");
    final IBluetoothA2dpSink service = getService();
    if (service != null && isEnabled()) {
        try {
            return service.getDevicesMatchingConnectionStates(states);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
Body of Second Method:
{
    if (VDBG)
        log("getDevicesMatchingStates()");
    final IBluetoothA2dpSink service = getService();
    if (service != null && isEnabled()) {
        try {
            return Attributable.setAttributionSource(service.getDevicesMatchingConnectionStates(states, mAttributionSource), mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
------------------------
Find a silently evolved API code:android.os.PersistableBundle.saveToXml:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    unparcel();
    XmlUtils.writeMapXml(mMap, out, this);
}
Body of Second Method:
{
    saveToXml(XmlUtils.makeTyped(out));
}
------------------------
Find a silently evolved API code:android.content.pm.ShortcutManager.requestPinShortcut:COMMENT
Method Modifier: public      
Comment:/**
 * Request to create a pinned shortcut.  The default launcher will receive this request and
 * ask the user for approval.  If the user approves it, the shortcut will be created, and
 * {@code resultIntent} will be sent. If a request is denied by the user, however, no response
 * will be sent to the caller.
 *
 * <p>Only apps with a foreground activity or a foreground service can call this method.
 * Otherwise, it'll throw {@link IllegalStateException}.
 *
 * <p>It's up to the launcher to decide how to handle previous pending requests when the same
 * package calls this API multiple times in a row. One possible strategy is to ignore any
 * previous requests.
 *
 * <p><b>Note:</b> See also the support library counterpart
 * {@link android.support.v4.content.pm.ShortcutManagerCompat#requestPinShortcut(
 * Context, ShortcutInfoCompat, IntentSender)},
 * which supports Android versions lower than {@link VERSION_CODES#O} using the
 * legacy private intent {@code com.android.launcher.action.INSTALL_SHORTCUT}.
 *
 * @param shortcut Shortcut to pin.  If an app wants to pin an existing (either static
 * or dynamic) shortcut, then it only needs to have an ID. Although other fields don't have
 * to be set, the target shortcut must be enabled.
 *
 * <p>If it's a new shortcut, all the mandatory fields, such as a short label, must be
 * set.
 * @param resultIntent If not null, this intent will be sent when the shortcut is pinned.
 * Use {@link android.app.PendingIntent#getIntentSender()} to create an {@link IntentSender}.
 * To avoid background execution limits, use an unexported, manifest-declared receiver.
 * For more details, see
 * <a href="/guide/topics/ui/shortcuts/creating-shortcuts.html#pinned">
 * Creating pinned shortcuts</a>.
 *
 * @return {@code TRUE} if the launcher supports this feature.  Note the API will return without
 * waiting for the user to respond, so getting {@code TRUE} from this API does *not* mean
 * the shortcut was pinned successfully.  {@code FALSE} if the launcher doesn't support this
 * feature.
 *
 * @see #isRequestPinShortcutSupported()
 * @see IntentSender
 * @see android.app.PendingIntent#getIntentSender()
 *
 * @throws IllegalArgumentException if a shortcut with the same ID exists and is disabled.
 * @throws IllegalStateException The caller doesn't have a foreground activity or a foreground
 * service, or the device is locked.
 */

Body of Frist Method:
{
    try {
        return mService.requestPinShortcut(mContext.getPackageName(), shortcut, resultIntent, injectMyUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    try {
        return (boolean) getFutureOrThrow(mService.requestPinShortcut(mContext.getPackageName(), shortcut, resultIntent, injectMyUserId()));
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.terminateCall:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Terminates a specified call.
 *
 * Works only when Extended Call Control is supported by Audio Gateway.
 *
 * @param device remote device
 * @param call Handle of call obtained in {@link #dial(BluetoothDevice, String)} or obtained via
 * {@link #ACTION_CALL_CHANGED}. {@code call} may be null in which case we will hangup all active
 * calls.
 * @return <code>true</code> if command has been issued successfully; <code>false</code>
 * otherwise; upon completion HFP sends {@link #ACTION_CALL_CHANGED} intent.
 *
 * <p>Feature required for successful execution is being reported by: {@link
 * #EXTRA_AG_FEATURE_ECC}. This method invocation will fail silently when feature is not
 * supported.</p>
 */

Body of Frist Method:
{
    if (DBG)
        log("terminateCall()");
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.terminateCall(device, call);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("terminateCall()");
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.terminateCall(device, call, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.view.inputmethod.CursorAnchorInfo.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * @return {@link CursorAnchorInfo} using parameters in this {@link Builder}.
 * @throws IllegalArgumentException if one or more positional parameters are specified but
 * the coordinate transformation matrix is not provided via {@link #setMatrix(Matrix)}.
 */

Body of Frist Method:
{
    if (!mMatrixInitialized) {
        // Coordinate transformation matrix is mandatory when at least one positional
        // parameter is specified.
        final boolean hasCharacterBounds = (mCharacterBoundsArrayBuilder != null && !mCharacterBoundsArrayBuilder.isEmpty());
        if (hasCharacterBounds || !Float.isNaN(mInsertionMarkerHorizontal) || !Float.isNaN(mInsertionMarkerTop) || !Float.isNaN(mInsertionMarkerBaseline) || !Float.isNaN(mInsertionMarkerBottom)) {
            throw new IllegalArgumentException("Coordinate transformation matrix is " + "required when positional parameters are specified.");
        }
    }
    return CursorAnchorInfo.create(this);
}
Body of Second Method:
{
    if (!mMatrixInitialized) {
        // Coordinate transformation matrix is mandatory when at least one positional
        // parameter is specified.
        final boolean hasCharacterBounds = (mCharacterBoundsArrayBuilder != null && !mCharacterBoundsArrayBuilder.isEmpty());
        if (hasCharacterBounds || !Float.isNaN(mInsertionMarkerHorizontal) || !Float.isNaN(mInsertionMarkerTop) || !Float.isNaN(mInsertionMarkerBaseline) || !Float.isNaN(mInsertionMarkerBottom)) {
            throw new IllegalArgumentException("Coordinate transformation matrix is " + "required when positional parameters are specified.");
        }
    }
    return new CursorAnchorInfo(this);
}
------------------------
Find a silently evolved API code:android.media.AudioPlaybackConfiguration.toLogFriendlyPlayerState:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    switch(state) {
        case PLAYER_STATE_UNKNOWN:
            return "unknown";
        case PLAYER_STATE_RELEASED:
            return "released";
        case PLAYER_STATE_IDLE:
            return "idle";
        case PLAYER_STATE_STARTED:
            return "started";
        case PLAYER_STATE_PAUSED:
            return "paused";
        case PLAYER_STATE_STOPPED:
            return "stopped";
        default:
            return "unknown player state - FIXME";
    }
}
Body of Second Method:
{
    switch(state) {
        case PLAYER_STATE_UNKNOWN:
            return "unknown";
        case PLAYER_STATE_RELEASED:
            return "released";
        case PLAYER_STATE_IDLE:
            return "idle";
        case PLAYER_STATE_STARTED:
            return "started";
        case PLAYER_STATE_PAUSED:
            return "paused";
        case PLAYER_STATE_STOPPED:
            return "stopped";
        case PLAYER_UPDATE_DEVICE_ID:
            return "device";
        default:
            return "unknown player state - FIXME";
    }
}
------------------------
Find a silently evolved API code:android.widget.ToggleButton.setTextOff:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the text for when the button is not in the checked state.
 *
 * @param textOff The text.
 */

Body of Frist Method:
{
    mTextOff = textOff;
    // Default state is derived from on/off-text, so state has to be updated when on/off-text
    // are updated.
    setDefaultStateDescritption();
}
Body of Second Method:
{
    mTextOff = textOff;
    // Default state is derived from on/off-text, so state has to be updated when on/off-text
    // are updated.
    setDefaultStateDescription();
}
------------------------
Find a silently evolved API code:android.net.VpnService.prepareAndAuthorize:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Version of {@link #prepare(Context)} which does not require user consent.
 *
 * <p>Requires {@link android.Manifest.permission#CONTROL_VPN} and should generally not be
 * used. Only acceptable in situations where user consent has been obtained through other means.
 *
 * <p>Once this is run, future preparations may be done with the standard prepare method as this
 * will authorize the package to prepare the VPN without consent in the future.
 *
 * @hide
 */

Body of Frist Method:
{
    IConnectivityManager cm = getService();
    String packageName = context.getPackageName();
    try {
        // Only prepare if we're not already prepared.
        int userId = context.getUserId();
        if (!cm.prepareVpn(packageName, null, userId)) {
            cm.prepareVpn(null, packageName, userId);
        }
        cm.setVpnPackageAuthorization(packageName, userId, VpnManager.TYPE_VPN_SERVICE);
    } catch (RemoteException e) {
    // ignore
    }
}
Body of Second Method:
{
    IVpnManager vm = getService();
    String packageName = context.getPackageName();
    try {
        // Only prepare if we're not already prepared.
        int userId = context.getUserId();
        if (!vm.prepareVpn(packageName, null, userId)) {
            vm.prepareVpn(null, packageName, userId);
        }
        vm.setVpnPackageAuthorization(packageName, userId, VpnManager.TYPE_VPN_SERVICE);
    } catch (RemoteException e) {
    // ignore
    }
}
------------------------
Find a silently evolved API code:android.widget.EdgeEffect.getMaxHeight:COMMENT
Method Modifier: public      
Comment:/**
 * Return the maximum height that the edge effect will be drawn at given the original
 * {@link #setSize(int, int) input size}.
 * @return The maximum height of the edge effect
 */

Body of Frist Method:
{
    return (int) (mBounds.height() * MAX_GLOW_SCALE + 0.5f);
}
Body of Second Method:
{
    return (int) mHeight;
}
------------------------
Find a silently evolved API code:android.preference.DialogPreference.showDialog:COMMENT
Method Modifier: protected   deprecated  
Comment:/**
 * Shows the dialog associated with this Preference. This is normally initiated
 * automatically on clicking on the preference. Call this method if you need to
 * show the dialog on some other event.
 *
 * @param state Optional instance state to restore on the dialog
 */

Body of Frist Method:
{
    Context context = getContext();
    mWhichButtonClicked = DialogInterface.BUTTON_NEGATIVE;
    mBuilder = new AlertDialog.Builder(context).setTitle(mDialogTitle).setIcon(mDialogIcon).setPositiveButton(mPositiveButtonText, this).setNegativeButton(mNegativeButtonText, this);
    View contentView = onCreateDialogView();
    if (contentView != null) {
        onBindDialogView(contentView);
        mBuilder.setView(contentView);
    } else {
        mBuilder.setMessage(mDialogMessage);
    }
    onPrepareDialogBuilder(mBuilder);
    getPreferenceManager().registerOnActivityDestroyListener(this);
    // Create the dialog
    final Dialog dialog = mDialog = mBuilder.create();
    if (state != null) {
        dialog.onRestoreInstanceState(state);
    }
    if (needInputMethod()) {
        requestInputMethod(dialog);
    }
    dialog.setOnShowListener(new DialogInterface.OnShowListener() {

        @Override
        public void onShow(DialogInterface dialog) {
            removeDismissCallbacks();
        }
    });
    dialog.setOnDismissListener(this);
    dialog.show();
}
Body of Second Method:
{
    Context context = getContext();
    mWhichButtonClicked = DialogInterface.BUTTON_NEGATIVE;
    mBuilder = new AlertDialog.Builder(context).setTitle(mDialogTitle).setIcon(mDialogIcon).setPositiveButton(mPositiveButtonText, this).setNegativeButton(mNegativeButtonText, this);
    View contentView = onCreateDialogView();
    if (contentView != null) {
        onBindDialogView(contentView);
        mBuilder.setView(contentView);
    } else {
        mBuilder.setMessage(mDialogMessage);
    }
    onPrepareDialogBuilder(mBuilder);
    getPreferenceManager().registerOnActivityDestroyListener(this);
    // Create the dialog
    final Dialog dialog = mDialog = mBuilder.create();
    if (state != null) {
        dialog.onRestoreInstanceState(state);
    }
    dialog.setOnShowListener(new DialogInterface.OnShowListener() {

        @Override
        public void onShow(DialogInterface dialog) {
            removeDismissCallbacks();
        }
    });
    dialog.setOnDismissListener(this);
    dialog.show();
}
------------------------
Find a silently evolved API code:android.media.ImageUtils.getNumPlanesForFormat:COMMENT
Method Modifier: public      static      
Comment:/**
 * Only a subset of the formats defined in
 * {@link android.graphics.ImageFormat ImageFormat} and
 * {@link android.graphics.PixelFormat PixelFormat} are supported by
 * ImageReader. When reading RGB data from a surface, the formats defined in
 * {@link android.graphics.PixelFormat PixelFormat} can be used; when
 * reading YUV, JPEG, HEIC or raw sensor data (for example, from the camera
 * or video decoder), formats from {@link android.graphics.ImageFormat ImageFormat}
 * are used.
 */

Body of Frist Method:
{
    switch(format) {
        case ImageFormat.YV12:
        case ImageFormat.YUV_420_888:
        case ImageFormat.NV21:
            return 3;
        case ImageFormat.NV16:
            return 2;
        case PixelFormat.RGB_565:
        case PixelFormat.RGBA_8888:
        case PixelFormat.RGBX_8888:
        case PixelFormat.RGB_888:
        case ImageFormat.JPEG:
        case ImageFormat.YUY2:
        case ImageFormat.Y8:
        case ImageFormat.Y16:
        case ImageFormat.RAW_SENSOR:
        case ImageFormat.RAW_PRIVATE:
        case ImageFormat.RAW10:
        case ImageFormat.RAW12:
        case ImageFormat.DEPTH16:
        case ImageFormat.DEPTH_POINT_CLOUD:
        case ImageFormat.RAW_DEPTH:
        case ImageFormat.DEPTH_JPEG:
        case ImageFormat.HEIC:
            return 1;
        case ImageFormat.PRIVATE:
            return 0;
        default:
            throw new UnsupportedOperationException(String.format("Invalid format specified %d", format));
    }
}
Body of Second Method:
{
    switch(format) {
        case ImageFormat.YV12:
        case ImageFormat.YUV_420_888:
        case ImageFormat.NV21:
        case ImageFormat.YCBCR_P010:
            return 3;
        case ImageFormat.NV16:
            return 2;
        case PixelFormat.RGB_565:
        case PixelFormat.RGBA_8888:
        case PixelFormat.RGBX_8888:
        case PixelFormat.RGB_888:
        case ImageFormat.JPEG:
        case ImageFormat.YUY2:
        case ImageFormat.Y8:
        case ImageFormat.Y16:
        case ImageFormat.RAW_SENSOR:
        case ImageFormat.RAW_PRIVATE:
        case ImageFormat.RAW10:
        case ImageFormat.RAW12:
        case ImageFormat.DEPTH16:
        case ImageFormat.DEPTH_POINT_CLOUD:
        case ImageFormat.RAW_DEPTH:
        case ImageFormat.RAW_DEPTH10:
        case ImageFormat.DEPTH_JPEG:
        case ImageFormat.HEIC:
            return 1;
        case ImageFormat.PRIVATE:
            return 0;
        default:
            throw new UnsupportedOperationException(String.format("Invalid format specified %d", format));
    }
}
------------------------
Find a silently evolved API code:android.content.pm.ShortcutManager.updateShortcuts:COMMENT
Method Modifier: public      
Comment:/**
 * Update all existing shortcuts with the same IDs.  Target shortcuts may be pinned and/or
 * dynamic, but they must not be immutable.
 *
 * <p>This API will be rate-limited.
 *
 * @return {@code true} if the call has succeeded. {@code false} if the call is rate-limited.
 *
 * @throws IllegalArgumentException If trying to update immutable shortcuts.
 *
 * @throws IllegalStateException when the user is locked.
 */

Body of Frist Method:
{
    try {
        return mService.updateShortcuts(mContext.getPackageName(), new ParceledListSlice(shortcutInfoList), injectMyUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    try {
        return (boolean) getFutureOrThrow(mService.updateShortcuts(mContext.getPackageName(), new ParceledListSlice(shortcutInfoList), injectMyUserId()));
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothPbap.setConnectionPolicy:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Set connection policy of the profile and tries to disconnect it if connectionPolicy is
 * {@link BluetoothProfile#CONNECTION_POLICY_FORBIDDEN}
 *
 * <p> The device should already be paired.
 * Connection policy can be one of:
 * {@link BluetoothProfile#CONNECTION_POLICY_ALLOWED},
 * {@link BluetoothProfile#CONNECTION_POLICY_FORBIDDEN},
 * {@link BluetoothProfile#CONNECTION_POLICY_UNKNOWN}
 *
 * @param device Paired bluetooth device
 * @param connectionPolicy is the connection policy to set to for this profile
 * @return true if connectionPolicy is set, false on error
 *
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("setConnectionPolicy(" + device + ", " + connectionPolicy + ")");
    try {
        final IBluetoothPbap service = mService;
        if (service != null && isEnabled() && isValidDevice(device)) {
            if (connectionPolicy != BluetoothProfile.CONNECTION_POLICY_FORBIDDEN && connectionPolicy != BluetoothProfile.CONNECTION_POLICY_ALLOWED) {
                return false;
            }
            return service.setConnectionPolicy(device, connectionPolicy);
        }
        if (service == null)
            Log.w(TAG, "Proxy not attached to service");
        return false;
    } catch (RemoteException e) {
        Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
        return false;
    }
}
Body of Second Method:
{
    if (DBG)
        log("setConnectionPolicy(" + device + ", " + connectionPolicy + ")");
    try {
        final IBluetoothPbap service = mService;
        if (service != null && isEnabled() && isValidDevice(device)) {
            if (connectionPolicy != BluetoothProfile.CONNECTION_POLICY_FORBIDDEN && connectionPolicy != BluetoothProfile.CONNECTION_POLICY_ALLOWED) {
                return false;
            }
            return service.setConnectionPolicy(device, connectionPolicy, mAttributionSource);
        }
        if (service == null)
            Log.w(TAG, "Proxy not attached to service");
        return false;
    } catch (RemoteException e) {
        Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
        return false;
    }
}
------------------------
Find a silently evolved API code:android.app.WindowConfiguration.updateFrom:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Copies the fields from delta into this Configuration object, keeping
 * track of which ones have changed. Any undefined fields in {@code delta}
 * are ignored and not copied in to the current Configuration.
 *
 * @return a bit mask of the changed fields, as per {@link #diff}
 * @hide
 */

Body of Frist Method:
{
    int changed = 0;
    // Only allow override if bounds is not empty
    if (!delta.mBounds.isEmpty() && !delta.mBounds.equals(mBounds)) {
        changed |= WINDOW_CONFIG_BOUNDS;
        setBounds(delta.mBounds);
    }
    if (delta.mAppBounds != null && !delta.mAppBounds.equals(mAppBounds)) {
        changed |= WINDOW_CONFIG_APP_BOUNDS;
        setAppBounds(delta.mAppBounds);
    }
    if (delta.mWindowingMode != WINDOWING_MODE_UNDEFINED && mWindowingMode != delta.mWindowingMode) {
        changed |= WINDOW_CONFIG_WINDOWING_MODE;
        setWindowingMode(delta.mWindowingMode);
    }
    if (delta.mActivityType != ACTIVITY_TYPE_UNDEFINED && mActivityType != delta.mActivityType) {
        changed |= WINDOW_CONFIG_ACTIVITY_TYPE;
        setActivityType(delta.mActivityType);
    }
    if (delta.mAlwaysOnTop != ALWAYS_ON_TOP_UNDEFINED && mAlwaysOnTop != delta.mAlwaysOnTop) {
        changed |= WINDOW_CONFIG_ALWAYS_ON_TOP;
        setAlwaysOnTop(delta.mAlwaysOnTop);
    }
    if (delta.mRotation != ROTATION_UNDEFINED && delta.mRotation != mRotation) {
        changed |= WINDOW_CONFIG_ROTATION;
        setRotation(delta.mRotation);
    }
    if (delta.mDisplayWindowingMode != WINDOWING_MODE_UNDEFINED && mDisplayWindowingMode != delta.mDisplayWindowingMode) {
        changed |= WINDOW_CONFIG_DISPLAY_WINDOWING_MODE;
        setDisplayWindowingMode(delta.mDisplayWindowingMode);
    }
    return changed;
}
Body of Second Method:
{
    int changed = 0;
    // Only allow override if bounds is not empty
    if (!delta.mBounds.isEmpty() && !delta.mBounds.equals(mBounds)) {
        changed |= WINDOW_CONFIG_BOUNDS;
        setBounds(delta.mBounds);
    }
    if (delta.mAppBounds != null && !delta.mAppBounds.equals(mAppBounds)) {
        changed |= WINDOW_CONFIG_APP_BOUNDS;
        setAppBounds(delta.mAppBounds);
    }
    if (!delta.mMaxBounds.isEmpty() && !delta.mMaxBounds.equals(mMaxBounds)) {
        changed |= WINDOW_CONFIG_MAX_BOUNDS;
        setMaxBounds(delta.mMaxBounds);
    }
    if (delta.mWindowingMode != WINDOWING_MODE_UNDEFINED && mWindowingMode != delta.mWindowingMode) {
        changed |= WINDOW_CONFIG_WINDOWING_MODE;
        setWindowingMode(delta.mWindowingMode);
    }
    if (delta.mActivityType != ACTIVITY_TYPE_UNDEFINED && mActivityType != delta.mActivityType) {
        changed |= WINDOW_CONFIG_ACTIVITY_TYPE;
        setActivityType(delta.mActivityType);
    }
    if (delta.mAlwaysOnTop != ALWAYS_ON_TOP_UNDEFINED && mAlwaysOnTop != delta.mAlwaysOnTop) {
        changed |= WINDOW_CONFIG_ALWAYS_ON_TOP;
        setAlwaysOnTop(delta.mAlwaysOnTop);
    }
    if (delta.mRotation != ROTATION_UNDEFINED && delta.mRotation != mRotation) {
        changed |= WINDOW_CONFIG_ROTATION;
        setRotation(delta.mRotation);
    }
    if (delta.mDisplayWindowingMode != WINDOWING_MODE_UNDEFINED && mDisplayWindowingMode != delta.mDisplayWindowingMode) {
        changed |= WINDOW_CONFIG_DISPLAY_WINDOWING_MODE;
        setDisplayWindowingMode(delta.mDisplayWindowingMode);
    }
    return changed;
}
------------------------
Find a silently evolved API code:android.bluetooth.le.AdvertisingSet.setPeriodicAdvertisingData:COMMENT
Method Modifier: public      
Comment:/**
 * Used to set periodic advertising data, must be called after setPeriodicAdvertisingParameters,
 * or after advertising was started with periodic advertising data set. This method returns
 * immediately, the operation status is delivered through
 * {@code callback.onPeriodicAdvertisingDataSet()}.
 *
 * @param periodicData Periodic advertising data. Size must not exceed {@link
 * BluetoothAdapter#getLeMaximumAdvertisingDataLength}. If the update takes place when the
 * periodic advertising is enabled for this set, the data can be maximum 251 bytes long.
 */

Body of Frist Method:
{
    try {
        mGatt.setPeriodicAdvertisingData(mAdvertiserId, periodicData);
    } catch (RemoteException e) {
        Log.e(TAG, "remote exception - ", e);
    }
}
Body of Second Method:
{
    try {
        mGatt.setPeriodicAdvertisingData(mAdvertiserId, periodicData, mAttributionSource);
    } catch (RemoteException e) {
        Log.e(TAG, "remote exception - ", e);
    }
}
------------------------
Find a silently evolved API code:android.accessibilityservice.AccessibilityServiceInfo.flagToString:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns the string representation of a flag. For example,
 * {@link #DEFAULT} is represented by the string DEFAULT.
 *
 * @param flag The flag.
 * @return The string representation.
 */

Body of Frist Method:
{
    switch(flag) {
        case DEFAULT:
            return "DEFAULT";
        case FLAG_INCLUDE_NOT_IMPORTANT_VIEWS:
            return "FLAG_INCLUDE_NOT_IMPORTANT_VIEWS";
        case FLAG_REQUEST_TOUCH_EXPLORATION_MODE:
            return "FLAG_REQUEST_TOUCH_EXPLORATION_MODE";
        case FLAG_SERVICE_HANDLES_DOUBLE_TAP:
            return "FLAG_SERVICE_HANDLES_DOUBLE_TAP";
        case FLAG_REQUEST_MULTI_FINGER_GESTURES:
            return "FLAG_REQUEST_MULTI_FINGER_GESTURES";
        case FLAG_REQUEST_ENHANCED_WEB_ACCESSIBILITY:
            return "FLAG_REQUEST_ENHANCED_WEB_ACCESSIBILITY";
        case FLAG_REPORT_VIEW_IDS:
            return "FLAG_REPORT_VIEW_IDS";
        case FLAG_REQUEST_FILTER_KEY_EVENTS:
            return "FLAG_REQUEST_FILTER_KEY_EVENTS";
        case FLAG_RETRIEVE_INTERACTIVE_WINDOWS:
            return "FLAG_RETRIEVE_INTERACTIVE_WINDOWS";
        case FLAG_ENABLE_ACCESSIBILITY_VOLUME:
            return "FLAG_ENABLE_ACCESSIBILITY_VOLUME";
        case FLAG_REQUEST_ACCESSIBILITY_BUTTON:
            return "FLAG_REQUEST_ACCESSIBILITY_BUTTON";
        case FLAG_REQUEST_FINGERPRINT_GESTURES:
            return "FLAG_REQUEST_FINGERPRINT_GESTURES";
        case FLAG_REQUEST_SHORTCUT_WARNING_DIALOG_SPOKEN_FEEDBACK:
            return "FLAG_REQUEST_SHORTCUT_WARNING_DIALOG_SPOKEN_FEEDBACK";
        default:
            return null;
    }
}
Body of Second Method:
{
    switch(flag) {
        case DEFAULT:
            return "DEFAULT";
        case FLAG_INCLUDE_NOT_IMPORTANT_VIEWS:
            return "FLAG_INCLUDE_NOT_IMPORTANT_VIEWS";
        case FLAG_REQUEST_TOUCH_EXPLORATION_MODE:
            return "FLAG_REQUEST_TOUCH_EXPLORATION_MODE";
        case FLAG_SERVICE_HANDLES_DOUBLE_TAP:
            return "FLAG_SERVICE_HANDLES_DOUBLE_TAP";
        case FLAG_REQUEST_MULTI_FINGER_GESTURES:
            return "FLAG_REQUEST_MULTI_FINGER_GESTURES";
        case FLAG_REQUEST_2_FINGER_PASSTHROUGH:
            return "FLAG_REQUEST_2_FINGER_PASSTHROUGH";
        case FLAG_SEND_MOTION_EVENTS:
            return "FLAG_SEND_MOTION_EVENTS";
        case FLAG_REQUEST_ENHANCED_WEB_ACCESSIBILITY:
            return "FLAG_REQUEST_ENHANCED_WEB_ACCESSIBILITY";
        case FLAG_REPORT_VIEW_IDS:
            return "FLAG_REPORT_VIEW_IDS";
        case FLAG_REQUEST_FILTER_KEY_EVENTS:
            return "FLAG_REQUEST_FILTER_KEY_EVENTS";
        case FLAG_RETRIEVE_INTERACTIVE_WINDOWS:
            return "FLAG_RETRIEVE_INTERACTIVE_WINDOWS";
        case FLAG_ENABLE_ACCESSIBILITY_VOLUME:
            return "FLAG_ENABLE_ACCESSIBILITY_VOLUME";
        case FLAG_REQUEST_ACCESSIBILITY_BUTTON:
            return "FLAG_REQUEST_ACCESSIBILITY_BUTTON";
        case FLAG_REQUEST_FINGERPRINT_GESTURES:
            return "FLAG_REQUEST_FINGERPRINT_GESTURES";
        case FLAG_REQUEST_SHORTCUT_WARNING_DIALOG_SPOKEN_FEEDBACK:
            return "FLAG_REQUEST_SHORTCUT_WARNING_DIALOG_SPOKEN_FEEDBACK";
        default:
            return null;
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothA2dpSink.getConnectionPolicy:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the connection policy of the profile.
 *
 * <p> The connection policy can be any of:
 * {@link #CONNECTION_POLICY_ALLOWED}, {@link #CONNECTION_POLICY_FORBIDDEN},
 * {@link #CONNECTION_POLICY_UNKNOWN}
 *
 * @param device Bluetooth device
 * @return connection policy of the device
 * @hide
 */

Body of Frist Method:
{
    if (VDBG)
        log("getConnectionPolicy(" + device + ")");
    final IBluetoothA2dpSink service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getConnectionPolicy(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.CONNECTION_POLICY_FORBIDDEN;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return BluetoothProfile.CONNECTION_POLICY_FORBIDDEN;
}
Body of Second Method:
{
    if (VDBG)
        log("getConnectionPolicy(" + device + ")");
    final IBluetoothA2dpSink service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getConnectionPolicy(device, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.CONNECTION_POLICY_FORBIDDEN;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return BluetoothProfile.CONNECTION_POLICY_FORBIDDEN;
}
------------------------
Find a silently evolved API code:android.hardware.display.DisplayViewport.toString:COMMENT
Method Modifier: public      hidden      
Comment:// For debugging purposes.

Body of Frist Method:
{
    final Integer port = physicalPort == null ? null : Byte.toUnsignedInt(physicalPort);
    return "DisplayViewport{type=" + typeToString(type) + ", valid=" + valid + ", isActive=" + isActive + ", displayId=" + displayId + ", uniqueId='" + uniqueId + "'" + ", physicalPort=" + port + ", orientation=" + orientation + ", logicalFrame=" + logicalFrame + ", physicalFrame=" + physicalFrame + ", deviceWidth=" + deviceWidth + ", deviceHeight=" + deviceHeight + "}";
}
Body of Second Method:
{
    return "DisplayViewport{type=" + typeToString(type) + ", valid=" + valid + ", isActive=" + isActive + ", displayId=" + displayId + ", uniqueId='" + uniqueId + "'" + ", physicalPort=" + physicalPort + ", orientation=" + orientation + ", logicalFrame=" + logicalFrame + ", physicalFrame=" + physicalFrame + ", deviceWidth=" + deviceWidth + ", deviceHeight=" + deviceHeight + "}";
}
------------------------
Find a silently evolved API code:android.telephony.SmsMessage.fragmentText:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Divide a message text into several fragments, none bigger than the maximum SMS message text
 * size.
 *
 * @param text text, must not be null.
 * @param subId Subscription to take SMS format.
 * @return an <code>ArrayList</code> of strings that, in order, comprise the original msg text.
 * @hide
 */

Body of Frist Method:
{
    // This function is for MO SMS
    final boolean isCdma = useCdmaFormatForMoSms(subId);
    TextEncodingDetails ted = isCdma ? com.android.internal.telephony.cdma.SmsMessage.calculateLength(text, false, true) : com.android.internal.telephony.gsm.SmsMessage.calculateLength(text, false);
    // TODO(cleanup): The code here could be rolled into the logic
    // below cleanly if these MAX_* constants were defined more
    // flexibly...
    int limit;
    if (ted.codeUnitSize == SmsConstants.ENCODING_7BIT) {
        int udhLength;
        if (ted.languageTable != 0 && ted.languageShiftTable != 0) {
            udhLength = GsmAlphabet.UDH_SEPTET_COST_TWO_SHIFT_TABLES;
        } else if (ted.languageTable != 0 || ted.languageShiftTable != 0) {
            udhLength = GsmAlphabet.UDH_SEPTET_COST_ONE_SHIFT_TABLE;
        } else {
            udhLength = 0;
        }
        if (ted.msgCount > 1) {
            udhLength += GsmAlphabet.UDH_SEPTET_COST_CONCATENATED_MESSAGE;
        }
        if (udhLength != 0) {
            udhLength += GsmAlphabet.UDH_SEPTET_COST_LENGTH;
        }
        limit = SmsConstants.MAX_USER_DATA_SEPTETS - udhLength;
    } else {
        if (ted.msgCount > 1) {
            limit = SmsConstants.MAX_USER_DATA_BYTES_WITH_HEADER;
            // Make sure total number of segments is less than 10.
            if (!hasEmsSupport() && ted.msgCount < 10) {
                limit -= 2;
            }
        } else {
            limit = SmsConstants.MAX_USER_DATA_BYTES;
        }
    }
    String newMsgBody = null;
    Resources r = Resources.getSystem();
    if (r.getBoolean(com.android.internal.R.bool.config_sms_force_7bit_encoding)) {
        newMsgBody = Sms7BitEncodingTranslator.translate(text, isCdma);
    }
    if (TextUtils.isEmpty(newMsgBody)) {
        newMsgBody = text;
    }
    // Index in code units.
    int pos = 0;
    int textLen = newMsgBody.length();
    ArrayList<String> result = new ArrayList<String>(ted.msgCount);
    while (pos < textLen) {
        // Counts code units.
        int nextPos = 0;
        if (ted.codeUnitSize == SmsConstants.ENCODING_7BIT) {
            if (isCdma && ted.msgCount == 1) {
                // For a singleton CDMA message, the encoding must be ASCII...
                nextPos = pos + Math.min(limit, textLen - pos);
            } else {
                // For multi-segment messages, CDMA 7bit equals GSM 7bit encoding (EMS mode).
                nextPos = GsmAlphabet.findGsmSeptetLimitIndex(newMsgBody, pos, limit, ted.languageTable, ted.languageShiftTable);
            }
        } else {
            // Assume unicode.
            nextPos = SmsMessageBase.findNextUnicodePosition(pos, limit, newMsgBody);
        }
        if ((nextPos <= pos) || (nextPos > textLen)) {
            Rlog.e(LOG_TAG, "fragmentText failed (" + pos + " >= " + nextPos + " or " + nextPos + " >= " + textLen + ")");
            break;
        }
        result.add(newMsgBody.substring(pos, nextPos));
        pos = nextPos;
    }
    return result;
}
Body of Second Method:
{
    // This function is for MO SMS
    final boolean isCdma = useCdmaFormatForMoSms(subId);
    TextEncodingDetails ted = isCdma ? com.android.internal.telephony.cdma.SmsMessage.calculateLength(text, false, true) : com.android.internal.telephony.gsm.SmsMessage.calculateLength(text, false);
    // TODO(cleanup): The code here could be rolled into the logic
    // below cleanly if these MAX_* constants were defined more
    // flexibly...
    int limit;
    if (ted.codeUnitSize == SmsConstants.ENCODING_7BIT) {
        int udhLength;
        if (ted.languageTable != 0 && ted.languageShiftTable != 0) {
            udhLength = GsmAlphabet.UDH_SEPTET_COST_TWO_SHIFT_TABLES;
        } else if (ted.languageTable != 0 || ted.languageShiftTable != 0) {
            udhLength = GsmAlphabet.UDH_SEPTET_COST_ONE_SHIFT_TABLE;
        } else {
            udhLength = 0;
        }
        if (ted.msgCount > 1) {
            udhLength += GsmAlphabet.UDH_SEPTET_COST_CONCATENATED_MESSAGE;
        }
        if (udhLength != 0) {
            udhLength += GsmAlphabet.UDH_SEPTET_COST_LENGTH;
        }
        limit = SmsConstants.MAX_USER_DATA_SEPTETS - udhLength;
    } else {
        if (ted.msgCount > 1) {
            limit = SmsConstants.MAX_USER_DATA_BYTES_WITH_HEADER;
            // Make sure total number of segments is less than 10.
            if (!hasEmsSupport() && ted.msgCount < 10) {
                limit -= 2;
            }
        } else {
            limit = SmsConstants.MAX_USER_DATA_BYTES;
        }
    }
    String newMsgBody = null;
    Resources r = Resources.getSystem();
    if (r.getBoolean(com.android.internal.R.bool.config_sms_force_7bit_encoding)) {
        // 7-bit ASCII table based translation is required only for CDMA single-part SMS since
        // ENCODING_7BIT_ASCII is used for CDMA single-part SMS and ENCODING_GSM_7BIT_ALPHABET
        // is used for CDMA multi-part SMS.
        newMsgBody = Sms7BitEncodingTranslator.translate(text, isCdma && ted.msgCount == 1);
    }
    if (TextUtils.isEmpty(newMsgBody)) {
        newMsgBody = text;
    }
    // Index in code units.
    int pos = 0;
    int textLen = newMsgBody.length();
    ArrayList<String> result = new ArrayList<String>(ted.msgCount);
    while (pos < textLen) {
        // Counts code units.
        int nextPos = 0;
        if (ted.codeUnitSize == SmsConstants.ENCODING_7BIT) {
            if (isCdma && ted.msgCount == 1) {
                // For a singleton CDMA message, the encoding must be ASCII...
                nextPos = pos + Math.min(limit, textLen - pos);
            } else {
                // For multi-segment messages, CDMA 7bit equals GSM 7bit encoding (EMS mode).
                nextPos = GsmAlphabet.findGsmSeptetLimitIndex(newMsgBody, pos, limit, ted.languageTable, ted.languageShiftTable);
            }
        } else {
            // Assume unicode.
            nextPos = SmsMessageBase.findNextUnicodePosition(pos, limit, newMsgBody);
        }
        if ((nextPos <= pos) || (nextPos > textLen)) {
            Rlog.e(LOG_TAG, "fragmentText failed (" + pos + " >= " + nextPos + " or " + nextPos + " >= " + textLen + ")");
            break;
        }
        result.add(newMsgBody.substring(pos, nextPos));
        pos = nextPos;
    }
    return result;
}
------------------------
Find a silently evolved API code:android.graphics.text.MeasuredText.getBounds:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieves the boundary box of the given range
 *
 * @param start an inclusive start index of the range
 * @param end an exclusive end index of the range
 * @param rect an output parameter
 */

Body of Frist Method:
{
    Preconditions.checkArgument(0 <= start && start <= mChars.length, "start(" + start + ") must be 0 <= start <= " + mChars.length);
    Preconditions.checkArgument(0 <= end && end <= mChars.length, "end(" + end + ") must be 0 <= end <= " + mChars.length);
    Preconditions.checkArgument(start <= end, "start(" + start + ") is larger than end(" + end + ")");
    Preconditions.checkNotNull(rect);
    nGetBounds(mNativePtr, mChars, start, end, rect);
}
Body of Second Method:
{
    Preconditions.checkArgument(0 <= start && start <= mChars.length, "start(%d) must be 0 <= start <= %d", start, mChars.length);
    Preconditions.checkArgument(0 <= end && end <= mChars.length, "end(%d) must be 0 <= end <= %d", end, mChars.length);
    Preconditions.checkArgument(start <= end, "start(%d) is larger than end(%d)", start, end);
    Preconditions.checkNotNull(rect);
    nGetBounds(mNativePtr, mChars, start, end, rect);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothGatt.requestConnectionPriority:COMMENT
Method Modifier: public      
Comment:/**
 * Request a connection parameter update.
 *
 * <p>This function will send a connection parameter update request to the
 * remote device.
 *
 * @param connectionPriority Request a specific connection priority. Must be one of {@link
 * BluetoothGatt#CONNECTION_PRIORITY_BALANCED}, {@link BluetoothGatt#CONNECTION_PRIORITY_HIGH}
 * or {@link BluetoothGatt#CONNECTION_PRIORITY_LOW_POWER}.
 * @throws IllegalArgumentException If the parameters are outside of their specified range.
 */

Body of Frist Method:
{
    if (connectionPriority < CONNECTION_PRIORITY_BALANCED || connectionPriority > CONNECTION_PRIORITY_LOW_POWER) {
        throw new IllegalArgumentException("connectionPriority not within valid range");
    }
    if (DBG)
        Log.d(TAG, "requestConnectionPriority() - params: " + connectionPriority);
    if (mService == null || mClientIf == 0)
        return false;
    try {
        mService.connectionParameterUpdate(mClientIf, mDevice.getAddress(), connectionPriority);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        return false;
    }
    return true;
}
Body of Second Method:
{
    if (connectionPriority < CONNECTION_PRIORITY_BALANCED || connectionPriority > CONNECTION_PRIORITY_LOW_POWER) {
        throw new IllegalArgumentException("connectionPriority not within valid range");
    }
    if (DBG)
        Log.d(TAG, "requestConnectionPriority() - params: " + connectionPriority);
    if (mService == null || mClientIf == 0)
        return false;
    try {
        mService.connectionParameterUpdate(mClientIf, mDevice.getAddress(), connectionPriority, mAttributionSource);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        return false;
    }
    return true;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothManager.getDevicesMatchingConnectionStates:COMMENT
Method Modifier: public      
Comment:/**
 * Get a list of devices that match any of the given connection
 * states.
 *
 * <p> If none of the devices match any of the given states,
 * an empty list will be returned.
 *
 * <p>This is not specific to any application configuration but represents
 * the connection state of the local Bluetooth adapter for this profile.
 * This can be used by applications like status bar which would just like
 * to know the state of the local adapter.
 *
 * @param profile GATT or GATT_SERVER
 * @param states Array of states. States can be one of {@link BluetoothProfile#STATE_CONNECTED},
 * {@link BluetoothProfile#STATE_CONNECTING}, {@link BluetoothProfile#STATE_DISCONNECTED},
 * {@link BluetoothProfile#STATE_DISCONNECTING},
 * @return List of devices. The list will be empty on error.
 */

Body of Frist Method:
{
    if (DBG)
        Log.d(TAG, "getDevicesMatchingConnectionStates");
    if (profile != BluetoothProfile.GATT && profile != BluetoothProfile.GATT_SERVER) {
        throw new IllegalArgumentException("Profile not supported: " + profile);
    }
    List<BluetoothDevice> devices = new ArrayList<BluetoothDevice>();
    try {
        IBluetoothManager managerService = mAdapter.getBluetoothManager();
        IBluetoothGatt iGatt = managerService.getBluetoothGatt();
        if (iGatt == null)
            return devices;
        devices = iGatt.getDevicesMatchingConnectionStates(states);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return devices;
}
Body of Second Method:
{
    if (DBG)
        Log.d(TAG, "getDevicesMatchingConnectionStates");
    if (profile != BluetoothProfile.GATT && profile != BluetoothProfile.GATT_SERVER) {
        throw new IllegalArgumentException("Profile not supported: " + profile);
    }
    List<BluetoothDevice> devices = new ArrayList<BluetoothDevice>();
    try {
        IBluetoothManager managerService = mAdapter.getBluetoothManager();
        IBluetoothGatt iGatt = managerService.getBluetoothGatt();
        if (iGatt == null)
            return devices;
        devices = Attributable.setAttributionSource(iGatt.getDevicesMatchingConnectionStates(states, mAttributionSource), mAttributionSource);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return devices;
}
------------------------
Find a silently evolved API code:android.view.DragEvent.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Creates a {@link android.os.Parcel} object from this DragEvent object.
 * @param dest A {@link android.os.Parcel} object in which to put the DragEvent object.
 * @param flags Flags to store in the Parcel.
 */

Body of Frist Method:
{
    dest.writeInt(mAction);
    dest.writeFloat(mX);
    dest.writeFloat(mY);
    dest.writeInt(mDragResult ? 1 : 0);
    if (mClipData == null) {
        dest.writeInt(0);
    } else {
        dest.writeInt(1);
        mClipData.writeToParcel(dest, flags);
    }
    if (mClipDescription == null) {
        dest.writeInt(0);
    } else {
        dest.writeInt(1);
        mClipDescription.writeToParcel(dest, flags);
    }
    if (mDragAndDropPermissions == null) {
        dest.writeInt(0);
    } else {
        dest.writeInt(1);
        dest.writeStrongBinder(mDragAndDropPermissions.asBinder());
    }
}
Body of Second Method:
{
    dest.writeInt(mAction);
    dest.writeFloat(mX);
    dest.writeFloat(mY);
    dest.writeFloat(mOffsetX);
    dest.writeFloat(mOffsetY);
    dest.writeInt(mDragResult ? 1 : 0);
    if (mClipData == null) {
        dest.writeInt(0);
    } else {
        dest.writeInt(1);
        mClipData.writeToParcel(dest, flags);
    }
    if (mClipDescription == null) {
        dest.writeInt(0);
    } else {
        dest.writeInt(1);
        mClipDescription.writeToParcel(dest, flags);
    }
    if (mDragSurface == null) {
        dest.writeInt(0);
    } else {
        dest.writeInt(1);
        mDragSurface.writeToParcel(dest, flags);
    }
    if (mDragAndDropPermissions == null) {
        dest.writeInt(0);
    } else {
        dest.writeInt(1);
        dest.writeStrongBinder(mDragAndDropPermissions.asBinder());
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.getAudioState:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns current audio state of Audio Gateway.
 *
 * Note: This is an internal function and shouldn't be exposed
 */

Body of Frist Method:
{
    if (VDBG)
        log("getAudioState");
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled()) {
        try {
            return service.getAudioState(device);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return BluetoothHeadsetClient.STATE_AUDIO_DISCONNECTED;
}
Body of Second Method:
{
    if (VDBG)
        log("getAudioState");
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled()) {
        try {
            return service.getAudioState(device, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return BluetoothHeadsetClient.STATE_AUDIO_DISCONNECTED;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothSocket.requestMaximumTxDataLength:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Set the LE Transmit Data Length to be the maximum that the BT Controller is capable of. This
 * parameter is used by the BT Controller to set the maximum transmission packet size on this
 * connection. This function is currently used for testing only.
 * @hide
 */

Body of Frist Method:
{
    if (mDevice == null) {
        throw new IOException("requestMaximumTxDataLength is called on null device");
    }
    try {
        if (mSocketState == SocketState.CLOSED) {
            throw new IOException("socket closed");
        }
        IBluetooth bluetoothProxy = BluetoothAdapter.getDefaultAdapter().getBluetoothService(null);
        if (bluetoothProxy == null) {
            throw new IOException("Bluetooth is off");
        }
        if (DBG)
            Log.d(TAG, "requestMaximumTxDataLength");
        bluetoothProxy.getSocketManager().requestMaximumTxDataLength(mDevice);
    } catch (RemoteException e) {
        Log.e(TAG, Log.getStackTraceString(new Throwable()));
        throw new IOException("unable to send RPC: " + e.getMessage());
    }
}
Body of Second Method:
{
    if (mDevice == null) {
        throw new IOException("requestMaximumTxDataLength is called on null device");
    }
    try {
        if (mSocketState == SocketState.CLOSED) {
            throw new IOException("socket closed");
        }
        IBluetooth bluetoothProxy = BluetoothAdapter.getDefaultAdapter().getBluetoothService();
        if (bluetoothProxy == null) {
            throw new IOException("Bluetooth is off");
        }
        if (DBG)
            Log.d(TAG, "requestMaximumTxDataLength");
        bluetoothProxy.getSocketManager().requestMaximumTxDataLength(mDevice);
    } catch (RemoteException e) {
        Log.e(TAG, Log.getStackTraceString(new Throwable()));
        throw new IOException("unable to send RPC: " + e.getMessage());
    }
}
------------------------
Find a silently evolved API code:android.app.WindowConfiguration.readFromProto:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Read from a protocol buffer input stream.
 * Protocol buffer message definition at {@link android.app.WindowConfigurationProto}
 *
 * @param proto   Stream to read the WindowConfiguration object from.
 * @param fieldId Field Id of the WindowConfiguration as defined in the parent message
 * @hide
 */

Body of Frist Method:
{
    final long token = proto.start(fieldId);
    try {
        while (proto.nextField() != ProtoInputStream.NO_MORE_FIELDS) {
            switch(proto.getFieldNumber()) {
                case (int) APP_BOUNDS:
                    mAppBounds = new Rect();
                    mAppBounds.readFromProto(proto, APP_BOUNDS);
                    break;
                case (int) BOUNDS:
                    mBounds = new Rect();
                    mBounds.readFromProto(proto, BOUNDS);
                    break;
                case (int) WINDOWING_MODE:
                    mWindowingMode = proto.readInt(WINDOWING_MODE);
                    break;
                case (int) ACTIVITY_TYPE:
                    mActivityType = proto.readInt(ACTIVITY_TYPE);
                    break;
            }
        }
    } finally {
        // Let caller handle any exceptions
        proto.end(token);
    }
}
Body of Second Method:
{
    final long token = proto.start(fieldId);
    try {
        while (proto.nextField() != ProtoInputStream.NO_MORE_FIELDS) {
            switch(proto.getFieldNumber()) {
                case (int) APP_BOUNDS:
                    mAppBounds = new Rect();
                    mAppBounds.readFromProto(proto, APP_BOUNDS);
                    break;
                case (int) BOUNDS:
                    mBounds.readFromProto(proto, BOUNDS);
                    break;
                case (int) MAX_BOUNDS:
                    mMaxBounds.readFromProto(proto, MAX_BOUNDS);
                    break;
                case (int) WINDOWING_MODE:
                    mWindowingMode = proto.readInt(WINDOWING_MODE);
                    break;
                case (int) ACTIVITY_TYPE:
                    mActivityType = proto.readInt(ACTIVITY_TYPE);
                    break;
            }
        }
    } finally {
        // Let caller handle any exceptions
        proto.end(token);
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadset.stopScoUsingVirtualVoiceCall:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Terminates an ongoing SCO connection and the associated virtual call.
 *
 * <p> Users can listen to {@link #ACTION_AUDIO_STATE_CHANGED}.
 * If this function returns true, this intent will be broadcasted with
 * {@link #EXTRA_STATE} set to {@link #STATE_AUDIO_DISCONNECTED}.
 *
 * @return true if successful, false if one of the following case applies
 * - virtual voice call is not started or has ended
 * - binder is dead or Bluetooth is disabled or other error
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("stopScoUsingVirtualVoiceCall()");
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.stopScoUsingVirtualVoiceCall();
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("stopScoUsingVirtualVoiceCall()");
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.stopScoUsingVirtualVoiceCall(mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return false;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothDevice.isBondingInitiatedLocally:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Gets whether bonding was initiated locally
 *
 * @return true if bonding is initiated locally, false otherwise
 *
 * @hide
 */

Body of Frist Method:
{
    final IBluetooth service = sService;
    if (service == null) {
        Log.w(TAG, "BT not enabled, isBondingInitiatedLocally failed");
        return false;
    }
    try {
        return service.isBondingInitiatedLocally(this);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
Body of Second Method:
{
    final IBluetooth service = sService;
    if (service == null) {
        Log.w(TAG, "BT not enabled, isBondingInitiatedLocally failed");
        return false;
    }
    try {
        return service.isBondingInitiatedLocally(this, mAttributionSource);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
------------------------
Find a silently evolved API code:android.app.admin.DeviceAdminReceiver.onUserRemoved:COMMENT
Method Modifier: public      
Comment:/**
 * Called when a user or profile is removed.
 *
 * <p>This callback is only applicable to device owners.
 *
 * @param context The running context as per {@link #onReceive}.
 * @param intent The received intent as per {@link #onReceive}.
 * @param removedUser The {@link UserHandle} of the user that has just been removed.
 */

Body of Frist Method:
{
}
Body of Second Method:
{
    if (LOCAL_LOGV) {
        Log.v(TAG, getClass().getName() + ".onUserRemoved() on user " + context.getUserId());
    }
}
------------------------
Find a silently evolved API code:android.media.AudioFormat.isEncodingLinearPcm:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    switch(audioFormat) {
        case ENCODING_PCM_16BIT:
        case ENCODING_PCM_8BIT:
        case ENCODING_PCM_FLOAT:
        case ENCODING_DEFAULT:
            return true;
        case ENCODING_AC3:
        case ENCODING_E_AC3:
        case ENCODING_DTS:
        case ENCODING_DTS_HD:
        case ENCODING_MP3:
        case ENCODING_AAC_LC:
        case ENCODING_AAC_HE_V1:
        case ENCODING_AAC_HE_V2:
        // wrapped in PCM but compressed
        case ENCODING_IEC61937:
        case ENCODING_DOLBY_TRUEHD:
        case ENCODING_AAC_ELD:
        case ENCODING_AAC_XHE:
        case ENCODING_AC4:
        case ENCODING_E_AC3_JOC:
        case ENCODING_DOLBY_MAT:
        case ENCODING_OPUS:
            return false;
        case ENCODING_INVALID:
        default:
            throw new IllegalArgumentException("Bad audio format " + audioFormat);
    }
}
Body of Second Method:
{
    switch(audioFormat) {
        case ENCODING_PCM_16BIT:
        case ENCODING_PCM_8BIT:
        case ENCODING_PCM_FLOAT:
        case ENCODING_PCM_24BIT_PACKED:
        case ENCODING_PCM_32BIT:
        case ENCODING_DEFAULT:
            return true;
        case ENCODING_AC3:
        case ENCODING_E_AC3:
        case ENCODING_DTS:
        case ENCODING_DTS_HD:
        case ENCODING_MP3:
        case ENCODING_AAC_LC:
        case ENCODING_AAC_HE_V1:
        case ENCODING_AAC_HE_V2:
        // wrapped in PCM but compressed
        case ENCODING_IEC61937:
        case ENCODING_DOLBY_TRUEHD:
        case ENCODING_AAC_ELD:
        case ENCODING_AAC_XHE:
        case ENCODING_AC4:
        case ENCODING_E_AC3_JOC:
        case ENCODING_DOLBY_MAT:
        case ENCODING_OPUS:
        case ENCODING_MPEGH_BL_L3:
        case ENCODING_MPEGH_BL_L4:
        case ENCODING_MPEGH_LC_L3:
        case ENCODING_MPEGH_LC_L4:
        case ENCODING_DTS_UHD:
        case ENCODING_DRA:
            return false;
        case ENCODING_INVALID:
        default:
            throw new IllegalArgumentException("Bad audio format " + audioFormat);
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadset.getDevicesMatchingConnectionStates:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (VDBG)
        log("getDevicesMatchingStates()");
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.getDevicesMatchingConnectionStates(states);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
Body of Second Method:
{
    if (VDBG)
        log("getDevicesMatchingStates()");
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled()) {
        try {
            return Attributable.setAttributionSource(service.getDevicesMatchingConnectionStates(states, mAttributionSource), mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.stopVoiceRecognition:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Stops voice recognition.
 *
 * @param device remote device
 * @return <code>true</code> if command has been issued successfully; <code>false</code>
 * otherwise; upon completion HFP sends {@link #ACTION_AG_EVENT} intent.
 *
 * <p>Feature required for successful execution is being reported by: {@link
 * #EXTRA_AG_FEATURE_VOICE_RECOGNITION}. This method invocation will fail silently when feature
 * is not supported.</p>
 */

Body of Frist Method:
{
    if (DBG)
        log("stopVoiceRecognition()");
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.stopVoiceRecognition(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("stopVoiceRecognition()");
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.stopVoiceRecognition(device, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.hardware.camera2.params.InputConfiguration.equals:COMMENT
Method Modifier: public      
Comment:/**
 * Check if this InputConfiguration is equal to another InputConfiguration.
 *
 * <p>Two input configurations are equal if and only if they have the same widths, heights, and
 * formats.</p>
 *
 * @param obj the object to compare this instance with.
 *
 * @return {@code true} if the objects were equal, {@code false} otherwise.
 */

Body of Frist Method:
{
    if (!(obj instanceof InputConfiguration)) {
        return false;
    }
    InputConfiguration otherInputConfig = (InputConfiguration) obj;
    if (otherInputConfig.getWidth() == mWidth && otherInputConfig.getHeight() == mHeight && otherInputConfig.getFormat() == mFormat) {
        return true;
    }
    return false;
}
Body of Second Method:
{
    if (!(obj instanceof InputConfiguration)) {
        return false;
    }
    InputConfiguration otherInputConfig = (InputConfiguration) obj;
    if (otherInputConfig.getWidth() == mWidth && otherInputConfig.getHeight() == mHeight && otherInputConfig.getFormat() == mFormat && otherInputConfig.isMultiResolution() == mIsMultiResolution) {
        return true;
    }
    return false;
}
------------------------
Find a silently evolved API code:android.content.ContentProviderClient.bulkInsert:COMMENT
Method Modifier: public      
Comment:/**
 * See {@link ContentProvider#bulkInsert ContentProvider.bulkInsert}
 */

Body of Frist Method:
{
    Objects.requireNonNull(url, "url");
    Objects.requireNonNull(initialValues, "initialValues");
    beforeRemote();
    try {
        return mContentProvider.bulkInsert(mPackageName, mAttributionTag, url, initialValues);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}
Body of Second Method:
{
    Objects.requireNonNull(url, "url");
    Objects.requireNonNull(initialValues, "initialValues");
    beforeRemote();
    try {
        return mContentProvider.bulkInsert(mAttributionSource, url, initialValues);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}
------------------------
Find a silently evolved API code:android.media.HwAudioSource.stop:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Stops the playback from {@link AudioDeviceInfo}.
 */

Body of Frist Method:
{
    baseStop();
    if (mNativeHandle > 0) {
        AudioSystem.stopAudioSource(mNativeHandle);
        mNativeHandle = 0;
    }
}
Body of Second Method:
{
    if (mNativeHandle > 0) {
        baseStop();
        AudioSystem.stopAudioSource(mNativeHandle);
        mNativeHandle = 0;
    }
}
------------------------
Find a silently evolved API code:android.util.apk.SourceStampVerificationResult.notPresent:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Create a non-present source stamp outcome.
 *
 * @return A non-present source stamp result.
 */

Body of Frist Method:
{
    return new SourceStampVerificationResult(/* present= */
    false, /* verified= */
    false, /* certificate= */
    null);
}
Body of Second Method:
{
    return new SourceStampVerificationResult(/* present= */
    false, /* verified= */
    false, /* certificate= */
    null, /* certificateLineage= */
    Collections.emptyList());
}
------------------------
Find a silently evolved API code:android.content.pm.ShortcutManager.pushDynamicShortcut:COMMENT
Method Modifier: public      
Comment:/**
 * Publish a single dynamic shortcut. If there are already dynamic or pinned shortcuts with the
 * same ID, each mutable shortcut is updated.
 *
 * <p>This method is useful when posting notifications which are tagged with shortcut IDs; In
 * order to make sure shortcuts exist and are up-to-date, without the need to explicitly handle
 * the shortcut count limit.
 * @see android.app.NotificationManager#notify(int, Notification)
 * @see Notification.Builder#setShortcutId(String)
 *
 * <p>If {@link #getMaxShortcutCountPerActivity()} is already reached, an existing shortcut with
 * the lowest rank will be removed to add space for the new shortcut.
 *
 * <p>If the rank of the shortcut is not explicitly set, it will be set to zero, and shortcut
 * will be added to the top of the list.
 *
 * @throws IllegalArgumentException if trying to update an immutable shortcut.
 *
 * @throws IllegalStateException when the user is locked.
 */

Body of Frist Method:
{
    try {
        mService.pushDynamicShortcut(mContext.getPackageName(), shortcut, injectMyUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    try {
        getFutureOrThrow(mService.pushDynamicShortcut(mContext.getPackageName(), shortcut, injectMyUserId()));
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.app.admin.DeviceAdminReceiver.onUserSwitched:COMMENT
Method Modifier: public      
Comment:/**
 * Called when a user or profile is switched to.
 *
 * <p>This callback is only applicable to device owners.
 *
 * @param context The running context as per {@link #onReceive}.
 * @param intent The received intent as per {@link #onReceive}.
 * @param switchedUser The {@link UserHandle} of the user that has just been switched to.
 */

Body of Frist Method:
{
}
Body of Second Method:
{
    if (LOCAL_LOGV) {
        Log.v(TAG, getClass().getName() + ".onUserSwitched() on user " + context.getUserId());
    }
}
------------------------
Find a silently evolved API code:android.ddm.DdmHandleProfiling.handleChunk:COMMENT
Method Modifier: public      
Comment:/**
 * Handle a chunk of data.
 */

Body of Frist Method:
{
    if (DEBUG)
        Log.v("ddm-heap", "Handling " + name(request.type) + " chunk");
    int type = request.type;
    if (type == CHUNK_MPRS) {
        return handleMPRS(request);
    } else if (type == CHUNK_MPRE) {
        return handleMPRE(request);
    } else if (type == CHUNK_MPSS) {
        return handleMPSS(request);
    } else if (type == CHUNK_MPSE) {
        return handleMPSEOrSPSE(request, "Method");
    } else if (type == CHUNK_MPRQ) {
        return handleMPRQ(request);
    } else if (type == CHUNK_SPSS) {
        return handleSPSS(request);
    } else if (type == CHUNK_SPSE) {
        return handleMPSEOrSPSE(request, "Sample");
    } else {
        throw new RuntimeException("Unknown packet " + ChunkHandler.name(type));
    }
}
Body of Second Method:
{
    if (DEBUG)
        Log.v("ddm-heap", "Handling " + name(request.type) + " chunk");
    int type = request.type;
    if (type == CHUNK_MPRS) {
        return handleMPRS(request);
    } else if (type == CHUNK_MPRE) {
        return handleMPRE(request);
    } else if (type == CHUNK_MPSS) {
        return handleMPSS(request);
    } else if (type == CHUNK_MPSE) {
        return handleMPSEOrSPSE(request, "Method");
    } else if (type == CHUNK_MPRQ) {
        return handleMPRQ(request);
    } else if (type == CHUNK_SPSS) {
        return handleSPSS(request);
    } else if (type == CHUNK_SPSE) {
        return handleMPSEOrSPSE(request, "Sample");
    } else {
        throw new RuntimeException("Unknown packet " + name(type));
    }
}
------------------------
Find a silently evolved API code:android.view.inputmethod.EditorInfo.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Used to package this object into a {@link Parcel}.
 *
 * @param dest The {@link Parcel} to be written.
 * @param flags The flags used for parceling.
 */

Body of Frist Method:
{
    dest.writeInt(inputType);
    dest.writeInt(imeOptions);
    dest.writeString(privateImeOptions);
    TextUtils.writeToParcel(actionLabel, dest, flags);
    dest.writeInt(actionId);
    dest.writeInt(initialSelStart);
    dest.writeInt(initialSelEnd);
    dest.writeInt(initialCapsMode);
    TextUtils.writeToParcel(hintText, dest, flags);
    TextUtils.writeToParcel(label, dest, flags);
    dest.writeString(packageName);
    dest.writeParcelable(autofillId, flags);
    dest.writeInt(fieldId);
    dest.writeString(fieldName);
    dest.writeBundle(extras);
    mInitialSurroundingText.writeToParcel(dest, flags);
    if (hintLocales != null) {
        hintLocales.writeToParcel(dest, flags);
    } else {
        LocaleList.getEmptyLocaleList().writeToParcel(dest, flags);
    }
    dest.writeStringArray(contentMimeTypes);
    UserHandle.writeToParcel(targetInputMethodUser, dest);
}
Body of Second Method:
{
    dest.writeInt(inputType);
    dest.writeInt(imeOptions);
    dest.writeString(privateImeOptions);
    dest.writeInt(internalImeOptions);
    TextUtils.writeToParcel(actionLabel, dest, flags);
    dest.writeInt(actionId);
    dest.writeInt(initialSelStart);
    dest.writeInt(initialSelEnd);
    dest.writeInt(initialCapsMode);
    TextUtils.writeToParcel(hintText, dest, flags);
    TextUtils.writeToParcel(label, dest, flags);
    dest.writeString(packageName);
    dest.writeParcelable(autofillId, flags);
    dest.writeInt(fieldId);
    dest.writeString(fieldName);
    dest.writeBundle(extras);
    dest.writeBoolean(mInitialSurroundingText != null);
    if (mInitialSurroundingText != null) {
        mInitialSurroundingText.writeToParcel(dest, flags);
    }
    if (hintLocales != null) {
        hintLocales.writeToParcel(dest, flags);
    } else {
        LocaleList.getEmptyLocaleList().writeToParcel(dest, flags);
    }
    dest.writeStringArray(contentMimeTypes);
    UserHandle.writeToParcel(targetInputMethodUser, dest);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothSocket.connect:COMMENT
Method Modifier: public      
Comment:/**
 * Attempt to connect to a remote device.
 * <p>This method will block until a connection is made or the connection
 * fails. If this method returns without an exception then this socket
 * is now connected.
 * <p>Creating new connections to
 * remote Bluetooth devices should not be attempted while device discovery
 * is in progress. Device discovery is a heavyweight procedure on the
 * Bluetooth adapter and will significantly slow a device connection.
 * Use {@link BluetoothAdapter#cancelDiscovery()} to cancel an ongoing
 * discovery. Discovery is not managed by the Activity,
 * but is run as a system service, so an application should always call
 * {@link BluetoothAdapter#cancelDiscovery()} even if it
 * did not directly request a discovery, just to be sure.
 * <p>{@link #close} can be used to abort this call from another thread.
 *
 * @throws IOException on error, for example connection failure
 */

Body of Frist Method:
{
    if (mDevice == null)
        throw new IOException("Connect is called on null device");
    try {
        if (mSocketState == SocketState.CLOSED)
            throw new IOException("socket closed");
        IBluetooth bluetoothProxy = BluetoothAdapter.getDefaultAdapter().getBluetoothService(null);
        if (bluetoothProxy == null)
            throw new IOException("Bluetooth is off");
        mPfd = bluetoothProxy.getSocketManager().connectSocket(mDevice, mType, mUuid, mPort, getSecurityFlags());
        synchronized (this) {
            if (DBG)
                Log.d(TAG, "connect(), SocketState: " + mSocketState + ", mPfd: " + mPfd);
            if (mSocketState == SocketState.CLOSED)
                throw new IOException("socket closed");
            if (mPfd == null)
                throw new IOException("bt socket connect failed");
            FileDescriptor fd = mPfd.getFileDescriptor();
            mSocket = LocalSocket.createConnectedLocalSocket(fd);
            mSocketIS = mSocket.getInputStream();
            mSocketOS = mSocket.getOutputStream();
        }
        int channel = readInt(mSocketIS);
        if (channel <= 0) {
            throw new IOException("bt socket connect failed");
        }
        mPort = channel;
        waitSocketSignal(mSocketIS);
        synchronized (this) {
            if (mSocketState == SocketState.CLOSED) {
                throw new IOException("bt socket closed");
            }
            mSocketState = SocketState.CONNECTED;
        }
    } catch (RemoteException e) {
        Log.e(TAG, Log.getStackTraceString(new Throwable()));
        throw new IOException("unable to send RPC: " + e.getMessage());
    }
}
Body of Second Method:
{
    if (mDevice == null)
        throw new IOException("Connect is called on null device");
    try {
        if (mSocketState == SocketState.CLOSED)
            throw new IOException("socket closed");
        IBluetooth bluetoothProxy = BluetoothAdapter.getDefaultAdapter().getBluetoothService();
        if (bluetoothProxy == null)
            throw new IOException("Bluetooth is off");
        mPfd = bluetoothProxy.getSocketManager().connectSocket(mDevice, mType, mUuid, mPort, getSecurityFlags());
        synchronized (this) {
            if (DBG)
                Log.d(TAG, "connect(), SocketState: " + mSocketState + ", mPfd: " + mPfd);
            if (mSocketState == SocketState.CLOSED)
                throw new IOException("socket closed");
            if (mPfd == null)
                throw new IOException("bt socket connect failed");
            FileDescriptor fd = mPfd.getFileDescriptor();
            mSocket = LocalSocket.createConnectedLocalSocket(fd);
            mSocketIS = mSocket.getInputStream();
            mSocketOS = mSocket.getOutputStream();
        }
        int channel = readInt(mSocketIS);
        if (channel <= 0) {
            throw new IOException("bt socket connect failed");
        }
        mPort = channel;
        waitSocketSignal(mSocketIS);
        synchronized (this) {
            if (mSocketState == SocketState.CLOSED) {
                throw new IOException("bt socket closed");
            }
            mSocketState = SocketState.CONNECTED;
        }
    } catch (RemoteException e) {
        Log.e(TAG, Log.getStackTraceString(new Throwable()));
        throw new IOException("unable to send RPC: " + e.getMessage());
    }
}
------------------------
Find a silently evolved API code:android.content.pm.ActivityInfo.hasFixedAspectRatio:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns true if the activity has maximum or minimum aspect ratio.
 * @hide
 */

Body of Frist Method:
{
    return maxAspectRatio != 0 || minAspectRatio != 0;
}
Body of Second Method:
{
    return getMaxAspectRatio() != 0 || getMinAspectRatio() != 0;
}
------------------------
Find a silently evolved API code:android.widget.EdgeEffect.setSize:COMMENT
Method Modifier: public      
Comment:/**
 * Set the size of this edge effect in pixels.
 *
 * @param width Effect width in pixels
 * @param height Effect height in pixels
 */

Body of Frist Method:
{
    final float r = width * RADIUS_FACTOR / SIN;
    final float y = COS * r;
    final float h = r - y;
    final float or = height * RADIUS_FACTOR / SIN;
    final float oy = COS * or;
    final float oh = or - oy;
    mRadius = r;
    mBaseGlowScale = h > 0 ? Math.min(oh / h, 1.f) : 1.f;
    mBounds.set(mBounds.left, mBounds.top, width, (int) Math.min(height, h));
}
Body of Second Method:
{
    final float r = width * RADIUS_FACTOR / SIN;
    final float y = COS * r;
    final float h = r - y;
    final float or = height * RADIUS_FACTOR / SIN;
    final float oy = COS * or;
    final float oh = or - oy;
    mRadius = r;
    mBaseGlowScale = h > 0 ? Math.min(oh / h, 1.f) : 1.f;
    mBounds.set(mBounds.left, mBounds.top, width, (int) Math.min(height, h));
    mWidth = width;
    mHeight = height;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothSap.getConnectionPolicy:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the connection policy of the profile.
 *
 * <p> The connection policy can be any of:
 * {@link #CONNECTION_POLICY_ALLOWED}, {@link #CONNECTION_POLICY_FORBIDDEN},
 * {@link #CONNECTION_POLICY_UNKNOWN}
 *
 * @param device Bluetooth device
 * @return connection policy of the device
 * @hide
 */

Body of Frist Method:
{
    if (VDBG)
        log("getConnectionPolicy(" + device + ")");
    final IBluetoothSap service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getConnectionPolicy(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.CONNECTION_POLICY_FORBIDDEN;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return BluetoothProfile.CONNECTION_POLICY_FORBIDDEN;
}
Body of Second Method:
{
    if (VDBG)
        log("getConnectionPolicy(" + device + ")");
    final IBluetoothSap service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getConnectionPolicy(device, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.CONNECTION_POLICY_FORBIDDEN;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return BluetoothProfile.CONNECTION_POLICY_FORBIDDEN;
}
------------------------
Find a silently evolved API code:android.os.Debug.stopNativeTracing:COMMENT
Method Modifier: public      static      
Comment:/**
 * Stop qemu tracing.  See {@link #startNativeTracing()} to start tracing.
 *
 * <p>Tracing can be started and stopped as many times as desired.  When
 * the qemu emulator itself is stopped then the buffered trace records
 * are flushed and written to the trace file.  In fact, it is not necessary
 * to call this method at all; simply killing qemu is sufficient.  But
 * starting and stopping a trace is useful for examining a specific
 * region of code.</p>
 */

Body of Frist Method:
{
    VMDebug.stopEmulatorTracing();
    // Open the sysfs file for writing and write "0" to it.
    PrintWriter outStream = null;
    try {
        FileOutputStream fos = new FileOutputStream(SYSFS_QEMU_TRACE_STATE);
        outStream = new FastPrintWriter(fos);
        outStream.println("0");
    } catch (Exception e) {
    // We could print an error message here but we probably want
    // to quietly ignore errors if we are not running in the emulator.
    } finally {
        if (outStream != null)
            outStream.close();
    }
}
Body of Second Method:
{
    // Open the sysfs file for writing and write "0" to it.
    PrintWriter outStream = null;
    try {
        FileOutputStream fos = new FileOutputStream(SYSFS_QEMU_TRACE_STATE);
        outStream = new FastPrintWriter(fos);
        outStream.println("0");
    } catch (Exception e) {
    // We could print an error message here but we probably want
    // to quietly ignore errors if we are not running in the emulator.
    } finally {
        if (outStream != null)
            outStream.close();
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothDevice.getUuids:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the supported features (UUIDs) of the remote device.
 *
 * <p>This method does not start a service discovery procedure to retrieve the UUIDs
 * from the remote device. Instead, the local cached copy of the service
 * UUIDs are returned.
 * <p>Use {@link #fetchUuidsWithSdp} if fresh UUIDs are desired.
 *
 * @return the supported features (UUIDs) of the remote device, or null on error
 */

Body of Frist Method:
{
    final IBluetooth service = sService;
    if (service == null || !isBluetoothEnabled()) {
        Log.e(TAG, "BT not enabled. Cannot get remote device Uuids");
        return null;
    }
    try {
        return service.getRemoteUuids(this);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return null;
}
Body of Second Method:
{
    final IBluetooth service = sService;
    if (service == null || !isBluetoothEnabled()) {
        Log.e(TAG, "BT not enabled. Cannot get remote device Uuids");
        return null;
    }
    try {
        return service.getRemoteUuids(this, mAttributionSource);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return null;
}
------------------------
Find a silently evolved API code:android.telephony.AccessNetworkConstants.transportTypeToString:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    switch(transportType) {
        case TRANSPORT_TYPE_WWAN:
            return "WWAN";
        case TRANSPORT_TYPE_WLAN:
            return "WLAN";
        default:
            return Integer.toString(transportType);
    }
}
Body of Second Method:
{
    switch(transportType) {
        case TRANSPORT_TYPE_WWAN:
            return "WWAN";
        case TRANSPORT_TYPE_WLAN:
            return "WLAN";
        case TRANSPORT_TYPE_INVALID:
            return "INVALID";
        default:
            return Integer.toString(transportType);
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothDevice.getType:COMMENT
Method Modifier: public      
Comment:/**
 * Get the Bluetooth device type of the remote device.
 *
 * @return the device type {@link #DEVICE_TYPE_CLASSIC}, {@link #DEVICE_TYPE_LE} {@link
 * #DEVICE_TYPE_DUAL}. {@link #DEVICE_TYPE_UNKNOWN} if it's not available
 */

Body of Frist Method:
{
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, "BT not enabled. Cannot get Remote Device type");
        return DEVICE_TYPE_UNKNOWN;
    }
    try {
        return service.getRemoteType(this);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return DEVICE_TYPE_UNKNOWN;
}
Body of Second Method:
{
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, "BT not enabled. Cannot get Remote Device type");
        return DEVICE_TYPE_UNKNOWN;
    }
    try {
        return service.getRemoteType(this, mAttributionSource);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return DEVICE_TYPE_UNKNOWN;
}
------------------------
Find a silently evolved API code:android.bluetooth.le.AdvertisingSet.setAdvertisingData:COMMENT
Method Modifier: public      
Comment:/**
 * Set/update data being Advertised. Make sure that data doesn't exceed the size limit for
 * specified AdvertisingSetParameters. This method returns immediately, the operation status is
 * delivered through {@code callback.onAdvertisingDataSet()}.
 * <p>
 * Advertising data must be empty if non-legacy scannable advertising is used.
 *
 * @param advertiseData Advertisement data to be broadcasted. Size must not exceed {@link
 * BluetoothAdapter#getLeMaximumAdvertisingDataLength}. If the advertisement is connectable,
 * three bytes will be added for flags. If the update takes place when the advertising set is
 * enabled, the data can be maximum 251 bytes long.
 */

Body of Frist Method:
{
    try {
        mGatt.setAdvertisingData(mAdvertiserId, advertiseData);
    } catch (RemoteException e) {
        Log.e(TAG, "remote exception - ", e);
    }
}
Body of Second Method:
{
    try {
        mGatt.setAdvertisingData(mAdvertiserId, advertiseData, mAttributionSource);
    } catch (RemoteException e) {
        Log.e(TAG, "remote exception - ", e);
    }
}
------------------------
Find a silently evolved API code:android.content.ContentProviderClient.openFile:COMMENT
Method Modifier: public      
Comment:/**
 * See {@link ContentProvider#openFile ContentProvider.openFile}.  Note that
 * this <em>does not</em>
 * take care of non-content: URIs such as file:.  It is strongly recommended
 * you use the {@link ContentResolver#openFileDescriptor
 * ContentResolver.openFileDescriptor} API instead.
 */

Body of Frist Method:
{
    Objects.requireNonNull(url, "url");
    Objects.requireNonNull(mode, "mode");
    beforeRemote();
    try {
        ICancellationSignal remoteSignal = null;
        if (signal != null) {
            signal.throwIfCanceled();
            remoteSignal = mContentProvider.createCancellationSignal();
            signal.setRemote(remoteSignal);
        }
        return mContentProvider.openFile(mPackageName, mAttributionTag, url, mode, remoteSignal, null);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}
Body of Second Method:
{
    return openFile(url, mode, null);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothA2dp.getPriority:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the priority of the profile.
 *
 * <p> The priority can be any of:
 * {@link #PRIORITY_OFF}, {@link #PRIORITY_ON}, {@link #PRIORITY_UNDEFINED}
 *
 * @param device Bluetooth device
 * @return priority of the device
 * @hide
 */

Body of Frist Method:
{
    if (VDBG)
        log("getPriority(" + device + ")");
    try {
        final IBluetoothA2dp service = getService();
        if (service != null && isEnabled() && isValidDevice(device)) {
            return BluetoothAdapter.connectionPolicyToPriority(service.getPriority(device));
        }
        if (service == null)
            Log.w(TAG, "Proxy not attached to service");
        return BluetoothProfile.PRIORITY_OFF;
    } catch (RemoteException e) {
        Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
        return BluetoothProfile.PRIORITY_OFF;
    }
}
Body of Second Method:
{
    if (VDBG)
        log("getPriority(" + device + ")");
    try {
        final IBluetoothA2dp service = getService();
        if (service != null && isEnabled() && isValidDevice(device)) {
            return BluetoothAdapter.connectionPolicyToPriority(service.getPriority(device, mAttributionSource));
        }
        if (service == null)
            Log.w(TAG, "Proxy not attached to service");
        return BluetoothProfile.PRIORITY_OFF;
    } catch (RemoteException e) {
        Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
        return BluetoothProfile.PRIORITY_OFF;
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.le.AdvertiseData.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Build the {@link AdvertiseData}.
 */

Body of Frist Method:
{
    return new AdvertiseData(mServiceUuids, mManufacturerSpecificData, mServiceData, mIncludeTxPowerLevel, mIncludeDeviceName);
}
Body of Second Method:
{
    return new AdvertiseData(mServiceUuids, mServiceSolicitationUuids, mManufacturerSpecificData, mServiceData, mIncludeTxPowerLevel, mIncludeDeviceName);
}
------------------------
Find a silently evolved API code:android.app.servertransaction.TransactionExecutorHelper.getLifecycleRequestForCurrentState:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Get the lifecycle state request to match the current state in the end of a transaction.
 */

Body of Frist Method:
{
    final int prevState = r.getLifecycleState();
    final ActivityLifecycleItem lifecycleItem;
    switch(prevState) {
        // TODO(lifecycler): Extend to support all possible states.
        case ON_PAUSE:
            lifecycleItem = PauseActivityItem.obtain();
            break;
        case ON_STOP:
            lifecycleItem = StopActivityItem.obtain(0);
            break;
        default:
            lifecycleItem = ResumeActivityItem.obtain(false);
            break;
    }
    return lifecycleItem;
}
Body of Second Method:
{
    final int prevState = r.getLifecycleState();
    final ActivityLifecycleItem lifecycleItem;
    switch(prevState) {
        // TODO(lifecycler): Extend to support all possible states.
        case ON_START:
            lifecycleItem = StartActivityItem.obtain(null);
            break;
        case ON_PAUSE:
            lifecycleItem = PauseActivityItem.obtain();
            break;
        case ON_STOP:
            lifecycleItem = StopActivityItem.obtain(0);
            break;
        default:
            lifecycleItem = ResumeActivityItem.obtain(false);
            break;
    }
    return lifecycleItem;
}
------------------------
Find a silently evolved API code:android.app.WindowConfiguration.hashCode:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    int result = 0;
    if (mAppBounds != null) {
        result = 31 * result + mAppBounds.hashCode();
    }
    result = 31 * result + mBounds.hashCode();
    result = 31 * result + mWindowingMode;
    result = 31 * result + mActivityType;
    result = 31 * result + mAlwaysOnTop;
    result = 31 * result + mRotation;
    result = 31 * result + mDisplayWindowingMode;
    return result;
}
Body of Second Method:
{
    int result = 0;
    result = 31 * result + Objects.hashCode(mAppBounds);
    result = 31 * result + Objects.hashCode(mBounds);
    result = 31 * result + Objects.hashCode(mMaxBounds);
    result = 31 * result + mWindowingMode;
    result = 31 * result + mActivityType;
    result = 31 * result + mAlwaysOnTop;
    result = 31 * result + mRotation;
    result = 31 * result + mDisplayWindowingMode;
    return result;
}
------------------------
Find a silently evolved API code:android.media.tv.tuner.frontend.DvbcFrontendSettings.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Builds a {@link DvbcFrontendSettings} object.
 */

Body of Frist Method:
{
    return new DvbcFrontendSettings(mFrequency, mModulation, mInnerFec, mSymbolRate, mOuterFec, mAnnex, mSpectralInversion);
}
Body of Second Method:
{
    return new DvbcFrontendSettings(mFrequency, mModulation, mInnerFec, mSymbolRate, mOuterFec, mAnnex, mSpectralInversion, mInterleaveMode, mBandwidth);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothDevice.setMessageAccessPermission:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets whether the message access is allowed to this device.
 *
 * @param value Can be {@link #ACCESS_UNKNOWN} if the device is unbonded,
 * {@link #ACCESS_ALLOWED} if the permission is being granted, or {@link #ACCESS_REJECTED} if
 * the permission is not being granted.
 * @return Whether the value has been successfully set.
 * @hide
 */

Body of Frist Method:
{
    // Validates param value is one of the accepted constants
    if (value != ACCESS_ALLOWED && value != ACCESS_REJECTED && value != ACCESS_UNKNOWN) {
        throw new IllegalArgumentException(value + "is not a valid AccessPermission value");
    }
    final IBluetooth service = sService;
    if (service == null) {
        return false;
    }
    try {
        return service.setMessageAccessPermission(this, value);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
Body of Second Method:
{
    // Validates param value is one of the accepted constants
    if (value != ACCESS_ALLOWED && value != ACCESS_REJECTED && value != ACCESS_UNKNOWN) {
        throw new IllegalArgumentException(value + "is not a valid AccessPermission value");
    }
    final IBluetooth service = sService;
    if (service == null) {
        return false;
    }
    try {
        return service.setMessageAccessPermission(this, value, mAttributionSource);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
------------------------
Find a silently evolved API code:android.telephony.CellSignalStrengthLte.updateLevel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    int[] rsrpThresholds, rsrqThresholds, rssnrThresholds;
    boolean rsrpOnly;
    if (cc == null) {
        mParametersUseForLevel = USE_RSRP;
        rsrpThresholds = sRsrpThresholds;
        rsrqThresholds = sRsrqThresholds;
        rssnrThresholds = sRssnrThresholds;
        rsrpOnly = false;
    } else {
        mParametersUseForLevel = cc.getInt(CarrierConfigManager.KEY_PARAMETERS_USED_FOR_LTE_SIGNAL_BAR_INT);
        if (DBG) {
            Rlog.i(LOG_TAG, "Using signal strength level: " + mParametersUseForLevel);
        }
        rsrpThresholds = cc.getIntArray(CarrierConfigManager.KEY_LTE_RSRP_THRESHOLDS_INT_ARRAY);
        if (rsrpThresholds == null)
            rsrpThresholds = sRsrpThresholds;
        if (DBG) {
            Rlog.i(LOG_TAG, "Applying LTE RSRP Thresholds: " + Arrays.toString(rsrpThresholds));
        }
        rsrqThresholds = cc.getIntArray(CarrierConfigManager.KEY_LTE_RSRQ_THRESHOLDS_INT_ARRAY);
        if (rsrqThresholds == null)
            rsrqThresholds = sRsrqThresholds;
        if (DBG) {
            Rlog.i(LOG_TAG, "Applying LTE RSRQ Thresholds: " + Arrays.toString(rsrqThresholds));
        }
        rssnrThresholds = cc.getIntArray(CarrierConfigManager.KEY_LTE_RSSNR_THRESHOLDS_INT_ARRAY);
        if (rssnrThresholds == null)
            rssnrThresholds = sRssnrThresholds;
        if (DBG) {
            Rlog.i(LOG_TAG, "Applying LTE RSSNR Thresholds: " + Arrays.toString(rssnrThresholds));
        }
        rsrpOnly = cc.getBoolean(CarrierConfigManager.KEY_USE_ONLY_RSRP_FOR_LTE_SIGNAL_BAR_BOOL, false);
    }
    int rsrpBoost = 0;
    if (ss != null) {
        rsrpBoost = ss.getLteEarfcnRsrpBoost();
    }
    int rsrp = inRangeOrUnavailable(mRsrp + rsrpBoost, MIN_LTE_RSRP, MAX_LTE_RSRP);
    if (rsrpOnly) {
        int level = updateLevelWithMeasure(rsrp, rsrpThresholds);
        if (DBG)
            log("updateLevel() - rsrp = " + level);
        if (level != SignalStrength.INVALID) {
            mLevel = level;
            return;
        }
    }
    int rsrpLevel = SignalStrength.INVALID;
    int rsrqLevel = SignalStrength.INVALID;
    int rssnrLevel = SignalStrength.INVALID;
    if (isLevelForParameter(USE_RSRP)) {
        rsrpLevel = updateLevelWithMeasure(rsrp, rsrpThresholds);
        if (DBG) {
            Rlog.i(LOG_TAG, "Updated 4G LTE RSRP Level: " + rsrpLevel);
        }
    }
    if (isLevelForParameter(USE_RSRQ)) {
        rsrqLevel = updateLevelWithMeasure(mRsrq, rsrqThresholds);
        if (DBG) {
            Rlog.i(LOG_TAG, "Updated 4G LTE RSRQ Level: " + rsrqLevel);
        }
    }
    if (isLevelForParameter(USE_RSSNR)) {
        rssnrLevel = updateLevelWithMeasure(mRssnr, rssnrThresholds);
        if (DBG) {
            Rlog.i(LOG_TAG, "Updated 4G LTE RSSNR Level: " + rssnrLevel);
        }
    }
    // Apply the smaller value among three levels of three measures.
    mLevel = Math.min(Math.min(rsrpLevel, rsrqLevel), rssnrLevel);
    if (mLevel == SignalStrength.INVALID) {
        int rssiLevel;
        if (mRssi > -51) {
            rssiLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
        } else if (mRssi >= -89) {
            rssiLevel = SIGNAL_STRENGTH_GREAT;
        } else if (mRssi >= -97) {
            rssiLevel = SIGNAL_STRENGTH_GOOD;
        } else if (mRssi >= -103) {
            rssiLevel = SIGNAL_STRENGTH_MODERATE;
        } else if (mRssi >= -113) {
            rssiLevel = SIGNAL_STRENGTH_POOR;
        } else {
            rssiLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
        }
        if (DBG)
            log("getLteLevel - rssi:" + mRssi + " rssiIconLevel:" + rssiLevel);
        mLevel = rssiLevel;
    }
}
Body of Second Method:
{
    int[] rsrpThresholds, rsrqThresholds, rssnrThresholds;
    boolean rsrpOnly;
    if (cc == null) {
        mParametersUseForLevel = USE_RSRP;
        rsrpThresholds = sRsrpThresholds;
        rsrqThresholds = sRsrqThresholds;
        rssnrThresholds = sRssnrThresholds;
        rsrpOnly = false;
    } else {
        mParametersUseForLevel = cc.getInt(CarrierConfigManager.KEY_PARAMETERS_USED_FOR_LTE_SIGNAL_BAR_INT);
        if (DBG) {
            Rlog.i(LOG_TAG, "Using signal strength level: " + mParametersUseForLevel);
        }
        rsrpThresholds = cc.getIntArray(CarrierConfigManager.KEY_LTE_RSRP_THRESHOLDS_INT_ARRAY);
        if (rsrpThresholds == null)
            rsrpThresholds = sRsrpThresholds;
        if (DBG) {
            Rlog.i(LOG_TAG, "Applying LTE RSRP Thresholds: " + Arrays.toString(rsrpThresholds));
        }
        rsrqThresholds = cc.getIntArray(CarrierConfigManager.KEY_LTE_RSRQ_THRESHOLDS_INT_ARRAY);
        if (rsrqThresholds == null)
            rsrqThresholds = sRsrqThresholds;
        if (DBG) {
            Rlog.i(LOG_TAG, "Applying LTE RSRQ Thresholds: " + Arrays.toString(rsrqThresholds));
        }
        rssnrThresholds = cc.getIntArray(CarrierConfigManager.KEY_LTE_RSSNR_THRESHOLDS_INT_ARRAY);
        if (rssnrThresholds == null)
            rssnrThresholds = sRssnrThresholds;
        if (DBG) {
            Rlog.i(LOG_TAG, "Applying LTE RSSNR Thresholds: " + Arrays.toString(rssnrThresholds));
        }
        rsrpOnly = cc.getBoolean(CarrierConfigManager.KEY_USE_ONLY_RSRP_FOR_LTE_SIGNAL_BAR_BOOL, false);
    }
    int rsrpBoost = 0;
    if (ss != null) {
        rsrpBoost = ss.getArfcnRsrpBoost();
    }
    int rsrp = inRangeOrUnavailable(mRsrp + rsrpBoost, MIN_LTE_RSRP, MAX_LTE_RSRP);
    if (rsrpOnly) {
        int level = updateLevelWithMeasure(rsrp, rsrpThresholds);
        if (DBG)
            log("updateLevel() - rsrp = " + level);
        if (level != SignalStrength.INVALID) {
            mLevel = level;
            return;
        }
    }
    int rsrpLevel = SignalStrength.INVALID;
    int rsrqLevel = SignalStrength.INVALID;
    int rssnrLevel = SignalStrength.INVALID;
    if (isLevelForParameter(USE_RSRP)) {
        rsrpLevel = updateLevelWithMeasure(rsrp, rsrpThresholds);
        if (DBG) {
            Rlog.i(LOG_TAG, "Updated 4G LTE RSRP Level: " + rsrpLevel);
        }
    }
    if (isLevelForParameter(USE_RSRQ)) {
        rsrqLevel = updateLevelWithMeasure(mRsrq, rsrqThresholds);
        if (DBG) {
            Rlog.i(LOG_TAG, "Updated 4G LTE RSRQ Level: " + rsrqLevel);
        }
    }
    if (isLevelForParameter(USE_RSSNR)) {
        rssnrLevel = updateLevelWithMeasure(mRssnr, rssnrThresholds);
        if (DBG) {
            Rlog.i(LOG_TAG, "Updated 4G LTE RSSNR Level: " + rssnrLevel);
        }
    }
    // Apply the smaller value among three levels of three measures.
    mLevel = Math.min(Math.min(rsrpLevel, rsrqLevel), rssnrLevel);
    if (mLevel == SignalStrength.INVALID) {
        int rssiLevel;
        if (mRssi > -51) {
            rssiLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
        } else if (mRssi >= -89) {
            rssiLevel = SIGNAL_STRENGTH_GREAT;
        } else if (mRssi >= -97) {
            rssiLevel = SIGNAL_STRENGTH_GOOD;
        } else if (mRssi >= -103) {
            rssiLevel = SIGNAL_STRENGTH_MODERATE;
        } else if (mRssi >= -113) {
            rssiLevel = SIGNAL_STRENGTH_POOR;
        } else {
            rssiLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
        }
        if (DBG)
            log("getLteLevel - rssi:" + mRssi + " rssiIconLevel:" + rssiLevel);
        mLevel = rssiLevel;
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHidHost.getConnectionPolicy:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the connection policy of the profile.
 *
 * <p> The connection policy can be any of:
 * {@link #CONNECTION_POLICY_ALLOWED}, {@link #CONNECTION_POLICY_FORBIDDEN},
 * {@link #CONNECTION_POLICY_UNKNOWN}
 *
 * @param device Bluetooth device
 * @return connection policy of the device
 * @hide
 */

Body of Frist Method:
{
    if (VDBG)
        log("getConnectionPolicy(" + device + ")");
    if (device == null) {
        throw new IllegalArgumentException("device must not be null");
    }
    final IBluetoothHidHost service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getConnectionPolicy(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.CONNECTION_POLICY_FORBIDDEN;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return BluetoothProfile.CONNECTION_POLICY_FORBIDDEN;
}
Body of Second Method:
{
    if (VDBG)
        log("getConnectionPolicy(" + device + ")");
    if (device == null) {
        throw new IllegalArgumentException("device must not be null");
    }
    final IBluetoothHidHost service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getConnectionPolicy(device, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.CONNECTION_POLICY_FORBIDDEN;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return BluetoothProfile.CONNECTION_POLICY_FORBIDDEN;
}
------------------------
Find a silently evolved API code:android.content.integrity.IntegrityUtils.getBytesFromHexDigest:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Obtain the raw bytes from hex encoded string.
 *
 * @throws IllegalArgumentException if {@code hexDigest} is not a valid hex encoding of some
 * bytes
 */

Body of Frist Method:
{
    checkArgument(hexDigest.length() % 2 == 0, "Invalid hex encoding " + hexDigest + ": must have even length");
    byte[] rawBytes = new byte[hexDigest.length() / 2];
    for (int i = 0; i < rawBytes.length; i++) {
        int upperNibble = hexDigest.charAt(2 * i);
        int lowerNibble = hexDigest.charAt(2 * i + 1);
        rawBytes[i] = (byte) ((hexToDec(upperNibble) << 4) | hexToDec(lowerNibble));
    }
    return rawBytes;
}
Body of Second Method:
{
    checkArgument(hexDigest.length() % 2 == 0, "Invalid hex encoding %s: must have even length", hexDigest);
    byte[] rawBytes = new byte[hexDigest.length() / 2];
    for (int i = 0; i < rawBytes.length; i++) {
        int upperNibble = hexDigest.charAt(2 * i);
        int lowerNibble = hexDigest.charAt(2 * i + 1);
        rawBytes[i] = (byte) ((hexToDec(upperNibble) << 4) | hexToDec(lowerNibble));
    }
    return rawBytes;
}
------------------------
Find a silently evolved API code:android.view.Choreographer.FrameDisplayEventReceiver.onVsync:COMMENT
Method Modifier: public      
Comment:// for the internal display implicitly.

Body of Frist Method:
{
    // Post the vsync event to the Handler.
    // The idea is to prevent incoming vsync events from completely starving
    // the message queue.  If there are no messages in the queue with timestamps
    // earlier than the frame time, then the vsync event will be processed immediately.
    // Otherwise, messages that predate the vsync event will be handled first.
    long now = System.nanoTime();
    if (timestampNanos > now) {
        Log.w(TAG, "Frame time is " + ((timestampNanos - now) * 0.000001f) + " ms in the future!  Check that graphics HAL is generating vsync " + "timestamps using the correct timebase.");
        timestampNanos = now;
    }
    if (mHavePendingVsync) {
        Log.w(TAG, "Already have a pending vsync event.  There should only be " + "one at a time.");
    } else {
        mHavePendingVsync = true;
    }
    mTimestampNanos = timestampNanos;
    mFrame = frame;
    Message msg = Message.obtain(mHandler, this);
    msg.setAsynchronous(true);
    mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);
}
Body of Second Method:
{
    try {
        if (Trace.isTagEnabled(Trace.TRACE_TAG_VIEW)) {
            Trace.traceBegin(Trace.TRACE_TAG_VIEW, "Choreographer#onVsync " + vsyncEventData.id);
        }
        // Post the vsync event to the Handler.
        // The idea is to prevent incoming vsync events from completely starving
        // the message queue.  If there are no messages in the queue with timestamps
        // earlier than the frame time, then the vsync event will be processed immediately.
        // Otherwise, messages that predate the vsync event will be handled first.
        long now = System.nanoTime();
        if (timestampNanos > now) {
            Log.w(TAG, "Frame time is " + ((timestampNanos - now) * 0.000001f) + " ms in the future!  Check that graphics HAL is generating vsync " + "timestamps using the correct timebase.");
            timestampNanos = now;
        }
        if (mHavePendingVsync) {
            Log.w(TAG, "Already have a pending vsync event.  There should only be " + "one at a time.");
        } else {
            mHavePendingVsync = true;
        }
        mTimestampNanos = timestampNanos;
        mFrame = frame;
        mLastVsyncEventData = vsyncEventData;
        Message msg = Message.obtain(mHandler, this);
        msg.setAsynchronous(true);
        mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_VIEW);
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.getConnectionPolicy:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the connection policy of the profile.
 *
 * <p> The connection policy can be any of:
 * {@link #CONNECTION_POLICY_ALLOWED}, {@link #CONNECTION_POLICY_FORBIDDEN},
 * {@link #CONNECTION_POLICY_UNKNOWN}
 *
 * @param device Bluetooth device
 * @return connection policy of the device
 * @hide
 */

Body of Frist Method:
{
    if (VDBG)
        log("getConnectionPolicy(" + device + ")");
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getConnectionPolicy(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.CONNECTION_POLICY_FORBIDDEN;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return BluetoothProfile.CONNECTION_POLICY_FORBIDDEN;
}
Body of Second Method:
{
    if (VDBG)
        log("getConnectionPolicy(" + device + ")");
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getConnectionPolicy(device, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.CONNECTION_POLICY_FORBIDDEN;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return BluetoothProfile.CONNECTION_POLICY_FORBIDDEN;
}
------------------------
Find a silently evolved API code:android.media.AudioFormat.isValidEncoding:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    switch(audioFormat) {
        case ENCODING_PCM_16BIT:
        case ENCODING_PCM_8BIT:
        case ENCODING_PCM_FLOAT:
        case ENCODING_AC3:
        case ENCODING_E_AC3:
        case ENCODING_DTS:
        case ENCODING_DTS_HD:
        case ENCODING_MP3:
        case ENCODING_AAC_LC:
        case ENCODING_AAC_HE_V1:
        case ENCODING_AAC_HE_V2:
        case ENCODING_IEC61937:
        case ENCODING_DOLBY_TRUEHD:
        case ENCODING_AAC_ELD:
        case ENCODING_AAC_XHE:
        case ENCODING_AC4:
        case ENCODING_E_AC3_JOC:
        case ENCODING_DOLBY_MAT:
        case ENCODING_OPUS:
            return true;
        default:
            return false;
    }
}
Body of Second Method:
{
    switch(audioFormat) {
        case ENCODING_PCM_16BIT:
        case ENCODING_PCM_8BIT:
        case ENCODING_PCM_FLOAT:
        case ENCODING_AC3:
        case ENCODING_E_AC3:
        case ENCODING_DTS:
        case ENCODING_DTS_HD:
        case ENCODING_MP3:
        case ENCODING_AAC_LC:
        case ENCODING_AAC_HE_V1:
        case ENCODING_AAC_HE_V2:
        case ENCODING_IEC61937:
        case ENCODING_DOLBY_TRUEHD:
        case ENCODING_AAC_ELD:
        case ENCODING_AAC_XHE:
        case ENCODING_AC4:
        case ENCODING_E_AC3_JOC:
        case ENCODING_DOLBY_MAT:
        case ENCODING_OPUS:
        case ENCODING_PCM_24BIT_PACKED:
        case ENCODING_PCM_32BIT:
        case ENCODING_MPEGH_BL_L3:
        case ENCODING_MPEGH_BL_L4:
        case ENCODING_MPEGH_LC_L3:
        case ENCODING_MPEGH_LC_L4:
        case ENCODING_DTS_UHD:
        case ENCODING_DRA:
            return true;
        default:
            return false;
    }
}
------------------------
Find a silently evolved API code:android.media.audiopolicy.AudioMixingRule.containsMatchAttributeRuleForUsage:COMMENT
Method Modifier: default     hidden      
Comment:/**
 * Returns {@code true} if this rule contains a RULE_MATCH_ATTRIBUTE_USAGE criterion for
 * the given usage
 *
 * @hide
 */

Body of Frist Method:
{
    for (AudioMixMatchCriterion criterion : mCriteria) {
        if (criterion.mRule == RULE_MATCH_ATTRIBUTE_USAGE && criterion.mAttr != null && criterion.mAttr.getUsage() == usage) {
            return true;
        }
    }
    return false;
}
Body of Second Method:
{
    for (AudioMixMatchCriterion criterion : mCriteria) {
        if (criterion.mRule == RULE_MATCH_ATTRIBUTE_USAGE && criterion.mAttr != null && criterion.mAttr.getSystemUsage() == usage) {
            return true;
        }
    }
    return false;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadset.phoneStateChanged:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Notify Headset of phone state change.
 * This is a backdoor for phone app to call BluetoothHeadset since
 * there is currently not a good way to get precise call state change outside
 * of phone app.
 *
 * @hide
 */

Body of Frist Method:
{
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled()) {
        try {
            service.phoneStateChanged(numActive, numHeld, callState, number, type, name);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
}
Body of Second Method:
{
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled()) {
        try {
            service.phoneStateChanged(numActive, numHeld, callState, number, type, name, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadset.getConnectedDevices:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (VDBG)
        log("getConnectedDevices()");
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.getConnectedDevices();
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
Body of Second Method:
{
    if (VDBG)
        log("getConnectedDevices()");
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled()) {
        try {
            return Attributable.setAttributionSource(service.getConnectedDevicesWithAttribution(mAttributionSource), mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothPbap.getConnectionState:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * {@inheritDoc}
 *
 * @hide
 */

Body of Frist Method:
{
    log("getConnectionState: device=" + device);
    try {
        final IBluetoothPbap service = mService;
        if (service != null && isEnabled() && isValidDevice(device)) {
            return service.getConnectionState(device);
        }
        if (service == null) {
            Log.w(TAG, "Proxy not attached to service");
        }
        return BluetoothProfile.STATE_DISCONNECTED;
    } catch (RemoteException e) {
        Log.e(TAG, e.toString());
    }
    return BluetoothProfile.STATE_DISCONNECTED;
}
Body of Second Method:
{
    log("getConnectionState: device=" + device);
    try {
        final IBluetoothPbap service = mService;
        if (service != null && isEnabled() && isValidDevice(device)) {
            return service.getConnectionState(device, mAttributionSource);
        }
        if (service == null) {
            Log.w(TAG, "Proxy not attached to service");
        }
        return BluetoothProfile.STATE_DISCONNECTED;
    } catch (RemoteException e) {
        Log.e(TAG, e.toString());
    }
    return BluetoothProfile.STATE_DISCONNECTED;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.getLastVoiceTagNumber:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get a number corresponding to last voice tag recorded on AG.
 *
 * @param device remote device
 * @return <code>true</code> if command has been issued successfully; <code>false</code>
 * otherwise; upon completion HFP sends {@link #ACTION_LAST_VTAG} or {@link #ACTION_RESULT}
 * intent;
 *
 * <p>Feature required for successful execution is being reported by: {@link
 * #EXTRA_AG_FEATURE_ATTACH_NUMBER_TO_VT}. This method invocation will fail silently when
 * feature is not supported.</p>
 */

Body of Frist Method:
{
    if (DBG)
        log("getLastVoiceTagNumber()");
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getLastVoiceTagNumber(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("getLastVoiceTagNumber()");
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getLastVoiceTagNumber(device, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.timezone.TzDataSetVersion.currentFormatMinorVersion:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Returns the minor tz data format version supported by this device.
 */

Body of Frist Method:
{
    return libcore.timezone.TzDataSetVersion.currentFormatMinorVersion();
}
Body of Second Method:
{
    return com.android.i18n.timezone.TzDataSetVersion.currentFormatMinorVersion();
}
------------------------
Find a silently evolved API code:android.telephony.PinResult.toString:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * String representation of the Pin Result.
 */

Body of Frist Method:
{
    return "type: " + getType() + ", attempts remaining: " + getAttemptsRemaining();
}
Body of Second Method:
{
    return "result: " + getResult() + ", attempts remaining: " + getAttemptsRemaining();
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothGattServer.readPhy:COMMENT
Method Modifier: public      
Comment:/**
 * Read the current transmitter PHY and receiver PHY of the connection. The values are returned
 * in {@link BluetoothGattServerCallback#onPhyRead}
 *
 * @param device The remote device to send this response to
 */

Body of Frist Method:
{
    try {
        mService.serverReadPhy(mServerIf, device.getAddress());
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
}
Body of Second Method:
{
    try {
        mService.serverReadPhy(mServerIf, device.getAddress(), mAttributionSource);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothGatt.readPhy:COMMENT
Method Modifier: public      
Comment:/**
 * Read the current transmitter PHY and receiver PHY of the connection. The values are returned
 * in {@link BluetoothGattCallback#onPhyRead}
 */

Body of Frist Method:
{
    try {
        mService.clientReadPhy(mClientIf, mDevice.getAddress());
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
}
Body of Second Method:
{
    try {
        mService.clientReadPhy(mClientIf, mDevice.getAddress(), mAttributionSource);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothPbapClient.disconnect:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Initiate disconnect.
 *
 * @param device Remote Bluetooth Device
 * @return false on error, true otherwise
 *
 * @hide
 */

Body of Frist Method:
{
    if (DBG) {
        log("disconnect(" + device + ")" + new Exception());
    }
    final IBluetoothPbapClient service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            service.disconnect(device);
            return true;
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null) {
        Log.w(TAG, "Proxy not attached to service");
    }
    return false;
}
Body of Second Method:
{
    if (DBG) {
        log("disconnect(" + device + ")" + new Exception());
    }
    final IBluetoothPbapClient service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            service.disconnect(device, mAttributionSource);
            return true;
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null) {
        Log.w(TAG, "Proxy not attached to service");
    }
    return false;
}
------------------------
Find a silently evolved API code:android.graphics.drawable.Icon.loadDrawable:COMMENT
Method Modifier: public      
Comment:/**
 * Returns a Drawable that can be used to draw the image inside this Icon, constructing it
 * if necessary. Depending on the type of image, this may not be something you want to do on
 * the UI thread, so consider using
 * {@link #loadDrawableAsync(Context, Message) loadDrawableAsync} instead.
 *
 * @param context {@link android.content.Context Context} in which to load the drawable; used
 * to access {@link android.content.res.Resources Resources}, for example.
 * @return A fresh instance of a drawable for this image, yours to keep.
 */

Body of Frist Method:
{
    final Drawable result = loadDrawableInner(context);
    if (result != null && (mTintList != null || mBlendMode != DEFAULT_BLEND_MODE)) {
        result.mutate();
        result.setTintList(mTintList);
        result.setTintBlendMode(mBlendMode);
    }
    return result;
}
Body of Second Method:
{
    final Drawable result = loadDrawableInner(context);
    if (result != null && hasTint()) {
        result.mutate();
        result.setTintList(mTintList);
        result.setTintBlendMode(mBlendMode);
    }
    return result;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothA2dp.getConnectedDevices:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (VDBG)
        log("getConnectedDevices()");
    try {
        final IBluetoothA2dp service = getService();
        if (service != null && isEnabled()) {
            return service.getConnectedDevices();
        }
        if (service == null)
            Log.w(TAG, "Proxy not attached to service");
        return new ArrayList<BluetoothDevice>();
    } catch (RemoteException e) {
        Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
        return new ArrayList<BluetoothDevice>();
    }
}
Body of Second Method:
{
    if (VDBG)
        log("getConnectedDevices()");
    try {
        final IBluetoothA2dp service = getService();
        if (service != null && isEnabled()) {
            return Attributable.setAttributionSource(service.getConnectedDevicesWithAttribution(mAttributionSource), mAttributionSource);
        }
        if (service == null)
            Log.w(TAG, "Proxy not attached to service");
        return new ArrayList<BluetoothDevice>();
    } catch (RemoteException e) {
        Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
        return new ArrayList<BluetoothDevice>();
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothGattServer.setPreferredPhy:COMMENT
Method Modifier: public      
Comment:/**
 * Set the preferred connection PHY for this app. Please note that this is just a
 * recommendation, whether the PHY change will happen depends on other applications peferences,
 * local and remote controller capabilities. Controller can override these settings. <p> {@link
 * BluetoothGattServerCallback#onPhyUpdate} will be triggered as a result of this call, even if
 * no PHY change happens. It is also triggered when remote device updates the PHY.
 *
 * @param device The remote device to send this response to
 * @param txPhy preferred transmitter PHY. Bitwise OR of any of {@link
 * BluetoothDevice#PHY_LE_1M_MASK}, {@link BluetoothDevice#PHY_LE_2M_MASK}, and {@link
 * BluetoothDevice#PHY_LE_CODED_MASK}.
 * @param rxPhy preferred receiver PHY. Bitwise OR of any of {@link
 * BluetoothDevice#PHY_LE_1M_MASK}, {@link BluetoothDevice#PHY_LE_2M_MASK}, and {@link
 * BluetoothDevice#PHY_LE_CODED_MASK}.
 * @param phyOptions preferred coding to use when transmitting on the LE Coded PHY. Can be one
 * of {@link BluetoothDevice#PHY_OPTION_NO_PREFERRED}, {@link BluetoothDevice#PHY_OPTION_S2} or
 * {@link BluetoothDevice#PHY_OPTION_S8}
 */

Body of Frist Method:
{
    try {
        mService.serverSetPreferredPhy(mServerIf, device.getAddress(), txPhy, rxPhy, phyOptions);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
}
Body of Second Method:
{
    try {
        mService.serverSetPreferredPhy(mServerIf, device.getAddress(), txPhy, rxPhy, phyOptions, mAttributionSource);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.le.AdvertisingSet.setPeriodicAdvertisingEnabled:COMMENT
Method Modifier: public      
Comment:/**
 * Used to enable/disable periodic advertising. This method returns immediately, the operation
 * status is delivered through {@code callback.onPeriodicAdvertisingEnable()}.
 *
 * @param enable whether the periodic advertising should be enabled (true), or disabled
 * (false).
 */

Body of Frist Method:
{
    try {
        mGatt.setPeriodicAdvertisingEnable(mAdvertiserId, enable);
    } catch (RemoteException e) {
        Log.e(TAG, "remote exception - ", e);
    }
}
Body of Second Method:
{
    try {
        mGatt.setPeriodicAdvertisingEnable(mAdvertiserId, enable, mAttributionSource);
    } catch (RemoteException e) {
        Log.e(TAG, "remote exception - ", e);
    }
}
------------------------
Find a silently evolved API code:android.provider.CalendarContract.CalendarAlerts.scheduleAlarm:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Schedules an alarm intent with the system AlarmManager that will
 * notify listeners when a reminder should be fired. The provider will
 * keep scheduled reminders up to date but apps may use this to
 * implement snooze functionality without modifying the reminders table.
 * Scheduled alarms will generate an intent using
 * {@link #ACTION_EVENT_REMINDER}. TODO Move to provider
 *
 * @param context A context for referencing system resources
 * @param manager The AlarmManager to use or null
 * @param alarmTime The time to fire the intent in UTC millis since
 * epoch
 * @hide
 */

Body of Frist Method:
{
    if (DEBUG) {
        String schedTime = TimeMigrationUtils.formatMillisWithFixedFormat(alarmTime);
        Log.d(TAG, "Schedule alarm at " + alarmTime + " " + schedTime);
    }
    if (manager == null) {
        manager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);
    }
    Intent intent = new Intent(ACTION_EVENT_REMINDER);
    intent.setData(ContentUris.withAppendedId(CalendarContract.CONTENT_URI, alarmTime));
    intent.putExtra(ALARM_TIME, alarmTime);
    intent.setFlags(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);
    PendingIntent pi = PendingIntent.getBroadcast(context, 0, intent, 0);
    manager.setExactAndAllowWhileIdle(AlarmManager.RTC_WAKEUP, alarmTime, pi);
}
Body of Second Method:
{
    if (DEBUG) {
        String schedTime = TimeMigrationUtils.formatMillisWithFixedFormat(alarmTime);
        Log.d(TAG, "Schedule alarm at " + alarmTime + " " + schedTime);
    }
    if (manager == null) {
        manager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);
    }
    Intent intent = new Intent(ACTION_EVENT_REMINDER);
    intent.setData(ContentUris.withAppendedId(CalendarContract.CONTENT_URI, alarmTime));
    intent.putExtra(ALARM_TIME, alarmTime);
    intent.setFlags(Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND);
    // Disable strict mode VM policy violations temporarily for intents that contain a
    // content URI but don't have FLAG_GRANT_READ_URI_PERMISSION.
    StrictMode.VmPolicy oldVmPolicy = StrictMode.allowVmViolations();
    PendingIntent pi = PendingIntent.getBroadcast(context, 0, intent, PendingIntent.FLAG_IMMUTABLE);
    StrictMode.setVmPolicy(oldVmPolicy);
    manager.setExactAndAllowWhileIdle(AlarmManager.RTC_WAKEUP, alarmTime, pi);
}
------------------------
Find a silently evolved API code:android.hardware.camera2.params.OutputConfiguration.equals:COMMENT
Method Modifier: public      
Comment:/**
 * Check if this {@link OutputConfiguration} is equal to another {@link OutputConfiguration}.
 *
 * <p>Two output configurations are only equal if and only if the underlying surfaces, surface
 * properties (width, height, format, dataspace) when the output configurations are created,
 * and all other configuration parameters are equal. </p>
 *
 * @return {@code true} if the objects were equal, {@code false} otherwise
 */

Body of Frist Method:
{
    if (obj == null) {
        return false;
    } else if (this == obj) {
        return true;
    } else if (obj instanceof OutputConfiguration) {
        final OutputConfiguration other = (OutputConfiguration) obj;
        if (mRotation != other.mRotation || !mConfiguredSize.equals(other.mConfiguredSize) || mConfiguredFormat != other.mConfiguredFormat || mSurfaceGroupId != other.mSurfaceGroupId || mSurfaceType != other.mSurfaceType || mIsDeferredConfig != other.mIsDeferredConfig || mIsShared != other.mIsShared || mConfiguredFormat != other.mConfiguredFormat || mConfiguredDataspace != other.mConfiguredDataspace || mConfiguredGenerationId != other.mConfiguredGenerationId || !Objects.equals(mPhysicalCameraId, other.mPhysicalCameraId))
            return false;
        int minLen = Math.min(mSurfaces.size(), other.mSurfaces.size());
        for (int i = 0; i < minLen; i++) {
            if (mSurfaces.get(i) != other.mSurfaces.get(i))
                return false;
        }
        return true;
    }
    return false;
}
Body of Second Method:
{
    if (obj == null) {
        return false;
    } else if (this == obj) {
        return true;
    } else if (obj instanceof OutputConfiguration) {
        final OutputConfiguration other = (OutputConfiguration) obj;
        if (mRotation != other.mRotation || !mConfiguredSize.equals(other.mConfiguredSize) || mConfiguredFormat != other.mConfiguredFormat || mSurfaceGroupId != other.mSurfaceGroupId || mSurfaceType != other.mSurfaceType || mIsDeferredConfig != other.mIsDeferredConfig || mIsShared != other.mIsShared || mConfiguredFormat != other.mConfiguredFormat || mConfiguredDataspace != other.mConfiguredDataspace || mConfiguredGenerationId != other.mConfiguredGenerationId || !Objects.equals(mPhysicalCameraId, other.mPhysicalCameraId) || mIsMultiResolution != other.mIsMultiResolution)
            return false;
        if (mSensorPixelModesUsed.size() != other.mSensorPixelModesUsed.size()) {
            return false;
        }
        for (int j = 0; j < mSensorPixelModesUsed.size(); j++) {
            if (mSensorPixelModesUsed.get(j) != other.mSensorPixelModesUsed.get(j)) {
                return false;
            }
        }
        int minLen = Math.min(mSurfaces.size(), other.mSurfaces.size());
        for (int i = 0; i < minLen; i++) {
            if (mSurfaces.get(i) != other.mSurfaces.get(i))
                return false;
        }
        return true;
    }
    return false;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothDevice.getBatteryLevel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the most recent identified battery level of this Bluetooth device
 *
 * @return Battery level in percents from 0 to 100, {@link #BATTERY_LEVEL_BLUETOOTH_OFF} if
 * Bluetooth is disabled or {@link #BATTERY_LEVEL_UNKNOWN} if device is disconnected, or does
 * not have any battery reporting service, or return value is invalid
 * @hide
 */

Body of Frist Method:
{
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, "Bluetooth disabled. Cannot get remote device battery level");
        return BATTERY_LEVEL_BLUETOOTH_OFF;
    }
    try {
        return service.getBatteryLevel(this);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return BATTERY_LEVEL_UNKNOWN;
}
Body of Second Method:
{
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, "Bluetooth disabled. Cannot get remote device battery level");
        return BATTERY_LEVEL_BLUETOOTH_OFF;
    }
    try {
        return service.getBatteryLevel(this, mAttributionSource);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return BATTERY_LEVEL_UNKNOWN;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.sendVendorAtCommand:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Send vendor specific AT command.
 *
 * @param device remote device
 * @param vendorId vendor number by Bluetooth SIG
 * @param atCommand command to be sent. It start with + prefix and only one command at one time.
 * @return <code>true</code> if command has been issued successfully; <code>false</code>
 * otherwise.
 */

Body of Frist Method:
{
    if (DBG)
        log("sendVendorSpecificCommand()");
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.sendVendorAtCommand(device, vendorId, atCommand);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("sendVendorSpecificCommand()");
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.sendVendorAtCommand(device, vendorId, atCommand, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.view.WindowManagerImpl.computeWindowInsets:COMMENT
Method Modifier: private     hidden      
Comment:// TODO(b/150095967): Set window type to LayoutParams

Body of Frist Method:
{
    // Initialize params which used for obtaining all system insets.
    final WindowManager.LayoutParams params = new WindowManager.LayoutParams();
    params.flags = FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR;
    params.token = (mParentWindow != null) ? mParentWindow.getContext().getActivityToken() : mContext.getActivityToken();
    params.systemUiVisibility = SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION;
    params.setFitInsetsTypes(0);
    params.setFitInsetsSides(0);
    return getWindowInsetsFromServer(params, bounds);
}
Body of Second Method:
{
    // Initialize params which used for obtaining all system insets.
    final WindowManager.LayoutParams params = new WindowManager.LayoutParams();
    params.flags = FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR;
    final Context context = (mParentWindow != null) ? mParentWindow.getContext() : mContext;
    params.token = Context.getToken(context);
    params.systemUiVisibility = SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION;
    params.setFitInsetsTypes(0);
    params.setFitInsetsSides(0);
    return getWindowInsetsFromServer(params, bounds);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.sendDTMF:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sends DTMF code.
 *
 * Possible code values : 0,1,2,3,4,5,6,7,8,9,A,B,C,D,*,#
 *
 * @param device remote device
 * @param code ASCII code
 * @return <code>true</code> if command has been issued successfully; <code>false</code>
 * otherwise; upon completion HFP sends {@link #ACTION_RESULT} intent;
 */

Body of Frist Method:
{
    if (DBG)
        log("sendDTMF()");
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.sendDTMF(device, code);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("sendDTMF()");
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.sendDTMF(device, code, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothPbapClient.getDevicesMatchingConnectionStates:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the list of devices matching specified states. Currently at most one.
 *
 * @return list of matching devices
 */

Body of Frist Method:
{
    if (DBG) {
        log("getDevicesMatchingStates()");
    }
    final IBluetoothPbapClient service = getService();
    if (service != null && isEnabled()) {
        try {
            return service.getDevicesMatchingConnectionStates(states);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null) {
        Log.w(TAG, "Proxy not attached to service");
    }
    return new ArrayList<BluetoothDevice>();
}
Body of Second Method:
{
    if (DBG) {
        log("getDevicesMatchingStates()");
    }
    final IBluetoothPbapClient service = getService();
    if (service != null && isEnabled()) {
        try {
            return Attributable.setAttributionSource(service.getDevicesMatchingConnectionStates(states, mAttributionSource), mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null) {
        Log.w(TAG, "Proxy not attached to service");
    }
    return new ArrayList<BluetoothDevice>();
}
------------------------
Find a silently evolved API code:android.telephony.LocationAccessPolicy.LocationPermissionQuery.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * build LocationPermissionQuery
 */

Body of Frist Method:
{
    return new LocationPermissionQuery(mCallingPackage, mCallingFeatureId, mCallingUid, mCallingPid, mMinSdkVersionForCoarse, mMinSdkVersionForFine, mLogAsInfo, mMethod);
}
Body of Second Method:
{
    if (mMinSdkVersionForCoarse < 0 || mMinSdkVersionForFine < 0) {
        throw new IllegalArgumentException("Must specify min sdk versions for" + " enforcement for both coarse and fine permissions");
    }
    if (mMinSdkVersionForFine > Build.VERSION_CODES.BASE && mMinSdkVersionForCoarse > Build.VERSION_CODES.BASE) {
        if (mMinSdkVersionForEnforcement != Math.min(mMinSdkVersionForCoarse, mMinSdkVersionForFine)) {
            throw new IllegalArgumentException("setMinSdkVersionForEnforcement must be" + " called.");
        }
    }
    if (mMinSdkVersionForFine < mMinSdkVersionForCoarse) {
        throw new IllegalArgumentException("Since fine location permission includes" + " access to coarse location, the min sdk level for enforcement of" + " the fine location permission must not be less than the min sdk" + " level for enforcement of the coarse location permission.");
    }
    return new LocationPermissionQuery(mCallingPackage, mCallingFeatureId, mCallingUid, mCallingPid, mMinSdkVersionForCoarse, mMinSdkVersionForFine, mLogAsInfo, mMethod);
}
------------------------
Find a silently evolved API code:android.hardware.camera2.params.InputConfiguration.hashCode:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    return HashCodeHelpers.hashCode(mWidth, mHeight, mFormat);
}
Body of Second Method:
{
    return HashCodeHelpers.hashCode(mWidth, mHeight, mFormat, mIsMultiResolution ? 1 : 0);
}
------------------------
Find a silently evolved API code:android.content.pm.PackageManager.deleteStatusToPublicStatus:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * {@hide}
 */

Body of Frist Method:
{
    switch(status) {
        case DELETE_SUCCEEDED:
            return PackageInstaller.STATUS_SUCCESS;
        case DELETE_FAILED_INTERNAL_ERROR:
            return PackageInstaller.STATUS_FAILURE;
        case DELETE_FAILED_DEVICE_POLICY_MANAGER:
            return PackageInstaller.STATUS_FAILURE_BLOCKED;
        case DELETE_FAILED_USER_RESTRICTED:
            return PackageInstaller.STATUS_FAILURE_BLOCKED;
        case DELETE_FAILED_OWNER_BLOCKED:
            return PackageInstaller.STATUS_FAILURE_BLOCKED;
        case DELETE_FAILED_ABORTED:
            return PackageInstaller.STATUS_FAILURE_ABORTED;
        case DELETE_FAILED_USED_SHARED_LIBRARY:
            return PackageInstaller.STATUS_FAILURE_CONFLICT;
        default:
            return PackageInstaller.STATUS_FAILURE;
    }
}
Body of Second Method:
{
    switch(status) {
        case DELETE_SUCCEEDED:
            return PackageInstaller.STATUS_SUCCESS;
        case DELETE_FAILED_INTERNAL_ERROR:
            return PackageInstaller.STATUS_FAILURE;
        case DELETE_FAILED_DEVICE_POLICY_MANAGER:
            return PackageInstaller.STATUS_FAILURE_BLOCKED;
        case DELETE_FAILED_USER_RESTRICTED:
            return PackageInstaller.STATUS_FAILURE_BLOCKED;
        case DELETE_FAILED_OWNER_BLOCKED:
            return PackageInstaller.STATUS_FAILURE_BLOCKED;
        case DELETE_FAILED_ABORTED:
            return PackageInstaller.STATUS_FAILURE_ABORTED;
        case DELETE_FAILED_USED_SHARED_LIBRARY:
            return PackageInstaller.STATUS_FAILURE_CONFLICT;
        case DELETE_FAILED_APP_PINNED:
            return PackageInstaller.STATUS_FAILURE_BLOCKED;
        default:
            return PackageInstaller.STATUS_FAILURE;
    }
}
------------------------
Find a silently evolved API code:android.content.IntentSender.getCreatorUserHandle:COMMENT
Method Modifier: public      
Comment:/**
 * Return the user handle of the application that created this
 * PendingIntent, that is the user under which you will actually be
 * sending the Intent.  The returned UserHandle is supplied by the system, so
 * that an application can not spoof its user.  See
 * {@link android.os.Process#myUserHandle() Process.myUserHandle()} for
 * more explanation of user handles.
 *
 * @return The user handle of the PendingIntent, or null if there is
 * none associated with it.
 */

Body of Frist Method:
{
    try {
        int uid = ActivityManager.getService().getUidForIntentSender(mTarget);
        return uid > 0 ? new UserHandle(UserHandle.getUserId(uid)) : null;
    } catch (RemoteException e) {
        // Should never happen.
        return null;
    }
}
Body of Second Method:
{
    int uid = getCachedInfo().getCreatorUid();
    return uid > 0 ? new UserHandle(UserHandle.getUserId(uid)) : null;
}
------------------------
Find a silently evolved API code:android.view.InputChannel.dispose:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Disposes the input channel.
 * Explicitly releases the reference this object is holding on the input channel.
 * When all references are released, the input channel will be closed.
 */

Body of Frist Method:
{
    nativeDispose(false);
}
Body of Second Method:
{
    nativeDispose(mPtr);
}
------------------------
Find a silently evolved API code:android.view.inputmethod.EditorInfo.getInitialTextBeforeCursor:COMMENT
Method Modifier: public      
Comment:/**
 * Get <var>length</var> characters of text before the current cursor position. May be
 * {@code null} when the protocol is not supported.
 *
 * @param length The expected length of the text.
 * @param flags Supplies additional options controlling how the text is returned. May be
 * either 0 or {@link InputConnection#GET_TEXT_WITH_STYLES}.
 * @return the text before the cursor position; the length of the returned text might be less
 * than <var>length</var>. When there is no text before the cursor, an empty string will be
 * returned. It could also be {@code null} when the editor or system could not support this
 * protocol.
 */

Body of Frist Method:
{
    return mInitialSurroundingText.getInitialTextBeforeCursor(length, flags);
}
Body of Second Method:
{
    if (mInitialSurroundingText == null) {
        return null;
    }
    int selStart = Math.min(mInitialSurroundingText.getSelectionStart(), mInitialSurroundingText.getSelectionEnd());
    int n = Math.min(length, selStart);
    return ((flags & InputConnection.GET_TEXT_WITH_STYLES) != 0) ? mInitialSurroundingText.getText().subSequence(selStart - n, selStart) : TextUtils.substring(mInitialSurroundingText.getText(), selStart - n, selStart);
}
------------------------
Find a silently evolved API code:android.security.KeyPairGeneratorSpec.getFlags:COMMENT
Method Modifier: public      hidden      deprecated  
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return mFlags;
}
Body of Second Method:
{
    return 0;
}
------------------------
Find a silently evolved API code:android.view.inputmethod.BaseInputConnection.getTextAfterCursor:COMMENT
Method Modifier: public      
Comment:/**
 * The default implementation returns the given amount of text from the
 * current cursor position in the buffer.
 */

Body of Frist Method:
{
    final Editable content = getEditable();
    if (content == null)
        return null;
    int a = Selection.getSelectionStart(content);
    int b = Selection.getSelectionEnd(content);
    if (a > b) {
        int tmp = a;
        a = b;
        b = tmp;
    }
    // Guard against the case where the cursor has not been positioned yet.
    if (b < 0) {
        b = 0;
    }
    if (b + length > content.length()) {
        length = content.length() - b;
    }
    if ((flags & GET_TEXT_WITH_STYLES) != 0) {
        return content.subSequence(b, b + length);
    }
    return TextUtils.substring(content, b, b + length);
}
Body of Second Method:
{
    Preconditions.checkArgumentNonnegative(length);
    final Editable content = getEditable();
    if (content == null)
        return null;
    int a = Selection.getSelectionStart(content);
    int b = Selection.getSelectionEnd(content);
    if (a > b) {
        int tmp = a;
        a = b;
        b = tmp;
    }
    // Guard against the case where the cursor has not been positioned yet.
    if (b < 0) {
        b = 0;
    }
    if (b + length > content.length()) {
        length = content.length() - b;
    }
    if ((flags & GET_TEXT_WITH_STYLES) != 0) {
        return content.subSequence(b, b + length);
    }
    return TextUtils.substring(content, b, b + length);
}
------------------------
Find a silently evolved API code:android.graphics.FrameInfo.setVsync:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * checkstyle
 */

Body of Frist Method:
{
    frameInfo[INTENDED_VSYNC] = intendedVsync;
    frameInfo[VSYNC] = usedVsync;
    frameInfo[OLDEST_INPUT_EVENT] = Long.MAX_VALUE;
    frameInfo[NEWEST_INPUT_EVENT] = 0;
    frameInfo[FLAGS] = 0;
}
Body of Second Method:
{
    frameInfo[FRAME_TIMELINE_VSYNC_ID] = frameTimelineVsyncId;
    frameInfo[INTENDED_VSYNC] = intendedVsync;
    frameInfo[VSYNC] = usedVsync;
    frameInfo[FLAGS] = 0;
    frameInfo[FRAME_DEADLINE] = frameDeadline;
    frameInfo[FRAME_START_TIME] = frameStartTime;
    frameInfo[FRAME_INTERVAL] = frameInterval;
}
------------------------
Find a silently evolved API code:android.net.Uri.PathPart.makeAbsolute:COMMENT
Method Modifier: default     static      
Comment:/**
 * Prepends path values with "/" if they're present, not empty, and
 * they don't already start with "/".
 */

Body of Frist Method:
{
    @SuppressWarnings("StringEquality") boolean encodedCached = oldPart.encoded != NOT_CACHED;
    // We don't care which version we use, and we don't want to force
    // unneccessary encoding/decoding.
    String oldPath = encodedCached ? oldPart.encoded : oldPart.decoded;
    if (oldPath == null || oldPath.length() == 0 || oldPath.startsWith("/")) {
        return oldPart;
    }
    // Prepend encoded string if present.
    String newEncoded = encodedCached ? "/" + oldPart.encoded : NOT_CACHED;
    // Prepend decoded string if present.
    @SuppressWarnings("StringEquality") boolean decodedCached = oldPart.decoded != NOT_CACHED;
    String newDecoded = decodedCached ? "/" + oldPart.decoded : NOT_CACHED;
    return new PathPart(newEncoded, newDecoded);
}
Body of Second Method:
{
    @SuppressWarnings("StringEquality") boolean encodedCached = oldPart.encoded != NotCachedHolder.NOT_CACHED;
    // We don't care which version we use, and we don't want to force
    // unneccessary encoding/decoding.
    String oldPath = encodedCached ? oldPart.encoded : oldPart.decoded;
    if (oldPath == null || oldPath.length() == 0 || oldPath.startsWith("/")) {
        return oldPart;
    }
    // Prepend encoded string if present.
    String newEncoded = encodedCached ? "/" + oldPart.encoded : NotCachedHolder.NOT_CACHED;
    // Prepend decoded string if present.
    @SuppressWarnings("StringEquality") boolean decodedCached = oldPart.decoded != NotCachedHolder.NOT_CACHED;
    String newDecoded = decodedCached ? "/" + oldPart.decoded : NotCachedHolder.NOT_CACHED;
    return new PathPart(newEncoded, newDecoded);
}
------------------------
Find a silently evolved API code:android.telephony.AccessNetworkConstants.NgranBands.getFrequencyRangeGroup:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Get frequency range group
 *
 * @param band NR band
 * @return The frequency range group
 *
 * @hide
 */

Body of Frist Method:
{
    switch(band) {
        case BAND_1:
        case BAND_2:
        case BAND_3:
        case BAND_5:
        case BAND_7:
        case BAND_8:
        case BAND_12:
        case BAND_14:
        case BAND_18:
        case BAND_20:
        case BAND_25:
        case BAND_28:
        case BAND_29:
        case BAND_30:
        case BAND_34:
        case BAND_38:
        case BAND_39:
        case BAND_40:
        case BAND_41:
        case BAND_48:
        case BAND_50:
        case BAND_51:
        case BAND_65:
        case BAND_66:
        case BAND_70:
        case BAND_71:
        case BAND_74:
        case BAND_75:
        case BAND_76:
        case BAND_77:
        case BAND_78:
        case BAND_79:
        case BAND_80:
        case BAND_81:
        case BAND_82:
        case BAND_83:
        case BAND_84:
        case BAND_86:
        case BAND_89:
        case BAND_90:
        case BAND_91:
        case BAND_92:
        case BAND_93:
        case BAND_94:
        case BAND_95:
            return FREQUENCY_RANGE_GROUP_1;
        case BAND_257:
        case BAND_258:
        case BAND_260:
        case BAND_261:
            return FREQUENCY_RANGE_GROUP_2;
        default:
            return FREQUENCY_RANGE_GROUP_UNKNOWN;
    }
}
Body of Second Method:
{
    switch(band) {
        case BAND_1:
        case BAND_2:
        case BAND_3:
        case BAND_5:
        case BAND_7:
        case BAND_8:
        case BAND_12:
        case BAND_14:
        case BAND_18:
        case BAND_20:
        case BAND_25:
        case BAND_26:
        case BAND_28:
        case BAND_29:
        case BAND_30:
        case BAND_34:
        case BAND_38:
        case BAND_39:
        case BAND_40:
        case BAND_41:
        case BAND_46:
        case BAND_48:
        case BAND_50:
        case BAND_51:
        case BAND_53:
        case BAND_65:
        case BAND_66:
        case BAND_70:
        case BAND_71:
        case BAND_74:
        case BAND_75:
        case BAND_76:
        case BAND_77:
        case BAND_78:
        case BAND_79:
        case BAND_80:
        case BAND_81:
        case BAND_82:
        case BAND_83:
        case BAND_84:
        case BAND_86:
        case BAND_89:
        case BAND_90:
        case BAND_91:
        case BAND_92:
        case BAND_93:
        case BAND_94:
        case BAND_95:
        case BAND_96:
            return FREQUENCY_RANGE_GROUP_1;
        case BAND_257:
        case BAND_258:
        case BAND_260:
        case BAND_261:
            return FREQUENCY_RANGE_GROUP_2;
        default:
            return FREQUENCY_RANGE_GROUP_UNKNOWN;
    }
}
------------------------
Find a silently evolved API code:android.media.AudioFormat.isEncodingLinearFrames:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    switch(audioFormat) {
        case ENCODING_PCM_16BIT:
        case ENCODING_PCM_8BIT:
        case ENCODING_PCM_FLOAT:
        // same size as stereo PCM
        case ENCODING_IEC61937:
        case ENCODING_DEFAULT:
            return true;
        case ENCODING_AC3:
        case ENCODING_E_AC3:
        case ENCODING_DTS:
        case ENCODING_DTS_HD:
        case ENCODING_MP3:
        case ENCODING_AAC_LC:
        case ENCODING_AAC_HE_V1:
        case ENCODING_AAC_HE_V2:
        case ENCODING_DOLBY_TRUEHD:
        case ENCODING_AAC_ELD:
        case ENCODING_AAC_XHE:
        case ENCODING_AC4:
        case ENCODING_E_AC3_JOC:
        case ENCODING_DOLBY_MAT:
        case ENCODING_OPUS:
            return false;
        case ENCODING_INVALID:
        default:
            throw new IllegalArgumentException("Bad audio format " + audioFormat);
    }
}
Body of Second Method:
{
    switch(audioFormat) {
        case ENCODING_PCM_16BIT:
        case ENCODING_PCM_8BIT:
        case ENCODING_PCM_FLOAT:
        // same size as stereo PCM
        case ENCODING_IEC61937:
        case ENCODING_PCM_24BIT_PACKED:
        case ENCODING_PCM_32BIT:
        case ENCODING_DEFAULT:
            return true;
        case ENCODING_AC3:
        case ENCODING_E_AC3:
        case ENCODING_DTS:
        case ENCODING_DTS_HD:
        case ENCODING_MP3:
        case ENCODING_AAC_LC:
        case ENCODING_AAC_HE_V1:
        case ENCODING_AAC_HE_V2:
        case ENCODING_DOLBY_TRUEHD:
        case ENCODING_AAC_ELD:
        case ENCODING_AAC_XHE:
        case ENCODING_AC4:
        case ENCODING_E_AC3_JOC:
        case ENCODING_DOLBY_MAT:
        case ENCODING_OPUS:
        case ENCODING_MPEGH_BL_L3:
        case ENCODING_MPEGH_BL_L4:
        case ENCODING_MPEGH_LC_L3:
        case ENCODING_MPEGH_LC_L4:
        case ENCODING_DTS_UHD:
        case ENCODING_DRA:
            return false;
        case ENCODING_INVALID:
        default:
            throw new IllegalArgumentException("Bad audio format " + audioFormat);
    }
}
------------------------
Find a silently evolved API code:android.timezone.TzDataSetVersion.currentFormatMajorVersion:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Returns the major tz data format version supported by this device.
 */

Body of Frist Method:
{
    return libcore.timezone.TzDataSetVersion.currentFormatMajorVersion();
}
Body of Second Method:
{
    return com.android.i18n.timezone.TzDataSetVersion.currentFormatMajorVersion();
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.connect:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Connects to remote device.
 *
 * Currently, the system supports only 1 connection. So, in case of the
 * second connection, this implementation will disconnect already connected
 * device automatically and will process the new one.
 *
 * @param device a remote device we want connect to
 * @return <code>true</code> if command has been issued successfully; <code>false</code>
 * otherwise; upon completion HFP sends {@link #ACTION_CONNECTION_STATE_CHANGED} intent.
 *
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("connect(" + device + ")");
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.connect(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("connect(" + device + ")");
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.connect(device, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.telephony.CallForwardingInfo.hashCode:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return Objects.hash(mStatus, mNumber, mReason, mTimeSeconds);
}
Body of Second Method:
{
    return Objects.hash(mEnabled, mNumber, mReason, mTimeSeconds);
}
------------------------
Find a silently evolved API code:android.content.ContentProviderClient.openAssetFile:COMMENT
Method Modifier: public      
Comment:/**
 * See {@link ContentProvider#openAssetFile ContentProvider.openAssetFile}.
 * Note that this <em>does not</em>
 * take care of non-content: URIs such as file:.  It is strongly recommended
 * you use the {@link ContentResolver#openAssetFileDescriptor
 * ContentResolver.openAssetFileDescriptor} API instead.
 */

Body of Frist Method:
{
    Objects.requireNonNull(url, "url");
    Objects.requireNonNull(mode, "mode");
    beforeRemote();
    try {
        ICancellationSignal remoteSignal = null;
        if (signal != null) {
            signal.throwIfCanceled();
            remoteSignal = mContentProvider.createCancellationSignal();
            signal.setRemote(remoteSignal);
        }
        return mContentProvider.openAssetFile(mPackageName, mAttributionTag, url, mode, remoteSignal);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}
Body of Second Method:
{
    Objects.requireNonNull(url, "url");
    Objects.requireNonNull(mode, "mode");
    beforeRemote();
    try {
        ICancellationSignal remoteSignal = null;
        if (signal != null) {
            signal.throwIfCanceled();
            remoteSignal = mContentProvider.createCancellationSignal();
            signal.setRemote(remoteSignal);
        }
        return mContentProvider.openAssetFile(mAttributionSource, url, mode, remoteSignal);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}
------------------------
Find a silently evolved API code:android.content.res.CompatibilityInfo.getTranslator:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns the translator which translates the coordinates in compatibility mode.
 * @param params the window's parameter
 */

Body of Frist Method:
{
    return isScalingRequired() ? new Translator() : null;
}
Body of Second Method:
{
    return (mCompatibilityFlags & SCALING_REQUIRED) != 0 ? new Translator() : null;
}
------------------------
Find a silently evolved API code:android.telephony.CellIdentity.isSameCell:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @param ci a CellIdentity to compare to the current CellIdentity.
 * @return true if ci has the same technology and Global Cell ID; false, otherwise.
 * @hide
 */

Body of Frist Method:
{
    if (ci == null)
        return false;
    if (this.getClass() != ci.getClass())
        return false;
    if (this.getGlobalCellId() == null || ci.getGlobalCellId() == null)
        return false;
    return TextUtils.equals(this.getGlobalCellId(), ci.getGlobalCellId());
}
Body of Second Method:
{
    if (ci == null)
        return false;
    if (this.getClass() != ci.getClass())
        return false;
    return TextUtils.equals(this.getGlobalCellId(), ci.getGlobalCellId());
}
------------------------
Find a silently evolved API code:android.location.GnssCapabilities.hasMeasurementCorrectionsLosSats:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns {@code true} if GNSS chipset supports line-of-sight satellite identification
 * measurement corrections, {@code false} otherwise.
 *
 * @hide
 */

Body of Frist Method:
{
    return hasCapability(MEASUREMENT_CORRECTIONS_LOS_SATS);
}
Body of Second Method:
{
    return (mMeasurementCorrectionsFlags & SUB_HAL_MEASUREMENT_CORRECTIONS_CAPABILITY_LOS_SATS) != 0;
}
------------------------
Find a silently evolved API code:android.graphics.drawable.GradientDrawable.getCornerRadii:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the radii for each of the 4 corners. For each corner, the array
 * contains 2 values, <code>[X_radius, Y_radius]</code>. The corners are
 * ordered top-left, top-right, bottom-right, bottom-left.
 * <p>
 * If the radius was previously set with {@link #setCornerRadius(float)},
 * or if the corners are not rounded, this method will return {@code null}.
 *
 * @return an array containing the radii for each of the 4 corners, or
 * {@code null}
 * @see #setCornerRadii(float[])
 */

Body of Frist Method:
{
    return mGradientState.mRadiusArray.clone();
}
Body of Second Method:
{
    float[] radii = mGradientState.mRadiusArray;
    if (radii == null) {
        return null;
    }
    return radii.clone();
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothA2dp.getConnectionPolicy:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the connection policy of the profile.
 *
 * <p> The connection policy can be any of:
 * {@link #CONNECTION_POLICY_ALLOWED}, {@link #CONNECTION_POLICY_FORBIDDEN},
 * {@link #CONNECTION_POLICY_UNKNOWN}
 *
 * @param device Bluetooth device
 * @return connection policy of the device
 * @hide
 */

Body of Frist Method:
{
    if (VDBG)
        log("getConnectionPolicy(" + device + ")");
    try {
        final IBluetoothA2dp service = getService();
        if (service != null && isEnabled() && isValidDevice(device)) {
            return service.getConnectionPolicy(device);
        }
        if (service == null)
            Log.w(TAG, "Proxy not attached to service");
        return BluetoothProfile.CONNECTION_POLICY_FORBIDDEN;
    } catch (RemoteException e) {
        Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
        return BluetoothProfile.CONNECTION_POLICY_FORBIDDEN;
    }
}
Body of Second Method:
{
    if (VDBG)
        log("getConnectionPolicy(" + device + ")");
    try {
        final IBluetoothA2dp service = getService();
        if (service != null && isEnabled() && isValidDevice(device)) {
            return service.getConnectionPolicy(device, mAttributionSource);
        }
        if (service == null)
            Log.w(TAG, "Proxy not attached to service");
        return BluetoothProfile.CONNECTION_POLICY_FORBIDDEN;
    } catch (RemoteException e) {
        Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
        return BluetoothProfile.CONNECTION_POLICY_FORBIDDEN;
    }
}
------------------------
Find a silently evolved API code:android.media.MediaMetadata.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Creates a {@link MediaMetadata} instance with the specified fields.
 *
 * @return The new MediaMetadata instance
 */

Body of Frist Method:
{
    return new MediaMetadata(mBundle);
}
Body of Second Method:
{
    if (mBitmapDimensionLimit != Integer.MAX_VALUE) {
        for (String key : mBundle.keySet()) {
            Object value = mBundle.get(key);
            if (value instanceof Bitmap) {
                Bitmap bmp = (Bitmap) value;
                if (bmp.getHeight() > mBitmapDimensionLimit || bmp.getWidth() > mBitmapDimensionLimit) {
                    putBitmap(key, scaleBitmap(bmp, mBitmapDimensionLimit));
                }
            }
        }
    }
    return new MediaMetadata(mBundle, mBitmapDimensionLimit);
}
------------------------
Find a silently evolved API code:android.timezone.TzDataSetVersion.read:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Reads the current Android time zone data set version file.
 */

Body of Frist Method:
{
    try {
        return new TzDataSetVersion(libcore.timezone.TzDataSetVersion.readTimeZoneModuleVersion());
    } catch (libcore.timezone.TzDataSetVersion.TzDataSetException e) {
        throw new TzDataSetException(e.getMessage(), e);
    }
}
Body of Second Method:
{
    try {
        return new TzDataSetVersion(TimeZoneDataFiles.readTimeZoneModuleVersion());
    } catch (com.android.i18n.timezone.TzDataSetVersion.TzDataSetException e) {
        throw new TzDataSetException(e.getMessage(), e);
    }
}
------------------------
Find a silently evolved API code:android.text.format.DateUtils.getAMPMString:COMMENT
Method Modifier: public      static      deprecated  
Comment:/**
 * Return a localized string for AM or PM.
 * @param ampm Either {@link Calendar#AM Calendar.AM} or {@link Calendar#PM Calendar.PM}.
 * @throws IndexOutOfBoundsException if the ampm is out of bounds.
 * @return Localized version of "AM" or "PM".
 * @deprecated Use {@link java.text.SimpleDateFormat} instead.
 */

Body of Frist Method:
{
    return LocaleData.get(Locale.getDefault()).amPm[ampm - Calendar.AM];
}
Body of Second Method:
{
    String[] amPm = DateFormat.getIcuDateFormatSymbols(Locale.getDefault()).getAmPmStrings();
    return amPm[ampm - Calendar.AM];
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothMap.getConnectionPolicy:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the connection policy of the profile.
 *
 * <p> The connection policy can be any of:
 * {@link #CONNECTION_POLICY_ALLOWED}, {@link #CONNECTION_POLICY_FORBIDDEN},
 * {@link #CONNECTION_POLICY_UNKNOWN}
 *
 * @param device Bluetooth device
 * @return connection policy of the device
 * @hide
 */

Body of Frist Method:
{
    if (VDBG)
        log("getConnectionPolicy(" + device + ")");
    final IBluetoothMap service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getConnectionPolicy(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.CONNECTION_POLICY_FORBIDDEN;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return BluetoothProfile.CONNECTION_POLICY_FORBIDDEN;
}
Body of Second Method:
{
    if (VDBG)
        log("getConnectionPolicy(" + device + ")");
    final IBluetoothMap service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getConnectionPolicy(device, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.CONNECTION_POLICY_FORBIDDEN;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return BluetoothProfile.CONNECTION_POLICY_FORBIDDEN;
}
------------------------
Find a silently evolved API code:android.app.WindowConfiguration.setToDefaults:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    setAppBounds(null);
    setBounds(null);
    setWindowingMode(WINDOWING_MODE_UNDEFINED);
    setActivityType(ACTIVITY_TYPE_UNDEFINED);
    setAlwaysOnTop(ALWAYS_ON_TOP_UNDEFINED);
    setRotation(ROTATION_UNDEFINED);
    setDisplayWindowingMode(WINDOWING_MODE_UNDEFINED);
}
Body of Second Method:
{
    setAppBounds(null);
    setBounds(null);
    setMaxBounds(null);
    setWindowingMode(WINDOWING_MODE_UNDEFINED);
    setActivityType(ACTIVITY_TYPE_UNDEFINED);
    setAlwaysOnTop(ALWAYS_ON_TOP_UNDEFINED);
    setRotation(ROTATION_UNDEFINED);
    setDisplayWindowingMode(WINDOWING_MODE_UNDEFINED);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothA2dp.setAvrcpAbsoluteVolume:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Tells remote device to set an absolute volume. Only if absolute volume is supported
 *
 * @param volume Absolute volume to be set on AVRCP side
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        Log.d(TAG, "setAvrcpAbsoluteVolume");
    try {
        final IBluetoothA2dp service = getService();
        if (service != null && isEnabled()) {
            service.setAvrcpAbsoluteVolume(volume);
        }
        if (service == null)
            Log.w(TAG, "Proxy not attached to service");
    } catch (RemoteException e) {
        Log.e(TAG, "Error talking to BT service in setAvrcpAbsoluteVolume()", e);
    }
}
Body of Second Method:
{
    if (DBG)
        Log.d(TAG, "setAvrcpAbsoluteVolume");
    try {
        final IBluetoothA2dp service = getService();
        if (service != null && isEnabled()) {
            service.setAvrcpAbsoluteVolume(volume, mAttributionSource);
        }
        if (service == null)
            Log.w(TAG, "Proxy not attached to service");
    } catch (RemoteException e) {
        Log.e(TAG, "Error talking to BT service in setAvrcpAbsoluteVolume()", e);
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothDevice.setPairingConfirmation:COMMENT
Method Modifier: public      
Comment:/**
 * Confirm passkey for {@link #PAIRING_VARIANT_PASSKEY_CONFIRMATION} pairing.
 *
 * @return true confirmation has been sent out false for error
 */

Body of Frist Method:
{
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, "BT not enabled. Cannot set pairing confirmation");
        return false;
    }
    try {
        return service.setPairingConfirmation(this, confirm);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
Body of Second Method:
{
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, "BT not enabled. Cannot set pairing confirmation");
        return false;
    }
    try {
        return service.setPairingConfirmation(this, confirm, mAttributionSource);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
------------------------
Find a silently evolved API code:android.net.Uri.PathPart.fromEncoded:COMMENT
Method Modifier: default     static      
Comment:/**
 * Creates a path from the encoded string.
 *
 * @param encoded part string
 */

Body of Frist Method:
{
    return from(encoded, NOT_CACHED);
}
Body of Second Method:
{
    return from(encoded, NotCachedHolder.NOT_CACHED);
}
------------------------
Find a silently evolved API code:android.hardware.display.DisplayManager.setTemporaryBrightness:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Temporarily sets the brightness of the display.
 * <p>
 * Requires the {@link android.Manifest.permission#CONTROL_DISPLAY_BRIGHTNESS} permission.
 * </p>
 *
 * @param brightness The brightness value from 0.0f to 1.0f.
 *
 * @hide Requires signature permission.
 */

Body of Frist Method:
{
    mGlobal.setTemporaryBrightness(brightness);
}
Body of Second Method:
{
    mGlobal.setTemporaryBrightness(displayId, brightness);
}
------------------------
Find a silently evolved API code:android.nfc.NfcAdapter.getNfcAdapterExtrasInterface:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (mContext == null) {
        throw new UnsupportedOperationException("You need a context on NfcAdapter to use the " + " NFC extras APIs");
    }
    try {
        return sService.getNfcAdapterExtrasInterface(mContext.getPackageName());
    } catch (RemoteException e) {
        attemptDeadServiceRecovery(e);
        return null;
    }
}
Body of Second Method:
{
    if (mContext == null) {
        throw new UnsupportedOperationException("You need a context on NfcAdapter to use the " + " NFC extras APIs");
    }
    try {
        return sService.getNfcAdapterExtrasInterface(mContext.getPackageName());
    } catch (RemoteException e) {
        attemptDeadServiceRecovery(e);
        // Try one more time
        if (sService == null) {
            Log.e(TAG, "Failed to recover NFC Service.");
            return null;
        }
        try {
            return sService.getNfcAdapterExtrasInterface(mContext.getPackageName());
        } catch (RemoteException ee) {
            Log.e(TAG, "Failed to recover NFC Service.");
        }
        return null;
    }
}
------------------------
Find a silently evolved API code:android.net.Uri.Part.fromEncoded:COMMENT
Method Modifier: default     static      
Comment:/**
 * Creates a part from the encoded string.
 *
 * @param encoded part string
 */

Body of Frist Method:
{
    return from(encoded, NOT_CACHED);
}
Body of Second Method:
{
    return from(encoded, NotCachedHolder.NOT_CACHED);
}
------------------------
Find a silently evolved API code:android.telephony.CallForwardingInfo.toString:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return "[CallForwardingInfo: status=" + mStatus + ", reason= " + mReason + ", timeSec= " + mTimeSeconds + " seconds" + ", number=" + Rlog.pii(TAG, mNumber) + "]";
}
Body of Second Method:
{
    return "[CallForwardingInfo: enabled=" + mEnabled + ", reason= " + mReason + ", timeSec= " + mTimeSeconds + " seconds" + ", number=" + Rlog.pii(TAG, mNumber) + "]";
}
------------------------
Find a silently evolved API code:android.os.HidlMemory.close:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Close the underlying native handle. No-op if handle is null or has been released using {@link
 * #releaseHandle()}.
 */

Body of Frist Method:
{
    if (mHandle != null) {
        mHandle.close();
    }
}
Body of Second Method:
{
    if (mHandle != null) {
        mHandle.close();
        mHandle = null;
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothA2dp.isOptionalCodecsEnabled:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns whether this device should have optional codecs enabled.
 *
 * @param device The device in question.
 * @return one of OPTIONAL_CODECS_PREF_UNKNOWN, OPTIONAL_CODECS_PREF_ENABLED, or
 * OPTIONAL_CODECS_PREF_DISABLED.
 * @hide
 */

Body of Frist Method:
{
    verifyDeviceNotNull(device, "isOptionalCodecsEnabled");
    try {
        final IBluetoothA2dp service = getService();
        if (service != null && isEnabled() && isValidDevice(device)) {
            return service.getOptionalCodecsEnabled(device);
        }
        if (service == null)
            Log.w(TAG, "Proxy not attached to service");
        return OPTIONAL_CODECS_PREF_UNKNOWN;
    } catch (RemoteException e) {
        Log.e(TAG, "Error talking to BT service in getOptionalCodecsEnabled()", e);
        return OPTIONAL_CODECS_PREF_UNKNOWN;
    }
}
Body of Second Method:
{
    verifyDeviceNotNull(device, "isOptionalCodecsEnabled");
    try {
        final IBluetoothA2dp service = getService();
        if (service != null && isEnabled() && isValidDevice(device)) {
            return service.getOptionalCodecsEnabled(device, mAttributionSource);
        }
        if (service == null)
            Log.w(TAG, "Proxy not attached to service");
        return OPTIONAL_CODECS_PREF_UNKNOWN;
    } catch (RemoteException e) {
        Log.e(TAG, "Error talking to BT service in getOptionalCodecsEnabled()", e);
        return OPTIONAL_CODECS_PREF_UNKNOWN;
    }
}
------------------------
Find a silently evolved API code:android.window.WindowOrganizer.applyTransaction:COMMENT
<android.window.WindowOrganizer: void applyTransaction(WindowContainerTransaction)>
public      static      hidden      ->public      hidden      
Method Modifier: public      static      hidden      
Method Modifier: Yes         Yes         Yes         
Method Updated:  Yes         No          Yes         
Comment:/**
 * Apply multiple WindowContainer operations at once.
 * @param t The transaction to apply.
 */

Body of Frist Method:
{
    try {
        getWindowOrganizerController().applyTransaction(t);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    try {
        if (!t.isEmpty()) {
            getWindowOrganizerController().applyTransaction(t);
        }
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.content.ContentProviderClient.canonicalize:COMMENT
Method Modifier: public      final       
Comment:/**
 * See {@link ContentProvider#canonicalize}
 */

Body of Frist Method:
{
    Objects.requireNonNull(url, "url");
    beforeRemote();
    try {
        return mContentProvider.canonicalize(mPackageName, mAttributionTag, url);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}
Body of Second Method:
{
    Objects.requireNonNull(url, "url");
    beforeRemote();
    try {
        return mContentProvider.canonicalize(mAttributionSource, url);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.le.AdvertiseData.equals:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (this == obj) {
        return true;
    }
    if (obj == null || getClass() != obj.getClass()) {
        return false;
    }
    AdvertiseData other = (AdvertiseData) obj;
    return Objects.equals(mServiceUuids, other.mServiceUuids) && BluetoothLeUtils.equals(mManufacturerSpecificData, other.mManufacturerSpecificData) && BluetoothLeUtils.equals(mServiceData, other.mServiceData) && mIncludeDeviceName == other.mIncludeDeviceName && mIncludeTxPowerLevel == other.mIncludeTxPowerLevel;
}
Body of Second Method:
{
    if (this == obj) {
        return true;
    }
    if (obj == null || getClass() != obj.getClass()) {
        return false;
    }
    AdvertiseData other = (AdvertiseData) obj;
    return Objects.equals(mServiceUuids, other.mServiceUuids) && Objects.equals(mServiceSolicitationUuids, other.mServiceSolicitationUuids) && BluetoothLeUtils.equals(mManufacturerSpecificData, other.mManufacturerSpecificData) && BluetoothLeUtils.equals(mServiceData, other.mServiceData) && mIncludeDeviceName == other.mIncludeDeviceName && mIncludeTxPowerLevel == other.mIncludeTxPowerLevel;
}
------------------------
Find a silently evolved API code:android.location.GnssAntennaInfo.SphericalCorrections.getDeltaPhi:COMMENT
Method Modifier: public      
Comment:/**
 * The fixed phi angle separation between successive columns.
 */

Body of Frist Method:
{
    return mDeltaPhi;
}
Body of Second Method:
{
    return 180.0D / (mNumColumns - 1);
}
------------------------
Find a silently evolved API code:android.ddm.DdmRegister.registerHandlers:COMMENT
Method Modifier: public      static      
Comment:/**
 * Register handlers for all known chunk types.
 *
 * If you write a handler, add a registration call here.
 *
 * Note that this is invoked by the application (usually through a
 * static initializer in the main class), not the VM.  It's done this
 * way so that the handlers can use Android classes with native calls
 * that aren't registered until after the VM is initialized (e.g.
 * logging).  It also allows debugging of DDM handler initialization.
 *
 * The chunk dispatcher will pause until we call registrationComplete(),
 * so that we don't have a race that causes us to drop packets before
 * we finish here.
 */

Body of Frist Method:
{
    if (false)
        Log.v("ddm", "Registering DDM message handlers");
    DdmHandleHello.register();
    DdmHandleThread.register();
    DdmHandleHeap.register();
    DdmHandleNativeHeap.register();
    DdmHandleProfiling.register();
    DdmHandleExit.register();
    DdmHandleViewDebug.register();
    DdmServer.registrationComplete();
}
Body of Second Method:
{
    if (false)
        Log.v("ddm", "Registering DDM message handlers");
    DdmHandleHello.register();
    DdmHandleHeap.register();
    DdmHandleNativeHeap.register();
    DdmHandleProfiling.register();
    DdmHandleExit.register();
    DdmHandleViewDebug.register();
    DdmServer.registrationComplete();
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadset.setConnectionPolicy:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Set connection policy of the profile
 *
 * <p> The device should already be paired.
 * Connection policy can be one of {@link #CONNECTION_POLICY_ALLOWED},
 * {@link #CONNECTION_POLICY_FORBIDDEN}, {@link #CONNECTION_POLICY_UNKNOWN}
 *
 * @param device Paired bluetooth device
 * @param connectionPolicy is the connection policy to set to for this profile
 * @return true if connectionPolicy is set, false on error
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("setConnectionPolicy(" + device + ", " + connectionPolicy + ")");
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        if (connectionPolicy != BluetoothProfile.CONNECTION_POLICY_FORBIDDEN && connectionPolicy != BluetoothProfile.CONNECTION_POLICY_ALLOWED) {
            return false;
        }
        try {
            return service.setConnectionPolicy(device, connectionPolicy);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("setConnectionPolicy(" + device + ", " + connectionPolicy + ")");
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        if (connectionPolicy != BluetoothProfile.CONNECTION_POLICY_FORBIDDEN && connectionPolicy != BluetoothProfile.CONNECTION_POLICY_ALLOWED) {
            return false;
        }
        try {
            return service.setConnectionPolicy(device, connectionPolicy, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.app.admin.DeviceAdminReceiver.onUserStarted:COMMENT
Method Modifier: public      
Comment:/**
 * Called when a user or profile is started.
 *
 * <p>This callback is only applicable to device owners.
 *
 * @param context The running context as per {@link #onReceive}.
 * @param intent The received intent as per {@link #onReceive}.
 * @param startedUser The {@link UserHandle} of the user that has just been started.
 */

Body of Frist Method:
{
}
Body of Second Method:
{
    if (LOCAL_LOGV) {
        Log.v(TAG, getClass().getName() + ".onUserStarted() on user " + context.getUserId());
    }
}
------------------------
Find a silently evolved API code:android.view.inputmethod.BaseInputConnection.getTextBeforeCursor:COMMENT
Method Modifier: public      
Comment:/**
 * The default implementation returns the given amount of text from the
 * current cursor position in the buffer.
 */

Body of Frist Method:
{
    final Editable content = getEditable();
    if (content == null)
        return null;
    int a = Selection.getSelectionStart(content);
    int b = Selection.getSelectionEnd(content);
    if (a > b) {
        int tmp = a;
        a = b;
        b = tmp;
    }
    if (a <= 0) {
        return "";
    }
    if (length > a) {
        length = a;
    }
    if ((flags & GET_TEXT_WITH_STYLES) != 0) {
        return content.subSequence(a - length, a);
    }
    return TextUtils.substring(content, a - length, a);
}
Body of Second Method:
{
    Preconditions.checkArgumentNonnegative(length);
    final Editable content = getEditable();
    if (content == null)
        return null;
    int a = Selection.getSelectionStart(content);
    int b = Selection.getSelectionEnd(content);
    if (a > b) {
        int tmp = a;
        a = b;
        b = tmp;
    }
    if (a <= 0) {
        return "";
    }
    if (length > a) {
        length = a;
    }
    if ((flags & GET_TEXT_WITH_STYLES) != 0) {
        return content.subSequence(a - length, a);
    }
    return TextUtils.substring(content, a - length, a);
}
------------------------
Find a silently evolved API code:android.app.admin.PasswordPolicy.getMinMetrics:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns a minimum password metrics that the password should have to satisfy current policy.
 */

Body of Frist Method:
{
    if (quality == PASSWORD_QUALITY_UNSPECIFIED) {
        return new PasswordMetrics(CREDENTIAL_TYPE_NONE);
    } else if (quality == PASSWORD_QUALITY_BIOMETRIC_WEAK || quality == PASSWORD_QUALITY_SOMETHING) {
        return new PasswordMetrics(CREDENTIAL_TYPE_PATTERN);
    }
    // quality is NUMERIC or stronger.
    PasswordMetrics result = new PasswordMetrics(CREDENTIAL_TYPE_PASSWORD);
    result.length = length;
    if (quality == PASSWORD_QUALITY_NUMERIC_COMPLEX) {
        result.seqLength = PasswordMetrics.MAX_ALLOWED_SEQUENCE;
    } else if (quality == PASSWORD_QUALITY_ALPHABETIC) {
        result.nonNumeric = 1;
    } else if (quality == PASSWORD_QUALITY_ALPHANUMERIC) {
        result.numeric = 1;
        result.nonNumeric = 1;
    } else if (quality == PASSWORD_QUALITY_COMPLEX) {
        result.numeric = numeric;
        result.letters = letters;
        result.upperCase = upperCase;
        result.lowerCase = lowerCase;
        result.nonLetter = nonLetter;
        result.symbols = symbols;
    }
    return result;
}
Body of Second Method:
{
    if (quality == PASSWORD_QUALITY_UNSPECIFIED) {
        return new PasswordMetrics(CREDENTIAL_TYPE_NONE);
    } else if (quality == PASSWORD_QUALITY_BIOMETRIC_WEAK || quality == PASSWORD_QUALITY_SOMETHING) {
        return new PasswordMetrics(CREDENTIAL_TYPE_PATTERN);
    } else if (quality == PASSWORD_QUALITY_NUMERIC || quality == PASSWORD_QUALITY_NUMERIC_COMPLEX) {
        PasswordMetrics result = new PasswordMetrics(CREDENTIAL_TYPE_PIN);
        result.length = length;
        if (quality == PASSWORD_QUALITY_NUMERIC_COMPLEX) {
            result.seqLength = PasswordMetrics.MAX_ALLOWED_SEQUENCE;
        }
        return result;
    }
    // quality is ALPHABETIC or stronger.
    PasswordMetrics result = new PasswordMetrics(CREDENTIAL_TYPE_PASSWORD);
    result.length = length;
    if (quality == PASSWORD_QUALITY_ALPHABETIC) {
        result.nonNumeric = 1;
    } else if (quality == PASSWORD_QUALITY_ALPHANUMERIC) {
        result.numeric = 1;
        result.nonNumeric = 1;
    } else if (quality == PASSWORD_QUALITY_COMPLEX) {
        result.numeric = numeric;
        result.letters = letters;
        result.upperCase = upperCase;
        result.lowerCase = lowerCase;
        result.nonLetter = nonLetter;
        result.symbols = symbols;
    }
    return result;
}
------------------------
Find a silently evolved API code:android.app.servertransaction.LaunchActivityItem.obtain:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Obtain an instance initialized with provided params.
 */

Body of Frist Method:
{
    LaunchActivityItem instance = ObjectPool.obtain(LaunchActivityItem.class);
    if (instance == null) {
        instance = new LaunchActivityItem();
    }
    setValues(instance, intent, ident, info, curConfig, overrideConfig, compatInfo, referrer, voiceInteractor, procState, state, persistentState, pendingResults, pendingNewIntents, isForward, profilerInfo, assistToken, fixedRotationAdjustments);
    return instance;
}
Body of Second Method:
{
    LaunchActivityItem instance = ObjectPool.obtain(LaunchActivityItem.class);
    if (instance == null) {
        instance = new LaunchActivityItem();
    }
    setValues(instance, intent, ident, info, curConfig, overrideConfig, compatInfo, referrer, voiceInteractor, procState, state, persistentState, pendingResults, pendingNewIntents, activityOptions, isForward, profilerInfo, assistToken, activityClientController, fixedRotationAdjustments, shareableActivityToken, launchedFromBubble);
    return instance;
}
------------------------
Find a silently evolved API code:android.text.style.SuggestionSpan.writeToParcelInternal:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    dest.writeStringArray(mSuggestions);
    dest.writeInt(mFlags);
    dest.writeString(mLocaleStringForCompatibility);
    dest.writeString(mLanguageTag);
    dest.writeInt(mHashCode);
    dest.writeInt(mEasyCorrectUnderlineColor);
    dest.writeFloat(mEasyCorrectUnderlineThickness);
    dest.writeInt(mMisspelledUnderlineColor);
    dest.writeFloat(mMisspelledUnderlineThickness);
    dest.writeInt(mAutoCorrectionUnderlineColor);
    dest.writeFloat(mAutoCorrectionUnderlineThickness);
}
Body of Second Method:
{
    dest.writeStringArray(mSuggestions);
    dest.writeInt(mFlags);
    dest.writeString(mLocaleStringForCompatibility);
    dest.writeString(mLanguageTag);
    dest.writeInt(mHashCode);
    dest.writeInt(mEasyCorrectUnderlineColor);
    dest.writeFloat(mEasyCorrectUnderlineThickness);
    dest.writeInt(mMisspelledUnderlineColor);
    dest.writeFloat(mMisspelledUnderlineThickness);
    dest.writeInt(mAutoCorrectionUnderlineColor);
    dest.writeFloat(mAutoCorrectionUnderlineThickness);
    dest.writeInt(mGrammarErrorUnderlineColor);
    dest.writeFloat(mGrammarErrorUnderlineThickness);
}
------------------------
Find a silently evolved API code:android.text.format.TimeFormatter.format:COMMENT
Method Modifier: public      
Comment:/**
 * Format the specified {@code wallTime} using {@code pattern}. The output is returned.
 */

Body of Frist Method:
{
    try {
        StringBuilder stringBuilder = new StringBuilder();
        outputBuilder = stringBuilder;
        // This uses the US locale because number localization is handled separately (see below)
        // and locale sensitive strings are output directly using outputBuilder.
        numberFormatter = new Formatter(stringBuilder, Locale.US);
        formatInternal(pattern, wallTime, zoneInfo);
        String result = stringBuilder.toString();
        // as being in ASCII and not localized.
        return localizeDigits(result);
    } finally {
        outputBuilder = null;
        numberFormatter = null;
    }
}
Body of Second Method:
{
    try {
        StringBuilder stringBuilder = new StringBuilder();
        outputBuilder = stringBuilder;
        // This uses the US locale because number localization is handled separately (see below)
        // and locale sensitive strings are output directly using outputBuilder.
        numberFormatter = new Formatter(stringBuilder, Locale.US);
        formatInternal(pattern, wallTime, zoneInfoData);
        String result = stringBuilder.toString();
        // as being in ASCII and not localized.
        return localizeDigits(result);
    } finally {
        outputBuilder = null;
        numberFormatter = null;
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHidHost.getDevicesMatchingConnectionStates:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * {@inheritDoc}
 *
 * @hide
 */

Body of Frist Method:
{
    if (VDBG)
        log("getDevicesMatchingStates()");
    final IBluetoothHidHost service = getService();
    if (service != null && isEnabled()) {
        try {
            return service.getDevicesMatchingConnectionStates(states);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
Body of Second Method:
{
    if (VDBG)
        log("getDevicesMatchingStates()");
    final IBluetoothHidHost service = getService();
    if (service != null && isEnabled()) {
        try {
            return Attributable.setAttributionSource(service.getDevicesMatchingConnectionStates(states, mAttributionSource), mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothAvrcpController.getConnectedDevices:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (VDBG)
        log("getConnectedDevices()");
    final IBluetoothAvrcpController service = getService();
    if (service != null && isEnabled()) {
        try {
            return service.getConnectedDevices();
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
Body of Second Method:
{
    if (VDBG)
        log("getConnectedDevices()");
    final IBluetoothAvrcpController service = getService();
    if (service != null && isEnabled()) {
        try {
            return Attributable.setAttributionSource(service.getConnectedDevices(mAttributionSource), mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothSap.getState:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the current state of the BluetoothSap service.
 *
 * @return One of the STATE_ return codes, or STATE_ERROR if this proxy object is currently not
 * connected to the Sap service.
 * @hide
 */

Body of Frist Method:
{
    if (VDBG)
        log("getState()");
    final IBluetoothSap service = getService();
    if (service != null) {
        try {
            return service.getState();
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            log(Log.getStackTraceString(new Throwable()));
    }
    return BluetoothSap.STATE_ERROR;
}
Body of Second Method:
{
    if (VDBG)
        log("getState()");
    final IBluetoothSap service = getService();
    if (service != null) {
        try {
            return service.getState(mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            log(Log.getStackTraceString(new Throwable()));
    }
    return BluetoothSap.STATE_ERROR;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHidHost.getConnectedDevices:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * {@inheritDoc}
 *
 * @hide
 */

Body of Frist Method:
{
    if (VDBG)
        log("getConnectedDevices()");
    final IBluetoothHidHost service = getService();
    if (service != null && isEnabled()) {
        try {
            return service.getConnectedDevices();
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
Body of Second Method:
{
    if (VDBG)
        log("getConnectedDevices()");
    final IBluetoothHidHost service = getService();
    if (service != null && isEnabled()) {
        try {
            return Attributable.setAttributionSource(service.getConnectedDevices(mAttributionSource), mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
------------------------
Find a silently evolved API code:android.location.LocationProvider.requiresNetwork:COMMENT
<android.location.LocationProvider: boolean requiresNetwork()>
public      ->public      deprecated  
Method Modifier: public      deprecated  
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Returns true if the provider requires access to a
 * data network (e.g., the Internet), false otherwise.
 */

Body of Frist Method:
{
    return mProperties.mRequiresNetwork;
}
Body of Second Method:
{
    if (mProperties == null) {
        return false;
    } else {
        return mProperties.hasNetworkRequirement();
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothA2dp.setOptionalCodecsEnabled:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets a persistent preference for whether a given device should have optional codecs enabled.
 *
 * @param device The device to set this preference for.
 * @param value Whether the optional codecs should be enabled for this device.  This should be
 * one of OPTIONAL_CODECS_PREF_UNKNOWN, OPTIONAL_CODECS_PREF_ENABLED, or
 * OPTIONAL_CODECS_PREF_DISABLED.
 * @hide
 */

Body of Frist Method:
{
    verifyDeviceNotNull(device, "setOptionalCodecsEnabled");
    try {
        if (value != BluetoothA2dp.OPTIONAL_CODECS_PREF_UNKNOWN && value != BluetoothA2dp.OPTIONAL_CODECS_PREF_DISABLED && value != BluetoothA2dp.OPTIONAL_CODECS_PREF_ENABLED) {
            Log.e(TAG, "Invalid value passed to setOptionalCodecsEnabled: " + value);
            return;
        }
        final IBluetoothA2dp service = getService();
        if (service != null && isEnabled() && isValidDevice(device)) {
            service.setOptionalCodecsEnabled(device, value);
        }
        if (service == null)
            Log.w(TAG, "Proxy not attached to service");
        return;
    } catch (RemoteException e) {
        Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
        return;
    }
}
Body of Second Method:
{
    verifyDeviceNotNull(device, "setOptionalCodecsEnabled");
    try {
        if (value != BluetoothA2dp.OPTIONAL_CODECS_PREF_UNKNOWN && value != BluetoothA2dp.OPTIONAL_CODECS_PREF_DISABLED && value != BluetoothA2dp.OPTIONAL_CODECS_PREF_ENABLED) {
            Log.e(TAG, "Invalid value passed to setOptionalCodecsEnabled: " + value);
            return;
        }
        final IBluetoothA2dp service = getService();
        if (service != null && isEnabled() && isValidDevice(device)) {
            service.setOptionalCodecsEnabled(device, value, mAttributionSource);
        }
        if (service == null)
            Log.w(TAG, "Proxy not attached to service");
        return;
    } catch (RemoteException e) {
        Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
        return;
    }
}
------------------------
Find a silently evolved API code:android.window.WindowMetricsHelper.getBoundsExcludingNavigationBarAndCutout:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Returns bounds excluding navigation bar and display cutout (but including status bar).
 * This has the same behavior as {@link Display#getSize(Point)}.
 */

Body of Frist Method:
{
    final WindowInsets windowInsets = windowMetrics.getWindowInsets();
    Insets insets;
    if (ViewRootImpl.sNewInsetsMode == NEW_INSETS_MODE_FULL) {
        insets = windowInsets.getInsetsIgnoringVisibility(navigationBars() | displayCutout());
    } else {
        final Insets stableInsets = windowInsets.getStableInsets();
        insets = Insets.of(stableInsets.left, 0, /* top */
        stableInsets.right, stableInsets.bottom);
        final DisplayCutout cutout = windowInsets.getDisplayCutout();
        insets = (cutout != null) ? Insets.max(insets, Insets.of(cutout.getSafeInsets())) : insets;
    }
    final Rect result = new Rect(windowMetrics.getBounds());
    result.inset(insets);
    return result;
}
Body of Second Method:
{
    final WindowInsets windowInsets = windowMetrics.getWindowInsets();
    final Rect result = new Rect(windowMetrics.getBounds());
    result.inset(windowInsets.getInsetsIgnoringVisibility(navigationBars() | displayCutout()));
    return result;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadset.getConnectionPolicy:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the connection policy of the profile.
 *
 * <p> The connection policy can be any of:
 * {@link #CONNECTION_POLICY_ALLOWED}, {@link #CONNECTION_POLICY_FORBIDDEN},
 * {@link #CONNECTION_POLICY_UNKNOWN}
 *
 * @param device Bluetooth device
 * @return connection policy of the device
 * @hide
 */

Body of Frist Method:
{
    if (VDBG)
        log("getConnectionPolicy(" + device + ")");
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getConnectionPolicy(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.CONNECTION_POLICY_FORBIDDEN;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return BluetoothProfile.CONNECTION_POLICY_FORBIDDEN;
}
Body of Second Method:
{
    if (VDBG)
        log("getConnectionPolicy(" + device + ")");
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getConnectionPolicy(device, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.CONNECTION_POLICY_FORBIDDEN;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return BluetoothProfile.CONNECTION_POLICY_FORBIDDEN;
}
------------------------
Find a silently evolved API code:android.content.pm.ShortcutManager.getPinnedShortcuts:COMMENT
Method Modifier: public      
Comment:/**
 * Return all pinned shortcuts from the caller app.
 *
 * <p>This API is intended to be used for examining what shortcuts are currently published.
 * Re-publishing returned {@link ShortcutInfo}s via APIs such as
 * {@link #setDynamicShortcuts(List)} may cause loss of information such as icons.
 *
 * @throws IllegalStateException when the user is locked.
 */

Body of Frist Method:
{
    try {
        return mService.getShortcuts(mContext.getPackageName(), FLAG_MATCH_PINNED, injectMyUserId()).getList();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    try {
        return getFutureOrThrow(mService.getShortcuts(mContext.getPackageName(), FLAG_MATCH_PINNED, injectMyUserId())).getList();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothDevice.setSimAccessPermission:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets whether the Sim access is allowed to this device.
 *
 * @param value Can be {@link #ACCESS_UNKNOWN} if the device is unbonded,
 * {@link #ACCESS_ALLOWED} if the permission is being granted, or {@link #ACCESS_REJECTED} if
 * the permission is not being granted.
 * @return Whether the value has been successfully set.
 * @hide
 */

Body of Frist Method:
{
    final IBluetooth service = sService;
    if (service == null) {
        return false;
    }
    try {
        return service.setSimAccessPermission(this, value);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
Body of Second Method:
{
    final IBluetooth service = sService;
    if (service == null) {
        return false;
    }
    try {
        return service.setSimAccessPermission(this, value, mAttributionSource);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
------------------------
Find a silently evolved API code:android.telephony.CellIdentityCdma.updateGlobalCellId:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    mGlobalCellId = null;
    if (mNetworkId == CellInfo.UNAVAILABLE || mSystemId == CellInfo.UNAVAILABLE || mBasestationId == CellInfo.UNAVAILABLE)
        return;
    mGlobalCellId = String.format("%04x%04x%04x", mSystemId, mNetworkId, mBasestationId);
}
Body of Second Method:
{
    mGlobalCellId = null;
    if (mNetworkId == CellInfo.UNAVAILABLE || mSystemId == CellInfo.UNAVAILABLE || mBasestationId == CellInfo.UNAVAILABLE)
        return;
    mGlobalCellId = formatSimple("%04x%04x%04x", mSystemId, mNetworkId, mBasestationId);
}
------------------------
Find a silently evolved API code:android.hardware.camera2.utils.SurfaceUtils.isFlexibleConsumer:COMMENT
Method Modifier: public      static      
Comment:/**
 * Return true is the consumer is one of the consumers that can accept
 * producer overrides of the default dimensions and format.
 */

Body of Frist Method:
{
    return LegacyCameraDevice.isFlexibleConsumer(output);
}
Body of Second Method:
{
    checkNotNull(output);
    long usageFlags = nativeDetectSurfaceUsageFlags(output);
    // Keep up to date with allowed consumer types in
    // frameworks/av/services/camera/libcameraservice/api2/CameraDeviceClient.cpp
    long disallowedFlags = HardwareBuffer.USAGE_VIDEO_ENCODE | USAGE_RENDERSCRIPT;
    long allowedFlags = HardwareBuffer.USAGE_GPU_SAMPLED_IMAGE | HardwareBuffer.USAGE_CPU_READ_OFTEN | USAGE_HW_COMPOSER;
    boolean flexibleConsumer = ((usageFlags & disallowedFlags) == 0 && (usageFlags & allowedFlags) != 0);
    return flexibleConsumer;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothManager.openGattServer:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Open a GATT Server
 * The callback is used to deliver results to Caller, such as connection status as well
 * as the results of any other GATT server operations.
 * The method returns a BluetoothGattServer instance. You can use BluetoothGattServer
 * to conduct GATT server operations.
 *
 * @param context App context
 * @param callback GATT server callback handler that will receive asynchronous callbacks.
 * @param transport preferred transport for GATT connections to remote dual-mode devices {@link
 * BluetoothDevice#TRANSPORT_AUTO} or {@link BluetoothDevice#TRANSPORT_BREDR} or {@link
 * BluetoothDevice#TRANSPORT_LE}
 * @return BluetoothGattServer instance
 * @hide
 */

Body of Frist Method:
{
    if (context == null || callback == null) {
        throw new IllegalArgumentException("null parameter: " + context + " " + callback);
    }
    try {
        IBluetoothManager managerService = mAdapter.getBluetoothManager();
        IBluetoothGatt iGatt = managerService.getBluetoothGatt();
        if (iGatt == null) {
            Log.e(TAG, "Fail to get GATT Server connection");
            return null;
        }
        BluetoothGattServer mGattServer = new BluetoothGattServer(iGatt, transport);
        Boolean regStatus = mGattServer.registerCallback(callback);
        return regStatus ? mGattServer : null;
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        return null;
    }
}
Body of Second Method:
{
    return (openGattServer(context, callback, transport, false));
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothGatt.setPreferredPhy:COMMENT
Method Modifier: public      
Comment:/**
 * Set the preferred connection PHY for this app. Please note that this is just a
 * recommendation, whether the PHY change will happen depends on other applications preferences,
 * local and remote controller capabilities. Controller can override these settings.
 * <p>
 * {@link BluetoothGattCallback#onPhyUpdate} will be triggered as a result of this call, even
 * if no PHY change happens. It is also triggered when remote device updates the PHY.
 *
 * @param txPhy preferred transmitter PHY. Bitwise OR of any of {@link
 * BluetoothDevice#PHY_LE_1M_MASK}, {@link BluetoothDevice#PHY_LE_2M_MASK}, and {@link
 * BluetoothDevice#PHY_LE_CODED_MASK}.
 * @param rxPhy preferred receiver PHY. Bitwise OR of any of {@link
 * BluetoothDevice#PHY_LE_1M_MASK}, {@link BluetoothDevice#PHY_LE_2M_MASK}, and {@link
 * BluetoothDevice#PHY_LE_CODED_MASK}.
 * @param phyOptions preferred coding to use when transmitting on the LE Coded PHY. Can be one
 * of {@link BluetoothDevice#PHY_OPTION_NO_PREFERRED}, {@link BluetoothDevice#PHY_OPTION_S2} or
 * {@link BluetoothDevice#PHY_OPTION_S8}
 */

Body of Frist Method:
{
    try {
        mService.clientSetPreferredPhy(mClientIf, mDevice.getAddress(), txPhy, rxPhy, phyOptions);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
}
Body of Second Method:
{
    try {
        mService.clientSetPreferredPhy(mClientIf, mDevice.getAddress(), txPhy, rxPhy, phyOptions, mAttributionSource);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
}
------------------------
Find a silently evolved API code:android.view.FrameMetrics.getMetric:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieves the value associated with Metric identifier {@code id}
 * for this frame.
 * <p>
 * Boolean metrics are represented in [0,1], with 0 corresponding to
 * false, and 1 corresponding to true.
 * </p>
 * @param id the metric to retrieve
 * @return the value of the metric or -1 if it is not available.
 */

Body of Frist Method:
{
    if (id < UNKNOWN_DELAY_DURATION || id > VSYNC_TIMESTAMP) {
        return -1;
    }
    if (mTimingData == null) {
        return -1;
    }
    if (id == FIRST_DRAW_FRAME) {
        return (mTimingData[Index.FLAGS] & FRAME_INFO_FLAG_FIRST_DRAW) != 0 ? 1 : 0;
    } else if (id == INTENDED_VSYNC_TIMESTAMP) {
        return mTimingData[Index.INTENDED_VSYNC];
    } else if (id == VSYNC_TIMESTAMP) {
        return mTimingData[Index.VSYNC];
    }
    int durationsIdx = 2 * id;
    return mTimingData[DURATIONS[durationsIdx + 1]] - mTimingData[DURATIONS[durationsIdx]];
}
Body of Second Method:
{
    if (id < UNKNOWN_DELAY_DURATION || id > DEADLINE) {
        return -1;
    }
    if (mTimingData == null) {
        return -1;
    }
    if (id == FIRST_DRAW_FRAME) {
        return (mTimingData[Index.FLAGS] & FLAG_WINDOW_VISIBILITY_CHANGED) != 0 ? 1 : 0;
    } else if (id == INTENDED_VSYNC_TIMESTAMP) {
        return mTimingData[Index.INTENDED_VSYNC];
    } else if (id == VSYNC_TIMESTAMP) {
        return mTimingData[Index.VSYNC];
    }
    int durationsIdx = 2 * id;
    return mTimingData[DURATIONS[durationsIdx + 1]] - mTimingData[DURATIONS[durationsIdx]];
}
------------------------
Find a silently evolved API code:android.view.InputChannel.openInputChannelPair:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Creates a new input channel pair.  One channel should be provided to the input
 * dispatcher and the other to the application's input queue.
 * @param name The descriptive (non-unique) name of the channel pair.
 * @return A pair of input channels.  The first channel is designated as the
 * server channel and should be used to publish input events.  The second channel
 * is designated as the client channel and should be used to consume input events.
 */

Body of Frist Method:
{
    if (name == null) {
        throw new IllegalArgumentException("name must not be null");
    }
    if (DEBUG) {
        Slog.d(TAG, "Opening input channel pair '" + name + "'");
    }
    return nativeOpenInputChannelPair(name);
}
Body of Second Method:
{
    if (name == null) {
        throw new IllegalArgumentException("name must not be null");
    }
    if (DEBUG) {
        Slog.d(TAG, "Opening input channel pair '" + name + "'");
    }
    InputChannel[] channels = new InputChannel[2];
    long[] nativeChannels = nativeOpenInputChannelPair(name);
    for (int i = 0; i < 2; i++) {
        channels[i] = new InputChannel();
        channels[i].setNativeInputChannel(nativeChannels[i]);
    }
    return channels;
}
------------------------
Find a silently evolved API code:android.content.ContentProviderClient.delete:COMMENT
Method Modifier: public      
Comment:/**
 * See {@link ContentProvider#delete ContentProvider.delete}
 */

Body of Frist Method:
{
    return delete(url, ContentResolver.createSqlQueryBundle(selection, selectionArgs));
}
Body of Second Method:
{
    Objects.requireNonNull(url, "url");
    beforeRemote();
    try {
        return mContentProvider.delete(mAttributionSource, url, extras);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}
------------------------
Find a silently evolved API code:android.service.autofill.augmented.Helper.logResponse:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Logs a {@code MetricsEvent.AUTOFILL_AUGMENTED_RESPONSE} event.
 */

Body of Frist Method:
{
    final LogMaker log = new LogMaker(MetricsEvent.AUTOFILL_AUGMENTED_RESPONSE).setType(type).setComponentName(componentName).addTaggedData(MetricsEvent.FIELD_AUTOFILL_SESSION_ID, mSessionId).addTaggedData(MetricsEvent.FIELD_AUTOFILL_SERVICE, servicePackageName).addTaggedData(MetricsEvent.FIELD_AUTOFILL_DURATION, durationMs);
    sMetricsLogger.write(log);
}
Body of Second Method:
{
    // Remove activity name from logging
    final ComponentName sanitizedComponentName = new ComponentName(componentName.getPackageName(), "");
    final LogMaker log = new LogMaker(MetricsEvent.AUTOFILL_AUGMENTED_RESPONSE).setType(type).setComponentName(sanitizedComponentName).addTaggedData(MetricsEvent.FIELD_AUTOFILL_SESSION_ID, mSessionId).addTaggedData(MetricsEvent.FIELD_AUTOFILL_SERVICE, servicePackageName).addTaggedData(MetricsEvent.FIELD_AUTOFILL_DURATION, durationMs);
    sMetricsLogger.write(log);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadset.getAudioState:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the current audio state of the Headset.
 * Note: This is an internal function and shouldn't be exposed
 *
 * @hide
 */

Body of Frist Method:
{
    if (VDBG)
        log("getAudioState");
    final IBluetoothHeadset service = mService;
    if (service != null && !isDisabled()) {
        try {
            return service.getAudioState(device);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return BluetoothHeadset.STATE_AUDIO_DISCONNECTED;
}
Body of Second Method:
{
    if (VDBG)
        log("getAudioState");
    final IBluetoothHeadset service = mService;
    if (service != null && !isDisabled()) {
        try {
            return service.getAudioState(device, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return BluetoothHeadset.STATE_AUDIO_DISCONNECTED;
}
------------------------
Find a silently evolved API code:android.telephony.ims.stub.ImsEcbmImplBase.enteredEcbm:COMMENT
Method Modifier: public      final       hidden      
Comment:/**
 * Notifies the framework when the device enters Emergency Callback Mode.
 *
 * @throws RuntimeException if the connection to the framework is not available.
 */

Body of Frist Method:
{
    Log.d(TAG, "Entered ECBM.");
    if (mListener != null) {
        try {
            mListener.enteredECBM();
        } catch (RemoteException e) {
            throw new RuntimeException(e);
        }
    }
}
Body of Second Method:
{
    Log.d(TAG, "Entered ECBM.");
    IImsEcbmListener listener;
    synchronized (mLock) {
        listener = mListener;
    }
    if (listener != null) {
        try {
            listener.enteredECBM();
        } catch (RemoteException e) {
            throw new RuntimeException(e);
        }
    }
}
------------------------
Find a silently evolved API code:android.service.voice.AlwaysOnHotwordDetector.invalidate:COMMENT
Method Modifier: default     hidden      
Comment:/**
 * Invalidates this hotword detector so that any future calls to this result
 * in an IllegalStateException.
 *
 * @hide
 */

Body of Frist Method:
{
    synchronized (mLock) {
        mAvailability = STATE_INVALID;
        notifyStateChangedLocked();
    }
}
Body of Second Method:
{
    synchronized (mLock) {
        mAvailability = STATE_INVALID;
        notifyStateChangedLocked();
        if (mSupportHotwordDetectionService) {
            try {
                mModelManagementService.shutdownHotwordDetectionService();
            } catch (RemoteException e) {
                throw e.rethrowFromSystemServer();
            }
        }
    }
}
------------------------
Find a silently evolved API code:android.os.PersistableBundle.readFromStream:COMMENT
Method Modifier: public      static      
Comment:/**
 * Reads a {@link PersistableBundle} from an {@link InputStream}.
 *
 * <p>The stream must be generated by {@link #writeToStream}.
 *
 * @see #writeToStream
 */

Body of Frist Method:
{
    try {
        XmlPullParser parser = XmlPullParserFactory.newInstance().newPullParser();
        parser.setInput(inputStream, UTF_8.name());
        parser.next();
        return PersistableBundle.restoreFromXml(parser);
    } catch (XmlPullParserException e) {
        throw new IOException(e);
    }
}
Body of Second Method:
{
    try {
        TypedXmlPullParser parser = Xml.newFastPullParser();
        parser.setInput(inputStream, UTF_8.name());
        parser.next();
        return PersistableBundle.restoreFromXml(parser);
    } catch (XmlPullParserException e) {
        throw new IOException(e);
    }
}
------------------------
Find a silently evolved API code:android.hardware.camera2.utils.SurfaceUtils.isSurfaceForHwVideoEncoder:COMMENT
Method Modifier: public      static      
Comment:/**
 * Check if the surface is for hardware video encoder consumer based on consumer end point
 * Gralloc usage flags.
 *
 * @param surface The surface to be checked.
 * @return true if the surface is for hardware video encoder consumer, false otherwise.
 */

Body of Frist Method:
{
    return LegacyCameraDevice.isVideoEncoderConsumer(surface);
}
Body of Second Method:
{
    checkNotNull(surface);
    long usageFlags = nativeDetectSurfaceUsageFlags(surface);
    long disallowedFlags = HardwareBuffer.USAGE_GPU_SAMPLED_IMAGE | USAGE_HW_COMPOSER | USAGE_RENDERSCRIPT | HardwareBuffer.USAGE_CPU_READ_OFTEN;
    long allowedFlags = HardwareBuffer.USAGE_VIDEO_ENCODE;
    boolean videoEncoderConsumer = ((usageFlags & disallowedFlags) == 0 && (usageFlags & allowedFlags) != 0);
    int surfaceFormat = getSurfaceFormat(surface);
    return videoEncoderConsumer;
}
------------------------
Find a silently evolved API code:android.widget.TextClock.chooseFormat:COMMENT
Method Modifier: private     
Comment:/**
 * Selects either one of {@link #getFormat12Hour()} or {@link #getFormat24Hour()}
 * depending on whether the user has selected 24-hour format.
 */

Body of Frist Method:
{
    final boolean format24Requested = is24HourModeEnabled();
    LocaleData ld = LocaleData.get(getContext().getResources().getConfiguration().locale);
    if (format24Requested) {
        mFormat = abc(mFormat24, mFormat12, ld.timeFormat_Hm);
        mDescFormat = abc(mDescFormat24, mDescFormat12, mFormat);
    } else {
        mFormat = abc(mFormat12, mFormat24, ld.timeFormat_hm);
        mDescFormat = abc(mDescFormat12, mDescFormat24, mFormat);
    }
    boolean hadSeconds = mHasSeconds;
    mHasSeconds = DateFormat.hasSeconds(mFormat);
    if (mShouldRunTicker && hadSeconds != mHasSeconds) {
        if (hadSeconds)
            getHandler().removeCallbacks(mTicker);
        else
            mTicker.run();
    }
}
Body of Second Method:
{
    final boolean format24Requested = is24HourModeEnabled();
    if (format24Requested) {
        mFormat = abc(mFormat24, mFormat12, getBestDateTimePattern("Hm"));
        mDescFormat = abc(mDescFormat24, mDescFormat12, mFormat);
    } else {
        mFormat = abc(mFormat12, mFormat24, getBestDateTimePattern("hm"));
        mDescFormat = abc(mDescFormat12, mDescFormat24, mFormat);
    }
    boolean hadSeconds = mHasSeconds;
    mHasSeconds = DateFormat.hasSeconds(mFormat);
    if (mShouldRunTicker && hadSeconds != mHasSeconds) {
        mTicker.run();
    }
}
------------------------
Find a silently evolved API code:android.view.InputChannel.release:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Release the Java objects hold over the native InputChannel. If other references
 * still exist in native-land, then the channel may continue to exist.
 */

Body of Frist Method:
{
    nativeRelease();
}
Body of Second Method:
{
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothA2dp.isOptionalCodecsSupported:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns whether this device supports optional codecs.
 *
 * @param device The device to check
 * @return one of OPTIONAL_CODECS_SUPPORT_UNKNOWN, OPTIONAL_CODECS_NOT_SUPPORTED, or
 * OPTIONAL_CODECS_SUPPORTED.
 * @hide
 */

Body of Frist Method:
{
    verifyDeviceNotNull(device, "isOptionalCodecsSupported");
    try {
        final IBluetoothA2dp service = getService();
        if (service != null && isEnabled() && isValidDevice(device)) {
            return service.supportsOptionalCodecs(device);
        }
        if (service == null)
            Log.w(TAG, "Proxy not attached to service");
        return OPTIONAL_CODECS_SUPPORT_UNKNOWN;
    } catch (RemoteException e) {
        Log.e(TAG, "Error talking to BT service in supportsOptionalCodecs()", e);
        return OPTIONAL_CODECS_SUPPORT_UNKNOWN;
    }
}
Body of Second Method:
{
    verifyDeviceNotNull(device, "isOptionalCodecsSupported");
    try {
        final IBluetoothA2dp service = getService();
        if (service != null && isEnabled() && isValidDevice(device)) {
            return service.supportsOptionalCodecs(device, mAttributionSource);
        }
        if (service == null)
            Log.w(TAG, "Proxy not attached to service");
        return OPTIONAL_CODECS_SUPPORT_UNKNOWN;
    } catch (RemoteException e) {
        Log.e(TAG, "Error talking to BT service in supportsOptionalCodecs()", e);
        return OPTIONAL_CODECS_SUPPORT_UNKNOWN;
    }
}
------------------------
Find a silently evolved API code:android.hardware.display.AmbientDisplayConfiguration.enabled:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * {@hide}
 */

Body of Frist Method:
{
    return pulseOnNotificationEnabled(user) || pulseOnLongPressEnabled(user) || alwaysOnEnabled(user) || wakeLockScreenGestureEnabled(user) || wakeDisplayGestureEnabled(user) || pickupGestureEnabled(user) || tapGestureEnabled(user) || doubleTapGestureEnabled(user);
}
Body of Second Method:
{
    return pulseOnNotificationEnabled(user) || pulseOnLongPressEnabled(user) || alwaysOnEnabled(user) || wakeLockScreenGestureEnabled(user) || wakeDisplayGestureEnabled(user) || pickupGestureEnabled(user) || tapGestureEnabled(user) || doubleTapGestureEnabled(user) || quickPickupSensorEnabled(user) || screenOffUdfpsEnabled(user);
}
------------------------
Find a silently evolved API code:android.view.autofill.AutofillValue.getListValue:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the value to autofill a selection list field.
 *
 * <p>See {@link View#AUTOFILL_TYPE_LIST} for more info.</p>
 *
 * @throws IllegalStateException if the value is not a list value
 */

Body of Frist Method:
{
    Preconditions.checkState(isList(), "value must be a list value, not type=" + mType);
    return (Integer) mValue;
}
Body of Second Method:
{
    Preconditions.checkState(isList(), "value must be a list value, not type=%d", mType);
    return (Integer) mValue;
}
------------------------
Find a silently evolved API code:android.content.pm.parsing.result.ParseInput.DeferredError.getTargetSdkForChange:COMMENT
Method Modifier: public      static      
Comment:/**
 * TODO(chiuwinson): This is required because PackageManager#getPackageArchiveInfo
 * cannot read the targetSdk info from the changeId because it requires the
 * READ_COMPAT_CHANGE_CONFIG which cannot be obtained automatically without entering the
 * server process. This should be removed once an alternative is found, or if the API
 * is removed.
 * @return the targetSdk that this change is gated on (> check), or -1 if disabled
 */

Body of Frist Method:
{
    if (changeId == MISSING_APP_TAG || changeId == EMPTY_INTENT_ACTION_CATEGORY || changeId == RESOURCES_ARSC_COMPRESSED) {
        return Build.VERSION_CODES.Q;
    }
    return -1;
}
Body of Second Method:
{
    if (changeId == MISSING_APP_TAG || changeId == EMPTY_INTENT_ACTION_CATEGORY || changeId == RESOURCES_ARSC_COMPRESSED) {
        return Build.VERSION_CODES.Q;
    }
    if (changeId == MISSING_EXPORTED_FLAG) {
        return Build.VERSION_CODES.R;
    }
    return -1;
}
------------------------
Find a silently evolved API code:android.media.Rating.newPercentageRating:COMMENT
Method Modifier: public      static      
Comment:/**
 * Return a Rating instance with a percentage-based rating.
 * Create and return a new Rating instance with a {@link #RATING_PERCENTAGE}
 * rating style, and a rating of the given percentage.
 * @param percent the value of the rating
 * @return null if the rating is out of range, a new Rating instance otherwise.
 */

Body of Frist Method:
{
    if ((percent < 0.0f) || (percent > 100.0f)) {
        Log.e(TAG, "Invalid percentage-based rating value");
        return null;
    } else {
        return new Rating(RATING_PERCENTAGE, percent);
    }
}
Body of Second Method:
{
    if (percent >= 0.0f && percent <= 100.0f) {
        return new Rating(RATING_PERCENTAGE, percent);
    } else {
        Log.e(TAG, "Invalid percentage-based rating value");
        return null;
    }
}
------------------------
Find a silently evolved API code:android.media.AudioFormat.isPublicEncoding:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    switch(audioFormat) {
        case ENCODING_PCM_16BIT:
        case ENCODING_PCM_8BIT:
        case ENCODING_PCM_FLOAT:
        case ENCODING_AC3:
        case ENCODING_E_AC3:
        case ENCODING_DTS:
        case ENCODING_DTS_HD:
        case ENCODING_MP3:
        case ENCODING_AAC_LC:
        case ENCODING_AAC_HE_V1:
        case ENCODING_AAC_HE_V2:
        case ENCODING_IEC61937:
        case ENCODING_DOLBY_TRUEHD:
        case ENCODING_AAC_ELD:
        case ENCODING_AAC_XHE:
        case ENCODING_AC4:
        case ENCODING_E_AC3_JOC:
        case ENCODING_DOLBY_MAT:
        case ENCODING_OPUS:
            return true;
        default:
            return false;
    }
}
Body of Second Method:
{
    switch(audioFormat) {
        case ENCODING_PCM_16BIT:
        case ENCODING_PCM_8BIT:
        case ENCODING_PCM_FLOAT:
        case ENCODING_AC3:
        case ENCODING_E_AC3:
        case ENCODING_DTS:
        case ENCODING_DTS_HD:
        case ENCODING_MP3:
        case ENCODING_AAC_LC:
        case ENCODING_AAC_HE_V1:
        case ENCODING_AAC_HE_V2:
        case ENCODING_IEC61937:
        case ENCODING_DOLBY_TRUEHD:
        case ENCODING_AAC_ELD:
        case ENCODING_AAC_XHE:
        case ENCODING_AC4:
        case ENCODING_E_AC3_JOC:
        case ENCODING_DOLBY_MAT:
        case ENCODING_OPUS:
        case ENCODING_PCM_24BIT_PACKED:
        case ENCODING_PCM_32BIT:
        case ENCODING_MPEGH_BL_L3:
        case ENCODING_MPEGH_BL_L4:
        case ENCODING_MPEGH_LC_L3:
        case ENCODING_MPEGH_LC_L4:
        case ENCODING_DTS_UHD:
        case ENCODING_DRA:
            return true;
        default:
            return false;
    }
}
------------------------
Find a silently evolved API code:android.location.LocationProvider.supportsBearing:COMMENT
<android.location.LocationProvider: boolean supportsBearing()>
public      ->public      deprecated  
Method Modifier: public      deprecated  
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Returns true if the provider is able to provide bearing
 * information, false otherwise.  A provider that reports bearing
 * under most circumstances but may occassionally not report it
 * should return true.
 */

Body of Frist Method:
{
    return mProperties.mSupportsBearing;
}
Body of Second Method:
{
    if (mProperties == null) {
        return false;
    } else {
        return mProperties.hasBearingSupport();
    }
}
------------------------
Find a silently evolved API code:android.view.InputChannel.getName:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Gets the name of the input channel.
 * @return The input channel name.
 */

Body of Frist Method:
{
    String name = nativeGetName();
    return name != null ? name : "uninitialized";
}
Body of Second Method:
{
    String name = nativeGetName(mPtr);
    return name != null ? name : "uninitialized";
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.rejectCall:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Rejects a call.
 *
 * @param device remote device
 * @return <code>true</code> if command has been issued successfully; <code>false</code>
 * otherwise; upon completion HFP sends {@link #ACTION_CALL_CHANGED} intent.
 *
 * <p>Feature required for successful execution is being reported by: {@link
 * #EXTRA_AG_FEATURE_REJECT_CALL}. This method invocation will fail silently when feature is not
 * supported.</p>
 */

Body of Frist Method:
{
    if (DBG)
        log("rejectCall()");
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.rejectCall(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("rejectCall()");
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.rejectCall(device, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.location.Geofence.createCircle:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Create a circular geofence (on a flat, horizontal plane).
 *
 * @param latitude latitude in degrees, between -90 and +90 inclusive
 * @param longitude longitude in degrees, between -180 and +180 inclusive
 * @param radius radius in meters
 * @return a new geofence
 * @throws IllegalArgumentException if any parameters are out of range
 */

Body of Frist Method:
{
    return new Geofence(latitude, longitude, radius);
}
Body of Second Method:
{
    return new Geofence(latitude, longitude, radius, expirationRealtimeMs);
}
------------------------
Find a silently evolved API code:android.location.LocationProvider.propertiesMeetCriteria:COMMENT
<android.location.LocationProvider: boolean propertiesMeetCriteria(String,ProviderProperties,Criteria)>
public      static      hidden      ->public      static      hidden      deprecated  
Method Modifier: public      static      hidden      deprecated  
Method Modifier: Yes         Yes         Yes         No          
Method Updated:  Yes         Yes         Yes         Yes         
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (LocationManager.PASSIVE_PROVIDER.equals(name)) {
        // passive provider never matches
        return false;
    }
    if (properties == null) {
        // that have not finished binding yet
        return false;
    }
    if (criteria.getAccuracy() != Criteria.NO_REQUIREMENT && criteria.getAccuracy() < properties.mAccuracy) {
        return false;
    }
    if (criteria.getPowerRequirement() != Criteria.NO_REQUIREMENT && criteria.getPowerRequirement() < properties.mPowerRequirement) {
        return false;
    }
    if (criteria.isAltitudeRequired() && !properties.mSupportsAltitude) {
        return false;
    }
    if (criteria.isSpeedRequired() && !properties.mSupportsSpeed) {
        return false;
    }
    if (criteria.isBearingRequired() && !properties.mSupportsBearing) {
        return false;
    }
    if (!criteria.isCostAllowed() && properties.mHasMonetaryCost) {
        return false;
    }
    return true;
}
Body of Second Method:
{
    if (LocationManager.PASSIVE_PROVIDER.equals(name)) {
        // passive provider never matches
        return false;
    }
    if (properties == null) {
        // that have not finished binding yet
        return false;
    }
    if (criteria.getAccuracy() != Criteria.NO_REQUIREMENT && criteria.getAccuracy() < properties.getAccuracy()) {
        return false;
    }
    if (criteria.getPowerRequirement() != Criteria.NO_REQUIREMENT && criteria.getPowerRequirement() < properties.getPowerUsage()) {
        return false;
    }
    if (criteria.isAltitudeRequired() && !properties.hasAltitudeSupport()) {
        return false;
    }
    if (criteria.isSpeedRequired() && !properties.hasSpeedSupport()) {
        return false;
    }
    if (criteria.isBearingRequired() && !properties.hasBearingSupport()) {
        return false;
    }
    if (!criteria.isCostAllowed() && properties.hasMonetaryCost()) {
        return false;
    }
    return true;
}
------------------------
Find a silently evolved API code:android.media.audiopolicy.AudioMix.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Combines all of the settings and return a new {@link AudioMix} object.
 * @return a new {@link AudioMix} object
 * @throws IllegalArgumentException if no {@link AudioMixingRule} has been set.
 */

Body of Frist Method:
{
    if (mRule == null) {
        throw new IllegalArgumentException("Illegal null AudioMixingRule");
    }
    if (mRouteFlags == 0) {
        // no route flags set, use default as described in Builder.setRouteFlags(int)
        mRouteFlags = ROUTE_FLAG_LOOP_BACK;
    }
    if (mFormat == null) {
        // FIXME Can we eliminate this?  Will AudioMix work with an unspecified sample rate?
        int rate = AudioSystem.getPrimaryOutputSamplingRate();
        if (rate <= 0) {
            rate = 44100;
        }
        mFormat = new AudioFormat.Builder().setSampleRate(rate).build();
    }
    if ((mDeviceSystemType != AudioSystem.DEVICE_NONE) && (mDeviceSystemType != AudioSystem.DEVICE_OUT_REMOTE_SUBMIX) && (mDeviceSystemType != AudioSystem.DEVICE_IN_REMOTE_SUBMIX)) {
        if ((mRouteFlags & ROUTE_FLAG_RENDER) == 0) {
            throw new IllegalArgumentException("Can't have audio device without flag ROUTE_FLAG_RENDER");
        }
        if (mRule.getTargetMixType() != AudioMix.MIX_TYPE_PLAYERS) {
            throw new IllegalArgumentException("Unsupported device on non-playback mix");
        }
    } else {
        if ((mRouteFlags & ROUTE_FLAG_SUPPORTED) == ROUTE_FLAG_RENDER) {
            throw new IllegalArgumentException("Can't have flag ROUTE_FLAG_RENDER without an audio device");
        }
        if ((mRouteFlags & ROUTE_FLAG_LOOP_BACK) == ROUTE_FLAG_LOOP_BACK) {
            if (mRule.getTargetMixType() == MIX_TYPE_PLAYERS) {
                mDeviceSystemType = AudioSystem.DEVICE_OUT_REMOTE_SUBMIX;
            } else if (mRule.getTargetMixType() == MIX_TYPE_RECORDERS) {
                mDeviceSystemType = AudioSystem.DEVICE_IN_REMOTE_SUBMIX;
            } else {
                throw new IllegalArgumentException("Unknown mixing rule type");
            }
        }
    }
    if (mRule.allowPrivilegedPlaybackCapture()) {
        String error = AudioMix.canBeUsedForPrivilegedCapture(mFormat);
        if (error != null) {
            throw new IllegalArgumentException(error);
        }
    }
    return new AudioMix(mRule, mFormat, mRouteFlags, mCallbackFlags, mDeviceSystemType, mDeviceAddress);
}
Body of Second Method:
{
    if (mRule == null) {
        throw new IllegalArgumentException("Illegal null AudioMixingRule");
    }
    if (mRouteFlags == 0) {
        // no route flags set, use default as described in Builder.setRouteFlags(int)
        mRouteFlags = ROUTE_FLAG_LOOP_BACK;
    }
    if (mFormat == null) {
        // FIXME Can we eliminate this?  Will AudioMix work with an unspecified sample rate?
        int rate = AudioSystem.getPrimaryOutputSamplingRate();
        if (rate <= 0) {
            rate = 44100;
        }
        mFormat = new AudioFormat.Builder().setSampleRate(rate).build();
    }
    if ((mDeviceSystemType != AudioSystem.DEVICE_NONE) && (mDeviceSystemType != AudioSystem.DEVICE_OUT_REMOTE_SUBMIX) && (mDeviceSystemType != AudioSystem.DEVICE_IN_REMOTE_SUBMIX)) {
        if ((mRouteFlags & ROUTE_FLAG_RENDER) == 0) {
            throw new IllegalArgumentException("Can't have audio device without flag ROUTE_FLAG_RENDER");
        }
        if (mRule.getTargetMixType() != AudioMix.MIX_TYPE_PLAYERS) {
            throw new IllegalArgumentException("Unsupported device on non-playback mix");
        }
    } else {
        if ((mRouteFlags & ROUTE_FLAG_SUPPORTED) == ROUTE_FLAG_RENDER) {
            throw new IllegalArgumentException("Can't have flag ROUTE_FLAG_RENDER without an audio device");
        }
        if ((mRouteFlags & ROUTE_FLAG_LOOP_BACK) == ROUTE_FLAG_LOOP_BACK) {
            if (mRule.getTargetMixType() == MIX_TYPE_PLAYERS) {
                mDeviceSystemType = AudioSystem.DEVICE_OUT_REMOTE_SUBMIX;
            } else if (mRule.getTargetMixType() == MIX_TYPE_RECORDERS) {
                mDeviceSystemType = AudioSystem.DEVICE_IN_REMOTE_SUBMIX;
            } else {
                throw new IllegalArgumentException("Unknown mixing rule type");
            }
        }
    }
    if (mRule.allowPrivilegedMediaPlaybackCapture()) {
        String error = AudioMix.canBeUsedForPrivilegedMediaCapture(mFormat);
        if (error != null) {
            throw new IllegalArgumentException(error);
        }
    }
    return new AudioMix(mRule, mFormat, mRouteFlags, mCallbackFlags, mDeviceSystemType, mDeviceAddress);
}
------------------------
Find a silently evolved API code:android.view.DisplayAdjustments.adjustMetrics:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Adjusts the given metrics if possible.
 */

Body of Frist Method:
{
    if (noFlip(realRotation)) {
        return;
    }
    int w = metrics.widthPixels;
    metrics.widthPixels = metrics.heightPixels;
    metrics.heightPixels = w;
    w = metrics.noncompatWidthPixels;
    metrics.noncompatWidthPixels = metrics.noncompatHeightPixels;
    metrics.noncompatHeightPixels = w;
    float x = metrics.xdpi;
    metrics.xdpi = metrics.ydpi;
    metrics.ydpi = x;
    x = metrics.noncompatXdpi;
    metrics.noncompatXdpi = metrics.noncompatYdpi;
    metrics.noncompatYdpi = x;
}
Body of Second Method:
{
    if (noFlip(realRotation)) {
        return;
    }
    int w = metrics.widthPixels;
    metrics.widthPixels = metrics.heightPixels;
    metrics.heightPixels = w;
    w = metrics.noncompatWidthPixels;
    metrics.noncompatWidthPixels = metrics.noncompatHeightPixels;
    metrics.noncompatHeightPixels = w;
}
------------------------
Find a silently evolved API code:android.util.AtomicFile.finishWrite:COMMENT
Method Modifier: public      
Comment:/**
 * Call when you have successfully finished writing to the stream
 * returned by {@link #startWrite()}.  This will close, sync, and
 * commit the new data.  The next attempt to read the atomic file
 * will return the new file stream.
 */

Body of Frist Method:
{
    if (str == null) {
        return;
    }
    if (!FileUtils.sync(str)) {
        Log.e(LOG_TAG, "Failed to sync file output stream");
    }
    try {
        str.close();
    } catch (IOException e) {
        Log.e(LOG_TAG, "Failed to close file output stream", e);
    }
    rename(mNewName, mBaseName);
    if (mCommitTag != null) {
        com.android.internal.logging.EventLogTags.writeCommitSysConfigFile(mCommitTag, SystemClock.uptimeMillis() - mStartTime);
    }
}
Body of Second Method:
{
    if (str == null) {
        return;
    }
    if (!FileUtils.sync(str)) {
        Log.e(LOG_TAG, "Failed to sync file output stream");
    }
    try {
        str.close();
    } catch (IOException e) {
        Log.e(LOG_TAG, "Failed to close file output stream", e);
    }
    rename(mNewName, mBaseName);
    if (mCommitEventLogger != null) {
        mCommitEventLogger.onFinishWrite();
    }
}
------------------------
Find a silently evolved API code:android.view.inputmethod.EditorInfo.getInitialTextAfterCursor:COMMENT
Method Modifier: public      
Comment:/**
 * Get <var>length</var> characters of text after the current cursor position. May be
 * {@code null} when the protocol is not supported.
 *
 * @param length The expected length of the text.
 * @param flags Supplies additional options controlling how the text is returned. May be
 * either 0 or {@link InputConnection#GET_TEXT_WITH_STYLES}.
 * @return the text after the cursor position; the length of the returned text might be less
 * than <var>length</var>. When there is no text after the cursor, an empty string will be
 * returned. It could also be {@code null} when the editor or system could not support this
 * protocol.
 */

Body of Frist Method:
{
    return mInitialSurroundingText.getInitialTextAfterCursor(length, flags);
}
Body of Second Method:
{
    if (mInitialSurroundingText == null) {
        return null;
    }
    int surroundingTextLength = mInitialSurroundingText.getText().length();
    int selEnd = Math.max(mInitialSurroundingText.getSelectionStart(), mInitialSurroundingText.getSelectionEnd());
    int n = Math.min(length, surroundingTextLength - selEnd);
    return ((flags & InputConnection.GET_TEXT_WITH_STYLES) != 0) ? mInitialSurroundingText.getText().subSequence(selEnd, selEnd + n) : TextUtils.substring(mInitialSurroundingText.getText(), selEnd, selEnd + n);
}
------------------------
Find a silently evolved API code:android.content.ContentProviderClient.applyBatch:COMMENT
Method Modifier: public      
Comment:/**
 * See {@link ContentProvider#applyBatch ContentProvider.applyBatch}
 */

Body of Frist Method:
{
    Objects.requireNonNull(operations, "operations");
    beforeRemote();
    try {
        return mContentProvider.applyBatch(mPackageName, mAttributionTag, authority, operations);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}
Body of Second Method:
{
    return applyBatch(mAuthority, operations);
}
------------------------
Find a silently evolved API code:android.telephony.ims.stub.ImsMultiEndpointImplBase.onImsExternalCallStateUpdate:COMMENT
Method Modifier: public      final       hidden      
Comment:/**
 * Notifies framework when Dialog Event Package update is received
 *
 * @throws RuntimeException if the connection to the framework is not available.
 */

Body of Frist Method:
{
    Log.d(TAG, "ims external call state update triggered.");
    if (mListener != null) {
        try {
            mListener.onImsExternalCallStateUpdate(externalCallDialogs);
        } catch (RemoteException e) {
            throw new RuntimeException(e);
        }
    }
}
Body of Second Method:
{
    Log.d(TAG, "ims external call state update triggered.");
    IImsExternalCallStateListener listener;
    synchronized (mLock) {
        listener = mListener;
    }
    if (listener != null) {
        try {
            listener.onImsExternalCallStateUpdate(externalCallDialogs);
        } catch (RemoteException e) {
            throw new RuntimeException(e);
        }
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.setConnectionPolicy:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Set connection policy of the profile
 *
 * <p> The device should already be paired.
 * Connection policy can be one of {@link #CONNECTION_POLICY_ALLOWED},
 * {@link #CONNECTION_POLICY_FORBIDDEN}, {@link #CONNECTION_POLICY_UNKNOWN}
 *
 * @param device Paired bluetooth device
 * @param connectionPolicy is the connection policy to set to for this profile
 * @return true if connectionPolicy is set, false on error
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("setConnectionPolicy(" + device + ", " + connectionPolicy + ")");
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        if (connectionPolicy != BluetoothProfile.CONNECTION_POLICY_FORBIDDEN && connectionPolicy != BluetoothProfile.CONNECTION_POLICY_ALLOWED) {
            return false;
        }
        try {
            return service.setConnectionPolicy(device, connectionPolicy);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("setConnectionPolicy(" + device + ", " + connectionPolicy + ")");
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        if (connectionPolicy != BluetoothProfile.CONNECTION_POLICY_FORBIDDEN && connectionPolicy != BluetoothProfile.CONNECTION_POLICY_ALLOWED) {
            return false;
        }
        try {
            return service.setConnectionPolicy(device, connectionPolicy, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothA2dpSink.getConnectionState:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * {@inheritDoc}
 *
 * @hide
 */

Body of Frist Method:
{
    if (VDBG)
        log("getState(" + device + ")");
    final IBluetoothA2dpSink service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getConnectionState(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.STATE_DISCONNECTED;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return BluetoothProfile.STATE_DISCONNECTED;
}
Body of Second Method:
{
    if (VDBG)
        log("getState(" + device + ")");
    final IBluetoothA2dpSink service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getConnectionState(device, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.STATE_DISCONNECTED;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return BluetoothProfile.STATE_DISCONNECTED;
}
------------------------
Find a silently evolved API code:android.util.apk.SourceStampVerificationResult.notVerified:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Create a non-verified source stamp outcome.
 *
 * @return A non-verified source stamp result.
 */

Body of Frist Method:
{
    return new SourceStampVerificationResult(/* present= */
    true, /* verified= */
    false, /* certificate= */
    null);
}
Body of Second Method:
{
    return new SourceStampVerificationResult(/* present= */
    true, /* verified= */
    false, /* certificate= */
    null, /* certificateLineage= */
    Collections.emptyList());
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.getCurrentAgEvents:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns list of current values of AG indicators.
 *
 * @param device remote device
 * @return bundle of AG  indicators; null if device is not in CONNECTED state
 */

Body of Frist Method:
{
    if (DBG)
        log("getCurrentCalls()");
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getCurrentAgEvents(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return null;
}
Body of Second Method:
{
    if (DBG)
        log("getCurrentCalls()");
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getCurrentAgEvents(device, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return null;
}
------------------------
Find a silently evolved API code:android.location.GnssCapabilities.hasGeofencing:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns {@code true} if GNSS chipset supports geofencing, {@code false} otherwise.
 *
 * @hide
 */

Body of Frist Method:
{
    return hasCapability(GEOFENCING);
}
Body of Second Method:
{
    return (mTopFlags & TOP_HAL_CAPABILITY_GEOFENCING) != 0;
}
------------------------
Find a silently evolved API code:android.telephony.CallQuality.toString:COMMENT
Method Modifier: public      hidden      
Comment:// Parcelable things

Body of Frist Method:
{
    return "CallQuality: {downlinkCallQualityLevel=" + mDownlinkCallQualityLevel + " uplinkCallQualityLevel=" + mUplinkCallQualityLevel + " callDuration=" + mCallDuration + " numRtpPacketsTransmitted=" + mNumRtpPacketsTransmitted + " numRtpPacketsReceived=" + mNumRtpPacketsReceived + " numRtpPacketsTransmittedLost=" + mNumRtpPacketsTransmittedLost + " numRtpPacketsNotReceived=" + mNumRtpPacketsNotReceived + " averageRelativeJitter=" + mAverageRelativeJitter + " maxRelativeJitter=" + mMaxRelativeJitter + " averageRoundTripTime=" + mAverageRoundTripTime + " codecType=" + mCodecType + " rtpInactivityDetected=" + mRtpInactivityDetected + " txSilenceDetected=" + mRxSilenceDetected + " rxSilenceDetected=" + mTxSilenceDetected + "}";
}
Body of Second Method:
{
    return "CallQuality: {downlinkCallQualityLevel=" + mDownlinkCallQualityLevel + " uplinkCallQualityLevel=" + mUplinkCallQualityLevel + " callDuration=" + mCallDuration + " numRtpPacketsTransmitted=" + mNumRtpPacketsTransmitted + " numRtpPacketsReceived=" + mNumRtpPacketsReceived + " numRtpPacketsTransmittedLost=" + mNumRtpPacketsTransmittedLost + " numRtpPacketsNotReceived=" + mNumRtpPacketsNotReceived + " averageRelativeJitter=" + mAverageRelativeJitter + " maxRelativeJitter=" + mMaxRelativeJitter + " averageRoundTripTime=" + mAverageRoundTripTime + " codecType=" + mCodecType + " rtpInactivityDetected=" + mRtpInactivityDetected + " txSilenceDetected=" + mTxSilenceDetected + " rxSilenceDetected=" + mRxSilenceDetected + "}";
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothMap.getClient:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the currently connected remote Bluetooth device (PCE).
 *
 * @return The remote Bluetooth device, or null if not in connected or connecting state, or if
 * this proxy object is not connected to the Map service.
 *
 * @hide
 */

Body of Frist Method:
{
    if (VDBG)
        log("getClient()");
    final IBluetoothMap service = getService();
    if (service != null) {
        try {
            return service.getClient();
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            log(Log.getStackTraceString(new Throwable()));
    }
    return null;
}
Body of Second Method:
{
    if (VDBG)
        log("getClient()");
    final IBluetoothMap service = getService();
    if (service != null) {
        try {
            return Attributable.setAttributionSource(service.getClient(mAttributionSource), mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            log(Log.getStackTraceString(new Throwable()));
    }
    return null;
}
------------------------
Find a silently evolved API code:android.app.admin.DeviceAdminReceiver.onDisableRequested:COMMENT
Method Modifier: public      
Comment:/**
 * Called when the user has asked to disable the administrator, as a result of
 * receiving {@link #ACTION_DEVICE_ADMIN_DISABLE_REQUESTED}, giving you
 * a chance to present a warning message to them.  The message is returned
 * as the result; if null is returned (the default implementation), no
 * message will be displayed.
 * @param context The running context as per {@link #onReceive}.
 * @param intent The received intent as per {@link #onReceive}.
 * @return Return the warning message to display to the user before
 * being disabled; if null is returned, no message is displayed.
 */

Body of Frist Method:
{
    return null;
}
Body of Second Method:
{
    if (LOCAL_LOGV) {
        Log.v(TAG, getClass().getName() + ".onDisableRequested() on user " + context.getUserId());
    }
    return null;
}
------------------------
Find a silently evolved API code:android.media.soundtrigger.SoundTriggerDetector.startRecognition:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Starts recognition on the associated sound model. Result is indicated via the
 * {@link Callback}.
 * @return Indicates whether the call succeeded or not.
 */

Body of Frist Method:
{
    if (DBG) {
        Slog.d(TAG, "startRecognition()");
    }
    boolean captureTriggerAudio = (recognitionFlags & RECOGNITION_FLAG_CAPTURE_TRIGGER_AUDIO) != 0;
    boolean allowMultipleTriggers = (recognitionFlags & RECOGNITION_FLAG_ALLOW_MULTIPLE_TRIGGERS) != 0;
    int audioCapabilities = 0;
    if ((recognitionFlags & RECOGNITION_FLAG_ENABLE_AUDIO_ECHO_CANCELLATION) != 0) {
        audioCapabilities |= SoundTrigger.ModuleProperties.AUDIO_CAPABILITY_ECHO_CANCELLATION;
    }
    if ((recognitionFlags & RECOGNITION_FLAG_ENABLE_AUDIO_NOISE_SUPPRESSION) != 0) {
        audioCapabilities |= SoundTrigger.ModuleProperties.AUDIO_CAPABILITY_NOISE_SUPPRESSION;
    }
    int status;
    try {
        status = mSoundTriggerService.startRecognition(new ParcelUuid(mSoundModelId), mRecognitionCallback, new RecognitionConfig(captureTriggerAudio, allowMultipleTriggers, null, null, audioCapabilities));
    } catch (RemoteException e) {
        return false;
    }
    return status == STATUS_OK;
}
Body of Second Method:
{
    if (DBG) {
        Slog.d(TAG, "startRecognition()");
    }
    boolean captureTriggerAudio = (recognitionFlags & RECOGNITION_FLAG_CAPTURE_TRIGGER_AUDIO) != 0;
    boolean allowMultipleTriggers = (recognitionFlags & RECOGNITION_FLAG_ALLOW_MULTIPLE_TRIGGERS) != 0;
    boolean runInBatterySaver = (recognitionFlags & RECOGNITION_FLAG_RUN_IN_BATTERY_SAVER) != 0;
    int audioCapabilities = 0;
    if ((recognitionFlags & RECOGNITION_FLAG_ENABLE_AUDIO_ECHO_CANCELLATION) != 0) {
        audioCapabilities |= SoundTrigger.ModuleProperties.AUDIO_CAPABILITY_ECHO_CANCELLATION;
    }
    if ((recognitionFlags & RECOGNITION_FLAG_ENABLE_AUDIO_NOISE_SUPPRESSION) != 0) {
        audioCapabilities |= SoundTrigger.ModuleProperties.AUDIO_CAPABILITY_NOISE_SUPPRESSION;
    }
    int status;
    try {
        status = mSoundTriggerSession.startRecognition(new ParcelUuid(mSoundModelId), mRecognitionCallback, new RecognitionConfig(captureTriggerAudio, allowMultipleTriggers, null, null, audioCapabilities), runInBatterySaver);
    } catch (RemoteException e) {
        return false;
    }
    return status == STATUS_OK;
}
------------------------
Find a silently evolved API code:android.view.MotionEvent.split:COMMENT
Method Modifier: public      final       hidden      
Comment:/**
 * Splits a motion event such that it includes only a subset of pointer ids.
 * @hide
 */

Body of Frist Method:
{
    MotionEvent ev = obtain();
    synchronized (gSharedTempLock) {
        final int oldPointerCount = nativeGetPointerCount(mNativePtr);
        ensureSharedTempPointerCapacity(oldPointerCount);
        final PointerProperties[] pp = gSharedTempPointerProperties;
        final PointerCoords[] pc = gSharedTempPointerCoords;
        final int[] map = gSharedTempPointerIndexMap;
        final int oldAction = nativeGetAction(mNativePtr);
        final int oldActionMasked = oldAction & ACTION_MASK;
        final int oldActionPointerIndex = (oldAction & ACTION_POINTER_INDEX_MASK) >> ACTION_POINTER_INDEX_SHIFT;
        int newActionPointerIndex = -1;
        int newPointerCount = 0;
        for (int i = 0; i < oldPointerCount; i++) {
            nativeGetPointerProperties(mNativePtr, i, pp[newPointerCount]);
            final int idBit = 1 << pp[newPointerCount].id;
            if ((idBit & idBits) != 0) {
                if (i == oldActionPointerIndex) {
                    newActionPointerIndex = newPointerCount;
                }
                map[newPointerCount] = i;
                newPointerCount += 1;
            }
        }
        if (newPointerCount == 0) {
            throw new IllegalArgumentException("idBits did not match any ids in the event");
        }
        final int newAction;
        if (oldActionMasked == ACTION_POINTER_DOWN || oldActionMasked == ACTION_POINTER_UP) {
            if (newActionPointerIndex < 0) {
                // An unrelated pointer changed.
                newAction = ACTION_MOVE;
            } else if (newPointerCount == 1) {
                // The first/last pointer went down/up.
                newAction = oldActionMasked == ACTION_POINTER_DOWN ? ACTION_DOWN : ACTION_UP;
            } else {
                // A secondary pointer went down/up.
                newAction = oldActionMasked | (newActionPointerIndex << ACTION_POINTER_INDEX_SHIFT);
            }
        } else {
            // Simple up/down/cancel/move or other motion action.
            newAction = oldAction;
        }
        final int historySize = nativeGetHistorySize(mNativePtr);
        for (int h = 0; h <= historySize; h++) {
            final int historyPos = h == historySize ? HISTORY_CURRENT : h;
            for (int i = 0; i < newPointerCount; i++) {
                nativeGetPointerCoords(mNativePtr, map[i], historyPos, pc[i]);
            }
            final long eventTimeNanos = nativeGetEventTimeNanos(mNativePtr, historyPos);
            if (h == 0) {
                ev.initialize(nativeGetDeviceId(mNativePtr), nativeGetSource(mNativePtr), nativeGetDisplayId(mNativePtr), newAction, nativeGetFlags(mNativePtr), nativeGetEdgeFlags(mNativePtr), nativeGetMetaState(mNativePtr), nativeGetButtonState(mNativePtr), nativeGetClassification(mNativePtr), nativeGetXOffset(mNativePtr), nativeGetYOffset(mNativePtr), nativeGetXPrecision(mNativePtr), nativeGetYPrecision(mNativePtr), nativeGetDownTimeNanos(mNativePtr), eventTimeNanos, newPointerCount, pp, pc);
            } else {
                nativeAddBatch(ev.mNativePtr, eventTimeNanos, pc, 0);
            }
        }
        return ev;
    }
}
Body of Second Method:
{
    MotionEvent ev = obtain();
    synchronized (gSharedTempLock) {
        final int oldPointerCount = nativeGetPointerCount(mNativePtr);
        ensureSharedTempPointerCapacity(oldPointerCount);
        final PointerProperties[] pp = gSharedTempPointerProperties;
        final PointerCoords[] pc = gSharedTempPointerCoords;
        final int[] map = gSharedTempPointerIndexMap;
        final int oldAction = nativeGetAction(mNativePtr);
        final int oldActionMasked = oldAction & ACTION_MASK;
        final int oldActionPointerIndex = (oldAction & ACTION_POINTER_INDEX_MASK) >> ACTION_POINTER_INDEX_SHIFT;
        int newActionPointerIndex = -1;
        int newPointerCount = 0;
        for (int i = 0; i < oldPointerCount; i++) {
            nativeGetPointerProperties(mNativePtr, i, pp[newPointerCount]);
            final int idBit = 1 << pp[newPointerCount].id;
            if ((idBit & idBits) != 0) {
                if (i == oldActionPointerIndex) {
                    newActionPointerIndex = newPointerCount;
                }
                map[newPointerCount] = i;
                newPointerCount += 1;
            }
        }
        if (newPointerCount == 0) {
            throw new IllegalArgumentException("idBits did not match any ids in the event");
        }
        final int newAction;
        if (oldActionMasked == ACTION_POINTER_DOWN || oldActionMasked == ACTION_POINTER_UP) {
            if (newActionPointerIndex < 0) {
                // An unrelated pointer changed.
                newAction = ACTION_MOVE;
            } else if (newPointerCount == 1) {
                // The first/last pointer went down/up.
                newAction = oldActionMasked == ACTION_POINTER_DOWN ? ACTION_DOWN : (getFlags() & FLAG_CANCELED) == 0 ? ACTION_UP : ACTION_CANCEL;
            } else {
                // A secondary pointer went down/up.
                newAction = oldActionMasked | (newActionPointerIndex << ACTION_POINTER_INDEX_SHIFT);
            }
        } else {
            // Simple up/down/cancel/move or other motion action.
            newAction = oldAction;
        }
        final int historySize = nativeGetHistorySize(mNativePtr);
        for (int h = 0; h <= historySize; h++) {
            final int historyPos = h == historySize ? HISTORY_CURRENT : h;
            for (int i = 0; i < newPointerCount; i++) {
                nativeGetPointerCoords(mNativePtr, map[i], historyPos, pc[i]);
            }
            final long eventTimeNanos = nativeGetEventTimeNanos(mNativePtr, historyPos);
            if (h == 0) {
                ev.initialize(nativeGetDeviceId(mNativePtr), nativeGetSource(mNativePtr), nativeGetDisplayId(mNativePtr), newAction, nativeGetFlags(mNativePtr), nativeGetEdgeFlags(mNativePtr), nativeGetMetaState(mNativePtr), nativeGetButtonState(mNativePtr), nativeGetClassification(mNativePtr), nativeGetXOffset(mNativePtr), nativeGetYOffset(mNativePtr), nativeGetXPrecision(mNativePtr), nativeGetYPrecision(mNativePtr), nativeGetDownTimeNanos(mNativePtr), eventTimeNanos, newPointerCount, pp, pc);
            } else {
                nativeAddBatch(ev.mNativePtr, eventTimeNanos, pc, 0);
            }
        }
        return ev;
    }
}
------------------------
Find a silently evolved API code:android.media.tv.tuner.frontend.FrontendStatus.isLnaOn:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Checks LNA (Low Noise Amplifier) is on or not.
 */

Body of Frist Method:
{
    if (mIsLnaOn == null) {
        throw new IllegalStateException();
    }
    return mIsLnaOn;
}
Body of Second Method:
{
    if (mIsLnaOn == null) {
        throw new IllegalStateException("LnaOn status is empty");
    }
    return mIsLnaOn;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothPbap.disconnect:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Disconnects the current Pbap client (PCE). Currently this call blocks,
 * it may soon be made asynchronous. Returns false if this proxy object is
 * not currently connected to the Pbap service.
 *
 * @hide
 */

Body of Frist Method:
{
    log("disconnect()");
    final IBluetoothPbap service = mService;
    if (service == null) {
        Log.w(TAG, "Proxy not attached to service");
        return false;
    }
    try {
        service.disconnect(device);
        return true;
    } catch (RemoteException e) {
        Log.e(TAG, e.toString());
    }
    return false;
}
Body of Second Method:
{
    log("disconnect()");
    final IBluetoothPbap service = mService;
    if (service == null) {
        Log.w(TAG, "Proxy not attached to service");
        return false;
    }
    try {
        service.disconnect(device, mAttributionSource);
        return true;
    } catch (RemoteException e) {
        Log.e(TAG, e.toString());
    }
    return false;
}
------------------------
Find a silently evolved API code:android.app.admin.DeviceAdminInfo.readPoliciesFromXml:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    mUsesPolicies = Integer.parseInt(parser.getAttributeValue(null, "flags"));
}
Body of Second Method:
{
    mUsesPolicies = parser.getAttributeInt(null, "flags");
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothSap.getClient:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the currently connected remote Bluetooth device (PCE).
 *
 * @return The remote Bluetooth device, or null if not in connected or connecting state, or if
 * this proxy object is not connected to the Sap service.
 * @hide
 */

Body of Frist Method:
{
    if (VDBG)
        log("getClient()");
    final IBluetoothSap service = getService();
    if (service != null) {
        try {
            return service.getClient();
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            log(Log.getStackTraceString(new Throwable()));
    }
    return null;
}
Body of Second Method:
{
    if (VDBG)
        log("getClient()");
    final IBluetoothSap service = getService();
    if (service != null) {
        try {
            return Attributable.setAttributionSource(service.getClient(mAttributionSource), mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            log(Log.getStackTraceString(new Throwable()));
    }
    return null;
}
------------------------
Find a silently evolved API code:android.content.pm.ShortcutManager.addDynamicShortcuts:COMMENT
Method Modifier: public      
Comment:/**
 * Publish the list of dynamic shortcuts.  If there are already dynamic or pinned shortcuts with
 * the same IDs, each mutable shortcut is updated.
 *
 * <p>This API will be rate-limited.
 *
 * @return {@code true} if the call has succeeded. {@code false} if the call is rate-limited.
 *
 * @throws IllegalArgumentException if {@link #getMaxShortcutCountPerActivity()} is exceeded,
 * or when trying to update immutable shortcuts.
 *
 * @throws IllegalStateException when the user is locked.
 */

Body of Frist Method:
{
    try {
        return mService.addDynamicShortcuts(mContext.getPackageName(), new ParceledListSlice(shortcutInfoList), injectMyUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    try {
        return (boolean) getFutureOrThrow(mService.addDynamicShortcuts(mContext.getPackageName(), new ParceledListSlice(shortcutInfoList), injectMyUserId()));
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.hardware.lights.Light.writeToParcel:COMMENT
<android.hardware.lights.Light: void writeToParcel(Parcel,int)>
public      hidden      ->public      
Method Modifier: public      hidden      
Method Modifier: Yes         Yes         
Method Updated:  Yes         No          
Comment:/**
 * Implement the Parcelable interface
 */

Body of Frist Method:
{
    dest.writeInt(mId);
    dest.writeInt(mOrdinal);
    dest.writeInt(mType);
}
Body of Second Method:
{
    dest.writeInt(mId);
    dest.writeString(mName);
    dest.writeInt(mOrdinal);
    dest.writeInt(mType);
    dest.writeInt(mCapabilities);
}
------------------------
Find a silently evolved API code:android.content.IntentSender.getCreatorPackage:COMMENT
Method Modifier: public      
Comment:/**
 * Return the package name of the application that created this
 * IntentSender, that is the identity under which you will actually be
 * sending the Intent.  The returned string is supplied by the system, so
 * that an application can not spoof its package.
 *
 * @return The package name of the PendingIntent, or null if there is
 * none associated with it.
 */

Body of Frist Method:
{
    try {
        return ActivityManager.getService().getPackageForIntentSender(mTarget);
    } catch (RemoteException e) {
        // Should never happen.
        return null;
    }
}
Body of Second Method:
{
    return getCachedInfo().getCreatorPackage();
}
------------------------
Find a silently evolved API code:android.hardware.camera2.utils.SurfaceUtils.getSurfaceSize:COMMENT
Method Modifier: public      static      
Comment:/**
 * Get the Surface size.
 *
 * @param surface The surface to be queried for size.
 * @return Size of the surface.
 *
 * @throws IllegalArgumentException if the surface is already abandoned.
 */

Body of Frist Method:
{
    try {
        return LegacyCameraDevice.getSurfaceSize(surface);
    } catch (BufferQueueAbandonedException e) {
        throw new IllegalArgumentException("Surface was abandoned", e);
    }
}
Body of Second Method:
{
    checkNotNull(surface);
    int[] dimens = new int[2];
    int errorFlag = nativeDetectSurfaceDimens(surface, /*out*/
    dimens);
    if (errorFlag == BAD_VALUE)
        throw new IllegalArgumentException("Surface was abandoned");
    return new Size(dimens[0], dimens[1]);
}
------------------------
Find a silently evolved API code:android.ddm.DdmHandleNativeHeap.handleChunk:COMMENT
Method Modifier: public      
Comment:/**
 * Handle a chunk of data.
 */

Body of Frist Method:
{
    Log.i("ddm-nativeheap", "Handling " + name(request.type) + " chunk");
    int type = request.type;
    if (type == CHUNK_NHGT) {
        return handleNHGT(request);
    } else {
        throw new RuntimeException("Unknown packet " + ChunkHandler.name(type));
    }
}
Body of Second Method:
{
    Log.i("ddm-nativeheap", "Handling " + name(request.type) + " chunk");
    int type = request.type;
    if (type == CHUNK_NHGT) {
        return handleNHGT(request);
    } else {
        throw new RuntimeException("Unknown packet " + name(type));
    }
}
------------------------
Find a silently evolved API code:android.text.style.SuggestionSpan.getUnderlineColor:COMMENT
Method Modifier: public      
Comment:/**
 * @return The color of the underline for that span, or 0 if there is no underline
 */

Body of Frist Method:
{
    // The order here should match what is used in updateDrawState
    final boolean misspelled = (mFlags & FLAG_MISSPELLED) != 0;
    final boolean easy = (mFlags & FLAG_EASY_CORRECT) != 0;
    final boolean autoCorrection = (mFlags & FLAG_AUTO_CORRECTION) != 0;
    if (easy) {
        if (!misspelled) {
            return mEasyCorrectUnderlineColor;
        } else {
            return mMisspelledUnderlineColor;
        }
    } else if (autoCorrection) {
        return mAutoCorrectionUnderlineColor;
    }
    return 0;
}
Body of Second Method:
{
    // The order here should match what is used in updateDrawState
    final boolean misspelled = (mFlags & FLAG_MISSPELLED) != 0;
    final boolean easy = (mFlags & FLAG_EASY_CORRECT) != 0;
    final boolean autoCorrection = (mFlags & FLAG_AUTO_CORRECTION) != 0;
    final boolean grammarError = (mFlags & FLAG_GRAMMAR_ERROR) != 0;
    if (easy) {
        if (grammarError) {
            return mGrammarErrorUnderlineColor;
        } else if (misspelled) {
            return mMisspelledUnderlineColor;
        } else {
            return mEasyCorrectUnderlineColor;
        }
    } else if (autoCorrection) {
        return mAutoCorrectionUnderlineColor;
    } else if (misspelled) {
        return mMisspelledUnderlineColor;
    } else if (grammarError) {
        return mGrammarErrorUnderlineColor;
    }
    return 0;
}
------------------------
Find a silently evolved API code:android.content.PermissionChecker.checkSelfPermissionForDataDelivery:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Checks whether your app has a given permission and whether the app op
 * that corresponds to this permission is allowed.
 *
 * <strong>NOTE:</strong> Use this method only for permission checks at the
 * point where you will deliver the permission protected data to clients.
 *
 * <p>For example, if an app registers a location listener it should have the location
 * permission but no data is actually sent to the app at the moment of registration
 * and you should use {@link #checkSelfPermissionForPreflight(Context, String)}
 * to determine if the app has or may have location permission (if app has only foreground
 * location the grant state depends on the app's fg/gb state) and this check will not
 * leave a trace that permission protected data was delivered. When you are about to
 * deliver the location data to a registered listener you should use this method
 * which will evaluate the permission access based on the current fg/bg state of the
 * app and leave a record that the data was accessed.
 *
 * <p>This API assumes the the {@link Binder#getCallingUid()} is the same as
 * {@link Process#myUid()}.
 *
 * @param context Context for accessing resources.
 * @param permission The permission to check.
 * @return The permission check result which is either {@link #PERMISSION_GRANTED}
 * or {@link #PERMISSION_SOFT_DENIED} or {@link #PERMISSION_HARD_DENIED}.
 * @param message A message describing the reason the permission was checked
 *
 * @see #checkSelfPermissionForPreflight(Context, String)
 */

Body of Frist Method:
{
    return checkPermissionForDataDelivery(context, permission, Process.myPid(), Process.myUid(), context.getPackageName(), context.getAttributionTag(), message);
}
Body of Second Method:
{
    return checkPermissionForDataDelivery(context, permission, Process.myPid(), Process.myUid(), context.getPackageName(), context.getAttributionTag(), message, /*startDataDelivery*/
    false);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadset.isInbandRingingEnabled:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Check if in-band ringing is currently enabled. In-band ringing could be disabled during an
 * active connection.
 *
 * @return true if in-band ringing is enabled, false if in-band ringing is disabled
 * @hide
 */

Body of Frist Method:
{
    if (DBG) {
        log("isInbandRingingEnabled()");
    }
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.isInbandRingingEnabled();
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null) {
        Log.w(TAG, "Proxy not attached to service");
    }
    return false;
}
Body of Second Method:
{
    if (DBG) {
        log("isInbandRingingEnabled()");
    }
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.isInbandRingingEnabled(mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null) {
        Log.w(TAG, "Proxy not attached to service");
    }
    return false;
}
------------------------
Find a silently evolved API code:android.app.admin.SecurityLog.SecurityEvent.getLogLevel:COMMENT
Method Modifier: public      
Comment:/**
 * Returns severity level for the event.
 */

Body of Frist Method:
{
    switch(getTag()) {
        case TAG_ADB_SHELL_INTERACTIVE:
        case TAG_ADB_SHELL_CMD:
        case TAG_SYNC_RECV_FILE:
        case TAG_SYNC_SEND_FILE:
        case TAG_APP_PROCESS_START:
        case TAG_KEYGUARD_DISMISSED:
        case TAG_KEYGUARD_SECURED:
        case TAG_OS_STARTUP:
        case TAG_OS_SHUTDOWN:
        case TAG_LOGGING_STARTED:
        case TAG_LOGGING_STOPPED:
        case TAG_MEDIA_MOUNT:
        case TAG_MEDIA_UNMOUNT:
        case TAG_PASSWORD_EXPIRATION_SET:
        case TAG_PASSWORD_COMPLEXITY_SET:
        case TAG_PASSWORD_HISTORY_LENGTH_SET:
        case TAG_MAX_SCREEN_LOCK_TIMEOUT_SET:
        case TAG_MAX_PASSWORD_ATTEMPTS_SET:
        case TAG_USER_RESTRICTION_ADDED:
        case TAG_USER_RESTRICTION_REMOVED:
        case TAG_CAMERA_POLICY_SET:
            return LEVEL_INFO;
        case TAG_CERT_AUTHORITY_REMOVED:
        case TAG_CRYPTO_SELF_TEST_COMPLETED:
            return getSuccess() ? LEVEL_INFO : LEVEL_ERROR;
        case TAG_CERT_AUTHORITY_INSTALLED:
        case TAG_KEYGUARD_DISMISS_AUTH_ATTEMPT:
        case TAG_KEY_IMPORT:
        case TAG_KEY_DESTRUCTION:
        case TAG_KEY_GENERATED:
            return getSuccess() ? LEVEL_INFO : LEVEL_WARNING;
        case TAG_LOG_BUFFER_SIZE_CRITICAL:
        case TAG_WIPE_FAILURE:
        case TAG_KEY_INTEGRITY_VIOLATION:
            return LEVEL_ERROR;
        case TAG_CERT_VALIDATION_FAILURE:
            return LEVEL_WARNING;
        default:
            return LEVEL_INFO;
    }
}
Body of Second Method:
{
    switch(getTag()) {
        case TAG_ADB_SHELL_INTERACTIVE:
        case TAG_ADB_SHELL_CMD:
        case TAG_SYNC_RECV_FILE:
        case TAG_SYNC_SEND_FILE:
        case TAG_APP_PROCESS_START:
        case TAG_KEYGUARD_DISMISSED:
        case TAG_KEYGUARD_SECURED:
        case TAG_OS_STARTUP:
        case TAG_OS_SHUTDOWN:
        case TAG_LOGGING_STARTED:
        case TAG_LOGGING_STOPPED:
        case TAG_MEDIA_MOUNT:
        case TAG_MEDIA_UNMOUNT:
        case TAG_PASSWORD_EXPIRATION_SET:
        case TAG_PASSWORD_COMPLEXITY_SET:
        case TAG_PASSWORD_HISTORY_LENGTH_SET:
        case TAG_MAX_SCREEN_LOCK_TIMEOUT_SET:
        case TAG_MAX_PASSWORD_ATTEMPTS_SET:
        case TAG_USER_RESTRICTION_ADDED:
        case TAG_USER_RESTRICTION_REMOVED:
        case TAG_CAMERA_POLICY_SET:
        case TAG_PASSWORD_COMPLEXITY_REQUIRED:
            return LEVEL_INFO;
        case TAG_CERT_AUTHORITY_REMOVED:
        case TAG_CRYPTO_SELF_TEST_COMPLETED:
            return getSuccess() ? LEVEL_INFO : LEVEL_ERROR;
        case TAG_CERT_AUTHORITY_INSTALLED:
        case TAG_KEYGUARD_DISMISS_AUTH_ATTEMPT:
        case TAG_KEY_IMPORT:
        case TAG_KEY_DESTRUCTION:
        case TAG_KEY_GENERATED:
            return getSuccess() ? LEVEL_INFO : LEVEL_WARNING;
        case TAG_LOG_BUFFER_SIZE_CRITICAL:
        case TAG_WIPE_FAILURE:
        case TAG_KEY_INTEGRITY_VIOLATION:
            return LEVEL_ERROR;
        case TAG_CERT_VALIDATION_FAILURE:
            return LEVEL_WARNING;
        default:
            return LEVEL_INFO;
    }
}
------------------------
Find a silently evolved API code:android.security.ConfirmationPrompt.presentPrompt:COMMENT
Method Modifier: public      
Comment:/**
 * Requests a confirmation prompt to be presented to the user.
 *
 * When the prompt is no longer being presented, one of the methods in
 * {@link ConfirmationCallback} is called on the supplied callback object.
 *
 * Confirmation prompts may not be available when accessibility services are running so this
 * may fail with a {@link ConfirmationNotAvailableException} exception even if
 * {@link #isSupported} returns {@code true}.
 *
 * @param executor the executor identifying the thread that will receive the callback.
 * @param callback the callback to use when the prompt is done showing.
 * @throws IllegalArgumentException if the prompt text is too long or malfomed.
 * @throws ConfirmationAlreadyPresentingException if another prompt is being presented.
 * @throws ConfirmationNotAvailableException if confirmation prompts are not supported.
 */

Body of Frist Method:
{
    if (mCallback != null) {
        throw new ConfirmationAlreadyPresentingException();
    }
    if (isAccessibilityServiceRunning(mContext)) {
        throw new ConfirmationNotAvailableException();
    }
    mCallback = callback;
    mExecutor = executor;
    int uiOptionsAsFlags = getUiOptionsAsFlags();
    String locale = Locale.getDefault().toLanguageTag();
    int responseCode = mKeyStore.presentConfirmationPrompt(mCallbackBinder, mPromptText.toString(), mExtraData, locale, uiOptionsAsFlags);
    switch(responseCode) {
        case KeyStore.CONFIRMATIONUI_OK:
            return;
        case KeyStore.CONFIRMATIONUI_OPERATION_PENDING:
            throw new ConfirmationAlreadyPresentingException();
        case KeyStore.CONFIRMATIONUI_UNIMPLEMENTED:
            throw new ConfirmationNotAvailableException();
        case KeyStore.CONFIRMATIONUI_UIERROR:
            throw new IllegalArgumentException();
        default:
            // Unexpected error code.
            Log.w(TAG, "Unexpected responseCode=" + responseCode + " from presentConfirmationPrompt() call.");
            throw new IllegalArgumentException();
    }
}
Body of Second Method:
{
    if (mCallback != null) {
        throw new ConfirmationAlreadyPresentingException();
    }
    if (isAccessibilityServiceRunning(mContext)) {
        throw new ConfirmationNotAvailableException();
    }
    mCallback = callback;
    mExecutor = executor;
    String locale = Locale.getDefault().toLanguageTag();
    int uiOptionsAsFlags = getUiOptionsAsFlags();
    int responseCode = getService().presentConfirmationPrompt(mConfirmationCallback, mPromptText.toString(), mExtraData, locale, uiOptionsAsFlags);
    switch(responseCode) {
        case AndroidProtectedConfirmation.ERROR_OK:
            return;
        case AndroidProtectedConfirmation.ERROR_OPERATION_PENDING:
            throw new ConfirmationAlreadyPresentingException();
        case AndroidProtectedConfirmation.ERROR_UNIMPLEMENTED:
            throw new ConfirmationNotAvailableException();
        default:
            // Unexpected error code.
            Log.w(TAG, "Unexpected responseCode=" + responseCode + " from presentConfirmationPrompt() call.");
            throw new IllegalArgumentException();
    }
}
------------------------
Find a silently evolved API code:android.location.GnssMeasurement.set:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets all contents to the values stored in the provided object.
 * @hide
 */

Body of Frist Method:
{
    mFlags = measurement.mFlags;
    mSvid = measurement.mSvid;
    mConstellationType = measurement.mConstellationType;
    mTimeOffsetNanos = measurement.mTimeOffsetNanos;
    mState = measurement.mState;
    mReceivedSvTimeNanos = measurement.mReceivedSvTimeNanos;
    mReceivedSvTimeUncertaintyNanos = measurement.mReceivedSvTimeUncertaintyNanos;
    mCn0DbHz = measurement.mCn0DbHz;
    mBasebandCn0DbHz = measurement.mBasebandCn0DbHz;
    mPseudorangeRateMetersPerSecond = measurement.mPseudorangeRateMetersPerSecond;
    mPseudorangeRateUncertaintyMetersPerSecond = measurement.mPseudorangeRateUncertaintyMetersPerSecond;
    mAccumulatedDeltaRangeState = measurement.mAccumulatedDeltaRangeState;
    mAccumulatedDeltaRangeMeters = measurement.mAccumulatedDeltaRangeMeters;
    mAccumulatedDeltaRangeUncertaintyMeters = measurement.mAccumulatedDeltaRangeUncertaintyMeters;
    mCarrierFrequencyHz = measurement.mCarrierFrequencyHz;
    mCarrierCycles = measurement.mCarrierCycles;
    mCarrierPhase = measurement.mCarrierPhase;
    mCarrierPhaseUncertainty = measurement.mCarrierPhaseUncertainty;
    mMultipathIndicator = measurement.mMultipathIndicator;
    mSnrInDb = measurement.mSnrInDb;
    mAutomaticGainControlLevelInDb = measurement.mAutomaticGainControlLevelInDb;
    mCodeType = measurement.mCodeType;
    mFullInterSignalBiasNanos = measurement.mFullInterSignalBiasNanos;
    mFullInterSignalBiasUncertaintyNanos = measurement.mFullInterSignalBiasUncertaintyNanos;
    mSatelliteInterSignalBiasNanos = measurement.mSatelliteInterSignalBiasNanos;
    mSatelliteInterSignalBiasUncertaintyNanos = measurement.mSatelliteInterSignalBiasUncertaintyNanos;
}
Body of Second Method:
{
    mFlags = measurement.mFlags;
    mSvid = measurement.mSvid;
    mConstellationType = measurement.mConstellationType;
    mTimeOffsetNanos = measurement.mTimeOffsetNanos;
    mState = measurement.mState;
    mReceivedSvTimeNanos = measurement.mReceivedSvTimeNanos;
    mReceivedSvTimeUncertaintyNanos = measurement.mReceivedSvTimeUncertaintyNanos;
    mCn0DbHz = measurement.mCn0DbHz;
    mBasebandCn0DbHz = measurement.mBasebandCn0DbHz;
    mPseudorangeRateMetersPerSecond = measurement.mPseudorangeRateMetersPerSecond;
    mPseudorangeRateUncertaintyMetersPerSecond = measurement.mPseudorangeRateUncertaintyMetersPerSecond;
    mAccumulatedDeltaRangeState = measurement.mAccumulatedDeltaRangeState;
    mAccumulatedDeltaRangeMeters = measurement.mAccumulatedDeltaRangeMeters;
    mAccumulatedDeltaRangeUncertaintyMeters = measurement.mAccumulatedDeltaRangeUncertaintyMeters;
    mCarrierFrequencyHz = measurement.mCarrierFrequencyHz;
    mCarrierCycles = measurement.mCarrierCycles;
    mCarrierPhase = measurement.mCarrierPhase;
    mCarrierPhaseUncertainty = measurement.mCarrierPhaseUncertainty;
    mMultipathIndicator = measurement.mMultipathIndicator;
    mSnrInDb = measurement.mSnrInDb;
    mAutomaticGainControlLevelInDb = measurement.mAutomaticGainControlLevelInDb;
    mCodeType = measurement.mCodeType;
    mFullInterSignalBiasNanos = measurement.mFullInterSignalBiasNanos;
    mFullInterSignalBiasUncertaintyNanos = measurement.mFullInterSignalBiasUncertaintyNanos;
    mSatelliteInterSignalBiasNanos = measurement.mSatelliteInterSignalBiasNanos;
    mSatelliteInterSignalBiasUncertaintyNanos = measurement.mSatelliteInterSignalBiasUncertaintyNanos;
    mSatellitePvt = measurement.mSatellitePvt;
    mReadOnlyCorrelationVectors = measurement.mReadOnlyCorrelationVectors;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothA2dpSink.disconnect:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Initiate disconnection from a profile
 *
 * <p> This API will return false in scenarios like the profile on the
 * Bluetooth device is not in connected state etc. When this API returns,
 * true, it is guaranteed that the connection state change
 * intent will be broadcasted with the state. Users can get the
 * disconnection state of the profile from this intent.
 *
 * <p> If the disconnection is initiated by a remote device, the state
 * will transition from {@link #STATE_CONNECTED} to
 * {@link #STATE_DISCONNECTED}. If the disconnect is initiated by the
 * host (local) device the state will transition from
 * {@link #STATE_CONNECTED} to state {@link #STATE_DISCONNECTING} to
 * state {@link #STATE_DISCONNECTED}. The transition to
 * {@link #STATE_DISCONNECTING} can be used to distinguish between the
 * two scenarios.
 *
 * @param device Remote Bluetooth Device
 * @return false on immediate error, true otherwise
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("disconnect(" + device + ")");
    final IBluetoothA2dpSink service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.disconnect(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("disconnect(" + device + ")");
    final IBluetoothA2dpSink service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.disconnect(device, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.view.DisplayEventReceiver.dispatchVsync:COMMENT
Method Modifier: private     hidden      
Comment:// Called from native code.

Body of Frist Method:
{
    onVsync(timestampNanos, physicalDisplayId, frame);
}
Body of Second Method:
{
    onVsync(timestampNanos, physicalDisplayId, frame, new VsyncEventData(frameTimelineVsyncId, frameDeadline, frameInterval));
}
------------------------
Find a silently evolved API code:android.os.Debug.enableEmulatorTraceOutput:COMMENT
Method Modifier: public      static      
Comment:/**
 * Enable "emulator traces", in which information about the current
 * method is made available to the "emulator -trace" feature.  There
 * is no corresponding "disable" call -- this is intended for use by
 * the framework when tracing should be turned on and left that way, so
 * that traces captured with F9/F10 will include the necessary data.
 *
 * This puts the VM into "profile" mode, which has performance
 * consequences.
 *
 * To temporarily enable tracing, use {@link #startNativeTracing()}.
 */

Body of Frist Method:
{
    VMDebug.startEmulatorTracing();
}
Body of Second Method:
{
    Log.w(TAG, "Unimplemented");
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothCodecConfig.sameCodecSpecificParameters:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Checks whether the codec specific parameters are the same.
 *
 * @param other the codec config to compare against
 * @return true if the codec specific parameters are the same, otherwise false.
 * @hide
 */

Body of Frist Method:
{
    if (other == null && mCodecType != other.mCodecType) {
        return false;
    }
    // Currently we only care about the LDAC Playback Quality at CodecSpecific1
    switch(mCodecType) {
        case SOURCE_CODEC_TYPE_LDAC:
            if (mCodecSpecific1 != other.mCodecSpecific1) {
                return false;
            }
        // fall through
        default:
            return true;
    }
}
Body of Second Method:
{
    if (other == null && mCodecType != other.mCodecType) {
        return false;
    }
    // Currently we only care about the AAC VBR and LDAC Playback Quality at CodecSpecific1
    switch(mCodecType) {
        case SOURCE_CODEC_TYPE_AAC:
        case SOURCE_CODEC_TYPE_LDAC:
            if (mCodecSpecific1 != other.mCodecSpecific1) {
                return false;
            }
        // fall through
        default:
            return true;
    }
}
------------------------
Find a silently evolved API code:android.app.ApplicationExitInfo.dump:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    pw.println(prefix + "ApplicationExitInfo " + seqSuffix + ":");
    pw.println(prefix + "  timestamp=" + sdf.format(new Date(mTimestamp)));
    pw.println(prefix + "  pid=" + mPid);
    pw.println(prefix + "  realUid=" + mRealUid);
    pw.println(prefix + "  packageUid=" + mPackageUid);
    pw.println(prefix + "  definingUid=" + mDefiningUid);
    pw.println(prefix + "  user=" + UserHandle.getUserId(mPackageUid));
    pw.println(prefix + "  process=" + mProcessName);
    pw.println(prefix + "  reason=" + mReason + " (" + reasonCodeToString(mReason) + ")");
    pw.println(prefix + "  status=" + mStatus);
    pw.println(prefix + "  importance=" + mImportance);
    pw.print(prefix + "  pss=");
    DebugUtils.printSizeValue(pw, mPss << 10);
    pw.println();
    pw.print(prefix + "  rss=");
    DebugUtils.printSizeValue(pw, mRss << 10);
    pw.println();
    pw.println(prefix + "  description=" + mDescription);
    pw.println(prefix + "  state=" + (ArrayUtils.isEmpty(mState) ? "empty" : Integer.toString(mState.length) + " bytes"));
    pw.println(prefix + "  trace=" + mTraceFile);
}
Body of Second Method:
{
    pw.println(prefix + "ApplicationExitInfo " + seqSuffix + ":");
    pw.println(prefix + "  timestamp=" + sdf.format(new Date(mTimestamp)));
    pw.println(prefix + "  pid=" + mPid);
    pw.println(prefix + "  realUid=" + mRealUid);
    pw.println(prefix + "  packageUid=" + mPackageUid);
    pw.println(prefix + "  definingUid=" + mDefiningUid);
    pw.println(prefix + "  user=" + UserHandle.getUserId(mPackageUid));
    pw.println(prefix + "  process=" + mProcessName);
    pw.println(prefix + "  reason=" + mReason + " (" + reasonCodeToString(mReason) + ")");
    pw.println(prefix + "  subreason=" + mSubReason + " (" + subreasonToString(mSubReason) + ")");
    pw.println(prefix + "  status=" + mStatus);
    pw.println(prefix + "  importance=" + mImportance);
    pw.print(prefix + "  pss=");
    DebugUtils.printSizeValue(pw, mPss << 10);
    pw.println();
    pw.print(prefix + "  rss=");
    DebugUtils.printSizeValue(pw, mRss << 10);
    pw.println();
    pw.println(prefix + "  description=" + mDescription);
    pw.println(prefix + "  state=" + (ArrayUtils.isEmpty(mState) ? "empty" : Integer.toString(mState.length) + " bytes"));
    pw.println(prefix + "  trace=" + mTraceFile);
}
------------------------
Find a silently evolved API code:android.widget.EdgeEffect.onPull:COMMENT
Method Modifier: public      
Comment:/**
 * A view should call this when content is pulled away from an edge by the user.
 * This will update the state of the current visual effect and its associated animation.
 * The host view should always {@link android.view.View#invalidate()} after this
 * and draw the results accordingly.
 *
 * @param deltaDistance Change in distance since the last call. Values may be 0 (no change) to
 * 1.f (full length of the view) or negative values to express change
 * back toward the edge reached to initiate the effect.
 * @param displacement The displacement from the starting side of the effect of the point
 * initiating the pull. In the case of touch this is the finger position.
 * Values may be from 0-1.
 */

Body of Frist Method:
{
    final long now = AnimationUtils.currentAnimationTimeMillis();
    mTargetDisplacement = displacement;
    if (mState == STATE_PULL_DECAY && now - mStartTime < mDuration) {
        return;
    }
    if (mState != STATE_PULL) {
        mGlowScaleY = Math.max(PULL_GLOW_BEGIN, mGlowScaleY);
    }
    mState = STATE_PULL;
    mStartTime = now;
    mDuration = PULL_TIME;
    mPullDistance += deltaDistance;
    final float absdd = Math.abs(deltaDistance);
    mGlowAlpha = mGlowAlphaStart = Math.min(MAX_ALPHA, mGlowAlpha + (absdd * PULL_DISTANCE_ALPHA_GLOW_FACTOR));
    if (mPullDistance == 0) {
        mGlowScaleY = mGlowScaleYStart = 0;
    } else {
        final float scale = (float) (Math.max(0, 1 - 1 / Math.sqrt(Math.abs(mPullDistance) * mBounds.height()) - 0.3d) / 0.7d);
        mGlowScaleY = mGlowScaleYStart = scale;
    }
    mGlowAlphaFinish = mGlowAlpha;
    mGlowScaleYFinish = mGlowScaleY;
}
Body of Second Method:
{
    int edgeEffectBehavior = getCurrentEdgeEffectBehavior();
    if (edgeEffectBehavior == TYPE_NONE) {
        finish();
        return;
    }
    final long now = AnimationUtils.currentAnimationTimeMillis();
    mTargetDisplacement = displacement;
    if (mState == STATE_PULL_DECAY && now - mStartTime < mDuration && edgeEffectBehavior == TYPE_GLOW) {
        return;
    }
    if (mState != STATE_PULL) {
        if (edgeEffectBehavior == TYPE_STRETCH) {
            // Restore the mPullDistance to the fraction it is currently showing -- we want
            // to "catch" the current stretch value.
            mPullDistance = mDistance;
        } else {
            mGlowScaleY = Math.max(PULL_GLOW_BEGIN, mGlowScaleY);
        }
    }
    mState = STATE_PULL;
    mStartTime = now;
    mDuration = PULL_TIME;
    mPullDistance += deltaDistance;
    if (edgeEffectBehavior == TYPE_STRETCH) {
        // Don't allow stretch beyond 1
        mPullDistance = Math.min(1f, mPullDistance);
    }
    mDistance = Math.max(0f, mPullDistance);
    mVelocity = 0;
    if (mPullDistance == 0) {
        mGlowScaleY = mGlowScaleYStart = 0;
        mGlowAlpha = mGlowAlphaStart = 0;
    } else {
        final float absdd = Math.abs(deltaDistance);
        mGlowAlpha = mGlowAlphaStart = Math.min(MAX_ALPHA, mGlowAlpha + (absdd * PULL_DISTANCE_ALPHA_GLOW_FACTOR));
        final float scale = (float) (Math.max(0, 1 - 1 / Math.sqrt(Math.abs(mPullDistance) * mBounds.height()) - 0.3d) / 0.7d);
        mGlowScaleY = mGlowScaleYStart = scale;
    }
    mGlowAlphaFinish = mGlowAlpha;
    mGlowScaleYFinish = mGlowScaleY;
    if (edgeEffectBehavior == TYPE_STRETCH && mDistance == 0) {
        mState = STATE_IDLE;
    }
}
------------------------
Find a silently evolved API code:android.view.inputmethod.InlineSuggestionInfo.newInlineSuggestionInfo:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Creates a new {@link InlineSuggestionInfo}, for testing purpose.
 *
 * @hide
 */

Body of Frist Method:
{
    return new InlineSuggestionInfo(presentationSpec, source, autofillHints, type, isPinned);
}
Body of Second Method:
{
    return new InlineSuggestionInfo(presentationSpec, source, autofillHints, type, isPinned, null);
}
------------------------
Find a silently evolved API code:android.graphics.drawable.Icon.convertToAshmem:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Puts the memory used by this instance into Ashmem memory, if possible.
 * @hide
 */

Body of Frist Method:
{
    if ((mType == TYPE_BITMAP || mType == TYPE_ADAPTIVE_BITMAP) && getBitmap().isMutable() && getBitmap().getAllocationByteCount() >= MIN_ASHMEM_ICON_SIZE) {
        setBitmap(getBitmap().createAshmemBitmap());
    }
}
Body of Second Method:
{
    if ((mType == TYPE_BITMAP || mType == TYPE_ADAPTIVE_BITMAP) && getBitmap().isMutable() && getBitmap().getAllocationByteCount() >= MIN_ASHMEM_ICON_SIZE) {
        setBitmap(getBitmap().asShared());
    }
}
------------------------
Find a silently evolved API code:android.app.admin.DelegatedAdminReceiver.onReceive:COMMENT
Method Modifier: public      final       
Comment:/**
 * Intercept delegated device administrator broadcasts. Implementations should not override
 * this method; implement the convenience callbacks for each action instead.
 */

Body of Frist Method:
{
    String action = intent.getAction();
    if (ACTION_CHOOSE_PRIVATE_KEY_ALIAS.equals(action)) {
        int uid = intent.getIntExtra(EXTRA_CHOOSE_PRIVATE_KEY_SENDER_UID, -1);
        Uri uri = intent.getParcelableExtra(EXTRA_CHOOSE_PRIVATE_KEY_URI);
        String alias = intent.getStringExtra(EXTRA_CHOOSE_PRIVATE_KEY_ALIAS);
        String chosenAlias = onChoosePrivateKeyAlias(context, intent, uid, uri, alias);
        setResultData(chosenAlias);
    } else if (ACTION_NETWORK_LOGS_AVAILABLE.equals(action)) {
        long batchToken = intent.getLongExtra(EXTRA_NETWORK_LOGS_TOKEN, -1);
        int networkLogsCount = intent.getIntExtra(EXTRA_NETWORK_LOGS_COUNT, 0);
        onNetworkLogsAvailable(context, intent, batchToken, networkLogsCount);
    } else {
        Log.w(TAG, "Unhandled broadcast: " + action);
    }
}
Body of Second Method:
{
    String action = intent.getAction();
    if (ACTION_CHOOSE_PRIVATE_KEY_ALIAS.equals(action)) {
        int uid = intent.getIntExtra(EXTRA_CHOOSE_PRIVATE_KEY_SENDER_UID, -1);
        Uri uri = intent.getParcelableExtra(EXTRA_CHOOSE_PRIVATE_KEY_URI);
        String alias = intent.getStringExtra(EXTRA_CHOOSE_PRIVATE_KEY_ALIAS);
        String chosenAlias = onChoosePrivateKeyAlias(context, intent, uid, uri, alias);
        setResultData(chosenAlias);
    } else if (ACTION_NETWORK_LOGS_AVAILABLE.equals(action)) {
        long batchToken = intent.getLongExtra(EXTRA_NETWORK_LOGS_TOKEN, -1);
        int networkLogsCount = intent.getIntExtra(EXTRA_NETWORK_LOGS_COUNT, 0);
        onNetworkLogsAvailable(context, intent, batchToken, networkLogsCount);
    } else if (ACTION_SECURITY_LOGS_AVAILABLE.equals(action)) {
        onSecurityLogsAvailable(context, intent);
    } else {
        Log.w(TAG, "Unhandled broadcast: " + action);
    }
}
------------------------
Find a silently evolved API code:android.view.autofill.AutofillValue.getDateValue:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the value to autofill a date field.
 *
 * <p>See {@link View#AUTOFILL_TYPE_DATE} for more info.</p>
 *
 * @throws IllegalStateException if the value is not a date value
 */

Body of Frist Method:
{
    Preconditions.checkState(isDate(), "value must be a date value, not type=" + mType);
    return (Long) mValue;
}
Body of Second Method:
{
    Preconditions.checkState(isDate(), "value must be a date value, not type=%d", mType);
    return (Long) mValue;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothDevice.cancelBondProcess:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Cancel an in-progress bonding request started with {@link #createBond}.
 *
 * @return true on success, false on error
 * @hide
 */

Body of Frist Method:
{
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, "BT not enabled. Cannot cancel Remote Device bond");
        return false;
    }
    try {
        Log.i(TAG, "cancelBondProcess() for device " + getAddress() + " called by pid: " + Process.myPid() + " tid: " + Process.myTid());
        return service.cancelBondProcess(this);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
Body of Second Method:
{
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, "BT not enabled. Cannot cancel Remote Device bond");
        return false;
    }
    try {
        Log.i(TAG, "cancelBondProcess() for device " + getAddress() + " called by pid: " + Process.myPid() + " tid: " + Process.myTid());
        return service.cancelBondProcess(this, mAttributionSource);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
------------------------
Find a silently evolved API code:android.view.SurfaceSession.finalize:COMMENT
Method Modifier: protected   hidden      
Comment:/* no user serviceable parts here ... */

Body of Frist Method:
{
    try {
        if (mNativeClient != 0) {
            nativeDestroy(mNativeClient);
        }
    } finally {
        super.finalize();
    }
}
Body of Second Method:
{
    try {
        kill();
    } finally {
        super.finalize();
    }
}
------------------------
Find a silently evolved API code:android.media.tv.tuner.frontend.AnalogFrontendSettings.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Builds a {@link AnalogFrontendSettings} object.
 */

Body of Frist Method:
{
    return new AnalogFrontendSettings(mFrequency, mSignalType, mSifStandard);
}
Body of Second Method:
{
    return new AnalogFrontendSettings(mFrequency, mSignalType, mSifStandard, mAftFlag);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.explicitCallTransfer:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Performs explicit call transfer.
 *
 * That means connect other calls and disconnect.
 *
 * @param device remote device
 * @return <code>true</code> if command has been issued successfully; <code>false</code>
 * otherwise; upon completion HFP sends {@link #ACTION_CALL_CHANGED} intent.
 *
 * <p>Feature required for successful execution is being reported by: {@link
 * #EXTRA_AG_FEATURE_MERGE_AND_DETACH}. This method invocation will fail silently when feature
 * is not supported.</p>
 */

Body of Frist Method:
{
    if (DBG)
        log("explicitCallTransfer()");
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.explicitCallTransfer(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("explicitCallTransfer()");
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.explicitCallTransfer(device, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothPan.isTetheringOn:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Determines whether tethering is enabled
 *
 * @return true if tethering is on, false if not or some error occurred
 * @hide
 */

Body of Frist Method:
{
    if (VDBG)
        log("isTetheringOn()");
    final IBluetoothPan service = getService();
    if (service != null && isEnabled()) {
        try {
            return service.isTetheringOn();
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
        }
    }
    return false;
}
Body of Second Method:
{
    if (VDBG)
        log("isTetheringOn()");
    final IBluetoothPan service = getService();
    if (service != null && isEnabled()) {
        try {
            return service.isTetheringOn(mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
        }
    }
    return false;
}
------------------------
Find a silently evolved API code:android.location.LocationProvider.requiresCell:COMMENT
<android.location.LocationProvider: boolean requiresCell()>
public      ->public      deprecated  
Method Modifier: public      deprecated  
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Returns true if the provider requires access to an appropriate
 * cellular network (e.g., to make use of cell tower IDs), false
 * otherwise.
 */

Body of Frist Method:
{
    return mProperties.mRequiresCell;
}
Body of Second Method:
{
    if (mProperties == null) {
        return false;
    } else {
        return mProperties.hasCellRequirement();
    }
}
------------------------
Find a silently evolved API code:android.os.VibrationAttributes.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Combines all of the attributes that have been set and returns a new
 * {@link VibrationAttributes} object.
 * @return a new {@link VibrationAttributes} object
 */

Body of Frist Method:
{
    VibrationAttributes ans = new VibrationAttributes(mUsage, mFlags, mAudioAttributes);
    return ans;
}
Body of Second Method:
{
    VibrationAttributes ans = new VibrationAttributes(mUsage, mOriginalAudioUsage, mFlags);
    return ans;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadset.clccResponse:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Send Headset of CLCC response
 *
 * @hide
 */

Body of Frist Method:
{
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled()) {
        try {
            service.clccResponse(index, direction, status, mode, mpty, number, type);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
}
Body of Second Method:
{
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled()) {
        try {
            service.clccResponse(index, direction, status, mode, mpty, number, type, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
}
------------------------
Find a silently evolved API code:android.net.util.SocketUtils.bindSocketToInterface:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Create a raw datagram socket that is bound to an interface.
 *
 * <p>Data sent through the socket will go directly to the underlying network, ignoring VPNs.
 */

Body of Frist Method:
{
    // SO_BINDTODEVICE actually takes a string. This works because the first member
    // of struct ifreq is a NULL-terminated interface name.
    // TODO: add a setsockoptString()
    Os.setsockoptIfreq(socket, SOL_SOCKET, SO_BINDTODEVICE, iface);
    NetworkUtils.protectFromVpn(socket);
}
Body of Second Method:
{
    // SO_BINDTODEVICE actually takes a string. This works because the first member
    // of struct ifreq is a NULL-terminated interface name.
    // TODO: add a setsockoptString()
    Os.setsockoptIfreq(socket, SOL_SOCKET, SO_BINDTODEVICE, iface);
    NetworkUtilsInternal.protectFromVpn(socket);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothA2dp.setConnectionPolicy:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Set connection policy of the profile
 *
 * <p> The device should already be paired.
 * Connection policy can be one of {@link #CONNECTION_POLICY_ALLOWED},
 * {@link #CONNECTION_POLICY_FORBIDDEN}, {@link #CONNECTION_POLICY_UNKNOWN}
 *
 * @param device Paired bluetooth device
 * @param connectionPolicy is the connection policy to set to for this profile
 * @return true if connectionPolicy is set, false on error
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("setConnectionPolicy(" + device + ", " + connectionPolicy + ")");
    try {
        final IBluetoothA2dp service = getService();
        if (service != null && isEnabled() && isValidDevice(device)) {
            if (connectionPolicy != BluetoothProfile.CONNECTION_POLICY_FORBIDDEN && connectionPolicy != BluetoothProfile.CONNECTION_POLICY_ALLOWED) {
                return false;
            }
            return service.setConnectionPolicy(device, connectionPolicy);
        }
        if (service == null)
            Log.w(TAG, "Proxy not attached to service");
        return false;
    } catch (RemoteException e) {
        Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
        return false;
    }
}
Body of Second Method:
{
    if (DBG)
        log("setConnectionPolicy(" + device + ", " + connectionPolicy + ")");
    try {
        final IBluetoothA2dp service = getService();
        if (service != null && isEnabled() && isValidDevice(device)) {
            if (connectionPolicy != BluetoothProfile.CONNECTION_POLICY_FORBIDDEN && connectionPolicy != BluetoothProfile.CONNECTION_POLICY_ALLOWED) {
                return false;
            }
            return service.setConnectionPolicy(device, connectionPolicy, mAttributionSource);
        }
        if (service == null)
            Log.w(TAG, "Proxy not attached to service");
        return false;
    } catch (RemoteException e) {
        Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
        return false;
    }
}
------------------------
Find a silently evolved API code:android.widget.ToggleButton.setTextOn:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the text for when the button is in the checked state.
 *
 * @param textOn The text.
 */

Body of Frist Method:
{
    mTextOn = textOn;
    // Default state is derived from on/off-text, so state has to be updated when on/off-text
    // are updated.
    setDefaultStateDescritption();
}
Body of Second Method:
{
    mTextOn = textOn;
    // Default state is derived from on/off-text, so state has to be updated when on/off-text
    // are updated.
    setDefaultStateDescription();
}
------------------------
Find a silently evolved API code:android.media.AudioFormat.getBytesPerSample:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    switch(audioFormat) {
        case ENCODING_PCM_8BIT:
            return 1;
        case ENCODING_PCM_16BIT:
        case ENCODING_IEC61937:
        case ENCODING_DEFAULT:
            return 2;
        case ENCODING_PCM_FLOAT:
            return 4;
        case ENCODING_INVALID:
        default:
            throw new IllegalArgumentException("Bad audio format " + audioFormat);
    }
}
Body of Second Method:
{
    switch(audioFormat) {
        case ENCODING_PCM_8BIT:
            return 1;
        case ENCODING_PCM_16BIT:
        case ENCODING_IEC61937:
        case ENCODING_DEFAULT:
            return 2;
        case ENCODING_PCM_24BIT_PACKED:
            return 3;
        case ENCODING_PCM_FLOAT:
        case ENCODING_PCM_32BIT:
            return 4;
        case ENCODING_INVALID:
        default:
            throw new IllegalArgumentException("Bad audio format " + audioFormat);
    }
}
------------------------
Find a silently evolved API code:android.content.pm.ShortcutManager.reportShortcutUsed:COMMENT
Method Modifier: public      
Comment:/**
 * Apps that publish shortcuts should call this method whenever the user
 * selects the shortcut containing the given ID or when the user completes
 * an action in the app that is equivalent to selecting the shortcut.
 * For more details, read about
 * <a href="/guide/topics/ui/shortcuts/managing-shortcuts.html#track-usage">
 * tracking shortcut usage</a>.
 *
 * <p>The information is accessible via {@link UsageStatsManager#queryEvents}
 * Typically, launcher apps use this information to build a prediction model
 * so that they can promote the shortcuts that are likely to be used at the moment.
 *
 * @throws IllegalStateException when the user is locked.
 */

Body of Frist Method:
{
    try {
        mService.reportShortcutUsed(mContext.getPackageName(), shortcutId, injectMyUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    try {
        getFutureOrThrow(mService.reportShortcutUsed(mContext.getPackageName(), shortcutId, injectMyUserId()));
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.app.WindowConfiguration.setTo:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Copies the fields specified by mask from delta into this Configuration object.
 * @hide
 */

Body of Frist Method:
{
    if ((mask & WINDOW_CONFIG_BOUNDS) != 0) {
        setBounds(delta.mBounds);
    }
    if ((mask & WINDOW_CONFIG_APP_BOUNDS) != 0) {
        setAppBounds(delta.mAppBounds);
    }
    if ((mask & WINDOW_CONFIG_WINDOWING_MODE) != 0) {
        setWindowingMode(delta.mWindowingMode);
    }
    if ((mask & WINDOW_CONFIG_ACTIVITY_TYPE) != 0) {
        setActivityType(delta.mActivityType);
    }
    if ((mask & WINDOW_CONFIG_ALWAYS_ON_TOP) != 0) {
        setAlwaysOnTop(delta.mAlwaysOnTop);
    }
    if ((mask & WINDOW_CONFIG_ROTATION) != 0) {
        setRotation(delta.mRotation);
    }
    if ((mask & WINDOW_CONFIG_DISPLAY_WINDOWING_MODE) != 0) {
        setDisplayWindowingMode(delta.mDisplayWindowingMode);
    }
}
Body of Second Method:
{
    if ((mask & WINDOW_CONFIG_BOUNDS) != 0) {
        setBounds(delta.mBounds);
    }
    if ((mask & WINDOW_CONFIG_APP_BOUNDS) != 0) {
        setAppBounds(delta.mAppBounds);
    }
    if ((mask & WINDOW_CONFIG_MAX_BOUNDS) != 0) {
        setMaxBounds(delta.mMaxBounds);
    }
    if ((mask & WINDOW_CONFIG_WINDOWING_MODE) != 0) {
        setWindowingMode(delta.mWindowingMode);
    }
    if ((mask & WINDOW_CONFIG_ACTIVITY_TYPE) != 0) {
        setActivityType(delta.mActivityType);
    }
    if ((mask & WINDOW_CONFIG_ALWAYS_ON_TOP) != 0) {
        setAlwaysOnTop(delta.mAlwaysOnTop);
    }
    if ((mask & WINDOW_CONFIG_ROTATION) != 0) {
        setRotation(delta.mRotation);
    }
    if ((mask & WINDOW_CONFIG_DISPLAY_WINDOWING_MODE) != 0) {
        setDisplayWindowingMode(delta.mDisplayWindowingMode);
    }
}
------------------------
Find a silently evolved API code:android.widget.EdgeEffect.onRelease:COMMENT
Method Modifier: public      
Comment:/**
 * Call when the object is released after being pulled.
 * This will begin the "decay" phase of the effect. After calling this method
 * the host view should {@link android.view.View#invalidate()} and thereby
 * draw the results accordingly.
 */

Body of Frist Method:
{
    mPullDistance = 0;
    if (mState != STATE_PULL && mState != STATE_PULL_DECAY) {
        return;
    }
    mState = STATE_RECEDE;
    mGlowAlphaStart = mGlowAlpha;
    mGlowScaleYStart = mGlowScaleY;
    mGlowAlphaFinish = 0.f;
    mGlowScaleYFinish = 0.f;
    mStartTime = AnimationUtils.currentAnimationTimeMillis();
    mDuration = RECEDE_TIME;
}
Body of Second Method:
{
    mPullDistance = 0;
    if (mState != STATE_PULL && mState != STATE_PULL_DECAY) {
        return;
    }
    mState = STATE_RECEDE;
    mGlowAlphaStart = mGlowAlpha;
    mGlowScaleYStart = mGlowScaleY;
    mGlowAlphaFinish = 0.f;
    mGlowScaleYFinish = 0.f;
    mVelocity = 0.f;
    mStartTime = AnimationUtils.currentAnimationTimeMillis();
    mDuration = RECEDE_TIME;
}
------------------------
Find a silently evolved API code:android.view.InputChannel.dup:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Duplicates the input channel.
 */

Body of Frist Method:
{
    InputChannel target = new InputChannel();
    nativeDup(target);
    return target;
}
Body of Second Method:
{
    InputChannel target = new InputChannel();
    target.setNativeInputChannel(nativeDup(mPtr));
    return target;
}
------------------------
Find a silently evolved API code:android.graphics.ImageFormat.isPublicFormat:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Determine whether or not this is a public-visible {@code format}.
 *
 * <p>In particular, {@code @hide} formats will return {@code false}.</p>
 *
 * <p>Any other formats (including UNKNOWN) will return {@code false}.</p>
 *
 * @param format an integer format
 * @return a boolean
 *
 * @hide
 */

Body of Frist Method:
{
    switch(format) {
        case RGB_565:
        case NV16:
        case YUY2:
        case YV12:
        case JPEG:
        case NV21:
        case YUV_420_888:
        case YUV_422_888:
        case YUV_444_888:
        case FLEX_RGB_888:
        case FLEX_RGBA_8888:
        case RAW_SENSOR:
        case RAW_PRIVATE:
        case RAW10:
        case RAW12:
        case DEPTH16:
        case DEPTH_POINT_CLOUD:
        case PRIVATE:
        case RAW_DEPTH:
        case Y8:
        case DEPTH_JPEG:
        case HEIC:
            return true;
    }
    return false;
}
Body of Second Method:
{
    switch(format) {
        case RGB_565:
        case NV16:
        case YUY2:
        case YV12:
        case JPEG:
        case NV21:
        case YUV_420_888:
        case YUV_422_888:
        case YUV_444_888:
        case YCBCR_P010:
        case FLEX_RGB_888:
        case FLEX_RGBA_8888:
        case RAW_SENSOR:
        case RAW_PRIVATE:
        case RAW10:
        case RAW12:
        case DEPTH16:
        case DEPTH_POINT_CLOUD:
        case PRIVATE:
        case RAW_DEPTH:
        case RAW_DEPTH10:
        case Y8:
        case DEPTH_JPEG:
        case HEIC:
            return true;
    }
    return false;
}
------------------------
Find a silently evolved API code:android.hardware.lights.LightsManager.openSession:COMMENT
<android.hardware.lights.LightsManager: LightsSession openSession()>
public      hidden      ->public      abstract    
Method Modifier: public      abstract    hidden      
Method Modifier: Yes         No          Yes         
Method Updated:  Yes         Yes         No          
Comment:/**
 * Creates a new LightsSession that can be used to control the device lights.
 */

Body of Frist Method:
{
    try {
        final LightsSession session = new LightsSession();
        mService.openSession(session.mToken);
        return session;
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.hardware.Sensor.setType:COMMENT
Method Modifier: private     
Comment:/**
 * Sets the Type associated with the sensor.
 * NOTE: to be used only by native bindings in SensorManager.
 *
 * This allows interned static strings to be used across all representations of the Sensor. If
 * a sensor type is not referenced here, it will still be interned by the native SensorManager.
 *
 * @return {@code true} if the StringType was successfully set, {@code false} otherwise.
 */

Body of Frist Method:
{
    mType = value;
    switch(mType) {
        case TYPE_ACCELEROMETER:
            mStringType = STRING_TYPE_ACCELEROMETER;
            return true;
        case TYPE_AMBIENT_TEMPERATURE:
            mStringType = STRING_TYPE_AMBIENT_TEMPERATURE;
            return true;
        case TYPE_GAME_ROTATION_VECTOR:
            mStringType = STRING_TYPE_GAME_ROTATION_VECTOR;
            return true;
        case TYPE_GEOMAGNETIC_ROTATION_VECTOR:
            mStringType = STRING_TYPE_GEOMAGNETIC_ROTATION_VECTOR;
            return true;
        case TYPE_GLANCE_GESTURE:
            mStringType = STRING_TYPE_GLANCE_GESTURE;
            return true;
        case TYPE_GRAVITY:
            mStringType = STRING_TYPE_GRAVITY;
            return true;
        case TYPE_GYROSCOPE:
            mStringType = STRING_TYPE_GYROSCOPE;
            return true;
        case TYPE_GYROSCOPE_UNCALIBRATED:
            mStringType = STRING_TYPE_GYROSCOPE_UNCALIBRATED;
            return true;
        case TYPE_HEART_RATE:
            mStringType = STRING_TYPE_HEART_RATE;
            return true;
        case TYPE_LIGHT:
            mStringType = STRING_TYPE_LIGHT;
            return true;
        case TYPE_LINEAR_ACCELERATION:
            mStringType = STRING_TYPE_LINEAR_ACCELERATION;
            return true;
        case TYPE_MAGNETIC_FIELD:
            mStringType = STRING_TYPE_MAGNETIC_FIELD;
            return true;
        case TYPE_MAGNETIC_FIELD_UNCALIBRATED:
            mStringType = STRING_TYPE_MAGNETIC_FIELD_UNCALIBRATED;
            return true;
        case TYPE_PICK_UP_GESTURE:
            mStringType = STRING_TYPE_PICK_UP_GESTURE;
            return true;
        case TYPE_PRESSURE:
            mStringType = STRING_TYPE_PRESSURE;
            return true;
        case TYPE_PROXIMITY:
            mStringType = STRING_TYPE_PROXIMITY;
            return true;
        case TYPE_RELATIVE_HUMIDITY:
            mStringType = STRING_TYPE_RELATIVE_HUMIDITY;
            return true;
        case TYPE_ROTATION_VECTOR:
            mStringType = STRING_TYPE_ROTATION_VECTOR;
            return true;
        case TYPE_SIGNIFICANT_MOTION:
            mStringType = STRING_TYPE_SIGNIFICANT_MOTION;
            return true;
        case TYPE_STEP_COUNTER:
            mStringType = STRING_TYPE_STEP_COUNTER;
            return true;
        case TYPE_STEP_DETECTOR:
            mStringType = STRING_TYPE_STEP_DETECTOR;
            return true;
        case TYPE_TILT_DETECTOR:
            mStringType = SENSOR_STRING_TYPE_TILT_DETECTOR;
            return true;
        case TYPE_WAKE_GESTURE:
            mStringType = STRING_TYPE_WAKE_GESTURE;
            return true;
        case TYPE_ORIENTATION:
            mStringType = STRING_TYPE_ORIENTATION;
            return true;
        case TYPE_TEMPERATURE:
            mStringType = STRING_TYPE_TEMPERATURE;
            return true;
        case TYPE_DEVICE_ORIENTATION:
            mStringType = STRING_TYPE_DEVICE_ORIENTATION;
            return true;
        case TYPE_DYNAMIC_SENSOR_META:
            mStringType = STRING_TYPE_DYNAMIC_SENSOR_META;
            return true;
        case TYPE_LOW_LATENCY_OFFBODY_DETECT:
            mStringType = STRING_TYPE_LOW_LATENCY_OFFBODY_DETECT;
            return true;
        case TYPE_ACCELEROMETER_UNCALIBRATED:
            mStringType = STRING_TYPE_ACCELEROMETER_UNCALIBRATED;
            return true;
        case TYPE_HINGE_ANGLE:
            mStringType = STRING_TYPE_HINGE_ANGLE;
        default:
            return false;
    }
}
Body of Second Method:
{
    mType = value;
    switch(mType) {
        case TYPE_ACCELEROMETER:
            mStringType = STRING_TYPE_ACCELEROMETER;
            return true;
        case TYPE_AMBIENT_TEMPERATURE:
            mStringType = STRING_TYPE_AMBIENT_TEMPERATURE;
            return true;
        case TYPE_GAME_ROTATION_VECTOR:
            mStringType = STRING_TYPE_GAME_ROTATION_VECTOR;
            return true;
        case TYPE_GEOMAGNETIC_ROTATION_VECTOR:
            mStringType = STRING_TYPE_GEOMAGNETIC_ROTATION_VECTOR;
            return true;
        case TYPE_GLANCE_GESTURE:
            mStringType = STRING_TYPE_GLANCE_GESTURE;
            return true;
        case TYPE_GRAVITY:
            mStringType = STRING_TYPE_GRAVITY;
            return true;
        case TYPE_GYROSCOPE:
            mStringType = STRING_TYPE_GYROSCOPE;
            return true;
        case TYPE_GYROSCOPE_UNCALIBRATED:
            mStringType = STRING_TYPE_GYROSCOPE_UNCALIBRATED;
            return true;
        case TYPE_HEART_RATE:
            mStringType = STRING_TYPE_HEART_RATE;
            return true;
        case TYPE_LIGHT:
            mStringType = STRING_TYPE_LIGHT;
            return true;
        case TYPE_LINEAR_ACCELERATION:
            mStringType = STRING_TYPE_LINEAR_ACCELERATION;
            return true;
        case TYPE_MAGNETIC_FIELD:
            mStringType = STRING_TYPE_MAGNETIC_FIELD;
            return true;
        case TYPE_MAGNETIC_FIELD_UNCALIBRATED:
            mStringType = STRING_TYPE_MAGNETIC_FIELD_UNCALIBRATED;
            return true;
        case TYPE_PICK_UP_GESTURE:
            mStringType = STRING_TYPE_PICK_UP_GESTURE;
            return true;
        case TYPE_PRESSURE:
            mStringType = STRING_TYPE_PRESSURE;
            return true;
        case TYPE_PROXIMITY:
            mStringType = STRING_TYPE_PROXIMITY;
            return true;
        case TYPE_RELATIVE_HUMIDITY:
            mStringType = STRING_TYPE_RELATIVE_HUMIDITY;
            return true;
        case TYPE_ROTATION_VECTOR:
            mStringType = STRING_TYPE_ROTATION_VECTOR;
            return true;
        case TYPE_SIGNIFICANT_MOTION:
            mStringType = STRING_TYPE_SIGNIFICANT_MOTION;
            return true;
        case TYPE_STEP_COUNTER:
            mStringType = STRING_TYPE_STEP_COUNTER;
            return true;
        case TYPE_STEP_DETECTOR:
            mStringType = STRING_TYPE_STEP_DETECTOR;
            return true;
        case TYPE_TILT_DETECTOR:
            mStringType = SENSOR_STRING_TYPE_TILT_DETECTOR;
            return true;
        case TYPE_WAKE_GESTURE:
            mStringType = STRING_TYPE_WAKE_GESTURE;
            return true;
        case TYPE_ORIENTATION:
            mStringType = STRING_TYPE_ORIENTATION;
            return true;
        case TYPE_TEMPERATURE:
            mStringType = STRING_TYPE_TEMPERATURE;
            return true;
        case TYPE_DEVICE_ORIENTATION:
            mStringType = STRING_TYPE_DEVICE_ORIENTATION;
            return true;
        case TYPE_DYNAMIC_SENSOR_META:
            mStringType = STRING_TYPE_DYNAMIC_SENSOR_META;
            return true;
        case TYPE_LOW_LATENCY_OFFBODY_DETECT:
            mStringType = STRING_TYPE_LOW_LATENCY_OFFBODY_DETECT;
            return true;
        case TYPE_ACCELEROMETER_UNCALIBRATED:
            mStringType = STRING_TYPE_ACCELEROMETER_UNCALIBRATED;
            return true;
        case TYPE_HINGE_ANGLE:
            mStringType = STRING_TYPE_HINGE_ANGLE;
            return true;
        default:
            return false;
    }
}
------------------------
Find a silently evolved API code:android.content.pm.parsing.PackageInfoWithoutStateUtils.generateWithoutComponentsUnchecked:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * This bypasses critical checks that are necessary for usage with data passed outside of
 * system server.
 *
 * Prefer {@link #generateWithoutComponents(ParsingPackageRead, int[], int, long, long, Set,
 * PackageUserState, int, ApexInfo, ApplicationInfo)}.
 */

Body of Frist Method:
{
    PackageInfo pi = new PackageInfo();
    pi.packageName = pkg.getPackageName();
    pi.splitNames = pkg.getSplitNames();
    pi.versionCode = pkg.getVersionCode();
    pi.versionCodeMajor = pkg.getVersionCodeMajor();
    pi.baseRevisionCode = pkg.getBaseRevisionCode();
    pi.splitRevisionCodes = pkg.getSplitRevisionCodes();
    pi.versionName = pkg.getVersionName();
    pi.sharedUserId = pkg.getSharedUserId();
    pi.sharedUserLabel = pkg.getSharedUserLabel();
    pi.applicationInfo = applicationInfo;
    pi.installLocation = pkg.getInstallLocation();
    if ((pi.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0 || (pi.applicationInfo.flags & ApplicationInfo.FLAG_UPDATED_SYSTEM_APP) != 0) {
        pi.requiredForAllUsers = pkg.isRequiredForAllUsers();
    }
    pi.restrictedAccountType = pkg.getRestrictedAccountType();
    pi.requiredAccountType = pkg.getRequiredAccountType();
    pi.overlayTarget = pkg.getOverlayTarget();
    pi.targetOverlayableName = pkg.getOverlayTargetName();
    pi.overlayCategory = pkg.getOverlayCategory();
    pi.overlayPriority = pkg.getOverlayPriority();
    pi.mOverlayIsStatic = pkg.isOverlayIsStatic();
    pi.compileSdkVersion = pkg.getCompileSdkVersion();
    pi.compileSdkVersionCodename = pkg.getCompileSdkVersionCodeName();
    pi.firstInstallTime = firstInstallTime;
    pi.lastUpdateTime = lastUpdateTime;
    if ((flags & PackageManager.GET_GIDS) != 0) {
        pi.gids = gids;
    }
    if ((flags & PackageManager.GET_CONFIGURATIONS) != 0) {
        int size = pkg.getConfigPreferences().size();
        if (size > 0) {
            pi.configPreferences = new ConfigurationInfo[size];
            pkg.getConfigPreferences().toArray(pi.configPreferences);
        }
        size = pkg.getReqFeatures().size();
        if (size > 0) {
            pi.reqFeatures = new FeatureInfo[size];
            pkg.getReqFeatures().toArray(pi.reqFeatures);
        }
        size = pkg.getFeatureGroups().size();
        if (size > 0) {
            pi.featureGroups = new FeatureGroupInfo[size];
            pkg.getFeatureGroups().toArray(pi.featureGroups);
        }
    }
    if ((flags & PackageManager.GET_PERMISSIONS) != 0) {
        int size = ArrayUtils.size(pkg.getPermissions());
        if (size > 0) {
            pi.permissions = new PermissionInfo[size];
            for (int i = 0; i < size; i++) {
                pi.permissions[i] = generatePermissionInfo(pkg.getPermissions().get(i), flags);
            }
        }
        size = pkg.getRequestedPermissions().size();
        if (size > 0) {
            pi.requestedPermissions = new String[size];
            pi.requestedPermissionsFlags = new int[size];
            for (int i = 0; i < size; i++) {
                final String perm = pkg.getRequestedPermissions().get(i);
                pi.requestedPermissions[i] = perm;
                // The notion of required permissions is deprecated but for compatibility.
                pi.requestedPermissionsFlags[i] |= PackageInfo.REQUESTED_PERMISSION_REQUIRED;
                if (grantedPermissions != null && grantedPermissions.contains(perm)) {
                    pi.requestedPermissionsFlags[i] |= PackageInfo.REQUESTED_PERMISSION_GRANTED;
                }
            }
        }
    }
    if (apexInfo != null) {
        File apexFile = new File(apexInfo.modulePath);
        pi.applicationInfo.sourceDir = apexFile.getPath();
        pi.applicationInfo.publicSourceDir = apexFile.getPath();
        if (apexInfo.isFactory) {
            pi.applicationInfo.flags |= ApplicationInfo.FLAG_SYSTEM;
        } else {
            pi.applicationInfo.flags &= ~ApplicationInfo.FLAG_SYSTEM;
        }
        if (apexInfo.isActive) {
            pi.applicationInfo.flags |= ApplicationInfo.FLAG_INSTALLED;
        } else {
            pi.applicationInfo.flags &= ~ApplicationInfo.FLAG_INSTALLED;
        }
        pi.isApex = true;
    }
    PackageParser.SigningDetails signingDetails = pkg.getSigningDetails();
    // deprecated method of getting signing certificates
    if ((flags & PackageManager.GET_SIGNATURES) != 0) {
        if (signingDetails.hasPastSigningCertificates()) {
            // Package has included signing certificate rotation information.  Return the oldest
            // cert so that programmatic checks keep working even if unaware of key rotation.
            pi.signatures = new Signature[1];
            pi.signatures[0] = signingDetails.pastSigningCertificates[0];
        } else if (signingDetails.hasSignatures()) {
            // otherwise keep old behavior
            int numberOfSigs = signingDetails.signatures.length;
            pi.signatures = new Signature[numberOfSigs];
            System.arraycopy(signingDetails.signatures, 0, pi.signatures, 0, numberOfSigs);
        }
    }
    // replacement for GET_SIGNATURES
    if ((flags & PackageManager.GET_SIGNING_CERTIFICATES) != 0) {
        if (signingDetails != PackageParser.SigningDetails.UNKNOWN) {
            // only return a valid SigningInfo if there is signing information to report
            pi.signingInfo = new SigningInfo(signingDetails);
        } else {
            pi.signingInfo = null;
        }
    }
    return pi;
}
Body of Second Method:
{
    PackageInfo pi = new PackageInfo();
    pi.packageName = pkg.getPackageName();
    pi.splitNames = pkg.getSplitNames();
    pi.versionCode = pkg.getVersionCode();
    pi.versionCodeMajor = pkg.getVersionCodeMajor();
    pi.baseRevisionCode = pkg.getBaseRevisionCode();
    pi.splitRevisionCodes = pkg.getSplitRevisionCodes();
    pi.versionName = pkg.getVersionName();
    pi.sharedUserId = pkg.getSharedUserId();
    pi.sharedUserLabel = pkg.getSharedUserLabel();
    pi.applicationInfo = applicationInfo;
    pi.installLocation = pkg.getInstallLocation();
    if ((pi.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0 || (pi.applicationInfo.flags & ApplicationInfo.FLAG_UPDATED_SYSTEM_APP) != 0) {
        pi.requiredForAllUsers = pkg.isRequiredForAllUsers();
    }
    pi.restrictedAccountType = pkg.getRestrictedAccountType();
    pi.requiredAccountType = pkg.getRequiredAccountType();
    pi.overlayTarget = pkg.getOverlayTarget();
    pi.targetOverlayableName = pkg.getOverlayTargetName();
    pi.overlayCategory = pkg.getOverlayCategory();
    pi.overlayPriority = pkg.getOverlayPriority();
    pi.mOverlayIsStatic = pkg.isOverlayIsStatic();
    pi.compileSdkVersion = pkg.getCompileSdkVersion();
    pi.compileSdkVersionCodename = pkg.getCompileSdkVersionCodeName();
    pi.firstInstallTime = firstInstallTime;
    pi.lastUpdateTime = lastUpdateTime;
    if ((flags & PackageManager.GET_GIDS) != 0) {
        pi.gids = gids;
    }
    if ((flags & PackageManager.GET_CONFIGURATIONS) != 0) {
        int size = pkg.getConfigPreferences().size();
        if (size > 0) {
            pi.configPreferences = new ConfigurationInfo[size];
            pkg.getConfigPreferences().toArray(pi.configPreferences);
        }
        size = pkg.getReqFeatures().size();
        if (size > 0) {
            pi.reqFeatures = new FeatureInfo[size];
            pkg.getReqFeatures().toArray(pi.reqFeatures);
        }
        size = pkg.getFeatureGroups().size();
        if (size > 0) {
            pi.featureGroups = new FeatureGroupInfo[size];
            pkg.getFeatureGroups().toArray(pi.featureGroups);
        }
    }
    if ((flags & PackageManager.GET_PERMISSIONS) != 0) {
        int size = ArrayUtils.size(pkg.getPermissions());
        if (size > 0) {
            pi.permissions = new PermissionInfo[size];
            for (int i = 0; i < size; i++) {
                pi.permissions[i] = generatePermissionInfo(pkg.getPermissions().get(i), flags);
            }
        }
        final List<ParsedUsesPermission> usesPermissions = pkg.getUsesPermissions();
        size = usesPermissions.size();
        if (size > 0) {
            pi.requestedPermissions = new String[size];
            pi.requestedPermissionsFlags = new int[size];
            for (int i = 0; i < size; i++) {
                final ParsedUsesPermission usesPermission = usesPermissions.get(i);
                pi.requestedPermissions[i] = usesPermission.name;
                // The notion of required permissions is deprecated but for compatibility.
                pi.requestedPermissionsFlags[i] |= PackageInfo.REQUESTED_PERMISSION_REQUIRED;
                if (grantedPermissions != null && grantedPermissions.contains(usesPermission.name)) {
                    pi.requestedPermissionsFlags[i] |= PackageInfo.REQUESTED_PERMISSION_GRANTED;
                }
                if ((usesPermission.usesPermissionFlags & ParsedUsesPermission.FLAG_NEVER_FOR_LOCATION) != 0) {
                    pi.requestedPermissionsFlags[i] |= PackageInfo.REQUESTED_PERMISSION_NEVER_FOR_LOCATION;
                }
            }
        }
    }
    if ((flags & PackageManager.GET_ATTRIBUTIONS) != 0) {
        int size = ArrayUtils.size(pkg.getAttributions());
        if (size > 0) {
            pi.attributions = new Attribution[size];
            for (int i = 0; i < size; i++) {
                pi.attributions[i] = generateAttribution(pkg.getAttributions().get(i));
            }
        }
        if (pkg.areAttributionsUserVisible()) {
            pi.applicationInfo.privateFlagsExt |= ApplicationInfo.PRIVATE_FLAG_EXT_ATTRIBUTIONS_ARE_USER_VISIBLE;
        } else {
            pi.applicationInfo.privateFlagsExt &= ~ApplicationInfo.PRIVATE_FLAG_EXT_ATTRIBUTIONS_ARE_USER_VISIBLE;
        }
    } else {
        pi.applicationInfo.privateFlagsExt &= ~ApplicationInfo.PRIVATE_FLAG_EXT_ATTRIBUTIONS_ARE_USER_VISIBLE;
    }
    if (apexInfo != null) {
        File apexFile = new File(apexInfo.modulePath);
        pi.applicationInfo.sourceDir = apexFile.getPath();
        pi.applicationInfo.publicSourceDir = apexFile.getPath();
        if (apexInfo.isFactory) {
            pi.applicationInfo.flags |= ApplicationInfo.FLAG_SYSTEM;
            pi.applicationInfo.flags &= ~ApplicationInfo.FLAG_UPDATED_SYSTEM_APP;
        } else {
            pi.applicationInfo.flags &= ~ApplicationInfo.FLAG_SYSTEM;
            pi.applicationInfo.flags |= ApplicationInfo.FLAG_UPDATED_SYSTEM_APP;
        }
        if (apexInfo.isActive) {
            pi.applicationInfo.flags |= ApplicationInfo.FLAG_INSTALLED;
        } else {
            pi.applicationInfo.flags &= ~ApplicationInfo.FLAG_INSTALLED;
        }
        pi.isApex = true;
    }
    PackageParser.SigningDetails signingDetails = pkg.getSigningDetails();
    // deprecated method of getting signing certificates
    if ((flags & PackageManager.GET_SIGNATURES) != 0) {
        if (signingDetails.hasPastSigningCertificates()) {
            // Package has included signing certificate rotation information.  Return the oldest
            // cert so that programmatic checks keep working even if unaware of key rotation.
            pi.signatures = new Signature[1];
            pi.signatures[0] = signingDetails.pastSigningCertificates[0];
        } else if (signingDetails.hasSignatures()) {
            // otherwise keep old behavior
            int numberOfSigs = signingDetails.signatures.length;
            pi.signatures = new Signature[numberOfSigs];
            System.arraycopy(signingDetails.signatures, 0, pi.signatures, 0, numberOfSigs);
        }
    }
    // replacement for GET_SIGNATURES
    if ((flags & PackageManager.GET_SIGNING_CERTIFICATES) != 0) {
        if (signingDetails != PackageParser.SigningDetails.UNKNOWN) {
            // only return a valid SigningInfo if there is signing information to report
            pi.signingInfo = new SigningInfo(signingDetails);
        } else {
            pi.signingInfo = null;
        }
    }
    return pi;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothAvrcpController.sendGroupNavigationCmd:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Send Group Navigation Command to Remote.
 * possible keycode values: next_grp, previous_grp defined above
 */

Body of Frist Method:
{
    Log.d(TAG, "sendGroupNavigationCmd dev = " + device + " key " + keyCode + " State = " + keyState);
    final IBluetoothAvrcpController service = getService();
    if (service != null && isEnabled()) {
        try {
            service.sendGroupNavigationCmd(device, keyCode, keyState);
            return;
        } catch (RemoteException e) {
            Log.e(TAG, "Error talking to BT service in sendGroupNavigationCmd()", e);
            return;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
}
Body of Second Method:
{
    Log.d(TAG, "sendGroupNavigationCmd dev = " + device + " key " + keyCode + " State = " + keyState);
    final IBluetoothAvrcpController service = getService();
    if (service != null && isEnabled()) {
        try {
            service.sendGroupNavigationCmd(device, keyCode, keyState, mAttributionSource);
            return;
        } catch (RemoteException e) {
            Log.e(TAG, "Error talking to BT service in sendGroupNavigationCmd()", e);
            return;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
}
------------------------
Find a silently evolved API code:android.os.SystemClock.currentGnssTimeClock:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns a {@link Clock} that starts at January 1, 1970 00:00:00.0 UTC,
 * synchronized using the device's location provider.
 *
 * @throws DateTimeException when the location provider has not had a location fix since boot.
 */

Body of Frist Method:
{
    return new SimpleClock(ZoneOffset.UTC) {

        private final ILocationManager mMgr = ILocationManager.Stub.asInterface(ServiceManager.getService(Context.LOCATION_SERVICE));

        @Override
        public long millis() {
            LocationTime time;
            try {
                time = mMgr.getGnssTimeMillis();
            } catch (RemoteException e) {
                e.rethrowFromSystemServer();
                return 0;
            }
            if (time == null) {
                throw new DateTimeException("Gnss based time is not available.");
            }
            long currentNanos = elapsedRealtimeNanos();
            long deltaMs = (currentNanos - time.getElapsedRealtimeNanos()) / 1000000L;
            return time.getTime() + deltaMs;
        }
    };
}
Body of Second Method:
{
    return new SimpleClock(ZoneOffset.UTC) {

        private final ILocationManager mMgr = ILocationManager.Stub.asInterface(ServiceManager.getService(Context.LOCATION_SERVICE));

        @Override
        public long millis() {
            LocationTime time;
            try {
                time = mMgr.getGnssTimeMillis();
            } catch (RemoteException e) {
                throw e.rethrowFromSystemServer();
            }
            if (time == null) {
                throw new DateTimeException("Gnss based time is not available.");
            }
            long currentNanos = elapsedRealtimeNanos();
            long deltaMs = (currentNanos - time.getElapsedRealtimeNanos()) / 1000000L;
            return time.getTime() + deltaMs;
        }
    };
}
------------------------
Find a silently evolved API code:android.content.Context.createFeatureContext:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * @removed
 */

Body of Frist Method:
{
    return createAttributionContext(featureId);
}
Body of Second Method:
{
    return createContext(new ContextParams.Builder(getParams()).setAttributionTag(attributionTag).build());
}
------------------------
Find a silently evolved API code:android.app.WindowConfiguration.dumpDebug:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Write to a protocol buffer output stream.
 * Protocol buffer message definition at {@link android.app.WindowConfigurationProto}
 *
 * @param protoOutputStream Stream to write the WindowConfiguration object to.
 * @param fieldId           Field Id of the WindowConfiguration as defined in the parent message
 * @hide
 */

Body of Frist Method:
{
    final long token = protoOutputStream.start(fieldId);
    if (mAppBounds != null) {
        mAppBounds.dumpDebug(protoOutputStream, APP_BOUNDS);
    }
    protoOutputStream.write(WINDOWING_MODE, mWindowingMode);
    protoOutputStream.write(ACTIVITY_TYPE, mActivityType);
    if (mBounds != null) {
        mBounds.dumpDebug(protoOutputStream, BOUNDS);
    }
    protoOutputStream.end(token);
}
Body of Second Method:
{
    final long token = protoOutputStream.start(fieldId);
    if (mAppBounds != null) {
        mAppBounds.dumpDebug(protoOutputStream, APP_BOUNDS);
    }
    protoOutputStream.write(WINDOWING_MODE, mWindowingMode);
    protoOutputStream.write(ACTIVITY_TYPE, mActivityType);
    mBounds.dumpDebug(protoOutputStream, BOUNDS);
    mMaxBounds.dumpDebug(protoOutputStream, MAX_BOUNDS);
    protoOutputStream.end(token);
}
------------------------
Find a silently evolved API code:android.text.format.Formatter.formatIpAddress:COMMENT
Method Modifier: public      static      deprecated  
Comment:/**
 * Returns a string in the canonical IPv4 format ###.###.###.### from a packed integer
 * containing the IP address. The IPv4 address is expected to be in little-endian
 * format (LSB first). That is, 0x01020304 will return "4.3.2.1".
 *
 * @deprecated Use {@link java.net.InetAddress#getHostAddress()}, which supports both IPv4 and
 * IPv6 addresses. This method does not support IPv6 addresses.
 */

Body of Frist Method:
{
    return NetworkUtils.intToInetAddress(ipv4Address).getHostAddress();
}
Body of Second Method:
{
    return Inet4AddressUtils.intToInet4AddressHTL(ipv4Address).getHostAddress();
}
------------------------
Find a silently evolved API code:android.view.inputmethod.EditorInfo.getInitialSelectedText:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the selected text, if any. May be {@code null} when the protocol is not supported or the
 * selected text is way too long.
 *
 * @param flags Supplies additional options controlling how the text is returned. May be
 * either 0 or {@link InputConnection#GET_TEXT_WITH_STYLES}.
 * @return the text that is currently selected, if any. It could be an empty string when there
 * is no text selected. When {@code null} is returned, the selected text might be too long or
 * this protocol is not supported.
 */

Body of Frist Method:
{
    // Swap selection start and end if necessary.
    final int correctedTextSelStart = initialSelStart > initialSelEnd ? initialSelEnd : initialSelStart;
    final int correctedTextSelEnd = initialSelStart > initialSelEnd ? initialSelStart : initialSelEnd;
    final int sourceSelLength = correctedTextSelEnd - correctedTextSelStart;
    if (initialSelStart < 0 || initialSelEnd < 0 || mInitialSurroundingText.getSelectionLength() != sourceSelLength) {
        return null;
    }
    return mInitialSurroundingText.getInitialSelectedText(flags);
}
Body of Second Method:
{
    if (mInitialSurroundingText == null) {
        return null;
    }
    // Swap selection start and end if necessary.
    final int correctedTextSelStart = initialSelStart > initialSelEnd ? initialSelEnd : initialSelStart;
    final int correctedTextSelEnd = initialSelStart > initialSelEnd ? initialSelStart : initialSelEnd;
    final int sourceSelLength = correctedTextSelEnd - correctedTextSelStart;
    int selStart = mInitialSurroundingText.getSelectionStart();
    int selEnd = mInitialSurroundingText.getSelectionEnd();
    if (selStart > selEnd) {
        int tmp = selStart;
        selStart = selEnd;
        selEnd = tmp;
    }
    final int selLength = selEnd - selStart;
    if (initialSelStart < 0 || initialSelEnd < 0 || selLength != sourceSelLength) {
        return null;
    }
    return ((flags & InputConnection.GET_TEXT_WITH_STYLES) != 0) ? mInitialSurroundingText.getText().subSequence(selStart, selEnd) : TextUtils.substring(mInitialSurroundingText.getText(), selStart, selEnd);
}
------------------------
Find a silently evolved API code:android.ddm.DdmHandleHeap.register:COMMENT
Method Modifier: public      static      
Comment:/**
 * Register for the messages we're interested in.
 */

Body of Frist Method:
{
    DdmServer.registerHandler(CHUNK_HPIF, mInstance);
    DdmServer.registerHandler(CHUNK_HPSG, mInstance);
    DdmServer.registerHandler(CHUNK_HPDU, mInstance);
    DdmServer.registerHandler(CHUNK_HPDS, mInstance);
    DdmServer.registerHandler(CHUNK_NHSG, mInstance);
    DdmServer.registerHandler(CHUNK_HPGC, mInstance);
    DdmServer.registerHandler(CHUNK_REAE, mInstance);
    DdmServer.registerHandler(CHUNK_REAQ, mInstance);
    DdmServer.registerHandler(CHUNK_REAL, mInstance);
}
Body of Second Method:
{
    DdmServer.registerHandler(CHUNK_HPGC, mInstance);
}
------------------------
Find a silently evolved API code:android.media.ImageUtils.getEstimatedNativeAllocBytes:COMMENT
Method Modifier: public      static      
Comment:/**
 * Return the estimated native allocation size in bytes based on width, height, format,
 * and number of images.
 *
 * <p>This is a very rough estimation and should only be used for native allocation
 * registration in VM so it can be accounted for during GC.</p>
 *
 * @param width The width of the images.
 * @param height The height of the images.
 * @param format The format of the images.
 * @param numImages The number of the images.
 */

Body of Frist Method:
{
    double estimatedBytePerPixel;
    switch(format) {
        // 10x compression from RGB_888
        case ImageFormat.JPEG:
        case ImageFormat.DEPTH_POINT_CLOUD:
        case ImageFormat.DEPTH_JPEG:
        case ImageFormat.HEIC:
            estimatedBytePerPixel = 0.3;
            break;
        case ImageFormat.Y8:
            estimatedBytePerPixel = 1.0;
            break;
        case ImageFormat.RAW10:
            estimatedBytePerPixel = 1.25;
            break;
        case ImageFormat.YV12:
        case ImageFormat.YUV_420_888:
        case ImageFormat.NV21:
        case ImageFormat.RAW12:
        case // A rough estimate because the real size is unknown.
        ImageFormat.PRIVATE:
            estimatedBytePerPixel = 1.5;
            break;
        case ImageFormat.NV16:
        case PixelFormat.RGB_565:
        case ImageFormat.YUY2:
        case ImageFormat.Y16:
        case ImageFormat.RAW_DEPTH:
        case ImageFormat.RAW_SENSOR:
        // round estimate, real size is unknown
        case ImageFormat.RAW_PRIVATE:
        case ImageFormat.DEPTH16:
            estimatedBytePerPixel = 2.0;
            break;
        case PixelFormat.RGB_888:
            estimatedBytePerPixel = 3.0;
            break;
        case PixelFormat.RGBA_8888:
        case PixelFormat.RGBX_8888:
            estimatedBytePerPixel = 4.0;
            break;
        default:
            throw new UnsupportedOperationException(String.format("Invalid format specified %d", format));
    }
    return (int) (width * height * estimatedBytePerPixel * numImages);
}
Body of Second Method:
{
    double estimatedBytePerPixel;
    switch(format) {
        // 10x compression from RGB_888
        case ImageFormat.JPEG:
        case ImageFormat.DEPTH_POINT_CLOUD:
        case ImageFormat.DEPTH_JPEG:
        case ImageFormat.HEIC:
            estimatedBytePerPixel = 0.3;
            break;
        case ImageFormat.Y8:
            estimatedBytePerPixel = 1.0;
            break;
        case ImageFormat.RAW10:
        case ImageFormat.RAW_DEPTH10:
            estimatedBytePerPixel = 1.25;
            break;
        case ImageFormat.YV12:
        case ImageFormat.YUV_420_888:
        case ImageFormat.NV21:
        case ImageFormat.RAW12:
        case // A rough estimate because the real size is unknown.
        ImageFormat.PRIVATE:
            estimatedBytePerPixel = 1.5;
            break;
        case ImageFormat.NV16:
        case PixelFormat.RGB_565:
        case ImageFormat.YUY2:
        case ImageFormat.Y16:
        case ImageFormat.RAW_DEPTH:
        case ImageFormat.RAW_SENSOR:
        // round estimate, real size is unknown
        case ImageFormat.RAW_PRIVATE:
        case ImageFormat.DEPTH16:
        case ImageFormat.YCBCR_P010:
            estimatedBytePerPixel = 2.0;
            break;
        case PixelFormat.RGB_888:
            estimatedBytePerPixel = 3.0;
            break;
        case PixelFormat.RGBA_8888:
        case PixelFormat.RGBX_8888:
            estimatedBytePerPixel = 4.0;
            break;
        default:
            throw new UnsupportedOperationException(String.format("Invalid format specified %d", format));
    }
    return (int) (width * height * estimatedBytePerPixel * numImages);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothPan.getConnectedDevices:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * {@inheritDoc}
 * @hide
 */

Body of Frist Method:
{
    if (VDBG)
        log("getConnectedDevices()");
    final IBluetoothPan service = getService();
    if (service != null && isEnabled()) {
        try {
            return service.getConnectedDevices();
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
Body of Second Method:
{
    if (VDBG)
        log("getConnectedDevices()");
    final IBluetoothPan service = getService();
    if (service != null && isEnabled()) {
        try {
            return Attributable.setAttributionSource(service.getConnectedDevices(mAttributionSource), mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
------------------------
Find a silently evolved API code:android.telecom.CallRedirectionService.redirectCall:COMMENT
Method Modifier: public      final       
Comment:/**
 * The implemented {@link CallRedirectionService} calls this method to response a request
 * received via {@link #onPlaceCall(Uri, PhoneAccountHandle, boolean)} to inform Telecom that
 * changes are required to the phone number or/and {@link PhoneAccountHandle} for the outgoing
 * call. Telecom will cancel the call if the implemented {@link CallRedirectionService}
 * replies Telecom a handle for an emergency number.
 *
 * <p>This can only be called from implemented
 * {@link #onPlaceCall(Uri, PhoneAccountHandle, boolean)}. The response corresponds to the
 * latest request via {@link #onPlaceCall(Uri, PhoneAccountHandle, boolean)}.
 *
 * @param gatewayUri the gateway uri for call redirection.
 * @param targetPhoneAccount the {@link PhoneAccountHandle} to use when placing the call.
 * @param confirmFirst Telecom will ask users to confirm the redirection via a yes/no dialog
 * if the confirmFirst is true, and if the redirection request of this
 * response was sent with a true flag of allowInteractiveResponse via
 * {@link #onPlaceCall(Uri, PhoneAccountHandle, boolean)}
 */

Body of Frist Method:
{
    try {
        mCallRedirectionAdapter.redirectCall(gatewayUri, targetPhoneAccount, confirmFirst);
    } catch (RemoteException e) {
        e.rethrowAsRuntimeException();
    }
}
Body of Second Method:
{
    try {
        if (mCallRedirectionAdapter == null) {
            throw new IllegalStateException("Can only be called from onPlaceCall.");
        }
        mCallRedirectionAdapter.redirectCall(gatewayUri, targetPhoneAccount, confirmFirst);
    } catch (RemoteException e) {
        e.rethrowAsRuntimeException();
    }
}
------------------------
Find a silently evolved API code:android.widget.DatePickerSpinnerDelegate.reorderSpinners:COMMENT
Method Modifier: private     
Comment:/**
 * Reorders the spinners according to the date format that is
 * explicitly set by the user and if no such is set fall back
 * to the current locale's default format.
 */

Body of Frist Method:
{
    mSpinners.removeAllViews();
    // We use numeric spinners for year and day, but textual months. Ask icu4c what
    // order the user's locale uses for that combination. http://b/7207103.
    String pattern = DateFormat.getBestDateTimePattern(Locale.getDefault(), "yyyyMMMdd");
    char[] order = ICU.getDateFormatOrder(pattern);
    final int spinnerCount = order.length;
    for (int i = 0; i < spinnerCount; i++) {
        switch(order[i]) {
            case 'd':
                mSpinners.addView(mDaySpinner);
                setImeOptions(mDaySpinner, spinnerCount, i);
                break;
            case 'M':
                mSpinners.addView(mMonthSpinner);
                setImeOptions(mMonthSpinner, spinnerCount, i);
                break;
            case 'y':
                mSpinners.addView(mYearSpinner);
                setImeOptions(mYearSpinner, spinnerCount, i);
                break;
            default:
                throw new IllegalArgumentException(Arrays.toString(order));
        }
    }
}
Body of Second Method:
{
    mSpinners.removeAllViews();
    // We use numeric spinners for year and day, but textual months. Ask icu4c what
    // order the user's locale uses for that combination. http://b/7207103.
    String pattern = DateFormat.getBestDateTimePattern(Locale.getDefault(), "yyyyMMMdd");
    char[] order = DateFormat.getDateFormatOrder(pattern);
    final int spinnerCount = order.length;
    for (int i = 0; i < spinnerCount; i++) {
        switch(order[i]) {
            case 'd':
                mSpinners.addView(mDaySpinner);
                setImeOptions(mDaySpinner, spinnerCount, i);
                break;
            case 'M':
                mSpinners.addView(mMonthSpinner);
                setImeOptions(mMonthSpinner, spinnerCount, i);
                break;
            case 'y':
                mSpinners.addView(mYearSpinner);
                setImeOptions(mYearSpinner, spinnerCount, i);
                break;
            default:
                throw new IllegalArgumentException(Arrays.toString(order));
        }
    }
}
------------------------
Find a silently evolved API code:android.widget.ToastPresenter.trySendAccessibilityEvent:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sends {@link AccessibilityEvent#TYPE_NOTIFICATION_STATE_CHANGED} event if accessibility is
 * enabled.
 */

Body of Frist Method:
{
    if (!mAccessibilityManager.isEnabled()) {
        return;
    }
    AccessibilityEvent event = AccessibilityEvent.obtain(AccessibilityEvent.TYPE_NOTIFICATION_STATE_CHANGED);
    event.setClassName(Toast.class.getName());
    event.setPackageName(packageName);
    view.dispatchPopulateAccessibilityEvent(event);
    mAccessibilityManager.sendAccessibilityEvent(event);
}
Body of Second Method:
{
    // We obtain AccessibilityManager manually via its constructor instead of using method
    // AccessibilityManager.getInstance() for 2 reasons:
    // 1. We want to be able to inject IAccessibilityManager in tests to verify behavior.
    // 2. getInstance() caches the instance for the process even if we pass a different
    // context to it. This is problematic for multi-user because callers can pass a context
    // created via Context.createContextAsUser().
    final AccessibilityManager accessibilityManager = new AccessibilityManager(mContext, mAccessibilityManager, mContext.getUserId());
    if (!accessibilityManager.isEnabled()) {
        accessibilityManager.removeClient();
        return;
    }
    AccessibilityEvent event = AccessibilityEvent.obtain(AccessibilityEvent.TYPE_NOTIFICATION_STATE_CHANGED);
    event.setClassName(Toast.class.getName());
    event.setPackageName(packageName);
    view.dispatchPopulateAccessibilityEvent(event);
    accessibilityManager.sendAccessibilityEvent(event);
    // Every new instance of A11yManager registers an IA11yManagerClient object with the
    // backing service. This client isn't removed until the calling process is destroyed,
    // causing a leak here. We explicitly remove the client.
    accessibilityManager.removeClient();
}
------------------------
Find a silently evolved API code:android.content.ContentProviderClient.insert:COMMENT
Method Modifier: public      
Comment:/**
 * See {@link ContentProvider#insert ContentProvider.insert}
 */

Body of Frist Method:
{
    return insert(url, initialValues, null);
}
Body of Second Method:
{
    Objects.requireNonNull(url, "url");
    beforeRemote();
    try {
        return mContentProvider.insert(mAttributionSource, url, initialValues, extras);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}
------------------------
Find a silently evolved API code:android.media.AudioDeviceInfo.isValidAudioDeviceTypeOut:COMMENT
Method Modifier: default     static      
Comment:/*package*/

Body of Frist Method:
{
    switch(type) {
        case TYPE_BUILTIN_EARPIECE:
        case TYPE_BUILTIN_SPEAKER:
        case TYPE_WIRED_HEADSET:
        case TYPE_WIRED_HEADPHONES:
        case TYPE_BLUETOOTH_SCO:
        case TYPE_BLUETOOTH_A2DP:
        case TYPE_HDMI:
        case TYPE_DOCK:
        case TYPE_USB_ACCESSORY:
        case TYPE_USB_DEVICE:
        case TYPE_USB_HEADSET:
        case TYPE_TELEPHONY:
        case TYPE_LINE_ANALOG:
        case TYPE_HDMI_ARC:
        case TYPE_LINE_DIGITAL:
        case TYPE_FM:
        case TYPE_AUX_LINE:
        case TYPE_IP:
        case TYPE_BUS:
        case TYPE_HEARING_AID:
        case TYPE_BUILTIN_SPEAKER_SAFE:
        case TYPE_REMOTE_SUBMIX:
            return true;
        default:
            return false;
    }
}
Body of Second Method:
{
    switch(type) {
        case TYPE_BUILTIN_EARPIECE:
        case TYPE_BUILTIN_SPEAKER:
        case TYPE_WIRED_HEADSET:
        case TYPE_WIRED_HEADPHONES:
        case TYPE_BLUETOOTH_SCO:
        case TYPE_BLUETOOTH_A2DP:
        case TYPE_HDMI:
        case TYPE_DOCK:
        case TYPE_USB_ACCESSORY:
        case TYPE_USB_DEVICE:
        case TYPE_USB_HEADSET:
        case TYPE_TELEPHONY:
        case TYPE_LINE_ANALOG:
        case TYPE_HDMI_ARC:
        case TYPE_HDMI_EARC:
        case TYPE_LINE_DIGITAL:
        case TYPE_FM:
        case TYPE_AUX_LINE:
        case TYPE_IP:
        case TYPE_BUS:
        case TYPE_HEARING_AID:
        case TYPE_BUILTIN_SPEAKER_SAFE:
        case TYPE_BLE_HEADSET:
        case TYPE_BLE_SPEAKER:
            return true;
        default:
            return false;
    }
}
------------------------
Find a silently evolved API code:android.content.pm.PackageManager.installStatusToString:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * {@hide}
 */

Body of Frist Method:
{
    final String str = installStatusToString(status);
    if (msg != null) {
        return str + ": " + msg;
    } else {
        return str;
    }
}
Body of Second Method:
{
    switch(status) {
        case INSTALL_SUCCEEDED:
            return "INSTALL_SUCCEEDED";
        case INSTALL_FAILED_ALREADY_EXISTS:
            return "INSTALL_FAILED_ALREADY_EXISTS";
        case INSTALL_FAILED_INVALID_APK:
            return "INSTALL_FAILED_INVALID_APK";
        case INSTALL_FAILED_INVALID_URI:
            return "INSTALL_FAILED_INVALID_URI";
        case INSTALL_FAILED_INSUFFICIENT_STORAGE:
            return "INSTALL_FAILED_INSUFFICIENT_STORAGE";
        case INSTALL_FAILED_DUPLICATE_PACKAGE:
            return "INSTALL_FAILED_DUPLICATE_PACKAGE";
        case INSTALL_FAILED_NO_SHARED_USER:
            return "INSTALL_FAILED_NO_SHARED_USER";
        case INSTALL_FAILED_UPDATE_INCOMPATIBLE:
            return "INSTALL_FAILED_UPDATE_INCOMPATIBLE";
        case INSTALL_FAILED_SHARED_USER_INCOMPATIBLE:
            return "INSTALL_FAILED_SHARED_USER_INCOMPATIBLE";
        case INSTALL_FAILED_MISSING_SHARED_LIBRARY:
            return "INSTALL_FAILED_MISSING_SHARED_LIBRARY";
        case INSTALL_FAILED_REPLACE_COULDNT_DELETE:
            return "INSTALL_FAILED_REPLACE_COULDNT_DELETE";
        case INSTALL_FAILED_DEXOPT:
            return "INSTALL_FAILED_DEXOPT";
        case INSTALL_FAILED_OLDER_SDK:
            return "INSTALL_FAILED_OLDER_SDK";
        case INSTALL_FAILED_CONFLICTING_PROVIDER:
            return "INSTALL_FAILED_CONFLICTING_PROVIDER";
        case INSTALL_FAILED_NEWER_SDK:
            return "INSTALL_FAILED_NEWER_SDK";
        case INSTALL_FAILED_TEST_ONLY:
            return "INSTALL_FAILED_TEST_ONLY";
        case INSTALL_FAILED_CPU_ABI_INCOMPATIBLE:
            return "INSTALL_FAILED_CPU_ABI_INCOMPATIBLE";
        case INSTALL_FAILED_MISSING_FEATURE:
            return "INSTALL_FAILED_MISSING_FEATURE";
        case INSTALL_FAILED_CONTAINER_ERROR:
            return "INSTALL_FAILED_CONTAINER_ERROR";
        case INSTALL_FAILED_INVALID_INSTALL_LOCATION:
            return "INSTALL_FAILED_INVALID_INSTALL_LOCATION";
        case INSTALL_FAILED_MEDIA_UNAVAILABLE:
            return "INSTALL_FAILED_MEDIA_UNAVAILABLE";
        case INSTALL_FAILED_VERIFICATION_TIMEOUT:
            return "INSTALL_FAILED_VERIFICATION_TIMEOUT";
        case INSTALL_FAILED_VERIFICATION_FAILURE:
            return "INSTALL_FAILED_VERIFICATION_FAILURE";
        case INSTALL_FAILED_PACKAGE_CHANGED:
            return "INSTALL_FAILED_PACKAGE_CHANGED";
        case INSTALL_FAILED_UID_CHANGED:
            return "INSTALL_FAILED_UID_CHANGED";
        case INSTALL_FAILED_VERSION_DOWNGRADE:
            return "INSTALL_FAILED_VERSION_DOWNGRADE";
        case INSTALL_PARSE_FAILED_NOT_APK:
            return "INSTALL_PARSE_FAILED_NOT_APK";
        case INSTALL_PARSE_FAILED_BAD_MANIFEST:
            return "INSTALL_PARSE_FAILED_BAD_MANIFEST";
        case INSTALL_PARSE_FAILED_UNEXPECTED_EXCEPTION:
            return "INSTALL_PARSE_FAILED_UNEXPECTED_EXCEPTION";
        case INSTALL_PARSE_FAILED_NO_CERTIFICATES:
            return "INSTALL_PARSE_FAILED_NO_CERTIFICATES";
        case INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES:
            return "INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES";
        case INSTALL_PARSE_FAILED_CERTIFICATE_ENCODING:
            return "INSTALL_PARSE_FAILED_CERTIFICATE_ENCODING";
        case INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME:
            return "INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME";
        case INSTALL_PARSE_FAILED_BAD_SHARED_USER_ID:
            return "INSTALL_PARSE_FAILED_BAD_SHARED_USER_ID";
        case INSTALL_PARSE_FAILED_MANIFEST_MALFORMED:
            return "INSTALL_PARSE_FAILED_MANIFEST_MALFORMED";
        case INSTALL_PARSE_FAILED_MANIFEST_EMPTY:
            return "INSTALL_PARSE_FAILED_MANIFEST_EMPTY";
        case INSTALL_FAILED_INTERNAL_ERROR:
            return "INSTALL_FAILED_INTERNAL_ERROR";
        case INSTALL_FAILED_USER_RESTRICTED:
            return "INSTALL_FAILED_USER_RESTRICTED";
        case INSTALL_FAILED_DUPLICATE_PERMISSION:
            return "INSTALL_FAILED_DUPLICATE_PERMISSION";
        case INSTALL_FAILED_NO_MATCHING_ABIS:
            return "INSTALL_FAILED_NO_MATCHING_ABIS";
        case INSTALL_FAILED_ABORTED:
            return "INSTALL_FAILED_ABORTED";
        case INSTALL_FAILED_BAD_DEX_METADATA:
            return "INSTALL_FAILED_BAD_DEX_METADATA";
        case INSTALL_FAILED_MISSING_SPLIT:
            return "INSTALL_FAILED_MISSING_SPLIT";
        case INSTALL_FAILED_BAD_SIGNATURE:
            return "INSTALL_FAILED_BAD_SIGNATURE";
        case INSTALL_FAILED_WRONG_INSTALLED_VERSION:
            return "INSTALL_FAILED_WRONG_INSTALLED_VERSION";
        case INSTALL_FAILED_PROCESS_NOT_DEFINED:
            return "INSTALL_FAILED_PROCESS_NOT_DEFINED";
        case INSTALL_FAILED_SESSION_INVALID:
            return "INSTALL_FAILED_SESSION_INVALID";
        default:
            return Integer.toString(status);
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothA2dp.getDevicesMatchingConnectionStates:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    if (VDBG)
        log("getDevicesMatchingStates()");
    try {
        final IBluetoothA2dp service = getService();
        if (service != null && isEnabled()) {
            return service.getDevicesMatchingConnectionStates(states);
        }
        if (service == null)
            Log.w(TAG, "Proxy not attached to service");
        return new ArrayList<BluetoothDevice>();
    } catch (RemoteException e) {
        Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
        return new ArrayList<BluetoothDevice>();
    }
}
Body of Second Method:
{
    if (VDBG)
        log("getDevicesMatchingStates()");
    try {
        final IBluetoothA2dp service = getService();
        if (service != null && isEnabled()) {
            return Attributable.setAttributionSource(service.getDevicesMatchingConnectionStatesWithAttribution(states, mAttributionSource), mAttributionSource);
        }
        if (service == null)
            Log.w(TAG, "Proxy not attached to service");
        return new ArrayList<BluetoothDevice>();
    } catch (RemoteException e) {
        Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
        return new ArrayList<BluetoothDevice>();
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadset.startScoUsingVirtualVoiceCall:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Initiates a SCO channel connection as a virtual voice call to the current active device
 * Active handsfree device will be notified of incoming call and connected call.
 *
 * <p> Users can listen to {@link #ACTION_AUDIO_STATE_CHANGED}.
 * If this function returns true, this intent will be broadcasted with
 * {@link #EXTRA_STATE} set to {@link #STATE_AUDIO_CONNECTING}.
 *
 * <p> {@link #EXTRA_STATE} will transition from
 * {@link #STATE_AUDIO_CONNECTING} to {@link #STATE_AUDIO_CONNECTED} when
 * audio connection is established and to {@link #STATE_AUDIO_DISCONNECTED}
 * in case of failure to establish the audio connection.
 *
 * @return true if successful, false if one of the following case applies
 * - SCO audio is not idle (connecting or connected)
 * - virtual call has already started
 * - there is no active device
 * - a Telecom managed call is going on
 * - binder is dead or Bluetooth is disabled or other error
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("startScoUsingVirtualVoiceCall()");
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.startScoUsingVirtualVoiceCall();
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("startScoUsingVirtualVoiceCall()");
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.startScoUsingVirtualVoiceCall(mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return false;
}
------------------------
Find a silently evolved API code:android.content.pm.ShortcutManager.removeAllDynamicShortcuts:COMMENT
Method Modifier: public      
Comment:/**
 * Delete all dynamic shortcuts from the caller app.
 *
 * @throws IllegalStateException when the user is locked.
 */

Body of Frist Method:
{
    try {
        mService.removeAllDynamicShortcuts(mContext.getPackageName(), injectMyUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    try {
        getFutureOrThrow(mService.removeAllDynamicShortcuts(mContext.getPackageName(), injectMyUserId()));
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.security.ConfirmationPrompt.isSupported:COMMENT
Method Modifier: public      static      
Comment:/**
 * Checks if the device supports confirmation prompts.
 *
 * @param context the application context.
 * @return true if confirmation prompts are supported by the device.
 */

Body of Frist Method:
{
    if (isAccessibilityServiceRunning(context)) {
        return false;
    }
    return KeyStore.getInstance().isConfirmationPromptSupported();
}
Body of Second Method:
{
    if (isAccessibilityServiceRunning(context)) {
        return false;
    }
    return new AndroidProtectedConfirmation().isConfirmationPromptSupported();
}
------------------------
Find a silently evolved API code:android.hardware.camera2.CameraCharacteristics.getPhysicalCameraIds:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the set of physical camera ids that this logical {@link CameraDevice} is
 * made up of.
 *
 * <p>A camera device is a logical camera if it has
 * REQUEST_AVAILABLE_CAPABILITIES_LOGICAL_MULTI_CAMERA capability. If the camera device
 * doesn't have the capability, the return value will be an empty set. </p>
 *
 * <p>Prior to API level 29, all returned IDs are guaranteed to be returned by {@link
 * CameraManager#getCameraIdList}, and can be opened directly by
 * {@link CameraManager#openCamera}. Starting from API level 29, for each of the returned ID,
 * if it's also returned by {@link CameraManager#getCameraIdList}, it can be used as a
 * standalone camera by {@link CameraManager#openCamera}. Otherwise, the camera ID can only be
 * used as part of the current logical camera.</p>
 *
 * <p>The set returned is not modifiable, so any attempts to modify it will throw
 * a {@code UnsupportedOperationException}.</p>
 *
 * @return Set of physical camera ids for this logical camera device.
 */

Body of Frist Method:
{
    int[] availableCapabilities = get(REQUEST_AVAILABLE_CAPABILITIES);
    if (availableCapabilities == null) {
        throw new AssertionError("android.request.availableCapabilities must be non-null " + "in the characteristics");
    }
    if (!ArrayUtils.contains(availableCapabilities, REQUEST_AVAILABLE_CAPABILITIES_LOGICAL_MULTI_CAMERA)) {
        return Collections.emptySet();
    }
    byte[] physicalCamIds = get(LOGICAL_MULTI_CAMERA_PHYSICAL_IDS);
    String physicalCamIdString = null;
    try {
        physicalCamIdString = new String(physicalCamIds, "UTF-8");
    } catch (java.io.UnsupportedEncodingException e) {
        throw new AssertionError("android.logicalCam.physicalIds must be UTF-8 string");
    }
    String[] physicalCameraIdArray = physicalCamIdString.split("\0");
    return Collections.unmodifiableSet(new HashSet<String>(Arrays.asList(physicalCameraIdArray)));
}
Body of Second Method:
{
    return mProperties.getPhysicalCameraIds();
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothA2dpSink.isAudioPlaying:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Check if audio is playing on the bluetooth device (A2DP profile is streaming music).
 *
 * @param device BluetoothDevice device
 * @return true if audio is playing (A2dp is streaming music), false otherwise
 *
 * @hide
 */

Body of Frist Method:
{
    final IBluetoothA2dpSink service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.isA2dpPlaying(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    final IBluetoothA2dpSink service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.isA2dpPlaying(device, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadset.close:COMMENT
Method Modifier: default     
Comment:/**
 * Close the connection to the backing service.
 * Other public functions of BluetoothHeadset will return default error
 * results once close() has been called. Multiple invocations of close()
 * are ok.
 */

Body of Frist Method:
{
    if (VDBG)
        log("close()");
    IBluetoothManager mgr = mAdapter.getBluetoothManager();
    if (mgr != null) {
        try {
            mgr.unregisterStateChangeCallback(mBluetoothStateChangeCallback);
        } catch (RemoteException re) {
            Log.e(TAG, "", re);
        }
    }
    mServiceListener = null;
    doUnbind();
}
Body of Second Method:
{
    if (VDBG)
        log("close()");
    IBluetoothManager mgr = mAdapter.getBluetoothManager();
    if (mgr != null) {
        try {
            mgr.unregisterStateChangeCallback(mBluetoothStateChangeCallback);
        } catch (RemoteException re) {
            Log.e(TAG, "", re);
        }
    }
    mServiceListener = null;
    doUnbind();
    mCloseGuard.close();
}
------------------------
Find a silently evolved API code:android.content.pm.ShortcutManager.setDynamicShortcuts:COMMENT
Method Modifier: public      
Comment:/**
 * Publish the list of shortcuts.  All existing dynamic shortcuts from the caller app
 * will be replaced.  If there are already pinned shortcuts with the same IDs,
 * the mutable pinned shortcuts are updated.
 *
 * <p>This API will be rate-limited.
 *
 * @return {@code true} if the call has succeeded. {@code false} if the call is rate-limited.
 *
 * @throws IllegalArgumentException if {@link #getMaxShortcutCountPerActivity()} is exceeded,
 * or when trying to update immutable shortcuts.
 *
 * @throws IllegalStateException when the user is locked.
 */

Body of Frist Method:
{
    try {
        return mService.setDynamicShortcuts(mContext.getPackageName(), new ParceledListSlice(shortcutInfoList), injectMyUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    try {
        return ((boolean) getFutureOrThrow(mService.setDynamicShortcuts(mContext.getPackageName(), new ParceledListSlice(shortcutInfoList), injectMyUserId())));
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.view.VerifiedKeyEvent.getFlag:COMMENT
Method Modifier: public      
Comment:/**
 * Get a specific flag of this key event, if possible. Return null if the flag value could
 * not be checked.
 *
 * @param flag the flag of interest
 * @return Boolean(true) if the key event has the requested flag
 * Boolean(false) if the key event does not have the requested flag
 * null if the flag value could not be checked
 *
 * @see KeyEvent#getFlags()
 * @see KeyEvent#FLAG_CANCELED
 */

Body of Frist Method:
{
    switch(flag) {
        // These values must be kept in sync with Input.cpp
        case FLAG_CANCELED:
            return (mFlags & flag) != 0;
    }
    return null;
}
Body of Second Method:
{
    switch(flag) {
        // These values must be kept in sync with Input.cpp
        case FLAG_CANCELED:
        case FLAG_IS_ACCESSIBILITY_EVENT:
            return (mFlags & flag) != 0;
    }
    return null;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.disconnect:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Disconnects remote device
 *
 * @param device a remote device we want disconnect
 * @return <code>true</code> if command has been issued successfully; <code>false</code>
 * otherwise; upon completion HFP sends {@link #ACTION_CONNECTION_STATE_CHANGED} intent.
 *
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("disconnect(" + device + ")");
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.disconnect(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("disconnect(" + device + ")");
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.disconnect(device, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.media.audiopolicy.AudioMixingRule.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Combines all of the matching and exclusion rules that have been set and return a new
 * {@link AudioMixingRule} object.
 * @return a new {@link AudioMixingRule} object
 */

Body of Frist Method:
{
    return new AudioMixingRule(mTargetMixType, mCriteria, mAllowPrivilegedPlaybackCapture, mVoiceCommunicationCaptureAllowed);
}
Body of Second Method:
{
    return new AudioMixingRule(mTargetMixType, mCriteria, mAllowPrivilegedMediaPlaybackCapture, mVoiceCommunicationCaptureAllowed);
}
------------------------
Find a silently evolved API code:android.app.admin.DeviceAdminReceiver.onUserAdded:COMMENT
Method Modifier: public      
Comment:/**
 * Called when a user or profile is created.
 *
 * <p>This callback is only applicable to device owners.
 *
 * @param context The running context as per {@link #onReceive}.
 * @param intent The received intent as per {@link #onReceive}.
 * @param addedUser The {@link UserHandle} of the user that has just been added.
 */

Body of Frist Method:
{
}
Body of Second Method:
{
    if (LOCAL_LOGV) {
        Log.v(TAG, getClass().getName() + ".onUserAdded() on user " + context.getUserId());
    }
}
------------------------
Find a silently evolved API code:android.content.pm.ActivityInfo.lockTaskLaunchModeToString:COMMENT
Method Modifier: public      static      final       hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    switch(lockTaskLaunchMode) {
        case LOCK_TASK_LAUNCH_MODE_DEFAULT:
            return "LOCK_TASK_LAUNCH_MODE_DEFAULT";
        case LOCK_TASK_LAUNCH_MODE_NEVER:
            return "LOCK_TASK_LAUNCH_MODE_NEVER";
        case LOCK_TASK_LAUNCH_MODE_ALWAYS:
            return "LOCK_TASK_LAUNCH_MODE_ALWAYS";
        case LOCK_TASK_LAUNCH_MODE_IF_WHITELISTED:
            return "LOCK_TASK_LAUNCH_MODE_IF_WHITELISTED";
        default:
            return "unknown=" + lockTaskLaunchMode;
    }
}
Body of Second Method:
{
    switch(lockTaskLaunchMode) {
        case LOCK_TASK_LAUNCH_MODE_DEFAULT:
            return "LOCK_TASK_LAUNCH_MODE_DEFAULT";
        case LOCK_TASK_LAUNCH_MODE_NEVER:
            return "LOCK_TASK_LAUNCH_MODE_NEVER";
        case LOCK_TASK_LAUNCH_MODE_ALWAYS:
            return "LOCK_TASK_LAUNCH_MODE_ALWAYS";
        case LOCK_TASK_LAUNCH_MODE_IF_ALLOWLISTED:
            return "LOCK_TASK_LAUNCH_MODE_IF_ALLOWLISTED";
        default:
            return "unknown=" + lockTaskLaunchMode;
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothDevice.setPhonebookAccessPermission:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets whether the phonebook access is allowed to this device.
 *
 * @param value Can be {@link #ACCESS_UNKNOWN}, {@link #ACCESS_ALLOWED} or {@link
 * #ACCESS_REJECTED}.
 * @return Whether the value has been successfully set.
 * @hide
 */

Body of Frist Method:
{
    final IBluetooth service = sService;
    if (service == null) {
        return false;
    }
    try {
        return service.setPhonebookAccessPermission(this, value);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
Body of Second Method:
{
    final IBluetooth service = sService;
    if (service == null) {
        return false;
    }
    try {
        return service.setPhonebookAccessPermission(this, value, mAttributionSource);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
------------------------
Find a silently evolved API code:android.media.soundtrigger.SoundTriggerDetector.stopRecognition:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Stops recognition for the associated model.
 */

Body of Frist Method:
{
    int status = STATUS_OK;
    try {
        status = mSoundTriggerService.stopRecognition(new ParcelUuid(mSoundModelId), mRecognitionCallback);
    } catch (RemoteException e) {
        return false;
    }
    return status == STATUS_OK;
}
Body of Second Method:
{
    int status = STATUS_OK;
    try {
        status = mSoundTriggerSession.stopRecognition(new ParcelUuid(mSoundModelId), mRecognitionCallback);
    } catch (RemoteException e) {
        return false;
    }
    return status == STATUS_OK;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.enterPrivateMode:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Enters private mode with a specified call.
 *
 * Works only when Extended Call Control is supported by Audio Gateway.
 *
 * @param device remote device
 * @param index index of the call to connect in private mode
 * @return <code>true</code> if command has been issued successfully; <code>false</code>
 * otherwise; upon completion HFP sends {@link #ACTION_CALL_CHANGED} intent.
 *
 * <p>Feature required for successful execution is being reported by: {@link
 * #EXTRA_AG_FEATURE_ECC}. This method invocation will fail silently when feature is not
 * supported.</p>
 */

Body of Frist Method:
{
    if (DBG)
        log("enterPrivateMode()");
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.enterPrivateMode(device, index);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("enterPrivateMode()");
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.enterPrivateMode(device, index, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadset.getAudioRouteAllowed:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns whether audio routing is allowed. see {@link #setAudioRouteAllowed(boolean)}.
 * Note: This is an internal function and shouldn't be exposed
 *
 * @hide
 */

Body of Frist Method:
{
    if (VDBG)
        log("getAudioRouteAllowed");
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.getAudioRouteAllowed();
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return false;
}
Body of Second Method:
{
    if (VDBG)
        log("getAudioRouteAllowed");
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.getAudioRouteAllowed(mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return false;
}
------------------------
Find a silently evolved API code:android.content.pm.ShortcutManager.enableShortcuts:COMMENT
Method Modifier: public      
Comment:/**
 * Re-enable pinned shortcuts that were previously disabled.  If the target shortcuts
 * are already enabled, this method does nothing.
 *
 * @throws IllegalArgumentException If trying to enable immutable shortcuts.
 *
 * @throws IllegalStateException when the user is locked.
 */

Body of Frist Method:
{
    try {
        mService.enableShortcuts(mContext.getPackageName(), shortcutIds, injectMyUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    try {
        getFutureOrThrow(mService.enableShortcuts(mContext.getPackageName(), shortcutIds, injectMyUserId()));
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.hardware.lights.LightsManager.getLights:COMMENT
<android.hardware.lights.LightsManager: List<Light> getLights()>
public      hidden      ->public      abstract    
Method Modifier: public      abstract    hidden      
Method Modifier: Yes         No          Yes         
Method Updated:  Yes         Yes         No          
Comment:/**
 * Returns the lights available on the device.
 *
 * @return A list of available lights
 */

Body of Frist Method:
{
    try {
        return mService.getLights();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:

------------------------
Find a silently evolved API code:android.widget.ProgressBar.onInitializeAccessibilityNodeInfoInternal:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    super.onInitializeAccessibilityNodeInfoInternal(info);
    if (!isIndeterminate()) {
        AccessibilityNodeInfo.RangeInfo rangeInfo = AccessibilityNodeInfo.RangeInfo.obtain(AccessibilityNodeInfo.RangeInfo.RANGE_TYPE_INT, getMin(), getMax(), getProgress());
        info.setRangeInfo(rangeInfo);
    }
}
Body of Second Method:
{
    super.onInitializeAccessibilityNodeInfoInternal(info);
    if (!isIndeterminate()) {
        AccessibilityNodeInfo.RangeInfo rangeInfo = AccessibilityNodeInfo.RangeInfo.obtain(AccessibilityNodeInfo.RangeInfo.RANGE_TYPE_INT, getMin(), getMax(), getProgress());
        info.setRangeInfo(rangeInfo);
        info.setStateDescription(formatStateDescription(mProgress));
    }
}
------------------------
Find a silently evolved API code:android.service.autofill.Validators.not:COMMENT
Method Modifier: public      static      
Comment:/**
 * Creates a validator that is valid when {@code validator} is not, and vice versa.
 *
 * <p>Used to represent a {@code NOT} boolean operation in a chain of validators.
 *
 * @throws IllegalArgumentException if {@code validator} is an instance of a class that is not
 * provided by the Android System.
 */

Body of Frist Method:
{
    Preconditions.checkArgument(validator instanceof InternalValidator, "validator not provided by Android System: " + validator);
    return new NegationValidator((InternalValidator) validator);
}
Body of Second Method:
{
    Preconditions.checkArgument(validator instanceof InternalValidator, "validator not provided by Android System: %s", validator);
    return new NegationValidator((InternalValidator) validator);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothMap.isConnected:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns true if the specified Bluetooth device is connected.
 * Returns false if not connected, or if this proxy object is not
 * currently connected to the Map service.
 *
 * @hide
 */

Body of Frist Method:
{
    if (VDBG)
        log("isConnected(" + device + ")");
    final IBluetoothMap service = getService();
    if (service != null) {
        try {
            return service.isConnected(device);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            log(Log.getStackTraceString(new Throwable()));
    }
    return false;
}
Body of Second Method:
{
    if (VDBG)
        log("isConnected(" + device + ")");
    final IBluetoothMap service = getService();
    if (service != null) {
        try {
            return service.isConnected(device, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            log(Log.getStackTraceString(new Throwable()));
    }
    return false;
}
------------------------
Find a silently evolved API code:android.media.AudioDeviceInfo.isValidAudioDeviceTypeIn:COMMENT
Method Modifier: default     static      
Comment:/*package*/

Body of Frist Method:
{
    switch(type) {
        case TYPE_BUILTIN_MIC:
        case TYPE_BLUETOOTH_SCO:
        case TYPE_BLUETOOTH_A2DP:
        case TYPE_WIRED_HEADSET:
        case TYPE_HDMI:
        case TYPE_TELEPHONY:
        case TYPE_DOCK:
        case TYPE_USB_ACCESSORY:
        case TYPE_USB_DEVICE:
        case TYPE_USB_HEADSET:
        case TYPE_FM_TUNER:
        case TYPE_TV_TUNER:
        case TYPE_LINE_ANALOG:
        case TYPE_LINE_DIGITAL:
        case TYPE_IP:
        case TYPE_BUS:
        case TYPE_REMOTE_SUBMIX:
            return true;
        default:
            return false;
    }
}
Body of Second Method:
{
    switch(type) {
        case TYPE_BUILTIN_MIC:
        case TYPE_BLUETOOTH_SCO:
        case TYPE_BLUETOOTH_A2DP:
        case TYPE_WIRED_HEADSET:
        case TYPE_HDMI:
        case TYPE_TELEPHONY:
        case TYPE_DOCK:
        case TYPE_USB_ACCESSORY:
        case TYPE_USB_DEVICE:
        case TYPE_USB_HEADSET:
        case TYPE_FM_TUNER:
        case TYPE_TV_TUNER:
        case TYPE_LINE_ANALOG:
        case TYPE_LINE_DIGITAL:
        case TYPE_IP:
        case TYPE_BUS:
        case TYPE_REMOTE_SUBMIX:
        case TYPE_BLE_HEADSET:
        case TYPE_HDMI_ARC:
        case TYPE_HDMI_EARC:
        case TYPE_ECHO_REFERENCE:
            return true;
        default:
            return false;
    }
}
------------------------
Find a silently evolved API code:android.graphics.ImageFormat.getBitsPerPixel:COMMENT
Method Modifier: public      static      
Comment:/**
 * Use this function to retrieve the number of bits per pixel of an
 * ImageFormat.
 *
 * @param format
 * @return the number of bits per pixel of the given format or -1 if the
 * format doesn't exist or is not supported.
 */

Body of Frist Method:
{
    switch(format) {
        case RGB_565:
            return 16;
        case NV16:
            return 16;
        case YUY2:
            return 16;
        case YV12:
            return 12;
        case Y8:
            return 8;
        case Y16:
        case DEPTH16:
            return 16;
        case NV21:
            return 12;
        case YUV_420_888:
            return 12;
        case YUV_422_888:
            return 16;
        case YUV_444_888:
            return 24;
        case FLEX_RGB_888:
            return 24;
        case FLEX_RGBA_8888:
            return 32;
        case RAW_DEPTH:
        case RAW_SENSOR:
            return 16;
        case RAW10:
            return 10;
        case RAW12:
            return 12;
    }
    return -1;
}
Body of Second Method:
{
    switch(format) {
        case RGB_565:
            return 16;
        case NV16:
            return 16;
        case YUY2:
            return 16;
        case YV12:
            return 12;
        case Y8:
            return 8;
        case Y16:
        case DEPTH16:
            return 16;
        case NV21:
            return 12;
        case YUV_420_888:
            return 12;
        case YUV_422_888:
            return 16;
        case YUV_444_888:
            return 24;
        case FLEX_RGB_888:
            return 24;
        case FLEX_RGBA_8888:
            return 32;
        case RAW_DEPTH:
        case RAW_SENSOR:
            return 16;
        case YCBCR_P010:
            return 20;
        case RAW_DEPTH10:
        case RAW10:
            return 10;
        case RAW12:
            return 12;
    }
    return -1;
}
------------------------
Find a silently evolved API code:android.view.contentcapture.ContentCaptureContext.dump:COMMENT
Method Modifier: public      
Comment:// TODO(b/111276913): dump to proto as well

Body of Frist Method:
{
    if (mComponentName != null) {
        pw.print("activity=");
        pw.print(mComponentName.flattenToShortString());
    }
    if (mId != null) {
        pw.print(", id=");
        mId.dump(pw);
    }
    pw.print(", taskId=");
    pw.print(mTaskId);
    pw.print(", displayId=");
    pw.print(mDisplayId);
    if (mParentSessionId != NO_SESSION_ID) {
        pw.print(", parentId=");
        pw.print(mParentSessionId);
    }
    if (mFlags > 0) {
        pw.print(", flags=");
        pw.print(mFlags);
    }
    if (mExtras != null) {
        // NOTE: cannot dump because it could contain PII
        pw.print(", hasExtras");
    }
}
Body of Second Method:
{
    if (mComponentName != null) {
        pw.print("activity=");
        pw.print(mComponentName.flattenToShortString());
    }
    if (mId != null) {
        pw.print(", id=");
        mId.dump(pw);
    }
    pw.print(", activityId=");
    pw.print(mActivityId);
    pw.print(", displayId=");
    pw.print(mDisplayId);
    if (mParentSessionId != NO_SESSION_ID) {
        pw.print(", parentId=");
        pw.print(mParentSessionId);
    }
    if (mFlags > 0) {
        pw.print(", flags=");
        pw.print(mFlags);
    }
    if (mExtras != null) {
        // NOTE: cannot dump because it could contain PII
        pw.print(", hasExtras");
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothAvrcpController.getPlayerSettings:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Gets the player application settings.
 *
 * @return the {@link BluetoothAvrcpPlayerSettings} or {@link null} if there is an error.
 */

Body of Frist Method:
{
    if (DBG)
        Log.d(TAG, "getPlayerSettings");
    BluetoothAvrcpPlayerSettings settings = null;
    final IBluetoothAvrcpController service = getService();
    if (service != null && isEnabled()) {
        try {
            settings = service.getPlayerSettings(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Error talking to BT service in getMetadata() " + e);
            return null;
        }
    }
    return settings;
}
Body of Second Method:
{
    if (DBG)
        Log.d(TAG, "getPlayerSettings");
    BluetoothAvrcpPlayerSettings settings = null;
    final IBluetoothAvrcpController service = getService();
    if (service != null && isEnabled()) {
        try {
            settings = service.getPlayerSettings(device, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, "Error talking to BT service in getMetadata() " + e);
            return null;
        }
    }
    return settings;
}
------------------------
Find a silently evolved API code:android.location.LocationProvider.requiresSatellite:COMMENT
<android.location.LocationProvider: boolean requiresSatellite()>
public      ->public      deprecated  
Method Modifier: public      deprecated  
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Returns true if the provider requires access to a
 * satellite-based positioning system (e.g., GPS), false
 * otherwise.
 */

Body of Frist Method:
{
    return mProperties.mRequiresSatellite;
}
Body of Second Method:
{
    if (mProperties == null) {
        return false;
    } else {
        return mProperties.hasSatelliteRequirement();
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothA2dp.getActiveDevice:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the connected device that is active.
 *
 * @return the connected device that is active or null if no device
 * is active
 * @hide
 */

Body of Frist Method:
{
    if (VDBG)
        log("getActiveDevice()");
    try {
        final IBluetoothA2dp service = getService();
        if (service != null && isEnabled()) {
            return service.getActiveDevice();
        }
        if (service == null)
            Log.w(TAG, "Proxy not attached to service");
        return null;
    } catch (RemoteException e) {
        Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
        return null;
    }
}
Body of Second Method:
{
    if (VDBG)
        log("getActiveDevice()");
    try {
        final IBluetoothA2dp service = getService();
        if (service != null && isEnabled()) {
            return Attributable.setAttributionSource(service.getActiveDevice(mAttributionSource), mAttributionSource);
        }
        if (service == null)
            Log.w(TAG, "Proxy not attached to service");
        return null;
    } catch (RemoteException e) {
        Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
        return null;
    }
}
------------------------
Find a silently evolved API code:android.telecom.PhoneAccount.capabilitiesToString:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Generates a string representation of a capabilities bitmask.
 *
 * @return String representation of the capabilities bitmask.
 * @hide
 */

Body of Frist Method:
{
    StringBuilder sb = new StringBuilder();
    if (hasCapabilities(CAPABILITY_SELF_MANAGED)) {
        sb.append("SelfManaged ");
    }
    if (hasCapabilities(CAPABILITY_SUPPORTS_VIDEO_CALLING)) {
        sb.append("SuppVideo ");
    }
    if (hasCapabilities(CAPABILITY_VIDEO_CALLING)) {
        sb.append("Video ");
    }
    if (hasCapabilities(CAPABILITY_VIDEO_CALLING_RELIES_ON_PRESENCE)) {
        sb.append("Presence ");
    }
    if (hasCapabilities(CAPABILITY_CALL_PROVIDER)) {
        sb.append("CallProvider ");
    }
    if (hasCapabilities(CAPABILITY_CALL_SUBJECT)) {
        sb.append("CallSubject ");
    }
    if (hasCapabilities(CAPABILITY_CONNECTION_MANAGER)) {
        sb.append("ConnectionMgr ");
    }
    if (hasCapabilities(CAPABILITY_EMERGENCY_CALLS_ONLY)) {
        sb.append("EmergOnly ");
    }
    if (hasCapabilities(CAPABILITY_MULTI_USER)) {
        sb.append("MultiUser ");
    }
    if (hasCapabilities(CAPABILITY_PLACE_EMERGENCY_CALLS)) {
        sb.append("PlaceEmerg ");
    }
    if (hasCapabilities(CAPABILITY_EMERGENCY_PREFERRED)) {
        sb.append("EmerPrefer ");
    }
    if (hasCapabilities(CAPABILITY_EMERGENCY_VIDEO_CALLING)) {
        sb.append("EmergVideo ");
    }
    if (hasCapabilities(CAPABILITY_SIM_SUBSCRIPTION)) {
        sb.append("SimSub ");
    }
    if (hasCapabilities(CAPABILITY_RTT)) {
        sb.append("Rtt");
    }
    if (hasCapabilities(CAPABILITY_ADHOC_CONFERENCE_CALLING)) {
        sb.append("AdhocConf");
    }
    return sb.toString();
}
Body of Second Method:
{
    StringBuilder sb = new StringBuilder();
    if (hasCapabilities(CAPABILITY_SELF_MANAGED)) {
        sb.append("SelfManaged ");
    }
    if (hasCapabilities(CAPABILITY_SUPPORTS_VIDEO_CALLING)) {
        sb.append("SuppVideo ");
    }
    if (hasCapabilities(CAPABILITY_VIDEO_CALLING)) {
        sb.append("Video ");
    }
    if (hasCapabilities(CAPABILITY_VIDEO_CALLING_RELIES_ON_PRESENCE)) {
        sb.append("Presence ");
    }
    if (hasCapabilities(CAPABILITY_CALL_PROVIDER)) {
        sb.append("CallProvider ");
    }
    if (hasCapabilities(CAPABILITY_CALL_SUBJECT)) {
        sb.append("CallSubject ");
    }
    if (hasCapabilities(CAPABILITY_CONNECTION_MANAGER)) {
        sb.append("ConnectionMgr ");
    }
    if (hasCapabilities(CAPABILITY_EMERGENCY_CALLS_ONLY)) {
        sb.append("EmergOnly ");
    }
    if (hasCapabilities(CAPABILITY_MULTI_USER)) {
        sb.append("MultiUser ");
    }
    if (hasCapabilities(CAPABILITY_PLACE_EMERGENCY_CALLS)) {
        sb.append("PlaceEmerg ");
    }
    if (hasCapabilities(CAPABILITY_EMERGENCY_PREFERRED)) {
        sb.append("EmerPrefer ");
    }
    if (hasCapabilities(CAPABILITY_EMERGENCY_VIDEO_CALLING)) {
        sb.append("EmergVideo ");
    }
    if (hasCapabilities(CAPABILITY_SIM_SUBSCRIPTION)) {
        sb.append("SimSub ");
    }
    if (hasCapabilities(CAPABILITY_RTT)) {
        sb.append("Rtt");
    }
    if (hasCapabilities(CAPABILITY_ADHOC_CONFERENCE_CALLING)) {
        sb.append("AdhocConf");
    }
    if (hasCapabilities(CAPABILITY_CALL_COMPOSER)) {
        sb.append("CallComposer ");
    }
    return sb.toString();
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothGatt.unregisterApp:COMMENT
Method Modifier: private     
Comment:/**
 * Unregister the current application and callbacks.
 */

Body of Frist Method:
{
    if (DBG)
        Log.d(TAG, "unregisterApp() - mClientIf=" + mClientIf);
    if (mService == null || mClientIf == 0)
        return;
    try {
        mCallback = null;
        mService.unregisterClient(mClientIf);
        mClientIf = 0;
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
}
Body of Second Method:
{
    if (DBG)
        Log.d(TAG, "unregisterApp() - mClientIf=" + mClientIf);
    if (mService == null || mClientIf == 0)
        return;
    try {
        mCallback = null;
        mService.unregisterClient(mClientIf, mAttributionSource);
        mClientIf = 0;
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothPan.getConnectionState:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * {@inheritDoc}
 * @hide
 */

Body of Frist Method:
{
    if (VDBG)
        log("getState(" + device + ")");
    final IBluetoothPan service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getConnectionState(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.STATE_DISCONNECTED;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return BluetoothProfile.STATE_DISCONNECTED;
}
Body of Second Method:
{
    if (VDBG)
        log("getState(" + device + ")");
    final IBluetoothPan service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getConnectionState(device, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.STATE_DISCONNECTED;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return BluetoothProfile.STATE_DISCONNECTED;
}
------------------------
Find a silently evolved API code:android.bluetooth.le.AdvertisingSet.setPeriodicAdvertisingParameters:COMMENT
Method Modifier: public      
Comment:/**
 * Update periodic advertising parameters associated with this set. Must be called when
 * periodic advertising is not enabled. This method returns immediately, the operation
 * status is delivered through {@code callback.onPeriodicAdvertisingParametersUpdated()}.
 */

Body of Frist Method:
{
    try {
        mGatt.setPeriodicAdvertisingParameters(mAdvertiserId, parameters);
    } catch (RemoteException e) {
        Log.e(TAG, "remote exception - ", e);
    }
}
Body of Second Method:
{
    try {
        mGatt.setPeriodicAdvertisingParameters(mAdvertiserId, parameters, mAttributionSource);
    } catch (RemoteException e) {
        Log.e(TAG, "remote exception - ", e);
    }
}
------------------------
Find a silently evolved API code:android.media.PlayerBase.baseRegisterPlayer:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * Call from derived class when instantiation / initialization is successful
 */

Body of Frist Method:
{
    if (!USE_AUDIOFLINGER_MUTING_FOR_OP) {
        IBinder b = ServiceManager.getService(Context.APP_OPS_SERVICE);
        mAppOps = IAppOpsService.Stub.asInterface(b);
        // initialize mHasAppOpsPlayAudio
        updateAppOpsPlayAudio();
        // register a callback to monitor whether the OP_PLAY_AUDIO is still allowed
        mAppOpsCallback = new IAppOpsCallbackWrapper(this);
        try {
            mAppOps.startWatchingMode(AppOpsManager.OP_PLAY_AUDIO, ActivityThread.currentPackageName(), mAppOpsCallback);
        } catch (RemoteException e) {
            Log.e(TAG, "Error registering appOps callback", e);
            mHasAppOpsPlayAudio = false;
        }
    }
    try {
        mPlayerIId = getService().trackPlayer(new PlayerIdCard(mImplType, mAttributes, new IPlayerWrapper(this)));
    } catch (RemoteException e) {
        Log.e(TAG, "Error talking to audio service, player will not be tracked", e);
    }
}
Body of Second Method:
{
    try {
        mPlayerIId = getService().trackPlayer(new PlayerIdCard(mImplType, mAttributes, new IPlayerWrapper(this), sessionId));
    } catch (RemoteException e) {
        Log.e(TAG, "Error talking to audio service, player will not be tracked", e);
    }
}
------------------------
Find a silently evolved API code:android.graphics.PathMeasure.getMatrix:COMMENT
Method Modifier: public      
Comment:/**
 * Pins distance to 0 <= distance <= getLength(), and then computes the
 * corresponding matrix. Returns false if there is no path, or a zero-length
 * path was specified, in which case matrix is unchanged.
 *
 * @param distance The distance along the associated path
 * @param matrix Allocated by the caller, this is set to the transformation
 * associated with the position and tangent at the specified distance
 * @param flags Specified what aspects should be returned in the matrix.
 */

Body of Frist Method:
{
    return native_getMatrix(native_instance, distance, matrix.native_instance, flags);
}
Body of Second Method:
{
    return native_getMatrix(native_instance, distance, matrix.ni(), flags);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothSap.isConnected:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns true if the specified Bluetooth device is connected.
 * Returns false if not connected, or if this proxy object is not
 * currently connected to the Sap service.
 *
 * @hide
 */

Body of Frist Method:
{
    if (VDBG)
        log("isConnected(" + device + ")");
    final IBluetoothSap service = getService();
    if (service != null) {
        try {
            return service.isConnected(device);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            log(Log.getStackTraceString(new Throwable()));
    }
    return false;
}
Body of Second Method:
{
    if (VDBG)
        log("isConnected(" + device + ")");
    final IBluetoothSap service = getService();
    if (service != null) {
        try {
            return service.isConnected(device, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            log(Log.getStackTraceString(new Throwable()));
    }
    return false;
}
------------------------
Find a silently evolved API code:android.view.ImeInsetsSourceConsumer.notifyHidden:COMMENT
Method Modifier: default     hidden      
Comment:/**
 * Notify {@link InputMethodService} that IME window is hidden.
 */

Body of Frist Method:
{
    getImm().notifyImeHidden(mController.getHost().getWindowToken());
}
Body of Second Method:
{
    getImm().notifyImeHidden(mController.getHost().getWindowToken());
    Trace.asyncTraceEnd(TRACE_TAG_VIEW, "IC.hideRequestFromApi", 0);
}
------------------------
Find a silently evolved API code:android.net.Proxy.setHttpProxySystemProperty:COMMENT
<android.net.Proxy: void setHttpProxySystemProperty(ProxyInfo)>
public      static      final       hidden      ->public      static      hidden      deprecated  
Method Modifier: public      static      final       hidden      deprecated  
Method Modifier: Yes         Yes         Yes         Yes         No          
Method Updated:  Yes         Yes         No          Yes         Yes         
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    String host = null;
    String port = null;
    String exclList = null;
    Uri pacFileUrl = Uri.EMPTY;
    if (p != null) {
        host = p.getHost();
        port = Integer.toString(p.getPort());
        exclList = p.getExclusionListAsString();
        pacFileUrl = p.getPacFileUrl();
    }
    setHttpProxySystemProperty(host, port, exclList, pacFileUrl);
}
Body of Second Method:
{
    setHttpProxyConfiguration(p);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothSap.getDevicesMatchingConnectionStates:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the list of devices matching specified states. Currently at most one.
 *
 * @return list of matching devices
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("getDevicesMatchingStates()");
    final IBluetoothSap service = getService();
    if (service != null && isEnabled()) {
        try {
            return service.getDevicesMatchingConnectionStates(states);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
Body of Second Method:
{
    if (DBG)
        log("getDevicesMatchingStates()");
    final IBluetoothSap service = getService();
    if (service != null && isEnabled()) {
        try {
            return Attributable.setAttributionSource(service.getDevicesMatchingConnectionStates(states, mAttributionSource), mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
------------------------
Find a silently evolved API code:android.text.TextUtils.trimToLengthWithEllipsis:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Trims the {@code text} to the first {@code size} characters and adds an ellipsis if the
 * resulting string is shorter than the input. This will result in an output string which is
 * longer than {@code size} for most inputs.
 *
 * @param size length of the result, should be greater than 0
 *
 * @hide
 */

Body of Frist Method:
{
    T trimmed = trimToSize(text, size);
    if (trimmed.length() < text.length()) {
        trimmed = (T) (trimmed.toString() + "...");
    }
    return trimmed;
}
Body of Second Method:
{
    T trimmed = trimToSize(text, size);
    if (text != null && trimmed.length() < text.length()) {
        trimmed = (T) (trimmed.toString() + "...");
    }
    return trimmed;
}
------------------------
Find a silently evolved API code:android.timezone.TelephonyNetworkFinder.findNetworkByMccMnc:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns information held about a specific MCC + MNC combination. It is expected for this
 * method to return {@code null}. Only known, unusual networks will typically have information
 * returned, e.g. if they operate in countries other than the one suggested by their MCC.
 */

Body of Frist Method:
{
    Objects.requireNonNull(mcc);
    Objects.requireNonNull(mnc);
    libcore.timezone.TelephonyNetwork telephonyNetworkDelegate = mDelegate.findNetworkByMccMnc(mcc, mnc);
    return telephonyNetworkDelegate != null ? new TelephonyNetwork(telephonyNetworkDelegate) : null;
}
Body of Second Method:
{
    Objects.requireNonNull(mcc);
    Objects.requireNonNull(mnc);
    com.android.i18n.timezone.TelephonyNetwork telephonyNetworkDelegate = mDelegate.findNetworkByMccMnc(mcc, mnc);
    return telephonyNetworkDelegate != null ? new TelephonyNetwork(telephonyNetworkDelegate) : null;
}
------------------------
Find a silently evolved API code:android.media.AudioFormat.toLogFriendlyEncoding:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    switch(enc) {
        case ENCODING_INVALID:
            return "ENCODING_INVALID";
        case ENCODING_PCM_16BIT:
            return "ENCODING_PCM_16BIT";
        case ENCODING_PCM_8BIT:
            return "ENCODING_PCM_8BIT";
        case ENCODING_PCM_FLOAT:
            return "ENCODING_PCM_FLOAT";
        case ENCODING_AC3:
            return "ENCODING_AC3";
        case ENCODING_E_AC3:
            return "ENCODING_E_AC3";
        case ENCODING_DTS:
            return "ENCODING_DTS";
        case ENCODING_DTS_HD:
            return "ENCODING_DTS_HD";
        case ENCODING_MP3:
            return "ENCODING_MP3";
        case ENCODING_AAC_LC:
            return "ENCODING_AAC_LC";
        case ENCODING_AAC_HE_V1:
            return "ENCODING_AAC_HE_V1";
        case ENCODING_AAC_HE_V2:
            return "ENCODING_AAC_HE_V2";
        case ENCODING_IEC61937:
            return "ENCODING_IEC61937";
        case ENCODING_DOLBY_TRUEHD:
            return "ENCODING_DOLBY_TRUEHD";
        case ENCODING_AAC_ELD:
            return "ENCODING_AAC_ELD";
        case ENCODING_AAC_XHE:
            return "ENCODING_AAC_XHE";
        case ENCODING_AC4:
            return "ENCODING_AC4";
        case ENCODING_E_AC3_JOC:
            return "ENCODING_E_AC3_JOC";
        case ENCODING_DOLBY_MAT:
            return "ENCODING_DOLBY_MAT";
        case ENCODING_OPUS:
            return "ENCODING_OPUS";
        default:
            return "invalid encoding " + enc;
    }
}
Body of Second Method:
{
    switch(enc) {
        case ENCODING_INVALID:
            return "ENCODING_INVALID";
        case ENCODING_PCM_16BIT:
            return "ENCODING_PCM_16BIT";
        case ENCODING_PCM_8BIT:
            return "ENCODING_PCM_8BIT";
        case ENCODING_PCM_FLOAT:
            return "ENCODING_PCM_FLOAT";
        case ENCODING_AC3:
            return "ENCODING_AC3";
        case ENCODING_E_AC3:
            return "ENCODING_E_AC3";
        case ENCODING_DTS:
            return "ENCODING_DTS";
        case ENCODING_DTS_HD:
            return "ENCODING_DTS_HD";
        case ENCODING_MP3:
            return "ENCODING_MP3";
        case ENCODING_AAC_LC:
            return "ENCODING_AAC_LC";
        case ENCODING_AAC_HE_V1:
            return "ENCODING_AAC_HE_V1";
        case ENCODING_AAC_HE_V2:
            return "ENCODING_AAC_HE_V2";
        case ENCODING_IEC61937:
            return "ENCODING_IEC61937";
        case ENCODING_DOLBY_TRUEHD:
            return "ENCODING_DOLBY_TRUEHD";
        case ENCODING_AAC_ELD:
            return "ENCODING_AAC_ELD";
        case ENCODING_AAC_XHE:
            return "ENCODING_AAC_XHE";
        case ENCODING_AC4:
            return "ENCODING_AC4";
        case ENCODING_E_AC3_JOC:
            return "ENCODING_E_AC3_JOC";
        case ENCODING_DOLBY_MAT:
            return "ENCODING_DOLBY_MAT";
        case ENCODING_OPUS:
            return "ENCODING_OPUS";
        case ENCODING_PCM_24BIT_PACKED:
            return "ENCODING_PCM_24BIT_PACKED";
        case ENCODING_PCM_32BIT:
            return "ENCODING_PCM_32BIT";
        case ENCODING_MPEGH_BL_L3:
            return "ENCODING_MPEGH_BL_L3";
        case ENCODING_MPEGH_BL_L4:
            return "ENCODING_MPEGH_BL_L4";
        case ENCODING_MPEGH_LC_L3:
            return "ENCODING_MPEGH_LC_L3";
        case ENCODING_MPEGH_LC_L4:
            return "ENCODING_MPEGH_LC_L4";
        case ENCODING_DTS_UHD:
            return "ENCODING_DTS_UHD";
        case ENCODING_DRA:
            return "ENCODING_DRA";
        default:
            return "invalid encoding " + enc;
    }
}
------------------------
Find a silently evolved API code:android.graphics.drawable.Icon.loadDrawableInner:COMMENT
Method Modifier: private     
Comment:/**
 * Do the heavy lifting of loading the drawable, but stop short of applying any tint.
 */

Body of Frist Method:
{
    switch(mType) {
        case TYPE_BITMAP:
            return new BitmapDrawable(context.getResources(), getBitmap());
        case TYPE_ADAPTIVE_BITMAP:
            return new AdaptiveIconDrawable(null, new BitmapDrawable(context.getResources(), getBitmap()));
        case TYPE_RESOURCE:
            if (getResources() == null) {
                // figure out where to load resources from
                String resPackage = getResPackage();
                if (TextUtils.isEmpty(resPackage)) {
                    // if none is specified, try the given context
                    resPackage = context.getPackageName();
                }
                if ("android".equals(resPackage)) {
                    mObj1 = Resources.getSystem();
                } else {
                    final PackageManager pm = context.getPackageManager();
                    try {
                        ApplicationInfo ai = pm.getApplicationInfo(resPackage, PackageManager.MATCH_UNINSTALLED_PACKAGES);
                        if (ai != null) {
                            mObj1 = pm.getResourcesForApplication(ai);
                        } else {
                            break;
                        }
                    } catch (PackageManager.NameNotFoundException e) {
                        Log.e(TAG, String.format("Unable to find pkg=%s for icon %s", resPackage, this), e);
                        break;
                    }
                }
            }
            try {
                return getResources().getDrawable(getResId(), context.getTheme());
            } catch (RuntimeException e) {
                Log.e(TAG, String.format("Unable to load resource 0x%08x from pkg=%s", getResId(), getResPackage()), e);
            }
            break;
        case TYPE_DATA:
            return new BitmapDrawable(context.getResources(), BitmapFactory.decodeByteArray(getDataBytes(), getDataOffset(), getDataLength()));
        case TYPE_URI:
            InputStream is = getUriInputStream(context);
            if (is != null) {
                return new BitmapDrawable(context.getResources(), BitmapFactory.decodeStream(is));
            }
            break;
        case TYPE_URI_ADAPTIVE_BITMAP:
            is = getUriInputStream(context);
            if (is != null) {
                return new AdaptiveIconDrawable(null, new BitmapDrawable(context.getResources(), BitmapFactory.decodeStream(is)));
            }
            break;
    }
    return null;
}
Body of Second Method:
{
    switch(mType) {
        case TYPE_BITMAP:
            return new BitmapDrawable(context.getResources(), getBitmap());
        case TYPE_ADAPTIVE_BITMAP:
            return new AdaptiveIconDrawable(null, new BitmapDrawable(context.getResources(), getBitmap()));
        case TYPE_RESOURCE:
            if (getResources() == null) {
                // figure out where to load resources from
                String resPackage = getResPackage();
                if (TextUtils.isEmpty(resPackage)) {
                    // if none is specified, try the given context
                    resPackage = context.getPackageName();
                }
                if ("android".equals(resPackage)) {
                    mObj1 = Resources.getSystem();
                } else {
                    final PackageManager pm = context.getPackageManager();
                    try {
                        ApplicationInfo ai = pm.getApplicationInfo(resPackage, PackageManager.MATCH_UNINSTALLED_PACKAGES | PackageManager.GET_SHARED_LIBRARY_FILES);
                        if (ai != null) {
                            mObj1 = pm.getResourcesForApplication(ai);
                        } else {
                            break;
                        }
                    } catch (PackageManager.NameNotFoundException e) {
                        Log.e(TAG, String.format("Unable to find pkg=%s for icon %s", resPackage, this), e);
                        break;
                    }
                }
            }
            try {
                return getResources().getDrawable(getResId(), context.getTheme());
            } catch (RuntimeException e) {
                Log.e(TAG, String.format("Unable to load resource 0x%08x from pkg=%s", getResId(), getResPackage()), e);
            }
            break;
        case TYPE_DATA:
            return new BitmapDrawable(context.getResources(), BitmapFactory.decodeByteArray(getDataBytes(), getDataOffset(), getDataLength()));
        case TYPE_URI:
            InputStream is = getUriInputStream(context);
            if (is != null) {
                return new BitmapDrawable(context.getResources(), BitmapFactory.decodeStream(is));
            }
            break;
        case TYPE_URI_ADAPTIVE_BITMAP:
            is = getUriInputStream(context);
            if (is != null) {
                return new AdaptiveIconDrawable(null, new BitmapDrawable(context.getResources(), BitmapFactory.decodeStream(is)));
            }
            break;
    }
    return null;
}
------------------------
Find a silently evolved API code:android.graphics.Canvas.concat:COMMENT
Method Modifier: public      
Comment:/**
 * Preconcat the current matrix with the specified matrix. If the specified
 * matrix is null, this method does nothing.
 *
 * @param matrix The matrix to preconcatenate with the current matrix
 */

Body of Frist Method:
{
    if (matrix != null)
        nConcat(mNativeCanvasWrapper, matrix.native_instance);
}
Body of Second Method:
{
    if (matrix != null)
        nConcat(mNativeCanvasWrapper, matrix.ni());
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothA2dp.getCodecStatus:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Gets the current codec status (configuration and capability).
 *
 * @param device the remote Bluetooth device. If null, use the current
 * active A2DP Bluetooth device.
 * @return the current codec status
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        Log.d(TAG, "getCodecStatus(" + device + ")");
    verifyDeviceNotNull(device, "getCodecStatus");
    try {
        final IBluetoothA2dp service = getService();
        if (service != null && isEnabled()) {
            return service.getCodecStatus(device);
        }
        if (service == null) {
            Log.w(TAG, "Proxy not attached to service");
        }
        return null;
    } catch (RemoteException e) {
        Log.e(TAG, "Error talking to BT service in getCodecStatus()", e);
        return null;
    }
}
Body of Second Method:
{
    if (DBG)
        Log.d(TAG, "getCodecStatus(" + device + ")");
    verifyDeviceNotNull(device, "getCodecStatus");
    try {
        final IBluetoothA2dp service = getService();
        if (service != null && isEnabled()) {
            return service.getCodecStatus(device, mAttributionSource);
        }
        if (service == null) {
            Log.w(TAG, "Proxy not attached to service");
        }
        return null;
    } catch (RemoteException e) {
        Log.e(TAG, "Error talking to BT service in getCodecStatus()", e);
        return null;
    }
}
------------------------
Find a silently evolved API code:android.service.controls.templates.ControlTemplate.createTemplateFromBundle:COMMENT
Method Modifier: default     static      hidden      
Comment:/**
 * @param bundle
 * @return
 * @hide
 */

Body of Frist Method:
{
    if (bundle == null) {
        Log.e(TAG, "Null bundle");
        return ERROR_TEMPLATE;
    }
    int type = bundle.getInt(KEY_TEMPLATE_TYPE, TYPE_ERROR);
    try {
        switch(type) {
            case TYPE_TOGGLE:
                return new ToggleTemplate(bundle);
            case TYPE_RANGE:
                return new RangeTemplate(bundle);
            case TYPE_TOGGLE_RANGE:
                return new ToggleRangeTemplate(bundle);
            case TYPE_TEMPERATURE:
                return new TemperatureControlTemplate(bundle);
            case TYPE_STATELESS:
                return new StatelessTemplate(bundle);
            case TYPE_NO_TEMPLATE:
                return NO_TEMPLATE;
            case TYPE_ERROR:
            default:
                return ERROR_TEMPLATE;
        }
    } catch (Exception e) {
        Log.e(TAG, "Error creating template", e);
        return ERROR_TEMPLATE;
    }
}
Body of Second Method:
{
    if (bundle == null) {
        Log.e(TAG, "Null bundle");
        return ERROR_TEMPLATE;
    }
    int type = bundle.getInt(KEY_TEMPLATE_TYPE, TYPE_ERROR);
    try {
        switch(type) {
            case TYPE_TOGGLE:
                return new ToggleTemplate(bundle);
            case TYPE_RANGE:
                return new RangeTemplate(bundle);
            case TYPE_THUMBNAIL:
                return new ThumbnailTemplate(bundle);
            case TYPE_TOGGLE_RANGE:
                return new ToggleRangeTemplate(bundle);
            case TYPE_TEMPERATURE:
                return new TemperatureControlTemplate(bundle);
            case TYPE_STATELESS:
                return new StatelessTemplate(bundle);
            case TYPE_NO_TEMPLATE:
                return NO_TEMPLATE;
            case TYPE_ERROR:
            default:
                return ERROR_TEMPLATE;
        }
    } catch (Exception e) {
        Log.e(TAG, "Error creating template", e);
        return ERROR_TEMPLATE;
    }
}
------------------------
Find a silently evolved API code:android.hardware.camera2.utils.SurfaceUtils.isSurfaceForPreview:COMMENT
Method Modifier: public      static      
Comment:/**
 * Check if a surface is for preview consumer based on consumer end point Gralloc usage flags.
 *
 * @param surface The surface to be checked.
 * @return true if the surface is for preview consumer, false otherwise.
 */

Body of Frist Method:
{
    return LegacyCameraDevice.isPreviewConsumer(surface);
}
Body of Second Method:
{
    checkNotNull(surface);
    long usageFlags = nativeDetectSurfaceUsageFlags(surface);
    long disallowedFlags = HardwareBuffer.USAGE_VIDEO_ENCODE | USAGE_RENDERSCRIPT | HardwareBuffer.USAGE_CPU_READ_OFTEN;
    long allowedFlags = HardwareBuffer.USAGE_GPU_SAMPLED_IMAGE | USAGE_HW_COMPOSER | HardwareBuffer.USAGE_GPU_COLOR_OUTPUT;
    boolean previewConsumer = ((usageFlags & disallowedFlags) == 0 && (usageFlags & allowedFlags) != 0);
    int surfaceFormat = getSurfaceFormat(surface);
    return previewConsumer;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothSap.setConnectionPolicy:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Set connection policy of the profile
 *
 * <p> The device should already be paired.
 * Connection policy can be one of {@link #CONNECTION_POLICY_ALLOWED},
 * {@link #CONNECTION_POLICY_FORBIDDEN}, {@link #CONNECTION_POLICY_UNKNOWN}
 *
 * @param device Paired bluetooth device
 * @param connectionPolicy is the connection policy to set to for this profile
 * @return true if connectionPolicy is set, false on error
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("setConnectionPolicy(" + device + ", " + connectionPolicy + ")");
    final IBluetoothSap service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        if (connectionPolicy != BluetoothProfile.CONNECTION_POLICY_FORBIDDEN && connectionPolicy != BluetoothProfile.CONNECTION_POLICY_ALLOWED) {
            return false;
        }
        try {
            return service.setConnectionPolicy(device, connectionPolicy);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("setConnectionPolicy(" + device + ", " + connectionPolicy + ")");
    final IBluetoothSap service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        if (connectionPolicy != BluetoothProfile.CONNECTION_POLICY_FORBIDDEN && connectionPolicy != BluetoothProfile.CONNECTION_POLICY_ALLOWED) {
            return false;
        }
        try {
            return service.setConnectionPolicy(device, connectionPolicy, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.security.ConfirmationPrompt.cancelPrompt:COMMENT
Method Modifier: public      
Comment:/**
 * Cancels a prompt currently being displayed.
 *
 * On success, the
 * {@link ConfirmationCallback#onCanceled onCanceled()} method on
 * the supplied callback object will be called asynchronously.
 *
 * @throws IllegalStateException if no prompt is currently being presented.
 */

Body of Frist Method:
{
    int responseCode = mKeyStore.cancelConfirmationPrompt(mCallbackBinder);
    if (responseCode == KeyStore.CONFIRMATIONUI_OK) {
        return;
    } else if (responseCode == KeyStore.CONFIRMATIONUI_OPERATION_PENDING) {
        throw new IllegalStateException();
    } else {
        // Unexpected error code.
        Log.w(TAG, "Unexpected responseCode=" + responseCode + " from cancelConfirmationPrompt() call.");
        throw new IllegalStateException();
    }
}
Body of Second Method:
{
    int responseCode = getService().cancelConfirmationPrompt(mConfirmationCallback);
    if (responseCode == AndroidProtectedConfirmation.ERROR_OK) {
        return;
    } else if (responseCode == AndroidProtectedConfirmation.ERROR_OPERATION_PENDING) {
        throw new IllegalStateException();
    } else {
        // Unexpected error code.
        Log.w(TAG, "Unexpected responseCode=" + responseCode + " from cancelConfirmationPrompt() call.");
        throw new IllegalStateException();
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothDevice.getMetadata:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get a keyed metadata for this {@link BluetoothDevice} as {@link String}
 *
 * @param key must be within the list of BluetoothDevice.METADATA_*
 * @return Metadata of the key as byte array, null on error or not found
 * @hide
 */

Body of Frist Method:
{
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, "Bluetooth is not enabled. Cannot get metadata");
        return null;
    }
    try {
        return service.getMetadata(this, key);
    } catch (RemoteException e) {
        Log.e(TAG, "getMetadata fail", e);
        return null;
    }
}
Body of Second Method:
{
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, "Bluetooth is not enabled. Cannot get metadata");
        return null;
    }
    try {
        return service.getMetadata(this, key, mAttributionSource);
    } catch (RemoteException e) {
        Log.e(TAG, "getMetadata fail", e);
        return null;
    }
}
------------------------
Find a silently evolved API code:android.view.contentcapture.ContentCaptureContext.getTaskId:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Gets the id of the {@link TaskInfo task} associated with this context.
 *
 * @hide
 */

Body of Frist Method:
{
    return mTaskId;
}
Body of Second Method:
{
    return mHasClientContext ? 0 : mActivityId.getTaskId();
}
------------------------
Find a silently evolved API code:android.telecom.CallRedirectionService.cancelCall:COMMENT
Method Modifier: public      final       
Comment:/**
 * The implemented {@link CallRedirectionService} calls this method to response a request
 * received via {@link #onPlaceCall(Uri, PhoneAccountHandle, boolean)} to inform Telecom that
 * an outgoing call should be canceled entirely.
 *
 * <p>This can only be called from implemented
 * {@link #onPlaceCall(Uri, PhoneAccountHandle, boolean)}. The response corresponds to the
 * latest request via {@link #onPlaceCall(Uri, PhoneAccountHandle, boolean)}.
 */

Body of Frist Method:
{
    try {
        mCallRedirectionAdapter.cancelCall();
    } catch (RemoteException e) {
        e.rethrowAsRuntimeException();
    }
}
Body of Second Method:
{
    try {
        if (mCallRedirectionAdapter == null) {
            throw new IllegalStateException("Can only be called from onPlaceCall.");
        }
        mCallRedirectionAdapter.cancelCall();
    } catch (RemoteException e) {
        e.rethrowAsRuntimeException();
    }
}
------------------------
Find a silently evolved API code:android.net.Uri.Part.fromDecoded:COMMENT
Method Modifier: default     static      
Comment:/**
 * Creates a part from the decoded string.
 *
 * @param decoded part string
 */

Body of Frist Method:
{
    return from(NOT_CACHED, decoded);
}
Body of Second Method:
{
    return from(NotCachedHolder.NOT_CACHED, decoded);
}
------------------------
Find a silently evolved API code:android.hardware.location.ContextHubIntentEvent.fromIntent:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Creates a ContextHubIntentEvent object from an Intent received through a PendingIntent
 * registered with {@link ContextHubManager.createClient(ContextHubInfo, PendingIntent, long)}.
 *
 * @param intent the Intent object from an Intent event
 * @return the ContextHubIntentEvent object describing the event
 *
 * @throws IllegalArgumentException if the Intent was not a valid intent
 */

Body of Frist Method:
{
    Objects.requireNonNull(intent, "Intent cannot be null");
    hasExtraOrThrow(intent, ContextHubManager.EXTRA_CONTEXT_HUB_INFO);
    ContextHubInfo info = intent.getParcelableExtra(ContextHubManager.EXTRA_CONTEXT_HUB_INFO);
    if (info == null) {
        throw new IllegalArgumentException("ContextHubInfo extra was null");
    }
    int eventType = getIntExtraOrThrow(intent, ContextHubManager.EXTRA_EVENT_TYPE);
    ContextHubIntentEvent event;
    switch(eventType) {
        case ContextHubManager.EVENT_NANOAPP_LOADED:
        case ContextHubManager.EVENT_NANOAPP_UNLOADED:
        case ContextHubManager.EVENT_NANOAPP_ENABLED:
        case ContextHubManager.EVENT_NANOAPP_DISABLED:
        case ContextHubManager.EVENT_NANOAPP_ABORTED:
        case // fall through
        ContextHubManager.EVENT_NANOAPP_MESSAGE:
            long nanoAppId = getLongExtraOrThrow(intent, ContextHubManager.EXTRA_NANOAPP_ID);
            if (eventType == ContextHubManager.EVENT_NANOAPP_MESSAGE) {
                hasExtraOrThrow(intent, ContextHubManager.EXTRA_MESSAGE);
                NanoAppMessage message = intent.getParcelableExtra(ContextHubManager.EXTRA_MESSAGE);
                if (message == null) {
                    throw new IllegalArgumentException("NanoAppMessage extra was null");
                }
                event = new ContextHubIntentEvent(info, eventType, nanoAppId, message);
            } else if (eventType == ContextHubManager.EVENT_NANOAPP_ABORTED) {
                int nanoAppAbortCode = getIntExtraOrThrow(intent, ContextHubManager.EXTRA_NANOAPP_ABORT_CODE);
                event = new ContextHubIntentEvent(info, eventType, nanoAppId, nanoAppAbortCode);
            } else {
                event = new ContextHubIntentEvent(info, eventType, nanoAppId);
            }
            break;
        case ContextHubManager.EVENT_HUB_RESET:
            event = new ContextHubIntentEvent(info, eventType);
            break;
        default:
            throw new IllegalArgumentException("Unknown intent event type " + eventType);
    }
    return event;
}
Body of Second Method:
{
    Objects.requireNonNull(intent, "Intent cannot be null");
    hasExtraOrThrow(intent, ContextHubManager.EXTRA_CONTEXT_HUB_INFO);
    ContextHubInfo info = intent.getParcelableExtra(ContextHubManager.EXTRA_CONTEXT_HUB_INFO);
    if (info == null) {
        throw new IllegalArgumentException("ContextHubInfo extra was null");
    }
    int eventType = getIntExtraOrThrow(intent, ContextHubManager.EXTRA_EVENT_TYPE);
    ContextHubIntentEvent event;
    switch(eventType) {
        case ContextHubManager.EVENT_NANOAPP_LOADED:
        case ContextHubManager.EVENT_NANOAPP_UNLOADED:
        case ContextHubManager.EVENT_NANOAPP_ENABLED:
        case ContextHubManager.EVENT_NANOAPP_DISABLED:
        case ContextHubManager.EVENT_NANOAPP_ABORTED:
        case ContextHubManager.EVENT_NANOAPP_MESSAGE:
        case // fall through
        ContextHubManager.EVENT_CLIENT_AUTHORIZATION:
            long nanoAppId = getLongExtraOrThrow(intent, ContextHubManager.EXTRA_NANOAPP_ID);
            if (eventType == ContextHubManager.EVENT_NANOAPP_MESSAGE) {
                hasExtraOrThrow(intent, ContextHubManager.EXTRA_MESSAGE);
                NanoAppMessage message = intent.getParcelableExtra(ContextHubManager.EXTRA_MESSAGE);
                if (message == null) {
                    throw new IllegalArgumentException("NanoAppMessage extra was null");
                }
                event = new ContextHubIntentEvent(info, eventType, nanoAppId, message);
            } else if (eventType == ContextHubManager.EVENT_NANOAPP_ABORTED) {
                int nanoAppAbortCode = getIntExtraOrThrow(intent, ContextHubManager.EXTRA_NANOAPP_ABORT_CODE);
                event = new ContextHubIntentEvent(info, eventType, nanoAppId, nanoAppAbortCode);
            } else if (eventType == ContextHubManager.EVENT_CLIENT_AUTHORIZATION) {
                int authState = getIntExtraOrThrow(intent, ContextHubManager.EXTRA_CLIENT_AUTHORIZATION_STATE);
                event = new ContextHubIntentEvent(info, eventType, nanoAppId, null, /* nanoAppMessage */
                -1, /* nanoAppAbortCode */
                authState);
            } else {
                event = new ContextHubIntentEvent(info, eventType, nanoAppId);
            }
            break;
        case ContextHubManager.EVENT_HUB_RESET:
            event = new ContextHubIntentEvent(info, eventType);
            break;
        default:
            throw new IllegalArgumentException("Unknown intent event type " + eventType);
    }
    return event;
}
------------------------
Find a silently evolved API code:android.bluetooth.le.AdvertisingSet.setScanResponseData:COMMENT
Method Modifier: public      
Comment:/**
 * Set/update scan response data. Make sure that data doesn't exceed the size limit for
 * specified AdvertisingSetParameters. This method returns immediately, the operation status
 * is delivered through {@code callback.onScanResponseDataSet()}.
 *
 * @param scanResponse Scan response associated with the advertisement data. Size must not
 * exceed {@link BluetoothAdapter#getLeMaximumAdvertisingDataLength}. If the update takes place
 * when the advertising set is enabled, the data can be maximum 251 bytes long.
 */

Body of Frist Method:
{
    try {
        mGatt.setScanResponseData(mAdvertiserId, scanResponse);
    } catch (RemoteException e) {
        Log.e(TAG, "remote exception - ", e);
    }
}
Body of Second Method:
{
    try {
        mGatt.setScanResponseData(mAdvertiserId, scanResponse, mAttributionSource);
    } catch (RemoteException e) {
        Log.e(TAG, "remote exception - ", e);
    }
}
------------------------
Find a silently evolved API code:android.nfc.NfcAdapter.getAdapterState:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Return the state of this NFC Adapter.
 *
 * <p>Returns one of {@link #STATE_ON}, {@link #STATE_TURNING_ON},
 * {@link #STATE_OFF}, {@link #STATE_TURNING_OFF}.
 *
 * <p>{@link #isEnabled()} is equivalent to
 * <code>{@link #getAdapterState()} == {@link #STATE_ON}</code>
 *
 * @return the current state of this NFC adapter
 *
 * @hide
 */

Body of Frist Method:
{
    try {
        return sService.getState();
    } catch (RemoteException e) {
        attemptDeadServiceRecovery(e);
        return NfcAdapter.STATE_OFF;
    }
}
Body of Second Method:
{
    try {
        return sService.getState();
    } catch (RemoteException e) {
        attemptDeadServiceRecovery(e);
        // Try one more time
        if (sService == null) {
            Log.e(TAG, "Failed to recover NFC Service.");
            return NfcAdapter.STATE_OFF;
        }
        try {
            return sService.getState();
        } catch (RemoteException ee) {
            Log.e(TAG, "Failed to recover NFC Service.");
        }
        return NfcAdapter.STATE_OFF;
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothA2dp.setCodecConfigPreference:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets the codec configuration preference.
 *
 * @param device the remote Bluetooth device. If null, use the current
 * active A2DP Bluetooth device.
 * @param codecConfig the codec configuration preference
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        Log.d(TAG, "setCodecConfigPreference(" + device + ")");
    verifyDeviceNotNull(device, "setCodecConfigPreference");
    if (codecConfig == null) {
        Log.e(TAG, "setCodecConfigPreference: Codec config can't be null");
        throw new IllegalArgumentException("codecConfig cannot be null");
    }
    try {
        final IBluetoothA2dp service = getService();
        if (service != null && isEnabled()) {
            service.setCodecConfigPreference(device, codecConfig);
        }
        if (service == null)
            Log.w(TAG, "Proxy not attached to service");
        return;
    } catch (RemoteException e) {
        Log.e(TAG, "Error talking to BT service in setCodecConfigPreference()", e);
        return;
    }
}
Body of Second Method:
{
    if (DBG)
        Log.d(TAG, "setCodecConfigPreference(" + device + ")");
    verifyDeviceNotNull(device, "setCodecConfigPreference");
    if (codecConfig == null) {
        Log.e(TAG, "setCodecConfigPreference: Codec config can't be null");
        throw new IllegalArgumentException("codecConfig cannot be null");
    }
    try {
        final IBluetoothA2dp service = getService();
        if (service != null && isEnabled()) {
            service.setCodecConfigPreference(device, codecConfig, mAttributionSource);
        }
        if (service == null)
            Log.w(TAG, "Proxy not attached to service");
        return;
    } catch (RemoteException e) {
        Log.e(TAG, "Error talking to BT service in setCodecConfigPreference()", e);
        return;
    }
}
------------------------
Find a silently evolved API code:android.content.ContentProviderClient.call:COMMENT
Method Modifier: public      
Comment:/**
 * See {@link ContentProvider#call(String, String, Bundle)}
 */

Body of Frist Method:
{
    Objects.requireNonNull(authority, "authority");
    Objects.requireNonNull(method, "method");
    beforeRemote();
    try {
        return mContentProvider.call(mPackageName, mAttributionTag, authority, method, arg, extras);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}
Body of Second Method:
{
    Objects.requireNonNull(authority, "authority");
    Objects.requireNonNull(method, "method");
    beforeRemote();
    try {
        return mContentProvider.call(mAttributionSource, authority, method, arg, extras);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadset.connectAudio:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Initiates a connection of headset audio to the current active device
 *
 * <p> Users can listen to {@link #ACTION_AUDIO_STATE_CHANGED}.
 * If this function returns true, this intent will be broadcasted with
 * {@link #EXTRA_STATE} set to {@link #STATE_AUDIO_CONNECTING}.
 *
 * <p> {@link #EXTRA_STATE} will transition from
 * {@link #STATE_AUDIO_CONNECTING} to {@link #STATE_AUDIO_CONNECTED} when
 * audio connection is established and to {@link #STATE_AUDIO_DISCONNECTED}
 * in case of failure to establish the audio connection.
 *
 * Note that this intent will not be sent if {@link BluetoothHeadset#isAudioOn()} is true
 * before calling this method
 *
 * @return false if there was some error such as there is no active headset
 * @hide
 */

Body of Frist Method:
{
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.connectAudio();
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return false;
}
Body of Second Method:
{
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.connectAudio(mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return false;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadset.disconnectAudio:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Initiates a disconnection of HFP SCO audio.
 * Tear down voice recognition or virtual voice call if any.
 *
 * <p> Users can listen to {@link #ACTION_AUDIO_STATE_CHANGED}.
 * If this function returns true, this intent will be broadcasted with
 * {@link #EXTRA_STATE} set to {@link #STATE_AUDIO_DISCONNECTED}.
 *
 * @return false if audio is not connected, or on error, true otherwise
 * @hide
 */

Body of Frist Method:
{
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.disconnectAudio();
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return false;
}
Body of Second Method:
{
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.disconnectAudio(mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return false;
}
------------------------
Find a silently evolved API code:android.app.admin.SystemUpdateInfo.readFromXml:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    // If an OTA has been applied (build fingerprint has changed), discard stale info.
    final String buildFingerprint = parser.getAttributeValue(null, ATTR_ORIGINAL_BUILD);
    if (!Build.FINGERPRINT.equals(buildFingerprint)) {
        return null;
    }
    final long receivedTime = Long.parseLong(parser.getAttributeValue(null, ATTR_RECEIVED_TIME));
    final int securityPatchState = Integer.parseInt(parser.getAttributeValue(null, ATTR_SECURITY_PATCH_STATE));
    return new SystemUpdateInfo(receivedTime, securityPatchState);
}
Body of Second Method:
{
    // If an OTA has been applied (build fingerprint has changed), discard stale info.
    final String buildFingerprint = parser.getAttributeValue(null, ATTR_ORIGINAL_BUILD);
    if (!Build.FINGERPRINT.equals(buildFingerprint)) {
        return null;
    }
    try {
        final long receivedTime = parser.getAttributeLong(null, ATTR_RECEIVED_TIME);
        final int securityPatchState = parser.getAttributeInt(null, ATTR_SECURITY_PATCH_STATE);
        return new SystemUpdateInfo(receivedTime, securityPatchState);
    } catch (XmlPullParserException e) {
        Log.w(TAG, "Load xml failed", e);
        return null;
    }
}
------------------------
Find a silently evolved API code:android.content.rollback.PackageRollbackInfo.removePendingBackup:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    int idx = mPendingBackups.indexOf(userId);
    if (idx != -1) {
        mPendingBackups.remove(idx);
    }
}
Body of Second Method:
{
    mPendingBackups.remove((Integer) userId);
}
------------------------
Find a silently evolved API code:android.database.sqlite.SQLiteCursor.finalize:COMMENT
Method Modifier: protected   
Comment:/**
 * Release the native resources, if they haven't been released yet.
 */

Body of Frist Method:
{
    try {
        // if the cursor hasn't been closed yet, close it first
        if (mWindow != null) {
            if (mStackTrace != null) {
                String sql = mQuery.getSql();
                int len = sql.length();
                StrictMode.onSqliteObjectLeaked("Finalizing a Cursor that has not been deactivated or closed. " + "database = " + mQuery.getDatabase().getLabel() + ", table = " + mEditTable + ", query = " + sql.substring(0, (len > 1000) ? 1000 : len), mStackTrace);
            }
            close();
        }
    } finally {
        super.finalize();
    }
}
Body of Second Method:
{
    try {
        // if the cursor hasn't been closed yet, close it first
        if (mWindow != null) {
            // Report original sql statement
            if (StrictMode.vmSqliteObjectLeaksEnabled()) {
                String sql = mQuery.getSql();
                int len = sql.length();
                StrictMode.onSqliteObjectLeaked("Finalizing a Cursor that has not been deactivated or closed. " + "database = " + mQuery.getDatabase().getLabel() + ", table = " + mEditTable + ", query = " + sql.substring(0, (len > 1000) ? 1000 : len), null);
            }
        }
    } finally {
        super.finalize();
    }
}
------------------------
Find a silently evolved API code:android.timezone.TelephonyLookup.getInstance:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Obtains an instance for use when resolving telephony time zone information.
 */

Body of Frist Method:
{
    synchronized (sLock) {
        if (sInstance == null) {
            sInstance = new TelephonyLookup(libcore.timezone.TelephonyLookup.getInstance());
        }
        return sInstance;
    }
}
Body of Second Method:
{
    synchronized (sLock) {
        if (sInstance == null) {
            sInstance = new TelephonyLookup(com.android.i18n.timezone.TelephonyLookup.getInstance());
        }
        return sInstance;
    }
}
------------------------
Find a silently evolved API code:android.security.keystore.KeyProtection.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Builds an instance of {@link KeyProtection}.
 *
 * @throws IllegalArgumentException if a required field is missing
 */

Body of Frist Method:
{
    return new KeyProtection(mKeyValidityStart, mKeyValidityForOriginationEnd, mKeyValidityForConsumptionEnd, mPurposes, mEncryptionPaddings, mSignaturePaddings, mDigests, mBlockModes, mRandomizedEncryptionRequired, mUserAuthenticationRequired, mUserAuthenticationType, mUserAuthenticationValidityDurationSeconds, mUserPresenceRequired, mUserAuthenticationValidWhileOnBody, mInvalidatedByBiometricEnrollment, mBoundToSecureUserId, mCriticalToDeviceEncryption, mUserConfirmationRequired, mUnlockedDeviceRequired, mIsStrongBoxBacked);
}
Body of Second Method:
{
    return new KeyProtection(mKeyValidityStart, mKeyValidityForOriginationEnd, mKeyValidityForConsumptionEnd, mPurposes, mEncryptionPaddings, mSignaturePaddings, mDigests, mBlockModes, mRandomizedEncryptionRequired, mUserAuthenticationRequired, mUserAuthenticationType, mUserAuthenticationValidityDurationSeconds, mUserPresenceRequired, mUserAuthenticationValidWhileOnBody, mInvalidatedByBiometricEnrollment, mBoundToSecureUserId, mCriticalToDeviceEncryption, mUserConfirmationRequired, mUnlockedDeviceRequired, mIsStrongBoxBacked, mMaxUsageCount);
}
------------------------
Find a silently evolved API code:android.content.pm.ShortcutManager.getShareTargets:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Used by framework's ShareSheet (ChooserActivity.java) to retrieve all of the direct share
 * targets that match the given IntentFilter.
 *
 * @param filter IntentFilter that will be used to retrieve the matching {@link ShortcutInfo}s.
 * @return List of {@link ShareShortcutInfo}s that match the given IntentFilter.
 * @hide
 */

Body of Frist Method:
{
    try {
        return mService.getShareTargets(mContext.getPackageName(), filter, injectMyUserId()).getList();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    try {
        return getFutureOrThrow(mService.getShareTargets(mContext.getPackageName(), filter, injectMyUserId())).getList();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.disconnectAudio:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Disconnects audio channel.
 *
 * It tears down the SCO channel from remote AG device.
 *
 * @param device remote device
 * @return <code>true</code> if command has been issued successfully; <code>false</code>
 * otherwise; upon completion HFP sends {@link #ACTION_AUDIO_STATE_CHANGED} intent;
 */

Body of Frist Method:
{
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled()) {
        try {
            return service.disconnectAudio(device);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return false;
}
Body of Second Method:
{
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled()) {
        try {
            return service.disconnectAudio(device, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return false;
}
------------------------
Find a silently evolved API code:android.hardware.camera2.utils.SurfaceUtils.getSurfaceFormat:COMMENT
Method Modifier: public      static      
Comment:/**
 * Get the Surface format.
 *
 * @param surface The surface to be queried for format.
 * @return format of the surface.
 *
 * @throws IllegalArgumentException if the surface is already abandoned.
 */

Body of Frist Method:
{
    try {
        return LegacyCameraDevice.detectSurfaceType(surface);
    } catch (BufferQueueAbandonedException e) {
        throw new IllegalArgumentException("Surface was abandoned", e);
    }
}
Body of Second Method:
{
    checkNotNull(surface);
    int surfaceType = nativeDetectSurfaceType(surface);
    if (surfaceType == BAD_VALUE)
        throw new IllegalArgumentException("Surface was abandoned");
    // ImageFormat.PRIVATE. b/9487482
    if ((surfaceType >= PixelFormat.RGBA_8888 && surfaceType <= BGRA_8888)) {
        surfaceType = ImageFormat.PRIVATE;
    }
    return surfaceType;
}
------------------------
Find a silently evolved API code:android.widget.HorizontalScrollView.fling:COMMENT
Method Modifier: public      
Comment:/**
 * Fling the scroll view
 *
 * @param velocityX The initial velocity in the X direction. Positive
 * numbers mean that the finger/cursor is moving down the screen,
 * which means we want to scroll towards the left.
 */

Body of Frist Method:
{
    if (getChildCount() > 0) {
        int width = getWidth() - mPaddingRight - mPaddingLeft;
        int right = getChildAt(0).getWidth();
        mScroller.fling(mScrollX, mScrollY, velocityX, 0, 0, Math.max(0, right - width), 0, 0, width / 2, 0);
        final boolean movingRight = velocityX > 0;
        View currentFocused = findFocus();
        View newFocused = findFocusableViewInMyBounds(movingRight, mScroller.getFinalX(), currentFocused);
        if (newFocused == null) {
            newFocused = this;
        }
        if (newFocused != currentFocused) {
            newFocused.requestFocus(movingRight ? View.FOCUS_RIGHT : View.FOCUS_LEFT);
        }
        postInvalidateOnAnimation();
    }
}
Body of Second Method:
{
    if (getChildCount() > 0) {
        int width = getWidth() - mPaddingRight - mPaddingLeft;
        int right = getChildAt(0).getRight() - mPaddingLeft;
        int maxScroll = Math.max(0, right - width);
        if (mScrollX == 0 && !mEdgeGlowLeft.isFinished()) {
            mEdgeGlowLeft.onAbsorb(-velocityX);
        } else if (mScrollX == maxScroll && !mEdgeGlowRight.isFinished()) {
            mEdgeGlowRight.onAbsorb(velocityX);
        } else {
            mScroller.fling(mScrollX, mScrollY, velocityX, 0, 0, maxScroll, 0, 0, width / 2, 0);
            final boolean movingRight = velocityX > 0;
            View currentFocused = findFocus();
            View newFocused = findFocusableViewInMyBounds(movingRight, mScroller.getFinalX(), currentFocused);
            if (newFocused == null) {
                newFocused = this;
            }
            if (newFocused != currentFocused) {
                newFocused.requestFocus(movingRight ? View.FOCUS_RIGHT : View.FOCUS_LEFT);
            }
        }
        postInvalidateOnAnimation();
    }
}
------------------------
Find a silently evolved API code:android.media.AudioFormat.toDisplayName:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 *
 * Return default name for a surround format. This is not an International name.
 * It is just a default to use if an international name is not available.
 *
 * @param audioFormat a surround format
 * @return short default name for the format.
 */

Body of Frist Method:
{
    switch(audioFormat) {
        case ENCODING_AC3:
            return "Dolby Digital";
        case ENCODING_E_AC3:
            return "Dolby Digital Plus";
        case ENCODING_DTS:
            return "DTS";
        case ENCODING_DTS_HD:
            return "DTS HD";
        case ENCODING_AAC_LC:
            return "AAC";
        case ENCODING_DOLBY_TRUEHD:
            return "Dolby TrueHD";
        case ENCODING_AC4:
            return "Dolby AC-4";
        case ENCODING_E_AC3_JOC:
            return "Dolby Atmos in Dolby Digital Plus";
        case ENCODING_DOLBY_MAT:
            return "Dolby MAT";
        default:
            return "Unknown surround sound format";
    }
}
Body of Second Method:
{
    switch(audioFormat) {
        case ENCODING_AC3:
            return "Dolby Digital";
        case ENCODING_E_AC3:
            return "Dolby Digital Plus";
        case ENCODING_DTS:
            return "DTS";
        case ENCODING_DTS_HD:
            return "DTS HD";
        case ENCODING_AAC_LC:
            return "AAC";
        case ENCODING_DOLBY_TRUEHD:
            return "Dolby TrueHD";
        case ENCODING_AC4:
            return "Dolby AC-4";
        case ENCODING_E_AC3_JOC:
            return "Dolby Atmos in Dolby Digital Plus";
        case ENCODING_DOLBY_MAT:
            return "Dolby MAT";
        case ENCODING_MPEGH_BL_L3:
            return "MPEG-H 3D Audio baseline profile level 3";
        case ENCODING_MPEGH_BL_L4:
            return "MPEG-H 3D Audio baseline profile level 4";
        case ENCODING_MPEGH_LC_L3:
            return "MPEG-H 3D Audio low complexity profile level 3";
        case ENCODING_MPEGH_LC_L4:
            return "MPEG-H 3D Audio low complexity profile level 4";
        case ENCODING_DTS_UHD:
            return "DTS UHD";
        case ENCODING_DRA:
            return "DRA";
        default:
            return "Unknown surround sound format";
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothDevice.isEncrypted:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns whether there is an open connection to this device
 * that has been encrypted.
 *
 * @return True if there is at least one encrypted connection to this device.
 * @hide
 */

Body of Frist Method:
{
    final IBluetooth service = sService;
    if (service == null) {
        // BT is not enabled, we cannot be connected.
        return false;
    }
    try {
        return service.getConnectionState(this) > CONNECTION_STATE_CONNECTED;
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        return false;
    }
}
Body of Second Method:
{
    final IBluetooth service = sService;
    if (service == null) {
        // BT is not enabled, we cannot be connected.
        return false;
    }
    try {
        return service.getConnectionStateWithAttribution(this, mAttributionSource) > CONNECTION_STATE_CONNECTED;
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        return false;
    }
}
------------------------
Find a silently evolved API code:android.content.pm.ShortcutManager.removeLongLivedShortcuts:COMMENT
Method Modifier: public      
Comment:/**
 * Delete long lived shortcuts by ID.
 *
 * @throws IllegalStateException when the user is locked.
 */

Body of Frist Method:
{
    try {
        mService.removeLongLivedShortcuts(mContext.getPackageName(), shortcutIds, injectMyUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    try {
        getFutureOrThrow(mService.removeLongLivedShortcuts(mContext.getPackageName(), shortcutIds, injectMyUserId()));
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothPan.getDevicesMatchingConnectionStates:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * {@inheritDoc}
 * @hide
 */

Body of Frist Method:
{
    if (VDBG)
        log("getDevicesMatchingStates()");
    final IBluetoothPan service = getService();
    if (service != null && isEnabled()) {
        try {
            return service.getDevicesMatchingConnectionStates(states);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
Body of Second Method:
{
    if (VDBG)
        log("getDevicesMatchingStates()");
    final IBluetoothPan service = getService();
    if (service != null && isEnabled()) {
        try {
            return Attributable.setAttributionSource(service.getDevicesMatchingConnectionStates(states, mAttributionSource), mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
------------------------
Find a silently evolved API code:android.graphics.pdf.PdfRenderer.Page.render:COMMENT
Method Modifier: public      
Comment:/**
 * Renders a page to a bitmap.
 * <p>
 * You may optionally specify a rectangular clip in the bitmap bounds. No rendering
 * outside the clip will be performed, hence it is your responsibility to initialize
 * the bitmap outside the clip.
 * </p>
 * <p>
 * You may optionally specify a matrix to transform the content from page coordinates
 * which are in points (1/72") to bitmap coordinates which are in pixels. If this
 * matrix is not provided this method will apply a transformation that will fit the
 * whole page to the destination clip if provided or the destination bitmap if no
 * clip is provided.
 * </p>
 * <p>
 * The clip and transformation are useful for implementing tile rendering where the
 * destination bitmap contains a portion of the image, for example when zooming.
 * Another useful application is for printing where the size of the bitmap holding
 * the page is too large and a client can render the page in stripes.
 * </p>
 * <p>
 * <strong>Note: </strong> The destination bitmap format must be
 * {@link Config#ARGB_8888 ARGB}.
 * </p>
 * <p>
 * <strong>Note: </strong> The optional transformation matrix must be affine as per
 * {@link android.graphics.Matrix#isAffine() Matrix.isAffine()}. Hence, you can specify
 * rotation, scaling, translation but not a perspective transformation.
 * </p>
 *
 * @param destination Destination bitmap to which to render.
 * @param destClip Optional clip in the bitmap bounds.
 * @param transform Optional transformation to apply when rendering.
 * @param renderMode The render mode.
 *
 * @see #RENDER_MODE_FOR_DISPLAY
 * @see #RENDER_MODE_FOR_PRINT
 */

Body of Frist Method:
{
    if (mNativePage == 0) {
        throw new NullPointerException();
    }
    destination = Preconditions.checkNotNull(destination, "bitmap null");
    if (destination.getConfig() != Config.ARGB_8888) {
        throw new IllegalArgumentException("Unsupported pixel format");
    }
    if (destClip != null) {
        if (destClip.left < 0 || destClip.top < 0 || destClip.right > destination.getWidth() || destClip.bottom > destination.getHeight()) {
            throw new IllegalArgumentException("destBounds not in destination");
        }
    }
    if (transform != null && !transform.isAffine()) {
        throw new IllegalArgumentException("transform not affine");
    }
    if (renderMode != RENDER_MODE_FOR_PRINT && renderMode != RENDER_MODE_FOR_DISPLAY) {
        throw new IllegalArgumentException("Unsupported render mode");
    }
    if (renderMode == RENDER_MODE_FOR_PRINT && renderMode == RENDER_MODE_FOR_DISPLAY) {
        throw new IllegalArgumentException("Only single render mode supported");
    }
    final int contentLeft = (destClip != null) ? destClip.left : 0;
    final int contentTop = (destClip != null) ? destClip.top : 0;
    final int contentRight = (destClip != null) ? destClip.right : destination.getWidth();
    final int contentBottom = (destClip != null) ? destClip.bottom : destination.getHeight();
    // If transform is not set, stretch page to whole clipped area
    if (transform == null) {
        int clipWidth = contentRight - contentLeft;
        int clipHeight = contentBottom - contentTop;
        transform = new Matrix();
        transform.postScale((float) clipWidth / getWidth(), (float) clipHeight / getHeight());
        transform.postTranslate(contentLeft, contentTop);
    }
    final long transformPtr = transform.native_instance;
    synchronized (sPdfiumLock) {
        nativeRenderPage(mNativeDocument, mNativePage, destination.getNativeInstance(), contentLeft, contentTop, contentRight, contentBottom, transformPtr, renderMode);
    }
}
Body of Second Method:
{
    if (mNativePage == 0) {
        throw new NullPointerException();
    }
    destination = Preconditions.checkNotNull(destination, "bitmap null");
    if (destination.getConfig() != Config.ARGB_8888) {
        throw new IllegalArgumentException("Unsupported pixel format");
    }
    if (destClip != null) {
        if (destClip.left < 0 || destClip.top < 0 || destClip.right > destination.getWidth() || destClip.bottom > destination.getHeight()) {
            throw new IllegalArgumentException("destBounds not in destination");
        }
    }
    if (transform != null && !transform.isAffine()) {
        throw new IllegalArgumentException("transform not affine");
    }
    if (renderMode != RENDER_MODE_FOR_PRINT && renderMode != RENDER_MODE_FOR_DISPLAY) {
        throw new IllegalArgumentException("Unsupported render mode");
    }
    if (renderMode == RENDER_MODE_FOR_PRINT && renderMode == RENDER_MODE_FOR_DISPLAY) {
        throw new IllegalArgumentException("Only single render mode supported");
    }
    final int contentLeft = (destClip != null) ? destClip.left : 0;
    final int contentTop = (destClip != null) ? destClip.top : 0;
    final int contentRight = (destClip != null) ? destClip.right : destination.getWidth();
    final int contentBottom = (destClip != null) ? destClip.bottom : destination.getHeight();
    // If transform is not set, stretch page to whole clipped area
    if (transform == null) {
        int clipWidth = contentRight - contentLeft;
        int clipHeight = contentBottom - contentTop;
        transform = new Matrix();
        transform.postScale((float) clipWidth / getWidth(), (float) clipHeight / getHeight());
        transform.postTranslate(contentLeft, contentTop);
    }
    // FIXME: This code is planned to be outside the UI rendering module, so it should not
    // be able to access native instances from Bitmap, Matrix, etc.
    final long transformPtr = transform.ni();
    synchronized (sPdfiumLock) {
        nativeRenderPage(mNativeDocument, mNativePage, destination.getNativeInstance(), contentLeft, contentTop, contentRight, contentBottom, transformPtr, renderMode);
    }
}
------------------------
Find a silently evolved API code:android.service.contentcapture.ActivityEvent.getTypeAsString:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    switch(type) {
        case TYPE_ACTIVITY_RESUMED:
            return "ACTIVITY_RESUMED";
        case TYPE_ACTIVITY_PAUSED:
            return "ACTIVITY_PAUSED";
        case TYPE_ACTIVITY_STOPPED:
            return "ACTIVITY_STOPPED";
        case TYPE_ACTIVITY_DESTROYED:
            return "ACTIVITY_DESTROYED";
        default:
            return "UKNOWN_TYPE: " + type;
    }
}
Body of Second Method:
{
    switch(type) {
        case TYPE_ACTIVITY_RESUMED:
            return "ACTIVITY_RESUMED";
        case TYPE_ACTIVITY_PAUSED:
            return "ACTIVITY_PAUSED";
        case TYPE_ACTIVITY_STOPPED:
            return "ACTIVITY_STOPPED";
        case TYPE_ACTIVITY_DESTROYED:
            return "ACTIVITY_DESTROYED";
        case TYPE_ACTIVITY_STARTED:
            return "ACTIVITY_STARTED";
        default:
            return "UKNOWN_TYPE: " + type;
    }
}
------------------------
Find a silently evolved API code:android.app.backup.BackupManager.isBackupServiceActive:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Report whether the backup mechanism is currently active.
 * When it is inactive, the device will not perform any backup operations, nor will it
 * deliver data for restore, although clients can still safely call BackupManager methods.
 *
 * @hide
 */

Body of Frist Method:
{
    mContext.enforceCallingOrSelfPermission(android.Manifest.permission.BACKUP, "isBackupServiceActive");
    checkServiceBinder();
    if (sService != null) {
        try {
            return sService.isBackupServiceActive(user.getIdentifier());
        } catch (RemoteException e) {
            Log.e(TAG, "isBackupEnabled() couldn't connect");
        }
    }
    return false;
}
Body of Second Method:
{
    if (!CompatChanges.isChangeEnabled(IS_BACKUP_SERVICE_ACTIVE_ENFORCE_PERMISSION_IN_SERVICE)) {
        mContext.enforceCallingOrSelfPermission(android.Manifest.permission.BACKUP, "isBackupServiceActive");
    }
    checkServiceBinder();
    if (sService != null) {
        try {
            return sService.isBackupServiceActive(user.getIdentifier());
        } catch (RemoteException e) {
            Log.e(TAG, "isBackupEnabled() couldn't connect");
        }
    }
    return false;
}
------------------------
Find a silently evolved API code:android.telephony.CellSignalStrengthLte.setDefaultValues:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    mSignalStrength = CellInfo.UNAVAILABLE;
    mRssi = CellInfo.UNAVAILABLE;
    mRsrp = CellInfo.UNAVAILABLE;
    mRsrq = CellInfo.UNAVAILABLE;
    mRssnr = CellInfo.UNAVAILABLE;
    mCqi = CellInfo.UNAVAILABLE;
    mTimingAdvance = CellInfo.UNAVAILABLE;
    mLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    mParametersUseForLevel = USE_RSRP;
}
Body of Second Method:
{
    mSignalStrength = CellInfo.UNAVAILABLE;
    mRssi = CellInfo.UNAVAILABLE;
    mRsrp = CellInfo.UNAVAILABLE;
    mRsrq = CellInfo.UNAVAILABLE;
    mRssnr = CellInfo.UNAVAILABLE;
    mCqiTableIndex = CellInfo.UNAVAILABLE;
    mCqi = CellInfo.UNAVAILABLE;
    mTimingAdvance = CellInfo.UNAVAILABLE;
    mLevel = SIGNAL_STRENGTH_NONE_OR_UNKNOWN;
    mParametersUseForLevel = USE_RSRP;
}
------------------------
Find a silently evolved API code:android.os.PersistableBundle.writeToStream:COMMENT
Method Modifier: public      
Comment:/**
 * Writes the content of the {@link PersistableBundle} to a {@link OutputStream}.
 *
 * <p>The content can be read by a {@link #readFromStream}.
 *
 * @see #readFromStream
 */

Body of Frist Method:
{
    FastXmlSerializer serializer = new FastXmlSerializer();
    serializer.setOutput(outputStream, UTF_8.name());
    serializer.startTag(null, "bundle");
    try {
        saveToXml(serializer);
    } catch (XmlPullParserException e) {
        throw new IOException(e);
    }
    serializer.endTag(null, "bundle");
    serializer.flush();
}
Body of Second Method:
{
    TypedXmlSerializer serializer = Xml.newFastSerializer();
    serializer.setOutput(outputStream, UTF_8.name());
    serializer.startTag(null, "bundle");
    try {
        saveToXml(serializer);
    } catch (XmlPullParserException e) {
        throw new IOException(e);
    }
    serializer.endTag(null, "bundle");
    serializer.flush();
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothPan.setConnectionPolicy:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Set connection policy of the profile
 *
 * <p> The device should already be paired.
 * Connection policy can be one of {@link #CONNECTION_POLICY_ALLOWED},
 * {@link #CONNECTION_POLICY_FORBIDDEN}, {@link #CONNECTION_POLICY_UNKNOWN}
 *
 * @param device Paired bluetooth device
 * @param connectionPolicy is the connection policy to set to for this profile
 * @return true if connectionPolicy is set, false on error
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("setConnectionPolicy(" + device + ", " + connectionPolicy + ")");
    try {
        final IBluetoothPan service = getService();
        if (service != null && isEnabled() && isValidDevice(device)) {
            if (connectionPolicy != BluetoothProfile.CONNECTION_POLICY_FORBIDDEN && connectionPolicy != BluetoothProfile.CONNECTION_POLICY_ALLOWED) {
                return false;
            }
            return service.setConnectionPolicy(device, connectionPolicy);
        }
        if (service == null)
            Log.w(TAG, "Proxy not attached to service");
        return false;
    } catch (RemoteException e) {
        Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
        return false;
    }
}
Body of Second Method:
{
    if (DBG)
        log("setConnectionPolicy(" + device + ", " + connectionPolicy + ")");
    try {
        final IBluetoothPan service = getService();
        if (service != null && isEnabled() && isValidDevice(device)) {
            if (connectionPolicy != BluetoothProfile.CONNECTION_POLICY_FORBIDDEN && connectionPolicy != BluetoothProfile.CONNECTION_POLICY_ALLOWED) {
                return false;
            }
            return service.setConnectionPolicy(device, connectionPolicy, mAttributionSource);
        }
        if (service == null)
            Log.w(TAG, "Proxy not attached to service");
        return false;
    } catch (RemoteException e) {
        Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
        return false;
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadset.getPriority:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the priority of the profile.
 *
 * <p> The priority can be any of:
 * {@link #PRIORITY_AUTO_CONNECT}, {@link #PRIORITY_OFF},
 * {@link #PRIORITY_ON}, {@link #PRIORITY_UNDEFINED}
 *
 * @param device Bluetooth device
 * @return priority of the device
 * @hide
 */

Body of Frist Method:
{
    if (VDBG)
        log("getPriority(" + device + ")");
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return BluetoothAdapter.connectionPolicyToPriority(service.getPriority(device));
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.PRIORITY_OFF;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return BluetoothProfile.PRIORITY_OFF;
}
Body of Second Method:
{
    if (VDBG)
        log("getPriority(" + device + ")");
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return BluetoothAdapter.connectionPolicyToPriority(service.getPriority(device, mAttributionSource));
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.PRIORITY_OFF;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return BluetoothProfile.PRIORITY_OFF;
}
------------------------
Find a silently evolved API code:android.timezone.ZoneInfoDb.getInstance:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Obtains the singleton instance.
 */

Body of Frist Method:
{
    synchronized (sLock) {
        if (sInstance == null) {
            sInstance = new ZoneInfoDb(libcore.timezone.ZoneInfoDb.getInstance());
        }
    }
    return sInstance;
}
Body of Second Method:
{
    synchronized (sLock) {
        if (sInstance == null) {
            sInstance = new ZoneInfoDb(com.android.i18n.timezone.ZoneInfoDb.getInstance());
        }
    }
    return sInstance;
}
------------------------
Find a silently evolved API code:android.security.keystore.KeyGenParameterSpec.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Builds an instance of {@code KeyGenParameterSpec}.
 */

Body of Frist Method:
{
    return new KeyGenParameterSpec(mKeystoreAlias, mUid, mKeySize, mSpec, mCertificateSubject, mCertificateSerialNumber, mCertificateNotBefore, mCertificateNotAfter, mKeyValidityStart, mKeyValidityForOriginationEnd, mKeyValidityForConsumptionEnd, mPurposes, mDigests, mEncryptionPaddings, mSignaturePaddings, mBlockModes, mRandomizedEncryptionRequired, mUserAuthenticationRequired, mUserAuthenticationValidityDurationSeconds, mUserAuthenticationType, mUserPresenceRequired, mAttestationChallenge, mUniqueIdIncluded, mUserAuthenticationValidWhileOnBody, mInvalidatedByBiometricEnrollment, mIsStrongBoxBacked, mUserConfirmationRequired, mUnlockedDeviceRequired, mCriticalToDeviceEncryption);
}
Body of Second Method:
{
    return new KeyGenParameterSpec(mKeystoreAlias, mNamespace, mKeySize, mSpec, mCertificateSubject, mCertificateSerialNumber, mCertificateNotBefore, mCertificateNotAfter, mKeyValidityStart, mKeyValidityForOriginationEnd, mKeyValidityForConsumptionEnd, mPurposes, mDigests, mEncryptionPaddings, mSignaturePaddings, mBlockModes, mRandomizedEncryptionRequired, mUserAuthenticationRequired, mUserAuthenticationValidityDurationSeconds, mUserAuthenticationType, mUserPresenceRequired, mAttestationChallenge, mDevicePropertiesAttestationIncluded, mAttestationIds, mUniqueIdIncluded, mUserAuthenticationValidWhileOnBody, mInvalidatedByBiometricEnrollment, mIsStrongBoxBacked, mUserConfirmationRequired, mUnlockedDeviceRequired, mCriticalToDeviceEncryption, mMaxUsageCount, mAttestKeyAlias);
}
------------------------
Find a silently evolved API code:android.net.Uri.PathPart.fromDecoded:COMMENT
Method Modifier: default     static      
Comment:/**
 * Creates a path from the decoded string.
 *
 * @param decoded part string
 */

Body of Frist Method:
{
    return from(NOT_CACHED, decoded);
}
Body of Second Method:
{
    return from(NotCachedHolder.NOT_CACHED, decoded);
}
------------------------
Find a silently evolved API code:android.view.Choreographer.getFrameIntervalNanos:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @return The refresh rate as the nanoseconds between frames
 * @hide
 */

Body of Frist Method:
{
    return mFrameIntervalNanos;
}
Body of Second Method:
{
    synchronized (mLock) {
        return mLastFrameIntervalNanos;
    }
}
------------------------
Find a silently evolved API code:android.widget.EdgeEffect.onAbsorb:COMMENT
Method Modifier: public      
Comment:/**
 * Call when the effect absorbs an impact at the given velocity.
 * Used when a fling reaches the scroll boundary.
 *
 * <p>When using a {@link android.widget.Scroller} or {@link android.widget.OverScroller},
 * the method <code>getCurrVelocity</code> will provide a reasonable approximation
 * to use here.</p>
 *
 * @param velocity Velocity at impact in pixels per second.
 */

Body of Frist Method:
{
    mState = STATE_ABSORB;
    velocity = Math.min(Math.max(MIN_VELOCITY, Math.abs(velocity)), MAX_VELOCITY);
    mStartTime = AnimationUtils.currentAnimationTimeMillis();
    mDuration = 0.15f + (velocity * 0.02f);
    // The glow depends more on the velocity, and therefore starts out
    // nearly invisible.
    mGlowAlphaStart = GLOW_ALPHA_START;
    mGlowScaleYStart = Math.max(mGlowScaleY, 0.f);
    // Growth for the size of the glow should be quadratic to properly
    // respond
    // to a user's scrolling speed. The faster the scrolling speed, the more
    // intense the effect should be for both the size and the saturation.
    mGlowScaleYFinish = Math.min(0.025f + (velocity * (velocity / 100) * 0.00015f) / 2, 1.f);
    // Alpha should change for the glow as well as size.
    mGlowAlphaFinish = Math.max(mGlowAlphaStart, Math.min(velocity * VELOCITY_GLOW_FACTOR * .00001f, MAX_ALPHA));
    mTargetDisplacement = 0.5f;
}
Body of Second Method:
{
    int edgeEffectBehavior = getCurrentEdgeEffectBehavior();
    if (edgeEffectBehavior == TYPE_STRETCH) {
        mState = STATE_RECEDE;
        mVelocity = velocity * ON_ABSORB_VELOCITY_ADJUSTMENT;
        mStartTime = AnimationUtils.currentAnimationTimeMillis();
    } else if (edgeEffectBehavior == TYPE_GLOW) {
        mState = STATE_ABSORB;
        mVelocity = 0;
        velocity = Math.min(Math.max(MIN_VELOCITY, Math.abs(velocity)), MAX_VELOCITY);
        mStartTime = AnimationUtils.currentAnimationTimeMillis();
        mDuration = 0.15f + (velocity * 0.02f);
        // The glow depends more on the velocity, and therefore starts out
        // nearly invisible.
        mGlowAlphaStart = GLOW_ALPHA_START;
        mGlowScaleYStart = Math.max(mGlowScaleY, 0.f);
        // Growth for the size of the glow should be quadratic to properly
        // respond
        // to a user's scrolling speed. The faster the scrolling speed, the more
        // intense the effect should be for both the size and the saturation.
        mGlowScaleYFinish = Math.min(0.025f + (velocity * (velocity / 100) * 0.00015f) / 2, 1.f);
        // Alpha should change for the glow as well as size.
        mGlowAlphaFinish = Math.max(mGlowAlphaStart, Math.min(velocity * VELOCITY_GLOW_FACTOR * .00001f, MAX_ALPHA));
        mTargetDisplacement = 0.5f;
    } else {
        finish();
    }
}
------------------------
Find a silently evolved API code:android.hardware.camera2.utils.SurfaceUtils.getSurfaceId:COMMENT
Method Modifier: public      static      
Comment:/**
 * Get the native object id of a surface.
 *
 * @param surface The surface to be checked.
 * @return the native object id of the surface, 0 if surface is not backed by a native object.
 */

Body of Frist Method:
{
    try {
        return LegacyCameraDevice.getSurfaceId(surface);
    } catch (BufferQueueAbandonedException e) {
        return 0;
    }
}
Body of Second Method:
{
    checkNotNull(surface);
    try {
        return nativeGetSurfaceId(surface);
    } catch (IllegalArgumentException e) {
        return 0;
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.startVoiceRecognition:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Starts voice recognition.
 *
 * @param device remote device
 * @return <code>true</code> if command has been issued successfully; <code>false</code>
 * otherwise; upon completion HFP sends {@link #ACTION_AG_EVENT} intent.
 *
 * <p>Feature required for successful execution is being reported by: {@link
 * #EXTRA_AG_FEATURE_VOICE_RECOGNITION}. This method invocation will fail silently when feature
 * is not supported.</p>
 */

Body of Frist Method:
{
    if (DBG)
        log("startVoiceRecognition()");
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.startVoiceRecognition(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("startVoiceRecognition()");
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.startVoiceRecognition(device, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothDevice.getMessageAccessPermission:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Gets whether message access is allowed to this bluetooth device
 *
 * @return Whether the message access is allowed to this device.
 * @hide
 */

Body of Frist Method:
{
    final IBluetooth service = sService;
    if (service == null) {
        return ACCESS_UNKNOWN;
    }
    try {
        return service.getMessageAccessPermission(this);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return ACCESS_UNKNOWN;
}
Body of Second Method:
{
    final IBluetooth service = sService;
    if (service == null) {
        return ACCESS_UNKNOWN;
    }
    try {
        return service.getMessageAccessPermission(this, mAttributionSource);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return ACCESS_UNKNOWN;
}
------------------------
Find a silently evolved API code:android.app.servertransaction.LaunchActivityItem.writeToParcel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Write from Parcel.
 */

Body of Frist Method:
{
    dest.writeTypedObject(mIntent, flags);
    dest.writeInt(mIdent);
    dest.writeTypedObject(mInfo, flags);
    dest.writeTypedObject(mCurConfig, flags);
    dest.writeTypedObject(mOverrideConfig, flags);
    dest.writeTypedObject(mCompatInfo, flags);
    dest.writeString(mReferrer);
    dest.writeStrongInterface(mVoiceInteractor);
    dest.writeInt(mProcState);
    dest.writeBundle(mState);
    dest.writePersistableBundle(mPersistentState);
    dest.writeTypedList(mPendingResults, flags);
    dest.writeTypedList(mPendingNewIntents, flags);
    dest.writeBoolean(mIsForward);
    dest.writeTypedObject(mProfilerInfo, flags);
    dest.writeStrongBinder(mAssistToken);
    dest.writeTypedObject(mFixedRotationAdjustments, flags);
}
Body of Second Method:
{
    dest.writeTypedObject(mIntent, flags);
    dest.writeInt(mIdent);
    dest.writeTypedObject(mInfo, flags);
    dest.writeTypedObject(mCurConfig, flags);
    dest.writeTypedObject(mOverrideConfig, flags);
    dest.writeTypedObject(mCompatInfo, flags);
    dest.writeString(mReferrer);
    dest.writeStrongInterface(mVoiceInteractor);
    dest.writeInt(mProcState);
    dest.writeBundle(mState);
    dest.writePersistableBundle(mPersistentState);
    dest.writeTypedList(mPendingResults, flags);
    dest.writeTypedList(mPendingNewIntents, flags);
    dest.writeBundle(mActivityOptions != null ? mActivityOptions.toBundle() : null);
    dest.writeBoolean(mIsForward);
    dest.writeTypedObject(mProfilerInfo, flags);
    dest.writeStrongBinder(mAssistToken);
    dest.writeStrongInterface(mActivityClientController);
    dest.writeTypedObject(mFixedRotationAdjustments, flags);
    dest.writeStrongBinder(mShareableActivityToken);
    dest.writeBoolean(mLaunchedFromBubble);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothDevice.removeBond:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Remove bond (pairing) with the remote device.
 * <p>Delete the link key associated with the remote device, and
 * immediately terminate connections to that device that require
 * authentication and encryption.
 *
 * @return true on success, false on error
 * @hide
 */

Body of Frist Method:
{
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, "BT not enabled. Cannot remove Remote Device bond");
        return false;
    }
    try {
        Log.i(TAG, "removeBond() for device " + getAddress() + " called by pid: " + Process.myPid() + " tid: " + Process.myTid());
        return service.removeBond(this);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
Body of Second Method:
{
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, "BT not enabled. Cannot remove Remote Device bond");
        return false;
    }
    try {
        Log.i(TAG, "removeBond() for device " + getAddress() + " called by pid: " + Process.myPid() + " tid: " + Process.myTid());
        return service.removeBond(this, mAttributionSource);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothPan.disconnect:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Initiate disconnection from a profile
 *
 * <p> This API will return false in scenarios like the profile on the
 * Bluetooth device is not in connected state etc. When this API returns,
 * true, it is guaranteed that the connection state change
 * intent will be broadcasted with the state. Users can get the
 * disconnection state of the profile from this intent.
 *
 * <p> If the disconnection is initiated by a remote device, the state
 * will transition from {@link #STATE_CONNECTED} to
 * {@link #STATE_DISCONNECTED}. If the disconnect is initiated by the
 * host (local) device the state will transition from
 * {@link #STATE_CONNECTED} to state {@link #STATE_DISCONNECTING} to
 * state {@link #STATE_DISCONNECTED}. The transition to
 * {@link #STATE_DISCONNECTING} can be used to distinguish between the
 * two scenarios.
 *
 * @param device Remote Bluetooth Device
 * @return false on immediate error, true otherwise
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("disconnect(" + device + ")");
    final IBluetoothPan service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.disconnect(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("disconnect(" + device + ")");
    final IBluetoothPan service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.disconnect(device, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.telephony.CallForwardingInfo.writeToParcel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    out.writeString(mNumber);
    out.writeInt(mStatus);
    out.writeInt(mReason);
    out.writeInt(mTimeSeconds);
}
Body of Second Method:
{
    out.writeString(mNumber);
    out.writeBoolean(mEnabled);
    out.writeInt(mReason);
    out.writeInt(mTimeSeconds);
}
------------------------
Find a silently evolved API code:android.security.KeyStoreParameter.getFlags:COMMENT
Method Modifier: public      hidden      deprecated  
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return mFlags;
}
Body of Second Method:
{
    return 0;
}
------------------------
Find a silently evolved API code:android.os.Debug.startNativeTracing:COMMENT
Method Modifier: public      static      
Comment:/**
 * Enable qemu tracing. For this to work requires running everything inside
 * the qemu emulator; otherwise, this method will have no effect. The trace
 * file is specified on the command line when the emulator is started. For
 * example, the following command line <br />
 * <code>emulator -trace foo</code><br />
 * will start running the emulator and create a trace file named "foo". This
 * method simply enables writing the trace records to the trace file.
 *
 * <p>
 * The main differences between this and {@link #startMethodTracing()} are
 * that tracing in the qemu emulator traces every cpu instruction of every
 * process, including kernel code, so we have more complete information,
 * including all context switches. We can also get more detailed information
 * such as cache misses. The sequence of calls is determined by
 * post-processing the instruction trace. The qemu tracing is also done
 * without modifying the application or perturbing the timing of calls
 * because no instrumentation is added to the application being traced.
 * </p>
 *
 * <p>
 * One limitation of using this method compared to using
 * {@link #startMethodTracing()} on the real device is that the emulator
 * does not model all of the real hardware effects such as memory and
 * bus contention.  The emulator also has a simple cache model and cannot
 * capture all the complexities of a real cache.
 * </p>
 */

Body of Frist Method:
{
    // Open the sysfs file for writing and write "1" to it.
    PrintWriter outStream = null;
    try {
        FileOutputStream fos = new FileOutputStream(SYSFS_QEMU_TRACE_STATE);
        outStream = new FastPrintWriter(fos);
        outStream.println("1");
    } catch (Exception e) {
    } finally {
        if (outStream != null)
            outStream.close();
    }
    VMDebug.startEmulatorTracing();
}
Body of Second Method:
{
    // Open the sysfs file for writing and write "1" to it.
    PrintWriter outStream = null;
    try {
        FileOutputStream fos = new FileOutputStream(SYSFS_QEMU_TRACE_STATE);
        outStream = new FastPrintWriter(fos);
        outStream.println("1");
    } catch (Exception e) {
    } finally {
        if (outStream != null)
            outStream.close();
    }
}
------------------------
Find a silently evolved API code:android.text.format.DateUtils.getDayOfWeekString:COMMENT
Method Modifier: public      static      deprecated  
Comment:/**
 * Return a string for the day of the week.
 * @param dayOfWeek One of {@link Calendar#SUNDAY Calendar.SUNDAY},
 * {@link Calendar#MONDAY Calendar.MONDAY}, etc.
 * @param abbrev One of {@link #LENGTH_LONG}, {@link #LENGTH_SHORT},
 * {@link #LENGTH_MEDIUM}, or {@link #LENGTH_SHORTEST}.
 * Note that in most languages, {@link #LENGTH_SHORT}
 * will return the same as {@link #LENGTH_MEDIUM}.
 * Undefined lengths will return {@link #LENGTH_MEDIUM}
 * but may return something different in the future.
 * @throws IndexOutOfBoundsException if the dayOfWeek is out of bounds.
 * @deprecated Use {@link java.text.SimpleDateFormat} instead.
 */

Body of Frist Method:
{
    LocaleData d = LocaleData.get(Locale.getDefault());
    String[] names;
    switch(abbrev) {
        case LENGTH_LONG:
            names = d.longWeekdayNames;
            break;
        case LENGTH_MEDIUM:
            names = d.shortWeekdayNames;
            break;
        // TODO
        case LENGTH_SHORT:
            names = d.shortWeekdayNames;
            break;
        // TODO
        case LENGTH_SHORTER:
            names = d.shortWeekdayNames;
            break;
        case LENGTH_SHORTEST:
            names = d.tinyWeekdayNames;
            break;
        default:
            names = d.shortWeekdayNames;
            break;
    }
    return names[dayOfWeek];
}
Body of Second Method:
{
    DateFormatSymbols dfs = DateFormatSymbols.getInstance();
    final int width;
    switch(abbrev) {
        case LENGTH_LONG:
            width = DateFormatSymbols.WIDE;
            break;
        case LENGTH_SHORTEST:
            width = DateFormatSymbols.NARROW;
            break;
        case LENGTH_MEDIUM:
        // TODO
        case LENGTH_SHORT:
        // TODO
        case LENGTH_SHORTER:
        default:
            width = DateFormatSymbols.ABBREVIATED;
            break;
    }
    return dfs.getWeekdays(DateFormatSymbols.FORMAT, width)[dayOfWeek];
}
------------------------
Find a silently evolved API code:android.os.incremental.IncrementalStorage.isFileFullyLoaded:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Checks whether a file under the current storage directory is fully loaded.
 *
 * @param path The relative path of the file.
 * @return True if the file is fully loaded.
 */

Body of Frist Method:
{
    return isFileRangeLoaded(path, 0, -1);
}
Body of Second Method:
{
    try {
        int res = mService.isFileFullyLoaded(mId, path);
        if (res < 0) {
            throw new IOException("isFileFullyLoaded() failed, errno " + -res);
        }
        return res == 0;
    } catch (RemoteException e) {
        e.rethrowFromSystemServer();
        return false;
    }
}
------------------------
Find a silently evolved API code:android.timezone.TelephonyLookup.getTelephonyNetworkFinder:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns an object capable of querying telephony network information. This method can return
 * {@code null} in the event of an error while reading the underlying data files.
 */

Body of Frist Method:
{
    libcore.timezone.TelephonyNetworkFinder telephonyNetworkFinderDelegate = mDelegate.getTelephonyNetworkFinder();
    return telephonyNetworkFinderDelegate != null ? new TelephonyNetworkFinder(telephonyNetworkFinderDelegate) : null;
}
Body of Second Method:
{
    com.android.i18n.timezone.TelephonyNetworkFinder telephonyNetworkFinderDelegate = mDelegate.getTelephonyNetworkFinder();
    return telephonyNetworkFinderDelegate != null ? new TelephonyNetworkFinder(telephonyNetworkFinderDelegate) : null;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothMap.getConnectedDevices:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the list of connected devices. Currently at most one.
 *
 * @return list of connected devices
 *
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("getConnectedDevices()");
    final IBluetoothMap service = getService();
    if (service != null && isEnabled()) {
        try {
            return service.getConnectedDevices();
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
Body of Second Method:
{
    if (DBG)
        log("getConnectedDevices()");
    final IBluetoothMap service = getService();
    if (service != null && isEnabled()) {
        try {
            return Attributable.setAttributionSource(service.getConnectedDevices(mAttributionSource), mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
------------------------
Find a silently evolved API code:android.ddm.DdmHandleHeap.handleChunk:COMMENT
Method Modifier: public      
Comment:/**
 * Handle a chunk of data.
 */

Body of Frist Method:
{
    if (false)
        Log.v("ddm-heap", "Handling " + name(request.type) + " chunk");
    int type = request.type;
    if (type == CHUNK_HPIF) {
        return handleHPIF(request);
    } else if (type == CHUNK_HPSG) {
        return handleHPSGNHSG(request, false);
    } else if (type == CHUNK_HPDU) {
        return handleHPDU(request);
    } else if (type == CHUNK_HPDS) {
        return handleHPDS(request);
    } else if (type == CHUNK_NHSG) {
        return handleHPSGNHSG(request, true);
    } else if (type == CHUNK_HPGC) {
        return handleHPGC(request);
    } else if (type == CHUNK_REAE) {
        return handleREAE(request);
    } else if (type == CHUNK_REAQ) {
        return handleREAQ(request);
    } else if (type == CHUNK_REAL) {
        return handleREAL(request);
    } else {
        throw new RuntimeException("Unknown packet " + ChunkHandler.name(type));
    }
}
Body of Second Method:
{
    if (false)
        Log.v("ddm-heap", "Handling " + name(request.type) + " chunk");
    int type = request.type;
    if (type == CHUNK_HPGC) {
        return handleHPGC(request);
    } else {
        throw new RuntimeException("Unknown packet " + name(type));
    }
}
------------------------
Find a silently evolved API code:android.media.audiopolicy.AudioMixingRule.Builder.addRuleInternal:COMMENT
Method Modifier: private     
Comment:/**
 * Add or exclude a rule on AudioAttributes or integer property for the selection of which
 * streams are mixed together.
 * No rule-to-parameter type check, all done in {@link #checkAddRuleObjInternal(int, Object)}.
 * Exceptions are thrown only when incompatible rules are added.
 * @param attrToMatch a non-null AudioAttributes instance for which a contradictory
 * rule hasn't been set yet, null if not used.
 * @param intProp an integer property to match or exclude, null if not used.
 * @param rule one of {@link AudioMixingRule#RULE_EXCLUDE_ATTRIBUTE_USAGE},
 * {@link AudioMixingRule#RULE_MATCH_ATTRIBUTE_USAGE},
 * {@link AudioMixingRule#RULE_MATCH_ATTRIBUTE_CAPTURE_PRESET} or
 * {@link AudioMixingRule#RULE_EXCLUDE_ATTRIBUTE_CAPTURE_PRESET},
 * {@link AudioMixingRule#RULE_MATCH_UID}, {@link AudioMixingRule#RULE_EXCLUDE_UID}.
 * {@link AudioMixingRule#RULE_MATCH_USERID},
 * {@link AudioMixingRule#RULE_EXCLUDE_USERID}.
 * @return the same Builder instance.
 * @throws IllegalArgumentException
 */

Body of Frist Method:
{
    // of mix being built. When adding the first rule, the mix type is MIX_TYPE_INVALID.
    if (mTargetMixType == AudioMix.MIX_TYPE_INVALID) {
        if (isPlayerRule(rule)) {
            mTargetMixType = AudioMix.MIX_TYPE_PLAYERS;
        } else {
            mTargetMixType = AudioMix.MIX_TYPE_RECORDERS;
        }
    } else if (((mTargetMixType == AudioMix.MIX_TYPE_PLAYERS) && !isPlayerRule(rule)) || ((mTargetMixType == AudioMix.MIX_TYPE_RECORDERS) && isPlayerRule(rule))) {
        throw new IllegalArgumentException("Incompatible rule for mix");
    }
    synchronized (mCriteria) {
        Iterator<AudioMixMatchCriterion> crIterator = mCriteria.iterator();
        final int match_rule = rule & ~RULE_EXCLUSION_MASK;
        while (crIterator.hasNext()) {
            final AudioMixMatchCriterion criterion = crIterator.next();
            if ((criterion.mRule & ~RULE_EXCLUSION_MASK) != match_rule) {
                // The two rules are not of the same type
                continue;
            }
            switch(match_rule) {
                case RULE_MATCH_ATTRIBUTE_USAGE:
                    // "usage"-based rule
                    if (criterion.mAttr.getUsage() == attrToMatch.getUsage()) {
                        if (criterion.mRule == rule) {
                            // rule already exists, we're done
                            return this;
                        } else {
                            // it is incompatible
                            throw new IllegalArgumentException("Contradictory rule exists" + " for " + attrToMatch);
                        }
                    }
                    break;
                case RULE_MATCH_ATTRIBUTE_CAPTURE_PRESET:
                    // "capture preset"-base rule
                    if (criterion.mAttr.getCapturePreset() == attrToMatch.getCapturePreset()) {
                        if (criterion.mRule == rule) {
                            // rule already exists, we're done
                            return this;
                        } else {
                            // it is incompatible
                            throw new IllegalArgumentException("Contradictory rule exists" + " for " + attrToMatch);
                        }
                    }
                    break;
                case RULE_MATCH_UID:
                    // "usage"-based rule
                    if (criterion.mIntProp == intProp.intValue()) {
                        if (criterion.mRule == rule) {
                            // rule already exists, we're done
                            return this;
                        } else {
                            // it is incompatible
                            throw new IllegalArgumentException("Contradictory rule exists" + " for UID " + intProp);
                        }
                    }
                    break;
                case RULE_MATCH_USERID:
                    // "userid"-based rule
                    if (criterion.mIntProp == intProp.intValue()) {
                        if (criterion.mRule == rule) {
                            // rule already exists, we're done
                            return this;
                        } else {
                            // it is incompatible
                            throw new IllegalArgumentException("Contradictory rule exists" + " for userId " + intProp);
                        }
                    }
                    break;
            }
        }
        // rule didn't exist, add it
        switch(match_rule) {
            case RULE_MATCH_ATTRIBUTE_USAGE:
            case RULE_MATCH_ATTRIBUTE_CAPTURE_PRESET:
                mCriteria.add(new AudioMixMatchCriterion(attrToMatch, rule));
                break;
            case RULE_MATCH_UID:
            case RULE_MATCH_USERID:
                mCriteria.add(new AudioMixMatchCriterion(intProp, rule));
                break;
            default:
                throw new IllegalStateException("Unreachable code in addRuleInternal()");
        }
    }
    return this;
}
Body of Second Method:
{
    // of mix being built. When adding the first rule, the mix type is MIX_TYPE_INVALID.
    if (mTargetMixType == AudioMix.MIX_TYPE_INVALID) {
        if (isPlayerRule(rule)) {
            mTargetMixType = AudioMix.MIX_TYPE_PLAYERS;
        } else if (isRecorderRule(rule)) {
            mTargetMixType = AudioMix.MIX_TYPE_RECORDERS;
        } else {
            // For rules which are not player or recorder specific (e.g. RULE_MATCH_UID),
            // the default mix type is MIX_TYPE_PLAYERS.
            mTargetMixType = AudioMix.MIX_TYPE_PLAYERS;
        }
    } else if ((isPlayerRule(rule) && (mTargetMixType != AudioMix.MIX_TYPE_PLAYERS)) || (isRecorderRule(rule)) && (mTargetMixType != AudioMix.MIX_TYPE_RECORDERS)) {
        throw new IllegalArgumentException("Incompatible rule for mix");
    }
    synchronized (mCriteria) {
        Iterator<AudioMixMatchCriterion> crIterator = mCriteria.iterator();
        final int match_rule = rule & ~RULE_EXCLUSION_MASK;
        while (crIterator.hasNext()) {
            final AudioMixMatchCriterion criterion = crIterator.next();
            if ((criterion.mRule & ~RULE_EXCLUSION_MASK) != match_rule) {
                // The two rules are not of the same type
                continue;
            }
            switch(match_rule) {
                case RULE_MATCH_ATTRIBUTE_USAGE:
                    // "usage"-based rule
                    if (criterion.mAttr.getSystemUsage() == attrToMatch.getSystemUsage()) {
                        if (criterion.mRule == rule) {
                            // rule already exists, we're done
                            return this;
                        } else {
                            // it is incompatible
                            throw new IllegalArgumentException("Contradictory rule exists" + " for " + attrToMatch);
                        }
                    }
                    break;
                case RULE_MATCH_ATTRIBUTE_CAPTURE_PRESET:
                    // "capture preset"-base rule
                    if (criterion.mAttr.getCapturePreset() == attrToMatch.getCapturePreset()) {
                        if (criterion.mRule == rule) {
                            // rule already exists, we're done
                            return this;
                        } else {
                            // it is incompatible
                            throw new IllegalArgumentException("Contradictory rule exists" + " for " + attrToMatch);
                        }
                    }
                    break;
                case RULE_MATCH_UID:
                    // "usage"-based rule
                    if (criterion.mIntProp == intProp.intValue()) {
                        if (criterion.mRule == rule) {
                            // rule already exists, we're done
                            return this;
                        } else {
                            // it is incompatible
                            throw new IllegalArgumentException("Contradictory rule exists" + " for UID " + intProp);
                        }
                    }
                    break;
                case RULE_MATCH_USERID:
                    // "userid"-based rule
                    if (criterion.mIntProp == intProp.intValue()) {
                        if (criterion.mRule == rule) {
                            // rule already exists, we're done
                            return this;
                        } else {
                            // it is incompatible
                            throw new IllegalArgumentException("Contradictory rule exists" + " for userId " + intProp);
                        }
                    }
                    break;
            }
        }
        // rule didn't exist, add it
        switch(match_rule) {
            case RULE_MATCH_ATTRIBUTE_USAGE:
            case RULE_MATCH_ATTRIBUTE_CAPTURE_PRESET:
                mCriteria.add(new AudioMixMatchCriterion(attrToMatch, rule));
                break;
            case RULE_MATCH_UID:
            case RULE_MATCH_USERID:
                mCriteria.add(new AudioMixMatchCriterion(intProp, rule));
                break;
            default:
                throw new IllegalStateException("Unreachable code in addRuleInternal()");
        }
    }
    return this;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothMap.getConnectionState:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get connection state of device
 *
 * @return device connection state
 *
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("getConnectionState(" + device + ")");
    final IBluetoothMap service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getConnectionState(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.STATE_DISCONNECTED;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return BluetoothProfile.STATE_DISCONNECTED;
}
Body of Second Method:
{
    if (DBG)
        log("getConnectionState(" + device + ")");
    final IBluetoothMap service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getConnectionState(device, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.STATE_DISCONNECTED;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return BluetoothProfile.STATE_DISCONNECTED;
}
------------------------
Find a silently evolved API code:android.app.admin.DeviceAdminReceiver.onDisabled:COMMENT
Method Modifier: public      
Comment:/**
 * Called prior to the administrator being disabled, as a result of
 * receiving {@link #ACTION_DEVICE_ADMIN_DISABLED}.  Upon return, you
 * can no longer use the protected parts of the {@link DevicePolicyManager}
 * API.
 * @param context The running context as per {@link #onReceive}.
 * @param intent The received intent as per {@link #onReceive}.
 */

Body of Frist Method:
{
}
Body of Second Method:
{
    if (LOCAL_LOGV) {
        Log.v(TAG, getClass().getName() + ".onDisabled() on user " + context.getUserId());
    }
}
------------------------
Find a silently evolved API code:android.text.format.DateFormat.getBestDateTimePattern:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns the best possible localized form of the given skeleton for the given
 * locale. A skeleton is similar to, and uses the same format characters as, a Unicode
 * <a href="http://www.unicode.org/reports/tr35/#Date_Format_Patterns">UTS #35</a>
 * pattern.
 *
 * <p>One difference is that order is irrelevant. For example, "MMMMd" will return
 * "MMMM d" in the {@code en_US} locale, but "d. MMMM" in the {@code de_CH} locale.
 *
 * <p>Note also in that second example that the necessary punctuation for German was
 * added. For the same input in {@code es_ES}, we'd have even more extra text:
 * "d 'de' MMMM".
 *
 * <p>This method will automatically correct for grammatical necessity. Given the
 * same "MMMMd" input, this method will return "d LLLL" in the {@code fa_IR} locale,
 * where stand-alone months are necessary. Lengths are preserved where meaningful,
 * so "Md" would give a different result to "MMMd", say, except in a locale such as
 * {@code ja_JP} where there is only one length of month.
 *
 * <p>This method will only return patterns that are in CLDR, and is useful whenever
 * you know what elements you want in your format string but don't want to make your
 * code specific to any one locale.
 *
 * @param locale the locale into which the skeleton should be localized
 * @param skeleton a skeleton as described above
 * @return a string pattern suitable for use with {@link java.text.SimpleDateFormat}.
 */

Body of Frist Method:
{
    return ICU.getBestDateTimePattern(skeleton, locale);
}
Body of Second Method:
{
    DateTimePatternGenerator dtpg = DateTimePatternGenerator.getInstance(locale);
    boolean allowDuplicateFields = !CompatChanges.isChangeEnabled(DISALLOW_DUPLICATE_FIELD_IN_SKELETON);
    return dtpg.getBestPattern(skeleton, DateTimePatternGenerator.MATCH_NO_OPTIONS, allowDuplicateFields);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothDevice.getBluetoothClass:COMMENT
Method Modifier: public      
Comment:/**
 * Get the Bluetooth class of the remote device.
 *
 * @return Bluetooth class object, or null on error
 */

Body of Frist Method:
{
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, "BT not enabled. Cannot get Bluetooth Class");
        return null;
    }
    try {
        int classInt = service.getRemoteClass(this);
        if (classInt == BluetoothClass.ERROR)
            return null;
        return new BluetoothClass(classInt);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return null;
}
Body of Second Method:
{
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, "BT not enabled. Cannot get Bluetooth Class");
        return null;
    }
    try {
        int classInt = service.getRemoteClass(this, mAttributionSource);
        if (classInt == BluetoothClass.ERROR)
            return null;
        return new BluetoothClass(classInt);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return null;
}
------------------------
Find a silently evolved API code:android.content.ContentProviderClient.uncanonicalize:COMMENT
Method Modifier: public      final       
Comment:/**
 * See {@link ContentProvider#uncanonicalize}
 */

Body of Frist Method:
{
    Objects.requireNonNull(url, "url");
    beforeRemote();
    try {
        return mContentProvider.uncanonicalize(mPackageName, mAttributionTag, url);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}
Body of Second Method:
{
    Objects.requireNonNull(url, "url");
    beforeRemote();
    try {
        return mContentProvider.uncanonicalize(mAttributionSource, url);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothMap.getDevicesMatchingConnectionStates:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the list of devices matching specified states. Currently at most one.
 *
 * @return list of matching devices
 *
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("getDevicesMatchingStates()");
    final IBluetoothMap service = getService();
    if (service != null && isEnabled()) {
        try {
            return service.getDevicesMatchingConnectionStates(states);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
Body of Second Method:
{
    if (DBG)
        log("getDevicesMatchingStates()");
    final IBluetoothMap service = getService();
    if (service != null && isEnabled()) {
        try {
            return Attributable.setAttributionSource(service.getDevicesMatchingConnectionStates(states, mAttributionSource), mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
------------------------
Find a silently evolved API code:android.view.textservice.TextServicesManager.createInstance:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * The factory method of {@link TextServicesManager}.
 *
 * @param context {@link Context} from which {@link TextServicesManager} should be instantiated.
 * @return {@link TextServicesManager} that is associated with {@link Context#getUserId()}.
 * @throws ServiceNotFoundException When {@link TextServicesManager} is not available.
 * @hide
 */

Body of Frist Method:
{
    return new TextServicesManager(context.getUserId());
}
Body of Second Method:
{
    return new TextServicesManager(context.getUserId(), context.getSystemService(InputMethodManager.class));
}
------------------------
Find a silently evolved API code:android.graphics.drawable.Icon.loadDrawableAsUser:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Load the requested resources under the given userId, if the system allows it,
 * before actually loading the drawable.
 *
 * @hide
 */

Body of Frist Method:
{
    if (mType == TYPE_RESOURCE) {
        String resPackage = getResPackage();
        if (TextUtils.isEmpty(resPackage)) {
            resPackage = context.getPackageName();
        }
        if (getResources() == null && !(getResPackage().equals("android"))) {
            final PackageManager pm = context.getPackageManager();
            try {
                // assign getResources() as the correct user
                mObj1 = pm.getResourcesForApplicationAsUser(resPackage, userId);
            } catch (PackageManager.NameNotFoundException e) {
                Log.e(TAG, String.format("Unable to find pkg=%s user=%d", getResPackage(), userId), e);
            }
        }
    }
    return loadDrawable(context);
}
Body of Second Method:
{
    if (mType == TYPE_RESOURCE) {
        String resPackage = getResPackage();
        if (TextUtils.isEmpty(resPackage)) {
            resPackage = context.getPackageName();
        }
        if (getResources() == null && !(getResPackage().equals("android"))) {
            // TODO(b/173307037): Move CONTEXT_INCLUDE_CODE to ContextImpl.createContextAsUser
            final Context userContext;
            if (context.getUserId() == userId) {
                userContext = context;
            } else {
                final boolean sameAppWithProcess = UserHandle.isSameApp(context.getApplicationInfo().uid, Process.myUid());
                final int flags = (sameAppWithProcess ? CONTEXT_INCLUDE_CODE : 0) | CONTEXT_RESTRICTED;
                userContext = context.createContextAsUser(UserHandle.of(userId), flags);
            }
            final PackageManager pm = userContext.getPackageManager();
            try {
                // assign getResources() as the correct user
                mObj1 = pm.getResourcesForApplication(resPackage);
            } catch (PackageManager.NameNotFoundException e) {
                Log.e(TAG, String.format("Unable to find pkg=%s user=%d", getResPackage(), userId), e);
            }
        }
    }
    return loadDrawable(context);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.setAudioRouteAllowed:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets whether audio routing is allowed.
 *
 * @param device remote device
 * @param allowed if routing is allowed to the device Note: This is an internal function and
 * shouldn't be exposed
 */

Body of Frist Method:
{
    if (VDBG)
        log("setAudioRouteAllowed");
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled()) {
        try {
            service.setAudioRouteAllowed(device, allowed);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
}
Body of Second Method:
{
    if (VDBG)
        log("setAudioRouteAllowed");
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled()) {
        try {
            service.setAudioRouteAllowed(device, allowed, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHidHost.getConnectionState:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * {@inheritDoc}
 *
 * @hide
 */

Body of Frist Method:
{
    if (VDBG)
        log("getState(" + device + ")");
    if (device == null) {
        throw new IllegalArgumentException("device must not be null");
    }
    final IBluetoothHidHost service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getConnectionState(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.STATE_DISCONNECTED;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return BluetoothProfile.STATE_DISCONNECTED;
}
Body of Second Method:
{
    if (VDBG)
        log("getState(" + device + ")");
    if (device == null) {
        throw new IllegalArgumentException("device must not be null");
    }
    final IBluetoothHidHost service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getConnectionState(device, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.STATE_DISCONNECTED;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return BluetoothProfile.STATE_DISCONNECTED;
}
------------------------
Find a silently evolved API code:android.graphics.Camera.getMatrix:COMMENT
Method Modifier: public      
Comment:/**
 * Computes the matrix corresponding to the current transformation
 * and copies it to the supplied matrix object.
 *
 * @param matrix The matrix to copy the current transforms into
 */

Body of Frist Method:
{
    nativeGetMatrix(matrix.native_instance);
}
Body of Second Method:
{
    nativeGetMatrix(matrix.ni());
}
------------------------
Find a silently evolved API code:android.media.AudioRecordingConfiguration.getAudioDevice:COMMENT
Method Modifier: public      
Comment:/**
 * Returns information about the audio input device used for this recording.
 * @return the audio recording device or null if this information cannot be retrieved
 */

Body of Frist Method:
{
    // build the AudioDeviceInfo from the patch handle
    ArrayList<AudioPatch> patches = new ArrayList<AudioPatch>();
    if (AudioManager.listAudioPatches(patches) != AudioManager.SUCCESS) {
        Log.e(TAG, "Error retrieving list of audio patches");
        return null;
    }
    for (int i = 0; i < patches.size(); i++) {
        final AudioPatch patch = patches.get(i);
        if (patch.id() == mPatchHandle) {
            final AudioPortConfig[] sources = patch.sources();
            if ((sources != null) && (sources.length > 0)) {
                // not supporting multiple sources, so just look at the first source
                final int devId = sources[0].port().id();
                final AudioDeviceInfo[] devices = AudioManager.getDevicesStatic(AudioManager.GET_DEVICES_INPUTS);
                for (int j = 0; j < devices.length; j++) {
                    if (devices[j].getId() == devId) {
                        return devices[j];
                    }
                }
            }
            // patch handle is unique, there won't be another with the same handle
            break;
        }
    }
    Log.e(TAG, "Couldn't find device for recording, did recording end already?");
    return null;
}
Body of Second Method:
{
    // build the AudioDeviceInfo from the patch handle
    ArrayList<AudioPatch> patches = new ArrayList<AudioPatch>();
    if (AudioManager.listAudioPatches(patches) != AudioManager.SUCCESS) {
        Log.e(TAG, "Error retrieving list of audio patches");
        return null;
    }
    for (int i = 0; i < patches.size(); i++) {
        final AudioPatch patch = patches.get(i);
        if (patch.id() == mPatchHandle) {
            final AudioPortConfig[] sources = patch.sources();
            if ((sources != null) && (sources.length > 0)) {
                // not supporting multiple sources, so just look at the first source
                int devId = sources[0].port().id();
                return AudioManager.getDeviceForPortId(devId, AudioManager.GET_DEVICES_INPUTS);
            }
            // patch handle is unique, there won't be another with the same handle
            break;
        }
    }
    Log.e(TAG, "Couldn't find device for recording, did recording end already?");
    return null;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothA2dpSink.setConnectionPolicy:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Set connection policy of the profile
 *
 * <p> The device should already be paired.
 * Connection policy can be one of {@link #CONNECTION_POLICY_ALLOWED},
 * {@link #CONNECTION_POLICY_FORBIDDEN}, {@link #CONNECTION_POLICY_UNKNOWN}
 *
 * @param device Paired bluetooth device
 * @param connectionPolicy is the connection policy to set to for this profile
 * @return true if connectionPolicy is set, false on error
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("setConnectionPolicy(" + device + ", " + connectionPolicy + ")");
    final IBluetoothA2dpSink service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        if (connectionPolicy != BluetoothProfile.CONNECTION_POLICY_FORBIDDEN && connectionPolicy != BluetoothProfile.CONNECTION_POLICY_ALLOWED) {
            return false;
        }
        try {
            return service.setConnectionPolicy(device, connectionPolicy);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("setConnectionPolicy(" + device + ", " + connectionPolicy + ")");
    final IBluetoothA2dpSink service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        if (connectionPolicy != BluetoothProfile.CONNECTION_POLICY_FORBIDDEN && connectionPolicy != BluetoothProfile.CONNECTION_POLICY_ALLOWED) {
            return false;
        }
        try {
            return service.setConnectionPolicy(device, connectionPolicy, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.bluetooth.le.AdvertiseData.hashCode:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return Objects.hash(mServiceUuids, mManufacturerSpecificData, mServiceData, mIncludeDeviceName, mIncludeTxPowerLevel);
}
Body of Second Method:
{
    return Objects.hash(mServiceUuids, mServiceSolicitationUuids, mManufacturerSpecificData, mServiceData, mIncludeDeviceName, mIncludeTxPowerLevel);
}
------------------------
Find a silently evolved API code:android.content.IntentSender.getTargetPackage:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * @deprecated Renamed to {@link #getCreatorPackage()}.
 */

Body of Frist Method:
{
    try {
        return ActivityManager.getService().getPackageForIntentSender(mTarget);
    } catch (RemoteException e) {
        // Should never happen.
        return null;
    }
}
Body of Second Method:
{
    return getCreatorPackage();
}
------------------------
Find a silently evolved API code:android.os.Vibrator.areEffectsSupported:COMMENT
Method Modifier: public      
Comment:/**
 * Query whether the vibrator supports the given effects.
 *
 * Not all hardware reports its effect capabilities, so the system may not necessarily know
 * whether an effect is supported or not.
 *
 * The returned array will be the same length as the query array and the value at a given index
 * will contain {@link #VIBRATION_EFFECT_SUPPORT_YES} if the effect at that same index in the
 * querying array is supported, {@link #VIBRATION_EFFECT_SUPPORT_NO} if it isn't supported, or
 * {@link #VIBRATION_EFFECT_SUPPORT_UNKNOWN} if the system can't determine whether it's
 * supported or not.
 *
 * @param effectIds Which effects to query for.
 * @return An array containing the systems current knowledge about whether the given effects
 * are supported or not.
 */

Body of Frist Method:
{
    final int[] support = new int[effectIds.length];
    Arrays.fill(support, VIBRATION_EFFECT_SUPPORT_NO);
    return support;
}
Body of Second Method:
{
    VibratorInfo info = getInfo();
    int[] supported = new int[effectIds.length];
    for (int i = 0; i < effectIds.length; i++) {
        supported[i] = info.isEffectSupported(effectIds[i]);
    }
    return supported;
}
------------------------
Find a silently evolved API code:android.hardware.camera2.params.StreamConfigurationMap.imageFormatToDataspace:COMMENT
Method Modifier: default     static      
Comment:/**
 * Convert a public format compatible with {@code ImageFormat} to an internal dataspace
 * from {@code graphics.h}.
 *
 * <p>In particular these formats are converted:
 * <ul>
 * <li>ImageFormat.JPEG => HAL_DATASPACE_V0_JFIF
 * <li>ImageFormat.DEPTH_POINT_CLOUD => HAL_DATASPACE_DEPTH
 * <li>ImageFormat.DEPTH16 => HAL_DATASPACE_DEPTH
 * <li>ImageFormat.DEPTH_JPEG => HAL_DATASPACE_DYNAMIC_DEPTH
 * <li>ImageFormat.HEIC => HAL_DATASPACE_HEIF
 * <li>others => HAL_DATASPACE_UNKNOWN
 * </ul>
 * </p>
 *
 * <p>Passing in an implementation-defined format here will fail (it's not a public format);
 * as will passing in an internal format which has a different public format equivalent.
 * See {@link #checkArgumentFormat} for more details about a legal public format.</p>
 *
 * <p>All other formats are returned as-is, no invalid check is performed.</p>
 *
 * <p>This function is the dual of {@link #imageFormatToPublic}.</p>
 *
 * @param format public image format from {@link ImageFormat} or {@link PixelFormat}
 * @return the converted image formats
 *
 * @see ImageFormat
 * @see PixelFormat
 *
 * @throws IllegalArgumentException
 * if {@code format} was {@code HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED}
 */

Body of Frist Method:
{
    switch(format) {
        case ImageFormat.JPEG:
            return HAL_DATASPACE_V0_JFIF;
        case ImageFormat.DEPTH_POINT_CLOUD:
        case ImageFormat.DEPTH16:
        case ImageFormat.RAW_DEPTH:
            return HAL_DATASPACE_DEPTH;
        case ImageFormat.DEPTH_JPEG:
            return HAL_DATASPACE_DYNAMIC_DEPTH;
        case ImageFormat.HEIC:
            return HAL_DATASPACE_HEIF;
        default:
            return HAL_DATASPACE_UNKNOWN;
    }
}
Body of Second Method:
{
    switch(format) {
        case ImageFormat.JPEG:
            return HAL_DATASPACE_V0_JFIF;
        case ImageFormat.DEPTH_POINT_CLOUD:
        case ImageFormat.DEPTH16:
        case ImageFormat.RAW_DEPTH:
        case ImageFormat.RAW_DEPTH10:
            return HAL_DATASPACE_DEPTH;
        case ImageFormat.DEPTH_JPEG:
            return HAL_DATASPACE_DYNAMIC_DEPTH;
        case ImageFormat.HEIC:
            return HAL_DATASPACE_HEIF;
        default:
            return HAL_DATASPACE_UNKNOWN;
    }
}
------------------------
Find a silently evolved API code:android.app.AppCompatCallbacks.install:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Install this class into the current process.
 *
 * @param disabledChanges Set of compatibility changes that are disabled for this process.
 */

Body of Frist Method:
{
    Compatibility.setCallbacks(new AppCompatCallbacks(disabledChanges));
}
Body of Second Method:
{
    Compatibility.setBehaviorChangeDelegate(new AppCompatCallbacks(disabledChanges));
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothPbapClient.getConnectedDevices:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the list of connected devices.
 * Currently at most one.
 *
 * @return list of connected devices
 */

Body of Frist Method:
{
    if (DBG) {
        log("getConnectedDevices()");
    }
    final IBluetoothPbapClient service = getService();
    if (service != null && isEnabled()) {
        try {
            return service.getConnectedDevices();
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null) {
        Log.w(TAG, "Proxy not attached to service");
    }
    return new ArrayList<BluetoothDevice>();
}
Body of Second Method:
{
    if (DBG) {
        log("getConnectedDevices()");
    }
    final IBluetoothPbapClient service = getService();
    if (service != null && isEnabled()) {
        try {
            return Attributable.setAttributionSource(service.getConnectedDevices(mAttributionSource), mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null) {
        Log.w(TAG, "Proxy not attached to service");
    }
    return new ArrayList<BluetoothDevice>();
}
------------------------
Find a silently evolved API code:android.view.textservice.TextServicesManager.getInstance:COMMENT
Method Modifier: public      static      hidden      deprecated  
Comment:/**
 * @deprecated Do not use. Just kept because of {@link UnsupportedAppUsage} in
 * {@link #getInstance()}.
 * @hide
 */

Body of Frist Method:
{
    synchronized (TextServicesManager.class) {
        if (sInstance == null) {
            try {
                sInstance = new TextServicesManager(UserHandle.myUserId());
            } catch (ServiceNotFoundException e) {
                throw new IllegalStateException(e);
            }
        }
        return sInstance;
    }
}
Body of Second Method:
{
    synchronized (TextServicesManager.class) {
        if (sInstance == null) {
            try {
                sInstance = new TextServicesManager(UserHandle.myUserId(), null);
            } catch (ServiceNotFoundException e) {
                throw new IllegalStateException(e);
            }
        }
        return sInstance;
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothGatt.requestLeConnectionUpdate:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Request an LE connection parameter update.
 *
 * <p>This function will send an LE connection parameters update request to the remote device.
 *
 * @return true, if the request is send to the Bluetooth stack.
 * @hide
 */

Body of Frist Method:
{
    if (DBG) {
        Log.d(TAG, "requestLeConnectionUpdate() - min=(" + minConnectionInterval + ")" + (1.25 * minConnectionInterval) + "msec, max=(" + maxConnectionInterval + ")" + (1.25 * maxConnectionInterval) + "msec, latency=" + slaveLatency + ", timeout=" + supervisionTimeout + "msec" + ", min_ce=" + minConnectionEventLen + ", max_ce=" + maxConnectionEventLen);
    }
    if (mService == null || mClientIf == 0)
        return false;
    try {
        mService.leConnectionUpdate(mClientIf, mDevice.getAddress(), minConnectionInterval, maxConnectionInterval, slaveLatency, supervisionTimeout, minConnectionEventLen, maxConnectionEventLen);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        return false;
    }
    return true;
}
Body of Second Method:
{
    if (DBG) {
        Log.d(TAG, "requestLeConnectionUpdate() - min=(" + minConnectionInterval + ")" + (1.25 * minConnectionInterval) + "msec, max=(" + maxConnectionInterval + ")" + (1.25 * maxConnectionInterval) + "msec, latency=" + slaveLatency + ", timeout=" + supervisionTimeout + "msec" + ", min_ce=" + minConnectionEventLen + ", max_ce=" + maxConnectionEventLen);
    }
    if (mService == null || mClientIf == 0)
        return false;
    try {
        mService.leConnectionUpdate(mClientIf, mDevice.getAddress(), minConnectionInterval, maxConnectionInterval, slaveLatency, supervisionTimeout, minConnectionEventLen, maxConnectionEventLen, mAttributionSource);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        return false;
    }
    return true;
}
------------------------
Find a silently evolved API code:android.hardware.camera2.params.StreamConfigurationMap.depthFormatToPublic:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Convert an internal format compatible with {@code graphics.h} into public-visible
 * {@code ImageFormat}. This assumes the dataspace of the format is HAL_DATASPACE_DEPTH.
 *
 * <p>In particular these formats are converted:
 * <ul>
 * <li>HAL_PIXEL_FORMAT_BLOB => ImageFormat.DEPTH_POINT_CLOUD
 * <li>HAL_PIXEL_FORMAT_Y16 => ImageFormat.DEPTH16
 * </ul>
 * </p>
 *
 * <p>Passing in an implementation-defined format which has no public equivalent will fail;
 * as will passing in a public format which has a different internal format equivalent.
 * See {@link #checkArgumentFormat} for more details about a legal public format.</p>
 *
 * <p>All other formats are returned as-is, no further invalid check is performed.</p>
 *
 * <p>This function is the dual of {@link #imageFormatToInternal} for formats associated with
 * HAL_DATASPACE_DEPTH.</p>
 *
 * @param format image format from {@link ImageFormat} or {@link PixelFormat}
 * @return the converted image formats
 *
 * @throws IllegalArgumentException
 * if {@code format} is {@code HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED} or
 * {@link ImageFormat#JPEG}
 *
 * @see ImageFormat
 * @see PixelFormat
 * @see #checkArgumentFormat
 * @hide
 */

Body of Frist Method:
{
    switch(format) {
        case HAL_PIXEL_FORMAT_BLOB:
            return ImageFormat.DEPTH_POINT_CLOUD;
        case HAL_PIXEL_FORMAT_Y16:
            return ImageFormat.DEPTH16;
        case HAL_PIXEL_FORMAT_RAW16:
            return ImageFormat.RAW_DEPTH;
        case ImageFormat.JPEG:
            throw new IllegalArgumentException("ImageFormat.JPEG is an unknown internal format");
        case HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED:
            throw new IllegalArgumentException("IMPLEMENTATION_DEFINED must not leak to public API");
        default:
            throw new IllegalArgumentException("Unknown DATASPACE_DEPTH format " + format);
    }
}
Body of Second Method:
{
    switch(format) {
        case HAL_PIXEL_FORMAT_BLOB:
            return ImageFormat.DEPTH_POINT_CLOUD;
        case HAL_PIXEL_FORMAT_Y16:
            return ImageFormat.DEPTH16;
        case HAL_PIXEL_FORMAT_RAW16:
            return ImageFormat.RAW_DEPTH;
        case HAL_PIXEL_FORMAT_RAW10:
            return ImageFormat.RAW_DEPTH10;
        case ImageFormat.JPEG:
            throw new IllegalArgumentException("ImageFormat.JPEG is an unknown internal format");
        case HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED:
            throw new IllegalArgumentException("IMPLEMENTATION_DEFINED must not leak to public API");
        default:
            throw new IllegalArgumentException("Unknown DATASPACE_DEPTH format " + format);
    }
}
------------------------
Find a silently evolved API code:android.content.pm.ShortcutManager.onApplicationActive:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Called internally when an app is considered to have come to the foreground
 * even when technically it's not.  This method resets the throttling for this package.
 * For example, when the user sends an "inline reply" on a notification, the system UI will
 * call it.
 *
 * @hide
 */

Body of Frist Method:
{
    try {
        mService.onApplicationActive(packageName, userId);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    try {
        getFutureOrThrow(mService.onApplicationActive(packageName, userId));
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.view.VerifiedMotionEvent.getFlag:COMMENT
Method Modifier: public      
Comment:/**
 * Get a specific flag of this motion event, if possible. Return null if the flag value could
 * not be checked.
 *
 * @param flag the flag of interest
 * @return Boolean(true) if the motion event has the requested flag
 * Boolean(false) if the motion event does not have the requested flag
 * null if the flag value could not be checked
 *
 * @see MotionEvent#FLAG_WINDOW_IS_OBSCURED
 * @see MotionEvent#FLAG_WINDOW_IS_PARTIALLY_OBSCURED
 */

Body of Frist Method:
{
    switch(flag) {
        // These values must be kept in sync with Input.cpp
        case FLAG_WINDOW_IS_OBSCURED:
        case FLAG_WINDOW_IS_PARTIALLY_OBSCURED:
            return (mFlags & flag) != 0;
    }
    return null;
}
Body of Second Method:
{
    switch(flag) {
        // These values must be kept in sync with Input.cpp
        case FLAG_IS_ACCESSIBILITY_EVENT:
        case FLAG_WINDOW_IS_OBSCURED:
        case FLAG_WINDOW_IS_PARTIALLY_OBSCURED:
            return (mFlags & flag) != 0;
    }
    return null;
}
------------------------
Find a silently evolved API code:android.app.admin.DeviceAdminReceiver.onReceive:COMMENT
Method Modifier: public      
Comment:/**
 * Intercept standard device administrator broadcasts.  Implementations
 * should not override this method; it is better to implement the
 * convenience callbacks for each action.
 */

Body of Frist Method:
{
    String action = intent.getAction();
    if (ACTION_PASSWORD_CHANGED.equals(action)) {
        onPasswordChanged(context, intent, intent.getParcelableExtra(Intent.EXTRA_USER));
    } else if (ACTION_PASSWORD_FAILED.equals(action)) {
        onPasswordFailed(context, intent, intent.getParcelableExtra(Intent.EXTRA_USER));
    } else if (ACTION_PASSWORD_SUCCEEDED.equals(action)) {
        onPasswordSucceeded(context, intent, intent.getParcelableExtra(Intent.EXTRA_USER));
    } else if (ACTION_DEVICE_ADMIN_ENABLED.equals(action)) {
        onEnabled(context, intent);
    } else if (ACTION_DEVICE_ADMIN_DISABLE_REQUESTED.equals(action)) {
        CharSequence res = onDisableRequested(context, intent);
        if (res != null) {
            Bundle extras = getResultExtras(true);
            extras.putCharSequence(EXTRA_DISABLE_WARNING, res);
        }
    } else if (ACTION_DEVICE_ADMIN_DISABLED.equals(action)) {
        onDisabled(context, intent);
    } else if (ACTION_PASSWORD_EXPIRING.equals(action)) {
        onPasswordExpiring(context, intent, intent.getParcelableExtra(Intent.EXTRA_USER));
    } else if (ACTION_PROFILE_PROVISIONING_COMPLETE.equals(action)) {
        onProfileProvisioningComplete(context, intent);
    } else if (ACTION_CHOOSE_PRIVATE_KEY_ALIAS.equals(action)) {
        int uid = intent.getIntExtra(EXTRA_CHOOSE_PRIVATE_KEY_SENDER_UID, -1);
        Uri uri = intent.getParcelableExtra(EXTRA_CHOOSE_PRIVATE_KEY_URI);
        String alias = intent.getStringExtra(EXTRA_CHOOSE_PRIVATE_KEY_ALIAS);
        String chosenAlias = onChoosePrivateKeyAlias(context, intent, uid, uri, alias);
        setResultData(chosenAlias);
    } else if (ACTION_LOCK_TASK_ENTERING.equals(action)) {
        String pkg = intent.getStringExtra(EXTRA_LOCK_TASK_PACKAGE);
        onLockTaskModeEntering(context, intent, pkg);
    } else if (ACTION_LOCK_TASK_EXITING.equals(action)) {
        onLockTaskModeExiting(context, intent);
    } else if (ACTION_NOTIFY_PENDING_SYSTEM_UPDATE.equals(action)) {
        long receivedTime = intent.getLongExtra(EXTRA_SYSTEM_UPDATE_RECEIVED_TIME, -1);
        onSystemUpdatePending(context, intent, receivedTime);
    } else if (ACTION_BUGREPORT_SHARING_DECLINED.equals(action)) {
        onBugreportSharingDeclined(context, intent);
    } else if (ACTION_BUGREPORT_SHARE.equals(action)) {
        String bugreportFileHash = intent.getStringExtra(EXTRA_BUGREPORT_HASH);
        onBugreportShared(context, intent, bugreportFileHash);
    } else if (ACTION_BUGREPORT_FAILED.equals(action)) {
        int failureCode = intent.getIntExtra(EXTRA_BUGREPORT_FAILURE_REASON, BUGREPORT_FAILURE_FAILED_COMPLETING);
        onBugreportFailed(context, intent, failureCode);
    } else if (ACTION_SECURITY_LOGS_AVAILABLE.equals(action)) {
        onSecurityLogsAvailable(context, intent);
    } else if (ACTION_NETWORK_LOGS_AVAILABLE.equals(action)) {
        long batchToken = intent.getLongExtra(EXTRA_NETWORK_LOGS_TOKEN, -1);
        int networkLogsCount = intent.getIntExtra(EXTRA_NETWORK_LOGS_COUNT, 0);
        onNetworkLogsAvailable(context, intent, batchToken, networkLogsCount);
    } else if (ACTION_USER_ADDED.equals(action)) {
        onUserAdded(context, intent, intent.getParcelableExtra(Intent.EXTRA_USER));
    } else if (ACTION_USER_REMOVED.equals(action)) {
        onUserRemoved(context, intent, intent.getParcelableExtra(Intent.EXTRA_USER));
    } else if (ACTION_USER_STARTED.equals(action)) {
        onUserStarted(context, intent, intent.getParcelableExtra(Intent.EXTRA_USER));
    } else if (ACTION_USER_STOPPED.equals(action)) {
        onUserStopped(context, intent, intent.getParcelableExtra(Intent.EXTRA_USER));
    } else if (ACTION_USER_SWITCHED.equals(action)) {
        onUserSwitched(context, intent, intent.getParcelableExtra(Intent.EXTRA_USER));
    } else if (ACTION_TRANSFER_OWNERSHIP_COMPLETE.equals(action)) {
        PersistableBundle bundle = intent.getParcelableExtra(EXTRA_TRANSFER_OWNERSHIP_ADMIN_EXTRAS_BUNDLE);
        onTransferOwnershipComplete(context, bundle);
    } else if (ACTION_AFFILIATED_PROFILE_TRANSFER_OWNERSHIP_COMPLETE.equals(action)) {
        onTransferAffiliatedProfileOwnershipComplete(context, intent.getParcelableExtra(Intent.EXTRA_USER));
    }
}
Body of Second Method:
{
    String action = intent.getAction();
    if (LOCAL_LOGV) {
        Log.v(TAG, getClass().getName() + ".onReceive(): received " + action + " on user " + context.getUserId());
    }
    if (ACTION_PASSWORD_CHANGED.equals(action)) {
        onPasswordChanged(context, intent, intent.getParcelableExtra(Intent.EXTRA_USER));
    } else if (ACTION_PASSWORD_FAILED.equals(action)) {
        onPasswordFailed(context, intent, intent.getParcelableExtra(Intent.EXTRA_USER));
    } else if (ACTION_PASSWORD_SUCCEEDED.equals(action)) {
        onPasswordSucceeded(context, intent, intent.getParcelableExtra(Intent.EXTRA_USER));
    } else if (ACTION_DEVICE_ADMIN_ENABLED.equals(action)) {
        onEnabled(context, intent);
    } else if (ACTION_DEVICE_ADMIN_DISABLE_REQUESTED.equals(action)) {
        CharSequence res = onDisableRequested(context, intent);
        if (res != null) {
            Bundle extras = getResultExtras(true);
            extras.putCharSequence(EXTRA_DISABLE_WARNING, res);
        }
    } else if (ACTION_DEVICE_ADMIN_DISABLED.equals(action)) {
        onDisabled(context, intent);
    } else if (ACTION_PASSWORD_EXPIRING.equals(action)) {
        onPasswordExpiring(context, intent, intent.getParcelableExtra(Intent.EXTRA_USER));
    } else if (ACTION_PROFILE_PROVISIONING_COMPLETE.equals(action)) {
        onProfileProvisioningComplete(context, intent);
    } else if (ACTION_CHOOSE_PRIVATE_KEY_ALIAS.equals(action)) {
        int uid = intent.getIntExtra(EXTRA_CHOOSE_PRIVATE_KEY_SENDER_UID, -1);
        Uri uri = intent.getParcelableExtra(EXTRA_CHOOSE_PRIVATE_KEY_URI);
        String alias = intent.getStringExtra(EXTRA_CHOOSE_PRIVATE_KEY_ALIAS);
        String chosenAlias = onChoosePrivateKeyAlias(context, intent, uid, uri, alias);
        setResultData(chosenAlias);
    } else if (ACTION_LOCK_TASK_ENTERING.equals(action)) {
        String pkg = intent.getStringExtra(EXTRA_LOCK_TASK_PACKAGE);
        onLockTaskModeEntering(context, intent, pkg);
    } else if (ACTION_LOCK_TASK_EXITING.equals(action)) {
        onLockTaskModeExiting(context, intent);
    } else if (ACTION_NOTIFY_PENDING_SYSTEM_UPDATE.equals(action)) {
        long receivedTime = intent.getLongExtra(EXTRA_SYSTEM_UPDATE_RECEIVED_TIME, -1);
        onSystemUpdatePending(context, intent, receivedTime);
    } else if (ACTION_BUGREPORT_SHARING_DECLINED.equals(action)) {
        onBugreportSharingDeclined(context, intent);
    } else if (ACTION_BUGREPORT_SHARE.equals(action)) {
        String bugreportFileHash = intent.getStringExtra(EXTRA_BUGREPORT_HASH);
        onBugreportShared(context, intent, bugreportFileHash);
    } else if (ACTION_BUGREPORT_FAILED.equals(action)) {
        int failureCode = intent.getIntExtra(EXTRA_BUGREPORT_FAILURE_REASON, BUGREPORT_FAILURE_FAILED_COMPLETING);
        onBugreportFailed(context, intent, failureCode);
    } else if (ACTION_SECURITY_LOGS_AVAILABLE.equals(action)) {
        onSecurityLogsAvailable(context, intent);
    } else if (ACTION_NETWORK_LOGS_AVAILABLE.equals(action)) {
        long batchToken = intent.getLongExtra(EXTRA_NETWORK_LOGS_TOKEN, -1);
        int networkLogsCount = intent.getIntExtra(EXTRA_NETWORK_LOGS_COUNT, 0);
        onNetworkLogsAvailable(context, intent, batchToken, networkLogsCount);
    } else if (ACTION_USER_ADDED.equals(action)) {
        onUserAdded(context, intent, intent.getParcelableExtra(Intent.EXTRA_USER));
    } else if (ACTION_USER_REMOVED.equals(action)) {
        onUserRemoved(context, intent, intent.getParcelableExtra(Intent.EXTRA_USER));
    } else if (ACTION_USER_STARTED.equals(action)) {
        onUserStarted(context, intent, intent.getParcelableExtra(Intent.EXTRA_USER));
    } else if (ACTION_USER_STOPPED.equals(action)) {
        onUserStopped(context, intent, intent.getParcelableExtra(Intent.EXTRA_USER));
    } else if (ACTION_USER_SWITCHED.equals(action)) {
        onUserSwitched(context, intent, intent.getParcelableExtra(Intent.EXTRA_USER));
    } else if (ACTION_TRANSFER_OWNERSHIP_COMPLETE.equals(action)) {
        PersistableBundle bundle = intent.getParcelableExtra(EXTRA_TRANSFER_OWNERSHIP_ADMIN_EXTRAS_BUNDLE);
        onTransferOwnershipComplete(context, bundle);
    } else if (ACTION_AFFILIATED_PROFILE_TRANSFER_OWNERSHIP_COMPLETE.equals(action)) {
        onTransferAffiliatedProfileOwnershipComplete(context, intent.getParcelableExtra(Intent.EXTRA_USER));
    } else if (ACTION_OPERATION_SAFETY_STATE_CHANGED.equals(action)) {
        onOperationSafetyStateChanged(context, intent);
    } else if (ACTION_COMPLIANCE_ACKNOWLEDGEMENT_REQUIRED.equals(action)) {
        onComplianceAcknowledgementRequired(context, intent);
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadset.setForceScoAudio:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Force SCO audio to be opened regardless any other restrictions
 *
 * @param forced Whether or not SCO audio connection should be forced: True to force SCO audio
 * False to use SCO audio in normal manner
 * @hide
 */

Body of Frist Method:
{
    if (VDBG)
        log("setForceScoAudio " + String.valueOf(forced));
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled()) {
        try {
            service.setForceScoAudio(forced);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
}
Body of Second Method:
{
    if (VDBG)
        log("setForceScoAudio " + String.valueOf(forced));
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled()) {
        try {
            service.setForceScoAudio(forced, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
}
------------------------
Find a silently evolved API code:android.hardware.display.BrightnessChangeEvent.Builder.build:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Builds a BrightnessChangeEvent
 */

Body of Frist Method:
{
    return new BrightnessChangeEvent(mBrightness, mTimeStamp, mPackageName, mUserId, mLuxValues, mLuxTimestamps, mBatteryLevel, mPowerBrightnessFactor, mNightMode, mColorTemperature, mLastBrightness, mIsDefaultBrightnessConfig, mIsUserSetBrightness, mColorValueBuckets, mColorSampleDuration);
}
Body of Second Method:
{
    return new BrightnessChangeEvent(mBrightness, mTimeStamp, mPackageName, mUserId, mUniqueDisplayId, mLuxValues, mLuxTimestamps, mBatteryLevel, mPowerBrightnessFactor, mNightMode, mColorTemperature, mReduceBrightColors, mReduceBrightColorsStrength, mReduceBrightColorsOffset, mLastBrightness, mIsDefaultBrightnessConfig, mIsUserSetBrightness, mColorValueBuckets, mColorSampleDuration);
}
------------------------
Find a silently evolved API code:android.content.pm.SuspendDialogInfo.restoreFromXml:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    final SuspendDialogInfo.Builder dialogInfoBuilder = new SuspendDialogInfo.Builder();
    try {
        final int iconId = XmlUtils.readIntAttribute(in, XML_ATTR_ICON_RES_ID, ID_NULL);
        final int titleId = XmlUtils.readIntAttribute(in, XML_ATTR_TITLE_RES_ID, ID_NULL);
        final int buttonTextId = XmlUtils.readIntAttribute(in, XML_ATTR_BUTTON_TEXT_RES_ID, ID_NULL);
        final int buttonAction = XmlUtils.readIntAttribute(in, XML_ATTR_BUTTON_ACTION, BUTTON_ACTION_MORE_DETAILS);
        final int dialogMessageResId = XmlUtils.readIntAttribute(in, XML_ATTR_DIALOG_MESSAGE_RES_ID, ID_NULL);
        final String dialogMessage = XmlUtils.readStringAttribute(in, XML_ATTR_DIALOG_MESSAGE);
        if (iconId != ID_NULL) {
            dialogInfoBuilder.setIcon(iconId);
        }
        if (titleId != ID_NULL) {
            dialogInfoBuilder.setTitle(titleId);
        }
        if (buttonTextId != ID_NULL) {
            dialogInfoBuilder.setNeutralButtonText(buttonTextId);
        }
        if (dialogMessageResId != ID_NULL) {
            dialogInfoBuilder.setMessage(dialogMessageResId);
        } else if (dialogMessage != null) {
            dialogInfoBuilder.setMessage(dialogMessage);
        }
        dialogInfoBuilder.setNeutralButtonAction(buttonAction);
    } catch (Exception e) {
        Slog.e(TAG, "Exception while parsing from xml. Some fields may default", e);
    }
    return dialogInfoBuilder.build();
}
Body of Second Method:
{
    final SuspendDialogInfo.Builder dialogInfoBuilder = new SuspendDialogInfo.Builder();
    try {
        final int iconId = in.getAttributeInt(null, XML_ATTR_ICON_RES_ID, ID_NULL);
        final int titleId = in.getAttributeInt(null, XML_ATTR_TITLE_RES_ID, ID_NULL);
        final String title = XmlUtils.readStringAttribute(in, XML_ATTR_TITLE);
        final int buttonTextId = in.getAttributeInt(null, XML_ATTR_BUTTON_TEXT_RES_ID, ID_NULL);
        final String buttonText = XmlUtils.readStringAttribute(in, XML_ATTR_BUTTON_TEXT);
        final int buttonAction = in.getAttributeInt(null, XML_ATTR_BUTTON_ACTION, BUTTON_ACTION_MORE_DETAILS);
        final int dialogMessageResId = in.getAttributeInt(null, XML_ATTR_DIALOG_MESSAGE_RES_ID, ID_NULL);
        final String dialogMessage = XmlUtils.readStringAttribute(in, XML_ATTR_DIALOG_MESSAGE);
        if (iconId != ID_NULL) {
            dialogInfoBuilder.setIcon(iconId);
        }
        if (titleId != ID_NULL) {
            dialogInfoBuilder.setTitle(titleId);
        } else if (title != null) {
            dialogInfoBuilder.setTitle(title);
        }
        if (buttonTextId != ID_NULL) {
            dialogInfoBuilder.setNeutralButtonText(buttonTextId);
        } else if (buttonText != null) {
            dialogInfoBuilder.setNeutralButtonText(buttonText);
        }
        if (dialogMessageResId != ID_NULL) {
            dialogInfoBuilder.setMessage(dialogMessageResId);
        } else if (dialogMessage != null) {
            dialogInfoBuilder.setMessage(dialogMessage);
        }
        dialogInfoBuilder.setNeutralButtonAction(buttonAction);
    } catch (Exception e) {
        Slog.e(TAG, "Exception while parsing from xml. Some fields may default", e);
    }
    return dialogInfoBuilder.build();
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadset.getActiveDevice:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the connected device that is active.
 *
 * @return the connected device that is active or null if no device
 * is active.
 * @hide
 */

Body of Frist Method:
{
    if (VDBG) {
        Log.d(TAG, "getActiveDevice");
    }
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled()) {
        try {
            return service.getActiveDevice();
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null) {
        Log.w(TAG, "Proxy not attached to service");
    }
    return null;
}
Body of Second Method:
{
    if (VDBG) {
        Log.d(TAG, "getActiveDevice");
    }
    final IBluetoothHeadset service = mService;
    if (service != null && isEnabled()) {
        try {
            return Attributable.setAttributionSource(service.getActiveDevice(mAttributionSource), mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null) {
        Log.w(TAG, "Proxy not attached to service");
    }
    return null;
}
------------------------
Find a silently evolved API code:android.media.tv.tuner.frontend.DvbsFrontendSettings.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Builds a {@link DvbsFrontendSettings} object.
 */

Body of Frist Method:
{
    return new DvbsFrontendSettings(mFrequency, mModulation, mCodeRate, mSymbolRate, mRolloff, mPilot, mInputStreamId, mStandard, mVcmMode);
}
Body of Second Method:
{
    return new DvbsFrontendSettings(mFrequency, mModulation, mCodeRate, mSymbolRate, mRolloff, mPilot, mInputStreamId, mStandard, mVcmMode, mScanType, mIsDiseqcRxMessage);
}
------------------------
Find a silently evolved API code:android.telephony.CellSignalStrengthLte.copyFrom:COMMENT
Method Modifier: protected   hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    mSignalStrength = s.mSignalStrength;
    mRssi = s.mRssi;
    mRsrp = s.mRsrp;
    mRsrq = s.mRsrq;
    mRssnr = s.mRssnr;
    mCqi = s.mCqi;
    mTimingAdvance = s.mTimingAdvance;
    mLevel = s.mLevel;
    mParametersUseForLevel = s.mParametersUseForLevel;
}
Body of Second Method:
{
    mSignalStrength = s.mSignalStrength;
    mRssi = s.mRssi;
    mRsrp = s.mRsrp;
    mRsrq = s.mRsrq;
    mRssnr = s.mRssnr;
    mCqiTableIndex = s.mCqiTableIndex;
    mCqi = s.mCqi;
    mTimingAdvance = s.mTimingAdvance;
    mLevel = s.mLevel;
    mParametersUseForLevel = s.mParametersUseForLevel;
}
------------------------
Find a silently evolved API code:android.app.admin.SystemUpdateInfo.writeToXml:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    out.startTag(null, tag);
    out.attribute(null, ATTR_RECEIVED_TIME, String.valueOf(mReceivedTime));
    out.attribute(null, ATTR_SECURITY_PATCH_STATE, String.valueOf(mSecurityPatchState));
    out.attribute(null, ATTR_ORIGINAL_BUILD, Build.FINGERPRINT);
    out.endTag(null, tag);
}
Body of Second Method:
{
    out.startTag(null, tag);
    out.attributeLong(null, ATTR_RECEIVED_TIME, mReceivedTime);
    out.attributeInt(null, ATTR_SECURITY_PATCH_STATE, mSecurityPatchState);
    out.attribute(null, ATTR_ORIGINAL_BUILD, Build.FINGERPRINT);
    out.endTag(null, tag);
}
------------------------
Find a silently evolved API code:android.app.job.JobParameters.setStopReason:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    stopReason = reason;
    this.debugStopReason = debugStopReason;
}
Body of Second Method:
{
    mStopReason = reason;
    mInternalStopReason = internalStopReason;
    this.debugStopReason = debugStopReason;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothClass.doesClassMatch:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Check class bits for possible bluetooth profile support.
 * This is a simple heuristic that tries to guess if a device with the
 * given class bits might support specified profile. It is not accurate for all
 * devices. It tries to err on the side of false positives.
 *
 * @param profile The profile to be checked
 * @return True if this device might support specified profile.
 * @hide
 */

Body of Frist Method:
{
    if (profile == PROFILE_A2DP) {
        if (hasService(Service.RENDER)) {
            return true;
        }
        // match on some other class bits.
        switch(getDeviceClass()) {
            case Device.AUDIO_VIDEO_HIFI_AUDIO:
            case Device.AUDIO_VIDEO_HEADPHONES:
            case Device.AUDIO_VIDEO_LOUDSPEAKER:
            case Device.AUDIO_VIDEO_CAR_AUDIO:
                return true;
            default:
                return false;
        }
    } else if (profile == PROFILE_A2DP_SINK) {
        if (hasService(Service.CAPTURE)) {
            return true;
        }
        // match on some other class bits.
        switch(getDeviceClass()) {
            case Device.AUDIO_VIDEO_HIFI_AUDIO:
            case Device.AUDIO_VIDEO_SET_TOP_BOX:
            case Device.AUDIO_VIDEO_VCR:
                return true;
            default:
                return false;
        }
    } else if (profile == PROFILE_HEADSET) {
        // pretty good signal
        if (hasService(Service.RENDER)) {
            return true;
        }
        // Just in case they forgot the render service class
        switch(getDeviceClass()) {
            case Device.AUDIO_VIDEO_HANDSFREE:
            case Device.AUDIO_VIDEO_WEARABLE_HEADSET:
            case Device.AUDIO_VIDEO_CAR_AUDIO:
                return true;
            default:
                return false;
        }
    } else if (profile == PROFILE_OPP) {
        if (hasService(Service.OBJECT_TRANSFER)) {
            return true;
        }
        switch(getDeviceClass()) {
            case Device.COMPUTER_UNCATEGORIZED:
            case Device.COMPUTER_DESKTOP:
            case Device.COMPUTER_SERVER:
            case Device.COMPUTER_LAPTOP:
            case Device.COMPUTER_HANDHELD_PC_PDA:
            case Device.COMPUTER_PALM_SIZE_PC_PDA:
            case Device.COMPUTER_WEARABLE:
            case Device.PHONE_UNCATEGORIZED:
            case Device.PHONE_CELLULAR:
            case Device.PHONE_CORDLESS:
            case Device.PHONE_SMART:
            case Device.PHONE_MODEM_OR_GATEWAY:
            case Device.PHONE_ISDN:
                return true;
            default:
                return false;
        }
    } else if (profile == PROFILE_HID) {
        return (getDeviceClass() & Device.Major.PERIPHERAL) == Device.Major.PERIPHERAL;
    } else if (profile == PROFILE_PANU || profile == PROFILE_NAP) {
        // No good way to distinguish between the two, based on class bits.
        if (hasService(Service.NETWORKING)) {
            return true;
        }
        return (getDeviceClass() & Device.Major.NETWORKING) == Device.Major.NETWORKING;
    } else {
        return false;
    }
}
Body of Second Method:
{
    if (profile == PROFILE_A2DP) {
        if (hasService(Service.RENDER)) {
            return true;
        }
        // match on some other class bits.
        switch(getDeviceClass()) {
            case Device.AUDIO_VIDEO_HIFI_AUDIO:
            case Device.AUDIO_VIDEO_HEADPHONES:
            case Device.AUDIO_VIDEO_LOUDSPEAKER:
            case Device.AUDIO_VIDEO_CAR_AUDIO:
                return true;
            default:
                return false;
        }
    } else if (profile == PROFILE_A2DP_SINK) {
        if (hasService(Service.CAPTURE)) {
            return true;
        }
        // match on some other class bits.
        switch(getDeviceClass()) {
            case Device.AUDIO_VIDEO_HIFI_AUDIO:
            case Device.AUDIO_VIDEO_SET_TOP_BOX:
            case Device.AUDIO_VIDEO_VCR:
                return true;
            default:
                return false;
        }
    } else if (profile == PROFILE_HEADSET) {
        // pretty good signal
        if (hasService(Service.RENDER)) {
            return true;
        }
        // Just in case they forgot the render service class
        switch(getDeviceClass()) {
            case Device.AUDIO_VIDEO_HANDSFREE:
            case Device.AUDIO_VIDEO_WEARABLE_HEADSET:
            case Device.AUDIO_VIDEO_CAR_AUDIO:
                return true;
            default:
                return false;
        }
    } else if (profile == PROFILE_OPP) {
        if (hasService(Service.OBJECT_TRANSFER)) {
            return true;
        }
        switch(getDeviceClass()) {
            case Device.COMPUTER_UNCATEGORIZED:
            case Device.COMPUTER_DESKTOP:
            case Device.COMPUTER_SERVER:
            case Device.COMPUTER_LAPTOP:
            case Device.COMPUTER_HANDHELD_PC_PDA:
            case Device.COMPUTER_PALM_SIZE_PC_PDA:
            case Device.COMPUTER_WEARABLE:
            case Device.PHONE_UNCATEGORIZED:
            case Device.PHONE_CELLULAR:
            case Device.PHONE_CORDLESS:
            case Device.PHONE_SMART:
            case Device.PHONE_MODEM_OR_GATEWAY:
            case Device.PHONE_ISDN:
                return true;
            default:
                return false;
        }
    } else if (profile == PROFILE_HID) {
        return getMajorDeviceClass() == Device.Major.PERIPHERAL;
    } else if (profile == PROFILE_PANU || profile == PROFILE_NAP) {
        // No good way to distinguish between the two, based on class bits.
        if (hasService(Service.NETWORKING)) {
            return true;
        }
        return getMajorDeviceClass() == Device.Major.NETWORKING;
    } else {
        return false;
    }
}
------------------------
Find a silently evolved API code:android.media.AudioPlaybackConfiguration.anonymizedCopy:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 * Creates a copy of the playback configuration that is stripped of any data enabling
 * identification of which application it is associated with ("anonymized").
 * @param toSanitize
 */

Body of Frist Method:
{
    final AudioPlaybackConfiguration anonymCopy = new AudioPlaybackConfiguration(in.mPlayerIId);
    anonymCopy.mPlayerState = in.mPlayerState;
    // do not reuse the full attributes: only usage, content type and public flags are allowed
    anonymCopy.mPlayerAttr = new AudioAttributes.Builder().setUsage(in.mPlayerAttr.getUsage()).setContentType(in.mPlayerAttr.getContentType()).setFlags(in.mPlayerAttr.getFlags()).setAllowedCapturePolicy(in.mPlayerAttr.getAllowedCapturePolicy() == ALLOW_CAPTURE_BY_ALL ? ALLOW_CAPTURE_BY_ALL : ALLOW_CAPTURE_BY_NONE).build();
    // anonymized data
    anonymCopy.mPlayerType = PLAYER_TYPE_UNKNOWN;
    anonymCopy.mClientUid = PLAYER_UPID_INVALID;
    anonymCopy.mClientPid = PLAYER_UPID_INVALID;
    anonymCopy.mIPlayerShell = null;
    return anonymCopy;
}
Body of Second Method:
{
    final AudioPlaybackConfiguration anonymCopy = new AudioPlaybackConfiguration(in.mPlayerIId);
    anonymCopy.mPlayerState = in.mPlayerState;
    // do not reuse the full attributes: only usage, content type and public flags are allowed
    AudioAttributes.Builder builder = new AudioAttributes.Builder().setContentType(in.mPlayerAttr.getContentType()).setFlags(in.mPlayerAttr.getFlags()).setAllowedCapturePolicy(in.mPlayerAttr.getAllowedCapturePolicy() == ALLOW_CAPTURE_BY_ALL ? ALLOW_CAPTURE_BY_ALL : ALLOW_CAPTURE_BY_NONE);
    if (AudioAttributes.isSystemUsage(in.mPlayerAttr.getSystemUsage())) {
        builder.setSystemUsage(in.mPlayerAttr.getSystemUsage());
    } else {
        builder.setUsage(in.mPlayerAttr.getUsage());
    }
    anonymCopy.mPlayerAttr = builder.build();
    anonymCopy.mDeviceId = in.mDeviceId;
    // anonymized data
    anonymCopy.mPlayerType = PLAYER_TYPE_UNKNOWN;
    anonymCopy.mClientUid = PLAYER_UPID_INVALID;
    anonymCopy.mClientPid = PLAYER_UPID_INVALID;
    anonymCopy.mIPlayerShell = null;
    anonymCopy.mSessionId = AudioSystem.AUDIO_SESSION_ALLOCATE;
    return anonymCopy;
}
------------------------
Find a silently evolved API code:android.security.KeyStoreParameter.Builder.build:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * Builds the instance of the {@code KeyStoreParameter}.
 *
 * @throws IllegalArgumentException if a required field is missing
 * @return built instance of {@code KeyStoreParameter}
 */

Body of Frist Method:
{
    return new KeyStoreParameter(mFlags);
}
Body of Second Method:
{
    return new KeyStoreParameter(0);
}
------------------------
Find a silently evolved API code:android.media.Rating.newStarRating:COMMENT
Method Modifier: public      static      
Comment:/**
 * Return a Rating instance with a star-based rating.
 * Create and return a new Rating instance with one of the star-base rating styles
 * and the given integer or fractional number of stars. Non integer values can for instance
 * be used to represent an average rating value, which might not be an integer number of stars.
 * @param starRatingStyle one of {@link #RATING_3_STARS}, {@link #RATING_4_STARS},
 * {@link #RATING_5_STARS}.
 * @param starRating a number ranging from 0.0f to 3.0f, 4.0f or 5.0f according to
 * the rating style.
 * @return null if the rating style is invalid, or the rating is out of range,
 * a new Rating instance otherwise.
 */

Body of Frist Method:
{
    float maxRating = -1.0f;
    switch(starRatingStyle) {
        case RATING_3_STARS:
            maxRating = 3.0f;
            break;
        case RATING_4_STARS:
            maxRating = 4.0f;
            break;
        case RATING_5_STARS:
            maxRating = 5.0f;
            break;
        default:
            Log.e(TAG, "Invalid rating style (" + starRatingStyle + ") for a star rating");
            return null;
    }
    if ((starRating < 0.0f) || (starRating > maxRating)) {
        Log.e(TAG, "Trying to set out of range star-based rating");
        return null;
    }
    return new Rating(starRatingStyle, starRating);
}
Body of Second Method:
{
    float maxRating = -1.0f;
    switch(starRatingStyle) {
        case RATING_3_STARS:
            maxRating = 3.0f;
            break;
        case RATING_4_STARS:
            maxRating = 4.0f;
            break;
        case RATING_5_STARS:
            maxRating = 5.0f;
            break;
        default:
            Log.e(TAG, "Invalid rating style (" + starRatingStyle + ") for a star rating");
            return null;
    }
    if (starRating >= 0.0f && starRating <= maxRating) {
        return new Rating(starRatingStyle, starRating);
    } else {
        Log.e(TAG, "Trying to set out of range star-based rating");
        return null;
    }
}
------------------------
Find a silently evolved API code:android.app.admin.DeviceAdminReceiver.onUserStopped:COMMENT
Method Modifier: public      
Comment:/**
 * Called when a user or profile is stopped.
 *
 * <p>This callback is only applicable to device owners.
 *
 * @param context The running context as per {@link #onReceive}.
 * @param intent The received intent as per {@link #onReceive}.
 * @param stoppedUser The {@link UserHandle} of the user that has just been stopped.
 */

Body of Frist Method:
{
}
Body of Second Method:
{
    if (LOCAL_LOGV) {
        Log.v(TAG, getClass().getName() + ".onUserStopped() on user " + context.getUserId());
    }
}
------------------------
Find a silently evolved API code:android.nfc.NfcAdapter.enableSecureNfc:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets Secure NFC feature.
 * <p>This API is for the Settings application.
 * @return True if successful
 * @hide
 */

Body of Frist Method:
{
    if (!sHasNfcFeature) {
        throw new UnsupportedOperationException();
    }
    try {
        return sService.setNfcSecure(enable);
    } catch (RemoteException e) {
        attemptDeadServiceRecovery(e);
        return false;
    }
}
Body of Second Method:
{
    if (!sHasNfcFeature) {
        throw new UnsupportedOperationException();
    }
    try {
        return sService.setNfcSecure(enable);
    } catch (RemoteException e) {
        attemptDeadServiceRecovery(e);
        // Try one more time
        if (sService == null) {
            Log.e(TAG, "Failed to recover NFC Service.");
            return false;
        }
        try {
            return sService.setNfcSecure(enable);
        } catch (RemoteException ee) {
            Log.e(TAG, "Failed to recover NFC Service.");
        }
        return false;
    }
}
------------------------
Find a silently evolved API code:android.view.animation.Transformation.printShortString:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Print short string, to optimize dumping.
 * @hide
 */

Body of Frist Method:
{
    pw.print("{alpha=");
    pw.print(mAlpha);
    pw.print(" matrix=");
    mMatrix.printShortString(pw);
    pw.print('}');
}
Body of Second Method:
{
    pw.print("{alpha=");
    pw.print(mAlpha);
    pw.print(" matrix=");
    mMatrix.dump(pw);
    pw.print('}');
}
------------------------
Find a silently evolved API code:android.content.res.CompatibilityInfo.isScalingRequired:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @return true if the scaling is required
 */

Body of Frist Method:
{
    return (mCompatibilityFlags & SCALING_REQUIRED) != 0;
}
Body of Second Method:
{
    return (mCompatibilityFlags & (SCALING_REQUIRED | HAS_OVERRIDE_SCALING)) != 0;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothDevice.isConnected:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns whether there is an open connection to this device.
 *
 * @return True if there is at least one open connection to this device.
 * @hide
 */

Body of Frist Method:
{
    final IBluetooth service = sService;
    if (service == null) {
        // BT is not enabled, we cannot be connected.
        return false;
    }
    try {
        return service.getConnectionState(this) != CONNECTION_STATE_DISCONNECTED;
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        return false;
    }
}
Body of Second Method:
{
    final IBluetooth service = sService;
    if (service == null) {
        // BT is not enabled, we cannot be connected.
        return false;
    }
    try {
        return service.getConnectionStateWithAttribution(this, mAttributionSource) != CONNECTION_STATE_DISCONNECTED;
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        return false;
    }
}
------------------------
Find a silently evolved API code:android.text.format.TimeFormatter.formatInternal:COMMENT
Method Modifier: private     
Comment:/**
 * Format the specified {@code wallTime} using {@code pattern}. The output is written to
 * {@link #outputBuilder}.
 */

Body of Frist Method:
{
    CharBuffer formatBuffer = CharBuffer.wrap(pattern);
    while (formatBuffer.remaining() > 0) {
        boolean outputCurrentChar = true;
        char currentChar = formatBuffer.get(formatBuffer.position());
        if (currentChar == '%') {
            outputCurrentChar = handleToken(formatBuffer, wallTime, zoneInfo);
        }
        if (outputCurrentChar) {
            outputBuilder.append(formatBuffer.get(formatBuffer.position()));
        }
        formatBuffer.position(formatBuffer.position() + 1);
    }
}
Body of Second Method:
{
    CharBuffer formatBuffer = CharBuffer.wrap(pattern);
    while (formatBuffer.remaining() > 0) {
        boolean outputCurrentChar = true;
        char currentChar = formatBuffer.get(formatBuffer.position());
        if (currentChar == '%') {
            outputCurrentChar = handleToken(formatBuffer, wallTime, zoneInfoData);
        }
        if (outputCurrentChar) {
            outputBuilder.append(formatBuffer.get(formatBuffer.position()));
        }
        formatBuffer.position(formatBuffer.position() + 1);
    }
}
------------------------
Find a silently evolved API code:android.telephony.CallForwardingInfo.equals:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (this == o)
        return true;
    if (!(o instanceof CallForwardingInfo)) {
        return false;
    }
    CallForwardingInfo other = (CallForwardingInfo) o;
    return mStatus == other.mStatus && mNumber == other.mNumber && mReason == other.mReason && mTimeSeconds == other.mTimeSeconds;
}
Body of Second Method:
{
    if (this == o)
        return true;
    if (!(o instanceof CallForwardingInfo)) {
        return false;
    }
    CallForwardingInfo other = (CallForwardingInfo) o;
    return mEnabled == other.mEnabled && mNumber == other.mNumber && mReason == other.mReason && mTimeSeconds == other.mTimeSeconds;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothPbapClient.getConnectionPolicy:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the connection policy of the profile.
 *
 * <p> The connection policy can be any of:
 * {@link #CONNECTION_POLICY_ALLOWED}, {@link #CONNECTION_POLICY_FORBIDDEN},
 * {@link #CONNECTION_POLICY_UNKNOWN}
 *
 * @param device Bluetooth device
 * @return connection policy of the device
 * @hide
 */

Body of Frist Method:
{
    if (VDBG) {
        log("getConnectionPolicy(" + device + ")");
    }
    final IBluetoothPbapClient service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getConnectionPolicy(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.CONNECTION_POLICY_FORBIDDEN;
        }
    }
    if (service == null) {
        Log.w(TAG, "Proxy not attached to service");
    }
    return BluetoothProfile.CONNECTION_POLICY_FORBIDDEN;
}
Body of Second Method:
{
    if (VDBG) {
        log("getConnectionPolicy(" + device + ")");
    }
    final IBluetoothPbapClient service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getConnectionPolicy(device, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.CONNECTION_POLICY_FORBIDDEN;
        }
    }
    if (service == null) {
        Log.w(TAG, "Proxy not attached to service");
    }
    return BluetoothProfile.CONNECTION_POLICY_FORBIDDEN;
}
------------------------
Find a silently evolved API code:android.telephony.CellSignalStrengthLte.writeToParcel:COMMENT
Method Modifier: public      
Comment:/**
 * Implement the Parcelable interface
 */

Body of Frist Method:
{
    if (DBG)
        log("writeToParcel(Parcel, int): " + toString());
    dest.writeInt(mRssi);
    // Need to multiply rsrp and rsrq by -1
    // to ensure consistency when reading values written here
    // unless the values are invalid
    dest.writeInt(mRsrp);
    dest.writeInt(mRsrq);
    dest.writeInt(mRssnr);
    dest.writeInt(mCqi);
    dest.writeInt(mTimingAdvance);
    dest.writeInt(mLevel);
}
Body of Second Method:
{
    if (DBG)
        log("writeToParcel(Parcel, int): " + toString());
    dest.writeInt(mRssi);
    // Need to multiply rsrp and rsrq by -1
    // to ensure consistency when reading values written here
    // unless the values are invalid
    dest.writeInt(mRsrp);
    dest.writeInt(mRsrq);
    dest.writeInt(mRssnr);
    dest.writeInt(mCqiTableIndex);
    dest.writeInt(mCqi);
    dest.writeInt(mTimingAdvance);
    dest.writeInt(mLevel);
}
------------------------
Find a silently evolved API code:android.hardware.camera2.utils.SurfaceUtils.getSurfaceDataspace:COMMENT
Method Modifier: public      static      
Comment:/**
 * Get the Surface dataspace.
 *
 * @param surface The surface to be queried for dataspace.
 * @return dataspace of the surface.
 *
 * @throws IllegalArgumentException if the surface is already abandoned.
 */

Body of Frist Method:
{
    try {
        return LegacyCameraDevice.detectSurfaceDataspace(surface);
    } catch (BufferQueueAbandonedException e) {
        throw new IllegalArgumentException("Surface was abandoned", e);
    }
}
Body of Second Method:
{
    checkNotNull(surface);
    int dataSpace = nativeDetectSurfaceDataspace(surface);
    if (dataSpace == BAD_VALUE)
        throw new IllegalArgumentException("Surface was abandoned");
    return dataSpace;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothGatt.refresh:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Clears the internal cache and forces a refresh of the services from the
 * remote device.
 *
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        Log.d(TAG, "refresh() - device: " + mDevice.getAddress());
    if (mService == null || mClientIf == 0)
        return false;
    try {
        mService.refreshDevice(mClientIf, mDevice.getAddress());
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        return false;
    }
    return true;
}
Body of Second Method:
{
    if (DBG)
        Log.d(TAG, "refresh() - device: " + mDevice.getAddress());
    if (mService == null || mClientIf == 0)
        return false;
    try {
        mService.refreshDevice(mClientIf, mDevice.getAddress(), mAttributionSource);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
        return false;
    }
    return true;
}
------------------------
Find a silently evolved API code:android.app.admin.DeviceAdminInfo.writePoliciesToXml:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    out.attribute(null, "flags", Integer.toString(mUsesPolicies));
}
Body of Second Method:
{
    out.attributeInt(null, "flags", mUsesPolicies);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothMap.setConnectionPolicy:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Set connection policy of the profile
 *
 * <p> The device should already be paired.
 * Connection policy can be one of {@link #CONNECTION_POLICY_ALLOWED},
 * {@link #CONNECTION_POLICY_FORBIDDEN}, {@link #CONNECTION_POLICY_UNKNOWN}
 *
 * @param device Paired bluetooth device
 * @param connectionPolicy is the connection policy to set to for this profile
 * @return true if connectionPolicy is set, false on error
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("setConnectionPolicy(" + device + ", " + connectionPolicy + ")");
    final IBluetoothMap service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        if (connectionPolicy != BluetoothProfile.CONNECTION_POLICY_FORBIDDEN && connectionPolicy != BluetoothProfile.CONNECTION_POLICY_ALLOWED) {
            return false;
        }
        try {
            return service.setConnectionPolicy(device, connectionPolicy);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("setConnectionPolicy(" + device + ", " + connectionPolicy + ")");
    final IBluetoothMap service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        if (connectionPolicy != BluetoothProfile.CONNECTION_POLICY_FORBIDDEN && connectionPolicy != BluetoothProfile.CONNECTION_POLICY_ALLOWED) {
            return false;
        }
        try {
            return service.setConnectionPolicy(device, connectionPolicy, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.graphics.text.MeasuredText.getCharWidthAt:COMMENT
Method Modifier: public      
Comment:/**
 * Returns the width of the character at the given offset.
 *
 * @param offset an offset of the character.
 */

Body of Frist Method:
{
    Preconditions.checkArgument(0 <= offset && offset < mChars.length, "offset(" + offset + ") is larger than text length: " + mChars.length);
    return nGetCharWidthAt(mNativePtr, offset);
}
Body of Second Method:
{
    Preconditions.checkArgument(0 <= offset && offset < mChars.length, "offset(%d) is larger than text length %d" + offset, mChars.length);
    return nGetCharWidthAt(mNativePtr, offset);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothPan.connect:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Initiate connection to a profile of the remote bluetooth device.
 *
 * <p> This API returns false in scenarios like the profile on the
 * device is already connected or Bluetooth is not turned on.
 * When this API returns true, it is guaranteed that
 * connection state intent for the profile will be broadcasted with
 * the state. Users can get the connection state of the profile
 * from this intent.
 *
 * @param device Remote Bluetooth Device
 * @return false on immediate error, true otherwise
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("connect(" + device + ")");
    final IBluetoothPan service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.connect(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("connect(" + device + ")");
    final IBluetoothPan service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.connect(device, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.getConnectedDevices:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Return the list of connected remote devices
 *
 * @return list of connected devices; empty list if nothing is connected.
 */

Body of Frist Method:
{
    if (VDBG)
        log("getConnectedDevices()");
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled()) {
        try {
            return service.getConnectedDevices();
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
Body of Second Method:
{
    if (VDBG)
        log("getConnectedDevices()");
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled()) {
        try {
            return Attributable.setAttributionSource(service.getConnectedDevices(mAttributionSource), mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothSap.disconnect:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Initiate disconnect.
 *
 * @param device Remote Bluetooth Device
 * @return false on error, true otherwise
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("disconnect(" + device + ")");
    final IBluetoothSap service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.disconnect(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("disconnect(" + device + ")");
    final IBluetoothSap service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.disconnect(device, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.bluetooth.le.AdvertisingSet.setAdvertisingParameters:COMMENT
Method Modifier: public      
Comment:/**
 * Update advertising parameters associated with this AdvertisingSet. Must be called when
 * advertising is not active. This method returns immediately, the operation status is delivered
 * through {@code callback.onAdvertisingParametersUpdated}.
 *
 * @param parameters advertising set parameters.
 */

Body of Frist Method:
{
    try {
        mGatt.setAdvertisingParameters(mAdvertiserId, parameters);
    } catch (RemoteException e) {
        Log.e(TAG, "remote exception - ", e);
    }
}
Body of Second Method:
{
    try {
        mGatt.setAdvertisingParameters(mAdvertiserId, parameters, mAttributionSource);
    } catch (RemoteException e) {
        Log.e(TAG, "remote exception - ", e);
    }
}
------------------------
Find a silently evolved API code:android.net.LocalSocketImpl.SocketInputStream.available:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    FileDescriptor myFd = fd;
    if (myFd == null)
        throw new IOException("socket closed");
    Int32Ref avail = new Int32Ref(0);
    try {
        Os.ioctlInt(myFd, OsConstants.FIONREAD, avail);
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
    return avail.value;
}
Body of Second Method:
{
    FileDescriptor myFd = fd;
    if (myFd == null)
        throw new IOException("socket closed");
    try {
        return Os.ioctlInt(myFd, OsConstants.FIONREAD);
    } catch (ErrnoException e) {
        throw e.rethrowAsIOException();
    }
}
------------------------
Find a silently evolved API code:android.widget.ToastPresenter.adjustLayoutParams:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Customizes {@code params} according to other parameters, ready to be passed to {@link
 * WindowManager#addView(View, ViewGroup.LayoutParams)}.
 */

Body of Frist Method:
{
    Configuration config = mResources.getConfiguration();
    int absGravity = Gravity.getAbsoluteGravity(gravity, config.getLayoutDirection());
    params.gravity = absGravity;
    if ((absGravity & Gravity.HORIZONTAL_GRAVITY_MASK) == Gravity.FILL_HORIZONTAL) {
        params.horizontalWeight = 1.0f;
    }
    if ((absGravity & Gravity.VERTICAL_GRAVITY_MASK) == Gravity.FILL_VERTICAL) {
        params.verticalWeight = 1.0f;
    }
    params.x = xOffset;
    params.y = yOffset;
    params.horizontalMargin = horizontalMargin;
    params.verticalMargin = verticalMargin;
    params.packageName = mContext.getPackageName();
    params.hideTimeoutMilliseconds = (duration == Toast.LENGTH_LONG) ? LONG_DURATION_TIMEOUT : SHORT_DURATION_TIMEOUT;
    params.token = windowToken;
}
Body of Second Method:
{
    Configuration config = mResources.getConfiguration();
    int absGravity = Gravity.getAbsoluteGravity(gravity, config.getLayoutDirection());
    params.gravity = absGravity;
    if ((absGravity & Gravity.HORIZONTAL_GRAVITY_MASK) == Gravity.FILL_HORIZONTAL) {
        params.horizontalWeight = 1.0f;
    }
    if ((absGravity & Gravity.VERTICAL_GRAVITY_MASK) == Gravity.FILL_VERTICAL) {
        params.verticalWeight = 1.0f;
    }
    params.x = xOffset;
    params.y = yOffset;
    params.horizontalMargin = horizontalMargin;
    params.verticalMargin = verticalMargin;
    params.packageName = mContext.getPackageName();
    params.hideTimeoutMilliseconds = (duration == Toast.LENGTH_LONG) ? LONG_DURATION_TIMEOUT : SHORT_DURATION_TIMEOUT;
    params.token = windowToken;
    if (removeWindowAnimations && params.windowAnimations == R.style.Animation_Toast) {
        params.windowAnimations = 0;
    }
}
------------------------
Find a silently evolved API code:android.widget.ProgressBar.formatStateDescription:COMMENT
Method Modifier: private     
Comment:/**
 * Default percentage format of the state description based on progress, for example,
 * "50 percent".
 *
 * @param progress the progress value, between {@link #getMin()} and {@link #getMax()}
 * @return state description based on progress
 */

Body of Frist Method:
{
    return NumberFormat.getPercentInstance(mContext.getResources().getConfiguration().locale).format(getPercent(progress));
}
Body of Second Method:
{
    // Cache the locale-appropriate NumberFormat.  Configuration locale is guaranteed
    // non-null, so the first time this is called we will always get the appropriate
    // NumberFormat, then never regenerate it unless the locale changes on the fly.
    final Locale curLocale = mContext.getResources().getConfiguration().getLocales().get(0);
    if (!curLocale.equals(mCachedLocale)) {
        mCachedLocale = curLocale;
        mPercentFormat = NumberFormat.getPercentInstance(curLocale);
    }
    return mPercentFormat.format(getPercent(progress));
}
------------------------
Find a silently evolved API code:android.content.pm.UserInfo.supportsSwitchTo:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @return true if this user can be switched to.
 */

Body of Frist Method:
{
    if (isEphemeral() && !isEnabled()) {
        // Don't support switching to an ephemeral user with removal in progress.
        return false;
    }
    if (preCreated) {
        // Don't support switching to pre-created users until they become "real" users.
        return false;
    }
    return !isProfile();
}
Body of Second Method:
{
    if (partial || !isEnabled()) {
        // removal in progress.
        return false;
    }
    if (preCreated) {
        // Don't support switching to pre-created users until they become "real" users.
        return false;
    }
    return !isProfile();
}
------------------------
Find a silently evolved API code:android.view.DragAndDropPermissions.release:COMMENT
Method Modifier: public      
Comment:/**
 * Revoke permissions explicitly.
 */

Body of Frist Method:
{
    try {
        mDragAndDropPermissions.release();
        mTransientToken = null;
    } catch (RemoteException e) {
    }
}
Body of Second Method:
{
    try {
        mDragAndDropPermissions.release();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.content.pm.parsing.PackageInfoWithoutStateUtils.generateActivityInfoUnchecked:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * This bypasses critical checks that are necessary for usage with data passed outside of
 * system server.
 *
 * Prefer {@link #generateActivityInfo(ParsingPackageRead, ParsedActivity, int,
 * PackageUserState, ApplicationInfo, int)}.
 */

Body of Frist Method:
{
    // Make shallow copies so we can store the metadata safely
    ActivityInfo ai = new ActivityInfo();
    assignSharedFieldsForComponentInfo(ai, a);
    ai.targetActivity = a.getTargetActivity();
    ai.processName = a.getProcessName();
    ai.exported = a.isExported();
    ai.theme = a.getTheme();
    ai.uiOptions = a.getUiOptions();
    ai.parentActivityName = a.getParentActivityName();
    ai.permission = a.getPermission();
    ai.taskAffinity = a.getTaskAffinity();
    ai.flags = a.getFlags();
    ai.privateFlags = a.getPrivateFlags();
    ai.launchMode = a.getLaunchMode();
    ai.documentLaunchMode = a.getDocumentLaunchMode();
    ai.maxRecents = a.getMaxRecents();
    ai.configChanges = a.getConfigChanges();
    ai.softInputMode = a.getSoftInputMode();
    ai.persistableMode = a.getPersistableMode();
    ai.lockTaskLaunchMode = a.getLockTaskLaunchMode();
    ai.screenOrientation = a.getScreenOrientation();
    ai.resizeMode = a.getResizeMode();
    Float maxAspectRatio = a.getMaxAspectRatio();
    ai.maxAspectRatio = maxAspectRatio != null ? maxAspectRatio : 0f;
    Float minAspectRatio = a.getMinAspectRatio();
    ai.minAspectRatio = minAspectRatio != null ? minAspectRatio : 0f;
    ai.supportsSizeChanges = a.getSupportsSizeChanges();
    ai.requestedVrComponent = a.getRequestedVrComponent();
    ai.rotationAnimation = a.getRotationAnimation();
    ai.colorMode = a.getColorMode();
    ai.windowLayout = a.getWindowLayout();
    ai.metaData = a.getMetaData();
    ai.applicationInfo = applicationInfo;
    return ai;
}
Body of Second Method:
{
    // Make shallow copies so we can store the metadata safely
    ActivityInfo ai = new ActivityInfo();
    assignSharedFieldsForComponentInfo(ai, a);
    ai.targetActivity = a.getTargetActivity();
    ai.processName = a.getProcessName();
    ai.exported = a.isExported();
    ai.theme = a.getTheme();
    ai.uiOptions = a.getUiOptions();
    ai.parentActivityName = a.getParentActivityName();
    ai.permission = a.getPermission();
    ai.taskAffinity = a.getTaskAffinity();
    ai.flags = a.getFlags();
    ai.privateFlags = a.getPrivateFlags();
    ai.launchMode = a.getLaunchMode();
    ai.documentLaunchMode = a.getDocumentLaunchMode();
    ai.maxRecents = a.getMaxRecents();
    ai.configChanges = a.getConfigChanges();
    ai.softInputMode = a.getSoftInputMode();
    ai.persistableMode = a.getPersistableMode();
    ai.lockTaskLaunchMode = a.getLockTaskLaunchMode();
    ai.screenOrientation = a.getScreenOrientation();
    ai.resizeMode = a.getResizeMode();
    Float maxAspectRatio = a.getMaxAspectRatio();
    ai.setMaxAspectRatio(maxAspectRatio != null ? maxAspectRatio : 0f);
    Float minAspectRatio = a.getMinAspectRatio();
    ai.setMinAspectRatio(minAspectRatio != null ? minAspectRatio : 0f);
    ai.supportsSizeChanges = a.getSupportsSizeChanges();
    ai.requestedVrComponent = a.getRequestedVrComponent();
    ai.rotationAnimation = a.getRotationAnimation();
    ai.colorMode = a.getColorMode();
    ai.windowLayout = a.getWindowLayout();
    ai.attributionTags = a.getAttributionTags();
    if ((flags & PackageManager.GET_META_DATA) != 0) {
        ai.metaData = a.getMetaData();
    }
    ai.applicationInfo = applicationInfo;
    return ai;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothPbapClient.getConnectionState:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get connection state of device
 *
 * @return device connection state
 */

Body of Frist Method:
{
    if (DBG) {
        log("getConnectionState(" + device + ")");
    }
    final IBluetoothPbapClient service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getConnectionState(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.STATE_DISCONNECTED;
        }
    }
    if (service == null) {
        Log.w(TAG, "Proxy not attached to service");
    }
    return BluetoothProfile.STATE_DISCONNECTED;
}
Body of Second Method:
{
    if (DBG) {
        log("getConnectionState(" + device + ")");
    }
    final IBluetoothPbapClient service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getConnectionState(device, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.STATE_DISCONNECTED;
        }
    }
    if (service == null) {
        Log.w(TAG, "Proxy not attached to service");
    }
    return BluetoothProfile.STATE_DISCONNECTED;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothMap.disconnect:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Initiate disconnect.
 *
 * @param device Remote Bluetooth Device
 * @return false on error, true otherwise
 *
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("disconnect(" + device + ")");
    final IBluetoothMap service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.disconnect(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("disconnect(" + device + ")");
    final IBluetoothMap service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.disconnect(device, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.telephony.ims.stub.ImsEcbmImplBase.exitedEcbm:COMMENT
Method Modifier: public      final       hidden      
Comment:/**
 * Notifies the framework when the device exits Emergency Callback Mode.
 *
 * @throws RuntimeException if the connection to the framework is not available.
 */

Body of Frist Method:
{
    Log.d(TAG, "Exited ECBM.");
    if (mListener != null) {
        try {
            mListener.exitedECBM();
        } catch (RemoteException e) {
            throw new RuntimeException(e);
        }
    }
}
Body of Second Method:
{
    Log.d(TAG, "Exited ECBM.");
    IImsEcbmListener listener;
    synchronized (mLock) {
        listener = mListener;
    }
    if (listener != null) {
        try {
            listener.exitedECBM();
        } catch (RemoteException e) {
            throw new RuntimeException(e);
        }
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.le.ScanSettings.Builder.setScanMode:COMMENT
Method Modifier: public      
Comment:/**
 * Set scan mode for Bluetooth LE scan.
 *
 * @param scanMode The scan mode can be one of {@link ScanSettings#SCAN_MODE_LOW_POWER},
 * {@link ScanSettings#SCAN_MODE_BALANCED} or {@link ScanSettings#SCAN_MODE_LOW_LATENCY}.
 * @throws IllegalArgumentException If the {@code scanMode} is invalid.
 */

Body of Frist Method:
{
    if (scanMode < SCAN_MODE_OPPORTUNISTIC || scanMode > SCAN_MODE_LOW_LATENCY) {
        throw new IllegalArgumentException("invalid scan mode " + scanMode);
    }
    mScanMode = scanMode;
    return this;
}
Body of Second Method:
{
    switch(scanMode) {
        case SCAN_MODE_OPPORTUNISTIC:
        case SCAN_MODE_LOW_POWER:
        case SCAN_MODE_BALANCED:
        case SCAN_MODE_LOW_LATENCY:
        case SCAN_MODE_AMBIENT_DISCOVERY:
            mScanMode = scanMode;
            break;
        default:
            throw new IllegalArgumentException("invalid scan mode " + scanMode);
    }
    return this;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothPbapClient.setConnectionPolicy:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Set connection policy of the profile
 *
 * <p> The device should already be paired.
 * Connection policy can be one of {@link #CONNECTION_POLICY_ALLOWED},
 * {@link #CONNECTION_POLICY_FORBIDDEN}, {@link #CONNECTION_POLICY_UNKNOWN}
 *
 * @param device Paired bluetooth device
 * @param connectionPolicy is the connection policy to set to for this profile
 * @return true if connectionPolicy is set, false on error
 * @hide
 */

Body of Frist Method:
{
    if (DBG) {
        log("setConnectionPolicy(" + device + ", " + connectionPolicy + ")");
    }
    final IBluetoothPbapClient service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        if (connectionPolicy != BluetoothProfile.CONNECTION_POLICY_FORBIDDEN && connectionPolicy != BluetoothProfile.CONNECTION_POLICY_ALLOWED) {
            return false;
        }
        try {
            return service.setConnectionPolicy(device, connectionPolicy);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null) {
        Log.w(TAG, "Proxy not attached to service");
    }
    return false;
}
Body of Second Method:
{
    if (DBG) {
        log("setConnectionPolicy(" + device + ", " + connectionPolicy + ")");
    }
    final IBluetoothPbapClient service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        if (connectionPolicy != BluetoothProfile.CONNECTION_POLICY_FORBIDDEN && connectionPolicy != BluetoothProfile.CONNECTION_POLICY_ALLOWED) {
            return false;
        }
        try {
            return service.setConnectionPolicy(device, connectionPolicy, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null) {
        Log.w(TAG, "Proxy not attached to service");
    }
    return false;
}
------------------------
Find a silently evolved API code:android.app.servertransaction.LaunchActivityItem.setValues:COMMENT
Method Modifier: private     static      hidden      
Comment:// Using the same method to set and clear values to make sure we don't forget anything

Body of Frist Method:
{
    instance.mIntent = intent;
    instance.mIdent = ident;
    instance.mInfo = info;
    instance.mCurConfig = curConfig;
    instance.mOverrideConfig = overrideConfig;
    instance.mCompatInfo = compatInfo;
    instance.mReferrer = referrer;
    instance.mVoiceInteractor = voiceInteractor;
    instance.mProcState = procState;
    instance.mState = state;
    instance.mPersistentState = persistentState;
    instance.mPendingResults = pendingResults;
    instance.mPendingNewIntents = pendingNewIntents;
    instance.mIsForward = isForward;
    instance.mProfilerInfo = profilerInfo;
    instance.mAssistToken = assistToken;
    instance.mFixedRotationAdjustments = fixedRotationAdjustments;
}
Body of Second Method:
{
    instance.mIntent = intent;
    instance.mIdent = ident;
    instance.mInfo = info;
    instance.mCurConfig = curConfig;
    instance.mOverrideConfig = overrideConfig;
    instance.mCompatInfo = compatInfo;
    instance.mReferrer = referrer;
    instance.mVoiceInteractor = voiceInteractor;
    instance.mProcState = procState;
    instance.mState = state;
    instance.mPersistentState = persistentState;
    instance.mPendingResults = pendingResults;
    instance.mPendingNewIntents = pendingNewIntents;
    instance.mActivityOptions = activityOptions;
    instance.mIsForward = isForward;
    instance.mProfilerInfo = profilerInfo;
    instance.mAssistToken = assistToken;
    instance.mActivityClientController = activityClientController;
    instance.mFixedRotationAdjustments = fixedRotationAdjustments;
    instance.mShareableActivityToken = shareableActivityToken;
    instance.mLaunchedFromBubble = launchedFromBubble;
}
------------------------
Find a silently evolved API code:android.content.ContentProviderClient.checkUriPermission:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * {@hide}
 */

Body of Frist Method:
{
    Objects.requireNonNull(uri, "uri");
    beforeRemote();
    try {
        return mContentProvider.checkUriPermission(mPackageName, mAttributionTag, uri, uid, modeFlags);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}
Body of Second Method:
{
    Objects.requireNonNull(uri, "uri");
    beforeRemote();
    try {
        return mContentProvider.checkUriPermission(mAttributionSource, uri, uid, modeFlags);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}
------------------------
Find a silently evolved API code:android.view.DragEvent.obtain:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    final DragEvent ev;
    synchronized (gRecyclerLock) {
        if (gRecyclerTop == null) {
            ev = new DragEvent();
            ev.init(action, x, y, description, data, dragAndDropPermissions, localState, result);
            return ev;
        }
        ev = gRecyclerTop;
        gRecyclerTop = ev.mNext;
        gRecyclerUsed -= 1;
    }
    ev.mRecycledLocation = null;
    ev.mRecycled = false;
    ev.mNext = null;
    ev.init(action, x, y, description, data, dragAndDropPermissions, localState, result);
    return ev;
}
Body of Second Method:
{
    final DragEvent ev;
    synchronized (gRecyclerLock) {
        if (gRecyclerTop == null) {
            ev = new DragEvent();
            ev.init(action, x, y, offsetX, offsetY, description, data, dragSurface, dragAndDropPermissions, localState, result);
            return ev;
        }
        ev = gRecyclerTop;
        gRecyclerTop = ev.mNext;
        gRecyclerUsed -= 1;
    }
    ev.mRecycledLocation = null;
    ev.mRecycled = false;
    ev.mNext = null;
    ev.init(action, x, y, offsetX, offsetY, description, data, dragSurface, dragAndDropPermissions, localState, result);
    return ev;
}
------------------------
Find a silently evolved API code:android.service.voice.AlwaysOnHotwordDetector.RefreshAvailabiltyTask.internalGetInitialAvailability:COMMENT
Method Modifier: private     
Comment:/**
 * @return The initial availability without checking the enrollment status.
 */

Body of Frist Method:
{
    synchronized (mLock) {
        // This detector has already been invalidated.
        if (mAvailability == STATE_INVALID) {
            return STATE_INVALID;
        }
    }
    ModuleProperties dspModuleProperties;
    try {
        dspModuleProperties = mModelManagementService.getDspModuleProperties();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
    // No DSP available
    if (dspModuleProperties == null) {
        return STATE_HARDWARE_UNAVAILABLE;
    }
    return STATE_NOT_READY;
}
Body of Second Method:
{
    synchronized (mLock) {
        // This detector has already been invalidated.
        if (mAvailability == STATE_INVALID) {
            return STATE_INVALID;
        }
    }
    ModuleProperties dspModuleProperties;
    try {
        dspModuleProperties = mSoundTriggerSession.getDspModuleProperties();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
    // No DSP available
    if (dspModuleProperties == null) {
        return STATE_HARDWARE_UNAVAILABLE;
    }
    return STATE_NOT_READY;
}
------------------------
Find a silently evolved API code:android.widget.EdgeEffect.finish:COMMENT
Method Modifier: public      
Comment:/**
 * Immediately finish the current animation.
 * After this call {@link #isFinished()} will return true.
 */

Body of Frist Method:
{
    mState = STATE_IDLE;
}
Body of Second Method:
{
    mState = STATE_IDLE;
    mDistance = 0;
    mVelocity = 0;
}
------------------------
Find a silently evolved API code:android.content.pm.ShortcutManager.removeDynamicShortcuts:COMMENT
Method Modifier: public      
Comment:/**
 * Delete dynamic shortcuts by ID.
 *
 * @throws IllegalStateException when the user is locked.
 */

Body of Frist Method:
{
    try {
        mService.removeDynamicShortcuts(mContext.getPackageName(), shortcutIds, injectMyUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    try {
        getFutureOrThrow(mService.removeDynamicShortcuts(mContext.getPackageName(), shortcutIds, injectMyUserId()));
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.media.tv.tuner.filter.IpFilterConfiguration.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Builds a {@link IpFilterConfiguration} object.
 */

Body of Frist Method:
{
    int ipAddrLength = mSrcIpAddress.length;
    if (ipAddrLength != mDstIpAddress.length || (ipAddrLength != 4 && ipAddrLength != 16)) {
        throw new IllegalArgumentException("The lengths of src and dst IP address must be 4 or 16 and must be the same." + "srcLength=" + ipAddrLength + ", dstLength=" + mDstIpAddress.length);
    }
    return new IpFilterConfiguration(mSettings, mSrcIpAddress, mDstIpAddress, mSrcPort, mDstPort, mPassthrough);
}
Body of Second Method:
{
    int ipAddrLength = mSrcIpAddress.length;
    if (ipAddrLength != mDstIpAddress.length || (ipAddrLength != 4 && ipAddrLength != 16)) {
        throw new IllegalArgumentException("The lengths of src and dst IP address must be 4 or 16 and must be the same." + "srcLength=" + ipAddrLength + ", dstLength=" + mDstIpAddress.length);
    }
    return new IpFilterConfiguration(mSettings, mSrcIpAddress, mDstIpAddress, mSrcPort, mDstPort, mPassthrough, mIpCid);
}
------------------------
Find a silently evolved API code:android.telephony.CellSignalStrengthLte.toString:COMMENT
Method Modifier: public      
Comment:/**
 * @return string representation.
 */

Body of Frist Method:
{
    return "CellSignalStrengthLte:" + " rssi=" + mRssi + " rsrp=" + mRsrp + " rsrq=" + mRsrq + " rssnr=" + mRssnr + " cqi=" + mCqi + " ta=" + mTimingAdvance + " level=" + mLevel + " parametersUseForLevel=" + mParametersUseForLevel;
}
Body of Second Method:
{
    return "CellSignalStrengthLte:" + " rssi=" + mRssi + " rsrp=" + mRsrp + " rsrq=" + mRsrq + " rssnr=" + mRssnr + " cqiTableIndex=" + mCqiTableIndex + " cqi=" + mCqi + " ta=" + mTimingAdvance + " level=" + mLevel + " parametersUseForLevel=" + mParametersUseForLevel;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothDevice.sdpSearch:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, "BT not enabled. Cannot query remote device sdp records");
        return false;
    }
    try {
        return service.sdpSearch(this, uuid);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
Body of Second Method:
{
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, "BT not enabled. Cannot query remote device sdp records");
        return false;
    }
    try {
        return service.sdpSearch(this, uuid, mAttributionSource);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
------------------------
Find a silently evolved API code:android.nfc.NfcAdapter.getNfcDtaInterface:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns the binder interface to the NFC-DTA test interface.
 * @hide
 */

Body of Frist Method:
{
    if (mContext == null) {
        throw new UnsupportedOperationException("You need a context on NfcAdapter to use the " + " NFC extras APIs");
    }
    try {
        return sService.getNfcDtaInterface(mContext.getPackageName());
    } catch (RemoteException e) {
        attemptDeadServiceRecovery(e);
        return null;
    }
}
Body of Second Method:
{
    if (mContext == null) {
        throw new UnsupportedOperationException("You need a context on NfcAdapter to use the " + " NFC extras APIs");
    }
    try {
        return sService.getNfcDtaInterface(mContext.getPackageName());
    } catch (RemoteException e) {
        attemptDeadServiceRecovery(e);
        // Try one more time
        if (sService == null) {
            Log.e(TAG, "Failed to recover NFC Service.");
            return null;
        }
        try {
            return sService.getNfcDtaInterface(mContext.getPackageName());
        } catch (RemoteException ee) {
            Log.e(TAG, "Failed to recover NFC Service.");
        }
        return null;
    }
}
------------------------
Find a silently evolved API code:android.hardware.camera2.impl.CameraMetadataNative.swap:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * <p>Perform a 0-copy swap of the internal metadata with another object.</p>
 *
 * <p>Useful to convert a CameraMetadata into e.g. a CaptureRequest.</p>
 *
 * @param other Metadata to swap with
 * @throws NullPointerException if other was null
 * @hide
 */

Body of Frist Method:
{
    nativeSwap(mMetadataPtr, other.mMetadataPtr);
    mCameraId = other.mCameraId;
    mHasMandatoryConcurrentStreams = other.mHasMandatoryConcurrentStreams;
    mDisplaySize = other.mDisplaySize;
}
Body of Second Method:
{
    nativeSwap(mMetadataPtr, other.mMetadataPtr);
    mCameraId = other.mCameraId;
    mHasMandatoryConcurrentStreams = other.mHasMandatoryConcurrentStreams;
    mDisplaySize = other.mDisplaySize;
    mMultiResolutionStreamConfigurationMap = other.mMultiResolutionStreamConfigurationMap;
    updateNativeAllocation();
    other.updateNativeAllocation();
}
------------------------
Find a silently evolved API code:android.media.tv.tuner.frontend.FrontendStatus.isEwbs:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Checks whether it's Emergency Warning Broadcasting System
 */

Body of Frist Method:
{
    if (mIsEwbs == null) {
        throw new IllegalStateException();
    }
    return mIsEwbs;
}
Body of Second Method:
{
    if (mIsEwbs == null) {
        throw new IllegalStateException("Ewbs status is empty");
    }
    return mIsEwbs;
}
------------------------
Find a silently evolved API code:android.app.BroadcastOptions.toBundle:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns the created options as a Bundle, which can be passed to
 * {@link android.content.Context#sendBroadcast(android.content.Intent)
 * Context.sendBroadcast(Intent)} and related methods.
 * Note that the returned Bundle is still owned by the BroadcastOptions
 * object; you must not modify it, but can supply it to the sendBroadcast
 * methods that take an options Bundle.
 */

Body of Frist Method:
{
    Bundle b = new Bundle();
    if (mTemporaryAppWhitelistDuration > 0) {
        b.putLong(KEY_TEMPORARY_APP_WHITELIST_DURATION, mTemporaryAppWhitelistDuration);
    }
    if (mMinManifestReceiverApiLevel != 0) {
        b.putInt(KEY_MIN_MANIFEST_RECEIVER_API_LEVEL, mMinManifestReceiverApiLevel);
    }
    if (mMaxManifestReceiverApiLevel != Build.VERSION_CODES.CUR_DEVELOPMENT) {
        b.putInt(KEY_MAX_MANIFEST_RECEIVER_API_LEVEL, mMaxManifestReceiverApiLevel);
    }
    if (mDontSendToRestrictedApps) {
        b.putBoolean(KEY_DONT_SEND_TO_RESTRICTED_APPS, true);
    }
    if (mAllowBackgroundActivityStarts) {
        b.putBoolean(KEY_ALLOW_BACKGROUND_ACTIVITY_STARTS, true);
    }
    return b.isEmpty() ? null : b;
}
Body of Second Method:
{
    Bundle b = new Bundle();
    if (isTemporaryAppAllowlistSet()) {
        b.putLong(KEY_TEMPORARY_APP_ALLOWLIST_DURATION, mTemporaryAppAllowlistDuration);
        b.putInt(KEY_TEMPORARY_APP_ALLOWLIST_TYPE, mTemporaryAppAllowlistType);
        b.putInt(KEY_TEMPORARY_APP_ALLOWLIST_REASON_CODE, mTemporaryAppAllowlistReasonCode);
        b.putString(KEY_TEMPORARY_APP_ALLOWLIST_REASON, mTemporaryAppAllowlistReason);
    }
    if (mMinManifestReceiverApiLevel != 0) {
        b.putInt(KEY_MIN_MANIFEST_RECEIVER_API_LEVEL, mMinManifestReceiverApiLevel);
    }
    if (mMaxManifestReceiverApiLevel != Build.VERSION_CODES.CUR_DEVELOPMENT) {
        b.putInt(KEY_MAX_MANIFEST_RECEIVER_API_LEVEL, mMaxManifestReceiverApiLevel);
    }
    if (mDontSendToRestrictedApps) {
        b.putBoolean(KEY_DONT_SEND_TO_RESTRICTED_APPS, true);
    }
    if (mAllowBackgroundActivityStarts) {
        b.putBoolean(KEY_ALLOW_BACKGROUND_ACTIVITY_STARTS, true);
    }
    return b.isEmpty() ? null : b;
}
------------------------
Find a silently evolved API code:android.graphics.pdf.PdfEditor.setTransformAndClip:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets a transformation and clip for a given page. The transformation matrix if
 * non-null must be affine as per {@link android.graphics.Matrix#isAffine()}. If
 * the clip is null, then no clipping is performed.
 *
 * @param pageIndex The page whose transform to set.
 * @param transform The transformation to apply.
 * @param clip The clip to apply.
 */

Body of Frist Method:
{
    throwIfClosed();
    throwIfPageNotInDocument(pageIndex);
    throwIfNotNullAndNotAfine(transform);
    if (transform == null) {
        transform = Matrix.IDENTITY_MATRIX;
    }
    if (clip == null) {
        Point size = new Point();
        getPageSize(pageIndex, size);
        synchronized (PdfRenderer.sPdfiumLock) {
            nativeSetTransformAndClip(mNativeDocument, pageIndex, transform.native_instance, 0, 0, size.x, size.y);
        }
    } else {
        synchronized (PdfRenderer.sPdfiumLock) {
            nativeSetTransformAndClip(mNativeDocument, pageIndex, transform.native_instance, clip.left, clip.top, clip.right, clip.bottom);
        }
    }
}
Body of Second Method:
{
    throwIfClosed();
    throwIfPageNotInDocument(pageIndex);
    throwIfNotNullAndNotAfine(transform);
    if (transform == null) {
        transform = Matrix.IDENTITY_MATRIX;
    }
    if (clip == null) {
        Point size = new Point();
        getPageSize(pageIndex, size);
        synchronized (PdfRenderer.sPdfiumLock) {
            nativeSetTransformAndClip(mNativeDocument, pageIndex, transform.ni(), 0, 0, size.x, size.y);
        }
    } else {
        synchronized (PdfRenderer.sPdfiumLock) {
            nativeSetTransformAndClip(mNativeDocument, pageIndex, transform.ni(), clip.left, clip.top, clip.right, clip.bottom);
        }
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHidHost.connect:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Initiate connection to a profile of the remote bluetooth device.
 *
 * <p> The system supports connection to multiple input devices.
 *
 * <p> This API returns false in scenarios like the profile on the
 * device is already connected or Bluetooth is not turned on.
 * When this API returns true, it is guaranteed that
 * connection state intent for the profile will be broadcasted with
 * the state. Users can get the connection state of the profile
 * from this intent.
 *
 * @param device Remote Bluetooth Device
 * @return false on immediate error, true otherwise
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("connect(" + device + ")");
    final IBluetoothHidHost service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.connect(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("connect(" + device + ")");
    final IBluetoothHidHost service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.connect(device, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.media.session.MediaController.getSessionInfo:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the additional session information which was set when the session was created.
 *
 * @return The additional session information, or an empty {@link Bundle} if not set.
 */

Body of Frist Method:
{
    if (mSessionInfo != null) {
        return new Bundle(mSessionInfo);
    }
    // Get info from the connected session.
    try {
        mSessionInfo = mSessionBinder.getSessionInfo();
    } catch (RemoteException e) {
        Log.d(TAG, "Dead object in getSessionInfo.", e);
    }
    if (mSessionInfo == null) {
        Log.w(TAG, "sessionInfo shouldn't be null.");
        mSessionInfo = Bundle.EMPTY;
    } else if (MediaSession.hasCustomParcelable(mSessionInfo)) {
        Log.w(TAG, "sessionInfo contains custom parcelable. Ignoring.");
        mSessionInfo = Bundle.EMPTY;
    }
    return new Bundle(mSessionInfo);
}
Body of Second Method:
{
    if (mSessionInfo != null) {
        return new Bundle(mSessionInfo);
    }
    // Get info from the connected session.
    try {
        mSessionInfo = mSessionBinder.getSessionInfo();
    } catch (RemoteException e) {
        Log.d(TAG, "Dead object in getSessionInfo.", e);
    }
    if (mSessionInfo == null) {
        Log.d(TAG, "sessionInfo is not set.");
        mSessionInfo = Bundle.EMPTY;
    } else if (MediaSession.hasCustomParcelable(mSessionInfo)) {
        Log.w(TAG, "sessionInfo contains custom parcelable. Ignoring.");
        mSessionInfo = Bundle.EMPTY;
    }
    return new Bundle(mSessionInfo);
}
------------------------
Find a silently evolved API code:android.hardware.camera2.params.OutputConfiguration.hashCode:COMMENT
Method Modifier: public      
Comment:/**
 * {@inheritDoc}
 */

Body of Frist Method:
{
    // surface is set.
    if (mIsDeferredConfig) {
        return HashCodeHelpers.hashCode(mRotation, mConfiguredSize.hashCode(), mConfiguredFormat, mConfiguredDataspace, mSurfaceGroupId, mSurfaceType, mIsShared ? 1 : 0, mPhysicalCameraId == null ? 0 : mPhysicalCameraId.hashCode());
    }
    return HashCodeHelpers.hashCode(mRotation, mSurfaces.hashCode(), mConfiguredGenerationId, mConfiguredSize.hashCode(), mConfiguredFormat, mConfiguredDataspace, mSurfaceGroupId, mIsShared ? 1 : 0, mPhysicalCameraId == null ? 0 : mPhysicalCameraId.hashCode());
}
Body of Second Method:
{
    // surface is set.
    if (mIsDeferredConfig) {
        return HashCodeHelpers.hashCode(mRotation, mConfiguredSize.hashCode(), mConfiguredFormat, mConfiguredDataspace, mSurfaceGroupId, mSurfaceType, mIsShared ? 1 : 0, mPhysicalCameraId == null ? 0 : mPhysicalCameraId.hashCode(), mIsMultiResolution ? 1 : 0, mSensorPixelModesUsed.hashCode());
    }
    return HashCodeHelpers.hashCode(mRotation, mSurfaces.hashCode(), mConfiguredGenerationId, mConfiguredSize.hashCode(), mConfiguredFormat, mConfiguredDataspace, mSurfaceGroupId, mIsShared ? 1 : 0, mPhysicalCameraId == null ? 0 : mPhysicalCameraId.hashCode(), mIsMultiResolution ? 1 : 0, mSensorPixelModesUsed.hashCode());
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.getConnectionState:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns state of the <code>device</code>
 *
 * @param device a remote device
 * @return the state of connection of the device
 */

Body of Frist Method:
{
    if (VDBG)
        log("getConnectionState(" + device + ")");
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getConnectionState(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.STATE_DISCONNECTED;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return BluetoothProfile.STATE_DISCONNECTED;
}
Body of Second Method:
{
    if (VDBG)
        log("getConnectionState(" + device + ")");
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getConnectionState(device, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.STATE_DISCONNECTED;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return BluetoothProfile.STATE_DISCONNECTED;
}
------------------------
Find a silently evolved API code:android.text.format.DateUtils.getMonthString:COMMENT
Method Modifier: public      static      deprecated  
Comment:/**
 * Return a localized string for the month of the year.
 * @param month One of {@link Calendar#JANUARY Calendar.JANUARY},
 * {@link Calendar#FEBRUARY Calendar.FEBRUARY}, etc.
 * @param abbrev One of {@link #LENGTH_LONG}, {@link #LENGTH_MEDIUM},
 * or {@link #LENGTH_SHORTEST}.
 * Undefined lengths will return {@link #LENGTH_MEDIUM}
 * but may return something different in the future.
 * @return Localized month of the year.
 * @deprecated Use {@link java.text.SimpleDateFormat} instead.
 */

Body of Frist Method:
{
    LocaleData d = LocaleData.get(Locale.getDefault());
    String[] names;
    switch(abbrev) {
        case LENGTH_LONG:
            names = d.longMonthNames;
            break;
        case LENGTH_MEDIUM:
            names = d.shortMonthNames;
            break;
        case LENGTH_SHORT:
            names = d.shortMonthNames;
            break;
        case LENGTH_SHORTER:
            names = d.shortMonthNames;
            break;
        case LENGTH_SHORTEST:
            names = d.tinyMonthNames;
            break;
        default:
            names = d.shortMonthNames;
            break;
    }
    return names[month];
}
Body of Second Method:
{
    DateFormatSymbols dfs = DateFormat.getIcuDateFormatSymbols(Locale.getDefault());
    final int width;
    switch(abbrev) {
        case LENGTH_LONG:
            width = DateFormatSymbols.WIDE;
            break;
        case LENGTH_SHORTEST:
            width = DateFormatSymbols.NARROW;
            break;
        case LENGTH_MEDIUM:
        case LENGTH_SHORT:
        case LENGTH_SHORTER:
        default:
            width = DateFormatSymbols.ABBREVIATED;
            break;
    }
    return dfs.getMonths(DateFormatSymbols.FORMAT, width)[month];
}
------------------------
Find a silently evolved API code:android.content.pm.SuspendDialogInfo.saveToXml:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (mIconResId != ID_NULL) {
        XmlUtils.writeIntAttribute(out, XML_ATTR_ICON_RES_ID, mIconResId);
    }
    if (mTitleResId != ID_NULL) {
        XmlUtils.writeIntAttribute(out, XML_ATTR_TITLE_RES_ID, mTitleResId);
    }
    if (mDialogMessageResId != ID_NULL) {
        XmlUtils.writeIntAttribute(out, XML_ATTR_DIALOG_MESSAGE_RES_ID, mDialogMessageResId);
    } else {
        XmlUtils.writeStringAttribute(out, XML_ATTR_DIALOG_MESSAGE, mDialogMessage);
    }
    if (mNeutralButtonTextResId != ID_NULL) {
        XmlUtils.writeIntAttribute(out, XML_ATTR_BUTTON_TEXT_RES_ID, mNeutralButtonTextResId);
    }
    XmlUtils.writeIntAttribute(out, XML_ATTR_BUTTON_ACTION, mNeutralButtonAction);
}
Body of Second Method:
{
    if (mIconResId != ID_NULL) {
        out.attributeInt(null, XML_ATTR_ICON_RES_ID, mIconResId);
    }
    if (mTitleResId != ID_NULL) {
        out.attributeInt(null, XML_ATTR_TITLE_RES_ID, mTitleResId);
    } else {
        XmlUtils.writeStringAttribute(out, XML_ATTR_TITLE, mTitle);
    }
    if (mDialogMessageResId != ID_NULL) {
        out.attributeInt(null, XML_ATTR_DIALOG_MESSAGE_RES_ID, mDialogMessageResId);
    } else {
        XmlUtils.writeStringAttribute(out, XML_ATTR_DIALOG_MESSAGE, mDialogMessage);
    }
    if (mNeutralButtonTextResId != ID_NULL) {
        out.attributeInt(null, XML_ATTR_BUTTON_TEXT_RES_ID, mNeutralButtonTextResId);
    } else {
        XmlUtils.writeStringAttribute(out, XML_ATTR_BUTTON_TEXT, mNeutralButtonText);
    }
    out.attributeInt(null, XML_ATTR_BUTTON_ACTION, mNeutralButtonAction);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.getCurrentAgFeatures:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get Audio Gateway features
 *
 * @param device remote device
 * @return bundle of AG features; null if no service or AG not connected
 */

Body of Frist Method:
{
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled()) {
        try {
            return service.getCurrentAgFeatures(device);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return null;
}
Body of Second Method:
{
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled()) {
        try {
            return service.getCurrentAgFeatures(device, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return null;
}
------------------------
Find a silently evolved API code:android.app.NotificationChannel.toJson:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    JSONObject record = new JSONObject();
    record.put(ATT_ID, getId());
    record.put(ATT_NAME, getName());
    record.put(ATT_DESC, getDescription());
    if (getImportance() != DEFAULT_IMPORTANCE) {
        record.put(ATT_IMPORTANCE, NotificationListenerService.Ranking.importanceToString(getImportance()));
    }
    if (canBypassDnd()) {
        record.put(ATT_PRIORITY, Notification.PRIORITY_MAX);
    }
    if (getLockscreenVisibility() != DEFAULT_VISIBILITY) {
        record.put(ATT_VISIBILITY, Notification.visibilityToString(getLockscreenVisibility()));
    }
    if (getSound() != null) {
        record.put(ATT_SOUND, getSound().toString());
    }
    if (getAudioAttributes() != null) {
        record.put(ATT_USAGE, Integer.toString(getAudioAttributes().getUsage()));
        record.put(ATT_CONTENT_TYPE, Integer.toString(getAudioAttributes().getContentType()));
        record.put(ATT_FLAGS, Integer.toString(getAudioAttributes().getFlags()));
    }
    record.put(ATT_LIGHTS, Boolean.toString(shouldShowLights()));
    record.put(ATT_LIGHT_COLOR, Integer.toString(getLightColor()));
    record.put(ATT_VIBRATION_ENABLED, Boolean.toString(shouldVibrate()));
    record.put(ATT_USER_LOCKED, Integer.toString(getUserLockedFields()));
    record.put(ATT_FG_SERVICE_SHOWN, Boolean.toString(isFgServiceShown()));
    record.put(ATT_VIBRATION, longArrayToString(getVibrationPattern()));
    record.put(ATT_SHOW_BADGE, Boolean.toString(canShowBadge()));
    record.put(ATT_DELETED, Boolean.toString(isDeleted()));
    record.put(ATT_GROUP, getGroup());
    record.put(ATT_BLOCKABLE_SYSTEM, isBlockable());
    record.put(ATT_ALLOW_BUBBLE, getAllowBubbles());
    // TODO: original importance
    return record;
}
Body of Second Method:
{
    JSONObject record = new JSONObject();
    record.put(ATT_ID, getId());
    record.put(ATT_NAME, getName());
    record.put(ATT_DESC, getDescription());
    if (getImportance() != DEFAULT_IMPORTANCE) {
        record.put(ATT_IMPORTANCE, NotificationListenerService.Ranking.importanceToString(getImportance()));
    }
    if (canBypassDnd()) {
        record.put(ATT_PRIORITY, Notification.PRIORITY_MAX);
    }
    if (getLockscreenVisibility() != DEFAULT_VISIBILITY) {
        record.put(ATT_VISIBILITY, Notification.visibilityToString(getLockscreenVisibility()));
    }
    if (getSound() != null) {
        record.put(ATT_SOUND, getSound().toString());
    }
    if (getAudioAttributes() != null) {
        record.put(ATT_USAGE, Integer.toString(getAudioAttributes().getUsage()));
        record.put(ATT_CONTENT_TYPE, Integer.toString(getAudioAttributes().getContentType()));
        record.put(ATT_FLAGS, Integer.toString(getAudioAttributes().getFlags()));
    }
    record.put(ATT_LIGHTS, Boolean.toString(shouldShowLights()));
    record.put(ATT_LIGHT_COLOR, Integer.toString(getLightColor()));
    record.put(ATT_VIBRATION_ENABLED, Boolean.toString(shouldVibrate()));
    record.put(ATT_USER_LOCKED, Integer.toString(getUserLockedFields()));
    record.put(ATT_FG_SERVICE_SHOWN, Boolean.toString(isFgServiceShown()));
    record.put(ATT_VIBRATION, longArrayToString(getVibrationPattern()));
    record.put(ATT_SHOW_BADGE, Boolean.toString(canShowBadge()));
    record.put(ATT_DELETED, Boolean.toString(isDeleted()));
    record.put(ATT_DELETED_TIME_MS, Long.toString(getDeletedTimeMs()));
    record.put(ATT_GROUP, getGroup());
    record.put(ATT_BLOCKABLE_SYSTEM, isBlockable());
    record.put(ATT_ALLOW_BUBBLE, getAllowBubbles());
    // TODO: original importance
    return record;
}
------------------------
Find a silently evolved API code:android.service.voice.AlwaysOnHotwordDetector.onSoundModelsChanged:COMMENT
Method Modifier: default     hidden      
Comment:/**
 * Reloads the sound models from the service.
 *
 * @hide
 */

Body of Frist Method:
{
    synchronized (mLock) {
        if (mAvailability == STATE_INVALID || mAvailability == STATE_HARDWARE_UNAVAILABLE) {
            Slog.w(TAG, "Received onSoundModelsChanged for an unsupported keyphrase/config");
            return;
        }
        // again if needed.
        if (mAvailability == STATE_KEYPHRASE_ENROLLED) {
            stopRecognitionLocked();
        }
        // Execute a refresh availability task - which should then notify of a change.
        new RefreshAvailabiltyTask().execute();
    }
}
Body of Second Method:
{
    synchronized (mLock) {
        if (mAvailability == STATE_INVALID || mAvailability == STATE_HARDWARE_UNAVAILABLE || mAvailability == STATE_ERROR) {
            Slog.w(TAG, "Received onSoundModelsChanged for an unsupported keyphrase/config" + " or in the error state");
            return;
        }
        // again if needed.
        if (mAvailability == STATE_KEYPHRASE_ENROLLED) {
            try {
                stopRecognitionLocked();
            } catch (SecurityException e) {
                Slog.w(TAG, "Failed to Stop the recognition", e);
                if (mTargetSdkVersion <= Build.VERSION_CODES.R) {
                    throw e;
                }
                updateAndNotifyStateChangedLocked(STATE_ERROR);
                return;
            }
        }
        // Execute a refresh availability task - which should then notify of a change.
        new RefreshAvailabiltyTask().execute();
    }
}
------------------------
Find a silently evolved API code:android.telephony.CellInfo.create:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    if (ci == null)
        return null;
    switch(ci.ratSpecificInfo.getDiscriminator()) {
        case CellInfoRatSpecificInfo.hidl_discriminator.gsm:
            return new CellInfoGsm(ci, timeStamp);
        case CellInfoRatSpecificInfo.hidl_discriminator.cdma:
            return new CellInfoCdma(ci, timeStamp);
        case CellInfoRatSpecificInfo.hidl_discriminator.lte:
            return new CellInfoLte(ci, timeStamp);
        case CellInfoRatSpecificInfo.hidl_discriminator.wcdma:
            return new CellInfoWcdma(ci, timeStamp);
        case CellInfoRatSpecificInfo.hidl_discriminator.tdscdma:
            return new CellInfoTdscdma(ci, timeStamp);
        case CellInfoRatSpecificInfo.hidl_discriminator.nr:
            return new CellInfoNr(ci, timeStamp);
        default:
            return null;
    }
}
Body of Second Method:
{
    if (ci == null)
        return null;
    switch(ci.info.getDiscriminator()) {
        case Info.hidl_discriminator.gsm:
            return new CellInfoGsm(ci, timeStamp);
        case Info.hidl_discriminator.cdma:
            return new CellInfoCdma(ci, timeStamp);
        case Info.hidl_discriminator.lte:
            return new CellInfoLte(ci, timeStamp);
        case Info.hidl_discriminator.wcdma:
            return new CellInfoWcdma(ci, timeStamp);
        case Info.hidl_discriminator.tdscdma:
            return new CellInfoTdscdma(ci, timeStamp);
        case Info.hidl_discriminator.nr:
            return new CellInfoNr(ci, timeStamp);
        default:
            return null;
    }
}
------------------------
Find a silently evolved API code:android.location.GnssCapabilities.hasMeasurementCorrections:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns {@code true} if GNSS chipset supports measurement corrections, {@code false}
 * otherwise.
 *
 * @hide
 */

Body of Frist Method:
{
    return hasCapability(MEASUREMENT_CORRECTIONS);
}
Body of Second Method:
{
    return (mTopFlags & TOP_HAL_CAPABILITY_MEASUREMENT_CORRECTIONS) != 0;
}
------------------------
Find a silently evolved API code:android.timezone.TimeZoneFinder.lookupCountryTimeZones:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns a {@link CountryTimeZones} object associated with the specified country code.
 * Caching is handled as needed. If the country code is not recognized or there is an error
 * during lookup this method can return null.
 */

Body of Frist Method:
{
    libcore.timezone.CountryTimeZones delegate = mDelegate.lookupCountryTimeZones(countryIso);
    return delegate == null ? null : new CountryTimeZones(delegate);
}
Body of Second Method:
{
    com.android.i18n.timezone.CountryTimeZones delegate = mDelegate.lookupCountryTimeZones(countryIso);
    return delegate == null ? null : new CountryTimeZones(delegate);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothDevice.cancelPairing:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Cancels pairing to this device
 *
 * @return true if pairing cancelled successfully, false otherwise
 *
 * @hide
 */

Body of Frist Method:
{
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, "BT not enabled. Cannot cancel pairing");
        return false;
    }
    try {
        return service.cancelBondProcess(this);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
Body of Second Method:
{
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, "BT not enabled. Cannot cancel pairing");
        return false;
    }
    try {
        return service.cancelBondProcess(this, mAttributionSource);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return false;
}
------------------------
Find a silently evolved API code:android.media.session.MediaController.PlaybackInfo.getPlaybackType:COMMENT
Method Modifier: public      
Comment:/**
 * Get the type of playback which affects volume handling. One of:
 * <ul>
 * <li>{@link #PLAYBACK_TYPE_LOCAL}</li>
 * <li>{@link #PLAYBACK_TYPE_REMOTE}</li>
 * </ul>
 *
 * @return The type of playback this session is using.
 */

Body of Frist Method:
{
    return mVolumeType;
}
Body of Second Method:
{
    return mPlaybackType;
}
------------------------
Find a silently evolved API code:android.security.KeyPairGeneratorSpec.Builder.build:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * Builds the instance of the {@code KeyPairGeneratorSpec}.
 *
 * @throws IllegalArgumentException if a required field is missing
 * @return built instance of {@code KeyPairGeneratorSpec}
 */

Body of Frist Method:
{
    return new KeyPairGeneratorSpec(mContext, mKeystoreAlias, mKeyType, mKeySize, mSpec, mSubjectDN, mSerialNumber, mStartDate, mEndDate, mFlags);
}
Body of Second Method:
{
    return new KeyPairGeneratorSpec(mContext, mKeystoreAlias, mKeyType, mKeySize, mSpec, mSubjectDN, mSerialNumber, mStartDate, mEndDate, 0);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothSap.getConnectionState:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get connection state of device
 *
 * @return device connection state
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("getConnectionState(" + device + ")");
    final IBluetoothSap service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getConnectionState(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.STATE_DISCONNECTED;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return BluetoothProfile.STATE_DISCONNECTED;
}
Body of Second Method:
{
    if (DBG)
        log("getConnectionState(" + device + ")");
    final IBluetoothSap service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getConnectionState(device, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return BluetoothProfile.STATE_DISCONNECTED;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return BluetoothProfile.STATE_DISCONNECTED;
}
------------------------
Find a silently evolved API code:android.app.WindowConfiguration.diff:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Return a bit mask of the differences between this Configuration object and the given one.
 * Does not change the values of either. Any undefined fields in <var>other</var> are ignored.
 * @param other The configuration to diff against.
 * @param compareUndefined If undefined values should be compared.
 * @return Returns a bit mask indicating which configuration
 * values has changed, containing any combination of {@link WindowConfig} flags.
 *
 * @see Configuration#diff(Configuration)
 * @hide
 */

Body of Frist Method:
{
    long changes = 0;
    if (!mBounds.equals(other.mBounds)) {
        changes |= WINDOW_CONFIG_BOUNDS;
    }
    // Make sure that one of the values is not null and that they are not equal.
    if ((compareUndefined || other.mAppBounds != null) && mAppBounds != other.mAppBounds && (mAppBounds == null || !mAppBounds.equals(other.mAppBounds))) {
        changes |= WINDOW_CONFIG_APP_BOUNDS;
    }
    if ((compareUndefined || other.mWindowingMode != WINDOWING_MODE_UNDEFINED) && mWindowingMode != other.mWindowingMode) {
        changes |= WINDOW_CONFIG_WINDOWING_MODE;
    }
    if ((compareUndefined || other.mActivityType != ACTIVITY_TYPE_UNDEFINED) && mActivityType != other.mActivityType) {
        changes |= WINDOW_CONFIG_ACTIVITY_TYPE;
    }
    if ((compareUndefined || other.mAlwaysOnTop != ALWAYS_ON_TOP_UNDEFINED) && mAlwaysOnTop != other.mAlwaysOnTop) {
        changes |= WINDOW_CONFIG_ALWAYS_ON_TOP;
    }
    if ((compareUndefined || other.mRotation != ROTATION_UNDEFINED) && mRotation != other.mRotation) {
        changes |= WINDOW_CONFIG_ROTATION;
    }
    if ((compareUndefined || other.mDisplayWindowingMode != WINDOWING_MODE_UNDEFINED) && mDisplayWindowingMode != other.mDisplayWindowingMode) {
        changes |= WINDOW_CONFIG_DISPLAY_WINDOWING_MODE;
    }
    return changes;
}
Body of Second Method:
{
    long changes = 0;
    if (!mBounds.equals(other.mBounds)) {
        changes |= WINDOW_CONFIG_BOUNDS;
    }
    // Make sure that one of the values is not null and that they are not equal.
    if ((compareUndefined || other.mAppBounds != null) && mAppBounds != other.mAppBounds && (mAppBounds == null || !mAppBounds.equals(other.mAppBounds))) {
        changes |= WINDOW_CONFIG_APP_BOUNDS;
    }
    if (!mMaxBounds.equals(other.mMaxBounds)) {
        changes |= WINDOW_CONFIG_MAX_BOUNDS;
    }
    if ((compareUndefined || other.mWindowingMode != WINDOWING_MODE_UNDEFINED) && mWindowingMode != other.mWindowingMode) {
        changes |= WINDOW_CONFIG_WINDOWING_MODE;
    }
    if ((compareUndefined || other.mActivityType != ACTIVITY_TYPE_UNDEFINED) && mActivityType != other.mActivityType) {
        changes |= WINDOW_CONFIG_ACTIVITY_TYPE;
    }
    if ((compareUndefined || other.mAlwaysOnTop != ALWAYS_ON_TOP_UNDEFINED) && mAlwaysOnTop != other.mAlwaysOnTop) {
        changes |= WINDOW_CONFIG_ALWAYS_ON_TOP;
    }
    if ((compareUndefined || other.mRotation != ROTATION_UNDEFINED) && mRotation != other.mRotation) {
        changes |= WINDOW_CONFIG_ROTATION;
    }
    if ((compareUndefined || other.mDisplayWindowingMode != WINDOWING_MODE_UNDEFINED) && mDisplayWindowingMode != other.mDisplayWindowingMode) {
        changes |= WINDOW_CONFIG_DISPLAY_WINDOWING_MODE;
    }
    return changes;
}
------------------------
Find a silently evolved API code:android.app.NotificationChannel.populateFromXmlForRestore:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    populateFromXml(parser, true, context);
}
Body of Second Method:
{
    populateFromXml(XmlUtils.makeTyped(parser), true, context);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothPan.setBluetoothTethering:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Turns on/off bluetooth tethering
 *
 * @param value is whether to enable or disable bluetooth tethering
 * @hide
 */

Body of Frist Method:
{
    String pkgName = mContext.getOpPackageName();
    if (DBG)
        log("setBluetoothTethering(" + value + "), calling package:" + pkgName);
    final IBluetoothPan service = getService();
    if (service != null && isEnabled()) {
        try {
            service.setBluetoothTethering(value, pkgName);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
        }
    }
}
Body of Second Method:
{
    String pkgName = mContext.getOpPackageName();
    if (DBG)
        log("setBluetoothTethering(" + value + "), calling package:" + pkgName);
    final IBluetoothPan service = getService();
    if (service != null && isEnabled()) {
        try {
            service.setBluetoothTethering(value, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
        }
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHidHost.setConnectionPolicy:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Set connection policy of the profile
 *
 * <p> The device should already be paired.
 * Connection policy can be one of {@link #CONNECTION_POLICY_ALLOWED},
 * {@link #CONNECTION_POLICY_FORBIDDEN}, {@link #CONNECTION_POLICY_UNKNOWN}
 *
 * @param device Paired bluetooth device
 * @param connectionPolicy is the connection policy to set to for this profile
 * @return true if connectionPolicy is set, false on error
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("setConnectionPolicy(" + device + ", " + connectionPolicy + ")");
    if (device == null) {
        throw new IllegalArgumentException("device must not be null");
    }
    final IBluetoothHidHost service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        if (connectionPolicy != BluetoothProfile.CONNECTION_POLICY_FORBIDDEN && connectionPolicy != BluetoothProfile.CONNECTION_POLICY_ALLOWED) {
            return false;
        }
        try {
            return service.setConnectionPolicy(device, connectionPolicy);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("setConnectionPolicy(" + device + ", " + connectionPolicy + ")");
    if (device == null) {
        throw new IllegalArgumentException("device must not be null");
    }
    final IBluetoothHidHost service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        if (connectionPolicy != BluetoothProfile.CONNECTION_POLICY_FORBIDDEN && connectionPolicy != BluetoothProfile.CONNECTION_POLICY_ALLOWED) {
            return false;
        }
        try {
            return service.setConnectionPolicy(device, connectionPolicy, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.view.WindowInsets.hasInsets:COMMENT
Method Modifier: public      
Comment:/**
 * Returns true if this WindowInsets has any nonzero insets.
 *
 * @return true if any inset values are nonzero
 */

Body of Frist Method:
{
    return !getInsets(mTypeInsetsMap, all()).equals(Insets.NONE) || !getInsets(mTypeMaxInsetsMap, all()).equals(Insets.NONE) || mDisplayCutout != null;
}
Body of Second Method:
{
    return !getInsets(mTypeInsetsMap, all()).equals(Insets.NONE) || !getInsets(mTypeMaxInsetsMap, all()).equals(Insets.NONE) || mDisplayCutout != null || mRoundedCorners != null;
}
------------------------
Find a silently evolved API code:android.os.Vibrator.arePrimitivesSupported:COMMENT
Method Modifier: public      
Comment:/**
 * Query whether the vibrator supports the given primitives.
 *
 * The returned array will be the same length as the query array and the value at a given index
 * will contain whether the effect at that same index in the querying array is supported or
 * not.
 *
 * @param primitiveIds Which primitives to query for.
 * @return Whether the primitives are supported.
 */

Body of Frist Method:
{
    return new boolean[primitiveIds.length];
}
Body of Second Method:
{
    VibratorInfo info = getInfo();
    boolean[] supported = new boolean[primitiveIds.length];
    for (int i = 0; i < primitiveIds.length; i++) {
        supported[i] = info.isPrimitiveSupported(primitiveIds[i]);
    }
    return supported;
}
------------------------
Find a silently evolved API code:android.view.autofill.AutofillValue.getTextValue:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the value to autofill a text field.
 *
 * <p>See {@link View#AUTOFILL_TYPE_TEXT} for more info.</p>
 *
 * @throws IllegalStateException if the value is not a text value
 */

Body of Frist Method:
{
    Preconditions.checkState(isText(), "value must be a text value, not type=" + mType);
    return (CharSequence) mValue;
}
Body of Second Method:
{
    Preconditions.checkState(isText(), "value must be a text value, not type=%d", mType);
    return (CharSequence) mValue;
}
------------------------
Find a silently evolved API code:android.content.SyncRequest.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Performs validation over the request and throws the runtime exception
 * <code>IllegalArgumentException</code> if this validation fails.
 *
 * @return a SyncRequest with the information contained within this
 * builder.
 */

Body of Frist Method:
{
    // Validate the extras bundle
    ContentResolver.validateSyncExtrasBundle(mCustomExtras);
    if (mCustomExtras == null) {
        mCustomExtras = new Bundle();
    }
    // Combine builder extra flags into the config bundle.
    mSyncConfigExtras = new Bundle();
    if (mIgnoreBackoff) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_IGNORE_BACKOFF, true);
    }
    if (mDisallowMetered) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_DISALLOW_METERED, true);
    }
    if (mRequiresCharging) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_REQUIRE_CHARGING, true);
    }
    if (mIgnoreSettings) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_IGNORE_SETTINGS, true);
    }
    if (mNoRetry) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_DO_NOT_RETRY, true);
    }
    if (mExpedited) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_EXPEDITED, true);
    }
    if (mIsManual) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_IGNORE_BACKOFF, true);
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_IGNORE_SETTINGS, true);
    }
    if (mSyncType == SYNC_TYPE_PERIODIC) {
        // If this is a periodic sync ensure than invalid extras were not set.
        if (ContentResolver.invalidPeriodicExtras(mCustomExtras) || ContentResolver.invalidPeriodicExtras(mSyncConfigExtras)) {
            throw new IllegalArgumentException("Illegal extras were set");
        }
    }
    // Ensure that a target for the sync has been set.
    if (mSyncTarget == SYNC_TARGET_UNKNOWN) {
        throw new IllegalArgumentException("Must specify an adapter with" + " setSyncAdapter(Account, String");
    }
    return new SyncRequest(this);
}
Body of Second Method:
{
    // Combine builder extra flags into the config bundle.
    mSyncConfigExtras = new Bundle();
    if (mIgnoreBackoff) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_IGNORE_BACKOFF, true);
    }
    if (mDisallowMetered) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_DISALLOW_METERED, true);
    }
    if (mRequiresCharging) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_REQUIRE_CHARGING, true);
    }
    if (mIgnoreSettings) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_IGNORE_SETTINGS, true);
    }
    if (mNoRetry) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_DO_NOT_RETRY, true);
    }
    if (mExpedited) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_EXPEDITED, true);
    }
    if (mScheduleAsExpeditedJob) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_SCHEDULE_AS_EXPEDITED_JOB, true);
    }
    if (mIsManual) {
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_IGNORE_BACKOFF, true);
        mSyncConfigExtras.putBoolean(ContentResolver.SYNC_EXTRAS_IGNORE_SETTINGS, true);
    }
    if (mCustomExtras == null) {
        mCustomExtras = new Bundle();
    }
    // Validate the extras bundles
    ContentResolver.validateSyncExtrasBundle(mCustomExtras);
    // If this is a periodic sync ensure than invalid extras were not set.
    if (mSyncType == SYNC_TYPE_PERIODIC) {
        if (ContentResolver.invalidPeriodicExtras(mCustomExtras) || ContentResolver.invalidPeriodicExtras(mSyncConfigExtras)) {
            throw new IllegalArgumentException("Illegal extras were set");
        }
    }
    // If this sync is scheduled as an EJ, ensure that invalid extras were not set.
    if (mCustomExtras.getBoolean(ContentResolver.SYNC_EXTRAS_SCHEDULE_AS_EXPEDITED_JOB) || mScheduleAsExpeditedJob) {
        if (ContentResolver.hasInvalidScheduleAsEjExtras(mCustomExtras) || ContentResolver.hasInvalidScheduleAsEjExtras(mSyncConfigExtras)) {
            throw new IllegalArgumentException("Illegal extras were set");
        }
    }
    // Ensure that a target for the sync has been set.
    if (mSyncTarget == SYNC_TARGET_UNKNOWN) {
        throw new IllegalArgumentException("Must specify an adapter with" + " setSyncAdapter(Account, String");
    }
    return new SyncRequest(this);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothPbapClient.connect:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Initiate connection.
 * Upon successful connection to remote PBAP server the Client will
 * attempt to automatically download the users phonebook and call log.
 *
 * @param device a remote device we want connect to
 * @return <code>true</code> if command has been issued successfully; <code>false</code>
 * otherwise;
 *
 * @hide
 */

Body of Frist Method:
{
    if (DBG) {
        log("connect(" + device + ") for PBAP Client.");
    }
    final IBluetoothPbapClient service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.connect(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null) {
        Log.w(TAG, "Proxy not attached to service");
    }
    return false;
}
Body of Second Method:
{
    if (DBG) {
        log("connect(" + device + ") for PBAP Client.");
    }
    final IBluetoothPbapClient service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.connect(device, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null) {
        Log.w(TAG, "Proxy not attached to service");
    }
    return false;
}
------------------------
Find a silently evolved API code:android.app.NotificationChannel.writeXmlForBackup:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    writeXml(out, true, context);
}
Body of Second Method:
{
    writeXml(XmlUtils.makeTyped(out), true, context);
}
------------------------
Find a silently evolved API code:android.content.pm.PackageManager.getPackageArchiveInfo:COMMENT
Method Modifier: public      
Comment:/**
 * Retrieve overall information about an application package defined in a
 * package archive file
 *
 * @param archiveFilePath The path to the archive file
 * @param flags Additional option flags to modify the data returned.
 * @return A PackageInfo object containing information about the package
 * archive. If the package could not be parsed, returns null.
 */

Body of Frist Method:
{
    if ((flags & (PackageManager.MATCH_DIRECT_BOOT_UNAWARE | PackageManager.MATCH_DIRECT_BOOT_AWARE)) == 0) {
        // Caller expressed no opinion about what encryption
        // aware/unaware components they want to see, so match both
        flags |= PackageManager.MATCH_DIRECT_BOOT_AWARE | PackageManager.MATCH_DIRECT_BOOT_UNAWARE;
    }
    boolean collectCertificates = (flags & PackageManager.GET_SIGNATURES) != 0 || (flags & PackageManager.GET_SIGNING_CERTIFICATES) != 0;
    ParseInput input = ParseTypeImpl.forParsingWithoutPlatformCompat().reset();
    ParseResult<ParsingPackage> result = ParsingPackageUtils.parseDefault(input, new File(archiveFilePath), 0, collectCertificates);
    if (result.isError()) {
        return null;
    }
    return PackageInfoWithoutStateUtils.generate(result.getResult(), null, flags, 0, 0, null, new PackageUserState(), UserHandle.getCallingUserId());
}
Body of Second Method:
{
    throw new UnsupportedOperationException("getPackageArchiveInfo() not implemented in subclass");
}
------------------------
Find a silently evolved API code:android.content.IntentSender.getCreatorUid:COMMENT
Method Modifier: public      
Comment:/**
 * Return the uid of the application that created this
 * PendingIntent, that is the identity under which you will actually be
 * sending the Intent.  The returned integer is supplied by the system, so
 * that an application can not spoof its uid.
 *
 * @return The uid of the PendingIntent, or -1 if there is
 * none associated with it.
 */

Body of Frist Method:
{
    try {
        return ActivityManager.getService().getUidForIntentSender(mTarget);
    } catch (RemoteException e) {
        // Should never happen.
        return -1;
    }
}
Body of Second Method:
{
    return getCachedInfo().getCreatorUid();
}
------------------------
Find a silently evolved API code:android.content.pm.PermissionInfo.protectionToString:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    String protLevel = "????";
    switch(level & PROTECTION_MASK_BASE) {
        case PermissionInfo.PROTECTION_DANGEROUS:
            protLevel = "dangerous";
            break;
        case PermissionInfo.PROTECTION_NORMAL:
            protLevel = "normal";
            break;
        case PermissionInfo.PROTECTION_SIGNATURE:
            protLevel = "signature";
            break;
        case PermissionInfo.PROTECTION_SIGNATURE_OR_SYSTEM:
            protLevel = "signatureOrSystem";
            break;
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_PRIVILEGED) != 0) {
        protLevel += "|privileged";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_DEVELOPMENT) != 0) {
        protLevel += "|development";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_APPOP) != 0) {
        protLevel += "|appop";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_PRE23) != 0) {
        protLevel += "|pre23";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_INSTALLER) != 0) {
        protLevel += "|installer";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_VERIFIER) != 0) {
        protLevel += "|verifier";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_PREINSTALLED) != 0) {
        protLevel += "|preinstalled";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_SETUP) != 0) {
        protLevel += "|setup";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_INSTANT) != 0) {
        protLevel += "|instant";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_RUNTIME_ONLY) != 0) {
        protLevel += "|runtime";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_OEM) != 0) {
        protLevel += "|oem";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_VENDOR_PRIVILEGED) != 0) {
        protLevel += "|vendorPrivileged";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_SYSTEM_TEXT_CLASSIFIER) != 0) {
        protLevel += "|textClassifier";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_WELLBEING) != 0) {
        protLevel += "|wellbeing";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_DOCUMENTER) != 0) {
        protLevel += "|documenter";
    }
    if ((level & PROTECTION_FLAG_CONFIGURATOR) != 0) {
        protLevel += "|configurator";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_INCIDENT_REPORT_APPROVER) != 0) {
        protLevel += "|incidentReportApprover";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_APP_PREDICTOR) != 0) {
        protLevel += "|appPredictor";
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_RETAIL_DEMO) != 0) {
        protLevel += "|retailDemo";
    }
    return protLevel;
}
Body of Second Method:
{
    final StringBuilder protLevel = new StringBuilder();
    switch(level & PROTECTION_MASK_BASE) {
        case PermissionInfo.PROTECTION_DANGEROUS:
            protLevel.append("dangerous");
            break;
        case PermissionInfo.PROTECTION_NORMAL:
            protLevel.append("normal");
            break;
        case PermissionInfo.PROTECTION_SIGNATURE:
            protLevel.append("signature");
            break;
        case PermissionInfo.PROTECTION_SIGNATURE_OR_SYSTEM:
            protLevel.append("signatureOrSystem");
            break;
        case PermissionInfo.PROTECTION_INTERNAL:
            protLevel.append("internal");
            break;
        default:
            protLevel.append("????");
            break;
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_PRIVILEGED) != 0) {
        protLevel.append("|privileged");
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_DEVELOPMENT) != 0) {
        protLevel.append("|development");
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_APPOP) != 0) {
        protLevel.append("|appop");
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_PRE23) != 0) {
        protLevel.append("|pre23");
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_INSTALLER) != 0) {
        protLevel.append("|installer");
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_VERIFIER) != 0) {
        protLevel.append("|verifier");
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_PREINSTALLED) != 0) {
        protLevel.append("|preinstalled");
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_SETUP) != 0) {
        protLevel.append("|setup");
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_INSTANT) != 0) {
        protLevel.append("|instant");
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_RUNTIME_ONLY) != 0) {
        protLevel.append("|runtime");
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_OEM) != 0) {
        protLevel.append("|oem");
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_VENDOR_PRIVILEGED) != 0) {
        protLevel.append("|vendorPrivileged");
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_SYSTEM_TEXT_CLASSIFIER) != 0) {
        protLevel.append("|textClassifier");
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_DOCUMENTER) != 0) {
        protLevel.append("|documenter");
    }
    if ((level & PROTECTION_FLAG_CONFIGURATOR) != 0) {
        protLevel.append("|configurator");
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_INCIDENT_REPORT_APPROVER) != 0) {
        protLevel.append("|incidentReportApprover");
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_APP_PREDICTOR) != 0) {
        protLevel.append("|appPredictor");
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_COMPANION) != 0) {
        protLevel.append("|companion");
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_RETAIL_DEMO) != 0) {
        protLevel.append("|retailDemo");
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_RECENTS) != 0) {
        protLevel.append("|recents");
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_ROLE) != 0) {
        protLevel.append("|role");
    }
    if ((level & PermissionInfo.PROTECTION_FLAG_KNOWN_SIGNER) != 0) {
        protLevel.append("|knownSigner");
    }
    return protLevel.toString();
}
------------------------
Find a silently evolved API code:android.location.GnssAntennaInfo.SphericalCorrections.getDeltaTheta:COMMENT
Method Modifier: public      
Comment:/**
 * The fixed theta angle separation between successive rows.
 */

Body of Frist Method:
{
    return mDeltaTheta;
}
Body of Second Method:
{
    return 360.0D / mNumRows;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.dial:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Places a call with specified number.
 *
 * @param device remote device
 * @param number valid phone number
 * @return <code>{@link BluetoothHeadsetClientCall} call</code> if command has been issued
 * successfully; <code>{@link null}</code> otherwise; upon completion HFP sends {@link
 * #ACTION_CALL_CHANGED} intent in case of success; {@link #ACTION_RESULT} is sent otherwise;
 */

Body of Frist Method:
{
    if (DBG)
        log("dial()");
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.dial(device, number);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return null;
}
Body of Second Method:
{
    if (DBG)
        log("dial()");
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return Attributable.setAttributionSource(service.dial(device, number, mAttributionSource), mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return null;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothDevice.getSimAccessPermission:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Gets whether sim access is allowed for this bluetooth device
 *
 * @return Whether the Sim access is allowed to this device.
 * @hide
 */

Body of Frist Method:
{
    final IBluetooth service = sService;
    if (service == null) {
        return ACCESS_UNKNOWN;
    }
    try {
        return service.getSimAccessPermission(this);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return ACCESS_UNKNOWN;
}
Body of Second Method:
{
    final IBluetooth service = sService;
    if (service == null) {
        return ACCESS_UNKNOWN;
    }
    try {
        return service.getSimAccessPermission(this, mAttributionSource);
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return ACCESS_UNKNOWN;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHidHost.disconnect:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Initiate disconnection from a profile
 *
 * <p> This API will return false in scenarios like the profile on the
 * Bluetooth device is not in connected state etc. When this API returns,
 * true, it is guaranteed that the connection state change
 * intent will be broadcasted with the state. Users can get the
 * disconnection state of the profile from this intent.
 *
 * <p> If the disconnection is initiated by a remote device, the state
 * will transition from {@link #STATE_CONNECTED} to
 * {@link #STATE_DISCONNECTED}. If the disconnect is initiated by the
 * host (local) device the state will transition from
 * {@link #STATE_CONNECTED} to state {@link #STATE_DISCONNECTING} to
 * state {@link #STATE_DISCONNECTED}. The transition to
 * {@link #STATE_DISCONNECTING} can be used to distinguish between the
 * two scenarios.
 *
 * @param device Remote Bluetooth Device
 * @return false on immediate error, true otherwise
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("disconnect(" + device + ")");
    final IBluetoothHidHost service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.disconnect(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("disconnect(" + device + ")");
    final IBluetoothHidHost service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.disconnect(device, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.content.pm.parsing.component.ParsedActivity.makeAppDetailsActivity:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Generate activity object that forwards user to App Details page automatically.
 * This activity should be invisible to user and user should not know or see it.
 */

Body of Frist Method:
{
    ParsedActivity activity = new ParsedActivity();
    activity.setPackageName(packageName);
    activity.theme = android.R.style.Theme_NoDisplay;
    activity.exported = true;
    activity.setName(PackageManager.APP_DETAILS_ACTIVITY_CLASS_NAME);
    activity.setProcessName(processName);
    activity.uiOptions = uiOptions;
    activity.taskAffinity = taskAffinity;
    activity.launchMode = ActivityInfo.LAUNCH_MULTIPLE;
    activity.documentLaunchMode = ActivityInfo.DOCUMENT_LAUNCH_NONE;
    activity.maxRecents = ActivityTaskManager.getDefaultAppRecentsLimitStatic();
    activity.configChanges = PackageParser.getActivityConfigChanges(0, 0);
    activity.softInputMode = 0;
    activity.persistableMode = ActivityInfo.PERSIST_NEVER;
    activity.screenOrientation = SCREEN_ORIENTATION_UNSPECIFIED;
    activity.resizeMode = RESIZE_MODE_FORCE_RESIZEABLE;
    activity.lockTaskLaunchMode = 0;
    activity.setDirectBootAware(false);
    activity.rotationAnimation = ROTATION_ANIMATION_UNSPECIFIED;
    activity.colorMode = ActivityInfo.COLOR_MODE_DEFAULT;
    if (hardwareAccelerated) {
        activity.setFlags(activity.getFlags() | ActivityInfo.FLAG_HARDWARE_ACCELERATED);
    }
    return activity;
}
Body of Second Method:
{
    ParsedActivity activity = new ParsedActivity();
    activity.setPackageName(packageName);
    activity.theme = android.R.style.Theme_NoDisplay;
    activity.exported = true;
    activity.setName(PackageManager.APP_DETAILS_ACTIVITY_CLASS_NAME);
    activity.setProcessName(processName);
    activity.uiOptions = uiOptions;
    activity.taskAffinity = taskAffinity;
    activity.launchMode = ActivityInfo.LAUNCH_MULTIPLE;
    activity.documentLaunchMode = ActivityInfo.DOCUMENT_LAUNCH_NONE;
    activity.maxRecents = ActivityTaskManager.getDefaultAppRecentsLimitStatic();
    activity.configChanges = ParsedActivityUtils.getActivityConfigChanges(0, 0);
    activity.softInputMode = 0;
    activity.persistableMode = ActivityInfo.PERSIST_NEVER;
    activity.screenOrientation = SCREEN_ORIENTATION_UNSPECIFIED;
    activity.resizeMode = RESIZE_MODE_FORCE_RESIZEABLE;
    activity.lockTaskLaunchMode = 0;
    activity.setDirectBootAware(false);
    activity.rotationAnimation = ROTATION_ANIMATION_UNSPECIFIED;
    activity.colorMode = ActivityInfo.COLOR_MODE_DEFAULT;
    if (hardwareAccelerated) {
        activity.setFlags(activity.getFlags() | ActivityInfo.FLAG_HARDWARE_ACCELERATED);
    }
    return activity;
}
------------------------
Find a silently evolved API code:android.telephony.PreciseDataConnectionState.getDataConnectionApnTypeBitMask:COMMENT
Method Modifier: public      hidden      deprecated  
Comment:/**
 * Returns the APN types mapped to this data connection.
 *
 * @deprecated use {@link #getApnSetting()}
 * @hide
 */

Body of Frist Method:
{
    return mApnTypes;
}
Body of Second Method:
{
    return (mApnSetting != null) ? mApnSetting.getApnTypeBitmask() : ApnSetting.TYPE_NONE;
}
------------------------
Find a silently evolved API code:android.location.LocationProvider.supportsAltitude:COMMENT
<android.location.LocationProvider: boolean supportsAltitude()>
public      ->public      deprecated  
Method Modifier: public      deprecated  
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Returns true if the provider is able to provide altitude
 * information, false otherwise.  A provider that reports altitude
 * under most circumstances but may occassionally not report it
 * should return true.
 */

Body of Frist Method:
{
    return mProperties.mSupportsAltitude;
}
Body of Second Method:
{
    if (mProperties == null) {
        return false;
    } else {
        return mProperties.hasAltitudeSupport();
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.le.ScanFilter.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Build {@link ScanFilter}.
 *
 * @throws IllegalArgumentException If the filter cannot be built.
 */

Body of Frist Method:
{
    return new ScanFilter(mDeviceName, mDeviceAddress, mServiceUuid, mUuidMask, mServiceSolicitationUuid, mServiceSolicitationUuidMask, mServiceDataUuid, mServiceData, mServiceDataMask, mManufacturerId, mManufacturerData, mManufacturerDataMask);
}
Body of Second Method:
{
    return new ScanFilter(mDeviceName, mDeviceAddress, mServiceUuid, mUuidMask, mServiceSolicitationUuid, mServiceSolicitationUuidMask, mServiceDataUuid, mServiceData, mServiceDataMask, mManufacturerId, mManufacturerData, mManufacturerDataMask, mAddressType, mIrk);
}
------------------------
Find a silently evolved API code:android.media.audiopolicy.AudioMixingRule.Builder.allowPrivilegedPlaybackCapture:COMMENT
Method Modifier: public      
Comment:/**
 * Set if the audio of app that opted out of audio playback capture should be captured.
 *
 * Caller of this method with <code>true</code>, MUST abide to the restriction listed in
 * {@link ALLOW_CAPTURE_BY_SYSTEM}, including but not limited to the captured audio
 * can not leave the capturing app, and the quality is limited to 16k mono.
 *
 * The permission {@link CAPTURE_AUDIO_OUTPUT} or {@link CAPTURE_MEDIA_OUTPUT} is needed
 * to ignore the opt-out.
 *
 * Only affects LOOPBACK|RENDER mix.
 *
 * @return the same Builder instance.
 */

Body of Frist Method:
{
    mAllowPrivilegedPlaybackCapture = allow;
    return this;
}
Body of Second Method:
{
    mAllowPrivilegedMediaPlaybackCapture = allow;
    return this;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothPbap.getConnectedDevices:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * {@inheritDoc}
 *
 * @hide
 */

Body of Frist Method:
{
    log("getConnectedDevices()");
    final IBluetoothPbap service = mService;
    if (service == null) {
        Log.w(TAG, "Proxy not attached to service");
        return new ArrayList<BluetoothDevice>();
    }
    try {
        return service.getConnectedDevices();
    } catch (RemoteException e) {
        Log.e(TAG, e.toString());
    }
    return new ArrayList<BluetoothDevice>();
}
Body of Second Method:
{
    log("getConnectedDevices()");
    final IBluetoothPbap service = mService;
    if (service == null) {
        Log.w(TAG, "Proxy not attached to service");
        return new ArrayList<BluetoothDevice>();
    }
    try {
        return Attributable.setAttributionSource(service.getConnectedDevices(mAttributionSource), mAttributionSource);
    } catch (RemoteException e) {
        Log.e(TAG, e.toString());
    }
    return new ArrayList<BluetoothDevice>();
}
------------------------
Find a silently evolved API code:android.telephony.PreciseDataConnectionState.getDataConnectionApn:COMMENT
Method Modifier: public      hidden      deprecated  
Comment:/**
 * Returns APN of this data connection.
 *
 * @deprecated use {@link #getApnSetting()}
 * @hide
 */

Body of Frist Method:
{
    return mApn;
}
Body of Second Method:
{
    return (mApnSetting != null) ? mApnSetting.getApnName() : "";
}
------------------------
Find a silently evolved API code:android.graphics.Canvas.setMatrix:COMMENT
Method Modifier: public      
Comment:/**
 * Completely replace the current matrix with the specified matrix. If the
 * matrix parameter is null, then the current matrix is reset to identity.
 *
 * <strong>Note:</strong> it is recommended to use {@link #concat(Matrix)},
 * {@link #scale(float, float)}, {@link #translate(float, float)} and
 * {@link #rotate(float)} instead of this method.
 *
 * @param matrix The matrix to replace the current matrix with. If it is
 * null, set the current matrix to identity.
 *
 * @see #concat(Matrix)
 */

Body of Frist Method:
{
    nSetMatrix(mNativeCanvasWrapper, matrix == null ? 0 : matrix.native_instance);
}
Body of Second Method:
{
    nSetMatrix(mNativeCanvasWrapper, matrix == null ? 0 : matrix.ni());
}
------------------------
Find a silently evolved API code:android.os.Process.waitForProcessDeath:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Wait for the death of the given process.
 *
 * @param pid The process ID to be waited on
 * @param timeout The maximum time to wait in milliseconds, or -1 to wait forever
 * @hide
 */

Body of Frist Method:
{
    FileDescriptor pidfd = null;
    if (sPidFdSupported == PIDFD_UNKNOWN) {
        int fd = -1;
        try {
            fd = nativePidFdOpen(pid, 0);
            sPidFdSupported = PIDFD_SUPPORTED;
        } catch (ErrnoException e) {
            sPidFdSupported = e.errno != OsConstants.ENOSYS ? PIDFD_SUPPORTED : PIDFD_UNSUPPORTED;
        } finally {
            if (fd >= 0) {
                pidfd = new FileDescriptor();
                pidfd.setInt$(fd);
            }
        }
    }
    boolean fallback = sPidFdSupported == PIDFD_UNSUPPORTED;
    if (!fallback) {
        try {
            if (pidfd == null) {
                int fd = nativePidFdOpen(pid, 0);
                if (fd >= 0) {
                    pidfd = new FileDescriptor();
                    pidfd.setInt$(fd);
                } else {
                    fallback = true;
                }
            }
            if (pidfd != null) {
                StructPollfd[] fds = new StructPollfd[] { new StructPollfd() };
                fds[0].fd = pidfd;
                fds[0].events = (short) OsConstants.POLLIN;
                fds[0].revents = 0;
                fds[0].userData = null;
                int res = Os.poll(fds, timeout);
                if (res > 0) {
                    return;
                } else if (res == 0) {
                    throw new TimeoutException();
                } else {
                // We should get an ErrnoException now
                }
            }
        } catch (ErrnoException e) {
            if (e.errno == OsConstants.EINTR) {
                throw new InterruptedException();
            }
            fallback = true;
        } finally {
            if (pidfd != null) {
                IoUtils.closeQuietly(pidfd);
            }
        }
    }
    if (fallback) {
        boolean infinity = timeout < 0;
        long now = System.currentTimeMillis();
        final long end = now + timeout;
        while (infinity || now < end) {
            try {
                Os.kill(pid, 0);
            } catch (ErrnoException e) {
                if (e.errno == OsConstants.ESRCH) {
                    return;
                }
            }
            Thread.sleep(1);
            now = System.currentTimeMillis();
        }
    }
    throw new TimeoutException();
}
Body of Second Method:
{
    boolean fallback = supportsPidFd();
    if (!fallback) {
        FileDescriptor pidfd = null;
        try {
            final int fd = nativePidFdOpen(pid, 0);
            if (fd >= 0) {
                pidfd = new FileDescriptor();
                pidfd.setInt$(fd);
            } else {
                fallback = true;
            }
            if (pidfd != null) {
                StructPollfd[] fds = new StructPollfd[] { new StructPollfd() };
                fds[0].fd = pidfd;
                fds[0].events = (short) OsConstants.POLLIN;
                fds[0].revents = 0;
                fds[0].userData = null;
                int res = Os.poll(fds, timeout);
                if (res > 0) {
                    return;
                } else if (res == 0) {
                    throw new TimeoutException();
                } else {
                // We should get an ErrnoException now
                }
            }
        } catch (ErrnoException e) {
            if (e.errno == OsConstants.EINTR) {
                throw new InterruptedException();
            }
            fallback = true;
        } finally {
            if (pidfd != null) {
                IoUtils.closeQuietly(pidfd);
            }
        }
    }
    if (fallback) {
        boolean infinity = timeout < 0;
        long now = System.currentTimeMillis();
        final long end = now + timeout;
        while (infinity || now < end) {
            try {
                Os.kill(pid, 0);
            } catch (ErrnoException e) {
                if (e.errno == OsConstants.ESRCH) {
                    return;
                }
            }
            Thread.sleep(1);
            now = System.currentTimeMillis();
        }
    }
    throw new TimeoutException();
}
------------------------
Find a silently evolved API code:android.location.GnssCapabilities.hasMeasurementCorrectionsExcessPathLength:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns {@code true} if GNSS chipset supports per satellite excess-path-length measurement
 * corrections, {@code false} otherwise.
 *
 * @hide
 */

Body of Frist Method:
{
    return hasCapability(MEASUREMENT_CORRECTIONS_EXCESS_PATH_LENGTH);
}
Body of Second Method:
{
    return (mMeasurementCorrectionsFlags & SUB_HAL_MEASUREMENT_CORRECTIONS_CAPABILITY_EXCESS_PATH_LENGTH) != 0;
}
------------------------
Find a silently evolved API code:android.media.tv.tuner.filter.AvSettings.Builder.build:COMMENT
Method Modifier: public      
Comment:/**
 * Builds a {@link AvSettings} object.
 */

Body of Frist Method:
{
    return new AvSettings(mMainType, mIsAudio, mIsPassthrough);
}
Body of Second Method:
{
    return new AvSettings(mMainType, mIsAudio, mIsPassthrough, mAudioStreamType, mVideoStreamType);
}
------------------------
Find a silently evolved API code:android.text.method.NumberKeyListener.addAmPmChars:COMMENT
Method Modifier: default     static      
Comment:/* package */

Body of Frist Method:
{
    if (locale == null) {
        return false;
    }
    final String[] amPm = LocaleData.get(locale).amPm;
    for (int i = 0; i < amPm.length; i++) {
        for (int j = 0; j < amPm[i].length(); j++) {
            final char ch = amPm[i].charAt(j);
            if (Character.isBmpCodePoint(ch)) {
                collection.add(Character.valueOf(ch));
            } else {
                // We don't support non-BMP characters.
                return false;
            }
        }
    }
    return true;
}
Body of Second Method:
{
    if (locale == null) {
        return false;
    }
    final String[] amPm = DateFormat.getIcuDateFormatSymbols(locale).getAmPmStrings();
    for (int i = 0; i < amPm.length; i++) {
        for (int j = 0; j < amPm[i].length(); j++) {
            final char ch = amPm[i].charAt(j);
            if (Character.isBmpCodePoint(ch)) {
                collection.add(Character.valueOf(ch));
            } else {
                // We don't support non-BMP characters.
                return false;
            }
        }
    }
    return true;
}
------------------------
Find a silently evolved API code:android.widget.EditorTouchState.update:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Updates the state based on the new event.
 */

Body of Frist Method:
{
    final int action = event.getActionMasked();
    if (action == MotionEvent.ACTION_DOWN) {
        final boolean isMouse = event.isFromSource(InputDevice.SOURCE_MOUSE);
        // We check both the time between the last up and current down event, as well as the
        // time between the first down and up events. The latter check is necessary to handle
        // the case when the user taps, drags/holds for some time, and then lifts up and
        // quickly taps in the same area. This scenario should not be treated as a double-tap.
        // This follows the behavior in GestureDetector.
        final long millisSinceLastUp = event.getEventTime() - mLastUpMillis;
        final long millisBetweenLastDownAndLastUp = mLastUpMillis - mLastDownMillis;
        // Detect double tap and triple click.
        if (millisSinceLastUp <= ViewConfiguration.getDoubleTapTimeout() && millisBetweenLastDownAndLastUp <= ViewConfiguration.getDoubleTapTimeout() && (mMultiTapStatus == MultiTapStatus.FIRST_TAP || (mMultiTapStatus == MultiTapStatus.DOUBLE_TAP && isMouse))) {
            if (mMultiTapStatus == MultiTapStatus.FIRST_TAP) {
                mMultiTapStatus = MultiTapStatus.DOUBLE_TAP;
            } else {
                mMultiTapStatus = MultiTapStatus.TRIPLE_CLICK;
            }
            mMultiTapInSameArea = isDistanceWithin(mLastDownX, mLastDownY, event.getX(), event.getY(), config.getScaledDoubleTapSlop());
            if (TextView.DEBUG_CURSOR) {
                String status = isDoubleTap() ? "double" : "triple";
                String inSameArea = mMultiTapInSameArea ? "in same area" : "not in same area";
                logCursor("EditorTouchState", "ACTION_DOWN: %s tap detected, %s", status, inSameArea);
            }
        } else {
            mMultiTapStatus = MultiTapStatus.FIRST_TAP;
            mMultiTapInSameArea = false;
            if (TextView.DEBUG_CURSOR) {
                logCursor("EditorTouchState", "ACTION_DOWN: first tap detected");
            }
        }
        mLastDownX = event.getX();
        mLastDownY = event.getY();
        mLastDownMillis = event.getEventTime();
        mMovedEnoughForDrag = false;
        mIsDragCloseToVertical = false;
    } else if (action == MotionEvent.ACTION_UP) {
        if (TextView.DEBUG_CURSOR) {
            logCursor("EditorTouchState", "ACTION_UP");
        }
        mLastUpX = event.getX();
        mLastUpY = event.getY();
        mLastUpMillis = event.getEventTime();
        mMovedEnoughForDrag = false;
        mIsDragCloseToVertical = false;
    } else if (action == MotionEvent.ACTION_MOVE) {
        if (!mMovedEnoughForDrag) {
            float deltaX = event.getX() - mLastDownX;
            float deltaY = event.getY() - mLastDownY;
            float deltaXSquared = deltaX * deltaX;
            float distanceSquared = (deltaXSquared) + (deltaY * deltaY);
            int touchSlop = config.getScaledTouchSlop();
            mMovedEnoughForDrag = distanceSquared > touchSlop * touchSlop;
            if (mMovedEnoughForDrag) {
                // If the direction of the swipe motion is within 45 degrees of vertical, it is
                // considered a vertical drag.
                mIsDragCloseToVertical = Math.abs(deltaX) <= Math.abs(deltaY);
            }
        }
    } else if (action == MotionEvent.ACTION_CANCEL) {
        mLastDownMillis = 0;
        mLastUpMillis = 0;
        mMultiTapStatus = MultiTapStatus.NONE;
        mMultiTapInSameArea = false;
        mMovedEnoughForDrag = false;
        mIsDragCloseToVertical = false;
    }
}
Body of Second Method:
{
    final int action = event.getActionMasked();
    if (action == MotionEvent.ACTION_DOWN) {
        final boolean isMouse = event.isFromSource(InputDevice.SOURCE_MOUSE);
        // We check both the time between the last up and current down event, as well as the
        // time between the first down and up events. The latter check is necessary to handle
        // the case when the user taps, drags/holds for some time, and then lifts up and
        // quickly taps in the same area. This scenario should not be treated as a double-tap.
        // This follows the behavior in GestureDetector.
        final long millisSinceLastUp = event.getEventTime() - mLastUpMillis;
        final long millisBetweenLastDownAndLastUp = mLastUpMillis - mLastDownMillis;
        // Detect double tap and triple click.
        if (millisSinceLastUp <= ViewConfiguration.getDoubleTapTimeout() && millisBetweenLastDownAndLastUp <= ViewConfiguration.getDoubleTapTimeout() && (mMultiTapStatus == MultiTapStatus.FIRST_TAP || (mMultiTapStatus == MultiTapStatus.DOUBLE_TAP && isMouse))) {
            if (mMultiTapStatus == MultiTapStatus.FIRST_TAP) {
                mMultiTapStatus = MultiTapStatus.DOUBLE_TAP;
            } else {
                mMultiTapStatus = MultiTapStatus.TRIPLE_CLICK;
            }
            mMultiTapInSameArea = isDistanceWithin(mLastDownX, mLastDownY, event.getX(), event.getY(), config.getScaledDoubleTapSlop());
            if (TextView.DEBUG_CURSOR) {
                String status = isDoubleTap() ? "double" : "triple";
                String inSameArea = mMultiTapInSameArea ? "in same area" : "not in same area";
                logCursor("EditorTouchState", "ACTION_DOWN: %s tap detected, %s", status, inSameArea);
            }
        } else {
            mMultiTapStatus = MultiTapStatus.FIRST_TAP;
            mMultiTapInSameArea = false;
            if (TextView.DEBUG_CURSOR) {
                logCursor("EditorTouchState", "ACTION_DOWN: first tap detected");
            }
        }
        mLastDownX = event.getX();
        mLastDownY = event.getY();
        mLastDownMillis = event.getEventTime();
        mMovedEnoughForDrag = false;
        mInitialDragDirectionXYRatio = 0.0f;
    } else if (action == MotionEvent.ACTION_UP) {
        if (TextView.DEBUG_CURSOR) {
            logCursor("EditorTouchState", "ACTION_UP");
        }
        mLastUpX = event.getX();
        mLastUpY = event.getY();
        mLastUpMillis = event.getEventTime();
        mMovedEnoughForDrag = false;
        mInitialDragDirectionXYRatio = 0.0f;
    } else if (action == MotionEvent.ACTION_MOVE) {
        if (!mMovedEnoughForDrag) {
            float deltaX = event.getX() - mLastDownX;
            float deltaY = event.getY() - mLastDownY;
            float deltaXSquared = deltaX * deltaX;
            float distanceSquared = (deltaXSquared) + (deltaY * deltaY);
            int touchSlop = config.getScaledTouchSlop();
            mMovedEnoughForDrag = distanceSquared > touchSlop * touchSlop;
            if (mMovedEnoughForDrag) {
                mInitialDragDirectionXYRatio = (deltaY == 0) ? Float.MAX_VALUE : Math.abs(deltaX / deltaY);
            }
        }
    } else if (action == MotionEvent.ACTION_CANCEL) {
        mLastDownMillis = 0;
        mLastUpMillis = 0;
        mMultiTapStatus = MultiTapStatus.NONE;
        mMultiTapInSameArea = false;
        mMovedEnoughForDrag = false;
        mInitialDragDirectionXYRatio = 0.0f;
    }
}
------------------------
Find a silently evolved API code:android.nfc.NfcAdapter.isEnabled:COMMENT
Method Modifier: public      
Comment:/**
 * Return true if this NFC Adapter has any features enabled.
 *
 * <p>If this method returns false, the NFC hardware is guaranteed not to
 * generate or respond to any NFC communication over its NFC radio.
 * <p>Applications can use this to check if NFC is enabled. Applications
 * can request Settings UI allowing the user to toggle NFC using:
 * <p><pre>startActivity(new Intent(Settings.ACTION_NFC_SETTINGS))</pre>
 *
 * @see android.provider.Settings#ACTION_NFC_SETTINGS
 * @return true if this NFC Adapter has any features enabled
 */

Body of Frist Method:
{
    try {
        return sService.getState() == STATE_ON;
    } catch (RemoteException e) {
        attemptDeadServiceRecovery(e);
        return false;
    }
}
Body of Second Method:
{
    try {
        return sService.getState() == STATE_ON;
    } catch (RemoteException e) {
        attemptDeadServiceRecovery(e);
        // Try one more time
        if (sService == null) {
            Log.e(TAG, "Failed to recover NFC Service.");
            return false;
        }
        try {
            return sService.getState() == STATE_ON;
        } catch (RemoteException ee) {
            Log.e(TAG, "Failed to recover NFC Service.");
        }
        return false;
    }
}
------------------------
Find a silently evolved API code:android.app.WindowConfiguration.toString:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return "{ mBounds=" + mBounds + " mAppBounds=" + mAppBounds + " mWindowingMode=" + windowingModeToString(mWindowingMode) + " mDisplayWindowingMode=" + windowingModeToString(mDisplayWindowingMode) + " mActivityType=" + activityTypeToString(mActivityType) + " mAlwaysOnTop=" + alwaysOnTopToString(mAlwaysOnTop) + " mRotation=" + (mRotation == ROTATION_UNDEFINED ? "undefined" : rotationToString(mRotation)) + "}";
}
Body of Second Method:
{
    return "{ mBounds=" + mBounds + " mAppBounds=" + mAppBounds + " mMaxBounds=" + mMaxBounds + " mWindowingMode=" + windowingModeToString(mWindowingMode) + " mDisplayWindowingMode=" + windowingModeToString(mDisplayWindowingMode) + " mActivityType=" + activityTypeToString(mActivityType) + " mAlwaysOnTop=" + alwaysOnTopToString(mAlwaysOnTop) + " mRotation=" + (mRotation == ROTATION_UNDEFINED ? "undefined" : rotationToString(mRotation)) + "}";
}
------------------------
Find a silently evolved API code:android.content.pm.UserInfo.toFullString:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    return "UserInfo[id=" + id + ", name=" + name + ", type=" + userType + ", flags=" + flagsToString(flags) + (preCreated ? " (pre-created)" : "") + (partial ? " (partial)" : "") + "]";
}
Body of Second Method:
{
    return "UserInfo[id=" + id + ", name=" + name + ", type=" + userType + ", flags=" + flagsToString(flags) + (preCreated ? " (pre-created)" : "") + (convertedFromPreCreated ? " (converted)" : "") + (partial ? " (partial)" : "") + "]";
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothDevice.setMetadata:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Set a keyed metadata of this {@link BluetoothDevice} to a
 * {@link String} value.
 * Only bonded devices's metadata will be persisted across Bluetooth
 * restart.
 * Metadata will be removed when the device's bond state is moved to
 * {@link #BOND_NONE}.
 *
 * @param key must be within the list of BluetoothDevice.METADATA_*
 * @param value a byte array data to set for key. Must be less than
 * {@link BluetoothAdapter#METADATA_MAX_LENGTH} characters in length
 * @return true on success, false on error
 * @hide
 */

Body of Frist Method:
{
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, "Bluetooth is not enabled. Cannot set metadata");
        return false;
    }
    if (value.length > METADATA_MAX_LENGTH) {
        throw new IllegalArgumentException("value length is " + value.length + ", should not over " + METADATA_MAX_LENGTH);
    }
    try {
        return service.setMetadata(this, key, value);
    } catch (RemoteException e) {
        Log.e(TAG, "setMetadata fail", e);
        return false;
    }
}
Body of Second Method:
{
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, "Bluetooth is not enabled. Cannot set metadata");
        return false;
    }
    if (value.length > METADATA_MAX_LENGTH) {
        throw new IllegalArgumentException("value length is " + value.length + ", should not over " + METADATA_MAX_LENGTH);
    }
    try {
        return service.setMetadata(this, key, value, mAttributionSource);
    } catch (RemoteException e) {
        Log.e(TAG, "setMetadata fail", e);
        return false;
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.getCurrentCalls:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns list of all calls in any state.
 *
 * @param device remote device
 * @return list of calls; empty list if none call exists
 */

Body of Frist Method:
{
    if (DBG)
        log("getCurrentCalls()");
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.getCurrentCalls(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return null;
}
Body of Second Method:
{
    if (DBG)
        log("getCurrentCalls()");
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return Attributable.setAttributionSource(service.getCurrentCalls(device, mAttributionSource), mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return null;
}
------------------------
Find a silently evolved API code:android.telephony.CarrierConfigManager.getDefaultCarrierServicePackageName:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Gets the package name for a default carrier service.
 * @return the package name for a default carrier service; empty string if not available.
 *
 * @hide
 */

Body of Frist Method:
{
    try {
        ICarrierConfigLoader loader = getICarrierConfigLoader();
        if (loader == null) {
            Rlog.w(TAG, "getDefaultCarrierServicePackageName ICarrierConfigLoader is null");
            return "";
        }
        return loader.getDefaultCarrierServicePackageName();
    } catch (RemoteException ex) {
        Rlog.e(TAG, "getDefaultCarrierServicePackageName ICarrierConfigLoader is null" + ex.toString());
    }
    return "";
}
Body of Second Method:
{
    try {
        ICarrierConfigLoader loader = getICarrierConfigLoader();
        if (loader == null) {
            Rlog.w(TAG, "getDefaultCarrierServicePackageName ICarrierConfigLoader is null");
            return "";
        }
        return loader.getDefaultCarrierServicePackageName();
    } catch (RemoteException ex) {
        Rlog.e(TAG, "getDefaultCarrierServicePackageName ICarrierConfigLoader is null" + ex.toString());
        ex.rethrowAsRuntimeException();
    }
    return "";
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothPbap.getDevicesMatchingConnectionStates:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * {@inheritDoc}
 *
 * @hide
 */

Body of Frist Method:
{
    log("getDevicesMatchingConnectionStates: states=" + Arrays.toString(states));
    final IBluetoothPbap service = mService;
    if (service == null) {
        Log.w(TAG, "Proxy not attached to service");
        return new ArrayList<BluetoothDevice>();
    }
    try {
        return service.getDevicesMatchingConnectionStates(states);
    } catch (RemoteException e) {
        Log.e(TAG, e.toString());
    }
    return new ArrayList<BluetoothDevice>();
}
Body of Second Method:
{
    log("getDevicesMatchingConnectionStates: states=" + Arrays.toString(states));
    final IBluetoothPbap service = mService;
    if (service == null) {
        Log.w(TAG, "Proxy not attached to service");
        return new ArrayList<BluetoothDevice>();
    }
    try {
        return Attributable.setAttributionSource(service.getDevicesMatchingConnectionStates(states, mAttributionSource), mAttributionSource);
    } catch (RemoteException e) {
        Log.e(TAG, e.toString());
    }
    return new ArrayList<BluetoothDevice>();
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothGattServer.unregisterCallback:COMMENT
Method Modifier: private     
Comment:/**
 * Unregister the current application and callbacks.
 */

Body of Frist Method:
{
    if (DBG)
        Log.d(TAG, "unregisterCallback() - mServerIf=" + mServerIf);
    if (mService == null || mServerIf == 0)
        return;
    try {
        mCallback = null;
        mService.unregisterServer(mServerIf);
        mServerIf = 0;
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
}
Body of Second Method:
{
    if (DBG)
        Log.d(TAG, "unregisterCallback() - mServerIf=" + mServerIf);
    if (mService == null || mServerIf == 0)
        return;
    try {
        mCallback = null;
        mService.unregisterServer(mServerIf, mAttributionSource);
        mServerIf = 0;
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
}
------------------------
Find a silently evolved API code:android.content.ContentProviderClient.refresh:COMMENT
Method Modifier: public      
Comment:/**
 * See {@link ContentProvider#refresh}
 */

Body of Frist Method:
{
    Objects.requireNonNull(url, "url");
    beforeRemote();
    try {
        ICancellationSignal remoteCancellationSignal = null;
        if (cancellationSignal != null) {
            cancellationSignal.throwIfCanceled();
            remoteCancellationSignal = mContentProvider.createCancellationSignal();
            cancellationSignal.setRemote(remoteCancellationSignal);
        }
        return mContentProvider.refresh(mPackageName, mAttributionTag, url, extras, remoteCancellationSignal);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}
Body of Second Method:
{
    Objects.requireNonNull(url, "url");
    beforeRemote();
    try {
        ICancellationSignal remoteCancellationSignal = null;
        if (cancellationSignal != null) {
            cancellationSignal.throwIfCanceled();
            remoteCancellationSignal = mContentProvider.createCancellationSignal();
            cancellationSignal.setRemote(remoteCancellationSignal);
        }
        return mContentProvider.refresh(mAttributionSource, url, extras, remoteCancellationSignal);
    } catch (DeadObjectException e) {
        if (!mStable) {
            mContentResolver.unstableProviderDied(mContentProvider);
        }
        throw e;
    } finally {
        afterRemote();
    }
}
------------------------
Find a silently evolved API code:android.app.servertransaction.TransactionExecutor.performLifecycleSequence:COMMENT
Method Modifier: private     hidden      
Comment:/**
 * Transition the client through previously initialized state sequence.
 */

Body of Frist Method:
{
    final int size = path.size();
    for (int i = 0, state; i < size; i++) {
        state = path.get(i);
        if (DEBUG_RESOLVER) {
            Slog.d(TAG, tId(transaction) + "Transitioning activity: " + getShortActivityName(r.token, mTransactionHandler) + " to state: " + getStateName(state));
        }
        switch(state) {
            case ON_CREATE:
                mTransactionHandler.handleLaunchActivity(r, mPendingActions, null);
                break;
            case ON_START:
                mTransactionHandler.handleStartActivity(r.token, mPendingActions);
                break;
            case ON_RESUME:
                mTransactionHandler.handleResumeActivity(r.token, false, /* finalStateRequest */
                r.isForward, "LIFECYCLER_RESUME_ACTIVITY");
                break;
            case ON_PAUSE:
                mTransactionHandler.handlePauseActivity(r.token, false, /* finished */
                false, /* userLeaving */
                0, /* configChanges */
                mPendingActions, "LIFECYCLER_PAUSE_ACTIVITY");
                break;
            case ON_STOP:
                mTransactionHandler.handleStopActivity(r.token, 0, /* configChanges */
                mPendingActions, false, /* finalStateRequest */
                "LIFECYCLER_STOP_ACTIVITY");
                break;
            case ON_DESTROY:
                mTransactionHandler.handleDestroyActivity(r.token, false, /* finishing */
                0, /* configChanges */
                false, /* getNonConfigInstance */
                "performLifecycleSequence. cycling to:" + path.get(size - 1));
                break;
            case ON_RESTART:
                mTransactionHandler.performRestartActivity(r.token, false);
                break;
            default:
                throw new IllegalArgumentException("Unexpected lifecycle state: " + state);
        }
    }
}
Body of Second Method:
{
    final int size = path.size();
    for (int i = 0, state; i < size; i++) {
        state = path.get(i);
        if (DEBUG_RESOLVER) {
            Slog.d(TAG, tId(transaction) + "Transitioning activity: " + getShortActivityName(r.token, mTransactionHandler) + " to state: " + getStateName(state));
        }
        switch(state) {
            case ON_CREATE:
                mTransactionHandler.handleLaunchActivity(r, mPendingActions, null);
                break;
            case ON_START:
                mTransactionHandler.handleStartActivity(r, mPendingActions, null);
                break;
            case ON_RESUME:
                mTransactionHandler.handleResumeActivity(r, false, /* finalStateRequest */
                r.isForward, "LIFECYCLER_RESUME_ACTIVITY");
                break;
            case ON_PAUSE:
                mTransactionHandler.handlePauseActivity(r, false, /* finished */
                false, /* userLeaving */
                0, /* configChanges */
                mPendingActions, "LIFECYCLER_PAUSE_ACTIVITY");
                break;
            case ON_STOP:
                mTransactionHandler.handleStopActivity(r, 0, /* configChanges */
                mPendingActions, false, /* finalStateRequest */
                "LIFECYCLER_STOP_ACTIVITY");
                break;
            case ON_DESTROY:
                mTransactionHandler.handleDestroyActivity(r, false, /* finishing */
                0, /* configChanges */
                false, /* getNonConfigInstance */
                "performLifecycleSequence. cycling to:" + path.get(size - 1));
                break;
            case ON_RESTART:
                mTransactionHandler.performRestartActivity(r, false);
                break;
            default:
                throw new IllegalArgumentException("Unexpected lifecycle state: " + state);
        }
    }
}
------------------------
Find a silently evolved API code:android.app.servertransaction.StartActivityItem.writeToParcel:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Write to Parcel.
 */

Body of Frist Method:
{
// Empty
}
Body of Second Method:
{
    dest.writeBundle(mActivityOptions != null ? mActivityOptions.toBundle() : null);
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.holdCall:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Holds a call.
 *
 * @param device remote device
 * @return <code>true</code> if command has been issued successfully; <code>false</code>
 * otherwise; upon completion HFP sends {@link #ACTION_CALL_CHANGED} intent.
 */

Body of Frist Method:
{
    if (DBG)
        log("holdCall()");
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.holdCall(device);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("holdCall()");
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.holdCall(device, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothA2dpSink.connect:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Initiate connection to a profile of the remote bluetooth device.
 *
 * <p> Currently, the system supports only 1 connection to the
 * A2DP profile. The API will automatically disconnect connected
 * devices before connecting.
 *
 * <p> This API returns false in scenarios like the profile on the
 * device is already connected or Bluetooth is not turned on.
 * When this API returns true, it is guaranteed that
 * connection state intent for the profile will be broadcasted with
 * the state. Users can get the connection state of the profile
 * from this intent.
 *
 * @param device Remote Bluetooth Device
 * @return false on immediate error, true otherwise
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("connect(" + device + ")");
    final IBluetoothA2dpSink service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.connect(device);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        log("connect(" + device + ")");
    final IBluetoothA2dpSink service = getService();
    if (service != null && isEnabled() && isValidDevice(device)) {
        try {
            return service.connect(device, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.media.RemoteController.startListeningToSessions:COMMENT
Method Modifier: default     hidden      deprecated  
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    final ComponentName listenerComponent = new ComponentName(mContext, mOnClientUpdateListener.getClass());
    Handler handler = null;
    if (Looper.myLooper() == null) {
        handler = new Handler(Looper.getMainLooper());
    }
    mSessionManager.addOnActiveSessionsChangedListener(mSessionListener, listenerComponent, UserHandle.myUserId(), handler);
    mSessionListener.onActiveSessionsChanged(mSessionManager.getActiveSessions(listenerComponent));
    if (DEBUG) {
        Log.d(TAG, "Registered session listener with component " + listenerComponent + " for user " + UserHandle.myUserId());
    }
}
Body of Second Method:
{
    final ComponentName listenerComponent = new ComponentName(mContext, mOnClientUpdateListener.getClass());
    Handler handler = null;
    if (Looper.myLooper() == null) {
        handler = new Handler(Looper.getMainLooper());
    }
    mSessionManager.addOnActiveSessionsChangedListener(mSessionListener, listenerComponent, handler);
    mSessionListener.onActiveSessionsChanged(mSessionManager.getActiveSessions(listenerComponent));
    if (DEBUG) {
        Log.d(TAG, "Registered session listener with component " + listenerComponent + " for user " + UserHandle.myUserId());
    }
}
------------------------
Find a silently evolved API code:android.ddm.DdmHandleHello.handleChunk:COMMENT
Method Modifier: public      
Comment:/**
 * Handle a chunk of data.
 */

Body of Frist Method:
{
    if (false)
        Log.v("ddm-heap", "Handling " + name(request.type) + " chunk");
    int type = request.type;
    if (type == CHUNK_HELO) {
        return handleHELO(request);
    } else if (type == CHUNK_FEAT) {
        return handleFEAT(request);
    } else {
        throw new RuntimeException("Unknown packet " + ChunkHandler.name(type));
    }
}
Body of Second Method:
{
    if (false)
        Log.v("ddm-heap", "Handling " + name(request.type) + " chunk");
    int type = request.type;
    if (type == CHUNK_HELO) {
        return handleHELO(request);
    } else if (type == CHUNK_FEAT) {
        return handleFEAT(request);
    } else {
        throw new RuntimeException("Unknown packet " + name(type));
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothAvrcpController.setPlayerApplicationSetting:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Sets the player app setting for current player.
 * returns true in case setting is supported by remote, false otherwise
 */

Body of Frist Method:
{
    if (DBG)
        Log.d(TAG, "setPlayerApplicationSetting");
    final IBluetoothAvrcpController service = getService();
    if (service != null && isEnabled()) {
        try {
            return service.setPlayerApplicationSetting(plAppSetting);
        } catch (RemoteException e) {
            Log.e(TAG, "Error talking to BT service in setPlayerApplicationSetting() " + e);
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
Body of Second Method:
{
    if (DBG)
        Log.d(TAG, "setPlayerApplicationSetting");
    final IBluetoothAvrcpController service = getService();
    if (service != null && isEnabled()) {
        try {
            return service.setPlayerApplicationSetting(plAppSetting, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, "Error talking to BT service in setPlayerApplicationSetting() " + e);
            return false;
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return false;
}
------------------------
Find a silently evolved API code:android.content.SyncResult.toDebugString:COMMENT
Method Modifier: public      
Comment:/**
 * Generates a debugging string indicating the status.
 * The string consist of a sequence of code letter followed by the count.
 * Code letters are f - fullSyncRequested, r - partialSyncUnavailable,
 * X - hardError, e - numParseExceptions, c - numConflictDetectedExceptions,
 * a - numAuthExceptions, D - tooManyDeletions, R - tooManyRetries,
 * b - databaseError, x - softError, l - syncAlreadyInProgress,
 * I - numIoExceptions
 * @return debugging string.
 */

Body of Frist Method:
{
    StringBuffer sb = new StringBuffer();
    if (fullSyncRequested) {
        sb.append("f1");
    }
    if (partialSyncUnavailable) {
        sb.append("r1");
    }
    if (hasHardError()) {
        sb.append("X1");
    }
    if (stats.numParseExceptions > 0) {
        sb.append("e").append(stats.numParseExceptions);
    }
    if (stats.numConflictDetectedExceptions > 0) {
        sb.append("c").append(stats.numConflictDetectedExceptions);
    }
    if (stats.numAuthExceptions > 0) {
        sb.append("a").append(stats.numAuthExceptions);
    }
    if (tooManyDeletions) {
        sb.append("D1");
    }
    if (tooManyRetries) {
        sb.append("R1");
    }
    if (databaseError) {
        sb.append("b1");
    }
    if (hasSoftError()) {
        sb.append("x1");
    }
    if (syncAlreadyInProgress) {
        sb.append("l1");
    }
    if (stats.numIoExceptions > 0) {
        sb.append("I").append(stats.numIoExceptions);
    }
    return sb.toString();
}
Body of Second Method:
{
    StringBuilder sb = new StringBuilder();
    if (fullSyncRequested) {
        sb.append("f1");
    }
    if (partialSyncUnavailable) {
        sb.append("r1");
    }
    if (hasHardError()) {
        sb.append("X1");
    }
    if (stats.numParseExceptions > 0) {
        sb.append("e").append(stats.numParseExceptions);
    }
    if (stats.numConflictDetectedExceptions > 0) {
        sb.append("c").append(stats.numConflictDetectedExceptions);
    }
    if (stats.numAuthExceptions > 0) {
        sb.append("a").append(stats.numAuthExceptions);
    }
    if (tooManyDeletions) {
        sb.append("D1");
    }
    if (tooManyRetries) {
        sb.append("R1");
    }
    if (databaseError) {
        sb.append("b1");
    }
    if (hasSoftError()) {
        sb.append("x1");
    }
    if (syncAlreadyInProgress) {
        sb.append("l1");
    }
    if (stats.numIoExceptions > 0) {
        sb.append("I").append(stats.numIoExceptions);
    }
    return sb.toString();
}
------------------------
Find a silently evolved API code:android.media.PlayerBase.baseUpdateAudioAttributes:COMMENT
Method Modifier: default     hidden      
Comment:/**
 * To be called whenever the audio attributes of the player change
 * @param attr non-null audio attributes
 */

Body of Frist Method:
{
    if (attr == null) {
        throw new IllegalArgumentException("Illegal null AudioAttributes");
    }
    try {
        getService().playerAttributes(mPlayerIId, attr);
    } catch (RemoteException e) {
        Log.e(TAG, "Error talking to audio service, STARTED state will not be tracked", e);
    }
    synchronized (mLock) {
        boolean attributesChanged = (mAttributes != attr);
        mAttributes = attr;
        updateAppOpsPlayAudio_sync(attributesChanged);
    }
}
Body of Second Method:
{
    if (attr == null) {
        throw new IllegalArgumentException("Illegal null AudioAttributes");
    }
    try {
        getService().playerAttributes(mPlayerIId, attr);
    } catch (RemoteException e) {
        Log.e(TAG, "Error talking to audio service, audio attributes will not be updated", e);
    }
    synchronized (mLock) {
        mAttributes = attr;
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothDevice.getName:COMMENT
Method Modifier: public      
Comment:/**
 * Get the friendly Bluetooth name of the remote device.
 *
 * <p>The local adapter will automatically retrieve remote names when
 * performing a device scan, and will cache them. This method just returns
 * the name for this device from the cache.
 *
 * @return the Bluetooth name, or null if there was a problem.
 */

Body of Frist Method:
{
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, "BT not enabled. Cannot get Remote Device name");
        return null;
    }
    try {
        String name = service.getRemoteName(this);
        if (name != null) {
            return name.replaceAll("[\\t\\n\\r]+", " ");
        }
        return null;
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return null;
}
Body of Second Method:
{
    final IBluetooth service = sService;
    if (service == null) {
        Log.e(TAG, "BT not enabled. Cannot get Remote Device name");
        return null;
    }
    try {
        String name = service.getRemoteName(this, mAttributionSource);
        if (name != null) {
            // remove whitespace characters from the name
            return name.replace('\t', ' ').replace('\n', ' ').replace('\r', ' ');
        }
        return null;
    } catch (RemoteException e) {
        Log.e(TAG, "", e);
    }
    return null;
}
------------------------
Find a silently evolved API code:android.content.pm.ShortcutManager.getShortcuts:COMMENT
Method Modifier: public      
Comment:/**
 * Returns {@link ShortcutInfo}s that match {@code matchFlags}.
 *
 * @param matchFlags result includes shortcuts matching this flags. Any combination of:
 * <ul>
 * <li>{@link #FLAG_MATCH_MANIFEST}
 * <li>{@link #FLAG_MATCH_DYNAMIC}
 * <li>{@link #FLAG_MATCH_PINNED}
 * <li>{@link #FLAG_MATCH_CACHED}
 * </ul>
 *
 * @return list of {@link ShortcutInfo}s that match the flag.
 *
 * <p>At least one of the {@code MATCH} flags should be set. Otherwise no shortcuts will be
 * returned.
 *
 * @throws IllegalStateException when the user is locked.
 */

Body of Frist Method:
{
    try {
        return mService.getShortcuts(mContext.getPackageName(), matchFlags, injectMyUserId()).getList();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    try {
        return getFutureOrThrow(mService.getShortcuts(mContext.getPackageName(), matchFlags, injectMyUserId())).getList();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.os.VibrationAttributes.Builder.setUsage:COMMENT
Method Modifier: public      
Comment:/**
 * Sets the attribute describing the type of corresponding vibration.
 * @param usage one of {@link VibrationAttributes#USAGE_ALARM},
 * {@link VibrationAttributes#USAGE_RINGTONE},
 * {@link VibrationAttributes#USAGE_NOTIFICATION},
 * {@link VibrationAttributes#USAGE_COMMUNICATION_REQUEST},
 * {@link VibrationAttributes#USAGE_TOUCH},
 * {@link VibrationAttributes#USAGE_PHYSICAL_EMULATION},
 * {@link VibrationAttributes#USAGE_HARDWARE_FEEDBACK}.
 * @return the same Builder instance.
 */

Body of Frist Method:
{
    mUsage = usage;
    return this;
}
Body of Second Method:
{
    mOriginalAudioUsage = AudioAttributes.USAGE_UNKNOWN;
    mUsage = usage;
    return this;
}
------------------------
Find a silently evolved API code:android.app.admin.DeviceAdminReceiver.onEnabled:COMMENT
Method Modifier: public      
Comment:/**
 * Called after the administrator is first enabled, as a result of
 * receiving {@link #ACTION_DEVICE_ADMIN_ENABLED}.  At this point you
 * can use {@link DevicePolicyManager} to set your desired policies.
 *
 * <p> If the admin is activated by a device owner, then the intent
 * may contain private extras that are relevant to user setup.
 * {@see DevicePolicyManager#createAndManageUser(ComponentName, String, ComponentName,
 * PersistableBundle, int)}
 *
 * @param context The running context as per {@link #onReceive}.
 * @param intent The received intent as per {@link #onReceive}.
 */

Body of Frist Method:
{
}
Body of Second Method:
{
    if (LOCAL_LOGV) {
        Log.v(TAG, getClass().getName() + ".onEnabled() on user " + context.getUserId());
    }
}
------------------------
Find a silently evolved API code:android.os.HandlerThread.getLooper:COMMENT
Method Modifier: public      
Comment:/**
 * This method returns the Looper associated with this thread. If this thread not been started
 * or for any reason isAlive() returns false, this method will return null. If this thread
 * has been started, this method will block until the looper has been initialized.
 * @return The looper.
 */

Body of Frist Method:
{
    if (!isAlive()) {
        return null;
    }
    // If the thread has been started, wait until the looper has been created.
    synchronized (this) {
        while (isAlive() && mLooper == null) {
            try {
                wait();
            } catch (InterruptedException e) {
            }
        }
    }
    return mLooper;
}
Body of Second Method:
{
    if (!isAlive()) {
        return null;
    }
    boolean wasInterrupted = false;
    // If the thread has been started, wait until the looper has been created.
    synchronized (this) {
        while (isAlive() && mLooper == null) {
            try {
                wait();
            } catch (InterruptedException e) {
                wasInterrupted = true;
            }
        }
    }
    /*
         * We may need to restore the thread's interrupted flag, because it may
         * have been cleared above since we eat InterruptedExceptions
         */
    if (wasInterrupted) {
        Thread.currentThread().interrupt();
    }
    return mLooper;
}
------------------------
Find a silently evolved API code:android.app.ApplicationExitInfo.subreasonToString:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * @hide
 */

Body of Frist Method:
{
    switch(subreason) {
        case SUBREASON_WAIT_FOR_DEBUGGER:
            return "WAIT FOR DEBUGGER";
        case SUBREASON_TOO_MANY_CACHED:
            return "TOO MANY CACHED PROCS";
        case SUBREASON_TOO_MANY_EMPTY:
            return "TOO MANY EMPTY PROCS";
        case SUBREASON_TRIM_EMPTY:
            return "TRIM EMPTY";
        case SUBREASON_LARGE_CACHED:
            return "LARGE CACHED";
        case SUBREASON_MEMORY_PRESSURE:
            return "MEMORY PRESSURE";
        case SUBREASON_EXCESSIVE_CPU:
            return "EXCESSIVE CPU USAGE";
        case SUBREASON_SYSTEM_UPDATE_DONE:
            return "SYSTEM UPDATE_DONE";
        case SUBREASON_KILL_ALL_FG:
            return "KILL ALL FG";
        case SUBREASON_KILL_ALL_BG_EXCEPT:
            return "KILL ALL BG EXCEPT";
        case SUBREASON_KILL_UID:
            return "KILL UID";
        case SUBREASON_KILL_PID:
            return "KILL PID";
        case SUBREASON_INVALID_START:
            return "INVALID START";
        case SUBREASON_INVALID_STATE:
            return "INVALID STATE";
        case SUBREASON_IMPERCEPTIBLE:
            return "IMPERCEPTIBLE";
        case SUBREASON_REMOVE_LRU:
            return "REMOVE LRU";
        case SUBREASON_ISOLATED_NOT_NEEDED:
            return "ISOLATED NOT NEEDED";
        default:
            return "UNKNOWN";
    }
}
Body of Second Method:
{
    switch(subreason) {
        case SUBREASON_WAIT_FOR_DEBUGGER:
            return "WAIT FOR DEBUGGER";
        case SUBREASON_TOO_MANY_CACHED:
            return "TOO MANY CACHED PROCS";
        case SUBREASON_TOO_MANY_EMPTY:
            return "TOO MANY EMPTY PROCS";
        case SUBREASON_TRIM_EMPTY:
            return "TRIM EMPTY";
        case SUBREASON_LARGE_CACHED:
            return "LARGE CACHED";
        case SUBREASON_MEMORY_PRESSURE:
            return "MEMORY PRESSURE";
        case SUBREASON_EXCESSIVE_CPU:
            return "EXCESSIVE CPU USAGE";
        case SUBREASON_SYSTEM_UPDATE_DONE:
            return "SYSTEM UPDATE_DONE";
        case SUBREASON_KILL_ALL_FG:
            return "KILL ALL FG";
        case SUBREASON_KILL_ALL_BG_EXCEPT:
            return "KILL ALL BG EXCEPT";
        case SUBREASON_KILL_UID:
            return "KILL UID";
        case SUBREASON_KILL_PID:
            return "KILL PID";
        case SUBREASON_INVALID_START:
            return "INVALID START";
        case SUBREASON_INVALID_STATE:
            return "INVALID STATE";
        case SUBREASON_IMPERCEPTIBLE:
            return "IMPERCEPTIBLE";
        case SUBREASON_REMOVE_LRU:
            return "REMOVE LRU";
        case SUBREASON_ISOLATED_NOT_NEEDED:
            return "ISOLATED NOT NEEDED";
        case SUBREASON_FREEZER_BINDER_IOCTL:
            return "FREEZER BINDER IOCTL";
        case SUBREASON_FREEZER_BINDER_TRANSACTION:
            return "FREEZER BINDER TRANSACTION";
        default:
            return "UNKNOWN";
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.getDevicesMatchingConnectionStates:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns list of remote devices in a particular state
 *
 * @param states collection of states
 * @return list of devices that state matches the states listed in <code>states</code>; empty
 * list if nothing matches the <code>states</code>
 */

Body of Frist Method:
{
    if (VDBG)
        log("getDevicesMatchingStates()");
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled()) {
        try {
            return service.getDevicesMatchingConnectionStates(states);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
Body of Second Method:
{
    if (VDBG)
        log("getDevicesMatchingStates()");
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled()) {
        try {
            return Attributable.setAttributionSource(service.getDevicesMatchingConnectionStates(states, mAttributionSource), mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
------------------------
Find a silently evolved API code:android.view.WindowInsets.consumeSystemWindowInsets:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * Returns a copy of this WindowInsets with the system window insets fully consumed.
 *
 * @return A modified copy of this WindowInsets
 * @deprecated Consuming of different parts individually of a {@link WindowInsets} instance is
 * deprecated, since {@link WindowInsets} contains many different insets. Use {@link #CONSUMED}
 * instead to stop dispatching insets.
 */

Body of Frist Method:
{
    return new WindowInsets(null, null, mTypeVisibilityMap, mIsRound, mAlwaysConsumeSystemBars, displayCutoutCopyConstructorArgument(this), mCompatInsetsTypes, mCompatIgnoreVisibility);
}
Body of Second Method:
{
    return new WindowInsets(null, null, mTypeVisibilityMap, mIsRound, mAlwaysConsumeSystemBars, displayCutoutCopyConstructorArgument(this), mRoundedCorners, mPrivacyIndicatorBounds, mCompatInsetsTypes, mCompatIgnoreVisibility);
}
------------------------
Find a silently evolved API code:android.content.pm.ShortcutManager.createShortcutResultIntent:COMMENT
Method Modifier: public      
Comment:/**
 * Returns an Intent which can be used by the default launcher to pin a shortcut containing the
 * given {@link ShortcutInfo}. This method should be used by an Activity to set a result in
 * response to {@link Intent#ACTION_CREATE_SHORTCUT}.
 *
 * @param shortcut New shortcut to pin.  If an app wants to pin an existing (either dynamic
 * or manifest) shortcut, then it only needs to have an ID, and other fields don't have to
 * be set, in which case, the target shortcut must be enabled.
 * If it's a new shortcut, all the mandatory fields, such as a short label, must be
 * set.
 * @return The intent that should be set as the result for the calling activity, or
 * <code>null</code> if the current launcher doesn't support shortcuts.
 *
 * @see Intent#ACTION_CREATE_SHORTCUT
 *
 * @throws IllegalArgumentException if a shortcut with the same ID exists and is disabled.
 */

Body of Frist Method:
{
    try {
        return mService.createShortcutResultIntent(mContext.getPackageName(), shortcut, injectMyUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    try {
        return getFutureOrThrow(mService.createShortcutResultIntent(mContext.getPackageName(), shortcut, injectMyUserId()));
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothSap.getConnectedDevices:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the list of connected devices. Currently at most one.
 *
 * @return list of connected devices
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("getConnectedDevices()");
    final IBluetoothSap service = getService();
    if (service != null && isEnabled()) {
        try {
            return service.getConnectedDevices();
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
Body of Second Method:
{
    if (DBG)
        log("getConnectedDevices()");
    final IBluetoothSap service = getService();
    if (service != null && isEnabled()) {
        try {
            return Attributable.setAttributionSource(service.getConnectedDevices(mAttributionSource), mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.getAudioRouteAllowed:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Returns whether audio routing is allowed.
 *
 * @param device remote device
 * @return whether the command succeeded Note: This is an internal function and shouldn't be
 * exposed
 */

Body of Frist Method:
{
    if (VDBG)
        log("getAudioRouteAllowed");
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled()) {
        try {
            return service.getAudioRouteAllowed(device);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return false;
}
Body of Second Method:
{
    if (VDBG)
        log("getAudioRouteAllowed");
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled()) {
        try {
            return service.getAudioRouteAllowed(device, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return false;
}
------------------------
Find a silently evolved API code:android.timezone.TimeZoneFinder.getInstance:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Obtains the singleton instance.
 */

Body of Frist Method:
{
    synchronized (sLock) {
        if (sInstance == null) {
            sInstance = new TimeZoneFinder(libcore.timezone.TimeZoneFinder.getInstance());
        }
    }
    return sInstance;
}
Body of Second Method:
{
    synchronized (sLock) {
        if (sInstance == null) {
            sInstance = new TimeZoneFinder(com.android.i18n.timezone.TimeZoneFinder.getInstance());
        }
    }
    return sInstance;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothA2dp.setActiveDevice:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Select a connected device as active.
 *
 * The active device selection is per profile. An active device's
 * purpose is profile-specific. For example, A2DP audio streaming
 * is to the active A2DP Sink device. If a remote device is not
 * connected, it cannot be selected as active.
 *
 * <p> This API returns false in scenarios like the profile on the
 * device is not connected or Bluetooth is not turned on.
 * When this API returns true, it is guaranteed that the
 * {@link #ACTION_ACTIVE_DEVICE_CHANGED} intent will be broadcasted
 * with the active device.
 *
 * @param device the remote Bluetooth device. Could be null to clear
 * the active device and stop streaming audio to a Bluetooth device.
 * @return false on immediate error, true otherwise
 * @hide
 */

Body of Frist Method:
{
    if (DBG)
        log("setActiveDevice(" + device + ")");
    try {
        final IBluetoothA2dp service = getService();
        if (service != null && isEnabled() && ((device == null) || isValidDevice(device))) {
            return service.setActiveDevice(device);
        }
        if (service == null)
            Log.w(TAG, "Proxy not attached to service");
        return false;
    } catch (RemoteException e) {
        Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
        return false;
    }
}
Body of Second Method:
{
    if (DBG)
        log("setActiveDevice(" + device + ")");
    try {
        final IBluetoothA2dp service = getService();
        if (service != null && isEnabled() && ((device == null) || isValidDevice(device))) {
            return service.setActiveDevice(device, mAttributionSource);
        }
        if (service == null)
            Log.w(TAG, "Proxy not attached to service");
        return false;
    } catch (RemoteException e) {
        Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
        return false;
    }
}
------------------------
Find a silently evolved API code:android.location.LocationProvider.supportsSpeed:COMMENT
<android.location.LocationProvider: boolean supportsSpeed()>
public      ->public      deprecated  
Method Modifier: public      deprecated  
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Returns true if the provider is able to provide speed
 * information, false otherwise.  A provider that reports speed
 * under most circumstances but may occassionally not report it
 * should return true.
 */

Body of Frist Method:
{
    return mProperties.mSupportsSpeed;
}
Body of Second Method:
{
    if (mProperties == null) {
        return false;
    } else {
        return mProperties.hasSpeedSupport();
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothHeadsetClient.connectAudio:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Initiates a connection of audio channel.
 *
 * It setup SCO channel with remote connected Handsfree AG device.
 *
 * @param device remote device
 * @return <code>true</code> if command has been issued successfully; <code>false</code>
 * otherwise; upon completion HFP sends {@link #ACTION_AUDIO_STATE_CHANGED} intent;
 */

Body of Frist Method:
{
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled()) {
        try {
            return service.connectAudio(device);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return false;
}
Body of Second Method:
{
    final IBluetoothHeadsetClient service = getService();
    if (service != null && isEnabled()) {
        try {
            return service.connectAudio(device, mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
    return false;
}
------------------------
Find a silently evolved API code:android.view.WindowInsets.consumeDisplayCutout:COMMENT
Method Modifier: public      deprecated  
Comment:/**
 * Returns a copy of this WindowInsets with the cutout fully consumed.
 *
 * @return A modified copy of this WindowInsets
 * @deprecated Consuming of different parts individually of a {@link WindowInsets} instance is
 * deprecated, since {@link WindowInsets} contains many different insets. Use {@link #CONSUMED}
 * instead to stop dispatching insets.
 */

Body of Frist Method:
{
    return new WindowInsets(mSystemWindowInsetsConsumed ? null : mTypeInsetsMap, mStableInsetsConsumed ? null : mTypeMaxInsetsMap, mTypeVisibilityMap, mIsRound, mAlwaysConsumeSystemBars, null, /* displayCutout */
    mCompatInsetsTypes, mCompatIgnoreVisibility);
}
Body of Second Method:
{
    return new WindowInsets(mSystemWindowInsetsConsumed ? null : mTypeInsetsMap, mStableInsetsConsumed ? null : mTypeMaxInsetsMap, mTypeVisibilityMap, mIsRound, mAlwaysConsumeSystemBars, null, /* displayCutout */
    mRoundedCorners, mPrivacyIndicatorBounds, mCompatInsetsTypes, mCompatIgnoreVisibility);
}
------------------------
Find a silently evolved API code:android.nfc.NfcAdapter.isSecureNfcEnabled:COMMENT
Method Modifier: public      
Comment:/**
 * Checks Secure NFC feature is enabled.
 *
 * @return True if Secure NFC is enabled, false otherwise
 * @throws UnsupportedOperationException if FEATURE_NFC is unavailable.
 * @throws UnsupportedOperationException if device doesn't support
 * Secure NFC functionality. {@link #isSecureNfcSupported}
 */

Body of Frist Method:
{
    if (!sHasNfcFeature) {
        throw new UnsupportedOperationException();
    }
    try {
        return sService.isNfcSecureEnabled();
    } catch (RemoteException e) {
        attemptDeadServiceRecovery(e);
        return false;
    }
}
Body of Second Method:
{
    if (!sHasNfcFeature) {
        throw new UnsupportedOperationException();
    }
    try {
        return sService.isNfcSecureEnabled();
    } catch (RemoteException e) {
        attemptDeadServiceRecovery(e);
        // Try one more time
        if (sService == null) {
            Log.e(TAG, "Failed to recover NFC Service.");
            return false;
        }
        try {
            return sService.isNfcSecureEnabled();
        } catch (RemoteException ee) {
            Log.e(TAG, "Failed to recover NFC Service.");
        }
        return false;
    }
}
------------------------
Find a silently evolved API code:android.telephony.TelephonyDisplayInfo.overrideNetworkTypeToString:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * Convert override network type to string.
 *
 * @param type Override network type
 * @return Override network type in string format
 * @hide
 */

Body of Frist Method:
{
    switch(type) {
        case OVERRIDE_NETWORK_TYPE_NONE:
            return "NONE";
        case OVERRIDE_NETWORK_TYPE_LTE_CA:
            return "LTE_CA";
        case OVERRIDE_NETWORK_TYPE_LTE_ADVANCED_PRO:
            return "LTE_ADV_PRO";
        case OVERRIDE_NETWORK_TYPE_NR_NSA:
            return "NR_NSA";
        case OVERRIDE_NETWORK_TYPE_NR_NSA_MMWAVE:
            return "NR_NSA_MMWAVE";
        default:
            return "UNKNOWN";
    }
}
Body of Second Method:
{
    switch(type) {
        case OVERRIDE_NETWORK_TYPE_NONE:
            return "NONE";
        case OVERRIDE_NETWORK_TYPE_LTE_CA:
            return "LTE_CA";
        case OVERRIDE_NETWORK_TYPE_LTE_ADVANCED_PRO:
            return "LTE_ADV_PRO";
        case OVERRIDE_NETWORK_TYPE_NR_NSA:
            return "NR_NSA";
        case OVERRIDE_NETWORK_TYPE_NR_NSA_MMWAVE:
            return "NR_NSA_MMWAVE";
        case OVERRIDE_NETWORK_TYPE_NR_ADVANCED:
            return "NR_ADVANCED";
        default:
            return "UNKNOWN";
    }
}
------------------------
Find a silently evolved API code:android.location.Geocoder.isPresent:COMMENT
Method Modifier: public      static      
Comment:/**
 * Returns true if the Geocoder methods getFromLocation and
 * getFromLocationName are implemented.  Lack of network
 * connectivity may still cause these methods to return null or
 * empty lists.
 */

Body of Frist Method:
{
    IBinder b = ServiceManager.getService(Context.LOCATION_SERVICE);
    ILocationManager lm = ILocationManager.Stub.asInterface(b);
    try {
        return lm.geocoderIsPresent();
    } catch (RemoteException e) {
        Log.e(TAG, "isPresent: got RemoteException", e);
        return false;
    }
}
Body of Second Method:
{
    IBinder b = ServiceManager.getService(Context.LOCATION_SERVICE);
    ILocationManager lm = ILocationManager.Stub.asInterface(b);
    try {
        return lm.geocoderIsPresent();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.view.autofill.AutofillValue.getToggleValue:COMMENT
Method Modifier: public      
Comment:/**
 * Gets the value to autofill a toggable field.
 *
 * <p>See {@link View#AUTOFILL_TYPE_TOGGLE} for more info.</p>
 *
 * @throws IllegalStateException if the value is not a toggle value
 */

Body of Frist Method:
{
    Preconditions.checkState(isToggle(), "value must be a toggle value, not type=" + mType);
    return (Boolean) mValue;
}
Body of Second Method:
{
    Preconditions.checkState(isToggle(), "value must be a toggle value, not type=%d", mType);
    return (Boolean) mValue;
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothMap.getState:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Get the current state of the BluetoothMap service.
 *
 * @return One of the STATE_ return codes, or STATE_ERROR if this proxy object is currently not
 * connected to the Map service.
 *
 * @hide
 */

Body of Frist Method:
{
    if (VDBG)
        log("getState()");
    final IBluetoothMap service = getService();
    if (service != null) {
        try {
            return service.getState();
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            log(Log.getStackTraceString(new Throwable()));
    }
    return BluetoothMap.STATE_ERROR;
}
Body of Second Method:
{
    if (VDBG)
        log("getState()");
    final IBluetoothMap service = getService();
    if (service != null) {
        try {
            return service.getState(mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            log(Log.getStackTraceString(new Throwable()));
    }
    return BluetoothMap.STATE_ERROR;
}
------------------------
Find a silently evolved API code:android.nfc.NfcAdapter.enable:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * Enable NFC hardware.
 *
 * <p>This call is asynchronous. Listen for
 * {@link #ACTION_ADAPTER_STATE_CHANGED} broadcasts to find out when the
 * operation is complete.
 *
 * <p>If this returns true, then either NFC is already on, or
 * a {@link #ACTION_ADAPTER_STATE_CHANGED} broadcast will be sent
 * to indicate a state transition. If this returns false, then
 * there is some problem that prevents an attempt to turn
 * NFC on (for example we are in airplane mode and NFC is not
 * toggleable in airplane mode on this platform).
 *
 * @hide
 */

Body of Frist Method:
{
    try {
        return sService.enable();
    } catch (RemoteException e) {
        attemptDeadServiceRecovery(e);
        return false;
    }
}
Body of Second Method:
{
    try {
        return sService.enable();
    } catch (RemoteException e) {
        attemptDeadServiceRecovery(e);
        // Try one more time
        if (sService == null) {
            Log.e(TAG, "Failed to recover NFC Service.");
            return false;
        }
        try {
            return sService.enable();
        } catch (RemoteException ee) {
            Log.e(TAG, "Failed to recover NFC Service.");
        }
        return false;
    }
}
------------------------
Find a silently evolved API code:android.content.pm.ShortcutManager.getDynamicShortcuts:COMMENT
Method Modifier: public      
Comment:/**
 * Return all dynamic shortcuts from the caller app.
 *
 * <p>This API is intended to be used for examining what shortcuts are currently published.
 * Re-publishing returned {@link ShortcutInfo}s via APIs such as
 * {@link #setDynamicShortcuts(List)} may cause loss of information such as icons.
 *
 * @throws IllegalStateException when the user is locked.
 */

Body of Frist Method:
{
    try {
        return mService.getShortcuts(mContext.getPackageName(), FLAG_MATCH_DYNAMIC, injectMyUserId()).getList();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    try {
        return getFutureOrThrow(mService.getShortcuts(mContext.getPackageName(), FLAG_MATCH_DYNAMIC, injectMyUserId())).getList();
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------
Find a silently evolved API code:android.telecom.CallRedirectionService.placeCallUnmodified:COMMENT
Method Modifier: public      final       
Comment:/**
 * The implemented {@link CallRedirectionService} calls this method to response a request
 * received via {@link #onPlaceCall(Uri, PhoneAccountHandle, boolean)} to inform Telecom that
 * no changes are required to the outgoing call, and that the call should be placed as-is.
 *
 * <p>This can only be called from implemented
 * {@link #onPlaceCall(Uri, PhoneAccountHandle, boolean)}. The response corresponds to the
 * latest request via {@link #onPlaceCall(Uri, PhoneAccountHandle, boolean)}.
 */

Body of Frist Method:
{
    try {
        mCallRedirectionAdapter.placeCallUnmodified();
    } catch (RemoteException e) {
        e.rethrowAsRuntimeException();
    }
}
Body of Second Method:
{
    try {
        if (mCallRedirectionAdapter == null) {
            throw new IllegalStateException("Can only be called from onPlaceCall.");
        }
        mCallRedirectionAdapter.placeCallUnmodified();
    } catch (RemoteException e) {
        e.rethrowAsRuntimeException();
    }
}
------------------------
Find a silently evolved API code:android.bluetooth.BluetoothA2dpSink.getConnectedDevices:COMMENT
Method Modifier: public      hidden      
Comment:/**
 * {@inheritDoc}
 *
 * @hide
 */

Body of Frist Method:
{
    if (VDBG)
        log("getConnectedDevices()");
    final IBluetoothA2dpSink service = getService();
    if (service != null && isEnabled()) {
        try {
            return service.getConnectedDevices();
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
Body of Second Method:
{
    if (VDBG)
        log("getConnectedDevices()");
    final IBluetoothA2dpSink service = getService();
    if (service != null && isEnabled()) {
        try {
            return Attributable.setAttributionSource(service.getConnectedDevices(mAttributionSource), mAttributionSource);
        } catch (RemoteException e) {
            Log.e(TAG, "Stack:" + Log.getStackTraceString(new Throwable()));
            return new ArrayList<BluetoothDevice>();
        }
    }
    if (service == null)
        Log.w(TAG, "Proxy not attached to service");
    return new ArrayList<BluetoothDevice>();
}
------------------------
Find a silently evolved API code:android.app.admin.DeviceAdminReceiver.onProfileProvisioningComplete:COMMENT
Method Modifier: public      
Comment:/**
 * Called when provisioning of a managed profile or managed device has completed successfully.
 *
 * <p> As a prerequisite for the execution of this callback the {@link DeviceAdminReceiver} has
 * to declare an intent filter for {@link #ACTION_PROFILE_PROVISIONING_COMPLETE}.
 * Its component must also be specified in the {@link DevicePolicyManager#EXTRA_DEVICE_ADMIN}
 * of the {@link DevicePolicyManager#ACTION_PROVISION_MANAGED_PROFILE} intent that started the
 * managed provisioning.
 *
 * <p>When provisioning of a managed profile is complete, the managed profile is hidden until
 * the profile owner calls {@link DevicePolicyManager#setProfileEnabled(ComponentName admin)}.
 * Typically a profile owner will enable the profile when it has finished any additional setup
 * such as adding an account by using the {@link AccountManager} and calling APIs to bring the
 * profile into the desired state.
 *
 * <p> Note that provisioning completes without waiting for any server interactions, so the
 * profile owner needs to wait for data to be available if required (e.g. Android device IDs or
 * other data that is set as a result of server interactions).
 *
 * <p>From version {@link android.os.Build.VERSION_CODES#O}, when managed provisioning has
 * completed, along with this callback the activity intent
 * {@link DevicePolicyManager#ACTION_PROVISIONING_SUCCESSFUL} will also be sent to the same
 * application.
 *
 * @param context The running context as per {@link #onReceive}.
 * @param intent The received intent as per {@link #onReceive}.
 */

Body of Frist Method:
{
}
Body of Second Method:
{
    if (LOCAL_LOGV) {
        Log.v(TAG, getClass().getName() + ".onProfileProvisioningComplete() on user " + context.getUserId());
    }
}
------------------------
Find a silently evolved API code:android.content.pm.parsing.PackageInfoWithoutStateUtils.generateProviderInfoUnchecked:COMMENT
Method Modifier: public      static      hidden      
Comment:/**
 * This bypasses critical checks that are necessary for usage with data passed outside of
 * system server.
 *
 * Prefer {@link #generateProviderInfo(ParsingPackageRead, ParsedProvider, int,
 * PackageUserState, ApplicationInfo, int)}.
 */

Body of Frist Method:
{
    // Make shallow copies so we can store the metadata safely
    ProviderInfo pi = new ProviderInfo();
    assignSharedFieldsForComponentInfo(pi, p);
    pi.exported = p.isExported();
    pi.flags = p.getFlags();
    pi.processName = p.getProcessName();
    pi.authority = p.getAuthority();
    pi.isSyncable = p.isSyncable();
    pi.readPermission = p.getReadPermission();
    pi.writePermission = p.getWritePermission();
    pi.grantUriPermissions = p.isGrantUriPermissions();
    pi.forceUriPermissions = p.isForceUriPermissions();
    pi.multiprocess = p.isMultiProcess();
    pi.initOrder = p.getInitOrder();
    pi.uriPermissionPatterns = p.getUriPermissionPatterns();
    pi.pathPermissions = p.getPathPermissions();
    pi.metaData = p.getMetaData();
    if ((flags & PackageManager.GET_URI_PERMISSION_PATTERNS) == 0) {
        pi.uriPermissionPatterns = null;
    }
    pi.applicationInfo = applicationInfo;
    return pi;
}
Body of Second Method:
{
    // Make shallow copies so we can store the metadata safely
    ProviderInfo pi = new ProviderInfo();
    assignSharedFieldsForComponentInfo(pi, p);
    pi.exported = p.isExported();
    pi.flags = p.getFlags();
    pi.processName = p.getProcessName();
    pi.authority = p.getAuthority();
    pi.isSyncable = p.isSyncable();
    pi.readPermission = p.getReadPermission();
    pi.writePermission = p.getWritePermission();
    pi.grantUriPermissions = p.isGrantUriPermissions();
    pi.forceUriPermissions = p.isForceUriPermissions();
    pi.multiprocess = p.isMultiProcess();
    pi.initOrder = p.getInitOrder();
    pi.uriPermissionPatterns = p.getUriPermissionPatterns();
    pi.pathPermissions = p.getPathPermissions();
    if ((flags & PackageManager.GET_URI_PERMISSION_PATTERNS) == 0) {
        pi.uriPermissionPatterns = null;
    }
    if ((flags & PackageManager.GET_META_DATA) != 0) {
        pi.metaData = p.getMetaData();
    }
    pi.applicationInfo = applicationInfo;
    return pi;
}
------------------------
Find a silently evolved API code:android.location.LocationProvider.hasMonetaryCost:COMMENT
<android.location.LocationProvider: boolean hasMonetaryCost()>
public      ->public      deprecated  
Method Modifier: public      deprecated  
Method Modifier: Yes         No          
Method Updated:  Yes         Yes         
Comment:/**
 * Returns true if the use of this provider may result in a
 * monetary charge to the user, false if use is free.  It is up to
 * each provider to give accurate information.
 */

Body of Frist Method:
{
    return mProperties.mHasMonetaryCost;
}
Body of Second Method:
{
    if (mProperties == null) {
        return false;
    } else {
        return mProperties.hasMonetaryCost();
    }
}
------------------------
Find a silently evolved API code:android.content.pm.ShortcutManager.disableShortcuts:COMMENT
Method Modifier: public      
Comment:/**
 * Disable pinned shortcuts.  For more details, read
 * <a href="/guide/topics/ui/shortcuts/managing-shortcuts.html#disable-shortcuts">
 * Disable shortcuts</a>.
 *
 * @throws IllegalArgumentException If trying to disable immutable shortcuts.
 *
 * @throws IllegalStateException when the user is locked.
 */

Body of Frist Method:
{
    try {
        mService.disableShortcuts(mContext.getPackageName(), shortcutIds, /* disabledMessage =*/
        null, /* disabledMessageResId =*/
        0, injectMyUserId());
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
Body of Second Method:
{
    try {
        getFutureOrThrow(mService.disableShortcuts(mContext.getPackageName(), shortcutIds, /* disabledMessage =*/
        null, /* disabledMessageResId =*/
        0, injectMyUserId()));
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
}
------------------------

